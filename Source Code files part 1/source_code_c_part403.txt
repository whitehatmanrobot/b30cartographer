osyncrasies of domain (CRED_TYPE_DOMAIN_*)
    credentials.  Domain credentials contain more than one target field.

    At least one of the naming parameters must be specified: NetbiosServerName,
    DnsServerName, NetbiosDomainName, DnsDomainName or DnsTreeName. This API returns
    the most specific credentials that match the naming parameters.  That is, if there
    is a credential that matches the target server name and a credential that matches
    the target domain name, only the server specific credential is returned.  This is
    the credential that would be used.

Arguments:

    LogonId - LogonId of the session to associate the credential with.

    CredFlags - Flags changing the behavior of the routine:
        CREDP_FLAGS_IN_PROCESS - Caller is in-process.  Password data may be returned
        CREDP_FLAGS_DONT_CACHE_TI - TargetInformation shouldn't be cached for CredGetTargetInfo

        Note: The CredFlags parameter is internal to the LSA process.
            The Flags parameter is external to the process.

    TargetInfo - Specifies the target information identifying the target server.

    Flags - Specifies flags to control the operation of the API.
        Reserved.  Must be zero.

    Count - Returns a count of the number of credentials returned in Credentials.

    Credentials - Returns a pointer to an array of pointers to credentials.
        The returned buffer must be freed by calling CrediFreeCredentials
Return Values:

    The following status codes may be returned:

        STATUS_INVALID_PARAMETER - None of the naming parameters were specified.

        STATUS_NOT_FOUND - There are no credentials matching the specified naming parameters.

        STATUS_NO_SUCH_LOGON_SESSION - The logon session does not exist or
            there is no credential set associated with this logon session.
            Network logon sessions do not have an associated credential set.

--*/

{
    NTSTATUS Status;
    CREDENTIAL_SETS CredentialSets = {NULL};
    PENCRYPTED_CREDENTIALW *TempCredentials = NULL;
    PCANONICAL_TARGET_INFO CanonicalTargetInfo = NULL;
    ULONG CredentialCount = 0;
    PCANONICAL_CREDENTIAL BestCredentials[CRED_TYPE_MAXIMUM];
    ULONG CredentialIndex;
    PLIST_ENTRY ListEntry;
    BOOLEAN CritSectLocked = FALSE;

    //
    // Validate the flags
    //

    if ( Flags != 0 ) {
        Status = STATUS_INVALID_PARAMETER_1;
        goto Cleanup;
    }


    //
    // Validate the TargetInfo
    //

    Status = CredpValidateTargetInfo( TargetInfo,
                                      &CanonicalTargetInfo );

    if ( !NT_SUCCESS(Status) ) {
        goto Cleanup;
    }

    //
    // Get the credential set.
    //

    Status = CredpReferenceCredSets( LogonId, &CredentialSets );

    if ( !NT_SUCCESS(Status) ) {
        goto Cleanup;
    }

    //
    // Determine the best credential of each type.
    //

    CredpLockCredSets( &CredentialSets );
    CritSectLocked = TRUE;
    Status = CredpFindBestCredentials( LogonId,
                                       CredFlags,
                                       &CredentialSets,
                                       CanonicalTargetInfo,
                                       BestCredentials,
                                       &CredentialCount );

    if ( !NT_SUCCESS(Status) ) {
        goto Cleanup;
    }

    if ( CredentialCount == 0 ) {
        Status = STATUS_NOT_FOUND;
        goto Cleanup;
    }

    //
    // Allocate a buffer to return the credentials in
    //

    TempCredentials = (PENCRYPTED_CREDENTIALW *) MIDL_user_allocate( CredentialCount * sizeof(PENCRYPTED_CREDENTIALW) );

    if ( TempCredentials == NULL ) {
        Status = STATUS_NO_MEMORY;
        goto Cleanup;
    }

    RtlZeroMemory( TempCredentials, CredentialCount * sizeof(PENCRYPTED_CREDENTIALW) );


    //
    // Grab a copy of each of the credentials to return to the caller.
    //

    for ( CredentialIndex = 0; CredentialIndex<CredentialCount; CredentialIndex++ ) {

        TempCredentials[CredentialIndex] =
            CredpCloneCredential( &CredentialSets,
                                  CredFlags | CREDP_FLAGS_USE_MIDL_HEAP,
                                  BestCredentials[CredentialIndex] );

        if ( TempCredentials[CredentialIndex] == NULL ) {
            Status = STATUS_NO_MEMORY;
            goto Cleanup;
        }

    }


    *Count = CredentialCount;
    *Credentials = TempCredentials;
    TempCredentials = NULL;
    Status = STATUS_SUCCESS;

    //
    // Cleanup
    //
Cleanup:

    if ( CanonicalTargetInfo != NULL ) {

        //
        // Cache this target info
        //
        if ( CritSectLocked &&
             (CredFlags & CREDP_FLAGS_DONT_CACHE_TI) == 0  &&
             (CanonicalTargetInfo->Flags & CRED_TI_USERNAME_TARGET) == 0 ) {

            if ( CredpCacheTargetInfo( &CredentialSets, CanonicalTargetInfo )) {
                CanonicalTargetInfo = NULL;
            }
        }

        //
        // Free the target info if it is still around
        //

        if ( CanonicalTargetInfo != NULL ) {
            LsapFreeLsaHeap( CanonicalTargetInfo );
        }
    }

    if ( CritSectLocked ) {
        CredpUnlockAndFlushCredSets( &CredentialSets );
    }

    if ( TempCredentials != NULL ) {
        CrediFreeCredentials( CredentialCount, TempCredentials );
    }

    CredpDereferenceCredSets( &CredentialSets );

    return Status;

}


extern "C"
NTSTATUS
CrediDelete (
    IN PLUID LogonId,
    IN ULONG CredFlags,
    IN LPWSTR TargetName,
    IN ULONG Type,
    IN ULONG Flags
    )

/*++

Routine Description:

    The CredDelete API deletes a credential from the user's credential set.
    The credential set used is the one associated with the logon session
    of the current token.  The token must not have the user's SID disabled.

Arguments:

    LogonId - LogonId of the session to associate the credential with.

    CredFlags - Flags changing the behavior of the routine:
        Must be zero.

        Note: The CredFlags parameter is internal to the LSA process.
            The Flags parameter is external to the process.

    TargetName - Specifies the name of the credential to delete.

    Type - Specifies the Type of the credential to find.
        One of the CRED_TYPE_* values should be specified.

    Flags - Specifies flags to control the operation of the API.
        Reserved.  Must be zero.

Return Values:

    The following status codes may be returned:

        STATUS_NOT_FOUND - There is no credential with the specified TargetName.

        STATUS_NO_SUCH_LOGON_SESSION - The logon session does not exist or
            there is no credential set associated with this logon session.
            Network logon sessions do not have an associated credential set.

--*/

{
    NTSTATUS Status;
    CREDENTIAL_SETS CredentialSets = {NULL};
    PCANONICAL_CREDENTIAL TempCredential;
    PPROMPT_DATA PromptData;
    UNICODE_STRING TargetNameString;
    DWORD TargetNameSize;
    BOOLEAN CritSectLocked = FALSE;

    //
    // Validate the flags
    //

    if ( Flags != 0 ) {
        Status = STATUS_INVALID_PARAMETER_1;
        goto Cleanup;
    }

    //
    // Validate the input parameters
    //

    Status = CredpValidateTargetName( TargetName,
                                      Type,
                                      MightBeUsernameTarget,
                                      NULL,         // Don't know user name
                                      NULL,         // Don't know persist
                                      &TargetNameSize,
                                      NULL,         // Don't care about name type
                                      NULL );       // Don't care about non-wilcarded form of name

    if ( !NT_SUCCESS(Status ) ) {
        goto Cleanup;
    }



    //
    // Get the credential set.
    //

    Status = CredpReferenceCredSets( LogonId, &CredentialSets );

    if ( !NT_SUCCESS(Status) ) {
        goto Cleanup;
    }


    //
    // Find the credential
    //

    TargetNameString.Buffer = TargetName;
    TargetNameString.MaximumLength = (USHORT) TargetNameSize;
    TargetNameString.Length = TargetNameString.MaximumLength - sizeof(WCHAR);

    CredpLockCredSets( &CredentialSets );
    CritSectLocked = TRUE;

    TempCredential = CredpFindCredential(
                            &CredentialSets,
                            &TargetNameString,
                            Type );

    if ( TempCredential == NULL ) {
        Status = STATUS_NOT_FOUND;
        goto Cleanup;
    }

    //
    // If this credential is a certificate *Session credential,
    //  and we automatically created a corresponding password *Session credential,
    //  delete the password cred on a best effort basis.

    if ( TempCredential->Cred.Type == CRED_TYPE_DOMAIN_CERTIFICATE &&
         (TempCredential->Cred.Flags & CRED_FLAGS_PASSWORD_FOR_CERT) != 0 &&
         TempCredential->WildcardType == WcUniversalSessionWildcard ) {


        (VOID) CrediDelete ( LogonId,
                             CredFlags,
                             TargetName,
                             CRED_TYPE_DOMAIN_PASSWORD,
                             Flags );

    }

    //
    // Find the prompt data (if any)
    //

    PromptData = CredpFindPromptData(
                            &CredentialSets,
                            &TargetNameString,
                            Type,
                            TempCredential->Cred.Persist );

    //
    // Mark the credential set as modified.
    //

    CredpMarkDirty( &CredentialSets, TempCredential->Cred.Persist, NULL );

    //
    // Delink and delete the credential.
    //

    RemoveEntryList( &TempCredential->Next );
    LsapFreeLsaHeap( TempCredential );

    //
    // Delink and delete the prompt data
    //

    if ( PromptData != NULL ) {
        RemoveEntryList( &PromptData->Next );
        LsapFreeLsaHeap( PromptData );
    }

    Status = STATUS_SUCCESS;

    //
    // Cleanup
    //
Cleanup:
    if ( CritSectLocked ) {
        CredpUnlockAndFlushCredSets( &CredentialSets );
    }

    CredpDereferenceCredSets( &CredentialSets );

    return Status;

}

NTSTATUS
CrediRename (
    IN PLUID LogonId,
    IN LPWSTR OldTargetName,
    IN LPWSTR NewTargetName,
    IN ULONG Type,
    IN ULONG Flags
    )

/*++

Routine Description:

    The CredRename API renames a credential in the user's credential set.
    The credential set used is the one associated with the logon session
    of the current token.  The token must not have the user's SID disabled.

Arguments:

    LogonId - LogonId of the session to associate the credential with.

    OldTargetName - Specifies the current name of the credential to rename.

    NewTargetName - Specifies the new name of the credential.

    Type - Specifies the Type of the credential to rename
        One of the CRED_TYPE_* values should be specified.

    Flags - Specifies flags to control the operation of the API.
        Reserved.  Must be zero.

Return Values:
    The following status codes may be returned:

        STATUS_NOT_FOUND - There is no credential with the specified OldTargetName.

        STATUS_OBJECT_NAME_COLLISION - There is already a credential named NewTargetName.

        STATUS_NO_SUCH_LOGON_SESSION - The logon session does not exist or
            there is no credential set associated with this logon session.
            Network logon sessions do not have an associated credential set.

--*/

{
    NTSTATUS Status;
    CREDENTIAL_SETS CredentialSets = {NULL};
    BOOLEAN CritSectLocked = FALSE;

    PPROMPT_DATA OldPromptData;
    UNICODE_STRING OldTargetNameString;
    DWORD OldTargetNameSize;
    PCANONICAL_CREDENTIAL OldCredential;
    WILDCARD_TYPE OldWildcardType;

    UNICODE_STRING NewTargetNameString;
    DWORD NewTargetNameSize;
    PCANONICAL_CREDENTIAL NewCredential;

    ENCRYPTED_CREDENTIALW LocalCredential;
    PCANONICAL_CREDENTIAL WrittenCredential;


    //
    // Validate the flags
    //

    if ( Flags != 0 ) {
        Status = STATUS_INVALID_PARAMETER_1;
        goto Cleanup;
    }

    //
    // Get the credential set.
    //

    Status = CredpReferenceCredSets( LogonId, &CredentialSets );

    if ( !NT_SUCCESS(Status) ) {
        goto Cleanup;
    }

    CredpLockCredSets( &CredentialSets );
    CritSectLocked = TRUE;



    //
    // Find the old credential
    //

    Status = CredpValidateTargetName( OldTargetName,
                                      Type,
                                      MightBeUsernameTarget,
                                      NULL,         // Don't know user name
                                      NULL,         // Don't know persist
                                      &OldTargetNameSize,
                                      &OldWildcardType,
                                      NULL );       // Don't care about non-wilcarded form of name

    if ( !NT_SUCCESS(Status ) ) {
        goto Cleanup;
    }

    OldTargetNameString.Buffer = OldTargetName;
    OldTargetNameString.MaximumLength = (USHORT) OldTargetNameSize;
    OldTargetNameString.Length = OldTargetNameString.MaximumLength - sizeof(WCHAR);

    OldCredential = CredpFindCredential(
                            &CredentialSets,
                            &OldTargetNameString,
                            Type );

    if ( OldCredential == NULL ) {
        Status = STATUS_NOT_FOUND;
        goto Cleanup;
    }

    //
    // Don't allow *Session creds to be renamed.
    //  That is especially thorny if the CRED_FLAGS_PASSWORD_FOR_CERT bit is set.
    //

    if ( OldWildcardType == WcUniversalSessionWildcard ) {
        Status = STATUS_INVALID_PARAMETER;
        DebugLog(( DEB_TRACE_CRED,
                   "CrediRename: Cannot rename *Session cred.\n" ));
        goto Cleanup;
    }





    //
    // Find the New credential
    //

    Status = CredpValidateTargetName( NewTargetName,
                                      Type,
                                      (OldCredential->Cred.Flags & CRED_FLAGS_USERNAME_TARGET) ?
                                            IsUsernameTarget :
                                            IsNotUsernameTarget,
                                      &OldCredential->Cred.UserName,
                                      &OldCredential->Cred.Persist,
                                      &NewTargetNameSize,
                                      NULL,         // Don't care about name type
                                      NULL );       // Don't care about non-wilcarded form of name

    if ( !NT_SUCCESS(Status ) ) {
        goto Cleanup;
    }

    NewTargetNameString.Buffer = NewTargetName;
    NewTargetNameString.MaximumLength = (USHORT) NewTargetNameSize;
    NewTargetNameString.Length = NewTargetNameString.MaximumLength - sizeof(WCHAR);

    NewCredential = CredpFindCredential(
                            &CredentialSets,
                            &NewTargetNameString,
                            Type );

    if ( NewCredential != NULL ) {
        Status = STATUS_OBJECT_NAME_COLLISION;
        goto Cleanup;
    }

    //
    // Find the prompt data (if any)
    //

    OldPromptData = CredpFindPromptData(
                            &CredentialSets,
                            &OldTargetNameString,
                            Type,
                            OldCredential->Cred.Persist );


    //
    // Write the new credential
    //
    // Clear the TargetAlias.  It'll either be syntactically invalid and fail.  Or
    //  worse, it'll be syntactically valid but semantic nonsense.
    //

    LocalCredential.Cred = OldCredential->Cred;
    LocalCredential.ClearCredentialBlobSize = OldCredential->ClearCredentialBlobSize;
    LocalCredential.Cred.TargetName = NewTargetName;
    LocalCredential.Cred.TargetAlias = NULL;

    Status = CredpWriteMorphedCredential(
                        &CredentialSets,
                        0,      // No flags.  (Password is encrypted via LsaProtectMemory.)
                        !ShouldPromptNow( OldPromptData ), // Preserve the prompted for state
                        NULL,       // No Target info
                        &LocalCredential,
                        &WrittenCredential );

    if ( !NT_SUCCESS(Status) ) {
        goto Cleanup;
    }

    //
    // Mark the credential set as modified.
    //

    CredpMarkDirty( &CredentialSets, OldCredential->Cred.Persist, NULL );

    //
    // Delink and delete the old credential.
    //

    RemoveEntryList( &OldCredential->Next );
    LsapFreeLsaHeap( OldCredential );

    //
    // Delink and delete the prompt data
    //

    if ( OldPromptData != NULL ) {
        RemoveEntryList( &OldPromptData->Next );
        LsapFreeLsaHeap( OldPromptData );
    }

    Status = STATUS_SUCCESS;

    //
    // Cleanup
    //
Cleanup:
    if ( CritSectLocked ) {
        CredpUnlockAndFlushCredSets( &CredentialSets );
    }

    CredpDereferenceCredSets( &CredentialSets );

    return Status;

}

extern "C"
NTSTATUS
CrediGetTargetInfo (
    IN PLUID LogonId,
    IN LPWSTR TargetServerName,
    IN ULONG Flags,
    OUT PCREDENTIAL_TARGET_INFORMATIONW *TargetInfo
    )

/*++

Routine Description:

    The CredGetTargetInfo API gets all of the known target name information
    for the named target machine.  This API is executed locally
    and does not need any particular privilege.  The information returned is expected
    to be passed to the CredReadDomainCredentials and CredWriteDomainCredentials APIs.
    The information should not be used for any other purpose.

    Authentication packages compute TargetInfo when attempting to authenticate to
    ServerName.  The authentication packages cache this target information to make it
    available to CredGetTargetInfo.  Therefore, the target information will only be
    available if we've recently attempted to authenticate to ServerName.

Arguments:

    LogonId - LogonId of the session the target info is associated with

    TargetServerName - This parameter specifies the name of the machine to get the information
        for.

    Flags - Specifies flags to control the operation of the API.

        CRED_ALLOW_NAME_RESOLUTION - Specifies that if no target info can be found for
            TargetName, then name resolution should be done on TargetName to convert it
            to other forms.  If target info exists for any of those other forms, that
            target info is returned.  Currently only DNS name resolution is done.

            This bit is useful if the application doesn't call the authentication package
            directly.  The application might pass the TargetName to another layer of software
            to authenticate to the server.  That layer of software might resolve the name and
            pass the resolved name to the authentication package.  As such, there will be no
            target info for the original TargetName.

    TargetInfo - Returns a pointer to the target information.
        At least one of the returned fields of TargetInfo will be non-NULL.

Return Values:

    The following status codes may be returned:

        STATUS_NO_MEMORY - There isn't enough memory to complete the operation.

        STATUS_NOT_FOUND - There is no credential with the specified TargetName.

--*/

{
    NTSTATUS Status;
    DWORD WinStatus;
    PCANONICAL_TARGET_INFO CanonicalTargetInfo;
    PCREDENTIAL_TARGET_INFORMATIONW LocalTargetInfo = NULL;
    ULONG TargetServerNameSize;
    LPBYTE Where;
    CREDENTIAL_SETS CredentialSets = {NULL};
    BOOLEAN CritSectLocked = FALSE;
    PDNS_RECORD DnsARecords = NULL;

#define CREDP_GTI_VALID_FLAGS CRED_ALLOW_NAME_RESOLUTION

    //
    // Validate the flags
    //

    if ( (Flags & ~CREDP_GTI_VALID_FLAGS) != 0 ) {
        Status = STATUS_INVALID_PARAMETER_1;
        goto Cleanup;
    }

    //
    // Validate the input parameters
    //

    if ( !CredpValidateString( TargetServerName,
                               CRED_MAX_DOMAIN_TARGET_NAME_LENGTH,
                               FALSE,   // NULL not OK
                               &TargetServerNameSize ) ) {
        Status = STATUS_INVALID_PARAMETER;
        DebugLog(( DEB_TRACE_CRED,
                   "CrediGetTargetInfo: Invalid TargetServerName buffer.\n" ));
        goto Cleanup;
    }

    //
    // Get the credential set.
    //

    Status = CredpReferenceCredSets( LogonId, &CredentialSets );

    if ( !NT_SUCCESS(Status) ) {
        goto Cleanup;
    }

    //
    // Lock the credential set.
    //

    CredpLockCredSets( &CredentialSets );
    CritSectLocked = TRUE;


    //
    // See if the named server can be found directly
    //

    CanonicalTargetInfo = CredpFindTargetInfo( &CredentialSets, TargetServerName );

    if ( CanonicalTargetInfo == NULL ) {
        PDNS_RECORD DnsRecord;

        //
        // If the caller doesn't wants us to try name resolution in an attempt for find the target info
        //  we're done.
        //

        if ( (Flags & CRED_ALLOW_NAME_RESOLUTION) == 0 ) {
            Status = STATUS_NOT_FOUND;
            goto Cleanup;
        }

        //
        // Query DNS for the name
        //

        WinStatus = DnsQuery_W(
                         TargetServerName,
                         DNS_TYPE_A,
                         0,     // No special flags
                         NULL,  // No special DNS servers
                         &DnsARecords,
                         NULL );

        if ( WinStatus != NO_ERROR ) {
            // Don't confuse the caller with a more specific status
            Status = STATUS_NOT_FOUND;
            goto Cleanup;

        }

        //
        // Find the first A or AAAA record
        //
        // Only look up the first name returned from DNS.  That's the name the redir used when
        // creating the SPN that the authentication packages pass us in the TargetName.
        //

        for ( DnsRecord = DnsARecords;
              DnsRecord != NULL;
              DnsRecord = DnsRecord->pNext ) {

            if ( DnsRecord->wType == DNS_TYPE_A ||
                 DnsRecord->wType == DNS_TYPE_AAAA ) {

                //
                // See if the named server can be found directly
                //

                CanonicalTargetInfo = CredpFindTargetInfo( &CredentialSets, DnsRecord->pName );

                break;
            }

        }

        if ( CanonicalTargetInfo == NULL ) {
            Status = STATUS_NOT_FOUND;
            goto Cleanup;
        }

    }


    //
    // Allocate a structure to return to the caller
    //

    LocalTargetInfo = (PCREDENTIAL_TARGET_INFORMATIONW) MIDL_user_allocate(
                        sizeof(*LocalTargetInfo) +
                        CanonicalTargetInfo->CredTypeCount * sizeof(DWORD) +
                        CanonicalTargetInfo->TargetName.MaximumLength +
                        CanonicalTargetInfo->NetbiosServerName.MaximumLength +
                        CanonicalTargetInfo->DnsServerName.MaximumLength +
                        CanonicalTargetInfo->NetbiosDomainName.MaximumLength +
                        CanonicalTargetInfo->DnsDomainName.MaximumLength +
                        CanonicalTargetInfo->DnsTreeName.MaximumLength +
                        CanonicalTargetInfo->PackageName.MaximumLength );

    if ( LocalTargetInfo == NULL) {
        Status = STATUS_NO_MEMORY;
        goto Cleanup;
    }

    RtlZeroMemory( LocalTargetInfo, sizeof(*LocalTargetInfo) );
    Where = (LPBYTE) (LocalTargetInfo+1);

    //
    // Copy the constant size data
    //

    LocalTargetInfo->Flags = CanonicalTargetInfo->Flags;

    //
    // Copy the DWORD aligned data
    //

    LocalTargetInfo->CredTypeCount = CanonicalTargetInfo->CredTypeCount;
    if ( LocalTargetInfo->CredTypeCount != 0 ) {
        LocalTargetInfo->CredTypes = (LPDWORD)Where;
        RtlCopyMemory( Where, CanonicalTargetInfo->CredTypes, CanonicalTargetInfo->CredTypeCount * sizeof(DWORD) );
        Where += CanonicalTargetInfo->CredTypeCount * sizeof(DWORD);
    } else {
        LocalTargetInfo->CredTypes = NULL;
    }

    //
    // Copy the 2-byte aligned data
    //

    if ( CanonicalTargetInfo->TargetName.Length != 0 ) {

        LocalTargetInfo->TargetName = (LPWSTR) Where;

        RtlCopyMemory( LocalTargetInfo->TargetName,
                       CanonicalTargetInfo->TargetName.Buffer,
                       CanonicalTargetInfo->TargetName.MaximumLength );

        Where += CanonicalTargetInfo->TargetName.MaximumLength;
    }

    if ( CanonicalTargetInfo->NetbiosServerName.Length != 0 ) {

        LocalTargetInfo->NetbiosServerName = (LPWSTR) Where;

        RtlCopyMemory( LocalTargetInfo->NetbiosServerName,
                       CanonicalTargetInfo->NetbiosServerName.Buffer,
                       CanonicalTargetInfo->NetbiosServerName.MaximumLength );

        Where += CanonicalTargetInfo->NetbiosServerName.MaximumLength;
    }

    if ( CanonicalTargetInfo->DnsServerName.Length != 0 ) {

        LocalTargetInfo->DnsServerName = (LPWSTR) Where;

        RtlCopyMemory( LocalTargetInfo->DnsServerName,
                       CanonicalTargetInfo->DnsServerName.Buffer,
                       CanonicalTargetInfo->DnsServerName.MaximumLength );

        Where += CanonicalTargetInfo->DnsServerName.MaximumLength;
    }

    if ( CanonicalTargetInfo->NetbiosDomainName.Length != 0 ) {

        LocalTargetInfo->NetbiosDomainName = (LPWSTR) Where;

        RtlCopyMemory( LocalTargetInfo->NetbiosDomainName,
                       CanonicalTargetInfo->NetbiosDomainName.Buffer,
                       CanonicalTargetInfo->NetbiosDomainName.MaximumLength );

        Where += CanonicalTargetInfo->NetbiosDomainName.MaximumLength;
    }

    if ( CanonicalTargetInfo->DnsDomainName.Length != 0 ) {

        LocalTargetInfo->DnsDomainName = (LPWSTR) Where;

        RtlCopyMemory( LocalTargetInfo->DnsDomainName,
                       CanonicalTargetInfo->DnsDomainName.Buffer,
                       CanonicalTargetInfo->DnsDomainName.MaximumLength );

        Where += CanonicalTargetInfo->DnsDomainName.MaximumLength;
    }

    if ( CanonicalTargetInfo->DnsTreeName.Length != 0 ) {

        LocalTargetInfo->DnsTreeName = (LPWSTR) Where;

        RtlCopyMemory( LocalTargetInfo->DnsTreeName,
                       CanonicalTargetInfo->DnsTreeName.Buffer,
                       CanonicalTargetInfo->DnsTreeName.MaximumLength );

        Where += CanonicalTargetInfo->DnsTreeName.MaximumLength;
    }

    if ( CanonicalTargetInfo->PackageName.Length != 0 ) {

        LocalTargetInfo->PackageName = (LPWSTR) Where;

        RtlCopyMemory( LocalTargetInfo->PackageName,
                       CanonicalTargetInfo->PackageName.Buffer,
                       CanonicalTargetInfo->PackageName.MaximumLength );

        Where += CanonicalTargetInfo->PackageName.MaximumLength;
    }

    //
    // Return the information to the caller
    //

    *TargetInfo = LocalTargetInfo;
    Status = STATUS_SUCCESS;


    //
    // Cleanup
    //
Cleanup:
    if ( CritSectLocked ) {
        CredpUnlockAndFlushCredSets( &CredentialSets );
    }

    if ( DnsARecords != NULL ) {
        DnsRecordListFree( DnsARecords, DnsFreeRecordListDeep );
    }

    CredpDereferenceCredSets( &CredentialSets );

    return Status;
}

NTSTATUS
CrediGetSessionTypes (
    IN PLUID LogonId,
    IN DWORD MaximumPersistCount,
    OUT LPDWORD MaximumPersist
    )

/*++

Routine Description:

    CredGetSessionTypes returns the maximum persistence supported by the current logon
    session.

    For whistler, CRED_PERSIST_LOCAL_MACHINE and CRED_PERSIST_ENTERPRISE credentials can not
    be stored for sessions where the profile is not loaded.  If future releases, credentials
    might not be associated with the user's profile.

Arguments:

    LogonId - LogonId of the session to associate the credential with.

    MaximumPersistCount - Specifies the number of elements in the MaximumPersist array.
        The caller should specify CRED_TYPE_MAXIMUM for this parameter.

    MaximumPersist - Returns the maximum persistance supported by the current logon session for
        each credential type.  Index into the array with one of the CRED_TYPE_* defines.
        Returns CRED_PERSIST_NONE if no credential of this type can be stored.
        Returns CRED_PERSIST_SESSION if only session specific credential may be stored.
        Returns CRED_PERSIST_LOCAL_MACHINE if session specific and machine specific credentials
            may be stored.
        Returns CRED_PERSIST_ENTERPRISE if any credential may be stored.

Return Values:

    STATUS_NO_SUCH_LOGON_SESSION - The logon session does not exist or
            there is no credential set associated with this logon session.
            Network logon sessions do not have an associated credential set.

--*/

{
    NTSTATUS Status;
    CREDENTIAL_SETS CredentialSets = {NULL};
    BOOLEAN CritSectLocked = FALSE;
    ULONG i;

    PCREDENTIAL_SET CredentialSet;
    ULONG Persist;

    //
    // Validate the parameters
    //

    if ( MaximumPersistCount != 0 && MaximumPersist == NULL ) {
        Status = STATUS_INVALID_PARAMETER;
        goto Cleanup;
    }

    //
    // Avoid huge buffers
    //  Allow some leeway to allow new applications to run on old OSes.
    //
    if ( MaximumPersistCount > CRED_TYPE_MAXIMUM_EX ) {
        Status = STATUS_INVALID_PARAMETER;
        goto Cleanup;
    }

    //
    // Get the credential set.
    //

    Status = CredpReferenceCredSets( LogonId, &CredentialSets );

    if ( !NT_SUCCESS(Status) ) {
        goto Cleanup;
    }

    //
    // Lock the credential set.
    //

    CredpLockCredSets( &CredentialSets );
    CritSectLocked = TRUE;

    //
    // Loop through the list filling in each element
    //

    for ( i=0; i<MaximumPersistCount; i++ ) {

        //
        // The default value depends on whether the profile is loaded.
        //

        if ( CredentialSets.SessionCredSets->ProfileLoaded ) {
            MaximumPersist[i] = CRED_PERSIST_ENTERPRISE;
        } else {
            MaximumPersist[i] = CRED_PERSIST_SESSION;
        }

        //
        // Some types can be disabled
        //

        if ( i == CRED_TYPE_GENERIC ) {
            /* Nothing to do here */


        //
        // Disable domain credentials based on policy
        //
        } else if ( CredpIsDomainCredential(i) ) {
            if ( CredDisableDomainCreds ) {

                MaximumPersist[i] = CRED_PERSIST_NONE;

            } else if ( CredIsPersonal &&
                        i != CRED_TYPE_DOMAIN_VISIBLE_PASSWORD ) {

                MaximumPersist[i] = CRED_PERSIST_NONE;
            }

        //
        // Disable all types we don't understand
        //
        } else {
            MaximumPersist[i] = CRED_PERSIST_NONE;
        }

    }

    Status = STATUS_SUCCESS;

    //
    // Cleanup
    //
Cleanup:
    if ( CritSectLocked ) {
        CredpUnlockAndFlushCredSets( &CredentialSets );
    }

    CredpDereferenceCredSets( &CredentialSets );

    return Status;
}


NTSTATUS
CrediProfileLoaded (
    IN PLUID LogonId
    )

/*++

Routine Description:

    The CredProfileLoaded API is a private API used by LoadUserProfile to notify the
    credential manager that the profile for the current user has been loaded.

    The caller must be impersonating the logged on user.

Arguments:

    LogonId - LogonId of the session to load the credentials for

Return Values:

    The following status codes may be returned:

        STATUS_NO_SUCH_LOGON_SESSION - The logon session does not exist or
            there is no credential set associated with this logon session.
            Network logon sessions do not have an associated credential set.

--*/
{
    NTSTATUS Status;
    DWORD WinStatus;
    CREDENTIAL_SETS CredentialSets = {NULL};
    BOOLEAN CritSectLocked = FALSE;

    PCREDENTIAL_SET CredentialSet;
    ULONG Persist;

    //
    // Get the credential set.
    //

    Status = CredpReferenceCredSets( LogonId, &CredentialSets );

    if ( !NT_SUCCESS(Status) ) {

        //
        // This is a notification API.  Just because there are no credentials, doesn't
        // mean the profile load should fail.  Indeed, it is already finished.
        //
        if ( Status == STATUS_NO_SUCH_LOGON_SESSION ) {
            Status = STATUS_SUCCESS;
        }
        goto Cleanup;
    }

    //
    // Lock the credential set.
    //

    CredpLockCredSets( &CredentialSets );
    CritSectLocked = TRUE;

    //
    // Mark it that the profile is now loaded.
    //

    CredentialSets.SessionCredSets->ProfileLoaded = TRUE;


    //
    // Loop through the list of credential sets reading each
    //

    for ( Persist=CRED_PERSIST_MIN; Persist <= CRED_PERSIST_MAX; Persist++ ) {

        //
        // Ignore non-persistent credential sets
        //

        if ( Persist == CRED_PERSIST_SESSION ) {
            continue;
        }

        CredentialSet = PersistToCredentialSet( &CredentialSets, Persist );

        //
        // If this cred set hasn't been read yet,
        //  read it now.
        //

        if ( !CredentialSet->FileRead ) {
            WinStatus = CredpReadCredSet( LogonId, &CredentialSets, Persist );

            if ( WinStatus == NO_ERROR ) {
                CredentialSet->FileRead = TRUE;
            }
        }

    }

    Status = STATUS_SUCCESS;

    //
    // Cleanup
    //
Cleanup:
    if ( CritSectLocked ) {
        CredpUnlockAndFlushCredSets( &CredentialSets );
    }

    CredpDereferenceCredSets( &CredentialSets );

    return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\base\lsa\server\ctxtapi.cxx ===
//+-----------------------------------------------------------------------
//
// Microsoft Windows
//
// Copyright (c) Microsoft Corporation 1991 - 1992
//
// File:        ctxtapi.c
//
// Contents:    Context APIs to the SPMgr.
//              - LsaInitContext
//              - LsaAcceptContext
//              - LsaFinalizeContext
//              - LsaMapContext
//
//              And WLsa functions
//
// History:     20 May 92   RichardW    Commented existing code
//
//------------------------------------------------------------------------


#include <lsapch.hxx>

//+---------------------------------------------------------------------------
//
//  Function:   WLsaInitContext
//
//  Synopsis:   Worker that maps the call to the appropriate package
//
//  Effects:
//
//  Arguments:  [phCredential]  --
//              [phContext]     --
//              [pTarget]       --
//              [fContextReq]   --
//              [dwReserved1]   --
//              [TargetDataRep] --
//              [pInput]        --
//              [dwReserved2]   --
//              [phNewContext]  --
//              [pOutput]       --
//              [pfContextAttr] --
//              [ptsExpiry]     --
//              [MappedContext] --
//              [ContextData]   --
//
//  Requires:
//
//  Returns:
//
//  History:    9-24-96   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
NTSTATUS
WLsaInitContext(    PCredHandle         phCredential,
                    PCtxtHandle         phContext,
                    PSECURITY_STRING    pTarget,
                    DWORD               fContextReq,
                    DWORD               dwReserved1,
                    DWORD               TargetDataRep,
                    PSecBufferDesc      pInput,
                    DWORD               dwReserved2,
                    PCtxtHandle         phNewContext,
                    PSecBufferDesc      pOutput,
                    DWORD *             pfContextAttr,
                    PTimeStamp          ptsExpiry,
                    PBOOLEAN            MappedContext,
                    PSecBuffer          ContextData )
{
    NTSTATUS       scRet;
    PLSAP_SECURITY_PACKAGE pspPackage;
    PSession    pSession = GetCurrentSession();
    PLSA_CALL_INFO CallInfo = LsapGetCurrentCall();
    PVOID ContextKey = NULL ;
    PVOID CredKey = NULL ;

    DebugLog((DEB_TRACE_WAPI, "[%x] WLsaInitContext(%p : %p, %p : %p, %ws)\n",
        pSession->dwProcessID,
        phCredential->dwUpper,
        phCredential->dwLower,
        phContext->dwUpper,
        phContext->dwLower,
        pTarget->Buffer));

#if DBG
    if ( pInput && pInput->cBuffers )
    {
        DsysAssert( (ULONG_PTR) pInput->pBuffers > PORT_MAXIMUM_MESSAGE_LENGTH );
    }
    if ( pOutput && pOutput->cBuffers )
    {
        DsysAssert( (ULONG_PTR) pOutput->pBuffers > PORT_MAXIMUM_MESSAGE_LENGTH );

    }
#endif

    //
    // Reset the new handle to a known, invalid state
    //

    phNewContext->dwLower = SPMGR_ID;
    phNewContext->dwUpper = 0;
    
    //
    // Check handles against the session to make sure they're valid.  If the
    // context handle is valid, we use that, otherwise the credential.
    //

    if (phCredential->dwUpper) 
    {
        scRet = ValidateCredHandle(
                    pSession,
                    phCredential,
                    &CredKey );
    
        if ( !NT_SUCCESS( scRet ) ) 
        {
            DsysAssert( (pSession->fSession & SESFLAG_KERNEL) == 0 );
        
            //
            // null out the dwUpper since the handle is invalid, do not want to 
            // bail it out here for app compat reasons: the credential handle 
            // is ignored when the context handle is valid
            //

            DebugLog((DEB_WARN, "[%#x] InitContext null out invalid credential handle %#x.%#x\n", 
                pSession->dwProcessID, phCredential->dwLower, phCredential->dwUpper));

            phCredential->dwUpper = NULL;
        }           
    }

    if (phContext->dwUpper) 
    {
        scRet = ValidateContextHandle(
                    pSession,
                    phContext,
                    &ContextKey );
    
        if ( !NT_SUCCESS( scRet ) ) 
        {
            DsysAssert( (pSession->fSession & SESFLAG_KERNEL) == 0 );

            //
            // null out the dwUpper since the handle is invalid 
            //

            DebugLog((DEB_WARN, "[%#x] InitContext null out invalid context handle %#x.%#x\n", 
                pSession->dwProcessID, phContext->dwLower, phContext->dwUpper));

            phContext->dwUpper = NULL;
        }
        else
        {   
            //
            // Tricky stuff:  if the context handle is valid, but does not
            // come from the same package as the credential, null out the cred
            // handle:
            //

            if ( phCredential->dwLower != phContext->dwLower )
            {
                phCredential->dwLower = 0;
                phCredential->dwUpper = 0;
            }
        }    
    }

    if ((phContext->dwUpper == NULL) && (phCredential->dwUpper == NULL)) 
    {
        DsysAssert( (pSession->fSession & SESFLAG_KERNEL) == 0 );

        scRet = SEC_E_INVALID_HANDLE;
        goto Cleanup;
    }

    //
    // log the call info using the context handle if it is valid, otherwise use 
    // the credential handle
    //

    LsapLogCallInfo( CallInfo, pSession, phContext->dwUpper ? *phContext : *phCredential );

    //
    // if the context handle is non null and valid, use its package value, otherwise
    // use the package value from the credential handle
    //

    pspPackage = SpmpValidRequest( phContext->dwUpper ? phContext->dwLower : phCredential->dwLower,
                    SP_ORDINAL_INITLSAMODECTXT );

    if ( !pspPackage )
    {
        scRet = SEC_E_INVALID_HANDLE;
        goto Cleanup;
    }

    SetCurrentPackageId( pspPackage->dwPackageID );

    StartCallToPackage( pspPackage );

    DebugLog((DEB_TRACE_VERB, "\tContext Req = 0x%08x\n", fContextReq));

    DebugLog((DEB_TRACE_VERB, "\tPackage = %ws\n", pspPackage->Name.Buffer));

    __try
    {
        scRet = pspPackage->FunctionTable.InitLsaModeContext(
                                                phCredential->dwUpper,
                                                phContext->dwUpper,
                                                pTarget,
                                                fContextReq,
                                                TargetDataRep,
                                                pInput,
                                                &phNewContext->dwUpper,
                                                pOutput,
                                                pfContextAttr,
                                                ptsExpiry,
                                                MappedContext,
                                                ContextData );
    }
    __except (SP_EXCEPTION)
    {
        scRet = GetExceptionCode();
        scRet = SPException(scRet, pspPackage->dwPackageID);
    }

    EndCallToPackage( pspPackage );

    DebugLog((DEB_TRACE_WAPI, "InitResult = %x\n", scRet));
    DebugLog((DEB_TRACE_VERB, "\tFlags = %08x\n", *pfContextAttr));

    //
    // Only add a new context if the old one didn't exist.
    // Otherwise copy the old context over the new context.
    //

    if ( NT_SUCCESS( scRet ) )
    {
        if ( (phNewContext->dwUpper != 0) &&
             (phNewContext->dwUpper != phContext->dwUpper) )
        {
            //
            // If the package ID is unchanged, set it to the current package
            // id.  This is so that if package changes the ID through
            // LsapChangeHandle, we can catch it.
            //

            if ( phNewContext->dwLower == SPMGR_ID )
            {
                phNewContext->dwLower = pspPackage->dwPackageID ;

                if (!AddContextHandle( pSession, phNewContext, 0 ))
                {
                    DebugLog(( DEB_ERROR, "Failed adding context handle %p:%p to session %p\n",
                                phNewContext->dwUpper, phNewContext->dwLower,
                                pSession ));

                    pspPackage = SpmpValidRequest(
                                                phNewContext->dwLower,
                                                SP_ORDINAL_DELETECTXT
                                                );

                    if ( pspPackage )
                    {
                        //
                        // remove the handle from the underlying package.
                        //

                        StartCallToPackage( pspPackage );

                        __try
                        {
                            pspPackage->FunctionTable.DeleteContext(
                                                        phNewContext->dwUpper
                                                        );
                        }
                        __except (SP_EXCEPTION)
                        {
                            NOTHING;
                        }

                        EndCallToPackage( pspPackage );
                    }

                    phNewContext->dwLower = 0;
                    phNewContext->dwUpper = 0;

                    scRet = SEC_E_INSUFFICIENT_MEMORY;
                }
            }
        }
        else
        {
            *phNewContext = *phContext;
        }
    }
    else
    {
        *phNewContext = *phContext ;
    }

    DebugLog(( DEB_TRACE_WAPI, "Init New Context = %p : %p to session %p\n",
        phNewContext->dwUpper , phNewContext->dwLower, pSession ));

    SetCurrentPackageId( SPMGR_ID );

Cleanup:

    if ( ContextKey )
    {
        DerefContextHandle( pSession, NULL, ContextKey );
    }

    if ( CredKey )
    {
        DerefCredHandle( pSession, NULL, CredKey );
    }

    return(scRet);
}

//+-------------------------------------------------------------------------
//
//  Function:   WLsaAcceptContext()
//
//  Synopsis:   Worker function for AcceptSecurityContext()
//
//  Effects:    Creates a server-side security context
//
//  Arguments:  See LsaAcceptContext()
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//--------------------------------------------------------------------------

NTSTATUS
WLsaAcceptContext(  PCredHandle     phCredential,
                    PCtxtHandle     phContext,
                    PSecBufferDesc  pInput,
                    DWORD           fContextReq,
                    DWORD           TargetDataRep,
                    PCtxtHandle     phNewContext,
                    PSecBufferDesc  pOutput,
                    DWORD *         pfContextAttr,
                    PTimeStamp      ptsExpiry,
                    PBOOLEAN        MappedContext,
                    PSecBuffer      ContextData)
{
    NTSTATUS       scRet;
    PLSAP_SECURITY_PACKAGE pspPackage;
    PSession    pSession;
    PVOID       ContextKey = NULL ;
    PVOID       CredKey = NULL ;
    PLSA_CALL_INFO CallInfo = LsapGetCurrentCall();

    //
    // Clear out the handle
    //

    phNewContext->dwLower = SPMGR_ID;
    phNewContext->dwUpper = 0;

#if DBG
    if ( pInput && pInput->cBuffers )
    {
        DsysAssert( (ULONG_PTR) pInput->pBuffers > PORT_MAXIMUM_MESSAGE_LENGTH );
    }
    if ( pOutput && pOutput->cBuffers )
    {
        DsysAssert( (ULONG_PTR) pOutput->pBuffers > PORT_MAXIMUM_MESSAGE_LENGTH );

    }
#endif
    //
    // Get our session
    //

    pSession = GetCurrentSession();

    DebugLog((DEB_TRACE_WAPI, "[%x] WLsaAcceptContext(%p : %p)\n",
                pSession->dwProcessID,
                phCredential->dwUpper, phCredential->dwLower));

    //
    // Check handles against the session to make sure they're valid.  If the
    // context handle is valid, we use that, otherwise the credential.
    //

    if (phCredential->dwUpper) 
    {
        scRet = ValidateCredHandle(
                    pSession,
                    phCredential,
                    &CredKey );
    
        if ( !NT_SUCCESS( scRet ) ) 
        {
            DsysAssert( (pSession->fSession & SESFLAG_KERNEL) == 0 );
        
            //
            // null out the dwUpper since the handle is invalid, do not want to 
            // bail it out here for app compat reasons: the credential handle 
            // is ignored when the context handle is valid
            //

            DebugLog((DEB_WARN, "[%#x] AcceptContext null out invalid credential handle %#x.%#x\n", 
                pSession->dwProcessID, phCredential->dwLower, phCredential->dwUpper));

            phCredential->dwUpper = NULL;
        }           
    }

    if (phContext->dwUpper) 
    {
        scRet = ValidateContextHandle(
                    pSession,
                    phContext,
                    &ContextKey );
    
        if ( !NT_SUCCESS( scRet ) ) 
        {
            DsysAssert( (pSession->fSession & SESFLAG_KERNEL) == 0 );

            //
            // null out the dwUpper since the handle is invalid 
            //

            DebugLog((DEB_WARN, "[%#x] AcceptContext null out invalid context handle %#x.%#x\n", 
                pSession->dwProcessID, phContext->dwLower, phContext->dwUpper));

            phContext->dwUpper = NULL;
        }
        else
        {   
            //
            // Tricky stuff:  if the context handle is valid, but does not
            // come from the same package as the credential, null out the cred
            // handle:
            //

            if ( phCredential->dwLower != phContext->dwLower )
            {
                phCredential->dwLower = 0;
                phCredential->dwUpper = 0;
            }
        }    
    }

    if ((phContext->dwUpper == NULL) && (phCredential->dwUpper == NULL)) 
    {
        DsysAssert( (pSession->fSession & SESFLAG_KERNEL) == 0 );

        scRet = SEC_E_INVALID_HANDLE;
        goto Cleanup;
    }

    //
    // log the call info using the context handle if it is valid, otherwise use 
    // the credential handle
    //

    LsapLogCallInfo( CallInfo, pSession, phContext->dwUpper ? *phContext : *phCredential );

    //
    // if the context handle is non null and valid, use its package value, otherwise
    // use the package value from the credential handle
    //

    pspPackage = SpmpValidRequest( phContext->dwUpper ? phContext->dwLower : phCredential->dwLower,
                    SP_ORDINAL_ACCEPTLSAMODECTXT );

    if ( !pspPackage )
    {
        DsysAssert( (pSession->fSession & SESFLAG_KERNEL) == 0 );

        scRet = SEC_E_INVALID_HANDLE;
        goto Cleanup;
    }

    SetCurrentPackageId( pspPackage->dwPackageID );

    StartCallToPackage( pspPackage );

    __try
    {
        scRet = pspPackage->FunctionTable.AcceptLsaModeContext(
                                            phCredential->dwUpper,
                                            phContext->dwUpper,
                                            pInput,
                                            fContextReq,
                                            TargetDataRep,
                                            &phNewContext->dwUpper,
                                            pOutput,
                                            pfContextAttr,
                                            ptsExpiry,
                                            MappedContext,
                                            ContextData );
    }
    __except (SP_EXCEPTION)
    {
        scRet = GetExceptionCode();
        scRet = SPException(scRet, pspPackage->dwPackageID);
    }

    EndCallToPackage( pspPackage );

    DebugLog((DEB_TRACE_WAPI, "[%x]  Result = %x\n", pSession->dwProcessID, scRet));

    //
    // Only add a new context if the old one didn't exist.
    // Otherwise copy the old context over the new context.
    //

    if ( NT_SUCCESS( scRet ) || ( scRet == SEC_E_INCOMPLETE_MESSAGE ) )
    {
        if ( (phNewContext->dwUpper != 0) &&
             (phNewContext->dwUpper != phContext->dwUpper) )
        {
            //
            // If the package ID is unchanged, set it to the current package
            // id.  This is so that if package changes the ID through
            //

            if ( phNewContext->dwLower == SPMGR_ID )
            {
                phNewContext->dwLower = pspPackage->dwPackageID ;

                if (!AddContextHandle( pSession, phNewContext, 0 ))
                {
                    DebugLog(( DEB_ERROR, "Failed adding context handle %p:%p to session %p\n",
                                phNewContext->dwUpper, phNewContext->dwLower,
                                pSession ));

                    pspPackage = SpmpValidRequest(
                                    phNewContext->dwLower,
                                    SP_ORDINAL_DELETECTXT
                                    );

                    if ( pspPackage )
                    {
                        //
                        // remove the handle from the underlying package.
                        //

                        StartCallToPackage( pspPackage );

                        __try
                        {
                            pspPackage->FunctionTable.DeleteContext(
                                                        phNewContext->dwUpper
                                                        );
                        }
                        __except (SP_EXCEPTION)
                        {
                            NOTHING;
                        }

                        EndCallToPackage( pspPackage );
                    }

                    phNewContext->dwLower = 0;
                    phNewContext->dwUpper = 0;

                    scRet = SEC_E_INSUFFICIENT_MEMORY;
                }
            }

        }
        else
        {
            *phNewContext = *phContext;
        }
    }
    else
    {
        *phNewContext = *phContext ;
    }

    DebugLog(( DEB_TRACE_WAPI, "Accept new context = %p : %p \n",
        phNewContext->dwUpper, phNewContext->dwLower ));

    SetCurrentPackageId( SPMGR_ID );

Cleanup:

    if ( ContextKey )
    {
        DerefContextHandle( pSession, NULL, ContextKey );
    }

    if ( CredKey )
    {
        DerefCredHandle( pSession, NULL, CredKey );
    }

    return(scRet);
}

//+-------------------------------------------------------------------------
//
//  Function:   WLsaDeleteContext
//
//  Synopsis:   Worker function for deleting a context
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//--------------------------------------------------------------------------
NTSTATUS
WLsaDeleteContext(  PCtxtHandle     phContext)
{
    NTSTATUS scRet;
    PSession        pSession = GetCurrentSession();
    PLSA_CALL_INFO CallInfo = LsapGetCurrentCall();


    DebugLog((DEB_TRACE_WAPI, "[%x] WDeleteContext(%p : %p)\n",
                pSession->dwProcessID,
                phContext->dwUpper, phContext->dwLower));


    scRet = ValidateAndDerefContextHandle(
                    pSession,
                    phContext );

    if ( (CallInfo->Flags & CALL_FLAG_NO_HANDLE_CHK) == 0 )
    {
        if ( !NT_SUCCESS( scRet ) )
        {
            DebugLog((DEB_ERROR,"[%x] Invalid handle passed to DeleteContext: %p:%p\n",
                pSession->dwProcessID,
                phContext->dwUpper,phContext->dwLower));

///            DsysAssert( (pSession->fSession & SESFLAG_KERNEL) == 0 );

        }
    }

    LsapLogCallInfo( CallInfo, pSession, *phContext );

    if (SUCCEEDED(scRet))
    {
        phContext->dwUpper = phContext->dwLower = 0xFFFFFFFF;
    }


    return(scRet);

}




//+-------------------------------------------------------------------------
//
//  Function:   WLsaApplyControlToken
//
//  Synopsis:   Worker function for applying a control token
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//--------------------------------------------------------------------------
NTSTATUS
WLsaApplyControlToken(  PCtxtHandle     phContext,
                        PSecBufferDesc  pInput)
{
    NTSTATUS         scRet;
    PLSAP_SECURITY_PACKAGE     pspPackage;
    PSession        pSession = GetCurrentSession();
    PLSA_CALL_INFO  CallInfo = LsapGetCurrentCall();
    PVOID           ContextKey ;


    DebugLog((DEB_TRACE_WAPI, "[%x] WApplyControlToken(%p : %p)\n",
                pSession->dwProcessID,
                phContext->dwUpper, phContext->dwLower));

    LsapLogCallInfo( CallInfo, pSession, *phContext );

    scRet = ValidateContextHandle(
                pSession,
                phContext,
                &ContextKey );

    if ( !NT_SUCCESS( scRet ) )
    {
        DsysAssert( (pSession->fSession & SESFLAG_KERNEL) == 0 );

        return( scRet );

    }

    pspPackage = SpmpValidRequest(  phContext->dwLower,
                                    SP_ORDINAL_APPLYCONTROLTOKEN);

    if ( !pspPackage )
    {
        return SEC_E_INVALID_HANDLE ;
    }

    SetCurrentPackageId(phContext->dwLower);

    StartCallToPackage( pspPackage );

    __try
    {
        scRet = pspPackage->FunctionTable.ApplyControlToken(
                                                phContext->dwUpper,
                                                pInput);
    }
    __except (SP_EXCEPTION)
    {
        scRet = GetExceptionCode();
        scRet = SPException(scRet, pspPackage->dwPackageID);
    }

    EndCallToPackage( pspPackage );

    SetCurrentPackageId( SPMGR_ID );

    DerefContextHandle( pSession, NULL, ContextKey );

    return(scRet);

}



NTSTATUS
WLsaQueryContextAttributes(
    PCtxtHandle phContext,
    ULONG       ulAttribute,
    PVOID       pvBuffer
    )
{
    NTSTATUS         scRet;
    PLSAP_SECURITY_PACKAGE     pspPackage = NULL ;
    PSession        pSession = GetCurrentSession();
    PLSA_CALL_INFO CallInfo = LsapGetCurrentCall();
    PVOID           ContextKey ;


    DebugLog((DEB_TRACE_WAPI, "[%x] WLsaQueryContextAttributes(%p : %p)\n",
                pSession->dwProcessID,
                phContext->dwUpper, phContext->dwLower));

    LsapLogCallInfo( CallInfo, pSession, *phContext );

    scRet = ValidateContextHandle(
                pSession,
                phContext,
                &ContextKey );


    if ( NT_SUCCESS( scRet ) )
    {
        pspPackage = SpmpValidRequest(  phContext->dwLower,
                                        SP_ORDINAL_QUERYCONTEXTATTRIBUTES);
    }
    if (( !pspPackage ) ||
        !NT_SUCCESS( scRet ) )
    {
        DsysAssert( (pSession->fSession & SESFLAG_KERNEL) == 0 );

        return(SEC_E_INVALID_HANDLE);
    }

    StartCallToPackage( pspPackage );

    SetCurrentPackageId(phContext->dwLower);

    __try
    {
        scRet = pspPackage->FunctionTable.QueryContextAttributes(
                                                phContext->dwUpper,
                                                ulAttribute,
                                                pvBuffer );
    }
    __except (SP_EXCEPTION)
    {
        scRet = GetExceptionCode();
        scRet = SPException(scRet, pspPackage->dwPackageID);
    }

    EndCallToPackage( pspPackage );

    SetCurrentPackageId( SPMGR_ID );

    DerefContextHandle( pSession, NULL, ContextKey );

    return(scRet);

}



NTSTATUS
WLsaSetContextAttributes(
    PCtxtHandle phContext,
    ULONG       ulAttribute,
    PVOID       pvBuffer,
    ULONG       cbBuffer
    )
{
    NTSTATUS         scRet;
    PLSAP_SECURITY_PACKAGE     pspPackage = NULL ;
    PSession        pSession = GetCurrentSession();
    PLSA_CALL_INFO CallInfo = LsapGetCurrentCall();
    PVOID           ContextKey ;


    DebugLog((DEB_TRACE_WAPI, "[%x] WLsaSetContextAttributes(%p : %p)\n",
                pSession->dwProcessID,
                phContext->dwUpper, phContext->dwLower));

    LsapLogCallInfo( CallInfo, pSession, *phContext );

    scRet = ValidateContextHandle(
                pSession,
                phContext,
                &ContextKey );


    if ( NT_SUCCESS( scRet ) )
    {
        pspPackage = SpmpValidRequest(  phContext->dwLower,
                                        SP_ORDINAL_SETCONTEXTATTRIBUTES);
    }
    if (( !pspPackage ) ||
        !NT_SUCCESS( scRet ) )
    {
        DsysAssert( (pSession->fSession & SESFLAG_KERNEL) == 0 );

        return(SEC_E_INVALID_HANDLE);
    }

    StartCallToPackage( pspPackage );

    SetCurrentPackageId(phContext->dwLower);

    __try
    {
        scRet = pspPackage->FunctionTable.SetContextAttributes(
                                                phContext->dwUpper,
                                                ulAttribute,
                                                pvBuffer,
                                                cbBuffer );
    }
    __except (SP_EXCEPTION)
    {
        scRet = GetExceptionCode();
        scRet = SPException(scRet, pspPackage->dwPackageID);
    }

    EndCallToPackage( pspPackage );

    SetCurrentPackageId( SPMGR_ID );

    DerefContextHandle( pSession, NULL, ContextKey );

    return(scRet);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\base\lsa\server\dblookup.h ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    dblookup.h

Abstract:

    LSA Database - Lookup Sid and Name Routine Private Data Definitions.

    NOTE:  This module should remain as portable code that is independent
           of the implementation of the LSA Database.  As such, it is
           permitted to use only the exported LSA Database interfaces
           contained in db.h and NOT the private implementation
           dependent functions in dbp.h.

Author:

    Scott Birrell       (ScottBi)      Novwember 27, 1992

Environment:

Revision History:

--*/

#include <safelock.h>

//////////////////////////////////////////////////////////////////////////
//                                                                      //
// Private Datatypes and Defines                                        //
//                                                                      //
//////////////////////////////////////////////////////////////////////////


//
//  This global controls what events are logged.
//  Note each level assumes that previous levels are to be logged too
//
//  Current only two values:
//
//  0 : (default) none
//  1 : fatal errors
//
extern DWORD LsapLookupLogLevel;


//
// This boolean indicates whether a post NT4 DC should perform
// extended lookups (eg by UPN) in a mixed domain (default is FALSE).
//
extern BOOLEAN LsapAllowExtendedDownlevelLookup;


//
// Set to 0 to disable the SID cache
//
#define USE_SID_CACHE 1

//
// Maximum number of Lookup Threads and maximum number to retain.
//

#define LSAP_DB_LOOKUP_MAX_THREAD_COUNT            ((ULONG) 0x00000002)
#define LSAP_DB_LOOKUP_MAX_RET_THREAD_COUNT        ((ULONG) 0x00000002)

//
// Work Item Granularity.
//

#define LSAP_DB_LOOKUP_WORK_ITEM_GRANULARITY       ((ULONG) 0x0000000f)

//
// Parameters specific to a Lookup Sids call.
//

typedef struct _LSAP_DB_LOOKUP_SIDS_PARAMS {

    PLSAPR_SID *Sids;
    PLSAPR_TRANSLATED_NAMES_EX TranslatedNames;

} LSAP_DB_LOOKUP_SIDS_PARAMS, *PLSAP_DB_LOOKUP_SIDS_PARAMS;

//
// Parameters specific to a Lookup Names call.
//

typedef struct _LSAP_DB_LOOKUP_NAMES_PARAMS {

    PLSAPR_UNICODE_STRING Names;
    PLSAPR_TRANSLATED_SIDS_EX2 TranslatedSids;

} LSAP_DB_LOOKUP_NAMES_PARAMS, *PLSAP_DB_LOOKUP_NAMES_PARAMS;

//
// Types of Lookup Operation.
//

typedef enum {

    LookupSids = 1,
    LookupNames

} LSAP_DB_LOOKUP_TYPE, *PLSAP_DB_LOOKUP_TYPE;

//
// Work Item states - Assignable, Assigned, Completed, Reassign
//

typedef enum {

    AssignableWorkItem = 1,
    AssignedWorkItem,
    CompletedWorkItem,
    ReassignWorkItem,
    NonAssignableWorkItem

} LSAP_DB_LOOKUP_WORK_ITEM_STATE, *PLSAP_DB_LOOKUP_WORK_ITEM_STATE;

//
// Work Item Properties.
//

#define LSAP_DB_LOOKUP_WORK_ITEM_ISOL    ((ULONG) 0x00000001L)
#define LSAP_DB_LOOKUP_WORK_ITEM_XFOREST ((ULONG) 0x00000002L)

//
// Lookup Work Item.  Each work item specifies a domain and an array of
// Sids or Names to be looked up in that domain.  This array is specified
// as an array of the Sid or Name indices relevant to the arrays specified
// as parameters to the lookup call.
//

typedef struct _LSAP_DB_LOOKUP_WORK_ITEM {

    LIST_ENTRY Links;
    LSAP_DB_LOOKUP_WORK_ITEM_STATE State;
    ULONG Properties;
    LSAPR_TRUST_INFORMATION TrustInformation;
    LONG DomainIndex;
    ULONG UsedCount;
    ULONG MaximumCount;
    PULONG Indices;

} LSAP_DB_LOOKUP_WORK_ITEM, *PLSAP_DB_LOOKUP_WORK_ITEM;

//
// Lookup Work List State.
//

typedef enum {

    InactiveWorkList = 1,
    ActiveWorkList,
    CompletedWorkList

} LSAP_DB_LOOKUP_WORK_LIST_STATE, *PLSAP_DB_LOOKUP_WORK_LIST_STATE;

//
// Work List for a Lookup Operation.  These are linked together if
// concurrent lookups are permitted.
//

typedef struct _LSAP_DB_LOOKUP_WORK_LIST {

    LIST_ENTRY WorkLists;
    PLSAP_DB_LOOKUP_WORK_ITEM AnchorWorkItem;
    NTSTATUS Status;
    LSAP_DB_LOOKUP_WORK_LIST_STATE State;
    LSAP_DB_LOOKUP_TYPE LookupType;
    LSAPR_HANDLE PolicyHandle;
    ULONG WorkItemCount;
    ULONG CompletedWorkItemCount;
    ULONG Count;
    LSAP_LOOKUP_LEVEL LookupLevel;
    PLSAPR_REFERENCED_DOMAIN_LIST ReferencedDomains;
    PULONG MappedCount;
    PULONG CompletelyUnmappedCount;
    ULONG AdvisoryChildThreadCount;
    NTSTATUS NonFatalStatus;
    HANDLE   LookupCompleteEvent;

    union {

        LSAP_DB_LOOKUP_SIDS_PARAMS LookupSidsParams;
        LSAP_DB_LOOKUP_NAMES_PARAMS LookupNamesParams;
    };

    LSAP_DB_LOOKUP_WORK_ITEM DummyAnchorWorkItem;


} LSAP_DB_LOOKUP_WORK_LIST, *PLSAP_DB_LOOKUP_WORK_LIST;

//
// Lookup Operation Work Queue.  The Queue is a circular doubly linked
// list of Work Lists.  Each Work List corresponds to a single
// Lookup Operation (i.e. an LsarLookupSids or LsarLookupNames call).
// A Work List is a circular doubly linked list of Work Items, each
// of these being a list of Sids or Names belonging to a specific
// Trusted Domain.  Work Items can be given out to different threads.
//

typedef struct _LSAP_DB_LOOKUP_WORK_QUEUE {

    SAFE_CRITICAL_SECTION Lock;
    PLSAP_DB_LOOKUP_WORK_LIST AnchorWorkList;
    PLSAP_DB_LOOKUP_WORK_LIST CurrentAssignableWorkList;
    PLSAP_DB_LOOKUP_WORK_ITEM CurrentAssignableWorkItem;
    ULONG ActiveChildThreadCount;
    ULONG MaximumChildThreadCount;
    ULONG MaximumRetainedChildThreadCount;
    LSAP_DB_LOOKUP_WORK_LIST DummyAnchorWorkList;

} LSAP_DB_LOOKUP_WORK_QUEUE, *PLSAP_DB_LOOKUP_WORK_QUEUE;

static LSAP_DB_LOOKUP_WORK_QUEUE LookupWorkQueue;


//
// Index to table of the well known SIDs
//
// This type indexes the table of well-known Sids maintained by the LSA
//

typedef enum _LSAP_WELL_KNOWN_SID_INDEX {

    LsapNullSidIndex = 0,
    LsapWorldSidIndex,
    LsapLocalSidIndex,
    LsapCreatorOwnerSidIndex,
    LsapCreatorGroupSidIndex,
    LsapCreatorOwnerServerSidIndex,
    LsapCreatorGroupServerSidIndex,
    LsapNtAuthoritySidIndex,
    LsapDialupSidIndex,
    LsapNetworkSidIndex,
    LsapBatchSidIndex,
    LsapInteractiveSidIndex,
    LsapServiceSidIndex,
    LsapLogonSidIndex,
    LsapBuiltInDomainSidIndex,
    LsapLocalSystemSidIndex,
    LsapAliasAdminsSidIndex,
    LsapAliasUsersSidIndex,
    LsapAnonymousSidIndex,
    LsapProxySidIndex,
    LsapServerSidIndex,
    LsapSelfSidIndex,
    LsapAuthenticatedUserSidIndex,
    LsapRestrictedSidIndex,
    LsapInternetDomainIndex,
    LsapTerminalServerSidIndex,
    LsapLocalServiceSidIndex,
    LsapNetworkServiceSidIndex,
    LsapRemoteInteractiveSidIndex,
    LsapNTLMAuthenticationSidIndex,
    LsapDigestAuthenticationSidIndex,
    LsapSChannelAuthenticationSidIndex,
    LsapThisOrganizationSidIndex,
    LsapOtherOrganizationSidIndex,
    LsapDummyLastSidIndex

} LSAP_WELL_KNOWN_SID_INDEX, *PLSAP_WELL_KNOWN_SID_INDEX;


//
// Macro to identify SIDs the LSA should ignore for lookups (i.e., these
// lookups are always done by SAM since the alias name may change)
//

#define  SID_IS_RESOLVED_BY_SAM(SidIndex)    \
            (((SidIndex) == LsapAliasUsersSidIndex) || ((SidIndex) == LsapAliasAdminsSidIndex))


//
// Mnemonics for Universal well known SIDs.  These reference the corresponding
// entries in the Well Known Sids table.
//

#define LsapNullSid               WellKnownSids[LsapNullSidIndex].Sid
#define LsapWorldSid              WellKnownSids[LsapWorldSidIndex].Sid
#define LsapLocalSid              WellKnownSids[LsapLocalSidIndex].Sid
#define LsapCreatorOwnerSid       WellKnownSids[LsapCreatorOwnerSidIndex].Sid
#define LsapCreatorGroupSid       WellKnownSids[LsapCreatorGroupSidIndex].Sid
#define LsapCreatorOwnerServerSid WellKnownSids[LsapCreatorOwnerServerSidIndex].Sid
#define LsapCreatorGroupServerSid WellKnownSids[LsapCreatorGroupServerSidIndex].Sid

//
// Sids defined by NT
//

#define LsapNtAuthoritySid        WellKnownSids[LsapNtAuthoritySid].Sid

#define LsapDialupSid             WellKnownSids[LsapDialupSidIndex].Sid
#define LsapNetworkSid            WellKnownSids[LsapNetworkSidIndex].Sid
#define LsapBatchSid              WellKnownSids[LsapBatchSidIndex].Sid
#define LsapInteractiveSid        WellKnownSids[LsapInteractiveSidIndex].Sid
#define LsapServiceSid            WellKnownSids[LsapServiceSidIndex].Sid
#define LsapBuiltInDomainSid      WellKnownSids[LsapBuiltInDomainSidIndex].Sid
#define LsapLocalSystemSid        WellKnownSids[LsapLocalSystemSidIndex].Sid
#define LsapLocalServiceSid       WellKnownSids[LsapLocalServiceSidIndex].Sid
#define LsapNetworkServiceSid     WellKnownSids[LsapNetworkServiceSidIndex].Sid
#define LsapRemoteInteractiveSid  WellKnownSids[LsapRemoteInteractiveSidIndex].Sid

#define LsapRestrictedSid         WellKnownSids[LsapRestrictedSidIndex].Sid
#define LsapInternetDomainSid     WellKnownSids[LsapInternetDomainIndex].Sid
#define LsapAliasAdminsSid        WellKnownSids[LsapAliasAdminsSidIndex].Sid
#define LsapAliasUsersSid         WellKnownSids[LsapAliasUsersSidIndex].Sid

#define LsapAnonymousSid          WellKnownSids[LsapAnonymousSidIndex].Sid
#define LsapServerSid             WellKnownSids[LsapServerSidIndex].Sid
#define LsapSelfSid               WellKnownSids[LsapSelfSidIndex].Sid
#define LsapAuthenticatedUserSid  WellKnownSids[LsapAuthenticatedUserSidIndex].Sid

#define LsapTerminalServerSid     WellKnownSids[LsapTerminalServerSidIndex].Sid

#define LsapPackageNTLMSid        WellKnownSids[LsapNTLMAuthenticationSidIndex].Sid
#define LsapPackageDigestSid      WellKnownSids[LsapDigestAuthenticationSidIndex].Sid
#define LsapPackageSChannelSid    WellKnownSids[LsapSChannelAuthenticationSidIndex].Sid

#define LsapThisOrganizationSid   WellKnownSids[LsapThisOrganizationSidIndex].Sid
#define LsapOtherOrganizationSid  WellKnownSids[LsapOtherOrganizationSidIndex].Sid

                                                         

//
// Well known LUIDs
//

extern LUID LsapSystemLogonId;
extern LUID LsapZeroLogonId;

//
// Well known privilege values
//

extern LUID LsapTcbPrivilege;

//
// Well known identifier authority values
//

extern SID_IDENTIFIER_AUTHORITY    LsapNullSidAuthority;
extern SID_IDENTIFIER_AUTHORITY    LsapWorldSidAuthority;
extern SID_IDENTIFIER_AUTHORITY    LsapLocalSidAuthority;
extern SID_IDENTIFIER_AUTHORITY    LsapCreatorSidAuthority;
extern SID_IDENTIFIER_AUTHORITY    LsapNtAuthority;

//
// Maximum number of Subauthority levels for well known Sids
//

#define LSAP_WELL_KNOWN_MAX_SUBAUTH_LEVEL  ((ULONG) 0x00000003L)

//
// Constants relating to Sid's
//

#define LSAP_MAX_SUB_AUTH_COUNT        (0x00000010L)
#define LSAP_MAX_SIZE_TEXT_SUBA        (0x00000009L)
#define LSAP_MAX_SIZE_TEXT_SID_HDR     (0x00000020L)
#define LSAP_MAX_SIZE_TEXT_SID                               \
    (LSAP_MAX_SIZE_TEXT_SID_HDR +                            \
     (LSAP_MAX_SUB_AUTH_COUNT * LSAP_MAX_SIZE_TEXT_SUBA))


//
// Well Known Sid Table Entry
//

typedef struct _LSAP_WELL_KNOWN_SID_ENTRY {

    PSID Sid;
    SID_NAME_USE Use;
    UNICODE_STRING Name;
    UNICODE_STRING DomainName;

} LSAP_WELL_KNOWN_SID_ENTRY, *PLSAP_WELL_KNOWN_SID_ENTRY;

//
// Well Known Sid Table Pointer
//

extern PLSAP_WELL_KNOWN_SID_ENTRY WellKnownSids;

NTSTATUS
LsapDbLookupGetDomainInfo(
    OUT PPOLICY_ACCOUNT_DOMAIN_INFO *AccountDomainInfo,
    OUT PPOLICY_DNS_DOMAIN_INFO *DnsDomainInfo
    );


///////////////////////////////////////////////////////////////////////////
//                                                                       //
// Lookup Sids and Names - Private Function Definitions                  //
//                                                                       //
///////////////////////////////////////////////////////////////////////////

BOOLEAN
LsapDbInitializeWellKnownSids(
    OUT PLSAP_WELL_KNOWN_SID_ENTRY *WellKnownSids
    );

BOOLEAN
LsapDbInitializeWellKnownSid(
    OUT PLSAP_WELL_KNOWN_SID_ENTRY WellKnownSids,
    IN LSAP_WELL_KNOWN_SID_INDEX WellKnownSidIndex,
    IN PSID_IDENTIFIER_AUTHORITY IdentifierAuthority,
    IN UCHAR SubAuthorityCount,
    IN OPTIONAL PULONG SubAuthorities,
    IN PWSTR Name,
    IN PWSTR Description,
    IN SID_NAME_USE Use
    );

BOOLEAN
LsapDbLookupIndexWellKnownSid(
    IN PLSAPR_SID Sid,
    OUT PLSAP_WELL_KNOWN_SID_INDEX WellKnownSidIndex
    );

BOOLEAN
LsapDbLookupIndexWellKnownSidName(
    IN PLSAPR_UNICODE_STRING Name,
    OUT PLSAP_WELL_KNOWN_SID_INDEX WellKnownSidIndex
    );

NTSTATUS
LsapDbGetNameWellKnownSid(
    IN LSAP_WELL_KNOWN_SID_INDEX WellKnownSidIndex,
    OUT PLSAPR_UNICODE_STRING Name,
    OUT OPTIONAL PLSAPR_UNICODE_STRING DomainName
    );

NTSTATUS
LsapDbLookupIsolatedWellKnownSids(
    IN ULONG Count,
    IN PLSAPR_SID *Sids,
    IN OUT PLSAPR_REFERENCED_DOMAIN_LIST ReferencedDomains,
    IN OUT PLSAPR_TRANSLATED_NAMES_EX TranslatedNames,
    IN OUT PULONG MappedCount,
    IN OUT PULONG CompletelyUnmappedCount
    );

NTSTATUS
LsapDbLookupSidsInLocalDomains(
    IN ULONG Count,
    IN PLSAPR_SID *Sids,
    IN OUT PLSAPR_REFERENCED_DOMAIN_LIST ReferencedDomains,
    IN OUT PLSAPR_TRANSLATED_NAMES_EX TranslatedNames,
    IN OUT PULONG MappedCount,
    IN OUT PULONG CompletelyUnmappedCount,
    IN ULONG Options
    );

NTSTATUS
LsapDbLookupSidsInLocalDomain(
    IN ULONG LocalDomain,
    IN ULONG Count,
    IN PLSAPR_SID *Sids,
    IN PLSAPR_TRUST_INFORMATION TrustInformation,
    IN OUT PLSAPR_REFERENCED_DOMAIN_LIST ReferencedDomains,
    IN OUT PLSAPR_TRANSLATED_NAMES_EX TranslatedNames,
    IN OUT PULONG MappedCount,
    IN OUT PULONG CompletelyUnmappedCount
    );

NTSTATUS
LsapDbLookupSidsInPrimaryDomain(
    IN ULONG Count,
    IN PLSAPR_SID *Sids,
    IN PLSAPR_TRUST_INFORMATION TrustInformation,
    IN OUT PLSAPR_REFERENCED_DOMAIN_LIST ReferencedDomains,
    IN OUT PLSAPR_TRANSLATED_NAMES_EX TranslatedNames,
    IN LSAP_LOOKUP_LEVEL LookupLevel,
    IN OUT PULONG MappedCount,
    IN OUT PULONG CompletelyUnmappedCount,
    OUT NTSTATUS  *NonFatalStatus,
    OUT BOOLEAN   *fDownlevelSecureChannel
    );

NTSTATUS
LsapDbLookupSidsInTrustedDomains(
    IN ULONG Count,
    IN PLSAPR_SID *Sids,
    IN BOOLEAN    fIncludeIntraforest,
    IN OUT PLSAPR_REFERENCED_DOMAIN_LIST ReferencedDomains,
    IN OUT PLSAPR_TRANSLATED_NAMES_EX TranslatedNames,
    IN LSAP_LOOKUP_LEVEL LookupLevel,
    IN OUT PULONG MappedCount,
    IN OUT PULONG CompletelyUnmappedCount,
    OUT NTSTATUS *NonFatalStatus
    );

NTSTATUS
LsapDbLookupSidsInGlobalCatalog(
    IN ULONG Count,
    IN PLSAPR_SID *Sids,
    IN OUT PLSAPR_REFERENCED_DOMAIN_LIST ReferencedDomains,
    IN OUT PLSAPR_TRANSLATED_NAMES_EX TranslatedNames,
    IN OUT PULONG MappedCount,
    IN OUT PULONG CompletelyUnmappedCount,
    IN BOOLEAN    fDoSidHistory,
    OUT NTSTATUS *NonFatalStatus
    );


NTSTATUS
LsapDbLookupSidsInGlobalCatalogWks(
    IN ULONG Count,
    IN PLSAPR_SID *Sids,
    IN OUT PLSAPR_REFERENCED_DOMAIN_LIST ReferencedDomains,
    IN OUT PLSAPR_TRANSLATED_NAMES_EX TranslatedNames,
    IN OUT PULONG MappedCount,
    IN OUT PULONG CompletelyUnmappedCount,
    OUT NTSTATUS *NonFatalStatus
    );

NTSTATUS
LsapDbLookupSidsInDomainList(
    IN ULONG Count,
    IN PLSAPR_SID *Sids,
    IN OUT PLSAPR_REFERENCED_DOMAIN_LIST ReferencedDomains,
    IN OUT PLSAPR_TRANSLATED_NAMES_EX TranslatedNames,
    IN OUT PULONG MappedCount,
    IN OUT PULONG CompletelyUnmappedCount
    );

NTSTATUS
LsapDbLookupTranslateUnknownSids(
    IN ULONG Count,
    IN PLSAPR_SID *Sids,
    IN PLSAPR_REFERENCED_DOMAIN_LIST ReferencedDomains,
    IN OUT PLSAPR_TRANSLATED_NAMES_EX TranslatedNames,
    IN ULONG MappedCount
    );

NTSTATUS
LsapDbLookupTranslateUnknownSidsInDomain(
    IN ULONG Count,
    IN PLSAPR_SID *Sids,
    IN PLSAPR_TRUST_INFORMATION TrustInformation,
    IN OUT PLSAPR_REFERENCED_DOMAIN_LIST ReferencedDomains,
    IN OUT PLSAPR_TRANSLATED_NAMES_EX TranslatedNames,
    IN LSAP_LOOKUP_LEVEL LookupLevel,
    IN OUT PULONG MappedCount,
    IN OUT PULONG CompletelyUnmappedCount
    );

NTSTATUS
LsapDbLookupSimpleNames(
    IN ULONG Count,
    IN ULONG LookupLevel,
    IN PLSAPR_UNICODE_STRING Names,
    IN PLSAPR_UNICODE_STRING PrefixNames,
    IN PLSAPR_UNICODE_STRING SuffixNames,
    IN PLSAPR_TRUST_INFORMATION BuiltInDomainTrustInformation,
    IN PLSAPR_TRUST_INFORMATION_EX AccountDomainTrustInformation,
    IN PLSAPR_TRUST_INFORMATION_EX PrimaryDomainTrustInformation,
    IN OUT PLSAPR_REFERENCED_DOMAIN_LIST ReferencedDomains,
    IN OUT PLSAPR_TRANSLATED_SIDS_EX2 TranslatedSids,
    IN OUT PULONG MappedCount,
    IN OUT PULONG CompletelyUnmappedCount
    );

NTSTATUS
LsapDbLookupWellKnownNames(
    IN ULONG Count,
    IN PLSAPR_UNICODE_STRING Names,
    IN PLSAPR_UNICODE_STRING PrefixNames,
    IN PLSAPR_UNICODE_STRING SuffixNames,
    IN OUT PLSAPR_REFERENCED_DOMAIN_LIST ReferencedDomains,
    IN OUT PLSAPR_TRANSLATED_SIDS_EX2 TranslatedSids,
    IN OUT PULONG MappedCount,
    IN OUT PULONG CompletelyUnmappedCount
    );

NTSTATUS
LsapDbLookupIsolatedDomainNames(
    IN ULONG Count,
    IN PLSAPR_UNICODE_STRING Names,
    IN PLSAPR_UNICODE_STRING PrefixNames,
    IN PLSAPR_UNICODE_STRING SuffixNames,
    IN PLSAPR_TRUST_INFORMATION BuiltInDomainTrustInformation,
    IN PLSAPR_TRUST_INFORMATION_EX AccountDomainTrustInformation,
    IN PLSAPR_TRUST_INFORMATION_EX PrimaryDomainTrustInformation,
    IN OUT PLSAPR_REFERENCED_DOMAIN_LIST ReferencedDomains,
    IN OUT PLSAPR_TRANSLATED_SIDS_EX2 TranslatedSids,
    IN OUT PULONG MappedCount,
    IN OUT PULONG CompletelyUnmappedCount
    );

NTSTATUS
LsapDbLookupIsolatedDomainName(
    IN ULONG NameIndex,
    IN PLSAPR_UNICODE_STRING IsolatedName,
    IN PLSAPR_TRUST_INFORMATION TrustInformation,
    IN OUT PLSAPR_REFERENCED_DOMAIN_LIST ReferencedDomains,
    IN OUT PLSAPR_TRANSLATED_SIDS_EX2 TranslatedSids,
    IN OUT PULONG MappedCount,
    IN OUT PULONG CompletelyUnmappedCount
    );

NTSTATUS
LsapDbLookupIsolatedDomainNameEx(
    IN ULONG NameIndex,
    IN PLSAPR_UNICODE_STRING IsolatedName,
    IN PLSAPR_TRUST_INFORMATION_EX TrustInformation,
    IN OUT PLSAPR_REFERENCED_DOMAIN_LIST ReferencedDomains,
    IN OUT PLSAPR_TRANSLATED_SIDS_EX2 TranslatedSids,
    IN OUT PULONG MappedCount,
    IN OUT PULONG CompletelyUnmappedCount
    );

NTSTATUS
LsapDbLookupNamesInLocalDomains(
    IN ULONG Count,
    IN PLSAPR_UNICODE_STRING Names,
    IN PLSAPR_UNICODE_STRING PrefixNames,
    IN PLSAPR_UNICODE_STRING SuffixNames,
    IN PLSAPR_TRUST_INFORMATION BuiltInDomainTrustInformation,
    IN PLSAPR_TRUST_INFORMATION_EX AccountDomainTrustInformation,
    IN OUT PLSAPR_REFERENCED_DOMAIN_LIST ReferencedDomains,
    IN OUT PLSAPR_TRANSLATED_SIDS_EX2 TranslatedSids,
    IN OUT PULONG MappedCount,
    IN OUT PULONG CompletelyUnmappedCount,
    IN ULONG Options
    );

NTSTATUS
LsapDbLookupNamesInLocalDomain(
    IN ULONG LocalDomain,
    IN ULONG Count,
    IN PLSAPR_UNICODE_STRING PrefixNames,
    IN PLSAPR_UNICODE_STRING SuffixNames,
    IN PLSAPR_TRUST_INFORMATION TrustInformation,
    IN OUT PLSAPR_REFERENCED_DOMAIN_LIST ReferencedDomains,
    IN OUT PLSAPR_TRANSLATED_SIDS_EX2 TranslatedSids,
    IN OUT PULONG MappedCount,
    IN OUT PULONG CompletelyUnmappedCount
    );

NTSTATUS
LsapDbLookupNamesInLocalDomainEx(
    IN ULONG LocalDomain,
    IN ULONG Count,
    IN PLSAPR_UNICODE_STRING PrefixNames,
    IN PLSAPR_UNICODE_STRING SuffixNames,
    IN PLSAPR_TRUST_INFORMATION_EX TrustInformationEx,
    IN OUT PLSAPR_REFERENCED_DOMAIN_LIST ReferencedDomains,
    IN OUT PLSAPR_TRANSLATED_SIDS_EX2 TranslatedSids,
    IN OUT PULONG MappedCount,
    IN OUT PULONG CompletelyUnmappedCount
    );

NTSTATUS
LsapDbLookupNamesInPrimaryDomain(
    IN ULONG LookupOptions,
    IN ULONG Count,
    IN PLSAPR_UNICODE_STRING Names,
    IN PLSAPR_UNICODE_STRING PrefixNames,
    IN PLSAPR_UNICODE_STRING SuffixNames,
    IN PLSAPR_TRUST_INFORMATION_EX TrustInformation,
    IN OUT PLSAPR_REFERENCED_DOMAIN_LIST ReferencedDomains,
    IN OUT PLSAPR_TRANSLATED_SIDS_EX2 TranslatedSids,
    IN LSAP_LOOKUP_LEVEL LookupLevel,
    IN OUT PULONG MappedCount,
    IN OUT PULONG CompletelyUnmappedCount,
    OUT BOOLEAN  *fDownlevelSecureChannel,
    OUT NTSTATUS *NonFatalStatus
    );

NTSTATUS
LsapDbLookupNamesInTrustedDomains(
    IN ULONG LookupOptions,
    IN ULONG Count,
    IN BOOLEAN fIncludeIntraforest,
    IN PLSAPR_UNICODE_STRING Names,
    IN PLSAPR_UNICODE_STRING PrefixNames,
    IN PLSAPR_UNICODE_STRING SuffixNames,
    IN OUT PLSAPR_REFERENCED_DOMAIN_LIST ReferencedDomains,
    IN OUT PLSAPR_TRANSLATED_SIDS_EX2 TranslatedSids,
    IN LSAP_LOOKUP_LEVEL LookupLevel,
    IN OUT PULONG MappedCount,
    IN OUT PULONG CompletelyUnmappedCount,
    OUT NTSTATUS *NonFatalStatus
    );

NTSTATUS
LsapDbLookupNamesInGlobalCatalog(
    IN ULONG LookupOptions,
    IN ULONG Count,
    IN PLSAPR_UNICODE_STRING Names,
    IN PLSAPR_UNICODE_STRING PrefixNames,
    IN PLSAPR_UNICODE_STRING SuffixNames,
    IN OUT PLSAPR_REFERENCED_DOMAIN_LIST ReferencedDomains,
    IN OUT PLSAPR_TRANSLATED_SIDS_EX2 TranslatedSids,
    IN OUT PULONG MappedCount,
    IN OUT PULONG CompletelyUnmappedCount,
    OUT NTSTATUS *NonFatalStatus
    );

NTSTATUS
LsapDbLookupNamesInGlobalCatalogWks(
    IN ULONG LookupOptions,
    IN ULONG Count,
    IN PLSAPR_UNICODE_STRING Names,
    IN PLSAPR_UNICODE_STRING PrefixNames,
    IN PLSAPR_UNICODE_STRING SuffixNames,
    IN OUT PLSAPR_REFERENCED_DOMAIN_LIST ReferencedDomains,
    IN OUT PLSAPR_TRANSLATED_SIDS_EX2 TranslatedSids,
    IN OUT PULONG MappedCount,
    IN OUT PULONG CompletelyUnmappedCount,
    OUT NTSTATUS *NonFatalStatus
    );

NTSTATUS
LsapDbLookupTranslateNameDomain(
    IN PLSAPR_TRUST_INFORMATION TrustInformation,
    IN OPTIONAL PLSA_TRANSLATED_SID_EX2 TranslatedSid,
    IN OUT PLSAPR_REFERENCED_DOMAIN_LIST ReferencedDomains,
    OUT PLONG DomainIndex
    );

NTSTATUS
LsapDbLookupTranslateUnknownNames(
    IN ULONG Count,
    IN PLSAPR_UNICODE_STRING Names,
    IN PLSAPR_UNICODE_STRING PrefixNames,
    IN PLSAPR_UNICODE_STRING SuffixNames,
    IN PLSAPR_REFERENCED_DOMAIN_LIST ReferencedDomains,
    IN OUT PLSAPR_TRANSLATED_SIDS_EX2 TranslatedSids,
    IN ULONG MappedCount
    );

NTSTATUS
LsapDbLookupTranslateUnknownNamesInDomain(
    IN ULONG Count,
    IN PLSAPR_UNICODE_STRING Names,
    IN PLSAPR_UNICODE_STRING PrefixNames,
    IN PLSAPR_UNICODE_STRING SuffixNames,
    IN PLSAPR_TRUST_INFORMATION_EX TrustInformationEx,
    IN OUT PLSAPR_REFERENCED_DOMAIN_LIST ReferencedDomains,
    IN OUT PLSAPR_TRANSLATED_SIDS_EX2 TranslatedSids,
    IN LSAP_LOOKUP_LEVEL LookupLevel,
    IN OUT PULONG MappedCount,
    IN OUT PULONG CompletelyUnmappedCount
    );

NTSTATUS
LsapDbLookupDispatchWorkerThreads(
    IN OUT PLSAP_DB_LOOKUP_WORK_LIST WorkList
    );

NTSTATUS
LsapRtlValidateControllerTrustedDomain(
    IN PLSAPR_UNICODE_STRING DomainControllerName,
    IN PLSAPR_TRUST_INFORMATION TrustInformation,
    IN ACCESS_MASK DesiredAccess,
    IN LPWSTR ServerPrincipalName,
    IN PVOID ClientContext,
    OUT PLSA_HANDLE PolicyHandle
    );

NTSTATUS
LsapDbLookupCreateListReferencedDomains(
    OUT PLSAPR_REFERENCED_DOMAIN_LIST *ReferencedDomains,
    IN ULONG InitialMaxEntries
    );

NTSTATUS
LsapDbLookupAddListReferencedDomains(
    IN OUT PLSAPR_REFERENCED_DOMAIN_LIST ReferencedDomains,
    IN PLSAPR_TRUST_INFORMATION TrustInformation,
    OUT PLONG DomainIndex
    );

BOOLEAN
LsapDbLookupListReferencedDomains(
    IN PLSAPR_REFERENCED_DOMAIN_LIST ReferencedDomains,
    IN PLSAPR_SID DomainSid,
    OUT PLONG DomainIndex
    );

NTSTATUS
LsapDbLookupGrowListReferencedDomains(
    IN OUT PLSAPR_REFERENCED_DOMAIN_LIST ReferencedDomains,
    IN ULONG MaximumEntries
    );

NTSTATUS
LsapDbLookupMergeDisjointReferencedDomains(
    IN OPTIONAL PLSAPR_REFERENCED_DOMAIN_LIST FirstReferencedDomainList,
    IN OPTIONAL PLSAPR_REFERENCED_DOMAIN_LIST SecondReferencedDomainList,
    OUT PLSAPR_REFERENCED_DOMAIN_LIST *OutputReferencedDomainList,
    IN ULONG Options
    );

NTSTATUS
LsapDbLookupInitialize(
    );

NTSTATUS
LsapDbLookupInitializeWorkQueue(
    );

NTSTATUS
LsapDbLookupInitializeWorkList(
    OUT PLSAP_DB_LOOKUP_WORK_LIST WorkList
    );

NTSTATUS
LsapDbLookupInitializeWorkItem(
    OUT PLSAP_DB_LOOKUP_WORK_ITEM WorkItem
    );

NTSTATUS
LsapDbLookupAcquireWorkQueueLock(
    );

VOID LsapDbLookupReleaseWorkQueueLock();

NTSTATUS
LsapDbLookupLocalDomains(
    OUT PLSAPR_TRUST_INFORMATION BuiltInDomainTrustInformation,
    OUT PLSAPR_TRUST_INFORMATION_EX AccountDomainTrustInformation,
    OUT PLSAPR_TRUST_INFORMATION_EX PrimaryDomainTrustInformation
    );

NTSTATUS
LsapDbLookupNamesBuildWorkList(
    IN ULONG LookupOptions,
    IN ULONG Count,
    IN BOOLEAN fIncludeIntraforest,
    IN PLSAPR_UNICODE_STRING Names,
    IN PLSAPR_UNICODE_STRING PrefixNames,
    IN PLSAPR_UNICODE_STRING SuffixNames,
    IN PLSAPR_REFERENCED_DOMAIN_LIST ReferencedDomains,
    IN PLSAPR_TRANSLATED_SIDS_EX2 TranslatedSids,
    IN LSAP_LOOKUP_LEVEL LookupLevel,
    IN OUT PULONG MappedCount,
    IN OUT PULONG CompletelyUnmappedCount,
    OUT PLSAP_DB_LOOKUP_WORK_LIST *WorkList
    );

NTSTATUS
LsapDbLookupSidsBuildWorkList(
    IN ULONG Count,
    IN PLSAPR_SID *Sids,
    IN BOOLEAN fIncludeIntraforest,
    IN PLSAPR_REFERENCED_DOMAIN_LIST ReferencedDomains,
    IN PLSAPR_TRANSLATED_NAMES_EX TranslatedNames,
    IN LSAP_LOOKUP_LEVEL LookupLevel,
    IN OUT PULONG MappedCount,
    IN OUT PULONG CompletelyUnmappedCount,
    OUT PLSAP_DB_LOOKUP_WORK_LIST *WorkList
    );

NTSTATUS
LsapDbLookupCreateWorkList(
    OUT PLSAP_DB_LOOKUP_WORK_LIST *WorkList
    );

NTSTATUS
LsapDbLookupInsertWorkList(
    IN PLSAP_DB_LOOKUP_WORK_LIST WorkList
    );

NTSTATUS
LsapDbLookupDeleteWorkList(
    IN PLSAP_DB_LOOKUP_WORK_LIST WorkList
    );

NTSTATUS
LsapDbLookupSignalCompletionWorkList(
    IN OUT PLSAP_DB_LOOKUP_WORK_LIST WorkList
    );

NTSTATUS
LsapDbLookupAwaitCompletionWorkList(
    IN OUT PLSAP_DB_LOOKUP_WORK_LIST WorkList
    );

NTSTATUS
LsapDbAddWorkItemToWorkList(
    IN OUT PLSAP_DB_LOOKUP_WORK_LIST WorkList,
    IN PLSAP_DB_LOOKUP_WORK_ITEM WorkItem
    );

NTSTATUS
LsapDbLookupStopProcessingWorkList(
    IN PLSAP_DB_LOOKUP_WORK_LIST WorkList,
    IN NTSTATUS TerminationStatus
    );

VOID
LsapDbUpdateMappedCountsWorkList(
    IN OUT PLSAP_DB_LOOKUP_WORK_LIST WorkList
    );

NTSTATUS
LsapDbLookupNamesUpdateTranslatedSids(
    IN OUT PLSAP_DB_LOOKUP_WORK_LIST WorkList,
    IN OUT PLSAP_DB_LOOKUP_WORK_ITEM WorkItem,
    IN PLSAPR_TRANSLATED_SID_EX2 TranslatedSids,
    IN PLSAPR_REFERENCED_DOMAIN_LIST ReferencedDomains
    );

NTSTATUS
LsapDbLookupSidsUpdateTranslatedNames(
    IN OUT PLSAP_DB_LOOKUP_WORK_LIST WorkList,
    IN OUT PLSAP_DB_LOOKUP_WORK_ITEM WorkItem,
    IN PLSA_TRANSLATED_NAME_EX TranslatedNames,
    IN PLSAPR_REFERENCED_DOMAIN_LIST ReferencedDomains
    );

VOID
LsapDbLookupWorkerThreadStart(
    );

VOID
LsapDbLookupWorkerThread(
    IN BOOLEAN PrimaryThread
    );

NTSTATUS
LsapDbLookupObtainWorkItem(
    OUT PLSAP_DB_LOOKUP_WORK_LIST *WorkList,
    OUT PLSAP_DB_LOOKUP_WORK_ITEM *WorkItem
    );

NTSTATUS
LsapDbLookupProcessWorkItem(
    IN OUT PLSAP_DB_LOOKUP_WORK_LIST WorkList,
    IN OUT PLSAP_DB_LOOKUP_WORK_ITEM WorkItem
    );

NTSTATUS
LsapDbLookupCreateWorkItem(
    IN PLSAPR_TRUST_INFORMATION TrustInformation,
    IN LONG DomainIndex,
    IN ULONG MaximumEntryCount,
    OUT PLSAP_DB_LOOKUP_WORK_ITEM *WorkItem
    );

NTSTATUS
LsapDbLookupAddIndicesToWorkItem(
    IN OUT PLSAP_DB_LOOKUP_WORK_ITEM WorkItem,
    IN ULONG Count,
    IN PULONG Indices
    );

NTSTATUS
LsapDbLookupComputeAdvisoryChildThreadCount(
    IN OUT PLSAP_DB_LOOKUP_WORK_LIST WorkList
    );

NTSTATUS
LsapDbLookupUpdateAssignableWorkItem(
    IN BOOLEAN MoveToNextWorkList
    );


NTSTATUS
LsapRtlExtractDomainSid(
    IN PSID Sid,
    OUT PSID *DomainSid
    );

VOID LsapDbLookupReturnThreadToPool();


/*++

PSID
LsapDbWellKnownSid(
    IN LSAP_WELL_KNOWN_SID_INDEX WellKnownSidIndex
    )

Routine Description:

    This macro function returns the Well Known Sid corresponding
    to an index into the Well Known Sid table.

Arguments:

    WellKnownSidIndex - Index into the Well Known Sid information table.
    It is the caller's responsibility to ensure that the given index
    is valid.

Return Value:

--*/

#define LsapDbWellKnownSid( WellKnownSidIndex )                         \
    (WellKnownSids[ WellKnownSidIndex ].Sid)

PUNICODE_STRING
LsapDbWellKnownSidName(
    IN LSAP_WELL_KNOWN_SID_INDEX WellKnownSidIndex
    );


/*++

SID_NAME_USE
LsapDbWellKnownSidNameUse(
    IN LSAP_DB_WELL_KNOWN_SID_INDEX WellKnownSidIndex
    )


Routine Description:

    This macro function returns the Sid Name Use of a Well Known Sid.

Arguments:

    WellKnownSidIndex - Index into the Well Known Sid information table.
    It is the caller's responsibility to ensure that the given index
    is valid.

Return Value:

--*/

#define LsapDbWellKnownSidNameUse( WellKnownSidIndex )                       \
    (WellKnownSids[ WellKnownSidIndex ].Use)


VOID
LsapDbUpdateCountCompUnmappedNames(
    OUT PLSAPR_TRANSLATED_SIDS_EX2 TranslatedSids,
    IN OUT PULONG CompletelyUnmappedCount
    );

/*++

PUNICODE_STRING
LsapDbWellKnownSidDescription(
    IN LSAP_WELL_KNOWN_SID_INDEX WellKnownSidIndex
    )

Routine Description:

    This macro function returns the Unicode Description of a Well Known Sid.

Arguments:

    WellKnownSidIndex - Index into the Well Known Sid information table.
    It is the caller's responsibility to ensure that the given index
    is valid.

Return Value:

--*/

#define LsapDbWellKnownSidDescription( WellKnownSidIndex )                         \
    (&(WellKnownSids[ WellKnownSidIndex ].DomainName))


PUNICODE_STRING
LsapDbWellKnownSidName(
    IN LSAP_WELL_KNOWN_SID_INDEX WellKnownSidIndex
    );

#define LsapDbAccessedBySidObject( ObjectTypeId ) \
    (LsapDbState.DbObjectTypes[ ObjectTypeId ].AccessedBySid)

#define LsapDbAccessedByNameObject( ObjectTypeId ) \
    (LsapDbState.DbObjectTypes[ ObjectTypeId ].AccessedByName)

#define LsapDbCompletelyUnmappedName(TranslatedName)                \
    (((TranslatedName)->DomainIndex == LSA_UNKNOWN_INDEX) &&        \
     ((TranslatedName)->Use == SidTypeUnknown))

#define LsapDbCompletelyUnmappedSid(TranslatedSid)                  \
    (((TranslatedSid)->DomainIndex == LSA_UNKNOWN_INDEX) &&         \
     ((TranslatedSid)->Use == SidTypeUnknown))


NTSTATUS
LsapGetDomainSidByNetbiosName(
    IN LPWSTR NetbiosName,
    OUT PSID *Sid
    );

NTSTATUS
LsapGetDomainSidByDnsName(
    IN LPWSTR DnsName,
    OUT PSID *Sid
    );

NTSTATUS
LsapGetDomainNameBySid(
    IN  PSID Sid,
    OUT PUNICODE_STRING DomainName
    );

VOID
LsapConvertTrustToEx(
    IN OUT PLSAPR_TRUST_INFORMATION_EX TrustInformationEx,
    IN PLSAPR_TRUST_INFORMATION TrustInformation
    );

VOID
LsapConvertExTrustToOriginal(
    IN OUT PLSAPR_TRUST_INFORMATION TrustInformation,
    IN PLSAPR_TRUST_INFORMATION_EX TrustInformationEx
    );

NTSTATUS
LsapDbOpenPolicyGc (
    OUT HANDLE *LsaPolicyHandle                        
    );


BOOLEAN
LsapRevisionCanHandleNewErrorCodes(
    IN ULONG Revision
    );

BOOLEAN
LsapIsDsDomainByNetbiosName(
    WCHAR *NetbiosName
    );

BOOLEAN
LsapIsBuiltinDomain(
    IN PSID Sid
    );

BOOLEAN
LsapDbIsStatusConnectionFailure(
    NTSTATUS st
    );

NTSTATUS
LsapDbLookupAccessCheck(
    IN LSAPR_HANDLE PolicyHandle
    );

NTSTATUS
LsapDbLookupXForestNamesBuildWorkList(
    IN ULONG Count,
    IN PLSAPR_UNICODE_STRING Names,
    IN PLSAPR_UNICODE_STRING PrefixNames,
    IN PLSAPR_UNICODE_STRING SuffixNames,
    IN PLSAPR_REFERENCED_DOMAIN_LIST ReferencedDomains,
    IN OUT PLSAPR_TRANSLATED_SIDS_EX2 TranslatedSids,
    IN LSAP_LOOKUP_LEVEL LookupLevel,
    IN OUT PULONG MappedCount,
    IN OUT PULONG CompletelyUnmappedCount,
    OUT PLSAP_DB_LOOKUP_WORK_LIST *WorkList
    );

NTSTATUS
LsapDbLookupXForestSidsBuildWorkList(
    IN ULONG Count,
    IN PLSAPR_SID *Sids,
    IN PLSAPR_REFERENCED_DOMAIN_LIST ReferencedDomains,
    IN PLSAPR_TRANSLATED_NAMES_EX TranslatedNames,
    IN LSAP_LOOKUP_LEVEL LookupLevel,
    IN OUT PULONG MappedCount,
    IN OUT PULONG CompletelyUnmappedCount,
    OUT PLSAP_DB_LOOKUP_WORK_LIST *WorkList
    );

NTSTATUS
LsaICLookupNamesWithCreds(
    IN LPWSTR ServerName,
    IN LPWSTR ServerPrincipalName,
    IN ULONG  AuthnLevel,
    IN ULONG  AuthnSvc,
    IN RPC_AUTH_IDENTITY_HANDLE AuthIdentity,
    IN ULONG  AuthzSvc,
    IN ULONG Count,
    IN PUNICODE_STRING Names,
    OUT PLSA_REFERENCED_DOMAIN_LIST *ReferencedDomains,
    OUT PLSA_TRANSLATED_SID_EX2 *Sids,
    IN LSAP_LOOKUP_LEVEL LookupLevel,
    IN OUT PULONG MappedCount
    );


NTSTATUS
LsaICLookupSidsWithCreds(
    IN LPWSTR ServerName,
    IN LPWSTR ServerPrincipalName,
    IN ULONG  AuthnLevel,
    IN ULONG  AuthnSvc,
    IN RPC_AUTH_IDENTITY_HANDLE AuthIdentity,
    IN ULONG  AuthzSvc,
    IN ULONG Count,
    IN PSID *Sids,
    OUT PLSA_REFERENCED_DOMAIN_LIST *ReferencedDomains,
    OUT PLSA_TRANSLATED_NAME_EX *Names,
    IN LSAP_LOOKUP_LEVEL LookupLevel,
    IN OUT PULONG MappedCount
    );

NTSTATUS
LsapDbLookupNameChainRequest(
    IN LSAPR_TRUST_INFORMATION_EX *TrustInfo,
    IN ULONG Count,
    IN PUNICODE_STRING Names,
    OUT PLSA_REFERENCED_DOMAIN_LIST *ReferencedDomains,
    OUT PLSA_TRANSLATED_SID_EX2 *Sids,
    IN LSAP_LOOKUP_LEVEL LookupLevel,
    OUT PULONG MappedCount,
    OUT PULONG ServerRevision OPTIONAL
    );

NTSTATUS
LsaDbLookupSidChainRequest(
    IN LSAPR_TRUST_INFORMATION_EX *TrustInfo,
    IN ULONG Count,
    IN PSID *Sids,
    OUT PLSA_REFERENCED_DOMAIN_LIST *ReferencedDomains,
    OUT PLSA_TRANSLATED_NAME_EX *Names,
    IN LSAP_LOOKUP_LEVEL LookupLevel,
    IN OUT PULONG MappedCount,
    OUT PULONG ServerRevision OPTIONAL
    );

LPWSTR
LsapDbLookupGetLevel(
    IN LSAP_LOOKUP_LEVEL LookupLevel
    );

#define LsapDbLookupReportEvent0(a, b, c, d, e) \
    if (a <= LsapLookupLogLevel) {SpmpReportEvent( TRUE, b, c, 0, d, e, 0);}

#define LsapDbLookupReportEvent1(a, b, c, d, e, f) \
    if (a <= LsapLookupLogLevel) {SpmpReportEvent( TRUE, b, c, 0, d, e, 1, f);}

#define LsapDbLookupReportEvent2(a, b, c, d, e, f, g) \
    if (a <= LsapLookupLogLevel) {SpmpReportEvent( TRUE, b, c, 0, d, e, 2, f, g);}

#define LsapDbLookupReportEvent3(a, b, c, d, e, f, g, h) \
    if (a <= LsapLookupLogLevel) {SpmpReportEvent( TRUE, b, c, 0, d, e, 3, f, g, h);}

NTSTATUS
LsapLookupReallocateTranslations(
    IN OUT PLSA_REFERENCED_DOMAIN_LIST *ReferencedDomains,
    IN     ULONG Count,
    IN OUT PLSA_TRANSLATED_NAME_EX *Names, OPTIONAL
    IN OUT PLSA_TRANSLATED_SID_EX2 *Sids  OPTIONAL
    );

//
// BOOLEAN
// LsapOutboundTrustedDomain(
//  PLSAP_DB_TRUSTED_DOMAIN_LIST_ENTRY x
//  );
//
// This routine returns TRUE if x is a trust to a domain
//
#define LsapOutboundTrustedDomain(x)                                           \
   (  ((x)->TrustInfoEx.TrustType == TRUST_TYPE_UPLEVEL                        \
   ||  (x)->TrustInfoEx.TrustType == TRUST_TYPE_DOWNLEVEL )                    \
   && ((x)->TrustInfoEx.Sid != NULL)                                           \
   && ((x)->TrustInfoEx.TrustDirection & TRUST_DIRECTION_OUTBOUND)             \
   && (((x)->TrustInfoEx.TrustAttributes & TRUST_ATTRIBUTE_FOREST_TRANSITIVE)  \
      == 0))

//
// BOOLEAN
// LsapOutboundTrustedForest(
//  PLSAP_DB_TRUSTED_DOMAIN_LIST_ENTRY x
//  );
//
// This routine returns TRUE if x is a trust to a forest
//
#define LsapOutboundTrustedForest(x)                                           \
   (  ((x)->TrustInfoEx.TrustType == TRUST_TYPE_UPLEVEL)                       \
   && ((x)->TrustInfoEx.Sid != NULL)                                           \
   && ((x)->TrustInfoEx.TrustDirection & TRUST_DIRECTION_OUTBOUND)             \
   && ((x)->TrustInfoEx.TrustAttributes & TRUST_ATTRIBUTE_FOREST_TRANSITIVE))  \



//
// Return values from LsapGetDomainLookupScope
//

//
// Scope is domains that we directly trust
//
#define LSAP_LOOKUP_TRUSTED_DOMAIN_DIRECT       0x00000001

//
// Scope is domains that we transitively trust
//
#define LSAP_LOOKUP_TRUSTED_DOMAIN_TRANSITIVE   0x00000002

//
// Scope is domains that we trust via forest trust
//
#define LSAP_LOOKUP_TRUSTED_FOREST              0x00000004

//
// Scope includes to lookup trusted forest domains locally
//
#define LSAP_LOOKUP_TRUSTED_FOREST_ROOT         0x00000008

//
// Allow lookups of DNS names
//
#define LSAP_LOOKUP_DNS_SUPPORT                 0x00000010

ULONG
LsapGetDomainLookupScope(
    IN LSAP_LOOKUP_LEVEL LookupLevel,
    IN ULONG             ClientRevision
    );

//
// Useful combinations
//
#define LSAP_LOOKUP_RESOLVE_ISOLATED_DOMAINS          \
            (LSAP_LOOKUP_TRUSTED_DOMAIN_DIRECT     |  \
             LSAP_LOOKUP_TRUSTED_DOMAIN_TRANSITIVE |  \
             LSAP_LOOKUP_TRUSTED_FOREST_ROOT)

NTSTATUS
LsapDbLookupNamesAsDomainNames(
    IN ULONG Flags,
    IN ULONG Count,
    IN PLSAPR_UNICODE_STRING Names,
    IN PLSAPR_UNICODE_STRING PrefixNames,
    IN PLSAPR_UNICODE_STRING SuffixNames,
    IN OUT PLSAPR_REFERENCED_DOMAIN_LIST ReferencedDomains,
    IN OUT PLSAPR_TRANSLATED_SIDS_EX2 TranslatedSids,
    IN OUT PULONG MappedCount
    );

NTSTATUS
LsapDbLookupSidsAsDomainSids(
    IN ULONG Flags,
    IN ULONG Count,
    IN PLSAPR_SID *Sids,
    IN OUT PLSAPR_REFERENCED_DOMAIN_LIST ReferencedDomains,
    IN OUT PLSAPR_TRANSLATED_NAMES_EX TranslatedNames,
    IN OUT PULONG MappedCount
    );

BOOLEAN 
LsapCompareDomainNames( 
    IN PUNICODE_STRING String,
    IN PUNICODE_STRING AmbiguousName,
    IN PUNICODE_STRING FlatName OPTIONAL
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\base\lsa\server\efscert.cxx ===
/*++

Copyright (c) 1997-1999  Microsoft Corporation

Module Name:

    efscert.cxx

Abstract:

    EFS Certificate management code

Author:

    Robert Reichel      (RobertRe)     July 4, 1997
    Robert Gu           (RobertG)      Dec. 4, 1997

Environment:

Revision History:

--*/

#include <lsapch.hxx>

extern "C" {
#include <nt.h>
#include <ntdef.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <stdio.h>
#include <wincrypt.h>
#include <efsstruc.h>
#include "lsasrvp.h"
#include "debug.h"
#include "efssrv.hxx"
#include "userkey.h"
}

//#define ProfilingEfs


/////////////////////////////////////////////////////////////////////////////////////
//                                                                                  /
//                                                                                  /
//                              Helper Functions                                    /
//                                                                                  /
//                                                                                  /
/////////////////////////////////////////////////////////////////////////////////////

PCCERT_CONTEXT
GetCertContextFromCertHash(
    IN PBYTE pbHash,
    IN DWORD cbHash,
    IN DWORD dwFlags,
    IN DWORD dwOpen
    )

/*++

Routine Description:

    Finds the cert with the passed cert hash in the user's MY store
    and returns a context pointer.

Arguments:

    pbHash - Supplies a pointer to the hash to be matched.

    cbHash - Supplies the length in bytes of the passed hash.
    
    dwFlags - Supplies flags to CertOpenStore
    
    dwOpen - 0 if not in the file open path

Return Value:

    Returns a pointer to a certificate context, or NULL.
    The returned context must be freed via CertFreeCertificateContext()

--*/

{
    CRYPT_HASH_BLOB hashBlob;
    BOOL            OidFound;
    PCCERT_CONTEXT pCertContext = NULL;
    DWORD          rc = ERROR_SUCCESS;

    //HCERTSTORE hStore = CertOpenSystemStoreW( NULL, L"MY");

#ifdef ProfilingEfs

LARGE_INTEGER  StartTime;
LARGE_INTEGER  StopTime;


NtQuerySystemTime(&StartTime);
#endif

    HCERTSTORE hStore = CertOpenStore(
                            CERT_STORE_PROV_SYSTEM_REGISTRY_W,
                            0,       // dwEncodingType
                            0,       // hCryptProv,
                            dwFlags,
                            L"My"
                            );

#ifdef ProfilingEfs

NtQuerySystemTime(&StopTime);
DbgPrint("OpenStore:%lu\tHashHead:%lu\n", (ULONG)(StopTime.QuadPart - StartTime.QuadPart)/1000, *((PULONG)pbHash));
#endif

    if (hStore != NULL) {

        //
        // Find our cert via the hash
        //

        hashBlob.cbData = cbHash;
        hashBlob.pbData = pbHash;

        pCertContext = CertFindCertificateInStore( hStore,
                                                   CRYPT_ASN_ENCODING,
                                                   0,
                                                   CERT_FIND_HASH,
                                                   &hashBlob,
                                                   NULL
                                                   );
        //
        // Let's make sure we have the right EFS OID
        //
        
        if (pCertContext) {
            rc = EfsFindCertOid(
                    szOID_KP_EFS,
                    pCertContext,
                    &OidFound
                    );
    
            if ((ERROR_SUCCESS != rc) || !OidFound) {
    
                if (dwOpen) {
    
                    //
                    // Let's try recovery cert
                    //
    
                    rc = EfsFindCertOid(
                            szOID_EFS_RECOVERY,
                            pCertContext,
                            &OidFound
                            );
                }
    
    
                if ((ERROR_SUCCESS != rc) || !OidFound) {
                    //
                    // Could not get the EFS OID. Same as not finding the cert.
                    //
        
                    CertFreeCertificateContext(pCertContext);
                    pCertContext = NULL;
                    if ((rc != ERROR_SUCCESS) && (rc != CERTSRV_E_KEY_LENGTH)){
                        rc = CERT_E_WRONG_USAGE;
                    }
                }
            }
        } else {
            rc = GetLastError();
        }

        CertCloseStore( hStore, 0 );
    }

    if (rc != ERROR_SUCCESS) {
        SetLastError(rc);
    }
    return( pCertContext );
}


LPWSTR
EfspGetCertDisplayInformation(
    IN PCCERT_CONTEXT pCertContext
    )
/*++

Routine Description:

    Returns the display string from the passed certificate context.

Arguments:

    pCertContext - Supplies a pointer to an open certificate context.

Return Value:

    On success, pointer to display string.  Caller must call
    LsapFreeLsaHeap() to free.

    NULL on failure.

--*/

{
    DWORD rc;
    LPWSTR UserDispName = NULL;

    rc = EfsGetCertNameFromCertContext(
                pCertContext,
                &UserDispName
                );

    if (rc == ERROR_SUCCESS) {
        return UserDispName;
    } else {
        SetLastError(rc);
        return NULL;
    }

}

PBYTE
GetCertHashFromCertContext(
    IN PCCERT_CONTEXT pCertContext,
    OUT PDWORD pcbHash
    )
/*++

Routine Description:

    Helper routine, takes a cert context and extracts the hash.

Arguments:

    pCertContext - Supplies the cert context.

    pcbHash - Returns the length in bytes of the returned hash.

Return Value:

    Returns a pointer to a hash block allocated out of heap memory,
    or NULL if either the attempt to get the hash failed or the attempt
    to allocate memory failed.

    Call GetLastError() for more details in case of failure.

--*/
{
    PBYTE pbHash = NULL;
    *pcbHash = 0;

    if (CertGetCertificateContextProperty(
                 pCertContext,
                 CERT_HASH_PROP_ID,
                 NULL,
                 pcbHash
                 )) {

        pbHash = (PBYTE)LsapAllocateLsaHeap( *pcbHash );

        if (pbHash != NULL) {

            if (!CertGetCertificateContextProperty(
                         pCertContext,
                         CERT_HASH_PROP_ID,
                         pbHash,
                         pcbHash
                         )) {

                LsapFreeLsaHeap( pbHash );
                pbHash = NULL;
                *pcbHash = 0;
            }

        } else {

            SetLastError( ERROR_NOT_ENOUGH_MEMORY );
        }
    }

    return( pbHash );
}

PCERT_PUBLIC_KEY_INFO
     ExportPublicKeyInfo(
     IN HCRYPTPROV hProv,
     IN DWORD dwKeySpec,
     IN DWORD dwCertEncodingType,
     IN OUT DWORD *pcbInfo
     )
{
    PCERT_PUBLIC_KEY_INFO pPubKeyInfo = NULL;

    if ( CryptExportPublicKeyInfo(
         hProv,
         dwKeySpec,
         dwCertEncodingType,
         NULL,
         pcbInfo)) {

        pPubKeyInfo = (PCERT_PUBLIC_KEY_INFO) LsapAllocateLsaHeap(*pcbInfo);

        if (pPubKeyInfo) {

            if (!CryptExportPublicKeyInfo( hProv,
                 dwKeySpec,
                 dwCertEncodingType,
                 pPubKeyInfo,
                 pcbInfo)) {

                LsapFreeLsaHeap( pPubKeyInfo );
                pPubKeyInfo = NULL;
                *pcbInfo = 0;
            }
        }
    }

    return ( pPubKeyInfo );
}

BOOL
EncodeAndAlloc(
    DWORD dwEncodingType,
    LPCSTR lpszStructType,
    const void * pvStructInfo,
    PBYTE * pbEncoded,
    PDWORD pcbEncoded
    )
{
    BOOL b = FALSE;

    if (CryptEncodeObject(
          dwEncodingType,
          lpszStructType,
          pvStructInfo,
          NULL,
          pcbEncoded )) {

        *pbEncoded = (PBYTE)LsapAllocateLsaHeap( *pcbEncoded );

        if (*pbEncoded) {

            if (CryptEncodeObject(
                  dwEncodingType,
                  lpszStructType,
                  pvStructInfo,
                  *pbEncoded,
                  pcbEncoded )) {

                b = TRUE;

            } else {

                LsapFreeLsaHeap( *pbEncoded );
                *pbEncoded = NULL;
            }

        } else {

            SetLastError( ERROR_NOT_ENOUGH_MEMORY );
        }
    }

    return( b );
}

DWORD
EfsMakeCertNames(
    IN  PEFS_USER_INFO pEfsUserInfo,
    OUT LPWSTR *DispInfo,
    OUT LPWSTR *SubjectName,
    OUT LPWSTR *UPNName
    )
{
    DWORD rc = ERROR_SUCCESS;
    
    *DispInfo = NULL;
    *UPNName = NULL;

    if (pEfsUserInfo->bDomainAccount) {

        //
        // Domain Account
        //

        HRESULT hr;
        HANDLE  hDS = NULL;
        DS_NAME_RESULT* UserName = NULL;

        hr = DsBind(NULL, NULL, &hDS);
        if (hr == NO_ERROR) {
            
            rc = DsCrackNames(
                    hDS,
                    DS_NAME_NO_FLAGS,
                    DS_SID_OR_SID_HISTORY_NAME,
                    DS_USER_PRINCIPAL_NAME,
                    1,
                    &(pEfsUserInfo->lpUserSid),
                    &UserName
                    );

            if (ERROR_SUCCESS == rc) {

                if (UserName->rItems[0].status == DS_NAME_NO_ERROR) {

                    *UPNName = (LPWSTR) LsapAllocateLsaHeap((wcslen(UserName->rItems[0].pName) + 1) * sizeof (WCHAR));
                    *DispInfo = (LPWSTR) LsapAllocateLsaHeap(
                                    (wcslen(UserName->rItems[0].pName) +
                                    wcslen(pEfsUserInfo->lpUserName) +
                                    3) * sizeof (WCHAR));
                    *SubjectName = (LPWSTR) LsapAllocateLsaHeap((wcslen(pEfsUserInfo->lpUserName)+4) * sizeof (WCHAR));
    
                    if (*UPNName && *DispInfo && *SubjectName ){
                        wcscpy(*UPNName, UserName->rItems[0].pName);
                        wcscpy(*DispInfo, pEfsUserInfo->lpUserName);
                        wcscat(*DispInfo, L"(");
                        wcscat(*DispInfo, *UPNName);
                        wcscat(*DispInfo, L")");
                        wcscpy(*SubjectName, L"CN=");
                        wcscat(*SubjectName, pEfsUserInfo->lpUserName);
                    } else {
    
                        if (*UPNName) {
                            LsapFreeLsaHeap( *UPNName );
                            *UPNName = NULL;
                        }
                        if (*DispInfo) {
                            LsapFreeLsaHeap( *DispInfo );
                            *DispInfo = NULL;
                        }
                        if (*SubjectName) {
                            LsapFreeLsaHeap( *SubjectName );
                            *SubjectName = NULL;
                        }
                        rc = ERROR_NOT_ENOUGH_MEMORY;
                    }

                }


                if (UserName){
                    DsFreeNameResult(UserName);
                    UserName = NULL;
                }

            }

            DsUnBindW( &hDS );

        }
    }


    if (NULL == *UPNName) {

        //
        // If Local Account, let the UPNNmae be User@Computer. DispInfo be User(User@Computer).
        // Else let the UPNName be User@Domain. DispInfo be User(User@Domain)
        //

        *UPNName = (LPWSTR) LsapAllocateLsaHeap(
                        (wcslen(pEfsUserInfo->lpUserName) + 
                        wcslen(pEfsUserInfo->lpDomainName) + 
                        2) * sizeof (WCHAR));
        *DispInfo = (LPWSTR) LsapAllocateLsaHeap(
                        (wcslen(pEfsUserInfo->lpDomainName) +
                        wcslen(pEfsUserInfo->lpUserName) * 2 +
                        4) * sizeof (WCHAR));
        *SubjectName = (LPWSTR) LsapAllocateLsaHeap(
                        (wcslen(pEfsUserInfo->lpUserName)+
                        4) * sizeof (WCHAR));

        if (*UPNName && *DispInfo && *SubjectName){
            wcscpy(*UPNName, pEfsUserInfo->lpUserName);
            wcscat(*UPNName, L"@");
            wcscat(*UPNName, pEfsUserInfo->lpDomainName);
            wcscpy(*DispInfo, pEfsUserInfo->lpUserName);
            wcscat(*DispInfo, L"(");
            wcscat(*DispInfo, *UPNName);
            wcscat(*DispInfo, L")");
            wcscpy(*SubjectName, L"CN=");
            wcscat(*SubjectName, pEfsUserInfo->lpUserName);
        } else {

            if (*UPNName) {
                LsapFreeLsaHeap( *UPNName );
                *UPNName = NULL;
            }
            if (*DispInfo) {
                LsapFreeLsaHeap( *DispInfo );
                *DispInfo = NULL;
            }
            if (*SubjectName) {
                LsapFreeLsaHeap( *SubjectName );
                *SubjectName = NULL;
            }
            rc = ERROR_NOT_ENOUGH_MEMORY;
        }

    }
    return rc;
}



DWORD
EfsFindCertOid(
    IN LPSTR pEfsCertOid,
    IN PCCERT_CONTEXT pCertContext,
    OUT BOOL *OidFound
    )

/*++

Routine Description:

    This routine takes a cert context and an Efs Oid. It will check if the cert has the Efs Oid or not.
    
Arguments:

    pEfsCertOid - Efs Oid to be searched for.
    
    pCertContext - The cert to be searched for.

    OidFound - The result. TRUE if the oid is found.

Return Value:

    Win32 Error code.
    
--*/
{
    BOOL bRet;
    PCERT_ENHKEY_USAGE pUsage;
    DWORD pcbUsage = 0;
    DWORD rc = ERROR_SUCCESS;
    DWORD ii;
    DWORD KeyLength;

    *OidFound = FALSE;

    //
    // Let's check the key length first
    //

    KeyLength = CertGetPublicKeyLength(X509_ASN_ENCODING | PKCS_7_ASN_ENCODING, &(pCertContext->pCertInfo->SubjectPublicKeyInfo));
    if (!KeyLength) {
        return GetLastError();
    }

    if (KeyLength < (RSA1024BIT_KEY >> 17)) {

        //
        //  Key length too short ( 512 ), We actually don't generate less than 1024.
        //

        return CERTSRV_E_KEY_LENGTH;
    }

    bRet = CertGetEnhancedKeyUsage(
               pCertContext,
               0,
               NULL,
               &pcbUsage
               );

    if (bRet) {

        SafeAllocaAllocate(pUsage, pcbUsage);

        if (pUsage) {
            bRet = CertGetEnhancedKeyUsage(
                       pCertContext,
                       0,
                       pUsage,
                       &pcbUsage
                       );
            if (bRet){
                for (ii=0; ii<pUsage->cUsageIdentifier;ii++) {
                    if (!strcmp(pUsage->rgpszUsageIdentifier[ii], pEfsCertOid)){

                        //
                        // We found the OID
                        //
                        *OidFound = TRUE;
                        break;
                    }
                }

            } else {
                rc = GetLastError();
            }

            SafeAllocaFree(pUsage);

        } else {
           rc = ERROR_NOT_ENOUGH_MEMORY;
        }
    } else {
        rc = GetLastError();
    }
    return rc;
}

LONG
EfsTimeExp(
    IN LPFILETIME CertExpTime
    )
/*++

Routine Description:

    This routine takes a time to see if it has passed.
    
Arguments:

    CertExpTime - time to be checked


Return Value:

    Non zero if passed.
    
--*/

{
    SYSTEMTIME SystemTime;
    FILETIME   FileTime;


    GetSystemTime(&SystemTime);
    SystemTimeToFileTime(&SystemTime, &FileTime);

    if (CompareFileTime(&FileTime, CertExpTime) <= 0)
        return 0;
    else
        return 1;


}

DWORD
GetKeyInfoFromCertHash(
    IN OUT PEFS_USER_INFO pEfsUserInfo,
    IN  PBYTE        pbHash,
    IN  DWORD        cbHash,
    OUT HCRYPTKEY  * hKey               OPTIONAL,
    OUT HCRYPTPROV * hProv              OPTIONAL,
    OUT LPWSTR     * ContainerName      OPTIONAL,
    OUT LPWSTR     * ProviderName       OPTIONAL,
    OUT LPWSTR     * DisplayInformation OPTIONAL,
    OUT PBOOLEAN     pbIsValid          OPTIONAL
    )
/*++

Routine Description:

    This routine takes a certificate hash and extracts from it information
    about the key it represents.  If the key information from this
    cert does not exist in the current context, it will return an error.

Arguments:

    pEfsUserInfo - User Information

    pbHash - Takes a pointer to the certificate hash.

    cbHash - The length in bytes of the certificate hash.

    hKey - Returns the handle to the key corresponding to this
        certificate.  Must be passed of hProv is passed.

    hProv - Returns the handle to the context corresponding to this
        certificate.  Must be passed of hKey is passed.

    ContainerName - Returns a string with the name of the container of the
        key in this certificate.

    ProviderName - Returns a string with the name of the provider of the
        key in this certificate.

    DisplayInformation - Returns the display information for the certificate.

    pbIsValid - If present, causes the cert to be validity checked and the
        results returned.

Return Value:

    ERROR_SUCCESS - The passed certificate is in the current user's MY
        store and the key it represents is in his context.

    !ERROR_SUCCESS - Either the certificate could not be found in the
        user's MY store, or the key in the certificate could not be
        instantiated.

--*/

{
    PCCERT_CONTEXT pCertContext;
    IN  PBYTE        pbLocalHash = NULL;
    IN  DWORD        cbLocalHash = 0;

    //
    // Don't trust CryptoAPI to set last error properly,
    // keep track of success and failure on our own.
    //

    BOOLEAN b = TRUE;
    BOOLEAN CreateCache = FALSE;
    BOOLEAN LocalCertValidated = FALSE;
    BOOLEAN DataNotCached = TRUE;
    DWORD rc = ERROR_SUCCESS;
    DWORD rc2 = ERROR_SUCCESS;

    HCRYPTKEY  hLocalKey = NULL;
    HCRYPTPROV hLocalProv = NULL;
    LPWSTR     LocalContainerName = NULL;
    LPWSTR     LocalProviderName = NULL;
    LPWSTR     LocalDisplayInformation = NULL;

    //
    // Output parameters
    //

    if (ARGUMENT_PRESENT(ContainerName)) {
        *ContainerName = NULL;
    }

    if (ARGUMENT_PRESENT(ProviderName)) {
        *ProviderName = NULL;
    }

    if (ARGUMENT_PRESENT(DisplayInformation)) {
        *DisplayInformation = NULL;
    }

    if (ARGUMENT_PRESENT(hProv)) {
        *hProv = NULL;
    }

    if (ARGUMENT_PRESENT(hKey)) {
        *hKey = NULL;
    }

    if (ARGUMENT_PRESENT( pbIsValid )){
        *pbIsValid = FALSE;
    }

    //
    //  Check if a cache node is available
    //

    if (!pEfsUserInfo->UserCacheStop) {
        if (pEfsUserInfo->pUserCache) {

            //
            // The user has a cache, check if the Hash matches
            //

            if ( pEfsUserInfo->pUserCache->cbHash == cbHash ) {

                if(RtlEqualMemory( pEfsUserInfo->pUserCache->pbHash, pbHash, cbHash)){

                    //
                    // Cache is valid. Use the cache
                    //


                    if (ARGUMENT_PRESENT( pbIsValid )){
                        *pbIsValid = (pEfsUserInfo->pUserCache->CertValidated == CERT_VALIDATED);
                    }
                    return ERROR_SUCCESS;

                }

                //
                // User might use an old key, do not put in the cache.
                //

            }

        } else {

            CreateCache = TRUE;

        }
    }

    //
    // Well, cert is not in the cache. The profile could be not loaded. Let's try to load the profile.
    // If the profile is already loaded, it will return success without calling LoadUserProfile().
    // We don't need to unload here. It will be unload at the very outside.
    //

    if (!EfspLoadUserProfile( pEfsUserInfo, TRUE )){

        //
        // Profile Load Failure
        //

        return GetLastError();

    }


    //
    // Find our cert via the hash
    //

    pCertContext = GetCertContextFromCertHash(
                        pbHash,
                        cbHash,
                        CERT_SYSTEM_STORE_CURRENT_USER,
                        ARGUMENT_PRESENT( pbIsValid )? 0:1
                        );


    if (pCertContext != NULL) {

        pbLocalHash = pbHash;
        cbLocalHash = cbHash;

        //
        // Let's check if the cert points to a new cert or not. If it is, the current reg value
        // will be changed.
        //
        PCCERT_CONTEXT pNewCertContext = NULL;


        if (ARGUMENT_PRESENT( pbIsValid ) || pEfsUserInfo->pUserCache == NULL) {

            //
            //  Create path or the first open
            //

            rc = EfsTryRenewCert(
                pEfsUserInfo,
                pCertContext,
                &pNewCertContext
                );
    
            if (ERROR_SUCCESS == rc) {
    
                if (ARGUMENT_PRESENT( pbIsValid )) {
    
                    //
                    // Not an open path. Let's switch the certificate
                    //

                    pbLocalHash =  GetCertHashFromCertContext(
                                      pNewCertContext,
                                      &cbLocalHash
                                      );
                    if (pbLocalHash) {

                        CertFreeCertificateContext( pCertContext );
                        pCertContext = pNewCertContext;
                        pNewCertContext = NULL;

                    } else {

                        //
                        //  Forget about the new cert
                        //

                        pbLocalHash = pbHash;
                        cbLocalHash = cbHash;
                        CertFreeCertificateContext( pNewCertContext );
                        pNewCertContext = NULL;
                    }
    
                } else {

                    //
                    //  Let's create the new cache for the new cert.
                    //

                    EfsCreateNewCache(pEfsUserInfo, pNewCertContext);
                    CertFreeCertificateContext( pNewCertContext );
                    pNewCertContext = NULL;
                    CreateCache = FALSE;
    
                }
            } else {

                rc = ERROR_SUCCESS;

            }

        }


        PCRYPT_KEY_PROV_INFO pCryptKeyProvInfo = GetKeyProvInfo( pCertContext );

        if (pCryptKeyProvInfo != NULL) {

            //
            // Copy out the container name and provider name if requested.
            //


            if (pCryptKeyProvInfo->pwszContainerName) {
               LocalContainerName = (LPWSTR)LsapAllocateLsaHeap( wcslen(pCryptKeyProvInfo->pwszContainerName) * sizeof( WCHAR ) + sizeof( UNICODE_NULL ));
               if (LocalContainerName != NULL) {
                  wcscpy( LocalContainerName, pCryptKeyProvInfo->pwszContainerName );
               } else {
                  rc = ERROR_NOT_ENOUGH_MEMORY;
                  b = FALSE;
               }
            }
            if (b && pCryptKeyProvInfo->pwszProvName) {
               LocalProviderName =  (LPWSTR)LsapAllocateLsaHeap( wcslen(pCryptKeyProvInfo->pwszProvName) * sizeof( WCHAR ) + sizeof( UNICODE_NULL ));
               if (LocalProviderName != NULL) {
                  wcscpy( LocalProviderName,  pCryptKeyProvInfo->pwszProvName );
               }
               else {
                  rc = ERROR_NOT_ENOUGH_MEMORY;
                  b = FALSE;
               }
            }
            if (!(LocalDisplayInformation = EfspGetCertDisplayInformation( pCertContext ))) {

               //
               // At least for now, we do not accept Cert without display name
               //

               rc = GetLastError();
               b = FALSE;
            }

            //
            // Get the key information
            //

            if (b) {

#ifdef ProfilingEfs

LARGE_INTEGER  StartTime;
LARGE_INTEGER  StopTime;


NtQuerySystemTime(&StartTime);
#endif
                if (CryptAcquireContext( &hLocalProv, pCryptKeyProvInfo->pwszContainerName, pCryptKeyProvInfo->pwszProvName, PROV_RSA_FULL, CRYPT_SILENT)) {

#ifdef ProfilingEfs
NtQuerySystemTime(&StopTime);
DbgPrint("CryptAcquireContext:%lu\tSessionID:%lu\tHashHead:%lu\n", (ULONG)(StopTime.QuadPart - StartTime.QuadPart)/1000, pEfsUserInfo->AuthId.LowPart, *((ULONG *)pbHash));
#endif
                    if (!CryptGetUserKey(hLocalProv, AT_KEYEXCHANGE, &hLocalKey)) {

                        rc = GetLastError();
                        b = FALSE;
                    }

                } else {

                    rc = GetLastError();
                    if (pEfsUserInfo->NonKerberos && (ERROR_OUTOFMEMORY != rc)) {

                        EfsLogEntry(
                            EVENTLOG_ERROR_TYPE,
                            0,
                            EFS_NTLM_ERROR,
                            0,
                            sizeof(DWORD),
                            NULL,
                            &rc
                            );

                        rc = ERROR_BAD_LOGON_SESSION_STATE;
                    }
                    b = FALSE;
                }

            }

            if (b) {

                if ( ARGUMENT_PRESENT( pbIsValid ) || CreateCache ) {

                    //
                    // Do cert validity checking. Check time and usage.
                    //
    
                    if ( CertVerifyTimeValidity(
                            NULL,
                            pCertContext->pCertInfo
                            )){

                        rc2 = CERT_E_EXPIRED;

                        //b = FALSE;

                    } else {

                        LocalCertValidated = TRUE;

                    }


                    if (ARGUMENT_PRESENT( pbIsValid )) {

                        //
                        // We need the validation info.
                        //

                        *pbIsValid = LocalCertValidated;

                    }

                }

                if ( CreateCache ) {

                    DWORD    certFlag;
    
                    //
                    // To determine if we can put the data in cache.
                    //

                    if (CurrentHashOK(pEfsUserInfo, pbLocalHash, cbLocalHash, &certFlag)) {

                        //
                        // This pbHash is in the user's key or has been put in. Let's create the cache node.
                        //

                        PUSER_CACHE pCacheNode;
                        PBYTE pbWkHash;
                        DWORD ImpersonationError = 0;

                        if ( 0 == (certFlag & CERTSTOREIDMASK) ) {

                            DWORD sevRc;

                            //
                            // The cert is not in the LM Trusted or Other store. Upgrade system from Win2K, or Beta 1 Whistler.
                            //

                            if (ERROR_SUCCESS == (sevRc = EfsAddCertToCertStore(pCertContext, OTHERPEOPLE, &ImpersonationError))) {
                                EfsMarkCertAddedToStore(pEfsUserInfo, CERTINLMOTHERSTORE);
                            } else {
                                if (ImpersonationError) {

                                    //
                                    // Got in trouble. We could not impersonate back.
                                    //

                                    ASSERT(FALSE);
                                    rc = sevRc;
                                    b = FALSE;

                                }
                            }

                        }

                        if (!ImpersonationError) {

                            PSID  pUserID = NULL;
                            ULONG SidLength = 0;

                            pCacheNode = (PUSER_CACHE) LsapAllocateLsaHeap(sizeof(USER_CACHE));
    
                            pbWkHash = (PBYTE) LsapAllocateLsaHeap(cbLocalHash);
    
                            if (pEfsUserInfo->InterActiveUser != USER_INTERACTIVE) {
                
                                SidLength = RtlLengthSid(pEfsUserInfo->pTokenUser->User.Sid);
                                pUserID = (PSID) LsapAllocateLsaHeap(SidLength);
                
                            }
                
                            if (pCacheNode && pbWkHash && ((SidLength == 0) || (pUserID))) {
        
                                NTSTATUS Status = STATUS_SUCCESS;

                                memset( pCacheNode, 0, sizeof( USER_CACHE ));
                                RtlCopyMemory(pbWkHash, pbLocalHash, cbLocalHash);
    
                                if (pUserID) {
                
                                    Status = RtlCopySid(
                                                 SidLength,
                                                 pUserID,
                                                 pEfsUserInfo->pTokenUser->User.Sid
                                                 );
                                }
    
                                if (NT_SUCCESS( Status ) && NT_SUCCESS( NtQuerySystemTime(&(pCacheNode->TimeStamp)))){
    
                                    if (EfspInitUserCacheNode(
                                                 pCacheNode,
                                                 pUserID,
                                                 pbWkHash,
                                                 cbLocalHash,
                                                 LocalContainerName,
                                                 LocalProviderName,
                                                 LocalDisplayInformation,
                                                 &(pCertContext->pCertInfo->NotAfter),
                                                 hLocalKey,
                                                 hLocalProv,
                                                 pUserID? NULL: &(pEfsUserInfo->AuthId),
                                                 LocalCertValidated? CERT_VALIDATED:CERT_VALIDATION_FAILED
                                                 )){
    
                                        //
                                        //  Cache node created and ready for use. Do not delete or close the info
                                        //  we just got.
                                        //
    
                                        LocalContainerName = NULL;
                                        LocalProviderName = NULL;
                                        LocalDisplayInformation = NULL;
                                        hLocalKey = NULL;
                                        hLocalProv = NULL;
                                        pEfsUserInfo->pUserCache = pCacheNode;
    
                                        DataNotCached = FALSE;
                                        rc = ERROR_SUCCESS;
                                        b = TRUE;              // We can have a non-validated cache node for the use of open file
    
                                    } else {
    
                                        LsapFreeLsaHeap(pCacheNode);
                                        LsapFreeLsaHeap(pbWkHash);
                                        pbWkHash = NULL;
                                        pCacheNode = NULL;
                                        if (pUserID) {
                                            LsapFreeLsaHeap(pUserID);
                                            pUserID = NULL;
                                        }
    
                                    }
    
                                } else {
    
                                    LsapFreeLsaHeap(pCacheNode);
                                    LsapFreeLsaHeap(pbWkHash);
                                    pbWkHash = NULL;
                                    pCacheNode = NULL;
                                    if (pUserID) {
                                        LsapFreeLsaHeap(pUserID);
                                        pUserID = NULL;
                                    }
    
                                }
        
                            } else {
                                if (pCacheNode) {
                                   LsapFreeLsaHeap(pCacheNode);
                                   pCacheNode = NULL;
                                }
                                if (pbWkHash) {
                                    LsapFreeLsaHeap(pbWkHash);
                                    pbWkHash = NULL;
                                }
                                if (pUserID) {
                                    LsapFreeLsaHeap(pUserID);
                                    pUserID = NULL;
                                }
                            }
                        }
                    } 
                }

                if (DataNotCached && b) {

                    //
                    // We need to returned the data to outside
                    //


                    if (ARGUMENT_PRESENT(ContainerName)) {

                        *ContainerName = LocalContainerName;
                        LocalContainerName = NULL;

                    } else {

                        LsapFreeLsaHeap( LocalContainerName );
                        LocalContainerName = NULL;

                    }
            
                    if (ARGUMENT_PRESENT(ProviderName)) {
                        *ProviderName = LocalProviderName;
                        LocalProviderName = NULL;
                    } else {

                        LsapFreeLsaHeap( LocalProviderName );
                        LocalProviderName = NULL;

                    }
            
                    if (ARGUMENT_PRESENT(DisplayInformation)) {
                        *DisplayInformation = LocalDisplayInformation;
                        LocalDisplayInformation = NULL;
                    } else {

                        LsapFreeLsaHeap( LocalDisplayInformation );
                        LocalDisplayInformation = NULL;

                    }
            
                    if (ARGUMENT_PRESENT(hKey)) {
                        *hKey = hLocalKey;
                        hLocalKey = NULL;

                    }
            
                    if (ARGUMENT_PRESENT(hProv)) {
                        *hProv = hLocalProv;
                        hLocalProv = NULL;
                    }

                }

            }

            LsapFreeLsaHeap( pCryptKeyProvInfo );
            if (pbLocalHash && (pbLocalHash != pbHash)) {
                LsapFreeLsaHeap( pbLocalHash );
            }


        } else {

            rc = GetLastError();
            b = FALSE;
        }

        if (pCertContext) {

            CertFreeCertificateContext( pCertContext );

        }


    } else {

        rc = GetLastError();
        b = FALSE;
    }

    if (!b) {

        ASSERT( rc != ERROR_SUCCESS );

        //
        // Something failed, cleanup the stuff we were going to return
        //

        if ( LocalContainerName) {
            LsapFreeLsaHeap( LocalContainerName );
        }

        if (LocalProviderName) {
            LsapFreeLsaHeap( LocalProviderName );
        }

        if (LocalDisplayInformation) {
            LsapFreeLsaHeap( LocalDisplayInformation );
        }

        if (hLocalKey) {
            CryptDestroyKey( hLocalKey );
        }

        if (hLocalProv) {
            CryptReleaseContext( hLocalProv, 0 );
        }
    }

    if (ARGUMENT_PRESENT( pbIsValid ) && !LocalCertValidated ) {
        if (rc == ERROR_SUCCESS) {
            rc = rc2;
        }
    }
    
    return( rc );
}


PCRYPT_KEY_PROV_INFO
GetKeyProvInfo(
    PCCERT_CONTEXT pCertContext
    )

/*++

Routine Description:

    This routine will extract the Key Provider Information from
    the passed certificate context.

Arguments:

    pCertContext - Supplies a pointer to a certificate context.

Return Value:

    Returns a pointer to a PCRYPT_KEY_PROV_INFO structure on success,
        otherwise returns NULL, which usually means that the certificate
        did not have the context property we were looking for (meaning
        that it probably isn't an EFS certificate).
--*/

{

    DWORD cbData = 0;
    BOOL b;
    PCRYPT_KEY_PROV_INFO pCryptKeyProvInfo = NULL;

    b = CertGetCertificateContextProperty(
             pCertContext,
             CERT_KEY_PROV_INFO_PROP_ID,
             NULL,
             &cbData
             );

    if (b) {

        pCryptKeyProvInfo = (PCRYPT_KEY_PROV_INFO)LsapAllocateLsaHeap( cbData );

        if (pCryptKeyProvInfo != NULL) {

            b = CertGetCertificateContextProperty(
                     pCertContext,
                     CERT_KEY_PROV_INFO_PROP_ID,
                     pCryptKeyProvInfo,
                     &cbData
                     );

            if (!b) {

                LsapFreeLsaHeap( pCryptKeyProvInfo );
                pCryptKeyProvInfo = NULL;
            }

        } else {

            SetLastError( ERROR_NOT_ENOUGH_MEMORY );
        }
    }

    return ( pCryptKeyProvInfo );
}


DWORD
EfsCreateNewCache(
    IN OUT PEFS_USER_INFO pEfsUserInfo, 
    IN PCCERT_CONTEXT pCertContext
    )

/*++

Routine Description:

    This routine will create a cache node.
    
Arguments:

    pEfsUserInfo - User Information

    pCertContext - Supplies a pointer to a certificate context.

Return Value:

    Returns Win32 error code.
--*/

{

    PBYTE        pbHash;
    DWORD        cbHash;
    HCRYPTKEY    hLocalKey = NULL;
    HCRYPTPROV   hLocalProv = NULL;
    DWORD        rc = ERROR_SUCCESS;
    LPWSTR       LocalContainerName = NULL;
    LPWSTR       LocalProviderName = NULL;
    LPWSTR       LocalDisplayInformation = NULL;
    PUSER_CACHE  pCacheNode;
    PCRYPT_KEY_PROV_INFO pCryptKeyProvInfo = GetKeyProvInfo( pCertContext );

    if (pCryptKeyProvInfo != NULL) {

        //
        // Copy out the container name and provider name if requested.
        //


        if (pCryptKeyProvInfo->pwszContainerName) {
           LocalContainerName = (LPWSTR)LsapAllocateLsaHeap( wcslen(pCryptKeyProvInfo->pwszContainerName) * sizeof( WCHAR ) + sizeof( UNICODE_NULL ));
           if (LocalContainerName != NULL) {
              wcscpy( LocalContainerName, pCryptKeyProvInfo->pwszContainerName );
           } else {
              rc = ERROR_NOT_ENOUGH_MEMORY;
           }
        }
        if ((ERROR_SUCCESS == rc) && pCryptKeyProvInfo->pwszProvName) {
           LocalProviderName =  (LPWSTR)LsapAllocateLsaHeap( wcslen(pCryptKeyProvInfo->pwszProvName) * sizeof( WCHAR ) + sizeof( UNICODE_NULL ));
           if (LocalProviderName != NULL) {
              wcscpy( LocalProviderName,  pCryptKeyProvInfo->pwszProvName );
           }
           else {
              rc = ERROR_NOT_ENOUGH_MEMORY;
           }
        }
        if ((ERROR_SUCCESS == rc) && !(LocalDisplayInformation = EfspGetCertDisplayInformation( pCertContext ))) {

           //
           // At least for now, we do not accept Cert without display name
           //

           rc = GetLastError();
        }

        //
        // Get the key information
        //

        if (ERROR_SUCCESS == rc) {

            if (CryptAcquireContext( &hLocalProv, pCryptKeyProvInfo->pwszContainerName, pCryptKeyProvInfo->pwszProvName, PROV_RSA_FULL, CRYPT_SILENT)) {

                if (!CryptGetUserKey(hLocalProv, AT_KEYEXCHANGE, &hLocalKey)) {

                    rc = GetLastError();
                }

            } else {

                rc = GetLastError();
            }

        }

        if (ERROR_SUCCESS == rc) {

            DWORD ImpersonationError = 0;
            DWORD sevRc;

            //
            // The cert may not be in the LM Trusted or OtherPeople store.
            //

            if (ERROR_SUCCESS == (sevRc = EfsAddCertToCertStore(pCertContext, OTHERPEOPLE, &ImpersonationError))) {
                EfsMarkCertAddedToStore(pEfsUserInfo, CERTINLMOTHERSTORE);
            } else {
                if (ImpersonationError) {

                    //
                    // Got in trouble. We could not impersonate back.
                    //

                    ASSERT(FALSE);
                    rc = sevRc;

                }
            }


            if (!ImpersonationError) {

                PSID  pUserID = NULL;
                ULONG SidLength = 0;

                pCacheNode = (PUSER_CACHE) LsapAllocateLsaHeap(sizeof(USER_CACHE));

                pbHash = GetCertHashFromCertContext(
                              pCertContext,
                              &cbHash
                              );

                if (pEfsUserInfo->InterActiveUser != USER_INTERACTIVE) {
    
                    SidLength = RtlLengthSid(pEfsUserInfo->pTokenUser->User.Sid);
                    pUserID = (PSID) LsapAllocateLsaHeap(SidLength);
    
                }
    
                if (pCacheNode && pbHash && ((SidLength == 0) || (pUserID))) {

                    NTSTATUS Status = STATUS_SUCCESS;

                    memset( pCacheNode, 0, sizeof( USER_CACHE ));

                    if (pUserID) {
    
                        Status = RtlCopySid(
                                     SidLength,
                                     pUserID,
                                     pEfsUserInfo->pTokenUser->User.Sid
                                     );
                    }

                    if (NT_SUCCESS( Status ) && NT_SUCCESS( Status = NtQuerySystemTime(&(pCacheNode->TimeStamp)))){

                        if (EfspInitUserCacheNode(
                                     pCacheNode,
                                     pUserID,
                                     pbHash,
                                     cbHash,
                                     LocalContainerName,
                                     LocalProviderName,
                                     LocalDisplayInformation,
                                     &(pCertContext->pCertInfo->NotAfter),
                                     hLocalKey,
                                     hLocalProv,
                                     pUserID? NULL: &(pEfsUserInfo->AuthId),
                                     CERT_VALIDATED
                                     )){

                            //
                            //  Cache node created and ready for use. Do not delete or close the info
                            //  we just got.
                            //

                            LocalContainerName = NULL;
                            LocalProviderName = NULL;
                            LocalDisplayInformation = NULL;
                            hLocalKey = NULL;
                            hLocalProv = NULL;
                            pEfsUserInfo->pUserCache = pCacheNode;
                            pCacheNode = NULL;

                        } else {

                            rc = GetLastError();

                        }

                    } else {

                        rc = RtlNtStatusToDosError( Status );

                    }

                } else {

                    rc = ERROR_NOT_ENOUGH_MEMORY;

                }

                if (ERROR_SUCCESS != rc) {

                    if (pCacheNode) {
                       LsapFreeLsaHeap(pCacheNode);
                       pCacheNode = NULL;
                    }
                    if (pbHash) {
                        LsapFreeLsaHeap(pbHash);
                        pbHash = NULL;
                    }
                    if (pUserID) {
                        LsapFreeLsaHeap(pUserID);
                        pUserID = NULL;
                    }

                }
            }

        }

        if (ERROR_SUCCESS != rc) {


            if (LocalContainerName) {

                LsapFreeLsaHeap(LocalContainerName);

            }
    
            if (LocalProviderName) {

                LsapFreeLsaHeap(LocalProviderName);

            }
    
            if (LocalDisplayInformation) {

                LsapFreeLsaHeap(LocalDisplayInformation);

            }

            if (hLocalKey) {
                CryptDestroyKey( hLocalKey );
            }
    
            if (hLocalProv) {
                CryptReleaseContext( hLocalProv, 0 );
            }

        }

        LsapFreeLsaHeap( pCryptKeyProvInfo );

    }

    return rc;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\base\lsa\server\efsapi.cxx ===
/*++

Copyright (c) 1997-1999  Microsoft Corporation

Module Name:

    efsapi.cxx

Abstract:

    EFS (Encrypting File System) API Interfaces

Author:

    Robert Reichel      (RobertRe)
    Robert Gu           (RobertG)

Environment:

Revision History:

--*/

#include <lsapch.hxx>

//
// Fodder

extern "C" {
#include <nt.h>
#include <ntdef.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <stdio.h>
#include <wincrypt.h>
#include <efsstruc.h>
#include "lsasrvp.h"
#include "debug.h"
#include "efssrv.hxx"
#include "userkey.h"
#include "lsapmsgs.h"

}


//Constant -- This buffer length should be enough for EFS temp file name
#define TEMPFILELEN 26

//
// Initial memory allocation block size for $EFS
//
#define INIT_EFS_BLOCK_SIZE    4096
#define INITBUFFERSIZE  4096
#define EFS_MAX_FILE_PATH      (sizeof(WCHAR) * 4096)


#define ENCRYPT 1

#define EfsErrPrint //

#define BASIC_KEY_INFO  1
#define UPDATE_KEY_USED 0x100

#define INFO_BUFFER_SIZE        (10*1024)
#define INFO_BUFFER_ITEM_LIMIT  20

//
// Global Variables
//

DESTable DesTable;

UCHAR DriverSessionKey[DES_BLOCKLEN];

HANDLE LsaPid = NULL;

//
// Prototypes
//

ULONG
StringInfoCmp(
    IN PFILE_STREAM_INFORMATION StreamInfoBase,
    IN PFILE_STREAM_INFORMATION LaterStreamInfoBase,
    IN ULONG StreamInfoSize
    );

BOOLEAN
EncryptFSCTLData(
    IN ULONG Fsctl,
    IN ULONG Psc,
    IN ULONG Csc,
    IN PVOID EfsData,
    IN ULONG EfsDataLength,
    IN OUT PUCHAR Buffer,
    IN OUT PULONG BufferLength
    );

BOOLEAN
SendHandle(
    IN HANDLE Handle,
    IN OUT PUCHAR EfsData,
    IN OUT PULONG EfsDataLength
    );

BOOLEAN
SendEfs(
    IN PEFS_KEY Fek,
    IN PEFS_DATA_STREAM_HEADER Efs,
    OUT PUCHAR EfsData,
    OUT PULONG EfsDataLength
    );

BOOLEAN
SendHandleAndEfs(
    IN HANDLE Handle,
    IN PEFS_DATA_STREAM_HEADER Efs,
    IN OUT PUCHAR EfsData,
    IN OUT PULONG EfsDataLength
    );

NTSTATUS
SendSkFsctl(
    IN ULONG PSC,
    IN ULONG CSC,
    IN ULONG EfsCode,
    IN PUCHAR InputData,
    IN ULONG InputDataSize,
    IN HANDLE Handle,
    IN ULONG FsCode,
    OUT IO_STATUS_BLOCK *IoStatusBlock
    );

NTSTATUS
EndErrorEncryptFile(
    IN HANDLE FileHandle,
    IN PUCHAR InputData,
    IN ULONG InputDataSize,
    OUT IO_STATUS_BLOCK *IoStatusBlock
    );

NTSTATUS
GetRootHandle(
    IN HANDLE FileHandle,
    PHANDLE RootDirectoryHandle
    );

NTSTATUS
GetParentEfsStream(
    IN HANDLE CurrentFileHandle,
    IN PUNICODE_STRING CurrentFileName,
    OUT PEFS_DATA_STREAM_HEADER *ParentEfsStream
    );

DWORD
MyCopyFile(
    HANDLE SourceFile,
    PUNICODE_STRING StreamNames,
    PHANDLE StreamHandles,
    PEFS_STREAM_SIZE StreamSizes,
    ULONG StreamCount,
    HANDLE hTargetFile,
    PHANDLE * TargetStreamHandles
    );

VOID
CleanupOpenFileStreams(
       IN PHANDLE Handles OPTIONAL,
       IN PUNICODE_STRING StreamNames OPTIONAL,
       IN PEFS_STREAM_SIZE Sizes OPTIONAL,
       IN PFILE_STREAM_INFORMATION StreamInfoBase OPTIONAL,
       IN HANDLE HSourceFile OPTIONAL,
       IN ULONG StreamCount
       );


NTSTATUS
GetBackupFileName(
    LPCWSTR SourceFile,
    LPWSTR * BackupName
    );


DWORD
CopyStream(
    HANDLE Target,
    HANDLE Source,
    PEFS_STREAM_SIZE StreamSize
    );


DWORD
CheckVolumeSpace(
    PFILE_FS_SIZE_INFORMATION VolInfo,
    PEFS_STREAM_SIZE StreamSizes,
    PHANDLE StreamHandles,
    ULONG StreamCount
    );

DWORD
CompressStreams(
    PEFS_STREAM_SIZE StreamSizes,
    PHANDLE StreamHandles,
    ULONG State,
    ULONG StreamCount
    );

DWORD
CheckOpenSection(
    PEFS_STREAM_SIZE StreamSizes,
    PHANDLE StreamHandles,
    ULONG StreamCount
    );

DWORD
CopyStreamSection(
    HANDLE Target,
    HANDLE SrcMapping,
    PLARGE_INTEGER Offset,
    PLARGE_INTEGER DataLength,
    PLARGE_INTEGER AllocationGranularity
    );

BOOL
EfspSetEfsOnFile(
    IN HANDLE hFile,
    PEFS_DATA_STREAM_HEADER pEfsStream,
    IN PEFS_KEY pNewFek
    );

NTSTATUS
GetFileEfsStream(
    IN HANDLE hFile,
    OUT PEFS_DATA_STREAM_HEADER * pEfsStream
    );


DWORD
EncryptFileSrv(
    IN PEFS_USER_INFO pEfsUserInfo,
    IN PUNICODE_STRING SourceFileNameU,
    IN HANDLE LogFileH
    )
/*++

Routine Description:

    This routine is the top level routine of the EncryptFile API.  It
    opens the passed source file and copies all of its data streams to
    a backup file in a known location.  It then marks all of the streams
    of the source as encrypted, and copies them back.

Arguments:

    SourceFileName - Supplies a Unicode string with the name of
        the file to be encrypted.

    LogFileH - Log file handle. Log file is zero size when passed in.


Return Value:

    ERROR_SUCCESS on success, other on failure.

--*/
{
    BOOL                 b = TRUE;
    BOOLEAN              CleanupSuccessful = TRUE;
    BOOLEAN              KeepLogFile = FALSE;

    ULONG                StatusInfoOffset = 0 ;
    DWORD                hResult = ERROR_SUCCESS;
    DWORD                FileAttributes;

    HANDLE               FileHandle;
    HANDLE               hSourceFile;
    HANDLE               hBackupFile = 0;
    PHANDLE              StreamHandles = NULL;

    LPWSTR               SourceFileName;
    LPWSTR               BackupFileName;

    FILE_FS_SIZE_INFORMATION    VolInfo;
    FILE_INTERNAL_INFORMATION  SourceID;
    FILE_INTERNAL_INFORMATION  BackupID;

    NTSTATUS                 Status;

    OBJECT_ATTRIBUTES        Obja;

    PFILE_STREAM_INFORMATION LaterStreamInfoBase = NULL;
    PFILE_STREAM_INFORMATION StreamInfoBase = NULL;

    PEFS_STREAM_SIZE           StreamSizes = NULL;

    PUNICODE_STRING          StreamNames = NULL;

    UINT                     TmpResult;

    ULONG                    LaterStreamInfoSize = 0;
    ULONG                    StreamCount    = 0;
    ULONG                    StreamInfoSize = 0;
    ULONG                    i;
    DWORD                   tmpDW;

    PEFS_DATA_STREAM_HEADER  ParentEfsStream = NULL;
    PEFS_DATA_STREAM_HEADER  CurrentEfsStream = NULL;

    IO_STATUS_BLOCK IoStatusBlock;
    ULONG InputDataSize;
    ULONG EfsDataLength;
    PUCHAR InputData;
    WORD WebDavPath = 0;

    //
    // Convert the source file name into an LPWSTR
    //

    if (!LogFileH){
        //
        //  No LogFile means WEBDAVPATH
        //

        WebDavPath = WEBDAVPATH;
    }

    SafeAllocaAllocate(SourceFileName, SourceFileNameU->Length + sizeof(UNICODE_NULL));

    if (SourceFileName == NULL){
        MarkFileForDelete( LogFileH );
        EfsErrPrint("Out of memory allocating SourceFileName");
        return( ERROR_NOT_ENOUGH_MEMORY );
    }

    SourceFileName[SourceFileNameU->Length/sizeof(WCHAR)] = UNICODE_NULL;

    RtlCopyMemory( SourceFileName, SourceFileNameU->Buffer, SourceFileNameU->Length );

    DebugLog((DEB_TRACE_EFS, "Encrypting file %ws \n", SourceFileName));

    FileAttributes = GetFileAttributes( SourceFileName );

    if (FileAttributes == -1){

        if (LogFileH){
            MarkFileForDelete( LogFileH );
        }

        SafeAllocaFree(SourceFileName);
        EfsErrPrint("GetFileAttributes failed with -1");
        return GetLastError();
    }

    //
    // Open the target file
    //

    if ( FileAttributes & FILE_ATTRIBUTE_DIRECTORY ){
        tmpDW = FILE_FLAG_BACKUP_SEMANTICS;
    } else {
        tmpDW = FILE_FLAG_OPEN_REPARSE_POINT;
    }

    //
    // CreateFile will add FILE_READ_ATTRIBUTES | FILE_WRITE_ATTRIBUTES | SYNCHRONIZE
    //

    hSourceFile =  CreateFile(
            SourceFileName,
            FILE_READ_DATA | FILE_WRITE_DATA | FILE_READ_ATTRIBUTES | FILE_WRITE_ATTRIBUTES,
            0,
            NULL,
            OPEN_EXISTING,
            tmpDW,
            NULL
            );

    if (hSourceFile != INVALID_HANDLE_VALUE) {

        NTSTATUS Status1;

        if ( FileAttributes & FILE_ATTRIBUTE_REPARSE_POINT) {

           //
           // Fail the call if the file is HSM or SIS file
           //
           FILE_ATTRIBUTE_TAG_INFORMATION TagInfo;

           Status = NtQueryInformationFile(
                     hSourceFile,
                     &IoStatusBlock,
                     &TagInfo,
                     sizeof ( FILE_ATTRIBUTE_TAG_INFORMATION ),
                     FileAttributeTagInformation
                     );

           if ( NT_SUCCESS( Status ) && ( (IO_REPARSE_TAG_HSM == TagInfo.ReparseTag) || (IO_REPARSE_TAG_SIS == TagInfo.ReparseTag))) {

              //
              // Log the error saying we do not support HSM and SIS
              //

              EfsLogEntry(
                EVENTLOG_ERROR_TYPE,
                0,
                EFS_REPARSE_FILE_ERROR,
                1,
                sizeof(ULONG),
                (LPCWSTR *)&SourceFileName,
                &TagInfo.ReparseTag
                );

              if (LogFileH){
                  MarkFileForDelete( LogFileH );
              }

              SafeAllocaFree(SourceFileName);
              CloseHandle( hSourceFile );
              EfsErrPrint("This is a SIS or HSM file.\n");
              return ERROR_ACCESS_DENIED;
           }
        }

        Status = NtQueryVolumeInformationFile(
            hSourceFile,
            &IoStatusBlock,
            &VolInfo,
            sizeof ( FILE_FS_SIZE_INFORMATION ),
            FileFsSizeInformation
            );

        if (WebDavPath != WEBDAVPATH) {

            Status1 = NtQueryInformationFile(
                hSourceFile,
                &IoStatusBlock,
                &SourceID,
                sizeof ( FILE_INTERNAL_INFORMATION ),
                FileInternalInformation
                );

        } else {

            //
            // SourceID not needed for WEB DAV file
            //


            Status1 = STATUS_SUCCESS;
        }

        if ( NT_SUCCESS( Status ) && NT_SUCCESS( Status1 ) ) {

 /*
            //
            //  Get parent directory $EFS
            //  We will visit this in Longhorn
            //

            RpcRevertToSelf();
            Status =  GetParentEfsStream(
                                hSourceFile,
                                SourceFileNameU,
                                &ParentEfsStream
                                );
            
 */
    
            
            if (NT_SUCCESS( Status ) ) {

                if ( FileAttributes & FILE_ATTRIBUTE_DIRECTORY ) {

                    if ( FileAttributes & FILE_ATTRIBUTE_COMPRESSED ){

                        USHORT State = COMPRESSION_FORMAT_NONE;
                        ULONG Length;

                        //
                        //  Uncompress the directory first
                        //

                        b = DeviceIoControl(hSourceFile,
                                            FSCTL_SET_COMPRESSION,
                                            &State,
                                            sizeof(USHORT),
                                            NULL,
                                            0,
                                            &Length,
                                            FALSE
                                            );

                        if ( !b ){
                            hResult = GetLastError();
                            DebugLog((DEB_WARN, "DeviceIoControl failed, setting hResult = %d\n", hResult  ));
EfsErrPrint("Uncompress the directory failed. Win Error=%d\n",hResult);
                        }

                    }

                    if (hResult == ERROR_SUCCESS) {

                        //
                        // Set_Encrypt on directory
                        //

                        //
                        //  We do not check the operation of the LOG.
                        //  Should we fail the normal operation just because the LOG operations
                        //  failed? The answer is probably not. The chance to use the LOG file is very
                        //  slim. We will use TxF when it is ready and we have time to deal with this.
                        //

                        if (LogFileH) {

                            CreateLogHeader(
                                LogFileH,
                                VolInfo.BytesPerSector,
                                &(SourceID.IndexNumber),
                                NULL,
                                SourceFileName,
                                NULL,
                                Encrypting,
                                BeginEncryptDir,
                                NULL
                                );

                        }

                        PEFS_KEY Fek ;

                        b = GenerateFEK( &Fek );

                        if (b) {

                            if (ConstructDirectoryEFS( pEfsUserInfo, Fek, &CurrentEfsStream )) {

                                //
                                // Prepare an Input data buffer in the form of
                                // PSC, [EFS_FC, CSC, SK, H, H, [SK, H, H]sk, $EFS]sk
                                //

                                InputDataSize = 2 * sizeof(DriverSessionKey) + 7 * sizeof(ULONG)
                                                + CurrentEfsStream->Length;

                                SafeAllocaAllocate(InputData, InputDataSize);

                                if ( NULL != InputData ) {

                                    EfsDataLength = InputDataSize - 3 * sizeof(ULONG);
                                    ( VOID ) SendHandleAndEfs(
                                                hSourceFile,
                                                CurrentEfsStream,
                                                InputData + 3 * sizeof(ULONG),
                                                &EfsDataLength
                                                );

                                    ( VOID ) EncryptFSCTLData(
                                                EFS_SET_ENCRYPT,
                                                EFS_ENCRYPT_STREAM,
                                                EFS_ENCRYPT_DIRSTR,
                                                InputData + 3*sizeof(ULONG),
                                                EfsDataLength,
                                                InputData,
                                                &InputDataSize
                                                );

                                    Status = NtFsControlFile(
                                                hSourceFile,
                                                0,
                                                NULL,
                                                NULL,
                                                &IoStatusBlock,
                                                FSCTL_SET_ENCRYPTION,
                                                InputData,
                                                InputDataSize,
                                                NULL,
                                                0
                                                );

                                    if (NT_SUCCESS( Status )) {

                                        hResult = ERROR_SUCCESS;

                                    } else {

                                        DebugLog((DEB_ERROR, "EncryptFileSrv: NtFsControlFile failed, status = (%x)\n" ,Status  ));
                                        hResult = RtlNtStatusToDosError( Status );

                                        //
                                        // Make sure the error was mapped
                                        //

                                        if (hResult == ERROR_MR_MID_NOT_FOUND) {

                                            DebugLog((DEB_WARN, "Unable to map NT Error (%x) to Win32 error, returning ERROR_ENCRYPTION_FAILED\n" , Status  ));
                                            hResult = ERROR_ENCRYPTION_FAILED;
                                        }

                                        EfsErrPrint("Encrypt directory FSCTL failed. Win Error=%d\n",hResult);
                                    }


                                    SafeAllocaFree( InputData );

                                } else {

                                    hResult = ERROR_NOT_ENOUGH_MEMORY;
EfsErrPrint("FSCTL input data memory allocation failed.\n");
                                }

                                LsapFreeLsaHeap( CurrentEfsStream );

                            } else {

                                hResult = GetLastError();
                                ASSERT( hResult != ERROR_SUCCESS );
                                DebugLog((DEB_WARN, "ConstructDirectoryEFS returned %x to hResult\n" ,hResult  ));
EfsErrPrint("ConstructDirectoryEFS failed. Win Error=%d\n",hResult);
                            }

                            LsapFreeLsaHeap( Fek );
                            Fek = NULL;

                        } else {

                            hResult = GetLastError();
                            ASSERT( hResult != ERROR_SUCCESS );
EfsErrPrint("Generate directory FEK failed. Win Error=%d\n",hResult);
                        }

                        if ((hResult != ERROR_SUCCESS) && ( FileAttributes & FILE_ATTRIBUTE_COMPRESSED )) {

                            //
                            // Restore the compression state
                            //

                            USHORT State = COMPRESSION_FORMAT_DEFAULT;
                            ULONG Length;

                            (VOID) DeviceIoControl(hSourceFile,
                                                FSCTL_SET_COMPRESSION,
                                                &State,
                                                sizeof(USHORT),
                                                NULL,
                                                0,
                                                &Length,
                                                FALSE
                                                );
                        }

                    }

                } else {

                    //
                    // It's a file, not a directory.
                    //

                    //
                    // Enumerate all the streams on the file
                    //
                    
                    Status = GetStreamInformation(
                                 hSourceFile,
                                 &StreamInfoBase,   // Free this
                                 &StreamInfoSize
                                 );

                    if (NT_SUCCESS( Status )) {

                        hResult = OpenFileStreams(
                                     hSourceFile,
                                     0,
                                     OPEN_FOR_ENC,
                                     StreamInfoBase,
                                     FILE_READ_DATA | FILE_WRITE_DATA | FILE_READ_ATTRIBUTES | FILE_WRITE_ATTRIBUTES | SYNCHRONIZE,
                                     FILE_OPEN,
                                     FILE_SYNCHRONOUS_IO_NONALERT | FILE_OPEN_REPARSE_POINT,
                                     &VolInfo,
                                     &StreamNames,      // Free this but not the contents!
                                     &StreamHandles,    // Free this
                                     &StreamSizes,      // Free this
                                     &StreamCount
                                     );

                        if (hResult == ERROR_SUCCESS) {

                            //
                            // We have handles to all of the streams of the file
                            //

                            //
                            // Prepare an Input data buffer in the form of
                            // PSC, [EFS_FC, CSC, Fek, [Fek]sk, $EFS]sk
                            //


                            PEFS_KEY Fek ;

                            b = GenerateFEK( &Fek );

                            if (b) {

                                b = ConstructEFS(
                                        pEfsUserInfo,
                                        Fek,
                                        ParentEfsStream,
                                        &CurrentEfsStream
                                        );

                                if (b) {

                                    InputDataSize = 2 * EFS_KEY_SIZE( Fek ) + 3 * sizeof(ULONG)
                                                    + CurrentEfsStream->Length;

                                    SafeAllocaAllocate(InputData, InputDataSize);

                                    if ( NULL != InputData ){

                                        //
                                        // This routine creates the backup file.
                                        //

                                        Status = CreateBackupFile(
                                                            SourceFileNameU,
                                                            &hBackupFile,
                                                            &BackupID,
                                                            &BackupFileName
                                                            );

                                        //
                                        // If power down happens right here before
                                        // the log file header is written, we will have a zero size
                                        // temp file left on the disk. This is very unlikely and not
                                        // a big deal we have a zero size file left on the disk.
                                        // After we use TxF, this will not even be an issue.
                                        //

                                        if ( NT_SUCCESS(Status) ){

                                            if (LogFileH) {

                                                Status = CreateLogHeader(
                                                                    LogFileH,
                                                                    VolInfo.BytesPerSector,
                                                                    &(SourceID.IndexNumber),
                                                                    &(BackupID.IndexNumber),
                                                                    SourceFileName,
                                                                    BackupFileName,
                                                                    Encrypting,
                                                                    BeginEncryptFile,
                                                                    &StatusInfoOffset
                                                                    );

                                            }


                                            LsapFreeLsaHeap( BackupFileName );

                                            if ( NT_SUCCESS(Status) ){

                                                if (LogFileH){

                                                    Status = WriteLogFile(
                                                                    LogFileH,
                                                                    VolInfo.BytesPerSector,
                                                                    StatusInfoOffset,
                                                                    BeginEncryptFile
                                                                    );

                                                    if ( !NT_SUCCESS(Status) ){

                                                        //
                                                        // Delete the backup file
                                                        //

                                                        MarkFileForDelete( hBackupFile );
                                                        CloseHandle( hBackupFile );
                                                        hBackupFile = 0;
    EfsErrPrint("Failed to write the log file.\n");
                                                    }
                                                }


                                            } else {
                                                MarkFileForDelete( hBackupFile );
                                                CloseHandle( hBackupFile );
                                                hBackupFile = 0;
EfsErrPrint("Failed to create the Log header.\n");
                                            }

                                        } else {

                                            //
                                            // Fail to create the backup file
                                            // Log it.
                                            //

                                            EfsLogEntry(
                                                EVENTLOG_ERROR_TYPE,
                                                0,
                                                EFS_TMP_FILE_ERROR,
                                                1,
                                                sizeof(NTSTATUS),
                                                (LPCWSTR *)&SourceFileName,
                                                &Status
                                                );

EfsErrPrint("Failed to create the backup file.");
                                        }

                                        if ( NT_SUCCESS(Status) ){

                                            EfsDataLength = InputDataSize - 3 * sizeof(ULONG);

                                            //
                                            // Prepare the FSCTL input data
                                            //

                                            ( VOID ) SendEfs(
                                                         Fek,
                                                         CurrentEfsStream,
                                                         InputData + 3 * sizeof(ULONG),
                                                         &EfsDataLength
                                                         );


                                            ( VOID ) EncryptFSCTLData(
                                                        EFS_SET_ENCRYPT,
                                                        EFS_ENCRYPT_FILE,
                                                        EFS_ENCRYPT_FILE,
                                                        InputData + 3*sizeof(ULONG),
                                                        EfsDataLength,
                                                        InputData,
                                                        &InputDataSize
                                                        );

                                            //
                                            //   Write the $EFS and turn on the bits
                                            //

                                            Status = NtFsControlFile(
                                                        hSourceFile,
                                                        0,
                                                        NULL,
                                                        NULL,
                                                        &IoStatusBlock,
                                                        FSCTL_SET_ENCRYPTION,
                                                        InputData,
                                                        InputDataSize,
                                                        NULL,
                                                        0
                                                        );

                                            if ( NT_SUCCESS( Status ) ){

                                                //
                                                // All failures from here on out need to be closed
                                                // with another FSCTL call.
                                                //


                                                //
                                                // Enumerate the streams again, and make sure nothing
                                                // has changed
                                                //
                                                
                                                Status = GetStreamInformation(
                                                             hSourceFile,
                                                             &LaterStreamInfoBase,    // Free this
                                                             &LaterStreamInfoSize
                                                             );

                                                if (NT_SUCCESS( Status )) {

                                                    if (StreamInfoSize == LaterStreamInfoSize) {

                                                        //
                                                        // Compare the original stream info structure with the one we just got,
                                                        // and make sure they're identical.  If not, punt.
                                                        //

                                                        ULONG rc = StringInfoCmp(StreamInfoBase, LaterStreamInfoBase, StreamInfoSize);

                                                        if (rc == 0) {

                                                            //
                                                            // Copy the file to the backup file.  Success if target exists
                                                            // (because the make temporary file command creates it).
                                                            //

                                                            PHANDLE TargetHandles;

                                                            //
                                                            // Revert to self to be able to open the multiple streams on the backup file
                                                            //

                                                            RpcRevertToSelf();

                                                            hResult = MyCopyFile(
                                                                        hSourceFile,        // handle to the file we're copying from (source file)
                                                                        StreamNames,        // names of the streams of the source file
                                                                        StreamHandles,      // handles to the streams of the source file
                                                                        StreamSizes,        // sizes of the streams of the source file
                                                                        StreamCount,        // number of streams we're copying, including unnamed data stream
                                                                        hBackupFile,         // Backup file handle
                                                                        &TargetHandles      // new handles of corresponding streams on backup file
                                                                        );

                                                            //
                                                            // Even the impersonation failed, it is OK. We already got all the handles we need.
                                                            // There shouldn't be security risk here. All the parameters from untrusted source have been 
                                                            // validated. Buffer overrun is not likely happen from here. Impersonation have been done multiple
                                                            // times in this code path. It is very unlikely that this would fail.
                                                            //

                                                            ( VOID ) RpcImpersonateClient( NULL );

                                                            if (hResult == ERROR_SUCCESS) {

                                                                //
                                                                // The backup file now exists and has data in it.
                                                                // We do not check the error code of WriteLogFile for the following reasons,
                                                                // 1. We are overwriting the sectors, out of disk space is not possible. The sectors have
                                                                //     just been written, defective sector is very unlikely.
                                                                // 2. In case, the sector becomes defective between the two writes. More than 99.99%
                                                                //     we can still finish the job without any problem.
                                                                // 3. In real life, it is very unlikely that power down or crash happens here and the sectors
                                                                //     just become defective right after last write.
                                                                //
                                                                // When TxF is used later, this will not be an issue.
                                                                //

                                                                if (LogFileH){

                                                                    ( VOID )WriteLogFile(
                                                                                    LogFileH,
                                                                                    VolInfo.BytesPerSector,
                                                                                    StatusInfoOffset,
                                                                                    EncryptTmpFileWritten
                                                                                    );

                                                                }

                                                               hResult = CheckOpenSection(
                                                                                        StreamSizes,
                                                                                        StreamHandles,
                                                                                        StreamCount
                                                                                        );

                                                               if ( ERROR_SUCCESS == hResult ){
                                                                    hResult =  CompressStreams(
                                                                                            StreamSizes,
                                                                                            StreamHandles,
                                                                                            COMPRESSION_FORMAT_NONE,
                                                                                            StreamCount
                                                                                            );
if (ERROR_SUCCESS != hResult) {
    EfsErrPrint("CompressStreams Failed. Win Error=%d\n",hResult);
}
                                                                } else {

                                                                    DebugLog((DEB_ERROR, "CheckOpenSection returned %d\n" ,hResult  ));

EfsErrPrint("Failed to check the open section. Win Error=%d\n",hResult);
                                                                }


                                                                if ( ERROR_SUCCESS == hResult ){
                                                                    //
                                                                    // Reuse the input data buffer for each stream
                                                                    // FSCTL call.
                                                                    //

                                                                    ( VOID )SendEfs(
                                                                                Fek,
                                                                                CurrentEfsStream,
                                                                                InputData + 3 * sizeof(ULONG),
                                                                                &EfsDataLength
                                                                                );


                                                                    ( VOID ) EncryptFSCTLData(
                                                                                EFS_SET_ENCRYPT,
                                                                                EFS_ENCRYPT_STREAM,
                                                                                EFS_ENCRYPT_STREAM,
                                                                                InputData + 3*sizeof(ULONG),
                                                                                EfsDataLength,
                                                                                InputData,
                                                                                &InputDataSize
                                                                                );

                                                                    //
                                                                    // Copy each stream from the backup to the original.
                                                                    // CopyFileStreams attempts to undo things in case of problems,
                                                                    // so we just have to report success or failure.
                                                                    //

                                                                    hResult = CopyFileStreams(
                                                                                 TargetHandles,     // handles to streams on the backup file
                                                                                 StreamHandles,     // handles to streams on the source file
                                                                                 StreamCount,       // number of streams
                                                                                 StreamSizes,       // sizes of streams
                                                                                 Encrypting,        // mark StreamHandles as Encrypted before copy
                                                                                 InputData,         // FSCTL input data
                                                                                 InputDataSize,     // FSCTL input data size
                                                                                 &CleanupSuccessful
                                                                                 );

                                                                    if (hResult != ERROR_SUCCESS) {
EfsErrPrint("CopyFileStreams Failed. Win Error=%d\n",hResult);
                                                                        DebugLog((DEB_ERROR, "CopyFileStreams returned %d\n" ,hResult  ));
                                                                    }
                                                                }

                                                                LsapFreeLsaHeap( Fek );
                                                                Fek = NULL;

                                                                if (hResult == ERROR_SUCCESS || CleanupSuccessful) {

                                                                    if (hResult == ERROR_SUCCESS) {

                                                                        //
                                                                        // Encryption is almost done. The file is still in a transit status
                                                                        // No error checking for writing the log file for the same reason
                                                                        // mentioned above.
                                                                        //

                                                                        if (LogFileH){

                                                                            ( VOID )WriteLogFile(
                                                                                            LogFileH,
                                                                                            VolInfo.BytesPerSector,
                                                                                            StatusInfoOffset,
                                                                                            EncryptionDone
                                                                                            );

                                                                        }

                                                                        //
                                                                        // Reuse the InputData buffer.
                                                                        // FSCTL Mark encryption success
                                                                        //

                                                                        Status = SendSkFsctl(
                                                                                        0,
                                                                                        0,
                                                                                        EFS_ENCRYPT_DONE,
                                                                                        InputData,
                                                                                        InputDataSize,
                                                                                        hSourceFile,
                                                                                        FSCTL_ENCRYPTION_FSCTL_IO,
                                                                                        &IoStatusBlock
                                                                                        );

                                                                    } else {
                                                                        //
                                                                        // FSCTL Fail Encrypting. We can reuse the InputData.
                                                                        // No stream has been encrypted yet.
                                                                        // Decrypt File will do the trick to restore the file status.
                                                                        //

                                                                        if (LogFileH){

                                                                            ( VOID )WriteLogFile(
                                                                                            LogFileH,
                                                                                            VolInfo.BytesPerSector,
                                                                                            StatusInfoOffset,
                                                                                            EncryptionBackout
                                                                                            );

                                                                        }

                                                                        ( VOID ) EndErrorEncryptFile(
                                                                                            hSourceFile,
                                                                                            InputData,
                                                                                            InputDataSize,
                                                                                            &IoStatusBlock
                                                                                            );

                                                                    }

                                                                    if (LogFileH){

                                                                        ( VOID )WriteLogFile(
                                                                                        LogFileH,
                                                                                        VolInfo.BytesPerSector,
                                                                                        StatusInfoOffset,
                                                                                        EncryptionSrcDone
                                                                                        );

                                                                    }

                                                                    //
                                                                    // Either the operation worked, or it failed but we managed to clean
                                                                    // up after ourselves.  In either case, we no longer need the backup
                                                                    // file or the log file.
                                                                    //
                                                                    // Delete the backup file first.
                                                                    //

                                                                    LONG j;
                                                                    // Do we need delete each stream?
                                                                    for (j=StreamCount - 1 ; j >= 0 ; j--) {
                                                                        MarkFileForDelete( TargetHandles[j] );
                                                                    }

                                                                } else {

                                                                    //
                                                                    // The operation failed and we couldn't clean up.  Keep the
                                                                    // log file and the backup file around so we can retry on
                                                                    // reboot.
                                                                    //

                                                                    if (LogFileH){

                                                                        KeepLogFile = TRUE;

                                                                        ( VOID )WriteLogFile(
                                                                                        LogFileH,
                                                                                        VolInfo.BytesPerSector,
                                                                                        StatusInfoOffset,
                                                                                        EncryptionMessup
                                                                                        );

                                                                    }

                                                                }

                                                                //
                                                                // Regardless of what happened, we don't need these any more.
                                                                //

                                                                LONG j;

                                                                for ( j = StreamCount -1 ; j >=0; j--) {
                                                                    CloseHandle( TargetHandles[j] );
                                                                }
                                                                hBackupFile = 0;

                                                                LsapFreeLsaHeap( TargetHandles );

                                                            } else {

                                                                //
                                                                // We couldn't copy everything to the backup file.
                                                                // No need to record error log information after this point.
                                                                // Tell the driver that the operation has failed.
                                                                //
                                                                // MyCopyFile has already taken care of cleaning up the
                                                                // backup file.
                                                                //
                                                                hBackupFile = 0;
                                                                DebugLog((DEB_ERROR, "MyCopyFile failed, error = %d\n" ,hResult  ));

                                                                LsapFreeLsaHeap( Fek );
                                                                Fek = NULL;
                                                                //
                                                                // FSCTL Fail Encrypting. We can reuse the InputData.
                                                                // No stream has been encrypted yet.
                                                                // Decrypt File will do the trick to restore the file status.
                                                                //

                                                                //
                                                                // We ignore the return status from FSCTL call,
                                                                // If it is failed, the only way to restore the status
                                                                // is by rebooting the system.
                                                                //
                                                                // Robert Reichel, you need think about what happened if
                                                                // the following call failed, although it is very unlikely.
                                                                // If the call fails and the log file gets removed, the file
                                                                // will be unaccessible. Convert the return code to hResult is
                                                                // obviously not correct.
                                                                //

                                                                ( VOID ) EndErrorEncryptFile(
                                                                                    hSourceFile,
                                                                                    InputData,
                                                                                    InputDataSize,
                                                                                    &IoStatusBlock
                                                                                    );

EfsErrPrint("Failed to make a copy of the file. Win Error=%d\n",hResult);
                                                            }

                                                       } else {

                                                            //
                                                            // Somebody added/removed stream(s).
                                                            // FSCTL Fail Encrypting. We can reuse the InputData.
                                                            // No stream has been encrypted yet.
                                                            // Decrypt File will do the trick to restore the file status.
                                                            //
                                                            MarkFileForDelete( hBackupFile );

                                                            LsapFreeLsaHeap( Fek );
                                                            Fek = NULL;
                                                            ( VOID ) EndErrorEncryptFile(
                                                                                hSourceFile,
                                                                                InputData,
                                                                                InputDataSize,
                                                                                &IoStatusBlock
                                                                                );

                                                            hResult = ERROR_ENCRYPTION_FAILED;
EfsErrPrint("Streams changed while doing encryption, StringInfoCmp(). Win Error=%d\n",hResult);
                                                        }

                                                    } else {

                                                        //
                                                        // Stream info size changed
                                                        // FSCTL Fail Encrypting. We can reuse the InputData.
                                                        // No stream has been encrypted yet.
                                                        // Decrypt File will do the trick to restore the file status.
                                                        //
                                                        MarkFileForDelete( hBackupFile );

                                                        LsapFreeLsaHeap( Fek );
                                                        Fek = NULL;
                                                        //
                                                        // We ignore the return status from FSCTL call,
                                                        // If it is failed, the only way to restore the status
                                                        // is by rebooting the system.
                                                        //
                                                        // Robert Reichel, you need think about what happened if
                                                        // the following call failed, although it is very unlikely.
                                                        // If the call fails and the log file gets removed, the file
                                                        // will be unaccessible. Convert the return code to hResult is
                                                        // obviously not correct.
                                                        //

                                                        ( VOID ) EndErrorEncryptFile(
                                                                            hSourceFile,
                                                                            InputData,
                                                                            InputDataSize,
                                                                            &IoStatusBlock
                                                                            );

                                                        hResult = ERROR_ENCRYPTION_FAILED;
EfsErrPrint("Streams changed while doing encryption, Size not eaqual. Win Error=%d\n",hResult);
                                                    }

                                                    LsapFreeLsaHeap( LaterStreamInfoBase );

                                                } else {

                                                    //
                                                    // GetStreamInformation() Failed
                                                    // FSCTL Fail Encrypting. We can reuse the InputData.
                                                    // No stream has been encrypted yet.
                                                    // Decrypt File will do the trick to restore the file status.
                                                    //
                                                    MarkFileForDelete( hBackupFile );

                                                    ( VOID ) EndErrorEncryptFile(
                                                                        hSourceFile,
                                                                        InputData,
                                                                        InputDataSize,
                                                                        &IoStatusBlock
                                                                        );

                                                    LsapFreeLsaHeap( Fek );
                                                    Fek = NULL;
                                                    hResult = RtlNtStatusToDosError( Status );
                                                    DebugLog((DEB_ERROR, "GetStreamInformation failed, error = %d\n" ,hResult  ));
EfsErrPrint("Cannot get the Streams for verification. Win Error=%d\n",hResult);
                                                }
                                            } else {

                                                //
                                                // Set encryption failed. No bits are turned on.
                                                // Only the unnamed data stream is created in temp file
                                                //
                                                MarkFileForDelete( hBackupFile );

                                                LsapFreeLsaHeap( Fek );
                                                Fek = NULL;
                                                DebugLog((DEB_ERROR, "EncryptFileSrv: NtFsControlFile failed, status = (%x)\n" ,Status  ));
                                                hResult = RtlNtStatusToDosError( Status );

                                                //
                                                // Make sure the error was mapped
                                                //

                                                if (hResult == ERROR_MR_MID_NOT_FOUND) {

                                                    DebugLog((DEB_WARN, "Unable to map NT Error (%x) to Win32 error, returning ERROR_ENCRYPTION_FAILED\n" , Status  ));
                                                    hResult = ERROR_ENCRYPTION_FAILED;
                                                }

                                                EfsErrPrint("Failed to write the $EFS or turn on the bit. Win Error=%d\n",hResult);
                                            }

                                        } else {

                                            //
                                            // Create Backup File failed or write log file failed
                                            // Temp file is already deleted.
                                            //
                                            LsapFreeLsaHeap( Fek );
                                            Fek = NULL;
                                            DebugLog((DEB_ERROR, "EncryptFileSrv: CreateBackupFile or CreateLogHeader failed, status = (%x)\n" ,Status  ));
                                            hResult = RtlNtStatusToDosError( Status );

                                            //
                                            // Make sure the error was mapped
                                            //

                                            if (hResult == ERROR_MR_MID_NOT_FOUND) {

                                                DebugLog((DEB_WARN, "Unable to map NT Error (%x) to Win32 error, returning ERROR_ENCRYPTION_FAILED\n" , Status  ));
                                                hResult = ERROR_ENCRYPTION_FAILED;
                                            }

                                        }

                                        if ( hBackupFile ){
                                            CloseHandle( hBackupFile );
                                            hBackupFile = 0;
                                        }

                                        SafeAllocaFree( InputData );

                                    } else {

                                        LsapFreeLsaHeap( Fek );
                                        Fek = NULL;
                                        hResult = ERROR_NOT_ENOUGH_MEMORY;
                                        EfsErrPrint("Out of memory.\n");
                                    }

                                    LsapFreeLsaHeap( CurrentEfsStream );

                                } else {

                                    hResult = GetLastError();

                                    DebugLog((DEB_ERROR, "ConstructEFS returned %x\n" ,hResult  ));
                                    LsapFreeLsaHeap( Fek );
                                    Fek = NULL;

EfsErrPrint("Failed to generate the FEK. Win Error=%d\n",hResult);
                                }

                            } else {

                                hResult = GetLastError();

EfsErrPrint("Failed to generate the FEK. Win Error=%d\n",hResult);
                            }

                            CleanupOpenFileStreams(
                                                StreamHandles,
                                                StreamNames,
                                                StreamSizes,
                                                NULL,
                                                hSourceFile,
                                                StreamCount
                                                );

                            StreamHandles = NULL;
                            StreamNames = NULL;
                            hSourceFile = NULL;

                        } else {

                            DebugLog((DEB_ERROR, "OpenFileStreams returned %d\n" ,hResult  ));
EfsErrPrint("Failed to open all the streams. Win Error=%d\n",hResult);
                        }


                        LsapFreeLsaHeap( StreamInfoBase );
                        StreamInfoBase = NULL;

                    } else {

                        //
                        // Unable to get stream information
                        //

                        DebugLog((DEB_ERROR, "Unable to obtain stream information, status = %x\n" ,Status  ));

                        hResult = RtlNtStatusToDosError( Status );

                        //
                        // Make sure the error was mapped
                        //

                        if (hResult == ERROR_MR_MID_NOT_FOUND) {

                            DebugLog((DEB_WARN, "Unable to map NT Error (%x) to Win32 error, returning ERROR_ENCRYPTION_FAILED\n" , Status  ));
                            hResult = ERROR_ENCRYPTION_FAILED;
                        }
EfsErrPrint("Failed to get all streams. Win Error=%d\n",hResult);
                    }
                }

                //
                // Free ParentEfsStream
                //

                if ( ParentEfsStream ){

                    LsapFreeLsaHeap( ParentEfsStream );

                }

            } else {

                //
                // GetParentEfsStream failed
                //


                hResult = RtlNtStatusToDosError( Status );

                //
                // Make sure the error was mapped
                //

                if (hResult == ERROR_MR_MID_NOT_FOUND) {

                    DebugLog((DEB_WARN, "Unable to map NT Error (%x) to Win32 error, returning ERROR_ENCRYPTION_FAILED\n" , Status  ));
                    hResult = ERROR_ENCRYPTION_FAILED;
                }
EfsErrPrint("GetParentEfsStream failed. Win Error=%d\n",hResult);

            }
        } else {

            //
            //  Either get volume info failed or get target file ID failed
            //
            if ( !NT_SUCCESS(Status1) ){
                Status = Status1;
            }
            hResult = RtlNtStatusToDosError( Status );

            //
            // Make sure the error was mapped
            //

            if (hResult == ERROR_MR_MID_NOT_FOUND) {

                DebugLog((DEB_WARN, "Unable to map NT Error (%x) to Win32 error, returning ERROR_ENCRYPTION_FAILED\n" , Status  ));
                hResult = ERROR_ENCRYPTION_FAILED;
            }

EfsErrPrint("Either get volume info failed or get target file ID failed. Win Error=%d\n",hResult);
        }

        if ( hSourceFile ){
            CloseHandle( hSourceFile );
        }

    } else {

        //
        // Open source file failed
        //

        hResult = GetLastError();
        EfsErrPrint("EFS Open source file failed. Win Error=%d FileName=%ws\n",
                    hResult,
                    SourceFileName);
    }

    if (!KeepLogFile && LogFileH){
        //
        // Delete the Log File
        //

        MarkFileForDelete( LogFileH );
    }

    SafeAllocaFree(SourceFileName);

    if (hResult != ERROR_SUCCESS){
        DebugLog((DEB_WARN, "EncryptFileSrv returning %x\n", hResult  ));
    }

    return( hResult );
}


DWORD
DecryptFileSrv(
    IN PUNICODE_STRING SourceFileNameU,
    IN HANDLE LogFileH,
    IN ULONG Recovery
    )
/*++

Routine Description:

    This routine is the top level routine of the EncryptFile API.  It
    opens the passed source file and copies all of its data streams to
    a backup file in a known location.  It then marks all of the streams
    of the source as encrypted, and copies them back.

Arguments:

    SourceFileName - Supplies a Unicode string with the name of
        the file to be encrypted.

    LogFileH - Log file handle. Log file is zero size when passed in.

    Recovery - If the decryption is for recovery or not

Return Value:

    ERROR_SUCCESS on success, other on failure.

--*/
{
    BOOL                     b = TRUE;
    BOOLEAN                  CleanupSuccessful = FALSE;
    BOOLEAN                  KeepLogFile = FALSE;

    ULONG                    StatusInfoOffset = 0 ;
    DWORD                    hResult = ERROR_SUCCESS;
    DWORD                    FileAttributes;

    HANDLE                   FileHandle;
    HANDLE                   hSourceFile = NULL;
    HANDLE                   hBackupFile = NULL;
    PHANDLE                  StreamHandles = NULL;

    LPWSTR                   SourceFileName = NULL;
    LPWSTR                   BackupFileName = NULL;

    FILE_FS_SIZE_INFORMATION   VolInfo;
    FILE_INTERNAL_INFORMATION  SourceID;
    FILE_INTERNAL_INFORMATION  BackupID;

    NTSTATUS                 Status = STATUS_SUCCESS;

    OBJECT_ATTRIBUTES        Obja;

    PFILE_STREAM_INFORMATION LaterStreamInfoBase = NULL;
    PFILE_STREAM_INFORMATION StreamInfoBase = NULL;

    PEFS_STREAM_SIZE         StreamSizes = NULL;

    PUNICODE_STRING          StreamNames = NULL;

    UINT                     TmpResult;

    ULONG                    LaterStreamInfoSize = 0;
    ULONG                    StreamCount    = 0;
    ULONG                    StreamInfoSize = 0;
    ULONG                    i;
    DWORD                    tmpDW;

    IO_STATUS_BLOCK IoStatusBlock;
    ULONG InputDataSize;
    ULONG EfsDataLength;
    PUCHAR InputData = NULL;
    ULONG   CreateOption = FILE_SYNCHRONOUS_IO_NONALERT;
    UNICODE_STRING SrcNtName;
    WORD WebDavPath = 0;

    if (!LogFileH){
        //
        //  No LogFile means WEBDAVPATH
        //

        WebDavPath = WEBDAVPATH;
    }

    //
    // Convert the source file name into an LPWSTR
    //

    SafeAllocaAllocate(SourceFileName, SourceFileNameU->Length + sizeof(UNICODE_NULL));

    if (SourceFileName == NULL){
        hResult = ERROR_NOT_ENOUGH_MEMORY;
        goto Cleanup;
    }

    InputDataSize = 7 * sizeof ( ULONG ) + 2 * sizeof ( DriverSessionKey );

    SafeAllocaAllocate(InputData, InputDataSize);

    if ( InputData == NULL ){
        hResult = ERROR_NOT_ENOUGH_MEMORY;
        goto Cleanup;
    }

    EfsDataLength = InputDataSize - 3 * sizeof ( ULONG );


    SourceFileName[SourceFileNameU->Length/sizeof(WCHAR)] = UNICODE_NULL;
    RtlCopyMemory( SourceFileName, SourceFileNameU->Buffer, SourceFileNameU->Length );

    DebugLog((DEB_TRACE_EFS, "Decrypting file %ws \n", SourceFileName));

    FileAttributes = GetFileAttributes( SourceFileName );

    if (FileAttributes == -1)
    {
        hResult = GetLastError();
        goto Cleanup;
    }

    if (!(FileAttributes & FILE_ATTRIBUTE_DIRECTORY)){
        CreateOption |= FILE_OPEN_REPARSE_POINT;
    }

    b =  RtlDosPathNameToNtPathName_U(
                        SourceFileName,
                        &SrcNtName,
                        NULL,
                        NULL
                        );

    if ( b ){

        InitializeObjectAttributes(
                    &Obja,
                    &SrcNtName,
                    OBJ_CASE_INSENSITIVE,
                    0,
                    NULL
                    );

        Status = NtCreateFile(
                        &hSourceFile,
                        FILE_READ_DATA | FILE_WRITE_DATA | FILE_READ_ATTRIBUTES | FILE_WRITE_ATTRIBUTES | SYNCHRONIZE,
                        &Obja,
                        &IoStatusBlock,
                        NULL,
                        0,
                        0,
                        FILE_OPEN,
                        CreateOption,
                        NULL,
                        0
                        );

        //
        //  Free the NT name
        //
        RtlFreeHeap(
            RtlProcessHeap(),
            0,
            SrcNtName.Buffer
            );

    } else {

        //
        //   The error code here is not quite accurate here. It is very unlikely
        //   getting here. Possibly out of memory
        //

        Status =  STATUS_ENCRYPTION_FAILED;
        hResult = GetLastError();

    }

    if ( NT_SUCCESS( Status ) ) {

        //
        // Determine if this path is to a directory or a file.  If it's a directory,
        // we have very little to do.
        //

        Status = NtQueryVolumeInformationFile(
            hSourceFile,
            &IoStatusBlock,
            &VolInfo,
            sizeof ( FILE_FS_SIZE_INFORMATION ),
            FileFsSizeInformation
            );

        if ( NT_SUCCESS( Status ) && (WebDavPath != WEBDAVPATH) ){

            Status = NtQueryInformationFile(
                hSourceFile,
                &IoStatusBlock,
                &SourceID,
                sizeof ( FILE_INTERNAL_INFORMATION ),
                FileInternalInformation
                );

        }

        if ( !NT_SUCCESS( Status ) ){
            hResult = RtlNtStatusToDosError( Status );

            //
            // Make sure the error was mapped
            //

            if (hResult == ERROR_MR_MID_NOT_FOUND){
                DebugLog((DEB_WARN,
                          "Unable to map NT Error (%x) to Win32 error, returning ERROR_ENCRYPTION_FAILED\n",
                          Status));

                hResult = ERROR_DECRYPTION_FAILED;
            }

            goto Cleanup;
        }

        if (FileAttributes & FILE_ATTRIBUTE_DIRECTORY) {

            //
            //  We do not check the operation of the LOG.
            //  Should we fail the normal operation just because the LOG operations
            //  failed?  The answer is probably not. The chance to use the LOG file is very
            //  slim. We will use TxF when it is ready and we have time to deal with this.
            //

            if (LogFileH) {
                CreateLogHeader(
                    LogFileH,
                    VolInfo.BytesPerSector,
                    &(SourceID.IndexNumber),
                    NULL,
                    SourceFileName,
                    NULL,
                    Decrypting,
                    BeginDecryptDir,
                    NULL
                    );
            }

            //
            // FSCTL Do Directory stuff
            //

    
            Status =  SendSkFsctl(
                            EFS_DECRYPT_STREAM,
                            EFS_DECRYPT_DIRSTR,
                            EFS_SET_ENCRYPT,
                            InputData,
                            InputDataSize,
                            hSourceFile,
                            FSCTL_SET_ENCRYPTION,
                            &IoStatusBlock
                            );

            if ( NT_SUCCESS( Status ) && IoStatusBlock.Information ){

                // 
                // IoStatusBlock.Information != 0 means there is no more encrypted
                // streams in the file (or dir).
                // If the following call failed, we could hardly restore the dir to the
                // perfect condition. It is very unlikely to fail here while we
                // succeed above.
                //

                Status =  SendSkFsctl(
                                EFS_DECRYPT_FILE,
                                EFS_DECRYPT_DIRFILE,
                                EFS_SET_ENCRYPT,
                                InputData,
                                InputDataSize,
                                hSourceFile,
                                FSCTL_SET_ENCRYPTION,
                                &IoStatusBlock
                                );

            } else if ( NT_SUCCESS( Status ) && (IoStatusBlock.Information == 0)) {

                //
                // More than 1 streams on the directory were encrypted. Log it.
                //


                EfsLogEntry(
                    EVENTLOG_ERROR_TYPE,
                    0,
                    EFS_DIR_MULTISTR_ERROR,
                    1,
                    0,
                    (LPCWSTR *)&SourceFileName,
                    NULL
                    );

            }
    
            hResult = NT_SUCCESS(Status) ? ERROR_SUCCESS : ERROR_DECRYPTION_FAILED;
            goto Cleanup;
        }

        //
        // Enumerate all the streams on the file
        //

        Status = GetStreamInformation(
                     hSourceFile,
                     &StreamInfoBase,   // Free this
                     &StreamInfoSize
                     );

        if (NT_SUCCESS( Status )) {

            hResult = OpenFileStreams(
                         hSourceFile,
                         0,
                         OPEN_FOR_DEC,
                         StreamInfoBase,
                         FILE_READ_DATA | FILE_WRITE_DATA | FILE_READ_ATTRIBUTES | FILE_WRITE_ATTRIBUTES | SYNCHRONIZE,
                         FILE_OPEN,
                         FILE_SYNCHRONOUS_IO_NONALERT | FILE_OPEN_REPARSE_POINT,
                         &VolInfo,
                         &StreamNames,      // Don't free this!
                         &StreamHandles,    // Free this
                         &StreamSizes,      // Free this
                         &StreamCount
                         );

            if (hResult == ERROR_SUCCESS) {

                //
                // This routine creates the backup file.
                //

                Status = CreateBackupFile(
                                    SourceFileNameU,
                                    &hBackupFile,
                                    &BackupID,
                                    &BackupFileName
                                    );

                //
                // If power down happens right here before
                // the log file header is written, we will have a zero size
                // temp file left on the disk. This is very unlikely and not
                // a big deal we have a zero size file left on the disk.
                //

                if ( NT_SUCCESS(Status) ){

                    if (LogFileH) {
                        Status = CreateLogHeader(
                                            LogFileH,
                                            VolInfo.BytesPerSector,
                                            &(SourceID.IndexNumber),
                                            &(BackupID.IndexNumber),
                                            SourceFileName,
                                            BackupFileName,
                                            Decrypting,
                                            BeginDecryptFile,
                                            &StatusInfoOffset
                                            );
                    }

                    if ( NT_SUCCESS(Status) )
                    {
                        if (LogFileH) {
                            Status = WriteLogFile(
                                            LogFileH,
                                            VolInfo.BytesPerSector,
                                            StatusInfoOffset,
                                            BeginDecryptFile
                                            );
                        }

                        //
                        // Fall through to failure check and error mapping below
                        //
                    }

                } else {

                    //
                    // Fail to create the backup file
                    // Log it.
                    //


                    EfsLogEntry(
                        EVENTLOG_ERROR_TYPE,
                        0,
                        EFS_TMP_FILE_ERROR,
                        1,
                        sizeof(NTSTATUS),
                        (LPCWSTR *)&SourceFileName,
                        &Status
                        );

                }

                if ( NT_SUCCESS(Status) ){

                    //
                    // We have handles to all of the streams of the file
                    //
                    // Enter "Decrypting" state here.  FSCTL call.
                    //
                    // All failures from here on out need to be closed
                    // with another FSCTL call.
                    //
                    Status =  SendSkFsctl(
                                    0,
                                    0,
                                    EFS_DECRYPT_BEGIN,
                                    InputData,
                                    InputDataSize,
                                    hSourceFile,
                                    FSCTL_ENCRYPTION_FSCTL_IO,
                                    &IoStatusBlock
                                    );
                }

                if ( !NT_SUCCESS( Status ) ){
                    //
                    //  Nothing has been done to the file.
                    //

                    CleanupOpenFileStreams(
                                        StreamHandles,
                                        StreamNames,
                                        StreamSizes,
                                        StreamInfoBase,
                                        hSourceFile,
                                        StreamCount
                                        );

                    StreamHandles  = NULL;
                    StreamNames    = NULL;
                    StreamInfoBase = NULL;
                    hSourceFile    = NULL;

                    hResult =  RtlNtStatusToDosError( Status );

                    //
                    // Make sure the error was mapped
                    //

                    if (hResult == ERROR_MR_MID_NOT_FOUND){
                        DebugLog((DEB_WARN,
                                  "Unable to map NT Error (%x) to Win32 error, "
                                      "returning ERROR_ENCRYPTION_FAILED\n",
                                  Status));

                        hResult = ERROR_DECRYPTION_FAILED;
                    }

                    goto Cleanup;
                }

                //
                // Enumerate the streams again, and make sure nothing
                // has changed. From this point on, the file is in TRANSITION
                // status. Any failure should not delete the logfile, unless the FSCTL
                // EFS_ENCRYPT_DONE is called
                //

                Status = GetStreamInformation(
                             hSourceFile,
                             &LaterStreamInfoBase,    // Free this
                             &LaterStreamInfoSize
                             );

                if (NT_SUCCESS( Status )) {

                    if (StreamInfoSize == LaterStreamInfoSize) {

                        //
                        // Compare the original stream info structure with the one we just got,
                        // and make sure they're identical.  If not, punt.
                        //

                        ULONG rc = StringInfoCmp(StreamInfoBase, LaterStreamInfoBase, StreamInfoSize);

                        if (rc == 0) {

                            //
                            // Copy the file to the backup file.  Success if target exists
                            // (because the make temporary file command creates it).
                            //

                            PHANDLE TargetHandles = NULL;

                            //
                            // Revert to self to open multiple streams on the backup file
                            //

                            RpcRevertToSelf();

                            hResult = MyCopyFile(
                                        hSourceFile,        // handle to the file we're copying from (source file)
                                        StreamNames,        // names of the streams of the source file
                                        StreamHandles,      // handles to the streams of the source file
                                        StreamSizes,        // sizes of the streams of the source file
                                        StreamCount,        // number of streams we're copying, including unnamed data stream
                                        hBackupFile,         // Backup file handle
                                        &TargetHandles      // new handles of corresponding streams on backup file
                                        );

                            //
                            // hBackupFile was already closed if MyCopyFile failed and will
                            // be closed along with the rest of the TargetHandles below if
                            // it succeeded.  Either way, we shouldn't close it directly.
                            //

                            hBackupFile = NULL;

                            //
                            // Even the impersonation failed, it is OK. We already got all the handles we need.
                            //

                            ( VOID ) RpcImpersonateClient( NULL );

                            if (hResult == ERROR_SUCCESS) {

                                //
                                // The backup file now exists and has data in it.
                                // We do not check the error code of WriteLogFile for the following reasons,
                                // 1. We are overwriting the sectors, out of disk space is not possible. The sectors have
                                //     just been written, defective sector is very unlikely.
                                // 2. In case, the sector becomes defective between the two writes. More than 99.99%
                                //     we can still finish the job without any problem.
                                // 3. In real life, it is very unlikely that power down or crash happens here and the sectors
                                //     just become defective right after last write.
                                //
                                // When later TxF is used, we will not manage the log file.
                                //

                                if (LogFileH) {
                                    ( VOID )WriteLogFile(
                                                    LogFileH,
                                                    VolInfo.BytesPerSector,
                                                    StatusInfoOffset,
                                                    DecryptTmpFileWritten
                                                    );
                                }


                                hResult = CheckOpenSection(
                                                        StreamSizes,
                                                        StreamHandles,
                                                        StreamCount
                                                        );

                                if ( ERROR_SUCCESS == hResult ){

                                   //
                                    // Reuse the input data buffer for each stream
                                    // FSCTL call.
                                    //

                                    ( VOID )SendHandle(
                                                hSourceFile,
                                                InputData + 3 * sizeof( ULONG ),
                                                &EfsDataLength
                                                );

                                    ( VOID ) EncryptFSCTLData(
                                                EFS_SET_ENCRYPT,
                                                EFS_DECRYPT_STREAM,
                                                EFS_DECRYPT_STREAM,
                                                InputData + 3 * sizeof(ULONG),
                                                EfsDataLength,
                                                InputData,
                                                &InputDataSize
                                                );

                                    //
                                    // Copy each stream from the backup to the original.
                                    // CopyFileStreams attempts to undo things in case of problems,
                                    // so we just have to report success or failure.
                                    //

                                    hResult = CopyFileStreams(
                                                 TargetHandles,     // handles to streams on the backup file
                                                 StreamHandles,     // handles to streams on the source file
                                                 StreamCount,       // number of streams
                                                 StreamSizes,       // sizes of streams
                                                 Decrypting,        // mark StreamHandles as Encrypted before copy
                                                 InputData,         // FSCTL input data
                                                 InputDataSize,     // FSCTL input data size
                                                 &CleanupSuccessful
                                                 );
                                }

                                if (hResult == ERROR_SUCCESS ) {

                                    //
                                    // Encryption is almost done. The file is still in a transit status
                                    // No error checking for writing the log file for the same reason
                                    // mentioned above.
                                    //

                                    if (LogFileH) {
                                        ( VOID )WriteLogFile(
                                                        LogFileH,
                                                        VolInfo.BytesPerSector,
                                                        StatusInfoOffset,
                                                        DecryptionDone
                                                        );
                                    }

                                    //
                                    // FSCTL Mark Decryption success
                                    //

                                    ( VOID ) SendSkFsctl(
                                                    EFS_DECRYPT_FILE,
                                                    EFS_DECRYPT_FILE,
                                                    EFS_SET_ENCRYPT,
                                                    InputData,
                                                    InputDataSize,
                                                    hSourceFile,
                                                    FSCTL_SET_ENCRYPTION,
                                                    &IoStatusBlock
                                                    );

                                    //
                                    // Delete the backup file first.
                                    //

                                    LONG j;


                                    for (j = StreamCount - 1 ; j >= 0 ; j--) {
                                        MarkFileForDelete( TargetHandles[j] );
                                    }

                                } else {

                                    if ( CleanupSuccessful ){

                                        //
                                        // The operation failed, but we could back out cleanly.
                                        // Delete the backup file first.
                                        //

                                        LONG j;


                                        for (j = StreamCount - 1 ; j >= 0 ; j--) {
                                            MarkFileForDelete( TargetHandles[j] );
                                        }


                                    } else {
                                        //
                                        // The operation failed and we couldn't clean up.  Keep the
                                        // log file and the backup file around so we can retry on
                                        // reboot.
                                        //

                                        KeepLogFile = TRUE;
                                    }
                                }

                                //
                                // Regardless of what happened, we don't need these any more.
                                // Note that this closes hBackupFile.
                                //

                                LONG j;

                                for (j=StreamCount - 1 ; j >= 0 ; j--)
                                {
                                    CloseHandle( TargetHandles[j] );
                                }

                                LsapFreeLsaHeap( TargetHandles );

                            } else {

                                //
                                // We couldn't copy everything to the backup file.
                                //
                                // Tell the driver that the operation has failed.
                                //
                                // MyCopyFile has already taken care of cleaning up the
                                // backup file.
                                //

                                DebugLog((DEB_ERROR, "MyCopyFile failed, error = %d\n" ,hResult  ));

                                //
                                // FSCTL Fail Decrypting
                                // EFS_ENCRYPT_DONE will do the trick.
                                //

                                ( VOID ) SendSkFsctl(
                                                0,
                                                0,
                                                EFS_ENCRYPT_DONE,
                                                InputData,
                                                InputDataSize,
                                                hSourceFile,
                                                FSCTL_ENCRYPTION_FSCTL_IO,
                                                &IoStatusBlock
                                                );

                                //
                                // MyCopyFile has already closed hBackupFile
                                //

                            }
                        } else {

                            //
                            // FSCTL Fail Decrypting
                            // EFS_ENCRYPT_DONE will do the trick.
                            //

                            ( VOID ) SendSkFsctl(
                                            0,
                                            0,
                                            EFS_ENCRYPT_DONE,
                                            InputData,
                                            InputDataSize,
                                            hSourceFile,
                                            FSCTL_ENCRYPTION_FSCTL_IO,
                                            &IoStatusBlock
                                            );

                            hResult = ERROR_DECRYPTION_FAILED;
                            goto Cleanup;
                        }

                    } else {

                        //
                        // FSCTL Fail Decrypting
                        // EFS_ENCRYPT_DONE will do the trick.
                        //

                        ( VOID ) SendSkFsctl(
                                        0,
                                        0,
                                        EFS_ENCRYPT_DONE,
                                        InputData,
                                        InputDataSize,
                                        hSourceFile,
                                        FSCTL_ENCRYPTION_FSCTL_IO,
                                        &IoStatusBlock
                                        );

                        hResult = ERROR_DECRYPTION_FAILED;
                        goto Cleanup;
                    }

                } else {

                    //
                    // FSCTL Fail Decrypting
                    // EFS_ENCRYPT_DONE will do the trick.
                    //

                    ( VOID ) SendSkFsctl(
                                    0,
                                    0,
                                    EFS_ENCRYPT_DONE,
                                    InputData,
                                    InputDataSize,
                                    hSourceFile,
                                    FSCTL_ENCRYPTION_FSCTL_IO,
                                    &IoStatusBlock
                                    );

                    hResult = RtlNtStatusToDosError( Status );

                    //
                    // Make sure the error was mapped
                    //

                    if (hResult == ERROR_MR_MID_NOT_FOUND)
                    {
                        DebugLog((DEB_WARN,
                                  "Unable to map NT Error (%x) to Win32 error, "
                                      "returning ERROR_ENCRYPTION_FAILED\n",
                                  Status));

                        hResult = ERROR_DECRYPTION_FAILED;
                    }

                    goto Cleanup;
                }

                CleanupOpenFileStreams(
                                    StreamHandles,
                                    StreamNames,
                                    StreamSizes,
                                    NULL,
                                    hSourceFile,
                                    StreamCount
                                    );

                StreamHandles = NULL;
                StreamNames = NULL;
                hSourceFile = NULL;
            }

        } else {

            hResult = RtlNtStatusToDosError( Status );

            //
            // Make sure the error was mapped
            //

            if (hResult == ERROR_MR_MID_NOT_FOUND)
            {
                DebugLog((DEB_WARN,
                          "Unable to map NT Error (%x) to Win32 error, "
                              "returning ERROR_ENCRYPTION_FAILED\n",
                          Status));

                hResult = ERROR_DECRYPTION_FAILED;
            }

            goto Cleanup;
        }

    } else {

        if ( Status != STATUS_ENCRYPTION_FAILED ){
            //
            // NtCreateFile failed
            //

            if (FileAttributes & FILE_ATTRIBUTE_READONLY) {
                hResult = ERROR_FILE_READ_ONLY;
            } else {

                hResult = RtlNtStatusToDosError( Status );

                //
                // Make sure the error was mapped
                //

                if (hResult == ERROR_MR_MID_NOT_FOUND){
                    DebugLog((DEB_WARN,
                              "Unable to map NT Error (%x) to Win32 error, "
                                  "returning ERROR_ENCRYPTION_FAILED\n",
                              Status));

                    hResult = ERROR_DECRYPTION_FAILED;
                }
            }
        }
        // else   Convert Dos name failed
    }

Cleanup:

    if (!KeepLogFile && LogFileH){
        MarkFileForDelete( LogFileH );
    }

    //
    // Free memory
    //

    SafeAllocaFree( SourceFileName );
    SafeAllocaFree( InputData );

    if (StreamInfoBase){
        LsapFreeLsaHeap( StreamInfoBase );
    }

    if (LaterStreamInfoBase){
        LsapFreeLsaHeap( LaterStreamInfoBase );
    }

    if (BackupFileName){
        LsapFreeLsaHeap( BackupFileName );
    }

    if (hBackupFile){
        MarkFileForDelete( hBackupFile );
        CloseHandle( hBackupFile );
    }

    if ( hSourceFile ){
        CloseHandle( hSourceFile );
    }

    return hResult;
}


DWORD
MyCopyFile(
    HANDLE hSourceFile,
    PUNICODE_STRING StreamNames,
    PHANDLE StreamHandles,
    PEFS_STREAM_SIZE StreamSizes,
    ULONG StreamCount,
    HANDLE hTargetFile,
    PHANDLE * TargetStreamHandles
    )
{

    ULONG i;
    NTSTATUS Status;
    PHANDLE TargetHandles;
    DWORD hResult = 0;
    IO_STATUS_BLOCK IoStatusBlock;

    TargetHandles = (PHANDLE)LsapAllocateLsaHeap( StreamCount * sizeof( HANDLE ));

    if (TargetHandles == NULL) {
        return( ERROR_NOT_ENOUGH_MEMORY );
    }

    RtlZeroMemory( TargetHandles, StreamCount * sizeof( HANDLE ));
    for (i=0 ; i<StreamCount ; i++) {

        //
        // For each stream on the source, create a stream with the same name on the target
        //

        if ( (DEF_STR_LEN == StreamNames[i].Length) &&
             !memcmp( StreamNames[i].Buffer,
                    DEFAULT_STREAM,
                    StreamNames[i].Length
                    )){

            //
            // Default stream
            //

            TargetHandles[i] = hTargetFile;

            if ( !(StreamSizes[i].StreamFlag & FILE_ATTRIBUTE_SPARSE_FILE) ){

                //
                // Reserve space for non sparse stream
                //
                FILE_END_OF_FILE_INFORMATION    FileSize;

                FileSize.EndOfFile = StreamSizes[i].EOFSize;
                Status = NtSetInformationFile(
                            TargetHandles[i],
                            &IoStatusBlock,
                            &FileSize,
                            sizeof(FileSize),
                            FileEndOfFileInformation
                            );

            }  else {

                Status = STATUS_SUCCESS;

            }

        } else {
            OBJECT_ATTRIBUTES Obja;
            PLARGE_INTEGER  AllocSize;

            if ( !(StreamSizes[i].StreamFlag & FILE_ATTRIBUTE_SPARSE_FILE) ){

                //
                // Reserve space for non sparse stream
                //

                AllocSize = &(StreamSizes[i].EOFSize);

            } else {

                AllocSize = NULL;

            }

            InitializeObjectAttributes(
                &Obja,
                &StreamNames[i],
                0,
                hTargetFile,
                NULL
                );

            Status = NtCreateFile(
                        &TargetHandles[i],
#ifdef EFSDBG
                        GENERIC_READ | GENERIC_WRITE | SYNCHRONIZE,
#else
                        GENERIC_READ | GENERIC_WRITE | SYNCHRONIZE | DELETE,
#endif
                        &Obja,
                        &IoStatusBlock,
                        AllocSize,
                        0,
#ifdef EFSDBG
                        FILE_SHARE_DELETE | FILE_SHARE_READ | FILE_SHARE_WRITE,        // have to share with delete-ers, since the main stream is open for delete
#else
                        FILE_SHARE_DELETE,        // have to share with delete-ers, since the main stream is open for delete
#endif
                        FILE_CREATE,
                        FILE_NON_DIRECTORY_FILE | FILE_SYNCHRONOUS_IO_NONALERT | FILE_OPEN_REPARSE_POINT,
                        NULL,
                        0
                        );

            if (!NT_SUCCESS( Status )){

                    //
                    // Just make sure it is zero
                    //

                    TargetHandles[i] = 0;
            }

        }

        if (NT_SUCCESS( Status )) {

            USHORT State = COMPRESSION_FORMAT_NONE;
            ULONG Length;

            if ( StreamSizes[i].StreamFlag & FILE_ATTRIBUTE_COMPRESSED ){

                State = COMPRESSION_FORMAT_DEFAULT;

            }

            //
            // Return code is not checked. Failing to compress or decompress  the
            // the temp file should not prevent the encryption operation.
            //

            (VOID) DeviceIoControl(
                                TargetHandles[i],
                                FSCTL_SET_COMPRESSION,
                                &State,
                                sizeof(USHORT),
                                NULL,
                                0,
                                &Length,
                                FALSE
                                );

            hResult = CopyStream( TargetHandles[i], StreamHandles[i], &StreamSizes[i] );
        }

        if (!NT_SUCCESS( Status ) || hResult != ERROR_SUCCESS) {

            //
            // We either failed in creating a new stream on the target,
            // or in copying it from the source to the target.  Regardless,
            // for each stream we created in the target, delete it.
            //

            ULONG StreamsCreated;

            if (NT_SUCCESS( Status ) || TargetHandles[i]) {

                StreamsCreated = i;

            } else {

                StreamsCreated = i-1;
            }

            ULONG j;

            //
            //  Default stream handle is in TargetHandles[0]
            //

            for ( j = 0 ; j <=StreamsCreated ; j++) {

                //
                // Paranoia: check if the handle is valid.
                //

                if (TargetHandles[j]){
                    MarkFileForDelete( TargetHandles[j] );
                    CloseHandle( TargetHandles[j] );
                }
            }

            LsapFreeLsaHeap( TargetHandles );

            //
            // Just to be safe
            //

            TargetHandles = NULL;

            if (!NT_SUCCESS( Status )) {
                hResult = RtlNtStatusToDosError( Status );
            }
            break;
        }
    }

    *TargetStreamHandles = TargetHandles;

    return( hResult );
}


DWORD
OpenFileStreams(
    IN HANDLE hSourceFile,
    IN ULONG ShareMode,
    IN ULONG Flag,
    IN PFILE_STREAM_INFORMATION StreamInfoBase,
    IN ULONG FileAccess,
    IN ULONG CreateDisposition,
    IN ULONG CreateOption,
    IN  PFILE_FS_SIZE_INFORMATION VolInfo,
    OUT PUNICODE_STRING * StreamNames,
    OUT PHANDLE * StreamHandles,
    OUT PEFS_STREAM_SIZE * StreamSizes,
    OUT PULONG StreamCount
    )
/*++

Routine Description:

    This routine opens the streams of file hSourceFile.

Arguments:

    hSourceFile - Supplies an opened handle to the file being worked.

    ShareMode - The share mode to open the streams.

    Flags - The reason for open the streams.

    StreamInfoBase - Information about the streams;

    StreamNames - The names of the streams.

    StreamHandles - The handles of the streams.

    StreamCount - Number strteams in the file.

    FileAccess - Desired access to the streams.

    CreateDisposition - Create disposition of the streams.

    CreateOption - Create options of the streams.

    StreamSizes - the sizes and attributes of the streams.

Return Value:

    Result of the operation.
--*/
{
    NTSTATUS Status;
    PUNICODE_STRING Names = NULL;
    PHANDLE Handles = NULL;
    PEFS_STREAM_SIZE Sizes = NULL;
    DWORD rc = ERROR_SUCCESS;

    PFILE_STREAM_INFORMATION StreamInfo = StreamInfoBase;
    BOOL b;

    //
    // First, count the number of streams
    //

    if (StreamInfoBase == NULL) {

        //
        // No stream to open. TRUE for most DIR.
        //

        *StreamCount = 0;
        return ERROR_SUCCESS;

    }

    *StreamCount = 0;

    while ( StreamInfo ) {

        (*StreamCount)++;

        if (StreamInfo->NextEntryOffset){
            StreamInfo = (PFILE_STREAM_INFORMATION)((PCHAR) StreamInfo + StreamInfo->NextEntryOffset);
        } else {
            StreamInfo = NULL;
        }
    }

    DebugLog((DEB_TRACE_EFS, "Found %d streams\n",*StreamCount));

    //
    // Allocate enough room for pointers and handles to the streams and their names
    //

    Handles = (PHANDLE)       LsapAllocateLsaHeap( *StreamCount * sizeof( HANDLE ));
    Names = (PUNICODE_STRING) LsapAllocateLsaHeap( *StreamCount * sizeof( UNICODE_STRING ));

    if ( StreamSizes ){
        Sizes = (PEFS_STREAM_SIZE)  LsapAllocateLsaHeap( *StreamCount * sizeof( EFS_STREAM_SIZE ));
    }

    if (Names == NULL || Handles == NULL || (StreamSizes && (Sizes == NULL))) {

        if (Handles != NULL) {
            LsapFreeLsaHeap( Handles );
        }

        if (Names != NULL) {
            LsapFreeLsaHeap( Names );
        }

        if (Sizes != NULL) {
            LsapFreeLsaHeap( Sizes );
        }

        DebugLog((DEB_ERROR, "Out of heap in OpenFileStreams\n"));
        return( ERROR_NOT_ENOUGH_MEMORY );
    }

    //
    // Zero out the handle array to simplify cleanup later
    //

    RtlZeroMemory( Handles, *StreamCount * sizeof( HANDLE ));

    //
    // Open a handle to each stream for exclusive access
    //

    StreamInfo = StreamInfoBase;

    ULONG i = 0;

    while ( StreamInfo ) {

        IO_STATUS_BLOCK IoStatusBlock;

        //
        // Build a string descriptor for the name of the stream.
        //

        Names[i].Buffer = &StreamInfo->StreamName[0];
        Names[i].MaximumLength = Names[i].Length = (USHORT) StreamInfo->StreamNameLength;

        if (Sizes != NULL) {
            Sizes[i].EOFSize = StreamInfo->StreamSize;
            Sizes[i].AllocSize = StreamInfo->StreamAllocationSize;
        }

        DebugLog((DEB_TRACE_EFS, "Opening stream %wZ\n",&Names[i]));

        if ( StreamInfo->NextEntryOffset ){
            StreamInfo = (PFILE_STREAM_INFORMATION)((PCHAR) StreamInfo + StreamInfo->NextEntryOffset);
        } else {
            StreamInfo = NULL;
        }

        //
        // To avoid sharing violation, we do not open the default stream again.
        // This also improves the performance
        //

        if ( (DEF_STR_LEN == Names[i].Length) &&
             !memcmp( Names[i].Buffer,
                    DEFAULT_STREAM,
                    DEF_STR_LEN
                    )
           ){

            Handles[i] = hSourceFile;
            Status = STATUS_SUCCESS;

        } else {

            //
            // Open the source stream.
            //

            OBJECT_ATTRIBUTES Obja;

            InitializeObjectAttributes(
                &Obja,
                &Names[i],
                0,
                hSourceFile,
                NULL
                );

            Status = NtCreateFile(
                        &Handles[i],
                        FileAccess,
                        &Obja,
                        &IoStatusBlock,
                        NULL,
                        0,
                        ShareMode,
                        FILE_OPEN,
                        CreateOption,
                        NULL,
                        0
                        );

        }

        if ( NT_SUCCESS(Status) && ( Flag != OPEN_FOR_EXP ) ){

            //
            // Flush the streams. This is not allowed in export because of the permission.
            //

            Status = NtFlushBuffersFile(
                                Handles[i],
                                &IoStatusBlock
                                );

        }

        if ( (Sizes != NULL) && NT_SUCCESS(Status) ) {

            FILE_BASIC_INFORMATION  StreamBasicInfo;
            IO_STATUS_BLOCK IoStatusBlock;

            //
            // Get File Attributes
            //
            Status = NtQueryInformationFile(
                Handles[i],
                &IoStatusBlock,
                &StreamBasicInfo,
                sizeof ( FILE_BASIC_INFORMATION ),
                FileBasicInformation
                );

            if (NT_SUCCESS(Status)){
                Sizes[i].StreamFlag = StreamBasicInfo.FileAttributes;
            }

        }

        if ( !NT_SUCCESS(Status) ) {

            DebugLog((DEB_ERROR, "Unable to open stream %wZ, status = (%x)\n", &Names[i], Status ));
            rc = RtlNtStatusToDosError( Status );

            //
            // In case the error isn't mapped, make sure we return something intelligent
            //

            if (rc == ERROR_MR_MID_NOT_FOUND) {
                DebugLog((DEB_TRACE_EFS, "OpenFileStreams returning ERROR_ENCRYPTION_FAILED\n" ));
                rc = ERROR_ENCRYPTION_FAILED;
            }

           break;

        }

        i++;
    }

    //
    // Estimate the space for Encrypt or Decrypt operation
    //

    if ( (rc == ERROR_SUCCESS) &&
          ((Flag == OPEN_FOR_ENC) || (Flag == OPEN_FOR_DEC))){

        rc = CheckVolumeSpace( VolInfo, Sizes, Handles, *StreamCount);

    }

    if ( rc != ERROR_SUCCESS ) {

        ULONG j;

        for (j=0 ; j<i ; j++) {
            if ( hSourceFile != Handles[j] ){
                NtClose( Handles[j] );
            }
        }
    }

    if ( rc == ERROR_SUCCESS ) {

        *StreamNames = Names;
        *StreamHandles = Handles;
        if (StreamSizes){
            *StreamSizes = Sizes;
        }

    } else {

        LsapFreeLsaHeap( Names);
        LsapFreeLsaHeap( Handles);
        if ( Sizes ){
            LsapFreeLsaHeap( Sizes);
        }

    }

    return( rc );
}


NTSTATUS
GetStreamInformation(
    IN HANDLE SourceFile,
    OUT PFILE_STREAM_INFORMATION * StreamInfoBase,
    OUT PULONG StreamInfoSize
    )

/*++

Routine Description:

    This routine queries the stream information from the passed source file.

Arguments:

    SourceFile - Supplies an opened handle to the file being queried.

    StreamInfoBase - Returns a pointer to the stream information as returned
        by NtQueryInformationFile().

    StreamInfoSize - Returns the size of the information returned in the
        StreamInfoBase parameter.

Return Value:

    STATUS_SUCCESS on success, else failure, either from RtlAllocateHeap()
        or NtQueryInformationFile();

--*/

{
    NTSTATUS Status;
    IO_STATUS_BLOCK IoStatusBlock;

    *StreamInfoSize = 4096;

    //
    // Stolen from CreateDirectoryExW (base\client\dir.c)
    //

    do {
        *StreamInfoBase = (PFILE_STREAM_INFORMATION)LsapAllocateLsaHeap( *StreamInfoSize);
        if ( NULL == *StreamInfoBase ) {
            return( STATUS_NO_MEMORY );
            }
        RtlZeroMemory(*StreamInfoBase, *StreamInfoSize);

        Status = NtQueryInformationFile(
                    SourceFile,
                    &IoStatusBlock,
                    (PVOID) *StreamInfoBase,
                    *StreamInfoSize,
                    FileStreamInformation
                    );

        if ( !NT_SUCCESS(Status) ) {
            LsapFreeLsaHeap( *StreamInfoBase);
            *StreamInfoBase = NULL;
            *StreamInfoSize *= 2;
        } else {
            if (IoStatusBlock.Information == 0) {

                //
                // No data stream were found. True for most DIR.
                //

                LsapFreeLsaHeap( *StreamInfoBase);
                *StreamInfoBase = NULL;
                *StreamInfoSize = 0;

            }
        }

    } while ( Status == STATUS_BUFFER_OVERFLOW ||
              Status == STATUS_BUFFER_TOO_SMALL );

    return( Status );
}


DWORD
CopyFileStreams(
    PHANDLE SourceStreams,
    PHANDLE StreamHandles,
    ULONG StreamCount,
    PEFS_STREAM_SIZE StreamSizes,
    EFSP_OPERATION Operation,
    PUCHAR FsInputData,
    ULONG FsInputDataSize,
    PBOOLEAN CleanupSuccessful
    )

/*++

Routine Description:

    This routine takes an array of source handles and target handles
    and attempts to copy the sources to the targets, in the order
    that the handles appear in the arrays.

    If there is an error part of the way through, this routine will
    try to clean up as well as it can, and return to the user whether
    or not to consider the target file corrupted.

Arguments:

    SourceStreams - Supplies an array of handles to streams to be copied.

    StreamHandles - Supplies an array of handles of target streams to be
        copied into.

    StreamCount - Supplies the number of elemets in the first two arrays.

    StreamSizes - Supplies an array of sizes of the streams being copied.

    Operation - Whether the streams are being encrypted or decrypted.

    FsInputData - Supplies the input data for the FSCTL_SET_ENCRYPTION call.

    FsInputDataSize - The length of FsInputData.

    CleanupSuccessful - If there is a failure, this parameter will return
        whether or not one or more of the streams on the file has been
        corrupted.


Return Value:

    ERROR_SUCCESS on success, failure otherwise.  In case of failure,
    callers should examine the CleanupSuccessful flag to determine the
    state of the target file.

--*/
{
    ULONG StreamIndex;
    DWORD hResult = 0;
    NTSTATUS Status = STATUS_SUCCESS;
    BOOL b = TRUE;
    ULONG i;
    DWORD rc = ERROR_SUCCESS;
    IO_STATUS_BLOCK IoStatusBlock;
    FILE_BASIC_INFORMATION  StreamBasicInfo = { 0 };

    *CleanupSuccessful = TRUE;

    for (StreamIndex = 0; StreamIndex < StreamCount ; StreamIndex++) {

        if ( Operation == EncryptRecovering ) {

            //
            // Called for recovering an unsuccessful encrypt. Get the attributes first.
            //

            Status = NtQueryInformationFile(
                StreamHandles[StreamIndex],
                &IoStatusBlock,
                &StreamBasicInfo,
                sizeof ( FILE_BASIC_INFORMATION ),
                FileBasicInformation
                );

            if ( !NT_SUCCESS( Status )) {

                b = FALSE;
                break;

            }
        }

        if ( ( Operation != EncryptRecovering ) ||
             (StreamBasicInfo.FileAttributes & FILE_ATTRIBUTE_ENCRYPTED) ){
            //
            // Mark target stream encrypted or decrypted.
            // Encrypt or decrypt information is in the input data
            //
            Status = NtFsControlFile(
                        StreamHandles[StreamIndex],
                        0,
                        NULL,
                        NULL,
                        &IoStatusBlock,
                        FSCTL_SET_ENCRYPTION,
                        FsInputData,
                        FsInputDataSize,
                        NULL,
                        0
                        );
        }


        if (NT_SUCCESS( Status )) {

            if ( Operation == EncryptRecovering ) {

                //
                // Check if we need to re-compress the file
                //

                if ( StreamSizes[StreamIndex].StreamFlag & FILE_ATTRIBUTE_COMPRESSED ){

                    //
                    //  Compress the target stream
                    //

                    USHORT State = COMPRESSION_FORMAT_DEFAULT;
                    ULONG Length;

                    //
                    // Return code is not checked. Failing to compress or decompress  the
                    // the original file should not prevent the recovery.
                    //

                    (VOID) DeviceIoControl(
                                        StreamHandles[StreamIndex],
                                        FSCTL_SET_COMPRESSION,
                                        &State,
                                        sizeof(USHORT),
                                        NULL,
                                        0,
                                        &Length,
                                        FALSE
                                        );

                }

            }

            hResult = CopyStream( StreamHandles[StreamIndex], SourceStreams[StreamIndex], &StreamSizes[StreamIndex] );

        } else {

            //
            // Not successful, but if we haven't modified the file at all, we can
            // still back out cleanly.
            //

            if (StreamIndex == 0) {
                return( RtlNtStatusToDosError( Status ) );
            }
        }

        if (!NT_SUCCESS( Status ) || hResult != ERROR_SUCCESS) {

            b = FALSE;
            break;
        }
    }

    if (!b) {

        if (!NT_SUCCESS( Status )) {

            //
            // Save the reason why we failed so we can return it.
            //

            rc = RtlNtStatusToDosError( Status );

        } else {

            rc = hResult;
        }

        //
        // Something failed, back up and clean up.  StreamIndex has the
        // index of the last stream we were operating on.
        //

        if (Operation == Encrypting) {

            //
            // If we were encrypting, then we need to go back and mark each
            // stream decrypted, and attempt to restore it from the backup.
            // If either of those fail, we're hosed.
            //

            for (i=0; i<StreamIndex ; i++) {

                //
                // Mark stream decrypted. We can reuse the input data buffer
                // here.
                //

                ( VOID )GetDecryptFsInput(
                            StreamHandles[StreamIndex],
                            FsInputData,
                            &FsInputDataSize
                            );

                Status = NtFsControlFile(
                            StreamHandles[StreamIndex],
                            0,
                            NULL,
                            NULL,
                            &IoStatusBlock,
                            FSCTL_SET_ENCRYPTION,
                            FsInputData,
                            FsInputDataSize,
                            NULL,
                            0
                            );

                //
                // Attempt to copy the stream from backup
                //

                hResult = CopyStream( StreamHandles[StreamIndex], SourceStreams[StreamIndex], &StreamSizes[StreamIndex] );

                if (!NT_SUCCESS( Status ) || hResult != ERROR_SUCCESS) {

                    *CleanupSuccessful = FALSE;

                    //
                    // Give up
                    //

                    break;
                }
            }

        } else {

            //
            // Decrypting.  Not a whole lot we can do here, because
            // we can't put the file back the way it was.
            //

            *CleanupSuccessful = FALSE;
        }
    }

    return( rc );
}


DWORD
CopyStream(
    HANDLE Target,
    HANDLE Source,
    PEFS_STREAM_SIZE StreamSize
    )
/*++

Routine Description:

    This routine copies a file stream from a source stream to a target
    stream.  It assumes that the streams have been opened for appropriate
    access.

Arguments:

    Target - Supplies a handle to the stream to be written to.  This handle
        must be open for WRITE access.

    Source - Supplies a stream handle to copy from.  This handle must be open
        for READ access.

    StreamSize - Supplies the size of the stream in bytes.


Return Value:

    ERROR_SUCCESS on success, failure otherwise.

--*/
{

    SYSTEM_INFO SystemInfo;
    LARGE_INTEGER StreamOffset;
    LARGE_INTEGER AllocationGranularity;
    HANDLE hStreamMapping;
    DWORD rc = NO_ERROR;
    IO_STATUS_BLOCK IoStatusBlock;
    NTSTATUS Status;

    if ( 0 == (StreamSize->EOFSize).QuadPart ){

        return ERROR_SUCCESS;

    }

    GetSystemInfo( &SystemInfo );
    SetFilePointer( Target, 0, NULL, FILE_BEGIN);

    AllocationGranularity.HighPart = 0;
    AllocationGranularity.LowPart = SystemInfo.dwAllocationGranularity;

    hStreamMapping = CreateFileMapping( Source, NULL, PAGE_READONLY, 0, 0, NULL );

    if (hStreamMapping == NULL) {
        return( GetLastError() );
    }

    if ( StreamSize->StreamFlag & FILE_ATTRIBUTE_SPARSE_FILE ){

        //
        // Sparsed stream. Query the ranges first.
        //

        FILE_ALLOCATED_RANGE_BUFFER InputData;
        PFILE_ALLOCATED_RANGE_BUFFER Ranges;
        ULONG OutDataBufferSize;
        ULONG   RangeCount;

        //
        // Set the target as a sparse file
        //

        Status = NtFsControlFile(
                    Target,
                    0,
                    NULL,
                    NULL,
                    &IoStatusBlock,
                    FSCTL_SET_SPARSE,
                    NULL,
                    0,
                    NULL,
                    0
                    );

        if ( NT_SUCCESS(Status) ){

            //
            // Set the EOF of the target
            //
            FILE_END_OF_FILE_INFORMATION    FileSize;

            FileSize.EndOfFile = StreamSize->EOFSize;
            Status = NtSetInformationFile(
                        Target,
                        &IoStatusBlock,
                        &FileSize,
                        sizeof(FileSize),
                        FileEndOfFileInformation
                        );

        }

        if ( !NT_SUCCESS(Status) ){

            CloseHandle( hStreamMapping );
            return RtlNtStatusToDosError( Status );

        }

        InputData.FileOffset.QuadPart = 0;
        InputData.Length.QuadPart = 0x7fffffffffffffff;

        OutDataBufferSize = INITBUFFERSIZE;

        do {

            Ranges = (PFILE_ALLOCATED_RANGE_BUFFER) LsapAllocatePrivateHeap(OutDataBufferSize);

            if ( NULL == Ranges )
            {
                CloseHandle( hStreamMapping );
                return ERROR_NOT_ENOUGH_MEMORY;
            }

            Status = NtFsControlFile(
                        Source,
                        0,
                        NULL,
                        NULL,
                        &IoStatusBlock,
                        FSCTL_QUERY_ALLOCATED_RANGES,
                        &InputData,
                        sizeof( FILE_ALLOCATED_RANGE_BUFFER ),
                        Ranges,
                        OutDataBufferSize
                        );

            if (Status == STATUS_PENDING)
            {
                ASSERT(TRUE);
                WaitForSingleObject(
                                       Source,
                                       INFINITE
                                       );

                Status = IoStatusBlock.Status;
            }

            if ( !NT_SUCCESS(Status) )
            {
                LsapFreePrivateHeap( Ranges );
                Ranges = NULL;
                OutDataBufferSize += INITBUFFERSIZE;
            }

        } while ( Status == STATUS_BUFFER_OVERFLOW );

        if ( NT_SUCCESS(Status) )
        {
            //
            //  We got the ranges
            //

            RangeCount = (ULONG)IoStatusBlock.Information / sizeof (FILE_ALLOCATED_RANGE_BUFFER);
            for ( ULONG ii = 0; ii < RangeCount; ii++ ){

                DWORD LowMoved;

                //
                // Move the target file pointer first
                //

                StreamOffset = Ranges[ii].FileOffset;
                LowMoved = SetFilePointer(
                                        Target,
                                        StreamOffset.LowPart,
                                        &StreamOffset.HighPart,
                                        FILE_BEGIN
                                        );
                if ( ( LowMoved != 0xFFFFFFFF ) || ( NO_ERROR != (rc = GetLastError())))
                {
                    rc = CopyStreamSection(
                            Target,
                            hStreamMapping,
                            &StreamOffset,
                            &(Ranges[ii].Length),
                            &AllocationGranularity
                            );

                }

                if ( NO_ERROR != rc )
                {
                    break;
                }
            }

            LsapFreePrivateHeap( Ranges );
            Ranges = NULL;
        }
        else
        {
            rc = RtlNtStatusToDosError( Status );

            LsapFreePrivateHeap( Ranges );
            Ranges = NULL;
        }

    } else {

        //
        // Non sparsed stream
        //

        StreamOffset.HighPart = 0;
        StreamOffset.LowPart = 0;

        rc = CopyStreamSection(
                Target,
                hStreamMapping,
                &StreamOffset,
                &(StreamSize->EOFSize),
                &AllocationGranularity
                );

    }

    CloseHandle( hStreamMapping );

    if ( rc == NO_ERROR ) {

        //
        // Flush the stream
        //

        Status = NtFlushBuffersFile(
                            Target,
                            &IoStatusBlock
                            );

        if ( !NT_SUCCESS(Status) ) {
            rc = RtlNtStatusToDosError( Status );
        }
    }

    return( rc );
}


VOID
CleanupOpenFileStreams(
       IN PHANDLE Handles OPTIONAL,
       IN PUNICODE_STRING StreamNames OPTIONAL,
       IN PEFS_STREAM_SIZE Sizes OPTIONAL,
       IN PFILE_STREAM_INFORMATION StreamInfoBase OPTIONAL,
       IN HANDLE HSourceFile OPTIONAL,
       IN ULONG StreamCount
       )
/*++

Routine Description:

    This routine cleans up after a call to OpenFileStreams.

Arguments:

    Handles - Supplies the array of handles returned from OpenFileStreams.

    Sizes - Supplies the array of stream sizes returned from OpenFileStreams.

    StreamCount - Supplies the number of streams returned from OpenFileStreams.


Return Value:

    None.  This is no recovery operation should this routine fail.

--*/
{
    ULONG i;

    if ( Handles ){

        for (ULONG i = 0; i<StreamCount ; i++) {
            if (HSourceFile == Handles[i]) {
                HSourceFile = 0;
            }
            NtClose( Handles[i] );
        }
        LsapFreeLsaHeap( Handles);
        if (HSourceFile) {

            //
            // Dir with data streams will get here
            //

            NtClose( HSourceFile );

        }

    } else if ( HSourceFile ){

        //
        //  HSourceFile is among one of Handles[]
        //


        NtClose( HSourceFile );

    }

    if ( StreamNames ){
        LsapFreeLsaHeap( StreamNames);
    }

    if ( Sizes ){
        LsapFreeLsaHeap( Sizes);
    }

    if ( StreamInfoBase ){
        LsapFreeLsaHeap( StreamInfoBase );
    }

    return;
}


VOID
MarkFileForDelete(
    HANDLE FileHandle
    )

/*++

Routine Description:

    This function marks the passed file for delete, so that it
    will be deleted by the system when its last handle is closed.

Arguments:

    FileHandle - A handle to a file that has been opened for DELETE
        access (see comments in the procedure body about this).


Return Value:

    None.

--*/


{
    FILE_DISPOSITION_INFORMATION Disposition;
    IO_STATUS_BLOCK IoStatusBlock;
    NTSTATUS Status;

#ifdef EFSDBG

    //
    // If we're in debugging mode, the file has not been opened
    // for delete access, since that would prohibit any other
    // process from accessing the file (which we want to do during
    // the debugging phase).
    //
    // Open the file again, for delete access this time, and
    // mark it for delete.  In the normal case, we don't have
    // to do this.
    //

    OBJECT_ATTRIBUTES Obja;
    UNICODE_STRING Unicode;

    RtlInitUnicodeString( &Unicode, NULL );

    InitializeObjectAttributes(
        &Obja,
        &Unicode,
        0,
        FileHandle,
        NULL
        );

    Status = NtCreateFile(
                &FileHandle,         // yes, overwrite the parameter
                DELETE | SYNCHRONIZE,
                &Obja,
                &IoStatusBlock,
                NULL,
                0,
                FILE_SHARE_READ | FILE_SHARE_WRITE,
                FILE_OPEN,
                FILE_NON_DIRECTORY_FILE | FILE_SYNCHRONOUS_IO_NONALERT,
                NULL,
                0
                );

    if (!NT_SUCCESS( Status )) {
        DbgPrint("NtCreateFile in MarkFileForDelete failed, status = %x\n",Status);
    }

#endif

//
// "DeleteFile is defined to be DeleteFileW, so undef it here...
//

#undef DeleteFile

        Disposition.DeleteFile = TRUE;

        Status = NtSetInformationFile(
                    FileHandle,
                    &IoStatusBlock,
                    &Disposition,
                    sizeof(Disposition),
                    FileDispositionInformation
                    );

        if (!NT_SUCCESS( Status )) {

            WCHAR   ErrorCode[16];
            LPWSTR  pErrorCode;

            _ltow( Status, ErrorCode, 16 );
            pErrorCode = &ErrorCode[0];

            EfsLogEntry(
              EVENTLOG_WARNING_TYPE,
              0,
              EFS_DEL_LOGFILE_ERROR,
              1,
              0,
              (LPCWSTR *)&pErrorCode,
              NULL
              );

        }

#ifdef EFSDBG

        CloseHandle( FileHandle );

#endif
}

BOOLEAN
SendHandle(
    IN HANDLE Handle,
    IN OUT PUCHAR EfsData,
    IN OUT PULONG EfsDataLength
    )

/*++

Routine Description:

    Constructs an EFS Data section of the form (Handle will be truncated to ULONG for SunDown)

    SK, Handle, Handle, [SK, Handle, Handle]sk

Arguments:

    Handle - Supplies the handle value to be encoded

    EfsData - Supplies a buffer large enough to contain the
        output data.

    EfsDataLength - Supplies the length of the EfsData, and
        returns either the length required or the length
        used.

Return Value:

    TRUE on success, FALSE otherwise.

--*/
{
    //
    // Compute the total size required
    //

    ULONG TotalSize = 4 * sizeof( ULONG ) + 2 * sizeof( DriverSessionKey );

    if (*EfsDataLength < TotalSize) {
        *EfsDataLength = TotalSize;
        return( FALSE );
    }

    *EfsDataLength = TotalSize;

    //
    // Copy everything in, and encrypt what needs to be encrypted.
    //

    PUCHAR Where = EfsData;

    RtlCopyMemory( Where, DriverSessionKey, sizeof( DriverSessionKey ) );
    Where += sizeof( DriverSessionKey );

    PULONG pUlong = (PULONG)Where;
    *pUlong = PtrToUlong(Handle);
    Where += sizeof( ULONG );

    pUlong = (PULONG)Where;
    *pUlong = PtrToUlong(Handle);
    Where += sizeof( ULONG );

    PUCHAR CryptData = Where;

    RtlCopyMemory( CryptData, EfsData, TotalSize/2 );

    //
    // Now encrypt the data starting at CryptData
    //

    LONG bytesToBeEnc = (LONG)(TotalSize/2);
    ASSERT( (bytesToBeEnc % DES_BLOCKLEN) == 0 );

    while ( bytesToBeEnc > 0 ) {

        //
        // Encrypt data with DES
        //

        des( CryptData,
             CryptData,
             &DesTable,
             ENCRYPT
           );

        CryptData += DES_BLOCKLEN;
        bytesToBeEnc -= DES_BLOCKLEN;
    }

    return( TRUE );
}


BOOLEAN
SendEfs(
    IN PEFS_KEY Fek,
    IN PEFS_DATA_STREAM_HEADER Efs,
    OUT PUCHAR EfsData,
    OUT PULONG EfsDataLength
    )
/*++

Routine Description:

    Constructs an EFS Data section of the form

    FEK, [FEK]sk, $EFS

Arguments:

    Fek - Supplies the FEK to be encoded

    Efs - Supplies the EFS to be encoded

    EfsData - Supplies a buffer large enough for the returned
        data.

    EfsDataLength - Supplies the length of the EfsData, and
        returns either the length required or the length
        used.

Return Value:

    TRUE on success, FALSE otherwise.

--*/
{
    //
    // Compute the total size required
    //

    ULONG TotalSize = 2 * EFS_KEY_SIZE( Fek ) + Efs->Length;

    if (*EfsDataLength < TotalSize) {
        *EfsDataLength = TotalSize;
        return( FALSE );
    }

    *EfsDataLength = TotalSize;

    //
    // Copy in the FEK twice, followed by the EFS stream
    //

    PUCHAR Where = EfsData;

    RtlCopyMemory( Where, Fek, EFS_KEY_SIZE( Fek ) );
    Where += EFS_KEY_SIZE( Fek );

    //
    // Save the location that we're going to encrypt
    //

    PUCHAR CryptData = Where;

    RtlCopyMemory( Where, Fek, EFS_KEY_SIZE( Fek ) );
    Where += EFS_KEY_SIZE( Fek );

    if ( Where != (PUCHAR) Efs ){
        RtlCopyMemory( Where, Efs, Efs->Length );
    }

    //
    // Encrypt the second FEK
    //

    LONG bytesToBeEnc = (LONG)(EFS_KEY_SIZE( Fek ));
    ASSERT( (bytesToBeEnc % DES_BLOCKLEN) == 0 );

    while ( bytesToBeEnc > 0 ) {

        //
        // Encrypt data with DES
        //

        des( CryptData,
             CryptData,
             &DesTable,
             ENCRYPT
           );

        CryptData += DES_BLOCKLEN;
        bytesToBeEnc -= DES_BLOCKLEN;
    }

    return( TRUE );
}

BOOLEAN
SendHandleAndEfs(
    IN HANDLE Handle,
    IN PEFS_DATA_STREAM_HEADER Efs,
    IN OUT PUCHAR EfsData,
    IN OUT PULONG EfsDataLength
    )
/*++

Routine Description:

    Constructs an EFS Data section of the form (Handle will be truncated to ULONG for SunDown)

    SK, Handle, Handle, [SK, Handle, Handle]sk $EFS

Arguments:

    Fek - Supplies the FEK to be encoded

    Efs - Supplies the EFS to be encoded

    EfsData - Returns a buffer containing the EFS data

    EfsDataLength - Returns the length of the EFS data.

Return Value:

    TRUE on success, FALSE otherwise.

--*/
{
    ULONG TotalSize = 4 * sizeof( ULONG ) + 2 * sizeof( DriverSessionKey ) + Efs->Length;

    if (*EfsDataLength < TotalSize) {
        *EfsDataLength = TotalSize;
        return( FALSE );
    }

    if ( SendHandle( Handle, EfsData, EfsDataLength ) ) {

        //
        // Tack the EFS onto the end of the buffer
        //

        RtlCopyMemory( EfsData + (*EfsDataLength), Efs, Efs->Length );
        *EfsDataLength += Efs->Length;
        return( TRUE );

    } else {

        return( FALSE );
    }
}


BOOLEAN
EncryptFSCTLData(
    IN ULONG Fsctl,
    IN ULONG Psc,
    IN ULONG Csc,
    IN PVOID EfsData,
    IN ULONG EfsDataLength,
    IN OUT PUCHAR Buffer,
    IN OUT PULONG BufferLength
    )
/*++

Routine Description:

    Constructs the input to the various FSCTL routines based
    on the passed parameters.  The general form is:

    PSC, [EFS_FC, CSC, [EFS Data]]sk

Arguments:


Return Value:

    TRUE on success, FALSE otherwise.

--*/
{
    ULONG TotalSize = 3 * sizeof( ULONG ) + EfsDataLength;

    if (*BufferLength < TotalSize) {
        *BufferLength = TotalSize;
        return( FALSE );
    }

    *BufferLength = TotalSize;

    //
    // Copy all the data in, and encrypt what needs to be encrypted
    //

    PULONG pUlong = (PULONG)Buffer;

    *pUlong++ = Psc;
    *pUlong++ = Fsctl;
    *pUlong++ = Csc;

    //
    // EfsData might point to inside Buffer and the data already in place
    //

    if ( (PVOID)pUlong != (PVOID)EfsData )
        RtlCopyMemory( (PUCHAR)pUlong, EfsData, EfsDataLength );

    LONG bytesToBeEnc = (LONG)(2 * sizeof(ULONG) + EfsDataLength);
    ASSERT( (bytesToBeEnc % DES_BLOCKLEN) == 0 );

    PUCHAR CryptData = Buffer + sizeof( ULONG );

    while ( bytesToBeEnc > 0 ) {

        //
        // Encrypt data with DES
        //

        des( CryptData,
             CryptData,
             &DesTable,
             ENCRYPT
           );

        CryptData += DES_BLOCKLEN;
        bytesToBeEnc -= DES_BLOCKLEN;
    }

    return( TRUE );
}


NTSTATUS
GetParentEfsStream(
    IN HANDLE CurrentFileHandle,
    IN PUNICODE_STRING CurrentFileName,
    OUT PEFS_DATA_STREAM_HEADER *ParentEfsStream
    )
/*++

Routine Description:

    Get the $EFS from the parent directory
    
    This routine is currently not used. It will be used again when we support inheritance in longhorn.

Arguments:

    SourceFileName -- Current file or directory name.

    ParentEfsStream

Return Value:

    Status of operation.

--*/

{

    ULONG Index;
    HANDLE ParentDir;
    PUCHAR InputData;
    ULONG InputDataSize;
    ULONG OutputDataSize;
    ULONG EfsDataLength;
    NTSTATUS Status;
    IO_STATUS_BLOCK IoStatusBlock;

    //
    // Get the parent name
    //

    *ParentEfsStream = NULL;

    Index = (CurrentFileName->Length)/sizeof( WCHAR ) - 1;
    while ( (Index > 0) && ( CurrentFileName->Buffer[Index] != L'\\') )
        Index--;

    if ( Index <= 0 )
        return STATUS_OBJECT_PATH_NOT_FOUND;

    LPWSTR ParentDirName;
/*
    if ( CurrentFileName->Buffer[Index-1] == L':' ){

        //
        // Parent is a root directory
        //

        Status = GetRootHandle( CurrentFileHandle, &ParentDir );

        if (!NT_SUCCESS( Status )){

            *ParentEfsStream = NULL;
            return STATUS_OBJECT_PATH_NOT_FOUND;
        }


    } else {
*/

        //
        // A normal directory. We can use WIN 32 API to open it.
        //

        SafeAllocaAllocate(ParentDirName, ( Index + 1 ) * sizeof(WCHAR));

        if ( ParentDirName == NULL )
        {
            *ParentEfsStream = NULL;
            return STATUS_INSUFFICIENT_RESOURCES;

        }

        RtlCopyMemory( ParentDirName, &CurrentFileName->Buffer[0], Index * sizeof(WCHAR));
        ParentDirName[Index] = UNICODE_NULL;

        //
        // FILE_FLAG_BACKUP_SEMANTICS is required to open a directory.
        //

        ParentDir = CreateFile(
                            ParentDirName,
                            FILE_READ_ATTRIBUTES,
                            FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE,
                            NULL,
                            OPEN_EXISTING,
                            FILE_FLAG_BACKUP_SEMANTICS,
                            NULL
                            );
        //
        // There is no need for us to hold ParentDirName any more
        //

        SafeAllocaFree( ParentDirName );

        if ( ParentDir == INVALID_HANDLE_VALUE )
        {
            return STATUS_OBJECT_PATH_NOT_FOUND;
        }
/*
    }
*/

    //
    // Now we got a handle to the parent directory in ParentDir.
    // Allocate input and output data buffer
    //

    OutputDataSize = INIT_EFS_BLOCK_SIZE;
    *ParentEfsStream = (PEFS_DATA_STREAM_HEADER) LsapAllocateLsaHeap( OutputDataSize );
    if ( *ParentEfsStream == NULL ){

        CloseHandle( ParentDir );
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    //
    // PSC, [EFS_FC, CSC , SK, H, H, [SK, H, H]sk]sk
    // PSC, CSC are ignored in this FSCTL call
    //

    InputDataSize = 2 * sizeof(DriverSessionKey) + 7 * sizeof(ULONG);

    SafeAllocaAllocate(InputData, InputDataSize );

    if ( InputData == NULL )
    {
        LsapFreeLsaHeap( *ParentEfsStream );
        *ParentEfsStream = NULL;
        CloseHandle( ParentDir );
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    //
    // Prepare an input data for making a FSCTL call to get the $EFS
    //

    EfsDataLength = 2 * sizeof(DriverSessionKey) + 4 * sizeof(ULONG);
    SendHandle( ParentDir, InputData + 3*sizeof(ULONG), &EfsDataLength );

    (VOID) EncryptFSCTLData(
                EFS_GET_ATTRIBUTE,
                0,
                0,
                InputData + 3*sizeof(ULONG),
                EfsDataLength,
                InputData,
                &InputDataSize
                );

    Status = NtFsControlFile(
                ParentDir,
                0,
                NULL,
                NULL,
                &IoStatusBlock,
                FSCTL_ENCRYPTION_FSCTL_IO,
                InputData,
                InputDataSize,
                *ParentEfsStream,
                OutputDataSize
                );

    if (!NT_SUCCESS( Status )) {

        //
        //  Check if the output data buffer too small
        //  Try again if it is.
        //

        if ( Status == STATUS_BUFFER_TOO_SMALL )
        {
            OutputDataSize = *(ULONG*)(*ParentEfsStream);

            if (OutputDataSize > INIT_EFS_BLOCK_SIZE)
            {
                LsapFreeLsaHeap( *ParentEfsStream );
                *ParentEfsStream = (PEFS_DATA_STREAM_HEADER)LsapAllocateLsaHeap( OutputDataSize );

                if ( *ParentEfsStream )
                {
                    Status = NtFsControlFile(
                            ParentDir,
                            0,
                            NULL,
                            NULL,
                            &IoStatusBlock,
                            FSCTL_ENCRYPTION_FSCTL_IO,
                            InputData,
                            InputDataSize,
                            *ParentEfsStream,
                            OutputDataSize
                            );
                }
            }
        }

        if ( !NT_SUCCESS( Status ) )
        {
            if ( *ParentEfsStream )
            {
                LsapFreeLsaHeap( *ParentEfsStream );
                *ParentEfsStream = NULL;
            }

            Status = STATUS_SUCCESS;

        }
    }

    SafeAllocaFree( InputData );
    CloseHandle( ParentDir );
    return Status;
}


NTSTATUS
GetRootHandle(
    IN HANDLE FileHandle,
    PHANDLE RootDirectoryHandle
    )
/*++

Routine Description:

    Get the handle to the root directory
    
    This routine is not used currently. It could be used in longhorn for inheritance. 
    We will revisit this in longhorn.

Arguments:

    FileHandle -- Current file or directory handle.

    RootDirectoryHandle -- Parent directory

Return Value:

    Status of operation.

--*/
{
    NTSTATUS Status;
    OBJECT_ATTRIBUTES Obja;
    UNICODE_STRING FileId;
    IO_STATUS_BLOCK IoStatusBlock;

    //
    // This is magic.  It opens the root directory of a volume by ID,
    // relative to the passed file name.
    //

    ULONG FileIdBuffer[2];

    FileIdBuffer[0] = 0x00000005;
    FileIdBuffer[1] = 0x00050000;

    FileId.Length = FileId.MaximumLength = 8;
    FileId.Buffer = (PWSTR)FileIdBuffer;

    InitializeObjectAttributes(
        &Obja,
        &FileId,
        0,
        FileHandle,
        NULL
        );

    Status = NtCreateFile(
                RootDirectoryHandle,
                FILE_READ_ATTRIBUTES,
                &Obja,
                &IoStatusBlock,
                NULL,
                0,
                FILE_SHARE_DELETE | FILE_SHARE_WRITE | FILE_SHARE_READ,
                FILE_OPEN,
                FILE_OPEN_BY_FILE_ID,
                NULL,
                0
                );

    return( Status );
}

BOOLEAN
GetDecryptFsInput(
    IN HANDLE Handle,
    OUT PUCHAR  InputData,
    OUT PULONG  InputDataSize
    )
/*++

Routine Description:

    Get the handle to the root directory

Arguments:

    Handle -- Current file or directory handle.

    InputData -- Data buffer for the decrypt FSCTL input data.
                 PSC, [EFS_FC, CSC, SK, H, H, [SK, H, H]sk]sk

    InputDataSize -- FSCTL input data length.

Return Value:

    TRUE IF SUCCESSFUL.

--*/
{
    ULONG RequiredSize;
    ULONG EfsDataSize;

    RequiredSize = 7 * sizeof( ULONG ) + 2 * sizeof(DriverSessionKey);
    if ( *InputDataSize < RequiredSize ){
        *InputDataSize = RequiredSize;
        return FALSE;
    }

    *InputDataSize = RequiredSize;
    EfsDataSize = RequiredSize - 3 * sizeof( ULONG );

    ( VOID )SendHandle(
                Handle,
                InputData + 3 * sizeof( ULONG ),
                &EfsDataSize
                );

    ( VOID ) EncryptFSCTLData(
                EFS_SET_ENCRYPT,
                EFS_DECRYPT_STREAM,
                EFS_DECRYPT_STREAM,
                InputData + 3 * sizeof(ULONG),
                EfsDataSize,
                InputData,
                InputDataSize
                );

    return TRUE;
}

NTSTATUS
EndErrorEncryptFile(
    IN HANDLE FileHandle,
    IN PUCHAR InputData,
    IN ULONG InputDataSize,
    OUT IO_STATUS_BLOCK *IoStatusBlock
    )

/*++

Routine Description:

    Removed the $EFS and clear the encrypt bit for the file.

Arguments:

    FileHandle -- Current file handle.

    InputData -- Data buffer for the decrypt FSCTL input data.
                 PSC, [EFS_FC, CSC, SK, H, H, [SK, H, H]sk]sk

    InputDataSize -- FSCTL input data length.

    IoStatusBlock -- Status information from FSCTL call.

Return Value:

    The status of operation.

--*/

{

    return (SendSkFsctl(
                EFS_DECRYPT_FILE,
                EFS_DECRYPT_FILE,
                EFS_SET_ENCRYPT,
                InputData,
                InputDataSize,
                FileHandle,
                FSCTL_SET_ENCRYPTION,
                IoStatusBlock
                )
            );

}

NTSTATUS
SendSkFsctl(
    IN ULONG Psc,
    IN ULONG Csc,
    IN ULONG EfsCode,
    IN PUCHAR InputData,
    IN ULONG InputDataSize,
    IN HANDLE Handle,
    IN ULONG FsCode,
    OUT IO_STATUS_BLOCK *IoStatusBlock
    )

/*++

Routine Description:

    Send FSCTL call with general EFS Data format. See comments
    for InputData

Arguments:

    Psc -- Plain subcode.

    Csc -- Cipher subcode

    EfsCode -- EFS function code.

    InputData -- Data buffer for the decrypt FSCTL input data.
                 PSC, [EFS_FC, CSC, SK, H, H, [SK, H, H]sk]sk

    InputDataSize -- FSCTL input data length.

    Handle -- Current stream handle.

    FsCode -- FSCTL control code.

    IoStatusBlock -- Status information from FSCTL call.

Return Value:

    The status of operation.

--*/
{

    ULONG EfsDataLength = InputDataSize - 3 * sizeof (ULONG);
    ULONG RequiredSize = 7 * sizeof( ULONG ) + 2 * sizeof(DriverSessionKey);
    BOOLEAN DummyOutput = FALSE;
    ULONG   OutPutLen = 0;
    VOID    *OutPutData = NULL;

    if ( InputDataSize < RequiredSize ){
        return STATUS_BUFFER_TOO_SMALL;
    }

    ( VOID )SendHandle(
                Handle,
                InputData + 3 * sizeof( ULONG ),
                &EfsDataLength
                );

    ( VOID ) EncryptFSCTLData(
                EfsCode,
                Psc,
                Csc,
                InputData + 3 * sizeof(ULONG),
                EfsDataLength,
                InputData,
                &InputDataSize
                );

    if (EFS_DECRYPT_STREAM == Psc) {
       OutPutData = (VOID *)&DummyOutput;
       OutPutLen = sizeof(BOOLEAN);
    }
    return ( NtFsControlFile(
                Handle,
                0,
                NULL,
                NULL,
                IoStatusBlock,
                FsCode,
                InputData,
                InputDataSize,
                OutPutData,
                OutPutLen
                )
            );

}

DWORD
GetVolumeRoot(
    IN PUNICODE_STRING  SrcFileName,
    OUT PUNICODE_STRING  RootPath
)

/*++

Routine Description:

    Get the root path name from the target file name

Arguments:

    SrcFileName -- Target file name.
    RootPathInfo -- Root path information

Return Value:

    The status of operation.

--*/

{

    ULONG BufferLength;
    WCHAR *PathName;
    BOOL    GotRoot;
    DWORD    RetCode = ERROR_SUCCESS;

    BufferLength = (ULONG)((SrcFileName->Length + sizeof(WCHAR)) <= MAX_PATH * sizeof(WCHAR)?
                            (MAX_PATH + 1) * sizeof(WCHAR) : (SrcFileName->Length + sizeof (WCHAR)));
    PathName = (WCHAR *) LsapAllocateLsaHeap(BufferLength);

    if ( !PathName  ) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RootPath->MaximumLength = (USHORT) BufferLength;
    GotRoot = GetVolumePathName(
                    SrcFileName->Buffer,
                    PathName,
                    BufferLength
                    );

    if (GotRoot){
        RootPath->Buffer = PathName;
        RootPath->Length = (USHORT) wcslen(PathName) * sizeof (WCHAR);
    } else {
        RetCode = GetLastError();
        RootPath->Buffer = NULL;
        RootPath->Length = 0;
        RootPath->MaximumLength = 0;
        LsapFreeLsaHeap( PathName );
    }


    return RetCode;
}

NTSTATUS
GetLogFile(
    IN PUNICODE_STRING RootPath,
    OUT HANDLE *LogFile
)

/*++

Routine Description:

    Create the log file.

Arguments:

    RootPath -- Volume root name.
    LogFile -- Log file handle

Return Value:

    The status of operation.

--*/

{
    NTSTATUS Status = STATUS_SUCCESS;
    HANDLE FileHdl;
    OBJECT_ATTRIBUTES Obja;
    IO_STATUS_BLOCK IoStatusBlock;
    UNICODE_STRING  FileName;
    UNICODE_STRING  RootNtName;
    UNICODE_STRING  LogFileName;
    DWORD                  FileAttributes;
    PSECURITY_DESCRIPTOR SD;
    BOOLEAN b;

    b =  RtlDosPathNameToNtPathName_U(
                        RootPath->Buffer,
                        &RootNtName,
                        NULL,
                        NULL
                        );

    if ( b ){
        //
        //  Allocate space for the temp log file name
        //

        SafeAllocaAllocate(FileName.Buffer, RootNtName.Length + EFSDIRLEN + TEMPFILELEN);

        if ( !FileName.Buffer ){
            //
            //  Free the NT name
            //
            RtlFreeHeap(
                RtlProcessHeap(),
                0,
                RootNtName.Buffer
                );

            return STATUS_INSUFFICIENT_RESOURCES;
        }

        //
        //  Make the EFS directory name of the volume
        //

        RtlCopyMemory(FileName.Buffer, RootNtName.Buffer, RootNtName.Length - sizeof(WCHAR));
        RtlCopyMemory(
            FileName.Buffer + (RootNtName.Length / sizeof(WCHAR)) - 1,
            EFSDIR,
            EFSDIRLEN
            );
        FileName.Length = RootNtName.Length + EFSDIRLEN - sizeof(WCHAR);
        FileName.MaximumLength = RootNtName.Length + EFSDIRLEN + TEMPFILELEN;
        FileName.Buffer[FileName.Length / sizeof (WCHAR)] = 0;

        //
        //  Free the NT name
        //
        RtlFreeHeap(
            RtlProcessHeap(),
            0,
            RootNtName.Buffer
            );

        //
        //   Create the LOG directory and file Security Descriptor
        //

        Status = MakeSystemFullControlSD( &SD );
        if ( NT_SUCCESS(Status) ){

            InitializeObjectAttributes(
                        &Obja,
                        &FileName,
                        OBJ_CASE_INSENSITIVE,
                        0,
                        SD
                        );

            //
            //  Open the EFS Log directory or Create if not exist
            //

            Status = NtCreateFile(
                        &FileHdl,
                        MAXIMUM_ALLOWED,
                        &Obja,
                        &IoStatusBlock,
                        NULL,
                        FILE_ATTRIBUTE_DIRECTORY | FILE_ATTRIBUTE_HIDDEN | FILE_ATTRIBUTE_SYSTEM,
                        FILE_SHARE_VALID_FLAGS,
                        FILE_OPEN_IF,
                        FILE_DIRECTORY_FILE ,
                        NULL,
                        0
                        );

            if (NT_SUCCESS(Status)){

                //
                //  The cache directory is created hidden and system access only. This will be
                //  created before any real encryption is done. So there is no need for us to check
                //  the encryption status of this directory.
                //

                CloseHandle(FileHdl);

                //
                //  Now trying to get the logfile name and create it
                //

                Status = CreateLogFile( &FileName, SD, LogFile );

            } else {

                //
                //  Cannot open the EFSCACHE dir
                //

                EfsLogEntry(
                    EVENTLOG_ERROR_TYPE,
                    0,
                    EFS_OPEN_CACHE_ERROR,
                    0,
                    sizeof(NTSTATUS),
                    NULL,
                    &Status
                    );

            }

            {

                //
                // Delete SD
                //

                NTSTATUS TmpStatus;
                BOOLEAN Present;
                BOOLEAN b;
                PACL pAcl;

                TmpStatus = RtlGetDaclSecurityDescriptor(SD, &Present, &pAcl, &b);

                if ( NT_SUCCESS(TmpStatus) && Present ){
                    LsapFreeLsaHeap(pAcl);
                }

                LsapFreeLsaHeap(SD);
            }
        }

        SafeAllocaFree( FileName.Buffer );
    }
    else{
        Status = STATUS_OBJECT_NAME_NOT_FOUND;
    }

    return Status;
}


NTSTATUS
MakeSystemFullControlSD(
    OUT PSECURITY_DESCRIPTOR *ppSD
    )

/*++

Routine Description:

    Create a system full control Security Descriptor.

Arguments:

    ppSD -- System full control security descriptor

Return Value:

    The status of operation.

--*/

{

    NTSTATUS NtStatus       = STATUS_SUCCESS;
    PSID SystemSid          =NULL;
    SID_IDENTIFIER_AUTHORITY IdentifierAuthority=SECURITY_NT_AUTHORITY;
    PACL pAcl               =NULL;
    DWORD                   cAclSize, cSDSize=0;

    //
    // build system sid
    //

    SafeAllocaAllocate(SystemSid, RtlLengthRequiredSid(1));

    if ( NULL == SystemSid ){
        return(STATUS_INSUFFICIENT_RESOURCES);
    }

    NtStatus = RtlInitializeSid(SystemSid, &IdentifierAuthority, (UCHAR)1);

    if ( !NT_SUCCESS(NtStatus) ){
        SafeAllocaFree( SystemSid );
        return NtStatus;
    }

    *(RtlSubAuthoritySid(SystemSid, 0)) = SECURITY_LOCAL_SYSTEM_RID;

    //
    // build a DACL for system full control
    //

    cAclSize = sizeof(ACL) + sizeof(ACCESS_ALLOWED_OBJECT_ACE) + RtlLengthSid(SystemSid);

    pAcl = (PACL)LsapAllocateLsaHeap(cAclSize);

    *ppSD = (PSECURITY_DESCRIPTOR) LsapAllocateLsaHeap(SECURITY_DESCRIPTOR_MIN_LENGTH);

    if ( ( NULL == pAcl ) || ( NULL == *ppSD ) ){
        if ( pAcl ) {
            LsapFreeLsaHeap( pAcl );
        }
        if ( *ppSD ) {
            LsapFreeLsaHeap( *ppSD );
            *ppSD = NULL;
        }

        SafeAllocaFree( SystemSid );
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlZeroMemory(pAcl, cAclSize);

    pAcl->AclRevision = ACL_REVISION_DS;
    pAcl->Sbz1        = (BYTE)0;
    pAcl->AclSize     = (USHORT)cAclSize;
    pAcl->AceCount    = 0;

    //
    // add a ace to the acl for System full control for file objects
    // the access type is ACCESS_ALLOWED_ACE
    // inheritance flag is CIOI
    //
    NtStatus = RtlAddAccessAllowedAceEx (
                        pAcl,
                        ACL_REVISION_DS,
                        OBJECT_INHERIT_ACE  |
                        CONTAINER_INHERIT_ACE,
                        GENERIC_ALL,
                        SystemSid
                        );

    if ( NT_SUCCESS(NtStatus) )
    {
        NtStatus = RtlCreateSecurityDescriptor( *ppSD,
                                SECURITY_DESCRIPTOR_REVISION );

        if ( NT_SUCCESS(NtStatus) )
        {
            //
            // Then set DACL (permission) to the security descriptor
            //

            NtStatus = RtlSetDaclSecurityDescriptor (
                                *ppSD,
                                TRUE,
                                pAcl,
                                FALSE
                                );

            if ( NT_SUCCESS(NtStatus) )
            {
                ((SECURITY_DESCRIPTOR *) *ppSD)->Control |= SE_DACL_PROTECTED;
            }
        }
    }

    //
    // free memory for SystemSid
    //

    SafeAllocaFree( SystemSid );

    if (!NT_SUCCESS(NtStatus))
    {
        LsapFreeLsaHeap( pAcl );
        LsapFreeLsaHeap( *ppSD );
        *ppSD = NULL;
    }

    return (NtStatus);
}


NTSTATUS
CreateLogFile(
    IN PUNICODE_STRING FileName,
    IN PSECURITY_DESCRIPTOR SD,
    OUT HANDLE *LogFile
)

/*++

Routine Description:

    Create a temp log file. We could not use the API GetTempFile to get the temp log file.
    We need our special Security Descriptor.

Arguments:

    FileName -- Directory to create the temp log file. Has enough space to add temporary
                    file name.

    SD -- Security Descriptor.

    LogFile -- File handle.

Return Value:

    The status of operation.

--*/

{
    NTSTATUS Status = STATUS_SUCCESS;
    ULONG Index = 0;
    PWCHAR TempLogFileName;
    int TempFileNameLen;
    USHORT OldLength;
    OBJECT_ATTRIBUTES Obja;
    IO_STATUS_BLOCK IoStatusBlock;
    BOOLEAN StopLoop = FALSE;

    OldLength = FileName->Length + sizeof (WCHAR);
    FileName->Buffer[ FileName->Length/sizeof(WCHAR) ] = L'\\';
    TempLogFileName = FileName->Buffer + OldLength/sizeof (WCHAR) ;

    for (; Index < 10000; Index++){

        //
        // This swprintf should be safe. The call is from trusted source and the buffer should be big enough.
        //

        TempFileNameLen = swprintf( TempLogFileName, L"EFS%d.LOG", Index);
        FileName->Length = OldLength + (USHORT) TempFileNameLen * sizeof (WCHAR);
        InitializeObjectAttributes(
                    &Obja,
                    FileName,
                    OBJ_CASE_INSENSITIVE,
                    0,
                    SD
                    );

        Status = NtCreateFile(
                    LogFile,
                    FILE_READ_DATA | FILE_WRITE_DATA | DELETE | SYNCHRONIZE,
                    &Obja,
                    &IoStatusBlock,
                    NULL,
                    FILE_ATTRIBUTE_HIDDEN,
                    0,
                    FILE_CREATE,
                    FILE_NO_INTERMEDIATE_BUFFERING | FILE_SYNCHRONOUS_IO_NONALERT ,
                    NULL,
                    0
                    );

        switch (Status) {
          case STATUS_SUCCESS:
          case STATUS_NO_SUCH_FILE:
          case STATUS_OBJECT_PATH_INVALID:
          case STATUS_OBJECT_PATH_SYNTAX_BAD:
          case STATUS_DIRECTORY_IS_A_REPARSE_POINT:
          case STATUS_OBJECT_PATH_NOT_FOUND:
          case STATUS_ACCESS_DENIED:
          case STATUS_DISK_CORRUPT_ERROR:
          case STATUS_FILE_CORRUPT_ERROR:
          case STATUS_DISK_FULL:
              StopLoop = TRUE;
              break;
          default:
              break;

        }
        if (StopLoop) {
           break;
        }
    }

    return Status;

}

NTSTATUS
CreateLogHeader(
    IN HANDLE LogFile,
    IN ULONG   SectorSize,
    IN PLARGE_INTEGER TragetID,
    IN PLARGE_INTEGER BackupID  OPTIONAL,
    IN LPCWSTR  SrcFileName,
    IN LPCWSTR  BackupFileName OPTIONAL,
    IN EFSP_OPERATION Operation,
    IN EFS_ACTION_STATUS Action,
    OUT ULONG *LogInfoOffset OPTIONAL
    )
/*++

Routine Description:

    Create a log file header.

Arguments:

    LogFile -- A handle to the log file

    SectorSize -- Sector size of the volume which the log file is in.

    TragetID -- Target file ID.

    BackupID -- Backup file ID.

    SrcFileName -- Target file path

    BackupFileName -- Backup file path

    Operation -- Encrypting or Decrypting

    Action -- The status of the operation.

    LogInfoOffset -- Starting offset of status info copy

Return Value:

    The status of operation.

--*/
{
    BYTE *WorkBuffer;
    PULONG tmpULong;
    PLARGE_INTEGER tmpLL;
    ULONG WorkOffset;
    NTSTATUS Status;
    IO_STATUS_BLOCK IoStatusBlock;
    LARGE_INTEGER ByteOffset;
    ULONG   BufferSize;
    ULONG   HeadDataSize;
    ULONG   SrcFileNameLen; // File path name length in bytes
    ULONG   BackupFileNameLen;

    SrcFileNameLen = (wcslen ( SrcFileName ) + 1 ) * sizeof (WCHAR);
    if ( BackupFileName ) {
        BackupFileNameLen = (wcslen ( BackupFileName ) + 1) * sizeof (WCHAR);
    } else {
        BackupFileNameLen = 0;
    }

    HeadDataSize = sizeof ( LOGHEADER ) + SrcFileNameLen + BackupFileNameLen;

    BufferSize = HeadDataSize + sizeof (ULONG); // Data + CheckSum
    if ( BufferSize <= SectorSize ){
        BufferSize = SectorSize;
    } else {
        BufferSize = ((ULONG)((BufferSize - 1) / SectorSize ) + 1) * SectorSize;
    }

    //
    // The memory used here must be aligned with sector boundary.
    // We cannot use LsapAllocateLsaHeap() here
    //

    WorkBuffer = (BYTE *) VirtualAlloc(
                                NULL,
                                BufferSize,
                                MEM_COMMIT,
                                PAGE_READWRITE
                                );
    if ( NULL == WorkBuffer ){
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    //
    //  Prepare common log header
    //
    RtlCopyMemory( ((PLOGHEADER)WorkBuffer)->SIGNATURE, LOGSIG, sizeof(WCHAR) * LOGSIGLEN );
    ((PLOGHEADER)WorkBuffer)->VerID =  LOGVERID;
    ((PLOGHEADER)WorkBuffer)->SectorSize = SectorSize;
    if ( Decrypting == Operation ) {
        ((PLOGHEADER)WorkBuffer)->Flag = LOG_DECRYPTION;
    } else {
        ((PLOGHEADER)WorkBuffer)->Flag = 0;
    }

    ((PLOGHEADER)WorkBuffer)->HeaderSize = HeadDataSize;
    ((PLOGHEADER)WorkBuffer)->HeaderBlockSize = BufferSize;
    ((PLOGHEADER)WorkBuffer)->TargetFilePathOffset = sizeof( LOGHEADER );
    ((PLOGHEADER)WorkBuffer)->TargetFilePathLength = SrcFileNameLen;
    RtlCopyMemory(
                    WorkBuffer + ((PLOGHEADER)WorkBuffer)->TargetFilePathOffset,
                    SrcFileName,
                    SrcFileNameLen
                    );

    if ( BackupFileName ){

        ((PLOGHEADER)WorkBuffer)->TempFilePathOffset = sizeof( LOGHEADER ) + SrcFileNameLen;
        ((PLOGHEADER)WorkBuffer)->TempFilePathLength = BackupFileNameLen;
        ((PLOGHEADER)WorkBuffer)->TempFileInternalName.QuadPart = BackupID->QuadPart;
        RtlCopyMemory(
                        WorkBuffer + ((PLOGHEADER)WorkBuffer)->TempFilePathOffset,
                        BackupFileName,
                        BackupFileNameLen
                        );

    } else {

        ((PLOGHEADER)WorkBuffer)->TempFilePathOffset = 0;
        ((PLOGHEADER)WorkBuffer)->TempFilePathLength = 0;
        ((PLOGHEADER)WorkBuffer)->TempFileInternalName.QuadPart = (LONGLONG) 0;

    }

    ((PLOGHEADER)WorkBuffer)->LengthOfTargetFileInternalName = sizeof (LARGE_INTEGER);
    ((PLOGHEADER)WorkBuffer)->TargetFileInternalName.QuadPart = TragetID->QuadPart;
    ((PLOGHEADER)WorkBuffer)->LengthOfTempFileInternalName = sizeof (LARGE_INTEGER);


    switch (Action){
        case BeginEncryptDir:
        case BeginDecryptDir:

            //
            //  No status information required for directory operation
            //  If crash happens before the completion, we always switch the status
            //  to decrypted status.
            //

            ((PLOGHEADER)WorkBuffer)->OffsetStatus1 = 0;
            ((PLOGHEADER)WorkBuffer)->OffsetStatus2 =0;
            ((PLOGHEADER)WorkBuffer)->Flag |= LOG_DIRECTORY;
            break;

        case BeginEncryptFile:
        case BeginDecryptFile:

            //
            //  To guarantee the atomic operation, status info copy begins
            //  at sector boundary.
            //

            ((PLOGHEADER)WorkBuffer)->OffsetStatus1 = BufferSize;
            ((PLOGHEADER)WorkBuffer)->OffsetStatus2 = BufferSize + SectorSize;
            if ( LogInfoOffset ){
                *LogInfoOffset = BufferSize;
            }

            break;
        default:
            break;
    }

    CreateBlockSum(WorkBuffer, HeadDataSize, BufferSize );

    //
    //  Write out the header sector
    //
    ByteOffset.QuadPart = (LONGLONG) 0;

    Status = NtWriteFile(
                    LogFile,
                    0,
                    NULL,
                    NULL,
                    &IoStatusBlock,
                    WorkBuffer,
                    BufferSize,
                    &ByteOffset,
                    NULL
                    );

    VirtualFree(
        WorkBuffer,
        0,
        MEM_RELEASE
        );

    return Status;

}

NTSTATUS
WriteLogFile(
    IN HANDLE LogFile,
    IN ULONG SectorSize,
    IN ULONG StartOffset,
    IN EFS_ACTION_STATUS Action
    )
/*++
Routine Description:

    Write Log Information.

Arguments:

    LogFile -- A handle to the log file

    SectorSize -- Sector size of the volume which the log file is in.

    Action -- The status of the operation.

Return Value:

    The status of operation.
--*/
{
    BYTE *WorkBuffer;
    NTSTATUS Status;
    IO_STATUS_BLOCK IoStatusBlock;
    LARGE_INTEGER ByteOffset;
    PULONG  tmpULong;

    //
    // The memory used here must be aligned with sector boundary.
    // We cannot use LsapAllocateLsaHeap() here
    //

    WorkBuffer = (BYTE *) VirtualAlloc(
                                NULL,
                                SectorSize,
                                MEM_COMMIT,
                                PAGE_READWRITE
                                );
    if ( NULL == WorkBuffer ){
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    tmpULong = (PULONG) WorkBuffer;
    *tmpULong =  2 * sizeof ( ULONG );
    * (tmpULong + 1) = Action;
    CreateBlockSum(WorkBuffer, *tmpULong, SectorSize );

    //
    //  Write out the header sector
    //
    ByteOffset.QuadPart = (LONGLONG) StartOffset;

    Status = NtWriteFile(
                    LogFile,
                    0,
                    NULL,
                    NULL,
                    &IoStatusBlock,
                    WorkBuffer,
                    SectorSize,
                    &ByteOffset,
                    NULL
                    );

    if ( NT_SUCCESS(Status) ) {
        ByteOffset.QuadPart = (LONGLONG) (StartOffset + SectorSize);

        Status = NtWriteFile(
                        LogFile,
                        0,
                        NULL,
                        NULL,
                        &IoStatusBlock,
                        WorkBuffer,
                        SectorSize,
                        &ByteOffset,
                        NULL
                        );
    }

    VirtualFree(
        WorkBuffer,
        0,
        MEM_RELEASE
        );
    return Status;

}

ULONG
GetCheckSum(
    IN BYTE *WorkBuffer,
    IN ULONG    Length
    )
/*++
Routine Description:

    Get the checksum of the written info. A simple checksum
    algorithm is used.

Arguments:

    WorkBuffer -- Starting point

    Length -- Length of the data to be checksumed.

Return Value:

    None.

--*/
{
    ULONG CheckSum = 0;
    ULONG *WorkData;

    WorkData =  (ULONG*)WorkBuffer;
    while ( WorkData < (ULONG *)(WorkBuffer + Length) ){

        //
        //  It is OK to add more bytes beyond WorkBuffer + Length if
        //  Length is not a multiple of sizeof (ULONG)
        //

        CheckSum += *WorkData++;
    }

    return CheckSum;

}

VOID
CreateBlockSum(
    IN BYTE *WorkBuffer,
    IN ULONG    Length,
    IN ULONG    BlockSize
    )
/*++
Routine Description:

    Create a simple checksum for the sector. The checksum is not security
    sensitive. Only for the purpose of detecting disk write error. A simple checksum
    algorithm is used.

Arguments:

    WorkBuffer -- Starting point

    Length -- Length of the data to be checksumed.

    SectorSize -- Sector size of the volume which the log file is in.

Return Value:

    None.

--*/
{
    ULONG CheckSum = 0;
    ULONG *WorkData;

    ASSERT ( Length <= BlockSize - sizeof (ULONG));

    CheckSum = GetCheckSum( WorkBuffer, Length );

    //
    //  Put the checksum at the end of sector
    //

    WorkData =  (ULONG*) (WorkBuffer + BlockSize - sizeof(ULONG));
    *WorkData = CheckSum;
    return;

}

NTSTATUS
CreateBackupFile(
    IN PUNICODE_STRING SourceFileNameU,
    OUT HANDLE *BackupFileHdl,
    OUT FILE_INTERNAL_INFORMATION *BackupID,
    OUT LPWSTR *BackupFileName
    )
/*++

Routine Description:

    Create a backup file

Arguments:

    SourceFileName -- Source file name

    BackupFileHdl -- Backup file handle pointer

    BackupID -- Backup file ID information.

Return Value:

    The status of operation.

--*/
{
    LONG   Index;
    int TempFileNameLen;
    LPWSTR BackupPureName;
    UNICODE_STRING  BackupFile;
    OBJECT_ATTRIBUTES   Obja;
    IO_STATUS_BLOCK     IoStatusBlock;
    PSECURITY_DESCRIPTOR    SD;
    NTSTATUS    Status;

    //
    //   Assume source file name in the format XXX...XXX\XXX or XXX
    //   No format of X:XXX. (Must be X:\XXX)
    //   The name was converted by APIs. The above assumption should be correct.
    //

    Index = SourceFileNameU->Length/sizeof(WCHAR) - 1;
    while ( Index >= 0 ){
        //
        //  Find the last '\'
        //
        if ( SourceFileNameU->Buffer[Index--] == L'\\'){
            break;
        }
    }

    Index++;

    //
    // Adjust the Index to point to the end of the directory not including '\'
    //

    if ( SourceFileNameU->Buffer[Index] ==  L'\\'){
        Index++;
    }

    //
    //   Allocate space for the backup file name
    //

    *BackupFileName = (LPWSTR) LsapAllocateLsaHeap( (Index + 20) * sizeof( WCHAR ));

    if ( NULL ==  *BackupFileName ){
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlCopyMemory( *BackupFileName, SourceFileNameU->Buffer, Index * sizeof(WCHAR));
    BackupPureName = *BackupFileName + Index;

    //
    //   Create file Security Descriptor
    //

    Status = MakeSystemFullControlSD( &SD );
    if ( NT_SUCCESS(Status) ){

        BOOLEAN StopLoop = FALSE;

        for (ULONG ii = 0; ii < 100000; ii++){

            BOOLEAN b;

            TempFileNameLen = swprintf(BackupPureName, L"EFS%d.TMP", ii);
            b = RtlDosPathNameToNtPathName_U(
                            *BackupFileName,
                            &BackupFile,
                            NULL,
                            NULL
                            );

            if ( b ){

                InitializeObjectAttributes(
                            &Obja,
                            &BackupFile,
                            OBJ_CASE_INSENSITIVE,
                            0,
                            SD
                            );

                //
                //  Create the EFS Temp file
                //  Does not hurt using FILE_OPEN_REPARSE_POINT
                //

                Status = NtCreateFile(
                            BackupFileHdl,
                            GENERIC_READ | GENERIC_WRITE | SYNCHRONIZE | DELETE,
                            &Obja,
                            &IoStatusBlock,
                            NULL,
                            FILE_ATTRIBUTE_HIDDEN | FILE_ATTRIBUTE_SYSTEM,
                            0,
                            FILE_CREATE,
                            FILE_SYNCHRONOUS_IO_NONALERT | FILE_OPEN_REPARSE_POINT,
                            NULL,
                            0
                            );
                if ( STATUS_ACCESS_DENIED == Status ) {

                    //
                    // Let's try to open it in the Local_System
                    //


                    RpcRevertToSelf();
                    Status =  NtCreateFile(
                            BackupFileHdl,
                            GENERIC_READ | GENERIC_WRITE | SYNCHRONIZE | DELETE,
                            &Obja,
                            &IoStatusBlock,
                            NULL,
                            FILE_ATTRIBUTE_HIDDEN | FILE_ATTRIBUTE_SYSTEM,
                            0,
                            FILE_CREATE,
                            FILE_SYNCHRONOUS_IO_NONALERT | FILE_OPEN_REPARSE_POINT,
                            NULL,
                            0
                            );
        
                    if (RPC_S_OK != RpcImpersonateClient( NULL )){

                        //
                        // This is very unlikely. We have did this before and it all succeeded.
                        // If this happens, let's quit as if we get STATUS_ACCESS_DENIED.
                        //

                        if (NT_SUCCESS(Status)) {
                            MarkFileForDelete(*BackupFileHdl);
                            CloseHandle( *BackupFileHdl );
                            *BackupFileHdl = 0;
                        }

                        Status = STATUS_ACCESS_DENIED;
                    }

                }

                RtlFreeHeap(
                    RtlProcessHeap(),
                    0,
                    BackupFile.Buffer
                    );

                switch (Status) {
                  case STATUS_SUCCESS:
                  case STATUS_NO_SUCH_FILE:
                  case STATUS_OBJECT_PATH_INVALID:
                  case STATUS_OBJECT_PATH_SYNTAX_BAD:
                  case STATUS_DIRECTORY_IS_A_REPARSE_POINT:
                  case STATUS_OBJECT_PATH_NOT_FOUND:
                  case STATUS_ACCESS_DENIED:
                  case STATUS_DISK_CORRUPT_ERROR:
                  case STATUS_FILE_CORRUPT_ERROR:
                  case STATUS_DISK_FULL:
                      StopLoop = TRUE;
                      break;
                  default:
                      break;

                }
                if (StopLoop) {
                   break;
                }
            }
        }

        if ( NT_SUCCESS(Status) ){
            if ( NT_SUCCESS(Status) ){

                //
                // Get FileID
                //
                Status = NtQueryInformationFile(
                    *BackupFileHdl,
                    &IoStatusBlock,
                    BackupID,
                    sizeof ( FILE_INTERNAL_INFORMATION ),
                    FileInternalInformation
                    );

                if ( !NT_SUCCESS(Status) ){
                    MarkFileForDelete(*BackupFileHdl);
                    CloseHandle( *BackupFileHdl );
                    *BackupFileHdl = 0;
                }

            } else {

                MarkFileForDelete(*BackupFileHdl);
                CloseHandle( *BackupFileHdl );
                *BackupFileHdl = 0;

            }
        }

        {

            //
            // Delete SD
            //

            NTSTATUS TmpStatus;
            BOOLEAN Present;
            BOOLEAN b;
            PACL pAcl;

            TmpStatus = RtlGetDaclSecurityDescriptor(SD, &Present, &pAcl, &b);
            if ( NT_SUCCESS(TmpStatus) && Present ){

                LsapFreeLsaHeap(pAcl);

            }
            LsapFreeLsaHeap(SD);
        }

    }

    if ( !NT_SUCCESS(Status) ){

        LsapFreeLsaHeap( *BackupFileName );
        *BackupFileName = NULL;

    }

    return Status;

}



NTSTATUS
SendGenFsctl(
    IN HANDLE Target,
    IN ULONG Psc,
    IN ULONG Csc,
    IN ULONG EfsCode,
    IN ULONG FsCode
    )
/*++
Routine Description:

    Set the encrypted file status to normal.

Arguments:

    Target -- A handle to the target file or directory.

    Psc -- Plain sub code

    Csc -- Cipher sub code

    EfsCode -- Efs function code

    FsCode -- FSCTL code

Return Value:

    The status of operation.
--*/
{
    NTSTATUS Status = STATUS_SUCCESS;
    ULONG InputDataSize;
    PUCHAR InputData;
    IO_STATUS_BLOCK IoStatusBlock;

    InputDataSize = 7 * sizeof ( ULONG ) + 2 * sizeof ( DriverSessionKey );

    SafeAllocaAllocate(InputData, InputDataSize);

    if ( InputData == NULL )
    {
        //
        //   This is unlikely to happen during the boot time.
        //

        return( STATUS_INSUFFICIENT_RESOURCES );
    }

    //
    //  Sync FSCTL assumed
    //

    Status = SendSkFsctl(
                    Psc,
                    Csc,
                    EfsCode,
                    InputData,
                    InputDataSize,
                    Target,
                    FsCode,
                    &IoStatusBlock
                    );

    SafeAllocaFree( InputData );
    return Status;
}


DWORD
EfsOpenFileRaw(
    IN      LPCWSTR     FileName,
    IN      LPCWSTR     LocalFileName,
    IN      BOOL        NetSession,
    IN      ULONG       Flags,
    OUT     PVOID *     Context
    )

/*++

Routine Description:

    This routine is used to open an encrypted file. It opens the file and
    prepares the necessary context to be used in ReadRaw data and WriteRaw
    data.


Arguments:

    FileName  --  Remote File name of the file to be exported. Used to check the share.

    LocalFileName -- Local file name for real jobs.

    NetSession -- Indicates network session.

    Flags -- Indicating if open for export or import; for directory or file.

    Context - Export context to be used by READ operation later. Caller should
              pass this back in ReadRaw().


Return Value:

    Result of the operation.

--*/

{
    ULONG   FileAttributes = FILE_ATTRIBUTE_NORMAL;
    ACCESS_MASK   FileAccess = 0 ;
    BOOL    Privilege = FALSE; // FALSE - not a backup operator
    ULONG   CreateDist = 0;
    ULONG   CreateOptions = 0;
    ULONG   ShareMode = 0;
    HANDLE  HSourceFile;
    NTSTATUS NtStatus;
    DWORD   HResult;
    OBJECT_ATTRIBUTES ObjectAttributes;
    OBJECT_ATTRIBUTES NetObjectAttributes;
    IO_STATUS_BLOCK  IoStatus;
    UNICODE_STRING  UniFileName;
    UNICODE_STRING  UniNetFileName={0,0,NULL};
    BOOLEAN TranslationStatus;

    PFILE_STREAM_INFORMATION StreamInfoBase = NULL;
    ULONG                    StreamInfoSize = 0;

    PUNICODE_STRING          StreamNames = NULL;
    PHANDLE                  StreamHandles = NULL;
    ULONG                    StreamCount    = 0;

    TOKEN_PRIVILEGES        Privs;
    PTOKEN_PRIVILEGES       OldPrivs;
    BOOL                    b;
    HANDLE                  TokenHandle = 0;
    DWORD                   ReturnLength;

    //
    // Convert file name to UNICODE_STRING and UNC format
    // Create an OBJECT_ATTRIBUTES
    //

    TranslationStatus = RtlDosPathNameToNtPathName_U(
                            LocalFileName,
                            &UniFileName,
                            NULL,
                            NULL
                            );

    if ( !TranslationStatus ) {

        return ERROR_PATH_NOT_FOUND;

    }

    if (NetSession) {
        UINT uiFileNameLen = 0;
        
        uiFileNameLen = wcslen(FileName);

        if (uiFileNameLen >= MAX_PATH )
        {
            // The path to file is longer than MAX_PATH so it must be \\?\UNC\ encoded.
            LPWSTR  wszTmpBuffer = NULL;
            UINT    uiTmpBuffLen = 0;

            // allocate the buffer
            uiTmpBuffLen = (uiFileNameLen + wcslen(L"\\\\?\\UNC") - 1) * sizeof(WCHAR) + sizeof(UNICODE_NULL);
            SafeAllocaAllocate(wszTmpBuffer, uiTmpBuffLen);

            if (NULL == wszTmpBuffer)
            {
                RtlFreeHeap(
                    RtlProcessHeap(),
                    0,
                    UniFileName.Buffer
                    );

                return ERROR_OUTOFMEMORY;
            }

            // prepend with "\\?\UNC\"
            wcscpy(wszTmpBuffer, L"\\\\?\\UNC");
            wcscat(wszTmpBuffer, &(FileName[1]));

            TranslationStatus = RtlDosPathNameToNtPathName_U(
                                    wszTmpBuffer,
                                    &UniNetFileName,
                                    NULL,
                                    NULL
                                    );

            SafeAllocaFree(wszTmpBuffer);
        }
        else
        {
            TranslationStatus = RtlDosPathNameToNtPathName_U(
                                    FileName,
                                    &UniNetFileName,
                                    NULL,
                                    NULL
                                    );
        }

        if ( !TranslationStatus ) {

            RtlFreeHeap(
                RtlProcessHeap(),
                0,
                UniFileName.Buffer
                );

            return ERROR_PATH_NOT_FOUND;

        }

        InitializeObjectAttributes(
                        &NetObjectAttributes,
                        &UniNetFileName,
                        OBJ_CASE_INSENSITIVE,
                        NULL,
                        NULL
                        );

    }

    InitializeObjectAttributes(
                    &ObjectAttributes,
                    &UniFileName,
                    OBJ_CASE_INSENSITIVE,
                    NULL,
                    NULL
                    );

    if ( Flags & CREATE_FOR_IMPORT ){

        //
        // Prepare parameters for create of import
        //

        FileAccess = FILE_WRITE_ATTRIBUTES;

        if ( Flags & CREATE_FOR_DIR ){

            //
            // Import a directory
            //

            FileAccess |= FILE_WRITE_DATA | FILE_READ_DATA | FILE_READ_ATTRIBUTES | SYNCHRONIZE;
            CreateDist = FILE_OPEN_IF;
            CreateOptions |= FILE_DIRECTORY_FILE | FILE_SYNCHRONOUS_IO_NONALERT | FILE_NO_COMPRESSION;
            FileAttributes |= FILE_ATTRIBUTE_DIRECTORY;

        } else {

            //
            // Import file
            // Should we use FILE_SUPERSEDE here?
            //

            FileAccess |= SYNCHRONIZE;
            CreateDist = FILE_OVERWRITE_IF;
            CreateOptions |= FILE_OPEN_REPARSE_POINT | FILE_SYNCHRONOUS_IO_NONALERT | FILE_NO_COMPRESSION;
            if (Flags & OVERWRITE_HIDDEN) {
                FileAttributes |= FILE_ATTRIBUTE_HIDDEN;
            }

        }


    } else {

        //
        // If export is requested and the file is not encrypted,
        // Fail the call.
        //

        FileAccess = FILE_READ_ATTRIBUTES;

        //
        // Prepare parameters for create of export
        //

        CreateDist = FILE_OPEN;
        if ( Flags & CREATE_FOR_DIR ){

            //
            // Export a directory
            //

            FileAccess |= FILE_READ_DATA;
            CreateOptions |= FILE_DIRECTORY_FILE;

        } else {
            FileAccess |= SYNCHRONIZE;
            CreateOptions |= FILE_OPEN_REPARSE_POINT | FILE_SYNCHRONOUS_IO_NONALERT;
        }

    }

    SafeAllocaAllocate(OldPrivs, sizeof(TOKEN_PRIVILEGES));

    if ( OldPrivs == NULL )
    {
        RtlFreeHeap(
            RtlProcessHeap(),
            0,
            UniFileName.Buffer
            );

        if (NetSession) {

            RtlFreeHeap(
                RtlProcessHeap(),
                0,
                UniNetFileName.Buffer
                );

        }

        return ERROR_NOT_ENOUGH_MEMORY;
    }

    //
    // We're impersonating, use the thread token.
    //

    b = OpenThreadToken(
            GetCurrentThread(),
            TOKEN_ADJUST_PRIVILEGES | TOKEN_QUERY,
            FALSE,
            &TokenHandle
            );

    if ( b )
    {
        //
        // We've got a token handle
        //

        //
        // If we're doing a create for import, enable restore privilege,
        // otherwise enable backup privilege.
        //


        Privs.PrivilegeCount = 1;
        Privs.Privileges[0].Attributes = SE_PRIVILEGE_ENABLED;

        if ( !(Flags & CREATE_FOR_IMPORT) )
        {
            Privs.Privileges[0].Luid = RtlConvertLongToLuid(SE_BACKUP_PRIVILEGE);

        }
        else
        {
            Privs.Privileges[0].Luid = RtlConvertLongToLuid(SE_RESTORE_PRIVILEGE);
        }

        ReturnLength = sizeof( TOKEN_PRIVILEGES );

        (VOID) AdjustTokenPrivileges (
                    TokenHandle,
                    FALSE,
                    &Privs,
                    sizeof( TOKEN_PRIVILEGES ),
                    OldPrivs,
                    &ReturnLength
                    );

        if ( ERROR_SUCCESS == GetLastError() ) {

            Privilege = TRUE;

        } else {

            //
            // Privilege adjust failed
            //

            CloseHandle( TokenHandle );
            TokenHandle = 0;

        }

    } else {

        //
        // We did not get the handle.
        //

        TokenHandle = 0;

    }

    //
    // Caller will call RpcRevertToSelf().
    // OldPrivs is not needed any more.
    //

    SafeAllocaFree( OldPrivs );
    OldPrivs = NULL;

    if ( !Privilege ){

        //
        // Not a backup operator
        //
        if ( !(Flags & CREATE_FOR_IMPORT) ){

            FileAccess |= FILE_READ_DATA;

        } else {

            FileAccess |= FILE_WRITE_DATA;

        }
    } else {

        //
        //  A backup operator or the user with the privilege
        //

        CreateOptions |= FILE_OPEN_FOR_BACKUP_INTENT;
        if ( !(Flags & CREATE_FOR_DIR) ){

            FileAccess |= DELETE;

        }

    }

    if (NetSession) {

        //
        // This create is for checking share access only. The handle from this is not good for
        // FSCTL with data buffer larger than 64K.
        //

        NtStatus = NtCreateFile(
                        &HSourceFile,
                        FileAccess,
                        &NetObjectAttributes,
                        &IoStatus,
                        (PLARGE_INTEGER) NULL,
                        FileAttributes,
                        ShareMode,
                        CreateDist,
                        CreateOptions,
                        (PVOID) NULL,
                        0L
                        );

        RtlFreeHeap(
            RtlProcessHeap(),
            0,
            UniNetFileName.Buffer
            );

        if (NT_SUCCESS(NtStatus)) {
             CloseHandle( HSourceFile );
        } else {

            RtlFreeHeap(
                RtlProcessHeap(),
                0,
                UniFileName.Buffer
                );

            if ( TokenHandle ){
                CloseHandle( TokenHandle );
            }

            return RtlNtStatusToDosError( NtStatus );
        }

    }

    NtStatus = NtCreateFile(
                    &HSourceFile,
                    FileAccess,
                    &ObjectAttributes,
                    &IoStatus,
                    (PLARGE_INTEGER) NULL,
                    FileAttributes,
                    ShareMode,
                    CreateDist,
                    CreateOptions,
                    (PVOID) NULL,
                    0L
                    );

    RtlFreeHeap(
        RtlProcessHeap(),
        0,
        UniFileName.Buffer
        );

    //
    // No need for FILE_DIRECTORY_FILE any more
    //

    CreateOptions &= ~FILE_DIRECTORY_FILE;
    FileAttributes &= ~FILE_ATTRIBUTE_DIRECTORY;

    if (NT_SUCCESS(NtStatus)){

        if ( Flags & CREATE_FOR_IMPORT ){

            if (Flags & CREATE_FOR_DIR) {

                //
                //  If the dir existed and compressed, we need extra steps to uncompressed it
                //


                FILE_BASIC_INFORMATION  StreamBasicInfo;
    
                //
                // Get File Attributes
                //
                NtStatus = NtQueryInformationFile(
                    HSourceFile,
                    &IoStatus,
                    &StreamBasicInfo,
                    sizeof ( FILE_BASIC_INFORMATION ),
                    FileBasicInformation
                    );
    
                if (NT_SUCCESS(NtStatus)){
                    if (StreamBasicInfo.FileAttributes & FILE_ATTRIBUTE_COMPRESSED){

                        USHORT State = COMPRESSION_FORMAT_NONE;
                        ULONG Length;
        
                        //
                        // Attempt to uncompress the directory
                        //
        
                        b = DeviceIoControl(
                                            HSourceFile,
                                            FSCTL_SET_COMPRESSION,
                                            &State,
                                            sizeof(USHORT),
                                            NULL,
                                            0,
                                            &Length,
                                            FALSE
                                            );
        
                        if (!b) {
                            HResult = GetLastError();
                            CloseHandle( HSourceFile );
                            if ( TokenHandle ){
                                CloseHandle( TokenHandle );
                            }
                            return HResult;
                        }
                    }
                } else {

                    CloseHandle( HSourceFile );
                    if ( TokenHandle ){
                        CloseHandle( TokenHandle );
                    }
                    return RtlNtStatusToDosError( NtStatus );

                }

            }
            //
            // Prepare import context
            //

            *Context = LsapAllocateLsaHeap(sizeof( IMPORT_CONTEXT ));

            if ( *Context ){

                (( PIMPORT_CONTEXT ) *Context)->Flag = CONTEXT_FOR_IMPORT;
                if (Flags & CREATE_FOR_DIR) {
                    (( PIMPORT_CONTEXT ) *Context)->Flag |= CONTEXT_OPEN_FOR_DIR;
                }
                (( PIMPORT_CONTEXT ) *Context)->Handle = HSourceFile;
                (( PIMPORT_CONTEXT ) *Context)->ContextID = EFS_CONTEXT_ID;
                (( PIMPORT_CONTEXT ) *Context)->Attribute = FileAttributes;
                (( PIMPORT_CONTEXT ) *Context)->CreateDisposition = CreateDist;
                (( PIMPORT_CONTEXT ) *Context)->CreateOptions = CreateOptions;
                (( PIMPORT_CONTEXT ) *Context)->DesiredAccess = FileAccess;

            } else {

                CloseHandle( HSourceFile );
                HSourceFile = 0;

                NtStatus = STATUS_INSUFFICIENT_RESOURCES;

            }

        } else {


            FILE_BASIC_INFORMATION  StreamBasicInfo;
            IO_STATUS_BLOCK IoStatusBlock;

            //
            // Get File Attributes
            //
            NtStatus = NtQueryInformationFile(
                HSourceFile,
                &IoStatusBlock,
                &StreamBasicInfo,
                sizeof ( FILE_BASIC_INFORMATION ),
                FileBasicInformation
                );

            if ( NT_SUCCESS(NtStatus)) {

                if ( !(StreamBasicInfo.FileAttributes & FILE_ATTRIBUTE_ENCRYPTED) ){

                    NtStatus = STATUS_ACCESS_DENIED;

                }

            }

            if (!NT_SUCCESS(NtStatus)) {

                CloseHandle( HSourceFile );
                HSourceFile = 0;

                if ( TokenHandle ){
                    CloseHandle( TokenHandle );
                }

                return RtlNtStatusToDosError( NtStatus );

            }

            //
            // Prepare export context
            //

            NtStatus = GetStreamInformation(
                            HSourceFile,
                            &StreamInfoBase,
                            &StreamInfoSize
                            );

            if (NT_SUCCESS(NtStatus)){

                if (FileAccess & DELETE) {
                    ShareMode |= FILE_SHARE_DELETE;
                }

                HResult = OpenFileStreams(
                                HSourceFile,
                                ShareMode,
                                OPEN_FOR_EXP,
                                StreamInfoBase,
                                FileAccess,
                                CreateDist,
                                CreateOptions,
                                NULL,
                                &StreamNames,
                                &StreamHandles,
                                NULL,
                                &StreamCount
                                );

                if ( HResult == NO_ERROR ) {

                    *Context = LsapAllocateLsaHeap( sizeof( EXPORT_CONTEXT ) );

                    if ( *Context ){

                        ((PEXPORT_CONTEXT) *Context)->Flag = CONTEXT_FOR_EXPORT;
                        if (Flags & CREATE_FOR_DIR) {
                            (( PEXPORT_CONTEXT ) *Context)->Flag |= CONTEXT_OPEN_FOR_DIR;
                        }
                        ((PEXPORT_CONTEXT) *Context)->Handle = HSourceFile;
                        ((PEXPORT_CONTEXT ) *Context)->ContextID = EFS_CONTEXT_ID;
                        ((PEXPORT_CONTEXT) *Context)->NumberOfStreams = StreamCount;
                        ((PEXPORT_CONTEXT) *Context)->StreamHandles = StreamHandles;
                        ((PEXPORT_CONTEXT) *Context)->StreamNames = StreamNames;
                        ((PEXPORT_CONTEXT) *Context)->StreamInfoBase = StreamInfoBase;

                    } else {

                        //
                        // Out of memory
                        //

                        CleanupOpenFileStreams(
                                            StreamHandles,
                                            StreamNames,
                                            NULL,
                                            StreamInfoBase,
                                            HSourceFile,
                                            StreamCount
                                            );

                        StreamHandles = NULL;
                        StreamNames = NULL;
                        StreamInfoBase = NULL;
                        HSourceFile = 0;
                        NtStatus = STATUS_INSUFFICIENT_RESOURCES;

                    }

                } else {

                    //
                    // Open streams wrong, free StreamInfoBase
                    //

                    if (StreamInfoBase) {
                        LsapFreeLsaHeap( StreamInfoBase );
                        StreamInfoBase = NULL;
                    }
                    CloseHandle( HSourceFile );
                    HSourceFile = 0;
                    if ( TokenHandle ){
                        CloseHandle( TokenHandle );
                    }

                    return HResult;

                }

            } else {

                //
                // Get stream info wrong
                //

                CloseHandle( HSourceFile );
                HSourceFile = 0;

            }
        }

    }

    if ( TokenHandle ){
        CloseHandle( TokenHandle );
    }

    return RtlNtStatusToDosError( NtStatus );

}

VOID
EfsCloseFileRaw(
    IN      PVOID           Context
    )
/*++

Routine Description:

    This routine frees the resources allocated by the CreateRaw

Arguments:

    Context - Created by the EfsOpenFileRaw.

Return Value:

    NO.

--*/
{
    if ( !Context || (((PEXPORT_CONTEXT) Context)->ContextID != EFS_CONTEXT_ID) ){
        return;
    }

    __try{
        if ( !(((PEXPORT_CONTEXT) Context)->Flag & CONTEXT_INVALID) ){
    
            if ( ((PEXPORT_CONTEXT) Context)->Flag & CONTEXT_FOR_IMPORT ){
    
                //
                // Free import context
                //
    
                CleanupOpenFileStreams(
                    NULL,
                    NULL,
                    NULL,
                    NULL,
                    ((PIMPORT_CONTEXT) Context)->Handle,
                    0
                    );
    
                //
                // Defensive code
                //
    
                ((PIMPORT_CONTEXT) Context)->Flag |= CONTEXT_INVALID;
    
           } else {
    
                //
                // Free export context
                //
    
                CleanupOpenFileStreams(
                    ((PEXPORT_CONTEXT) Context)->StreamHandles,
                    ((PEXPORT_CONTEXT) Context)->StreamNames,
                    NULL,
                    ((PEXPORT_CONTEXT) Context)->StreamInfoBase,
                    ((PEXPORT_CONTEXT) Context)->Handle,
                    ((PEXPORT_CONTEXT) Context)->NumberOfStreams
                    );
    
                //
                // Defensive code
                //
    
                ((PEXPORT_CONTEXT) Context)->Flag |= CONTEXT_INVALID;
    
            }
    
        }
    
        LsapFreeLsaHeap( Context);
        Context = NULL;
    } __except (EXCEPTION_EXECUTE_HANDLER) {

        if (Context) {

            //
            // Defensive code. Don't try to free Context just in case the context is from bad guy and is bogus.
            // We can always access the ContextID field as this is guranteed by the RPC. Export and Import has
            // the same offset for this field, as it is 0.
            //

            ((PEXPORT_CONTEXT) Context)->ContextID = 0;
        }
    }

}

long EfsReadFileRaw(
    PVOID           Context,
    PVOID           EfsOutPipe
    )
/*++

Routine Description:

    This routine is used to read encrypted file's raw data. It uses
    NTFS FSCTL to get the data.
    
    NULL value of Context or EfsOutPipe is checked by the caller.

Arguments:

    Context -- Context handle.
    EfsOutPipe -- Pipe handle.

Return Value:

    The result of operation.

--*/
{

    VOID    *FsctlInput = NULL;
    VOID    *WorkBuffer = NULL;
    VOID    *BufPointer;
    VOID    *FsctlOutput;
    USHORT  *PUShort;
    PULONG  PUlong;
    ULONG   FsctlInputLength;
    ULONG   EfsDataLength;
    ULONG   FsctlOutputLength;
    ULONG   SendDataLength;
    ULONG   WkBufLength;
    ULONG   BytesAdvanced;
    DWORD   HResult = NO_ERROR;
    BOOLEAN MoreToRead = TRUE;
    BOOLEAN StreamEncrypted = TRUE;
    ULONG   StreamIndex;
    LONGLONG StreamOffset;
    NTSTATUS NtStatus;
    IO_STATUS_BLOCK IoStatusBlock;
    FILE_BASIC_INFORMATION StreamInfo;
    ULONG   ii;

    if ( (((PEXPORT_CONTEXT) Context)->ContextID != EFS_CONTEXT_ID) ||
          (((PEXPORT_CONTEXT) Context)->Flag & (CONTEXT_FOR_IMPORT | CONTEXT_INVALID ))
       ){
        //
        // RPC Attack. Flush the pipe and return error.
        //

        HResult = EFSSendPipeData( (char *)&SendDataLength, 0, EfsOutPipe );
        return ERROR_ACCESS_DENIED;
    }

    //
    // Allocate necessary memory
    //

    SafeAllocaAllocate(FsctlInput, FSCTL_EXPORT_INPUT_LENGTH);

    //
    // Try to allocate a reasonable size buffer. The size can be fine tuned later, but should
    // at least one page plus 4K.  FSCTL_OUTPUT_LESS_LENGTH should be n * page size.
    // FSCTL_OUTPUT_MIN_LENGTH can be fine tuned later. It should be at least one page
    // plus 4K.
    //

    WkBufLength = FSCTL_OUTPUT_INITIAL_LENGTH;

    while ( !WorkBuffer && WkBufLength >= FSCTL_OUTPUT_MIN_LENGTH ){

        //
        // Sector alignment is required here.
        //

        WorkBuffer = VirtualAlloc(
                        NULL,
                        WkBufLength,
                        MEM_COMMIT,
                        PAGE_READWRITE
                        );

        if ( !WorkBuffer ){

            //
            // Memory allocation failed.
            // Try smaller allocation.
            //

            WkBufLength -= FSCTL_OUTPUT_LESS_LENGTH;

        }

    }

    if ( !WorkBuffer || !FsctlInput ){
        //
        // Not enough memory to run export
        //

        if ( WorkBuffer ){
            VirtualFree(
                WorkBuffer,
                0,
                MEM_RELEASE
                );
        }

        if ( FsctlInput ){
            SafeAllocaFree( FsctlInput );
        }

        //
        // Flush the pipe and return error.
        //

        HResult = EFSSendPipeData( (char *)&SendDataLength, 0, EfsOutPipe );
        return ERROR_OUTOFMEMORY;
    }

    RtlZeroMemory( FsctlInput, FSCTL_EXPORT_INPUT_LENGTH );
    RtlZeroMemory( WorkBuffer, WkBufLength );

    //
    // Prepare the export file header
    //

    (( PEFSEXP_FILE_HEADER )WorkBuffer )->VersionID = EFS_EXP_FORMAT_CURRENT_VERSION;
    RtlCopyMemory( &((( PEFSEXP_FILE_HEADER )WorkBuffer )->FileSignature[0]),
                   FILE_SIGNATURE,
                   EFS_SIGNATURE_LENGTH * sizeof( WCHAR )
                 );

    BufPointer = (char *) WorkBuffer + sizeof ( EFSEXP_FILE_HEADER );
    (( PEFSEXP_STREAM_HEADER )BufPointer )->Length = sizeof (USHORT) +
                                                     sizeof (EFSEXP_STREAM_HEADER);

    RtlCopyMemory( &((( PEFSEXP_STREAM_HEADER )BufPointer )->StreamSignature[0]),
               STREAM_SIGNATURE,
               EFS_SIGNATURE_LENGTH * sizeof( WCHAR )
             );
    (( PEFSEXP_STREAM_HEADER )BufPointer )->NameLength = sizeof (USHORT);

    BufPointer = (char *)BufPointer + sizeof (EFSEXP_STREAM_HEADER);
    PUShort = (USHORT *)BufPointer;
    *PUShort = EFS_STREAM_ID;

    //
    // Let's send out the File header and stream header
    //


    SendDataLength = (ULONG)((char *)BufPointer - (char *)WorkBuffer) + sizeof (USHORT);
    HResult = EFSSendPipeData( (char *)WorkBuffer, SendDataLength, EfsOutPipe );

    if (HResult != NO_ERROR)
    {
        VirtualFree(
            WorkBuffer,
            0,
            MEM_RELEASE
            );

        SafeAllocaFree( FsctlInput );


        //
        // Flush the pipe and return error.
        //

        (void) EFSSendPipeData( (char *)&SendDataLength, 0, EfsOutPipe );
        return HResult;
    }

    //
    // Reset BufPointer so that it is aligned again.
    //

    RtlZeroMemory( WorkBuffer, SendDataLength );
    BufPointer = WorkBuffer;

    RtlCopyMemory( &((( PEFSEXP_DATA_HEADER )BufPointer )->DataSignature[0]),
               DATA_SIGNATURE,
               EFS_SIGNATURE_LENGTH * sizeof( WCHAR )
             );
    FsctlOutput = (char *)BufPointer + sizeof ( EFSEXP_DATA_HEADER );
    FsctlOutputLength = WkBufLength - ( (ULONG) (( char* ) FsctlOutput - ( char* )WorkBuffer) );

    //
    // Issue the FSCTL to get the $EFS
    //
    EfsDataLength = FsctlInputLength = COMMON_FSCTL_HEADER_SIZE;

    ( VOID )SendHandle(
                ((PEXPORT_CONTEXT) Context)->Handle,
                (PUCHAR)FsctlInput + 3 * sizeof( ULONG ),
                &EfsDataLength
                );

    ( VOID ) EncryptFSCTLData(
                EFS_GET_ATTRIBUTE,
                0,
                0,
                (PUCHAR)FsctlInput  + 3 * sizeof(ULONG),
                EfsDataLength,
                (PUCHAR)FsctlInput,
                &FsctlInputLength
                );

    NtStatus = NtFsControlFile(
                ((PEXPORT_CONTEXT) Context)->Handle,
                0,
                NULL,
                NULL,
                &IoStatusBlock,
                FSCTL_ENCRYPTION_FSCTL_IO,
                FsctlInput,
                FsctlInputLength,
                FsctlOutput,
                FsctlOutputLength
                );

    if (!NT_SUCCESS( NtStatus )) {

        //
        //  Check if the output data buffer too small
        //  Try again if it is.
        //

        if ( NtStatus == STATUS_BUFFER_TOO_SMALL ){

            ULONG EfsMetaDataLength;
            ULONG BytesInBuffer;
            VOID  *TmpBuffer;

            EfsMetaDataLength = *((ULONG *)FsctlOutput);
            BytesInBuffer = (ULONG) (( char* ) FsctlOutput - ( char* )WorkBuffer);
            WkBufLength = EfsMetaDataLength + BytesInBuffer;

            // Make it a multiple of 4K

            WkBufLength = ((WkBufLength + FSCTL_OUTPUT_MISC_LENGTH - 1) / FSCTL_OUTPUT_MISC_LENGTH) * FSCTL_OUTPUT_MISC_LENGTH;

            TmpBuffer = VirtualAlloc(
                            NULL,
                            WkBufLength,
                            MEM_COMMIT,
                            PAGE_READWRITE
                            );

            if (TmpBuffer) {
                RtlCopyMemory(TmpBuffer, WorkBuffer, BytesInBuffer);

                VirtualFree(
                    WorkBuffer,
                    0,
                    MEM_RELEASE
                    );
                WorkBuffer = TmpBuffer;
                FsctlOutput = (char *)WorkBuffer + BytesInBuffer;
                FsctlOutputLength = WkBufLength - BytesInBuffer;
                BufPointer = WorkBuffer;

                NtStatus = NtFsControlFile(
                            ((PEXPORT_CONTEXT) Context)->Handle,
                            0,
                            NULL,
                            NULL,
                            &IoStatusBlock,
                            FSCTL_ENCRYPTION_FSCTL_IO,
                            FsctlInput,
                            FsctlInputLength,
                            FsctlOutput,
                            FsctlOutputLength
                            );
            } else {
                NtStatus = STATUS_INSUFFICIENT_RESOURCES;
            }
        }
    }

    if ( NT_SUCCESS(NtStatus)){

        (( PEFSEXP_DATA_HEADER )BufPointer )->Length = sizeof (EFSEXP_DATA_HEADER) + *((ULONG *)FsctlOutput);

        //
        // Send out the $EFS stream
        //

        SendDataLength = WkBufLength - FsctlOutputLength + *((ULONG *)FsctlOutput);

        HResult = EFSSendPipeData( (char *)WorkBuffer, SendDataLength, EfsOutPipe );

        //
        // Now begin to processing other data streams
        //


        StreamIndex = 0;
        StreamOffset = 0;

        if (((PEXPORT_CONTEXT) Context)->NumberOfStreams == 0) {

            MoreToRead = FALSE;

        } else {

            ( (PREQUEST_RAW_ENCRYPTED_DATA)FsctlInput )->Length = WkBufLength - FSCTL_OUTPUT_MISC_LENGTH;
            FsctlInputLength = sizeof ( REQUEST_RAW_ENCRYPTED_DATA );

        }

        while ( (HResult == NO_ERROR) && MoreToRead ){

            //
            // Fill the request header
            //

            ( (PREQUEST_RAW_ENCRYPTED_DATA)FsctlInput )->FileOffset = StreamOffset;

            //
            // Prepare output data
            //

            BufPointer = WorkBuffer ;

            if ( 0 == StreamOffset ){

                //
                //  Check if the stream is encrypted or not
                //  For the current version, we only support non-encrypted
                //  stream in directory file. Non-encrypted stream in normal
                //  file may be exported but import is not supported. EFS does
                //  not support mixed data stream in a file.
                //

                NtStatus = NtQueryInformationFile(
                            ((PEXPORT_CONTEXT) Context)->StreamHandles[ StreamIndex ],
                            &IoStatusBlock,
                            &StreamInfo,
                            sizeof (FILE_BASIC_INFORMATION),
                            FileBasicInformation
                            );

                if ( !NT_SUCCESS( NtStatus ) ){

                    //
                    // Error occured. Quit processing.
                    //

                    HResult = RtlNtStatusToDosError( NtStatus );
                    break;

                }

                if ( StreamInfo.FileAttributes & FILE_ATTRIBUTE_ENCRYPTED ){

                            StreamEncrypted = TRUE;
                            (( PEFSEXP_STREAM_HEADER )BufPointer )->Flag = 0;

                } else {

                            StreamEncrypted = FALSE;
                            (( PEFSEXP_STREAM_HEADER )BufPointer )->Flag = STREAM_NOT_ENCRYPTED;

                }

                //
                // A new stream started. Insert a stream header
                //

                (( PEFSEXP_STREAM_HEADER )BufPointer )->NameLength =
                        ((PEXPORT_CONTEXT) Context)->StreamNames[ StreamIndex ].Length;
                SendDataLength = (( PEFSEXP_STREAM_HEADER )BufPointer )->Length =
                        (( PEFSEXP_STREAM_HEADER )BufPointer )->NameLength +
                        sizeof (EFSEXP_STREAM_HEADER);

                RtlCopyMemory( &((( PEFSEXP_STREAM_HEADER )BufPointer )->StreamSignature[0]),
                        STREAM_SIGNATURE,
                        EFS_SIGNATURE_LENGTH * sizeof( WCHAR )
                        );

                (( PEFSEXP_STREAM_HEADER )BufPointer )->Reserved[0] =
                        (( PEFSEXP_STREAM_HEADER )BufPointer )->Reserved[1] =
                        0;

                BufPointer = (char *)BufPointer + sizeof (EFSEXP_STREAM_HEADER);

                RtlCopyMemory( BufPointer,
                        ((PEXPORT_CONTEXT) Context)->StreamNames[ StreamIndex ].Buffer,
                        ((PEXPORT_CONTEXT) Context)->StreamNames[ StreamIndex ].Length
                        );

                //
                // Let's send out the data so that we can better aligned for data section
                //

                HResult = EFSSendPipeData( (char *)WorkBuffer, SendDataLength, EfsOutPipe );
                if (HResult != NO_ERROR) {
                    break;
                } else {
                    BufPointer =  WorkBuffer;
                }

            }

            //
            // Prepare data header
            //

            (( PEFSEXP_DATA_HEADER )BufPointer )->Flag = 0;
            RtlCopyMemory( &((( PEFSEXP_DATA_HEADER )BufPointer )->DataSignature[0]),
                       DATA_SIGNATURE,
                       EFS_SIGNATURE_LENGTH * sizeof( WCHAR )
                     );
            FsctlOutput = (char *)BufPointer + sizeof ( EFSEXP_DATA_HEADER );
            FsctlOutputLength = WkBufLength - (ULONG)( ( char* ) FsctlOutput - ( char* )WorkBuffer);

            //
            // Read raw data
            //
            if ( StreamEncrypted ){

                //
                // Stream Encrypted. This is a sync call.
                //

                NtStatus = NtFsControlFile(
                            ((PEXPORT_CONTEXT) Context)->StreamHandles[ StreamIndex ],
                            0,
                            NULL,
                            NULL,
                            &IoStatusBlock,
                            FSCTL_READ_RAW_ENCRYPTED,
                            FsctlInput,
                            FsctlInputLength,
                            FsctlOutput,
                            FsctlOutputLength
                            );


                if ( !NT_SUCCESS( NtStatus ) && ( STATUS_END_OF_FILE != NtStatus) ){

                    //
                    // Error occured. Quit processing.
                    //

                    HResult = RtlNtStatusToDosError( NtStatus );
                    break;

                }

                //
                // Calculate the length of data send to caller
                //
                SendDataLength = ((PENCRYPTED_DATA_INFO)FsctlOutput)->OutputBufferOffset;
                for ( ii=0; ii < ((PENCRYPTED_DATA_INFO)FsctlOutput)->NumberOfDataBlocks; ii++){

                    SendDataLength += ((PENCRYPTED_DATA_INFO)FsctlOutput)->DataBlockSize[ii];

                }

                (( PEFSEXP_DATA_HEADER )BufPointer )->Length = SendDataLength +
                                                               sizeof ( EFSEXP_DATA_HEADER );
                SendDataLength += (ULONG)(( char* ) FsctlOutput - ( char* )WorkBuffer);

                //
                // Check if this is the last stream block
                //

                BytesAdvanced = ((PENCRYPTED_DATA_INFO)FsctlOutput)->NumberOfDataBlocks <<
                                ((PENCRYPTED_DATA_INFO)FsctlOutput)->DataUnitShift;

                if ( ( STATUS_END_OF_FILE == NtStatus ) ||
                     (((PENCRYPTED_DATA_INFO)FsctlOutput)->BytesWithinFileSize < BytesAdvanced)
                    ) {

                    //
                    // Last block in this stream
                    //

                    StreamOffset = 0;
                    StreamIndex++;
                    if ( StreamIndex >= ((PEXPORT_CONTEXT) Context)->NumberOfStreams ){

                        MoreToRead = FALSE;
                        HResult = NO_ERROR;

                    }

                    if ( STATUS_END_OF_FILE == NtStatus ){

                        //
                        //  End of file. No need to send data to caller
                        //

                        continue;
                    }

                } else {

                    //
                    // More data block to be read for this stream.
                    //

                    StreamOffset = ((PENCRYPTED_DATA_INFO)FsctlOutput)->StartingFileOffset
                                   + BytesAdvanced;

                }

            } else {

                //
                // Not encrypted stream. Use normal read.
                //

                NtStatus = NtReadFile(
                    ((PEXPORT_CONTEXT) Context)->StreamHandles[ StreamIndex ],
                    0,
                    NULL,
                    NULL,
                    &IoStatusBlock,
                    FsctlOutput,
                    FsctlOutputLength,
                    (PLARGE_INTEGER)&StreamOffset,
                    NULL
                    );

                if ( !NT_SUCCESS( NtStatus ) && ( STATUS_END_OF_FILE != NtStatus) ){

                    //
                    // Error occured. Quit processing.
                    //

                    HResult = RtlNtStatusToDosError( NtStatus );
                    break;

                }

                //
                // Calculate the length of data send to caller
                //

                SendDataLength = (ULONG)IoStatusBlock.Information;
                (( PEFSEXP_DATA_HEADER )BufPointer )->Length = SendDataLength +
                                                               sizeof ( EFSEXP_DATA_HEADER );

                SendDataLength += (ULONG)(( char* ) FsctlOutput - ( char* )WorkBuffer);

                //
                // Check if this is the last stream block
                //

                BytesAdvanced = (ULONG)IoStatusBlock.Information;

                if ( ( STATUS_END_OF_FILE == NtStatus ) || (FsctlOutputLength > BytesAdvanced)) {

                    //
                    // Last block in this stream
                    //

                    StreamOffset = 0;
                    StreamIndex++;
                    if ( StreamIndex >= ((PEXPORT_CONTEXT) Context)->NumberOfStreams ){

                        MoreToRead = FALSE;
                        HResult = NO_ERROR;

                    }

                    if ( STATUS_END_OF_FILE == NtStatus ){

                        //
                        //  End of file. No need to send data to caller
                        //

                        continue;
                    }

                } else {

                    //
                    // More data block to be read for this stream.
                    //

                    StreamOffset += BytesAdvanced;

                }

            }

            HResult = EFSSendPipeData( (char *)WorkBuffer, SendDataLength, EfsOutPipe );

        }//while

    } else {

        //
        //  Read $EFS wrong
        //

        HResult = RtlNtStatusToDosError( NtStatus );

    }

    //
    // End the sending data with length of 0 byte. (This flushes the pipe.)
    //

    EFSSendPipeData( (char *)WorkBuffer, 0, EfsOutPipe );

    //
    //  Finished. Clean up the memory.
    //

    VirtualFree(
        WorkBuffer,
        0,
        MEM_RELEASE
        );

    SafeAllocaFree( FsctlInput );

    return HResult;
}


ULONG
CheckSignature(
    void *Signature
    )

/*++

Routine Description:

    This routine returns the signature type.

Arguments:

    Signature - Signature string.

Return Value:

    The type of signature. 0 for bogus signature.

--*/
{

    if ( !memcmp( Signature, FILE_SIGNATURE, SIG_LENGTH )){

        return SIG_EFS_FILE;

    }

    if ( !memcmp( Signature, STREAM_SIGNATURE, SIG_LENGTH )){

        return SIG_EFS_STREAM;

    }

    if ( !memcmp( Signature, DATA_SIGNATURE, SIG_LENGTH )){

        return SIG_EFS_DATA;

    }

    return SIG_NO_MATCH;
}

long
EfsWriteFileRaw(
    PVOID           Context,
    PVOID           EfsInPipe
    )
/*++

Routine Description:

    This routine is used to write encrypted file's raw data. It uses
    NTFS FSCTL to put the data.

Arguments:

    Context -- Context handle.
    EfsInPipe -- Pipe handle.

Return Value:

    The result of operation.

--*/
{
    DWORD   HResult = NO_ERROR;
    ULONG   GetDataLength;
    ULONG   NextToRead;
    ULONG   FsctlInputLength;
    ULONG   BytesInBuffer;
    VOID    *WorkBuffer = NULL;
    VOID    *ReadBuffer = NULL;
    VOID    *FsctlInput;
    VOID    *BufPointer;

    NTSTATUS NtStatus;
    IO_STATUS_BLOCK  IoStatusBlock;
    HANDLE  CurrentStream = 0;
    LONGLONG StreamOffset;
    ULONG   SigID;
    UNICODE_STRING StreamName;
    OBJECT_ATTRIBUTES ObjectAttributes;
    PEFSEXP_STREAM_HEADER StreamHeader;
    TOKEN_PRIVILEGES    Privs;
    PTOKEN_PRIVILEGES   OldPrivs = NULL;
    HANDLE  TokenHandle = 0;
    DWORD   ReturnLength;
    BOOL    GotToken;
    BOOLEAN PrivilegeEnabled = FALSE;
    BOOLEAN MoreByteToWrite = TRUE;
    BOOLEAN CrntStrIsDefault = FALSE;
    BOOLEAN CrntStreamEncrypted = TRUE;

    if ( (((PEXPORT_CONTEXT) Context)->ContextID != EFS_CONTEXT_ID) ||
        !(((PIMPORT_CONTEXT) Context)->Flag & CONTEXT_FOR_IMPORT ) ||
         (((PIMPORT_CONTEXT) Context)->Flag & CONTEXT_INVALID) 
       ){

        //
        // Possible RPC attack.
        //

        return ERROR_ACCESS_DENIED;

    }

    //
    // Allocate necessary memory
    //

    WorkBuffer = VirtualAlloc(
                    NULL,
                    FSCTL_OUTPUT_INITIAL_LENGTH,
                    MEM_COMMIT,
                    PAGE_READWRITE
                    );

    if ( !WorkBuffer ){
            return ERROR_OUTOFMEMORY;
    }

    //
    //  Read in the file headers first.
    //

    GetDataLength = sizeof ( EFSEXP_FILE_HEADER ) +
                    sizeof ( EFSEXP_STREAM_HEADER ) +
                    sizeof ( USHORT ) +
                    sizeof ( EFSEXP_DATA_HEADER ) +
                    sizeof ( ULONG );

    HResult = EFSReceivePipeData( (char *)WorkBuffer, &GetDataLength, EfsInPipe );

    if ( NO_ERROR != HResult ){

        VirtualFree(
            WorkBuffer,
            0,
            MEM_RELEASE
            );
        return HResult;

    }

    //
    // Verify file format
    //

    if ( SIG_EFS_FILE != CheckSignature(
                                (char *)WorkBuffer +
                                sizeof( ULONG)
                                ) ||
         SIG_EFS_STREAM != CheckSignature(
                                (char *)WorkBuffer +
                                sizeof( EFSEXP_FILE_HEADER ) +
                                sizeof( ULONG)
                                ) ||
         SIG_EFS_DATA != CheckSignature(
                                (char *)WorkBuffer +
                                sizeof( EFSEXP_FILE_HEADER ) +
                                sizeof ( EFSEXP_STREAM_HEADER ) +
                                sizeof ( USHORT ) +
                                sizeof( ULONG)
                                ) ||
         EFS_STREAM_ID != *((USHORT *)(
                                (char *)WorkBuffer +
                                sizeof( EFSEXP_FILE_HEADER ) +
                                sizeof ( EFSEXP_STREAM_HEADER )
                                )) ||
         EFS_EXP_FORMAT_CURRENT_VERSION != ((PEFSEXP_FILE_HEADER)WorkBuffer)->VersionID ){

        //
        // Signature does not match. This includes file which has less bytes than
        // expected head information.
        //

        VirtualFree(
            WorkBuffer,
            0,
            MEM_RELEASE
            );

        return ERROR_BAD_FORMAT;

    }

    //
    // Read in $EFS
    //


    RtlCopyMemory( WorkBuffer, (char *)WorkBuffer + GetDataLength - sizeof(ULONG), sizeof( ULONG ) );
    BytesInBuffer = sizeof(ULONG);
    BufPointer = (char *)WorkBuffer + BytesInBuffer;

    //
    // The read will include the length of the next block.
    //

    NextToRead = GetDataLength = *((PULONG)WorkBuffer) ;
    FsctlInputLength = FSCTL_OUTPUT_INITIAL_LENGTH - BytesInBuffer;

    if ((NextToRead + NextToRead + FSCTL_OUTPUT_MISC_LENGTH) > (FSCTL_OUTPUT_INITIAL_LENGTH - BytesInBuffer)) {

        //
        // We need a large buffer to hold 2 $EFS plus some head info
        //

        VOID *TmpBuffer;
        ULONG NewBufferLength;

        NewBufferLength = ((NextToRead + NextToRead + FSCTL_OUTPUT_MISC_LENGTH + BytesInBuffer
                           + FSCTL_OUTPUT_MISC_LENGTH - 1) / FSCTL_OUTPUT_MISC_LENGTH) * FSCTL_OUTPUT_MISC_LENGTH;

        TmpBuffer = VirtualAlloc(
                        NULL,
                        NewBufferLength,
                        MEM_COMMIT,
                        PAGE_READWRITE
                        );
        if (TmpBuffer) {

            RtlCopyMemory( TmpBuffer, WorkBuffer, BytesInBuffer);

            VirtualFree(
                WorkBuffer,
                0,
                MEM_RELEASE
                );
            WorkBuffer = TmpBuffer;
            BufPointer = (char *)WorkBuffer + BytesInBuffer;
            FsctlInputLength = NewBufferLength - BytesInBuffer;

        } else {

            VirtualFree(
                WorkBuffer,
                0,
                MEM_RELEASE
                );
            return ERROR_OUTOFMEMORY;
        }

    }

    HResult = EFSReceivePipeData( (char *)BufPointer, &NextToRead, EfsInPipe );
    if ( NO_ERROR != HResult ){

        VirtualFree(
            WorkBuffer,
            0,
            MEM_RELEASE
            );
        return HResult;

    }

    if ( GetDataLength > NextToRead){

        //
        // No data stream followed $EFS. This is either a 0 length file
        // Or a directory file.
        //

        MoreByteToWrite = FALSE;
        NextToRead = 0;

    }  else {

        NextToRead = *(ULONG UNALIGNED *)(( char *) BufPointer + GetDataLength - sizeof (ULONG));

    }

    //
    //  The $EFS is in. Write it out!
    //  First prepare the FsctlInput
    //

    FsctlInput = (char*) BufPointer + GetDataLength;
    FsctlInputLength -= GetDataLength;

    //
    // Send FsctlInputData to the server
    //

    HResult = GetOverWriteEfsAttrFsctlInput(
                        (( PIMPORT_CONTEXT ) Context)->Flag,
                        (( PIMPORT_CONTEXT ) Context)->DesiredAccess,
                        ( char * )BufPointer - sizeof (ULONG),
                        GetDataLength,
                        (char *)FsctlInput,
                        &FsctlInputLength
                        );

    if ( NO_ERROR != HResult ){

        VirtualFree(
            WorkBuffer,
            0,
            MEM_RELEASE
            );
        return HResult;

    }

    NtStatus = NtFsControlFile(
                ((PIMPORT_CONTEXT) Context)->Handle,
                0,
                NULL,
                NULL,
                &IoStatusBlock,
                FSCTL_SET_ENCRYPTION ,
                FsctlInput,
                FsctlInputLength,
                NULL,
                NULL
                );

    if ( NT_SUCCESS( NtStatus )){

        DWORD ShareMode = 0;

        //
        // $EFS is written now
        //

        StreamOffset = 0;

        //
        // ********* Trick Trick Trick *********
        // NTFS will have better performance if align the data block.
        // We already have the length field of the block which is a ULONG
        // field. Here we start our offset at sizeof (ULONG).
        // Not only performance, now is required by NTFS. Otherwise it will
        // fail.
        //

        BufPointer = (char *)WorkBuffer + sizeof (ULONG);

        while ( MoreByteToWrite ){

            GetDataLength = NextToRead;

            //
            // The read will include the length of the next block.
            // No backward reading here.
            //

            HResult = EFSReceivePipeData( (char *)BufPointer, &GetDataLength, EfsInPipe );

            if ( NO_ERROR != HResult ){

                break;

            }

            __try{

                if ( GetDataLength < NextToRead ){

                    //
                    // End of file reached
                    //

                    MoreByteToWrite = FALSE;
                    NextToRead = 0;

                } else {

                    //
                    // Prepare for next read block. Be careful about the alignment here.
                    //

                    RtlCopyMemory((char *) &NextToRead,
                                  (char *) BufPointer +  GetDataLength - sizeof (ULONG),
                                  sizeof (ULONG)
                                  );

                }

                SigID = CheckSignature( BufPointer );
                if ( SIG_EFS_STREAM == SigID ){

                    //
                    // This is a stream block. Create a new stream.
                    //

                    StreamHeader = (PEFSEXP_STREAM_HEADER)((char *)BufPointer - sizeof( ULONG ));
                    if ( StreamHeader->Flag & STREAM_NOT_ENCRYPTED ){

                        CrntStreamEncrypted = FALSE;

                    } else {

                        CrntStreamEncrypted = TRUE;
                    }

                    StreamName.Length = (USHORT) StreamHeader->NameLength;

                    StreamName.Buffer = ( USHORT* )((char *)BufPointer +
                        sizeof ( EFSEXP_STREAM_HEADER ) -
                        sizeof ( ULONG ));

                    if ( CurrentStream && !CrntStrIsDefault){

                        //
                        // Close the previous stream
                        //

                        NtClose(CurrentStream);
                        CurrentStream = 0;

                    }

                    if ( (DEF_STR_LEN == StreamName.Length) &&
                         !memcmp( StreamName.Buffer,
                                DEFAULT_STREAM,
                                StreamName.Length
                                )
                       ){

                        //
                        // Default data stream to be processed.
                        // This is the most case. We need to optimize this!!!
                        //

                        CurrentStream = ((PIMPORT_CONTEXT) Context)->Handle;
                        CrntStrIsDefault = TRUE;

                    } else {

                        //
                        //  Other data streams
                        //

                        if ( (((( PIMPORT_CONTEXT ) Context)->CreateOptions) & FILE_OPEN_FOR_BACKUP_INTENT) &&
                              ( !PrivilegeEnabled))
                        {
                            //
                            // Enable the Privilege. We only enable once. If fail, we return.
                            //

                            PrivilegeEnabled = TRUE;

                            SafeAllocaAllocate(OldPrivs, sizeof( TOKEN_PRIVILEGES ));

                            if ( OldPrivs == NULL )
                            {
                                HResult = ERROR_NOT_ENOUGH_MEMORY;
                                break;
                            }

                            //
                            // We're impersonating, use the thread token.
                            //

                            GotToken = OpenThreadToken(
                                    GetCurrentThread(),
                                    TOKEN_ADJUST_PRIVILEGES | TOKEN_QUERY,
                                    FALSE,
                                    &TokenHandle
                                    );

                            if ( GotToken ) {

                                //
                                // We've got a token handle
                                //

                                Privs.PrivilegeCount = 1;
                                Privs.Privileges[0].Attributes = SE_PRIVILEGE_ENABLED;
                                Privs.Privileges[0].Luid = RtlConvertLongToLuid(SE_RESTORE_PRIVILEGE);

                                ReturnLength = sizeof( TOKEN_PRIVILEGES );

                                (VOID) AdjustTokenPrivileges (
                                            TokenHandle,
                                            FALSE,
                                            &Privs,
                                            sizeof( TOKEN_PRIVILEGES ),
                                            OldPrivs,
                                            &ReturnLength
                                            );

                                HResult = GetLastError();

                                //
                                // Caller will call RpcRevertToSelf().
                                // OldPrivs is not needed any more.
                                //

                                SafeAllocaFree( OldPrivs );
                                OldPrivs = NULL;

                                if ( ERROR_SUCCESS != HResult ) {

                                    //
                                    // Privilege adjust failed
                                    //

                                    CloseHandle( TokenHandle );
                                    TokenHandle = 0;
                                    break;

                                }

                            } else {

                                //
                                // We did not get the handle.
                                //

                                TokenHandle = 0;
                                HResult = GetLastError();
                                SafeAllocaFree( OldPrivs );
                                OldPrivs = NULL;
                                break;

                            }

                            if (((PIMPORT_CONTEXT) Context)->DesiredAccess & DELETE) {
                                ShareMode = FILE_SHARE_DELETE;
                            }
                        }

                        StreamName.MaximumLength = StreamName.Length;

                        CrntStrIsDefault = FALSE;

                        InitializeObjectAttributes(
                                &ObjectAttributes,
                                &StreamName,
                                0,
                                ((PIMPORT_CONTEXT) Context)->Handle,
                                NULL
                                );

                        NtStatus = NtCreateFile(
                                        &CurrentStream,
                                        ((PIMPORT_CONTEXT) Context)->DesiredAccess,
                                        &ObjectAttributes,
                                        &IoStatusBlock,
                                        (PLARGE_INTEGER) NULL,
                                        ((PIMPORT_CONTEXT) Context)->Attribute,
                                        ShareMode,
                                        ((PIMPORT_CONTEXT) Context)->CreateDisposition,
                                        ((PIMPORT_CONTEXT) Context)->CreateOptions,
                                        (PVOID) NULL,
                                        0L
                                        );

                        if ( !NT_SUCCESS( NtStatus ) ){

                            HResult = RtlNtStatusToDosError( NtStatus );
                            break;

                        }
                    }

                    //
                    // Stream header processed. Adjust BufPointer to make it consistant with ReadRaw
                    //

                    BufPointer = (char *)WorkBuffer + sizeof (ULONG);
                    continue;

                }

                if ( SIG_EFS_DATA != SigID ){

                    //
                    // Corrupted file
                    //
                    HResult = ERROR_FILE_CORRUPT;
                    break;

                }

                //
                // Processing the data block
                // After all the above is done, this should be a piece of cake!
                //

                FsctlInput = (char *)BufPointer + sizeof (EFSEXP_DATA_HEADER) - sizeof (ULONG);
                FsctlInputLength = GetDataLength - sizeof (EFSEXP_DATA_HEADER);
                if ( !MoreByteToWrite ){

                    //
                    //  Adjust for the last block. There is no extra length
                    //  field for the next block.
                    //

                    FsctlInputLength += sizeof (ULONG);
                }

                if ( CrntStreamEncrypted ){

                    //
                    // Most of the case.
                    //

                    //
                    //  finally writing data out
                    //

                    NtStatus = NtFsControlFile(
                                CurrentStream,
                                0,
                                NULL,
                                NULL,
                                &IoStatusBlock,
                                FSCTL_WRITE_RAW_ENCRYPTED,
                                FsctlInput,
                                FsctlInputLength,
                                NULL,
                                0
                                );

                } else {

                    //
                    // Currently only support plain data stream on directory
                    //

                    NtStatus = NtWriteFile(
                        CurrentStream,
                        0,
                        NULL,
                        NULL,
                        &IoStatusBlock,
                        FsctlInput,
                        FsctlInputLength,
                        NULL,
                        NULL
                        );

                }

                if ( !NT_SUCCESS( NtStatus ) ){

                    HResult = RtlNtStatusToDosError( NtStatus );
                    break;

                }

                BufPointer = (char *)WorkBuffer + sizeof (ULONG);
                HResult = NO_ERROR;

            }__except(EXCEPTION_EXECUTE_HANDLER) {

              //
              // Malicious data passed in. Return access denied.
              //

              HResult = ERROR_FILE_CORRUPT;
              MoreByteToWrite = FALSE;

            }


        } //while loop

    } else {

        //
        // Writing $EFS error
        //

        HResult = RtlNtStatusToDosError( NtStatus );

    }

    if ( CurrentStream && !CrntStrIsDefault ){

        NtClose(CurrentStream);

    }

    if ( TokenHandle ){
        CloseHandle( TokenHandle );
    }

    VirtualFree(
        WorkBuffer,
        0,
        MEM_RELEASE
        );

    if (HResult == ERROR_FILE_CORRUPT) {

        EfspLogAttack(NULL, CORRUPT_DATA_1);

    }

    return HResult;

}

DWORD
GetOverWriteEfsAttrFsctlInput(
    ULONG Flag,
    ULONG AccessFlag,
    char *InputData,
    ULONG InputDataLength,
    char *OutputData,
    ULONG *OutputDataLength
    )
/*++

Routine Description:

    This routine is used to prepare the FSCTL input data buffer for
    EFS_OVERWRITE_ATTRIBUTE used in import.

Arguments:

    Flag -- Indicate the type of the target.

    AccessFlag -- Indicate the kind of access required.

    InputData -- Required input data ($EFS)

    InputDataLength -- The length of the input data.

    OutputData -- The prepared data as the result of this routine.

    OutputDataLength -- The length of the output data.

Return Value:

    The result of operation.

--*/
{
    DWORD   HResult = NO_ERROR;
    PEFS_KEY Fek = NULL;
    PEFS_DATA_STREAM_HEADER NewEfs = NULL;
    ULONG EfsDataLength = 0 ;
    ULONG OutBufLen = *OutputDataLength;
    BOOLEAN WithFek = FALSE;
    PBYTE SourceEfs;
    ULONG CipherSubCode;
    EFS_USER_INFO EfsUserInfo;


    if ( !(Flag & CONTEXT_OPEN_FOR_DIR) ){

        //
        // Not for directory file. Check if we can get
        // FEK or not.
        //

        if (EfspGetUserInfo( &EfsUserInfo )) {

            if (EfspLoadUserProfile( &EfsUserInfo, FALSE )) {

                HResult = DecryptFek(
                            &EfsUserInfo,
                            ( PEFS_DATA_STREAM_HEADER ) InputData,
                            &Fek,
                            &NewEfs,
                            0
                            );

                EfspUnloadUserProfile( &EfsUserInfo );

            } else {

                HResult = GetLastError();

            }

            EfspFreeUserInfo( &EfsUserInfo );

        } else {

            HResult = GetLastError();

        }

        if ( NO_ERROR == HResult ){

            WithFek = TRUE;

        } else {

            if ( AccessFlag & FILE_WRITE_DATA ){

                //
                //  A general user without the key.
                //



                return ERROR_ACCESS_DENIED;

            } else {

                HResult = NO_ERROR;

            }

        }
    }

    if ( WithFek ){

        //
        // Calculate the length of output buffer
        // and the offset to put the $EFS
        //

        *OutputDataLength = 3 * sizeof(ULONG) +
                                  2 * EFS_KEY_SIZE( Fek );

        if (NewEfs){
            SourceEfs = (PBYTE) NewEfs;
        } else {
            SourceEfs = (PBYTE) InputData;
        }
        *OutputDataLength += *(PULONG)SourceEfs;

        if (OutBufLen >= *OutputDataLength) {

           EfsDataLength = *OutputDataLength - 3 * sizeof(ULONG);

           ( VOID ) SendEfs(
                        Fek,
                        (PEFS_DATA_STREAM_HEADER) SourceEfs,
                        (PBYTE) OutputData + 3 * sizeof(ULONG),
                        &EfsDataLength
                        );
        } else {
           HResult = ERROR_INSUFFICIENT_BUFFER;
        }

        //
        //  Free the memory we have allocated.
        //

        if ( Fek ){

            LsapFreeLsaHeap( Fek );

        }
        if ( NewEfs ){

            LsapFreeLsaHeap( NewEfs );

        }

        CipherSubCode = WRITE_EFS_ATTRIBUTE | SET_EFS_KEYBLOB;

    } else {

        //
        // No FEK required.
        //

        *OutputDataLength = COMMON_FSCTL_HEADER_SIZE +
                                  *(PULONG)InputData;


        if (OutBufLen >= *OutputDataLength) {
           EfsDataLength = *OutputDataLength - 3 * sizeof(ULONG);

           ( VOID ) SendHandleAndEfs(
                       (HANDLE) ULongToPtr(Flag),
                       (PEFS_DATA_STREAM_HEADER) InputData,
                       (PBYTE) OutputData + 3 * sizeof(ULONG),
                       &EfsDataLength
                       );
        } else {
           HResult = ERROR_INSUFFICIENT_BUFFER;
        }

        CipherSubCode = WRITE_EFS_ATTRIBUTE;

    }

    if ( NO_ERROR == HResult ) {

       ( VOID ) EncryptFSCTLData(
                   EFS_OVERWRITE_ATTRIBUTE,
                   EFS_ENCRYPT_STREAM,
                   CipherSubCode,
                   (PBYTE) OutputData + 3 * sizeof(ULONG),
                   EfsDataLength,
                   (PBYTE) OutputData,
                   OutputDataLength
                   );

    }

    return HResult;

}

DWORD
CheckVolumeSpace(
    PFILE_FS_SIZE_INFORMATION VolInfo,
    PEFS_STREAM_SIZE StreamSizes,
    PHANDLE StreamHandles,
    ULONG StreamCount
    )
/*++

Routine Description:

    This routine estimates if the volume has enough disk space to do the encryption or
    decryption operation. The estimates is not accurate. System overheads are not included.
    Real available space could be more or less when the operation begins. If we are not sure,
    the operation will continue until we really run out of space.

Arguments:

    VolInfo -- Information to calculate how much space left.

    StreamSizes -- Information to calculate how much space needed.

    StreamCount -- Number of data streams.

Return Value:

    ERROR_SUCCESS returned if there might be enough space.

--*/
{
    LARGE_INTEGER   SpaceLeft;
    LARGE_INTEGER   SpaceNeeded;
    ULONG   ClusterSize;
    ULONG ii;

    SpaceLeft = VolInfo->AvailableAllocationUnits;
    ClusterSize = VolInfo->SectorsPerAllocationUnit * VolInfo->BytesPerSector;
    SpaceLeft.QuadPart *= ClusterSize;
    for ( ii = 0, SpaceNeeded.QuadPart = 0; ii < StreamCount; ii++)
    {
        if ( StreamSizes[ii].StreamFlag & ( FILE_ATTRIBUTE_COMPRESSED | FILE_ATTRIBUTE_SPARSE_FILE ) ){

            FILE_STANDARD_INFORMATION   StreamStdInfo;
            IO_STATUS_BLOCK IoStatusBlock;
            NTSTATUS Status;

            //
            // Get File Attributes
            //
            Status = NtQueryInformationFile(
                StreamHandles[ii],
                &IoStatusBlock,
                &StreamStdInfo,
                sizeof ( FILE_STANDARD_INFORMATION ),
                FileStandardInformation
                );

            if (!NT_SUCCESS(Status)){

                //
                // We got error. We are not sure if we have enough space. Give it a try.
                //

                return ERROR_SUCCESS;
            }

            if ( StreamSizes[ii].StreamFlag &  FILE_ATTRIBUTE_SPARSE_FILE ){

                //
                // A sparse file (may be compressed). The more accurate way is to query
                // the ranges. Even with that is still a rough estimate. For better performance,
                // we use the STD info.
                //

                SpaceNeeded.QuadPart += StreamStdInfo.AllocationSize.QuadPart;

            } else {

                //
                // Compressed file. Using Virtual Allocation Size + Total Allocation Size
                //

                SpaceNeeded.QuadPart += StreamSizes[ii].AllocSize.QuadPart + StreamStdInfo.AllocationSize.QuadPart;

            }

        } else {
            SpaceNeeded.QuadPart += StreamSizes[ii].AllocSize.QuadPart;
        }

        if ( SpaceNeeded.QuadPart >=  SpaceLeft.QuadPart ){
            return ERROR_DISK_FULL;
        }
    }

    return ERROR_SUCCESS;
}

DWORD
CompressStreams(
    PEFS_STREAM_SIZE StreamSizes,
    PHANDLE StreamHandles,
    ULONG State,
    ULONG StreamCount
    )
/*++

Routine Description:

    This routine compresses or decompresses the passed in streams.

Arguments:

    StreamSizes -- Holding streams' original state info.

    StreamHandles -- Stream handles.

    State -- New compressed state.

    StreamCount -- Number of data streams.

Return Value:

    ERROR_SUCCESS returned if there might be enough space.

--*/
{
    DWORD rc = ERROR_SUCCESS;
    ULONG Length;
    ULONG ii;
    BOOL b = TRUE;

    for (ii = 0; ii < StreamCount; ii++){

        b = DeviceIoControl(
                            StreamHandles[ii],
                            FSCTL_SET_COMPRESSION,
                            &State,
                            sizeof(USHORT),
                            NULL,
                            0,
                            &Length,
                            FALSE
                            );

        if ( !b ){
            rc = GetLastError();
            break;
        }

    }

    if ( !b ){

        //
        //  Error happened. Try to restore the stream state.
        //

        for ( ULONG jj = 0; jj < ii; jj++){

            if ( StreamSizes[ jj ].StreamFlag & FILE_ATTRIBUTE_COMPRESSED ){

                State =  COMPRESSION_FORMAT_DEFAULT;

            } else {

                State =  COMPRESSION_FORMAT_NONE;

            }

            //
            // Error is not checked. We can only recover the state as much
            // as we can.
            //

            (VOID) DeviceIoControl(
                                StreamHandles[jj],
                                FSCTL_SET_COMPRESSION,
                                &State,
                                sizeof(USHORT),
                                NULL,
                                0,
                                &Length,
                                FALSE
                                );
        }

    }

    return rc;
}

DWORD
CheckOpenSection(
    PEFS_STREAM_SIZE StreamSizes,
    PHANDLE StreamHandles,
    ULONG StreamCount
    )
/*++

Routine Description:

    This routine set EOF of a stream to 0 and then back to its original size.
    All the stream content is lost. Valid length is set to 0. This process will also
    speed up a compressed file encryption.

Arguments:

    StreamSizes -- Holding streams' original state info.

    StreamHandles -- Stream handles.

    StreamCount -- Number of data streams.

Return Value:

    ERROR_SUCCESS returned if succeed.

--*/
{
    ULONG ii;
    FILE_END_OF_FILE_INFORMATION    FileSize;
    IO_STATUS_BLOCK IoStatusBlock;
    NTSTATUS Status = STATUS_SUCCESS;

    for (ii = 0; ii < StreamCount; ii++){
        FileSize.EndOfFile.QuadPart = 0;
        Status = NtSetInformationFile(
                    StreamHandles[ii],
                    &IoStatusBlock,
                    &FileSize,
                    sizeof(FileSize),
                    FileEndOfFileInformation
                    );
        if ( !NT_SUCCESS(Status) ){

            //
            // A section handle may be open on the stream.
            //

            break;
        }
    }

    if ( NT_SUCCESS(Status) ){
        for (ii = 0; ii < StreamCount; ii++){
            FileSize.EndOfFile = StreamSizes[ii].EOFSize;
            Status = NtSetInformationFile(
                        StreamHandles[ii],
                        &IoStatusBlock,
                        &FileSize,
                        sizeof(FileSize),
                        FileEndOfFileInformation
                        );
            if ( !NT_SUCCESS(Status) ){
                break;
            }
        }
    }

    return RtlNtStatusToDosError( Status );
}

DWORD
CopyStreamSection(
    HANDLE Target,
    HANDLE SrcMapping,
    PLARGE_INTEGER Offset,
    PLARGE_INTEGER DataLength,
    PLARGE_INTEGER AllocationGranularity
    )
/*++

Routine Description:

    This routine copies a section of data from source stream
    to target stream.

Arguments:

    Target -- Destination stream handle.

    SrcMapping -- Source stream mapping handle.

    Offset -- Data offdset in the stream.

    DataLength -- Byte count to be copied.

    AllocationGranularity -- Allocation granularity.

Return Value:

    Results of the operation.

--*/
{
    LARGE_INTEGER RemainingData = *DataLength;
    LARGE_INTEGER StreamOffset = *Offset;
    ULONG BytesToCopy;
    PVOID pbFile;
    DWORD BytesWritten;
    BOOL b;
    DWORD rc = NO_ERROR;

    while ( RemainingData.QuadPart > 0 ) {

        //
        // Determine number of bytes to be mapped
        //

        if (  RemainingData.QuadPart < AllocationGranularity->QuadPart ) {
            BytesToCopy = RemainingData.LowPart;
        } else {
            BytesToCopy = AllocationGranularity->LowPart;
        }

        pbFile = MapViewOfFile(
                      SrcMapping,
                      FILE_MAP_READ,
                      StreamOffset.HighPart,
                      StreamOffset.LowPart,
                      BytesToCopy
                      );

        if (pbFile != NULL) {

            //
            // Write the data to the target stream
            //

            b = WriteFile(
                       Target,
                       pbFile,
                       BytesToCopy,
                       &BytesWritten,
                       NULL
                       );

            UnmapViewOfFile( pbFile );

            LARGE_INTEGER BytesCopied;

            BytesCopied.HighPart = 0;
            BytesCopied.LowPart = BytesToCopy;

            RemainingData.QuadPart -= BytesCopied.QuadPart;
            StreamOffset.QuadPart += BytesCopied.QuadPart;

            if (!b) {
                rc = GetLastError();
                DebugLog((DEB_ERROR, "WriteFile failed, error = %d\n", rc ));
                break;
            }

        } else {

            rc = GetLastError();
            DebugLog((DEB_ERROR, "MapViewOfFile failed, error = %d\n" ,rc));
            break;
        }
    }

    return rc;

}

NTSTATUS
GetFileEfsStream(
    IN HANDLE hFile,
    OUT PEFS_DATA_STREAM_HEADER * pEfsStream
    )
/*++

Routine Description:

    Get the $EFS from the passed file or directory

Arguments:

    hFile - An open handle the the file or directory of interest.

    pEfsStream - Returns a pointer to a block of memory containing the EFS stream
        for the passed file.  Free with LsapFreeLsaHeap();

Return Value:

    Status of operation.

--*/

{

    ULONG Index;
    ULONG cbOutputData;
    ULONG EfsDataLength;
    NTSTATUS Status;
    IO_STATUS_BLOCK IoStatusBlock;
    ULONG TmpOutputData;

    *pEfsStream = NULL;

    //
    // Now we got a handle to the parent directory in ParentDir.
    // Allocate input and output data buffer
    //

    cbOutputData = sizeof( ULONG );

    //
    // PSC, [EFS_FC, CSC , SK, H, H, [SK, H, H]sk]sk
    // PSC, CSC are ignored in this FSCTL call
    //

    const ULONG InputDataSize = (2 * sizeof(DriverSessionKey)) + (7 * sizeof(ULONG));
    BYTE InputData[InputDataSize];

    ULONG cbInputData = InputDataSize;

    //
    // Prepare an input data for making a FSCTL call to get the $EFS
    //

    EfsDataLength = 2 * sizeof(DriverSessionKey) + 4 * sizeof(ULONG);
    SendHandle( hFile, InputData + 3*sizeof(ULONG), &EfsDataLength );

    (VOID) EncryptFSCTLData(
                EFS_GET_ATTRIBUTE,
                0,
                0,
                InputData + (3 * sizeof(ULONG)),
                EfsDataLength,
                InputData,
                &cbInputData
                );

    //
    // First call to get the size
    //

    Status = NtFsControlFile(
                hFile,
                0,
                NULL,
                NULL,
                &IoStatusBlock,
                FSCTL_ENCRYPTION_FSCTL_IO,
                InputData,
                cbInputData,
                &TmpOutputData,
                cbOutputData
                );

    ASSERT(!NT_SUCCESS( Status ));

    if (Status == STATUS_BUFFER_TOO_SMALL) {

        //
        //  Check if the output data buffer too small
        //  Try again if it is.
        //

        cbOutputData = TmpOutputData;
        *pEfsStream = (PEFS_DATA_STREAM_HEADER)LsapAllocateLsaHeap( cbOutputData );

        if ( *pEfsStream ) {

            Status = NtFsControlFile(
                    hFile,
                    0,
                    NULL,
                    NULL,
                    &IoStatusBlock,
                    FSCTL_ENCRYPTION_FSCTL_IO,
                    InputData,
                    cbInputData,
                    *pEfsStream,
                    cbOutputData
                    );
        } else {

            Status = STATUS_INSUFFICIENT_RESOURCES;
        }

        if ( !NT_SUCCESS( Status ) ){

            if ( *pEfsStream ){
                LsapFreeLsaHeap( *pEfsStream );
                *pEfsStream = NULL;
            }
        }
    }

    return Status;
}


ULONG
StringInfoCmp(
    IN PFILE_STREAM_INFORMATION StreamInfoBaseSrc,
    IN PFILE_STREAM_INFORMATION StreamInfoBaseDst,
    IN ULONG StreamInfoSize
    )
/*++

Routine Description:

    This routine compares to blocks FILE_STREAM_INFORMATION. The StreamAllocationSize
    cound differ and they should still be thought as eaqual.

Arguments:

    StreamInfoBaseSrc - Source block

    StreamInfoBaseDst - Dstination block

    StreamInfoSize - Block size in bytes

Return Value:

    0 if compares same.

--*/
{
   ULONG rc;

   rc = memcmp(StreamInfoBaseSrc, StreamInfoBaseDst, StreamInfoSize);
   if (rc) {
      do {

         rc = memcmp(StreamInfoBaseSrc->StreamName,
                     StreamInfoBaseDst->StreamName,
                     StreamInfoBaseSrc->StreamNameLength
                     );

         if (StreamInfoBaseSrc->NextEntryOffset){
             StreamInfoBaseSrc = (PFILE_STREAM_INFORMATION)((PCHAR) StreamInfoBaseSrc + StreamInfoBaseSrc->NextEntryOffset);
         } else {
             StreamInfoBaseSrc = NULL;
         }

         if (StreamInfoBaseDst->NextEntryOffset){
             StreamInfoBaseDst = (PFILE_STREAM_INFORMATION)((PCHAR) StreamInfoBaseDst + StreamInfoBaseDst->NextEntryOffset);
         } else {
             StreamInfoBaseDst = NULL;
         }

         if (((StreamInfoBaseSrc == NULL) || (StreamInfoBaseDst == NULL)) && (StreamInfoBaseSrc != StreamInfoBaseDst)) {
            rc = 1;
         }

      } while ( (rc == 0) && StreamInfoBaseSrc );
   }

   return rc;
}

//
//  Beta 2 API
//





DWORD
AddUsersToFileSrv(
    IN PEFS_USER_INFO pEfsUserInfo,
    IN LPCTSTR lpFileName,
    IN DWORD nUsers,
    IN PENCRYPTION_CERTIFICATE * pEncryptionCertificates
    )

/*++

Routine Description:

    This routine will add an entry in the DDF field of the passed file
    for each certificate passed.

    The file will not be modified at all if any errors occur
    during processing.

Arguments:

    lpFileName - Supplies the name of the file to be encrypted.  File may
        be local or remote.  It will be opened for exclusive access.

    dwCertificates - Supplies the number of certificate structures in the
        pEncryptionCertificates array.

    pEncryptionCertificates - Supplies an array of pointers to certificate
        structures, one for each user to be added to the file.


Return Value:

    This routine will fail under the following circumstances:

    Passed file is not encrypted.

    Passed file cannot be opened for exclusive access.

    Caller does not have keys to decrypt the file.

    A passed certificate was not structurally valid.  In this case,
    the entire operation will fail.

    And all the other reasons why an EFS operation can fail
    (EFS not present, no recovery policy, etc)

--*/
{
    BOOL b = FALSE;
    DWORD rc = ERROR_SUCCESS;

    //
    // Open the passed file and get the EFS stream
    //

    //
    // Open for READ_ATTRIBUTES so we don't go through all the noise of
    // decrypting the FEK when we don't really care to (we're going to have to
    // do that here anyway).  We could open the file just to be sure the decrypt
    // is going to work, but there's no point in speeding up the failure case.
    //

    PEFS_DATA_STREAM_HEADER pEfsStream = NULL;

    HANDLE hFile;

    DWORD                FileAttributes;
    DWORD                Flags = 0;

    FileAttributes = GetFileAttributes( lpFileName );
    if (FileAttributes == -1) {
       return GetLastError();
    }
    if (FileAttributes & FILE_ATTRIBUTE_DIRECTORY) {
       Flags = FILE_FLAG_BACKUP_SEMANTICS;
    }
    hFile =  CreateFile(
                    lpFileName,
                    FILE_READ_ATTRIBUTES | FILE_WRITE_DATA,
                    0,
                    NULL,
                    OPEN_EXISTING,
                    Flags,
                    NULL
                    );

    if (hFile != INVALID_HANDLE_VALUE) {

        //
        // Get the EFS stream
        //

        NTSTATUS Status;

        Status = GetFileEfsStream(
                     hFile,
                     &pEfsStream
                     );

        if (NT_SUCCESS( Status )) {

            //
            // Decrypt the FEK, if possible
            //

            PEFS_KEY Fek;
            PEFS_DATA_STREAM_HEADER UpdatedEfs = NULL;

            rc = DecryptFek( pEfsUserInfo, pEfsStream, &Fek, &UpdatedEfs, 0 );

            if (rc == ERROR_SUCCESS) {

                if (UpdatedEfs != NULL) {

                    //
                    // Something changed since the last time this file was
                    // opened.
                    //

                    LsapFreeLsaHeap( pEfsStream );
                    pEfsStream = UpdatedEfs;
                    UpdatedEfs = NULL;
                }

                //
                // For each certificate passed to us,
                // add it to the EFS stream.
                //

                for (DWORD i=0; i<nUsers ; i++) {

                    PENCRYPTION_CERTIFICATE pEncryptionCert;
                    BOOLEAN bRet;

                    __try{

                        pEncryptionCert= pEncryptionCertificates[i];
                        bRet = AddUserToEFS(
                            pEfsStream,
                            pEncryptionCert->pUserSid,
                            Fek,
                            pEncryptionCert->pCertBlob->pbData,
                            pEncryptionCert->pCertBlob->cbData,
                            &UpdatedEfs
                            );
                    } __except (EXCEPTION_EXECUTE_HANDLER) {

                        bRet = FALSE;
                        SetLastError( ERROR_INVALID_PARAMETER );
                        EfspLogAttack(pEfsUserInfo, CORRUPT_DATA_2);

                    }


                    if (bRet) {

                        //
                        // Toss the old EFS stream and pick up the new one.
                        //

                        if (UpdatedEfs) {
                           b = TRUE;
                           LsapFreeLsaHeap( pEfsStream );
                           pEfsStream = UpdatedEfs;
                           UpdatedEfs = NULL;
                        }

                    } else {

                        b = FALSE;
                        rc = GetLastError();
                        break;

                    }
                }

                //
                // If we got out with everything working,
                // set the new EFS stream on the file.  Otherwise,
                // clean up and fail the entire operation.
                //

                if (b) {

                    //
                    // Set the new EFS stream on the file.
                    //

                    if (!EfspSetEfsOnFile( hFile, pEfsStream, NULL )) {
                        rc = GetLastError();
                    }
                }
            }

            LsapFreeLsaHeap( pEfsStream );

        } else {

            rc = RtlNtStatusToDosError( Status );
        }

        CloseHandle( hFile );

    } else {

        rc = GetLastError();
    }

    return( rc );
}


BOOL
EfspSetEfsOnFile(
    IN HANDLE hFile,
    PEFS_DATA_STREAM_HEADER pEfsStream,
    IN PEFS_KEY pNewFek OPTIONAL
    )
/*++

Routine Description:

    The routine sets the passed EFS stream onto the passed file.  The
    file must be open for WRITE_DATA access.

Arguments:

    hFile - Supplies a handle to the file being modified.

    pEfsStream - Supplies the new EFS stream to be placed on the file.

Return Value:

    TRUE on success, FALSE on failure.  Call GetLastError() for more details.

--*/

{
    BOOL b = FALSE;

    DWORD OutputDataLength = 0;
    DWORD EfsDataLength = 0;
    PBYTE OutputData = NULL;

    if (ARGUMENT_PRESENT( pNewFek )) {

        OutputDataLength = 3 * sizeof(ULONG) + 2 * EFS_KEY_SIZE( pNewFek ) + pEfsStream->Length;

        EfsDataLength = OutputDataLength - 3 * sizeof(ULONG);

        SafeAllocaAllocate(OutputData, OutputDataLength);

        if (OutputData) {

            b = SendEfs(
                    pNewFek,
                    pEfsStream,
                    (PBYTE) OutputData + 3 * sizeof(ULONG),
                    &EfsDataLength
                    );
        }

    } else {

        //
        // Not changing the FEK on the file.
        //

        OutputDataLength = COMMON_FSCTL_HEADER_SIZE + pEfsStream->Length;

        EfsDataLength = OutputDataLength - 3 * sizeof(ULONG);

        SafeAllocaAllocate(OutputData, OutputDataLength);

        if (OutputData) {

            b = SendHandleAndEfs(
                       hFile,
                       pEfsStream,
                       (PBYTE) OutputData + 3 * sizeof(ULONG),
                       &EfsDataLength
                       );
        }
    }

    if (b) {

        DWORD Attributes = WRITE_EFS_ATTRIBUTE;

        if (ARGUMENT_PRESENT( pNewFek )) {
            Attributes |= SET_EFS_KEYBLOB;
        }

        b = EncryptFSCTLData(
                   EFS_OVERWRITE_ATTRIBUTE,
                   EFS_ENCRYPT_STREAM,
                   Attributes,
                   (PBYTE) OutputData + 3 * sizeof(ULONG),
                   EfsDataLength,
                   (PBYTE) OutputData,
                   &OutputDataLength
                   );

        //
        // As currently implemented, this routine cannot fail.
        //

        ASSERT(b);

        NTSTATUS NtStatus;
        IO_STATUS_BLOCK IoStatusBlock;

        DWORD FsControl;

        if (ARGUMENT_PRESENT( pNewFek )) {
            FsControl = FSCTL_SET_ENCRYPTION;
        } else {
            FsControl = FSCTL_ENCRYPTION_FSCTL_IO;
        }

        NtStatus = NtFsControlFile(
                    hFile,
                    0,
                    NULL,
                    NULL,
                    &IoStatusBlock,
                    FsControl,
                    OutputData,
                    OutputDataLength,
                    NULL,
                    NULL
                    );

        if ( NT_SUCCESS( NtStatus )){

            b = TRUE;

        } else {

            b = FALSE;

            SetLastError( RtlNtStatusToDosError( NtStatus ) );
        }
    }

    SafeAllocaFree( OutputData );

    return( b );
}


DWORD
QueryUsersOnFileSrv(
    IN  LPCTSTR lpFileName,
    OUT PDWORD pnUsers,
    OUT PENCRYPTION_CERTIFICATE_HASH ** pUsers
    )
/*++

Routine Description:

    This routine will return a buffer containing the certificate hashes
    and SIDs for the users who can decrypt the specified file.

    Note that the current user does not need to be able to decrypt the
    file.

Arguments:

    lpFileName - Supplies the file to be examined.  This file will be opened
        for exclusive access.  The caller must have READ_ATTRIBUTES access to
        the file.

    pnUsers - Returns the number of entries in the pHashes array.  This field will be
        set even if pHashes is NULL.

    pHashes - Supplies a buffer to be filled with an array of ENCRYPTION_CERTIFICATE_HASH
        structures, one for each user listed in the DDF of the file.  This parameter may
        be NULL if the caller is trying to determine the required size.


Return Value:

    This routine will fail if:

    The passed file is not encrypted.

    The passed buffer is non-NULL but not large enough.

    The current user does not have READ_ATTRIBUTES access to the file.

--*/

{
    //
    // Open the file
    //

    BOOL b = FALSE;
    HANDLE hFile;
    PEFS_DATA_STREAM_HEADER pEfsStream;
    DWORD rc = ERROR_SUCCESS;

    DWORD                FileAttributes;
    DWORD                Flags = 0;

    *pnUsers = NULL;
    *pUsers = NULL;


    FileAttributes = GetFileAttributes( lpFileName );
    if (FileAttributes == -1) {
       return GetLastError();
    }
    if (FileAttributes & FILE_ATTRIBUTE_DIRECTORY) {
       Flags = FILE_FLAG_BACKUP_SEMANTICS;
    }
    hFile =  CreateFile(
                    lpFileName,
                    FILE_READ_ATTRIBUTES,
                    0,
                    NULL,
                    OPEN_EXISTING,
                    Flags,
                    NULL
                    );

    if (hFile != INVALID_HANDLE_VALUE) {

        //
        // Get the EFS stream
        //

        NTSTATUS Status;

        Status = GetFileEfsStream(
                     hFile,
                     &pEfsStream
                     );

        if (NT_SUCCESS( Status )) {

            PENCRYPTED_KEYS pDDF = (PENCRYPTED_KEYS)OFFSET_TO_POINTER( DataDecryptionField, pEfsStream );

            __try {

                //
                // We may have gotten corrupted bits off the disk.  We can't
                // verify the checksum on the EfsStream, because we don't have the
                // FEK (and we don't want to require the caller to have to decrypt
                // the file to get this information).  So wrap this call in a
                // try-except so we don't risk blowing up.
                //

                b = QueryCertsFromEncryptedKeys(
                        pDDF,
                        pnUsers,
                        pUsers
                        );

                if (!b) {
                    rc = GetLastError();
                }

            } __except (EXCEPTION_EXECUTE_HANDLER) {

                b = FALSE;

                rc = GetExceptionCode();

                if (ERROR_NOACCESS == rc) {
                    rc = ERROR_FILE_CORRUPT;
                }
            }

            LsapFreeLsaHeap( pEfsStream );

        } else {

            rc = RtlNtStatusToDosError( Status );
        }

        CloseHandle( hFile );

    } else {

        rc = GetLastError();
    }

    if (rc != ERROR_SUCCESS) {
        DebugLog((DEB_WARN, "QueryUsersOnFileSrv returning %x\n" ,rc  ));
    }

    return( rc );
}


DWORD
QueryRecoveryAgentsSrv(
    IN LPCTSTR lpFileName,
    OUT PDWORD pnRecoveryAgents,
    OUT PENCRYPTION_CERTIFICATE_HASH ** pRecoveryAgents
    )
/*++

Routine Description:

    This routine will return a buffer containing the certificate hashes
    for the recovery agents on the passed file.

    Note that the current user does not need to be able to decrypt the
    file.

    [ Should we combine this routine with the one above, and just take a
    flag?  Or should there be one routine that returns everything, perhaps
    with a mark for each user that is in the DRF?  There are several ways
    to do this. ]

Arguments:

    lpFileName - Supplies the file to be examined.  This file will be opened
        for exclusive access.  The caller must have READ_ATTRIBUTES access to
        the file.

    pcbBuffer - Supplies/returns the size of the buffer passed in the in pHashes
        parameter.  If pHashes is NULL, the function will succeed and the required
        size will be returned.

    pHashes - Supplies a buffer to be filled with an array of ENCRYPTION_CERTIFICATE_HASH
        structures, one for each user listed in the DRF of the file.  This parameter may
        be NULL if the caller is trying to determine the required size.


Return Value:

    This routine will fail if:

    The passed file is not encrypted.

    The passed buffer is non-NULL but not large enough.

    The current user does not have READ_ATTRIBUTES access to the file.

--*/

{
    //
    // Open the file
    //

    BOOL b = FALSE;
    HANDLE hFile;
    PEFS_DATA_STREAM_HEADER pEfsStream;
    DWORD rc = ERROR_SUCCESS;

    DWORD                FileAttributes;
    DWORD                Flags = 0;

    *pnRecoveryAgents = 0;
    *pRecoveryAgents = NULL;

    FileAttributes = GetFileAttributes( lpFileName );
    if (FileAttributes == -1) {
       return GetLastError();
    }
    if (FileAttributes & FILE_ATTRIBUTE_DIRECTORY) {
       Flags = FILE_FLAG_BACKUP_SEMANTICS;
    }
    hFile =  CreateFile(
                    lpFileName,
                    FILE_READ_ATTRIBUTES,
                    0,
                    NULL,
                    OPEN_EXISTING,
                    Flags,
                    NULL
                    );

    if (hFile != INVALID_HANDLE_VALUE) {

        //
        // Get the EFS stream
        //

        NTSTATUS Status;

        Status = GetFileEfsStream(
                     hFile,
                     &pEfsStream
                     );

        if (NT_SUCCESS( Status )) {

            PENCRYPTED_KEYS pDRF = (PENCRYPTED_KEYS)OFFSET_TO_POINTER( DataRecoveryField, pEfsStream );

            if ( (PVOID)pDRF != (PVOID)pEfsStream) {

                __try {
    
                    b = QueryCertsFromEncryptedKeys(
                            pDRF,
                            pnRecoveryAgents,
                            pRecoveryAgents
                            );
    
                    if (!b) {
                        rc = GetLastError();
                    }
    
                } __except (EXCEPTION_EXECUTE_HANDLER) {
    
                    b = FALSE;
    
                    rc = GetExceptionCode();
    
                    if (ERROR_NOACCESS == rc) {
                        rc = ERROR_FILE_CORRUPT;
                    }
                }

            }


            LsapFreeLsaHeap( pEfsStream );

        } else {

            rc = RtlNtStatusToDosError( Status );
        }

        CloseHandle( hFile );

    } else {

        rc = GetLastError();
    }

    if (rc != ERROR_SUCCESS) {
        DebugLog((DEB_WARN, "QueryRecoveryAgentsSrv returning %x\n" ,rc  ));
    }

    return( rc );
}


DWORD
RemoveUsersFromFileSrv(
    IN PEFS_USER_INFO pEfsUserInfo,
    IN LPCTSTR lpFileName,
    IN DWORD nUsers,
    IN PENCRYPTION_CERTIFICATE_HASH * pHashes
    )

/*++

Routine Description:

    This routine will remove the passed users from the list
    of people who can decrypt the passed file.

    The file will not be modified at all if any errors occur
    during processing.

Arguments:

    lpFileName - Supplies a pointer to the file to be edited.  This file
        will be opened for exclusive access.

    nHashes - Supplies the number of hashes in the pHashes array.

    pHashes - Supplies an array of pointers to hash structures for subjects to be
        removed from the file.


Return Value:

    This function will fail if:

    The passed file is not encrypted.

    The user does not have sufficient access to the file.

--*/
{
    PEFS_DATA_STREAM_HEADER UpdatedEfs = NULL;
    HANDLE hFile;
    PEFS_DATA_STREAM_HEADER pEfsStream = NULL;
    DWORD rc                           = ERROR_SUCCESS;
    PEFS_KEY Fek                       = NULL;

    DWORD                FileAttributes;
    DWORD                Flags = 0;

    FileAttributes = GetFileAttributes( lpFileName );
    if (FileAttributes == -1) {
       return GetLastError();
    }
    if (FileAttributes & FILE_ATTRIBUTE_DIRECTORY) {
       Flags = FILE_FLAG_BACKUP_SEMANTICS;
    }
    hFile =  CreateFile(
                lpFileName,
                FILE_READ_ATTRIBUTES| FILE_WRITE_DATA,
                0,
                NULL,
                OPEN_EXISTING,
                Flags,
                NULL
                );

    if (hFile != INVALID_HANDLE_VALUE) {

        //
        // Get the EFS stream
        //

        NTSTATUS Status;

        Status = GetFileEfsStream(
                     hFile,
                     &pEfsStream
                     );

        if (NT_SUCCESS( Status )) {

            rc = DecryptFek( pEfsUserInfo, pEfsStream, &Fek, &UpdatedEfs, 0 );

            if (ERROR_SUCCESS == rc) {

                //
                // If we got an EFS stream back, toss the
                // one from the file and use it.
                //

                if ( UpdatedEfs != NULL ) {
                    LsapFreeLsaHeap( pEfsStream );
                    pEfsStream = UpdatedEfs;
                    UpdatedEfs = NULL;
                }

                if (RemoveUsersFromEfsStream(
                        pEfsStream,
                        nUsers,
                        pHashes,
                        Fek,
                        &UpdatedEfs
                        )) {

                    //
                    // If we got an EFS stream back, toss the old EFS
                    // stream and pick up the new one.  We'll only get
                    // an EFS stream back if we found someone to remove.
                    //

                    if (UpdatedEfs != NULL) {

                        LsapFreeLsaHeap( pEfsStream );
                        pEfsStream = UpdatedEfs;
                        UpdatedEfs = NULL;

                        if (!EfspSetEfsOnFile( hFile, pEfsStream, NULL )) {
                            rc = GetLastError();
                        }
                    }

                } else {

                    rc = GetLastError();
                }

                if (UpdatedEfs != NULL) {
                    LsapFreeLsaHeap( UpdatedEfs );
                }

                LsapFreeLsaHeap( Fek );
            }

            LsapFreeLsaHeap( pEfsStream );

        } else {

            rc = RtlNtStatusToDosError( Status );
        }

        CloseHandle( hFile );

    } else {

        rc = GetLastError();
    }

    return( rc );
}


DWORD
SetFileEncryptionKeySrv(
    IN PEFS_USER_INFO pEfsUserInfo,
    IN PENCRYPTION_CERTIFICATE pEncryptionCertificate
    )
{
    DWORD rc = ERROR_SUCCESS;
    PBYTE      pbHash = NULL;
    DWORD      cbHash;


    //
    // Get the current cert hash
    //

    (void) GetCurrentHash(
            pEfsUserInfo,
            &pbHash,
            &cbHash
            );

    //
    // If no certificate was passed, call the code to create
    // a new user key from scratch.
    //

    if (!ARGUMENT_PRESENT( pEncryptionCertificate )) {

        //
        // Create a new key
        //

        rc = EfspReplaceUserKeyInformation( pEfsUserInfo );

    } else {

        __try{

            if ( pEncryptionCertificate->pCertBlob ){
                rc = EfspInstallCertAsUserKey( pEfsUserInfo, pEncryptionCertificate );
            } else {
                rc = ERROR_INVALID_PARAMETER;
            }

        } __except (EXCEPTION_EXECUTE_HANDLER) {

            rc = ERROR_INVALID_PARAMETER;

        }

    }

    if ( (ERROR_SUCCESS == rc) && pbHash) {

        //
        // Operation succeeded and there was a current key. Make our best effort
        // to mark the old cert as archived.
        //

        PCCERT_CONTEXT pCertContext;

        pCertContext = GetCertContextFromCertHash(
                            pbHash,
                            cbHash,
                            CERT_STORE_DEFER_CLOSE_UNTIL_LAST_FREE_FLAG | CERT_SYSTEM_STORE_CURRENT_USER,
                            0
                            );

        if (pCertContext != NULL) {

            CRYPT_DATA_BLOB dataBlob = {0, NULL};

            //
            // This is best effort. We do not need to check the return code.
            //

            (void) CertSetCertificateContextProperty(
                        pCertContext,
                        CERT_ARCHIVED_PROP_ID,
                        0,
                        &dataBlob
                        );


            CertFreeCertificateContext( pCertContext );

        }
    }

    if (pbHash) {
        LsapFreeLsaHeap(pbHash);
    }



    return( rc );
}

DWORD
DuplicateEncryptionInfoFileSrv (
    PEFS_USER_INFO pEfsUserInfo,
    LPCWSTR lpSrcFileName,
    LPCWSTR lpDestFileName,
    LPCWSTR lpDestUncName,
    DWORD   dwCreationDistribution,
    DWORD   dwAttributes,
    PEFS_RPC_BLOB pRelativeSD,
    BOOL    bInheritHandle
    )
/*++

Routine Description:

    This routine will transfer the EFS information from the source file
    to the target file.  It assumes

    The caller has FILE_READ_ATTRIBUTES access to the source file

    The caller has WRITE_ATTRIBUTE and WRITE_DATA access to the target.  If the target
    is encrypted, the caller must be able to decrypt it.

Arguments:

    pEfsUserInfo - Supplies the user info structure for the current caller.

    lpSrcFileName - Supplies a pointer to the name of the source file.

    lpDestFileName - Supplies a pointer to the name of the destination file.

    dwCreationDistribution - CreationDistribution used in CreateFile.

    dwAttributes - File attributes used in CreateFile.

    pRelativeSD - Relative Security Descriptor.

    BOOL - bInheritHandle.

Return Value:

    Win32 error.

--*/

{
    //
    // Get the encryption information off of the src file.
    //

    HANDLE hSrcFile;
    HANDLE hDestFile;
    DWORD rc = ERROR_SUCCESS;
    BOOLEAN fResult = FALSE;
    PEFS_KEY Fek;

    DWORD                FileAttributes;
    DWORD                FileAttributesDst;
    DWORD                FlagsSrc = 0;
    DWORD                creationDistribution = 0;

    FileAttributes = GetFileAttributes( lpSrcFileName );
    if (FileAttributes == -1) {
       return GetLastError();
    }
    if (FileAttributes & FILE_ATTRIBUTE_DIRECTORY) {
       FlagsSrc = FILE_FLAG_BACKUP_SEMANTICS;
    }

    //
    // Try to open the file.
    //

    hSrcFile =  CreateFile(
                    lpSrcFileName,
                    FILE_READ_ATTRIBUTES,
                    FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE,
                    NULL,
                    OPEN_EXISTING,
                    FlagsSrc,
                    NULL
                    );

    if (hSrcFile != INVALID_HANDLE_VALUE) {

        NTSTATUS Status;
        PEFS_DATA_STREAM_HEADER pEfsStream;

        Status = GetFileEfsStream(
                     hSrcFile,
                     &pEfsStream
                     );

        if (NT_SUCCESS( Status )) {

            PEFS_DATA_STREAM_HEADER NewEfs = NULL;
            GUID NewId;

            //
            // We need to change the file ID here. DecryptFek will recalculate
            // the checksum for us.
            //

            RPC_STATUS RpcStatus = UuidCreate ( &NewId );

            if (RpcStatus == ERROR_SUCCESS || RpcStatus == RPC_S_UUID_LOCAL_ONLY) {
                RtlCopyMemory( &(pEfsStream->EfsId), &NewId, sizeof( GUID ) );
            }

            rc = DecryptFek(
                     pEfsUserInfo,
                     pEfsStream,
                     &Fek,
                     &NewEfs,
                     0
                     );

            if (rc == ERROR_SUCCESS) {

                //
                // Got the $EFS, now prepares to create destination
                //

                FileAttributesDst =  GetFileAttributes( lpDestFileName );
                if (FileAttributesDst == -1) {

                    rc = GetLastError();

                    FileAttributesDst = 0;

                    if ((ERROR_FILE_NOT_FOUND == rc) || (ERROR_PATH_NOT_FOUND == rc)) {
                        rc = ERROR_SUCCESS;
                        if (FileAttributes & FILE_ATTRIBUTE_DIRECTORY) {
                            creationDistribution = FILE_CREATE;

                            //
                            // Force the new destination to be a directory
                            //

                            dwAttributes |= FILE_ATTRIBUTE_DIRECTORY;
                        }
                    }

                } else {

                    //
                    // File exist. Check if Dir to Dir or File to File
                    //

                    if (dwCreationDistribution == CREATE_NEW) {

                        //
                        // The file is already existed. CREATE_NEW will fail.
                        //

                        rc = ERROR_FILE_EXISTS;

                    } else if (FileAttributes & FILE_ATTRIBUTE_DIRECTORY){

                        if (!(FileAttributesDst & FILE_ATTRIBUTE_DIRECTORY)) {

                            rc =  ERROR_DS_SRC_AND_DST_OBJECT_CLASS_MISMATCH;

                        } else {

                            if (FileAttributesDst & FILE_ATTRIBUTE_ENCRYPTED) {
                                creationDistribution = FILE_OPEN;
                            }

                        }
                    } else {

                        if (FileAttributesDst & FILE_ATTRIBUTE_DIRECTORY) {

                          rc =  ERROR_DS_SRC_AND_DST_OBJECT_CLASS_MISMATCH;

                        }

                    }

                }


                //
                // Now we can Create/open the destination.
                // We have not validate the share access yet. We will use the UNC name
                // to validate if it is a network session.
                //

                OBJECT_ATTRIBUTES        Obja;
                UNICODE_STRING           DstNtName;
                LPWSTR                   DstFileName = NULL;
                LPWSTR                   LongFileName = NULL;
                DWORD                    FileNameLength;
                BOOL                     b = TRUE;
                ULONG                    CreateOptions = 0;
                IO_STATUS_BLOCK          IoStatusBlock;

                RtlInitUnicodeString(
                    &DstNtName,
                    NULL
                    );

                if (rc == ERROR_SUCCESS) {

                    if (lpDestUncName) {


                        if ( (FileNameLength = wcslen(lpDestUncName)) >= MAX_PATH ) {

                            //
                            // We need \\?\UNC\server\share\dir\file format to open the file.
                            //

                            DstFileName = LongFileName = (LPWSTR)LsapAllocateLsaHeap( (FileNameLength + 8) * sizeof (WCHAR) );
                            if (!LongFileName) {
                                rc = ERROR_NOT_ENOUGH_MEMORY;
                            } else {

                                wcscpy(LongFileName, L"\\\\?\\UNC");
                                wcscat(LongFileName, &lpDestUncName[1]);

                            }

                        } else {

                            DstFileName = (LPWSTR) lpDestUncName;

                        }

                    } else {

                       DstFileName = (LPWSTR) lpDestFileName;

                    }

                }


                if ( rc != ERROR_SUCCESS ) {

                    if (NewEfs) {
                        LsapFreeLsaHeap( NewEfs );
                    }
                    LsapFreeLsaHeap( Fek );
                    LsapFreeLsaHeap( pEfsStream );
                    CloseHandle( hSrcFile );
                    return rc;

                }

                b =  RtlDosPathNameToNtPathName_U(
                                    DstFileName,
                                    &DstNtName,
                                    NULL,
                                    NULL
                                    );

                if ( b ){

                    if (!creationDistribution) {
                        creationDistribution = (dwCreationDistribution == CREATE_NEW) ? FILE_CREATE : FILE_OVERWRITE_IF;
                    }

                    if (FileAttributes & FILE_ATTRIBUTE_DIRECTORY) {
                        CreateOptions = FILE_DIRECTORY_FILE;
                    } else {

                        //
                        // NTFS does not support FILE_NO_COPRESSION for the dir.
                        //

                        CreateOptions |= FILE_NO_COMPRESSION;
                    }


                    //
                    // Encryption bit is not needed. We will encrypt it any way.
                    //

                    dwAttributes &= ~(FILE_ATTRIBUTE_ENCRYPTED | FILE_ATTRIBUTE_READONLY);

                    InitializeObjectAttributes(
                                &Obja,
                                &DstNtName,
                                bInheritHandle ? OBJ_INHERIT | OBJ_CASE_INSENSITIVE : OBJ_CASE_INSENSITIVE,
                                0,
                                pRelativeSD? pRelativeSD->pbData:NULL
                                );

                    Status = NtCreateFile(
                                    &hDestFile,
                                    FILE_READ_DATA | FILE_WRITE_DATA | FILE_WRITE_ATTRIBUTES | FILE_READ_ATTRIBUTES | SYNCHRONIZE,
                                    &Obja,
                                    &IoStatusBlock,
                                    NULL,
                                    dwAttributes,
                                    0,
                                    creationDistribution,
                                    CreateOptions | FILE_SYNCHRONOUS_IO_NONALERT,
                                    NULL,
                                    0
                                    );

                    if ( NT_SUCCESS(Status) && lpDestUncName ) {

                        //
                        // If this is a net session, we need to close the loopback handle.
                        // This handle is not good to send large FSCTL request.
                        // In this case, the file should already exist or overwritten.
                        // No parameters for create new file are needed, such as SD.
                        //

                        RtlFreeHeap(
                            RtlProcessHeap(),
                            0,
                            DstNtName.Buffer
                            );

                        RtlInitUnicodeString(
                            &DstNtName,
                            NULL
                            );

                        CloseHandle( hDestFile );

                        Status = STATUS_NO_SUCH_FILE;

                        b =  RtlDosPathNameToNtPathName_U(
                                            lpDestFileName,
                                            &DstNtName,
                                            NULL,
                                            NULL
                                            );

                        if ( b ){

                            InitializeObjectAttributes(
                                        &Obja,
                                        &DstNtName,
                                        bInheritHandle ? OBJ_INHERIT | OBJ_CASE_INSENSITIVE : OBJ_CASE_INSENSITIVE,
                                        0,
                                        NULL
                                        );

                            Status = NtCreateFile(
                                            &hDestFile,
                                            FILE_READ_DATA | FILE_WRITE_DATA | FILE_WRITE_ATTRIBUTES | FILE_READ_ATTRIBUTES | SYNCHRONIZE,
                                            &Obja,
                                            &IoStatusBlock,
                                            NULL,
                                            dwAttributes,
                                            0,
                                            FILE_OPEN,
                                            CreateOptions | FILE_SYNCHRONOUS_IO_NONALERT,
                                            NULL,
                                            0
                                            );
                        }

                    }

                    if (NT_SUCCESS(Status)) {

                        //
                        // Work around for FILE_NO_COMPRESSION
                        //

                        if ((FileAttributesDst & FILE_ATTRIBUTE_COMPRESSED) || ((dwCreationDistribution == CREATE_NEW) && (FileAttributes & FILE_ATTRIBUTE_DIRECTORY))) {

                            //
                            // Let's decompressed the dir
                            //

                            USHORT State = COMPRESSION_FORMAT_NONE;
                            ULONG Length;

                            //
                            // Attempt to uncompress the directory. Best effort. If it fails, we still continue.
                            //

                            b = DeviceIoControl(
                                                hDestFile,
                                                FSCTL_SET_COMPRESSION,
                                                &State,
                                                sizeof(USHORT),
                                                NULL,
                                                0,
                                                &Length,
                                                FALSE
                                                );

                        }

                        if (!EfspSetEfsOnFile( hDestFile, NewEfs? NewEfs : pEfsStream, Fek )) {

                            rc = GetLastError();
                            if ( ERROR_INVALID_FUNCTION == rc ) {

                                //
                                // lpDestFileName is a local path. Change it to be a volume name.
                                //

                                DWORD FileSystemFlags;
                                WCHAR RootDirName[4];

                                wcsncpy(RootDirName, lpDestFileName, 3);
                                RootDirName[3] = 0;
                                if(GetVolumeInformation(
                                    RootDirName,
                                    NULL, // Volume name.
                                    0, // Volume name length.
                                    NULL, // Serial number.
                                    NULL, // Maximum length.
                                    &FileSystemFlags,
                                    NULL, // File system type.
                                    0
                                    )){

                                    if (!(FileSystemFlags & FILE_SUPPORTS_ENCRYPTION)) {

                                        //
                                        //  Let's map the error.
                                        //

                                        rc = ERROR_VOLUME_NOT_SUPPORT_EFS;
                                        if (dwCreationDistribution == CREATE_NEW) {
                                            CloseHandle( hDestFile );
                                            hDestFile = 0;
                                            DeleteFileW(lpDestFileName);
                                        }


                                    }

                                }

                            }
                        }

                        if (hDestFile) {
                            CloseHandle( hDestFile );
                        }

                    } else {

                        rc = RtlNtStatusToDosError( Status );

                    }
                } else {

                    rc = GetLastError();

                }

                if (DstNtName.Buffer) {
                    RtlFreeHeap(
                        RtlProcessHeap(),
                        0,
                        DstNtName.Buffer
                        );
                }

                if (LongFileName) {
                    LsapFreeLsaHeap( LongFileName );
                }

                if (NewEfs) {
                    LsapFreeLsaHeap( NewEfs );
                }
                LsapFreeLsaHeap( Fek );
            }

            LsapFreeLsaHeap( pEfsStream );

        } else {

            rc = RtlNtStatusToDosError( Status );
        }

        CloseHandle( hSrcFile );

    } else {

        rc = GetLastError();
    }

    return( rc );
}

VOID
EfsLogEntry (
    WORD    wType,
    WORD    wCategory,
    DWORD   dwEventID,
    WORD    wNumStrings,
    DWORD   dwDataSize,
    LPCTSTR *lpStrings,
    LPVOID  lpRawData
    )
/*++
Routine Description:

    This routine wraps the call to ReportEvent.
Arguments:

    See info for ReportEvent.

Return Value:

    None.
--*/
{

    HANDLE EventHandleLog;

    NTSTATUS        Status;
    HANDLE          hToken = NULL;

    Status = NtOpenThreadToken(
                 NtCurrentThread(),
                 TOKEN_IMPERSONATE,
                 TRUE,                    // OpenAsSelf
                 &hToken
                 );

    if (NT_SUCCESS( Status )) {

        //
        // If RevertToSelf fails, we still need to try log the event
        //

        (void)RevertToSelf();

    }

    EventHandleLog = RegisterEventSource(
                             NULL,
                             EFSSOURCE
                             );

    if ( EventHandleLog ){

       ReportEvent(
           EventHandleLog,
           wType,
           wCategory,
           dwEventID,
           NULL,
           wNumStrings,
           dwDataSize,
           lpStrings,
           lpRawData
           );
       DeregisterEventSource( EventHandleLog );
    }

    if (NT_SUCCESS( Status )) {

        Status = NtSetInformationThread(
                    NtCurrentThread(),
                    ThreadImpersonationToken,
                    (PVOID) &hToken,
                    sizeof(HANDLE)
                    );

        //
        //  What can we do if we could not impersonate back?
        //

        if (!NT_SUCCESS( Status )) {
            ASSERT(FALSE);
        }
    }
}

VOID
EfspLogAttack(
    PEFS_USER_INFO pEfsUserInfo,
    DWORD attackID
    )
{
    BOOLEAN  SafeMemAllocated = FALSE;
    LPCWSTR  lpArray[2];

    if (NULL == pEfsUserInfo) {

        SafeAllocaAllocate(pEfsUserInfo, sizeof(EFS_USER_INFO));
        if (pEfsUserInfo) {
            SafeMemAllocated = TRUE;
            if (!EfspGetUserInfo( pEfsUserInfo )){
                SafeAllocaFree( pEfsUserInfo );
                SafeMemAllocated = FALSE;
                pEfsUserInfo = NULL;

            }
        }
    }

    if (pEfsUserInfo){

        lpArray[0] = pEfsUserInfo->lpDomainName;
        lpArray[1] = pEfsUserInfo->lpUserName;
        EfsLogEntry(
          EVENTLOG_ERROR_TYPE,
          0,
          EFS_UNDER_ATTACK,
          2,
          sizeof (DWORD),
          (LPCWSTR *)&lpArray[0],
          &attackID
          );

        if (SafeMemAllocated) {
            EfspFreeUserInfo( pEfsUserInfo );
            SafeAllocaFree( pEfsUserInfo );
        }
    }
}

DWORD
EfsUpdateFiles(
    LPCWSTR DirPath,
    LPWSTR  *Description,
    DWORD   *InfoCount
    )
{
    DWORD rc = ERROR_SUCCESS;

    PTCHAR DirectorySpecEnd;
    HANDLE FindHandle;
    WIN32_FIND_DATA FindData;
    HANDLE hFile;
    LPWSTR FilePath;
    DWORD  PathLen;


    //
    //  So that we can keep on appending names to the directory spec
    //  get a pointer to the end of its string
    //


    PathLen = wcslen( DirPath );
    if (PathLen >= (EFS_MAX_FILE_PATH / sizeof(WCHAR)) - 7) {

        //
        //  We will skip the file path longer than EFS_MAX_FILE_PATH / sizeof(WCHAR))
        //  It is very unlikely we will hit this, which means path has more than 4k chars.
        //  7 is for \\?\ and \*0
        //

        //
        // File path too long
        //

        if (*Description == NULL) {

            *Description = (LPWSTR)LsapAllocateLsaHeap( INFO_BUFFER_SIZE );

            //
            // LsapAllocateLsaHeap should have set 0.
            // For safety, we set the 0 again.
            //
            if (*Description) {
                (*Description)[0] = 0;
            } else {
                return ERROR_NOT_ENOUGH_MEMORY;
            }


        }

        if (*Description && *InfoCount <= (INFO_BUFFER_ITEM_LIMIT-1)) {
            if (wcslen(DirPath)+wcslen(*Description) + 4 < INFO_BUFFER_SIZE/sizeof(WCHAR)) {
                wcscat(*Description, DirPath);
                wcscat(*Description, L"\n");
                (*InfoCount)++;
            }
        }
        return ERROR_SUCCESS;
    }

    //
    // This routine is recursive. Better to avoid big stack allocations. 
    //

    FilePath = (LPWSTR)LsapAllocateLsaHeap( EFS_MAX_FILE_PATH);
    if (!FilePath) {
        return ERROR_NOT_ENOUGH_MEMORY; 
    }

    if (DirPath[0] != L'\\') {

        //
        // Let's add the \\?\ a the begining to bypass the file length limit
        //

        RtlCopyMemory(FilePath, L"\\\\?\\", 4 * sizeof(WCHAR));
        RtlCopyMemory(FilePath + 4 , DirPath, (PathLen+1) * sizeof (WCHAR) );  

    } else {
        RtlCopyMemory( FilePath, DirPath, (PathLen+1) * sizeof (WCHAR) );
    }

    PathLen = wcslen(FilePath);

    if (FilePath[PathLen-1] != L'\\') {
        FilePath[PathLen] = L'\\';
        FilePath[PathLen+1] = 0;
        PathLen++;
    }

    DirectorySpecEnd = FilePath + PathLen;




    //
    //  setup the template for findfirst/findnext
    //

    if (PathLen  < EFS_MAX_FILE_PATH/sizeof(WCHAR) - 2) {

       wcscpy( DirectorySpecEnd, L"*" );

       FindHandle = FindFirstFile( FilePath, &FindData );

       if (INVALID_HANDLE_VALUE != FindHandle) {

           do {

               //
               //  Now skip over the . and .. entries
               //

               if (0 == wcscmp(&FindData.cFileName[0], TEXT(".")) ||
                   0 == wcscmp(&FindData.cFileName[0], TEXT(".."))) {

                   continue;

               } else {

                   //
                   //  Make sure we don't try any paths that are too long for us
                   //  to deal with.
                   //

                   if ((DirectorySpecEnd - FilePath) +
                            wcslen( FindData.cFileName ) >= EFS_MAX_FILE_PATH/sizeof(WCHAR) ) {

                       continue;
                   }

                   if ( !(FindData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) &&
                        (FindData.dwFileAttributes & FILE_ATTRIBUTE_ENCRYPTED)) {

                       //
                       //  append the found file to the directory spec and open
                       //  the file
                       //
    
                       wcscpy( DirectorySpecEnd, FindData.cFileName );
    
                       //
                       //  Now touch the file
                       //


                       hFile = CreateFileW(
                                    FilePath,
                                    GENERIC_READ,
                                    FILE_SHARE_READ | FILE_SHARE_WRITE,
                                    NULL,
                                    OPEN_EXISTING,
                                    0,
                                    NULL
                                    );

                       if ( INVALID_HANDLE_VALUE != hFile ){

                           CloseHandle(hFile);

                       } else {

                           if (*Description == NULL) {

                               *Description = (LPWSTR)LsapAllocateLsaHeap( INFO_BUFFER_SIZE );

                               //
                               // LsapAllocateLsaHeap should have set 0.
                               // For safety, we set the 0 again.
                               //

                               if (*Description) {
                                   (*Description)[0] = 0;
                               } else {

                                   FindClose( FindHandle );
                                   LsapFreeLsaHeap(FilePath);
                                   return ERROR_NOT_ENOUGH_MEMORY;
                               }


                           }

                           if (*Description && *InfoCount <= (INFO_BUFFER_ITEM_LIMIT-1)) {
                               if (wcslen(FilePath)+wcslen(*Description) + 4 < INFO_BUFFER_SIZE/sizeof(WCHAR)) {
                                   wcscat(*Description, FilePath);
                                   wcscat(*Description, L"\n");
                                   (*InfoCount)++;
                               }
                           }

                       }

                       //
                       //  We will just skip the files we couldn't touch.
                       //

                   }

               }

           } while ( FindNextFile( FindHandle, &FindData ));

           FindClose( FindHandle );
       }
    } else {

        //
        // File path too long
        //

        if (*Description == NULL) {

            *Description = (LPWSTR)LsapAllocateLsaHeap( INFO_BUFFER_SIZE );

            //
            // LsapAllocateLsaHeap should have set 0.
            // For safety, we set the 0 again.
            //

            if (*Description) {
                (*Description)[0] = 0;
            } else {
                LsapFreeLsaHeap(FilePath);
                return ERROR_NOT_ENOUGH_MEMORY;
            }


        }

        if (*Description && *InfoCount <= (INFO_BUFFER_ITEM_LIMIT-1)) {
            if (wcslen(FilePath)+wcslen(*Description) + 4 < INFO_BUFFER_SIZE/sizeof(WCHAR)) {
                wcscat(*Description, FilePath);
                wcscat(*Description, L"\n");
                (*InfoCount)++;
            }
        }

    }

    //
    //  Now do the sub directories
    //

    if (PathLen  < EFS_MAX_FILE_PATH/sizeof(WCHAR) - 2) {

       wcscpy( DirectorySpecEnd, L"*" );

       FindHandle = FindFirstFile( FilePath, &FindData );

       if (INVALID_HANDLE_VALUE != FindHandle) {

           do {

               //
               //  Now skip over the . and .. entries otherwise we'll recurse
               //  like mad
               //

               if (0 == lstrcmp(&FindData.cFileName[0], TEXT(".")) ||
                   0 == lstrcmp(&FindData.cFileName[0], TEXT(".."))) {

                   continue;

               } else {

                   //
                   //  If the entry is for a directory then we'll tack on the
                   //  subdirectory name to the directory spec and recursively
                   //  call otherselves
                   //

                   if (FindData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) {

                       //
                       //  Make sure we don't try any paths that are too long for us
                       //  to deal with.
                       //

                       if ((DirectorySpecEnd - FilePath) + 1 +
                                wcslen( FindData.cFileName ) >= EFS_MAX_FILE_PATH/sizeof(WCHAR) ) {
    
                           continue;
                       }

                       wcscpy( DirectorySpecEnd, FindData.cFileName );
                       wcscat( DirectorySpecEnd, TEXT("\\") );

                       rc = EfsUpdateFiles( FilePath, Description, InfoCount);
                   }
               }

           } while ( (ERROR_SUCCESS == rc ) && FindNextFile( FindHandle, &FindData ));

           FindClose( FindHandle );
       }
    }

    LsapFreeLsaHeap(FilePath);

    return rc;
}


DWORD
EfsFileKeyInfoSrv(
    IN  LPCWSTR lpFileName,
    IN  DWORD   InfoClass,
    OUT PDWORD  nbData,
    OUT PBYTE   *pbData
    )
/*++

Routine Description:

    This routine gets the internal info about the encryption used on the file.

Arguments:

    lpFileName - File name.

    nbData - Length of pbData returned.

    pbData - Info returned

Return Value:

    Win32 error.

--*/
{
    PEFS_KEY Fek = NULL;
    HANDLE hFile;
    PEFS_DATA_STREAM_HEADER pEfsStream = NULL;
    NTSTATUS Status;
    DWORD rc = ERROR_SUCCESS;
    DWORD  FileAttributes;
    DWORD  Flags = 0;

    LPWSTR Description;
    DWORD  InfoCount;

    EFS_USER_INFO EfsUserInfo;
    PEFS_KEY_INFO pKeyInfo;

    *nbData = 0;
    *pbData = NULL;

    Description = NULL;
    InfoCount = 0;

    if ((InfoClass != BASIC_KEY_INFO) && (InfoClass != UPDATE_KEY_USED)) {
        return ERROR_INVALID_PARAMETER;
    }
    FileAttributes = GetFileAttributes( lpFileName );
    if (FileAttributes == -1) {
       return GetLastError();
    }

    if (InfoClass == UPDATE_KEY_USED) {
        if (FileAttributes & FILE_ATTRIBUTE_DIRECTORY) {
            if (EfspGetUserInfo( &EfsUserInfo )) {
    
                if (EfspLoadUserProfile( &EfsUserInfo, FALSE )) {
    
                    rc = EfsUpdateFiles(lpFileName, &Description, &InfoCount);
                    if (Description) {

                        InfoCount = (wcslen(Description) + 1) * sizeof(WCHAR);
                        *pbData = (PBYTE) MIDL_user_allocate( InfoCount );
                        if (*pbData) {
                            RtlCopyMemory(*pbData, Description, InfoCount); 
                            *nbData = InfoCount;
                        }

                        LsapFreeLsaHeap(Description);

                    }
    
                    EfspUnloadUserProfile( &EfsUserInfo );
    
                } else {
                    rc = GetLastError();
                }
                EfspFreeUserInfo( &EfsUserInfo );
            } else {
                GetLastError();
            }

            return rc;

        } else {
            return ERROR_INVALID_PARAMETER;
        }
    }

    //
    // InfoClass == BASIC_KEY_INFO
    //

    if ((FileAttributes & FILE_ATTRIBUTE_ENCRYPTED) == 0) {
        return ERROR_FILE_NOT_ENCRYPTED;
    }
    if (FileAttributes & FILE_ATTRIBUTE_DIRECTORY) {
       Flags = FILE_FLAG_BACKUP_SEMANTICS;
    }
    hFile =  CreateFile(
                    lpFileName,
                    FILE_READ_ATTRIBUTES,
                    0,
                    NULL,
                    OPEN_EXISTING,
                    Flags,
                    NULL
                    );
    if (hFile == INVALID_HANDLE_VALUE) {
        return GetLastError();
    }


    Status = GetFileEfsStream(
                 hFile,
                 &pEfsStream
                 );
    CloseHandle(hFile);

    if (NT_SUCCESS( Status )){
        if (EfspGetUserInfo( &EfsUserInfo )) {

            if (EfspLoadUserProfile( &EfsUserInfo, FALSE )) {

                rc = EfsGetFek(
                        &EfsUserInfo,
                        pEfsStream,
                        &Fek
                        );

                if (ERROR_SUCCESS == rc) {
                    pKeyInfo = (PEFS_KEY_INFO) MIDL_user_allocate( sizeof(EFS_KEY_INFO) );
                    if (pKeyInfo) {
                        pKeyInfo->dwVersion = 1;
                        pKeyInfo->Entropy = Fek->Entropy;
                        pKeyInfo->Algorithm = Fek->Algorithm;
                        pKeyInfo->KeyLength = Fek->KeyLength;
                        *pbData = (PBYTE) pKeyInfo;
                        *nbData = sizeof(EFS_KEY_INFO);
                    }
                    LsapFreeLsaHeap( Fek );

                }

                EfspUnloadUserProfile( &EfsUserInfo );

            } else {
                rc = GetLastError();
            }
            EfspFreeUserInfo( &EfsUserInfo );
        } else {
            rc = GetLastError();
        }
    } else {
        rc = RtlNtStatusToDosError( Status );
    }

    LsapFreeLsaHeap( pEfsStream );

    return rc;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\base\lsa\server\debug.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1993.
//
//  File:       debug.h
//
//  Contents:
//
//  Classes:
//
//  Functions:
//
//  History:    9-21-94   RichardW   Created
//
//----------------------------------------------------------------------------

#ifndef __DEBUG_H__
#define __DEBUG_H__

#include <dsysdbg.h>

// The following Debug Flags can be turned on to trace different areas to
// trace while executing.  Feel free to add more levels.

#define DEB_TRACE_VERB      0x00000008  // Verbose tracing (parameter dumps)
#define DEB_TRACE_WAPI      0x00000010  // Trace Worker APIs
#define DEB_TRACE_HELPERS   0x00000020  // Trace SPHelp functions
#define DEB_TRACE_RM        0x00000040  // Trace Reference Monitor stuff
#define DEB_TRACE_INIT      0x00000080  // Trace initialization msgs
#define DEB_TRACE_SCAV      0x00000100  // Trace scavenger operations
#define DEB_TRACE_CRED      0x00000200  // Trace supp. credentials
#define DEB_TRACE_LSA_AU    0x00000400  // Trace LSA AU functions
#define DEB_TRACE_LPC       0x00000800  // Trace LPC stuff
#define DEB_TRACE_NEG       0x00001000  // Trace Negotiate functions
#define DEB_TRACE_SAM       0x00002000  // Trace SAM hooks
#define DEB_TRACE_LSA       0x00004000  // Trace LSA support for DS
#define DEB_TRACE_SPECIAL   0x00008000  // Trace Special stuff
#define DEB_TRACE_QUEUE     0x00010000  // Trace queue and tasks
#define DEB_TRACE_HANDLES   0x00020000  // Trace handle code
#define DEB_TRACE_NEG_LOCKS 0x00040000  // Trace negotiate locks
#define DEB_TRACE_AUDIT     0x00080000  // Trace audit activity
#define DEB_TRACE_EFS       0x00100000  // Trace EFS functions
#define DEB_TRACE_FRAG      0x00200000  // Trace neg fragmentation
#define DEB_LOG_ONLY        0x80000000  // Do not log this to the debugger
#define DEB_BREAK_ON_ERROR  0x40000000  // BreakOnError macro enabled (see below)

// The following flags control when the SPM will raise breakpoints for
// debugging through a remote debugger.  Setting these bits on and enabling
// DEB_BREAK_ON_ERROR will cause a breakpoint at the following conditions

#define BREAK_ON_BEGIN_INIT 0x01    // Break point at beginning of init
#define BREAK_ON_BEGIN_END  0x02    // Break point at complete of init
#define BREAK_ON_P_CONNECT  0x04    // Break at process connect
#define BREAK_ON_SP_EXCEPT  0x08    // Break if a package causes an exception
#define BREAK_ON_PROBLEM    0x10    // Break if a serious problem occurs
#define BREAK_ON_SHUTDOWN   0x20    // Break on beginning of shutdown
#define BREAK_ON_LOAD       0x40    // Break when a package is loaded


//
// Negotiation specific debugging
//

#define DEB_TRACE_LOCKS     0x00000010

#if DBG

// Debugging support prototypes:

void    InitDebugSupport(void);
void    LogEvent(long, const char *, ...);

extern SECPKG_FUNCTION_TABLE   DbgTable;

DECLARE_DEBUG2(SPM);
DECLARE_DEBUG2(Neg);

extern  DWORD   BreakFlags;         // Breakpoints

#define DebugLog(x) SPMDebugPrint x
#define DebugLogEx(x) SPMDebugPrint x
#define NegDebugLog(x)  NegDebugPrint x
#define DebugStmt(x)    x
#define BreakOnError(x) \
            if ((x & BreakFlags) && \
                (SPMInfoLevel & DEB_BREAK_ON_ERROR)) \
                { \
                    DebugLog((DEB_BREAK_ON_ERROR, "Breakpoint requested\n" )); \
                    DbgUserBreakPoint(); \
                }

#define ASSERT_CONTINUE 0
#define ASSERT_BREAK    1
#define ASSERT_SUSPEND  2
#define ASSERT_KILL     3
#define ASSERT_PROMPT   4
#define ASSERT_DEBUGGER 5


#define SpmAssertEx( exp , ContinueCode ) \
            DsysAssertEx( exp, ContinueCode )

#define SpmAssertMsgEx( Msg, exp, ContinueCode ) \
            DsysAssertMsgEx( exp, Msg, ContinueCode )

#define SpmAssert(exp)          SpmAssertEx(exp, ASSERT_DEBUGGER)
#define SpmAssertMsg(Msg, exp)  SpmAssertMsgEx(Msg, exp, ASSERT_DEBUGGER )
#define SpmpThreadStartup()     SpmpThreadStartupEx()
#define SpmpThreadExit()        SpmpThreadExitEx()

void
SpmpThreadStartupEx(void);

void
SpmpThreadExitEx(void);



#else   // Not DBG

#define DebugLog(x)

#define NegDebugLog(x) 

#ifdef DBG_ERRORS
void ExLogEvent(long, const char *, ...);
#define DebugLogEx(x)   ExLogEvent x
#else
#define DebugLogEx(x)
#endif

#define DebugStmt(x)

#define BreakOnError(x)

#define SpmAssertEx(exp, ContinueCode)

#define SpmAssert(exp)

#define SpmAssertMsg(Msg, exp)

#define SpmAssertMsgEx(Msg, exp, ContinueCode)
#define SpmpThreadStartup()
#define SpmpThreadExit()

#endif


#endif // __DEBUG_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\base\lsa\server\debug.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1993.
//
//  File:       debug.c
//
//  Contents:   Debugging support functions
//
//  Classes:
//
//  Functions:
//
//  Note:       This file is not compiled for retail builds
//
//  History:    4-29-93   RichardW   Created
//
//----------------------------------------------------------------------------

#include <lsapch.hxx>
extern "C"
{
#define ANSI
#include <stdarg.h>
}
//
//  For ease of debugging the SPMgr, all the debug support functions have
//  been stuck here.  Basically, we read info from win.ini, since that allows
//  us to configure the debug level via a text file (and DOS, for example).
//
//  Format is:
//
//  win.ini
//
//  [SPM]
//      DebugFlags=<Flag>[<,Flag>]*
//      BreakFlags=<BreakFlag>[<,BreakFlags>]*
//
//  WHERE:
//      Flag is one of the following:
//          Error, Warning, Trace, Verbose, BreakOnError, Helpers,
//          RefMon, Locator, WAPI, Init, Audit, Db, Lsa
//
//      BreakFlags will cause SPMgr to break, if BreakOnError is set in
//      DebugFlags:
//          InitBegin, InitEnd, Connect, Exception, Problem, Load
//
//

#if DBG         // NOTE:  This file not compiled for retail builds


extern "C"
{
WINBASEAPI
BOOL
WINAPI
IsDebuggerPresent(
    VOID
    );
}

DEFINE_DEBUG2(SPM);
DEBUG_KEY   SpmgrDebugKeys[] = { {DEB_ERROR,            "Error"},
                                 {DEB_WARN,             "Warning"},
                                 {DEB_TRACE,            "Trace"},
                                 {DEB_TRACE_VERB,       "Verbose"},
                                 {DEB_TRACE_WAPI,       "WAPI"},
                                 {DEB_TRACE_HELPERS,    "Helpers"},
                                 {DEB_TRACE_RM,         "RefMon"},
                                 {DEB_TRACE_INIT,       "Init"},
                                 {DEB_TRACE_SCAV,       "Scav"},
                                 {DEB_TRACE_CRED,       "Cred"},
                                 {DEB_TRACE_NEG,        "Neg"},
                                 {DEB_TRACE_LPC,        "LPC"},
                                 {DEB_TRACE_SAM,        "SAM"},
                                 {DEB_TRACE_LSA,        "LSA"},
                                 {DEB_TRACE_SPECIAL,    "Special"},
                                 {DEB_TRACE_QUEUE,      "Queue"},
                                 {DEB_TRACE_HANDLES,    "Handles"},
                                 {DEB_TRACE_NEG_LOCKS,  "NegLock"},
                                 {DEB_TRACE_AUDIT,      "Audit"},
                                 {DEB_TRACE_EFS,        "EFS"},
                                 {DEB_TRACE_FRAG,       "NegFrag"},
                                 {DEB_BREAK_ON_ERROR,   "BreakOnError"},
                                 {0, NULL},
                                 };

DWORD   BreakFlags = 0;

DEFINE_DEBUG2(Neg);
DEBUG_KEY   NegDebugKeys[]   = { {DEB_ERROR,            "Error"},
                                 {DEB_WARN,             "Warning"},
                                 {DEB_TRACE,            "Trace"},
                                 {DEB_TRACE_LOCKS,      "Locks"},
                                 {0, NULL},
                                 };

extern  DWORD   NoUnload;

CHAR    DbgPackageName[] = "LSA Debug Package";

LSA_AP_INITIALIZE_PACKAGE       DbgInitialize;
LSA_AP_CALL_PACKAGE             DbgCallPackage;

SECPKG_FUNCTION_TABLE   DbgTable = {
            DbgInitialize,
            NULL,
            DbgCallPackage,
            NULL,
            DbgCallPackage,         
            DbgCallPackage,
            NULL,
            NULL,
            NULL
            };

// Debugging support functions.

// These two functions do not exist in Non-Debug builds.  They are wrappers
// to the commnot functions (maybe I should get rid of that as well...)
// that echo the message to a log file.

char   szSection[] = "SPMgr";

typedef struct _DebugKeys {
    char *  Name;
    DWORD   Value;
} DebugKeys, *PDebugKeys;

DebugKeys   BreakKeyNames[] = {
                {"InitBegin",   BREAK_ON_BEGIN_INIT},
                {"InitEnd",     BREAK_ON_BEGIN_END},
                {"Connect",     BREAK_ON_P_CONNECT},
                {"Exception",   BREAK_ON_SP_EXCEPT},
                {"Problem",     BREAK_ON_PROBLEM},
                {"Shutdown",    BREAK_ON_SHUTDOWN},
                {"Load",        BREAK_ON_LOAD}
                };

#define NUM_BREAK_KEYS  (sizeof(BreakKeyNames) / sizeof(DebugKeys))

DWORD
GetDebugKeyValue(
    PDebugKeys      KeyTable,
    int             cKeys,
    LPSTR           pszKey)
{
    int     i;

    for (i = 0; i < cKeys ; i++ )
    {
        if (_strcmpi(KeyTable[i].Name, pszKey) == 0)
        {
            return(KeyTable[i].Value);
        }
    }
    return(0);
}


//+---------------------------------------------------------------------------
//
//  Function:   LoadDebugParameters
//
//  Synopsis:   Loads debug parameters from win.ini
//
//  Effects:
//
//  Arguments:  (none)
//
//  Requires:
//
//  Returns:
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:
//
//  History:    4-29-93   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------

void
LoadDebugParameters(void)
{
    char    szVal[128];
    char *  pszDebug;
    int     cbVal;


    if (SPMInfoLevel & DEB_BREAK_ON_ERROR)
    {
        SPMSetOption( DEBUG_BREAK_ON_ERROR, TRUE, TRUE );

        cbVal = GetProfileStringA(szSection, "BreakFlags", "", szVal, sizeof(szVal));
        if (cbVal)
        {
            pszDebug = strtok(szVal, ", \t");
            while (pszDebug)
            {
                BreakFlags |= GetDebugKeyValue(BreakKeyNames, NUM_BREAK_KEYS,
                                                pszDebug);

                pszDebug = strtok(NULL, ", \t");
            }
        } // If break flags exists
    }


}


//+---------------------------------------------------------------------------
//
//  Function:   InitDebugSupport
//
//  Synopsis:   Initializes debugging support for the SPMgr
//
//  Effects:
//
//  Arguments:  (none)
//
//  Requires:
//
//  Returns:
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:
//
//  History:    4-29-93   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------

void
InitDebugSupport(void)
{
    SPMInitDebug(SpmgrDebugKeys);

    LoadDebugParameters();
}


SECURITY_STATUS
SEC_ENTRY
DbgInitialize(
    IN ULONG AuthenticationPackageId,
    IN PLSA_DISPATCH_TABLE LsaDispatchTable,
    IN OPTIONAL PSTRING Database,
    IN OPTIONAL PSTRING Confidentiality,
    OUT PSTRING *AuthenticationPackageName
    )
{
    PSTRING Name ;

    Name = (PSTRING) LsapAllocateLsaHeap( sizeof( STRING ) );
    
    if ( Name )
    {
        Name->Buffer = (PSTR) LsapAllocateLsaHeap( sizeof( DbgPackageName ) );
        Name->Length = sizeof( DbgPackageName ) - 1;
        Name->MaximumLength = sizeof( DbgPackageName );
        if ( Name->Buffer )
        {
            strcpy( Name->Buffer, DbgPackageName );
            *AuthenticationPackageName = Name ;
            return TRUE ;
        }
        else 
        {
            LsapFreeLsaHeap( Name );
        }
    }

    return FALSE ;
}


NTSTATUS
DbgCallPackage(
    IN PLSA_CLIENT_REQUEST ClientRequest,
    IN PVOID ProtocolSubmitBuffer,
    IN PVOID ClientBufferBase,
    IN ULONG SubmitBufferLength,
    OUT PVOID *ProtocolReturnBuffer,
    OUT PULONG ReturnBufferLength,
    OUT PNTSTATUS ProtocolStatus
    )
{
    return STATUS_INVALID_PARAMETER ;

}

#else // DBG

#pragma warning(disable:4206)   // Disable the empty transation unit
                                // warning/error

#endif  // NOTE:  This file not compiled for retail builds
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\base\lsa\server\efsrpc_s_stub.c ===
#include "efsrpc_s.c"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\base\lsa\server\efsinit.cxx ===
/*++

Copyright (c) 1997-1999  Microsoft Corporation

Module Name:

    efsinit.cxx

Abstract:

    EFS (Encrypting File System) Server

Author:

    Robert Reichel      (RobertRe)     July 4, 1997
    Robert Gu           (RobertGu)     Jan 7, 1998

Environment:

Revision History:

--*/
#include <lsapch.hxx>

extern "C" {
#include <nt.h>
#include <ntdef.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <stdio.h>
#include <efsstruc.h>
#include "lsasrvp.h"
#include "debug.h"
#include "efssrv.hxx"
#include "userkey.h"
#include <cfgmgr32.h>
#include <initguid.h>
#include <mountmgr.h>
#include <Userenv.h>
}

#define  TIME_UNIT 10000000         // 1 TIME_UNIT == 1 second
#define  CERT_VALID_TIME 86400 // seconds - Default cache length 1 day

//
// Local prototypes of CFGMGR32 functions for dynamic load
//

typedef CMAPI CONFIGRET (WINAPI *
    CM_GET_DEVICE_INTERFACE_LISTW)(
        IN LPGUID,
        IN DEVINSTID_W,
        OUT PWCHAR,
        IN ULONG,
        IN ULONG );

typedef CMAPI CONFIGRET (WINAPI *
    CM_GET_DEVICE_INTERFACE_LIST_SIZEW)(
        IN PULONG,
        IN LPGUID,
        IN DEVINSTID_W,
        IN ULONG
        );

typedef CONFIGRET ( * CMP_WAITSERVICESAVAILABLE)(
        IN HMACHINE
        );


//
// Extern Vars
//

extern RTL_RESOURCE RecoveryPolicyResource;
extern CURRENT_RECOVERY_POLICY CurrentRecoveryPolicy;
extern "C" BOOLEAN EfsDisabled;


//
//  Event handle used to sync with the driver
//

HANDLE EfsInitEventHandle = 0;

//
// Efs event handle to get policy change notification
//

HANDLE EfsPolicyEventHandle = 0;
HANDLE EfsWaitHandle = 0;
EFS_POL_CALLBACK EfsPolCallBack;

BOOLEAN EfsServerInitialized = FALSE;
extern "C" BOOLEAN EfsPersonalVer = TRUE;

BOOLEAN EfspInDomain = FALSE;

//
// Cache values
//

HCRYPTPROV hProvVerify = 0;

WCHAR EfsComputerName[MAX_COMPUTERNAME_LENGTH + 1];
LIST_ENTRY UserCacheList;
RTL_CRITICAL_SECTION GuardCacheListLock;
LONG UserCacheListLimit = 5; // We might read this number from the registry in the future
LONG UserCacheListCount = 0;

LONGLONG CACHE_CERT_VALID_TIME;
LONG RecoveryCertIsValidating = 0;

static PSID LocalSystemSid;

DWORD
InitRecoveryPolicy(
    VOID
    );

DWORD
SetDefaultRecoveryPolicy(
    VOID
    );

DWORD
ParseRecoveryPolicy_1_1(
    IN  PLSAPR_POLICY_DOMAIN_EFS_INFO PolicyEfsInfo OPTIONAL,
    OUT PCURRENT_RECOVERY_POLICY ParsedRecoveryPolicy
    );

VOID
EfsGetRegSettings(
    VOID
    );

NTSTATUS
EfsServerInit(
    VOID
    )
/*++

Routine Description:

    This routine is called during server initialization to allow
    EFS to initialize its data structures and inform the EFS Driver
    that it's up and running.

Arguments:

    None.

Return Value:

    None.

--*/

{

    OBJECT_ATTRIBUTES ObjA;
    NTSTATUS Status;
    UNICODE_STRING EfsInitEventName;
    OSVERSIONINFOEX Osvi;
    DWORD Result;
    DWORD nSize = MAX_COMPUTERNAME_LENGTH + 1;

    CACHE_CERT_VALID_TIME = (LONGLONG) CERT_VALID_TIME;
    CACHE_CERT_VALID_TIME *= (LONGLONG) TIME_UNIT; 

    if ( !GetComputerName ( EfsComputerName, &nSize )){

        KdPrint(("EfsServerInit - GetComputerName failed 0x%lx\n", GetLastError()));
        return STATUS_UNSUCCESSFUL;

    }

    Osvi.dwOSVersionInfoSize = sizeof(OSVERSIONINFOEX);
    if (GetVersionEx((LPOSVERSIONINFO)&Osvi)){

        if ((Osvi.wProductType == VER_NT_WORKSTATION) && ( Osvi.wSuiteMask & VER_SUITE_PERSONAL)) {

            EfsPersonalVer = TRUE;
            return STATUS_UNSUCCESSFUL;

        } else {

            if (Osvi.wProductType != VER_NT_WORKSTATION) {

                //
                // A server or DC. Increase the cache node value by 95.
                // This value could be reset by the registry value.
                //

                UserCacheListLimit += 95;


            }
            EfsPersonalVer = FALSE;
        }

    } else {

        //
        // Treat as personal
        //

        EfsPersonalVer = TRUE;
        return STATUS_UNSUCCESSFUL;
    }

    //
    // Init the cache list
    //

    InitializeListHead(&UserCacheList);
    Status = RtlInitializeCriticalSection(&GuardCacheListLock);
    if (!NT_SUCCESS(Status)) {
        return Status;
    }

    EfsGetRegSettings();

    Status = InitDriverSessionKey();
    if (!NT_SUCCESS(Status)) {

        KdPrint(("EfsServerInit - EFS Init Session Key failed 0x%lx\n", Status));
        return( Status );

    }

    DebugLog((DEB_TRACE_EFS, "In EfsServerInit\n"   ));

    //
    // Zero out the initial recovery policy structure
    //

    Result = ParseRecoveryPolicy_1_1(
                 NULL,
                 &CurrentRecoveryPolicy
                 );

    //
    // Determine if we're in a domain or not.  This must be done
    // before checking the recovery policy.
    //

    EfspRoleChangeCallback( (POLICY_NOTIFICATION_INFORMATION_CLASS)NULL );

    Status = LsaIRegisterPolicyChangeNotificationCallback(
                 &EfspRoleChangeCallback,
                 PolicyNotifyDnsDomainInformation
                 );

    //
    // Try to get the current recovery policy.
    //

    __try{

        RtlInitializeResource( &RecoveryPolicyResource );

    } __except (EXCEPTION_EXECUTE_HANDLER){

        Status = GetExceptionCode();

    }
    if ( !NT_SUCCESS( Status ) ) {
        return Status ;
    }

    Result = InitRecoveryPolicy();

    if (ERROR_SUCCESS != Result) {

        //
        // We couldn't initialize our recovery policy.  Continue to
        // initialize the server so that the driver can proceed.
        //

        DebugLog((DEB_ERROR, "EfsServerInit - EFS Init Recovery Policy failed 0x%lx\n\n" ,Result  ));
    }

    //
    // Try to establish connection with the driver.
    // Normally, the driver has not been loaded yet. Create
    // an event and wait for the driver. If the event already
    // exists, signal it.
    //

    RtlInitUnicodeString( &EfsInitEventName, L"\\EFSInitEvent" );

    InitializeObjectAttributes(
        &ObjA,
        &EfsInitEventName,
        0,
        NULL,
        NULL
        );

    Status = NtCreateEvent(
                 &EfsInitEventHandle,
                 EVENT_MODIFY_STATE,
                 &ObjA,
                 NotificationEvent,
                 FALSE
                 );

    if (!NT_SUCCESS(Status)) {

        if (STATUS_OBJECT_NAME_COLLISION == Status) {

            //
            // EFS driver has been loaded.
            // Open and signal the event. Event handle will be closed
            // in GenerateDriverSessionKey()
            //

            Status = NtOpenEvent(
                         &EfsInitEventHandle,
                         EVENT_MODIFY_STATE,
                         &ObjA
                         );

            //
            // If the EFS Init event could not be opened, the EFS Server cannot
            // synchronize with the EFS Driver so neither component will
            // function correctly.
            //

            if (!NT_SUCCESS(Status)) {

                KdPrint(("EfsServerInit - Connection with the driver failed 0x%lx\n",Status));
                return( Status );

            }

            //
            // Signal the EFS Init Event.  If the signalling fails, the EFS Server
            // is not able to synchronize properly with the EFS Driver.
            // This is a serious error which prevents both components from
            // functioning correctly.
            //

            Status = NtSetEvent( EfsInitEventHandle, NULL );

            if (!NT_SUCCESS(Status)) {

                KdPrint(("EfsServerInit - Init Event Set failed 0x%lx\n",Status));
                return( Status );
            }

        } else {

            //
            //  Other unexpected error
            //

            KdPrint(("EfsServerInit - Event handling failed 0x%lx\n",Status));
            return( Status );

        }
    }

    SID_IDENTIFIER_AUTHORITY    NtAuthority = SECURITY_NT_AUTHORITY;

    Status = RtlAllocateAndInitializeSid(
                 &NtAuthority,
                 1,
                 SECURITY_LOCAL_SYSTEM_RID,
                 0, 0, 0, 0, 0, 0, 0,
                 &LocalSystemSid
                 );

    Status = LsaIRegisterPolicyChangeNotificationCallback(
                 &RecoveryInformationCallback,
                 PolicyNotifyDomainEfsInformation
                 );

    //
    // Check EFS disable policy if a DC member
    //

    if (EfspInDomain) {

        //
        // Only do this if in the domain
        //

        EfsPolicyEventHandle = CreateEvent(NULL, TRUE, FALSE, NULL);
        if (EfsPolicyEventHandle) {

            HANDLE waitHandle;


            EfsPolCallBack.EfsDisable = &EfsDisabled;
            EfsPolCallBack.EfsPolicyEventHandle = &EfsPolicyEventHandle;

            //
            // We got the event handle. Let's register it to the GP notification.
            // If we can't wait on it, we don't need to register it.
            //

            if (RegisterGPNotification(EfsPolicyEventHandle, TRUE)){
                if (!NT_SUCCESS(RtlRegisterWait(
                                    &EfsWaitHandle,
                                    EfsPolicyEventHandle, 
                                    EfsGetPolRegSettings, 
                                    &EfsPolCallBack, 
                                    INFINITE, 
                                    WT_EXECUTEONLYONCE))){
            
                    //
                    //  We couldn't use the thread pool. 
                    //
    
                    UnregisterGPNotification(EfsPolicyEventHandle);

                    CloseHandle(EfsPolicyEventHandle);
                    EfsPolicyEventHandle = 0;
    
                }
            } else {
                //
                // We failed to register. No need to wait for the notification.
                //

                //RtlDeregisterWait(EfsWaitHandle);
                CloseHandle(EfsPolicyEventHandle);
                EfsPolicyEventHandle = 0;

            }
            

        }

        //
        //  Now let's read the policy data left by the last session.
        //  Pass in &EfsDisabled so that later we could easily change this to
        //  include more features, such as algorithms controlled by the policy.
        //

        EfsApplyLastPolicy(&EfsDisabled);


    } else {

        //
        // Delete the possible left over key if there is. We may move this to
        // DC disjoin later.
        //

        EfsRemoveKey();

    }
    

    EfsServerInitialized  =  TRUE;

    if (NT_SUCCESS( Status )) {
        DebugLog((DEB_TRACE_EFS, "EFS Server initialized successfully\n"   ));
    } else {
        DebugLog((DEB_ERROR, "EFS Server Init failed, Status = %x\n" ,Status  ));
    }

    return( Status );
}

NTSTATUS
InitDriverSessionKey(
    VOID
    )
/*++

Routine Description:

    Generates a session key to be used by the driver and the server
    for sending information back and forth securely.

Arguments:

    None.

Return Value:

    STATUS_SUCCESS on success, STATUS_UNSUCCESSFUL otherwise.

--*/
{
    BOOL rc;

    //
    // hProvVerify will remain open until the process is shut down.
    // CryptReleaseContext(hProvVerify, 0) will not be called for this handle.
    //
    //

    if (!CryptAcquireContext(&hProvVerify, NULL, MS_DEF_PROV, PROV_RSA_FULL, CRYPT_VERIFYCONTEXT | CRYPT_SILENT)) {

        KdPrint(("InitDriverSessionKey - CryptAcquireContext failed, error = %x\n", GetLastError()));
        return( STATUS_UNSUCCESSFUL );

    }

    rc = CryptGenRandom( hProvVerify, SESSION_KEY_SIZE, DriverSessionKey );

    if (!rc) {
        return( STATUS_UNSUCCESSFUL );
    } else {

        LsaPid = (HANDLE) LongToPtr(GetCurrentProcessId());

        deskey( &DesTable, DriverSessionKey );

        return( STATUS_SUCCESS );
    }
}

NTSTATUS
GenerateDriverSessionKey(
    OUT PEFS_INIT_DATAEXG InitDataExg
    )
/*++

Routine Description:

    Actually it just sends the pre-created session key back to the
    caller. The key is generated in InitDriverSessionKey.

Arguments:

    InitDataExg - Supplies a pointer to a structure in which to put
        the initial data to be sent to the driver.

Return Value:

    STATUS_SUCCESS.

--*/

{
    memcpy( InitDataExg->Key, DriverSessionKey, SESSION_KEY_SIZE );
    InitDataExg->LsaProcessID = LsaPid;

    if ( EfsInitEventHandle ){

        //
        // Connection to driver established
        //

        NtClose( EfsInitEventHandle );
        EfsInitEventHandle = 0;

    }

    return( STATUS_SUCCESS );
}

inline
VOID
AcquireRecoveryPolicyWriteLock()
{
    BOOL b = RtlAcquireResourceExclusive( &RecoveryPolicyResource, TRUE );

    ASSERT( b );
}

inline
VOID
ReleaseRecoveryPolicyWriteLock()
{
    RtlReleaseResource( &RecoveryPolicyResource );
}


DWORD
InitRecoveryPolicy(
    VOID
    )

/*++

Routine Description:

    This routine is used to initialize the current recovery policy.

Arguments:

    None

Return Value:

    None.

--*/
{
    //
    // Attempt to query the recovery policy
    // from LSA, and if there isn't any,
    // attempt to create a default set.
    //

    DWORD Result = ERROR_SUCCESS;
    PLSAPR_POLICY_DOMAIN_EFS_INFO PolicyEfsInfo = NULL;

    NTSTATUS Status = LsarQueryDomainInformationPolicy(
                          LsapPolicyHandle,
                          PolicyDomainEfsInformation,
                          (PLSAPR_POLICY_DOMAIN_INFORMATION *)&PolicyEfsInfo
                          );

    if (!NT_SUCCESS( Status )) {
        return( RtlNtStatusToDosError(Status) );
    }

    //
    // We're going to parse it right into the global that maintains
    // the current recovery data, so take the write lock.
    //

    AcquireRecoveryPolicyWriteLock();

    //
    // Free the old parsed recovery bits
    //

    FreeParsedRecoveryPolicy( &CurrentRecoveryPolicy );

    Result = ParseRecoveryPolicy_1_1( PolicyEfsInfo, &CurrentRecoveryPolicy );

    if (PolicyEfsInfo != NULL) {

        LsaIFree_LSAPR_POLICY_DOMAIN_INFORMATION (
            PolicyDomainEfsInformation,
            (PLSAPR_POLICY_DOMAIN_INFORMATION)PolicyEfsInfo
            );
    }

    ReleaseRecoveryPolicyWriteLock();

    return( Result );
}


DWORD
ParseRecoveryPolicy_1_1(
    IN  PLSAPR_POLICY_DOMAIN_EFS_INFO PolicyEfsInfo OPTIONAL,
    OUT PCURRENT_RECOVERY_POLICY ParsedRecoveryPolicy
    )

/*++

Routine Description:

    This routine takes the currently defined recovery policy and parses
    it into a form that can be used conveniently.

Arguments:

    PolicyEfsInfo - Optionally supplies a pointer to the current
        recovery policy from the LSA.

    ParsedRecoveryPolicy - Returns a structure containing recovery information
        in an easy-to-digest format.

Return Value:

    return-value - Description of conditions needed to return value. - or -
    None.

--*/

{
    //
    // Fill in the contents of the ParsedRecoveryPolicy structure
    // with the contents of the passed policy information.
    //

    PRECOVERY_POLICY_1_1 RecoveryPolicy;
    DWORD Found = 0;
    PRECOVERY_KEY_1_1 RecoveryKey;
    DWORD rc = ERROR_SUCCESS;
    BOOL b = FALSE;

    if (PolicyEfsInfo == NULL) {

        //
        // NULL recovery policy
        //

        ParsedRecoveryPolicy->PolicyStatus = RECOVERY_POLICY_NULL;
        goto NoPolicy1;
    }

    RecoveryPolicy = (PRECOVERY_POLICY_1_1)PolicyEfsInfo->EfsBlob;

    if (RecoveryPolicy == NULL) {

        //
        // Empty recovery policy
        //

        ParsedRecoveryPolicy->PolicyStatus = RECOVERY_POLICY_EMPTY;
        goto NoPolicy1;
    }

    ParsedRecoveryPolicy->dwKeyCount = RecoveryPolicy->RecoveryPolicyHeader.RecoveryKeyCount;

    if (ParsedRecoveryPolicy->dwKeyCount == 0) {
        ParsedRecoveryPolicy->PolicyStatus = RECOVERY_POLICY_NO_AGENT;
        goto NoPolicy1;
    }


    __try {

        //
        // Scan the recovery data looking for recovery keys in a format we understand
        //

        ULONG i;
        RecoveryKey = (PRECOVERY_KEY_1_1) &(RecoveryPolicy->RecoveryKeyList[0]);

        for (i=0 ; i< (ParsedRecoveryPolicy->dwKeyCount) ; i++) {

            PEFS_PUBLIC_KEY_INFO PublicKeyInfo = &RecoveryKey->PublicKeyInfo;

            if (* ((ULONG UNALIGNED *) &(PublicKeyInfo->KeySourceTag)) == EfsCertificate) {
                Found++;
            }

            RecoveryKey = (PRECOVERY_KEY_1_1)( ((PBYTE)RecoveryKey) + * ((ULONG UNALIGNED *) &(RecoveryKey->TotalLength)) );
        }

        if (0 == Found) {

            ParsedRecoveryPolicy->PolicyStatus = RECOVERY_POLICY_BAD_POLICY;
            goto NoPolicy1;

        } else {

            ParsedRecoveryPolicy->Base = (PBYTE)LsapAllocateLsaHeap( 7 * sizeof( PVOID ) * Found );

            if (ParsedRecoveryPolicy->Base) {

                ZeroMemory( ParsedRecoveryPolicy->Base, 7 * sizeof( PVOID ) * Found);

                PBYTE Base = ParsedRecoveryPolicy->Base;

                ParsedRecoveryPolicy->pbHash = (PBYTE *)Base;
                Base += Found * sizeof(PVOID);

                ParsedRecoveryPolicy->cbHash = (PDWORD)Base;
                Base += Found * sizeof(PVOID);

                ParsedRecoveryPolicy->pbPublicKeys = (PBYTE *)Base;
                Base += Found * sizeof(PVOID);

                ParsedRecoveryPolicy->cbPublicKeys = (PDWORD)Base;
                Base += Found * sizeof(PVOID);

                ParsedRecoveryPolicy->lpDisplayInfo = (LPWSTR *)Base;
                Base += Found * sizeof(PVOID);

                ParsedRecoveryPolicy->pCertContext = (PCCERT_CONTEXT *)Base;
                Base += Found * sizeof(PVOID);

                ParsedRecoveryPolicy->pSid = (PSID *)Base;
            } else {

                ParsedRecoveryPolicy->PolicyStatus = RECOVERY_POLICY_NO_MEMORY;
                return( ERROR_NOT_ENOUGH_MEMORY );
            }

            ParsedRecoveryPolicy->dwKeyCount = Found;
            ParsedRecoveryPolicy->PolicyStatus = RECOVERY_POLICY_OK;

            //
            // Make a copy of the policy information so we can free what we were passed in the caller
            //

            RecoveryKey = (PRECOVERY_KEY_1_1) &(RecoveryPolicy->RecoveryKeyList[0]);


            for (i=0 ; i< (ParsedRecoveryPolicy->dwKeyCount) ; i++) {

                PEFS_PUBLIC_KEY_INFO PublicKeyInfo = &RecoveryKey->PublicKeyInfo;

                if (* ((ULONG UNALIGNED *) &(PublicKeyInfo->KeySourceTag)) == EfsCertificate) {

                    b = ParseRecoveryCertificate( PublicKeyInfo,
                                                  &ParsedRecoveryPolicy->pbHash[i],
                                                  &ParsedRecoveryPolicy->cbHash[i],
                                                  &ParsedRecoveryPolicy->pbPublicKeys[i],
                                                  &ParsedRecoveryPolicy->cbPublicKeys[i],
                                                  &ParsedRecoveryPolicy->lpDisplayInfo[i],
                                                  &ParsedRecoveryPolicy->pCertContext[i],
                                                  &ParsedRecoveryPolicy->pSid[i]
                                                  );

                    if (!b) {
                        break;
                    }
                }

                RecoveryKey = (PRECOVERY_KEY_1_1)( ((PBYTE)RecoveryKey) + * ((ULONG UNALIGNED *) &(RecoveryKey->TotalLength)) );
            }
        }

    } __except (EXCEPTION_EXECUTE_HANDLER) {

        b = FALSE;

        //
        // There was something wrong with the recovery policy.
        // Return this so we can at least print out an error.
        //

        rc = GetExceptionCode();
    }

    if (!b) {

        //
        // Something failed, clean up
        //

        rc = GetLastError();
        FreeParsedRecoveryPolicy( ParsedRecoveryPolicy );
        ParsedRecoveryPolicy->PolicyStatus = RECOVERY_POLICY_UNKNOWN_BAD;

        DebugLog((DEB_WARN, "Error parsing recovery policy\n"   ));
    }

    //
    // Policy refreshed. The Cert validation needs to be refreshed.
    //

    ParsedRecoveryPolicy->CertValidated   = CERT_NOT_VALIDATED;

    return( rc );


NoPolicy1:

    ParsedRecoveryPolicy->dwKeyCount       = 0;
    ParsedRecoveryPolicy->TimeStamp.QuadPart = 0;
    ParsedRecoveryPolicy->CertValidated   = CERT_NOT_VALIDATED;
    ParsedRecoveryPolicy->Base             = NULL;
    ParsedRecoveryPolicy->pbHash           = NULL;
    ParsedRecoveryPolicy->cbHash           = NULL;
    ParsedRecoveryPolicy->pbPublicKeys     = NULL;
    ParsedRecoveryPolicy->cbPublicKeys     = NULL;
    ParsedRecoveryPolicy->lpDisplayInfo    = NULL;
    ParsedRecoveryPolicy->pCertContext     = NULL;
    ParsedRecoveryPolicy->pSid             = NULL;

    return( ERROR_SUCCESS );
}


VOID
FreeParsedRecoveryPolicy(
    PCURRENT_RECOVERY_POLICY ParsedRecoveryPolicy
    )
/*++

Routine Description:

    This routine will free the allocated memory in a
    CURRENT_RECOVERY_POLICY structure.

Arguments:

    ParsedRecoveryPolicy - Supplies a structure that has
        had data parsed into it.

Return Value:

    None.

--*/

{
    //
    // Walk through the recovery policy and free everything
    //

    DWORD i;

    if (ParsedRecoveryPolicy->Base) {

        for (i=0; i<ParsedRecoveryPolicy->dwKeyCount; i++) {

            if (ParsedRecoveryPolicy->pbHash[i] != NULL) {
                LsapFreeLsaHeap( ParsedRecoveryPolicy->pbHash[i] );
            }

            if (ParsedRecoveryPolicy->pbPublicKeys[i] != NULL) {
                LsapFreeLsaHeap( ParsedRecoveryPolicy->pbPublicKeys[i] );
            }

            if (ParsedRecoveryPolicy->lpDisplayInfo[i] != NULL) {
                LsapFreeLsaHeap( ParsedRecoveryPolicy->lpDisplayInfo[i] );
            }

            if (ParsedRecoveryPolicy->pCertContext[i] != NULL) {
                CertFreeCertificateContext( ParsedRecoveryPolicy->pCertContext[i] );
            }

            if (ParsedRecoveryPolicy->pSid[i] != NULL) {
                LsapFreeLsaHeap( ParsedRecoveryPolicy->pSid[i] );
            }
        }

        LsapFreeLsaHeap( ParsedRecoveryPolicy->Base );
    }

    //
    // Paranoia
    //

    ParsedRecoveryPolicy->Base          = NULL;
    ParsedRecoveryPolicy->CertValidated  = CERT_NOT_VALIDATED;
    ParsedRecoveryPolicy->PolicyStatus  = RECOVERY_POLICY_NULL;
    ParsedRecoveryPolicy->dwKeyCount    = 0;
    ParsedRecoveryPolicy->pbHash        = NULL;
    ParsedRecoveryPolicy->cbHash        = NULL;
    ParsedRecoveryPolicy->pbPublicKeys  = NULL;
    ParsedRecoveryPolicy->cbPublicKeys  = NULL;
    ParsedRecoveryPolicy->lpDisplayInfo = NULL;
    ParsedRecoveryPolicy->pCertContext  = NULL;
    ParsedRecoveryPolicy->pSid          = NULL;
}

DWORD WINAPI
EFSRecover(
    IN LPVOID Param
    )
/*++
Routine Description:

    Enumerate the volumes and do the possible recovery jobs caused by
    power outage or crash during encryption or decryption.

Arguments:

    Param -- Standard parameter for thread. Not used.

Return Value:

    Operation result.

--*/
{
    CONFIGRET RetCode;
    WCHAR  *VolBuffer;
    WCHAR *PathName;
    ULONG  VolOffset;
    ULONG   bufLen;
    HMODULE hCfgMgr ;
    CMP_WAITSERVICESAVAILABLE pCMP_WaitServicesAvailable ;
    CM_GET_DEVICE_INTERFACE_LIST_SIZEW pCM_Get_Device_Interface_List_Size ;
    CM_GET_DEVICE_INTERFACE_LISTW pCM_Get_Device_Interface_List ;

//    hCfgMgr = LoadLibrary( TEXT("cfgmgr32.dll" ) );

    hCfgMgr = LoadLibrary( TEXT("setupapi.dll" ) );

    if ( hCfgMgr ){
        pCMP_WaitServicesAvailable = (CMP_WAITSERVICESAVAILABLE)
                                            GetProcAddress( hCfgMgr,
                                                            "CMP_WaitServicesAvailable" );
        pCM_Get_Device_Interface_List_Size = (CM_GET_DEVICE_INTERFACE_LIST_SIZEW)
                                            GetProcAddress( hCfgMgr,
                                                            "CM_Get_Device_Interface_List_SizeW" );

        pCM_Get_Device_Interface_List = (CM_GET_DEVICE_INTERFACE_LISTW)
                                            GetProcAddress( hCfgMgr,
                                                            "CM_Get_Device_Interface_ListW" );

        if ( (!pCMP_WaitServicesAvailable) ||
             (!pCM_Get_Device_Interface_List_Size) ||
             (!pCM_Get_Device_Interface_List) )
        {
            FreeLibrary( hCfgMgr );

            return GetLastError() ;
        }
    } else {
       return GetLastError() ;
    }


    RetCode = pCMP_WaitServicesAvailable( NULL );

    if ( CR_SUCCESS != RetCode ){
        FreeLibrary( hCfgMgr );
        return RetCode;
    }


    RetCode = pCM_Get_Device_Interface_List_Size(
                                    &bufLen,
                                    (LPGUID)&MOUNTDEV_MOUNTED_DEVICE_GUID,
                                    NULL,
                                    CM_GET_DEVICE_INTERFACE_LIST_PRESENT
                                    );



    if ( CR_SUCCESS == RetCode ){

        SafeAllocaAllocate(VolBuffer, bufLen * sizeof(WCHAR));
        SafeAllocaAllocate(PathName, MAX_PATH_LENGTH);

        if ( (NULL != VolBuffer) && (NULL != PathName) ){

            RetCode = pCM_Get_Device_Interface_List(
                                (LPGUID)&MOUNTDEV_MOUNTED_DEVICE_GUID,
                                NULL,
                                VolBuffer,
                                bufLen,
                                CM_GET_DEVICE_INTERFACE_LIST_PRESENT
                            );

            if ( CR_SUCCESS == RetCode ){

                VolOffset = 0;
                while (*(VolBuffer + VolOffset)) {

                    //
                    // See if recovery is needed on the volume
                    //

                    wcscpy(PathName, VolBuffer + VolOffset);
                    wcscat(PathName, EFSDIR);
                    TryRecoverVol(VolBuffer + VolOffset, PathName);
                    while (*(VolBuffer + VolOffset++));

                }
            } else {

                HANDLE EventHandleLog = RegisterEventSource(
                                                NULL,
                                                EFSSOURCE
                                                );

                if ( EventHandleLog ){
                    ReportEvent(
                        EventHandleLog,
                        EVENTLOG_ERROR_TYPE,
                        0,
                        EFS_GET_VOLUMES_ERROR,
                        NULL,
                        0,
                        4,
                        NULL,
                        &RetCode
                        );
                    DeregisterEventSource( EventHandleLog );

                }


                if ( CR_REGISTRY_ERROR == RetCode ){

                    //
                    // Map CR error to winerror
                    //

                    RetCode = ERROR_REGISTRY_CORRUPT;

                }
            }

            SafeAllocaFree( VolBuffer );
            SafeAllocaFree( PathName );

        } else {

            SafeAllocaFree( PathName );
            SafeAllocaFree( VolBuffer );

            RetCode =  ERROR_NOT_ENOUGH_MEMORY;

        }
    } else {

        DWORD  RetCode1 = GetLastError();
        HANDLE EventHandleLog = RegisterEventSource(
                                    NULL,
                                    EFSSOURCE
                                    );


        if ( EventHandleLog ){
            ReportEvent(
                EventHandleLog,
                EVENTLOG_ERROR_TYPE,
                0,
                EFS_PNP_NOT_READY,
                NULL,
                0,
                4,
                NULL,
                &RetCode1
                );
            DeregisterEventSource( EventHandleLog );

        }

        if ( CR_REGISTRY_ERROR == RetCode1 ){

            //
            // Map CR error to winerror
            //

            RetCode = ERROR_REGISTRY_CORRUPT;

        }
    }

    FreeLibrary( hCfgMgr );

    return RetCode;
}


void
TryRecoverVol(
    IN const WCHAR *VolumeName,
    IN WCHAR *CacheDir
    )
/*++
Routine Description:

    Do the possible recovery jobs caused by
    power outage or crash during encryption or decryption on the volume.

Arguments:

    VolumeName -- volume name to be checked.

    CacheDir -- EFSCACHE dir. The buffer can be used in this routine.

Return Value:

    None.

--*/
{
    HANDLE EfsCacheDir;
    LPWIN32_FIND_DATA   FindFileInfo;
    HANDLE  FindHandle;

    //
    // Check if the directory EFSCACHE exist or not
    //

    EfsCacheDir = CreateFile(
            CacheDir,
            GENERIC_READ,
            FILE_SHARE_READ,
            NULL,
            OPEN_EXISTING,
            FILE_FLAG_BACKUP_SEMANTICS,
            0
            );
    
    if (EfsCacheDir == INVALID_HANDLE_VALUE){
    //
    //  No recovery needed
    //
    
    return;
    }

    CloseHandle(EfsCacheDir);

    //
    //  Search the possible log file
    //

    SafeAllocaAllocate(FindFileInfo, sizeof ( WIN32_FIND_DATA ));

    ASSERT(FindFileInfo);
    if ( NULL == FindFileInfo )
    {
        return;
    }

    wcscat(CacheDir, EFSLOGPATTERN);

    FindHandle =  FindFirstFile( CacheDir, FindFileInfo );

    if (FindHandle == INVALID_HANDLE_VALUE)
    {
        //
        //  No LogFile found. No recovery needed
        //

        SafeAllocaFree(FindFileInfo);
        return;
    }

    //
    // Log file found. FT procedure begins
    //
    HANDLE EventHandleLog = RegisterEventSource(NULL,
                                                EFSSOURCE);

    if ( EventHandleLog )
    {
        //
        // Error in handling Event Log should not prevent real FT job.
        //

        ReportEvent(
            EventHandleLog,
            EVENTLOG_INFORMATION_TYPE,
            0,
            EFS_FT_STARTED,
            NULL,
            0,
            0,
            NULL,
            NULL
            );
    }

    for (;;)
    {
        BOOL b;

        //
        // Our log file name should be less than 12.
        //

        if (wcslen(FindFileInfo->cFileName) <= 12) {
            TryRecoverFile( VolumeName, FindFileInfo, EventHandleLog );
        }

        b = FindNextFile( FindHandle, FindFileInfo );

        if ( !b )
        {
            break;
        }
    }

    if ( EventHandleLog )
    {
        DeregisterEventSource( EventHandleLog );
    }

    SafeAllocaFree( FindFileInfo);
    FindClose( FindHandle );
    return;
}


void
TryRecoverFile(
    IN const WCHAR *VolumeName,
    IN LPWIN32_FIND_DATA   FindFileInfo,
    IN HANDLE  EventHandleLog
    )
/*++
Routine Description:

    Do the possible recovery jobs caused by
    power outage or crash during encryption or decryption for the file.

Arguments:

    VolumeName -- volume name the log file is in.

    FindFileInfo -- Information about this log file.

Return Value:

    None.

--*/
{
    WCHAR   *FileName = NULL;
    HANDLE  LogFile = INVALID_HANDLE_VALUE;
    HANDLE  TmpFile = NULL;
    HANDLE  Target;
    HANDLE  VolumeHandle = INVALID_HANDLE_VALUE;
    LPWSTR  TargetName;
    LPWSTR  TmpName = NULL;
    LOGHEADER   FileHeader;
    ULONG   SectorSize;
    BYTE    *ReadBuffer = NULL;
    BYTE    *StatusBuffer = NULL;
    BOOL    b;
    ULONG   BufferSize;
    DWORD   BytesRead;
    ULONG   CheckSum;
    EFS_ACTION_STATUS   Action;
    NTSTATUS Status;
    UNICODE_STRING FileId;

    VolumeHandle = CreateFile(VolumeName,
                              GENERIC_READ,
                              FILE_SHARE_READ | FILE_SHARE_WRITE,
                              NULL,
                              OPEN_EXISTING,
                              FILE_FLAG_BACKUP_SEMANTICS,
                              0);

    if ( INVALID_HANDLE_VALUE == VolumeHandle )
    {
        //
        // Directory on this volume opened successfully. It is unlikely that we will
        // come here.
        //

        return;
    }

    SafeAllocaAllocate(FileName, MAX_PATH_LENGTH);

    //
    //  Out of memory is unlikely at the boot time
    //

    ASSERT (FileName);
    if ( NULL == FileName )
    {
        goto Cleanup;
    }

    //
    // Construct the log file name.  FindFileInfo->cFileName has been limited by the caller
    // that the max length is 12. So the following wcscat should be OK.
    //

    wcscpy( FileName, VolumeName );
    wcscat( FileName,  EFSDIR );
    wcscat( FileName, L"\\");
    wcscat( FileName,  FindFileInfo->cFileName);

    LogFile = CreateFile(
                    FileName,
                    GENERIC_READ | GENERIC_WRITE | DELETE,
                    0,
                    NULL,
                    OPEN_EXISTING,
                    0,
                    0
                    );

    if ( INVALID_HANDLE_VALUE == LogFile )
    {
        DWORD   ErrCode = GetLastError();

        if ( EventHandleLog )
        {
            ReportEvent(
                EventHandleLog,
                EVENTLOG_ERROR_TYPE,
                0,
                EFS_OPEN_LOGFILE_ERROR,
                NULL,
                0,
                4,
                NULL,
                &ErrCode
                );
        }

        goto Cleanup;
    }

    b = ReadFile(
        LogFile,
        &FileHeader,
        sizeof( LOGHEADER ),
        &BytesRead,
        NULL
        );

    if ( !b )
    {
        //
        //  File IO error
        //
        DWORD   ErrCode = GetLastError();

        if ( EventHandleLog ){
            ReportEvent(
                EventHandleLog,
                EVENTLOG_ERROR_TYPE,
                0,
                EFS_READ_LOGFILE_ERROR,
                NULL,
                0,
                4,
                NULL,
                &ErrCode
                );
        }

        goto Cleanup;
    }

    if ( 0 == BytesRead ){

        //
        // Zero length log file. Nothing started. Delete it.
        //

        MarkFileForDelete( LogFile );
        goto Cleanup;
    }

    if ( (BytesRead < sizeof( LOGHEADER )) ||
         (LOGSIGLEN * sizeof (WCHAR) != RtlCompareMemory(
                                &(FileHeader.SIGNATURE[0]),
                                LOGSIG,
                                LOGSIGLEN * sizeof (WCHAR)
                                        )) ||
          ( LOGVERID != FileHeader.VerID )){
        //
        // Probably not our log file
        //

        if ( EventHandleLog ){
            ReportEvent(
                EventHandleLog,
                EVENTLOG_INFORMATION_TYPE,
                0,
                EFS_LOGFILE_FORMAT_ERROR,
                NULL,
                0,
                0,
                NULL,
                NULL
                );
        }

        goto Cleanup;
    }

    //
    //  Read in the whole header to continue the process
    //

    SectorSize = FileHeader.SectorSize;
    BufferSize = FileHeader.HeaderBlockSize;

    ASSERT( BufferSize % SectorSize == 0 );

    SafeAllocaAllocate(ReadBuffer, BufferSize);

    //
    // StatusBuffer must be aligned for cached IO.
    // LsapAllocateLsaHeap() is not aligned.
    //

    if ((FileHeader.Flag & LOG_DIRECTORY) == 0) {
        StatusBuffer = (BYTE *) VirtualAlloc(
                                NULL,
                                FileHeader.OffsetStatus2 - FileHeader.OffsetStatus1,
                                MEM_COMMIT,
                                PAGE_READWRITE
                                );
    } else {
        StatusBuffer = NULL;
    }

    ASSERT( (FileHeader.OffsetStatus2 - FileHeader.OffsetStatus1) % SectorSize == 0 );
    ASSERT( ReadBuffer );

    if ( (NULL == ReadBuffer) || ((NULL == StatusBuffer) && ((FileHeader.Flag & LOG_DIRECTORY) == 0)) )
    {
        //
        //  Out of memory is almost impossible during the boot time.
        //

        goto Cleanup;
    }

    SetFilePointer( LogFile, 0, NULL, FILE_BEGIN);

    b = ReadFile(
        LogFile,
        ReadBuffer,
        BufferSize,
        &BytesRead,
        NULL
        );

    if ( !b || ( BytesRead != BufferSize ) ){

        //
        //  File IO error, Should sent out some debug Info?
        //

        DWORD   ErrCode = GetLastError();

        if ( EventHandleLog ){
            ReportEvent(
                EventHandleLog,
                EVENTLOG_ERROR_TYPE,
                0,
                EFS_READ_LOGFILE_ERROR,
                NULL,
                0,
                4,
                NULL,
                &ErrCode
                );
        }

        goto Cleanup;
    }

    CheckSum = GetCheckSum(ReadBuffer, FileHeader.HeaderSize );
    if (CheckSum == *(ULONG* ) (ReadBuffer + BufferSize - sizeof(ULONG))){
        OBJECT_ATTRIBUTES Obja;
        IO_STATUS_BLOCK IoStatusBlock;

        //
        //  The header is in good condition. Get TargetName and TmpName for the error
        //  msg in system log.
        //

        TargetName = (WCHAR *)( ReadBuffer + FileHeader.TargetFilePathOffset );

        if ( (FileHeader.Flag & LOG_DIRECTORY) == 0 )
        {
            //
            // Operation was on File not on Directory
            // The real status is in Status block. Read in the status block.
            // Log file may updated. We need to reopen it with non-cached IO.
            //

            CloseHandle( LogFile );
            LogFile = CreateFile(FileName,
                                 GENERIC_READ | GENERIC_WRITE | DELETE,
                                 0,
                                 NULL,
                                 OPEN_EXISTING,
                                 FILE_FLAG_NO_BUFFERING,
                                 0);

            //
            //  Log File name is done. We are going to use FileName memory space
            //  to get a temp file name.
            //

            if ( INVALID_HANDLE_VALUE == LogFile )
            {
                //
                // Log File cannot be open as non-cached IO. Try next time.
                // This is weird.
                //
                DWORD   ErrCode = GetLastError();

                ASSERT (FALSE);

                if ( EventHandleLog )
                {
                    ReportEvent(
                        EventHandleLog,
                        EVENTLOG_ERROR_TYPE,
                        0,
                        EFS_OPEN_LOGFILE_NC_ERROR,
                        NULL,
                        0,
                        4,
                        NULL,
                        &ErrCode
                        );
                }

                goto Cleanup;
            }

            //
            // Open the temp file first.
            //

            TmpName = (WCHAR *)( ReadBuffer + FileHeader.TempFilePathOffset );
            FileId.Buffer = (WCHAR *) &(FileHeader.TempFileInternalName);
            FileId.Length = FileId.MaximumLength = sizeof (LARGE_INTEGER);
            InitializeObjectAttributes(
                &Obja,
                &FileId,
                0,
                VolumeHandle,
                NULL
                );

            Status = NtCreateFile(
                        &TmpFile,
                        GENERIC_READ | GENERIC_WRITE | SYNCHRONIZE,
                        &Obja,
                        &IoStatusBlock,
                        NULL,
                        0,
                        0,
                        FILE_OPEN,
                        FILE_OPEN_BY_FILE_ID | FILE_NON_DIRECTORY_FILE | FILE_SYNCHRONOUS_IO_NONALERT | FILE_OPEN_REPARSE_POINT,
                        NULL,
                        0
                        );

            if (NT_SUCCESS( Status )){

                OBJECT_NAME_INFORMATION *ATempFileName;
                ULONG PathLength;

                //
                //  Temp file opened with File ID. File open by ID cannot be deleted. So
                //  we need to get a name and reopen it using the name with DELETE
                //  access
                //

                ATempFileName = (OBJECT_NAME_INFORMATION *)FileName;
                Status = NtQueryObject(
                    TmpFile,
                    ObjectNameInformation,
                    ATempFileName,
                    MAX_PATH_LENGTH,
                    &PathLength
                    );

                if ( NT_SUCCESS( Status ) ){

                    CloseHandle(TmpFile);
                    TmpFile = 0;
                    InitializeObjectAttributes(
                        &Obja,
                        &(ATempFileName->Name),
                        0,
                        0,
                        NULL
                        );

                    Status = NtCreateFile(
                                &TmpFile,
                                GENERIC_READ | GENERIC_WRITE | SYNCHRONIZE | DELETE,
                                &Obja,
                                &IoStatusBlock,
                                NULL,
                                0,
                                0,
                                FILE_OPEN,
                                FILE_NON_DIRECTORY_FILE | FILE_SYNCHRONOUS_IO_NONALERT | FILE_OPEN_REPARSE_POINT,
                                NULL,
                                0
                                );

                    if (!NT_SUCCESS( Status )){

                        //
                        //  Well, we cannot open with the name got. Strange.
                        //  Reopen it with File ID. Temp file is not going to be deleted.
                        //

                        ASSERT(FALSE);
                        if ( EventHandleLog ){

                            LPWSTR lpStrings[2];
                            lpStrings[1] = TargetName;
                            lpStrings[0] = TmpName;

                            ReportEvent(
                                EventHandleLog,
                                EVENTLOG_WARNING_TYPE,
                                0,
                                EFS_TMP_OPEN_NAME_ERROR,
                                NULL,
                                2,
                                4,
                                (LPCTSTR *) &lpStrings[0],
                                &Status
                                );
                        }

                        InitializeObjectAttributes(
                            &Obja,
                            &FileId,
                            0,
                            VolumeHandle,
                            NULL
                            );

                        Status = NtCreateFile(
                                    &TmpFile,
                                    GENERIC_READ | GENERIC_WRITE | SYNCHRONIZE,
                                    &Obja,
                                    &IoStatusBlock,
                                    NULL,
                                    0,
                                    0,
                                    FILE_OPEN,
                                    FILE_OPEN_BY_FILE_ID | FILE_NON_DIRECTORY_FILE | FILE_SYNCHRONOUS_IO_NONALERT | FILE_OPEN_REPARSE_POINT,
                                    NULL,
                                    0
                                    );

                        if (!NT_SUCCESS( Status )){

                            //
                            //  Well, more strange. We cannot even open the file we opened
                            //  Nothing we can do this time. Try next time.
                            //

                            if ( EventHandleLog ){

                                LPWSTR lpStrings[2];
                                lpStrings[1] = TargetName;
                                lpStrings[0] = TmpName;

                                ReportEvent(
                                    EventHandleLog,
                                    EVENTLOG_WARNING_TYPE,
                                    0,
                                    EFS_TMP_FILEID_ERROR,
                                    NULL,
                                    2,
                                    4,
                                    (LPCTSTR*) &lpStrings[0],
                                    &Status
                                    );
                            }

                            goto Cleanup;
                        }
                    }
                } else {

                    if ( EventHandleLog ){

                        LPWSTR lpStrings[2];
                        lpStrings[0] = TargetName;
                        lpStrings[1] = TmpName;

                        ReportEvent(
                            EventHandleLog,
                            EVENTLOG_WARNING_TYPE,
                            0,
                            EFS_TMP_FILENAME_ERROR,
                            NULL,
                            2,
                            4,
                            (LPCTSTR*) &lpStrings[0],
                            &Status
                            );
                    }

                }

                //
                //  If a name cannot be got, the following apply.
                //  Temp file is existed. But we cannot get a name. Weird.
                //  The recover will go on. But the temp file will not be deleted
                //

            } else {

                //
                // Temp file is not exist. May be deleted by our operations.
                //  Make sure the handle is 0.
                //

                TmpFile = 0;
            }

            Status = ReadLogFile(
                            LogFile,
                            StatusBuffer,
                            FileHeader.OffsetStatus1,
                            FileHeader.OffsetStatus2
                            );

            if (!NT_SUCCESS( Status )) {

                //
                // Status copies are not valid.  Nothing have started or we can do nothing
                // to recover. Delete the log file.
                //

                MarkFileForDelete( LogFile );

                goto Cleanup;
            }

            Action =  * (EFS_ACTION_STATUS *) (StatusBuffer + sizeof (ULONG));

        } else {

            //
            //  Operations were on a directory
            //

            if ( FileHeader.Flag & LOG_DECRYPTION ){

                Action = BeginDecryptDir;

            } else {

                Action = BeginEncryptDir;

            }
        }

        //
        // Open the target file.
        //

        FileId.Buffer = (WCHAR* ) &(FileHeader.TargetFileInternalName);
        FileId.Length = FileId.MaximumLength = sizeof (LARGE_INTEGER);
        InitializeObjectAttributes(
            &Obja,
            &FileId,
            0,
            VolumeHandle,
            NULL
            );

        Status = NtCreateFile(
                    &Target,
                    GENERIC_READ | GENERIC_WRITE | SYNCHRONIZE ,
                    &Obja,
                    &IoStatusBlock,
                    NULL,
                    0,
                    0,
                    FILE_OPEN,
                    FILE_OPEN_BY_FILE_ID | FILE_SYNCHRONOUS_IO_NONALERT | FILE_OPEN_REPARSE_POINT,
                    NULL,
                    0
                    );

        if (!NT_SUCCESS( Status )) {

            //
            // OOPS! We can not open the target. What can we do without the target.
            // Delete the log file.
            //

            if ( EventHandleLog ){

                ReportEvent(
                    EventHandleLog,
                    EVENTLOG_WARNING_TYPE,
                    0,
                    EFS_TARGET_OPEN_ERROR,
                    NULL,
                    1,
                    4,
                    (LPCTSTR*) &TargetName,
                    &Status
                    );
            }

            MarkFileForDelete( LogFile );

            goto Cleanup;
        }

        //
        //  We survived so far. Now is the show time!
        //

        DoRecover(
            Target,
            TmpFile,
            LogFile,
            TargetName,
            TmpName,
            FileHeader.OffsetStatus2 - FileHeader.OffsetStatus1,
            FileHeader.OffsetStatus1,
            Action,
            EventHandleLog
            );

        CloseHandle ( Target );

    } else {

        //
        // The header is not fully written. Nothing could have be done.
        // Just delete the log file and we are done.
        //

        MarkFileForDelete( LogFile );
    }

Cleanup:

    if (VolumeHandle != INVALID_HANDLE_VALUE)
    {
        CloseHandle( VolumeHandle );
    }

    if (LogFile != INVALID_HANDLE_VALUE)
    {
        CloseHandle( LogFile );
    }

    if (TmpFile != NULL)
    {
        CloseHandle( TmpFile );
    }

    SafeAllocaFree(FileName);
    SafeAllocaFree(ReadBuffer);

    if (StatusBuffer)
    {
        VirtualFree(StatusBuffer,
                    0,
                    MEM_RELEASE);
    }

    return;
}


NTSTATUS
ReadLogFile(
    IN HANDLE LogFile,
    OUT BYTE* ReadBuffer,
    IN ULONG FirstCopy,
    IN ULONG SecondCopy
    )
/*++
Routine Description:

    Read Status Log Information.

Arguments:

    LogFile -- A handle to the log file

    ReadBuffer -- Buffer for the output data.

    FirstCopy -- Offset of first status information copy in the logfile.

    SecondCopy -- Offset of second status information copy in the logfile.

Return Value:

    The status of operation.
--*/
{
    ULONG ReadBytes;
    NTSTATUS Status;
    IO_STATUS_BLOCK IoStatusBlock;
    LARGE_INTEGER ByteOffset;
    ULONG CheckSum;
    BOOLEAN WrongCheckSum = FALSE;


    //
    //  Write out the header sector
    //
    ByteOffset.QuadPart = (LONGLONG) FirstCopy;
    ReadBytes = SecondCopy - FirstCopy;

    Status = NtReadFile(
                    LogFile,
                    0,
                    NULL,
                    NULL,
                    &IoStatusBlock,
                    ReadBuffer,
                    ReadBytes,
                    &ByteOffset,
                    NULL
                    );

    if ( NT_SUCCESS(Status) ) {

        //
        // Check the integrity of the data
        //


        CheckSum = GetCheckSum( ReadBuffer, 2 * sizeof (ULONG)  );
        if ( CheckSum != *(ULONG *)( ReadBuffer + ReadBytes - sizeof (ULONG) )){

            WrongCheckSum =  TRUE;

        }

    }

    if ( !NT_SUCCESS(Status) || WrongCheckSum ) {

        ByteOffset.QuadPart = (LONGLONG) SecondCopy;
        Status = NtReadFile(
                        LogFile,
                        0,
                        NULL,
                        NULL,
                        &IoStatusBlock,
                        ReadBuffer,
                        ReadBytes,
                        &ByteOffset,
                        NULL
                        );

        if ( NT_SUCCESS(Status) ) {

            //
            // Check the integrity of the data
            //


            CheckSum = GetCheckSum( ReadBuffer, 2 * sizeof (ULONG)  );
            if ( CheckSum != *(ULONG *)( ReadBuffer + ReadBytes - sizeof (ULONG) )){

                //
                //  Both status copy are bad.
                //

                Status =  STATUS_FILE_CORRUPT_ERROR;
            }
        }
    }

    return Status;
}

NTSTATUS
DoRecover(
    IN HANDLE Target,
    IN HANDLE TmpFile  OPTIONAL,
    IN HANDLE LogFile,
    IN LPCWSTR  TargetName,
    IN LPCWSTR  TmpName OPTIONAL,
    IN ULONG StatusCopySize,
    IN ULONG StatusStartOffset,
    IN ULONG   Action,
    IN HANDLE  EventHandleLog
    )
/*++
Routine Description:

    Do the real dirty recovery job here.

Arguments:

    Target -- A handle to the target file or directory.

    TmpFile -- A handle to the temp file if Target is a file.

    LogFile -- A handle to the log file.

    TargetName -- Target file name. This info is used for error log only.

    TmpName -- Temp backup file name. This info is used for error log only.

    StatusCopySize -- Log file status copy section size.

    StatusStartOffset --  Offset of status copy in the log file.

    Action -- The status to begin.

    EventHandleLog -- Event log handle.

Return Value:

    The status of operation.
--*/
{

    NTSTATUS Status = STATUS_SUCCESS;
    EFSP_OPERATION Operation = EncryptRecovering;

    if ( ( BeginEncryptDir == Action ) || ( BeginDecryptDir == Action ) ){

        //
        // In both cases, we will do Decrypt on the directory
        //

        Status = DecryptDir( Target, TargetName );
        if ( NT_SUCCESS(Status) ) {

            //
            // The operation was successful
            //
            if ( EventHandleLog ){

                ReportEvent(
                    EventHandleLog,
                    EVENTLOG_INFORMATION_TYPE,
                    0,
                    EFS_TARGET_RECOVERED,
                    NULL,
                    1,
                    0,
                    (LPCTSTR*) &TargetName,
                    NULL
                    );
            }

            MarkFileForDelete( LogFile );

        } else {

            //
            //  EFS driver might not be loaded. Log the information.
            //

            if ( EventHandleLog ){

                ReportEvent(
                    EventHandleLog,
                    EVENTLOG_ERROR_TYPE,
                    0,
                    EFS_DRIVER_MISSING,
                    NULL,
                    1,
                    0,
                    (LPCTSTR*) &TargetName,
                    NULL
                    );
            }
        }
    }  else {

        //
        // File operations
        //

        switch ( Action ) {
            case EncryptionMessup:

                //
                //  The original file is messed up due to the unknown reason.
                //  Operation required,
                //      Same as  EncryptTmpFileWritten.
                //

                Operation = EncryptRecovering;

                // ***** Fall through intended *****

            case DecryptTmpFileWritten:

                //
                //  Temp file is created and written during the decryption. The original file is probably
                //  damaged. Operation required,
                //      Same as the EncryptTmpFileWritten. The file will end up as plain text.
                //

                if ( DecryptTmpFileWritten == Action ){
                    Operation = DecryptRecovering;
                }

                //
                // ***** Fall through intended *****
                //

            case EncryptTmpFileWritten:

                if ( EncryptTmpFileWritten == Action ){

                    Operation = EncryptRecovering;

                }

                //
                //  Temp file is created and written during the encryption. The original file is probably
                //  damaged. Operation required,
                //      FSCTL decrypt each stream, copy the data back to the original file. Log file
                //      will be updated to BeginEncryptFile after all the streams are copied back. Then
                //      continue the case indicated in BeginEncryptFile.
                //
                if ( !TmpFile ){

                    //
                    //  Temp backup not existed or open failed, we can do nothing for this.
                    //  Log the error information and quit.
                    //
                    if ( EventHandleLog ){

                        LPCWSTR lpStrings[2];
                        lpStrings[1] = TargetName;
                        lpStrings[0] = TmpName;

                        ReportEvent(
                            EventHandleLog,
                            EVENTLOG_ERROR_TYPE,
                            0,
                            EFS_TMPFILE_MISSING,
                            NULL,
                            2,
                            4,
                            &lpStrings[0],
                            &Status
                            );
                    }

                    return STATUS_NO_SUCH_FILE;
                }

                Status = RestoreTarget(
                            Target,
                            TmpFile,
                            TargetName,
                            TmpName,
                            EventHandleLog,
                            Operation
                            );

                if ( NT_SUCCESS(Status) ) {

                    WriteLogFile(
                        LogFile,
                        StatusCopySize,
                        StatusStartOffset,
                        BeginEncryptFile
                        );

                } else {

                    return Status;

                }

                // ***** Fall through intended *****

            case DecryptionDone:

                //
                //  All the streams are marked decrypted. The file might still have the flag set.
                //  Operation required,
                //      Same as BeginEncryptFile.
                //

                // ***** Fall through intended *****

            case EncryptionBackout:

                //
                //  Encryption failed but we managed the original streams back. The file might
                //  be in a transition status.
                //  Operation required,
                //      Same as BeginEncryptFile.
                //

                // ***** Fall through intended *****

            case BeginEncryptFile:

                //
                //  File encryption just begin. Original file is not changed.
                //  Operation required,
                //      Remove the $EFS, remove the tempfile if existed and remove the log file.
                //

                Status = SendGenFsctl(
                                        Target,
                                        EFS_DECRYPT_FILE,
                                        EFS_DECRYPT_FILE,
                                        EFS_SET_ENCRYPT,
                                        FSCTL_SET_ENCRYPTION
                                        );

                if ( NT_SUCCESS(Status) ) {

                    if ( TmpFile ){
                        MarkFileForDelete( TmpFile );
                    }
                    MarkFileForDelete( LogFile );

                    if ( EventHandleLog ){

                        ReportEvent(
                            EventHandleLog,
                            EVENTLOG_INFORMATION_TYPE,
                            0,
                            EFS_TARGET_RECOVERED,
                            NULL,
                            1,
                            0,
                            &TargetName,
                            NULL
                            );
                    }
                } else {

                    //
                    //  EFS driver may not be loaded. Write the log info.
                    //

                    if ( EventHandleLog ){

                        ReportEvent(
                            EventHandleLog,
                            EVENTLOG_ERROR_TYPE,
                            0,
                            EFS_DRIVER_MISSING,
                            NULL,
                            1,
                            0,
                            &TargetName,
                            NULL
                            );
                    }
                }

                break;

            case BeginDecryptFile:

                //
                //  File decryption just begin. Original file is not changed.
                //  Operation required,
                //      Set the transition status to normal, remove the tempfile if existed and
                //      remove the log file.
                //

                // ***** Fall through intended *****

            case EncryptionDone:

                //
                //  All the streams were encrypted. The original file might be in transition status.
                //  Operation required,
                //      FSCTL to set the transition status to normal. Update the log status to
                //      EncryptionSrcDone. Continue to EncryptionSrcDone.
                //

                Status = SendGenFsctl(
                                        Target,
                                        0,
                                        0,
                                        EFS_ENCRYPT_DONE,
                                        FSCTL_ENCRYPTION_FSCTL_IO
                                        );

                if ( !NT_SUCCESS(Status) ) {

                    //
                    //  EFS driver might not be loaded. Log error.
                    //

                    if ( EventHandleLog ){

                        ReportEvent(
                            EventHandleLog,
                            EVENTLOG_ERROR_TYPE,
                            0,
                            EFS_DRIVER_MISSING,
                            NULL,
                            1,
                            0,
                            &TargetName,
                            NULL
                            );
                    }
                    return Status;

                }

                // ***** Fall through intended *****

            case EncryptionSrcDone:

                //
                //  The original file is encrypted successfully. The temp file might still be left.
                //  Operation required,
                //      Remove the temp file if existed and remove the log file.
                //

                if ( TmpFile ){
                    MarkFileForDelete( TmpFile );
                }
                MarkFileForDelete( LogFile );

                if ( EventHandleLog ){

                    ReportEvent(
                        EventHandleLog,
                        EVENTLOG_INFORMATION_TYPE,
                        0,
                        EFS_TARGET_RECOVERED,
                        NULL,
                        1,
                        0,
                        &TargetName,
                        NULL
                        );
                }
                break;

            default:

                //
                // Not our log file or tempered by someone.
                // Write to the log to notify the user.
                //

                Status = STATUS_FILE_CORRUPT_ERROR;
                break;
        }
    }

    return Status;
}

NTSTATUS
DecryptDir(
    IN HANDLE Target,
    IN LPCWSTR  TargetName
    )
/*++
Routine Description:

    Decrypt a directory.

Arguments:

    Target -- A handle to the target file or directory.

    TargetName -- Target file name. This info is used for error log only.

Return Value:

    The status of operation.
--*/
{
    NTSTATUS Status = STATUS_SUCCESS;

    Status = SendGenFsctl(
                            Target,
                            EFS_DECRYPT_STREAM,
                            EFS_DECRYPT_DIRSTR,
                            EFS_SET_ENCRYPT,
                            FSCTL_SET_ENCRYPTION
                            );

    if ( NT_SUCCESS( Status ) ){

        Status = SendGenFsctl(
                                Target,
                                EFS_DECRYPT_FILE,
                                EFS_DECRYPT_DIRFILE,
                                EFS_SET_ENCRYPT,
                                FSCTL_SET_ENCRYPTION
                                );
    }

    return Status;

}

NTSTATUS
RestoreTarget(
    IN HANDLE   Target,
    IN HANDLE   TmpFile,
    IN LPCWSTR   TargetName,
    IN LPCWSTR   TmpName,
    IN HANDLE   EventHandleLog,
    EFSP_OPERATION Operation
    )
/*++
Routine Description:

    Copy all the streams in the temp backup file to the original target file.

Arguments:

    Target -- A handle to the target file or directory.

    TmpFile -- A handle to the temp file if Target is a file.

    TargetName -- Target file name. This info is used for error log only.

    TmpName -- Temp backup file name. This info is used for error log only.

    Operation -- Indicate if encryption or decryption was tried.

Return Value:

    The status of operation.
--*/
{
    NTSTATUS Status;
    DWORD hResult;
    PFILE_STREAM_INFORMATION StreamInfoBase = NULL;
    ULONG   StreamInfoSize = 0;
    ULONG   StreamCount = 0;
    PEFS_STREAM_SIZE  StreamSizes;
    PHANDLE  StreamHandles;
    PUNICODE_STRING StreamNames;

    Status = GetStreamInformation(
                 TmpFile,
                 &StreamInfoBase,
                 &StreamInfoSize
                 );

    if ( NT_SUCCESS( Status ) ){
        hResult = OpenFileStreams(
                    TmpFile,
                    FILE_SHARE_DELETE,        // have to share with delete-ers, since the main stream is open for delete
                    OPEN_FOR_FTR,
                    StreamInfoBase,
                    FILE_READ_DATA | FILE_WRITE_DATA | FILE_READ_ATTRIBUTES | FILE_WRITE_ATTRIBUTES | SYNCHRONIZE,
                    FILE_OPEN,
                    FILE_SYNCHRONOUS_IO_NONALERT | FILE_OPEN_REPARSE_POINT,
                    NULL,
                    &StreamNames,      // Free this but not the contents!
                    &StreamHandles,    // Free this
                    &StreamSizes,      // Free this
                    &StreamCount
                    );

        if (hResult == ERROR_SUCCESS){
            PHANDLE  TargetStreamHandles;
            LONG   ArrIndex;

            SafeAllocaAllocate(TargetStreamHandles, StreamCount * sizeof (HANDLE));

            if ( TargetStreamHandles ){

                //
                // Open streams at the original target file
                //
                for ( ArrIndex = 0; ArrIndex < (LONG) StreamCount; ArrIndex++){
                    if ( StreamHandles[ArrIndex] == TmpFile ){
                        TargetStreamHandles[ArrIndex] = Target;
                    } else {
                        OBJECT_ATTRIBUTES Obja;
                        IO_STATUS_BLOCK IoStatusBlock;

                        InitializeObjectAttributes(
                            &Obja,
                            &StreamNames[ArrIndex],
                            0,
                            Target,
                            NULL
                            );

                        Status = NtCreateFile(
                                    &TargetStreamHandles[ArrIndex],
                                    GENERIC_READ | GENERIC_WRITE | SYNCHRONIZE,
                                    &Obja,
                                    &IoStatusBlock,
                                    NULL,
                                    0,
                                    0,
                                    FILE_OPEN_IF,
                                    FILE_NON_DIRECTORY_FILE | FILE_SYNCHRONOUS_IO_NONALERT | FILE_OPEN_REPARSE_POINT,
                                    NULL,
                                    0
                                    );
                        if (!NT_SUCCESS( Status )){

                            if ( EventHandleLog ){

                                ReportEvent(
                                    EventHandleLog,
                                    EVENTLOG_ERROR_TYPE,
                                    0,
                                    EFS_TARGET_STREAM_OPEN_ERROR,
                                    NULL,
                                    1,
                                    4,
                                    &TargetName,
                                    &Status
                                    );
                            }

                            break;
                        }
                    }
                }

                if ( NT_SUCCESS( Status ) ){
                    ULONG  FsInputDataSize;
                    PUCHAR FsInputData;

                    //
                    //  Adjust ArrIndex for clean up
                    //

                    ArrIndex--;

                    //
                    //  Make a FSCTL request input data block
                    //

                    FsInputDataSize = 7 * sizeof( ULONG ) + 2 * sizeof(DriverSessionKey);

                    SafeAllocaAllocate(FsInputData, FsInputDataSize);

                    if ( FsInputData )
                    {
                        BOOLEAN CleanupSuccessful;

                        ( VOID )GetDecryptFsInput(
                                    Target,
                                    FsInputData,
                                    &FsInputDataSize
                                    );

                        hResult = CopyFileStreams(
                                     StreamHandles,     // handles to streams on the backup file
                                     TargetStreamHandles, // Handles to the streams on the original file
                                     StreamCount,       // number of streams
                                     StreamSizes,       // sizes of streams
                                     Operation,         // mark StreamHandles as Decrypted before copy
                                     FsInputData,         // FSCTL input data
                                     FsInputDataSize,     // FSCTL input data size
                                     &CleanupSuccessful
                                     );

                        SafeAllocaFree( FsInputData );

                        if ( hResult != ERROR_SUCCESS )
                        {
                            if ( EventHandleLog ){

                                ReportEvent(
                                    EventHandleLog,
                                    EVENTLOG_ERROR_TYPE,
                                    0,
                                    EFS_STREAM_COPY_ERROR,
                                    NULL,
                                    1,
                                    4,
                                    &TargetName,
                                    &hResult
                                    );
                            }

                            Status = STATUS_UNSUCCESSFUL;
                        }
                    }
                    else
                    {
                        //
                        //  Out of memory. Almost impossible during LSA init.
                        //

                        ASSERT(FALSE);
                        Status = STATUS_INSUFFICIENT_RESOURCES;
                    }
                }

                //
                //  Clean up TargetStreamHandles at the target.
                //

                while (ArrIndex >= 0)
                {
                    if ( TargetStreamHandles[ArrIndex] != Target )
                    {
                        CloseHandle(TargetStreamHandles[ArrIndex]);
                    }

                    ArrIndex--;
                }

                SafeAllocaFree( TargetStreamHandles );
            }

            //
            //  Clean up StreamHandles and etc.
            //

            for (ArrIndex = 0; ArrIndex< (LONG) StreamCount ; ArrIndex++) {
                if ( StreamHandles[ArrIndex] != TmpFile){
                    NtClose( StreamHandles[ArrIndex] );
                }
            }

            LsapFreeLsaHeap( StreamHandles);
            LsapFreeLsaHeap( StreamNames);
            LsapFreeLsaHeap( StreamSizes);

        } else {

            //
            //  Not all the requested streams could be opened.
            //  Write the log info.
            //
            if ( EventHandleLog ){

                LPCWSTR lpStrings[2];
                lpStrings[1] = TargetName;
                lpStrings[0] = TmpName;

                ReportEvent(
                    EventHandleLog,
                    EVENTLOG_ERROR_TYPE,
                    0,
                    EFS_TMP_STREAM_OPEN_ERROR,
                    NULL,
                    2,
                    4,
                    &lpStrings[0],
                    &hResult
                    );
            }

            Status = STATUS_UNSUCCESSFUL;
        }

        LsapFreeLsaHeap( StreamInfoBase );

    }  else {

        //
        //  Stream info cannot be got. Write LOG info.
        //
        if ( EventHandleLog ){

            LPCWSTR lpStrings[2];
            lpStrings[1] = TargetName;
            lpStrings[0] = TmpName;

            ReportEvent(
                EventHandleLog,
                EVENTLOG_ERROR_TYPE,
                0,
                EFS_TMP_STREAM_INFO_ERROR,
                NULL,
                2,
                4,
                &lpStrings[0],
                &Status
                );
        }

    }

    return Status;
}

BOOL
ParseRecoveryCertificate(
    IN  PEFS_PUBLIC_KEY_INFO  pPublicKeyInfo,
    OUT PBYTE               * pbHash,
    OUT PDWORD                cbHash,
    OUT PBYTE               * pbPublicKey,
    OUT PDWORD                cbPublicKey,
    OUT LPWSTR              * lpDisplayInfo,
    OUT PCCERT_CONTEXT      * pCertContext,
    OUT PSID                * pSid
    )

/*++

Routine Description:

    This routine takes a certificate passed in the recovery policy and
    extracts the interesting information.

Arguments:

    pPublicKeyInfo - Takes the public key info structure from the
        recovery policy.

    pbHash - Returns the hash of the passed certificate.

    cbHash - Returns the lengh in bytes of the returned hash.

    pbPublicKey - Returns a pointer to the public key blob of the certificate.

    cbPublicKey - Returns the length in bytes of the public key.

    lpDisplayInfo - Returns display information about the certificate.

    pCertContext - Cert context for the passed certificate.

    pSid - Returns SID of the recovery agent

Return Value:

    TRUE on success, FALSE on failure.  Call GetLastError() for more details.

--*/

{
    //
    // Get the certificate out of the public key info structure
    //


    PEFS_PUBLIC_KEY_INFO pAlignedPublicKeyInfo;
    BOOLEAN freeAlignedInfo;
    DWORD rc = ERROR_SUCCESS;

    rc =  EfsAlignBlock(
                    pPublicKeyInfo,
                    (PVOID *)&pAlignedPublicKeyInfo,
                    &freeAlignedInfo
                    );
    if (!pAlignedPublicKeyInfo) {

        //
        // OOM. Treat it as not current.
        //

        rc = ERROR_NOT_ENOUGH_MEMORY;
        return FALSE;

    }

    ASSERT( pAlignedPublicKeyInfo->KeySourceTag == EfsCertificate );

    //
    // Initialize OUT parameters
    //

    *pbHash        = NULL;
    *pbPublicKey   = NULL;
    *lpDisplayInfo = NULL;
    *pCertContext  = NULL;
    *pSid          = NULL;


    PBYTE pbCert = (PBYTE)OFFSET_TO_POINTER(CertificateInfo.Certificate, pAlignedPublicKeyInfo);
    DWORD cbCert = pAlignedPublicKeyInfo->CertificateInfo.CertificateLength;

    *pCertContext = CertCreateCertificateContext(
                          CRYPT_ASN_ENCODING,
                          (const PBYTE)pbCert,
                          cbCert);

    if (*pCertContext) {

        PCERT_INFO pCertInfo = (*pCertContext)->pCertInfo;
        CERT_PUBLIC_KEY_INFO * pSubjectPublicKeyInfo = &pCertInfo->SubjectPublicKeyInfo;
        CRYPT_BIT_BLOB * PublicKey = &pSubjectPublicKeyInfo->PublicKey;

        *cbPublicKey = 0;

        if (CryptDecodeObject(
                CRYPT_ASN_ENCODING,
                RSA_CSP_PUBLICKEYBLOB,
                PublicKey->pbData,
                PublicKey->cbData,
                0,
                NULL,
                cbPublicKey
                )) {

            if (*pbPublicKey = (PBYTE)LsapAllocateLsaHeap( *cbPublicKey )) {

                if (CryptDecodeObject(
                        CRYPT_ASN_ENCODING,
                        RSA_CSP_PUBLICKEYBLOB,
                        PublicKey->pbData,
                        PublicKey->cbData,
                        0,
                        *pbPublicKey,
                        cbPublicKey
                        )) {

                    //
                    // Get the certificate hash
                    //

                    *cbHash = 0;

                    if (CertGetCertificateContextProperty(
                                 *pCertContext,
                                 CERT_HASH_PROP_ID,
                                 NULL,
                                 cbHash
                                 )) {

                        *pbHash = (PBYTE)LsapAllocateLsaHeap( *cbHash );

                        if (*pbHash) {

                            if (CertGetCertificateContextProperty(
                                         *pCertContext,
                                         CERT_HASH_PROP_ID,
                                         *pbHash,
                                         cbHash
                                         )) {

                                //
                                // Get the display information
                                //

                                *lpDisplayInfo = EfspGetCertDisplayInformation( *pCertContext );

                                if (*lpDisplayInfo == NULL) {

                                    rc = GetLastError();
                                }

                                //
                                // Try to get the recovery agent SID
                                // This info is not very important. If we fail, we should continue.
                                //

                                if (pAlignedPublicKeyInfo->PossibleKeyOwner) {

                                    DWORD SidLength;
                                    PSID  RecSid = (PSID) OFFSET_TO_POINTER( PossibleKeyOwner, pAlignedPublicKeyInfo );

                                    SidLength = GetLengthSid(RecSid);
                                    *pSid = (PSID)LsapAllocateLsaHeap( SidLength );
                                    if (*pSid) {
                                        RtlCopyMemory( *pSid, RecSid, SidLength );
                                    }
                                }


                            } else {

                                rc = GetLastError();
                            }

                        } else {

                            rc = ERROR_NOT_ENOUGH_MEMORY;
                        }

                    } else {

                        rc = GetLastError();
                    }

                } else {

                    rc = GetLastError();
                }

            } else {

                rc = ERROR_NOT_ENOUGH_MEMORY;
            }

        } else {

            rc = GetLastError();
        }

    } else {

        rc = GetLastError();
    }

    if (freeAlignedInfo) {
        LsapFreeLsaHeap( pAlignedPublicKeyInfo );
    }

    if (rc != ERROR_SUCCESS) {

        //
        // Free the stuff we were going to return
        //

        if (*pbHash != NULL) {
            LsapFreeLsaHeap( *pbHash );
            *pbHash = NULL;
        }

        if (*pbPublicKey != NULL) {
            LsapFreeLsaHeap( *pbPublicKey );
            *pbPublicKey = NULL;
        }

        if (*lpDisplayInfo != NULL) {
            LsapFreeLsaHeap( *lpDisplayInfo );
            *lpDisplayInfo = NULL;
        }

        if (*pCertContext != NULL) {
            CertFreeCertificateContext( *pCertContext );
            *pCertContext = NULL;
        }

        if (*pSid != NULL) {
            LsapFreeLsaHeap( *pSid );
            *pSid = NULL;
        }
    }

    SetLastError( rc );

    return( rc == ERROR_SUCCESS );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\base\lsa\server\efssrv.cxx ===
/*++

Copyright (c) 1997-1999  Microsoft Corporation

Module Name:

    efssrv.cxx                                             

Abstract:

    EFS (Encrypting File System) Server

Author:

    Robert Reichel      (RobertRe)     
    Robert Gu           (RobertG)

Environment:

Revision History:

--*/

#include <lsapch.hxx>

extern "C" {
#include <nt.h>
#include <ntdef.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <stdio.h>
#include <efsstruc.h>
#include <lmaccess.h>
#include <lmcons.h>
#include <lmapibuf.h>
#include <userenv.h>
#include <userenvp.h>
#include "lsasrvp.h"
#include "debug.h"
#include "efssrv.hxx"
#include "userkey.h"
}

//#define ProfilingEfs

#define ALGORITHM_ID      TEXT("AlgorithmID")
#define KEYCACHEPERIOD    TEXT("KeyCacheValidationPeriod")
#define FIPSPOLICY        TEXT("FipsAlgorithmPolicy")
#define EFSCONFIG         TEXT("EfsConfiguration")
#define EFSLASTGOODCONFIG TEXT("LastGoodEfsConfiguration")
#define USERCACHELIMIT    TEXT("UserCacheSize")
#define RSAKEYLENGTH      TEXT("RSAKeyLength")


//
// The following key GPOSTATUSKEY is a temp solution. GPO should provide an API to tell people
// if the GP propagation succeeded or not.
//

#define GPOSTATUSKEY      TEXT("SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Winlogon\\GPExtensions\\{35378EAC-683F-11D2-A89A-00C04FBBCFA2}")
#define GPSTATUS          TEXT("Status")

//
// EFS key
//

#define EFSMACHINEKEY     TEXT("SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\EFS")
#define EFSPOLKEY         TEXT("SOFTWARE\\Policies\\Microsoft\\Windows NT\\CurrentVersion\\EFS")

#define POLICYUSEFIPS     1
#define DISABLEEFS        0x00000001

// Default cache length is 3600 seconds

#define MAXCACHELENGTH    86400 * 7  // Max cache period - 7 Days. We only check time valid.
#define MINCACHELENGTH    1800       // Min cache period - 0.5 Hours

#define MINCACHESIZE      5          // Cache node number
#define MAXCACHESIZE      150        // Default on Pro is 5 On server is 100

#define TIME_UNIT 10000000         // 1 TIME_UNIT == 1 second
#define MAX_RSA_KEY_LENGTH   16384    // Max RSA Key Length

extern LONG RecoveryCertIsValidating;
extern HANDLE EfsWaitHandle;

///////////////////////////////////////////////////////////////////////////////
//                                                                            /
// Define how long our FEKs can be.  An FEK will be allocated into a fixed    /
// size buffer, but only a certain number of bits of entropy may be used in   /
// the export version.                                                        /
//                                                                            /
///////////////////////////////////////////////////////////////////////////////

//
// This number affects the FEK generation algorithm.  It represents the number
// of bits of entropy in the key.
//

const EXPORT_KEY_STRENGTH = 56;
const DOMESTIC_KEY_STRENGTH = 128;
const EXPORT_DESX_SALT_LENGTH = 9;
const DES3_KEY_STRENGTH = 168;
const AES_KEY_STRENGTH_256 = 256;

const DWORD WAITFORCERTVALIDATE = 10000;

#ifndef LSASRV_EXPORT

    const DWORD KeyEntropy = DOMESTIC_KEY_STRENGTH;

#else

    const DWORD KeyEntropy = EXPORT_KEY_STRENGTH;

#endif

LONG EFSDebugLevel = 0;


ALG_ID  EfsAlgInForce = CALG_AES_256;
DWORD   RsaKeyLength = RSA1024BIT_KEY;
extern "C" BOOLEAN EfsDisabled = FALSE;

//
// Current recovery policy
//

RTL_RESOURCE RecoveryPolicyResource;

CURRENT_RECOVERY_POLICY CurrentRecoveryPolicy;

DWORD   MissingRecoveryPolicyLogged = 0;

//
// Functions in EFSAPI.CXX
//

BOOLEAN
EncryptFSCTLData(
    IN ULONG Fsctl,
    IN ULONG Psc,
    IN ULONG Csc,
    IN PVOID EfsData,
    IN ULONG EfsDataLength,
    IN OUT PUCHAR Buffer,
    IN OUT PULONG BufferLength
    );

BOOLEAN
SendHandle(
    IN HANDLE Handle,
    IN OUT PUCHAR EfsData,
    IN OUT PULONG EfsDataLength
    );

BOOLEAN
SendEfs(
    IN PEFS_KEY Fek,
    IN PEFS_DATA_STREAM_HEADER Efs,
    OUT PUCHAR EfsData,
    OUT PULONG EfsDataLength
    );

BOOLEAN
SendHandleAndEfs(
    IN HANDLE Handle,
    IN PEFS_DATA_STREAM_HEADER Efs,
    IN OUT PUCHAR EfsData,
    IN OUT PULONG EfsDataLength
    );

//
// Function prototypes in this module
//

BOOLEAN
CreatePublicKeyInformationThumbprint(
    IN PSID  pUserSid,
    IN PBYTE pbCertHash,
    IN DWORD cbCertHash,
    IN LPWSTR lpDisplayInformation OPTIONAL,
    IN LPWSTR ContainerName OPTIONAL,
    IN LPWSTR ProviderName OPTIONAL,
    OUT PEFS_PUBLIC_KEY_INFO * PublicKeyInformation
    );

PBYTE
EncryptFEK(
    IN PEFS_KEY Fek,
    IN HCRYPTKEY hRSAKey,
    OUT PDWORD dwEncryptedFEKLength
    );

PEFS_KEY
ExtractFek(
    IN PEFS_USER_INFO pEfsUserInfo,
    IN PENCRYPTED_KEY EncryptedKey,
    IN BOOL CheckBits
    );

DWORD
ConstructEncryptedKey(
    IN PBYTE EncryptedFEK,
    IN DWORD dwEncryptedFEKLength,
    IN PEFS_PUBLIC_KEY_INFO PublicKeyInformation,
    IN PEFS_KEY_SALT pEfsKeySalt,
    OUT PENCRYPTED_KEY *EncryptedKey,
    IN OUT PDWORD EncryptedKeySize
    );

DWORD
ConstructKeyRing(
    IN PEFS_KEY Fek,
    IN DWORD KeyCount,
    IN LPWSTR KeyNames[] OPTIONAL,
    IN LPWSTR ProviderNames[] OPTIONAL,
    IN PBYTE PublicKeys[],
    IN DWORD PublicKeyLengths[],
    IN PBYTE pbHashes[],
    IN DWORD cbHashes[],
    IN LPWSTR lpDisplayInformation[],
    IN PSID  pSid[],
    IN BOOLEAN PublicKeyHandle,
    OUT PENCRYPTED_KEYS *KeyRing,
    OUT PDWORD KeyRingLength
    );

DWORD
InitRecoveryPolicy(
    VOID
    );

VOID
DumpPublicKeyInfo(
    PEFS_PUBLIC_KEY_INFO PublicKeyInfo
    );

void
DumpRecoveryKey(
    PRECOVERY_KEY_1_1 pRecoveryKey
    );

PEFS_DATA_STREAM_HEADER
AssembleEfsStream(
    IN PENCRYPTED_KEYS pDDF,
    IN DWORD cbDDF,
    IN PENCRYPTED_KEYS pDRF,
    IN DWORD cbDRF,
    IN PEFS_KEY Fek
    );

PENCRYPTED_KEY
GetEncryptedKeyByIndex(
    PENCRYPTED_KEYS pEncryptedKeys,
    DWORD KeyIndex
    );

BOOL
DeleteEncryptedKeyByIndex(
   IN PEFS_DATA_STREAM_HEADER pEfs,
   IN DWORD KeyIndex,
   IN PEFS_KEY Fek,
   OUT PEFS_DATA_STREAM_HEADER * pNewEfs
   );

BOOLEAN
EqualEncryptedKeys(
    IN PENCRYPTED_KEYS SrcKeys, 
    IN PENCRYPTED_KEYS DstKeys, 
    IN DWORD           cbDstKeys
  );

//
// Server
//

VOID
EfsGetRegSettings(
    VOID
    )
/*++

Routine Description:

    This routine is called during server initialization to set
    the EFS encryption algorithm.
    
Arguments:

    None.

Return Value:

    None.

--*/
{
    LONG rc;
    HKEY EfsKey;
    DWORD AlgId;
    DWORD CacheLength;
    DWORD CacheSize;
    DWORD EfsConfig;
    DWORD SizeInfo;
    DWORD Type;
    DWORD RSAKeyLen;
    

    rc = RegOpenKeyEx( HKEY_LOCAL_MACHINE,
                       TEXT("SYSTEM\\CurrentControlSet\\Control\\LSA"),
                       0,
                       GENERIC_READ,
                       &EfsKey
                     );

    if (rc == ERROR_SUCCESS) {

        SizeInfo = sizeof(DWORD);
        rc = RegQueryValueEx(
                EfsKey,
                FIPSPOLICY,
                NULL,
                &Type,
                (PUCHAR) &AlgId,
                &SizeInfo
                );

        if (rc == ERROR_SUCCESS) {

            if ( AlgId== POLICYUSEFIPS ) {
                EfsAlgInForce = CALG_3DES;
            }

        }
        RegCloseKey( EfsKey );
    }

    rc = RegOpenKeyEx( HKEY_LOCAL_MACHINE,
                       EFSMACHINEKEY,
                       0,
                       GENERIC_READ,
                       &EfsKey
                     );
    if (rc == ERROR_SUCCESS) {

        if (EfsAlgInForce == CALG_AES_256) {

            //
            // FIPS Policy does not say we have to use FIPS. Let's check if user says EFS
            // should use specific algorithm.
            //

            SizeInfo = sizeof(DWORD);
            rc = RegQueryValueEx(
                    EfsKey,
                    ALGORITHM_ID,
                    NULL,
                    &Type,
                    (PUCHAR) &AlgId,
                    &SizeInfo
                    );
    
            if (rc == ERROR_SUCCESS) {
                switch (AlgId) {
    
                    case CALG_3DES:
    
                        EfsAlgInForce = CALG_3DES; //0x6603
                        break;
    
                    case CALG_DESX:
                        EfsAlgInForce = CALG_DESX; //0x6604
                        break;
    
                    case CALG_AES_256:
    
                        //
                        // Fall through intended
                        //
    
                    default:
                        // EfsAlgInForce = CALG_AES_256;//0x6610
                        break;
    
                }
            }
    
        }

        SizeInfo = sizeof(DWORD);
        rc = RegQueryValueEx(
                EfsKey,
                KEYCACHEPERIOD,
                NULL,
                &Type,
                (PUCHAR) &CacheLength,
                &SizeInfo
                );

        if (rc == ERROR_SUCCESS) {
            if ((CacheLength >= MINCACHELENGTH) && (CacheLength <= MAXCACHELENGTH)){
                CACHE_CERT_VALID_TIME = CacheLength * TIME_UNIT;
            }
        }

        SizeInfo = sizeof(DWORD);
        rc = RegQueryValueEx(
                EfsKey,
                USERCACHELIMIT,
                NULL,
                &Type,
                (PUCHAR) &CacheSize,
                &SizeInfo
                );

        if (rc == ERROR_SUCCESS) {
            if ((CacheSize >= MINCACHESIZE) && (CacheSize <= MAXCACHESIZE)){
                UserCacheListLimit = CacheSize;
            }
        }

        //
        // Check key length
        //

        SizeInfo = sizeof(DWORD);
        rc = RegQueryValueEx(
                EfsKey,
                RSAKEYLENGTH,
                NULL,
                &Type,
                (PUCHAR) &RSAKeyLen,
                &SizeInfo
                );

        if (rc == ERROR_SUCCESS) {
            if ((RSAKeyLen > 1024) && (RSAKeyLen <= MAX_RSA_KEY_LENGTH)){

                //
                // Key length must be multiple of 8
                //

                RSAKeyLen &= 0x0000FFF8;
                RsaKeyLength = RSAKeyLen << 16;

            }
        }


        
        
        //
        // Check if EFS is disabled in Policy
        //

        SizeInfo = sizeof(DWORD);
        rc = RegQueryValueEx(
                EfsKey,
                EFSCONFIG,
                NULL,
                &Type,
                (PUCHAR) &EfsConfig,
                &SizeInfo
                );

        if (rc == ERROR_SUCCESS) {
            if (EfsConfig & DISABLEEFS){
                EfsDisabled = TRUE;
            }
        }
        RegCloseKey( EfsKey );

    }
}

BOOL
EfsIsGpoGood(
    VOID
    )
/*++

Routine Description:

    This is a temp workaround to check if GP propagation succeeded or not.
    
    GP should provide an API to do this.
        
Arguments:

    Not used.

Return Value:

    None.

--*/
{
    LONG rc;
    HKEY PolKey;
    DWORD SizeInfo;
    DWORD PolStatus = 0;
    DWORD Type;
    BOOL  GoodPol = TRUE;

    rc = RegOpenKeyEx( HKEY_LOCAL_MACHINE,
                       GPOSTATUSKEY,
                       0,
                       GENERIC_READ,
                       &PolKey
                     );

    if (rc == ERROR_SUCCESS) {
    
        //
        // Check if EFS is disabled in Policy
        //

        SizeInfo = sizeof(DWORD);
        rc = RegQueryValueEx(
                PolKey,
                GPSTATUS,
                NULL,
                &Type,
                (PUCHAR) &PolStatus,
                &SizeInfo
                );

        if (rc == ERROR_SUCCESS) {
            if (PolStatus) {

                //
                //Last policy propagation failed
                //

                GoodPol = FALSE;
            }
        } else {

            //
            // Assuming last propagation failed
            //

            GoodPol = FALSE;
        }

        RegCloseKey( PolKey );

    } else {

        GoodPol = FALSE;
        
    }

    return GoodPol;
    
}

VOID
EfsRemoveKey(
    VOID
    )
/*++

Routine Description:

    This routine removes EFS Last Good Policy Key.
        
Arguments:

    No.
    
Return Value:

    No.
    
--*/
{

    LONG rc;
    HKEY EfsKey;

    rc = RegOpenKeyEx( HKEY_LOCAL_MACHINE,
                   EFSMACHINEKEY,
                   0,
                   GENERIC_READ | KEY_SET_VALUE,
                   &EfsKey
                 );

    if (rc == ERROR_SUCCESS) {

        //
        // Delete the last good key
        //

        RegDeleteValue(
            EfsKey,            
            EFSLASTGOODCONFIG
            );

        RegCloseKey( EfsKey );

    } 
}

BOOL
EfsApplyGoodPolicy(
    IN BOOLEAN* pEfsDisabled
    )
/*++

Routine Description:

    This routine is a common routine to apply good policy data.
        
Arguments:

    pEfsDisabled -- Point to the global EfsDisabled. 
    
Return Value:

    TRUE if we applied the data. FALSE if no data available.

--*/
{

    LONG rc;
    HKEY EfsKey;
    HKEY EfsPolKey;
    DWORD EfsConfig;
    DWORD SizeInfo;
    DWORD Type;
    BOOL PolicyValueApplied = FALSE;

    //
    // Open EFS policy key
    //

    rc = RegOpenKeyEx( HKEY_LOCAL_MACHINE,
                       EFSPOLKEY,
                       0,
                       GENERIC_READ,
                       &EfsPolKey
                     );

    if (rc == ERROR_SUCCESS) {

        //
        // Let's try to get the latest value
        //


        SizeInfo = sizeof(DWORD);
        rc = RegQueryValueEx(
                EfsPolKey,
                EFSCONFIG,
                NULL,
                &Type,
                (PUCHAR) &EfsConfig,
                &SizeInfo
                );

        if (rc == ERROR_SUCCESS) {

            PolicyValueApplied = TRUE;

            if (EfsConfig & DISABLEEFS){

                if (!(*pEfsDisabled)) {
                    *pEfsDisabled = TRUE;
                }

            } else {

                if (*pEfsDisabled) {
                    *pEfsDisabled = FALSE;
                }

            }

            //
            // We need to update our LAST Good key.
            //

            DWORD Disposition = 0;
                    
            rc = RegCreateKeyEx(
                     HKEY_LOCAL_MACHINE,
                     EFSMACHINEKEY,
                     0,
                     TEXT("REG_SZ"),
                     REG_OPTION_NON_VOLATILE,
                     KEY_ALL_ACCESS,
                     NULL,
                     &EfsKey,
                     &Disposition    // address of disposition value buffer
                     );

            if (rc == ERROR_SUCCESS) {

                //
                // OK. Let's upadte the value
                //

                RegSetValueEx(
                    EfsKey,
                    EFSLASTGOODCONFIG,
                    0,
                    REG_DWORD,
                    (CONST BYTE *)&EfsConfig,
                    sizeof(DWORD)
                    );

                RegCloseKey( EfsKey );

            }

        }

        RegCloseKey( EfsPolKey );

    } 
        
    return (PolicyValueApplied);

}

VOID
EfsApplyLastPolicy(
    IN BOOLEAN *pEfsDisabled
    )

/*++

Routine Description:

    This routine is called during boot init time.
        
Arguments:

    pEfsDisabled -- Point to the global EfsDisabled. May be changed to a structure pointer later
                    to support more EFS policy vars.

Return Value:

    None.

--*/
{

    LONG rc;
    HKEY EfsKey;
    DWORD EfsConfig;
    DWORD SizeInfo;
    DWORD Type;

    if (EfsIsGpoGood()) {

        //
        // We got a good policy.
        //

        BOOL PolicyValueApplied;

        PolicyValueApplied = EfsApplyGoodPolicy(
                                pEfsDisabled
                                );
            
        if (!PolicyValueApplied) {

            //
            // Policy key is missing or value removed. We need to delete the last good value.
            // The last good value could be non-existing. It does not hurt to try again during
            // the boot.
            //

            EfsRemoveKey();
        
        }

    } else {

        //
        // Last Policy propagation failed. Tried to get the last good one if there is one.
        //

        rc = RegOpenKeyEx( HKEY_LOCAL_MACHINE,
                       EFSMACHINEKEY,
                       0,
                       GENERIC_READ,
                       &EfsKey
                     );

        if (rc == ERROR_SUCCESS) {

            SizeInfo = sizeof(DWORD);
            rc = RegQueryValueEx(
                    EfsKey,
                    EFSLASTGOODCONFIG,
                    NULL,
                    &Type,
                    (PUCHAR) &EfsConfig,
                    &SizeInfo
                    );
    
            if (rc == ERROR_SUCCESS) {
                if (EfsConfig & DISABLEEFS){

                    if (!(*pEfsDisabled)) {
                        *pEfsDisabled = TRUE;
                    }

                } else {

                    if (*pEfsDisabled) {
                        *pEfsDisabled = FALSE;
                    }

                }
            }

            RegCloseKey( EfsKey );

        }
    }
}

VOID
EfsGetPolRegSettings(
    IN PVOID pEfsPolCallBack,
    IN BOOLEAN timeExpired
    )
/*++

Routine Description:

    This routine is called during policy propagation.
        
Arguments:

    pEfsDisabled -- Point to a structure EFS_POL_CALLBACK.
                    
    timeExpired -- FALSE if trigged by the event.

Return Value:

    None.

--*/
{

    LONG rc;
    HKEY EfsKey;
    DWORD EfsConfig;
    DWORD SizeInfo;
    DWORD Type;
    BOOLEAN * CrntEfsDisabled = ((PEFS_POL_CALLBACK) pEfsPolCallBack)->EfsDisable; 

    if (timeExpired) {

        //
        // May be killed.
        //

        if (*(((PEFS_POL_CALLBACK)pEfsPolCallBack)->EfsPolicyEventHandle)) {
            UnregisterGPNotification(*(((PEFS_POL_CALLBACK) pEfsPolCallBack)->EfsPolicyEventHandle));
            CloseHandle(*(((PEFS_POL_CALLBACK) pEfsPolCallBack)->EfsPolicyEventHandle));
            *(((PEFS_POL_CALLBACK) pEfsPolCallBack)->EfsPolicyEventHandle) = 0;
        }
        if (EfsWaitHandle) {
            RtlDeregisterWait(EfsWaitHandle);
            EfsWaitHandle = 0;
        }
        return;
    }

    if (EfsIsGpoGood()) {

        //
        // We got a good policy.
        //

        BOOL PolicyValueApplied;

        PolicyValueApplied = EfsApplyGoodPolicy(
                                CrntEfsDisabled
                                );
            
        if (!PolicyValueApplied) {

            //
            // Policy key is missing or value removed. We need to delete the last good value.
            //

            rc = RegOpenKeyEx( HKEY_LOCAL_MACHINE,
                           EFSMACHINEKEY,
                           0,
                           GENERIC_READ | KEY_SET_VALUE,
                           &EfsKey
                         );

            if (rc == ERROR_SUCCESS) {

                //
                // Set back the default value first.
                //

                SizeInfo = sizeof(DWORD);
                rc = RegQueryValueEx(
                        EfsKey,
                        EFSCONFIG,
                        NULL,
                        &Type,
                        (PUCHAR) &EfsConfig,
                        &SizeInfo
                        );
        
                if (rc == ERROR_SUCCESS) {
                    if (EfsConfig & DISABLEEFS){
    
                        if (!(*CrntEfsDisabled)) {
                            *CrntEfsDisabled = TRUE;
                        }
    
                    } else {
    
                        if (*CrntEfsDisabled) {
                            *CrntEfsDisabled = FALSE;
                        }
    
                    }
                } else {

                    //
                    // No default value is treated as enable EFS
                    //

                    if (*CrntEfsDisabled) {
                        *CrntEfsDisabled = FALSE;
                    }
                }

                //
                // Delete the last good key
                //

                RegDeleteValue(
                    EfsKey,            
                    EFSLASTGOODCONFIG
                    );

                RegCloseKey( EfsKey );

            } else {

                //
                // No default key value. Enable EFS if not now.
                //

                if (*CrntEfsDisabled) {
                    *CrntEfsDisabled = FALSE;
                }

            }

        }
    }
    

    if (EfsWaitHandle) {

        //
        // Unregister the last one
        //

        RtlDeregisterWait(EfsWaitHandle);
        EfsWaitHandle = 0;

        //
        // Reset the notification event
        //

        if (*(((PEFS_POL_CALLBACK) pEfsPolCallBack)->EfsPolicyEventHandle)) {

            ResetEvent(*(((PEFS_POL_CALLBACK) pEfsPolCallBack)->EfsPolicyEventHandle));


            //
            // Reregister for a new one
            //

            if (!NT_SUCCESS(RtlRegisterWait(
                                &EfsWaitHandle,
                                *(((PEFS_POL_CALLBACK)pEfsPolCallBack)->EfsPolicyEventHandle), 
                                EfsGetPolRegSettings, 
                                pEfsPolCallBack, 
                                INFINITE, 
                                WT_EXECUTEONLYONCE))){
        
                //
                //  We couldn't use the thread pool. 
                //
    
                UnregisterGPNotification(*(((PEFS_POL_CALLBACK)pEfsPolCallBack)->EfsPolicyEventHandle));
                CloseHandle(*(((PEFS_POL_CALLBACK) pEfsPolCallBack)->EfsPolicyEventHandle));
                *(((PEFS_POL_CALLBACK) pEfsPolCallBack)->EfsPolicyEventHandle) = 0;
    
            }
        }

    }

}


VOID
RecoveryInformationCallback(
    POLICY_NOTIFICATION_INFORMATION_CLASS ChangedInfoClass
    )
/*++

Routine Description:

    Callback for when EFS Recovery policy information changes

Arguments:

    ChangedInfoClass - The info class that changed.

Return Value:

    None.

--*/

{
    InitRecoveryPolicy();
    return;
}


VOID
EfspRoleChangeCallback(
    POLICY_NOTIFICATION_INFORMATION_CLASS ChangedInfoClass
    )
/*++

Routine Description:

    Callback for when the role of the machine in a domain changes.

Arguments:

    ChangedInfoClass - The info class that changed.

Return Value:

    None.

--*/

{
    NTSTATUS Status;
    PPOLICY_PRIMARY_DOMAIN_INFO PrimaryDomainInfo;

    Status = LsarQueryInformationPolicy(LsapPolicyHandle,
                                        PolicyPrimaryDomainInformation,
                                        (PLSAPR_POLICY_INFORMATION *)&PrimaryDomainInfo
                                        );
    if (!NT_SUCCESS(Status)) {
        DebugLog((DEB_ERROR, "Failed to query primary domain from Lsa, Status = 0x%lx\n", Status));
    } else {
        if (PrimaryDomainInfo->Sid != NULL) {
            EfspInDomain = TRUE;
        } else {
            EfspInDomain = FALSE;
        }

        LsaFreeMemory( PrimaryDomainInfo );
    }

    return;
}

#if 0

    //
    // We may revisit this function in inheritance work. Keep it for now.
    //


BOOL
GetPublicKey(
     HCRYPTKEY hKey,
     PBYTE * PublicKeyBlob,
     PDWORD KeyLength
     )
/*++

Routine Description:

    Exports a public key

Arguments:

    hKey - Supplies the key handle to be exported

    PublicKeyBlob - Returns a buffer containing the exported key

    KeyLength - Returns the length of the exported key buffer in bytes.

Return Value:

    TRUE on success, FALSE otherwise.

--*/
{
    *KeyLength = 0;
    *PublicKeyBlob = NULL;

    if (hKey == NULL) {
        ASSERT( FALSE );
        return( FALSE );
    }

    BOOL b = CryptExportKey( hKey, 0, PUBLICKEYBLOB, 0, NULL, KeyLength );

    if (b) {

        *PublicKeyBlob = (PBYTE) LsapAllocateLsaHeap( *KeyLength );

        if (*PublicKeyBlob != NULL) {

            b = CryptExportKey( hKey, 0, PUBLICKEYBLOB, 0, *PublicKeyBlob, KeyLength );

            if (!b) {

                LsapFreeLsaHeap( *PublicKeyBlob );
                *PublicKeyBlob = NULL;
            }

        } else {

            b = FALSE;
        }
    }

    return( b );
}
#endif

inline
VOID
AcquireRecoveryPolicyReadLock()
{
    BOOL b = RtlAcquireResourceShared( &RecoveryPolicyResource, TRUE );

    ASSERT( b );
}

inline
VOID
ReleaseRecoveryPolicyReadLock()
{
    RtlReleaseResource( &RecoveryPolicyResource );
}

inline
VOID
ReleaseRecoveryData()
{
    ReleaseRecoveryPolicyReadLock();
}



DWORD  
GetRecoveryData(
    OUT PDWORD   dwKeyCount,
    OUT PDWORD   dwPolicyStatus,
    OUT PBYTE  * pbPublicKeys[],
    OUT DWORD  * cbPublicKeys[],
    OUT PBYTE  * pbHashes[],
    OUT DWORD  * cbHashes[],
    OUT LPWSTR * lpDisplayInfo[] OPTIONAL,
    OUT PSID   * pSid[] OPTIONAL
    )
/*++

Routine Description:

    This routine returns the current recovery data.  It takes a read
    lock on the recovery data so that it cannot be modified while in use.
    This lock must be freed by calling ReleaseRecoveryData().

Arguments:

    dwKeyCount - Returns the list of keys in the current recovery data.
    
    dwPolicyStatus - The status of the recovery policy.

    pbPublicKeys - Returns an array of pointers to exported public key blobs that will be used
        to encrypt the FEK.

    cbPublicKeys - Specifies the length (in bytes) of each of the keys returned
        in the PublicKeys array.
      
    pbHashes - Returns an array of pointers to the key hashes.
    
    cbHashes - Specifies the length (in bytes) of each of the key hashes.
    
    lpDisplayInfo - Recovery cert display information.

    pSid - Sids of the recovery agents

Return Value:

    ERROR_SUCCESS for succeed.

--*/

{
    AcquireRecoveryPolicyReadLock();

    //
    // Verify that all of the cert contexts are still valid.
    //
    // If any of them fail, say that there is no recovery
    // policy on the system.
    //

    DWORD i;
    BOOLEAN fResult = TRUE;

    LARGE_INTEGER  TimeStamp;

    if ( (*dwPolicyStatus = CurrentRecoveryPolicy.PolicyStatus) < RECOVERY_POLICY_OK) {

        *dwKeyCount   = CurrentRecoveryPolicy.dwKeyCount;
        *pbPublicKeys = CurrentRecoveryPolicy.pbPublicKeys;
        *cbPublicKeys = CurrentRecoveryPolicy.cbPublicKeys;
        *pbHashes     = CurrentRecoveryPolicy.pbHash;
        *cbHashes     = CurrentRecoveryPolicy.cbHash;

        if (lpDisplayInfo) {
            *lpDisplayInfo = CurrentRecoveryPolicy.lpDisplayInfo;
        }

        if (pSid) {
            *pSid = CurrentRecoveryPolicy.pSid;
        }
    
        return( ERROR_SUCCESS );
    }

    TimeStamp.QuadPart = 0;

    //
    // Check if we need validate the certs again
    //

    if ((NT_SUCCESS( NtQuerySystemTime(&TimeStamp)) && 
        (TimeStamp.QuadPart - CurrentRecoveryPolicy.TimeStamp.QuadPart > CACHE_CERT_VALID_TIME )) ||
        (CurrentRecoveryPolicy.CertValidated == CERT_NOT_VALIDATED)){

        //
        // We only let one thread in here.
        //

        LONG IsCertBeingValidated;

        IsCertBeingValidated = InterlockedExchange(&RecoveryCertIsValidating, 1);

        if ((CurrentRecoveryPolicy.CertValidated == CERT_NOT_VALIDATED) && (IsCertBeingValidated == 1)) {

            //
            // If the recovery cert has not been validated and some other thread is validating, 
            // let's wait for a 10 seconds.
            //

            Sleep(WAITFORCERTVALIDATE);
            if (CurrentRecoveryPolicy.CertValidated == CERT_NOT_VALIDATED) {

                //
                // Not validated yet. Let's try to grab the lock. Let other thread to wait.
                //

                IsCertBeingValidated = InterlockedExchange(&RecoveryCertIsValidating, 1);
            }
            
        }

        if ( (IsCertBeingValidated != 1) || (CurrentRecoveryPolicy.CertValidated == CERT_NOT_VALIDATED) ) {

            //
            // No thread is validating the cert, let's do it
            //

            for (i=0; i<CurrentRecoveryPolicy.dwKeyCount; i++) {

                //
                // We only check the time in the cert
                //

                LONG CertTimeValid;

                if (CertTimeValid = CertVerifyTimeValidity(
                                        NULL,
                                        CurrentRecoveryPolicy.pCertContext[i]->pCertInfo
                                        )){
                    if ( CertTimeValid > 0 ) {

                        DebugLog((DEB_WARN, "Expired certificate in recovery policy\n"));
                        *dwPolicyStatus = RECOVERY_POLICY_EXPIRED_CERTS;

                        fResult = FALSE;
                        break;
                    } else {
                        DebugLog((DEB_WARN, "Expired certificate in recovery policy\n"));
                        *dwPolicyStatus = RECOVERY_POLICY_NOT_EFFECT_CERTS;

                        fResult = FALSE;
                        break;
                    }
                }

            }
    
            //
            // When policy is propagated, the write lock is acquired. When we get here, we are having read lock and no one
            // is having the write lock. It is OK for threads stepping each other on writing CertValidated and TimeStamp here.
            // We are checking the validation in hours, a fraction of a second window here can be ignored.
            //
    
            if (CurrentRecoveryPolicy.dwKeyCount && fResult) {
                CurrentRecoveryPolicy.CertValidated = CERT_VALIDATED;
            } else if ( CurrentRecoveryPolicy.dwKeyCount ) {
                CurrentRecoveryPolicy.CertValidated = CERT_VALIDATION_FAILED;
            }
    
            if (CurrentRecoveryPolicy.CertValidated != CERT_NOT_VALIDATED) {
                CurrentRecoveryPolicy.TimeStamp.QuadPart = TimeStamp.QuadPart;
            }

            if (IsCertBeingValidated != 1) {
                InterlockedExchange(&RecoveryCertIsValidating, IsCertBeingValidated);
            }

        }

    }

    if (CurrentRecoveryPolicy.CertValidated == CERT_VALIDATED) {

        *dwKeyCount   = CurrentRecoveryPolicy.dwKeyCount;
        *pbPublicKeys = CurrentRecoveryPolicy.pbPublicKeys;
        *cbPublicKeys = CurrentRecoveryPolicy.cbPublicKeys;
        *pbHashes     = CurrentRecoveryPolicy.pbHash;
        *cbHashes     = CurrentRecoveryPolicy.cbHash;

        if (lpDisplayInfo) {
            *lpDisplayInfo = CurrentRecoveryPolicy.lpDisplayInfo;
        }

        if (pSid) {
            *pSid = CurrentRecoveryPolicy.pSid;
        }

    } else {

        *dwKeyCount = 0;
    }

    if ( ((RECOVERY_POLICY_EXPIRED_CERTS == *dwPolicyStatus) || 
          (RECOVERY_POLICY_NOT_EFFECT_CERTS == *dwPolicyStatus)) && 
         ( 0 == MissingRecoveryPolicyLogged) ) {

        DWORD  eventID = EFS_INVALID_RECOVERY_POLICY_ERROR;

        //
        // Log the fail to get the recovery policy
        //

        MissingRecoveryPolicyLogged = 1;

        EfsLogEntry(
          EVENTLOG_ERROR_TYPE,
          0,
          eventID,
          0,
          0,
          NULL,
          NULL
          );
    }

    return( ERROR_SUCCESS );
}


BOOLEAN
ConstructEFS(
    PEFS_USER_INFO pEfsUserInfo,
    PEFS_KEY Fek,
    PEFS_DATA_STREAM_HEADER ParentEfsStreamHeader,
    PEFS_DATA_STREAM_HEADER * EfsStreamHeader
    )
/*++

Routine Description:

    This routine will construct an EFS stream.  It is intended to be used
    whenever an entire EFS stream is required, such as when a new file is
    created.

    An EFS stream contains a header, a DDF (which contains current user key
    information), and a DRF (which contains recovery information).

Arguments:

    Fek - Supplies a pointer to a partially filled in EFS_KEY structure,
        specifying the length of the desired key and the algorithm that
        will be used with the key to encrypt the file.

        It is important that the algorithm field be filled in, since this
        key will be eventually encrypted in its entirety, and all the fields
        must be present for that to work.

    ParentEfsStreamHeader - Supplies the EFS stream from the containing directory,
        if one exists.  This parameter is not currently used, because we do
        not support inheritance from directories to files (yet).

    EfsStreamHeader - Returns a pointer to an EFS_DATA_STREAM_HEADER which is
        the head of an EFS stream.  This header is followed by variable length
        data containing the actual EFS data.


Return Value:

--*/
{

    LPWSTR      ContainerName        = NULL;
    HCRYPTPROV  hProv                = 0;
    HCRYPTKEY   hUserKey             = 0;
    LPWSTR      lpDisplayInformation = NULL;
    LPWSTR      ProviderName         = NULL;
    DWORD       ProviderType         = 0;
    PUCHAR      PublicKey            = NULL;
    HCRYPTKEY   hWkUserKey           = NULL;
    DWORD       rc;

    PEFS_DATA_STREAM_HEADER EFS = NULL;

    DWORD       DRFLength            = 0;
    DWORD       DDFLength            = 0;

    PENCRYPTED_KEYS pDRF = NULL;
    PENCRYPTED_KEYS pDDF = NULL;

    PBYTE       pbHash;
    DWORD       cbHash;

    BOOLEAN     b                    = FALSE;

    //
    // To build the DDF, we need the user's current key from the registry.
    // This routine will get the key information from the registry and open
    // the context containing the key.
    //

    rc = GetCurrentKey(
             pEfsUserInfo,
             &hUserKey,
             &hProv,
             &ContainerName,
             &ProviderName,
             &ProviderType,
             &lpDisplayInformation,
             &pbHash,
             &cbHash
             );

    if (ERROR_SUCCESS == rc) {

        if (hUserKey) {
            hWkUserKey = hUserKey;
        } else {

            //
            // Use the key in the cache
            //

            ASSERT(pEfsUserInfo->pUserCache);
            ASSERT(pEfsUserInfo->pUserCache->hUserKey);

            hWkUserKey = pEfsUserInfo->pUserCache->hUserKey;

        }

    } else {

        SetLastError( rc );
        return( FALSE );
    }

    //
    // Before we exit, make sure to clean up ContainerName, ProviderName, pbHash, hUserKey, hProv
    //
    
    rc = GenerateDRF( Fek, &pDRF, &DRFLength);

    if (ERROR_SUCCESS == rc) {

        LPWSTR      lpWkContainerName;
        LPWSTR      lpWkDisplayInformation;
        LPWSTR      lpWkProviderName;
        PBYTE       pbWkHash;
        DWORD       cbWkHash;

        if (hUserKey) {

            //
            // Do not use the cache
            //

            lpWkContainerName = ContainerName;
            lpWkProviderName =  ProviderName;
            lpWkDisplayInformation = lpDisplayInformation;
            pbWkHash = pbHash;
            cbWkHash = cbHash;

        } else {

            //
            // Use the cache
            //

            lpWkContainerName = pEfsUserInfo->pUserCache->ContainerName;
            lpWkProviderName =  pEfsUserInfo->pUserCache->ProviderName;
            lpWkDisplayInformation = pEfsUserInfo->pUserCache->DisplayInformation;
            pbWkHash = pEfsUserInfo->pUserCache->pbHash;
            cbWkHash = pEfsUserInfo->pUserCache->cbHash;

        }

        rc = ConstructKeyRing(
                Fek,
                1,
                &lpWkContainerName,
                &lpWkProviderName,
                (PBYTE *)&hWkUserKey,
                NULL,
                &pbWkHash,
                &cbWkHash,
                &lpWkDisplayInformation,
                &(pEfsUserInfo->pTokenUser->User.Sid),
                TRUE,
                &pDDF,
                &DDFLength
                );

        if (ERROR_SUCCESS == rc) {

            DWORD EfsLength = DDFLength + DRFLength + sizeof( EFS_DATA_STREAM_HEADER );

            //
            // Efs has to be a multiple of 8 in length to encrypt properly.
            //

            EfsLength = (EfsLength + 7) & 0xfffffff8;

            EFS = (PEFS_DATA_STREAM_HEADER)LsapAllocateLsaHeap( EfsLength );

            if (EFS != NULL) {

                memset( EFS, 0, sizeof( EFS_DATA_STREAM_HEADER ));

                EFS->Length = EfsLength;
                EFS->State = 0;            // used by the server
                EFS->EfsVersion = EFS_CURRENT_VERSION;

                RPC_STATUS RpcStatus = UuidCreate ( &EFS->EfsId );

                if (RpcStatus == ERROR_SUCCESS || RpcStatus == RPC_S_UUID_LOCAL_ONLY) {

                    //
                    // A "local-only" UUID is ok in this case
                    //

                    EFS->DataDecryptionField = (ULONG)sizeof(EFS_DATA_STREAM_HEADER );
                    memcpy( (PENCRYPTED_KEYS)((PBYTE)EFS + sizeof( EFS_DATA_STREAM_HEADER )), pDDF, DDFLength );

                    if ( 0 == DRFLength) {
                        EFS->DataRecoveryField = 0;
                    } else {
                        EFS->DataRecoveryField = (ULONG)(sizeof(EFS_DATA_STREAM_HEADER ) + DDFLength);
                        memcpy( (PENCRYPTED_KEYS)((PBYTE)EFS + sizeof( EFS_DATA_STREAM_HEADER ) + DDFLength ), pDRF, DRFLength );
                    }

       /*
                    BOOLEAN f = EfspChecksumEfs( EFS, Fek );

                    ASSERT( f );

                    if (!f) {
                        rc = GetLastError();
                        ASSERT( rc != ERROR_SUCCESS );
                        LsapFreeLsaHeap( EFS );
                        *EfsStreamHeader = NULL;
                    } else {

                        //
                        // Everything worked, return success.
                        //

                        *EfsStreamHeader = EFS;
                        b = TRUE;
                    }
        */

                    *EfsStreamHeader = EFS;
                    b = TRUE;


                } else {

                    rc = RpcStatus;

                }
            } else {

                rc = GetLastError();

            }
        }

    }

    ReleaseRecoveryData();

    if (pDDF) {

        LsapFreeLsaHeap(pDDF);

    }

    if (pDRF) {

        LsapFreeLsaHeap(pDRF);
    }


    if (ContainerName) {

       //
       //  Defensive checking
       //

       LsapFreeLsaHeap( ContainerName );
    }
   
    if (ProviderName) {
       LsapFreeLsaHeap( ProviderName );
    }
   
    if (lpDisplayInformation) {
       LsapFreeLsaHeap( lpDisplayInformation );
    }
   
    if (PublicKey) {
       LsapFreeLsaHeap( PublicKey );
    }
   
    if (pbHash) {
       LsapFreeLsaHeap( pbHash );
    }

    if (hUserKey) {
       CryptDestroyKey( hUserKey );
    }
    if (hProv) {
       CryptReleaseContext( hProv, 0 );
    }

    if (EFSDebugLevel > 0) {
        DumpEFS( *EfsStreamHeader );
    }

    SetLastError( rc );


#if DBG

    if (!b) {
        ASSERT( rc != ERROR_SUCCESS );
    }

#endif

    return( b );

}


BOOLEAN
ConstructDirectoryEFS(
    IN PEFS_USER_INFO pEfsUserInfo,
    IN PEFS_KEY Fek,
    OUT PEFS_DATA_STREAM_HEADER * EfsStreamHeader
    )

/*++

Routine Description:

    This routine constructs the EFS stream for a directory.

Arguments:

    pEfsUserInfo - Supplies useful information about our caller.

    Fek - Supplies the Fek to put into the EFS stream.

    EfsStreamHeader - Returns a pointer to the new EFS stream.


Return Value:

    return-value - Description of conditions needed to return value. - or -
    None.

--*/
{
    return( ConstructEFS( pEfsUserInfo, Fek, NULL, EfsStreamHeader ) );
}



DWORD
ConstructKeyRing(
    IN PEFS_KEY Fek,
    IN DWORD KeyCount,
    IN LPWSTR KeyNames[] OPTIONAL,
    IN LPWSTR ProviderNames[] OPTIONAL,
    IN PBYTE PublicKeys[],
    IN DWORD PublicKeyLengths[],
    IN PBYTE pbHashes[],
    IN DWORD cbHashes[],
    IN LPWSTR lpDisplayInformation[],
    IN PSID pSid[],
    IN BOOLEAN PublicKeyHandle,
    OUT PENCRYPTED_KEYS *KeyRing,
    OUT PDWORD KeyRingLength
    )

/*++

Routine Description:

    This routine will construct a key ring (DDF or DRF) structure.  A keyring
    contains one or more ENCRYPTED_KEY structures, each of which represents
    an encoding of the FEK with a different user key.

    The caller is expected to call this routine twice, once to determine the
    length of the structure, and a second time to actually create the key ring
    structure.

    Note that the passed keys do not need to exist in the current context,
    and if we are building a DRF structure, most likely will not exist
    in the current context.

Arguments:

    Fek - Provides the unencrypted FEK for the file.

    KeyCount - Provides the number of keys that are going to be placed in this
        keyring.

    KeyNames - Provides an array of NULL-terminated WCHAR strings, each naming
        a key.

    ProviderNames - Provides an array of providers that is parallel to the
        KeyNames array.

    PublicKeys - Provides an array of pointers to PUBLICKEYBLOB structures,
        one for each named key.

    PublicKeyLengths - Provides an array of lengths of the PUBLICKEYBLOB
        structures pointed to by the PublicKeys array. It could also points to the key
        handle.

    pSid - Users' SIDs
    
    PublicKeyHandle - Indicate if PublicKeys point to PUBLICKEYBLOB or key handles.

    KeyRing - Returns a pointer to the constructed keyring.  If this parameter
        is NULL, only the length will be computed and returned.

    KeyRingLength - Provides the size of the passed KeyRing buffer, or or if the
        KeyRing pointer is NULL, the size of the buffer that must be passed in to
        return the KeyRing.

Return Value:

    ERROR_SUCCESS - Returned if successful.


    ERROR_NOT_ENOUGH_MEMORY - Some attempt to allocate memory from the local
        heap failed.

--*/

{
    //
    // For each Key passed in, import the public key blob
    // and export the session key encrypted with that blob.
    // The FEK will be encrypted with the same session key
    // in each entry.
    //

    PEFS_KEY_SALT pEfsKeySalt = NULL;

    PENCRYPTED_KEY * EncryptedKey = NULL;
    PDWORD           EncryptedKeySize;
    BOOL          GotPublicKey = TRUE;

    SafeAllocaAllocate(EncryptedKey, KeyCount * sizeof(PENCRYPTED_KEY));

    *KeyRing = NULL;

    if (EncryptedKey == NULL) {
        return( ERROR_NOT_ENOUGH_MEMORY );
    }

    SafeAllocaAllocate(EncryptedKeySize, KeyCount * sizeof( DWORD ));

    if (EncryptedKeySize == NULL) {

        SafeAllocaFree( EncryptedKey );
        return( ERROR_NOT_ENOUGH_MEMORY );
    }

    DWORD i;

    DWORD rc = ERROR_SUCCESS;

    for (i = 0 ; i<KeyCount ; i++) {

        EncryptedKey[i] = NULL;
        EncryptedKeySize[i] = 0;
    }

    for ( i = 0; i<KeyCount && rc==ERROR_SUCCESS ; i++ ) {

        //
        // Import the passed public key
        //

        HCRYPTKEY hXchgKey = 0;

        if (PublicKeyHandle) {

            GotPublicKey = TRUE;
            hXchgKey = (HCRYPTKEY)PublicKeys[i];

        } else {
            GotPublicKey = CryptImportKey( hProvVerify, PublicKeys[i], PublicKeyLengths[i], 0, CRYPT_EXPORTABLE, &hXchgKey );
        }

        if (GotPublicKey) {

            DWORD dwEncryptedFEKLength = 0;

            PBYTE EncryptedFEK = EncryptFEK( Fek, hXchgKey, &dwEncryptedFEKLength );

            if (EncryptedFEK == NULL) {

                rc = GetLastError();
                ASSERT( rc != ERROR_SUCCESS );

            } else {

                PEFS_PUBLIC_KEY_INFO PublicKeyInformation = NULL;

                LPWSTR KeyName;
                LPWSTR ProviderName;

                if (KeyNames && ProviderNames) {

                    KeyName = KeyNames[i];
                    ProviderName = ProviderNames[i];

                } else {

                    KeyName = NULL;
                    ProviderName = NULL;
                }

                if  (CreatePublicKeyInformationThumbprint(
                         pSid[i],
                         pbHashes[i],
                         cbHashes[i],
                         lpDisplayInformation[i],
                         KeyName,
                         ProviderName,
                         &PublicKeyInformation
                         )) {

                    if ( Fek->Entropy <= EXPORT_KEY_STRENGTH ){

                        DWORD SaltLength;
                        DWORD SaltBlockLength;

                        if (GetSaltLength(Fek->Algorithm, &SaltLength, &SaltBlockLength)){

                            pEfsKeySalt = (PEFS_KEY_SALT)LsapAllocateLsaHeap( sizeof( EFS_KEY_SALT ) + SaltBlockLength );
                            if (pEfsKeySalt){
                                pEfsKeySalt->Length = sizeof( EFS_KEY_SALT ) + SaltBlockLength;
                                pEfsKeySalt->SaltType = Fek->Algorithm;
                                RtlCopyMemory( (PBYTE)pEfsKeySalt + sizeof( EFS_KEY_SALT ),
                                                EFS_KEY_DATA( Fek ),
                                                SaltLength
                                              );
                            }
                        }

                    } else {
                        pEfsKeySalt = NULL;
                    }

                    if (pEfsKeySalt || (Fek->Entropy > EXPORT_KEY_STRENGTH)) {


                        rc = ConstructEncryptedKey( EncryptedFEK,
                                                    dwEncryptedFEKLength,
                                                    PublicKeyInformation,
                                                    pEfsKeySalt,
                                                    &EncryptedKey[i],
                                                    &EncryptedKeySize[i]
                                                    );

                    }


                    //
                    // Clean up output from CreatePublicKeyInformation
                    //

                    LsapFreeLsaHeap( PublicKeyInformation );
                    if (pEfsKeySalt){
                        LsapFreeLsaHeap( pEfsKeySalt );
                    }

                } else {

                    rc = GetLastError();
                }

                //
                // Clean up output from EncryptFEK
                //

                LsapFreeLsaHeap( EncryptedFEK );
            }

            //
            // If the we imported the key, don't need this key any more, get rid of it.
            //

            if (!PublicKeyHandle) {
                CryptDestroyKey( hXchgKey );
            }


        } else {

            //
            // Couldn't import a public key, pick up error code
            //

            rc = GetLastError();
        }


        if (rc != ERROR_SUCCESS) {

            //
            // Something failed along the way, clean up all previous allocations
            //

            for (DWORD j = 0; j < i ; j++ ) {
                if (EncryptedKey[j]) {
                    LsapFreeLsaHeap( EncryptedKey[j] );
                }
            }

            SafeAllocaFree( EncryptedKey );
            SafeAllocaFree( EncryptedKeySize );

            return( rc );
        }
    }


    //
    // We successfully created all of the EncryptedKey structures.  Assemble them
    // all into a KeyRing and return the result.
    //


    *KeyRingLength = 0;

    for (i=0 ; i<KeyCount ; i++) {
        *KeyRingLength += EncryptedKeySize[i];
    }

    *KeyRingLength += (sizeof ( ENCRYPTED_KEYS ) - sizeof( ENCRYPTED_KEY ));


    *KeyRing = (PENCRYPTED_KEYS)LsapAllocateLsaHeap( *KeyRingLength );

    if (NULL != *KeyRing) {

        (*KeyRing)->KeyCount = KeyCount;
    
        PBYTE Base = (PBYTE) &((*KeyRing)->EncryptedKey[0]);
    
        for (i=0 ; i<KeyCount ; i++) {
    
            memcpy( Base, EncryptedKey[i], EncryptedKey[i]->Length );
            Base += EncryptedKey[i]->Length;
        }
    
    } else {
        *KeyRingLength = 0;
        rc = ERROR_NOT_ENOUGH_MEMORY;
    }



    //
    // Clean everything up and return
    //

    for (i = 0; i<KeyCount ; i++ ) {
        LsapFreeLsaHeap( EncryptedKey[i] );
    }

    SafeAllocaFree( EncryptedKey );
    SafeAllocaFree( EncryptedKeySize );

    return( rc );
}


PEFS_KEY
GetFekFromEncryptedKeys(
    IN OUT PEFS_USER_INFO pEfsUserInfo,
    IN PENCRYPTED_KEYS Keys,
    IN BOOL CheckBits,
    OUT PDWORD KeyIndex
    )

/*++

Routine Description:

    This routine will attempt to decode the FEK from an ENCRYPTED_KEYS
    structure.  It will do this by iterating through all of the fields in the
    DRF and attempting to use each one to decrypt the FEK.

Arguments:

    pEfsUserInfo - User information.

    Keys - Provides the ENCRYPTED_KEYS to be examined.
    
    CheckBits - If we need to check international version or not. TRUE will check.
    
    KeyIndex - Which encrypted key is used.

Return Value:

    On success, returns a pointer to an FEK, which must be freed when no longer
    needed.  Returns NULL on error.

--*/
{
    DWORD rc = ERROR_DECRYPTION_FAILED;
    PEFS_KEY Fek = NULL;

    PENCRYPTED_KEY pAlignedKey = NULL;
    BOOLEAN freeAlignedKey = FALSE;
    DWORD   retCode;

    if (Keys != NULL) {

        __try {

            PENCRYPTED_KEY pEncryptedKey = &Keys->EncryptedKey[0];
            ULONG keyCount = *(ULONG UNALIGNED*)&(Keys->KeyCount);

            //
            // Walk down the list of key names in the ENCRYTPED_KEYS
            //

            if (!keyCount) {

                EfspLogAttack(pEfsUserInfo, CORRUPT_DATA_3);

            }

            for (*KeyIndex=0 ; *KeyIndex<keyCount ; (*KeyIndex)++) {


                retCode =  EfsAlignBlock(
                                pEncryptedKey,
                                (PVOID *)&pAlignedKey,
                                &freeAlignedKey
                                );
                if (!pAlignedKey) {

                    //
                    // OOM. Treat it as not current.
                    //

                    rc = ERROR_NOT_ENOUGH_MEMORY;
                    break;

                }

                Fek = ExtractFek( pEfsUserInfo, pAlignedKey, CheckBits );

                if (Fek != NULL) {

                    //
                    // Decryption worked, return the key
                    //

                    if (freeAlignedKey) {
                        LsapFreeLsaHeap( pAlignedKey );
                    }
                    rc = ERROR_SUCCESS;
                    break;
                }

                pEncryptedKey = (PENCRYPTED_KEY)( ((PBYTE)pEncryptedKey) + pAlignedKey->Length );
                if (freeAlignedKey) {
                    LsapFreeLsaHeap( pAlignedKey );
                    freeAlignedKey = FALSE;
                }
            }
        } __except(EXCEPTION_EXECUTE_HANDLER) {

              rc = ERROR_WRONG_EFS;
              if (freeAlignedKey) {
                  LsapFreeLsaHeap( pAlignedKey );
                  freeAlignedKey = FALSE;
              }

              EfspLogAttack(pEfsUserInfo, CORRUPT_DATA_4);
        }

    }

    SetLastError(rc);

    return( Fek );
}


DWORD
GetLengthEncryptedKeys(
    IN PENCRYPTED_KEYS pEncryptedKeys
    )

/*++

Routine Description:

    Computes the total size in bytes of an ENCRYPTED_KEYS structure.

Arguments:

    pEncryptedKeys - Supplies a pointer to an ENCRYPTED_KEYS structre.

Return Value:

    The length in bytes of the passed structure.

--*/

{
    DWORD cb=0;
    ULONG keyCount = *((ULONG UNALIGNED *) &(pEncryptedKeys->KeyCount));
    ULONG keyLength;

    PENCRYPTED_KEY pEncryptedKey = &pEncryptedKeys->EncryptedKey[0];

    for (DWORD i=0; i<keyCount ; i++) {

        keyLength = *((ULONG UNALIGNED *) &(pEncryptedKey->Length));
        cb += keyLength;
        pEncryptedKey = (PENCRYPTED_KEY)( ((PBYTE)pEncryptedKey) + keyLength );
    }

    cb += sizeof( ENCRYPTED_KEYS ) - sizeof( ENCRYPTED_KEY );

    return( cb );
}

BOOL
AppendEncryptedKeyToDDF(
    IN PEFS_DATA_STREAM_HEADER EfsStream,
    IN PENCRYPTED_KEY EncryptedKey,
    IN PEFS_KEY Fek,
    OUT PEFS_DATA_STREAM_HEADER * OutputEfs
    )

/*++

Routine Description:

    This routine will take an existing EFS stream and append the
    passed encrypted key to the end of the DDF section.  It does
    not check to see if the key is already there or not.

Arguments:

    EfsStream - The existing EFS stream.

    EncryptedKey - The FEK encrypted with the new public key.

    OutputEfs - Receives the new EFS stream to be placed on the
        file.

Return Value:

--*/

{
    BOOL b = FALSE;

    //
    // This is a simple append operation.
    //
    // The new size is the size of the old EFS stream
    // plus the size of the new key.  Allocate space for it.
    //

    DWORD EfsLength = EfsStream->Length + EncryptedKey->Length;
    EfsLength = (EfsLength + 7) & 0xfffffff8;

    *OutputEfs = (PEFS_DATA_STREAM_HEADER)LsapAllocateLsaHeap( EfsLength );

    if (*OutputEfs) {

        memset( *OutputEfs, 0, sizeof( EFS_DATA_STREAM_HEADER ));

        //
        // Copy the header
        //

        PEFS_DATA_STREAM_HEADER Efs = *OutputEfs;
        *Efs = *EfsStream;

        Efs->Length = EfsLength;

        //
        // Start copying the DDF at the base of the EFS
        // structure.  Copy the whole thing.  Do ourselves a
        // favor and don't assume that the DDF or DRF are in
        // any particular order in the EFS structure.
        //

        PENCRYPTED_KEYS pDDF = (PENCRYPTED_KEYS)OFFSET_TO_POINTER( DataDecryptionField, EfsStream );
        DWORD cbDDF = GetLengthEncryptedKeys( pDDF );

        //
        // Store away the offset to the beginning on the DDF
        //

        Efs->DataDecryptionField = (ULONG)sizeof( EFS_DATA_STREAM_HEADER );

        PBYTE Base = (PBYTE)OFFSET_TO_POINTER( DataDecryptionField, Efs );
        memcpy( Base, pDDF, cbDDF );

        //
        // Point to the new DDF, we need to fix it up a little
        //

        PENCRYPTED_KEYS pNewDDF = (PENCRYPTED_KEYS)Base;
        pNewDDF->KeyCount++;

        Base += cbDDF;

        memcpy( Base, EncryptedKey, EncryptedKey->Length );

        Base += EncryptedKey->Length;

        //
        // Now copy the DRF onto the end and we're done.
        //


        PENCRYPTED_KEYS pDRF = (PENCRYPTED_KEYS)OFFSET_TO_POINTER( DataRecoveryField, EfsStream );

        if ((PVOID) pDRF == (PVOID) EfsStream) {

            Efs->DataRecoveryField = 0;

        } else {

            DWORD cbDRF = GetLengthEncryptedKeys( pDRF );
            Efs->DataRecoveryField = (ULONG)POINTER_TO_OFFSET( Base, Efs );
            memcpy( Base, pDRF, cbDRF );

        }


//        Base += cbDRF

        b = TRUE;

//        memset( &(Efs->EfsHash), 0, MD5_HASH_SIZE );
//        EfspChecksumEfs( Efs, Fek );

    } else {

        SetLastError( ERROR_NOT_ENOUGH_MEMORY );
    }

    return( b );
}


BOOLEAN
EfspCertInEFS(
    IN PBYTE pbHash,
    IN DWORD cbHash,
    IN PEFS_DATA_STREAM_HEADER pEfsStream
    )

/*++

Routine Description:

    Searches the passed EFS stream for an entry with the same hash as passed.

Arguments:

    pbHash - Supplies a pointer to the hash being queried

    cbHash - Supplies the length in bytes of the hash being queried

    pEfsStream - Supplies the EFS stream from the file being queried


Return Value:

    TRUE if the passed hash is found, FALSE otherwise.

--*/

{
    BOOLEAN fFound = FALSE;
    DWORD KeyIndex;

    //
    // Check the hash in each entry in the DDF.  If
    // we get a match, return success.
    //

    PDDF Keys = (PENCRYPTED_KEYS)OFFSET_TO_POINTER( DataDecryptionField, pEfsStream );

    PENCRYPTED_KEY pEncryptedKey = &Keys->EncryptedKey[0];

    for (KeyIndex=0 ; KeyIndex<Keys->KeyCount ; KeyIndex++) {

        PEFS_PUBLIC_KEY_INFO PublicKeyInfo = (PEFS_PUBLIC_KEY_INFO)( (PUCHAR)pEncryptedKey + *(ULONG UNALIGNED *) &(pEncryptedKey->PublicKeyInfo) );
        PEFS_CERT_HASH_DATA CertHashData = (PEFS_CERT_HASH_DATA)( (PUCHAR) PublicKeyInfo + *(ULONG UNALIGNED *) &(PublicKeyInfo->CertificateThumbprint.CertHashData));
        
        if (*(DWORD UNALIGNED *)&(CertHashData->cbHash) == cbHash) {

            PBYTE pbSrcHash = (PBYTE)CertHashData + *(ULONG UNALIGNED *) &(CertHashData->pbHash); 

            if (memcmp(pbSrcHash, pbHash, cbHash) == 0) {
                fFound = TRUE;
                break;
            }
        }

        pEncryptedKey = NEXT_ENCRYPTED_KEY( pEncryptedKey );
    }

    return( fFound );
}



BOOLEAN
AddUserToEFS(
    IN PEFS_DATA_STREAM_HEADER EfsStream,
    IN PSID NewUserSid OPTIONAL,
    IN PEFS_KEY Fek,
    IN PBYTE pbCert,
    IN DWORD cbCert,
    OUT PEFS_DATA_STREAM_HEADER * NewEfs
    )

/*++

Routine Description:

    This routine adds a new encrypted key block to the DDF of the passed
    EFS stream.

Arguments:

    EfsStream - Takes a pointer to the EFS stream to be modified.

    NewUserSid - Optionally supplies a pointer to the SID of the new user.

    Fek - Supplies the FEK of the file being modified.

    pbCert - Supplies a pointer to the certificate of the new user.

    cbCert - Supplies the lenght in bytes of the certificate.

    NewEfs - Returns a pointer to the new EFS stream.

Return Value:

    TRUE on success, FALSE on failure.  Call GetLastError() for more details.

--*/

{
    DWORD rc;
    PEFS_DATA_STREAM_HEADER Efs = NULL;
    BOOLEAN b = FALSE;

    //
    // Get the key information from the passed cert
    //

    PCCERT_CONTEXT pCertContext = CertCreateCertificateContext(
                                      X509_ASN_ENCODING,
                                      pbCert,
                                      cbCert
                                      );
    if (pCertContext != NULL) {

        PBYTE pbHash;
        DWORD cbHash;

        pbHash = GetCertHashFromCertContext(
                     pCertContext,
                     &cbHash
                     );

        if (pbHash) {

            //
            // See if this hash is already on the file.  If so, return error.
            //

            if (!EfspCertInEFS( pbHash, cbHash, EfsStream )) {

                //
                // Now get the public key out of the cert so we can
                // encrypt the FEK
                //

                PCERT_PUBLIC_KEY_INFO pSubjectPublicKeyInfo = &pCertContext->pCertInfo->SubjectPublicKeyInfo;

                //
                // Import the public key into a context
                //

                HCRYPTKEY hKey;

                if (CryptImportPublicKeyInfo( hProvVerify, X509_ASN_ENCODING, pSubjectPublicKeyInfo, &hKey )) {

                    //
                    // Use the newly imported key to encrypt the FEK
                    //

                    DWORD dwEncryptedFEKLength = 0;

                    PBYTE EncryptedFEK = EncryptFEK( Fek, hKey, &dwEncryptedFEKLength );

                    if (EncryptedFEK != NULL) {

                        PEFS_PUBLIC_KEY_INFO PublicKeyInformation = NULL;

                        //
                        // This may come back NULL, but that's ok.
                        //

                        LPWSTR lpDisplayName = EfspGetCertDisplayInformation( pCertContext );

                        b = CreatePublicKeyInformationThumbprint(
                                NewUserSid,
                                pbHash,
                                cbHash,
                                lpDisplayName,
                                NULL,
                                NULL,
                                &PublicKeyInformation
                                );

                        if (lpDisplayName) {
                            LsapFreeLsaHeap( lpDisplayName );
                        }

                        if (b) {

                            PEFS_KEY_SALT pEfsKeySalt = NULL;

                            if (Fek->Entropy <= EXPORT_KEY_STRENGTH) {

                                DWORD SaltLength;
                                DWORD SaltBlockLength;

                                if (GetSaltLength(Fek->Algorithm, &SaltLength, &SaltBlockLength)) {

                                    SafeAllocaAllocate(pEfsKeySalt, sizeof(EFS_KEY_SALT) + SaltBlockLength);

                                    if (pEfsKeySalt) {
                                        pEfsKeySalt->Length = sizeof( EFS_KEY_SALT ) + SaltBlockLength;
                                        pEfsKeySalt->SaltType = Fek->Algorithm;
                                        RtlCopyMemory( (PBYTE)pEfsKeySalt + sizeof( EFS_KEY_SALT ),
                                            EFS_KEY_DATA( Fek ),
                                            SaltLength
                                            );
                                    }
                                }

                            } else {
                                pEfsKeySalt = NULL;
                            }

                            if (pEfsKeySalt || (Fek->Entropy > EXPORT_KEY_STRENGTH)) {


                                DWORD EncryptedKeySize = 0;
                                PENCRYPTED_KEY EncryptedKey;

                                rc = ConstructEncryptedKey( EncryptedFEK,
                                         dwEncryptedFEKLength,
                                         PublicKeyInformation,
                                         pEfsKeySalt,
                                         &EncryptedKey,
                                         &EncryptedKeySize
                                         );
                                //
                                // We'll check the return code below
                                //

                                if (rc == ERROR_SUCCESS) {

                                    b = AppendEncryptedKeyToDDF(
                                            EfsStream,
                                            EncryptedKey,
                                            Fek,
                                            NewEfs
                                            ) != 0;

                                    LsapFreeLsaHeap( EncryptedKey );

                                } else {

                                    SetLastError( rc );
                                }

                                SafeAllocaFree( pEfsKeySalt );

                            } else {

                                SetLastError( ERROR_NOT_ENOUGH_MEMORY );
                            }

                            LsapFreeLsaHeap( PublicKeyInformation );
                        }

                        LsapFreeLsaHeap( EncryptedFEK );
                    }

                    CryptDestroyKey( hKey );
                }

            } else {

               //
               // Adding duplicate cert considered succeed
               //

               b = TRUE;
            }

            LsapFreeLsaHeap( pbHash );
        }

        CertFreeCertificateContext( pCertContext );
    }

    if (!b) {

        //
        // If we're not going to return success, clean up everything we were
        // planning on returning.
        //

        if (*NewEfs != NULL) {
            LsapFreeLsaHeap( *NewEfs );
        }
    }

    return( b );
}


PENCRYPTED_KEY
GetEncryptedKeyByIndex(
    PENCRYPTED_KEYS pEncryptedKeys,
    DWORD KeyIndex
    )
{
    ASSERT( KeyIndex < *((ULONG UNALIGNED *)&(pEncryptedKeys->KeyCount)) );

    PENCRYPTED_KEY pEncryptedKey = &pEncryptedKeys->EncryptedKey[0];

    if (KeyIndex == 0) {
        return( pEncryptedKey );
    }

    for (DWORD i=0; i<KeyIndex ; i++, pEncryptedKey = (PENCRYPTED_KEY)(((PBYTE)(pEncryptedKey)) + *(ULONG UNALIGNED *)&((PENCRYPTED_KEY)(pEncryptedKey))->Length)) ;

    return( pEncryptedKey );
}

BOOL
UserKeyCurrent(
    PEFS_USER_INFO pEfsUserInfo,
    PDDF Ddf,
    DWORD KeyIndex
    )
/*++

Routine Description:

    This routine checks to see if the key used to decrypt the file
    is the user's current encryption key.

Arguments:

    Ddf - Supplies the DDF of the file being accessed.

    KeyIndex - Supplies the index of the key in the DDF that was
        used to open the file.

Return Value:

    TRUE if the key used corresponds to the user's encryption key.

    FALSE otherwise.

--*/

{
    BOOL b = TRUE;
    DWORD rc = ERROR_SUCCESS;

    PBYTE pbCurrentKeyHash = NULL;
    DWORD cbCurrentKeyHash;
    PBYTE pbHash;
    DWORD cbHash;
    PBYTE pbWkHash = NULL;

    //
    // Compare the current user key with the contents
    // of the specified key, and see if they're in sync.
    //

    PENCRYPTED_KEY pEncryptedKey = GetEncryptedKeyByIndex( Ddf, KeyIndex );

    PENCRYPTED_KEY pAlignedKey;
    BOOLEAN freeAlignedKey;

    rc =  EfsAlignBlock(
                    pEncryptedKey,
                    (PVOID *)&pAlignedKey,
                    &freeAlignedKey
                    );
    if (!pAlignedKey) {

        //
        // OOM. Treat it as current.
        //

        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        return TRUE;

    }

    PEFS_PUBLIC_KEY_INFO pPublicKeyInfo = (PEFS_PUBLIC_KEY_INFO)OFFSET_TO_POINTER( PublicKeyInfo, pAlignedKey );

    if (pPublicKeyInfo->KeySourceTag != EfsCertificateThumbprint) {

        //
        // The user key may be current, but the key on the file isn't.
        // Return FALSE so as to regenerate the EFS on this file.
        //

        DebugLog((DEB_WARN, "Updating downlevel file\n"   ));
        if (freeAlignedKey) {
            LsapFreeLsaHeap( pAlignedKey );
        }

        return( FALSE );
    }

    PEFS_CERT_HASH_DATA CertHashData = (PEFS_CERT_HASH_DATA)OFFSET_TO_POINTER( CertificateThumbprint.CertHashData, pPublicKeyInfo );
    pbHash = (PBYTE)OFFSET_TO_POINTER( pbHash, CertHashData );
    cbHash = CertHashData->cbHash;

    if (pEfsUserInfo->pUserCache) {

        //
        // Check the current against the cache
        //

        pbWkHash = pEfsUserInfo->pUserCache->pbHash;
        cbCurrentKeyHash = pEfsUserInfo->pUserCache->cbHash;

    } else {

        rc = GetCurrentHash(
                 pEfsUserInfo,
                 &pbCurrentKeyHash,
                 &cbCurrentKeyHash
                 );

        if (rc == ERROR_SUCCESS) {

            pbWkHash = pbCurrentKeyHash;

        }

    }

    //
    // Compare the hash stored in the current user key
    // with the hash in the specified public key info.
    //

    if (rc == ERROR_SUCCESS) {

        //
        // Compare the thumbprint in the public key info against
        // the user's current.
        //



        if (cbHash == cbCurrentKeyHash) {

            if (memcmp(pbWkHash, pbHash, cbHash) != 0) {

                b = FALSE;

            }
        } else {

            b = FALSE;

        }

    }

    if (pbCurrentKeyHash) {
        LsapFreeLsaHeap( pbCurrentKeyHash );
    }

    if (freeAlignedKey) {
        LsapFreeLsaHeap( pAlignedKey );
    }

    //
    // If we failed to get the current key hash and reach here, this means we also failed to create the hash.
    // This could mean that we could not set the current key. We could not test if the hash could be the current.
    // We could not replace the DDF with a current one anyway. We assume the passed in hash as the current.
    // Could I be wrong here?
    //

    return( b );
}

BOOL
ReplaceUserKey(
    PEFS_USER_INFO pEfsUserInfo,
    PEFS_KEY Fek,
    PEFS_DATA_STREAM_HEADER EfsStream,
    DWORD KeyIndex,
    PEFS_DATA_STREAM_HEADER * UpdatedEfs
    )
/*++

Routine Description:

    This routine will replace the user key specified by the passed KeyIndex
    with another one that uses the current user EFS keys.

    It assumes that we are in the context of the caller who owns this key.

Arguments:

    Fek - Supplies the decrypted FEK for the file.

    EfsStream - Supplies the EFS stream on the file.

    KeyIndex - Supplies the index of the key to be replaced.

    UpdatedEfs - Receives a pointer to the new EFS stream to be
        placed on the file.

Return Value:

--*/
{
    //
    // Query the current user keys.  This will give me
    // back a hash and a container and provider name.
    //

    HCRYPTKEY hKey;
    HCRYPTPROV hProv;
    PBYTE pbHash;
    DWORD cbHash;

    BOOL b = FALSE;
    DWORD rc;

    LPWSTR ContainerName;
    LPWSTR ProviderName;
    LPWSTR DisplayInfo;
    DWORD ProviderType;

    DebugLog((DEB_WARN, "Updating EFS stream\n"   ));

    PSID NewUserSid = pEfsUserInfo->pTokenUser->User.Sid;

    rc = GetCurrentKey(
             pEfsUserInfo,
             &hKey,
             &hProv,
             &ContainerName,
             &ProviderName,
             &ProviderType,
             &DisplayInfo,
             &pbHash,
             &cbHash
             );

    //
    // Use this key information to encrypt the FEK
    // and generate an encrypted key structure.
    //

    if (rc == ERROR_SUCCESS) {

        DWORD dwEncryptedFEKLength = 0;

        PBYTE EncryptedFEK;
        HCRYPTKEY hLocalKey;
        HCRYPTPROV hLocalProv;
        PBYTE pbLocalHash;
        DWORD cbLocalHash;
        LPWSTR lpLocalContainerName;
        LPWSTR lpLocalProviderName;
        LPWSTR lpLocalDisplayInfo;

        if (pbHash) {
            pbLocalHash = pbHash;
            cbLocalHash = cbHash;
            hLocalKey = hKey;
            hLocalProv = hProv;
            lpLocalContainerName = ContainerName;
            lpLocalProviderName = ProviderName;
            lpLocalDisplayInfo = DisplayInfo;
        } else {

            ASSERT(pEfsUserInfo->pUserCache);

            pbLocalHash = pEfsUserInfo->pUserCache->pbHash;
            cbLocalHash = pEfsUserInfo->pUserCache->cbHash;
            hLocalKey = pEfsUserInfo->pUserCache->hUserKey;
            hLocalProv = pEfsUserInfo->pUserCache->hProv;
            lpLocalContainerName = pEfsUserInfo->pUserCache->ContainerName;
            lpLocalProviderName = pEfsUserInfo->pUserCache->ProviderName;
            lpLocalDisplayInfo = pEfsUserInfo->pUserCache->DisplayInformation;

        }
         
        EncryptedFEK = EncryptFEK( Fek, hLocalKey, &dwEncryptedFEKLength );

        if (EncryptedFEK != NULL) {

            PEFS_PUBLIC_KEY_INFO PublicKeyInformation = NULL;

            if (CreatePublicKeyInformationThumbprint(
                    NewUserSid,
                    pbLocalHash,
                    cbLocalHash,
                    lpLocalDisplayInfo,
                    lpLocalContainerName,
                    lpLocalProviderName,
                    &PublicKeyInformation
                    )) {

                PEFS_KEY_SALT pEfsKeySalt = NULL;

                if ( Fek->Entropy <= EXPORT_KEY_STRENGTH ){

                    DWORD SaltLength;
                    DWORD SaltBlockLength;

                    if (GetSaltLength(Fek->Algorithm, &SaltLength, &SaltBlockLength)){

                        SafeAllocaAllocate(pEfsKeySalt, sizeof(EFS_KEY_SALT) + SaltBlockLength);

                        if (pEfsKeySalt){
                            pEfsKeySalt->Length = sizeof( EFS_KEY_SALT ) + SaltBlockLength;
                            pEfsKeySalt->SaltType = Fek->Algorithm;
                            RtlCopyMemory( (PBYTE)pEfsKeySalt + sizeof( EFS_KEY_SALT ),
                                            EFS_KEY_DATA( Fek ),
                                            SaltLength );
                        }
                    }

                } else {

                    pEfsKeySalt = NULL;
                }

                if (pEfsKeySalt || (Fek->Entropy > EXPORT_KEY_STRENGTH)) {

                    //
                    // This should return an error
                    //

                    DWORD EncryptedKeySize = 0;
                    PENCRYPTED_KEY EncryptedKey;

                    rc = ConstructEncryptedKey( EncryptedFEK,
                                                dwEncryptedFEKLength,
                                                PublicKeyInformation,
                                                pEfsKeySalt,
                                                &EncryptedKey,
                                                &EncryptedKeySize
                                                );
                    //
                    // We'll check the return code below
                    //

                    if (rc == ERROR_SUCCESS) {


                        PEFS_DATA_STREAM_HEADER NewEfs = NULL;

                        if (AppendEncryptedKeyToDDF(
                                EfsStream,
                                EncryptedKey,
                                Fek,
                                &NewEfs
                                )) {

                            PEFS_DATA_STREAM_HEADER pNewEfs2 = NULL;

                            if (DeleteEncryptedKeyByIndex(
                                    NewEfs,
                                    KeyIndex,
                                    Fek,
                                    &pNewEfs2
                                    )) {

                                *UpdatedEfs = pNewEfs2;
                                b = TRUE;

                            } else {

                                *UpdatedEfs = NULL;  // paranoia
                            }

                            LsapFreeLsaHeap( NewEfs );
                        }

                        LsapFreeLsaHeap( EncryptedKey );

                    }

                    SafeAllocaFree( pEfsKeySalt );
                }

                LsapFreeLsaHeap( PublicKeyInformation );
            }

            LsapFreeLsaHeap( EncryptedFEK );
        } else {

            rc = GetLastError();

        }

        if (ContainerName) {
            LsapFreeLsaHeap( ContainerName );
        }

        if (ProviderName) {
            LsapFreeLsaHeap( ProviderName );
        }

        if (DisplayInfo) {
            LsapFreeLsaHeap( DisplayInfo );
        }

        if (pbHash) {
            LsapFreeLsaHeap( pbHash );
        }

        if (hKey) {
            CryptDestroyKey( hKey );
        }

        if (hProv) {
            CryptReleaseContext( hProv, 0 );
        }

    }

    SetLastError( rc );

    if (!b) {
        DebugLog((DEB_ERROR, "Update failed, error = %x\n" ,GetLastError()  ));
    }

    return( b );
}

BOOL
DeleteEncryptedKeyByIndex(
   IN PEFS_DATA_STREAM_HEADER pEfs,
   IN DWORD KeyIndex,
   IN PEFS_KEY Fek,
   OUT PEFS_DATA_STREAM_HEADER * pNewEfs
   )

/*++

Routine Description:

    This routine deletes the passed key from the DDF of the passed
    EFS stream, and returns a new EFS stream.  It does not deallocate
    the original EFS stream.

Arguments:

    pEfs - Supplies a pointer to the original EFS stream.

    KeyIndex - Supplies the index of the key to delete.

    pNewEfs - Returns a pointer to the new EFS stream allocated
        out of heap.

Return Value:

    TRUE on success, FALSE on failure.  GetLastError() will return more information.

--*/

{
    BOOL b = FALSE;

    PENCRYPTED_KEYS pNewDDF;

    //
    // Do this the lazy way: build the new DDF
    // and copy it into the EFS stream.
    //

    PENCRYPTED_KEYS pDDF = (PENCRYPTED_KEYS)OFFSET_TO_POINTER( DataDecryptionField, pEfs );

    //
    // This is an over estimate, but it will do.
    //

    SafeAllocaAllocate(pNewDDF, GetLengthEncryptedKeys( pDDF ));

    if (pNewDDF) {

        pNewDDF->KeyCount = pDDF->KeyCount - 1;
        DWORD cbNewDDF = sizeof( ENCRYPTED_KEYS ) - sizeof( ENCRYPTED_KEY );

        PBYTE Target = (PBYTE)(&pNewDDF->EncryptedKey[0]);
        PBYTE Source = (PBYTE)(&pDDF->EncryptedKey[0]);

        for (DWORD i=0; i<pDDF->KeyCount ; i++) {

            if (i != KeyIndex) {

                //
                // We want this one.  Copy it.
                //

                DWORD KeyLength = *((DWORD UNALIGNED*) &((PENCRYPTED_KEY)Source)->Length);
                cbNewDDF += KeyLength;

                memcpy( Target, Source, KeyLength );

                Target = (PBYTE)NEXT_ENCRYPTED_KEY( Target );
                Source = (PBYTE)NEXT_ENCRYPTED_KEY( Source );

            } else {

                //
                // Skip this one.
                //

                Source = (PBYTE)NEXT_ENCRYPTED_KEY( Source );
            }
        }

        //
        // pNewDDF contains a pointer to our new DDF.
        //

        PENCRYPTED_KEYS pDRF = (PENCRYPTED_KEYS)OFFSET_TO_POINTER( DataRecoveryField, pEfs );
        DWORD cbDRF;

        if ((PVOID)pDRF == (PVOID)pEfs) {

            //
            //  There was no DRF
            //

            cbDRF = 0;
            pDRF = NULL;

        } else {
            cbDRF = GetLengthEncryptedKeys( pDRF );
        }

        *pNewEfs = AssembleEfsStream( pNewDDF, cbNewDDF, pDRF, cbDRF, Fek );

        if (*pNewEfs) {
            b = TRUE;
        } else {
            *pNewEfs = NULL;    // paranoia
            SetLastError( ERROR_NOT_ENOUGH_MEMORY );
        }

        SafeAllocaFree( pNewDDF );

    } else {

        SetLastError( ERROR_NOT_ENOUGH_MEMORY );
    }

    return( b );
}


PEFS_DATA_STREAM_HEADER
AssembleEfsStream(
    IN PENCRYPTED_KEYS pDDF,
    IN DWORD cbDDF,
    IN PENCRYPTED_KEYS pDRF,
    IN DWORD cbDRF,
    IN PEFS_KEY Fek
    )
/*++

Routine Description:

    This routine takes the pieces of an EFS stream and assembles them into
    an EFS stream.

Arguments:

    pDDF - Supplies a pointer to the DDF for the new EFS stream.

    cbDDF - Supplies the length in bytes of the DDF.

    pDRF - Supplies a pointer to the DRF for the new EFS stream.

    cbDRF - Supplies the length in bytes of the DRF.

Return Value:

    Returns a pointer to a new EFS stream, or NULL.  Caller is responsible
    for freeing the returned memory.

--*/

{
    //
    // Compute the total size of the new EFS stream
    //

    DWORD cbNewEFS = sizeof( EFS_DATA_STREAM_HEADER ) + cbDDF + cbDRF;
    cbNewEFS = (cbNewEFS + 7) & 0xfffffff8;

    PEFS_DATA_STREAM_HEADER pNewEFS = (PEFS_DATA_STREAM_HEADER)LsapAllocateLsaHeap( cbNewEFS );

    if (pNewEFS) {

        memset( pNewEFS, 0, sizeof( EFS_DATA_STREAM_HEADER ) );

        pNewEFS->Length     = cbNewEFS;
        pNewEFS->State      = 0;
        pNewEFS->EfsVersion = EFS_CURRENT_VERSION;

        RPC_STATUS RpcStatus = UuidCreate( &pNewEFS->EfsId );

        if (RpcStatus == ERROR_SUCCESS || RpcStatus == RPC_S_UUID_LOCAL_ONLY) {

            //
            // Copy in the DDF
            //

            PBYTE Base = (PBYTE)(((PBYTE)pNewEFS) + sizeof( EFS_DATA_STREAM_HEADER ));
            pNewEFS->DataDecryptionField = (ULONG)POINTER_TO_OFFSET( Base, pNewEFS  );
            memcpy( Base, pDDF, cbDDF );

            Base += cbDDF;

            //
            // Copy the DRF
            //

            if (pDRF) {
                memcpy( Base, pDRF, cbDRF );
                pNewEFS->DataRecoveryField = (ULONG)POINTER_TO_OFFSET( Base, pNewEFS );
            } else {
                pNewEFS->DataRecoveryField = 0;
            }


            // Base += cbDRF

            // EfspChecksumEfs( pNewEFS, Fek );

        } else {

            //
            // Couldn't get a UUID, fail
            //

            LsapFreeLsaHeap( pNewEFS );
            pNewEFS = NULL;
        }
    }

    return( pNewEFS );
}

BOOL
RecoveryInformationCurrent(
    PEFS_DATA_STREAM_HEADER EfsStream
    )
/*++

Routine Description:

    This routine examines the recovery information in an EFS stream and determines if
    the system recovery information has changed since this stream was generated.  It
    does this by comparing the certificate hashes stored in the current recovery
    information with the certificate hashes stored in the passed DRF.

Arguments:

    EfsStream - Supplies a pointer to the EFS stream to be examined.

Return Value:

    TRUE - Recovery information is up to date.

    FALSE - DRF must be regenerated with new recovery information.

--*/
{

    //
    // Assume that the entries in the DRF correspond to entries in the
    // current recovery information array in order.  That will simplify
    // this operation considerably.
    //

    //
    // Get a pointer to the DRF
    //

    PDRF pDrf = (PENCRYPTED_KEYS)OFFSET_TO_POINTER( DataRecoveryField, EfsStream );

    //
    // For each entry in the DRF, compare hash to corresponding entry in recovery
    // policy.  Fail on first mismatch.
    //

    ULONG KeyCount = 0;

    if ((PVOID)pDrf == (PVOID)EfsStream) {

        //
        // No DRF field.
        //

        pDrf = NULL;

    }
     
    //
    // pDrf->KeyCount could be unaligned
    //

    if (pDrf) {
        KeyCount = *((ULONG UNALIGNED *) &pDrf->KeyCount);
    }
    
/*
    //
    // There may not be a recovery policy on this machine.  If that's the case,
    // we're just going to leave this file alone.
    //

    if (CurrentRecoveryPolicy.dwKeyCount == 0) {
        return( TRUE );
    }
*/

    if (!pDrf && CurrentRecoveryPolicy.PolicyStatus < RECOVERY_POLICY_OK) {

        //
        // Current recovery policy has no valid recovery agent and the existing $EFS
        // has no valid agent too.
        //

        return (TRUE);

    }

    if (CurrentRecoveryPolicy.dwKeyCount != KeyCount) {
        return( FALSE );
    }

    ASSERT(pDrf);
    if (!pDrf) {

        //
        // We should never get into this. This is only for the purpose of defensive.
        //

        return (TRUE);
    }

    PENCRYPTED_KEY pEncryptedKey = &pDrf->EncryptedKey[0];

    for (ULONG i=0; i<KeyCount ; i++) {

        PENCRYPTED_KEY pAlignedKey;
        BOOLEAN freeAlignedKey;

        (VOID) EfsAlignBlock(
            pEncryptedKey,
            (PVOID *)&pAlignedKey,
            &freeAlignedKey
            );
        if (!pAlignedKey) {

            //
            // OOM. Treat it as not current.
            //

            return (FALSE);

        }

        PEFS_PUBLIC_KEY_INFO PublicKeyInfo = (PEFS_PUBLIC_KEY_INFO)OFFSET_TO_POINTER( PublicKeyInfo, pAlignedKey );
        ASSERT( PublicKeyInfo->KeySourceTag  == EfsCertificateThumbprint );

        PEFS_CERT_HASH_DATA CertHashData = (PEFS_CERT_HASH_DATA)OFFSET_TO_POINTER( CertificateThumbprint.CertHashData, PublicKeyInfo );
        PBYTE pbHash = (PBYTE)OFFSET_TO_POINTER( pbHash, CertHashData );
        DWORD cbHash = CertHashData->cbHash;
         
        if ((cbHash != CurrentRecoveryPolicy.cbHash[i]) || (memcmp(pbHash, CurrentRecoveryPolicy.pbHash[i], cbHash) != 0)) {

            if (freeAlignedKey) {
                LsapFreeLsaHeap( pAlignedKey );                
            }
            return( FALSE );

        } else {

            pEncryptedKey = (PENCRYPTED_KEY)(((PBYTE)(pEncryptedKey)) + pAlignedKey->Length);
            if (freeAlignedKey) {
                LsapFreeLsaHeap( pAlignedKey );                
            }
        }
    }

    return( TRUE );
}


DWORD
UpdateRecoveryInformation(
    PEFS_KEY Fek,
    PEFS_DATA_STREAM_HEADER EfsStream,
    PEFS_DATA_STREAM_HEADER * UpdatedEfs
    )
/*++

Routine Description:

    This routine will create a new EFS stream based on the passed in one.
    The new EFS stream will contain a DRF based on the current recovery
    policy.  It is assumed that someone else has already verified that
    the DRF is this stream is out of date, this routine will not do that.

Arguments:

    Fek - The FEK for the file being updated.

    EfsStream - Supplies the existing EFS stream for the file.

    UpdatedEfs - Returns an updated EFS stream for the file, allocated out of heap.


Return Value:

    return-value - Description of conditions needed to return value. - or -
    None.

--*/
{

    DWORD rc;
    DWORD cbDDF = 0;
    DWORD cbDRF = 0;
    PENCRYPTED_KEYS pNewDRF;

    *UpdatedEfs = NULL;


    //
    // Simply generate a new DRF and stick it onto the end of the existing EFS
    // stream.
    //

    PDDF pDdf = (PENCRYPTED_KEYS)OFFSET_TO_POINTER( DataDecryptionField, EfsStream );

    cbDDF = GetLengthEncryptedKeys( pDdf );

    rc = GenerateDRF( Fek, &pNewDRF, &cbDRF);

    if (rc == ERROR_SUCCESS) {

        *UpdatedEfs = AssembleEfsStream( pDdf, cbDDF, pNewDRF, cbDRF, Fek );

        if (*UpdatedEfs == NULL) {

            rc = ERROR_NOT_ENOUGH_MEMORY;
        }

        LsapFreeLsaHeap( pNewDRF );

    }

    ReleaseRecoveryData();

    return( rc );
}


DWORD
DecryptFek(
    IN PEFS_USER_INFO pEfsUserInfo,
    IN PEFS_DATA_STREAM_HEADER EfsStream,
    OUT PEFS_KEY * Fek,
    OUT PEFS_DATA_STREAM_HEADER * NewEfs,
    IN ULONG OpenType
    )
/*++

Routine Description:

    This routine will extract the FEK from the passed Efs stream.
    It will also check to see if the EFS stream is up to date w.r.t.
    current keys and recovery policy, and if not, it will generate
    a new one.

Arguments:


    EfsStream - Supplies the EFS stream from the file being opened.

    Fek - Returns the decrypted FEK from the EFS stream.  This data is
        allocated out of local heap and must be freed by the caller.

    NewEfs - Returns a new EFS stream for the file if necessary, otherwise
        returns NULL.  This data is allocated out of local heap and must be
        freed by the caller

    OpenType - Whether this is a normal open or an open for recovery.

Return Value:

    return-value - Description of conditions needed to return value. - or -
    None.

--*/

{

    DWORD rc = ERROR_SUCCESS;
    DWORD KeyIndex;
    PEFS_DATA_STREAM_HEADER UpdatedEfs = NULL;
    BOOLEAN Recovery = FALSE;
    BOOLEAN bEfsInvalid = FALSE;
    BOOLEAN DRFIsCurrent = FALSE;
    BOOLEAN ReqUpdateDRF = FALSE;

    *Fek = NULL;
    *NewEfs = NULL;

    if (EfsStream->EfsVersion > EFS_CURRENT_VERSION) {
        return ERROR_EFS_VERSION_NOT_SUPPORT;
    }

//    DbgPrint("User:%ws\\%ws\n", pEfsUserInfo->lpDomainName?pEfsUserInfo->lpDomainName:L"Unknown", pEfsUserInfo->lpUserName?pEfsUserInfo->lpUserName:L"Unknown"); 

    __try {

#if DBG

        UUID * EfsUuid = &EfsStream->EfsId;

        WCHAR * StringUuid;

        if (STATUS_SUCCESS == UuidToString ( EfsUuid, &StringUuid )) {

            DebugLog((DEB_TRACE_EFS, "Found $EFS w/ id: %ws\n" ,StringUuid  ));

            RpcStringFree( &StringUuid) ;
        }

#endif

        //
        // First try the DDF, and if we strike out there, the DRF.
        //

        PDDF Ddf = (PENCRYPTED_KEYS)OFFSET_TO_POINTER( DataDecryptionField, EfsStream );
        PDRF Drf = (PENCRYPTED_KEYS)OFFSET_TO_POINTER( DataRecoveryField,   EfsStream );

        if ((PVOID)Drf == (PVOID)EfsStream) {

            //
            // No DRF field.
            //

            Drf = NULL;

        }

        *Fek = GetFekFromEncryptedKeys( pEfsUserInfo, (PENCRYPTED_KEYS)Ddf, TRUE, &KeyIndex );

        if ((NULL == *Fek) && Drf) {

            *Fek = GetFekFromEncryptedKeys( pEfsUserInfo, (PENCRYPTED_KEYS)Drf, TRUE, &KeyIndex );
            Recovery = TRUE;
        }

        if (*Fek == NULL) {

            //
            // Bad keyset means that none of the keysets in the current
            // context could decrypt this file.
            //

            if (GetLastError() == NTE_BAD_KEYSET) {

                return ( ERROR_DECRYPTION_FAILED );

            } else {

                return ( GetLastError() );
            }

        } else {

            //
            // If we opened the file via the DDF, make sure
            // that the entry we used is current for the current
            // user.
            //

            if (!Recovery) {

                if (!UserKeyCurrent( pEfsUserInfo, Ddf, KeyIndex )) {

                    //
                    // The index we used to open the file
                    // is not current. Replace with the current user
                    // key.
                    //

                    (VOID) ReplaceUserKey( pEfsUserInfo, *Fek, EfsStream, KeyIndex, &UpdatedEfs );
                }
            }

            // 
            // Checksum the EFS stream to make sure it has not been tampered with.
            // If it is changed, we will try to see if the DRF has been checnged or not.
            // Keep the following deleted code for a while. We may need part of them in the future
            // for inheritance support.
            //
/*
            if (!EfspValidateEfsStream( EfsStream, *Fek )) {

                //
                // Checksum not match. See if the DRF changed
                //

                PENCRYPTED_KEYS  pNewDRF;
                DWORD            cbDRF;

                rc = GenerateDRF(*Fek, &pNewDRF, &cbDRF);
                if ( ERROR_SUCCESS == rc ) {

                    //
                    // Let's see if the DRF matches
                    //

                    if (EqualEncryptedKeys(Drf, pNewDRF, cbDRF)) {

                        //
                        // DRF is not modified. We can't fix the modification
                        // Regenerate the check sum.
                        //

                        DRFIsCurrent = TRUE;

                        if (!UpdatedEfs) {

                            //
                            // If $EFS is updated above, we don't need to generate the check sum again.
                            //
                        
                            UpdatedEfs = (PEFS_DATA_STREAM_HEADER)LsapAllocateLsaHeap( EfsStream->Length );
                            if (UpdatedEfs) {

                                RtlCopyMemory(UpdatedEfs, EfsStream, EfsStream->Length);
                                memset( &UpdatedEfs->EfsHash, 0, MD5_HASH_SIZE );
                                EfspChecksumEfs( UpdatedEfs, *Fek );

                            }

                        }

                        //
                        //  This is the best effort. If we failed to get the memory in the above
                        //  We will still try to let user open the file. But not fix the check sum
                        //



                    } else {

                        //
                        // Either the checksum is modified, or the DRF is modified.
                        // Do the check sum with the new DRF
                        //

                        ReqUpdateDRF = TRUE;

                    }

                    LsapFreeLsaHeap( pNewDRF );

                }

                ReleaseRecoveryData();

            }
*/


            //
            // Regardless of whether we did a recovery or not,
            // we still need to check to see if the recovery
            // information is up to snuff.
            //

            if ( !RecoveryInformationCurrent( EfsStream ) ) {

                //
                // We may have fixed up the current user key
                // above.  If so, modify that EFS stream.
                // Otherwise, use the one that the user
                // passed in.
                //

                if (UpdatedEfs) {

                    PEFS_DATA_STREAM_HEADER Tmp;
                    rc = UpdateRecoveryInformation( *Fek, UpdatedEfs, &Tmp );

                    if (ERROR_SUCCESS == rc) {
                        LsapFreeLsaHeap( UpdatedEfs );
                        UpdatedEfs = Tmp;
                    }

                } else {

                    rc = UpdateRecoveryInformation( *Fek, EfsStream, &UpdatedEfs );
                }
            }

            //
            // We successfully decrypted the file, but we may
            // not have been able to update the various parts
            // That's ok, we'll let the file decrypt.
            //
            // Note that, if there have been no updates,
            // UpdatedEfs is NULL, so this is a safe thing to do.
            //

            *NewEfs = UpdatedEfs;

            return ( ERROR_SUCCESS );
        }

    } __except(EXCEPTION_EXECUTE_HANDLER) {

        rc = GetExceptionCode();
        
        DebugLog((DEB_ERROR, "DecryptFek got exception:%x\n" ,rc));

        //
        // Clean up
        //
        
        if (UpdatedEfs) {
          LsapFreeLsaHeap( UpdatedEfs );
        }
        
        if (*Fek != NULL) {
          LsapFreeLsaHeap( *Fek );
          *Fek = NULL;
        }
    }

    return( rc );
}



DWORD
EfsGetFek(
    IN PEFS_USER_INFO pEfsUserInfo,
    IN PEFS_DATA_STREAM_HEADER EfsStream,
    OUT PEFS_KEY * Fek
    )
/*++

Routine Description:

    This routine will extract the FEK from the passed Efs stream.

Arguments:


    EfsStream - Supplies the EFS stream from the file being opened.

    Fek - Returns the decrypted FEK from the EFS stream.  This data is
        allocated out of local heap and must be freed by the caller.


Return Value:

    return-value - Description of conditions needed to return value. - or -
    None.

--*/

{

    DWORD rc = ERROR_SUCCESS;
    DWORD KeyIndex;

    *Fek = NULL;

    __try {


        //
        // First try the DDF, and if we strike out there, the DRF.
        //

        PDDF Ddf = (PENCRYPTED_KEYS)OFFSET_TO_POINTER( DataDecryptionField, EfsStream );
        PDRF Drf = (PENCRYPTED_KEYS)OFFSET_TO_POINTER( DataRecoveryField,   EfsStream );

        *Fek = GetFekFromEncryptedKeys( pEfsUserInfo, (PENCRYPTED_KEYS)Ddf, FALSE, &KeyIndex );

        if ((NULL == *Fek) && ( (PVOID)Drf != (PVOID)EfsStream) ) {

            *Fek = GetFekFromEncryptedKeys( pEfsUserInfo, (PENCRYPTED_KEYS)Drf, FALSE, &KeyIndex );
        
        }

        if (*Fek == NULL) {

                return (rc = GetLastError() );

        }
    }  __except(EXCEPTION_EXECUTE_HANDLER) {

        rc = GetExceptionCode();
        
        if (*Fek != NULL) {
          LsapFreeLsaHeap( *Fek );
          *Fek = NULL;
        }
    }

    return( rc );

}


PEFS_KEY
ExtractFek(
    IN PEFS_USER_INFO pEfsUserInfo,
    IN PENCRYPTED_KEY EncryptedKey,
    IN BOOL CheckBits
    )

/*++

Routine Description:

    This routine will take the passed EncryptedKey structure and attempt
    to decrypt the FEK encoded in the structure.  It will do this by first
    attempting to create context using the Provider and Container names
    contained in the structure.  If such a context exists, its key
    exchange key is used to import the encrypted session key from the
    structure.

    Once the session key has been imported, it is used to decrypt the encrypted
    FEK structure.  All of the pieces are then used to reconstruct the key
    integrity information structure, and if this verifies, then it is assumed
    that the FEK has been decoded correctly.

Arguments:

    pEfsUserInfo - User Info.

    EncryptedKey - Supplies a pointer to an EncryptedKey from the file being opened.
    
    CheckBits - TRUE will check the encryption bits against current version.

Return Value:

    On success, returns a pointer to a decrypted FEK.  On failure, returns NULL.

    The returned pointer is allocated out of heap and must be freed.

--*/
{
    //
    // Obtain a context to the user's RSA key
    //

    DWORD LastError = ERROR_SUCCESS;
    PEFS_KEY DecryptedFEK = NULL;
    PEFS_PUBLIC_KEY_INFO PublicKeyInfo = (PEFS_PUBLIC_KEY_INFO) OFFSET_TO_POINTER(PublicKeyInfo, EncryptedKey);
    HCRYPTPROV hProv = 0;
    HCRYPTKEY hKey;

    HCRYPTPROV hWkProv;
    HCRYPTKEY hWkKey;

    switch (PublicKeyInfo->KeySourceTag) {
        case EfsCertificateThumbprint:
            {
                //
                // See if there is a cert in the current context
                // that corresponds to this thumbprint.  If so,
                // we're in business.
                // The KeySourceTag has been changed a couple of times
                // during the development. Now this is the only valid tag.
                //

                PBYTE pbHash;
                DWORD cbHash;

                PEFS_CERT_HASH_DATA CertHashData = (PEFS_CERT_HASH_DATA)OFFSET_TO_POINTER( CertificateThumbprint.CertHashData, PublicKeyInfo );
                pbHash = (PBYTE)OFFSET_TO_POINTER( pbHash, CertHashData );
                cbHash = CertHashData->cbHash;
                if (cbHash && !IsBadReadPtr(pbHash, cbHash)) {

                    LastError = GetKeyInfoFromCertHash(
                                    pEfsUserInfo,
                                    pbHash,
                                    cbHash,
                                    &hKey,
                                    &hProv,
                                    NULL,
                                    NULL,
                                    NULL,
                                    NULL
                                    );

                    if (LastError != ERROR_SUCCESS) {
                        SetLastError( LastError );
                        return( NULL );
                    }

                } else {
                    EfspLogAttack(pEfsUserInfo, CORRUPT_DATA_5);
                    SetLastError( ERROR_FILE_CORRUPT );
                    return NULL;
                }

                break;
            }

        default:
            return( NULL );
            break;
    }

    if (hKey) {

        //
        //  We are not using the cache.
        //

        hWkKey = hKey;

    } else {

        ASSERT(pEfsUserInfo->pUserCache);

        hWkKey = pEfsUserInfo->pUserCache->hUserKey;

    }

    //
    // Decrypt the FEK field with the session key
    //

    PBYTE EncryptedFEK = (PBYTE)OFFSET_TO_POINTER( EncryptedFEK, EncryptedKey );

    //
    // Copy the FEK into a temporary buffer for decryption
    //

    __try{

        DWORD cbData = EncryptedKey->EncryptedFEKLength;

        DecryptedFEK = (PEFS_KEY)LsapAllocateLsaHeap( cbData );

        if (DecryptedFEK != NULL) {

            memcpy( DecryptedFEK, EncryptedFEK, cbData );

            BOOL Verified = FALSE;

    #ifdef ProfilingEfs

    LARGE_INTEGER  StartTime;
    LARGE_INTEGER  StopTime;


    NtQuerySystemTime(&StartTime);
    #endif
            if (CryptDecrypt( hWkKey, 0, TRUE, 0, (PBYTE)DecryptedFEK, &cbData )) {

    #ifdef ProfilingEfs

    NtQuerySystemTime(&StopTime);

    DbgPrint("CryptDecrypt:%lu\tSessionID:%lu\n", (ULONG)(StopTime.QuadPart - StartTime.QuadPart)/1000, pEfsUserInfo->AuthId.LowPart);

    #endif

                //
                // First, perform a sanity check: make sure the key we just decrypted has a length field
                // that's reasonable.  If not, we got back garbage.
                //

                if (EFS_KEY_SIZE( DecryptedFEK) <= cbData) {

                    //
                    // Check the Entropy and the salt here
                    //

                    PEFS_KEY_SALT pEfsKeySalt = (PEFS_KEY_SALT)OFFSET_TO_POINTER( EfsKeySalt, EncryptedKey );

                    if ( (KeyEntropy == EXPORT_KEY_STRENGTH) && CheckBits){
                        if ( DecryptedFEK->Entropy <= KeyEntropy ){

                            //
                            // Check the salt
                            //

                            DWORD SaltLength;
                            DWORD SaltBlockLength;

                            if (GetSaltLength(DecryptedFEK->Algorithm, &SaltLength,&SaltBlockLength)){
                                if ( pEfsKeySalt ){
                                    Verified = (memcmp( EFS_KEY_DATA(DecryptedFEK), (PBYTE)pEfsKeySalt + sizeof(EFS_KEY_SALT), SaltLength ) == 0);
                                } else {

                                    //
                                    // This should not happen
                                    //

                                    ASSERT(FALSE);
                                    Verified = FALSE;
                                }

                            } else {

                                //
                                // This algorithm has no salt
                                //

                                Verified = TRUE;
                            }

                        } else {

                            //
                            // Export version cannot decrypt files encrypted with longer keys
                            //

                            Verified = FALSE;
                        }

                    } else {

                        Verified = TRUE;
                    }

    //robertg       Now you have a pointer to the salt structure to play with.  Set Verified == TRUE if
    //              everything checks out.

                }

            } else {

                //
                // If we got back a bad length error, that means that the plaintext of
                // FEK was larger than the cyphertext.  Assume that this can't happen,
                // since the CryptDecrypt interface doesn't seem to be able to handle
                // this situation.
                //

                ASSERT(GetLastError() != NTE_BAD_LEN);

                LastError = GetLastError();
            }

            if (!Verified) {

                LsapFreeLsaHeap( DecryptedFEK );
                DecryptedFEK = NULL;

                LastError = ERROR_DECRYPTION_FAILED;
            }

        } else {

            LastError = ERROR_NOT_ENOUGH_MEMORY;
        }

    } __except (EXCEPTION_EXECUTE_HANDLER) {

          EfspLogAttack(pEfsUserInfo, CORRUPT_DATA_6);
          LastError = ERROR_FILE_CORRUPT;
          if (DecryptedFEK) {
              LsapFreeLsaHeap( DecryptedFEK );
              DecryptedFEK = NULL;
          }

    }


    //
    // Clean up what we allocated.
    //

    if (hKey) {

        CryptDestroyKey( hKey );
        CryptReleaseContext( hProv, 0 );

    }


    SetLastError( LastError );

    return( DecryptedFEK );
}


BOOLEAN
GenerateFEK(
    IN OUT PEFS_KEY *Key
    )

/*++

Routine Description:

    Generates a new File Encryption Key (FEK).

Arguments:

    Key - Supplies a pointer to PEFS_KEY.

Return Value:

    Error if not enough space can be located.


--*/
{
    PBYTE KeyData;
    ULONG   KeyLength;
    BOOL b = FALSE;
    DWORD LiveKeyEntropy;

    //
    // Allocate the buffer for the EFS_KEY.
    // Set the algorithm and key length here.
    //

    switch (EfsAlgInForce) {

        case CALG_3DES:

            //
            // DES3 has no international version
            //

            KeyLength = DES3_KEYSIZE;
            LiveKeyEntropy = DES3_KEY_STRENGTH;
            break;

        case CALG_DESX:
            KeyLength = DESX_KEYSIZE - 8;
            LiveKeyEntropy = KeyEntropy;
            break;

        case CALG_AES_256:
        default:
            
            KeyLength = AES_KEYSIZE_256;
            LiveKeyEntropy = AES_KEY_STRENGTH_256;
            break;

    }

    *Key = (PEFS_KEY)LsapAllocateLsaHeap( sizeof( EFS_KEY ) + KeyLength );
    if ( NULL == *Key ){
        SetLastError(ERROR_OUTOFMEMORY);
        return FALSE;
    }

    (*Key)->KeyLength = KeyLength;
    (*Key)->Algorithm = EfsAlgInForce;


    KeyData = (PBYTE)(((PBYTE)*Key) + sizeof( EFS_KEY ));

    if (b = CryptGenRandom( hProvVerify, (*Key)->KeyLength, KeyData )) {
        (*Key)->Entropy = LiveKeyEntropy;
    } else {
        LsapFreeLsaHeap( *Key );
        *Key = NULL;
    }


    return( b != 0);
}



DWORD
CreatePublicKeyInformationCertificate(
    IN PSID  pUserSid OPTIONAL,
    PBYTE pbCert,
    DWORD cbCert,
    OUT PEFS_PUBLIC_KEY_INFO * PublicKeyInformation
    )
{
    DWORD PublicKeyInformationLength = 0;
    DWORD UserSidLength = 0;
    PWCHAR Base;

    if (pUserSid != NULL) {
        UserSidLength = GetLengthSid( pUserSid );
    }

    //
    // Total size is the size of the public key info structure, the size of the
    // cert hash data structure, the length of the thumbprint, and the lengths of the
    // container name and provider name if they were passed.
    //

    PublicKeyInformationLength = sizeof( EFS_PUBLIC_KEY_INFO )  + UserSidLength + cbCert;

    //
    // Allocate and fill in the PublicKeyInformation structure
    //

    *PublicKeyInformation = (PEFS_PUBLIC_KEY_INFO)LsapAllocateLsaHeap( PublicKeyInformationLength );

    if (*PublicKeyInformation == NULL) {
        return( ERROR_NOT_ENOUGH_MEMORY );
    }

    (*PublicKeyInformation)->Length = PublicKeyInformationLength;
    (*PublicKeyInformation)->KeySourceTag = (ULONG)EfsCertificate;

    //
    // Copy the string and SID data to the end of the structure.
    //

    Base = (PWCHAR)(*PublicKeyInformation);
    Base = (PWCHAR)((PBYTE)Base + sizeof( EFS_PUBLIC_KEY_INFO ));

    if (pUserSid != NULL) {

        (*PublicKeyInformation)->PossibleKeyOwner = (ULONG)POINTER_TO_OFFSET( Base, *PublicKeyInformation );
        CopySid( UserSidLength, (PSID)Base, pUserSid );

    } else {

        (*PublicKeyInformation)->PossibleKeyOwner = 0;
    }

    Base = (PWCHAR)((PBYTE)Base + UserSidLength);

    (*PublicKeyInformation)->CertificateInfo.CertificateLength = cbCert;
    (*PublicKeyInformation)->CertificateInfo.Certificate = (ULONG)POINTER_TO_OFFSET( Base, *PublicKeyInformation );

    memcpy( (PBYTE)Base, pbCert, cbCert );

    return( ERROR_SUCCESS );

}



BOOLEAN
CreatePublicKeyInformationThumbprint(
    IN PSID  pUserSid OPTIONAL,
    IN PBYTE pbCertHash,
    IN DWORD cbCertHash,
    IN LPWSTR lpDisplayInformation OPTIONAL,
    IN LPWSTR ContainerName OPTIONAL,
    IN LPWSTR ProviderName OPTIONAL,
    OUT PEFS_PUBLIC_KEY_INFO * PublicKeyInformation
    )

/*++

Routine Description:

    This routine creates an EFS_PUBLIC_KEY_INFO structure that can be
    placed in an EFS stream.

Arguments:

    ContainerName - The name of the container containing the public key.  This
        parameter is not optional if ProviderName is passed.

    ProviderName - The name of the provider containing the public key.  This
        parameter is not optional if ContainerName is passed.

    pbPublicKeyBlob - The actual public key blob exported from CryptAPI

    KeySource - Data for the KeySource field in the public key structure

    cbPublicKeyBlob - The length of the public key blob in bytes

    PublicKeyInformation - Returns the filled in EFS_PUBLIC_KEY_INFO
        structure.


Return Value:

    ERROR_SUCCESS or ERROR_NOT_ENOUGH_MEMORY as appropriate

--*/
{
    DWORD PublicKeyInformationLength = 0;
    DWORD cbThumbprint = 0;
    DWORD UserSidLength = 0;
    PWCHAR Base;

    if (pUserSid != NULL) {
        UserSidLength = GetLengthSid( pUserSid );
    }

    //
    // Total size is the size of the public key info structure, the size of the
    // cert hash data structure, the length of the thumbprint, and the lengths of the
    // container name and provider name if they were passed.
    //

    PublicKeyInformationLength = sizeof( EFS_PUBLIC_KEY_INFO )  + UserSidLength;

    cbThumbprint = sizeof( EFS_CERT_HASH_DATA ) + cbCertHash;

    if (ContainerName != NULL ) {
        cbThumbprint += (wcslen( ContainerName ) + 1) * sizeof( WCHAR );
    }

    if (ProviderName != NULL ) {
       cbThumbprint += (wcslen( ProviderName ) + 1) * sizeof( WCHAR );
    }

    if (lpDisplayInformation != NULL) {
        cbThumbprint += (wcslen( lpDisplayInformation ) + 1) * sizeof( WCHAR );
    }

    PublicKeyInformationLength += cbThumbprint;

    //
    // Allocate and fill in the PublicKeyInformation structure
    //

    *PublicKeyInformation = (PEFS_PUBLIC_KEY_INFO)LsapAllocateLsaHeap( PublicKeyInformationLength );

    if (*PublicKeyInformation == NULL) {
        SetLastError( ERROR_NOT_ENOUGH_MEMORY );
        return( FALSE );
    }

    (*PublicKeyInformation)->Length = PublicKeyInformationLength;

    //
    // Mark the information as from CryptoAPI, since that's all we support right now.
    //

    (*PublicKeyInformation)->KeySourceTag = (ULONG)EfsCertificateThumbprint;

    //
    // Copy the string and SID data to the end of the structure.
    //

    Base = (PWCHAR)(*PublicKeyInformation);
    Base = (PWCHAR)((PBYTE)Base + sizeof( EFS_PUBLIC_KEY_INFO ));

    if (pUserSid != NULL) {

        (*PublicKeyInformation)->PossibleKeyOwner = (ULONG)POINTER_TO_OFFSET( Base, *PublicKeyInformation );
        CopySid( UserSidLength, (PSID)Base, pUserSid );

    } else {

        (*PublicKeyInformation)->PossibleKeyOwner = (ULONG)0;
    }

    Base = (PWCHAR)((PBYTE)Base + UserSidLength);

    PEFS_CERT_HASH_DATA pCertHashData;

    (*PublicKeyInformation)->CertificateThumbprint.ThumbprintLength = cbThumbprint;
    (*PublicKeyInformation)->CertificateThumbprint.CertHashData = (ULONG)POINTER_TO_OFFSET( Base, *PublicKeyInformation );

    pCertHashData = (PEFS_CERT_HASH_DATA)Base;

    //
    // Zero the header, eliminate the garbage if any of Container, Provide or Display
    // Information is NULL.
    //

    RtlZeroMemory(pCertHashData, sizeof( EFS_CERT_HASH_DATA ));

    Base = (PWCHAR)((PBYTE)Base + sizeof( EFS_CERT_HASH_DATA ));

    //
    // Copy the hash data to the end of the cert hash data block,
    // and set the offset from the *beginning of the cert hash data block
    // (not the beginning of the public key info structure)
    //

    pCertHashData->cbHash = cbCertHash;
    pCertHashData->pbHash = (ULONG)POINTER_TO_OFFSET( Base, pCertHashData );
    memcpy( (PBYTE)Base, pbCertHash, cbCertHash );

    Base = (PWCHAR)((PBYTE)Base + cbCertHash);

    //
    // If we have Container/Provider hint info, copy them in now
    //

    if (ContainerName != NULL) {

        pCertHashData->ContainerName = (ULONG)POINTER_TO_OFFSET( Base, pCertHashData );
        wcscpy( (PWCHAR)Base, ContainerName );

        //
        // wcscpy copies trailing NULL characters, but wcslen doesn't include them in returned lengths,
        // so add 1 to adjust.
        //

        Base += (wcslen( ContainerName ) + 1);

    }

    if (ProviderName != NULL) {

       //
       // Store the offset into the session key structure
       //

       pCertHashData->ProviderName = (ULONG)POINTER_TO_OFFSET( Base, pCertHashData );
       wcscpy( (PWCHAR)Base, ProviderName );

       Base += (wcslen( ProviderName ) + 1);

    }

    if (lpDisplayInformation != NULL) {
        pCertHashData->lpDisplayInformation = (ULONG)POINTER_TO_OFFSET( Base, pCertHashData );
        wcscpy( (PWCHAR)Base, lpDisplayInformation );

        Base += (wcslen( lpDisplayInformation ) + 1);
    }

    return( TRUE );
}


DWORD
ConstructEncryptedKey(
    PBYTE EncryptedFEK,
    DWORD dwEncryptedFEKLength,
    PEFS_PUBLIC_KEY_INFO PublicKeyInformation,
    PEFS_KEY_SALT pEfsKeySalt OPTIONAL,
    OUT PENCRYPTED_KEY *EncryptedKey,
    OUT PDWORD EncryptedKeySize
    )

/*++

Routine Description:

    This routine constructs an ENCRYPTED_KEY structure from the passed
    arguments.

Arguments:

    EncryptedFEK - The encrypted FEK.

    dwEncryptedFEKLength - The length of the encrypted FEK in bytes.

    PublicKeyInformation - The public key information stucture containing
        the public key.

    pEfsKeySalt - Salt block.

    EncryptedKey - Returns the encrypted key structure.

    EncryptedKeySize - Supplies the length of the encrypted
        key structure.  Returns the actual length used or required.

Return Value:

    ERROR_NOT_ENOUGH_MEMORY - Out of memory.

    ERROR_SUCCESS - Success

--*/
{
    //
    // We now have all the information we need to construct the EncryptedKeys structure
    // Compute the total size required
    //

    DWORD KeySize = sizeof( ENCRYPTED_KEY )   +
                    dwEncryptedFEKLength       +
                    PublicKeyInformation->Length;

    if (pEfsKeySalt){
        KeySize += pEfsKeySalt->Length;
    }

    *EncryptedKey = (PENCRYPTED_KEY) LsapAllocateLsaHeap( KeySize );

    if ( NULL == *EncryptedKey ) {
        *EncryptedKeySize = 0;
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    *EncryptedKeySize = KeySize;


    PBYTE Base;

    (*EncryptedKey)->Length = *EncryptedKeySize;
    Base = (PBYTE)(((PBYTE)*EncryptedKey) + sizeof( ENCRYPTED_KEY ));

    //
    // Copy in the public key info structure
    //

    memcpy( Base, PublicKeyInformation, PublicKeyInformation->Length );

    //
    // Save offset to what we just copied.
    //

    (*EncryptedKey)->PublicKeyInfo = (ULONG)POINTER_TO_OFFSET(Base, *EncryptedKey);
    Base += PublicKeyInformation->Length;


    //
    // Copy the FEK, which is a completely encrypted structure
    //

    memcpy( Base, EncryptedFEK, dwEncryptedFEKLength );
    (*EncryptedKey)->EncryptedFEK = (ULONG)POINTER_TO_OFFSET(Base, *EncryptedKey);
    (*EncryptedKey)->EncryptedFEKLength = dwEncryptedFEKLength;
    Base += dwEncryptedFEKLength;

    //
    // Copy the Salt Information
    //

    if (pEfsKeySalt){
        memcpy( Base, pEfsKeySalt, pEfsKeySalt->Length );
        (*EncryptedKey)->EfsKeySalt = (ULONG)POINTER_TO_OFFSET(Base, *EncryptedKey);
    } else {
        (*EncryptedKey)->EfsKeySalt = 0;
    }

    return( ERROR_SUCCESS );
}


PBYTE
EncryptFEK(
    IN PEFS_KEY Fek,
    IN HCRYPTKEY hRSAKey,
    OUT PDWORD dwEncryptedFEKLength
    )
{
    DWORD rc=ERROR_SUCCESS;
    
    *dwEncryptedFEKLength = EFS_KEY_SIZE( Fek );

    //
    // If CryptoAPI worked properly, we wouldn't need this, but it doesn't,
    // so we do.
    //


    if (CryptEncrypt( hRSAKey, 0, TRUE, 0, NULL, dwEncryptedFEKLength, 0 )) {

        DWORD BufferLength = (*dwEncryptedFEKLength < EFS_KEY_SIZE(Fek)) ? EFS_KEY_SIZE(Fek) : *dwEncryptedFEKLength;

        PBYTE EncryptedFEK = (PBYTE)LsapAllocateLsaHeap( BufferLength );

        if (EncryptedFEK != NULL) {

            //
            // Copy the FEK into our new buffer and encrypt it there.
            //

            memcpy( EncryptedFEK, Fek, EFS_KEY_SIZE( Fek ) );

            //
            // Reset the length of the data to be encrypted
            //

            *dwEncryptedFEKLength = EFS_KEY_SIZE( Fek );

            if (CryptEncrypt( hRSAKey, 0, TRUE, 0, EncryptedFEK, dwEncryptedFEKLength, BufferLength )) {
                return( EncryptedFEK );

            } else {

                rc = GetLastError();
                DebugLog((DEB_ERROR, "EncryptFEK: 2nd CryptEncrypt failed, error = %x\n" , rc  ));
            }

            //
            // If we're here, we failed, clean up
            //

            LsapFreeLsaHeap( EncryptedFEK );

        } else {
            rc = ERROR_NOT_ENOUGH_MEMORY;
        }

    } else {

        rc = GetLastError();
        DebugLog((DEB_ERROR, "EncryptFEK: 1st CryptEncrypt failed, error = %x\n" , rc  ));
    }

    if (rc != ERROR_SUCCESS) {
        SetLastError(rc);
    }
    return( NULL );
}

BOOL
RemoveUsersFromEfsStream(
    IN PEFS_DATA_STREAM_HEADER pEfsStream,
    IN DWORD nHashes,
    IN PENCRYPTION_CERTIFICATE_HASH * pHashes,
    IN PEFS_KEY Fek,
    OUT PEFS_DATA_STREAM_HEADER * pNewEfsStream
    )
/*++

Routine Description:

    This routine removes the passed users from the passed EFS
    stream, and returns a new one to be applied to the file.

Arguments:

    argument-name - Supplies | Returns description of argument.
    .
    .

Return Value:

    return-value - Description of conditions needed to return value. - or -
    None.

--*/

{

    //
    // First, see how many matches there are so we can compute
    // the final size of the structure we're going to have to
    // allocate.
    //

    DWORD cbSizeToDelete = 0;
    DWORD nKeysToDelete = 0;
    DWORD rc = ERROR_SUCCESS;
    BOOL b = FALSE;

    PENCRYPTED_KEYS pDDF = (PENCRYPTED_KEYS)OFFSET_TO_POINTER( DataDecryptionField, pEfsStream );

    DWORD KeyCount = pDDF->KeyCount;

    PDWORD KeyIndicesToDelete;

    if (nHashes >= KeyCount) {

        //
        // Possible RPC attack.
        //
        SetLastError(ERROR_ACCESS_DENIED);
        return FALSE;
    }

    SafeAllocaAllocate(KeyIndicesToDelete, KeyCount * sizeof( DWORD ));

    if (KeyIndicesToDelete) {

        memset( KeyIndicesToDelete, 0, KeyCount * sizeof( DWORD ));

        //
        // First pass: walk the list of keys in the DDF and compare each one to the
        // keys in the list of hashes passed.  Count the matches and keep track of the
        // total size of the resulting structure.
        //

        PENCRYPTED_KEY pEncryptedKey = &pDDF->EncryptedKey[0];

        for (DWORD i=0; i<KeyCount ; i++, pEncryptedKey = NEXT_ENCRYPTED_KEY( pEncryptedKey )) {


            PENCRYPTED_KEY pAlignedKey;
            BOOLEAN freeAlignedKey;
    
            rc =  EfsAlignBlock(
                            pEncryptedKey,
                            (PVOID *)&pAlignedKey,
                            &freeAlignedKey
                            );
            if (!pAlignedKey) {
    
                //
                // OOM. Treat it as not current.
                //
    
                rc = ERROR_NOT_ENOUGH_MEMORY; 
                nKeysToDelete = 0;
                break;
    
            }

            PEFS_PUBLIC_KEY_INFO pPublicKeyInfo = (PEFS_PUBLIC_KEY_INFO)OFFSET_TO_POINTER( PublicKeyInfo, pAlignedKey );

            ASSERT( pPublicKeyInfo->KeySourceTag == EfsCertificateThumbprint );

            PEFS_CERT_HASH_DATA CertHashData = (PEFS_CERT_HASH_DATA)OFFSET_TO_POINTER( CertificateThumbprint.CertHashData, pPublicKeyInfo );
            DWORD cbHash = CertHashData->cbHash;
            PBYTE pbHash = (PBYTE)OFFSET_TO_POINTER( pbHash, CertHashData );

            //
            // Compare the hash data with all of the data in the array
            //

            __try{

                for (DWORD j=0; j<nHashes ; j++) {
    
                    PENCRYPTION_CERTIFICATE_HASH pHash = pHashes[j];
                    PEFS_HASH_BLOB pHashBlob = pHash->pHash;
    
                    if (pHashBlob->cbData == cbHash ) {
    
                        if (memcmp( pHashBlob->pbData, pbHash, cbHash ) == 0) {
    
                            //
                            // We have a match.  That means that this entry is going to be removed from
                            // the DDF when it is rebuilt.
                            //
    
                            cbSizeToDelete += pAlignedKey->Length;
                            KeyIndicesToDelete[nKeysToDelete] = i;
                            nKeysToDelete++;
    
                            break;
                        }
                    }
                }
            } __except (EXCEPTION_EXECUTE_HANDLER) {

                //
                // The passed in pHashes is bad
                //

                nKeysToDelete = 0;
                rc = ERROR_INVALID_PARAMETER;
                EfspLogAttack(NULL, CORRUPT_DATA_7);

            }

            if (freeAlignedKey) {
                LsapFreeLsaHeap( pAlignedKey );
            }

            if (ERROR_INVALID_PARAMETER == rc) {
                break;
            }
        }

        if (nKeysToDelete != 0) {

            //
            // We made at least one match.  The size of the new efs stream is the size of
            // the old one minus the size of the stuff we're deleting.
            //

            DWORD cbNewEfsStream = pEfsStream->Length - cbSizeToDelete;
            cbNewEfsStream = (cbNewEfsStream + 7) & 0xfffffff8;

            *pNewEfsStream = (PEFS_DATA_STREAM_HEADER)LsapAllocateLsaHeap( cbNewEfsStream );

            if (*pNewEfsStream) {

                //
                // Copy the old header to the new structure.
                //

                **pNewEfsStream = *pEfsStream;
                ((PEFS_DATA_STREAM_HEADER)*pNewEfsStream)->Length = cbNewEfsStream;

                //
                // Copy the old DDF to the new DDF, skipping the
                // ones we want to delete
                //

                //
                // Base is our target.  Make it point to the end of the header, which
                // is where we're going to start copying the new DDF.
                //

                PBYTE Base = (PBYTE) (((PBYTE)(*pNewEfsStream)) + sizeof( EFS_DATA_STREAM_HEADER ));

                //
                // Set the offset of the new DDF into the header.
                //

                (*pNewEfsStream)->DataDecryptionField = (ULONG)POINTER_TO_OFFSET( Base, *pNewEfsStream );

                //
                // Start to assemble the new DDF
                //

                PENCRYPTED_KEYS pNewDDF = (PENCRYPTED_KEYS)Base;
                pNewDDF->KeyCount = KeyCount - nKeysToDelete;

                Base = (PBYTE)(&pNewDDF->EncryptedKey[0]);
                PBYTE Source = (PBYTE)(&pDDF->EncryptedKey[0]);

                DWORD NextKeyIndexToDelete = 0;

                for (DWORD i=0; i<KeyCount ; i++) {

                    if (KeyIndicesToDelete[NextKeyIndexToDelete] != i) {

                        //
                        // We're not going to delete this one, copy it.
                        //

                        DWORD KeyLength = * (DWORD UNALIGNED *) &(((PENCRYPTED_KEY)Source)->Length);

                        memcpy( Base, Source, KeyLength );

                        Base = (PBYTE)NEXT_ENCRYPTED_KEY( Base );
                        Source = (PBYTE)NEXT_ENCRYPTED_KEY( Source );

                    } else {

                        //
                        // We're going to delete this one.  Leave Base
                        // alone, but bump Source to the next key.
                        //

                        Source = (PBYTE)NEXT_ENCRYPTED_KEY( Source );
                        NextKeyIndexToDelete++;

                    }
                }

                //
                // The new DDF is in place.  Copy the recovery information
                // from the old EFS stream into the new one.
                //
                // Base points to where the DRF needs to go, and Source
                // points to where the old one is (in theory).
                //

                ASSERT( Source == (PBYTE)OFFSET_TO_POINTER( DataRecoveryField, pEfsStream ));

                PENCRYPTED_KEYS pDRF = (PENCRYPTED_KEYS)Source;

                //
                // Set the offset of the new DRF into the new EFS stream.
                //

                if ((PVOID)pDRF == (PVOID)pEfsStream) {

                    //
                    // No DRF in the old $EFS
                    //

                    (*pNewEfsStream)->DataRecoveryField = 0;

                } else {

                    (*pNewEfsStream)->DataRecoveryField = (ULONG)POINTER_TO_OFFSET( Base, *pNewEfsStream );
    
                    //
                    // We can copy the old DRF directly into the new one, since nothing in
                    // it is changing.
                    //
    
                    //
                    // Base now points to the top of an ENCRYPTED_KEYS structure.
                    // Fill in its header.
                    //
    
                    PENCRYPTED_KEYS pNewDRF = (PENCRYPTED_KEYS)Base;
                    
                    *((ULONG UNALIGNED *) &(pNewDRF->KeyCount)) = *((ULONG UNALIGNED *) &(pDRF->KeyCount));
                    KeyCount = *((DWORD UNALIGNED *) &(pDRF->KeyCount));
                    //
                    // That was the header.  Now start copying the
                    // encrypted keys themselves.
                    //
    
                    Base = (PBYTE)(&pNewDRF->EncryptedKey[0]);
                    Source = (PBYTE)(&pDRF->EncryptedKey[0]);
    
                    for (i=0; i<KeyCount ; i++) {
    
                        DWORD KeyLength = * (DWORD UNALIGNED *) &(((PENCRYPTED_KEY)Source)->Length);
    
                        memcpy( Base, Source, KeyLength );
    
                        Base = (PBYTE)NEXT_ENCRYPTED_KEY( Base );
                        Source = (PBYTE)NEXT_ENCRYPTED_KEY( Source );
                    }

                }

                b = TRUE;


//                memset( &((*pNewEfsStream)->EfsHash), 0, MD5_HASH_SIZE );
//                if (EfspChecksumEfs( *pNewEfsStream, Fek )) {
//                    b = TRUE;
//                }

            } else {

                rc = ERROR_NOT_ENOUGH_MEMORY;
            }

        } else {

            if (ERROR_SUCCESS == rc) {
               b = TRUE;
            }

        }

        SafeAllocaFree( KeyIndicesToDelete );

    } else {

        rc = ERROR_NOT_ENOUGH_MEMORY;

    }

    if (!b) {

        //
        // Something failed, clean up what we were going
        // to return.
        //

        if (*pNewEfsStream) {
            LsapFreeLsaHeap( *pNewEfsStream );
            *pNewEfsStream = NULL;  // paranoia
        }
    }

    SetLastError(rc);
    return( b );
}


BOOL
QueryCertsFromEncryptedKeys(
    IN PENCRYPTED_KEYS pEncryptedKeys,
    OUT PDWORD pnUsers,
    OUT PENCRYPTION_CERTIFICATE_HASH ** pHashes
    )
/*++

Routine Description:

    This routine takes a set of encrypted keys and returns the data
    that we wish to display about each one.

Arguments:

    pEncryptedKeys - Supplies the array of encrypted keys.

    pnUsers - Returns the number of users on the file.

    pHashes - Returns the hash information about each user.

Return Value:

    TRUE on success, FALSE on failure.  Call GetLastError() for more details.

--*/

{
    DWORD rc = ERROR_SUCCESS;
    PENCRYPTION_CERTIFICATE_HASH pTmp = NULL;

    //
    // Walk the entries in the encrypted keys and return the information we want about each one.
    //

    DWORD KeyCount = * (DWORD UNALIGNED *) &(pEncryptedKeys->KeyCount);
    *pnUsers = KeyCount;
    PENCRYPTED_KEY pEncryptedKey = &pEncryptedKeys->EncryptedKey[0];

    //
    // *pHashes points to an array of pointers to ENCRYPTION_CERTIFICATE_HASH structures.
    // There will be one entry for each Key on the file
    //

    *pHashes = (PENCRYPTION_CERTIFICATE_HASH *)MIDL_user_allocate( sizeof(PENCRYPTION_CERTIFICATE_HASH) * KeyCount );

    if (*pHashes) {

        memset( *pHashes, 0, sizeof(PENCRYPTION_CERTIFICATE_HASH) * KeyCount );

        for (DWORD i=0;
             i < KeyCount;
             i++, pEncryptedKey = NEXT_ENCRYPTED_KEY( pEncryptedKey )
             ) {


            PENCRYPTED_KEY pAlignedKey;
            BOOLEAN freeAlignedKey;
    
            rc =  EfsAlignBlock(
                            pEncryptedKey,
                            (PVOID *)&pAlignedKey,
                            &freeAlignedKey
                            );
            if (!pAlignedKey) {
    
                //
                // OOM. Treat it as not current.
                //
    
                rc = ERROR_NOT_ENOUGH_MEMORY;
                break;
    
            }

            PEFS_PUBLIC_KEY_INFO pPublicKeyInfo = (PEFS_PUBLIC_KEY_INFO)OFFSET_TO_POINTER( PublicKeyInfo, pAlignedKey );

            ASSERT( pPublicKeyInfo->KeySourceTag == EfsCertificateThumbprint );

            PENCRYPTION_CERTIFICATE_HASH pTmp = (PENCRYPTION_CERTIFICATE_HASH) MIDL_user_allocate( sizeof(ENCRYPTION_CERTIFICATE_HASH ));

            if (pTmp) {

                memset( pTmp, 0, sizeof( ENCRYPTION_CERTIFICATE_HASH ));

                pTmp->cbTotalLength = sizeof( ENCRYPTION_CERTIFICATE_HASH );

                if (pPublicKeyInfo->PossibleKeyOwner) {

                    PSID pUserSid = ( PSID )OFFSET_TO_POINTER( PossibleKeyOwner, pPublicKeyInfo );

                    pTmp->pUserSid = (SID *)MIDL_user_allocate( GetLengthSid( pUserSid ));

                    if (pTmp->pUserSid) {

                        CopySid( GetLengthSid( pUserSid ),
                                 pTmp->pUserSid,
                                 pUserSid
                                 );
                    } else {

                        rc = ERROR_NOT_ENOUGH_MEMORY;
                    }

                } else {

                    pTmp->pUserSid = NULL;
                }

                //
                // Copy the hash
                //

                if (rc == ERROR_SUCCESS) {

                    pTmp->pHash = (PEFS_HASH_BLOB)MIDL_user_allocate( sizeof( EFS_HASH_BLOB ));

                    if (pTmp->pHash) {

                        PEFS_CERT_HASH_DATA CertHashData = (PEFS_CERT_HASH_DATA)OFFSET_TO_POINTER( CertificateThumbprint.CertHashData, pPublicKeyInfo );

                        pTmp->pHash->cbData = CertHashData->cbHash;
                        pTmp->pHash->pbData = (PBYTE)MIDL_user_allocate( pTmp->pHash->cbData );

                        if (pTmp->pHash->pbData) {

                            memcpy( pTmp->pHash->pbData, OFFSET_TO_POINTER( pbHash, CertHashData ), pTmp->pHash->cbData );
                            ASSERT( rc == ERROR_SUCCESS );

                        } else {

                            rc = ERROR_NOT_ENOUGH_MEMORY;
                        }

                        if (rc == ERROR_SUCCESS) {

                            //
                            // Allocate and fill in the display information field.
                            //

                            if (CertHashData->lpDisplayInformation) {

                                LPWSTR lpDisplayInformation = (LPWSTR)OFFSET_TO_POINTER( lpDisplayInformation, CertHashData );

                                pTmp->lpDisplayInformation = (LPWSTR)MIDL_user_allocate( (wcslen( lpDisplayInformation ) + 1) * sizeof( WCHAR ));

                                if (pTmp->lpDisplayInformation) {

                                    wcscpy( pTmp->lpDisplayInformation, lpDisplayInformation );
                                    (pTmp->lpDisplayInformation)[wcslen(lpDisplayInformation)] = UNICODE_NULL;

                                    ASSERT( rc == ERROR_SUCCESS );

                                } else {

                                    rc = ERROR_NOT_ENOUGH_MEMORY;
                                }
                            }
                        }

                    } else {

                        rc = ERROR_NOT_ENOUGH_MEMORY;
                    }
                }

            } else {

                rc = ERROR_NOT_ENOUGH_MEMORY;
            }

            if (rc != ERROR_SUCCESS) {

                //
                // We couldn't successfully build this structure.  Free up
                // all the stuff we were going to return and drop out of the loop.
                //

                if (pTmp) {
                    if (pTmp->pHash) {
                        if (pTmp->pHash->pbData) {
                           MIDL_user_free( pTmp->pHash->pbData );
                        }
                        MIDL_user_free( pTmp->pHash );
                    }
   
                    if (pTmp->lpDisplayInformation) {
                        MIDL_user_free( pTmp->lpDisplayInformation );
                    }
   
                    if (pTmp->pUserSid) {
                        MIDL_user_free( pTmp->pUserSid );
                    }
   
                    MIDL_user_free( pTmp );
                }

                if (freeAlignedKey) {
                    LsapFreeLsaHeap( pAlignedKey );
                }

                break;

            } else {

                (*pHashes)[i] = pTmp;
                if (freeAlignedKey) {
                    LsapFreeLsaHeap( pAlignedKey );
                }
            }
        }

        if (rc != ERROR_SUCCESS) {

            //
            // Something failed along the way, walk down the list of ones
            // we successfully allocated and free them up.  Any partially
            // allocated ones will have been cleaned up above.
            //

            DWORD i=0;

            while ( (*pHashes)[i] ) {

                pTmp = (*pHashes)[i];

                ASSERT( pTmp->pHash );
                ASSERT( pTmp->pHash->pbData );

                MIDL_user_free( pTmp->pHash->pbData );
                MIDL_user_free( pTmp->pHash );
                if (pTmp->lpDisplayInformation) {
                    MIDL_user_free( pTmp->lpDisplayInformation );
                }
                if (pTmp->pUserSid) {
                    MIDL_user_free( pTmp->pUserSid );
                }
                MIDL_user_free( pTmp );

                (*pHashes)[i] = NULL;
                i++;
            }

            MIDL_user_free( *pHashes );
            *pHashes = NULL;
        }

    } else {

        rc = ERROR_NOT_ENOUGH_MEMORY;
    }

    SetLastError( rc );

    return( ERROR_SUCCESS == rc ? TRUE : FALSE );
}


BOOL
EfsErrorToNtStatus(
    IN DWORD WinError,
    OUT PNTSTATUS NtStatus
    )
{
    switch (WinError) {
        case ERROR_ENCRYPTION_FAILED:
            {
                *NtStatus = STATUS_ENCRYPTION_FAILED;
                break;
            }
        case NTE_BAD_KEYSET:
        case CRYPT_E_NOT_FOUND:
        case ERROR_DECRYPTION_FAILED:
            {
                *NtStatus = STATUS_DECRYPTION_FAILED;
                break;
            }
        case ERROR_FILE_ENCRYPTED:
            {
                *NtStatus = STATUS_FILE_ENCRYPTED;
                break;
            }
        case ERROR_NO_RECOVERY_POLICY:
            {
                *NtStatus = STATUS_NO_RECOVERY_POLICY;
                break;
            }
        case ERROR_NO_EFS:
            {
                *NtStatus = STATUS_NO_EFS;
                break;
            }
        case ERROR_WRONG_EFS:
            {
                *NtStatus = STATUS_WRONG_EFS;
                break;
            }
        case ERROR_NO_USER_KEYS:
            {
                *NtStatus = STATUS_NO_USER_KEYS;
                break;
            }
        case ERROR_FILE_NOT_ENCRYPTED:
            {
                *NtStatus = STATUS_FILE_NOT_ENCRYPTED;
                break;
            }
        case ERROR_NOT_EXPORT_FORMAT:
            {
                *NtStatus = STATUS_NOT_EXPORT_FORMAT;
                break;
            }
        case ERROR_OUTOFMEMORY:
            {
                *NtStatus = STATUS_INSUFFICIENT_RESOURCES;
                break;
            }
        case ERROR_ACCESS_DENIED:
            {
                *NtStatus = STATUS_ACCESS_DENIED;
                break;
            }
        default:
            {
                DebugLog((DEB_WARN, "EfsErrorToNtStatus, unable to translate 0x%x\n" , WinError  ));
                return( FALSE );
                break;
            }
    }

    return( TRUE );
}


VOID
DumpBytes(
    PBYTE Blob,
    ULONG Length,
    ULONG IndentLevel
    )
{

    const UINT Columns = 8;
    UINT Rows = Length / Columns;
    if (Length % Columns != 0) {
        Rows++;
    }

    for (UINT j=0; j<Rows ; j++) {
        for (UINT k=0; k<IndentLevel ; k++) {
            DbgPrint("\t");
        }
        for (UINT i=0; i<Columns ; i++) {
            DbgPrint("%02X ",Blob[ j*Columns + i ]);
            if ((j*Columns + i) == Length) {
                break;
            }
        }
        DbgPrint("\n");
    }
}


VOID
DumpPublicKeyInfo(
    PEFS_PUBLIC_KEY_INFO PublicKeyInfo
    )
{
    DbgPrint("\t\tPublicKeyInfo:\n");
    DbgPrint("\t\tLength = 0x%x\n",PublicKeyInfo->Length);

    if (PublicKeyInfo->PossibleKeyOwner != NULL) {

        PWCHAR SidString = ConvertSidToWideCharString( OFFSET_TO_POINTER( PossibleKeyOwner, PublicKeyInfo) );
        DbgPrint("\t\tUserSid = %ws\n",SidString);
        LsapFreeLsaHeap( SidString );

    } else {

        DbgPrint("\t\tUserSid = NULL\n");
    }

    switch (PublicKeyInfo->KeySourceTag) {
        case EfsCryptoAPIContainer:
            {
                DbgPrint("\t\tTag = EfsCryptoAPIContainer\n");
                DbgPrint("\t\tContainerName = %ws\n",OFFSET_TO_POINTER( ContainerInfo.ContainerName, PublicKeyInfo ));
                DbgPrint("\t\tProviderName = %ws\n",OFFSET_TO_POINTER( ContainerInfo.ProviderName, PublicKeyInfo ));

                DbgPrint("\t\tPublicKeyBlobLength = 0x%x\n",PublicKeyInfo->ContainerInfo.PublicKeyBlobLength);

                DumpBytes( (PBYTE)OFFSET_TO_POINTER( ContainerInfo.PublicKeyBlob, PublicKeyInfo ), PublicKeyInfo->ContainerInfo.PublicKeyBlobLength, 2 );

                break;
            }
        case EfsCertificateThumbprint:
            {

                DbgPrint("\t\tTag = EfsCertificateThumbprint\n");
                PEFS_CERT_HASH_DATA CertHashData = (PEFS_CERT_HASH_DATA)OFFSET_TO_POINTER( CertificateThumbprint.CertHashData, PublicKeyInfo );

                LPWSTR ContainerName = NULL;

                if (CertHashData->ContainerName) {
                    LPWSTR ContainerName = (LPWSTR)OFFSET_TO_POINTER( ContainerName ,CertHashData);
                    DbgPrint("\t\tContainerName = %ws\n",ContainerName);
                } else {
                    DbgPrint("\t\tContainerName = NULL\n");
                }

                LPWSTR ProviderName = NULL;

                if (CertHashData->ProviderName) {
                    LPWSTR ProviderName = (LPWSTR)OFFSET_TO_POINTER( ProviderName ,CertHashData);
                    DbgPrint("\t\tProviderName = %ws\n",ProviderName);
                } else {
                    DbgPrint("\t\tProviderName = NULL\n");
                }

                LPWSTR lpDisplayInformation = NULL;

                if (CertHashData->lpDisplayInformation) {
                    LPWSTR lpDisplayInformation = (LPWSTR)OFFSET_TO_POINTER( lpDisplayInformation ,CertHashData);
                    DbgPrint("\t\tlpDisplayInformation = %ws\n",lpDisplayInformation);
                } else {
                    DbgPrint("\t\tlpDisplayInformation = NULL\n");
                }

                DbgPrint("\t\tcbHash = 0x%x\n",CertHashData->cbHash );
                DbgPrint("\t\tpbHash = \n");
                PBYTE pbHash = (PBYTE)OFFSET_TO_POINTER( pbHash, CertHashData );
                DumpBytes( pbHash, CertHashData->cbHash, 2);
                break;
            }
        case EfsCertificate:
            {
                DbgPrint("KeySourceTag of EfsCertificate unexpected\n");
                break;
            }

        default:
            {
                DbgPrint("Unknown KeySourceTag value: %d\n",PublicKeyInfo->KeySourceTag );
                break;
            }
    }
}

VOID
DumpEncryptedKey(
    PENCRYPTED_KEY EncryptedKey
    )
{
    DbgPrint("\tLength = 0x%x\n",EncryptedKey->Length);

    PEFS_PUBLIC_KEY_INFO PublicKeyInfo = (PEFS_PUBLIC_KEY_INFO)OFFSET_TO_POINTER( PublicKeyInfo, EncryptedKey );
    DumpPublicKeyInfo( PublicKeyInfo );

    DbgPrint("\tEncryptedFEKLength = 0x%x\n",EncryptedKey->EncryptedFEKLength);
    DbgPrint("\tEncryptedFEK = \n");
    DumpBytes( (PBYTE)OFFSET_TO_POINTER( EncryptedFEK, EncryptedKey ), EncryptedKey->EncryptedFEKLength, 1 );

}


void
DumpRecoveryKey(
    PRECOVERY_KEY_1_1 pRecoveryKey
    )
{
    DbgPrint("\nRecovery key @ 0x%x\n",pRecoveryKey);

    DbgPrint("Length = 0x%x\n",pRecoveryKey->TotalLength);
    DbgPrint("PublicKeyInfo:\n");
    DumpPublicKeyInfo( &pRecoveryKey->PublicKeyInfo );
}


VOID
DumpEFS(
    PEFS_DATA_STREAM_HEADER Efs
    )
{
    DbgPrint("\nEFS @ 0x%x:\n",Efs);


    DbgPrint("Length = \t\t0x%x\n",Efs->Length);
    DbgPrint("State = \t\t%d\n",Efs->State);
    DbgPrint("EfsVersion = \t\t%d\n",Efs->EfsVersion);
    DbgPrint("CryptoApiVersion = \t%d\n",Efs->CryptoApiVersion);
    DbgPrint("Offset to DDF = \t0x%x\n",Efs->DataDecryptionField);
    DbgPrint("Offset to DRF = \t0x%x\n",Efs->DataRecoveryField);
    DbgPrint("Reserved = \t0x%x\n",Efs->Reserved);

    DbgPrint("\nDDF:\n");

    PENCRYPTED_KEYS Ddf = (PENCRYPTED_KEYS)OFFSET_TO_POINTER( DataDecryptionField, Efs );

    DbgPrint("Number of keys = %d\n",Ddf->KeyCount );

    UINT i;

    PENCRYPTED_KEY EncryptedKey = &Ddf->EncryptedKey[0];
    for (i=0; i<Ddf->KeyCount; i++) {
        DbgPrint("\tKey %d:\n",i);
        DumpEncryptedKey( EncryptedKey );
        EncryptedKey = (PENCRYPTED_KEY)(((PBYTE)EncryptedKey) + EncryptedKey->Length);
    }

    DbgPrint("\nDRF:\n");

    PENCRYPTED_KEYS Drf = (PENCRYPTED_KEYS)OFFSET_TO_POINTER( DataRecoveryField, Efs );

    DbgPrint("Number of keys = %d\n",Drf->KeyCount );

    EncryptedKey = &Drf->EncryptedKey[0];
    for (i=0; i<Drf->KeyCount; i++) {
        DbgPrint("\tKey %d:\n",i);
        DumpEncryptedKey( EncryptedKey );
        EncryptedKey = (PENCRYPTED_KEY)(((PBYTE)EncryptedKey) + EncryptedKey->Length);
    }
}


#if 0

BOOLEAN
EfspChecksumEfs(
    PEFS_DATA_STREAM_HEADER pEFS,
    PEFS_KEY Fek
    )
/*++

Routine Description:

    This routine will checksum the passed EFS stream and fill in the checksum
    field in the header.  Assumes that the checksum field itself is set to 0.

Arguments:

    pEFS - Supplies the EFS stream to be checksum'd.  Assume that this structure
        has been fully filled in.

    Fek - Supplies a pointer to the FEK for the file.

Return Value:

    TRUE on success, FALSE on failure.  Sets LastErrror.

--*/

{
    HCRYPTHASH hHash = 0;
    DWORD dwHashedDataLength = MD5_HASH_SIZE;
    BOOL b = FALSE;
    DWORD rc = ERROR_SUCCESS;


    if (CryptCreateHash( hProvVerify, CALG_MD5, 0, 0, &hHash )) {

        if (CryptHashData( hHash, (PBYTE)pEFS, pEFS->Length, 0 )) {

            if (CryptHashData( hHash, EFS_KEY_DATA( Fek ), Fek->KeyLength, 0 )) {

                if (CryptGetHashParam( hHash, HP_HASHVAL, (PBYTE)(&pEFS->EfsHash), &dwHashedDataLength, 0 )) {

                    ASSERT( dwHashedDataLength == MD5_HASH_SIZE );

                    b = TRUE;

                } else {

                    rc = GetLastError();
                    ASSERT( rc != ERROR_SUCCESS );
                }

            } else {

                rc = GetLastError();
                ASSERT( rc != ERROR_SUCCESS );
            }

        } else {

            rc = GetLastError();
            ASSERT( rc != ERROR_SUCCESS );
        }

        CryptDestroyHash( hHash );

    } else {

        rc = GetLastError();
        ASSERT( rc != ERROR_SUCCESS );
    }


    SetLastError( rc );

    return( b != 0);
}


BOOLEAN
EfspValidateEfsStream(
    PEFS_DATA_STREAM_HEADER pEFS,
    PEFS_KEY Fek
    )
/*++

Routine Description:

    This routine checks the checksum in an EFS stream.

Arguments:

    pEFS - Supplies the EFS stream to be validated.

    Fek - Supplies the FEK of the encrypted file.

Return Value:

    TRUE on success, FALSE on failure.

--*/
{
    DWORD dwHashSize =   MD5_HASH_SIZE  ;

    UCHAR SavedChecksum[ MD5_HASH_SIZE ];
    UCHAR NewCheckSum  [ MD5_HASH_SIZE ];

    BOOL b = FALSE;
    HCRYPTHASH hHash = 0;
    HCRYPTPROV hProv;

    DWORD rc = ERROR_SUCCESS;

    //
    // We have to do the checksum with the checksum in the header
    // zero'd out.  Save the original in a local.
    //

    memcpy( SavedChecksum, &pEFS->EfsHash, MD5_HASH_SIZE );
    memset( &pEFS->EfsHash, 0, MD5_HASH_SIZE );

    if (CryptCreateHash( hProvVerify, CALG_MD5, 0, 0, &hHash )) {

        if (CryptHashData( hHash, (PBYTE)pEFS, pEFS->Length, 0 )) {

            if (CryptHashData( hHash, EFS_KEY_DATA( Fek ), Fek->KeyLength, 0 )) {

                if (CryptGetHashParam( hHash, HP_HASHVAL, NewCheckSum, &dwHashSize, 0 )) {

                    ASSERT( dwHashSize == MD5_HASH_SIZE );

                    if (memcmp( NewCheckSum, SavedChecksum, MD5_HASH_SIZE ) == 0) {
                        b = TRUE;
                    } else {
                        rc = ERROR_ACCESS_DENIED;
                    }

                } else {

                    rc = GetLastError();
                    ASSERT( rc != ERROR_SUCCESS );
                }

            } else {

                rc = GetLastError();
                ASSERT( rc != ERROR_SUCCESS );
            }

        } else {

            rc = GetLastError();
            ASSERT( rc != ERROR_SUCCESS );
        }

        CryptDestroyHash( hHash );

    } else {

        rc = GetLastError();
        ASSERT( rc != ERROR_SUCCESS );
    }


    //
    // Copy back the original
    //

    memcpy( &pEFS->EfsHash, SavedChecksum, MD5_HASH_SIZE );

    SetLastError( rc );

    return( b != 0);
}

#endif

BOOL
GetSaltLength(
    ALG_ID AlgID,
    DWORD *SaltLength,
    DWORD *SaltBlockLength
    )
/*++

Routine Description:

    This routine returns the length of key salt

Arguments:

    AlgID - Encryption Algorithm ID.

    SaltLength - Bytes to be copied from key.

    SaltBlockLength - Bytes of key salt block in $EFS

Return Value:

    TRUE on success, FALSE on failure.
--*/
{
    BOOL b = FALSE;

    switch (AlgID){
        case CALG_DESX:
            *SaltLength = EXPORT_DESX_SALT_LENGTH;
            *SaltBlockLength = (EXPORT_DESX_SALT_LENGTH + 4 ) & 0xfffffffc;
            b = TRUE;
            break;
        default:
            *SaltLength = 0;
            *SaltBlockLength = 0;
            break;
    }
    return b;
}


VOID
EfspUnloadUserProfile(
    IN PEFS_USER_INFO pEfsUserInfo
    )
/*++

Routine Description:

    Cleans up after a call to EfspLoadUserProfile.  Returns impersonating our client.

Arguments:

    pEfsUserInfo - Supplies useful information about the current user.


Return Value:

    None.

--*/

{
    NTSTATUS Status;

    if (!(pEfsUserInfo->hThreadToken)) {

        //
        // The profile was not loaded by EFS.
        //

        ASSERT( pEfsUserInfo->hProfile == NULL);
        return;

    }

    RevertToSelf();

    (VOID) UnloadUserProfile (pEfsUserInfo->hThreadToken, pEfsUserInfo->hProfile);
    pEfsUserInfo->hProfile = NULL;

    //
    // Start impersonating again
    //

    Status = NtSetInformationThread(
                NtCurrentThread(),
                ThreadImpersonationToken,
                (PVOID) &(pEfsUserInfo->hThreadToken),
                sizeof(HANDLE)
                );

    if (!NT_SUCCESS( Status )) {
        DebugLog((DEB_ERROR, "EfspUnloadUserProfile: NtSetInformationThread returned %x\n" ,Status  ));
    }

    NtClose( pEfsUserInfo->hThreadToken );
    pEfsUserInfo->hThreadToken = NULL;

    return;
}

VOID
EfspFreeUserCache( 
    IN PUSER_CACHE pUserCache
    )
{
    if (pUserCache == NULL){
        return;
    }
    if (pUserCache->UserId) {

        LsapFreeLsaHeap( pUserCache->UserId );

    }
    if (pUserCache->pbHash) {

         LsapFreeLsaHeap( pUserCache->pbHash );

    }

    if (pUserCache->ContainerName) {

         LsapFreeLsaHeap( pUserCache->ContainerName );

    }
    if (pUserCache->DisplayInformation) {

         LsapFreeLsaHeap( pUserCache->DisplayInformation );

    }
    if (pUserCache->ProviderName) {

         LsapFreeLsaHeap( pUserCache->ProviderName );

    }
    if (pUserCache->hUserKey) {

       CryptDestroyKey( pUserCache->hUserKey );

    }
    if (pUserCache->hProv) {

       CryptReleaseContext( pUserCache->hProv, 0 );

    }

    LsapFreeLsaHeap( pUserCache );

}

VOID
EfspReleaseUserCache(
    IN PUSER_CACHE pUserCache
    )

/*++

Routine Description:

    Decrease the ref count increased by the EfspGetUserCache

Arguments:

    pUserCache - Cache node

Return Value:

    
--*/
{
    RtlEnterCriticalSection( &GuardCacheListLock );
    pUserCache->UseRefCount-- ;
    RtlLeaveCriticalSection( &GuardCacheListLock );
}

PUSER_CACHE
EfspGetUserCache(
    IN OUT PEFS_USER_INFO pEfsUserInfo
    )
/*++

Routine Description:

    This routine will try to find the user's cert info in the cache list.
    
    If return not NULL, this call must be balanced with a EfspReleaseUserCache(PUSER_CACHE pUserCache)

Arguments:

    pEfsUserInfo - User Info

Return Value:

    User cache list node, if match found in the cache.
    NULL if not found.
    
--*/
{
    PLIST_ENTRY pListHead, pLink;
    PUSER_CACHE pUserCache;
    LONG        InterActiveUser = pEfsUserInfo->InterActiveUser;
    BOOLEAN     CacheFound = FALSE;

    //
    // Check to see if there is cache available
    //

    pEfsUserInfo->UserCacheStop = FALSE;

    RtlEnterCriticalSection( &GuardCacheListLock );

    if (UserCacheList.Flink == &UserCacheList) {

        //
        // list empty
        //

        RtlLeaveCriticalSection( &GuardCacheListLock );
        return NULL;
    }
    for (pLink = UserCacheList.Flink; pLink != &UserCacheList; pLink = pLink->Flink) {
        pUserCache = CONTAINING_RECORD(pLink, USER_CACHE, CacheChain);

        ASSERT( pLink );
        ASSERT( pLink->Flink );

        if (InterActiveUser == USER_INTERACTIVE) {

            CacheFound = (pEfsUserInfo->AuthId.LowPart == pUserCache->AuthId.LowPart) &&
                         (pEfsUserInfo->AuthId.HighPart == pUserCache->AuthId.HighPart);

        } else {

            //
            //  For remote user, use SID.
            //

            if (pUserCache->UserId != NULL) {

                CacheFound = RtlEqualSid( pEfsUserInfo->pTokenUser->User.Sid, pUserCache->UserId );

            } else {

                CacheFound = FALSE;

            }


        }

        if ( CacheFound ) {

            //
            //  Find the cache node. Hold it
            //

            if (pUserCache->StopUseCount) {

                //
                //  Free cache waiting
                //  When cache for a session is stopped, both interactive and non-interactive should be stopped
                //

                pEfsUserInfo->UserCacheStop = TRUE;

                RtlLeaveCriticalSection( &GuardCacheListLock );
                return NULL;

            }


            pUserCache->UseRefCount++;
            RtlLeaveCriticalSection( &GuardCacheListLock );
            return pUserCache;

        }

    }
    RtlLeaveCriticalSection( &GuardCacheListLock );

    return NULL;
}


BOOLEAN
EfspAddUserCache(
    IN  PUSER_CACHE pUserCache
    )
/*++

Routine Description:

    This routine will try to add the user's cert info in the cache list.
    
    If return TRUE, this call must be balanced with a EfspReleaseUserCache(PUSER_CACHE pUserCache)

Arguments:

    pUserCache - User Cache node.

Return Value:

    TRUE if added successfully
    FALSE if the list is full.
    
--*/
{
    PLIST_ENTRY pListHead, pLink;
    PUSER_CACHE pUserTmpCache;

    RtlEnterCriticalSection( &GuardCacheListLock );

    if (UserCacheListCount >= UserCacheListLimit) {

        //
        // Let's see if we can kick someone out.
        //

        pLink = UserCacheList.Blink;
        while ( pLink != &UserCacheList ){

            pUserTmpCache = CONTAINING_RECORD(pLink, USER_CACHE, CacheChain);

            ASSERT( pLink );
            ASSERT( pLink->Blink );

            pLink = pLink->Blink;
            if ( pUserTmpCache->UseRefCount <= 0 ){

                //
                // No one is using it. Let's remove it.
                //

                RemoveEntryList(&( pUserTmpCache->CacheChain ));
                UserCacheListCount--;
                EfspFreeUserCache( pUserTmpCache );
                break;

            }
        }

        if (UserCacheListCount >= UserCacheListLimit) {
            RtlLeaveCriticalSection( &GuardCacheListLock );
            return FALSE;
        }

    }


    
    InsertHeadList(&UserCacheList, &( pUserCache->CacheChain ));
    UserCacheListCount++;

    RtlLeaveCriticalSection( &GuardCacheListLock );
    return TRUE;
}


BOOLEAN
EfspGetUserInfo(
    IN OUT PEFS_USER_INFO pEfsUserInfo
    )

/*++

Routine Description:

    This routine obtains all the interesting information about the user
    that we're going to need later.

Arguments:

    pEfsUserInfo - Supplies a pointer to an EfsUserInfo structure which
        will be filled in.

Return Value:

    return-value - Description of conditions needed to return value. - or -
    None.

--*/

{
    NTSTATUS Status;
    BOOLEAN fReturn = FALSE;
    DWORD rc = ERROR_SUCCESS;

    memset( pEfsUserInfo, 0, sizeof( EFS_USER_INFO ));

    Status = EfspGetUserName(pEfsUserInfo);

    if (NT_SUCCESS( Status )) {

        EfspIsDomainUser( pEfsUserInfo->lpDomainName, &pEfsUserInfo->bDomainAccount );

        EfspIsSystem( pEfsUserInfo, &pEfsUserInfo->bIsSystem );
        if (pEfsUserInfo->bIsSystem) {
            pEfsUserInfo->bDomainAccount = FALSE;
        }

        fReturn = TRUE;
    
        pEfsUserInfo->pUserCache = EfspGetUserCache( pEfsUserInfo );


    } else {

        rc = RtlNtStatusToDosError( Status );
    }

    SetLastError( rc );

    return( fReturn );
}

VOID
EfspFreeUserInfo(
    IN PEFS_USER_INFO pEfsUserInfo
    )
/*++

Routine Description:

    Frees the memory allocated by EfspGetUserInfo().  Does
    not free the passed structure.

Arguments:

    pEfsUserInfo - Supplies a pointer to the structure to be
        de-allocated.


Return Value:

    None.

--*/
{
    if (pEfsUserInfo->lpUserName) {
        LsapFreeLsaHeap( pEfsUserInfo->lpUserName );
    }

    if (pEfsUserInfo->lpDomainName) {
        LsapFreeLsaHeap( pEfsUserInfo->lpDomainName );
    }

    if (pEfsUserInfo->lpProfilePath) {
        LsapFreeLsaHeap( pEfsUserInfo->lpProfilePath );
    }

    if (pEfsUserInfo->pTokenUser) {
        LsapFreeLsaHeap( pEfsUserInfo->pTokenUser );
    }

    if (pEfsUserInfo->lpUserSid) {
        UNICODE_STRING Dummy;
        Dummy.Buffer = pEfsUserInfo->lpUserSid;
        RtlFreeUnicodeString(&Dummy);
    }

    if (pEfsUserInfo->lpKeyPath) {
        LsapFreeLsaHeap( pEfsUserInfo->lpKeyPath );
    }

    ASSERT(pEfsUserInfo->hProfile == NULL);
    ASSERT(pEfsUserInfo->hThreadToken == NULL);

    if (pEfsUserInfo->hProfile && pEfsUserInfo->hThreadToken) {

        //
        // If we get here, we already did something wrong.
        //

        RevertToSelf();

        UnloadUserProfile (pEfsUserInfo->hThreadToken, pEfsUserInfo->hProfile);

        (void)NtSetInformationThread(
                NtCurrentThread(),
                ThreadImpersonationToken,
                (PVOID) &(pEfsUserInfo->hThreadToken),
                sizeof(HANDLE)
                );
    
        NtClose( pEfsUserInfo->hThreadToken );

        pEfsUserInfo->hProfile = NULL;
        pEfsUserInfo->hThreadToken = NULL;

    }

    if (pEfsUserInfo->pUserCache) {
/*
#if DBG

        DbgPrint("Cache Ref Count Before Release = %ld\n",pEfsUserInfo->pUserCache->UseRefCount);

#endif
*/

        EfspReleaseUserCache(pEfsUserInfo->pUserCache);
/*
#if DBG

        DbgPrint("Cache Ref Count After Release = %ld\n",pEfsUserInfo->pUserCache->UseRefCount);

#endif
*/

    }

    return;
}


BOOL
EfspLoadUserProfile(
    IN  PEFS_USER_INFO pEfsUserInfo,
    IN  BOOLEAN        bForceLoad
    )
/*++

Routine Description:

    This routine attempts to determine if the user's profile is loaded,
    and if it is not, loads it.

    Callers are expected to call EfspUnloadUserProfile() during their cleanup.

Arguments:

    pEfsUserInfo - Supplies useful information about the current user.
    
    bForceLoad - TRUE to load profile if cache is already existed.

Return Value:

    TRUE if the profile is already loaded or if this routine loads it successfully,
    FALSE otherwise.

--*/

{
    DWORD           rc                 = ERROR_SUCCESS;

    BOOLEAN         b                  = FALSE;
    BOOL            fReturn            = FALSE;

    LPWSTR          lpServerName       = NULL;
    PUSER_INFO_3    lpUserInfo         = NULL;
    LPWSTR          lpLocalProfilePath = NULL;

    BOOLEAN         DomainUser         = pEfsUserInfo->bDomainAccount;
    BOOLEAN         IsSystem           = pEfsUserInfo->bIsSystem;
    LPWSTR          lpDomainName       = pEfsUserInfo->lpDomainName;
    LPWSTR          lpProfilePath      = pEfsUserInfo->lpProfilePath;
    LPWSTR          lpUserName         = pEfsUserInfo->lpUserName;
    LPWSTR          SidString          = pEfsUserInfo->lpUserSid;

    NTSTATUS        Status;

    PDOMAIN_CONTROLLER_INFO DomainControllerInfo = NULL;

    if (IsSystem) {
        return TRUE;
    }

    if (pEfsUserInfo->InterActiveUser == USER_INTERACTIVE) {
        return TRUE;
    }

    if (!bForceLoad && pEfsUserInfo->pUserCache) {

        //
        // We found a cache for the non-interactive logged on user.
        // Do not load the user profile if not froced to.
        //

        return TRUE;
    }

    if (pEfsUserInfo->hProfile) {

        //
        // Profile alread loaded
        //

        return TRUE;

    }

    Status = NtOpenThreadToken(
                 NtCurrentThread(),
                 TOKEN_QUERY | TOKEN_IMPERSONATE | TOKEN_DUPLICATE,
                 TRUE,                    // OpenAsSelf
                 &(pEfsUserInfo->hThreadToken)
                 );

    if (NT_SUCCESS( Status )) {

        LONG lRet;
        HKEY phKeyCurrentUser;

        lRet = RegOpenKeyExW(
                      HKEY_USERS,
                      SidString,
                      0,      // dwOptions
                      MAXIMUM_ALLOWED,
                      &phKeyCurrentUser
                      );

        if (ERROR_SUCCESS == lRet) {

            //
            // The profile is loaded.  Ref it so it doesn't disappear.
            //

            PROFILEINFO pi;

            ZeroMemory (&pi, sizeof(pi));
            pi.dwSize = sizeof(pi);
            pi.lpUserName = lpUserName;
            pi.dwFlags = PI_LITELOAD;

            //
            // Cannot be impersonating when loading the profile
            //

            RevertToSelf();

            __try {

                fReturn = LoadUserProfile (pEfsUserInfo->hThreadToken, &pi);

            } __except( EXCEPTION_EXECUTE_HANDLER ) {

                  fReturn = FALSE;
                  SetLastError( GetExceptionCode() );
            }

            if (!fReturn) {

                rc = GetLastError();

            } else {

                pEfsUserInfo->hProfile = pi.hProfile;
            }

            //
            // Start impersonating again
            //

            Status = NtSetInformationThread(
                        NtCurrentThread(),
                        ThreadImpersonationToken,
                        (PVOID) &(pEfsUserInfo->hThreadToken),
                        sizeof(HANDLE)
                        );

            if (!NT_SUCCESS( Status )) {

                //
                // Well, if we can't start impersonating again,
                // we're not going to be able to continue the operation.
                // So unload the profile and fail this whole thing.
                //

                if (fReturn) {
                    (VOID) UnloadUserProfile (pEfsUserInfo->hThreadToken, pEfsUserInfo->hProfile);
                    NtClose( pEfsUserInfo->hThreadToken );
                    pEfsUserInfo->hThreadToken = NULL;
                    pEfsUserInfo->hProfile = NULL;
                }

                fReturn = FALSE;
                DebugLog((DEB_ERROR, "EfspLoadUserProfile: Unloading profile, NtSetInformationThread returned %x\n" ,Status  ));

                rc = RtlNtStatusToDosError( Status );
            }

            RegCloseKey( phKeyCurrentUser );

        } else {

            //
            // The profile is not loaded.  Load it.
            //

            if (IsSystem) {

                lpLocalProfilePath = NULL;
                DebugLog((DEB_TRACE_EFS, "Attempting to open stream from System context\n"   ));

            } else {

                if (lpProfilePath != NULL) {

                    //
                    // We got the profile path from the logon information.
                    //

                    DebugLog((DEB_TRACE_EFS, "Got profile path %ws from logon information", lpProfilePath ));

                    //
                    // Do this up here so we can have common code below.
                    //

                    // RevertToSelf();

                    lpLocalProfilePath = lpProfilePath;

                } else {

                    //
                    // We didn't get a profile path from the logon information,
                    // do it the slow way.
                    //

                    DebugLog((DEB_TRACE_EFS, "Attempting to compute profile information\n"   ));

                    BOOLEAN fGotServerName = TRUE;

                    if (DomainUser) {

                        //
                        // Determine the name of the DC for this domain
                        //

                        rc = DsGetDcName(
                                 NULL,
                                 lpDomainName,
                                 NULL,
                                 NULL,
                                 NULL,
                                 &DomainControllerInfo
                                 );

                        if (ERROR_SUCCESS == rc) {

                            lpServerName = DomainControllerInfo->DomainControllerName;

                        } else {

                            DebugLog((DEB_ERROR, "Failed to obtain DC Name from DsGetDcName, error = %d\n" ,rc  ));
                            fGotServerName = FALSE;
                        }

                    } else {

                        //
                        // Local user, query the local machine
                        //

                        lpServerName = NULL;
                    }

                    if (fGotServerName) {

                        //
                        // Need to do this so that NetUserGetInfo will work.
                        // If we don't, the server may fail trying to impersonate us,
                        // and then the API will fail.  If we revert, then it will only
                        // fail if the machine has been denied access.
                        //

                        // RevertToSelf();

                        rc = NetUserGetInfo( lpServerName, lpUserName, 3, (LPBYTE *)&lpUserInfo );

                        if (ERROR_SUCCESS == rc) {

                            lpLocalProfilePath = lpUserInfo->usri3_profile;

                        } else {

                            DebugLog((DEB_ERROR, "NetUserGetInfo failed, error = %d\n" ,rc  ));

                        }
                    }
                }
            }

            //
            // Make sure we revert before calling LoadUserProfile
            //

            RevertToSelf();

            //
            // We have a profile path.  Note that it may be NULL.
            //

            DebugLog((DEB_TRACE_EFS, "Loading profile path %ws\n" , (lpLocalProfilePath == NULL ? L"NULL" : lpLocalProfilePath)));

            PROFILEINFO pi;

            ZeroMemory (&pi, sizeof(pi));
            pi.dwSize = sizeof(pi);
            pi.lpUserName = lpUserName;
            pi.lpProfilePath = lpLocalProfilePath;
            pi.dwFlags = PI_LITELOAD;

            __try {

                fReturn = LoadUserProfile (pEfsUserInfo->hThreadToken, &pi);

            } __except( EXCEPTION_EXECUTE_HANDLER ) {

                  fReturn = FALSE;
                  SetLastError( GetExceptionCode() );
            }

            if (!fReturn) {

                NtClose( pEfsUserInfo->hThreadToken );
                pEfsUserInfo->hThreadToken = NULL;
                rc = GetLastError();
                DebugLog((DEB_ERROR, "LoadUserProfile failed, error = %d\n" ,rc  ));

            } else {

                pEfsUserInfo->hProfile = pi.hProfile;
            }

            //
            // Start impersonating again, at least until LoadUserProfile
            // stops turning off impersonation.
            //

            Status = NtSetInformationThread(
                        NtCurrentThread(),
                        ThreadImpersonationToken,
                        (PVOID) &(pEfsUserInfo->hThreadToken),
                        sizeof(HANDLE)
                        );

            if (!NT_SUCCESS( Status )) {

                fReturn = FALSE;
                DebugLog((DEB_ERROR, "EfspLoadUserProfile: NtSetInformationThread returned %x\n" ,Status  ));
                
                (VOID) UnloadUserProfile (pEfsUserInfo->hThreadToken, pEfsUserInfo->hProfile);
                NtClose( pEfsUserInfo->hThreadToken );
                pEfsUserInfo->hThreadToken = NULL;
                pEfsUserInfo->hProfile = NULL;

                rc = RtlNtStatusToDosError( Status );
            }

            if (lpUserInfo != NULL) {
                NetApiBufferFree( lpUserInfo );
            }
        }

        if (lpServerName) {
            NetApiBufferFree( DomainControllerInfo );
        }

        if (!fReturn) {

            //
            // We did not succeed for some reason.
            // Clean up what we were going to return.
            //

            if (pEfsUserInfo->hThreadToken) {
                NtClose( pEfsUserInfo->hThreadToken );
                pEfsUserInfo->hThreadToken = NULL;
            }
        }

    } else {

        SetLastError( RtlNtStatusToDosError( Status ));
    }

    SetLastError( rc );

    return( fReturn );
}

DWORD
GenerateDRF(
    IN  PEFS_KEY  Fek,
    OUT PENCRYPTED_KEYS *pNewDRF,
    OUT DWORD *cbDRF
    )
{
    DWORD rc;
    DWORD    DRFKeyCount;
    DWORD    DRFStatus;
    PBYTE  * DRFPublicKeys;
    DWORD  * DRFPublicKeyLengths;
    PBYTE  * DRFCertHashes;
    DWORD  * DRFCertHashLengths;
    LPWSTR * DRFDisplayInformation;
    PSID   * pDRFSid;

    *pNewDRF = NULL;
    *cbDRF = 0;

    rc = GetRecoveryData(
            &DRFKeyCount,
            &DRFStatus,
            &DRFPublicKeys,
            &DRFPublicKeyLengths,
            &DRFCertHashes,
            &DRFCertHashLengths,
            &DRFDisplayInformation,
            &pDRFSid
            );

    if (rc == ERROR_SUCCESS) {

        if (DRFKeyCount > 0) {

            rc = ConstructKeyRing(
                    Fek,
                    DRFKeyCount,
                    NULL,         // No key name information for recovery agents
                    NULL,
                    DRFPublicKeys,
                    DRFPublicKeyLengths,
                    DRFCertHashes,
                    DRFCertHashLengths,
                    DRFDisplayInformation,
                    pDRFSid,
                    FALSE,
                    pNewDRF,
                    cbDRF
                    );

        } else {

            //
            // No DRF will be returned
            //

            if (DRFStatus < RECOVERY_POLICY_OK) {

                //
                // EFS will go ahead with encryption without DRF
                //

                rc = ERROR_SUCCESS;


            } else {

                rc = ERROR_BAD_RECOVERY_POLICY; 

            }

        }
    }

    return rc;
}

BOOLEAN
EqualEncryptedKeys(
    IN PENCRYPTED_KEYS SrcKeys, 
    IN PENCRYPTED_KEYS DstKeys, 
    IN DWORD           cbDstKeys
    )
/*++

Routine Description:

    This routine compares two encrypted key arrays.

Arguments:

    SrcKeys - Source key arrays.

    DstKeys - Destination key arrays.

    cbDstKeys - Destination key array size.

Return Value:

    TRUE if equal,
    FALSE otherwise.

--*/
{
    DWORD cbSrcKeys = 0;
    ULONG KeyCount =  *(ULONG UNALIGNED *) &(SrcKeys->KeyCount);
    PENCRYPTED_KEY pEncryptedKey;
    ULONG keyLength;

    if (KeyCount != DstKeys->KeyCount ) {
        return FALSE;
    }
        
    pEncryptedKey = &(SrcKeys->EncryptedKey[0]);
 
    while ( KeyCount > 0 ) {
        keyLength = * (ULONG UNALIGNED *) &(pEncryptedKey->Length);
        cbSrcKeys += keyLength;
        pEncryptedKey = (PENCRYPTED_KEY)( ((PBYTE)pEncryptedKey) + keyLength );
        KeyCount--;
    }

    cbSrcKeys += (sizeof ( ENCRYPTED_KEYS ) - sizeof( ENCRYPTED_KEY ));

    if ( cbSrcKeys != cbDstKeys ) {

        return FALSE;

    }

    return RtlEqualMemory( SrcKeys, DstKeys, cbDstKeys);

}

DWORD
EfsGetCertNameFromCertContext(
    PCCERT_CONTEXT CertContext,
    LPWSTR * UserDispName
    )
/*++
Routine Description:
    Get the user name from the certificate
Arguments:
    CertContext -- Cert Context
    UserCertName -- User Common Name ( Caller is responsible to delete this memory )
Return Value:
     ERROR_SUCCESS if succeed.
     If No Name found. "USER_UNKNOWN is returned".
--*/

{
    DWORD   NameLength;
    DWORD   UserNameBufLen = 0;
    DWORD   BlobLen = 0;
    PCERT_EXTENSION AlterNameExt = NULL;
    BOOL    b;
    LPWSTR  DNSName = NULL;
    LPWSTR  UPNName = NULL;
    LPWSTR  CommonName = NULL;
    DWORD   rc = ERROR_SUCCESS;

    if ( NULL == UserDispName ){
        return ERROR_SUCCESS;
    }

    *UserDispName = NULL;

    AlterNameExt = CertFindExtension(
            szOID_SUBJECT_ALT_NAME2,
            CertContext->pCertInfo->cExtension,
            CertContext->pCertInfo->rgExtension
            );

    if (AlterNameExt){

        //
        // Find the alternative name
        //

        b = CryptDecodeObject(
                X509_ASN_ENCODING | PKCS_7_ASN_ENCODING,
                szOID_SUBJECT_ALT_NAME ,
                AlterNameExt->Value.pbData,
                AlterNameExt->Value.cbData,
                0,
                NULL,
                &BlobLen
                );
        if (b){

            //
            // Let's decode it
            //

            CERT_ALT_NAME_INFO *AltNameInfo = NULL;

            SafeAllocaAllocate(AltNameInfo, BlobLen);

            if (AltNameInfo){

                b = CryptDecodeObject(
                        X509_ASN_ENCODING | PKCS_7_ASN_ENCODING,
                        szOID_SUBJECT_ALT_NAME,
                        AlterNameExt->Value.pbData,
                        AlterNameExt->Value.cbData,
                        0,
                        AltNameInfo,
                        &BlobLen
                        );
                if (b){

                    //
                    // Now search for the UPN, SPN, DNS, EFS name
                    //

                    DWORD   cAltEntry = AltNameInfo->cAltEntry;
                    DWORD   ii = 0;

                    while (ii < cAltEntry){
                        if ((AltNameInfo->rgAltEntry[ii].dwAltNameChoice == CERT_ALT_NAME_OTHER_NAME ) &&
                             !strcmp(szOID_NT_PRINCIPAL_NAME, AltNameInfo->rgAltEntry[ii].pOtherName->pszObjId)
                            ){

                            //
                            // We found the UPN name
                            //

                            CERT_NAME_VALUE* CertUPNName = NULL;

                            b = CryptDecodeObject(
                                    X509_ASN_ENCODING | PKCS_7_ASN_ENCODING,
                                    X509_UNICODE_ANY_STRING,
                                    AltNameInfo->rgAltEntry[ii].pOtherName->Value.pbData,
                                    AltNameInfo->rgAltEntry[ii].pOtherName->Value.cbData,
                                    0,
                                    NULL,
                                    &BlobLen
                                    );
                            if (b){

                                SafeAllocaAllocate(CertUPNName, BlobLen);

                                if (CertUPNName){
                                    b = CryptDecodeObject(
                                            X509_ASN_ENCODING | PKCS_7_ASN_ENCODING,
                                            X509_UNICODE_ANY_STRING,
                                            AltNameInfo->rgAltEntry[ii].pOtherName->Value.pbData,
                                            AltNameInfo->rgAltEntry[ii].pOtherName->Value.cbData,
                                            0,
                                            CertUPNName,
                                            &BlobLen
                                            );
                                    if (b){

                                        SafeAllocaAllocate(UPNName,
                                                           CertUPNName->Value.cbData + sizeof(WCHAR));

                                        if (UPNName){
                                            wcscpy(UPNName, (LPCWSTR) CertUPNName->Value.pbData);
                                        }
                                    }

                                    SafeAllocaFree(CertUPNName);

                                    if (UPNName){

                                        //
                                        // Got the UPN name. Stop searching.
                                        //
                                        break;
                                    }
                                }
                            }

                                            
                        } else {

                            //
                            // Check for other alternative name
                            //

                            if (AltNameInfo->rgAltEntry[ii].dwAltNameChoice == CERT_ALT_NAME_DNS_NAME){
                                DNSName = AltNameInfo->rgAltEntry[ii].pwszDNSName;
                            } 

                        }

                        ii++;

                    }

                    if ( NULL == UPNName ){

                        //
                        // No UPN name, let's get the other option
                        //

                        if (DNSName){

                            SafeAllocaAllocate(UPNName, sizeof(WCHAR) * (wcslen( DNSName ) + 1));

                            if (UPNName){
                                wcscpy(UPNName, DNSName);
                            }
                        }
                    }
                }

                SafeAllocaFree(AltNameInfo);
            }
        }
    }


    NameLength = CertGetNameString(
                                CertContext,
                                CERT_NAME_SIMPLE_DISPLAY_TYPE,
                                0,
                                NULL,
                                NULL,
                                0
                                );

    if ( NameLength > 1){

        //
        // The display name exist. Go get the display name.
        //

        SafeAllocaAllocate(CommonName, sizeof(WCHAR) * NameLength);

        if ( NULL == CommonName ){

            SafeAllocaFree( UPNName );

            return ERROR_NOT_ENOUGH_MEMORY;
        }

        UserNameBufLen = NameLength;
        NameLength = CertGetNameString(
                                    CertContext,
                                    CERT_NAME_SIMPLE_DISPLAY_TYPE,
                                    0,
                                    NULL,
                                    CommonName,
                                    UserNameBufLen
                                    );

        ASSERT (NameLength == UserNameBufLen);
    } 


    if (CommonName || UPNName){

        NameLength = 3;
        if (CommonName){
            NameLength += wcslen(CommonName);
        }
        if (UPNName){
            NameLength += wcslen(UPNName);
        }
        

        *UserDispName = (LPWSTR)LsapAllocateLsaHeap(sizeof(WCHAR) * NameLength);
        if (*UserDispName) {
            if (CommonName){
                wcscpy(*UserDispName, CommonName);
                if (UPNName){
                    wcscat(*UserDispName, L"(");
                    wcscat(*UserDispName, UPNName);
                    wcscat(*UserDispName, L")");
                }
            } else {
                wcscpy(*UserDispName, UPNName);
            }
        } else {
            rc = ERROR_NOT_ENOUGH_MEMORY;
        }

        SafeAllocaFree( CommonName );
        SafeAllocaFree( UPNName );

        return rc;
    } 

    return DISP_E_UNKNOWNNAME;
}


DWORD
EfsAddCertToCertStore(
    IN PCCERT_CONTEXT pCert,
    IN LPCWSTR pStoreName,
    OUT DWORD   *ImpersonationError
    )

/*++

Routine Description:

    This routine adds the cert to the LM Trusted store.

Arguments:

    pCert -- The cert to be added.
    pStoreName -- LM store name.
    ImpersonationError -- Error indicate that we could impersonate after revert to self. This should not be the case.
    
Return Value:

    Win32 error code
    
--*/
{


    NTSTATUS        Status;
    HANDLE          hToken;
    DWORD           errCode = ERROR_SUCCESS;
    HCERTSTORE      localStore;

    *ImpersonationError = 0;
    Status = NtOpenThreadToken(
                 NtCurrentThread(),
                 TOKEN_QUERY | TOKEN_IMPERSONATE,
                 TRUE,                    // OpenAsSelf
                 &hToken
                 );

    if (NT_SUCCESS( Status )) {

        RevertToSelf();

        localStore = CertOpenStore(
                            CERT_STORE_PROV_SYSTEM_W,
                            0,       // dwEncodingType
                            0,       // hCryptProv,
                            CERT_SYSTEM_STORE_LOCAL_MACHINE  | CERT_STORE_MAXIMUM_ALLOWED_FLAG,
                            pStoreName
                            );
        if (localStore) {
            LPWSTR crntUserName;
            LPWSTR userName;
            PCCERT_CONTEXT userCert = NULL;
            CERT_ENHKEY_USAGE certEnhKeyUsage;
            LPSTR lpstr = szOID_EFS_CRYPTO;

            certEnhKeyUsage.cUsageIdentifier = 1;
            certEnhKeyUsage.rgpszUsageIdentifier  = &lpstr;

            errCode = EfsGetCertNameFromCertContext(
                                pCert,
                                &crntUserName
                                );

            if (crntUserName) {

                //
                // Let's enumerate the certs in the store to see if we need to remove the old similar
                // EFS cert.
                //

                do {

                    userCert = CertFindCertificateInStore(
                                       localStore,
                                       X509_ASN_ENCODING,
                                       0, //CERT_FIND_EXT_ONLY_ENHKEY_USAGE_FLAG,
                                       CERT_FIND_ENHKEY_USAGE,
                                       &certEnhKeyUsage,
                                       userCert
                                       );
                    if (userCert) {

                        EfsGetCertNameFromCertContext(
                                            userCert,
                                            &userName
                                            );
                        if (userName) {

                            if (!wcscmp(userName, crntUserName) ) {

                                //
                                // Find the name match. Remove it.
                                //

                                PCCERT_CONTEXT tmpCert;

                                tmpCert = CertDuplicateCertificateContext(userCert);
                                if (tmpCert) {
                                    CertDeleteCertificateFromStore(tmpCert);
                                }

                            }

                            LsapFreeLsaHeap( userName );

                        }
                    }

                } while (userCert);

                if(!CertAddEncodedCertificateToStore(
                       localStore,
                       X509_ASN_ENCODING | PKCS_7_ASN_ENCODING,
                       pCert->pbCertEncoded,
                       pCert->cbCertEncoded,
                       CERT_STORE_ADD_NEW,
                       NULL) ) {
 
                    errCode = GetLastError();
    
                }

                LsapFreeLsaHeap( crntUserName );

            } else {
                errCode = GetLastError();
            }

            CertCloseStore( localStore, 0 );
        }

        Status = NtSetInformationThread(
                    NtCurrentThread(),
                    ThreadImpersonationToken,
                    (PVOID) &hToken,
                    sizeof(HANDLE)
                    );

        if (!NT_SUCCESS( Status )) {
            ASSERT(FALSE);
            *ImpersonationError = 1;
            errCode = RtlNtStatusToDosError( Status );

        }

    } else {
        errCode = RtlNtStatusToDosError( Status );
    }

    return errCode;

}

DWORD
EfsAlignBlock(
    IN PVOID InPointer,
    OUT PVOID   *OutPointer,
    OUT BOOLEAN *NewMemory
    )

/*++

Routine Description:

    This routine will align the structure with the first ULONG as the length of the structure
    so that we don't get alignment faults.

Arguments:

    InPointer -- Original Block
    OutPointer -- Aligned Block
    NewMemory -- If new memory block allocated
            
Return Value:

    Win32 error code
    
--*/
{

    if ( ((INT_PTR) InPointer & 0x03) == 0) {
         *OutPointer = InPointer;
         *NewMemory = FALSE;
         return ERROR_SUCCESS;
    }

    ULONG length;
    DWORD result=ERROR_SUCCESS;

    RtlCopyMemory(&length, InPointer, sizeof (ULONG));
    *OutPointer = (PENCRYPTED_KEY)LsapAllocateLsaHeap(length);
    if (*OutPointer) {

        RtlCopyMemory(*OutPointer, InPointer, length);
        *NewMemory = TRUE;
    } else {
        *NewMemory = FALSE;
        result = ERROR_NOT_ENOUGH_MEMORY;
    }

    return result;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\base\lsa\server\handle.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1997.
//
//  File:       handle.hxx
//
//  Contents:   Handle Package interface
//
//  Classes:
//
//  Functions:
//
//  History:    2-03-97   RichardW   Created
//
//----------------------------------------------------------------------------

#ifndef __HANDLE_HXX__
#define __HANDLE_HXX__

typedef
VOID (WINAPI HP_ENUM_CALLBACK_FN)(
    PSecHandle  Handle,
    PVOID Context,
    ULONG RefCount
    );

typedef HP_ENUM_CALLBACK_FN * PHP_ENUM_CALLBACK_FN;

typedef struct _SEC_HANDLE_ENTRY {
    LIST_ENTRY  List ;
    SecHandle   Handle ;
    PVOID       Context ;
    ULONG       HandleCount ;
    ULONG       RefCount ;
    ULONG       HandleIssuedCount ; // same as HandleCount, but doesn't go down.
    ULONG       Flags ;
} SEC_HANDLE_ENTRY, * PSEC_HANDLE_ENTRY ;

#define SEC_HANDLE_FLAG_DELETE_PENDING  0x00000002
#define SEC_HANDLE_FLAG_NO_CALLBACK     0x00000004

typedef
BOOL (WINAPI HP_INITIALIZE_FN)(
    VOID
    );

typedef
PVOID (WINAPI HP_CREATE_FN)(
    IN ULONG    Flags,
    IN PVOID    HandleTable OPTIONAL,
    IN PHP_ENUM_CALLBACK_FN Callback OPTIONAL
    );

#define HANDLE_PACKAGE_NO_SERIALIZE         0x00000001
#define HANDLE_PACKAGE_CALLBACK_ON_DELETE   0x00000002
#define HANDLE_PACKAGE_REQUIRE_UNIQUE       0x00000004

#define HANDLE_PACKAGE_MAX_FLAG             0x00000004
#define HANDLE_PACKAGE_GENERAL_FLAGS        0x00000007


typedef
BOOL (WINAPI HP_DELETE_FN)(
    PVOID   HandleTable,
    PHP_ENUM_CALLBACK_FN Callback
    );

typedef
BOOL (WINAPI HP_ADD_HANDLE_FN)(
    PVOID   HandleTable,
    PSecHandle  Handle,
    PVOID Context,
    ULONG Flags
    );

typedef
BOOL (WINAPI HP_DELETE_HANDLE_FN)(
    PVOID   HandleTable,
    PSecHandle Handle,
    ULONG   Options
    );

#define DELHANDLE_FORCE         0x00000001
#define DELHANDLE_NO_CALLBACK   0x00000002

typedef
BOOL (WINAPI HP_VALIDATE_HANDLE_FN)(
    PVOID   HandleTable,
    PSecHandle  Handle,
    BOOL Deref
    );

typedef 
PVOID (WINAPI HP_REF_HANDLE_FN)(
    PVOID HandleTable,
    PSecHandle Handle
    );

typedef 
VOID (WINAPI HP_DEREF_HANDLE_KEY_FN)(
    PVOID HandleTable,
    PVOID HandleKey
    );
                                        

typedef
PVOID (WINAPI HP_GET_HANDLE_CONTEXT_FN)(
    PVOID HandleTable,
    PSecHandle Handle
    );

typedef
BOOL (WINAPI HP_RELEASE_CONTEXT_FN)(
    PVOID HandleTable,
    PSecHandle Handle
    );

typedef HP_INITIALIZE_FN * PHP_INITIALIZE_FN;
typedef HP_CREATE_FN * PHP_CREATE_FN ;
typedef HP_DELETE_FN * PHP_DELETE_FN ;
typedef HP_ADD_HANDLE_FN * PHP_ADD_HANDLE_FN ;
typedef HP_DELETE_HANDLE_FN * PHP_DELETE_HANDLE_FN ;
typedef HP_VALIDATE_HANDLE_FN * PHP_VALIDATE_HANDLE_FN ;
typedef HP_REF_HANDLE_FN * PHP_REF_HANDLE_FN ;
typedef HP_DEREF_HANDLE_KEY_FN * PHP_DEREF_HANDLE_KEY_FN ;
typedef HP_GET_HANDLE_CONTEXT_FN * PHP_GET_HANDLE_CONTEXT_FN ;
typedef HP_RELEASE_CONTEXT_FN * PHP_RELEASE_CONTEXT_FN ;

typedef struct _HANDLE_PACKAGE {
    ULONG                   TableSize ;
    PHP_INITIALIZE_FN       Initialize ;
    PHP_CREATE_FN           Create ;
    PHP_DELETE_FN           Delete ;
    PHP_ADD_HANDLE_FN       AddHandle ;
    PHP_DELETE_HANDLE_FN    DeleteHandle ;
    PHP_VALIDATE_HANDLE_FN  ValidateHandle ;
    PHP_REF_HANDLE_FN       RefHandle ;
    PHP_DEREF_HANDLE_KEY_FN DerefHandleKey ;
    PHP_GET_HANDLE_CONTEXT_FN GetHandleContext ;
    PHP_RELEASE_CONTEXT_FN  ReleaseContext ;
} HANDLE_PACKAGE, * PHANDLE_PACKAGE ;



PVOID
LhtConvertSmallToLarge(
    PVOID Small
    );

extern HANDLE_PACKAGE   LargeHandlePackage ;
extern HANDLE_PACKAGE   SmallHandlePackage ;

#endif // __HANDLE_HXX__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\base\lsa\server\klpcstub.h ===
//+-----------------------------------------------------------------------
//
// Microsoft Windows
//
// Copyright (c) Microsoft Corporation 1992 - 1994
//
// File:        klpcstub.h
//
// Contents:    prototypes for lpc server stubs
//
//
// History:     3-11-94     MikeSw      Created
//
//------------------------------------------------------------------------


LSA_DISPATCH_FN LpcLsaLookupPackage;
LSA_DISPATCH_FN LpcLsaLogonUser;
LSA_DISPATCH_FN LpcLsaCallPackage;
LSA_DISPATCH_FN LpcLsaDeregisterLogonProcess;
LSA_DISPATCH_FN LpcGetBinding;
LSA_DISPATCH_FN LpcSetSession;
LSA_DISPATCH_FN LpcFindPackage;
LSA_DISPATCH_FN LpcEnumPackages;
LSA_DISPATCH_FN LpcAcquireCreds;
LSA_DISPATCH_FN LpcEstablishCreds;
LSA_DISPATCH_FN LpcFreeCredHandle;
LSA_DISPATCH_FN LpcInitContext;
LSA_DISPATCH_FN LpcAcceptContext;
LSA_DISPATCH_FN LpcApplyToken;
LSA_DISPATCH_FN LpcDeleteContext;
LSA_DISPATCH_FN LpcQueryPackage;
LSA_DISPATCH_FN LpcGetUserInfo;
LSA_DISPATCH_FN LpcGetCreds;
LSA_DISPATCH_FN LpcSaveCreds;
LSA_DISPATCH_FN LpcQueryCredAttributes;
LSA_DISPATCH_FN LpcAddPackage;
LSA_DISPATCH_FN LpcDeletePackage;
LSA_DISPATCH_FN LpcEfsGenerateKey;
LSA_DISPATCH_FN LpcEfsGenerateDirEfs;
LSA_DISPATCH_FN LpcEfsDecryptFek;
LSA_DISPATCH_FN LpcEfsGenerateSessionKey;
LSA_DISPATCH_FN LpcCallback;
LSA_DISPATCH_FN LpcQueryContextAttributes;
SECURITY_STATUS LpcLsaPolicyChangeNotify( PSPM_LPC_MESSAGE pApiMessage );
LSA_DISPATCH_FN LpcGetUserName;
LSA_DISPATCH_FN LpcAddCredentials ;
LSA_DISPATCH_FN LpcEnumLogonSessions ;
LSA_DISPATCH_FN LpcGetLogonSessionData ;
LSA_DISPATCH_FN LpcSetContextAttributes;
LSA_DISPATCH_FN LpcLookupAccountName ;
LSA_DISPATCH_FN LpcLookupAccountSid ;
LSA_DISPATCH_FN LpcLookupWellKnownSid ;

LSA_DISPATCH_FN DispatchAPI ;
LSA_DISPATCH_FN DispatchAPIDirect ;
extern PLSA_DISPATCH_FN DllCallbackHandler ;

NTSTATUS
LsapClientCallback(
    PSession Session,
    ULONG   Type,
    PVOID   Function,
    PVOID Argument1,
    PVOID Argument2,
    PSecBuffer Input,
    PSecBuffer Output
    );

typedef PVOID (NTAPI DSA_THSave)(VOID);
typedef VOID (NTAPI DSA_THRestore)(PVOID);

extern  DSA_THSave *    GetDsaThreadState ;
extern  DSA_THRestore * RestoreDsaThreadState ;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\base\lsa\server\lht.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1997.
//
//  File:       lht.cxx
//
//  Contents:   Context handle management for servers
//
//  Classes:
//
//  Functions:
//
//  History:    1-31-97   RichardW   Created
//
//----------------------------------------------------------------------------

#include <lsapch.hxx>

#include "sht.hxx"
#include "lht.hxx"

//
// Due to the high number of connections for servers, the client context list
// for a particular session could grow into the thousands.  At that stage, a
// linear list that is searched to validate a handle is prohibitively expensive.
//
// Thus, the faster, if more expensive to set up and add handle package
//

HP_INITIALIZE_FN    LhtInitialize ;
HP_CREATE_FN        LhtCreate ;
HP_DELETE_FN        LhtDelete ;
HP_ADD_HANDLE_FN    LhtAddHandle ;
HP_DELETE_HANDLE_FN LhtDeleteHandle ;
HP_VALIDATE_HANDLE_FN LhtValidateHandle ;
HP_REF_HANDLE_FN    LhtRefHandle ;
HP_DEREF_HANDLE_KEY_FN LhtDerefHandleKey ;
HP_GET_HANDLE_CONTEXT_FN LhtGetHandleContext ;
HP_RELEASE_CONTEXT_FN LhtReleaseContext ;

HANDLE_PACKAGE  LargeHandlePackage = {
                    sizeof( LARGE_HANDLE_TABLE ),
                    LhtInitialize,
                    LhtCreate,
                    LhtDelete,
                    LhtAddHandle,
                    LhtDeleteHandle,
                    LhtValidateHandle,
                    LhtRefHandle,
                    LhtDerefHandleKey,
                    LhtGetHandleContext,
                    LhtReleaseContext
                    };


ULONG   LhtFastMem ;
ULONG   LhtShiftValues[] = { 4, 12, 16, 20 };


#define IndexFromHandle( Level, Handle )    \
            ( ( ((PSecHandle) Handle)->dwUpper >> LhtShiftValues[ Level ] ) & HANDLE_TABLE_MASK )

#define LhtLockTable( t ) \
            if ( (((PLARGE_HANDLE_TABLE) t)->Flags & LHT_NO_SERIALIZE ) == 0 ) \
            {                                                                  \
                RtlEnterCriticalSection( &((PLARGE_HANDLE_TABLE)t)->Lock ); \
            }

#define LhtUnlockTable( t ) \
            if ( (((PLARGE_HANDLE_TABLE) t)->Flags & LHT_NO_SERIALIZE ) == 0 ) \
            {                                                                  \
                RtlLeaveCriticalSection( &((PLARGE_HANDLE_TABLE)t)->Lock ); \
            }


#define LHT_ACTION_ADDREF       0
#define LHT_ACTION_DELREF       1
#define LHT_ACTION_FORCEDEL     2
#define LHT_ACTION_VALIDATE     3
#define LHT_ACTION_ADDHANDLE    4
#define LHT_ACTION_DELHANDLE    5

#define LHT_ACTION_MASK     0x0000FFFF
#define LHT_ACTION_LOCKED   0x00010000
#define LHTP_DEREF_NOT_DEL  0x10000000
#define LHTP_HANDLE_CHECKED 0x20000000

//+---------------------------------------------------------------------------
//
//  Function:   LhtInitialize
//
//  Synopsis:   Initializes the LHT handle package
//
//  Arguments:  (none)
//
//  History:    2-03-97   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
BOOL
LhtInitialize(
    VOID
    )
{
    return TRUE ;
}



//+---------------------------------------------------------------------------
//
//  Function:   LhtCreate
//
//  Synopsis:   Creates a large handle table.  The table is referenced through
//              the returned pointer
//
//  Arguments:  [Flags] -- Flags as defined by handle.hxx
//
//  History:    2-03-97   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
PVOID
LhtCreate(
    IN ULONG Flags,
    IN PVOID HandleTable,
    IN PHP_ENUM_CALLBACK_FN Callback
    )
{
    PLARGE_HANDLE_TABLE Table ;
    ULONG i;

    if ( HandleTable )
    {
        Table = (PLARGE_HANDLE_TABLE) HandleTable ;
    }
    else
    {
        Table = (PLARGE_HANDLE_TABLE) LsapAllocatePrivateHeap( sizeof( LARGE_HANDLE_TABLE ) );
    }

    if ( Table )
    {
        Table->Tag = LHT_TAG ;
        Table->Flags = 0 ;

        Table->Flags = (Flags & HANDLE_PACKAGE_GENERAL_FLAGS);


        if ( Flags & HANDLE_PACKAGE_CALLBACK_ON_DELETE )
        {
            Table->DeleteCallback = Callback ;
        }
        else
        {
            Table->DeleteCallback = NULL ;
        }

        if ( HandleTable )
        {
            Table->Flags |= LHT_NO_FREE ;
        }

        Table->Depth = 0 ;


        if ( ( Flags & LHT_NO_SERIALIZE ) == 0 )
        {
            NTSTATUS Status = RtlInitializeCriticalSectionAndSpinCount(
                                        &Table->Lock,
                                        LsaTuningParameters.CritSecSpinCount
                                        );

            if (!NT_SUCCESS(Status))
            {
                if ( !HandleTable )
                {
                    LsapFreePrivateHeap( Table );
                }

                Table = NULL ;
            }
        }
    }

    if ( Table )
    {

        for ( i = 0 ; i < HANDLE_TABLE_SIZE ; i++ )
        {
            SmallHandlePackage.Create( Flags | HANDLE_PACKAGE_NO_SERIALIZE,
                                        & Table->Lists[i],
                                        Callback );
        }

    }

    return Table ;

}

//+---------------------------------------------------------------------------
//
//  Function:   LhtpDeleteTable
//
//  Synopsis:   Delete table worker function
//
//  Arguments:  [Table]    --
//              [Callback] --
//
//  History:    4-15-97   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
VOID
LhtpDeleteTable(
    PLARGE_HANDLE_TABLE Table,
    PHP_ENUM_CALLBACK_FN Callback
    )
{
    ULONG Index ;
    PSEC_HANDLE_ENTRY Entry ;
    PLIST_ENTRY Scan ;

    LhtLockTable( Table );

    for ( Index = 0 ; Index < HANDLE_TABLE_SIZE ; Index++ )
    {
        if ( Table->Lists[Index].Flags & LHT_SUB_TABLE )
        {
            LhtpDeleteTable( (PLARGE_HANDLE_TABLE) Table->Lists[Index].List.Flink,
                             Callback );

        }
        else
        {
            SmallHandlePackage.Delete( &Table->Lists[ Index ], Callback );
        }
    }

    LhtUnlockTable( Table );

    if ( (Table->Flags & LHT_NO_SERIALIZE) == 0 )
    {
        RtlDeleteCriticalSection(  &Table->Lock );
    }

    if ( ( Table->Flags & LHT_NO_FREE ) == 0 )
    {
        LsapFreePrivateHeap( Table );
    }
}

//+---------------------------------------------------------------------------
//
//  Function:   LhtDelete
//
//  Synopsis:   Delete a table
//
//  Arguments:  [HandleTable] --
//              [Callback]    --
//
//  History:    4-15-97   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
BOOL
LhtDelete(
    PVOID   HandleTable,
    PHP_ENUM_CALLBACK_FN Callback
    )
{
    PLARGE_HANDLE_TABLE Table ;

    Table = (PLARGE_HANDLE_TABLE) HandleTable ;

    LhtLockTable( Table );

    Table->Flags |= LHT_DELETE_PENDING ;

    LhtpDeleteTable( Table, Callback );

    return TRUE ;
}

//+---------------------------------------------------------------------------
//
//  Function:   LhtpFindHandle
//
//  Synopsis:   Worker function that grovels a handle table
//
//  Arguments:  [HandleTable] -- Table to scan
//              [Handle]      -- handle to search for
//              [Action]      -- action to take on the handle record
//
//  History:    2-03-97   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
PSEC_HANDLE_ENTRY
LhtpFindHandle(
    PVOID   HandleTable,
    PSecHandle  Handle,
    ULONG   Action,
    PBOOL   Removed,
    PVOID * FinalTable OPTIONAL
    )
{
    PLARGE_HANDLE_TABLE Table ;
    PSEC_HANDLE_ENTRY   Entry ;
    PLIST_ENTRY         Scan ;
    ULONG Index ;
    BOOL Locked ;

    Table = (PLARGE_HANDLE_TABLE) HandleTable ;

    LhtLockTable( Table );

    Entry = NULL ;

    while ( TRUE )
    {
        Index = (ULONG) IndexFromHandle( Table->Depth, Handle );

        if ( Table->Lists[ Index ].Flags & LHT_SUB_TABLE )
        {
            Table = (PLARGE_HANDLE_TABLE) Table->Lists[ Index ].List.Flink ;

            continue;
        }

        Entry = ShtpFindHandle( &Table->Lists[ Index ], Handle, Action, Removed );

        if ( FinalTable )
        {
            *FinalTable = &Table->Lists[ Index ] ;
        }

        break;
    }

    Table = (PLARGE_HANDLE_TABLE) HandleTable ;

    LhtUnlockTable( Table );

    return Entry ;


}

//+---------------------------------------------------------------------------
//
//  Function:   LhtpConvertSmallToLarge
//
//  Synopsis:   Worker to convert small tables to large
//
//  Arguments:  [Small] --
//              [Large] --
//
//  History:    7-08-97   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
BOOL
LhtpConvertSmallToLarge(
    PSMALL_HANDLE_TABLE Small,
    PLARGE_HANDLE_TABLE Large
    )
{
    ULONG NewIndex ;
    PSEC_HANDLE_ENTRY Entry ;

    while ( Entry = ShtpPopHandle( Small ) )
    {
        NewIndex = (ULONG) IndexFromHandle( Large->Depth, &(Entry->Handle) );

        ShtpInsertHandle( &Large->Lists[ NewIndex ], Entry );

    }

    return TRUE ;
}


//+---------------------------------------------------------------------------
//
//  Function:   LhtpExpandTable
//
//  Synopsis:   Expands the given index into its own table
//
//  Effects:    New table associated with given index
//
//  Arguments:  [Table] -- Source table
//              [Index] -- Source index
//
//  Requires:   Table must be write-locked
//
//  History:    1-31-97   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
BOOL
LhtpExpandTable(
   PLARGE_HANDLE_TABLE  Table,
   ULONG    Index
   )
{
    PLARGE_HANDLE_TABLE NewTable ;
    PLIST_ENTRY List;
    ULONG NewFlags ;

    NewFlags = HANDLE_PACKAGE_NO_SERIALIZE ;

    if ( Table->DeleteCallback )
    {
        NewFlags |= HANDLE_PACKAGE_CALLBACK_ON_DELETE ;
    }

    NewTable = (PLARGE_HANDLE_TABLE) LhtCreate( NewFlags |
                                                    LHT_CHILD,
                                                NULL,
                                                Table->DeleteCallback );

    if ( !NewTable )
    {
        return FALSE ;
    }

    NewTable->Depth = Table->Depth + 1 ;

    NewTable->Parent = Table ;

    NewTable->IndexOfParent = Index ;

    LhtpConvertSmallToLarge( &Table->Lists[ Index ], NewTable );

    Table->Lists[ Index ].List.Flink = (PLIST_ENTRY) NewTable ;

    Table->Lists[ Index ].Flags = LHT_SUB_TABLE ;

    return TRUE ;

}

//+---------------------------------------------------------------------------
//
//  Function:   LhtConvertSmallToLarge
//
//  Synopsis:   Converts a small handle table to a large one
//
//  Arguments:  [Small] --
//
//  History:    7-08-97   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
PVOID
LhtConvertSmallToLarge(
    PVOID Small
    )
{
    PLARGE_HANDLE_TABLE Large ;
    PSMALL_HANDLE_TABLE SmallTable = (PSMALL_HANDLE_TABLE) Small ;
    PULONG Tag ;

    Tag = (PULONG) Small ;

    if ( *Tag == LHT_TAG )
    {
        return Small ;
    }

    if ( *Tag != SHT_TAG )
    {
        return NULL ;
    }

    Large = (PLARGE_HANDLE_TABLE) LhtCreate( (SmallTable->DeleteCallback ?
                                                HANDLE_PACKAGE_CALLBACK_ON_DELETE : 0),
                                             NULL,
                                             SmallTable->DeleteCallback );

    if ( Large )
    {
        LhtpConvertSmallToLarge( SmallTable, Large );

        ShtDelete( Small, NULL );

        return Large ;
    }

    return NULL ;
}

//+---------------------------------------------------------------------------
//
//  Function:   LhtAddHandle
//
//  Synopsis:   Add a handle to a handle table
//
//  Arguments:  [HandleTable] -- Table to add the handle to
//              [Handle]      -- Handle to add
//
//  History:    2-03-97   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
BOOL
LhtAddHandle(
    PVOID   HandleTable,
    PSecHandle  Handle,
    PVOID   Context,
    ULONG Flags
    )
{
    PSEC_HANDLE_ENTRY   Entry ;
    PLARGE_HANDLE_TABLE Table ;
    ULONG Index ;


    Table = (PLARGE_HANDLE_TABLE) HandleTable ;

    LhtLockTable( Table );

    Entry = LhtpFindHandle( HandleTable, 
                            Handle, 
                            LHT_ACTION_ADDHANDLE, 
                            NULL, 
                            NULL );

    if ( Entry )
    {
        LhtUnlockTable( Table );

        return TRUE ;
    }

    //
    // No entry, need to insert one.
    //

    while ( TRUE )
    {
        Index = (ULONG) IndexFromHandle( Table->Depth, Handle );

        if ( Table->Lists[ Index ].Flags & LHT_SUB_TABLE )
        {
            Table = (PLARGE_HANDLE_TABLE) Table->Lists[ Index ].List.Flink ;

            continue;
        }

        if(SmallHandlePackage.AddHandle( &Table->Lists[ Index ], Handle, Context, Flags ))
        {
            if ( Table->Lists[ Index ].Count > HANDLE_SPLIT_THRESHOLD )
            {
                LhtpExpandTable( Table, Index );
            }

            break;
        }

        LhtUnlockTable( (PLARGE_HANDLE_TABLE)HandleTable );
        return FALSE;
    }

    Table = (PLARGE_HANDLE_TABLE) HandleTable ;

    Table->Count++;

    LhtUnlockTable( Table );

    return TRUE ;
}

//+---------------------------------------------------------------------------
//
//  Function:   LhtDeleteHandle
//
//  Synopsis:   Delete a handle from the table
//
//  Arguments:  [HandleTable] -- Table
//              [Handle]      -- Handle to delete
//              [Force]       -- Force delete, even if handle is not ref'd to zero
//
//  History:    2-03-97   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
BOOL
LhtDeleteHandle(
    PVOID       HandleTable,
    PSecHandle  Handle,
    ULONG       Options
    )
{
    PSEC_HANDLE_ENTRY Entry ;
    PLARGE_HANDLE_TABLE Table ;
    BOOL Removed;
    ULONG Action ;

    if ( Options & DELHANDLE_FORCE )
    {
        Action = LHT_ACTION_FORCEDEL ;
    }
    else if ( Options & LHTP_DEREF_NOT_DEL )
    {
        Action = LHT_ACTION_DELREF | LHTP_HANDLE_CHECKED ;
    }
    else 
    {
        Action = LHT_ACTION_DELHANDLE ;
    }


    Entry = LhtpFindHandle( HandleTable,
                           Handle,
                           Action,
                           &Removed,
                           NULL );

    if ( Entry )
    {
        if ( Removed )
        {
            Table = (PLARGE_HANDLE_TABLE) HandleTable ;

            LhtLockTable( Table );

            Table->Count--;

            LhtUnlockTable( Table );

            if ( (Table->DeleteCallback) &&
                 ((Options & DELHANDLE_NO_CALLBACK) == 0 ) &&
                 ((Entry->Flags & SEC_HANDLE_FLAG_NO_CALLBACK ) == 0 ) )
            {
                Table->DeleteCallback(
                                &Entry->Handle,
                                Entry->Context,
                                Entry->HandleIssuedCount    // Entry->RefCount
                                );
            }

            if ( ( Entry->Flags & SEC_HANDLE_FLAG_DELETE_PENDING ) == 0 )
            {
                LsapFreePrivateHeap( Entry );
            }
        }

        return TRUE ;
    }

    return FALSE ;
}


//+---------------------------------------------------------------------------
//
//  Function:   LhtValidateHandle
//
//  Synopsis:   Validate that a handle is within the table
//
//  Arguments:  [HandleTable] --
//              [Handle]      --
//
//  History:    2-03-97   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
BOOL
LhtValidateHandle(
    PVOID       HandleTable,
    PSecHandle  Handle,
    BOOL        Deref
    )
{
    PSEC_HANDLE_ENTRY Entry ;
    PLARGE_HANDLE_TABLE Table ;
    BOOL Removed ;

    Entry = LhtpFindHandle( 
                HandleTable, 
                Handle, 
                (Deref ? LHT_ACTION_DELHANDLE : LHT_ACTION_VALIDATE), 
                &Removed,
                NULL );

    if ( Entry )
    {

        if ( Removed )
        {
            Table = (PLARGE_HANDLE_TABLE) HandleTable ;

            LhtLockTable( Table );

            Table->Count--;

            LhtUnlockTable( Table );

            if ( ( Table->DeleteCallback ) &&
                 ( ( Entry->Flags & SEC_HANDLE_FLAG_NO_CALLBACK) == 0 ) )
            {
                Table->DeleteCallback(
                            &Entry->Handle,
                            Entry->Context,
                            Entry->HandleIssuedCount    // Entry->RefCount
                            );
            }

            if ( ( Entry->Flags & SEC_HANDLE_FLAG_DELETE_PENDING ) == 0 )
            {
                LsapFreePrivateHeap( Entry );
            }
        }

        return TRUE ;
    }
    else
    {
        return FALSE ;
    }
}

PVOID
LhtRefHandle(
    PVOID HandleTable,
    PSecHandle Handle
    )
{
    PSEC_HANDLE_ENTRY Entry ;

    Entry = LhtpFindHandle(
                HandleTable,
                Handle,
                LHT_ACTION_ADDREF,
                NULL,
                NULL );

    return Entry ;
}

VOID
LhtDerefHandleKey(
    PVOID HandleTable,
    PVOID HandleKey
    )
{
    PSEC_HANDLE_ENTRY Entry = (PSEC_HANDLE_ENTRY) HandleKey ;

    LhtDeleteHandle( HandleTable, &Entry->Handle, LHTP_DEREF_NOT_DEL );
}

PVOID
LhtGetHandleContext(
    PVOID       HandleTable,
    PSecHandle  Handle
    )
{
    PSEC_HANDLE_ENTRY Entry ;

    Entry = LhtpFindHandle( 
                HandleTable, 
                Handle, 
                LHT_ACTION_ADDREF, 
                NULL,
                NULL );

    if ( Entry )
    {
        return Entry->Context ;
    }
    else
    {
        return NULL ;
    }
}


BOOL
LhtReleaseContext(
    PVOID       HandleTable,
    PSecHandle  Handle
    )
{
    PSEC_HANDLE_ENTRY Entry ;
    PLARGE_HANDLE_TABLE Table ;
    BOOL Removed;

    Entry = LhtpFindHandle( HandleTable,
                           Handle,
                           LHT_ACTION_DELREF,
                           &Removed,
                           NULL );

    if ( Entry )
    {
        if ( Removed )
        {
            Table = (PLARGE_HANDLE_TABLE) HandleTable ;

            LhtLockTable( Table );

            Table->Count--;

            LhtUnlockTable( Table );

            if ( ( Table->DeleteCallback ) &&
                 ( ( Entry->Flags & SEC_HANDLE_FLAG_NO_CALLBACK ) == 0 ) )
            {
                Table->DeleteCallback( &Entry->Handle, Entry->Context, Entry->RefCount );
            }

            if ( ( Entry->Flags & SEC_HANDLE_FLAG_DELETE_PENDING ) == 0 )
            {
                LsapFreePrivateHeap( Entry );
            }
        }

        return TRUE ;
    }

    return FALSE ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\base\lsa\server\klpc.cxx ===
//+-----------------------------------------------------------------------
//
// Microsoft Windows
//
// Copyright (c) Microsoft Corporation 1991 - 1992
//
// File:        KLPC.C
//
// Contents:    LPC Support for the KSEC device driver
//
// Functions:   CreateLpcPort
//              AcceptConnection
//              LPCServerThread
//              HandleLPCError
//              ShutdownServerThread
//              StartLPCThread
//              StopLPCThread
//
// History:     20 May 92   RichardW    Created
//
//------------------------------------------------------------------------

#include <lsapch.hxx>
extern "C" {
#include "klpcstub.h"
}

//
// Module variables:
//

WCHAR   szPortName[] = SPM_PORTNAME;

HANDLE  hListenThread;

HANDLE  hLpcPort;           // This port ID is used for everything.

SECURITY_STATUS LsapTrapStatusCode ;

DSA_THSave *    GetDsaThreadState ;
DSA_THRestore * RestoreDsaThreadState ;

PLSAP_API_LOG   LpcApiLog ;

#define DBG_CONNECT     ((ULONG) 0xFFFFFFFF)
#define DBG_DISCONNECT  ((ULONG) 0xFFFFFFFE)


//
// Local Prototypes:
//

NTSTATUS CreateLpcPort(HANDLE *, PWSTR, DWORD, DWORD, DWORD);

DWORD LpcHandler(PVOID    pMsg);
DWORD RundownConnection(PVOID pMessage);
DWORD RundownConnectionNoFree(PVOID pMsg);

PLSAP_API_LOG
ApiLogCreate(
    ULONG Entries
    )
{
    PLSAP_API_LOG ApiLog ;
    ULONG Size ;

    if ( Entries == 0 )
    {
        Entries = DEFAULT_LOG_SIZE;
    }
    DsysAssert( ((Entries & (Entries - 1) ) == 0 ) );

    if ( Entries & (Entries - 1 ))
    {
        return NULL ;
    }

    Size = sizeof( LSAP_API_LOG ) + ( sizeof( LSAP_API_LOG_ENTRY ) * (Entries - 1) ) ;

    ApiLog = (PLSAP_API_LOG) LsapAllocatePrivateHeap( Size );

    if ( ApiLog )
    {
        ApiLog->TotalSize = Entries ;
        ApiLog->ModSize = Entries - 1;
    }

    return ApiLog ;
}

PLSAP_API_LOG_ENTRY
ApiLogAlloc(
    PLSAP_API_LOG Log
    )
{
    ULONG WatchDog ;
    PLSAP_API_LOG_ENTRY Entry = NULL ;

    if ( !Log )
    {
        return NULL ;
    }

    WatchDog = Log->TotalSize * 2 ;

    while ( ( Log->Entries[ Log->Current ].ThreadId != 0 ) &&
            ( Log->Entries[ Log->Current ].ThreadId != 0xFFFFFFFF ) &&
            ( WatchDog ) )
    {
        Log->Current++ ;
        Log->Current &= Log->ModSize ;
        WatchDog-- ;
    }

    if ( WatchDog )
    {
        Entry = & Log->Entries[ Log->Current ] ;
        Entry->ThreadId = 0 ;

        Log->Current ++ ;
        Log->Current &=  Log->ModSize;
    }

    return Entry ;
}

PLSAP_API_LOG_ENTRY
ApiLogLocate(
    PLSAP_API_LOG Log,
    ULONG MessageId
    )
{
    ULONG i ;
    PLSAP_API_LOG_ENTRY Entry = NULL ;

    for ( i = 0 ; i < Log->TotalSize ; i++ )
    {
        if ( Log->Entries[ i ].MessageId == MessageId )
        {
            Entry = &Log->Entries[ i ];
            break;
        }
    }

    return Entry ;
}


//+-------------------------------------------------------------------------
//
//  Function:   SetKsecEvent
//
//  Synopsis:   Triggers the event releasing the KSecDD
//
//  Effects:    Better be ready for LPC by when this call is executed
//
//--------------------------------------------------------------------------
NTSTATUS
SetKsecEvent(void)
{
    HANDLE  hEvent;

    hEvent = SpmOpenEvent(EVENT_ALL_ACCESS,FALSE, SPM_EVENTNAME);

    if (!hEvent)
    {
        DebugLog((DEB_WARN, "Could not open %ws, %d\n", SPM_EVENTNAME, GetLastError()));
        return(STATUS_INVALID_HANDLE);
    }

    if (!SetEvent(hEvent))
    {
        DebugLog((DEB_ERROR, "Failed to set ksec event, %d\n", GetLastError()));
        (void) CloseHandle(hEvent);
        return(STATUS_INVALID_HANDLE);
    }

    (void) CloseHandle(hEvent);
    return(STATUS_SUCCESS);
}

//+-------------------------------------------------------------------------
//
//  Function:   LsapBuildSD
//
//  Synopsis:   Shared code to build the SD for either the KsecEvent or
//              the LPC port.  For the KsecEvent, give everybody
//              GENERIC_EXECUTE access.  For the LPC port, give everybody
//              access to call in on it.
//
//  Effects:    For KsecEvent, sets the security on the event.
//              For LPC port, returns the SD as an OUT parameter
//
//--------------------------------------------------------------------------
NTSTATUS
LsapBuildSD(
    IN ULONG dwType,
    OUT PSECURITY_DESCRIPTOR *ppSD  OPTIONAL
    )
{
    HANDLE  hEvent = NULL;
    NTSTATUS Status;
    ULONG SDLength;
    PACL pEventDacl = NULL;
    PSECURITY_DESCRIPTOR pEventSD = NULL;
    ULONG ulWorldAccess = 0;
    ULONG ulAdminAccess = 0;

    if (dwType == BUILD_KSEC_SD)
    {
        hEvent = SpmOpenEvent(EVENT_ALL_ACCESS,FALSE, SPM_EVENTNAME);

        if (!hEvent)
        {
            DebugLog((DEB_WARN, "Could not open %ws, %d\n", SPM_EVENTNAME, GetLastError()));
            return(STATUS_INVALID_HANDLE);
        }

        //
        // The default DACL is the same as SePublicDefaultDacl in ntos\se
        //
        // World gets GENERIC_EXECUTE
        // Admin gets GENERIC_READ, GENERIC_EXECUTE, READ_CONTROL
        // System gets GENERIC_ALL
        //

        ulWorldAccess = GENERIC_EXECUTE | GENERIC_READ;
        ulAdminAccess = GENERIC_READ | GENERIC_EXECUTE | READ_CONTROL;
    }
    else
    {
        //
        // ppSD is an OUT parameter for BUILD_LPC_SD
        //
        ASSERT(ppSD != NULL);

        ulWorldAccess = SYNCHRONIZE | GENERIC_READ | GENERIC_WRITE | GENERIC_EXECUTE;
        ulAdminAccess = GENERIC_ALL;
    }

    SDLength = sizeof(SECURITY_DESCRIPTOR) +
                   (ULONG) sizeof(ACL) +
                   (3 * ((ULONG) sizeof(ACCESS_ALLOWED_ACE) - sizeof(ULONG))) +
                   RtlLengthSid( LsapLocalSystemSid ) +
                   RtlLengthSid( LsapAliasAdminsSid ) +
                   RtlLengthSid( LsapWorldSid );

    pEventSD = (PSECURITY_DESCRIPTOR) LsapAllocateLsaHeap(SDLength);

    if (pEventSD == NULL)
    {
        if (dwType == BUILD_KSEC_SD)
        {
            CloseHandle(hEvent);
        }

        return(STATUS_INSUFFICIENT_RESOURCES);
    }

    pEventDacl = (PACL) ((PBYTE) pEventSD + sizeof(SECURITY_DESCRIPTOR));

    Status = RtlCreateAcl( pEventDacl,
                           SDLength - sizeof(SECURITY_DESCRIPTOR),
                           ACL_REVISION);

    ASSERT( NT_SUCCESS(Status) );

    //
    // WORLD access
    //

    Status = RtlAddAccessAllowedAce (
                 pEventDacl,
                 ACL_REVISION,
                 ulWorldAccess,
                 LsapWorldSid
                 );

    ASSERT( NT_SUCCESS(Status) );

    //
    // SYSTEM access
    //

    Status = RtlAddAccessAllowedAce (
                 pEventDacl,
                 ACL_REVISION,
                 GENERIC_ALL,
                 LsapLocalSystemSid
                 );

    ASSERT( NT_SUCCESS(Status) );

    //
    // ADMINISTRATORS access
    //

    Status = RtlAddAccessAllowedAce (
                 pEventDacl,
                 ACL_REVISION,
                 ulAdminAccess,
                 LsapAliasAdminsSid
                 );

    ASSERT( NT_SUCCESS(Status) );

    //
    // Now initialize security descriptors
    // that export this protection
    //

    Status = RtlCreateSecurityDescriptor(
                 pEventSD,
                 SECURITY_DESCRIPTOR_REVISION1
                 );

    ASSERT( NT_SUCCESS(Status) );

    Status = RtlSetDaclSecurityDescriptor(
                 pEventSD,
                 TRUE,                       // DaclPresent
                 pEventDacl,
                 FALSE                       // DaclDefaulted
                 );

    ASSERT( NT_SUCCESS(Status) );

    if (dwType == BUILD_KSEC_SD)
    {
        Status = NtSetSecurityObject(
                    hEvent,
                    DACL_SECURITY_INFORMATION,
                    pEventSD
                    );

        CloseHandle(hEvent);
        LsapFreeLsaHeap(pEventSD);

        if (!NT_SUCCESS(Status))
        {
            DebugLog((DEB_ERROR,"Failed to set event SD: 0x%x\n",Status));
        }
    }
    else
    {
        ASSERT(hEvent == NULL);

        if (NT_SUCCESS(Status))
        {
            *ppSD = pEventSD;
        }
        else
        {
            DebugLog((DEB_ERROR, "Failed to create LPC SD: 0x%x\n", Status));
            LsapFreeLsaHeap(pEventSD);
        }
    }

    return(Status);
}

//+-------------------------------------------------------------------------
//
//  Function:   CreateLpcPort
//
//  Synopsis:   Creates an LPC port and returns a handle to it.
//
//  Effects:
//
//  Arguments:  phPort      - receives port handle
//              pszPortName - Unicode name of port
//              cbConnect   - Size of the connect message data
//              cbMessage   - Size of the messages
//              cMessages   - Max number of messages queued
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//--------------------------------------------------------------------------

NTSTATUS
CreateLpcPort(  HANDLE *    phPort,
                PWSTR       pszPortName,
                DWORD       cbConnect,
                DWORD       cbMessage,
                DWORD       cMessages)
{
    NTSTATUS             nsReturn;
    OBJECT_ATTRIBUTES    PortObjAttr;
    UNICODE_STRING       ucsPortName;
    PSECURITY_DESCRIPTOR psdPort;

    //
    // Create a security descriptor for the port we are about to create
    //

    nsReturn = LsapBuildSD(BUILD_LPC_SD, &psdPort);

    if (!NT_SUCCESS(nsReturn))
    {
        return nsReturn;
    }

    //
    // Create the name
    //

    RtlInitUnicodeString(&ucsPortName, pszPortName);

    InitializeObjectAttributes(&PortObjAttr, &ucsPortName, 0, NULL, psdPort);

    //
    // Create the port

    nsReturn = NtCreatePort(phPort,                 // returned handle
                            &PortObjAttr,           // name, etc.
                            cbConnect,              // size of a connect msg
                            cbMessage,              // size of a normal msg
                            cMessages * cbMessage   // number of msgs to buffer
                            );                      // communication

    LsapFreeLsaHeap(psdPort);

    return nsReturn;
}


//+---------------------------------------------------------------------------
//
//  Function:   AcceptConnection
//
//  Synopsis:   Accepts a connection from a client.
//
//  Effects:
//
//  Arguments:  [ConnectReq]  --
//
//  Requires:
//
//  Returns:
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:
//
//  History:    7-22-93   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------

DWORD
AcceptConnection(
    PVOID   pvConnect
    )
{
    PSession            pSession = NULL ;
    HANDLE              hCommPort;
    PHANDLE             phPort;
    NTSTATUS            scRet;
    BOOLEAN             bAccept = TRUE;
    NTSTATUS            Status;
    PSPM_LPC_MESSAGE    ConnectReq = (PSPM_LPC_MESSAGE) pvConnect;
    WCHAR               LogonProcessName[LSAP_MAX_PACKAGE_NAME_LENGTH+1];
    CHAR                NarrowLogonName[ LSAP_MAX_PACKAGE_NAME_LENGTH + 1 ];
    LUID                LogonId;
    ULONG               Flags = 0;
    LSA_CALL_INFO       CallInfo ;

    DBG_DISPATCH_PROLOGUE( LpcApiLog, pvConnect, CallInfo );

    scRet = LsapValidLogonProcess(
                &ConnectReq->ConnectionRequest,
                ConnectReq->pmMessage.u1.s1.DataLength,
                &ConnectReq->pmMessage.ClientId,
                &LogonId,
                &Flags
                );

    if (NT_SUCCESS(scRet))
    {
        //
        // Create a session to represent the client.
        //

        strncpy(
            NarrowLogonName,
            ConnectReq->ConnectionRequest.LogonProcessName,
            LSAP_MAX_PACKAGE_NAME_LENGTH
            );

        NarrowLogonName[ LSAP_MAX_PACKAGE_NAME_LENGTH ] = '\0';

        mbstowcs(
            LogonProcessName,
            NarrowLogonName,
            LSAP_MAX_PACKAGE_NAME_LENGTH+1
            );

        scRet = CreateSession(  &ConnectReq->pmMessage.ClientId,
                                TRUE,
                                LogonProcessName,
                                Flags,
                                &pSession);
    }

    if (!NT_SUCCESS(scRet))
    {
        bAccept = FALSE;
        phPort = &hCommPort;
        if ( pSession )
        {
            SpmpDereferenceSession( pSession );
            pSession = NULL ;
        }
    }
    else
    {
        PLSAP_AU_REGISTER_CONNECT_RESP Response;

        phPort = &pSession->hPort;

        //
        // Fill in the complete connection info:
        //

        Response = (PLSAP_AU_REGISTER_CONNECT_RESP) &ConnectReq->ConnectionRequest;

        if ( pSession->dwProcessID == pDefaultSession->dwProcessID )
        {
            //
            // We're connecting to us.  Set a flag:
            //

            Response->SecurityMode |= LSA_MODE_SAME_PROCESS ;
        }

        Response->CompletionStatus = STATUS_SUCCESS;
        Response->PackageCount = SpmpCurrentPackageCount();
    }

    //
    // Accept the connection
    //

    DebugLog((DEB_TRACE, "LpcListen:  %sing connection from %x.%x\n",
               (bAccept ? "Accept" : "Reject"),
               ConnectReq->pmMessage.ClientId.UniqueProcess,
               ConnectReq->pmMessage.ClientId.UniqueThread ));

    Status = NtAcceptConnectPort(phPort,        // Save the port handle
                                pSession,       // Associate the session
                                (PPORT_MESSAGE) ConnectReq,
                                                // Connection request to accept
                                bAccept,        // Accept the connection
                                NULL,           // Server view (none)
                                NULL            // Client view (none)
                                );

    if ( !NT_SUCCESS( Status ) )
    {
        //
        // Failed to respond appropriately.  If we had
        // set things up for this session, tear them down
        //

        if ( NT_SUCCESS( scRet ) )
        {
            SpmpDereferenceSession( pSession );
            pSession = NULL ;

            goto Cleanup ;
        }
    }

    if ((!NT_SUCCESS(scRet)) || (!bAccept))
    {
        if ( scRet == STATUS_INVALID_CID )
        {
            PPORT_MESSAGE Message = (PPORT_MESSAGE) ConnectReq ;

            DebugLog((DEB_ERROR,
                      "LSA: Failed to %s client [%x.%x, Message %x] because of invalid clientid\n",
                      ( bAccept ? "accept" : "reject" ),
                      Message->ClientId.UniqueProcess,
                      Message->ClientId.UniqueThread,
                      Message->MessageId));
        }

        DebugLog((DEB_ERROR, "Failed to accept 0x%08x\n", scRet));

        //
        // Delete the session we just created:
        //

        if ( pSession )
        {
            SpmpDereferenceSession( pSession );
        }

        goto Cleanup;
    }

    //
    // Must complete the session record *BEFORE* calling CompleteConnectPort,
    // since as soon as that happens, the other guy could send another message
    // and we might hit an assert.
    //

    if (bAccept)
    {
        Status = NtCompleteConnectPort(pSession->hPort);
    }

Cleanup:

    DBG_DISPATCH_POSTLOGUE( (NT_SUCCESS(Status) ? ULongToPtr(scRet) : ULongToPtr(Status)),
                            LongToPtr(DBG_CONNECT) );

    LsapFreePrivateHeap( ConnectReq );

    return( 0 );
}


//+---------------------------------------------------------------------------
//
//  Function:   LpcServerThread
//
//  Synopsis:   Handles all requests from clients
//
//  Arguments:  [pvIgnored] --
//
//  History:    7-23-93   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------

ULONG
LpcServerThread(PVOID   pvIgnored)
{
    PSession            pSession;
    PSession            pMySession = GetCurrentSession();
    NTSTATUS             scRet;
    PSPM_LPC_MESSAGE    pMessage;
    CSHORT              sMessageType;
    NTSTATUS            Status;
    UCHAR               PanicBuffer[sizeof(SPM_LPC_MESSAGE)];
    BOOLEAN             OutOfMemory;
    HANDLE              hDummy;
    PVOID               TaskPointer ;
    LPTHREAD_START_ROUTINE TaskFunction ;
    BOOL                ScheduleUrgent ;
    BOOL                ExecNow ;
#if DBG_TRACK_API
    PLSAP_API_LOG_ENTRY Entry ;
#endif

    //
    // First, create the port:
    //

    DebugLog((DEB_TRACE_INIT, "LpcServerThread starting up, creating port\n"));

    scRet = CreateLpcPort(  &hLpcPort,          // Handle that stores the port
                            szPortName,         // Name of the port.
                            sizeof(SPM_LPC_MESSAGE), // Size of a connect message
                            sizeof(SPM_LPC_MESSAGE), // Size of a request message
                            16);                // Number of messages to queue

    if (FAILED(scRet))
    {
        DebugLog((DEB_ERROR, "CreateLpcPort returned 0x%08x\n", scRet));
        return((ULONG) scRet);
    }

    DebugLog((DEB_TRACE, "LPCServerThread started on port %ws\n", szPortName));

    DebugLog((DEB_TRACE_INIT, "LpcServerThread starting up:  setting event\n"));

    //
    // Trigger the KSec event that will cause the device driver to allow
    // connections
    //

    scRet = SetKsecEvent();

#if DBG
    if (FAILED(scRet))
    {
        DebugLog((DEB_ERROR, "Error setting event, %x\n", scRet));
    }
#endif

#if DBG_TRACK_API

    LpcApiLog = ApiLogCreate( 0 );

    if ( !LpcApiLog )
    {
        NtClose( hLpcPort );

        return STATUS_NO_MEMORY ;
    }

#endif

    //
    // All we do is wait here:
    //

    for (; ; )
    {
        //
        // Allocate memory for the message
        //

        pMessage = (PSPM_LPC_MESSAGE) LsapAllocatePrivateHeap(
                                sizeof( SPM_LPC_MESSAGE ) );

        if (pMessage)
        {
            OutOfMemory = FALSE;
        }
        else
        {
            OutOfMemory = TRUE;
            pMessage = (PSPM_LPC_MESSAGE) PanicBuffer;
        }

        //
        // Wait for a message from one of the critters
        //
        pSession = NULL;
        ExecNow = FALSE ;

        Status = NtReplyWaitReceivePort(hLpcPort,                   // Port
                                        (void **)&pSession,         // Get session
                                        NULL,                       // No reply
                                        (PPORT_MESSAGE) pMessage);  // Recvd msg

        if ( !NT_SUCCESS( Status ) )
        {
            DebugLog(( DEB_ERROR, "LpcServer:  ReplyWaitReceive returned %x\n",
                       Status ));

            if ( !OutOfMemory )
            {
                LsapFreePrivateHeap( pMessage );
            }

            continue;
        }

        DebugLog((DEB_TRACE_WAPI, "LpcServer:  Received msg from %x.%x\n",
                    pMessage->pmMessage.ClientId.UniqueProcess,
                    pMessage->pmMessage.ClientId.UniqueThread));

        if (pSession)
        {
            DsysAssert(pSession->hPort);
        }
        else
        {
            DsysAssert(pMessage->pmMessage.u2.s2.Type == LPC_CONNECTION_REQUEST);
        }

        if (OutOfMemory)
        {
            //
            // Generate a fail
            //
            DebugLog((DEB_ERROR, "KLPC:  out of memory, failing request %x\n",
                        pMessage->pmMessage.MessageId));

            if (pMessage->pmMessage.u2.s2.Type == LPC_CONNECTION_REQUEST)
            {
                Status = NtAcceptConnectPort(
                                &hDummy,
                                NULL,
                                (PPORT_MESSAGE) pMessage,
                                FALSE,
                                NULL,
                                NULL);
            }
            else if (pMessage->pmMessage.u2.s2.Type == LPC_REQUEST)
            {
                pMessage->ApiMessage.Args.SpmArguments.fAPI |= SPMAPI_FLAG_ERROR_RET;
                pMessage->ApiMessage.scRet = STATUS_INSUFFICIENT_RESOURCES;

                while (TRUE)
                {
                    Status = NtReplyPort(pSession->hPort, (PPORT_MESSAGE) pMessage);

                    if (Status == STATUS_INSUFFICIENT_RESOURCES ||
                        Status == STATUS_NO_MEMORY)
                    {
                        Sleep(125);
                    }
                    else
                    {
                        break;
                    }
                }
            }
            else if (pMessage->pmMessage.u2.s2.Type == LPC_PORT_CLOSED)
            {
                SetCurrentSession( pSession );

                RundownConnectionNoFree( pMessage );

                SetCurrentSession( pMySession );
            }
            else
            {
                DebugLog((DEB_ERROR, "Unknown Message received, punting\n"));
            }

            continue;
        }

        if (!NT_SUCCESS(Status))
        {
            DebugLog((DEB_ERROR, "Discarding message, %x\n", scRet));

            LsapFreePrivateHeap( pMessage );

            continue;
        }

        //
        // Check message for LPC errors
        //

#if DBG_TRACK_API

        Entry = ApiLogAlloc( LpcApiLog );

        if ( Entry )
        {
            Entry->MessageId = pMessage->pmMessage.MessageId ;
            Entry->pvMessage = pMessage ;
            GetSystemTimeAsFileTime( (LPFILETIME) &Entry->QueueTime );
        }

#endif

        sMessageType = pMessage->pmMessage.u2.s2.Type;
        switch(sMessageType & ~LPC_KERNELMODE_MESSAGE)
        {
            case LPC_REQUEST:
            case LPC_REPLY:
            case LPC_DATAGRAM:

                //
                // "Normal" API requests.  Route to the standard
                // handler, non urgent:
                //

                TaskFunction = LpcHandler ;
                ScheduleUrgent = FALSE ;

                if ((pMessage->ApiMessage.dwAPI > LsapAuMaxApiNumber) &&
                    (pMessage->ApiMessage.dwAPI < SPMAPI_MaxApiNumber) &&
                    (pMessage->ApiMessage.Args.SpmArguments.fAPI & SPMAPI_FLAG_EXEC_NOW) )
                {
                    ExecNow = TRUE ;
                }

                break;

            case LPC_CONNECTION_REQUEST:

                //
                // New connection request.  Handle with some priority
                //

                TaskFunction = AcceptConnection ;
                ScheduleUrgent = TRUE ;
                pSession = pMySession ;
                break;

            case LPC_PORT_CLOSED:

                //
                // Client has gone away.  Make sure we clean up
                //

                TaskFunction = RundownConnection ;
                ScheduleUrgent = FALSE ;

                DebugLog((DEB_TRACE, "Client %d.%d died, running down session\n",
                                pMessage->pmMessage.ClientId.UniqueProcess,
                                pMessage->pmMessage.ClientId.UniqueThread));

                break ;

            case LPC_LOST_REPLY:
            case LPC_CLIENT_DIED:
            case LPC_EXCEPTION:
            case LPC_DEBUG_EVENT:
            case LPC_ERROR_EVENT:
            default:

                //
                // These are debugger messages, so we should never see them.
                //

                DebugLog((DEB_WARN,"Discarding message type %d\n",sMessageType));

                LsapFreePrivateHeap( pMessage );

                continue;
        }

        //
        // If the message has the EXEC_NOW flag on, that means that the caller
        // deemed this urgent, and not to be spawned to another thread.
        //
        if ( ExecNow )
        {
            TlsSetValue(dwSession, pSession);
            LpcHandler(pMessage);
            TlsSetValue(dwSession, pMySession);
            continue;
        }

        //
        // Assign a thread to handle the request, and
        // then loop back and wait again.
        //

        TaskPointer = LsapAssignThread(
                        TaskFunction,
                        pMessage,
                        pSession,
                        ScheduleUrgent != 0);

        if ( !TaskPointer )
        {
            //
            // Generate a fail
            //
            DebugLog((DEB_ERROR, "KLPC:  out of memory, failing request %x\n",
                        pMessage->pmMessage.MessageId));

            //
            // For connection requests, there is no reply.  In fact, using Reply
            // will cause lots of problems since the client will be stalled waiting
            // for the reply.
            //

            if ( sMessageType == LPC_CONNECTION_REQUEST )
            {
                Status = NtAcceptConnectPort(
                                &hDummy,
                                NULL,
                                (PPORT_MESSAGE) pMessage,
                                FALSE,
                                NULL,
                                NULL);

                DBG_DISPATCH_POSTLOGUE( UlongToPtr( STATUS_INSUFFICIENT_RESOURCES ),
                                    LongToPtr(DBG_CONNECT) );
            }
            else
            {
                pMessage->ApiMessage.Args.SpmArguments.fAPI |= SPMAPI_FLAG_ERROR_RET;
                pMessage->ApiMessage.scRet = STATUS_INSUFFICIENT_RESOURCES;

                while (TRUE)
                {
                    Status = NtReplyPort(pSession->hPort, (PPORT_MESSAGE) pMessage);

                    if (Status == STATUS_INSUFFICIENT_RESOURCES ||
                        Status == STATUS_NO_MEMORY)
                    {
                        Sleep(125);
                    }
                    else
                    {
                        break;
                    }
                }

                DBG_DISPATCH_POSTLOGUE( ULongToPtr( STATUS_INSUFFICIENT_RESOURCES ),
                                pMessage->ApiMessage.dwAPI );
            }

            LsapFreePrivateHeap( pMessage );
        }

#if DBG_TRACK_API

        if ( Entry )
        {
            Entry->WorkItem = TaskPointer ;
        }
#endif

    }

    return((ULONG) scRet);
}


//+---------------------------------------------------------------------------
//
//  Function:   LpcHandler
//
//  Synopsis:   Generic threadpool function called to handle an LPC request
//
//  Arguments:  [pMsg] -- Message to process
//
//  History:    7-23-93   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------

DWORD
LpcHandler(
    PVOID    pMsg
    )
{
    PSPM_LPC_MESSAGE    pApi = (PSPM_LPC_MESSAGE) pMsg ;
    PSession            pSession = (PSession) TlsGetValue(dwSession);
    NTSTATUS            Status = STATUS_SUCCESS;
    DWORD               i;
    LSA_CALL_INFO       CallInfo ;
    PULONG_PTR          Where ;
    BOOL                BreakOnCall = FALSE;
    BOOL                IsCallInfoSet = FALSE;

    ZeroMemory( &CallInfo, sizeof(CallInfo) );

    DBG_DISPATCH_PROLOGUE( LpcApiLog, pApi, CallInfo );

    DsysAssert( pSession != pDefaultSession );

    //
    // Verify that if the caller claimed to be from Kernel mode
    // that they still are.  If the session is still indefinite,
    // fix that up now:
    //

    if ( ( pSession->fSession & SESFLAG_MAYBEKERNEL ) != 0 )
    {
        if ( ( pApi->pmMessage.u2.s2.Type & LPC_KERNELMODE_MESSAGE ) != 0 )
        {
            pSession->fSession &= ~(SESFLAG_MAYBEKERNEL | SESFLAG_WOW_PROCESS) ;
            pSession->fSession |= SESFLAG_KERNEL ;

            if ( pEfsSession )
            {
                if ( (pEfsSession->fSession & SESFLAG_EFS) == 0 )
                {
                    LsapUpdateEfsSession( pSession );
                }
            }
        }
        else
        {
            //
            // This was a very bad caller.  They set the flag that it
            // was going to be a kernel mode session, but then they turned
            // out not to be in kernel mode.  Kill this session
            //

            LockSession( pSession );
            if ( pSession->hPort )
            {
                NtClose( pSession->hPort );
                pSession->hPort = NULL ;
            }
            UnlockSession( pSession );

            goto Cleanup;
        }
    }

    if ((pApi->ApiMessage.dwAPI > LsapAuMaxApiNumber) &&
        ((pSession->fSession & SESFLAG_KERNEL) != 0))
    {
        if ((pApi->pmMessage.u2.s2.Type & LPC_KERNELMODE_MESSAGE) == 0)
        {
            DebugLog((DEB_ERROR, "Caller claimed to be from kernelmode but sent non-kernelmode message\n"));
            pApi->ApiMessage.scRet = STATUS_ACCESS_DENIED ;
            Status = STATUS_ACCESS_DENIED;
        }
    }

    CallInfo.Message = pApi ;
    CallInfo.CallInfo.ProcessId = HandleToUlong(pApi->pmMessage.ClientId.UniqueProcess);
    CallInfo.CallInfo.ThreadId = HandleToUlong(pApi->pmMessage.ClientId.UniqueThread);
    CallInfo.CallInfo.Attributes = 0 ;
    CallInfo.InProcCall = FALSE ;
    CallInfo.Session = pSession ;

    if (((pSession->fSession & SESFLAG_TCB_PRIV) != 0) ||
        ((pSession->fSession & SESFLAG_KERNEL) != 0))
    {
        CallInfo.CallInfo.Attributes |= SECPKG_CALL_IS_TCB ;
    }

    if ( pApi->ApiMessage.Args.SpmArguments.fAPI & SPMAPI_FLAG_ANSI_CALL)
    {
        CallInfo.CallInfo.Attributes |= SECPKG_CALL_ANSI ;
    }

    if ( pApi->pmMessage.u2.s2.Type & LPC_KERNELMODE_MESSAGE )
    {
        CallInfo.CallInfo.Attributes |= SECPKG_CALL_KERNEL_MODE ;

        if ( pApi->ApiMessage.Args.SpmArguments.fAPI & SPMAPI_FLAG_KMAP_MEM )
        {
            CallInfo.Flags |= CALL_FLAG_KERNEL_POOL ;
            CallInfo.KMap = (PKSEC_LSA_MEMORY_HEADER) pApi->ApiMessage.Args.SpmArguments.ContextPointer;
        }
    }

    //
    // If the kernel driver has set the error-ret flag, then we have
    // been asked to break in by the driver.  If we're allowed to take
    // breakpoints (checked later), we'll break in.  For now, set the flag
    // that we should check:
    //

    if ( pApi->ApiMessage.Args.SpmArguments.fAPI & SPMAPI_FLAG_ERROR_RET )
    {
        if ( CallInfo.CallInfo.Attributes & SECPKG_CALL_KERNEL_MODE )
        {
            BreakOnCall = TRUE ;
        }
    }

    if ( pSession->fSession & SESFLAG_WOW_PROCESS )
    {
        CallInfo.CallInfo.Attributes |= SECPKG_CALL_WOWCLIENT ;
    }

    CallInfo.Allocs = 0 ;

    //
    // Only copy out the IP address from "new" clients (vs. clients compiled using a version
    // of lsadll.lib from a previous OS release that didn't have this field).
    //

    if ( pApi->ApiMessage.dwAPI == LsapAuLogonUserApi
          &&
         pApi->pmMessage.u1.s1.DataLength == LSAP_AU_DATA_LENGTH(sizeof(LSAP_LOGON_USER_ARGS)))
    {
        RtlCopyMemory(CallInfo.IpAddress,
                      pApi->ApiMessage.Args.LsaArguments.LogonUser.IpAddress,
                      LSAP_ADDRESS_LENGTH);
    }
    else if ( pApi->ApiMessage.dwAPI == SPMAPI_AcceptContext )
    {
        RtlCopyMemory(CallInfo.IpAddress,
                      pApi->ApiMessage.Args.SpmArguments.API.AcceptContext.IpAddress,
                      LSAP_ADDRESS_LENGTH);
    }

    if (NT_SUCCESS(Status))
    {
        DebugLog((DEB_TRACE_WAPI, "[%x.%x] Dispatching API (Message %x)\n",
                    pApi->pmMessage.ClientId.UniqueProcess,
                    pApi->pmMessage.ClientId.UniqueThread,
                    pApi->pmMessage.MessageId));

        LsapSetCurrentCall( &CallInfo );
        IsCallInfoSet = TRUE;

        //
        // Call the dispatcher, and have the request routed to the security package
        //

        DsysAssert( pSession->hPort );

        //
        // If we need a breakpoint, this will do it.  Note that this
        // will return immediately if we weren't started under a debugger.
        //

        if ( BreakOnCall )
        {
            LsapInternalBreak();
        }

        Status = DispatchAPI( pApi );

#if DBG
        if ( ( LsapTrapStatusCode != 0 ) )
        {
            DsysAssert( LsapTrapStatusCode != pApi->ApiMessage.scRet );
        }
#endif

    }

    //
    // Done.  Send the message back to the caller, and return to the
    // thread pool.
    //

    if ( ( pApi->ApiMessage.dwAPI > LsapAuMaxApiNumber ) &&
         ( pApi->ApiMessage.Args.SpmArguments.fAPI & SPMAPI_FLAG_ALLOCS ) )
    {
        if ( CallInfo.Allocs )
        {
            DsysAssert( CallInfo.Allocs <= MAX_BUFFERS_IN_CALL );

            Where = (PULONG_PTR) pApi->ApiMessage.bData ;

            *Where++ = CallInfo.Allocs ;

            for ( i = 0 ; i < CallInfo.Allocs ; i++ )
            {
                *Where++ = (ULONG_PTR) CallInfo.Buffers[ i ];
            }
        }
        else
        {
            pApi->ApiMessage.Args.SpmArguments.fAPI &= ~(SPMAPI_FLAG_ALLOCS) ;
        }
    }

    DsysAssert(pSession->hPort);

    do
    {
        Status = NtReplyPort(   pSession->hPort,
                                (PPORT_MESSAGE) pApi);

        if ( ! NT_SUCCESS( Status ) )
        {
            if (Status == STATUS_NO_MEMORY)
            {
                Sleep(125);     // Sleep for an eighth of a second, and retry
                continue;
            }

            if (Status == STATUS_INVALID_CID)
            {
                //
                // Already received the CLIENT_DIED and has been run down,
                // and the session has been deref'd, so when we go, it will
                // be closed completely.
                //

                break ;
            }

            //
            // All other errors, until we have something more sensible to
            // do,
            //

            LsapLpcContextCleanup(pApi);

            break;
        }
    } while ( !NT_SUCCESS(Status)  );

Cleanup:

    if (IsCallInfoSet)
    {
       LsapSetCurrentCall( NULL );
    }

    DBG_DISPATCH_POSTLOGUE(
            (NT_SUCCESS( Status ) ? ULongToPtr(pApi->ApiMessage.scRet) : ULongToPtr(Status)),
            LongToPtr(pApi->ApiMessage.dwAPI) );

    LsapFreePrivateHeap( pApi );

    //
    // We're out of here.
    //

    return(0);
}


//+---------------------------------------------------------------------------
//
//  Function:   RundownConnection
//
//  Synopsis:   Handles running down a closed connection
//
//  Arguments:  [pMsg] -- Message
//
//  History:    4-01-94   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
DWORD
RundownConnectionNoFree(PVOID pMsg)
{
    NTSTATUS       scRet;
    PSession    pSession;
    LSA_CALL_INFO CallInfo ;

    DBG_DISPATCH_PROLOGUE( LpcApiLog, pMsg, CallInfo );

    pSession = GetCurrentSession();

    DebugLog((DEB_TRACE, "[%x] Process Detach\n", pSession->dwProcessID));

    //
    // Call the session manager to do preliminary cleanup:
    //

    LsapSessionDisconnect( pSession );

    //
    // Deref the session.  Note that a client may have died while we were
    // processing one or more requests in other threads.  So, this is a
    // safe (possibly deferred) dereference operation.
    //

    SpmpDereferenceSession(pSession);

    //
    // Use the default, spmgr session.
    //

    TlsSetValue(dwSession, pDefaultSession);

    //
    // Clean up and we're out of here...
    //

    DBG_DISPATCH_POSTLOGUE( ULongToPtr(STATUS_SUCCESS), LongToPtr(DBG_DISCONNECT) );

    return(0);
}

DWORD
RundownConnection(
    PVOID pMessage
    )
{
    RundownConnectionNoFree( pMessage );

    LsapFreePrivateHeap( pMessage );

    return 0 ;
}

//+---------------------------------------------------------------------------
//
//  Function:   CatchLpcDeath
//
//  Synopsis:   This function is invoked when the LPC thread dies
//
//  Arguments:  [PVOID] --
//
//  History:    9-13-95   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------


DWORD
CatchLpcDeath(
    PVOID pvIgnored)
{

    DsysAssertMsg(FALSE, "LPC Thread died");

    return(0);
}

//+---------------------------------------------------------------------------
//
//  Function:   StartLpcThread
//
//  Synopsis:   Initializes the LPC server.
//
//  Arguments:  (none)
//
//  History:    7-23-93   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------


NTSTATUS
StartLpcThread(void)
{

    DWORD   tid;


    hListenThread = LsapCreateThread(
                        NULL,
                        0,
                        LpcServerThread,
                        0,
                        0,
                        &tid
                        );

    if (!hListenThread)
    {
        return(STATUS_UNSUCCESSFUL);
    }

    LsaIRegisterNotification(
        CatchLpcDeath,
        NULL,
        NOTIFIER_TYPE_HANDLE_WAIT,
        0,
        NOTIFIER_FLAG_ONE_SHOT,
        0,
        hListenThread
        );

    return(STATUS_SUCCESS);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\base\lsa\server\logons.cxx ===
//+-----------------------------------------------------------------------
//
// Microsoft Windows
//
// Copyright (c) Microsoft Corporation 1991 - 1992
//
// File:        Logons.c
//
// Contents:    Logon Session lists and so forth
//
// Functions    InitLogonSessions
//              AddLogonSession
//              LocateLogonSession
//
//
// History:     27 Oct 92   RichardW    Created
//
//------------------------------------------------------------------------

#include <lsapch.hxx>

extern "C"
{
#include <ntrmlsa.h>
#include "sidcache.h"
#include <adtp.h>
#include <secext.h>
#include <lm.h>        // NetApiBufferFree

NTSTATUS LsapInitializeCredentials();
}

#define THIRTY_MIN  { 0x30E23400, 0x00000004 }
#define NEVER_MIN   { 0xFFFFFFFF, 0x7FFFFFFF }

#define LOGON_SESSION_LIST_COUNT_MAX    8
// insure power of 2.
C_ASSERT( (LOGON_SESSION_LIST_COUNT_MAX % 2) == 0 );

ULONG LogonSessionListCount;
RTL_RESOURCE LogonSessionListLock[ LOGON_SESSION_LIST_COUNT_MAX ] ;

PVOID LogonSessionTable ;
PHANDLE_PACKAGE LogonSessionPackage ;

LIST_ENTRY LogonSessionList[ LOGON_SESSION_LIST_COUNT_MAX ] ;

ULONG LogonSessionCount[ LOGON_SESSION_LIST_COUNT_MAX ] ;
PLSAP_DS_NAME_MAP LocalSystemNameMap ;

#define LogonIdToListIndex(Id)                  (Id.LowPart & (LogonSessionListCount-1))
#define LogonIdToListIndexPtr(Id)               (Id->LowPart & (LogonSessionListCount-1))

#define WriteLockLogonSessionList(LockIndex)    RtlAcquireResourceExclusive( &LogonSessionListLock[LockIndex], TRUE )
#define ReadLockLogonSessionList(LockIndex)     RtlAcquireResourceShared( &LogonSessionListLock[LockIndex], TRUE )
#define ReadToWriteLockLogonSessionList(LockIndex)   RtlConvertSharedToExclusive( &LogonSessionListLock[LockIndex] )
#define UnlockLogonSessionList(LockIndex)       RtlReleaseResource( &LogonSessionListLock[LockIndex] )

// #define LOGON_SESSION_TRACK 1

#ifdef LOGON_SESSION_TRACK
HANDLE LogonSessionLog ;
#endif

extern "C"
VOID LogonSessionLogWrite( PCHAR Format, ... );

#ifdef LOGON_SESSION_TRACK
#define LSLog( x )  LogonSessionLogWrite x
#else
#define LSLog( x )
#endif

LARGE_INTEGER LsapNameLifespans[ LSAP_MAX_DS_NAMES ] =
{
    THIRTY_MIN,     // Unknown
    THIRTY_MIN,     // FQDN (CN=yada, DC=yada)
    NEVER_MIN,      // SAM Compatible
    THIRTY_MIN,     // Display (Fred Smith)
    THIRTY_MIN,     // unused
    THIRTY_MIN,     // unused
    NEVER_MIN,      // GUID
    THIRTY_MIN,     // Canonical
    THIRTY_MIN,     // UPN
    THIRTY_MIN,     // Canonical Ex
    THIRTY_MIN,     // SPN
    NEVER_MIN,      // unused (by GetUserNameEx)
    NEVER_MIN       // DNS domain name
};

#define LsapConvertLuidToSecHandle( L, H ) \
            ((PSecHandle)(H))->dwLower = ((PLUID)(L))->HighPart ;  \
            ((PSecHandle)(H))->dwUpper = ((PLUID)(L))->LowPart ;

BOOL
LsapSetSamAccountNameForLogonSession(
    PLSAP_LOGON_SESSION LogonSession
    );

NTSTATUS
LsapGetFormatsForLogon(
    PLSAP_LOGON_SESSION LogonSession,
    IN LPWSTR Domain,
    IN LPWSTR Name,
    IN ULONG  NameType,
    OUT PLSAP_DS_NAME_MAP * Map
    );

NTSTATUS
LsapCreateDnsNameFromCanonicalName(
    IN  PLSAP_LOGON_SESSION LogonSession,
    IN  ULONG               NameType,
    OUT PLSAP_DS_NAME_MAP   * Map
    );


#ifdef LOGON_SESSION_TRACK

VOID
LogonSessionLogWrite(
    PCHAR Format,
    ...
    )
{
    CHAR Buffer[ 256 ];
    va_list ArgList ;
    int TotalSize ;
    ULONG SizeWritten ;

    if ( LogonSessionLog == NULL )
    {
        return;
    }

    va_start( ArgList, Format );

    if ((TotalSize = _vsnprintf(Buffer,
                                sizeof(Buffer),
                                Format, ArgList)) < 0)
    {
        return;

    }

    WriteFile( LogonSessionLog, Buffer, TotalSize, &SizeWritten, NULL );

}

VOID
LsapInitLogonSessionLog(
    VOID
    )
{
    WCHAR Path[ MAX_PATH ];

    ExpandEnvironmentStrings(L"%SystemRoot%\\Debug\\logonsession.log", Path, MAX_PATH );

    LogonSessionLog = CreateFile( Path, GENERIC_WRITE, FILE_SHARE_READ,
                                  NULL, CREATE_ALWAYS, 0, NULL );


    if ( LogonSessionLog == INVALID_HANDLE_VALUE )
    {
        LogonSessionLog = NULL ;

        return ;
    }

    LogonSessionLogWrite( "New LogonSession log created\n" );

}

#endif


ULONG LogonFormats[] =
{
    NameFullyQualifiedDN,  // needed for GPO
    NameUniqueId           // needed for GPO
};

BOOLEAN
LsapIsNameFormatUsedForLogon(
    IN ULONG NameType
    )
{
    ULONG i;

    for ( i = 0; i < (sizeof(LogonFormats)/sizeof(LogonFormats[0])); i++) {
        if ( NameType == LogonFormats[i] ) {
            return TRUE;
        }
    }

    return FALSE;
}


//+---------------------------------------------------------------------------
//
//  Function:   LsapDerefDsNameMap
//
//  Synopsis:   Drops the refcount on a DS name map and deletes it if the
//              refcount hits zero
//
//  Arguments:  [Map] -- Pointer to the DS name map
//
//  History:    8-17-98   RichardW   Created
//
//  Notes:      If Map points into an active logon session, THE EXCLUSIVE
//              WRITE LOCK FOR THAT LOGON SESSION MUST BE HELD WHEN THIS
//              ROUTINE IS CALLED.
//
//----------------------------------------------------------------------------

VOID
LsapDerefDsNameMap(
    PLSAP_DS_NAME_MAP Map
    )
{
    LONG RefCount;

    RefCount = InterlockedDecrement( &Map->RefCount );

    if ( RefCount == 0 )
    {
        LsapFreePrivateHeap( Map );
    }
}


PLSAP_DS_NAME_MAP
LsapCreateDsNameMap(
    PUNICODE_STRING Name,
    ULONG NameType
    )
{
    LSAP_DS_NAME_MAP * Map ;
    LARGE_INTEGER Now ;
    PLARGE_INTEGER Lifespan ;

    Map = (PLSAP_DS_NAME_MAP) LsapAllocatePrivateHeap(
                sizeof( LSAP_DS_NAME_MAP ) + Name->Length + sizeof(WCHAR) );

    if ( Map )
    {
        Lifespan = &LsapNameLifespans[ NameType ];

        if ( Lifespan->QuadPart != 0x7FFFFFFFFFFFFFFF )
        {
            GetSystemTimeAsFileTime( (LPFILETIME) &Now );

            Map->ExpirationTime.QuadPart = Now.QuadPart + Lifespan->QuadPart ;
        }
        else
        {
            Map->ExpirationTime.QuadPart = Lifespan->QuadPart ;
        }

        Map->RefCount = 1 ;

        Map->Name.Buffer = (PWSTR) ( Map + 1 );
        Map->Name.MaximumLength = (USHORT) ( Name->Length + sizeof(WCHAR) );
        Map->Name.Length = Name->Length ;
        RtlCopyMemory( Map->Name.Buffer,
                       Name->Buffer,
                       Name->Length );
        Map->Name.Buffer[ Map->Name.Length / sizeof( WCHAR )] = L'\0';
    }

    return Map ;
}


//+---------------------------------------------------------------------------
//
//  Function:   LsapLogonSessionDelete
//
//  Synopsis:   Callback invoked when record is to be deleted.
//
//  Arguments:  [Handle]  --
//              [Context] --
//
//  History:    8-17-98   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------

VOID
LsapLogonSessionDelete(
    PSecHandle Handle,
    PVOID Context,
    ULONG RefCount
    )
{
    PLSAP_LOGON_SESSION LogonSession ;
    ULONG i;
    ULONG ListIndex;
    BOOLEAN bAudit;
    LogonSession = (PLSAP_LOGON_SESSION) Context ;
    NTSTATUS Status;

    if (LogonSession->UserSid != NULL)
    {
        Status = LsapAdtAuditingEnabledByLogonId(
                     AuditCategoryLogon,
                     &LogonSession->LogonId,
                     EVENTLOG_AUDIT_SUCCESS,
                     &bAudit
                     );

        if (!NT_SUCCESS( Status ))
        {
            LsapAuditFailed( Status );
        }
        else if (bAudit)
        {
            LsapAdtAuditLogoff( LogonSession );
        }
    }
    
    Status = LsapAdtLogoffPerUserAuditing(
                 &LogonSession->LogonId
                 );

    if ( !NT_SUCCESS(Status)) {

        DebugLog(( DEB_ERROR, "LSA LsapAdtLogoffPerUserAuditing failed, %x\n", Status ));
    }

    ListIndex = LogonIdToListIndex(LogonSession->LogonId);

    WriteLockLogonSessionList(ListIndex);

    RemoveEntryList( &LogonSession->List );

    LogonSessionCount[ListIndex]-- ;

    UnlockLogonSessionList(ListIndex);

    LSLog(( "Deleting logon session %x:%x\n",
            LogonSession->LogonId.HighPart,
            LogonSession->LogonId.LowPart ));

    for ( i = 0 ; i < LSAP_MAX_DS_NAMES ; i++ )
    {
        if ( LogonSession->DsNames[ i ] )
        {
            LsapDerefDsNameMap( LogonSession->DsNames[ i ] );
            LogonSession->DsNames[ i ] = NULL ;
        }
    }

    LsapAuLogonTerminatedPackages( &LogonSession->LogonId );

    if ( LogonSession->Packages )
    {
        LsapFreePackageCredentialList( LogonSession->Packages );
    }

    if ( LogonSession->UserSid )
    {
        LsapDbReleaseLogonNameFromCache( LogonSession->UserSid );
        LsapFreeLsaHeap( LogonSession->UserSid );
    }

    if ( LogonSession->ProfilePath.Buffer )
    {
        LsapFreeLsaHeap( LogonSession->ProfilePath.Buffer );
    }

    if ( LogonSession->AuthorityName.Buffer )
    {
        LsapFreeLsaHeap( LogonSession->AuthorityName.Buffer );
    }

    if ( LogonSession->AccountName.Buffer )
    {
        LsapFreeLsaHeap( LogonSession->AccountName.Buffer );
    }

    if ( LogonSession->NewAuthorityName.Buffer )
    {
        LsapFreeLsaHeap( LogonSession->NewAuthorityName.Buffer );
    }
    
    if ( LogonSession->NewAccountName.Buffer )
    {
        LsapFreeLsaHeap( LogonSession->NewAccountName.Buffer );
    }

    if( LogonSession->LogonServer.Buffer )
    {
        LsapFreePrivateHeap( LogonSession->LogonServer.Buffer );
    }

    if ( LogonSession->TokenHandle != NULL )
    {
        NtClose( LogonSession->TokenHandle );
    }

    if ( LogonSession->LicenseHandle != INVALID_HANDLE_VALUE )
    {
        LsaFreeLicenseHandle( LogonSession->LicenseHandle );
    }

    CredpDereferenceCredSets( &LogonSession->CredentialSets );

    LsapFreePrivateHeap( Context );
}


NTSTATUS
LsapCreateLsaLogonSession(
    IN PLUID Luid,
    OUT PLSAP_LOGON_SESSION * pLogonSession
    )
{
    PLSAP_LOGON_SESSION LogonSession ;
    SecHandle Handle ;

    LogonSession = (PLSAP_LOGON_SESSION) LsapAllocatePrivateHeap(
                        sizeof( LSAP_LOGON_SESSION ) );

    *pLogonSession = LogonSession ;

    if ( LogonSession )
    {
        LSLog(( "Creating logon session %x:%x\n",
                Luid->HighPart, Luid->LowPart ));

        RtlZeroMemory( LogonSession, sizeof( LSAP_LOGON_SESSION ) );

        LogonSession->LogonId = *Luid ;

        GetSystemTimeAsFileTime( (LPFILETIME) &LogonSession->LogonTime );

        LsapConvertLuidToSecHandle( Luid, &Handle );

        if ( LogonSessionPackage->AddHandle(
                                    LogonSessionTable,
                                    &Handle,
                                    LogonSession,
                                    0 ) )
        {
            ULONG ListIndex = LogonIdToListIndex(LogonSession->LogonId);

            WriteLockLogonSessionList(ListIndex);

            InsertHeadList( &LogonSessionList[ListIndex], &LogonSession->List );

            LogonSessionCount[ListIndex]++ ;

            UnlockLogonSessionList(ListIndex);

            return STATUS_SUCCESS;
        }
        else
        {
            LsapFreePrivateHeap( LogonSession );
        }

        return STATUS_UNSUCCESSFUL ;
    }

    return STATUS_NO_MEMORY ;
}


BOOLEAN
LsapLogonSessionInitialize(
    VOID
    )
{
    LUID LocalSystem = SYSTEM_LUID ;
    PLSAP_LOGON_SESSION LogonSession ;
    PLSAPR_POLICY_DNS_DOMAIN_INFO DnsDomainInfo = NULL;
    PLSAP_DS_NAME_MAP NameMap = NULL;
    NTSTATUS Status ;
    NT_PRODUCT_TYPE ProductType;
    ULONG LockIndex;
    HANDLE ProcessToken;
    UNICODE_STRING UnicodeString;
    OBJECT_ATTRIBUTES obja;

    Status = LsapInitializeCredentials();

    if (!NT_SUCCESS(Status))
    {
        return FALSE;
    }

    LogonSessionListCount = 1;

    RtlGetNtProductType( &ProductType );

    if( ProductType == NtProductLanManNt ||
        ProductType == NtProductServer )
    {
        SYSTEM_INFO si;

        GetSystemInfo( &si );

        //
        // if not an even power of two, bump it up.
        //

        if( si.dwNumberOfProcessors & 1 )
        {
            si.dwNumberOfProcessors++;
        }

        //
        // insure it fits in the confines of the max allowed.
        //

        if( si.dwNumberOfProcessors > LOGON_SESSION_LIST_COUNT_MAX)
        {
            si.dwNumberOfProcessors = LOGON_SESSION_LIST_COUNT_MAX;
        }

        if( si.dwNumberOfProcessors )
        {
            LogonSessionListCount = si.dwNumberOfProcessors;
        }

        LogonSessionPackage = &LargeHandlePackage ;

    } else {

        LogonSessionPackage = &SmallHandlePackage ;
    }

    //
    // list count is 1, or a power of two, for index purposes.
    //

    ASSERT( (LogonSessionListCount == 1) || ((LogonSessionListCount % 2) == 0) );

    for( LockIndex=0 ; LockIndex < LogonSessionListCount ; LockIndex++ )
    {
        __try {
            RtlInitializeResource (&LogonSessionListLock[LockIndex]);
        } __except(EXCEPTION_EXECUTE_HANDLER)
        {
            Status = STATUS_INSUFFICIENT_RESOURCES;
            break;
        }

        InitializeListHead( &LogonSessionList[LockIndex] );
    }

    if (!NT_SUCCESS(Status))
    {
        return FALSE;
    }

#ifdef LOGON_SESSION_TRACK

    LsapInitLogonSessionLog();

    LogonSessionPackage = &LargeHandlePackage ;

#endif

    if ( LogonSessionPackage->Initialize() )
    {
        LogonSessionTable = LogonSessionPackage->Create(
                                HANDLE_PACKAGE_CALLBACK_ON_DELETE |
                                    HANDLE_PACKAGE_REQUIRE_UNIQUE,
                                NULL,
                                LsapLogonSessionDelete );

        if ( LogonSessionTable == NULL )
        {
            return FALSE ;
        }
    }
    else
    {
        return FALSE ;
    }

    //
    // Now, create the initial logon session for local system:
    //

    Status = LsapCreateLsaLogonSession(
                    &LocalSystem,
                    &LogonSession );

    if ( !NT_SUCCESS( Status ) )
    {
        return FALSE ;
    }

    Status = LsapDuplicateString(
                &LogonSession->AccountName,
                LsapDbWellKnownSidName(LsapLocalSystemSidIndex) );

    if ( !NT_SUCCESS( Status ) )
    {
        return FALSE ;
    }

    Status = LsapDuplicateString(
                &LogonSession->AuthorityName,
                LsapDbWellKnownSidDescription(LsapLocalSystemSidIndex) );

    if ( !NT_SUCCESS( Status ) )
    {
        return FALSE ;
    }

    Status = LsapDuplicateSid(
                &LogonSession->UserSid,
                LsapLocalSystemSid );

    if ( !NT_SUCCESS( Status ) )
    {
        return FALSE ;
    }

    LogonSession->LogonType = (SECURITY_LOGON_TYPE) 0 ;
    LogonSession->LicenseHandle = INVALID_HANDLE_VALUE ;

    //
    // Store the NT4 name away separately:
    //

    LsapSetSamAccountNameForLogonSession( LogonSession );

    if ( LogonSession->DsNames[ NameSamCompatible ] )
    {
        LocalSystemNameMap = LogonSession->DsNames[ NameSamCompatible ];

        LogonSession->DsNames[ NameSamCompatible ] = NULL ;
    }

    //
    // Add the DNS domain name for the machine account
    //

    Status = LsaIQueryInformationPolicyTrusted(PolicyDnsDomainInformation,
                                               (PLSAPR_POLICY_INFORMATION *) &DnsDomainInfo);

    if (NT_SUCCESS(Status))
    {
        //
        // No other threads around -- just jam the name in the logon session directly
        //

        NameMap = LsapCreateDsNameMap( (PUNICODE_STRING) &DnsDomainInfo->DnsDomainName,
                                       NameDnsDomain );

        //
        // Free the primary domain info
        //

        LsaIFree_LSAPR_POLICY_INFORMATION(PolicyDnsDomainInformation,
                                          (PLSAPR_POLICY_INFORMATION) DnsDomainInfo);

        if ( NameMap == NULL )
        {
            return FALSE;
        }

        LogonSession->DsNames[ NameDnsDomain ] = NameMap;
    }

    //
    // Grab a token handle for the logon session
    //

    Status = NtOpenProcessToken(
                 NtCurrentProcess(),
                 TOKEN_DUPLICATE|TOKEN_QUERY,
                 &ProcessToken );

    if (NT_SUCCESS( Status )) {

        Status = LsapSetSessionToken( ProcessToken, &LocalSystem );

        NtClose( ProcessToken );

        if ( !NT_SUCCESS( Status ) ) {
            return FALSE ;
        }
    }

    //
    // Init System Logon will update the names appropriately.
    //

    return TRUE ;
}


NTSTATUS
LsapCreateLogonSession(
    IN OUT PLUID LogonId
    )

/*++

Routine Description:

    This function adds a new logon session to the list of logon sessions.
    This service acquires the AuLock.

Arguments:

    LogonId - The ID to assign to the new logon session. If it is zero,
        a new logon ID will be created.

Return Value:

    STATUS_SUCCESS - The logon session has been successfully deleted.

    STATUS_LOGON_SESSION_COLLISION - The specified Logon ID is already in
        use by another logon session.

    STATUS_QUOTA_EXCEEDED - The request could not be fulfilled due to
        memory quota limitations.

--*/

{
    NTSTATUS Status;
    PLSAP_LOGON_SESSION NewSession;
    SecHandle Handle ;

    //
    // Create a logon Id if it has not already been don
    //

    if (LogonId->LowPart == 0 && LogonId->HighPart == 0)
    {
        Status =  NtAllocateLocallyUniqueId(LogonId);
        ASSERT(NT_SUCCESS(Status));
    }

    Status = LsapCreateLsaLogonSession(
                    LogonId,
                    &NewSession );

    if ( !NT_SUCCESS( Status ) )
    {
        return Status ;
    }

    NewSession->CreatingPackage = GetCurrentPackageId();

    RtlCopyLuid( &NewSession->LogonId, LogonId );

    //
    // Tell the reference monitor about the logon session...
    //

    Status = LsapCallRm(
                 RmCreateLogonSession,
                 (PVOID)LogonId,
                 (ULONG)sizeof(LUID),
                 NULL,
                 0
                 );

    if ( !NT_SUCCESS(Status) ) {

        LsapConvertLuidToSecHandle( LogonId, &Handle );

        LogonSessionPackage->DeleteHandle(
                                    LogonSessionTable,
                                    &Handle,
                                    FALSE );
        return Status;
    }

    return STATUS_SUCCESS;
}


NTSTATUS
LsapGetLogonSessionAccountInfo (
    IN PLUID LogonId,
    OUT PUNICODE_STRING AccountName,
    OUT PUNICODE_STRING AuthorityName
    )

/*++

Routine Description:

    This function retrieves username and authentication domain information
    for a specified logon session.


Arguments:

    LogonId - The ID of the logon session to set.

    AccountName - points to a unicode string with no buffer.  A buffer
        containing the account name will be allocated and returned
        using the PROCESS HEAP - NOT THE LSA HEAP.

    AuthorityName - points to a unicode string with no buffer.  A buffer
        containing the authority name will be allocated and returned
        using the PROCESS HEAP - NOT THE LSA HEAP.



Return Value:

    STATUS_NO_SUCH_LOGON_SESSION - The specified logon session does
        not currently exist.

    STATUS_NO_MEMORY - Could not allocate enough process heap.

--*/

{
    NTSTATUS                Status = STATUS_SUCCESS;
    PLSAP_LOGON_SESSION     LogonSession;
    ULONG ListIndex;

    AccountName->Length = 0;
    AccountName->Buffer = NULL;
    AccountName->MaximumLength = 0;

    AuthorityName->Length = 0;
    AuthorityName->Buffer = NULL;
    AuthorityName->MaximumLength = 0;

    LogonSession = LsapLocateLogonSession(LogonId);

    if (LogonSession == NULL)
    {
        return STATUS_NO_SUCH_LOGON_SESSION ;
    }

    ListIndex = LogonIdToListIndex( LogonSession->LogonId );

    ReadLockLogonSessionList(ListIndex);

    if ( NT_SUCCESS( Status ) &&
         LogonSession->AccountName.Buffer )
    {
        Status = LsapDuplicateString( AccountName, &LogonSession->AccountName );
    }

    if ( NT_SUCCESS( Status ) &&
         LogonSession->AuthorityName.Buffer )
    {
        Status = LsapDuplicateString( AuthorityName, &LogonSession->AuthorityName );
    }

    UnlockLogonSessionList(ListIndex);

    LsapReleaseLogonSession(LogonSession);

    return(Status);
}


BOOL
LsapSetSamAccountNameForLogonSession(
    PLSAP_LOGON_SESSION LogonSession
    )
{
    UNICODE_STRING CombinedName ;

    if ( LogonSession->AccountName.Buffer &&
         LogonSession->AuthorityName.Buffer )
    {
        SafeAllocaAllocate(CombinedName.Buffer,
                           LogonSession->AccountName.Length +
                                LogonSession->AuthorityName.Length +
                                sizeof( WCHAR ) * 2);

        if ( CombinedName.Buffer )
        {
            CombinedName.MaximumLength = LogonSession->AccountName.Length +
                                         LogonSession->AuthorityName.Length +
                                         sizeof( WCHAR ) * 2 ;

            CombinedName.Length = CombinedName.MaximumLength - 2 ;

            RtlCopyMemory( CombinedName.Buffer,
                           LogonSession->AuthorityName.Buffer,
                           LogonSession->AuthorityName.Length );

            CombinedName.Buffer[ LogonSession->AuthorityName.Length / sizeof(WCHAR) ] = L'\\';

            RtlCopyMemory( &CombinedName.Buffer[ LogonSession->AuthorityName.Length / sizeof( WCHAR ) + 1],
                           LogonSession->AccountName.Buffer,
                           LogonSession->AccountName.Length );

            CombinedName.Buffer[ CombinedName.Length / sizeof(WCHAR) ] = L'\0';

            LogonSession->DsNames[ NameSamCompatible ] =
                            LsapCreateDsNameMap(
                                &CombinedName,
                                NameSamCompatible );

            SafeAllocaFree(CombinedName.Buffer);
        }
        else
        {
            return FALSE;
        }
    }

    return ( LogonSession->DsNames[ NameSamCompatible ] != NULL );
}


NTSTATUS
LsapSetLogonSessionAccountInfo (
    IN PLUID LogonId,
    IN PUNICODE_STRING AccountName,
    IN PUNICODE_STRING AuthorityName,
    IN OPTIONAL PUNICODE_STRING ProfilePath,
    IN PSID * pUserSid,
    IN SECURITY_LOGON_TYPE LogonType,
    IN OPTIONAL PSECPKG_PRIMARY_CRED PrimaryCredentials
    )

/*++

Routine Description:

    This function sets username and authentication domain information
    for a specified logon session.

    The current account name and authority name, if any, will be freed.

    However, if this is the system logon session the information won't
    be set.

Arguments:

    LogonId - The ID of the logon session to set.

    AccountName - points to a unicode string containing the account name
        to be assigned to the logon session.  Both the UNICODE_STRING
        structure and the buffer pointed to by that structure are expected
        to be allocated from lsa heap, and they will eventually be freed
        to that heap when no longer needed.

    AuthorityName - points to a unicode string containing the name of the
        authenticating authority of the logon session.  Both the
        UNICODE_STRING structure and the buffer pointed to by that structure
        are expected to be allocated from lsa heap, and they will eventually
        be freed to that heap when no longer needed.

    ProfilePath - points to a unicode string containing the path to the
        user's profile. The structure & buffer need to be freed.

Return Value:

    STATUS_NO_SUCH_LOGON_SESSION - The specified logon session does
        not currently exist.

--*/

{
    NTSTATUS                Status = STATUS_SUCCESS;
    PLSAP_LOGON_SESSION     LogonSession;
    ULONG                   ListIndex;
    UNICODE_STRING          NullString = { 0 };
    ULONG i ;
    UNICODE_STRING          CombinedName ;
    UNICODE_STRING          OldAccountName = {0};
    UNICODE_STRING          OldProfilePath = {0};
    UNICODE_STRING          OldAuthorityName = {0};
    PSID                    OldUserSid = NULL;
    UNICODE_STRING          OldLogonServer = {0};
    UNICODE_STRING          LogonServer = {0};
    SECURITY_LOGON_TYPE     OldLogonType;
    BOOL                    fAccountNameChanged   = TRUE;
    BOOL                    fAuthorityNameChanged = TRUE;
    BOOL                    fUserSidChanged       = TRUE;

    ASSERT( pUserSid );

    LogonSession = LsapLocateLogonSession(LogonId);

    if ( !LogonSession )
    {
        return STATUS_NO_SUCH_LOGON_SESSION ;
    }

    //
    // Get a Credential Set for this session.
    //

    if ( ( ( LogonType == Interactive ) ||
           ( LogonType == Batch )       ||
           ( LogonType == Service )     ||
           ( LogonType == CachedInteractive )     ||
           ( LogonType == RemoteInteractive ) ) &&
         ( *pUserSid != NULL ) ) {

        Status = CredpCreateCredSets( *pUserSid,
                                      AuthorityName,
                                      &LogonSession->CredentialSets );

        if ( !NT_SUCCESS(Status) ) {
            LsapReleaseLogonSession(LogonSession);
            return Status;
        }
    }

    if( PrimaryCredentials != NULL )
    {
        if( PrimaryCredentials->LogonServer.Buffer )
        {
            LogonServer.Buffer = (PWSTR)LsapAllocatePrivateHeap( PrimaryCredentials->LogonServer.Length );

            if ( LogonServer.Buffer != NULL )
            {
                CopyMemory( LogonServer.Buffer,
                            PrimaryCredentials->LogonServer.Buffer,
                            PrimaryCredentials->LogonServer.Length
                            );

                LogonServer.Length = PrimaryCredentials->LogonServer.Length;
                LogonServer.MaximumLength = LogonServer.Length;
            }
            else
            {
                LsapReleaseLogonSession( LogonSession );
                return STATUS_NO_MEMORY;
            }
        }
    }

    ListIndex = LogonIdToListIndex( LogonSession->LogonId );
    WriteLockLogonSessionList(ListIndex);

    for ( i = 0 ; i < LSAP_MAX_DS_NAMES ; i++ )
    {
        //
        // Save the names that were prepopulated by the auth package.
        // SAM name is restored further down.
        //

        if ( LogonSession->DsNames[ i ]
              &&
             (i != NameDisplay)
              &&
             (i != NameUserPrincipal)
              &&
             (i != NameDnsDomain))
        {
            LsapDerefDsNameMap( LogonSession->DsNames[ i ] );

            LogonSession->DsNames[ i ] = NULL ;
        }
    }

    //
    // Free current names if necessary.  Since LsapDbAddLogonNameToCache is
    // called outside the scope of the LogonSessionListLock, there's a potential
    // race condition when multiple threads call LsaLogonUser for LocalService
    // or NetworkService (since they always use the same logon session).  To
    // avoid this, don't update the parameters in the logon session unless
    // the incoming parameters are different from those already in the session.
    // Do this only for the parameters LsapDbAddLogonNameToCache uses (account
    // name, authority name, and user SID).
    //

    if (LogonSession->AccountName.Buffer != NULL)
    {
        if (RtlCompareUnicodeString(&LogonSession->AccountName,
                                    AccountName,
                                    TRUE) == 0)
        {
            fAccountNameChanged = FALSE;
        }
    }

    if (LogonSession->AuthorityName.Buffer != NULL)
    {
        if (RtlCompareUnicodeString(&LogonSession->AuthorityName,
                                    AuthorityName,
                                    TRUE) == 0)
        {
            fAuthorityNameChanged = FALSE;
        }
    }

    if (LogonSession->UserSid != NULL)
    {
        if (RtlEqualSid(LogonSession->UserSid,
                        *pUserSid))
        {
            fUserSidChanged = FALSE;
        }
    }

    //
    // Assign the new names - they may be null
    //

    if (fAccountNameChanged)
    {
        OldAccountName = LogonSession->AccountName;

        if ( AccountName )
        {
            LogonSession->AccountName = *AccountName;
        }
        else
        {
            LogonSession->AccountName = NullString ;
        }
    }

    if (fAuthorityNameChanged)
    {
        OldAuthorityName = LogonSession->AuthorityName;

        if ( AuthorityName )
        {
            LogonSession->AuthorityName = *AuthorityName;
        }
        else
        {
            LogonSession->AuthorityName = NullString ;
        }
    }

    OldProfilePath = LogonSession->ProfilePath;

    if ( ProfilePath )
    {
        LogonSession->ProfilePath = *ProfilePath;
    }
    else
    {
        LogonSession->ProfilePath = NullString ;
    }

    if (fUserSidChanged)
    {
        OldUserSid = LogonSession->UserSid;
        LogonSession->UserSid = *pUserSid;
    }

    OldLogonType = LogonSession->LogonType;
    LogonSession->LogonType = LogonType;

    OldLogonServer = LogonSession->LogonServer;
    LogonSession->LogonServer = LogonServer;
    LogonServer.Buffer = NULL;

    if ( FALSE == LsapSetSamAccountNameForLogonSession( LogonSession ))
    {
        Status = STATUS_NO_MEMORY;
    }

    if ( !NT_SUCCESS( Status ))
    {
        if ( fAccountNameChanged )
        {
            LogonSession->AccountName = OldAccountName;
            OldAccountName.Buffer = NULL;
        }

        if ( fAuthorityNameChanged )
        {
            LogonSession->AuthorityName = OldAuthorityName;
            OldAuthorityName.Buffer = NULL;
        }

        LogonSession->ProfilePath = OldProfilePath;
        OldProfilePath.Buffer = NULL;

        if ( fUserSidChanged )
        {
            LogonSession->UserSid = OldUserSid;
            OldUserSid = NULL;
        }

        LogonServer = LogonSession->LogonServer;
        LogonSession->LogonServer = OldLogonServer;
        OldLogonServer.Buffer = NULL;

        LogonSession->LogonType = OldLogonType;
    }

    UnlockLogonSessionList(ListIndex);

    if ( NT_SUCCESS( Status ))
    {
        if ( fAccountNameChanged && AccountName )
        {
            AccountName->Buffer = NULL;
            AccountName->Length = 0;
        }

        if ( fAuthorityNameChanged && AuthorityName )
        {
            AuthorityName->Buffer = NULL;
            AuthorityName->Length = 0;
        }

        if ( fUserSidChanged && pUserSid )
        {
            *pUserSid = NULL;
        }

        if ( ProfilePath )
        {
            ProfilePath->Buffer = NULL;
            ProfilePath->Length = 0;
        }
    }

    if ( NT_SUCCESS( Status ) &&
         LogonSession->UserSid &&
         LogonSession->AccountName.Buffer &&
         LogonSession->AuthorityName.Buffer )
    {
        LsapDbAddLogonNameToCache(
            &LogonSession->AccountName,
            &LogonSession->AuthorityName,
            LogonSession->UserSid );
    }

    LsapReleaseLogonSession(LogonSession);

    if( OldAccountName.Buffer )
    {
        LsapFreeLsaHeap( OldAccountName.Buffer );
    }

    if( OldAuthorityName.Buffer )
    {
        LsapFreeLsaHeap( OldAuthorityName.Buffer );
    }

    if( OldProfilePath.Buffer )
    {
        LsapFreeLsaHeap( OldProfilePath.Buffer );
    }

    if( OldUserSid )
    {
        LsapFreeLsaHeap( OldUserSid );
    }

    if( OldLogonServer.Buffer )
    {
        LsapFreePrivateHeap( OldLogonServer.Buffer );
    }

    return(Status);
}


NTSTATUS
LsapLogonSessionDeletedWrkr(
    IN PLSA_COMMAND_MESSAGE CommandMessage,
    OUT PLSA_REPLY_MESSAGE ReplyMessage
    )

/*++

Routine Description:

    This function is called by the reference monitor (via LPC) when the
    reference count on a logon session drops to zero.  This indicates that
    the logon session is no longer needed.  This is technically when the
    user is considered (from a security standpoint) to be logged out.


Arguments:

    CommandMessage - Pointer to structure containing LSA command message
        information consisting of an LPC PORT_MESSAGE structure followed
        by the command number (LsapComponentTestCommand).

        The command-specific portion of this parameter contains the
        LogonId (LUID) of the logon session whose reference count
        has dropped to zero.

    ReplyMessage - Pointer to structure containing LSA reply message
        information consisting of an LPC PORT_MESSAGE structure followed
        by the command ReturnedStatus field in which a status code from the
        command will be returned.

Return Value:

    None.

--*/

{
    NTSTATUS Status;
    LUID LogonId;
    SecHandle Handle ;

    //
    // Check that command is expected type
    //

    ASSERT( CommandMessage->CommandNumber == LsapLogonSessionDeletedCommand );

    //
    // Typecast the command parameter to what we expect.
    //

    LogonId = *((LUID *) CommandMessage->CommandParams);

    LsapConvertLuidToSecHandle( &LogonId, &Handle );

    LogonSessionPackage->DeleteHandle(
                            LogonSessionTable,
                            &Handle,
                            FALSE );

    UNREFERENCED_PARAMETER(ReplyMessage); // Intentionally not referenced

    return( STATUS_SUCCESS );
}


PLSAP_LOGON_SESSION
LsapLocateLogonSession(
    PLUID LogonId
    )
{
    SecHandle Handle ;
    PLSAP_LOGON_SESSION LogonSession ;

    LsapConvertLuidToSecHandle( LogonId, &Handle );

    LogonSession = (PLSAP_LOGON_SESSION) LogonSessionPackage->GetHandleContext(
                                                                LogonSessionTable,
                                                                &Handle );

    return LogonSession ;
}


VOID
LsapReleaseLogonSession(
    PLSAP_LOGON_SESSION LogonSession
    )
{
    SecHandle Handle ;

    LsapConvertLuidToSecHandle( &LogonSession->LogonId, &Handle );

    LogonSessionPackage->ReleaseContext(
                            LogonSessionTable,
                            &Handle );
}


NTSTATUS
LsapDeleteLogonSession (
    IN PLUID LogonId
    )

/*++

Routine Description:

    This function deletes a logon session context record.  It is expected
    that no TOKEN objects were ever created within this logon session.
    This means we must inform the Reference Monitor to clean up its
    information on the logon session.

    If TOKEN objecs were created within this logon session, then deletion
    of those tokens will cause the logon session to be deleted.

    This service acquires the AuLock.


Arguments:

    LogonId - The ID of the logon session to delete.

Return Value:

    STATUS_SUCCESS - The logon session has been successfully deleted.

    STATUS_NO_SUCH_LOGON_SESSION - The specified logon session doesn't
        exist.

    STATUS_BAD_LOGON_SESSION_STATE - The logon session is not in a state
        that allows it to be deleted.  This is typically an indication
        that the logon session has had a token created within it, and it
        may no longer be explicitly deleted.

--*/

{
    PLSAP_LOGON_SESSION LogonSession ;
    SecHandle Handle;
    NTSTATUS Status ;

    Status = LsapCallRm(
                 RmDeleteLogonSession,
                 (PVOID)LogonId,
                 (ULONG)sizeof(LUID),
                 NULL,
                 0
                 );

    if ( !NT_SUCCESS(Status)) {

        DebugLog(( DEB_ERROR, "LSA/RM DeleteLogonSession failed, %x\n", Status ));
    }

    LsapConvertLuidToSecHandle( LogonId, &Handle );

    LogonSessionPackage->DeleteHandle(
                            LogonSessionTable,
                            &Handle,
                            FALSE );

    return STATUS_SUCCESS ;
}


PLSAP_DS_NAME_MAP
LsapGetNameForLocalSystem(
    VOID
    )
{
    InterlockedIncrement( &LocalSystemNameMap->RefCount );

    return LocalSystemNameMap;
}

NTSTATUS
LsapImpersonateNetworkService(
    VOID
    )
{
    NTSTATUS Status;

    HANDLE TokenHandle = NULL;
    LUID NetworkServiceLuid = NETWORKSERVICE_LUID;

    Status = LsapOpenTokenByLogonId(&NetworkServiceLuid, &TokenHandle);

    if (!NT_SUCCESS(Status)) 
    {
        goto Cleanup;
    }

    Status = NtSetInformationThread(
                NtCurrentThread(),
                ThreadImpersonationToken,
                &TokenHandle,
                sizeof(TokenHandle) 
                );

    if (!NT_SUCCESS( Status)) 
    {
        goto Cleanup;
    }

Cleanup:

    if (TokenHandle) 
    {
        NtClose(TokenHandle);
    }

    return Status;
}

NTSTATUS
LsapGetNameForLogonSession(
    PLSAP_LOGON_SESSION LogonSession,
    ULONG NameType,
    PLSAP_DS_NAME_MAP * Map,
    BOOL  LocalOnly
    )
{
    NTSTATUS Status ;
    ULONG   ListIndex;
    PLSAP_DS_NAME_MAP NameMap ;
    LARGE_INTEGER Now ;
    WCHAR   TranslatedNameBuffer[ MAX_PATH ];
    ULONG   TranslatedNameLength ;
    PWSTR   TranslatedName = NULL ;
    UNICODE_STRING TransName ;
    PLSAP_DS_NAME_MAP SamMap ;
    BOOL TranslateStatus;
    BOOL Flush = FALSE ;
    DWORD Options ;
    WCHAR * AuthorityName = NULL;
    WCHAR * SamMapName = NULL;
    BOOLEAN NeedToImpersonate = TRUE;
    BOOL    NeedDnsDomainName = FALSE;
    BOOL    GotComputerName = FALSE;

    *Map = NULL ;

    Options = NameType & SPM_NAME_OPTION_MASK ;
    NameType &= (~SPM_NAME_OPTION_MASK );

    if ( Options & SPM_NAME_OPTION_FLUSH )
    {
        Flush = TRUE ;
    }

    if ( NameType >= LSAP_MAX_DS_NAMES )
    {
        return STATUS_INVALID_PARAMETER ;
    }

    GetSystemTimeAsFileTime( (LPFILETIME) &Now );

    //
    // Check for format/account combinations that have no chance
    // of succeeding (e.g., DS formats for local-only accounts)
    // to avoid hitting the network.  Do this outside of the
    // critical region since the LUID is a read-only field.
    //

    if (NameType == NameUniqueId)
    {
        LUID LocalServiceLuid   = LOCALSERVICE_LUID;
        LUID NetworkServiceLuid = NETWORKSERVICE_LUID;

        if (RtlEqualLuid(&LogonSession->LogonId,
                         &LocalServiceLuid)
             ||
            RtlEqualLuid(&LogonSession->LogonId,
                         &NetworkServiceLuid))
        {
            return STATUS_NO_SUCH_DOMAIN;
        }
    }

    ListIndex = LogonIdToListIndex( LogonSession->LogonId );
    ReadLockLogonSessionList(ListIndex);

    if ( LogonSession->DsNames[ NameType ] )
    {
        NameMap = LogonSession->DsNames[ NameType ];

        if ( ( NameMap->ExpirationTime.QuadPart >= Now.QuadPart ) &&
             ( !Flush ) )
        {
            //
            // Valid entry, bump the ref count and return it
            //

            InterlockedIncrement( &NameMap->RefCount );

            UnlockLogonSessionList(ListIndex);

            *Map = NameMap ;

            return STATUS_SUCCESS ;
        }

        //
        // convert the lock to exclusive.
        //

        ReadToWriteLockLogonSessionList(ListIndex);

        //
        // Entry has expired.  Remove it, crack the name anew
        //

        LsapDerefDsNameMap( NameMap );

        LogonSession->DsNames[ NameType ] = NULL ;
    }

    SamMap = LogonSession->DsNames[ NameSamCompatible ];

    if ( SamMap == NULL )
    {
        LsapSetSamAccountNameForLogonSession( LogonSession );

        SamMap = LogonSession->DsNames[ NameSamCompatible ] ;

        if ( SamMap == NULL )
        {
            UnlockLogonSessionList(ListIndex);
            return STATUS_NO_MEMORY ;
        }
    }

    //
    // Not present, or it had expired.  Crack from the beginning:
    //

    if ( NameType == NameSamCompatible )
    {
        *Map = SamMap ;

        InterlockedIncrement( &SamMap->RefCount );

        UnlockLogonSessionList(ListIndex);

        return STATUS_SUCCESS ;
    }
    else if ( NameType == NameDnsDomain )
    {
        //
        // See if we're dealing with an NT4 domain, in which case we won't
        // have a DNS domain name.  If so, return ERROR_NONE_MAPPED for
        // consistency and a way for the caller to know the DC is NT4.
        //

        if (!LocalOnly)
        {
            DWORD dwError;
            PDOMAIN_CONTROLLER_INFO pDcInfo = NULL;

            TranslatedNameLength = MAX_PATH ;
            TranslatedName = TranslatedNameBuffer ;

            if (!GetComputerNameW( TranslatedName, &TranslatedNameLength ))
            {
                //
                // GetComputerNameW only sets the last Win32 error but we
                // need to return an NTSTATUS code.  Set the last status
                // to STATUS_UNSUCCESSFUL (via RtlNtStatusToDosError) and
                // then reset the last Win32 error.
                //

                dwError = GetLastError();
                SetLastError(RtlNtStatusToDosError(STATUS_UNSUCCESSFUL));
                SetLastError(dwError);

                return NtCurrentTeb()->LastStatusValue;
            }

            RtlInitUnicodeString( &TransName, TranslatedName );

            GotComputerName = TRUE;

            //
            // Don't hit the network for local logons.
            //

            if ( !RtlEqualUnicodeString( &LogonSession->AuthorityName,
                                         &TransName,
                                         TRUE ) )
            {
                if (LogonSession->AuthorityName.MaximumLength <= LogonSession->AuthorityName.Length ||
                    LogonSession->AuthorityName.Buffer[LogonSession->AuthorityName.Length / sizeof(WCHAR)] != L'\0')
                {
                    SafeAllocaAllocate(AuthorityName,
                                       LogonSession->AuthorityName.Length + sizeof(WCHAR));

                    if (AuthorityName == NULL)
                    {
                        UnlockLogonSessionList(ListIndex);
                        return STATUS_INSUFFICIENT_RESOURCES;
                    }

                    RtlCopyMemory(AuthorityName,
                                  LogonSession->AuthorityName.Buffer,
                                  LogonSession->AuthorityName.Length);

                    AuthorityName[LogonSession->AuthorityName.Length / sizeof( WCHAR )] = L'\0';
                }
                else
                {
                    AuthorityName = LogonSession->AuthorityName.Buffer;
                }


                //
                // Note that this perf hit is negligible for the non-NT4 case as the next call
                // to DsGetDcName (in SecpTranslateName) will be satisfied from the cache.  In
                // the NT4 case, we'd otherwise drop into SecpTranslateName and make a failing
                // DsGetDcName call there instead.
                //

                UnlockLogonSessionList(ListIndex);

                dwError = DsGetDcName(NULL,
                                      AuthorityName,
                                      NULL,
                                      NULL,
                                      DS_DIRECTORY_SERVICE_PREFERRED,
                                      &pDcInfo);

                // LOCKLOCK: think about read, then convert to write, re-check.
                WriteLockLogonSessionList(ListIndex);

                //
                // Recheck the name in case it was filled in while we
                // were hitting the network.
                //

                if ( LogonSession->DsNames[ NameType ] )
                {
                    NameMap = LogonSession->DsNames[ NameType ];

                    if ( ( NameMap->ExpirationTime.QuadPart >= Now.QuadPart ) &&
                         ( !Flush ) )
                    {
                        //
                        // Valid entry, bump the ref count and return it
                        //

                        InterlockedIncrement( &NameMap->RefCount );

                        UnlockLogonSessionList(ListIndex);

                        if (dwError == NO_ERROR)
                        {
                            NetApiBufferFree(pDcInfo);
                        }

                        *Map = NameMap ;

                        return STATUS_SUCCESS ;
                    }

                    //
                    // Entry has expired.  Remove it, crack the name anew
                    //

                    LsapDerefDsNameMap( NameMap );

                    LogonSession->DsNames[ NameType ] = NULL ;
                }

                if (dwError != NO_ERROR)
                {
                    UnlockLogonSessionList(ListIndex);

                    //
                    // DsGetDcName doesn't set the last error.  Set it now along
                    // with the last status value (first SetLastError sets the
                    // status value via RtlNtStatusToDosError).
                    //

                    SetLastError(RtlNtStatusToDosError(STATUS_UNSUCCESSFUL));
                    SetLastError(dwError);

                    return NtCurrentTeb()->LastStatusValue;
                }

                if (!(pDcInfo->Flags & DS_DS_FLAG))
                {
                    //
                    // NT4 DC
                    //

                    UnlockLogonSessionList(ListIndex);
                    NetApiBufferFree(pDcInfo);
                    return STATUS_NONE_MAPPED;
                }

                NetApiBufferFree(pDcInfo);
            }
        }

        //
        // Since NameDnsDomain is a GetUserNameEx construct, calling
        // the DS for it will directly will fail.  Ask the DS for the
        // canonical name and on success, extract the DNS name below.
        //

        NeedDnsDomainName = TRUE;

        NameType = NameCanonical;

        //
        // If the canonical name is already there, we don't
        // need to hit the DS below.
        //

        if (LogonSession->DsNames[NameType])
        {
            Status = LsapCreateDnsNameFromCanonicalName(LogonSession, NameType, Map);

            UnlockLogonSessionList(ListIndex);
            return Status;
        }

        //
        // We may have the CanonicalEx name and not Canonical -- try that one too.
        //

        NameType = NameCanonicalEx;

        if (LogonSession->DsNames[NameType])
        {
            Status = LsapCreateDnsNameFromCanonicalName(LogonSession, NameType, Map);

            UnlockLogonSessionList(ListIndex);
            return Status;
        }

        //
        // Otherwise fall through and hit the DS for the canonical name if allowed
        //

        if (LocalOnly)
        {
            UnlockLogonSessionList(ListIndex);
            return STATUS_NONE_MAPPED;
        }
    }

    UnlockLogonSessionList(ListIndex);

    if (LocalOnly)
    {
        //
        // We got this far and the name's not yet mapped.  Since we
        // can't hit the network, fail.
        //

        return STATUS_NONE_MAPPED;
    }

    if (!GotComputerName)
    {
        TranslatedNameLength = MAX_PATH ;
        TranslatedName = TranslatedNameBuffer ;

        if (!GetComputerNameW( TranslatedName, &TranslatedNameLength ))
        {
            //
            // GetComputerNameW only sets the last Win32 error but we
            // need to return an NTSTATUS code.  Set the last status
            // to STATUS_UNSUCCESSFUL (via RtlNtStatusToDosError) and
            // then reset the last Win32 error.
            //

            DWORD dwError = GetLastError();
            SetLastError(RtlNtStatusToDosError(STATUS_UNSUCCESSFUL));
            SetLastError(dwError);

            return NtCurrentTeb()->LastStatusValue;
        }

        RtlInitUnicodeString( &TransName, TranslatedName );
    }

    if ( RtlEqualUnicodeString( &LogonSession->AuthorityName,
                                &TransName,
                                TRUE ) )
    {
        //
        // Local Logons don't get mapped names.
        //

        return STATUS_NONE_MAPPED ;
    }

    //
    // Make sure AuthorityName and SamMapName are NULL-terminated.
    // Create dynamically allocated copies if necessary.
    //

    if (AuthorityName == NULL &&
        (LogonSession->AuthorityName.MaximumLength <= LogonSession->AuthorityName.Length ||
         LogonSession->AuthorityName.Buffer[LogonSession->AuthorityName.Length / sizeof(WCHAR)] != L'\0'))
    {
        SafeAllocaAllocate(AuthorityName,
                           LogonSession->AuthorityName.Length + sizeof(WCHAR));

        if (AuthorityName == NULL)
        {
            return STATUS_INSUFFICIENT_RESOURCES;
        }

        RtlCopyMemory(AuthorityName, LogonSession->AuthorityName.Buffer, LogonSession->AuthorityName.Length);
        AuthorityName[LogonSession->AuthorityName.Length / sizeof( WCHAR )] = L'\0';
    }
    else
    {
        AuthorityName = LogonSession->AuthorityName.Buffer;
    }

    if (SamMap->Name.MaximumLength <= SamMap->Name.Length ||
        SamMap->Name.Buffer[SamMap->Name.Length / sizeof(WCHAR)] != L'\0')
    {
        SafeAllocaAllocate(SamMapName,
                           SamMap->Name.Length + sizeof(WCHAR));

        if (SamMapName == NULL)
        {
            if (AuthorityName != LogonSession->AuthorityName.Buffer)
            {
                SafeAllocaFree(AuthorityName);
            }

            return STATUS_INSUFFICIENT_RESOURCES;
        }

        RtlCopyMemory(SamMapName, SamMap->Name.Buffer, SamMap->Name.Length);
        SamMapName[SamMap->Name.Length / sizeof( WCHAR )] = L'\0';
    }
    else
    {
        SamMapName = SamMap->Name.Buffer;
    }

    //
    // We are going to be hitting the wire; if this is a special
    // known format, then optimize by calling DsCrackName to return
    // the other popular formats.  The cache will be seeded with
    // the results and hence avoid calls in the future.  This is
    // done to improve logon performance.
    //
    if ( LsapIsNameFormatUsedForLogon( NameType ) ) {

        Status = LsapGetFormatsForLogon( LogonSession,
                                         AuthorityName,
                                         SamMapName,
                                         NameType,
                                         Map );

        if ( NT_SUCCESS( Status ) ) {

            // we are done!
            goto Exit;

        } else {

            // Ok -- go the slow way
            Status = STATUS_SUCCESS;
        }
    }

Retry:

    //
    // Translate the name, in the caller's context if possible
    //

    if ( NeedToImpersonate )
    {
        Status = LsapImpersonateClient();

        if ( !NT_SUCCESS(Status) )
        {
            if (Status != STATUS_BAD_IMPERSONATION_LEVEL)
            {
                goto Exit;
            }

            //
            // Failed to impersonate as the client supplied an identify-level
            // token.  Make sure the following code knows not to revert or
            // to retry using machine creds as it's redundant.
            //

            Status = LsapImpersonateNetworkService();

            if ( !NT_SUCCESS(Status) )
            {
                goto Exit;
            }
        }
    }

    //
    // No need to "clear" Status to STATUS_SUCCESS here as it's
    // always set below before returning on all codepaths.
    //

    TranslatedNameLength = MAX_PATH ;

    TranslatedName = TranslatedNameBuffer ;

    TranslateStatus = SecpTranslateName(
            AuthorityName,
            SamMapName,
            NameSamCompatible,
            (EXTENDED_NAME_FORMAT) NameType,
            TranslatedName,
            &TranslatedNameLength );

    if ( !TranslateStatus )
    {
        Status = NtCurrentTeb()->LastStatusValue ;

        if ( Status == STATUS_BUFFER_TOO_SMALL )
        {
            TranslatedName = (PWSTR) LsapAllocatePrivateHeap( TranslatedNameLength * sizeof( WCHAR ) );

            if ( TranslatedName )
            {
                TranslateStatus = SecpTranslateName(
                        AuthorityName,
                        SamMapName,
                        NameSamCompatible,
                        (EXTENDED_NAME_FORMAT) NameType,
                        TranslatedName,
                        &TranslatedNameLength );

            }

        } else if ( NeedToImpersonate &&
                    NtCurrentTeb()->LastErrorValue == ERROR_ACCESS_DENIED ) {

            //
            // Fall back to machine creds and try again
            //

            RevertToSelf();
            NeedToImpersonate = FALSE;
            goto Retry;
        }
    }

    if ( NeedToImpersonate ) {

        RevertToSelf();
    }

    if ( TranslateStatus )
    {
        // LOCKLOCK: think about read, then convert to write, re-check.
        WriteLockLogonSessionList(ListIndex);

        if ( LogonSession->DsNames[ NameType ] )
        {
            //
            // Someone else filled it in while we were out cracking
            // it as well.  Use theirs, discard ours:
            //


            NameMap = LogonSession->DsNames[ NameType ];

            InterlockedIncrement( &NameMap->RefCount );

            UnlockLogonSessionList(ListIndex);

            *Map = NameMap ;

            if ( TranslatedName != TranslatedNameBuffer )
            {
                LsapFreePrivateHeap( TranslatedName );
            }

            Status = STATUS_SUCCESS;

            goto Exit;
        }

        //
        // SecpTranslateName returns length including the terminating NULL,
        // so correct for that here
        //

        TransName.Buffer = TranslatedName ;
        TransName.Length = (USHORT) (( TranslatedNameLength - 1 ) * sizeof(WCHAR));
        TransName.MaximumLength = TransName.Length + sizeof( WCHAR );

        NameMap = LsapCreateDsNameMap(
                        &TransName,
                        NameType );

        if ( NameMap )
        {
            LogonSession->DsNames[ NameType ] = NameMap ;

            InterlockedIncrement( &NameMap->RefCount );

            UnlockLogonSessionList(ListIndex);

            *Map = NameMap ;

            if ( TranslatedName != TranslatedNameBuffer )
            {
                LsapFreePrivateHeap( TranslatedName );
            }

            Status = STATUS_SUCCESS;

            goto Exit;
        }
        else
        {
            UnlockLogonSessionList(ListIndex);
            Status = STATUS_NO_MEMORY ;
        }
    }
    else
    {
        Status = NtCurrentTeb()->LastStatusValue ;
    }

    //
    // If the DS couldn't map the UPN (e.g., the account has a default UPN), we can
    // still potentially cruft up a UPN using <SAM account name>@<DNS domain name>
    //

    if (Status == STATUS_NONE_MAPPED && NameType == NameUserPrincipal)
    {
        ReadLockLogonSessionList(ListIndex);

        PLSAP_DS_NAME_MAP UsernameMap = LogonSession->DsNames[NameSamCompatible];
        PLSAP_DS_NAME_MAP DnsNameMap  = LogonSession->DsNames[NameDnsDomain];

        if (UsernameMap != NULL && DnsNameMap != NULL)
        {
            //
            // Modifying the refcount in maps that point into
            // active logon sessions -- need the write lock.
            //

            ReadToWriteLockLogonSessionList(ListIndex);

            InterlockedIncrement( &UsernameMap->RefCount );
            InterlockedIncrement( &DnsNameMap->RefCount );

            LPWSTR Upn;
            LPWSTR Scan = wcschr(UsernameMap->Name.Buffer, L'\\');
            ULONG  Index;

            if (Scan != NULL)
            {
                Scan++;
            }
            else
            {
                Scan = UsernameMap->Name.Buffer;
            }

            //
            // SAM name is always NULL-terminated
            //

            Index = wcslen(Scan);

            SafeAllocaAllocate(Upn, Index * sizeof(WCHAR) + DnsNameMap->Name.Length + 2 * sizeof(WCHAR));

            if (Upn != NULL)
            {
                UNICODE_STRING  String;

                wcsncpy(Upn, Scan, Index);
                Upn[Index++] = L'@';
                RtlCopyMemory(Upn + Index, DnsNameMap->Name.Buffer, DnsNameMap->Name.Length);
                Upn[Index + DnsNameMap->Name.Length / sizeof(WCHAR)] = L'\0';

                LsapDerefDsNameMap(UsernameMap);
                LsapDerefDsNameMap(DnsNameMap);

                RtlInitUnicodeString(&String, Upn);

                *Map = LsapCreateDsNameMap(&String, NameType);

                Status = (*Map == NULL ? STATUS_NO_MEMORY : STATUS_SUCCESS);

                SafeAllocaFree(Upn);
            }
            else
            {
                LsapDerefDsNameMap(UsernameMap);
                LsapDerefDsNameMap(DnsNameMap);
                Status = STATUS_NO_MEMORY;
            }
        }

        UnlockLogonSessionList(ListIndex);
    }

    if ( TranslatedName != TranslatedNameBuffer )
    {
        LsapFreePrivateHeap( TranslatedName );
    }

Exit:

    if (NeedDnsDomainName && NT_SUCCESS(Status))
    {
        //
        // We successfully retrieved the canonical name but what we really
        // want is the DnsDomainName -- extract it and add it to the session.
        //

        // LOCKLOCK: think about read, then convert to write, re-check.
        WriteLockLogonSessionList(ListIndex);

        //
        // Another thread may have cracked the name before we got here.
        //

        NameMap = LogonSession->DsNames[ NameDnsDomain ];

        if ( NameMap )
        {
            if ( ( NameMap->ExpirationTime.QuadPart >= Now.QuadPart ) &&
                 ( !Flush ) )
            {
                //
                // Valid entry, bump the ref count and return it
                //

                InterlockedIncrement( &NameMap->RefCount );
                *Map = NameMap ;

                NeedDnsDomainName = FALSE ;
                Status = STATUS_SUCCESS;
            }
            else
            {
                //
                // Entry has expired.  Remove it, crack the name anew
                //

                LsapDerefDsNameMap( NameMap );

                LogonSession->DsNames[ NameDnsDomain ] = NULL ;
            }
        }

        if (NeedDnsDomainName)
        {
            Status = LsapCreateDnsNameFromCanonicalName(LogonSession, NameType, Map);

            //
            // Since we just successfully created the canonical name map, its refcount
            // has been bumped up.  Undo that since we're really after the DnsDomainName
            // (whose refcount was bumped up in LsapCreateDnsNameFromCanonicalName).
            //

            // LOCKLOCK: if exlusive lock held, don't use interlocked.
            //LogonSession->DsNames[NameType]->RefCount--;
            InterlockedDecrement( &LogonSession->DsNames[NameType]->RefCount );
        }

        UnlockLogonSessionList(ListIndex);

        NameType = NameDnsDomain;
    }

    if (AuthorityName != LogonSession->AuthorityName.Buffer)
    {
        SafeAllocaFree(AuthorityName);
    }

    if (SamMapName != SamMap->Name.Buffer)
    {
        SafeAllocaFree(SamMapName);
    }

    return Status ;
}


NTSTATUS
WLsaEnumerateLogonSession(
    PULONG Count,
    PLUID * Sessions
    )
{
    PLUID Logons ;
    PVOID LocalCopy = NULL ;
    PLIST_ENTRY Scan ;
    PLSAP_LOGON_SESSION LogonSession ;
    PVOID ClientMemory ;
    ULONG ListIndex;
    NTSTATUS Status ;
    ULONG TotalLogonSessionCount = 0;
    BOOLEAN LogonSessionsLocked = TRUE;

    //
    // lock all the lists for read access, and get a total count.
    //

    for( ListIndex = 0 ; ListIndex < LogonSessionListCount ; ListIndex++ )
    {
        ReadLockLogonSessionList(ListIndex);
        TotalLogonSessionCount += LogonSessionCount[ ListIndex ];
    }

    SafeAllocaAllocate(Logons, TotalLogonSessionCount * sizeof(LUID));

    if ( !Logons )
    {
        Status = STATUS_NO_MEMORY ;
        goto Cleanup;
    }

    *Count = TotalLogonSessionCount ;

    LocalCopy = Logons ;

    for (ListIndex = 0 ; ListIndex < LogonSessionListCount ; ListIndex++ )
    {
        Scan = LogonSessionList[ListIndex].Flink ;

        while ( Scan != &LogonSessionList[ListIndex] )
        {
            LogonSession = CONTAINING_RECORD( Scan, LSAP_LOGON_SESSION, List );

            *Logons++ = LogonSession->LogonId ;

            Scan = Scan->Flink ;
        }

        UnlockLogonSessionList( ListIndex );
    }

    LogonSessionsLocked = FALSE;


    ClientMemory = LsapClientAllocate( *Count * sizeof( LUID ) );

    if ( ClientMemory )
    {
        Status = LsapCopyToClient( LocalCopy,
                                   ClientMemory,
                                   *Count * sizeof( LUID ) );

        *Sessions = (PLUID) ClientMemory ;
    }
    else
    {
        Status = STATUS_NO_MEMORY ;
    }

Cleanup:

    if( LogonSessionsLocked )
    {
        for (ListIndex = 0 ; ListIndex < LogonSessionListCount ; ListIndex++ )
        {
            UnlockLogonSessionList( ListIndex );
        }
    }

    SafeAllocaFree(LocalCopy);

    return Status ;
}


NTSTATUS
LsaIGetNbAndDnsDomainNames(
    IN PUNICODE_STRING DomainName,
    OUT PUNICODE_STRING DnsDomainName,
    OUT PUNICODE_STRING NetbiosDomainName
    )

/*++

Routine Description:

    Get both the Netbios name and DNS name of a domain.  DomainName must correspond to
    the account domain of some user that is currently logged onto the system.

Arguments:

    DomainName - Name of the Netbios or DNS domain to query.

    DnsDomainName - Returns the DnsDomainName of the domain if DomainName is trusted.
        DnsDomainName->Buffer will be zero terminated.
        DnsDomainName->Buffer must be freed using LsaIFreeHeap.

    NetbiosDomainName - Returns the Netbios domain name of the domain if DomainName is trusted.
        NetbiosDomainName->Buffer will be zero terminated.
        NetbiosDomainName->Buffer must be freed using LsaIFreeHeap.

Return Value:

    STATUS_SUCCESS: The routine functioned properly.
        DnsDomainName->Buffer and NetbiosDomainName->Buffer will return null if
        the mapping isn't known.

--*/
{
    PLUID Logons ;
    PVOID LocalCopy ;
    PLIST_ENTRY Scan ;
    PLSAP_LOGON_SESSION LogonSession ;
    PVOID ClientMemory ;
    NTSTATUS Status = STATUS_SUCCESS;
    PUNICODE_STRING LocalDnsDomainName;
    ULONG ListIndex;
    BOOLEAN EntryFound = FALSE;

    //
    // Initialization
    //

    RtlInitUnicodeString( DnsDomainName, NULL );
    RtlInitUnicodeString( NetbiosDomainName, NULL );

    //
    // Loop through the logon session list trying to find a match
    //

    for( ListIndex = 0 ; ListIndex < LogonSessionListCount ; ListIndex++ )
    {
        ReadLockLogonSessionList(ListIndex);
        for ( Scan = LogonSessionList[ListIndex].Flink; Scan != &LogonSessionList[ListIndex]; Scan = Scan->Flink ) {

            LogonSession = CONTAINING_RECORD( Scan, LSAP_LOGON_SESSION, List );

            //
            // Ignore this entry unless both names are known
            //

            if (LogonSession->DsNames[NameDnsDomain] == NULL)
            {
                continue;
            }

            LocalDnsDomainName = &LogonSession->DsNames[NameDnsDomain]->Name;

            if ( LocalDnsDomainName->Length == 0 ||
                 LogonSession->AuthorityName.Length == 0 )
            {
                continue;
            }

            //
            // Compare the passed in name with the Netbios and DNS name on the entry
            //

            if ( (DomainName->Length == LogonSession->AuthorityName.Length &&
                  RtlEqualUnicodeString( DomainName,
                                         &LogonSession->AuthorityName,
                                         TRUE ) ) ||
                 (DomainName->Length == LocalDnsDomainName->Length &&
                  RtlEqualUnicodeString( DomainName,
                                         LocalDnsDomainName,
                                         TRUE ) ) ) {

                //
                // Grab the Dns domain name
                //

                DnsDomainName->Buffer = (LPWSTR) LsapAllocatePrivateHeapNoZero(
                                                LocalDnsDomainName->Length +
                                                sizeof(WCHAR) );

                if ( DnsDomainName->Buffer == NULL ) {
                    Status = STATUS_INSUFFICIENT_RESOURCES;
                    break;
                }

                RtlCopyMemory( DnsDomainName->Buffer,
                               LocalDnsDomainName->Buffer,
                               LocalDnsDomainName->Length );

                DnsDomainName->Buffer[LocalDnsDomainName->Length/sizeof(WCHAR)] = L'\0';
                DnsDomainName->Length = LocalDnsDomainName->Length;
                DnsDomainName->MaximumLength = LocalDnsDomainName->Length + sizeof(WCHAR);

                //
                // Grab the netbios domain name
                //

                NetbiosDomainName->Buffer = (LPWSTR) LsapAllocatePrivateHeapNoZero(
                                                LogonSession->AuthorityName.Length +
                                                sizeof(WCHAR) );

                if ( NetbiosDomainName->Buffer == NULL ) {
                    LsapFreePrivateHeap( DnsDomainName->Buffer );
                    DnsDomainName->Buffer = NULL;

                    Status = STATUS_INSUFFICIENT_RESOURCES;
                    break;
                }

                RtlCopyMemory( NetbiosDomainName->Buffer,
                               LogonSession->AuthorityName.Buffer,
                               LogonSession->AuthorityName.Length );
                NetbiosDomainName->Buffer[LogonSession->AuthorityName.Length/sizeof(WCHAR)] = L'\0';
                NetbiosDomainName->Length = LogonSession->AuthorityName.Length;
                NetbiosDomainName->MaximumLength = LogonSession->AuthorityName.Length + sizeof(WCHAR);

                Status = STATUS_SUCCESS;
                EntryFound = TRUE;
                break;
            }
        }

        UnlockLogonSessionList(ListIndex);

        if( !NT_SUCCESS(Status) || EntryFound )
        {
            break;
        }
    }

    return Status;
}


NTSTATUS
WLsaGetLogonSessionData(
    PLUID LogonId,
    PVOID * LogonData
    )
{
    PLSAP_LOGON_SESSION LogonSession;
    ULONG Size ;
    PVOID ClientBuffer ;
    PUCHAR Offset ;
    PUCHAR LocalOffset ;
    NTSTATUS Status ;
    PSECURITY_LOGON_SESSION_DATA Data = NULL;
    PLSAP_SECURITY_PACKAGE Package ;
    HANDLE Token ;
    BOOL OkayToQuery = FALSE ;
    PLSAP_DS_NAME_MAP DnsMap = NULL;
    PLSAP_DS_NAME_MAP UpnMap = NULL;
    ULONG ListIndex;
    USHORT cbAccount, cbAuthority, cbLogonServer;
    ULONG cbSid;
    LPWSTR lpLocalAccount = NULL, lpLocalAuthority, lpLocalLogonServer;
    PSID lpLocalSid;
    BOOL LogonSessionListLocked = FALSE;

    LogonSession = LsapLocateLogonSession( LogonId );

    if ( !LogonSession )
    {
        return STATUS_NO_SUCH_LOGON_SESSION ;
    }

    Status = LsapImpersonateClient();

    ListIndex = LogonIdToListIndex(LogonSession->LogonId);

    ReadLockLogonSessionList(ListIndex);
    LogonSessionListLocked = TRUE;

    if ( NT_SUCCESS( Status ) )
    {
        if ( LogonSession->UserSid == NULL ||
             !CheckTokenMembership( NULL,
                                    LogonSession->UserSid,
                                    &OkayToQuery ) )
        {
            OkayToQuery = FALSE ;
        }

        if ( !OkayToQuery )
        {
            if ( !CheckTokenMembership( NULL,
                                        LsapAliasAdminsSid,
                                        &OkayToQuery ) )
            {
                OkayToQuery = FALSE ;
            }
        }

        RevertToSelf();
    }

    if ( !OkayToQuery )
    {
        Status = STATUS_ACCESS_DENIED ;
    }

    if ( !NT_SUCCESS( Status ) )
    {
        goto Cleanup;
    }

    Package = SpmpLocatePackage( LogonSession->CreatingPackage );

    if ( !Package )
    {
        Status = STATUS_NO_SUCH_LOGON_SESSION ;
        goto Cleanup;
    }

    //
    // Make local copies of the fields of interest in the
    // logon session so they don't change mid-stream.
    //

    cbAccount     = LogonSession->AccountName.Buffer ? LogonSession->AccountName.Length : 0;
    cbAuthority   = LogonSession->AuthorityName.Buffer ? LogonSession->AuthorityName.Length : 0;
    cbLogonServer = LogonSession->LogonServer.Buffer ? LogonSession->LogonServer.Length : 0;
    cbSid         = LogonSession->UserSid ? RtlLengthSid(LogonSession->UserSid) : 0;

    Size = cbAccount + cbAuthority + cbLogonServer + 3 * sizeof(WCHAR) + cbSid;

    SafeAllocaAllocate(lpLocalAccount, Size);

    if ( !lpLocalAccount )
    {
        Status = STATUS_NO_MEMORY;
        goto Cleanup;
    }

    lpLocalAuthority   = lpLocalAccount + cbAccount / sizeof(WCHAR) + 1;
    lpLocalLogonServer = lpLocalAuthority + cbAuthority / sizeof(WCHAR) + 1;

    RtlZeroMemory(lpLocalAccount,     Size);

    if ( cbAccount )
    {
        RtlCopyMemory(lpLocalAccount,     LogonSession->AccountName.Buffer,   cbAccount);
    }

    if ( cbAuthority )
    {
        RtlCopyMemory(lpLocalAuthority,   LogonSession->AuthorityName.Buffer, cbAuthority);
    }

    if ( cbLogonServer )
    {
        RtlCopyMemory(lpLocalLogonServer, LogonSession->LogonServer.Buffer,   cbLogonServer);
    }

    if (cbSid)
    {
        lpLocalSid = (PSID) (lpLocalLogonServer + cbLogonServer / sizeof(WCHAR) + 1);

        RtlCopyMemory(lpLocalSid, LogonSession->UserSid, cbSid);
    }
    else
    {
        lpLocalSid = NULL;
    }

    UpnMap = LogonSession->DsNames[NameUserPrincipal];

    if (UpnMap != NULL)
    {
        InterlockedIncrement( &UpnMap->RefCount );
    }

    DnsMap = LogonSession->DsNames[NameDnsDomain];

    if (DnsMap != NULL)
    {
        InterlockedIncrement( &DnsMap->RefCount );
    }

    UnlockLogonSessionList(ListIndex);
    LogonSessionListLocked = FALSE;

    Size += sizeof( SECURITY_LOGON_SESSION_DATA ) +
            Package->Name.Length + sizeof( WCHAR ) +
            sizeof(WCHAR) + // DnsMap
            sizeof(WCHAR) ; // UpnMap

    if( DnsMap != NULL )
    {
        Size += DnsMap->Name.Length;
    }

    if( UpnMap != NULL )
    {
        Size += UpnMap->Name.Length;
    }

    SafeAllocaAllocate(Data, Size);

    if ( !Data )
    {
        Status = STATUS_NO_MEMORY ;
        goto Cleanup;
    }

    ClientBuffer = LsapClientAllocate( Size );

    if ( !ClientBuffer )
    {
        Status = STATUS_NO_MEMORY ;
        goto Cleanup;
    }

    Offset = (PUCHAR) ClientBuffer + sizeof( SECURITY_LOGON_SESSION_DATA );
    LocalOffset = (PUCHAR) ( Data + 1 );

    Data->Size = sizeof( SECURITY_LOGON_SESSION_DATA );
    Data->LogonId = LogonSession->LogonId ;
    Data->LogonType = (ULONG) LogonSession->LogonType ;
    Data->Session = LogonSession->Session ;
    Data->LogonTime = LogonSession->LogonTime ;

    //
    // do the UserSid first since it needs to be 4-byte aligned
    //

    if ( lpLocalSid )
    {
        Data->Sid = (PSID) Offset ;

        RtlCopyMemory(LocalOffset,
                      lpLocalSid,
                      cbSid);

        Offset += cbSid;
        LocalOffset += cbSid;
    }
    else
    {
        Data->Sid = (PSID) NULL ;
    }

    Data->UserName.Length = cbAccount ;
    Data->UserName.MaximumLength = Data->UserName.Length + sizeof( WCHAR );
    Data->UserName.Buffer = (PWSTR) Offset ;

    RtlCopyMemory(  LocalOffset,
                    lpLocalAccount,
                    cbAccount );

    LocalOffset += cbAccount ;

    *LocalOffset++ = '\0';
    *LocalOffset++ = '\0';

    Offset += Data->UserName.MaximumLength ;

    Data->LogonDomain.Length = cbAuthority ;
    Data->LogonDomain.MaximumLength = Data->LogonDomain.Length + sizeof( WCHAR );
    Data->LogonDomain.Buffer = (PWSTR) Offset ;

    RtlCopyMemory( LocalOffset,
                   lpLocalAuthority,
                   cbAuthority );

    LocalOffset += cbAuthority ;

    *LocalOffset++ = '\0';
    *LocalOffset++ = '\0';

    Offset += Data->LogonDomain.MaximumLength ;

    Data->AuthenticationPackage.Length = Package->Name.Length ;
    Data->AuthenticationPackage.MaximumLength = Data->AuthenticationPackage.Length + sizeof( WCHAR );
    Data->AuthenticationPackage.Buffer = (PWSTR) Offset ;

    RtlCopyMemory(  LocalOffset,
                    Package->Name.Buffer,
                    Package->Name.Length );

    LocalOffset += Package->Name.Length ;

    *LocalOffset++ = '\0';
    *LocalOffset++ = '\0';

    Offset += Data->AuthenticationPackage.MaximumLength ;

    //
    // do the LogonServer
    //

    Data->LogonServer.Length = cbLogonServer ;
    Data->LogonServer.MaximumLength = Data->LogonServer.Length + sizeof( WCHAR );
    Data->LogonServer.Buffer = (PWSTR) Offset ;

    RtlCopyMemory(  LocalOffset,
                    lpLocalLogonServer,
                    cbLogonServer );

    LocalOffset += cbLogonServer ;

    *LocalOffset++ = '\0';
    *LocalOffset++ = '\0';

    Offset += Data->LogonServer.MaximumLength ;

    //
    // do the DnsDomainName
    //

    if (DnsMap != NULL)
    {
        Data->DnsDomainName.Length = DnsMap->Name.Length;
        Data->DnsDomainName.MaximumLength = Data->DnsDomainName.Length + sizeof( WCHAR );
        Data->DnsDomainName.Buffer = (PWSTR) Offset ;

        RtlCopyMemory(  LocalOffset,
                        DnsMap->Name.Buffer,
                        DnsMap->Name.Length );

        LocalOffset += DnsMap->Name.Length ;

        *LocalOffset++ = '\0';
        *LocalOffset++ = '\0';

        Offset += Data->DnsDomainName.MaximumLength ;
    }
    else
    {
        Data->DnsDomainName.Length = Data->DnsDomainName.MaximumLength = 0;
        Data->DnsDomainName.Buffer = (PWSTR) Offset;

        *LocalOffset++ = '\0';
        *LocalOffset++ = '\0';
    }

    //
    // do the Upn
    //

    if (UpnMap != NULL)
    {
        Data->Upn.Length = UpnMap->Name.Length ;
        Data->Upn.MaximumLength = Data->Upn.Length + sizeof( WCHAR );
        Data->Upn.Buffer = (PWSTR) Offset ;

        RtlCopyMemory(  LocalOffset,
                        UpnMap->Name.Buffer,
                        UpnMap->Name.Length );

        LocalOffset += UpnMap->Name.Length ;

        *LocalOffset++ = '\0';
        *LocalOffset++ = '\0';

        Offset += Data->Upn.MaximumLength ;
    }
    else
    {
        Data->Upn.Length = Data->Upn.MaximumLength = 0;
        Data->Upn.Buffer = (PWSTR) Offset;

        *LocalOffset++ = '\0';
        *LocalOffset++ = '\0';
    }

    Status = LsapCopyToClient( Data,
                               ClientBuffer,
                               Size );

    *LogonData = ClientBuffer ;

Cleanup:

    if (DnsMap != NULL || UpnMap != NULL)
    {
        if ( !LogonSessionListLocked )
        {
            WriteLockLogonSessionList(ListIndex);
            LogonSessionListLocked = TRUE;
        }

        if (DnsMap != NULL)
        {
            LsapDerefDsNameMap(DnsMap);
        }

        if (UpnMap != NULL)
        {
            LsapDerefDsNameMap(UpnMap);
        }
    }

    if ( LogonSessionListLocked )
    {
        UnlockLogonSessionList(ListIndex);
    }

    LsapReleaseLogonSession( LogonSession );

    SafeAllocaFree(Data);
    SafeAllocaFree(lpLocalAccount);

    return Status ;
}


NTSTATUS
LsapGetFormatsForLogon(
    IN PLSAP_LOGON_SESSION LogonSession,
    IN LPWSTR Domain,
    IN LPWSTR Name,
    IN ULONG  DesiredNameType,
    OUT PLSAP_DS_NAME_MAP * Map
    )
{
    NTSTATUS Status = STATUS_SUCCESS;
    LPWSTR   *TranslatedNames = NULL;
    BOOL TranslateStatus;
    PLSAP_DS_NAME_MAP NameMap;
    UNICODE_STRING TransName;
    ULONG i;
    BOOLEAN NeedToImpersonate = TRUE;
    ULONG ListIndex = LogonIdToListIndex(LogonSession->LogonId);

Retry:

    if ( NeedToImpersonate )
    {
        Status = LsapImpersonateClient();

        if ( !NT_SUCCESS(Status) )
        {
            if ( Status != STATUS_BAD_IMPERSONATION_LEVEL )
            {
                goto Exit;
            }

            //
            // Failed to impersonate as the client supplied an identify-level
            // token.  Make sure the following code knows not to revert or
            // to retry using machine creds as it's redundant.
            //

            Status = LsapImpersonateNetworkService();

            if ( !NT_SUCCESS(Status) )
            {
                goto Exit;
            }
        }
    }

    //
    // If the client thread is using an identify or anonymous level token,
    // do the translation in system context.
    //

    TranslateStatus = SecpTranslateNameEx( Domain,
                                           Name,
                                           NameSamCompatible,
                                           (EXTENDED_NAME_FORMAT*) LogonFormats,
                                           sizeof(LogonFormats)/sizeof(LogonFormats[0]),
                                          &TranslatedNames );

    //
    // If we successfully impersonated above, revert now.
    //

    if ( NeedToImpersonate )
    {
        RevertToSelf();
    }

    Status = STATUS_SUCCESS;

    if ( !TranslateStatus ) {

        if ( NeedToImpersonate &&
             NtCurrentTeb()->LastErrorValue == ERROR_ACCESS_DENIED ) {

            //
            // Fall back to machine creds and try again
            //

            NeedToImpersonate = FALSE;
            goto Retry;
        }

        Status = STATUS_UNSUCCESSFUL;

    } else {

        ULONG i;

        // LOCKLOCK: look at read, convertwrite, recheck
        WriteLockLogonSessionList(ListIndex);

        for (i = 0; i < sizeof(LogonFormats)/sizeof(LogonFormats[0]); i++ ) {

            ULONG NameFormat = LogonFormats[i];

            if ( LogonSession->DsNames[ NameFormat ] ) {

                //
                // Someone else filled it in while we were out cracking
                // it as well.  Use theirs, discard ours:
                //
                NameMap = LogonSession->DsNames[ NameFormat ];

            } else {

                //
                // Still no entry -- create one
                //
                TransName.Buffer = TranslatedNames[i] ;
                TransName.Length = (USHORT) (wcslen(TranslatedNames[i]) * sizeof(WCHAR));
                TransName.MaximumLength = TransName.Length + sizeof( WCHAR );

                NameMap = LsapCreateDsNameMap(
                                &TransName,
                                NameFormat );

                if ( NameMap )
                {
                    LogonSession->DsNames[ NameFormat ] = NameMap ;
                }
                else
                {
                    UnlockLogonSessionList(ListIndex);
                    Status = STATUS_NO_MEMORY ;
                    goto Exit;
                }
            }

            if ( NameFormat == DesiredNameType ) {

                InterlockedIncrement( &NameMap->RefCount );

                *Map = NameMap ;
            }
        }

        //
        // Should have found a match
        //

        ASSERT( *Map );

        UnlockLogonSessionList(ListIndex);
    }

Exit:

    if ( TranslatedNames ) {

        for ( i = 0; i < sizeof(LogonFormats)/sizeof(LogonFormats[0]); i++ ) {
            if ( TranslatedNames[i] ) {

                SecpFreeMemory( TranslatedNames[i] );
            }
        }

        SecpFreeMemory( TranslatedNames );
    }

    return Status;
}


NTSTATUS
LsapSetSessionToken(
    IN HANDLE InputTokenHandle,
    IN PLUID LogonId
    )
/*++

Routine Description:

    This routine duplicates the InputTokenHandle and sets that duplicated handle on the
    LogonSession identified by the LogonId.

    The duplicated handle is available for subsequent callers of LsapOpenTokenByLogonId.

Arguments:

    InputTokenHandle - A handle to a token for the logon session

    LogonId - The logon id of the session

Return Values:

    Status of the operation.


--*/
{
    NTSTATUS Status;

    OBJECT_ATTRIBUTES ObjAttrs;
    SECURITY_QUALITY_OF_SERVICE SecurityQofS;

    HANDLE TokenHandle = NULL;
    ULONG TokenIsReferenced;
    ULONG StatsSize ;
    TOKEN_STATISTICS TokenStats ;

    PLSAP_LOGON_SESSION LogonSession = NULL;

    //
    // Get the credential set from the logon session.
    //

    LogonSession = LsapLocateLogonSession( LogonId );

    if ( LogonSession == NULL ) {
        ASSERT( LogonSession != NULL );
        // This isn't fatal.
        Status = STATUS_SUCCESS;
        goto Cleanup;
    }

    //
    // Ensure there isn't already a token for this session.
    //

    if ( LogonSession->TokenHandle != NULL ) {
        // This can happen for "local service" and "network service"
        // This isn't fatal.
        Status = STATUS_SUCCESS;
        goto Cleanup;
    }

    //
    // Duplicate the token
    //

    Status = NtQueryInformationToken(
                   InputTokenHandle,
                   TokenStatistics,
                   &TokenStats,
                   sizeof( TokenStats ),
                   &StatsSize );

    if ( !NT_SUCCESS( Status ) ) {
        // This isn't fatal.
        Status = STATUS_SUCCESS;
        goto Cleanup;
    }

    //
    // if primary token handed in (eg: system process), over-ride to SecurityImpersonation from SecurityAnonymous
    //

    if(TokenStats.TokenType == TokenPrimary)
    {
        TokenStats.ImpersonationLevel = SecurityImpersonation;
    }

    InitializeObjectAttributes( &ObjAttrs, NULL, 0L, NULL, NULL );
    SecurityQofS.Length = sizeof( SECURITY_QUALITY_OF_SERVICE );
    SecurityQofS.ImpersonationLevel = min( SecurityImpersonation, TokenStats.ImpersonationLevel );
    SecurityQofS.ContextTrackingMode = FALSE;     // Snapshot client context
    SecurityQofS.EffectiveOnly = FALSE;
    ObjAttrs.SecurityQualityOfService = &SecurityQofS;

    Status = NtDuplicateToken( InputTokenHandle,
                               TOKEN_ALL_ACCESS,
                               &ObjAttrs,
                               FALSE,
                               TokenImpersonation,
                               &TokenHandle );

    if ( !NT_SUCCESS(Status) ) {
        goto Cleanup;
    }

    //
    // Make this token not reference the logon session.
    //  (Otherwise, the existence of this token reference would prevent the reference monitor
    //  from detecting the last reference to the logon session.)
    //

    TokenIsReferenced = FALSE;

    Status = NtSetInformationToken( TokenHandle,
                                    TokenSessionReference,
                                    &TokenIsReferenced,
                                    sizeof(TokenIsReferenced) );

    if ( !NT_SUCCESS(Status) ) {

        goto Cleanup;
    }

    //
    // once the token is added to the logonsession, it is read-only.
    //

    if( InterlockedCompareExchangePointer(
                        &LogonSession->TokenHandle,
                        TokenHandle,
                        NULL
                        ) == NULL)
    {
        //
        // if the value was NULL initially, then we updated it with the new token
        // set the new token NULL so we don't free it.
        //

        TokenHandle = NULL;
    }

    Status = STATUS_SUCCESS;

Cleanup:

    if ( TokenHandle != NULL ) {
        NtClose( TokenHandle );
    }

    if ( LogonSession != NULL ) {
        LsapReleaseLogonSession( LogonSession );
    }

    return Status;
}


NTSTATUS
LsapOpenTokenByLogonId(
    IN PLUID LogonId,
    OUT HANDLE *RetTokenHandle
    )
/*++

Routine Description:

    This routine opens a token by LogonId.  It is only valid for LogonIds where all of the
    following are true:

    * A logon session has been created via LsapCreateLogonSession, AND
    * A token has been created via LsapCreateToken or by the LSA after an authentication package
    returns successfully from LsaApLogonUser(Ex)(2).

Arguments:

    LogonId - The logon id of the session

    RetTokenHandle - Returns a handle to the token.  The token is an impersonation token,
        is granted TOKEN_ALL_ACCESS, and should be closed via NtClose.


Return Values:

    Status of the operation.

    STATUS_NO_SUCH_LOGON_SESSION - The logon session does not exist.

    STATUS_NO_TOKEN - There is no token for this logon session.


--*/
{
    NTSTATUS Status;

    OBJECT_ATTRIBUTES ObjAttrs;
    SECURITY_QUALITY_OF_SERVICE SecurityQofS;

    HANDLE TokenHandle = NULL;

    PLSAP_LOGON_SESSION LogonSession = NULL;
    PSession    pSession = GetCurrentSession();

    //
    // Get the credential set from the logon session.
    //

    LogonSession = LsapLocateLogonSession( LogonId );

    if ( LogonSession == NULL ) {

        //
        // If this is the anonymous logon id,
        //  create a token.
        //

        if ( RtlEqualLuid( LogonId,
                           &LsapAnonymousLogonId ) ) {

            LSA_TOKEN_INFORMATION_NULL VNull;
            TOKEN_SOURCE NullTokenSource = {"*LAnon*", 0};
            HANDLE ImpersonatedToken = NULL;

            VNull.Groups = NULL;

            VNull.ExpirationTime.HighPart = 0x7FFFFFFF;
            VNull.ExpirationTime.LowPart = 0xFFFFFFFF;

            //
            // insure we aren't impersonating a client when we try to create the token
            // this is relevant for inproc security package consumers.
            // BLACKCOMB: Duplicate a cached anonymous token instead.
            //

            Status = NtOpenThreadToken(
                            NtCurrentThread(),
                            TOKEN_IMPERSONATE | TOKEN_QUERY | TOKEN_QUERY_SOURCE,
                            TRUE,
                            &ImpersonatedToken
                            );

            if (!NT_SUCCESS(Status))
            {
                if (Status != STATUS_NO_TOKEN)
                {
                    goto Cleanup;
                }

                ImpersonatedToken = NULL ;
            }

            Status = LsapCreateNullToken( LogonId,
                                          &NullTokenSource,
                                          &VNull,
                                          RetTokenHandle );

            if ( ImpersonatedToken )
            {
                NtSetInformationThread(
                                NtCurrentThread(),
                                ThreadImpersonationToken,
                                &ImpersonatedToken,
                                sizeof(HANDLE)
                                );
                NtClose(ImpersonatedToken);
            }

            goto Cleanup;
        }

        Status = STATUS_NO_SUCH_LOGON_SESSION;
        goto Cleanup;
    }

    //
    // Ensure there is a token for this session.
    //

    if ( LogonSession->TokenHandle == NULL ) {
        Status = STATUS_NO_TOKEN;
        goto Cleanup;
    }

    //
    // Duplicate the token
    // NOTE: logon session is not locked because the token is a read-only field once set.
    //

    InitializeObjectAttributes( &ObjAttrs, NULL, 0L, NULL, NULL );
    SecurityQofS.Length = sizeof( SECURITY_QUALITY_OF_SERVICE );
    SecurityQofS.ImpersonationLevel = SecurityImpersonation;
    SecurityQofS.ContextTrackingMode = FALSE;     // Snapshot client context
    SecurityQofS.EffectiveOnly = FALSE;
    ObjAttrs.SecurityQualityOfService = &SecurityQofS;

    Status = NtDuplicateToken( LogonSession->TokenHandle,
                               TOKEN_ALL_ACCESS,
                               &ObjAttrs,
                               FALSE,
                               TokenImpersonation,
                               &TokenHandle );

    if ( !NT_SUCCESS(Status) ) {

        goto Cleanup;
    }

    if( pSession )
    {
        //
        // for terminal server, the session can change after the original logon.
        // insure the caller gets an token with the correct SessionId.
        //

        if( pSession->SessionId != LogonSession->Session )
        {
            HANDLE PriorToken = NULL;

            //
            // if there is an impersonation token present, as can be the case in
            // certain in-proc scenarios, save and restore the token around the privileged
            // operation.
            //

            Status = NtOpenThreadToken(
                        NtCurrentThread(),
                        TOKEN_QUERY | TOKEN_IMPERSONATE | TOKEN_READ,
                        TRUE,
                        &PriorToken );

            if ( NT_SUCCESS( Status ) )
            {
                HANDLE NullToken = NULL;

                //
                // revert to self...
                //

                NtSetInformationThread(
                            NtCurrentThread(),
                            ThreadImpersonationToken,
                            &NullToken,
                            sizeof( HANDLE )
                            );
            }

            //
            // privileged operation: update the token sessionId.
            //

            Status = NtSetInformationToken(
                                    TokenHandle,
                                    TokenSessionId,
                                    &pSession->SessionId,
                                    sizeof( ULONG )
                                    );

            ASSERT( NT_SUCCESS(Status) );

            //
            // put the prior token back.
            //

            if ( PriorToken )
            {
                NtSetInformationThread(
                    NtCurrentThread(),
                    ThreadImpersonationToken,
                    &PriorToken,
                    sizeof( HANDLE )
                    );

                NtClose( PriorToken );
            }

            if( !NT_SUCCESS(Status) )
            {
                goto Cleanup;
            }
        }
    }

    *RetTokenHandle = TokenHandle;
    TokenHandle = NULL;

    Status = STATUS_SUCCESS;

Cleanup:

    if ( TokenHandle != NULL ) {
        NtClose( TokenHandle );
    }

    if ( LogonSession != NULL ) {
        LsapReleaseLogonSession( LogonSession );
    }

    return Status;
}

NTSTATUS
LsapDomainRenameHandlerForLogonSessions(
    IN PUNICODE_STRING OldNetbiosName,
    IN PUNICODE_STRING OldDnsName,
    IN PUNICODE_STRING NewNetbiosName,
    IN PUNICODE_STRING NewDnsName
    )
/*++

Routine Description:

    Walks the logon sessions list and renames the logon sessions with the given
    new netbios and DNS domain names

Arguments:

    OldNetbiosName      old netbios name of the domain
    OldDnsName          old DNS name of the domain
    NewNetbiosName      new netbios name of the domain
    NewDnsName          new DNS name of the domain

Returns:

    STATUS_ error code

--*/
{
    ULONG ListIndex;
    NTSTATUS Status = STATUS_SUCCESS;

    ASSERT( OldNetbiosName );
    ASSERT( OldDnsName );
    ASSERT( NewNetbiosName );
    ASSERT( NewDnsName );

    for(ListIndex = 0 ; ListIndex < LogonSessionListCount ; ListIndex++ )
    {
        // LOCKLOCK: look at read, convertwrite on match,
        WriteLockLogonSessionList(ListIndex);

        for ( PLIST_ENTRY Scan = LogonSessionList[ListIndex].Flink;
              Scan != &LogonSessionList[ListIndex];
              Scan = Scan->Flink ) {

            UNICODE_STRING NetbiosName = {0};
            UNICODE_STRING DnsName = {0};
            PLSAP_LOGON_SESSION LogonSession = CONTAINING_RECORD( Scan, LSAP_LOGON_SESSION, List );
            PLSAP_DS_NAME_MAP SamMap = LogonSession->DsNames[ NameSamCompatible ];
            PLSAP_DS_NAME_MAP DnsMap = LogonSession->DsNames[ NameDnsDomain ];

            Status = STATUS_SUCCESS;

            if ( NT_SUCCESS( Status ) &&
                 RtlEqualUnicodeString(
                     OldNetbiosName,
                     &LogonSession->AuthorityName,
                     TRUE )) {

                Status = LsapDuplicateString( // Use LsapAllocateLsaHeap
                             &NetbiosName,
                             NewNetbiosName
                             );
            }

            if ( NT_SUCCESS( Status ) &&
                 DnsMap &&
                 RtlEqualUnicodeString(
                     OldDnsName,
                     &DnsMap->Name,
                     TRUE )) {

                Status = LsapDuplicateString2( // Use LsapAllocatePrivateHeap
                             &DnsName,
                             NewDnsName
                             );
            }

            if ( !NT_SUCCESS( Status )) {

                LsapFreeLsaHeap( NetbiosName.Buffer );
                LsapFreePrivateHeap( DnsName.Buffer );
                break;
            }

            if ( NetbiosName.Buffer ) {

                LsapFreeLsaHeap( LogonSession->AuthorityName.Buffer );
                LogonSession->AuthorityName = NetbiosName;
            }

            if ( DnsMap && DnsName.Buffer )
            {
                LsapDerefDsNameMap(DnsMap);
                LogonSession->DsNames[NameDnsDomain] = LsapCreateDsNameMap(&DnsName, NameDnsDomain);
            }

            if ( SamMap &&
                 SamMap->Name.Length > OldNetbiosName->Length &&
                 0 == _wcsnicmp(
                          SamMap->Name.Buffer,
                          OldNetbiosName->Buffer,
                          OldNetbiosName->Length / sizeof( WCHAR )) &&
                 SamMap->Name.Buffer[ OldNetbiosName->Length / sizeof( WCHAR )] == L'\\' ) {

                LsapDerefDsNameMap( SamMap );

                if ( FALSE == LsapSetSamAccountNameForLogonSession( LogonSession )) {

                    Status = STATUS_INSUFFICIENT_RESOURCES;
                    break;
                }
            }
        }

        UnlockLogonSessionList(ListIndex);
    }

    return Status;
}


NTSTATUS
LsapCreateDnsNameFromCanonicalName(
    IN  PLSAP_LOGON_SESSION LogonSession,
    IN  ULONG               NameType,
    OUT PLSAP_DS_NAME_MAP   * Map
    )
/*++

Routine Description:

    Internal routine used to extract the DnsDomainName given the canonical name

Arguments:

    LogonSession - The logon session in question

    Map - Pointer that receives the allocated/refcounted name map on success

Return Values:

    Status of the operation.

Notes:

    The LogonSessionListLock MUST be held for exclusive access when this routine is called

--*/
{
    PLSAP_DS_NAME_MAP CanonicalNameMap = LogonSession->DsNames[NameType];
    UNICODE_STRING    DnsDomainName;
    LPWSTR            lpSlash;
    USHORT            i;

    ASSERT(CanonicalNameMap != NULL);
    ASSERT(LogonSession->DsNames[NameDnsDomain] == NULL);

    //
    // Find the first forward slash in the canonical name.  No guarantees on
    // NULL-termination in a UNICODE_STRING.
    //

    lpSlash = NULL;

    for (i = 0; i < CanonicalNameMap->Name.Length; i++)
    {
        if (CanonicalNameMap->Name.Buffer[i] == L'/')
        {
            lpSlash = &CanonicalNameMap->Name.Buffer[i];
            break;
        }
    }

    if (lpSlash == NULL)
    {
        //
        // The canonical name is bad -- bail.
        //

        ASSERT(lpSlash != NULL);
        return STATUS_NONE_MAPPED;
    }

    RtlInitUnicodeString(&DnsDomainName, CanonicalNameMap->Name.Buffer);
    DnsDomainName.Length = (USHORT) (lpSlash - CanonicalNameMap->Name.Buffer) * sizeof(WCHAR);

    *Map = LsapCreateDsNameMap(&DnsDomainName, NameDnsDomain);

    if (*Map == NULL)
    {
        return STATUS_NO_MEMORY;
    }

    LogonSession->DsNames[NameDnsDomain] = *Map;
    // LOCKLOCK: check refcount interlocked if not exclusive.
//    (*Map)->RefCount++;
    InterlockedIncrement( &(*Map)->RefCount );

    return STATUS_SUCCESS;
}


NTSTATUS
LsaIAddNameToLogonSession(
    IN  PLUID           LogonId,
    IN  ULONG           NameFormat,
    IN  PUNICODE_STRING Name
    )
/*++

Routine Description:

    Internal routine for the auth packages to call to add names to the cache in the
    logon session

Arguments:

    LogonId - The logon id of the session

    NameFormat - The EXTENDED_NAME_FORMAT for the name in question (from secext.h)

    Name - The name itself

Return Values:

    Status of the operation.

    STATUS_NO_SUCH_LOGON_SESSION - The logon session does not exist.

--*/
{
    PLSAP_LOGON_SESSION  LogonSession;
    PLSAP_DS_NAME_MAP    NameMap;
    ULONG                ListIndex;
    BOOL                 fDeleteMap = FALSE;

    //
    // We trust the auth package to be passing in valid parameters
    // session so assert on all invalid parameter errors.
    //

    if (Name == NULL)
    {
        //
        // Package doesn't have this info -- ignore it
        //

        return STATUS_SUCCESS;
    }

    LogonSession = LsapLocateLogonSession(LogonId);

    if (LogonSession == NULL)
    {
        ASSERT(LogonSession != NULL);
        return STATUS_NO_SUCH_LOGON_SESSION;
    }

    ASSERT(NameFormat < LSAP_MAX_DS_NAMES && NameFormat != NameSamCompatible);

    NameMap = LsapCreateDsNameMap(Name, NameFormat);

    if (NameMap == NULL)
    {
        LsapReleaseLogonSession(LogonSession);
        return STATUS_NO_MEMORY;
    }

    //
    // Update the logon session.
    //

    ListIndex = LogonIdToListIndexPtr( LogonId );

    ReadLockLogonSessionList(ListIndex);

    if (LogonSession->DsNames[NameFormat] == NULL)
    {
        //
        // check again, this time with the write lock held.
        //

        ReadToWriteLockLogonSessionList(ListIndex);

        if( LogonSession->DsNames[NameFormat] == NULL )
        {
            LogonSession->DsNames[NameFormat] = NameMap;
        }
        else
        {
            fDeleteMap = TRUE;
        }
    }
    else
    {
        //
        // Another thread beat us to it -- keep the name in the session
        //

        fDeleteMap = TRUE;
    }

    UnlockLogonSessionList(ListIndex);

    if (fDeleteMap)
    {
        //
        // No need to hold a lock here as NameMap doesn't
        // point into an active logon session.
        //

        LsapDerefDsNameMap(NameMap);
    }

    LsapReleaseLogonSession(LogonSession);
    return STATUS_SUCCESS;
}


NTSTATUS
LsaIGetNameFromLuid(
    IN PLUID                LogonId,
    IN ULONG                NameFormat,
    IN BOOLEAN              LocalOnly,
    IN OUT PUNICODE_STRING  Name

    )
/*++

Routine Description:

    Internal routine for the auth packages to call to get the stored lsa version
    of names by LUID.

Arguments:

    LogonId - The logon id of the session

    NameFormat - The EXTENDED_NAME_FORMAT for the name in question (from secext.h)

    LocalOnly - Stay on box?

    Name - The name itself, freed by caller useing FreePrivateHeap

Return Values:

    Status of the operation.

    STATUS_NO_SUCH_LOGON_SESSION - The logon session does not exist.

--*/
{
    PLSAP_LOGON_SESSION  LogonSession;
    PLSAP_DS_NAME_MAP    NameMap;
    BOOL                 fDeleteMap = FALSE;
    NTSTATUS             Status;

    LogonSession = LsapLocateLogonSession(LogonId);

    if (LogonSession == NULL)
    {
        ASSERT(LogonSession != NULL);
        return STATUS_NO_SUCH_LOGON_SESSION;
    }

    ASSERT(NameFormat < LSAP_MAX_DS_NAMES);


    //
    // Note:  This function is intended for use in kerberos
    // to build information for a logon session created
    // by another package.  As such, we'll only be looking
    // for DNS domain & client name.  We should never have to
    // go off box for this info.
    //

    Status = LsapGetNameForLogonSession(
                LogonSession,
                NameFormat,
                &NameMap,
                LocalOnly
                );

    LsapReleaseLogonSession(LogonSession);

    if (!NT_SUCCESS(Status))
    {
        goto cleanup;
    }

    Name->Length = NameMap->Name.Length;
    Name->MaximumLength = NameMap->Name.MaximumLength;
    Name->Buffer = (PWSTR) LsapAllocatePrivateHeap(Name->MaximumLength);

    if (Name->Buffer == NULL)
    {
        Status = STATUS_NO_MEMORY;
        goto cleanup;
    }

    RtlCopyUnicodeString(
        Name,
        &NameMap->Name
        );

cleanup:

    if (NameMap)
    {
        LsapDerefDsNameMap(NameMap);
    }

    return Status;
}

NTSTATUS
LsaISetLogonGuidInLogonSession(
    IN  PLUID  LogonId,
    IN  LPGUID LogonGuid
    )
/*++

Routine Description:

    Internal routine for the auth packages (currently only kerberos)
    to set the logon GUID in the logon session

Arguments:

    LogonId   - The logon id of the session

    LogonGuid - The logon GUID of the session

Return Values:

    Status of the operation.

    STATUS_NO_SUCH_LOGON_SESSION - The logon session does not exist.

--*/
{
    PLSAP_LOGON_SESSION  LogonSession = NULL;
    NTSTATUS Status = STATUS_SUCCESS;
    ULONG ListIndex;
    GUID ZeroGuid = { 0 };

    //
    // We trust the auth package to be passing in valid parameters
    // session so assert on all invalid parameter errors.
    //

    LogonSession = LsapLocateLogonSession(LogonId);

    if (LogonSession == NULL)
    {
        Status = STATUS_NO_SUCH_LOGON_SESSION;
        goto Cleanup;
    }

    //
    // Update the logon session.
    //

    // take the appropriate lock depending on the input.

    ListIndex = LogonIdToListIndexPtr(LogonId);

    if ( LogonGuid )
    {
        WriteLockLogonSessionList(ListIndex);
        RtlCopyMemory( &LogonSession->LogonGuid, LogonGuid, sizeof(GUID) );
    }
    else
    {
        //
        // it's likely already zero.
        //

        ReadLockLogonSessionList(ListIndex);

        if( memcmp( &LogonSession->LogonGuid, &ZeroGuid, sizeof(ZeroGuid) ) != 0 )
        {
            ReadToWriteLockLogonSessionList(ListIndex);
            RtlCopyMemory( &LogonSession->LogonGuid, &ZeroGuid, sizeof(GUID) );
        }
    }

    UnlockLogonSessionList(ListIndex);


Cleanup:
    if ( LogonSession )
    {
        LsapReleaseLogonSession(LogonSession);
    }

    return Status;
}


NTSTATUS
LsaISetPackageAttrInLogonSession(
    IN  PLUID  LogonId,
    IN  ULONG  PackageAttr
    )
/*++

Routine Description:

    Internal routine for the auth packages (currently only NTLM)
    to set package-specific attributes in the logon session

Arguments:

    LogonId     - The logon id of the session

    PackageAttr - Mask of package-specific flags to set in the logon session

Return Values:

    Status of the operation.

    STATUS_NO_SUCH_LOGON_SESSION - The logon session does not exist.

--*/
{
    PLSAP_LOGON_SESSION LogonSession = NULL;

    //
    // We trust the auth package to be passing in valid parameters
    // session so assert on all invalid parameter errors.
    //

    LogonSession = LsapLocateLogonSession(LogonId);

    if (LogonSession == NULL)
    {
        ASSERT(LogonSession != NULL);
        return STATUS_NO_SUCH_LOGON_SESSION;
    }

    //
    // Update the logon session -- don't lock as this is
    // a write-once field.
    //

// NOTE: this field is effectively read-only once a package has returned
// control from the initial logon path. (eg: once a server can use the token/session)

    LogonSession->PackageSpecificAttr |= PackageAttr;

    LsapReleaseLogonSession(LogonSession);

    return STATUS_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\base\lsa\server\lsapch2.h ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    lsapch2.h

Abstract:

    LSA Subsystem - precompiled includes for C Server Side

Author:

    Mike Swift          (MikeSw)        January 14, 1997

Environment:

Revision History:

--*/

#ifndef _LSAPCH2_
#define _LSAPCH2_

#include "lsaprgma.h"
#include <lsasrvp.h>
#include <ausrvp.h>
#include <spmgr.h>

#ifndef NO_DS_HEADERS
#include <lsads.h>
#endif

#include <winsock2.h>
#include "ws2tcpip.h"

//
// uncomment the following to enable a lot of warnings
// 
// #include <warning.h>
// #pragma warning(3:4100)   // Unreferenced formal parameter
// #pragma warning(3:4701)   // local may be used w/o init
// #pragma warning(3:4702)   // Unreachable code
// #pragma warning(3:4705)   // Statement has no effect
// #pragma warning(3:4706)   // assignment w/i conditional expression
// #pragma warning(3:4709)   // command operator w/o index expression


#endif // _LSAPCH2_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\base\lsa\server\klpcstub.cxx ===
//+-----------------------------------------------------------------------
//
// Microsoft Windows
//
// Copyright (c) Microsoft Corporation 1991 - 1992
//
// File:        KLPCSTUB.CXX
//
// Contents:    LPC Support for the KSEC device driver
//              API Dispatcher
//              (Un)Marshalling code
//
//
// Functions:   GetClientString
//              LpcAcquireCreds
//              LpcInitContext
//              LpcAcceptContext
//
//              DispatchAPI
//
// History:     20 May 92   RichardW    Created
//              11 Mar 94   MikeSw      Renamed from klpc2.c
//
//------------------------------------------------------------------------

#include <lsapch.hxx>
extern "C"
{
#include "klpcstub.h"
#include <efsstruc.h>
#include "efssrv.hxx"
#include "sphelp.h"
}
ULONG LsapPageSize ;
LONG InternalMessageId ;
PLSAP_API_LOG   InternalApiLog ;
//
// Maximum size of a string.  This is the max size of
// a short, less the null terminator
//
#define LSAP_MAX_STRING_LENGTH (0xfffc)

//#define LSAP_CATCH_BAD_VM

static  EfsSessionKeySent = FALSE;

extern  "C" BOOLEAN EfsPersonalVer;

extern  "C" BOOLEAN EfsDisabled;

//#define  ProfilingEfs
#ifdef ProfilingEfs
WCHAR  EfsProfileLogName[32] = {'A', 0};
LONG   LogFileIsBeingCreated = 0;
HANDLE EfsProfileLogHandle = 0;
#endif

#if DBG
char * SessionStatLabels[] = {  "<Disconnect>",
                                "<Connect>",
                                "LsaLookupPackage",
                                "LsaLogonUser",
                                "LsaCallPackage",
                                "LsaDeregisterLogonProcess",
                                "<empty>",
                                "(I) GetBinding",
                                "(I) SetSession",
                                "(I) FindPackage",
                                "EnumeratePackages",
                                "AcquireCredentialHandle",
                                "EstablishCredentials",
                                "FreeCredentialHandle",
                                "InitializeSecurityContext",
                                "AcceptSecurityContext",
                                "ApplyControlToken",
                                "DeleteSecurityContext",
                                "QueryPackage",
                                "GetUserInfo",
                                "GetCredentials",
                                "SaveCredentials",
                                "DeleteCredentials",
                                "QueryCredAttributes",
                                "AddPackage",
                                "DeletePackage",
                                "GenerateKey",
                                "GenerateDirEfs",
                                "DecryptFek",
                                "GenerateSessionKey",
                                "Callback",
                                "QueryContextAttributes",
                                "PolicyChangeNotify",
                                "GetUserName",
                                "AddCredentials",
                                "EnumLogonSessions",
                                "GetLogonSessionData",
                                "SetContextAttribute",
                                "LookupAccountName",
                                "LookupAccountSid",
                                "LookupWellKnownSid",
                                "<empty>" };
#define ApiLabel(x) (((x+2) < sizeof(SessionStatLabels) / sizeof(char *)) ?  \
                        SessionStatLabels[(x+2)] : "[Illegal API Number!]")
#endif



PLSA_DISPATCH_FN DllCallbackHandler ;
//
// Function orders after LsapAuMaxApiNumber must match SPM_API and
// SPM_API_NUMBER defined in ..\h\spmlpc.h
//
PLSA_DISPATCH_FN LpcDispatchTable[ SPMAPI_MaxApiNumber ] =
{
    LpcLsaLookupPackage,
    LpcLsaLogonUser,
    LpcLsaCallPackage,
    LpcLsaDeregisterLogonProcess,
    NULL, // LsapAuMaxApiNumber
    LpcGetBinding,
    LpcSetSession,
    LpcFindPackage,
    LpcEnumPackages,
    LpcAcquireCreds,
    LpcEstablishCreds,
    LpcFreeCredHandle,
    LpcInitContext,
    LpcAcceptContext,
    LpcApplyToken,
    LpcDeleteContext,
    LpcQueryPackage,
    LpcGetUserInfo,
    LpcGetCreds,
    LpcSaveCreds,
    LpcQueryCredAttributes,
    LpcAddPackage,
    LpcDeletePackage,
    LpcEfsGenerateKey,
    LpcEfsGenerateDirEfs,
    LpcEfsDecryptFek,
    LpcEfsGenerateSessionKey,
    LpcCallback,
    LpcQueryContextAttributes,
    LpcLsaPolicyChangeNotify,
    LpcGetUserName,
    LpcAddCredentials,
    LpcEnumLogonSessions,
    LpcGetLogonSessionData,
    LpcSetContextAttributes,
    LpcLookupAccountName,
    LpcLookupAccountSid,
    LpcLookupWellKnownSid
};

NTSTATUS
MapTokenBuffer(
    PSecBufferDesc  pInput,
    BOOLEAN         fDoClientCopy
    );

#define KLPC_FLAG_RESET (~(SPMAPI_FLAG_ERROR_RET |                      \
                            SPMAPI_FLAG_MEMORY | SPMAPI_FLAG_PREPACK |  \
                            SPMAPI_FLAG_EXEC_NOW ) )

//+---------------------------------------------------------------------------
//
//  Function:   AbortLpcContext
//
//  Synopsis:   Aborts a security context if something goes wrong.
//
//  Effects:    Calls a DeleteContext() on the context.
//
//  Arguments:  [phContext] -- Context to abort
//
//  History:    6-29-93   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
void
AbortLpcContext(
    PCtxtHandle phContext
    )
{
    NTSTATUS             scRet;
    PLSA_CALL_INFO      CallInfo ;

    CallInfo = LsapGetCurrentCall();

    CallInfo->Flags |= CALL_FLAG_NO_HANDLE_CHK ;

    DebugLog((DEB_WARN, "[%x] Aborting context %p:%p\n",
                    GetCurrentSession()->dwProcessID, phContext->dwUpper,
                    phContext->dwLower));


    scRet = WLsaDeleteContext(  phContext );

    if (FAILED(scRet))
    {
        DebugLog((DEB_WARN, "[%x] DeleteContext failed (%x) on context %p:%p\n",
                        GetCurrentSession()->dwProcessID, scRet, phContext->dwUpper,
                        phContext->dwLower));

    }

    CallInfo->Flags &= (~(CALL_FLAG_NO_HANDLE_CHK));

}

//+-------------------------------------------------------------------------
//
//  Function:   GetClientString
//
//  Synopsis:   Get a string from client memory
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//--------------------------------------------------------------------------
NTSTATUS
GetClientString(
    PUNICODE_STRING pssSource,
    PUNICODE_STRING pssDest,
    PSPM_LPC_MESSAGE pMessage,
    PUCHAR * Where
    )
{
    NTSTATUS   scRet = S_OK;
    PLSA_CALL_INFO CallInfo = LsapGetCurrentCall();

    *pssDest = *pssSource;


    if ( pssDest->Length > LSAP_MAX_STRING_LENGTH )
    {
        return STATUS_INVALID_PARAMETER ;
    }

    if ( CallInfo->Flags & CALL_FLAG_KERNEL_POOL )
    {
        if ((ULONG_PTR) pssSource->Buffer >= (ULONG_PTR) sizeof( SPM_LPC_MESSAGE ) )
        {
            *pssDest = *pssSource ;
            if ( pssDest->Length < pssDest->MaximumLength )
            {
                pssDest->Buffer[ pssDest->Length / sizeof( WCHAR )] = L'\0';

            }
            return STATUS_SUCCESS ;
        }
    }

    pssDest->Buffer = (LPWSTR) LsapAllocatePrivateHeap(pssDest->Length+sizeof(WCHAR));
    if (pssDest->Buffer)
    {
        pssDest->MaximumLength = pssDest->Length + sizeof(WCHAR);

        if (pssSource->Length != 0)
        {
            if ((ULONG_PTR) pssSource->Buffer >= (ULONG_PTR) sizeof( SPM_LPC_MESSAGE ) )
            {
                scRet = LsapCopyFromClient(  pssSource->Buffer,
                                            pssDest->Buffer,
                                            pssDest->Length);
                if (FAILED(scRet))
                {
                    LsapFreePrivateHeap(pssDest->Buffer);
                    pssDest->Buffer = NULL;
                }
            }
            else
            {
                //
                // Prepacked buffers -- make sure the specified lengths are valid.
                // Note that the second check mixes pssSource and pssDest for the
                // buffer and length.  That's OK as pssDest->Length is the same as
                // pssSource->Length at this point -- pssDest->Length is used to
                // be consistent with the RtlCopyMemory call below.
                //

                if ((pssSource->Length > CBPREPACK) ||
                    ((ULONG_PTR) pssSource->Buffer + pssDest->Length > sizeof(SPM_LPC_MESSAGE)))
                {
                    LsapFreePrivateHeap( pssDest->Buffer );

                    pssDest->Buffer = NULL ;

                    return STATUS_INVALID_PARAMETER ;
                }

                *Where = (PUCHAR) (pMessage) + (ULONG_PTR) pssSource->Buffer ;

                if (*Where == NULL)
                {
                    *Where = pMessage->ApiMessage.bData;
                }

                RtlCopyMemory(
                    pssDest->Buffer,
                    *Where,
                    pssDest->Length);

                *Where += pssDest->Length;

            }
        }

        return(scRet);
    }
    return(SEC_E_INSUFFICIENT_MEMORY);
}


//+-------------------------------------------------------------------------
//
//  Function:   PutClientString
//
//  Synopsis:   Get a string from client memory
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//--------------------------------------------------------------------------
NTSTATUS
PutClientString(
    PUNICODE_STRING pssSource,
    PUNICODE_STRING pssDest
    )
{
    NTSTATUS   scRet;

    pssDest->Length = pssSource->Length;

    //
    // If the destination buffer isn't allocated yet, allocate it.
    //

    if (!pssDest->Buffer)
    {
        pssDest->Buffer = (LPWSTR) LsapClientAllocate(pssDest->Length+sizeof(WCHAR));
        pssDest->MaximumLength = pssDest->Length+sizeof(WCHAR);
    }

    if (pssDest->Buffer)
    {
        scRet = LsapCopyToClient(  pssSource->Buffer,
                                  pssDest->Buffer,
                                  pssDest->Length);
        if (FAILED(scRet))
        {
            LsapClientFree(pssDest->Buffer);
            pssDest->Buffer = NULL;
        }

        return(scRet);
    }
    return(SEC_E_INSUFFICIENT_MEMORY);
}



//+-------------------------------------------------------------------------
//
//  Function:   MapTokenBuffer
//
//  Synopsis:   Maps the security token buffer into local memory
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------
NTSTATUS
MapTokenBuffer(
    PSecBufferDesc  pInput,
    BOOLEAN         fDoClientCopy
    )
{
    ULONG i;
    NTSTATUS scRet = STATUS_SUCCESS;
    PLSA_CALL_INFO CallInfo = LsapGetCurrentCall();

    //
    // Mark all buffers as unmapped in case of failure
    //

    for (i = 0; i < pInput->cBuffers ; i++ )
    {
        pInput->pBuffers[i].BufferType |= SECBUFFER_UNMAPPED;
    }

    for (i = 0; i < pInput->cBuffers ; i++ )
    {

        //
        // Always map the security token - it is assumed that this
        // is always wanted by all packages
        //

        if ((pInput->pBuffers[i].BufferType & ~SECBUFFER_ATTRMASK) == SECBUFFER_TOKEN)
        {
            if (fDoClientCopy)
            {
                scRet = LsapMapClientBuffer( &pInput->pBuffers[i],
                                             &pInput->pBuffers[i] );
            }
            else
            {
                pInput->pBuffers[i].pvBuffer = LsapAllocateLsaHeap(pInput->pBuffers[i].cbBuffer);

                if (!pInput->pBuffers[i].pvBuffer)
                {
                    scRet = SEC_E_INSUFFICIENT_MEMORY;

                    if (i > 0)
                    {
                        do
                        {
                            i--;

                            if ((pInput->pBuffers[i].BufferType & ~SECBUFFER_ATTRMASK)
                                     == SECBUFFER_TOKEN)
                            {
                                LsapFreeLsaHeap(pInput->pBuffers[i].pvBuffer);
                                pInput->pBuffers[i].pvBuffer = NULL;
                                pInput->pBuffers[i].BufferType |= SECBUFFER_UNMAPPED;
                            }
                        }
                        while (i != 0);
                    }
                }
                else
                {
                    pInput->pBuffers[i].BufferType &= ~SECBUFFER_UNMAPPED;
                }
            }
            if (FAILED(scRet))
            {
                return(scRet);
            }
        }
        else
        {
            NOTHING ;
        }
    }

    return(S_OK);
}


//+---------------------------------------------------------------------------
//
//  Function:   AllocateClientBuffers
//
//  Synopsis:   Allocate space in the client process for TOKEN type buffers
//
//  Arguments:  [pOutput]       --
//              [pClientOutput] --
//              [pFlags]        --
//
//  History:    8-14-98   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
NTSTATUS
AllocateClientBuffers(
    PSecBufferDesc pOutput,
    PSecBufferDesc pClientOutput,
    PUSHORT pFlags)
{
    ULONG i;


    DsysAssert(pOutput->cBuffers <= MAX_SECBUFFERS);
    if (pOutput->cBuffers > MAX_SECBUFFERS)
    {
        return(SEC_E_INVALID_TOKEN);
    }

    for (i = 0; i < pOutput->cBuffers ; i++ )
    {
        pClientOutput->pBuffers[i] = pOutput->pBuffers[i];
        if (((pOutput->pBuffers[i].BufferType & ~SECBUFFER_ATTRMASK) == SECBUFFER_TOKEN)
             && (pOutput->pBuffers[i].cbBuffer))
        {
            pClientOutput->pBuffers[i].pvBuffer =
                    LsapClientAllocate(pOutput->pBuffers[i].cbBuffer);

            if (!pClientOutput->pBuffers[i].pvBuffer)
            {
                return( SEC_E_INSUFFICIENT_MEMORY );
            }

            *pFlags |= SPMAPI_FLAG_MEMORY;

        }

    }

    return(S_OK);
}


//+-------------------------------------------------------------------------
//
//  Function:   CopyClientBuffers
//
//  Synopsis:   Copies any mapped buffers over to the client's address
//              space.  The length is also copies for those buffers.
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------
NTSTATUS
CopyClientBuffers(
    PSecBufferDesc pSource,
    PSecBufferDesc pDest)
{
    ULONG i;
    NTSTATUS scRet;

    for (i = 0; i < pSource->cBuffers ; i++ )
    {
        //
        // Only copy it if the buffer exists and is unmapped -
        // otherwise nothing changed or there is nothing and it is
        // a waste of time.
        //


        if (pSource->pBuffers[i].pvBuffer &&
            !(pSource->pBuffers[i].BufferType & SECBUFFER_UNMAPPED))
        {
            DsysAssert(pSource->pBuffers[i].cbBuffer <= pDest->pBuffers[i].cbBuffer);

            scRet = LsapCopyToClient(    pSource->pBuffers[i].pvBuffer,
                                        pDest->pBuffers[i].pvBuffer,
                                        pSource->pBuffers[i].cbBuffer );

            if (FAILED(scRet))
            {
                //
                // Again, we have a real problem when this fails.  We
                // abort the context and return an error.
                //

                return(SEC_E_INSUFFICIENT_MEMORY);



            }

            //
            // Copy the length over also
            //

            pDest->pBuffers[i].cbBuffer = pSource->pBuffers[i].cbBuffer;
            pDest->pBuffers[i].BufferType = pSource->pBuffers[i].BufferType &
                                                (~SECBUFFER_ATTRMASK) ;
        }
    }
    return(S_OK);
}


//+---------------------------------------------------------------------------
//
//  Function:   LsapWriteClientBuffer
//
//  Synopsis:   Allocates and copies a buffer out to the client
//
//  Arguments:  [LsaBuffer]    --
//              [ClientBuffer] --
//
//  History:    4-11-97   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
NTSTATUS
LsapWriteClientBuffer(
    IN PSecBuffer   LsaBuffer,
    OUT PSecBuffer  ClientBuffer
    )
{
    NTSTATUS Status ;
    PVOID Client ;

    Status = LsapAllocateClientBuffer( NULL,
                                        LsaBuffer->cbBuffer,
                                        &Client );

    if ( NT_SUCCESS( Status ) )
    {
        Status = LsapCopyToClientBuffer( NULL,
                                         LsaBuffer->cbBuffer,
                                         Client,
                                         LsaBuffer->pvBuffer );

        if ( NT_SUCCESS( Status ) )
        {
            ClientBuffer->BufferType = LsaBuffer->BufferType ;
            ClientBuffer->cbBuffer = LsaBuffer->cbBuffer ;
            ClientBuffer->pvBuffer = Client ;
        }
        else
        {
            LsapFreeClientBuffer( NULL, Client );
        }
    }

    return Status ;
}


//+---------------------------------------------------------------------------
//
//  Function:   LsapLpcContextCleanup
//
//  Synopsis:   Cleanup context on failures
//
//  Arguments:  [pMessage]  --
//
//  History:    5-10-02   LZhu   Created
//
//  Notes:
//
//-----------------------------------------------------------------------------

VOID
LsapLpcContextCleanup(
    PSPM_LPC_MESSAGE pMessage
    )
{
    PLSA_CALL_INFO CallInfo = LsapGetCurrentCall();

    DsysAssert(CallInfo && L"Must have call info present");

    switch (pMessage->ApiMessage.dwAPI)
    {
    case SPMAPI_InitContext:
        if (pMessage->ApiMessage.Args.SpmArguments.fAPI & SPMAPI_FLAG_HANDLE_CHG)
        {
            SPMInitContextAPI*  pInitContext = LPC_MESSAGE_ARGSP(pMessage, InitContext);

            DebugLog((DEB_ERROR, "[%#x] LsapLpcContextCleanup deleting InitContext handle %p : %p\n",
                CallInfo->Session->dwProcessID, pInitContext->hNewContext.dwUpper, pInitContext->hNewContext.dwLower));

            AbortLpcContext(&pInitContext->hNewContext);
            pMessage->ApiMessage.Args.SpmArguments.fAPI &= ~SPMAPI_FLAG_HANDLE_CHG;
        }
        break;
    case SPMAPI_AcceptContext:
        if (pMessage->ApiMessage.Args.SpmArguments.fAPI & SPMAPI_FLAG_HANDLE_CHG)
        {
            SPMAcceptContextAPI* pAcceptContext = LPC_MESSAGE_ARGSP( pMessage, AcceptContext );

            pAcceptContext = LPC_MESSAGE_ARGSP(pMessage, AcceptContext);

            DebugLog((DEB_ERROR, "[%#x] LsapLpcContextCleanup deleting AcceptContext handle %p : %p\n",
                CallInfo->Session->dwProcessID, pAcceptContext->hNewContext.dwUpper, pAcceptContext->hNewContext.dwLower));

            AbortLpcContext(&pAcceptContext->hNewContext);
            pMessage->ApiMessage.Args.SpmArguments.fAPI &= ~SPMAPI_FLAG_HANDLE_CHG;
        }
        break;
    default:

            //
            // no clean up
            //

        break;
    }
}

//+---------------------------------------------------------------------------
//
//  Function:   LsapChangeHandle
//
//  Synopsis:   Changes a handle, based on the current API, session
//
//  Arguments:  [HandleOp]  --
//              [OldHandle] --
//              [NewHandle] --
//
//  History:    9-20-96   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
BOOL
LsapChangeHandle(
    SECHANDLE_OPS   HandleOp,
    PSecHandle  OldHandle,
    PSecHandle  NewHandle
    )
{
    PLSA_CALL_INFO CallInfo ;
    PSPM_LPC_MESSAGE    pMessage;
    SPMAcquireCredsAPI *pAcquireCreds;
    SPMInitContextAPI * pInitContext;
    SPMAcceptContextAPI *pAcceptContext;
    BOOL ContextHandle ;
    PSession pSession ;
    SecHandle RemoveHandle = { 0 };
    PVOID Key ;


    CallInfo = LsapGetCurrentCall();

    if ( !CallInfo )
    {
        return FALSE ;
    }

    pMessage = CallInfo->Message ;

    pSession = CallInfo->Session ;


    ContextHandle = TRUE ;

    if ( HandleOp == HandleRemoveReplace )
    {
        RemoveHandle = *OldHandle ;
    }

    switch ( pMessage->ApiMessage.dwAPI )
    {
        case SPMAPI_AcquireCreds:
            pAcquireCreds = LPC_MESSAGE_ARGSP( pMessage, AcquireCreds );

            if ( HandleOp == HandleReplace )
            {
                RemoveHandle = pAcquireCreds->hCredential ;
            }

            DebugLog((DEB_TRACE, "[%x] Changing Handle %p : %p to %p : %p\n",
                pSession->dwProcessID,
                pAcquireCreds->hCredential.dwUpper, pAcquireCreds->hCredential.dwLower,
                NewHandle->dwUpper, NewHandle->dwLower ));

            pAcquireCreds->hCredential = *NewHandle ;

            ContextHandle = FALSE ;

            break;

        case SPMAPI_InitContext:
            pInitContext = LPC_MESSAGE_ARGSP( pMessage, InitContext );

            if ( HandleOp == HandleReplace )
            {
                RemoveHandle = pInitContext->hContext ;
            }

            DebugLog((DEB_TRACE, "[%x] Changing Handle %p : %p to %p : %p\n",
                pSession->dwProcessID,
                pInitContext->hContext.dwUpper, pInitContext->hContext.dwLower,
                NewHandle->dwUpper, NewHandle->dwLower ));

            pInitContext->hNewContext = *NewHandle ;

            break;

        case SPMAPI_AcceptContext:
            pAcceptContext = LPC_MESSAGE_ARGSP( pMessage, AcceptContext );

            if ( HandleOp == HandleReplace )
            {
                RemoveHandle = pAcceptContext->hContext ;
            }

            DebugLog((DEB_TRACE, "[%x] Changing Handle %p : %p to %p : %p\n",
                pSession->dwProcessID,
                pAcceptContext->hNewContext.dwUpper, pAcceptContext->hNewContext.dwLower,
                NewHandle->dwUpper, NewHandle->dwLower ));

            pAcceptContext->hNewContext = *NewHandle ;

            break;

        default:

            return( FALSE );
    }

    pMessage->ApiMessage.Args.SpmArguments.fAPI |= SPMAPI_FLAG_HANDLE_CHG ;

    //
    // Clean up the handle references.  The old handle is dereferenced,
    // the new handle is referenced once (to make up for it).
    //

    if ( ContextHandle )
    {
        if ( HandleOp != HandleSet )
        {
            DebugLog(( DEB_TRACE, "[%x] Deleting old context handle %p : %p\n",
                            pSession->dwProcessID,
                            RemoveHandle.dwUpper, RemoveHandle.dwLower ));

            ValidateAndDerefContextHandle( pSession, &RemoveHandle );

            // ValidateContextHandle( pSession, NewHandle, &Key );
        }

    }
    else
    {
        if ( HandleOp != HandleSet )
        {
            DebugLog(( DEB_TRACE, "[%x] Deleting old credential handle %p : %p\n",
                            pSession->dwProcessID,
                            RemoveHandle.dwUpper, RemoveHandle.dwLower ));

            ValidateAndDerefCredHandle( pSession, &RemoveHandle );

            // ValidateCredHandle( pSession, NewHandle, &Key );
        }

    }

    return( TRUE );

}

NTSTATUS
LsapFixupAuthIdentity(
    PKSEC_LSA_MEMORY_HEADER KMap,
    PVOID AuthIdentity
    )
{
    PSEC_WINNT_AUTH_IDENTITY_EX AuthEx ;
    NTSTATUS Status = STATUS_SUCCESS ;
    ULONG_PTR PoolBase = (ULONG_PTR) -1 ;
    USHORT i ;

    AuthEx = (PSEC_WINNT_AUTH_IDENTITY_EX) AuthIdentity ;

    DsysAssert( AuthEx->Version == SEC_WINNT_AUTH_IDENTITY_VERSION );

    for ( i = 0 ; i < KMap->MapCount ; i++ )
    {
        if ( (PUCHAR) KMap + KMap->PoolMap[ i ].Offset == (PUCHAR) AuthIdentity )
        {
            PoolBase = (ULONG_PTR) KMap->PoolMap[ i ].Pool ;
            break;
        }

    }

    if ( AuthEx->User )
    {
        if ( (ULONG_PTR) AuthEx->User > PoolBase)
        {
            AuthEx->User = (PWSTR) ( (ULONG_PTR) AuthEx->User - PoolBase );

        }
        if ( (ULONG_PTR) AuthEx->User < 0x10000 )
        {
            AuthEx->User = (PWSTR) ((ULONG_PTR)AuthEx->User + (PUCHAR) AuthIdentity);

        }
        else
        {
            if ( !LsapIsBlockInKMap( KMap, AuthEx->User ) )
            {
                Status = STATUS_ACCESS_VIOLATION ;
            }
        }

    }
    if ( AuthEx->Domain )
    {
        if ( (ULONG_PTR) AuthEx->Domain > PoolBase)
        {
            AuthEx->Domain = (PWSTR) ( (ULONG_PTR) AuthEx->Domain - PoolBase );

        }
        if ( (ULONG_PTR) AuthEx->Domain < 0x10000 )
        {
            AuthEx->Domain = (PWSTR) ((ULONG_PTR)AuthEx->Domain + (PUCHAR) AuthIdentity);

        }
        else
        {
            if ( !LsapIsBlockInKMap( KMap, AuthEx->Domain ) )
            {
                Status = STATUS_ACCESS_VIOLATION ;
            }
        }

    }
    if ( AuthEx->Password )
    {
        if ( (ULONG_PTR) AuthEx->Password > PoolBase)
        {
            AuthEx->Password = (PWSTR) ( (ULONG_PTR) AuthEx->Password - PoolBase );

        }
        if ( (ULONG_PTR) AuthEx->Password < 0x10000 )
        {
            AuthEx->Password = (PWSTR) ((ULONG_PTR)AuthEx->Password + (PUCHAR) AuthIdentity);

        }
        else
        {
            if ( !LsapIsBlockInKMap( KMap, AuthEx->Password ) )
            {
                Status = STATUS_ACCESS_VIOLATION ;
            }
        }

    }
    if ( AuthEx->PackageList )
    {
        if ( (ULONG_PTR) AuthEx->PackageList > PoolBase)
        {
            AuthEx->PackageList = (PWSTR) ( (ULONG_PTR) AuthEx->PackageList - PoolBase );

        }
        if ( (ULONG_PTR) AuthEx->PackageList < 0x10000 )
        {
            AuthEx->PackageList = (PWSTR) ((ULONG_PTR)AuthEx->PackageList + (PUCHAR) AuthIdentity);

        }
        else
        {
            if ( !LsapIsBlockInKMap( KMap, AuthEx->PackageList ) )
            {
                Status = STATUS_ACCESS_VIOLATION ;
            }
        }

    }

    return Status ;
}

//+-------------------------------------------------------------------------
//
//  Function:   LpcAcquireCreds()
//
//  Synopsis:   Lpc stub for AcquireCredHandle
//
//  Effects:    Calls the WLsaAcquire function
//
//  Arguments:  pApiMessage - Input message
//              pApiMessage   - Output message
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//--------------------------------------------------------------------------
NTSTATUS
LpcAcquireCreds(
    PSPM_LPC_MESSAGE  pApiMessage
    )
{
    UNICODE_STRING  ssPrincipalName;
    UNICODE_STRING  ssPackageName;
    NTSTATUS scApiRet;
    NTSTATUS scRet;
    SPMAcquireCredsAPI * pArgs = &pApiMessage->ApiMessage.Args.SpmArguments.API.AcquireCreds;

    PLSA_CALL_INFO  CallInfo ;
    PUCHAR Where = NULL;

    CallInfo = LsapGetCurrentCall();

    DebugLog((DEB_TRACE, "[%x] LpcAcquireCreds()\n", GetCurrentSession()->dwProcessID));

    ssPrincipalName.Buffer = NULL;
    ssPackageName.Buffer = NULL;

    if (pArgs->ssPrincipal.Buffer )
    {
        scRet = GetClientString(&pArgs->ssPrincipal,
                            &ssPrincipalName,
                            pApiMessage,
                            &Where);
        if (FAILED(scRet))
        {
            DebugLog((DEB_ERROR, "GetClientString failed to get principal name 0x%08x\n", scRet));
            pApiMessage->ApiMessage.scRet = scRet;
            return(scRet);
        }

    } else {
        ssPrincipalName.MaximumLength = 0;
        ssPrincipalName.Length = 0;
        ssPrincipalName.Buffer = NULL;
    }

    scRet = GetClientString(&pArgs->ssSecPackage,
                            &ssPackageName,
                            pApiMessage,
                            &Where);

    if (FAILED(scRet))
    {
        LsapFreePrivateHeap(ssPrincipalName.Buffer);
        DebugLog((DEB_ERROR, "GetClientString failed to get package name 0x%08x\n", scRet));
        pApiMessage->ApiMessage.scRet = scRet;
        return(scRet);
    }

    if ( CallInfo->Flags & CALL_FLAG_KERNEL_POOL )
    {
        scRet = LsapFixupAuthIdentity( CallInfo->KMap, pArgs->pvAuthData );
        if ( !NT_SUCCESS( scRet ) )
        {
            LsapFreePrivateHeap(ssPrincipalName.Buffer);
            LsapFreePrivateHeap(ssPackageName.Buffer);
            DebugLog((DEB_ERROR, "AuthData in KMap not formatted correctly\n" ));

            pApiMessage->ApiMessage.scRet = scRet;
            return(scRet);
        }
    }

    scApiRet = WLsaAcquireCredHandle(   (PSECURITY_STRING) &ssPrincipalName,
                                        (PSECURITY_STRING) &ssPackageName,
                                        pArgs->fCredentialUse,
                                        &pArgs->LogonID,
                                        (PVOID) pArgs->pvAuthData,
                                        (PVOID) pArgs->pvGetKeyFn,
                                        (PVOID) pArgs->ulGetKeyArgument,
                                        &pArgs->hCredential,
                                        &pArgs->tsExpiry);

    //
    // Reset the reply flags:
    //

    pApiMessage->ApiMessage.Args.SpmArguments.fAPI &= KLPC_FLAG_RESET ;

    DebugLog((DEB_TRACE_VERB, "[%x] WLsaAcquire returned %x\n", GetCurrentSession()->dwProcessID, scRet));

    LsapFreePrivateHeap(ssPackageName.Buffer);

    LsapFreePrivateHeap(ssPrincipalName.Buffer);

    pApiMessage->ApiMessage.scRet = scApiRet;

    if (FAILED(pApiMessage->ApiMessage.scRet))
    {
        pApiMessage->ApiMessage.Args.SpmArguments.fAPI |= SPMAPI_FLAG_ERROR_RET;
    }

    return(S_OK);
}


//+---------------------------------------------------------------------------
//
//  Function:   LpcFreeCredHandle
//
//  Synopsis:   Free a credential handle
//
//  Arguments:  [pApiMessage] --
//
//  History:    8-14-98   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
NTSTATUS
LpcFreeCredHandle(
    PSPM_LPC_MESSAGE  pApiMessage
    )
{
    NTSTATUS     hrApiRet;

    DebugLog((DEB_TRACE, "[%x] LpcFreeCreds\n", GetCurrentSession()->dwProcessID));

    hrApiRet = WLsaFreeCredHandle(&pApiMessage->ApiMessage.Args.SpmArguments.API.FreeCredHandle.hCredential);

    pApiMessage->ApiMessage.Args.SpmArguments.fAPI &= KLPC_FLAG_RESET ;

    pApiMessage->ApiMessage.scRet = hrApiRet;

    if (FAILED(hrApiRet))
    {
        pApiMessage->ApiMessage.Args.SpmArguments.fAPI |= SPMAPI_FLAG_ERROR_RET;
    }

    return(S_OK);
}

//+---------------------------------------------------------------------------
//
//  Function:   LsapCaptureBuffers
//
//  Synopsis:   Capture client buffers and counts to local memory, validating
//              as we go.
//
//  Arguments:  [InputBuffers]   --
//              [MappedBuffers]  --
//              [MapTokenBuffer] --
//
//  History:    8-14-98   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
NTSTATUS
LsapCaptureBuffers(
    IN PUCHAR          Base,
    IN PSecBufferDesc  InputBuffers,
    OUT PSecBufferDesc MappedBuffers,
    OUT PVOID *        CapturedBuffers,
    IN BOOLEAN         MapTokenBuffers
    )
{
    NTSTATUS Status = STATUS_SUCCESS ;
    PSecBuffer LocalCopy ;
    PSecBufferDesc Capture ;
    ULONG i ;

    //
    // Initialize them first:
    //

    *CapturedBuffers = NULL ;

    RtlZeroMemory(
        MappedBuffers->pBuffers,
        MappedBuffers->cBuffers * sizeof( SecBuffer ) );

    for (i = 0 ; i < MappedBuffers->cBuffers ; i++ )
    {
        MappedBuffers->pBuffers[ i ].BufferType = SECBUFFER_UNMAPPED ;
    }

    if ( InputBuffers->cBuffers > MappedBuffers->cBuffers )
    {
        return STATUS_INVALID_PARAMETER ;
    }


    //
    // Sizewise, we're safe to copy now:
    //


    if ( (ULONG_PTR) InputBuffers->pBuffers < PORT_MAXIMUM_MESSAGE_LENGTH )
    {
        if ((InputBuffers->cBuffers * sizeof( SecBuffer ) > CBPREPACK) ||
            ((ULONG_PTR) InputBuffers->pBuffers + InputBuffers->cBuffers * sizeof(SecBuffer) >
                 PORT_MAXIMUM_MESSAGE_LENGTH))
        {
            return STATUS_INVALID_PARAMETER ;
        }

        LocalCopy = (PSecBuffer) (Base +
                                (ULONG_PTR) InputBuffers->pBuffers );

        RtlCopyMemory(
            MappedBuffers->pBuffers,
            LocalCopy,
            InputBuffers->cBuffers * sizeof( SecBuffer ) );
    }
    else
    {
        //
        // They were too big to fit.  Copy them directly from the client
        // process:
        //


        Capture = (PSecBufferDesc) LsapAllocatePrivateHeap( sizeof( SecBufferDesc ) +
                                          sizeof( SecBuffer ) * InputBuffers->cBuffers );

        if ( Capture == NULL )
        {
            Status = SEC_E_INSUFFICIENT_MEMORY ;
        }
        else
        {
            Capture->pBuffers = (PSecBuffer) (Capture + 1);
            Capture->cBuffers = InputBuffers->cBuffers ;
            Capture->ulVersion = SECBUFFER_VERSION ;

            Status = LsapCopyFromClient(
                            InputBuffers->pBuffers,
                            MappedBuffers->pBuffers,
                            InputBuffers->cBuffers * sizeof( SecBuffer ) );

            if ( NT_SUCCESS( Status ) )
            {
                RtlCopyMemory(
                    Capture->pBuffers,
                    MappedBuffers->pBuffers,
                    InputBuffers->cBuffers * sizeof( SecBuffer ) );

                *CapturedBuffers = Capture ;
            }
            else
            {
                LsapFreePrivateHeap( Capture );
            }

        }


    }

    if ( !NT_SUCCESS( Status ) )
    {
        for ( i = 0 ; i < MappedBuffers->cBuffers ; i++ )
        {
            MappedBuffers->pBuffers[ i ].BufferType = SECBUFFER_UNMAPPED ;
        }
        return Status ;
    }

    //
    // Touch up the mapped buffers so that the count is correct
    //

    MappedBuffers->cBuffers = InputBuffers->cBuffers ;

    //
    // try to map the security blob one:
    //

    if ( MapTokenBuffers )
    {
        Status = MapTokenBuffer(
                    MappedBuffers,
                    TRUE );
    }
    else
    {
        Status = STATUS_SUCCESS ;
    }


    return Status ;

}


VOID
LsapResetKsecBuffer(
    PKSEC_LSA_MEMORY_HEADER Header
    )
{
    Header->Consumed = Header->Preserve ;
    Header->MapCount = 0 ;
    RtlZeroMemory( Header->PoolMap, sizeof( KSEC_LSA_POOL_MAP ) * KSEC_LSA_MAX_MAPS );

}

//+---------------------------------------------------------------------------
//
//  Function:   LsapCreateKsecBuffer
//
//  Synopsis:   Creates a kmap buffer to return to ksecdd
//
//  Arguments:  [InitialSize] -- Minimum size of the buffer
//
//  History:    2-9-01    RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
PKSEC_LSA_MEMORY_HEADER
LsapCreateKsecBuffer(
    SIZE_T InitialSize
    )
{
    PKSEC_LSA_MEMORY_HEADER Header = NULL ;
    NTSTATUS Status ;
    SIZE_T Size = LSA_MAX_KMAP_SIZE ;


    InitialSize += sizeof( KSEC_LSA_MEMORY_HEADER );

    DsysAssert( InitialSize < Size );

    Status = NtAllocateVirtualMemory(
                    NtCurrentProcess(),
                    (PVOID *) &Header,
                    0,
                    &Size,
                    MEM_RESERVE,
                    PAGE_READWRITE );

    if ( NT_SUCCESS( Status ) )
    {
        Status = NtAllocateVirtualMemory(
                    NtCurrentProcess(),
                    (PVOID *) &Header,
                    0,
                    &InitialSize,
                    MEM_COMMIT,
                    PAGE_READWRITE );

        if ( NT_SUCCESS( Status ) )
        {
            Header->Size = LSA_MAX_KMAP_SIZE ;
            Header->Commit = (ULONG) InitialSize ;
            Header->Preserve = sizeof( KSEC_LSA_MEMORY_HEADER );

            LsapResetKsecBuffer( Header );

        }
        else
        {
            NtFreeVirtualMemory(
                    NtCurrentProcess(),
                    (PVOID *) &Header,
                    0,
                    MEM_RELEASE );

            Header = NULL ;
        }
    }

    return Header ;


}


PVOID
LsapAllocateFromKsecBuffer(
    PKSEC_LSA_MEMORY_HEADER Header,
    ULONG Size
    )
{

    SIZE_T DesiredSize ;
    NTSTATUS Status ;
    PVOID Block ;
    PVOID Page ;


    Size = ROUND_UP_COUNT( Size, ALIGN_LPVOID );

    if ( Header->Consumed + Size > Header->Commit )
    {
        DesiredSize = Header->Commit - Header->Consumed + Size ;

        DesiredSize = ROUND_UP_COUNT( DesiredSize, LsapPageSize );

        Page = (PUCHAR) Header + Header->Commit ;

        Status = NtAllocateVirtualMemory(
                    NtCurrentProcess(),
                    &Page,
                    0,
                    &DesiredSize,
                    MEM_COMMIT,
                    PAGE_READWRITE );

        if ( NT_SUCCESS( Status ) )
        {
            Header->Commit += (ULONG) DesiredSize ;

        }

    }

    if ( Header->Consumed + Size <= Header->Commit )
    {
        Block = (PVOID) ((PUCHAR) Header + Header->Consumed) ;

        Header->Consumed += Size ;

    }
    else
    {

        Block = NULL ;
    }

    return Block ;
}




//+---------------------------------------------------------------------------
//
//  Function:   LsapUncaptureBuffers
//
//  Synopsis:   Return all the buffers to the client process.
//
//  Arguments:  [Base]           -- Base address of message
//              [CapturedBuffers]-- Captured buffer descriptions
//              [InputBuffers]   -- Buffers supplied by the client
//              [MappedBuffers]  -- Mapped buffers
//              [AllocateMemory] -- Allocate memory for
//
//  History:    8-14-98   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
NTSTATUS
LsapUncaptureBuffers(
    IN PUCHAR  Base,
    IN OUT PVOID * CapturedBuffers,
    IN OUT PSecBufferDesc InputBuffers,
    IN OUT PSecBufferDesc MappedBuffers,
    IN BOOL AllocateMemory,
    IN BOOL CopyBack,
    OUT PULONG pFlags
    )
{
    NTSTATUS Status = STATUS_SUCCESS ;
    PSecBuffer Buffers ;
    PSecBufferDesc Capture ;
    ULONG i ;
    PVOID Scratch ;
    PVOID ScratchBuffers[ MAX_SECBUFFERS ];
    PSecBufferDesc Input;
    SecBufferDesc InputFixup ;
    PLSA_CALL_INFO  CallInfo = LsapGetCurrentCall();

    DebugLog(( DEB_TRACE_SPECIAL, "LsapUncaptureBuffers:\n" ));

    RtlZeroMemory( ScratchBuffers, sizeof( ScratchBuffers ) );

    Capture = (PSecBufferDesc) *CapturedBuffers ;

    if ( InputBuffers )
    {


        if ( Capture )
        {
            DebugLog(( DEB_TRACE_SPECIAL, "  using captured buffers\n" ));
            Input = Capture ;
        }
        else
        {
            if ( (ULONG_PTR) InputBuffers->pBuffers < PORT_MAXIMUM_MESSAGE_LENGTH  )
            {
                //
                // Time to fix up:
                //

                InputFixup.pBuffers = (PSecBuffer) (Base + (ULONG_PTR) InputBuffers->pBuffers );
                InputFixup.cBuffers = InputBuffers->cBuffers ;
                InputFixup.ulVersion = SECBUFFER_VERSION ;

                Input = &InputFixup ;
                DebugLog(( DEB_TRACE_SPECIAL, "  using buffers in message\n" ));
            }
            else
            {
                Input = InputBuffers ;
                DebugLog(( DEB_TRACE_SPECIAL, "  using buffers from caller\n" ));
            }

        }

        //
        // First, handle the map back to the client process
        //

        for ( i = 0 ; i < MappedBuffers->cBuffers ; i++ )
        {

            //
            // If this is a read only buffer, or it was not mapped across,
            // skip it.  There is no change that will go back to the client.
            //

            DebugLog(( DEB_TRACE_SPECIAL, " Processing buffer %d, <t=%x [%c%c%c],cb=%x,pv=%p>\n",
                        i,
                        MappedBuffers->pBuffers[ i ].BufferType & ~SECBUFFER_ATTRMASK,
                        (MappedBuffers->pBuffers[ i ].BufferType & SECBUFFER_READONLY ? 'R' : ' '),
                        (MappedBuffers->pBuffers[ i ].BufferType & SECBUFFER_UNMAPPED ? 'U' : ' '),
                        (MappedBuffers->pBuffers[ i ].BufferType & SECBUFFER_KERNEL_MAP ? 'K' : ' '),
                        MappedBuffers->pBuffers[ i ].cbBuffer,
                        MappedBuffers->pBuffers[ i ].pvBuffer ));

            //
            // For readonly or untouched buffers, skip them.
            //

            if ( ( MappedBuffers->pBuffers[ i ].BufferType & SECBUFFER_ATTRMASK ) ==
                    ( SECBUFFER_READONLY | SECBUFFER_UNMAPPED ) )
            {
                DebugLog(( DEB_TRACE_SPECIAL, "  Buffer %d: skipped\n", i ));
                continue;
            }

            //
            // If this is a SSPI security blob (aka a token), decide what
            // needs to be done:
            //
            if ( ( MappedBuffers->pBuffers[ i ].BufferType & (~SECBUFFER_ATTRMASK) )
                      == SECBUFFER_TOKEN )
            {
                if ( ( MappedBuffers->pBuffers[ i ].cbBuffer > 0 ) &&
                     ( CopyBack ) )
                {
                    DebugLog(( DEB_TRACE_SPECIAL, "  Copying back buffer %d\n", i ));

                    if ( CallInfo->Flags & CALL_FLAG_KMAP_USED )
                    {
                        //
                        // KMap case:
                        //

                        Scratch = LsapAllocateFromKsecBuffer(
                                        CallInfo->KMap,
                                        MappedBuffers->pBuffers[ i ].cbBuffer
                                        );

                        if ( !Scratch )
                        {
                            Status = SEC_E_INSUFFICIENT_MEMORY ;
                            break;

                        }

                        *pFlags |= SPMAPI_FLAG_KMAP_MEM ;

                    }
                    else if ( AllocateMemory )
                    {
                        Scratch = LsapClientAllocate(
                                        MappedBuffers->pBuffers[ i ].cbBuffer
                                        );

                        //
                        // Allocation failed, break out of the loop with a failure
                        // status code, and handle the failure there:
                        //

                        if ( !Scratch )
                        {
                            Status = SEC_E_INSUFFICIENT_MEMORY ;
                            break;
                        }

                        *pFlags |= SPMAPI_FLAG_MEMORY;
                    }
                    else
                    {

                        Scratch = Input->pBuffers[ i ].pvBuffer ;
                        if ( Input->pBuffers[ i ].cbBuffer <
                                MappedBuffers->pBuffers[ i ].cbBuffer )
                        {
                            //
                            // Buffer too small.  Break out and return the failure
                            //

                            Status = STATUS_BUFFER_TOO_SMALL ;
                            break;
                        }
                    }

                    //
                    // Copy the buffer back to the client address space
                    //

                    ScratchBuffers[ i ] = Scratch ;

                    if ( CallInfo->Flags & CALL_FLAG_KMAP_USED )
                    {
                        DebugLog(( DEB_TRACE_SPECIAL, "  Copying %x bytes from %p to %p [KMap]\n",
                               MappedBuffers->pBuffers[ i ].cbBuffer,
                               MappedBuffers->pBuffers[ i ].pvBuffer,
                               Scratch ));

                        RtlCopyMemory(
                            Scratch,
                            MappedBuffers->pBuffers[ i ].pvBuffer,
                            MappedBuffers->pBuffers[ i ].cbBuffer );

                        Status = STATUS_SUCCESS ;

                    }
                    else
                    {
                        DebugLog(( DEB_TRACE_SPECIAL, "  Copying %x bytes from %p to %p\n",
                                   MappedBuffers->pBuffers[ i ].cbBuffer,
                                   MappedBuffers->pBuffers[ i ].pvBuffer,
                                   Scratch ));

                        Status = LsapCopyToClient(
                                    MappedBuffers->pBuffers[ i ].pvBuffer,
                                    Scratch,
                                    MappedBuffers->pBuffers[ i ].cbBuffer
                                    );

                    }

                    if ( !NT_SUCCESS( Status ) )
                    {
                        break;
                    }

                }
                else
                {
                    //
                    // For zero length buffers that appear to be mapped, set scratch
                    // equal to the original input value.
                    //

                    DebugLog(( DEB_TRACE_SPECIAL, "  Zero length buffer\n" ));

                    ScratchBuffers[ i ] = Input->pBuffers[ i ].pvBuffer ;
                }
            }
            else
            {
                //
                // This is not a token buffer, it is a EXTRA, or PADDING, or
                // one of those.  Turn off the mapping bit, and copy out
                // the buffer value.
                //
                DebugLog(( DEB_TRACE_SPECIAL, "  Special buffer [%p] passed back\n",
                            Input->pBuffers[ i ].pvBuffer ));

                ScratchBuffers[ i ] = Input->pBuffers[ i ].pvBuffer ;
            }

        }
    }
    else
    {

        DebugLog(( DEB_TRACE_SPECIAL, "InputBuffers is NULL, just walking and freeing\n" ));
    }

    //
    // Now go through and free any allocated memory
    //

    for ( i = 0 ; i < MappedBuffers->cBuffers ; i++ )
    {
        if ( (MappedBuffers->pBuffers[ i ].BufferType & SECBUFFER_UNMAPPED) == 0 )
        {
            //
            // This buffer was mapped in.  Free it.
            //

            if ( !LsapIsBlockInKMap( CallInfo->KMap, MappedBuffers->pBuffers[ i ].pvBuffer ) )
            {
                LsapFreeLsaHeap( MappedBuffers->pBuffers[ i ].pvBuffer );

            }
            else
            {
                DebugLog(( DEB_TRACE_SPECIAL, "Buffer at %p is in KMap\n", MappedBuffers->pBuffers[ i ].pvBuffer ));
            }
        }

        //
        // Turn off our bit
        //

        MappedBuffers->pBuffers[ i ].BufferType &= ~(SECBUFFER_UNMAPPED);

        //
        // If we allocated a new buffer (here or in the client), it's
        // been stored away in the scratch array, and we copy it in
        //


        if ( ScratchBuffers[ i ] )
        {
            MappedBuffers->pBuffers[ i ].pvBuffer = ScratchBuffers[ i ];
        }
    }

    if ( InputBuffers )
    {
        if ( NT_SUCCESS( Status ) )
        {
            //
            // Now, copy back the buffer descriptors.  Note that in the normal (optimal)
            // case, this will fit into the LPC message.  Otherwise, we have to copy

            if ( (ULONG_PTR) InputBuffers->pBuffers < PORT_MAXIMUM_MESSAGE_LENGTH )
            {
                Buffers = (PSecBuffer) (Base + (ULONG_PTR) InputBuffers->pBuffers );

                RtlCopyMemory(
                    Buffers,
                    MappedBuffers->pBuffers,
                    MappedBuffers->cBuffers * sizeof( SecBuffer ) );
            }
            else
            {
                Status = LsapCopyToClient(
                    MappedBuffers->pBuffers,
                    InputBuffers->pBuffers,
                    MappedBuffers->cBuffers * sizeof( SecBuffer ) );
            }

            InputBuffers->cBuffers = MappedBuffers->cBuffers ;
        }

    }


    if ( Capture )
    {
        LsapFreePrivateHeap( Capture );
        *CapturedBuffers = NULL ;
    }

    return Status ;

}

//+---------------------------------------------------------------------------
//
//  Function:   LsapChangeBuffer
//
//  Synopsis:   Switches a buffer around.  If the old one needs to be freed,
//              it is cleaned up.
//
//  Arguments:  [Old] --
//              [New] --
//
//  Returns:
//
//  Notes:
//
//----------------------------------------------------------------------------

NTSTATUS
LsapChangeBuffer(
    PSecBuffer Old,
    PSecBuffer New
    )
{
    if ( ( Old->BufferType & SECBUFFER_KERNEL_MAP ) == 0 )
    {
        if ( ( Old->BufferType & SECBUFFER_UNMAPPED ) == 0 )
        {
            LsapFreeLsaHeap( Old->pvBuffer );
        }

    }

    *Old = *New ;

    return STATUS_SUCCESS ;
}


NTSTATUS
LsapCheckMarshalledTargetInfo(
    IN  PUNICODE_STRING TargetServerName
    )
{
    ULONG CandidateSize;

    NTSTATUS Status;

    //
    // If target info wasn't supplied,
    //  do nothing
    //

    if( (TargetServerName == NULL) ||
        (TargetServerName->Buffer == NULL) ||
        (TargetServerName->Length == 0) )
    {
        return STATUS_SUCCESS;
    }

    //
    // Unmarshal without asking for the unmarshaled data to get the size of the marshaled data
    //

    Status = CredUnmarshalTargetInfo (
                    TargetServerName->Buffer,
                    TargetServerName->Length,
                    NULL,
                    &CandidateSize );

    if( !NT_SUCCESS(Status) )
    {
        if( Status == STATUS_INVALID_PARAMETER )
        {
            Status = STATUS_SUCCESS;
        }
    } else {

        //
        // marshalled information was found.  adjust the Length to
        // represent the non-marshalled content, and MaximumLength to
        // include non-marshalled+marshalled content.  This allows legacy
        // packages to continue to handle the TargetServerName string properly.
        //

        TargetServerName->MaximumLength = TargetServerName->Length;
        TargetServerName->Length -= (USHORT)CandidateSize;
    }

    return Status ;
}



//+-------------------------------------------------------------------------
//
//  Function:   LpcInitContext()
//
//  Synopsis:   LPC Serverside InitializeSecurityContext
//
//  Notes:      OutputBuffers and LocalOutput are the local copy of the
//              output buffers.  The secbuffers in the ApiMessage point
//              to client addresses.
//
//--------------------------------------------------------------------------
NTSTATUS
LpcInitContext(
    PSPM_LPC_MESSAGE  pApiMessage
    )

{
    UNICODE_STRING  ssTarget = {0,0,NULL};
    NTSTATUS         scApiRet;
    NTSTATUS         scRet;
    ULONG           i;
    PSecBufferDesc  pOutput = NULL;
    PSecBufferDesc  pInput = NULL;
    PVOID           CapturedInput = NULL ;
    PVOID           CapturedOutput = NULL  ;
    SecBufferDesc   LocalOutput;
    SecBufferDesc   LocalInput ;
    SPMInitContextAPI  * pArgs = &pApiMessage->ApiMessage.Args.SpmArguments.API.InitContext;
    PUCHAR Where = NULL;
    SecBuffer       ContextData = {0,0,NULL};
    SecBuffer       OutputBuffers[MAX_SECBUFFERS];
    SecBuffer       InputBuffers[MAX_SECBUFFERS];
    BOOLEAN         MappedOutput = FALSE;
    BOOLEAN         FirstCall ;
    DWORD Flags ;
    PLSA_CALL_INFO  CallInfo = LsapGetCurrentCall();

    DebugLog((DEB_TRACE, "[%x] LpcInitContext()\n", GetCurrentSession()->dwProcessID));

    DebugLog((DEB_TRACE_VERB, "  hCredentials = %d:%d\n",
              pArgs->hCredential.dwUpper,
              pArgs->hCredential.dwLower));



    //
    // Copy target string to local space:
    //


    scRet = GetClientString(&pArgs->ssTarget,
                            &ssTarget,
                            pApiMessage,
                            &Where);
    if (FAILED(scRet))
    {
        pApiMessage->ApiMessage.scRet = scRet;
        pApiMessage->ApiMessage.Args.SpmArguments.fAPI |= SPMAPI_FLAG_ERROR_RET;
        DebugLog((DEB_ERROR, "LpcInitContext, no target, error %x\n", scRet));
        return(scRet);
    }

    //
    // check if the caller supplied marshalled target info.
    // this will update the Length and MaximumLength fields
    // if marshalled info was present.
    //

    LsapCheckMarshalledTargetInfo( &ssTarget );

    //
    // Set all the SecBuffer's to be unmapped, but map the Security token
    //

    LocalInput.pBuffers = InputBuffers ;
    LocalInput.ulVersion = SECBUFFER_VERSION ;

    if (pArgs->sbdInput.cBuffers)
    {

        pInput = &pArgs->sbdInput;

        //
        // If there is a buffer, reset the pointer and
        // map it
        //

        LocalInput.cBuffers = MAX_SECBUFFERS ;

        scRet = LsapCaptureBuffers(
                        (PUCHAR) pArgs,
                        pInput,
                        &LocalInput,
                        &CapturedInput,
                        TRUE );

        if ( !NT_SUCCESS( scRet ) )
        {
            pInput = NULL ;
            scApiRet = scRet ;
            goto InitCleanExit ;
        }

    }
    else
    {
        LocalInput.pBuffers = InputBuffers ;
        LocalInput.cBuffers = 0 ;
        LocalInput.ulVersion = SECBUFFER_VERSION ;
    }

    //
    // Copy the output SecBuffer's so that if they get mapped we can
    // still copy back the data
    //

    pOutput = &pArgs->sbdOutput;
    if (pOutput->cBuffers)
    {
        LocalOutput.cBuffers = MAX_SECBUFFERS ;
        LocalOutput.pBuffers = OutputBuffers;
        LocalOutput.ulVersion = SECBUFFER_VERSION ;

        scRet = LsapCaptureBuffers(
                    (PUCHAR) pArgs,
                    pOutput,
                    &LocalOutput,
                    &CapturedOutput,
                    FALSE );


        if ( !NT_SUCCESS( scRet ) )
        {
            scApiRet = scRet ;
            goto Init_FreeStringAndExit ;
        }


        MappedOutput = TRUE;
    }
    else
    {
        LocalOutput.cBuffers = 0 ;
        LocalOutput.pBuffers = OutputBuffers ;
        LocalOutput.ulVersion = SECBUFFER_VERSION ;
    }

    if (pArgs->sbdOutput.cBuffers &&
        !(pArgs->fContextReq & ISC_REQ_ALLOCATE_MEMORY))
    {
        if (FAILED(scRet = MapTokenBuffer(&LocalOutput, FALSE)))
        {
            scApiRet = scRet;
            goto InitCleanExit;
        }
    }

    //
    // Call the worker for relay to the package:
    //

    if ( ( pArgs->hContext.dwUpper == 0 ) &&
         ( pArgs->hContext.dwLower == 0 ) )
    {
        FirstCall = TRUE ;
    }
    else
    {
        FirstCall = FALSE ;
    }

    scApiRet = WLsaInitContext( &pArgs->hCredential,
                                &pArgs->hContext,
                                (PSECURITY_STRING) &ssTarget,
                                pArgs->fContextReq,
                                pArgs->dwReserved1,
                                pArgs->TargetDataRep,
                                &LocalInput,          // &pArgs->sbdInput,
                                pArgs->dwReserved2,
                                &pArgs->hNewContext,
                                &LocalOutput,
                                &pArgs->fContextAttr,
                                &pArgs->tsExpiry,
                                &pArgs->MappedContext,
                                &ContextData );

    // DsysAssert( scApiRet != SEC_E_INVALID_HANDLE );
    if( scApiRet == SEC_E_INVALID_HANDLE ||
        scApiRet == STATUS_INVALID_HANDLE )
    {
        DebugLog((DEB_ERROR, "[%x] LpcInitContext() returning invalid handle\n", GetCurrentSession()->dwProcessID));

        DebugLog((DEB_ERROR, "  hCredentials = %p:%p\n",
              pArgs->hCredential.dwUpper,
              pArgs->hCredential.dwLower));
        DebugLog((DEB_ERROR, "  hContext = %p:%p\n",
              pArgs->hContext.dwUpper,
              pArgs->hContext.dwLower));

        DsysAssert( ShutdownBegun );
    }

    //
    // Reset the reply flags:
    //

    pApiMessage->ApiMessage.Args.SpmArguments.fAPI &= KLPC_FLAG_RESET ;


    //
    // If this is the failure case, don't bother copying everything down.
    //

    if (FAILED(scApiRet))
    {
        pApiMessage->ApiMessage.Args.SpmArguments.fAPI |= SPMAPI_FLAG_ERROR_RET;

        //
        // Unmap any output buffers
        //

        Flags = 0 ;

        scRet = LsapUncaptureBuffers(
                    (PUCHAR) pArgs,
                    &CapturedOutput,
                    &pArgs->sbdOutput,
                    &LocalOutput,
                    FALSE,
                    FALSE,
                    &Flags );


    }
    else
    {
        //
        // Now we have to look at the output and copy all the mapped
        // buffers back.
        //

        Flags = pApiMessage->ApiMessage.Args.SpmArguments.fAPI ;

        //
        // if a KMap is present, use it.
        //

        if ( CallInfo->KMap )
        {
            CallInfo->Flags |= CALL_FLAG_KMAP_USED ;
        }

        scRet = LsapUncaptureBuffers(
                    (PUCHAR) pArgs,
                    &CapturedOutput,
                    &pArgs->sbdOutput,
                    &LocalOutput,
                    (pArgs->fContextReq & ISC_REQ_ALLOCATE_MEMORY) ? TRUE : FALSE,
                    TRUE,
                    &Flags );

        pApiMessage->ApiMessage.Args.SpmArguments.fAPI = (USHORT) Flags ;

        if (NT_SUCCESS(scRet) && (ContextData.cbBuffer != 0))
        {
            pArgs->ContextData = ContextData;
            pArgs->ContextData.pvBuffer = LsapClientAllocate(ContextData.cbBuffer);
            if ( pArgs->ContextData.pvBuffer )
            {
                scRet = LsapCopyToClient(
                            ContextData.pvBuffer,
                            pArgs->ContextData.pvBuffer,
                            ContextData.cbBuffer
                            );
            }
            else
            {
                scRet = SEC_E_INSUFFICIENT_MEMORY ;
            }
        }


        if (FAILED(scRet))
        {
            //
            // Again, we have a real problem when this fails.  We
            // abort the context and return an error.
            //

            if ( FirstCall )
            {
                AbortLpcContext(&pArgs->hNewContext);
            }

            scApiRet = scRet;

            goto InitCleanExit;

        }



    }

InitCleanExit:

    pApiMessage->ApiMessage.scRet = scApiRet;

    //
    // Unmap the input buffers
    //


    scRet = LsapUncaptureBuffers(
                (PUCHAR) pArgs,
                &CapturedInput,
                &pArgs->sbdInput,
                &LocalInput,
                FALSE,
                FALSE,
                NULL );


    if (ContextData.pvBuffer != NULL)
    {
        LsapFreeLsaHeap(ContextData.pvBuffer);
    }

    if (FAILED(scRet) && (pArgs->ContextData.pvBuffer != NULL))
    {
            LsapClientFree(pArgs->ContextData.pvBuffer);
            pArgs->ContextData.pvBuffer;

    }

Init_FreeStringAndExit:


    //
    // Test the string pointer.  If it is within the KMap, do
    // not free it.  If there is no KMap, or it was separately
    // allocated, free it:
    //

    if (  !LsapIsBlockInKMap( CallInfo->KMap, ssTarget.Buffer ) )
    {
        LsapFreePrivateHeap( ssTarget.Buffer );

    }

    return(scRet);
}





//+-------------------------------------------------------------------------
//
//  Function:   LpcAcceptContext()
//
//  Synopsis:
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:      The memory management is kind of weird.  The input buffers
//              are mapped into the SPMgr's memory and can be freed.  Easy.
//              The output buffers are more complex.  The original buffer
//              pointers are kep in the arguments structure, while the
//              local copies are kept in LocalOutput.
//
//--------------------------------------------------------------------------
NTSTATUS
LpcAcceptContext(
    PSPM_LPC_MESSAGE  pApiMessage
    )

{
    NTSTATUS        scRet = S_OK;
    NTSTATUS        scApiRet;
    ULONG           i;
    SecBufferDesc   LocalOutput;
    SecBufferDesc   LocalInput ;
    PSecBufferDesc  pInput = NULL;
    PSecBufferDesc  pOutput = NULL ;
    SPMAcceptContextAPI * pArgs = &pApiMessage->ApiMessage.Args.SpmArguments.API.AcceptContext;
    BOOLEAN MappedOutput = FALSE;
    BOOLEAN FirstCall ;
    BOOL CopyBack = FALSE ;
    DWORD Flags ;
    PVOID CapturedInput = NULL ;
    PVOID CapturedOutput = NULL ;


    SecBuffer OutputBuffers[MAX_SECBUFFERS];
    SecBuffer InputBuffers[MAX_SECBUFFERS];
    SecBuffer ContextData = {0,0,NULL};
    PLSA_CALL_INFO  CallInfo = LsapGetCurrentCall();

    DebugLog((DEB_TRACE, "[%x] LpcAcceptContext\n", GetCurrentSession()->dwProcessID));

    // Copy input token to local space:
    //
    // Set all the SecBuffer's to be unmapped, but map the Security token
    //

    pInput = &pArgs->sbdInput;

    LocalInput.pBuffers = InputBuffers ;
    LocalInput.cBuffers = MAX_SECBUFFERS ;
    LocalInput.ulVersion = SECBUFFER_VERSION ;

    if (pInput->cBuffers)
    {

        scRet = LsapCaptureBuffers(
                    (PUCHAR) pArgs,
                    pInput,
                    &LocalInput,
                    &CapturedInput,
                    TRUE );


        if ( !NT_SUCCESS( scRet ) )
        {
            scApiRet = scRet;
            goto AcceptCleanExit;
        }
    }
    else
    {
        LocalInput.cBuffers = 0 ;
    }

    //
    // Copy the output SecBuffer's so that if they get mapped we can
    // still copy back the data
    //


    LocalOutput.cBuffers = MAX_SECBUFFERS ;
    LocalOutput.pBuffers = OutputBuffers ;
    LocalOutput.ulVersion = SECBUFFER_VERSION ;

    pOutput = &pArgs->sbdOutput ;

    if ( pOutput->cBuffers )
    {
        scRet = LsapCaptureBuffers(
                    (PUCHAR) pArgs,
                    pOutput,
                    &LocalOutput,
                    &CapturedOutput,
                    FALSE );

        if ( !NT_SUCCESS( scRet ) )
        {
            scApiRet = scRet ;

            goto AcceptCleanExit ;
        }

#if DBG
        if ( (pArgs->fContextReq & ASC_REQ_ALLOCATE_MEMORY ) == 0 )
        {
            for ( i = 0 ; i < LocalOutput.cBuffers ; i++ )
            {
                if ( (LocalOutput.pBuffers[ i ].BufferType & (~SECBUFFER_ATTRMASK)) == SECBUFFER_TOKEN )
                {
                    DsysAssert( LocalOutput.pBuffers[ i ].cbBuffer > 0 );

                }

            }

        }
#endif

    }
    else
    {
        LocalOutput.cBuffers = 0 ;
    }


    MappedOutput = TRUE;
    if (LocalOutput.cBuffers &&
        !(pArgs->fContextReq & ASC_REQ_ALLOCATE_MEMORY))
    {


        if (FAILED(scRet = MapTokenBuffer(&LocalOutput,FALSE)))
        {
            scApiRet = scRet;
            goto AcceptCleanExit;
        }
    }
    else
    {
        //
        // Since they asked us to allocate memory, ensure the output
        // buffers are NULL.
        //

        for (i = 0; i < LocalOutput.cBuffers ; i++ )
        {
            LocalOutput.pBuffers[i].pvBuffer = NULL;
        }
    }

    if ( ( pArgs->hContext.dwUpper == 0 ) &&
         ( pArgs->hContext.dwLower == 0 ) )
    {
        FirstCall = TRUE ;
    }
    else
    {
        FirstCall = FALSE ;
    }

    scApiRet = WLsaAcceptContext(   &pArgs->hCredential,
                                    &pArgs->hContext,
                                    &LocalInput,
                                    pArgs->fContextReq,
                                    pArgs->TargetDataRep,
                                    &pArgs->hNewContext,
                                    &LocalOutput,
                                    &pArgs->fContextAttr,
                                    &pArgs->tsExpiry,
                                    &pArgs->MappedContext,
                                    &ContextData );

    //
    // Reset the reply flags:
    //
    pApiMessage->ApiMessage.Args.SpmArguments.fAPI &= KLPC_FLAG_RESET;


    if (FAILED(scApiRet))
    {
        pApiMessage->ApiMessage.Args.SpmArguments.fAPI |= SPMAPI_FLAG_ERROR_RET;

        //
        // Copy the sizes from the output security buffers in case they
        // are used to indicate how much space is required
        //

        if ((pArgs->fContextAttr & ASC_RET_EXTENDED_ERROR) == 0)
        {
            CopyBack = FALSE ;
        }
        else
        {
            CopyBack = TRUE ;
        }
    }
    else
    {
        CopyBack = TRUE ;
    }

    //
    // Turn on this flag on return, so that all allocations will come
    // out of the map.  This is safe because KMap would only be set
    // for the right callers.
    //
    if ( CallInfo->KMap )
    {
        CallInfo->Flags |= CALL_FLAG_KMAP_USED ;
    }

    if (NT_SUCCESS(scRet) && (ContextData.cbBuffer != 0))
    {
        pArgs->ContextData = ContextData;
        pArgs->ContextData.pvBuffer = LsapClientAllocate(ContextData.cbBuffer);
        if (pArgs->ContextData.pvBuffer == NULL)
        {
            scRet = SEC_E_INSUFFICIENT_MEMORY;
        }
        else
        {
            scRet = LsapCopyToClient(
                        ContextData.pvBuffer,
                        pArgs->ContextData.pvBuffer,
                        ContextData.cbBuffer
                        );

            if ( !NT_SUCCESS( scRet ) )
            {
                DebugLog(( DEB_ERROR, "Copy to Client failed, %x.  Client addr %p, size %#x\n",
                          scRet, pArgs->ContextData.pvBuffer, ContextData.cbBuffer ));

            }

        }
    }



    if ( NT_SUCCESS( scRet ) )
    {
        Flags = pApiMessage->ApiMessage.Args.SpmArguments.fAPI ;

#if DBG
        if ( ( scRet == SEC_I_CONTINUE_NEEDED ) &&
             ( LocalInput.pBuffers[0].cbBuffer < 2048 ) )
        {
            ULONG t ;

            for ( t = 0 ; t < LocalOutput.cBuffers ; t++ )
            {
                if ( ( LocalOutput.pBuffers[ t ].BufferType & 0xFFFF ) == SECBUFFER_TOKEN )
                {
                    DsysAssert( LocalOutput.pBuffers[ t ].cbBuffer > 0 );

                }


            }

        }
#endif

        scRet = LsapUncaptureBuffers(
                    (PUCHAR) pArgs,
                    &CapturedOutput,
                    &pArgs->sbdOutput,
                    &LocalOutput,
                    (pArgs->fContextReq & ASC_REQ_ALLOCATE_MEMORY ) ? TRUE : FALSE,
                    CopyBack,
                    &Flags );

        pApiMessage->ApiMessage.Args.SpmArguments.fAPI = (USHORT) Flags ;

    }


    if (FAILED(scRet))
    {

        if ( FirstCall )
        {
            AbortLpcContext(&pArgs->hNewContext);
        }

        if( scRet == SEC_E_INSUFFICIENT_MEMORY )
        {
            DebugLog((DEB_ERROR,"[%x] Accept Failed, low memory handle passed: %p:%p\n",
                GetCurrentSession()->dwProcessID,
                pArgs->hNewContext.dwUpper,
                pArgs->hNewContext.dwLower
                ));
        }

        //
        // Turn off any flags that would cause the client to try and send
        // an invalid blob:
        //

        pArgs->fContextAttr &= ~ ( ASC_RET_EXTENDED_ERROR );

        scApiRet = scRet;

        goto AcceptCleanExit;
    }


AcceptCleanExit:

    pApiMessage->ApiMessage.scRet = scApiRet;

    //
    // This is cool.  Either I allocated the buffer, and I can free it this
    // way, or the package allocated it.  If the package allocated, then the
    // address is in this buffer, and I free it.  So cool.
    //

    scRet = LsapUncaptureBuffers(
                (PUCHAR) pArgs,
                &CapturedInput,
                &pArgs->sbdInput,
                &LocalInput,
                FALSE,
                FALSE,
                NULL );

    if (ContextData.pvBuffer != NULL)
    {
        LsapFreeLsaHeap(ContextData.pvBuffer);
    }

    if (FAILED(scRet) && (pArgs->ContextData.pvBuffer != NULL))
    {
        LsapClientFree(pArgs->ContextData.pvBuffer);
        pArgs->ContextData.pvBuffer = NULL;
    }


    return(scRet);
}




//+-------------------------------------------------------------------------
//
//  Function:   LpcEstablishCreds
//
//  Synopsis:   Lpc stub for WLsaEstablishCreds()
//
//  Notes:      obsolete
//
//--------------------------------------------------------------------------
NTSTATUS
LpcEstablishCreds(
    PSPM_LPC_MESSAGE  pApiMessage
    )
{
    pApiMessage->ApiMessage.scRet = STATUS_NOT_SUPPORTED ;
    pApiMessage->ApiMessage.Args.SpmArguments.fAPI |= SPMAPI_FLAG_ERROR_RET;

    return STATUS_SUCCESS ;
}








//+-------------------------------------------------------------------------
//
//  Function:   LpcDeleteContext
//
//  Synopsis:   Delete context
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//--------------------------------------------------------------------------
NTSTATUS
LpcDeleteContext(
    PSPM_LPC_MESSAGE pApiMessage
    )
{
    NTSTATUS scRet;
    SPMDeleteContextAPI * pArgs = &pApiMessage->ApiMessage.Args.SpmArguments.API.DeleteContext;


    scRet = WLsaDeleteContext(  &pArgs->hContext );

    //
    // Reset the reply flags:
    //

    pApiMessage->ApiMessage.Args.SpmArguments.fAPI &= KLPC_FLAG_RESET ;

    pApiMessage->ApiMessage.scRet = scRet;


    return(S_OK);
}



//+---------------------------------------------------------------------------
//
//  Function:   LpcGetBinding
//
//  Synopsis:   Get the DLL binding info for a package
//
//  Arguments:  [pApiMessage] --
//
//  History:    8-14-98   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
NTSTATUS
LpcGetBinding(
    PSPM_LPC_MESSAGE    pApiMessage
    )
{
    SPMGetBindingAPI * pArgs = &pApiMessage->ApiMessage.Args.SpmArguments.API.GetBinding;
    NTSTATUS scRet;
    ULONG Size;
    PWSTR Base;
    PWSTR Remote;

    pArgs->BindingInfo.PackageName.Buffer = NULL ;
    pArgs->BindingInfo.Comment.Buffer = NULL ;

    scRet = WLsaGetBinding( pArgs->ulPackageId,
                            &pArgs->BindingInfo,
                            &Size,
                            &Base );

    if (SUCCEEDED(scRet))
    {
        //
        // We succeeded so now we have to copy the two strings
        //

        Remote = (PWSTR) LsapClientAllocate( Size );

        if (Remote != NULL)
        {
            LsapCopyToClient( Base, Remote, Size );

            pArgs->BindingInfo.PackageName.Buffer = Remote ;
            pArgs->BindingInfo.Comment.Buffer = Remote +
                                pArgs->BindingInfo.PackageName.MaximumLength / 2;

            pArgs->BindingInfo.ModuleName.Buffer = pArgs->BindingInfo.Comment.Buffer +
                                            pArgs->BindingInfo.Comment.MaximumLength / 2;
        }
        else
        {
            scRet = SEC_E_INSUFFICIENT_MEMORY;
        }

        LsapFreeLsaHeap( Base );

    }
    pApiMessage->ApiMessage.scRet = scRet;

    return(scRet);

}

//+---------------------------------------------------------------------------
//
//  Function:   LpcSetSession
//
//  Synopsis:   Internal function to set session options, including the
//              hook to do direct calls while in-process.
//
//  Arguments:  [pApiMessage] --
//
//  History:    8-14-98   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
NTSTATUS
LpcSetSession(
    PSPM_LPC_MESSAGE    pApiMessage
    )
{
    NTSTATUS scRet;
    SPMSetSessionAPI * Args = &pApiMessage->ApiMessage.Args.SpmArguments.API.SetSession ;

    DebugLog((DEB_TRACE_VERB,"SetSession\n"));

    scRet = LsapSetSessionOptions( Args->Request,
                                   Args->Argument,
                                   &Args->Response );

    pApiMessage->ApiMessage.scRet = STATUS_SUCCESS;

    return(scRet);
}

//+---------------------------------------------------------------------------
//
//  Function:   LpcFindPackage
//
//  Synopsis:   Locates a package by id
//
//  Arguments:  [pApiMessage] --
//
//  History:    8-14-98   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
NTSTATUS
LpcFindPackage(
    PSPM_LPC_MESSAGE    pApiMessage
    )
{
    NTSTATUS scRet;
    SECURITY_STRING ssPackageName;
    SPMFindPackageAPI * pArgs = &pApiMessage->ApiMessage.Args.SpmArguments.API.FindPackage;
    PUCHAR Where = NULL;

    scRet = GetClientString(&pArgs->ssPackageName,&ssPackageName, pApiMessage, &Where);
    if (FAILED(scRet))
    {
        pApiMessage->ApiMessage.scRet = scRet;
        return(scRet);
    }

    DebugLog((DEB_TRACE_VERB,"Find Package called for %wZ\n",&ssPackageName));

    scRet = WLsaFindPackage(&ssPackageName,&pArgs->ulPackageId);

    LsapFreePrivateHeap(ssPackageName.Buffer);

    pApiMessage->ApiMessage.scRet = scRet;
    return(scRet);

}


//+---------------------------------------------------------------------------
//
//  Function:   LpcEnumPackages
//
//  Synopsis:   Enumerate available packages
//
//  Arguments:  [pApiMessage] --
//
//  History:    8-14-98   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
NTSTATUS
LpcEnumPackages(
    PSPM_LPC_MESSAGE    pApiMessage
    )
{
    NTSTATUS scRet;
    SPMEnumPackagesAPI * pArgs = &pApiMessage->ApiMessage.Args.SpmArguments.API.EnumPackages;

    scRet = WLsaEnumeratePackages(&pArgs->cPackages,&pArgs->pPackages);

    pApiMessage->ApiMessage.scRet = scRet;
    return(scRet);

}



//+-------------------------------------------------------------------------
//
//  Function:   LpcApplyToken
//
//  Synopsis:
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------

NTSTATUS
LpcApplyToken(
    PSPM_LPC_MESSAGE pApiMessage
    )
{
    NTSTATUS scRet;
    SPMApplyTokenAPI * pArgs = &pApiMessage->ApiMessage.Args.SpmArguments.API.ApplyToken;
    ULONG i;



    pArgs->sbdInput.pBuffers = pArgs->sbInputBuffer;

    scRet = MapTokenBuffer(&pArgs->sbdInput, TRUE);
    if (FAILED(scRet))
    {
        return(SEC_E_INSUFFICIENT_MEMORY);
    }

    scRet = WLsaApplyControlToken(  &pArgs->hContext,
                                    &pArgs->sbdInput);

    //
    // Reset the reply flags:
    //
    pApiMessage->ApiMessage.Args.SpmArguments.fAPI &= KLPC_FLAG_RESET ;

    pApiMessage->ApiMessage.scRet = scRet;


    for (i = 0; i < pArgs->sbdInput.cBuffers; i++ )
    {
        if (!(pArgs->sbdInput.pBuffers[i].BufferType & SECBUFFER_UNMAPPED))
        {
            LsapFreeLsaHeap(pArgs->sbdInput.pBuffers[i].pvBuffer);
        }
    }


    return(scRet);
}



//+-------------------------------------------------------------------------
//
//  Function:   LpcQueryPackage
//
//  Synopsis:
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------
NTSTATUS
LpcQueryPackage(
    PSPM_LPC_MESSAGE pApiMessage
    )
{
    NTSTATUS scRet;
    SPMQueryPackageAPI * pArgs = &pApiMessage->ApiMessage.Args.SpmArguments.API.QueryPackage;
    SECURITY_STRING ssPackageName;
    BOOLEAN fNameAlloc = FALSE;
    BOOLEAN fCommentAlloc = FALSE;
    LPWSTR pszNameString = NULL;
    LPWSTR pszCommentString = NULL;
    ULONG cbLength;
    PUCHAR Where = NULL;



    scRet = GetClientString(&pArgs->ssPackageName,&ssPackageName, pApiMessage, &Where);
    if (FAILED(scRet))
    {
        pApiMessage->ApiMessage.scRet = scRet;
        return(scRet);
    }

    DebugLog((DEB_TRACE_VERB,"Querying package %wZ\n",&ssPackageName));

    scRet = WLsaQueryPackageInfo(   &ssPackageName,
                                    &pArgs->pPackageInfo);

    //
    // Reset the reply flags:
    //

    pApiMessage->ApiMessage.Args.SpmArguments.fAPI &= KLPC_FLAG_RESET ;

    DebugLog((DEB_TRACE_VERB,"Querying package returned %x\n",scRet));

    LsapFreePrivateHeap(ssPackageName.Buffer);
    pApiMessage->ApiMessage.scRet = scRet;

    return(scRet);
}




//+-------------------------------------------------------------------------
//
//  Function:   LpcGetUserInfo
//
//  Synopsis:
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------
NTSTATUS
LpcGetUserInfo(
    PSPM_LPC_MESSAGE    pApiMessage
    )
{
    NTSTATUS scRet;
    static LUID lFake = {0,0};
    SPMGetUserInfoAPI * pArgs = &pApiMessage->ApiMessage.Args.SpmArguments.API.GetUserInfo;
    PLUID pLogonId;

    if ((pArgs->LogonId.LowPart == 0) &&
        (pArgs->LogonId.HighPart == 0))
    {
        pLogonId = NULL;
    }
    else pLogonId = &pArgs->LogonId;

    scRet = WLsaGetSecurityUserInfo(
                pLogonId,
                pArgs->fFlags,
                &pArgs->pUserInfo
                );

    pApiMessage->ApiMessage.scRet = scRet;
    return(scRet);

}


//+-------------------------------------------------------------------------
//
//  Function:   LpcGetCreds
//
//  Synopsis:
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------

NTSTATUS
LpcGetCreds(
    PSPM_LPC_MESSAGE pApiMessage
    )
{
    NTSTATUS scRet;
    SPMGetCredsAPI * pArgs = &pApiMessage->ApiMessage.Args.SpmArguments.API.GetCreds;

    scRet = SEC_E_UNSUPPORTED_FUNCTION;

    pApiMessage->ApiMessage.scRet = scRet;

    //
    // It is up to the package to do the right thing with the
    // buffer (for now).
    //

    return(scRet);
}


//+-------------------------------------------------------------------------
//
//  Function:   LpcSaveCreds
//
//  Synopsis:
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------

NTSTATUS
LpcSaveCreds(PSPM_LPC_MESSAGE pApiMessage)
{
    NTSTATUS scRet;
    SPMSaveCredsAPI * pArgs = &pApiMessage->ApiMessage.Args.SpmArguments.API.SaveCreds;

    scRet = SEC_E_UNSUPPORTED_FUNCTION;

    pApiMessage->ApiMessage.scRet = scRet;


    return(scRet);
}


//+-------------------------------------------------------------------------
//
//  Function:   LpcLsaLookupPackage
//
//  Synopsis:
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------
NTSTATUS
LpcLsaLookupPackage(
    PSPM_LPC_MESSAGE pApiMessage
    )
{
    PLSAP_AU_API_MESSAGE pLsaMessage = (PLSAP_AU_API_MESSAGE) pApiMessage;
    UNICODE_STRING  sPackageName;
    ANSI_STRING     sAnsiName;
    PLSAP_SECURITY_PACKAGE     pspPackage;
    NTSTATUS Status;

    //
    //  First, convert ANSI name to UNICODE
    //

    if ( pLsaMessage->Arguments.LookupPackage.PackageNameLength >
            LSAP_MAX_PACKAGE_NAME_LENGTH )
    {
        return STATUS_INVALID_PARAMETER ;
    }

    sAnsiName.Length = (USHORT) pLsaMessage->Arguments.LookupPackage.PackageNameLength;
    sAnsiName.MaximumLength = LSAP_MAX_PACKAGE_NAME_LENGTH+1;
    sAnsiName.Buffer = pLsaMessage->Arguments.LookupPackage.PackageName;

    Status = RtlAnsiStringToUnicodeString(&sPackageName, &sAnsiName, TRUE);
    if ( !NT_SUCCESS(Status) )
    {
        pLsaMessage->Arguments.LookupPackage.AuthenticationPackage = (ULONG) -1;
        pLsaMessage->ReturnedStatus = Status;
    }
    else
    {
        //
        // Now, look up the package.
        //
        pspPackage = SpmpLookupPackage(&sPackageName);

        if (pspPackage)
        {
            pLsaMessage->Arguments.LookupPackage.AuthenticationPackage = (DWORD) pspPackage->dwPackageID;
            pLsaMessage->ReturnedStatus = STATUS_SUCCESS;
        }
        else
        {
            pLsaMessage->Arguments.LookupPackage.AuthenticationPackage = (ULONG) -1;
            pLsaMessage->ReturnedStatus = STATUS_NO_SUCH_PACKAGE;
        }
        RtlFreeUnicodeString(&sPackageName);
    }

    return(S_OK);
}


//+-------------------------------------------------------------------------
//
//  Function:   LpcLsaDeregisterLogonProcess
//
//  Synopsis:
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------
NTSTATUS
LpcLsaDeregisterLogonProcess(
    PSPM_LPC_MESSAGE pApiMessage
    )
{
    PLSAP_AU_API_MESSAGE pLsaMessage = (PLSAP_AU_API_MESSAGE) pApiMessage;


    //
    // The client side will close the handle (or not, not a big deal), and
    // we will run down the session at that time.  Safer that way, as well.
    //


    pLsaMessage->ReturnedStatus = STATUS_SUCCESS;

    return(S_OK);
}



//+---------------------------------------------------------------------------
//
//  Function:   LpcLsaLogonUser
//
//  Synopsis:   Unmarshalls everything for a call to WLsaLogonUserWhoopee
//
//  Arguments:  [pApiMessage] --
//
//  History:    6-14-94   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
NTSTATUS
LpcLsaLogonUser(
    PSPM_LPC_MESSAGE pApiMessage
    )
{
    NTSTATUS Status;
    LSAP_CLIENT_REQUEST ClientRequest;
    PLSAP_AU_API_MESSAGE pLsaMessage = (PLSAP_AU_API_MESSAGE) pApiMessage;

    ClientRequest.Request = (PLSAP_AU_API_MESSAGE) pApiMessage;

    pLsaMessage->ReturnedStatus = LsapAuApiDispatchLogonUser(&ClientRequest);

    if ( NT_SUCCESS( pLsaMessage->ReturnedStatus ) )
    {
        if ( ( pLsaMessage->Arguments.LogonUser.LogonType == Interactive ) &&
             ( pLsaMessage->Arguments.LogonUser.ProfileBuffer == NULL ) )
        {
            DsysAssertMsg( pLsaMessage->Arguments.LogonUser.ProfileBuffer,
                           "Successful logon, but profile is NULL. w\n" );
        }
    }

    return(STATUS_SUCCESS);

}

//+-------------------------------------------------------------------------
//
//  Function:   LpcLsaCallPackage
//
//  Synopsis:
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------
NTSTATUS
LpcLsaCallPackage(
    PSPM_LPC_MESSAGE pApiMessage
    )
{
    LSAP_CLIENT_REQUEST ClientRequest;
    PLSAP_AU_API_MESSAGE pLsaMessage = (PLSAP_AU_API_MESSAGE) pApiMessage;

    ClientRequest.Request = (PLSAP_AU_API_MESSAGE) pApiMessage;

    pLsaMessage->ReturnedStatus = LsapAuApiDispatchCallPackage(&ClientRequest);

    return(STATUS_SUCCESS);
}





//+-------------------------------------------------------------------------
//
//  Function:   LpcQueryCredAttributes
//
//
//
//--------------------------------------------------------------------------
NTSTATUS
LpcQueryCredAttributes(
    PSPM_LPC_MESSAGE  pApiMessage
    )
{
    NTSTATUS     hrApiRet;
    SPMQueryCredAttributesAPI * pArgs = &pApiMessage->ApiMessage.Args.SpmArguments.API.QueryCredAttributes;
    PLSA_CALL_INFO CallInfo ;

    CallInfo = LsapGetCurrentCall();

    hrApiRet = WLsaQueryCredAttributes(
                    &pArgs->hCredentials,
                    pArgs->ulAttribute,
                    pArgs->pBuffer
                    );

    pApiMessage->ApiMessage.Args.SpmArguments.fAPI &= KLPC_FLAG_RESET ;

    if ( CallInfo->Allocs )
    {
        ULONG i ;

        pApiMessage->ApiMessage.Args.SpmArguments.fAPI |= SPMAPI_FLAG_ALLOCS ;

        pArgs->Allocs = CallInfo->Allocs ;

        for ( i = 0 ; i < CallInfo->Allocs ; i++ )
        {
            pArgs->Buffers[i] = CallInfo->Buffers[i] ;
        }
    }

    pApiMessage->ApiMessage.scRet = hrApiRet;

    if (FAILED(hrApiRet))
    {
        pApiMessage->ApiMessage.Args.SpmArguments.fAPI |= SPMAPI_FLAG_ERROR_RET;
    }

    return(S_OK);
}




//+---------------------------------------------------------------------------
//
//  Function:   LpcAddPackage
//
//  Algorithm:
//
//  History:    3-05-97   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
SECURITY_STATUS
LpcAddPackage(
    PSPM_LPC_MESSAGE pApiMessage
    )
{
    SPMAddPackageAPI * pArgs;
    SECURITY_STRING PackageName;
    SECURITY_STATUS scRet ;
    PUCHAR Where = NULL;
    SECURITY_PACKAGE_OPTIONS Options;

    pArgs = LPC_MESSAGE_ARGSP( pApiMessage, AddPackage );

    scRet = GetClientString(&pArgs->Package,
                            &PackageName,
                            pApiMessage,
                            &Where);

    if (FAILED(scRet))
    {
        pApiMessage->ApiMessage.scRet = scRet;

        return(scRet);
    }

    DebugLog((DEB_TRACE_VERB,"Add Package called for %ws\n",
                        PackageName.Buffer ));

    Options.Flags = pArgs->OptionsFlags ;
    Options.Size = sizeof( SECURITY_PACKAGE_OPTIONS );

    scRet = WLsaAddPackage( &PackageName,
                            &Options );

    LsapFreePrivateHeap( PackageName.Buffer );

    pApiMessage->ApiMessage.scRet = scRet;

    return( scRet );

}

//+---------------------------------------------------------------------------
//
//  Function:   LpcDeletePackage
//
//  History:    3-05-97   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
SECURITY_STATUS
LpcDeletePackage(
    PSPM_LPC_MESSAGE pApiMessage)
{
    pApiMessage->ApiMessage.scRet = SEC_E_UNSUPPORTED_FUNCTION ;

    return( SEC_E_OK );
}

//+---------------------------------------------------------------------------
//
//  Function:   LpcQueryContextAttributes
//
//  History:    3-05-97   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
NTSTATUS
LpcQueryContextAttributes(
    PSPM_LPC_MESSAGE  pApiMessage
    )
{
    NTSTATUS     hrApiRet;
    SPMQueryContextAttrAPI * pArgs = &pApiMessage->ApiMessage.Args.SpmArguments.API.QueryContextAttr;
    PLSA_CALL_INFO CallInfo ;

    CallInfo = LsapGetCurrentCall();

    hrApiRet = WLsaQueryContextAttributes(
                    &pArgs->hContext,
                    pArgs->ulAttribute,
                    pArgs->pBuffer
                    );

    pApiMessage->ApiMessage.Args.SpmArguments.fAPI &= KLPC_FLAG_RESET ;

    pApiMessage->ApiMessage.scRet = hrApiRet;

    if ( CallInfo->Allocs )
    {
        ULONG i ;

        pApiMessage->ApiMessage.Args.SpmArguments.fAPI |= SPMAPI_FLAG_ALLOCS ;

        pArgs->Allocs = CallInfo->Allocs ;

        for ( i = 0 ; i < CallInfo->Allocs ; i++ )
        {
            pArgs->Buffers[i] = CallInfo->Buffers[i] ;
        }
    }

    if (FAILED(hrApiRet))
    {
        pApiMessage->ApiMessage.Args.SpmArguments.fAPI |= SPMAPI_FLAG_ERROR_RET;
    }

    return(S_OK);
}

//+---------------------------------------------------------------------------
//
//  Function:   LpcSetContextAttributes
//
//  History:    4-20-00   CliffV   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
NTSTATUS
LpcSetContextAttributes(
    PSPM_LPC_MESSAGE  pApiMessage
    )
{
    NTSTATUS     hrApiRet;
    SPMSetContextAttrAPI * pArgs = &pApiMessage->ApiMessage.Args.SpmArguments.API.SetContextAttr;
    PLSA_CALL_INFO CallInfo ;

    CallInfo = LsapGetCurrentCall();

    hrApiRet = WLsaSetContextAttributes(
                    &pArgs->hContext,
                    pArgs->ulAttribute,
                    pArgs->pBuffer,
                    pArgs->cbBuffer
                    );


    pApiMessage->ApiMessage.Args.SpmArguments.fAPI &= KLPC_FLAG_RESET ;

    pApiMessage->ApiMessage.scRet = hrApiRet;

    if (FAILED(hrApiRet))
    {
        pApiMessage->ApiMessage.Args.SpmArguments.fAPI |= SPMAPI_FLAG_ERROR_RET;
    }

    return(S_OK);
}

#ifdef ProfilingEfs

//
// This is for test only. We don't check error vigorously.
//

VOID
OutputEfsProfilingLog(
    WCHAR         *UserName,
    ULONG         AuthIdLow,
    WCHAR         *EfsOp,
    LARGE_INTEGER *StartTime,
    LARGE_INTEGER *ProfileStartTime,
    LARGE_INTEGER *ProfileEndtime,
    LARGE_INTEGER *UnLoadStartTime,
    LARGE_INTEGER *UnLoadEndTime,
    LARGE_INTEGER *EndTime
              )
{

    SYSTEMTIME  SysTime;
    WCHAR       OutBuffer[160];
    WCHAR       LogFileName[16];
    DWORD       BytesWriiten;

    GetLocalTime(&SysTime);
    wsprintf(LogFileName, L"%d.%d.%d",  SysTime.wYear, SysTime.wMonth, SysTime.wDay);
    if (wcscmp(LogFileName, EfsProfileLogName)) {

        LONG IsFileBeingCreated;

        IsFileBeingCreated = InterlockedExchange(&LogFileIsBeingCreated, 1);

        if (IsFileBeingCreated != 1) {

            if (EfsProfileLogHandle) {
                CloseHandle(EfsProfileLogHandle);
                EfsProfileLogHandle = 0;
            }
            wcscpy(EfsProfileLogName, LogFileName);
            wcscpy(OutBuffer, L"d:\\efs\\");
            wcscat(OutBuffer, LogFileName);
            EfsProfileLogHandle = CreateFile(
                                    OutBuffer,
                                    GENERIC_WRITE,
                                    FILE_SHARE_READ | FILE_SHARE_WRITE,
                                    NULL,
                                    OPEN_ALWAYS,
                                    FILE_ATTRIBUTE_NORMAL,
                                    NULL
                                    );

            InterlockedExchange(&LogFileIsBeingCreated, IsFileBeingCreated);

        } else {
            Sleep(5000); //Wait for 5 seconds
        }

    }

    wsprintf(OutBuffer, L"%d.%d.%d:%d.%d.%d\t%ws\t%lu\t%ld\t%ws\t%lu\t%lu\t%lu\t%lu\r\n",
                        SysTime.wYear,
                        SysTime.wMonth,
                        SysTime.wDay,
                        SysTime.wHour,
                        SysTime.wMinute,
                        SysTime.wSecond,
                        UserName,
                        AuthIdLow,
                        UserCacheListCount,
                        EfsOp,
                        (ULONG)((EndTime->QuadPart - StartTime->QuadPart)/1000),
                        (ULONG)((ProfileEndtime->QuadPart - ProfileStartTime->QuadPart)/1000),
                        (ULONG)((UnLoadEndTime->QuadPart - UnLoadStartTime->QuadPart)/1000),
                        (ULONG)((UnLoadStartTime->QuadPart - ProfileEndtime->QuadPart)/1000)
                        );
    WriteFile(
        EfsProfileLogHandle,
        OutBuffer,
        wcslen(OutBuffer)*sizeof(WCHAR),
        &BytesWriiten,
        NULL
        );
    DbgPrint("%ws%", OutBuffer);
}
#endif

//+---------------------------------------------------------------------------
//
//  Function:   LpcCallback
//
//  Synopsis:   Callback handler.  Should never be hit.
//
//  Arguments:  [pApiMessage] --
//
//  History:    3-05-97   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
NTSTATUS
LpcCallback(
    PSPM_LPC_MESSAGE    pApiMessage
    )
{
    pApiMessage->ApiMessage.scRet = SEC_E_UNSUPPORTED_FUNCTION ;
    pApiMessage->ApiMessage.Args.SpmArguments.fAPI &= KLPC_FLAG_RESET ;
    return S_OK ;
}



NTSTATUS
WLsaGenerateKey(
    PEFS_DATA_STREAM_HEADER DirectoryEfsStream,
    PEFS_DATA_STREAM_HEADER * EfsStream,
    PULONG  EfsLength,
    PEFS_KEY * Fek
    )
{
    NTSTATUS        Status;
    DWORD           HResult;

    PEFS_DATA_STREAM_HEADER EfsStreamHeader;


#ifdef ProfilingEfs
LARGE_INTEGER  StartTotal;
LARGE_INTEGER  StartProfile;
LARGE_INTEGER  EndProfile;
LARGE_INTEGER  EndTotal;
LARGE_INTEGER  StartUnload;
LARGE_INTEGER  EndUnload;
WCHAR          UserName[32];
ULONG          AuthIDLow=0;

NtQuerySystemTime(&StartTotal);
#endif

    //
    // Impersonate the client
    //

    Status = LsapImpersonateClient( );

    if (!NT_SUCCESS(Status)) {
        return( Status );
    }

    EFS_USER_INFO   EfsUserInfo;

    if (EfspGetUserInfo( &EfsUserInfo )) {

#ifdef ProfilingEfs
wcscpy(UserName, EfsUserInfo.lpUserName);
AuthIDLow = EfsUserInfo.AuthId.LowPart;
NtQuerySystemTime(&StartProfile);
#endif

        BOOL b = EfspLoadUserProfile( &EfsUserInfo, FALSE );

#ifdef ProfilingEfs
NtQuerySystemTime(&EndProfile);
#endif

        if (!b) {

            HResult = GetLastError();
            if (!EfsErrorToNtStatus(HResult, &Status)) {
                Status = STATUS_UNSUCCESSFUL;
            }

        } else {

            //
            // Generate the Fek.  This routine will fill in the
            // EFS_KEY structure with key data.
            //

            if (GenerateFEK( Fek )) {

                if (!ConstructEFS( &EfsUserInfo, *Fek, DirectoryEfsStream, &EfsStreamHeader )) {

                    HResult = GetLastError();

                    ASSERT( HResult != ERROR_SUCCESS );

                    DebugLog((DEB_ERROR, "ConstructEFS failed, error = (%x)\n" ,HResult  ));

                    LsapFreeLsaHeap( *Fek );
                    *Fek = NULL;

                    if (!EfsErrorToNtStatus(HResult, &Status)) {
                        Status = STATUS_UNSUCCESSFUL;
                    }

                } else {

                    *EfsStream = EfsStreamHeader;
                    *EfsLength = EfsStreamHeader->Length;
                }

            } else {

                HResult = GetLastError();
                if (!EfsErrorToNtStatus(HResult, &Status)) {
                    Status = STATUS_UNSUCCESSFUL;
                }
            }

#ifdef ProfilingEfs
NtQuerySystemTime(&StartUnload);
#endif

            EfspUnloadUserProfile( &EfsUserInfo );

#ifdef ProfilingEfs
NtQuerySystemTime(&EndUnload);
#endif
        }

        EfspFreeUserInfo( &EfsUserInfo );

    } else {

        HResult = GetLastError();
        if (!EfsErrorToNtStatus(HResult, &Status)) {
            Status = STATUS_UNSUCCESSFUL;
        }

    }


    RevertToSelf();

#ifdef ProfilingEfs
NtQuerySystemTime(&EndTotal);

OutputEfsProfilingLog(
    UserName,
    AuthIDLow,
    L"Create",
    &StartTotal,
    &StartProfile,
    &EndProfile,
    &StartUnload,
    &EndUnload,
    &EndTotal
    );
#endif

    return Status;
}

NTSTATUS
WLsaGenerateDirEfs(
    PEFS_DATA_STREAM_HEADER DirectoryEfsStream,
    PEFS_DATA_STREAM_HEADER * EfsStream
    )
{
    NTSTATUS Status;
    DWORD HResult;

    PEFS_KEY Fek = NULL;

    Status = LsapImpersonateClient( );

    if (!NT_SUCCESS(Status)) {
        return( Status );
    }

    EFS_USER_INFO   EfsUserInfo;

    if (EfspGetUserInfo( &EfsUserInfo )) {

        if (!EfspLoadUserProfile( &EfsUserInfo, FALSE )) {

            HResult = GetLastError();
            if (!EfsErrorToNtStatus(HResult, &Status)) {
                Status = STATUS_UNSUCCESSFUL;
            }

        } else {

            if (GenerateFEK( &Fek )) {

                if (!ConstructDirectoryEFS(
                             &EfsUserInfo,
                             Fek,
                             EfsStream
                             )) {

                    HResult = GetLastError();
                    ASSERT( HResult != ERROR_SUCCESS );
                    DebugLog((DEB_ERROR, "ConstructDirectoryEFS failed, error = (%x)\n" ,HResult  ));
                    if (!EfsErrorToNtStatus(HResult, &Status)) {
                        Status = STATUS_UNSUCCESSFUL;
                    }
                }

                LsapFreeLsaHeap( Fek );

            } else {

                HResult = GetLastError();
                if (!EfsErrorToNtStatus(HResult, &Status)) {
                    Status = STATUS_UNSUCCESSFUL;
                }
            }

            EfspUnloadUserProfile( &EfsUserInfo );
        }

        EfspFreeUserInfo( &EfsUserInfo );

    } else {

        HResult = GetLastError();
        if (!EfsErrorToNtStatus(HResult, &Status)) {
            Status = STATUS_UNSUCCESSFUL;
        }
    }

    RevertToSelf();

    return Status;
}



NTSTATUS
LpcEfsGenerateKey(   PSPM_LPC_MESSAGE    pApiMessage)

/*++

Routine Description:

    This routine generates an FEK and an EFS stream for the file
    being encrypted.

Arguments:

    pApiMessage - Supplies the LPC message from the driver.

Return Value:

    return-value - Description of conditions needed to return value. - or -
    None.

--*/

{
    NTSTATUS scRet;
    SPMEfsGenerateKeyAPI * Args = &pApiMessage->ApiMessage.Args.SpmArguments.API.EfsGenerateKey ;
    ULONG EfsLength = 0;
    PEFS_KEY Fek = NULL;
    PEFS_DATA_STREAM_HEADER EfsStream;
    SIZE_T BufferLength;

    DebugLog((DEB_TRACE_EFS,"LpcEfsGenerateKey, Args is at %x\n",Args));

    if ((pApiMessage->pmMessage.u2.s2.Type & LPC_KERNELMODE_MESSAGE) == 0){
        DebugLog((DEB_ERROR,"Caller is not from kernelmode \n"));
        pApiMessage->ApiMessage.scRet = STATUS_ACCESS_DENIED ;
        return STATUS_ACCESS_DENIED;
    }

    if (EfsPersonalVer || EfsDisabled) {
        pApiMessage->ApiMessage.scRet = STATUS_NOT_SUPPORTED;
        return STATUS_NOT_SUPPORTED;
    }

    scRet = WLsaGenerateKey(
               (PEFS_DATA_STREAM_HEADER)Args->DirectoryEfsStream,
               &EfsStream,
               &EfsLength,
               &Fek
               );

    if (NT_SUCCESS( scRet )) {

        //
        // Copy the FEK to the client's address space
        //

        PVOID Target = NULL;

        BufferLength = EFS_KEY_SIZE( Fek ) + EfsLength;

#ifdef LSAP_CATCH_BAD_VM
        if ( BufferLength > 0x2000000 )
        {
            DbgPrint("Allocation too large\n" );
            DbgBreakPoint();
        }
#endif
        scRet = NtAllocateVirtualMemory(
                            GetCurrentProcess(),
                            &Target,
                            0,
                            &BufferLength,
                            MEM_COMMIT,
                            PAGE_READWRITE
                            );

        Args->BufferLength = (ULONG) BufferLength;
        if (NT_SUCCESS( scRet )) {

            //
            // Save away the base of the allocation so that the driver may free it
            // when it's finished with it.
            //

            Args->BufferBase = Target;
            Args->Fek = Target;

            RtlCopyMemory(
                Target,
                (PVOID)Fek,
                EFS_KEY_SIZE( Fek )
                );


            Target = (PVOID)((ULONG_PTR)Target + EFS_KEY_SIZE( Fek ));
            Args->EfsStream = Target;

            RtlCopyMemory(
                Target,
                (PVOID)EfsStream,
                EfsLength
                );

        } else {

            Args->BufferBase = NULL;
            Args->BufferLength = 0;
            Args->Fek = NULL;
            Args->EfsStream = NULL;

        }

        if ( Fek ){
            RtlSecureZeroMemory(EFS_KEY_DATA(Fek), Fek->KeyLength );
            LsapFreeLsaHeap( Fek );
        }

        if ( EfsStream ){
            LsapFreeLsaHeap( EfsStream );
        }
    }

    pApiMessage->ApiMessage.scRet = scRet;
    return( scRet );
}


NTSTATUS
LpcEfsGenerateDirEfs(
    PSPM_LPC_MESSAGE pApiMessage
    )
/*++

Routine Description:

    Lpc stub for GenerateDirEfs

Arguments:

    pApiMessage - LPC Message

Return Value:

    NtStatus

--*/
{
    SPMEfsGenerateDirEfsAPI * Args = &pApiMessage->ApiMessage.Args.SpmArguments.API.EfsGenerateDirEfs ;
    PEFS_DATA_STREAM_HEADER EfsStream;
    NTSTATUS scRet;
    ULONG EfsLength = 0;

    if ((pApiMessage->pmMessage.u2.s2.Type & LPC_KERNELMODE_MESSAGE) == 0){
        DebugLog((DEB_ERROR,"Caller is not from kernelmode \n"));
        pApiMessage->ApiMessage.scRet = STATUS_ACCESS_DENIED ;
        return STATUS_ACCESS_DENIED;
    }

    if (EfsPersonalVer || EfsDisabled) {
        pApiMessage->ApiMessage.scRet = STATUS_NOT_SUPPORTED;
        return STATUS_NOT_SUPPORTED;
    }

    scRet = WLsaGenerateDirEfs(
        (PEFS_DATA_STREAM_HEADER)Args->DirectoryEfsStream,
        &EfsStream
        );

    if (NT_SUCCESS( scRet )) {

        PVOID Target = NULL;

        SIZE_T EfsLength = EfsStream->Length;

#ifdef LSAP_CATCH_BAD_VM
        if ( EfsLength > 0x2000000 )
        {
            DbgPrint("Allocation too large\n" );
            DbgBreakPoint();
        }
#endif

        scRet = NtAllocateVirtualMemory(
                            GetCurrentProcess(),
                            &Target,
                            0,
                            &EfsLength,
                            MEM_COMMIT,
                            PAGE_READWRITE
                            );

        if (NT_SUCCESS( scRet )) {

            Args->BufferBase = Target;
            Args->BufferLength = EfsStream->Length;
            Args->EfsStream = Target;

            RtlCopyMemory(
                Target,
                (PVOID)EfsStream,
                EfsStream->Length
                );

        } else {

                Args->BufferBase = NULL;
                Args->BufferLength = 0;
                Args->EfsStream = NULL;
        }

        if (EfsStream){
            LsapFreeLsaHeap( EfsStream );
        }
    }

    pApiMessage->ApiMessage.scRet = scRet;
    return( scRet );
}

NTSTATUS
WLsaDecryptFek(
    PEFS_DATA_STREAM_HEADER EfsStream,
    PEFS_KEY * Fek,
    PEFS_DATA_STREAM_HEADER * NewEfs,
    ULONG OpenType
    )

/*++

Routine Description:

    Worker function for DecryptFek

Arguments:

    EfsStream - The $EFS attribute for the file being decrypted.

    Fek - Returns the FEK for the file being decrypted.  This structure
        is allocated out of heap and must be freed by the caller.

    NewEfs - Optionally returns a new $EFS stream to be applied to
        the file.

    OpenType - Whether this is a decrypt or recovery operation.


Return Value:

    NtStatus

--*/

{
    NTSTATUS Status;
    DWORD HResult;
    DWORD rc;

    HANDLE hToken = NULL;
    HANDLE hProfile = NULL;

#ifdef ProfilingEfs
LARGE_INTEGER  StartTotal;
LARGE_INTEGER  StartProfile;
LARGE_INTEGER  EndProfile;
LARGE_INTEGER  EndTotal;
LARGE_INTEGER  StartUnload;
LARGE_INTEGER  EndUnload;
WCHAR          UserName[32];
ULONG          AuthIDLow=0;

NtQuerySystemTime(&StartTotal);
#endif

    Status = LsapImpersonateClient( );

    if (!NT_SUCCESS(Status)) {
        return( Status );
    }

    EFS_USER_INFO EfsUserInfo;

    if (EfspGetUserInfo( &EfsUserInfo ) ) {

#ifdef ProfilingEfs
wcscpy(UserName, EfsUserInfo.lpUserName);
AuthIDLow = EfsUserInfo.AuthId.LowPart;
NtQuerySystemTime(&StartProfile);
#endif

        if (EfspLoadUserProfile( &EfsUserInfo, FALSE )) {

#ifdef ProfilingEfs
NtQuerySystemTime(&EndProfile);
#endif

            HResult = DecryptFek( &EfsUserInfo, EfsStream, Fek, NewEfs, OpenType );

            if (HResult != ERROR_SUCCESS) {
                DebugLog((DEB_ERROR, "WLsaDecryptFek: DecryptFek failed, error = %x\n" ,HResult  ));
                if (!EfsErrorToNtStatus(HResult, &Status)) {
                    Status = STATUS_UNSUCCESSFUL;
                }
            }

#ifdef ProfilingEfs
NtQuerySystemTime(&StartUnload);
#endif

            EfspUnloadUserProfile( &EfsUserInfo );

#ifdef ProfilingEfs
NtQuerySystemTime(&EndUnload);
#endif

        } else {

            HResult = GetLastError();
            if (!EfsErrorToNtStatus(HResult, &Status)) {
                Status = STATUS_UNSUCCESSFUL;
            }
        }

        EfspFreeUserInfo( &EfsUserInfo );

    } else {

        HResult = GetLastError();
        if (!EfsErrorToNtStatus(HResult, &Status)) {
            Status = STATUS_UNSUCCESSFUL;
        }
    }

    RevertToSelf();

#ifdef ProfilingEfs
NtQuerySystemTime(&EndTotal);
OutputEfsProfilingLog(
    UserName,
    AuthIDLow,
    L"Open",
    &StartTotal,
    &StartProfile,
    &EndProfile,
    &StartUnload,
    &EndUnload,
    &EndTotal
    );
#endif

    return Status;
}


NTSTATUS
LpcEfsDecryptFek(   PSPM_LPC_MESSAGE    pApiMessage)
{
    SPMEfsDecryptFekAPI * Args = &pApiMessage->ApiMessage.Args.SpmArguments.API.EfsDecryptFek ;
    PEFS_DATA_STREAM_HEADER NewEfs;
    NTSTATUS Status;
    ULONG EfsLength = 0;
    PEFS_KEY Fek;
    SIZE_T BufferLength;

    Args->BufferBase = NULL;
    Args->BufferLength = 0;
    Args->Fek = NULL;
    Args->NewEfs = NULL;

    if ((pApiMessage->pmMessage.u2.s2.Type & LPC_KERNELMODE_MESSAGE) == 0){
        DebugLog((DEB_ERROR,"Caller is not from kernelmode \n"));
        pApiMessage->ApiMessage.scRet = STATUS_ACCESS_DENIED ;
        return STATUS_ACCESS_DENIED;
    }

    if (EfsPersonalVer || EfsDisabled) {
        pApiMessage->ApiMessage.scRet = STATUS_NOT_SUPPORTED;
        return STATUS_NOT_SUPPORTED;
    }

    Status = WLsaDecryptFek( (PEFS_DATA_STREAM_HEADER)Args->EfsStream, &Fek, &NewEfs, Args->OpenType  );


    if (NT_SUCCESS( Status )) {

        BufferLength = EFS_KEY_SIZE( Fek );

        if (NewEfs != NULL) {
            BufferLength += NewEfs->Length;
        }

        PVOID Target = NULL;

#ifdef LSAP_CATCH_BAD_VM
        if ( BufferLength > 0x2000000 )
        {
            DbgPrint("Allocation too large\n" );
            DbgBreakPoint();
        }
#endif
        Status = NtAllocateVirtualMemory(
                            GetCurrentProcess(),
                            &Target,
                            0,
                            &BufferLength,
                            MEM_COMMIT,
                            PAGE_READWRITE
                            );


        Args->BufferLength = (ULONG) BufferLength;
        if (NT_SUCCESS( Status )) {

            Args->BufferBase = Target;
            Args->Fek = Target;

            RtlCopyMemory(
                Target,
                (PVOID)Fek,
                EFS_KEY_SIZE( Fek )
                );

            if (NewEfs != NULL) {

                Target = (PVOID)((DWORD_PTR)Target + EFS_KEY_SIZE( Fek ));
                Args->NewEfs = Target;

                RtlCopyMemory(
                    Target,
                    (PVOID)NewEfs,
                    NewEfs->Length
                    );

            }

        } else {

            Args->BufferBase = NULL;
            Args->BufferLength = 0;
            Args->Fek = NULL;

        }

        if ( Fek){
            RtlSecureZeroMemory(EFS_KEY_DATA(Fek), Fek->KeyLength );
            LsapFreeLsaHeap( Fek );
        }

        if ( NewEfs ){
            LsapFreeLsaHeap( NewEfs );
        }
    }

    pApiMessage->ApiMessage.scRet = Status;

    return( Status );
}


NTSTATUS
LpcEfsGenerateSessionKey(
    PSPM_LPC_MESSAGE    pApiMessage
    )
{
    SPMEfsGenerateSessionKeyAPI * Args = &pApiMessage->ApiMessage.Args.SpmArguments.API.EfsGenerateSessionKey ;
    NTSTATUS scRet;

    EFS_INIT_DATAEXG InitDataExg;

    if ((pApiMessage->pmMessage.u2.s2.Type & LPC_KERNELMODE_MESSAGE) == 0){
        DebugLog((DEB_ERROR,"Caller is not from kernelmode \n"));
        pApiMessage->ApiMessage.scRet = STATUS_ACCESS_DENIED ;
        return STATUS_ACCESS_DENIED;
    }

    if ( EfsSessionKeySent ){
        pApiMessage->ApiMessage.scRet = STATUS_ACCESS_DENIED ;
        return STATUS_ACCESS_DENIED;
    }

    scRet = GenerateDriverSessionKey( &InitDataExg );

    if (NT_SUCCESS( scRet )) {

        //
        // Copy the returned session key into the argument buffer
        //

        RtlCopyMemory( &Args->InitDataExg, &InitDataExg, sizeof( EFS_INIT_DATAEXG ));

        pApiMessage->pmMessage.u1.s1.DataLength = LPC_DATA_LENGTH( sizeof( EFS_INIT_DATAEXG ) );
        pApiMessage->pmMessage.u1.s1.TotalLength = LPC_TOTAL_LENGTH( sizeof( EFS_INIT_DATAEXG ) );

        EfsSessionKeySent = TRUE;
    }

    //
    // Wipe out the session key
    //

    RtlSecureZeroMemory((PVOID)&InitDataExg, sizeof( EFS_INIT_DATAEXG ));
    pApiMessage->ApiMessage.scRet = scRet;

    return( scRet );
}

NTSTATUS
LpcGetUserName(
    PSPM_LPC_MESSAGE pApiMessage
    )
{

    LUID LogonId ;
    PLSAP_LOGON_SESSION LogonSession ;
    NTSTATUS Status ;
    SECPKG_CLIENT_INFO ClientInfo ;
    SPMGetUserNameXAPI * Args = &pApiMessage->ApiMessage.Args.SpmArguments.API.GetUserNameX ;
    PLSAP_DS_NAME_MAP Map ;
    PLSAP_DS_NAME_MAP SamMap = NULL ;
    UNICODE_STRING String ;
    PWSTR Scan ;
    PWSTR DnsDomainName = NULL;

    Status = LsapGetClientInfo( &ClientInfo );

    if ( NT_SUCCESS( Status ) )
    {
        LogonSession = LsapLocateLogonSession( &ClientInfo.LogonId );

        if ( LogonSession )
        {
            if ( RtlEqualLuid( &ClientInfo.LogonId,
                               &LsapSystemLogonId ) &&
                 (Args->Options & SPM_NAME_OPTION_NT4_ONLY) )
            {
                Map = LsapGetNameForLocalSystem();

                Status = STATUS_SUCCESS ;

            }
            else
            {
                Status = LsapGetNameForLogonSession(
                                LogonSession,
                                Args->Options,
                                &Map,
                                FALSE );

                if (NT_SUCCESS(Status)
                     &&
                    (Args->Options & (~SPM_NAME_OPTION_MASK)) == NameDnsDomain)
                {
                    //
                    // To cruft up the NameDnsDomain format, we need
                    // the SAM username.
                    //

                    Status = LsapGetNameForLogonSession(
                                    LogonSession,
                                    NameSamCompatible,
                                    &SamMap,
                                    FALSE);

                    if (!NT_SUCCESS(Status))
                    {
                        LsapDerefDsNameMap(Map);
                    }
                }
            }

            LsapReleaseLogonSession( LogonSession );

            if ( NT_SUCCESS( Status ) )
            {
                //
                // See what we can do.
                //

                if ( (Args->Options & SPM_NAME_OPTION_NT4_ONLY) == 0)
                {
                    if ((Args->Options & (~SPM_NAME_OPTION_MASK )) != NameDnsDomain)
                    {
                        String = Map->Name ;
                    }
                    else
                    {
                        //
                        // Build up the DnsDomainName format
                        //

                        Scan = wcschr( SamMap->Name.Buffer, L'\\' );

                        if ( Scan )
                        {
                            Scan++;
                        }
                        else
                        {
                            Scan = SamMap->Name.Buffer;
                        }

                        //
                        // SAM name is always NULL-terminated
                        //

                        SafeAllocaAllocate(DnsDomainName,
                                           Map->Name.Length + (wcslen(Scan) + 2) * sizeof(WCHAR));

                        if (DnsDomainName != NULL)
                        {
                            ULONG Index = Map->Name.Length / sizeof(WCHAR);

                            wcsncpy(DnsDomainName, Map->Name.Buffer, Index);
                            DnsDomainName[Index++] = L'\\';
                            wcscpy(DnsDomainName + Index, Scan);

                            RtlInitUnicodeString(&String, DnsDomainName);
                        }
                        else
                        {
                            String.Length = String.MaximumLength = 0;
                            String.Buffer = NULL;

                            Status = STATUS_NO_MEMORY;
                        }

                        LsapDerefDsNameMap(SamMap);
                    }
                }
                else
                {
                    Scan = wcschr( Map->Name.Buffer, L'\\' );

                    if ( Scan )
                    {
                        Scan++;
                        RtlInitUnicodeString( &String, Scan );
                    }
                    else
                    {
                        String = Map->Name ;
                    }
                }

                if (NT_SUCCESS(Status))
                {
                    if ( String.Length <= Args->Name.MaximumLength )
                    {
                        Args->Name.Length = String.Length ;

                        if ( String.Length < CBPREPACK )
                        {
                            Args->Name.Buffer = (PWSTR) ((LONG_PTR) pApiMessage->ApiMessage.bData
                                                           - (LONG_PTR) Args);

                            RtlCopyMemory(
                                pApiMessage->ApiMessage.bData,
                                String.Buffer,
                                String.Length );

                            pApiMessage->pmMessage.u1.s1.DataLength = LPC_DATA_LENGTH( String.Length );
                            pApiMessage->pmMessage.u1.s1.TotalLength = LPC_TOTAL_LENGTH( String.Length );
                        }
                        else
                        {
                            Status = LsapCopyToClient(
                                        String.Buffer,
                                        Args->Name.Buffer,
                                        String.Length );
                        }
                    }
                    else
                    {
                        Args->Name.Length = String.Length ;
                        Args->Name.Buffer = NULL ;
                        Status = STATUS_BUFFER_OVERFLOW ;
                    }
                }

                LsapDerefDsNameMap( Map );
            }
            else
            {
                if ( Status == STATUS_UNSUCCESSFUL )
                {
                    pApiMessage->ApiMessage.Args.SpmArguments.fAPI |= SPMAPI_FLAG_WIN32_ERROR ;
                    Status = GetLastError();
                }
            }
        }
        else
        {
            DebugLog(( DEB_ERROR, "No logon session found for impersonated client!\n" ));
            Status = STATUS_NO_SUCH_LOGON_SESSION ;
        }
    }

    SafeAllocaFree(DnsDomainName);

    pApiMessage->ApiMessage.Args.SpmArguments.fAPI &= KLPC_FLAG_RESET ;

    pApiMessage->ApiMessage.scRet = Status ;

    return STATUS_SUCCESS ;
}


NTSTATUS
LpcAddCredentials(
    PSPM_LPC_MESSAGE pApiMessage
    )
{
    UNICODE_STRING  ssPrincipalName;
    UNICODE_STRING  ssPackageName;
    NTSTATUS scApiRet;
    NTSTATUS scRet;
    SPMAddCredentialAPI * pArgs = &pApiMessage->ApiMessage.Args.SpmArguments.API.AddCredential;
    PUCHAR Where = NULL;

    DebugLog((DEB_TRACE, "[%x] LpcAddCredentials()\n", GetCurrentSession()->dwProcessID));

    ssPrincipalName.Buffer = NULL;
    ssPackageName.Buffer = NULL;

    if (pArgs->ssPrincipal.Buffer )
    {
        scRet = GetClientString(&pArgs->ssPrincipal,
                            &ssPrincipalName,
                            pApiMessage,
                            &Where);
        if (FAILED(scRet))
        {
            DebugLog((DEB_ERROR, "GetClientString failed to get principal name 0x%08x\n", scRet));
            pApiMessage->ApiMessage.scRet = scRet;
            return(scRet);
        }

    } else {
        ssPrincipalName.MaximumLength = 0;
        ssPrincipalName.Length = 0;
        ssPrincipalName.Buffer = NULL;
    }

    scRet = GetClientString(&pArgs->ssSecPackage,
                            &ssPackageName,
                            pApiMessage,
                            &Where);

    if (FAILED(scRet))
    {
        LsapFreePrivateHeap(ssPrincipalName.Buffer);
        DebugLog((DEB_ERROR, "GetClientString failed to get package name 0x%08x\n", scRet));
        pApiMessage->ApiMessage.scRet = scRet;
        return(scRet);
    }

    scApiRet = WLsaAddCredentials(
                    &pArgs->hCredentials,
                    &ssPrincipalName,
                    &ssPackageName,
                    pArgs->fCredentialUse,
                    (PVOID) pArgs->pvAuthData,
                    (PVOID) pArgs->pvGetKeyFn,
                    (PVOID) pArgs->ulGetKeyArgument,
                    &pArgs->tsExpiry );


    //
    // Reset the reply flags:
    //
    pApiMessage->ApiMessage.Args.SpmArguments.fAPI &= KLPC_FLAG_RESET ;


    LsapFreePrivateHeap(ssPackageName.Buffer);

    LsapFreePrivateHeap(ssPrincipalName.Buffer);

    pApiMessage->ApiMessage.scRet = scApiRet;
    if (FAILED(pApiMessage->ApiMessage.scRet))
    {
        pApiMessage->ApiMessage.Args.SpmArguments.fAPI |= SPMAPI_FLAG_ERROR_RET;
    }
    return(S_OK);

}

NTSTATUS
LpcEnumLogonSessions(
    PSPM_LPC_MESSAGE pApiMessage
    )
{
    NTSTATUS scApiRet;
    NTSTATUS scRet;
    SPMEnumLogonSessionAPI * pArgs = &pApiMessage->ApiMessage.Args.SpmArguments.API.EnumLogonSession ;

    DebugLog((DEB_TRACE, "[%x] LpcEnumLogonSessions()\n", GetCurrentSession()->dwProcessID));

    scApiRet = WLsaEnumerateLogonSession(
                    &pArgs->LogonSessionCount,
                    (PLUID *) &pArgs->LogonSessionList );

    //
    // Reset the reply flags:
    //

    pApiMessage->ApiMessage.Args.SpmArguments.fAPI &= KLPC_FLAG_RESET ;
    pApiMessage->ApiMessage.scRet = scApiRet;

    if (FAILED(pApiMessage->ApiMessage.scRet))
    {
        pApiMessage->ApiMessage.Args.SpmArguments.fAPI |= SPMAPI_FLAG_ERROR_RET;
    }

    return(S_OK);
}

NTSTATUS
LpcGetLogonSessionData(
    PSPM_LPC_MESSAGE pApiMessage
    )
{
    NTSTATUS scApiRet;
    NTSTATUS scRet;
    SPMGetLogonSessionDataAPI * pArgs = &pApiMessage->ApiMessage.Args.SpmArguments.API.GetLogonSessionData ;

    DebugLog((DEB_TRACE, "[%x] LpcGetLogonSessionData()\n", GetCurrentSession()->dwProcessID));

    scApiRet = WLsaGetLogonSessionData(
                    &pArgs->LogonId,
                    &pArgs->LogonSessionInfo );

    //
    // Reset the reply flags:
    //
    pApiMessage->ApiMessage.Args.SpmArguments.fAPI &= KLPC_FLAG_RESET ;


    pApiMessage->ApiMessage.scRet = scApiRet;

    if (FAILED(pApiMessage->ApiMessage.scRet))
    {
        pApiMessage->ApiMessage.Args.SpmArguments.fAPI |= SPMAPI_FLAG_ERROR_RET;
    }
    return(S_OK);

}

NTSTATUS
LpcLookupAccountName(
    PSPM_LPC_MESSAGE pApiMessage
    )
{
    NTSTATUS scApiRet;
    NTSTATUS scRet;
    SPMLookupAccountNameXAPI * pArgs = &pApiMessage->ApiMessage.Args.SpmArguments.API.LookupAccountNameX ;
    UNICODE_STRING  Name ;
    PUCHAR          Where = NULL ;
    LSAPR_TRANSLATED_SIDS_EX2 Sids ;
    PLSAPR_REFERENCED_DOMAIN_LIST DomList ;
    LSAPR_UNICODE_STRING String ;
    ULONG MappedCount ;
    ULONG Available ;
    ULONG Size ;

    DebugLog((DEB_TRACE, "[%x] LpcLookupAccountName()\n", GetCurrentSession()->dwProcessID));

    scApiRet = GetClientString(
                    &pArgs->Name,
                    &Name,
                    pApiMessage,
                    &Where );

    if ( NT_SUCCESS( scApiRet ) )
    {
        MappedCount = 0 ;

        String.Length = Name.Length ;
        String.MaximumLength = Name.MaximumLength ;
        String.Buffer = Name.Buffer ;

        scApiRet = LsarLookupNames3(
                        LsapPolicyHandle,
                        1,
                        &String,
                        &DomList,
                        &Sids,
                        LsapLookupWksta,
                        &MappedCount,
                        0,
                        LSA_CLIENT_LATEST );

        if ( NT_SUCCESS( scApiRet ) )
        {

            Where = pApiMessage->ApiMessage.bData ;
            pArgs->NameUse = Sids.Sids[0].Use ;

            Size = RtlLengthSid( (PSID) Sids.Sids[0].Sid );

            pArgs->Sid = (PVOID) (Where - (PUCHAR) pApiMessage) ;
            RtlCopyMemory(
                Where,
                Sids.Sids[0].Sid,
                Size );

            Available = CBPREPACK - Size ;
            Where += Size ;

            Size = DomList->Domains[0].Name.Length ;
            if ( Available >= Size )
            {
                RtlCopyMemory(
                    Where,
                    DomList->Domains[0].Name.Buffer,
                    Size );

                pArgs->Domain.Buffer = (PWSTR) (Where - (PUCHAR) pApiMessage ) ;
                pArgs->Domain.Length = (USHORT) Size ;
                pArgs->Domain.MaximumLength = (USHORT) Size ;

            }
            else
            {
                pArgs->Domain.Buffer = NULL ;
                pArgs->Domain.Length = 0 ;
                pArgs->Domain.MaximumLength = 0 ;
            }

            MIDL_user_free( DomList );
            MIDL_user_free( Sids.Sids );
        }
    }

    //
    // Reset the reply flags:
    //

    pApiMessage->ApiMessage.Args.SpmArguments.fAPI &= KLPC_FLAG_RESET ;

    pApiMessage->ApiMessage.scRet = scApiRet;

    if (FAILED(pApiMessage->ApiMessage.scRet))
    {
        pApiMessage->ApiMessage.Args.SpmArguments.fAPI |= SPMAPI_FLAG_ERROR_RET;
    }

    return(S_OK);
}

NTSTATUS
LpcLookupAccountSid(
    PSPM_LPC_MESSAGE pApiMessage
    )
{
    NTSTATUS scApiRet = STATUS_SUCCESS ;
    NTSTATUS scRet;
    SPMLookupAccountSidXAPI * pArgs = &pApiMessage->ApiMessage.Args.SpmArguments.API.LookupAccountSidX ;
    PUCHAR          Where = NULL ;
    PLSAPR_REFERENCED_DOMAIN_LIST DomList ;
    LSAPR_SID_ENUM_BUFFER SidBuffer ;
    LSAPR_SID_INFORMATION SidInfo ;
    LSAPR_TRANSLATED_NAMES_EX Names ;
    ULONG MappedCount ;
    SIZE_T Available ;
    ULONG Size ;
    PSID Sid = NULL ;
    PLSA_CALL_INFO CallInfo ;
    ULONG Consumed = 0 ;

    CallInfo = LsapGetCurrentCall();

    DebugLog((DEB_TRACE, "[%x] LpcLookupAccountSid()\n", GetCurrentSession()->dwProcessID));

    Where = (ULONG_PTR) pArgs->Sid + (PUCHAR) pApiMessage ;
    Available = sizeof( SPM_LPC_MESSAGE ) - (ULONG_PTR) pArgs->Sid ;

    //
    // Verify that the passed SID is at least large enough for the SID header
    //
    if ( Available < sizeof( SID ) )
    {
        scApiRet = STATUS_INVALID_PARAMETER ;
    }

    if ( NT_SUCCESS( scApiRet ) )
    {
        Sid = (PSID) ( Where );

        if ( !RtlValidSid( Sid ))
        {
            scApiRet = STATUS_INVALID_PARAMETER;
        }
    }

    if ( NT_SUCCESS( scApiRet ) )
    {
        Size = RtlLengthSid( Sid );

        if ( Size > Available )
        {
            scApiRet = STATUS_INVALID_PARAMETER ;
        }
    }

    if ( NT_SUCCESS( scApiRet ) )
    {
        PSID DomainSid = NULL;
        MappedCount = 0 ;

        SidInfo.Sid = (PLSAPR_SID) Sid ;
        SidBuffer.Entries = 1 ;
        SidBuffer.SidInfo = &SidInfo ;

        scApiRet = LsarLookupSids2(
                        LsapPolicyHandle,
                        &SidBuffer,
                        &DomList,
                        &Names,
                        LsapLookupWksta,
                        &MappedCount,
                        0,
                        LSA_CLIENT_LATEST );

        if ( NT_SUCCESS( scApiRet ) &&
             ( MappedCount == 1 ) )
        {
            pArgs->Domain.Buffer = NULL ;
            pArgs->Domain.Length = 0 ;
            pArgs->Domain.MaximumLength = 0 ;

            if ( CallInfo->KMap )
            {
                CallInfo->Flags |= CALL_FLAG_KMAP_USED ;
            }

            Where = pApiMessage->ApiMessage.bData ;

            pArgs->NameUse = Names.Names[0].Use ;

            Size = Names.Names[0].Name.Length ;

            Available = CBPREPACK ;

            if ( Available >= Size )
            {
                pArgs->Name.Buffer = (PWSTR) (Where - (PUCHAR) pApiMessage );
                pArgs->Name.Length = (USHORT) Size ;
                pArgs->Name.MaximumLength = pArgs->Name.Length ;

                RtlCopyMemory(
                    Where,
                    Names.Names[0].Name.Buffer,
                    Size );

                Available = Available - Size ;
                Where += Size ;
                Consumed += Size ;
            }
            else
            {
                pArgs->Name.Buffer = (PWSTR) LsapClientAllocate( Size + sizeof( WCHAR ) );

                if ( pArgs->Name.Buffer )
                {
                    scApiRet = LsapCopyToClient(
                        Names.Names[0].Name.Buffer,
                        pArgs->Name.Buffer,
                        Size );

                    pArgs->Name.Length = (USHORT) Size ;
                    pArgs->Name.MaximumLength = (USHORT) Size ;
                }
            }

            Size = DomList->Domains[0].Name.Length ;
            if ( Available >= Size )
            {
                RtlCopyMemory(
                    Where,
                    DomList->Domains[0].Name.Buffer,
                    Size );

                pArgs->Domain.Buffer = (PWSTR) (Where - (PUCHAR) pApiMessage );
                pArgs->Domain.Length = (USHORT) Size ;
                pArgs->Domain.MaximumLength = (USHORT) Size ;

                Consumed += Size ;
            }
            else
            {
                //
                // Attempt to allocate in the client space:
                //

                pArgs->Domain.Buffer = (PWSTR) LsapClientAllocate( Size + sizeof( WCHAR ) );

                if ( pArgs->Domain.Buffer )
                {
                    scApiRet = LsapCopyToClient(
                        DomList->Domains[0].Name.Buffer,
                        pArgs->Domain.Buffer,
                        Size );

                    pArgs->Domain.Length = (USHORT) Size ;
                    pArgs->Domain.MaximumLength = (USHORT) Size ;
                }
            }

            if ( pArgs->Name.Buffer == NULL ||
                 pArgs->Domain.Buffer == NULL )
            {
                scApiRet = STATUS_NO_MEMORY;
            }

            MIDL_user_free( DomList );
            MIDL_user_free( Names.Names );
        }

        SafeAllocaFree( DomainSid );
    }

    //
    // Reset the reply flags:
    //

    pApiMessage->ApiMessage.Args.SpmArguments.fAPI &= KLPC_FLAG_RESET ;
    pApiMessage->pmMessage.u1.s1.DataLength = LPC_DATA_LENGTH( Consumed );
    pApiMessage->pmMessage.u1.s1.TotalLength = LPC_TOTAL_LENGTH( Consumed );
    pApiMessage->ApiMessage.scRet = scApiRet;

    if (FAILED(pApiMessage->ApiMessage.scRet))
    {
        pApiMessage->ApiMessage.Args.SpmArguments.fAPI |= SPMAPI_FLAG_ERROR_RET;
    }

    return(S_OK);
}


NTSTATUS
LpcLookupWellKnownSid(
    PSPM_LPC_MESSAGE pApiMessage
    )
{
    NTSTATUS scApiRet = STATUS_SUCCESS ;
    DECLARE_ARGSP( pArgs, pApiMessage, LookupWellKnownSid );
    PUCHAR          Where = NULL ;
    PSID Sid = NULL ;
    ULONG Consumed = 0 ;
    UCHAR AccountDomain[ SECURITY_MAX_SID_SIZE ];

    DebugLog((DEB_TRACE, "[%x] LpcLookupWellKnownSid()\n", GetCurrentSession()->dwProcessID));

    Consumed = CBPREPACK ;
    Where = pApiMessage->ApiMessage.bData ;
    pArgs->Sid = (PVOID) (Where - (PUCHAR) pApiMessage );

    Sid = (PSID) AccountDomain ;
    RtlCopyMemory(
        Sid,
        LsapAccountDomainMemberSid,
        RtlLengthSid( LsapAccountDomainMemberSid ) );

    //
    // The global LsapAccountDomainMemberSid is always of the form S-1-5-15-x-y-z-0
    // the 'if' statement below should always evaluate to true, and proceed
    // to whack off the trailing zero
    //

    if ( *RtlSubAuthoritySid(Sid, *RtlSubAuthorityCountSid(Sid) - 1) == 0 )
    {
        *RtlSubAuthorityCountSid( Sid ) = *RtlSubAuthorityCountSid( Sid ) - 1 ;
    }

    if ( Consumed > SECURITY_MAX_SID_SIZE )
    {
        Consumed = SECURITY_MAX_SID_SIZE;
    }

    if ( CreateWellKnownSid(
            pArgs->SidType,
            Sid,
            (PSID) Where,
            &Consumed ) )
    {
        scApiRet = STATUS_SUCCESS ;
    }
    else
    {
        Consumed = 0 ;
        scApiRet = STATUS_INVALID_PARAMETER ;
    }

    //
    // Reset the reply flags:
    //
    pApiMessage->ApiMessage.Args.SpmArguments.fAPI &= KLPC_FLAG_RESET ;

    pApiMessage->pmMessage.u1.s1.DataLength = LPC_DATA_LENGTH( Consumed );
    pApiMessage->pmMessage.u1.s1.TotalLength = LPC_TOTAL_LENGTH( Consumed );

    pApiMessage->ApiMessage.scRet = scApiRet;

    if (FAILED(pApiMessage->ApiMessage.scRet))
    {
        pApiMessage->ApiMessage.Args.SpmArguments.fAPI |= SPMAPI_FLAG_ERROR_RET;
    }

    return(S_OK);
}

//+---------------------------------------------------------------------------
//
//  Function:   LsapClientCallback
//
//  Synopsis:   Client Callback.
//
//  Arguments:  [Session]   --
//              [Type]      --
//              [Function]  --
//              [Argument1] --
//              [Argument2] --
//              [Input]     --
//              [Output]    --
//
//  History:    12-09-97   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
NTSTATUS
LsapClientCallback(
    PSession Session,
    ULONG   Type,
    PVOID   Function,
    PVOID   Argument1,
    PVOID   Argument2,
    PSecBuffer Input,
    PSecBuffer Output
    )
{
    PSPM_LPC_MESSAGE    Message ;
    NTSTATUS Status ;
    SPMCallbackAPI * Args ;
    PSPM_LPC_MESSAGE    ReplyTo ;
    PVOID ClientBuffer ;
    PLSA_CALL_INFO CallInfo ;

    CallInfo = LsapGetCurrentCall();

    if ( !CallInfo )
    {
        return STATUS_INVALID_PARAMETER ;
    }

    ReplyTo = CallInfo->Message ;

    if ( !ReplyTo )
    {
        return STATUS_INVALID_PARAMETER ;
    }

    SafeAllocaAllocate(Message, sizeof( SPM_LPC_MESSAGE ));

    if ( !Message )
    {
        return SEC_E_INSUFFICIENT_MEMORY ;
    }

//    DebugLog(( DEB_TRACE_LPC, "Calling back on LPC message %x\n",
//            ReplyTo->pmMessage.MessageId ));

    PREPARE_MESSAGE_EX( (*Message), Callback, SPMAPI_FLAG_CALLBACK, 0 );

    Message->pmMessage = ReplyTo->pmMessage ;
    Message->pmMessage.u1.s1.DataLength = LPC_DATA_LENGTH( 0 );
    Message->pmMessage.u1.s1.TotalLength = LPC_TOTAL_LENGTH( 0 );

    Args = LPC_MESSAGE_ARGS( (*Message), Callback );

    Args->Type = Type ;
    Args->CallbackFunction = Function ;
    Args->Argument1 = Argument1 ;
    Args->Argument2 = Argument2 ;

    if ( Input->pvBuffer )
    {
        Status = LsapWriteClientBuffer( Input, &Args->Input );

        if ( !NT_SUCCESS( Status ) )
        {
            SafeAllocaFree( Message );

            return Status ;
        }
    }
    else
    {
        Args->Input.BufferType = SECBUFFER_EMPTY ;
        Args->Input.cbBuffer = 0 ;
        Args->Input.pvBuffer = NULL ;
    }

    ClientBuffer = Args->Input.pvBuffer ;

    if ( CallInfo->InProcCall )
    {
        //
        // Inproc Callback!
        //

        Status = DllCallbackHandler( Message );
    }
    else
    {
        DsysAssert( Session->hPort );

        Status = NtRequestWaitReplyPort( Session->hPort,
                                         (PPORT_MESSAGE) Message,
                                         (PPORT_MESSAGE) Message );
    }

    if ( !NT_SUCCESS( Status ) )
    {
        SafeAllocaFree( Message );

        return Status ;
    }

    if ( ClientBuffer )
    {
        LsapFreeClientBuffer( NULL, ClientBuffer );
    }

    *Output = Args->Output ;

    Status = Message->ApiMessage.scRet ;

    SafeAllocaFree( Message );

    return Status ;
}



//+---------------------------------------------------------------------------
//
//  Function:   LsapShutdownInprocDll
//
//  Synopsis:   Shuts down the inproc secur32 DLL
//
//  History:    11-04-98   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
VOID
LsapShutdownInprocDll(
    VOID
    )
{
    SPM_LPC_MESSAGE LocalMessage ;
    PSPM_LPC_MESSAGE    Message ;
    SPMCallbackAPI * Args ;

    Message = &LocalMessage;

    PREPARE_MESSAGE_EX( (*Message), Callback, SPMAPI_FLAG_CALLBACK, 0 );

    Args = LPC_MESSAGE_ARGS( (*Message), Callback );

    Args->Type = SPM_CALLBACK_INTERNAL ;
    Args->CallbackFunction = NULL ;
    Args->Argument1 = (PVOID) SPM_CALLBACK_SHUTDOWN ;
    Args->Argument2 = 0 ;

    if ( DllCallbackHandler )
    {
        (void) DllCallbackHandler( Message );
    }

}

//+-------------------------------------------------------------------------
//
//  Function:   DispatchAPI()
//
//  Synopsis:   Dispatches API requests
//
//  Effects:
//
//  Arguments:  pApiMessage - Input message
//              pApiMessage   - Output message
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//--------------------------------------------------------------------------

extern "C"
NTSTATUS
DispatchAPI(PSPM_LPC_MESSAGE  pApiMessage)
{
    NTSTATUS scRet;
    PSession        pSession ;

    pSession = GetCurrentSession();

    DebugLog((DEB_TRACE,"[%x] LpcDispatch: dispatching %s (%x)\n",
                    pSession->dwProcessID, ApiLabel(pApiMessage->ApiMessage.dwAPI),
                    pApiMessage->ApiMessage.dwAPI));



    scRet = 0;


    if ((pApiMessage->ApiMessage.dwAPI >= LsapAuLookupPackageApi) &&
        (pApiMessage->ApiMessage.dwAPI < SPMAPI_MaxApiNumber) &&
        (LpcDispatchTable[pApiMessage->ApiMessage.dwAPI] != NULL) )
    {
        if ( !ShutdownBegun )
        {
            scRet = LpcDispatchTable[pApiMessage->ApiMessage.dwAPI](pApiMessage);

            //
            // BUGBUG: If scRet is not STATUS_SUCCESS, the error code gets dropped
            //
        }
        else
        {
            pApiMessage->ApiMessage.scRet = STATUS_SHUTDOWN_IN_PROGRESS;
        }

        //
        // Shutdown may have been initiated prior or during a call in progress.
        // If the call failed, we always return an error code indicating that
        // shutdown was invoked.  This avoids returning random error codes
        // that can result from calls failing due to async shutdown activities.
        //

        if( ShutdownBegun && !NT_SUCCESS(pApiMessage->ApiMessage.scRet) )
        {
            scRet = STATUS_SHUTDOWN_IN_PROGRESS;
            pApiMessage->ApiMessage.Args.SpmArguments.fAPI |= SPMAPI_FLAG_ERROR_RET;
            pApiMessage->ApiMessage.scRet = scRet ;
        }

        //
        // Do some checking to see if we're getting pounded by an agressive
        // app.  NOTE:  This is not MT safe (counters are not interlocked,
        // resets are not protected).  This is merely an optimization to try
        // and service clients with dedicated threads.  The counter may not
        // be precise - them's the breaks.
        //

        pSession->CallCount++ ;

        if ( pSession->Tick + 5000 < GetTickCount() )
        {
            //
            // Ok, in a minimum five second interval, did more than, say, 50
            // requests come in.  If so, set a flag indicating that the client
            // should request a workqueue.
            //

            if ( pSession->CallCount > 50 )
            {
                if (pApiMessage->ApiMessage.dwAPI > LsapAuMaxApiNumber )
                {
                    pApiMessage->ApiMessage.Args.SpmArguments.fAPI |= SPMAPI_FLAG_GETSTATE ;
                }
            }
            pSession->CallCount = 0;
            pSession->Tick = GetTickCount();
        }

    }
    else
    {
        DebugLog((DEB_ERROR, "[%x] Dispatch:  Unknown API code %d\n",
                        pSession->dwProcessID, pApiMessage->ApiMessage.dwAPI));

        pApiMessage->ApiMessage.Args.SpmArguments.fAPI |= SPMAPI_FLAG_ERROR_RET;

        pApiMessage->ApiMessage.scRet = SEC_E_UNSUPPORTED_FUNCTION;
    }

    DebugLog((DEB_TRACE, "[%x] LpcDispatch:  retcode = %x\n", pSession->dwProcessID, pApiMessage->ApiMessage.scRet));


    return(S_OK);
}

VOID
LsapInitializeCallInfo(
    PLSA_CALL_INFO CallInfo,
    BOOL InProcess
    )
{
    PLSA_CALL_INFO OriginalCall ;

    OriginalCall = LsapGetCurrentCall() ;

    ZeroMemory( CallInfo, sizeof( LSA_CALL_INFO ) );

    CallInfo->PreviousCall = OriginalCall ;

    CallInfo->InProcCall = InProcess ;

    CallInfo->CallInfo.ProcessId = HandleToUlong(NtCurrentTeb()->ClientId.UniqueProcess) ;
    CallInfo->CallInfo.ThreadId = HandleToUlong(NtCurrentTeb()->ClientId.UniqueThread) ;

    CallInfo->CallInfo.Attributes = 0 ;
    CallInfo->Allocs = 0 ;

    CallInfo->LogContext = NULL ;
}

NTSTATUS
LsapBuildCallInfo(
    PSPM_LPC_MESSAGE    pApiMessage,
    PLSA_CALL_INFO CallInfo,
    PHANDLE Impersonated,
    PSession * NewSession,
    PSession * OldSession
    )
{
    NTSTATUS scRet ;
    BOOL Recurse = FALSE ;
    HANDLE ImpersonatedToken ;
    PSession pOldSession ;
    PSession pSession ;
    PLSA_CALL_INFO OriginalCall ;

    OriginalCall = LsapGetCurrentCall() ;

    LsapInitializeCallInfo( CallInfo,
                            TRUE );

    //
    // Only copy out the IP address from "new" clients (vs. clients compiled using a version
    // of lsadll.lib from a previous OS release that didn't have this field).
    //

    if ( pApiMessage->ApiMessage.dwAPI == LsapAuLogonUserApi
          &&
         pApiMessage->pmMessage.u1.s1.DataLength == LSAP_AU_DATA_LENGTH(sizeof(LSAP_LOGON_USER_ARGS)))
    {
        RtlCopyMemory(CallInfo->IpAddress,
                      pApiMessage->ApiMessage.Args.LsaArguments.LogonUser.IpAddress,
                      LSAP_ADDRESS_LENGTH);
    }
    else if ( pApiMessage->ApiMessage.dwAPI == SPMAPI_AcceptContext )
    {
        RtlCopyMemory(CallInfo->IpAddress,
                      pApiMessage->ApiMessage.Args.SpmArguments.API.AcceptContext.IpAddress,
                      LSAP_ADDRESS_LENGTH);
    }

    //
    // Save away who we were impersonating
    //

    scRet = NtOpenThreadToken(
                NtCurrentThread(),
                TOKEN_IMPERSONATE | TOKEN_QUERY | TOKEN_QUERY_SOURCE,
                TRUE,
                &ImpersonatedToken
                );
    if (!NT_SUCCESS(scRet))
    {
        if (scRet != STATUS_NO_TOKEN)
        {
            return(scRet);
        }
        ImpersonatedToken = NULL ;

        scRet = STATUS_SUCCESS ;
    }

    *Impersonated = ImpersonatedToken ;

    CallInfo->InProcToken = ImpersonatedToken ;
    CallInfo->Message = pApiMessage ;

    //
    // Check to see if we're recursing:
    //
    if ( OriginalCall &&
         OriginalCall->InProcCall &&
         pApiMessage &&
         OriginalCall->Message )
    {
        if ( OriginalCall->Message->ApiMessage.dwAPI == pApiMessage->ApiMessage.dwAPI )
        {
            //
            // Same call.  Since they're both inproc, the pointers
            // are valid.  Compare the target strings
            //

            if ( pApiMessage->ApiMessage.dwAPI == SPMAPI_InitContext )
            {
                Recurse = (RtlCompareUnicodeString(
                            &pApiMessage->ApiMessage.Args.SpmArguments.API.InitContext.ssTarget,
                            &OriginalCall->Message->ApiMessage.Args.SpmArguments.API.InitContext.ssTarget,
                            TRUE ) == 0) ;
            }
            else if( pApiMessage->ApiMessage.dwAPI == LsapAuCallPackageApi ) 
            {
                Recurse = TRUE;
            }
        }
    }

    if ( Recurse )
    {
        DebugLog(( DEB_ERROR, "Recursive call\n" ));
        CallInfo->CallInfo.Attributes |= SECPKG_CALL_RECURSIVE ;
    }

    pOldSession = GetCurrentSession();

    pSession = pDefaultSession ;

    CallInfo->Session = pSession ;

    SpmpReferenceSession( pSession );

    *NewSession = pSession ;
    *OldSession = pOldSession ;

    return scRet ;

}

extern "C"
NTSTATUS
InitializeDirectDispatcher(
    VOID
    )
{
    InternalApiLog = ApiLogCreate( 0 );

    if ( InternalApiLog )
    {
        return STATUS_SUCCESS ;
    }

    return STATUS_UNSUCCESSFUL ;
}

//+---------------------------------------------------------------------------
//
//  Function:   DispatchAPIDirect
//
//  Synopsis:   Dispatcher to be called from security.dll when in process.
//
//  Arguments:  [pApiMessage] --
//
//  History:    9-13-96   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
NTSTATUS
SEC_ENTRY
DispatchAPIDirect(
    PSPM_LPC_MESSAGE    pApiMessage)
{
    NTSTATUS scRet;
    PSession    pOldSession;
    PSession    pSession;
    PVOID   DsaState ;
    HANDLE ImpersonatedToken = NULL;
    ULONG TokenSize = sizeof(HANDLE);
    LSA_CALL_INFO CallInfo ;
    PLSA_CALL_INFO OriginalCall ;
    ULONG_PTR OriginalPackageId;
    PLSAP_API_LOG_ENTRY Entry ;

    //
    // save off the current package hints to allow recursion in process.
    //

    OriginalCall = LsapGetCurrentCall() ;
    OriginalPackageId = GetCurrentPackageId();

    pApiMessage->pmMessage.MessageId = InterlockedIncrement( &InternalMessageId );

    Entry = ApiLogAlloc( InternalApiLog );

    scRet = LsapBuildCallInfo(
                pApiMessage,
                &CallInfo,
                &ImpersonatedToken,
                &pSession,
                &pOldSession );


    if ( !NT_SUCCESS( scRet ) )
    {
        return scRet ;
    }

    DBG_DISPATCH_PROLOGUE_EX( Entry, pApiMessage, CallInfo );

    LsapSetCurrentCall( &CallInfo );

    SetCurrentSession( pSession );


    if ( GetDsaThreadState )
    {
        DsaState = GetDsaThreadState();
    }
    else
    {
        DsaState = NULL ;
    }

    DebugLog((DEB_TRACE,"[%x] DispatchAPIDirect: dispatching %s (%d)\n",
                    pSession->dwProcessID, ApiLabel(pApiMessage->ApiMessage.dwAPI),
                    pApiMessage->ApiMessage.dwAPI));


    scRet = 0;

    if ((pApiMessage->ApiMessage.dwAPI >= LsapAuLookupPackageApi) &&
        (pApiMessage->ApiMessage.dwAPI < SPMAPI_MaxApiNumber) &&
        (LpcDispatchTable[pApiMessage->ApiMessage.dwAPI] != NULL) )
    {

        scRet = LpcDispatchTable[pApiMessage->ApiMessage.dwAPI](pApiMessage);

    }
    else
    {
        DebugLog((DEB_ERROR, "[%x] Dispatch:  Unknown API code %x\n", pSession->dwProcessID, pApiMessage->ApiMessage.dwAPI));
        pApiMessage->ApiMessage.Args.SpmArguments.fAPI |= SPMAPI_FLAG_ERROR_RET;
        pApiMessage->ApiMessage.scRet = SEC_E_UNSUPPORTED_FUNCTION;
    }

    DebugLog((DEB_TRACE, "[%x] DispatchAPIDirect:  retcode = %x\n", pSession->dwProcessID, pApiMessage->ApiMessage.scRet));

    if ( DsaState )
    {
        RestoreDsaThreadState( DsaState );
    }

    if ( pOldSession != pSession )
    {
        SetCurrentSession( pOldSession );
    }

    DBG_DISPATCH_POSTLOGUE( ULongToPtr( pApiMessage->ApiMessage.scRet ),
                            pApiMessage->ApiMessage.dwAPI );

    SpmpDereferenceSession( pSession );

    SetCurrentPackageId( OriginalPackageId );

    LsapSetCurrentCall( OriginalCall );

    (void) NtSetInformationThread(
                NtCurrentThread(),
                ThreadImpersonationToken,
                (PVOID) &ImpersonatedToken,
                sizeof(HANDLE)
                );

    if ( ImpersonatedToken )
    {
        NtClose( ImpersonatedToken );
    }

    return( SEC_E_OK );

}



//+---------------------------------------------------------------------------
//
//  Function:   LpcLsaPolicyChangeNotify
//
//  Synopsis:   Lpc stub for LsaPolicyChangeNotify
//
//  Arguments:  [pApiMessage] --
//
//  History:    06-05-98   MacM     Created
//
//  Notes:
//
//----------------------------------------------------------------------------
NTSTATUS
LpcLsaPolicyChangeNotify(
    PSPM_LPC_MESSAGE    pApiMessage
    )
{
    SPMLsaPolicyChangeNotifyAPI * Args = &pApiMessage->ApiMessage.Args.SpmArguments.API.LsaPolicyChangeNotify;
    NTSTATUS Status = STATUS_SUCCESS;
    HANDLE LocalHandle = NULL;
    PSession Session;

    HANDLE PassedHandle = ( HANDLE ) Args->EventHandle;    // extract the handle and put it
                                                           // correctly sized variable

    Session = GetCurrentSession();

    Status = CheckCaller( Session );

    if ( !NT_SUCCESS( Status ) ) {

        DebugLog(( DEB_ERROR, "CheckCaller returned 0x%lx\n", Status ));

        return( Status );
    }

    if ( Args->Register ) {

        //
        // Duplicate the handle
        //

        Status = NtDuplicateObject( Session->hProcess,
                                    PassedHandle,
                                    NtCurrentProcess(),
                                    &LocalHandle,
                                    0,
                                    0,
                                    DUPLICATE_SAME_ACCESS );
    }

    //
    // Now, the notify
    //
    if (NT_SUCCESS( Status )) {

        Status = LsapNotifyProcessNotificationEvent( Args->NotifyInfoClass,
                                                     LocalHandle,
                                                     GetCurrentSession()->dwProcessID,
                                                     PassedHandle,
                                                     Args->Register );

        if ( NT_SUCCESS( Status )) {
            // Indicate that we've successfully registered the handle
            LocalHandle = NULL;
        }

        //
        // Since we duplicated the handle in our namespace, if we fail to register it,
        // make sure we close it
        //
        if ( LocalHandle != NULL ) {
            NtClose( LocalHandle );
        }
    }

    pApiMessage->ApiMessage.scRet = Status;

    return( Status );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\base\lsa\server\lsarpc_s_stub.c ===
#include "lsarpc_s.c"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\base\lsa\server\lsaprgma.h ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    lsaprgma.h

Abstract:

    This file contains compiler pragmas to disable specific warnings to
    let the LSA compile at warning level 4

Author:

    Jonathan Schwartz (jschwart)  25-Apr-2000

Environment:

    User Mode -Win32

Revision History:

    25-Apr-2000
        created

--*/

// Unreferenced formal parameter

#pragma warning (disable: 4100)

// Named type definition in parentheses

#pragma warning (disable: 4115)

// Conditional expression is constant

#pragma warning (disable: 4127)

// Zero-sized array in struct/union

#pragma warning (disable: 4200)

// Nameless struct/union

#pragma warning (disable: 4201)

// Redefined extern to static

#pragma warning (disable: 4211)

// Bit field types other than int

#pragma warning (disable: 4214)

// Address of dllimport is not static

#pragma warning (disable: 4232)

// Cast truncates constant value

#pragma warning (disable: 4310)

// Structure was padded due to __declspec(align())

#pragma warning (disable: 4324)

// LHS indirection alignment greater than argument alignment

#pragma warning (disable: 4327)

// Pointer indirection alignment greater than argument alignment

#pragma warning (disable: 4328)

// Removal of unused inline functions

#pragma warning (disable: 4514)

// Assignment within conditional expression

#pragma warning (disable: 4706)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\base\lsa\server\lsads.h ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    lsads.h

Abstract:

    Private macros/definitions/prototypes for implementing portions of the LSA store
    in the DS and in the registry, simultaneously

Author:

    Mac McLain          (MacM)       Jan 17, 1997

Environment:

    User Mode

Revision History:

--*/

#ifndef __LSADS_H__
#define __LSADS_H__

#include <ntdsa.h>
#include <dsysdbg.h>
#include <safelock.h>

#if DBG == 1

    #ifdef ASSERT
        #undef ASSERT
    #endif

    #define ASSERT  DsysAssert

    #define DEB_UPGRADE     0x10
    #define DEB_POLICY      0x20
    #define DEB_FIXUP       0x80
    #define DEB_NOTIFY      0x100
    #define DEB_DSNOTIFY    0x200
    #define DEB_FTRACE      0x400
    #define DEB_LOOKUP      0x800
    #define DEB_HANDLE      0x1000
    #define DEB_FTINFO      0x2000
    #define DEB_SIDFILTER   0x4000 

#ifdef __cplusplus
extern "C" {
#endif // __cplusplus

    DECLARE_DEBUG2( LsaDs )

#ifdef __cplusplus
}
#endif // __cplusplus

    #define LsapDsDebugOut( args ) LsaDsDebugPrint args

    #define LsapEnterFunc( x )                                              \
    LsaDsDebugPrint( DEB_FTRACE, "0x%lx: Entering %s\n", GetCurrentThreadId(), x );

    #define LsapExitFunc( x, y )                                            \
    LsaDsDebugPrint( DEB_FTRACE, "0x%lx: Leaving %s: 0x%lx\n", GetCurrentThreadId(), x, y );

#else

    #define LsapDsDebugOut(args)
    #define LsapEnterFunc( x )
    #define LsapExitFunc( x, y )

#endif  // DBG


//
// These function prototypes control how the Ds transactioning is done.  In
// the Ds case, the pointers are initialized to routines that actually do
// transactioning.  In the non-Ds case, they point to dummy rountines that
// do nothing.
//

typedef NTSTATUS ( *pfDsOpenTransaction ) ( ULONG );
typedef NTSTATUS ( *pfDsApplyTransaction ) ( ULONG );
typedef NTSTATUS ( *pfDsAbortTransaction ) ( ULONG );

//
// Ds functions that behave differently for the Ds and non-Ds case exist
// in this function table.
//
typedef struct _LSADS_DS_FUNC_TABLE {

    pfDsOpenTransaction     pOpenTransaction;
    pfDsApplyTransaction    pApplyTransaction;
    pfDsAbortTransaction    pAbortTransaction;

} LSADS_DS_FUNC_TABLE, *PLSADS_DS_FUNC_TABLE;

typedef struct _LSADS_DS_SYSTEM_CONTAINER_ITEMS {

    PDSNAME TrustedDomainObject;
    PDSNAME SecretObject;

} LSADS_DS_SYSTEM_CONTAINER_ITEMS, *PLSADS_DS_SYSTEM_CONTAINER_ITEMS;

//
// Basic LsaDs information structure
//

typedef struct _LSADS_DS_STATE_INFO {

    PDSNAME DsRoot;                 // DSNAME of the root of the Ds
    PDSNAME DsPartitionsContainer;  // DSNAME of the partitions container
    PDSNAME DsSystemContainer;      // DSNAME of the system container
    PDSNAME DsConfigurationContainer;   // DSNAME of the configuration container

    ULONG   DsDomainHandle;         // DS Handle of the domain
    LSADS_DS_FUNC_TABLE DsFuncTable;    // Function table for Ds specific
                                        // functions
    LSADS_DS_SYSTEM_CONTAINER_ITEMS SystemContainerItems;
    PVOID   SavedThreadState;       // Results from THSave
    BOOLEAN DsTransactionSave;
    BOOLEAN DsTHStateSave;
    BOOLEAN DsOperationSave;
    BOOLEAN WriteLocal;             // Can we write to the registry?
    BOOLEAN UseDs;                  // Is the Ds active?
    BOOLEAN FunctionTableInitialized;   // Is the function table initialized
    BOOLEAN DsInitializedAndRunning;    // Has the Ds started
    BOOLEAN Nt4UpgradeInProgress;       // Is this the case of an upgrade from NT4

} LSADS_DS_STATE_INFO, *PLSADS_DS_STATE_INFO;

typedef struct _LSADS_PER_THREAD_INFO {

    BOOLEAN SavedTransactionValid;
    ULONG UseCount;
    ULONG DsThreadStateUseCount;
    ULONG DsTransUseCount;
    ULONG DsOperationCount;
    PVOID SavedThreadState;
    PVOID InitialThreadState;
    ULONG OldTrustDirection;
    ULONG OldTrustType;

} LSADS_PER_THREAD_INFO, *PLSADS_PER_THREAD_INFO;

#if DBG
typedef struct _LSADS_THREAD_INFO_NODE {
    PLSADS_PER_THREAD_INFO ThreadInfo;
    ULONG ThreadId;
} LSADS_THREAD_INFO_NODE, *PLSADS_THREAD_INFO_NODE;

#define LSAP_THREAD_INFO_LIST_MAX    15
extern LSADS_THREAD_INFO_NODE LsapDsThreadInfoList[ LSAP_THREAD_INFO_LIST_MAX ];
extern SAFE_RESOURCE LsapDsThreadInfoListResource;
#endif

//
// Extern definitions
//
extern LSADS_DS_STATE_INFO LsaDsStateInfo;

#ifdef __cplusplus
extern "C" {
#endif // __cplusplus

extern DWORD LsapDsThreadState;

#ifdef __cplusplus
}
#endif // __cplusplus

//
// Implemented as a macro for performance reasons
//
// PLSADS_PER_THREAD_INFO
// LsapQueryThreadInfo(
//    VOID
//    );
#define LsapQueryThreadInfo( )  TlsGetValue( LsapDsThreadState )

VOID
LsapDsDebugInitialize(
    VOID
    );

//
// Registry specific functions
//
NTSTATUS
LsapRegReadObjectSD(
    IN  LSAPR_HANDLE            ObjectHandle,
    OUT PSECURITY_DESCRIPTOR   *ppSD
    );

NTSTATUS
LsapRegGetPhysicalObjectName(
    IN PLSAP_DB_OBJECT_INFORMATION ObjectInformation,
    IN PUNICODE_STRING  LogicalNameU,
    OUT OPTIONAL PUNICODE_STRING PhysicalNameU
    );

NTSTATUS
LsapRegOpenObject(
    IN LSAP_DB_HANDLE  ObjectHandle,
    IN ULONG  OpenMode,
    OUT PVOID  *pvKey
    );

NTSTATUS
LsapRegOpenTransaction(
    );

NTSTATUS
LsapRegApplyTransaction(
    );

NTSTATUS
LsapRegAbortTransaction(
    );

NTSTATUS
LsapRegCreateObject(
    IN PUNICODE_STRING  ObjectPath,
    IN LSAP_DB_OBJECT_TYPE_ID   ObjectType
    );

NTSTATUS
LsapRegDeleteObject(
    IN PUNICODE_STRING  ObjectPath
    );

NTSTATUS
LsapRegWriteAttribute(
    IN PUNICODE_STRING  AttributePath,
    IN PVOID            pvAttribute,
    IN ULONG            AttributeLength
    );

NTSTATUS
LsapRegDeleteAttribute(
    IN PUNICODE_STRING  AttributePath,
    IN BOOLEAN DeleteSecurely,
    IN ULONG AttributeLength
    );

NTSTATUS
LsapRegReadAttribute(
    IN LSAPR_HANDLE ObjectHandle,
    IN PUNICODE_STRING AttributeName,
    IN OPTIONAL PVOID AttributeValue,
    IN OUT PULONG AttributeValueLength
    );

//
// Counterpart Ds functions
//
NTSTATUS
LsapDsReadObjectSD(
    IN  LSAPR_HANDLE            ObjectHandle,
    OUT PSECURITY_DESCRIPTOR   *ppSD
    );

NTSTATUS
LsapDsGetPhysicalObjectName(
    IN PLSAP_DB_OBJECT_INFORMATION ObjectInformation,
    IN BOOLEAN DefaultName,
    IN PUNICODE_STRING  LogicalNameU,
    OUT OPTIONAL PUNICODE_STRING PhysicalNameU
    );

NTSTATUS
LsapDsOpenObject(
    IN LSAP_DB_HANDLE  ObjectHandle,
    IN ULONG  OpenMode,
    OUT PVOID  *pvKey
    );

NTSTATUS
LsapDsVerifyObjectExistenceByDsName(
    IN PDSNAME  DsName
    );

NTSTATUS
LsapDsOpenTransaction(
    IN ULONG Options
    );

//
// Assert that there is a DS transaction open
//
#define LsapAssertDsTransactionOpen() \
{ \
    PLSADS_PER_THREAD_INFO CurrentThreadInfo; \
    CurrentThreadInfo = LsapQueryThreadInfo(); \
                                               \
    ASSERT( CurrentThreadInfo != NULL );       \
    if ( CurrentThreadInfo != NULL ) {         \
        ASSERT( CurrentThreadInfo->DsTransUseCount > 0 ); \
    } \
}

NTSTATUS
LsapDsOpenTransactionDummy(
    IN ULONG Options
    );

NTSTATUS
LsapDsApplyTransaction(
    IN ULONG Options
    );

NTSTATUS
LsapDsApplyTransactionDummy(
    IN ULONG Options
    );

NTSTATUS
LsapDsAbortTransaction(
    IN ULONG Options
    );

NTSTATUS
LsapDsAbortTransactionDummy(
    IN ULONG Options
    );

NTSTATUS
LsapDsCreateObject(
    IN PUNICODE_STRING  ObjectPath,
    IN ULONG Flags,
    IN LSAP_DB_OBJECT_TYPE_ID   ObjectType
    );

NTSTATUS
LsapDsDeleteObject(
    IN PUNICODE_STRING  ObjectPath
    );

NTSTATUS
LsapDsWriteAttributes(
    IN PUNICODE_STRING  ObjectPath,
    IN PLSAP_DB_ATTRIBUTE Attributes,
    IN ULONG AttributeCount,
    IN ULONG Options
    );

NTSTATUS
LsapDsWriteAttributesByDsName(
    IN PDSNAME  ObjectPath,
    IN PLSAP_DB_ATTRIBUTE Attributes,
    IN ULONG AttributeCount,
    IN ULONG Options
    );

NTSTATUS
LsapDsReadAttributes(
    IN PUNICODE_STRING  ObjectPath,
    IN ULONG Options,
    IN OUT PLSAP_DB_ATTRIBUTE Attributes,
    IN ULONG AttributeCount
    );

NTSTATUS
LsapDsReadAttributesByDsName(
    IN PDSNAME  ObjectPath,
    IN ULONG Options,
    IN OUT PLSAP_DB_ATTRIBUTE Attributes,
    IN ULONG AttributeCount
    );

NTSTATUS
LsapDsRenameObject(
    IN PDSNAME OldObject,
    IN PDSNAME NewParent,
    IN ULONG AttrType,
    IN PUNICODE_STRING NewObject
    );

NTSTATUS
LsapDsDeleteAttributes(
    IN PUNICODE_STRING  ObjectPath,
    IN OUT PLSAP_DB_ATTRIBUTE Attributes,
    IN ULONG AttributeCount
    );

//
// Interesting or global functions
//
PVOID
LsapDsAlloc(
    IN  DWORD   dwLen
    );

VOID
LsapDsFree(
    IN  PVOID   pvMemory
    );

NTSTATUS
LsapDsInitializePromoteInterface(
    VOID
    );

BOOLEAN
LsapDsIsValidSid(
    IN PSID Sid,
    IN BOOLEAN DsSid
    );

NTSTATUS
LsapDsTruncateNameToFitCN(
    IN PUNICODE_STRING OriginalName,
    OUT PUNICODE_STRING TruncatedName
    );

BOOLEAN
LsapDsIsNtStatusResourceError(
    NTSTATUS NtStatus
    );

NTSTATUS
LsapDsReadObjectSDByDsName(
    IN  DSNAME* Object,
    OUT PSECURITY_DESCRIPTOR *pSD
    );

NTSTATUS
LsapDsGetDefaultSecurityDescriptor(
    IN ULONG ClassId,
    OUT PSECURITY_DESCRIPTOR *ppSD,
    OUT ULONG                *cbSD
    );

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\base\lsa\server\lsastr.h ===
#ifndef _LSASTR_H
#define _LSASTR_H

/*++

Copyright (c) 1999  Microsoft Corporation

Module Name:

    lsastr.h

Abstract:

    Common string operations.

Author:

    24-March-1999 kumarp

--*/

#ifdef __cplusplus
extern "C" {
#endif

VOID
LsapTruncateUnicodeString(
    IN OUT PUNICODE_STRING String,
    IN USHORT TruncateToNumChars);

BOOLEAN
LsapRemoveTrailingDot(
    IN OUT PUNICODE_STRING String,
    IN BOOLEAN AdjustLengthOnly);

#ifdef __cplusplus
}
#endif

#endif // _LSASTR_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\base\lsa\server\lsasrvmm.h ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    lsasrvmm.h

Abstract:

    Local Security Authority - Main Include File for Lsa Server Memory
                               Management Routines.

Author:

    Scott Birrell       (ScottBi)      February 29, 1992

Environment:

Revision History:

--*/

/////////////////////////////////////////////////////////////////////////////
//                                                                         //
// Free List Routines and Definitions                                      //
//                                                                         //
/////////////////////////////////////////////////////////////////////////////

#define LSAP_MM_MIDL                      ((ULONG)     0x00000001L)
#define LSAP_MM_HEAP                      ((ULONG)     0x00000002L)

//
// Options from LsapMmCleanupFreeList
//

#define LSAP_MM_FREE_BUFFERS              ((ULONG)     0x00000001L)

typedef struct _LSAP_MM_FREE_LIST_ENTRY {

    PVOID Buffer;
    ULONG Options;

} LSAP_MM_FREE_LIST_ENTRY, *PLSAP_MM_FREE_LIST_ENTRY;

typedef struct _LSAP_MM_FREE_LIST {

    ULONG UsedCount;
    ULONG MaxCount;
    PLSAP_MM_FREE_LIST_ENTRY Buffers;

} LSAP_MM_FREE_LIST, *PLSAP_MM_FREE_LIST;

#define LsapMmInitializeFreeListStatic( _list_, _buffer_ )                  \
(_list_)->UsedCount = 0;                                                    \
(_list_)->MaxCount = sizeof( _buffer_ ) / sizeof( LSAP_MM_FREE_LIST_ENTRY );\
(_list_)->Buffers = _buffer_;

NTSTATUS
LsapMmCreateFreeList(
    OUT PLSAP_MM_FREE_LIST FreeList,
    IN ULONG MaxEntries
    );

NTSTATUS
LsapMmAllocateMidl(
    IN PLSAP_MM_FREE_LIST FreeList,
    OUT PVOID *OutputBuffer,
    IN ULONG BufferLength
    );

VOID
LsapMmFreeLastEntry(
    IN PLSAP_MM_FREE_LIST FreeList
    );

VOID
LsapMmCleanupFreeList(
    IN PLSAP_MM_FREE_LIST FreeList,
    IN ULONG Options
    );

NTSTATUS
LsapRpcCopyUnicodeString(
    IN OPTIONAL PLSAP_MM_FREE_LIST FreeList,
    OUT PUNICODE_STRING DestinationString,
    IN PUNICODE_STRING SourceString
    );

NTSTATUS
LsapRpcCopyUnicodeStrings(
    IN OPTIONAL PLSAP_MM_FREE_LIST FreeList,
    IN ULONG Count,
    OUT PUNICODE_STRING *DestinationStrings,
    IN PUNICODE_STRING SourceStrings
    );

NTSTATUS
LsapRpcCopySid(
    IN OPTIONAL PLSAP_MM_FREE_LIST FreeList,
    OUT PSID *DestinationSid,
    IN PSID SourceSid
    );

NTSTATUS
LsapRpcCopyTrustInformation(
    IN OPTIONAL PLSAP_MM_FREE_LIST FreeList,
    OUT PLSAPR_TRUST_INFORMATION OutputTrustInformation,
    IN PLSAPR_TRUST_INFORMATION InputTrustInformation
    );

NTSTATUS
LsapRpcCopyTrustInformationEx(
    IN OPTIONAL PLSAP_MM_FREE_LIST FreeList,
    OUT PLSAPR_TRUSTED_DOMAIN_INFORMATION_EX OutputTrustInformation,
    IN PLSAPR_TRUSTED_DOMAIN_INFORMATION_EX InputTrustInformation
    );

/////////////////////////////////////////////////////////////////////////////
//                                                                         //
// Heap Routines                                                           //
//                                                                         //
/////////////////////////////////////////////////////////////////////////////


BOOLEAN
LsapHeapInitialize(
    IN BOOLEAN Server
    );

PVOID
LsapAllocateLsaHeap (
    IN ULONG Length
    );

VOID
LsapFreeLsaHeap (
    IN PVOID Base
    );

PVOID
NTAPI
LsapAllocatePrivateHeap (
    IN SIZE_T Length
    );

PVOID
NTAPI
LsapAllocatePrivateHeapNoZero(
    IN SIZE_T cbMemory
    );

VOID
NTAPI
LsapFreePrivateHeap (
    IN PVOID Base
    );

#define LsapGetCurrentHeap()    ((HANDLE) TlsGetValue( dwThreadHeap ))
#define LsapSetCurrentHeap(x)   TlsSetValue( dwThreadHeap, x )
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\base\lsa\server\lsastr.c ===
/*++

Copyright (c) 1999  Microsoft Corporation

Module Name:

    lsastr.c

Abstract:

    Common string operations.

Author:

    24-March-1999 kumarp

--*/

#include <lsapch2.h>

VOID
LsapTruncateUnicodeString(
    IN OUT PUNICODE_STRING String,
    IN USHORT TruncateToNumChars)
/*++

Routine Description:

    If a string is longer than TruncateToNumChars then truncate it
    to TruncateToNumChars.

Arguments:

    String - pointer to string

    TruncateToNumChars - number of chars to truncate to

Return Value:

    None

Notes:

    No memory (de)allocations are involved.

--*/
{
    USHORT TruncateToLength = TruncateToNumChars*sizeof(WCHAR);

    if (String->Length > TruncateToLength) {

        String->Length = TruncateToLength;
        String->Buffer[TruncateToNumChars] = UNICODE_NULL;
    }
}

BOOLEAN
LsapRemoveTrailingDot(
    IN OUT PUNICODE_STRING String,
    IN BOOLEAN AdjustLengthOnly)
/*++

Routine Description:

    If there is a '.' at the end of a string, remove it.

Arguments:

    String - pointer to unicode string

    AdjustLengthOnly - If TRUE only decrements the Length member of
        String otherwise replaces dot with UNICODE_NULL as well.

Return Value:

    TRUE if trailing dot was present, FALSE otherwise.

Notes:

--*/
{
    USHORT NumCharsInString;

    NumCharsInString = String->Length / sizeof(WCHAR);

    if (NumCharsInString &&
        (String->Buffer[NumCharsInString-1] == L'.')) {

        String->Length -= sizeof(WCHAR);
        if (!AdjustLengthOnly) {

            String->Buffer[NumCharsInString-1] = UNICODE_NULL;
        }

        return TRUE;
    }

    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\base\lsa\server\lsawow.h ===
/*++

copyright (c) 2000 Microsoft Corporation

Module Name:

    lsawow.h

Abstract:

    WOW64 structure/function definitions for the LSA server

Author:

    8-Nov-2000     JSchwart

Revision History:


--*/

#ifndef _LSAWOW_H
#define _LSAWOW_H

#if _WIN64

//
// WOW64 versions of public data structures.  These MUST be kept
// in sync with their public equivalents.
//

typedef struct _QUOTA_LIMITS_WOW64
{
    ULONG         PagedPoolLimit;
    ULONG         NonPagedPoolLimit;
    ULONG         MinimumWorkingSetSize;
    ULONG         MaximumWorkingSetSize;
    ULONG         PagefileLimit;
    LARGE_INTEGER TimeLimit;
}
QUOTA_LIMITS_WOW64, *PQUOTA_LIMITS_WOW64;

#endif  // _WIN64

#endif  // _LSAWOW_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\base\lsa\server\lsasrvp.h ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    lsasrvp.h

Abstract:

    LSA Subsystem - Private Includes for Server Side

    This file contains includes that are global to the Lsa Server Side

Author:

    Scott Birrell       (ScottBi)       January 22, 1992

Environment:

Revision History:

--*/

#ifndef _LSASRVP_
#define _LSASRVP_

#ifdef __cplusplus
extern "C" {
#endif

//
// The LSA Server Is UNICODE Based.  Define UNICODE before global includes
// so that it is defined before the TEXT macro.
//

#ifndef UNICODE

#define UNICODE

#endif // UNICODE

//
// Set the EXTERN macro so only one file allocates all the globals.
//

#ifdef ALLOC_EXTERN
#define EXTERN
#else
#define EXTERN extern
#endif // ALLOC_EXTERN

#include <lsacomp.h>
#include <wincred.h>
#include <alloca.h>
#include <malloc.h>


//
// The following come from \nt\private\inc
#include <align.h>
#include <samrpc.h>
#include <samsrv.h>
#include <samisrv.h>
#include <lsarpc.h>
#include <lsaisrv.h>
#include <nlrepl.h>
#include <seposix.h>

//
// The following all come from \nt\private\lsa\server
//

#include "lsasrvmm.h"
#include "au.h"
#include "db.h"
#include "adt.h"
#include "dblookup.h"
#include "lsads.h"
#include "lsads.h"
#include "lsastr.h"
#include "lsawow.h"


//////////////////////////////////////////////////////////////////////
//                                                                  //
// The following define controls the diagnostic capabilities that   //
// are built into LSA.                                              //
//                                                                  //
//////////////////////////////////////////////////////////////////////

#if DBG
#define LSAP_DIAGNOSTICS 1
#endif // DBG


//
// These definitions are useful diagnostics aids
//

#if LSAP_DIAGNOSTICS

//
// Diagnostics included in build
//

//
// Test for diagnostics enabled
//

#define IF_LSAP_GLOBAL( FlagName ) \
    if (LsapGlobalFlag & (LSAP_DIAG_##FlagName))

//
// Diagnostics print statement
//

#define LsapDiagPrint( FlagName, _Text_ )                               \
    IF_LSAP_GLOBAL( FlagName )                                          \
        DbgPrint _Text_


//
// Make sure no thread leaves with any open state
//

#define LSAP_TRACK_DBLOCK

#ifdef LSAP_TRACK_DBLOCK
#define LsarpReturnCheckSetup()  \
ULONG   __lsarpthreadusecountstart; \
{\
  PLSADS_PER_THREAD_INFO __lsarpCurrentThreadInfo = (PLSADS_PER_THREAD_INFO) LsapQueryThreadInfo() ;\
  if (__lsarpCurrentThreadInfo!=NULL)\
        __lsarpthreadusecountstart = __lsarpCurrentThreadInfo->UseCount;\
  else \
        __lsarpthreadusecountstart =0;\
}

#define LsarpReturnPrologue()    \
{\
    PLSADS_PER_THREAD_INFO __lsarpCurrentThreadInfoEnd =   (PLSADS_PER_THREAD_INFO)LsapQueryThreadInfo() ;\
    ULONG __lsarpthreadusecountend ; \
    if (__lsarpCurrentThreadInfoEnd!=NULL)\
            __lsarpthreadusecountend = __lsarpCurrentThreadInfoEnd->UseCount;\
    else\
        __lsarpthreadusecountend = 0;\
    ASSERT (__lsarpthreadusecountstart==__lsarpthreadusecountend);\
}

#else

#define LsarpReturnPrologue()
#define LsarpReturnCheckSetup()

#endif



#else

//
// No diagnostics included in build
//

//
// Test for diagnostics enabled
//

#define IF_LSAP_GLOBAL( FlagName ) if (FALSE)


//
// Diagnostics print statement (nothing)
//

#define LsapDiagPrint( FlagName, Text )     ;

#define LsarpReturnPrologue()
#define LsarpReturnCheckSetup()

#endif // LSAP_DIAGNOSTICS


//
// The following flags enable or disable various diagnostic
// capabilities within LSA.  These flags are set in
// LsapGlobalFlag
//
//      DB_LOOKUP_WORK_LIST - Display activities related to sid/name lookups.
//
//      AU_TRACK_THREADS - Display dynamic AU thread creation / deletion
//          information.
//
//      AU_MESSAGES - Display information related to the processing of
//          Authentication messages.
//
//      AU_LOGON_SESSIONS - Display information about the creation/deletion
//          of logon sessions within LSA.
//
//      DB_INIT - Display information about the initialization of LSA.
//

#define LSAP_DIAG_DB_LOOKUP_WORK_LIST       ((ULONG) 0x00000001L)
#define LSAP_DIAG_AU_TRACK_THREADS          ((ULONG) 0x00000002L)
#define LSAP_DIAG_AU_MESSAGES               ((ULONG) 0x00000004L)
#define LSAP_DIAG_AU_LOGON_SESSIONS         ((ULONG) 0x00000008L)
#define LSAP_DIAG_DB_INIT                   ((ULONG) 0x00000010L)





//////////////////////////////////////////////////////////////////////
//                                                                  //
// Other defines                                                    //
//                                                                  //
//////////////////////////////////////////////////////////////////////

//
// Maximum length of a SID in bytes
//

#define MAX_SID_LEN (sizeof(SID) + sizeof(ULONG) * SID_MAX_SUB_AUTHORITIES)

//
// Heap available for general use throughout LSA
//

EXTERN PVOID LsapHeap;

//
// LSA Private Global State Data Structure
//

typedef struct _LSAP_STATE {

    HANDLE LsaCommandPortHandle;
    HANDLE RmCommandPortHandle;
    HANDLE AuditLogFileHandle;
    HANDLE AuditLogSectionHandle;
    PVOID  AuditLogBaseAddress;
    ULONG  AuditLogViewSize;
    LARGE_INTEGER AuditLogInitSize;
    LARGE_INTEGER AuditLogMaximumSizeOfSection;
    OBJECT_ATTRIBUTES  AuditLogObjectAttributes;
    STRING AuditLogNameString;
    GENERIC_MAPPING GenericMapping;
    UNICODE_STRING SubsystemName;
    PRIVILEGE_SET Privileges;
    BOOLEAN GenerateOnClose;
    BOOLEAN SystemShutdownPending;

} LSAP_STATE, *PLSAP_STATE;

extern LSAP_STATE LsapState;

extern BOOLEAN LsapInitialized;

//
// Global handle to LSA's policy object.
// This handle is opened for trusted client.
//

extern LSAPR_HANDLE LsapPolicyHandle;

//
// LSA Server Command Dispatch Table Entry
//

typedef NTSTATUS (*PLSA_COMMAND_WORKER)(PLSA_COMMAND_MESSAGE, PLSA_REPLY_MESSAGE);

//
// LSA Client Control Block
//
// This structure contains context information relevant to a successful
// LsaOpenLsa call.
//

typedef struct _LSAP_CLIENT_CONTROL_BLOCK {
    HANDLE KeyHandle;           // Configuration Registry Key
    ACCESS_MASK GrantedAccess;  // Accesses granted to LSA Database Object
} LSAP_CLIENT_CONTROL_BLOCK, *PLSAP_CLIENT_CONTROL_BLOCK;


//
// LSA Privilege Pseudo-Object Types and Flags
//

// *********************** IMPORTANT NOTE ************************
//
// Privilege objects (privileges containing a list of users who have that
// privilge) are pseudo-objects that use the account objects as a backing
// stored.  There are currently no public interfaces to open a privilege
// object, so there need not be public access flags.
//

#define PRIVILEGE_VIEW      0x00000001L
#define PRIVILEGE_ADJUST    0x00000002L
#define PRIVILEGE_ALL       (STANDARD_RIGHTS_REQUIRED | \
                             PRIVILEGE_VIEW | \
                             PRIVILEGE_ADJUST)



//
// LSA API Error Handling Cleanup Flags
//
// These flags specify cleanup operations to be performed after an LSA
// API call has hit a fatal error.  They are passed in the ErrorCleanupFlags
// variable of the API or worker's error handling routine.
//

#define LSAP_CLEANUP_REVERT_TO_SELF        (0x00000001L)
#define LSAP_CLEANUP_CLOSE_LSA_HANDLE      (0x00000002L)
#define LSAP_CLEANUP_FREE_USTRING          (0x00000004L)
#define LSAP_CLEANUP_CLOSE_REG_KEY         (0x00000008L)
#define LSAP_CLEANUP_DELETE_REG_KEY        (0x00000010L)
#define LSAP_CLEANUP_DB_UNLOCK             (0x00000020L)

NTSTATUS
LsapRmInitializeServer(
    );

VOID
LsapRmServerThread(
    );

NTSTATUS
LsapRPCInit(
    );

BOOLEAN
LsapAuInit(       // Authentication initialization
    );

NTSTATUS
LsapDbInitializeRights(
    );

VOID
LsapDbCleanupRights(
    );

NTSTATUS
LsapCallRm(
    IN RM_COMMAND_NUMBER CommandNumber,
    IN OPTIONAL PVOID CommandParams,
    IN ULONG CommandParamsLength,
    OUT OPTIONAL PVOID ReplyBuffer,
    IN ULONG ReplyBufferLength
    );

NTSTATUS
LsapLogonSessionDeletedWrkr(
    IN PLSA_COMMAND_MESSAGE CommandMessage,
    OUT PLSA_REPLY_MESSAGE ReplyMessage
    );

NTSTATUS
LsapComponentTestWrkr(
    IN PLSA_COMMAND_MESSAGE CommandMessage,
    OUT PLSA_REPLY_MESSAGE ReplyMessage
    );

//
// Prototypes of RPC free routines used by LsaIFree.c
//

void _fgs__STRING (STRING  * _source);
void _fgs__LSAPR_SID_INFORMATION (LSAPR_SID_INFORMATION  * _source);
void _fgs__LSAPR_SID_ENUM_BUFFER (LSAPR_SID_ENUM_BUFFER  * _source);
void _fgs__LSAPR_ACCOUNT_INFORMATION (LSAPR_ACCOUNT_INFORMATION  * _source);
void _fgs__LSAPR_ACCOUNT_ENUM_BUFFER (LSAPR_ACCOUNT_ENUM_BUFFER  * _source);
void _fgs__LSAPR_UNICODE_STRING (LSAPR_UNICODE_STRING  * _source);
void _fgs__LSAPR_SECURITY_DESCRIPTOR (LSAPR_SECURITY_DESCRIPTOR  * _source);
void _fgs__LSAPR_SR_SECURITY_DESCRIPTOR (LSAPR_SR_SECURITY_DESCRIPTOR  * _source);
void _fgs__LSAPR_POLICY_PRIVILEGE_DEF (LSAPR_POLICY_PRIVILEGE_DEF  * _source);
void _fgs__LSAPR_PRIVILEGE_ENUM_BUFFER (LSAPR_PRIVILEGE_ENUM_BUFFER  * _source);
void _fgs__LSAPR_OBJECT_ATTRIBUTES (LSAPR_OBJECT_ATTRIBUTES  * _source);
void _fgs__LSAPR_CR_CIPHER_VALUE (LSAPR_CR_CIPHER_VALUE  * _source);
void _fgs__LSAPR_TRUST_INFORMATION (LSAPR_TRUST_INFORMATION  * _source);
void _fgs__LSAPR_TRUSTED_ENUM_BUFFER (LSAPR_TRUSTED_ENUM_BUFFER  * _source);
void _fgs__LSAPR_TRUSTED_ENUM_BUFFER_EX (LSAPR_TRUSTED_ENUM_BUFFER_EX  * _source);
void _fgs__LSAPR_REFERENCED_DOMAIN_LIST (LSAPR_REFERENCED_DOMAIN_LIST  * _source);
void _fgs__LSAPR_TRANSLATED_SIDS (LSAPR_TRANSLATED_SIDS  * _source);
void _fgs__LSAPR_TRANSLATED_NAME (LSAPR_TRANSLATED_NAME  * _source);
void _fgs__LSAPR_TRANSLATED_NAMES (LSAPR_TRANSLATED_NAMES  * _source);
void _fgs__LSAPR_POLICY_ACCOUNT_DOM_INFO (LSAPR_POLICY_ACCOUNT_DOM_INFO  * _source);
void _fgs__LSAPR_POLICY_PRIMARY_DOM_INFO (LSAPR_POLICY_PRIMARY_DOM_INFO  * _source);
void _fgs__LSAPR_POLICY_PD_ACCOUNT_INFO (LSAPR_POLICY_PD_ACCOUNT_INFO  * _source);
void _fgs__LSAPR_POLICY_REPLICA_SRCE_INFO (LSAPR_POLICY_REPLICA_SRCE_INFO  * _source);
void _fgs__LSAPR_POLICY_AUDIT_EVENTS_INFO (LSAPR_POLICY_AUDIT_EVENTS_INFO  * _source);
void _fgs__LSAPR_TRUSTED_DOMAIN_NAME_INFO (LSAPR_TRUSTED_DOMAIN_NAME_INFO  * _source);
void _fgs__LSAPR_TRUSTED_CONTROLLERS_INFO (LSAPR_TRUSTED_CONTROLLERS_INFO  * _source);
void _fgu__LSAPR_POLICY_INFORMATION (LSAPR_POLICY_INFORMATION  * _source, POLICY_INFORMATION_CLASS _branch);
void _fgu__LSAPR_POLICY_DOMAIN_INFORMATION (LSAPR_POLICY_DOMAIN_INFORMATION  * _source,
                                            POLICY_DOMAIN_INFORMATION_CLASS _branch);
void _fgu__LSAPR_TRUSTED_DOMAIN_INFO (LSAPR_TRUSTED_DOMAIN_INFO  * _source, TRUSTED_INFORMATION_CLASS _branch);

//
// Old worker prototypes - These are temporary
//

#define LsapComponentTestCommandWrkr LsapComponentTestWrkr
#define LsapWriteAuditMessageCommandWrkr LsapAdtWriteLogWrkr

NTSTATUS
ServiceInit (
    );

NTSTATUS
LsapInitLsa(
    );

BOOLEAN
LsapSeSetWellKnownValues(
    );

VOID
RtlConvertSidToText(
    IN PSID Sid,
    OUT PUCHAR Buffer
    );

ULONG
RtlSizeANSISid(
    IN PSID Sid
    );

NTSTATUS
LsapGetMessageStrings(
    LPVOID              Resource,
    DWORD               Index1,
    PUNICODE_STRING     String1,
    DWORD               Index2,
    PUNICODE_STRING     String2 OPTIONAL
    );


VOID
LsapLogError(
    IN OPTIONAL PUCHAR Message,
    IN NTSTATUS Status
    );

NTSTATUS
LsapWinerrorToNtStatus(
    IN DWORD WinError
    );

NTSTATUS
LsapNtStatusFromLastWinError( VOID );


NTSTATUS
LsapGetPrivilegesAndQuotas(
    IN SECURITY_LOGON_TYPE LogonType,
    IN ULONG IdCount,
    IN PSID_AND_ATTRIBUTES Ids,
    OUT PULONG PrivilegeCount,
    OUT PLUID_AND_ATTRIBUTES *Privileges,
    OUT PQUOTA_LIMITS QuotaLimits
    );


NTSTATUS
LsapQueryClientInfo(
    PTOKEN_USER *UserSid,
    PLUID AuthenticationId
    );


NTSTATUS
LsapGetAccountDomainInfo(
    PPOLICY_ACCOUNT_DOMAIN_INFO *PolicyAccountDomainInfo
    );

NTSTATUS
LsapOpenSam( VOID );

NTSTATUS
LsapOpenSamEx(
    BOOLEAN DuringStartup
    );

NTSTATUS
LsapNotifyProcessNotificationEvent(
    IN POLICY_NOTIFICATION_INFORMATION_CLASS InformationClass,
    IN HANDLE EventHandle,
    IN ULONG OwnerProcess,
    IN HANDLE OwnerEventHandle,
    IN BOOLEAN Register
    );



/////////////////////////////////////////////////////////////////////////
//                                                                     //
//      Shared Global Variables                                        //
//                                                                     //
/////////////////////////////////////////////////////////////////////////

//
// Handles used to talk to SAM directly.
// Also, a flag to indicate whether or not the handles are valid.
//


extern BOOLEAN LsapSamOpened;

extern SAMPR_HANDLE LsapAccountDomainHandle;
extern SAMPR_HANDLE LsapBuiltinDomainHandle;

//
// globals controlling logon parameters.
//

extern DWORD LsapGlobalRestrictNullSessions;
extern DWORD LsapGlobalRestrictAnonymous;
extern DWORD LsapGlobalSetAdminOwner;

#if LSAP_DIAGNOSTICS

//
// Used as a global diagnostics control flag within lsass.exe
//

extern ULONG LsapGlobalFlag;
#endif // LSAP_DIAGNOSTICS

//
// Fast version of NtQuerySystemTime
//

#define LsapQuerySystemTime( _Time ) GetSystemTimeAsFileTime( (LPFILETIME)(_Time) )

VOID
FixupEnvironment(
    VOID
    );

#ifdef __cplusplus
}
#endif

#endif // _LSASRVP_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\base\lsa\server\lsawmi.c ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name:

    LSAWMI.C
    
Abstract:

    Implement LSA Server event tracing by using WMI trace infrastructure. 
    
Author:

    16-March-1999 kumarp
    
Revision History:


--*/

#include <lsapch2.h>
#include <wmistr.h>
#define INITGUID
#include <lsawmi.h>



//
// Globals
//
ULONG       LsapEventTraceFlag = FALSE;
TRACEHANDLE LsapTraceRegistrationHandle = (TRACEHANDLE) 0;
TRACEHANDLE LsapTraceLoggerHandle = (TRACEHANDLE) 0;



//
// Forward declaration
// 

ULONG
LsapTraceControlCallBack(
    IN WMIDPREQUESTCODE RequestCode, 
    IN PVOID RequestContext, 
    IN OUT ULONG *InOutBufferSize, 
    IN OUT PVOID Buffer
    );

LPWSTR
LsapMakeNullTerminatedString(
    IN PUNICODE_STRING u
    );

//
// before you change the elements of the following structure,
// read notes in lsawmi.h file
//
TRACE_GUID_REGISTRATION LsapTraceGuids[] =
{
    {&LsapTraceEventGuid_QuerySecret,                 NULL},
    {&LsaTraceEventGuid_Close,                        NULL},
    {&LsaTraceEventGuid_OpenPolicy,                   NULL},
    {&LsaTraceEventGuid_QueryInformationPolicy,       NULL},
    {&LsaTraceEventGuid_SetInformationPolicy,         NULL},
    {&LsaTraceEventGuid_EnumerateTrustedDomains,      NULL},
    {&LsaTraceEventGuid_LookupNames,                  NULL},
    {&LsaTraceEventGuid_LookupSids,                   NULL},
    {&LsaTraceEventGuid_OpenTrustedDomain,            NULL},
    {&LsaTraceEventGuid_QueryInfoTrustedDomain,       NULL},
    {&LsaTraceEventGuid_SetInformationTrustedDomain,  NULL},
    {&LsaTraceEventGuid_QueryTrustedDomainInfoByName, NULL},
    {&LsaTraceEventGuid_SetTrustedDomainInfoByName,   NULL},
    {&LsaTraceEventGuid_EnumerateTrustedDomainsEx,    NULL},
    {&LsaTraceEventGuid_CreateTrustedDomainEx,        NULL},
    {&LsaTraceEventGuid_QueryDomainInformationPolicy, NULL},
    {&LsaTraceEventGuid_SetDomainInformationPolicy,   NULL},
    {&LsaTraceEventGuid_OpenTrustedDomainByName,      NULL},
    {&LsaTraceEventGuid_QueryForestTrustInformation,  NULL},
    {&LsaTraceEventGuid_SetForestTrustInformation,    NULL},
    {&LsaTraceEventGuid_LookupIsolatedNameInTrustedDomains, NULL},
};


#define LsapTraceGuidCount (sizeof(LsapTraceGuids) / sizeof(TRACE_GUID_REGISTRATION))

    

ULONG
_stdcall
LsapInitializeWmiTrace( LPVOID ThreadParams )
/*++    
Routine Description:

    Register WMI Trace Guids.
    This routine is called during LSA initialization. LSA gets initialized
    before WMI therefore we call this from a seaprate thread. This
    thread can then wait on WMI.
    
Parameters:

    ThreadParams - Currently ignored.
    
Reture Values:
    
    NTSTATUS - Standard Nt Result Code
    
--*/
{
    ULONG   Status = ERROR_SUCCESS;
    HMODULE hModule;
    TCHAR FileName[MAX_PATH+1];
    DWORD nLen = 0;

#define RESOURCE_NAME TEXT("LsaMofResource")
#define IMAGE_PATH    TEXT("lsass.exe")

    LsapEnterFunc("LsapInitializeWmiTrace");
    
    hModule = GetModuleHandle(IMAGE_PATH);
    if (hModule != NULL) {
        nLen = GetModuleFileName(hModule, FileName, MAX_PATH);
    }
    if (nLen == 0) {
        lstrcpy(FileName, IMAGE_PATH);
    }
    
    //
    // Register Trace GUIDs
    // 
    Status = RegisterTraceGuids(
                    LsapTraceControlCallBack, 
                    NULL, 
                    &LsapTraceControlGuid, 
                    LsapTraceGuidCount, 
                    LsapTraceGuids, 
                    FileName, 
                    RESOURCE_NAME, 
                    &LsapTraceRegistrationHandle);
                    
#if DBG
    if (Status != ERROR_SUCCESS)
    {
        DebugLog(( DEB_ERROR, "LsapInitializeWmiTrace failed: 0x%x\n", Status));
    }
#endif // DBG
    
    return Status;
}


ULONG
LsapTraceControlCallBack(
    IN WMIDPREQUESTCODE RequestCode, 
    IN PVOID RequestContext, 
    IN OUT ULONG *InOutBufferSize, 
    IN OUT PVOID Buffer
    )
/*++

Routine Description:

    Call back function called by the WMI module to enable or
    disable LSA tracing.

Arguments:

    RequestCode - WMI_ENABLE_EVENTS or WMI_DISABLE_EVENTS

    RequestContext - currently ignored

    InOutBufferSize - size of data returned by this call back.
        Currently always set to 0.

    Buffer - pointer to data received. In case of WMI_ENABLE_EVENTS,
        this is a pointer to the trace handle.

Return Value:

    Win32 error code.

Notes:

--*/
{
    ULONG   Status = ERROR_SUCCESS;
    
    LsapEnterFunc("LsapTraceControlCallBack");

    switch (RequestCode) 
    {
        case WMI_ENABLE_EVENTS:
        {
            LsapTraceLoggerHandle = GetTraceLoggerHandle(Buffer);
            LsapEventTraceFlag = TRUE;     // enable flag
            break; 
        }
    
        case WMI_DISABLE_EVENTS:
        {
            LsapTraceLoggerHandle = (TRACEHANDLE) 0;
            LsapEventTraceFlag = FALSE;     // disable flag
            break;
        }
        default:
        {
            Status = ERROR_INVALID_PARAMETER;
            break;
        }
    } 
    
    *InOutBufferSize = 0;
    
    return Status;
} 

NTSTATUS
LsapStartWmiTraceInitThread(void)
/*++

Routine Description:

    Start the thread that registers WMI trace guids.

Parameters:

    None

Return Values:

    NTSTATUS - Standard Nt Result Code

--*/
{
    NTSTATUS Status=STATUS_SUCCESS;
    HANDLE   ThreadHandle;
    ULONG    ThreadId = 0;
    ULONG    WinError;
    
    ThreadHandle = CreateThread(NULL,
                                0, 
                                LsapInitializeWmiTrace,
                                NULL,
                                0,
                                &ThreadId);
                                    
    if (NULL == ThreadHandle) 
    {
        Status = STATUS_UNSUCCESSFUL;
        WinError = GetLastError();
        DebugLog((DEB_ERROR, "Failed to create thread for LsapInitializeWmiTrace: 0x%x", WinError));
    }
    else
    {
        CloseHandle(ThreadHandle);
    }

    return Status;
}


VOID
LsapTraceEvent(
    IN ULONG WmiEventType, 
    IN LSA_TRACE_EVENT_TYPE LsaTraceEventType
    )

/*++

Routine Description:

    This routine will do a WMI event trace. 

Parameters:

    WmiEventType - Event Type, valid values are:
                   EVENT_TRACE_TYPE_START
                   EVENT_TRACE_TYPE_END
                   
    TraceGuid - Index in LsapTraceGuids[]                   
    
Return Values:

    None.

--*/
{
    LsapTraceEventWithData(WmiEventType,
                           LsaTraceEventType,
                           0,
                           NULL);

}

VOID
LsapTraceEventWithData(
    IN ULONG WmiEventType, 
    IN LSA_TRACE_EVENT_TYPE LsaTraceEventType,
    IN ULONG ItemCount,
    IN PUNICODE_STRING Items  OPTIONAL
    )

/*++

Routine Description:

    This routine will do a WMI event trace. 

Parameters:

    WmiEventType - Event Type, valid values are:
                   EVENT_TRACE_TYPE_START
                   EVENT_TRACE_TYPE_END
                   EVENT_TRACE_TYPE_INFO
                   
    TraceGuid - Index in LsapTraceGuids[]                   
    
    ItemCount - the number of elements in Items
    
    Items - an array of information.  The unicode strings don't have
            to represent strings -- can be binary data whose length
            is denoted by the Length field.

Return Values:

    None.

--*/

{
#if DBG
    ULONG WinError;
#endif    

    WCHAR       NullChar = UNICODE_NULL;
    PVOID       BuffersToFree[10];
    ULONG       BuffersToFreeCount = 0;
    ULONG       i;

    struct
    {
        EVENT_TRACE_HEADER  EventTrace;
        MOF_FIELD           EventInfo[2];
    } Event;
    
    //
    // Theoretically, only test LsapEventTraceFlag would be enough, since
    // LsapEventTraceFlag will remain FALSE in Registry Mode, because 
    // LsapInitializeTrace() will never been called in Registry Mode.
    // Thus nobody will change the value of LsapEventTraceFlag 
    // 
    if (!LsapEventTraceFlag) {
        return;
    }

    // 
    // Fill the event information. 
    // 
    ZeroMemory(&Event, sizeof(Event));
    Event.EventTrace.GuidPtr = (ULONGLONG) LsapTraceGuids[LsaTraceEventType].Guid; 
    Event.EventTrace.Class.Type = (UCHAR) WmiEventType;
    Event.EventTrace.Flags |= (WNODE_FLAG_USE_GUID_PTR |  // GUID is actually a pointer 
                         WNODE_FLAG_TRACED_GUID);         // denotes a trace 
    Event.EventTrace.Size = sizeof(Event.EventTrace);     // no other parameters/information


    if ( (LsaTraceEventType == LsaTraceEvent_LookupIsolatedNameInTrustedDomains)  ) {

        //
        // Add the flag that indicates that there is more data
        //
        Event.EventTrace.Flags |= WNODE_FLAG_USE_MOF_PTR;

        //
        // Make sure enough space has been allocated on the stack for us
        //
        ASSERT(sizeof(Event.EventInfo) >= (sizeof(MOF_FIELD) * 2));
        ASSERT( (ItemCount == 2) && (Items != NULL) );

        //
        // Fill in the data requested
        //
        for (i = 0; i < ItemCount; i++) {

            LPWSTR String = NULL;
            ULONG  Length;

            //
            // Re'alloc to get a NULL terminated string
            //
            String = LsapMakeNullTerminatedString(&Items[i]);
            if (NULL == String) {
                String = &NullChar;
                Length = sizeof(NullChar);
            } else {
                Length = Items[i].Length + sizeof(WCHAR);
            }
            Event.EventInfo[i].Length = Length;
            Event.EventInfo[i].DataPtr = (ULONGLONG)String;
            Event.EventTrace.Size += sizeof(Event.EventInfo[i]);

            if (&NullChar != String) {
                ASSERT(BuffersToFreeCount < sizeof(BuffersToFree)/sizeof(BuffersToFree[0]));
                BuffersToFree[BuffersToFreeCount++] = String;
            }
        }
    }

#if DBG        
    WinError =
#endif
        TraceEvent(LsapTraceLoggerHandle, (PEVENT_TRACE_HEADER) &Event); 

#if DBG        
    if (WinError != ERROR_SUCCESS)
    {
        DebugLog(( DEB_ERROR, "WMI TraceEvent failed, status %x\n", WinError));
    }
#endif        

    for (i = 0; i < BuffersToFreeCount; i++) {
        LsapFreeLsaHeap(BuffersToFree[i]);
    }

}

LPWSTR
LsapGetClientNetworkAddress(
    VOID
    )
/*++

Routine Description:

    This routine returns a NULL terminated string that represents the network
    address of the client.  If the address cannot be obtained, NULL is returned.
    If the return value is non-NULL, the string must be freed with
    RpcStringFreeW.
    

Parameters:

    None.

Return Values:

    See description.

--*/
{
    ULONG              RpcStatus;
    RPC_BINDING_HANDLE ServerBinding = NULL;
    PWSTR              StringBinding = NULL;
    LPWSTR             NetworkAddr   = NULL;

    RpcStatus = RpcBindingServerFromClient(NULL, &ServerBinding); 

    if (RPC_S_OK == RpcStatus) {

        RpcStatus = RpcBindingToStringBindingW(ServerBinding, &StringBinding);
        
        if (RPC_S_OK == RpcStatus) {

            RpcStatus = RpcStringBindingParseW(StringBinding, 
                                           NULL,
                                           NULL,
                                           &NetworkAddr,
                                           NULL,
                                           NULL
                                           );

            RpcStringFreeW(&StringBinding);
        }

        RpcBindingFree(&ServerBinding);

    }

    return NetworkAddr;
}


LPWSTR
LsapMakeNullTerminatedString(
    IN PUNICODE_STRING u
    )
/*++

Routine Description:

    This routine returns a NULL terminated string composed of the data in 
    u. The string must be freed with LsapFreeLsaHeap().
    
    If u->Length is 0, a non-NULL string with the NULL character as the first
    character is returned.

Parameters:

    u -- a unicode string

Return Values:

    See description.

--*/
{
    LPWSTR String = NULL;
    ULONG  Length;
    if (u) {
        Length = u->Length + sizeof(WCHAR);
        String = LsapAllocateLsaHeap(Length);
        if (String != NULL) {
            RtlCopyMemory(String, u->Buffer, u->Length);
            String[u->Length / sizeof(WCHAR)] = UNICODE_NULL;
        }
    }
    return String;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\base\lsa\server\msvlayer.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1993.
//
//  File:       msvlayer.c
//
//  Contents:   Support for the fake MSV layer
//
//  Classes:
//
//  Functions:
//
//  History:    5-31-93   RichardW   Created
//
//----------------------------------------------------------------------------

#include <lsapch.hxx>
extern "C"
{
#include "sesmgr.h"
#include <ntmsv1_0.h>
}


NTSTATUS
LsapAllocateClientBuffer(
    IN PLSA_CLIENT_REQUEST ClientRequest,
    IN ULONG LengthRequired,
    OUT PVOID *ClientBaseAddress
    )
{
    DebugLog((DEB_TRACE_LSA_AU, "package called LsapAllocateClientBuffer\n"));
    *ClientBaseAddress = LsapClientAllocate(LengthRequired);
    if (*ClientBaseAddress == NULL)
    {
        return(STATUS_NO_MEMORY);
    }
    else
    {
        return(STATUS_SUCCESS);
    }
}

NTSTATUS
LsapFreeClientBuffer(
    IN PLSA_CLIENT_REQUEST ClientRequest,
    IN PVOID ClientBaseAddress
    )
{
    DebugLog((DEB_TRACE_LSA_AU, "package called LsapFreeClientBuffer\n"));
    LsapClientFree(ClientBaseAddress);
    return(STATUS_SUCCESS);
}

NTSTATUS
LsapCopyToClientBuffer(
    IN PLSA_CLIENT_REQUEST ClientRequest,
    IN ULONG Length,
    IN PVOID ClientBaseAddress,
    IN PVOID BufferToCopy
    )
{
    return(LsapCopyToClient(BufferToCopy, ClientBaseAddress, Length));
}

NTSTATUS
LsapCopyFromClientBuffer(
    IN PLSA_CLIENT_REQUEST ClientRequest,
    IN ULONG Length,
    IN PVOID BufferToCopy,
    IN PVOID ClientBaseAddress
    )
{
    return(LsapCopyFromClient(ClientBaseAddress, BufferToCopy, Length));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\base\lsa\server\lsawmi.h ===
#ifndef _LSAWMI_H
#define _LSAWMI_H

/*++

copyright (c) 1998 Microsoft Corporation

Module Name:

    LSAWMI.H
    
Abstract:

    Implement LSA server event trace by using WMI trace infrastructure.
    
Author:
    
    16-March-1999 kumarp
    
Revision History:

    
--*/    


#include <wmistr.h>
#include <evntrace.h>



extern ULONG        LsapEventTraceFlag;
extern TRACEHANDLE  LsapTraceRegistrationHandle;
extern TRACEHANDLE  LsapTraceLoggerHandle;


//
// The following "typedef enum" actually is the index of 
// TRACE_GUID_REGISTRATION struct entry in the array LsapTraceGuids[].
// Each enum defines an event that is to be traced using WMI tracing.
// 
// To add WMI tracing to a function Foo do the following steps:
// - add an entry (LsaTraceEvent_Foo) to LSA_TRACE_EVENT_TYPE below
// - generate a new guid using uuidgen.exe -s
// - add a DEFINE_GUID entry at the end of this file using this guid
// - add a corresponding entry (LsaTraceEventGuid_Foo) to LsapTraceGuids[]
// - add a corresponding entry to lsasrv.mof file
// - at the beginning of function Foo insert the following call:
//     LsapTraceEvent(EVENT_TRACE_TYPE_START, LsaTraceEvent_Foo);
// - at the end of function Foo insert the following call:
//     LsapTraceEvent(EVENT_TRACE_TYPE_END, LsaTraceEvent_Foo);
//
// Make sure that Foo returns only from one location, otherwise the
// LsapTraceEvent calls will not be balanced.
//
typedef enum _LSA_TRACE_EVENT_TYPE {

    LsaTraceEvent_QuerySecret=0,
    LsaTraceEvent_Close,
    LsaTraceEvent_OpenPolicy,
    LsaTraceEvent_QueryInformationPolicy,
    LsaTraceEvent_SetInformationPolicy,
    LsaTraceEvent_EnumerateTrustedDomains,
    LsaTraceEvent_LookupNames,
    LsaTraceEvent_LookupSids,
    LsaTraceEvent_OpenTrustedDomain,
    LsaTraceEvent_QueryInfoTrustedDomain,
    LsaTraceEvent_SetInformationTrustedDomain,
//     LsaTraceEvent_QueryInformationPolicy2,
//     LsaTraceEvent_SetInformationPolicy2,
    LsaTraceEvent_QueryTrustedDomainInfoByName,
    LsaTraceEvent_SetTrustedDomainInfoByName,
    LsaTraceEvent_EnumerateTrustedDomainsEx,
    LsaTraceEvent_CreateTrustedDomainEx,
    LsaTraceEvent_QueryDomainInformationPolicy,
    LsaTraceEvent_SetDomainInformationPolicy,
    LsaTraceEvent_OpenTrustedDomainByName,
    LsaTraceEvent_QueryForestTrustInformation,
    LsaTraceEvent_SetForestTrustInformation,
    LsaTraceEvent_LookupIsolatedNameInTrustedDomains,

} LSA_TRACE_EVENT_TYPE;

NTSTATUS
LsapStartWmiTraceInitThread(void);

#ifdef __cplusplus
extern "C" {
#endif // __cplusplus

VOID
LsapTraceEvent(
    IN ULONG WmiEventType, 
    IN LSA_TRACE_EVENT_TYPE LsaTraceEventType
    );

VOID
LsapTraceEventWithData(
    IN ULONG WmiEventType, 
    IN LSA_TRACE_EVENT_TYPE LsaTraceEventType,
    IN ULONG ItemCount,
    IN PUNICODE_STRING Items  OPTIONAL
    );

LPWSTR
LsapGetClientNetworkAddress(
    VOID
    );

#ifdef __cplusplus
}
#endif // __cplusplus

//
// Control GUID for the group of GUIDs that define LSA WMI tracing
// 
DEFINE_GUID ( /* cc85922f-db41-11d2-9244-006008269001 */
        LsapTraceControlGuid,
        0xcc85922f,
        0xdb41,
        0x11d2,
        0x92, 0x44, 0x00, 0x60, 0x08, 0x26, 0x90, 0x01
        );

DEFINE_GUID ( /* cc85922e-db41-11d2-9244-006008269001 */
        LsapTraceEventGuid_QuerySecret,
        0xcc85922e,
        0xdb41,
        0x11d2,
        0x92, 0x44, 0x00, 0x60, 0x08, 0x26, 0x90, 0x01
        );

DEFINE_GUID ( /* 2306fe3b-dbf6-11d2-9244-006008269001 */
        LsaTraceEventGuid_Close,
        0x2306fe3b,
        0xdbf6,
        0x11d2,
        0x92, 0x44, 0x00, 0x60, 0x08, 0x26, 0x90, 0x01
        );

DEFINE_GUID ( /* 2306fe3a-dbf6-11d2-9244-006008269001 */
        LsaTraceEventGuid_OpenPolicy,
        0x2306fe3a,
        0xdbf6,
        0x11d2,
        0x92, 0x44, 0x00, 0x60, 0x08, 0x26, 0x90, 0x01
        );

DEFINE_GUID ( /* 2306fe39-dbf6-11d2-9244-006008269001 */
        LsaTraceEventGuid_QueryInformationPolicy,
        0x2306fe39,
        0xdbf6,
        0x11d2,
        0x92, 0x44, 0x00, 0x60, 0x08, 0x26, 0x90, 0x01
        );

DEFINE_GUID ( /* 2306fe38-dbf6-11d2-9244-006008269001 */
        LsaTraceEventGuid_SetInformationPolicy,
        0x2306fe38,
        0xdbf6,
        0x11d2,
        0x92, 0x44, 0x00, 0x60, 0x08, 0x26, 0x90, 0x01
        );

DEFINE_GUID ( /* 2306fe37-dbf6-11d2-9244-006008269001 */
        LsaTraceEventGuid_EnumerateTrustedDomains,
        0x2306fe37,
        0xdbf6,
        0x11d2,
        0x92, 0x44, 0x00, 0x60, 0x08, 0x26, 0x90, 0x01
        );

DEFINE_GUID ( /* 2306fe36-dbf6-11d2-9244-006008269001 */
        LsaTraceEventGuid_LookupNames,
        0x2306fe36,
        0xdbf6,
        0x11d2,
        0x92, 0x44, 0x00, 0x60, 0x08, 0x26, 0x90, 0x01
        );

DEFINE_GUID ( /* 2306fe35-dbf6-11d2-9244-006008269001 */
        LsaTraceEventGuid_LookupSids,
        0x2306fe35,
        0xdbf6,
        0x11d2,
        0x92, 0x44, 0x00, 0x60, 0x08, 0x26, 0x90, 0x01
        );

DEFINE_GUID ( /* 2306fe34-dbf6-11d2-9244-006008269001 */
        LsaTraceEventGuid_OpenTrustedDomain,
        0x2306fe34,
        0xdbf6,
        0x11d2,
        0x92, 0x44, 0x00, 0x60, 0x08, 0x26, 0x90, 0x01
        );

DEFINE_GUID ( /* 2306fe33-dbf6-11d2-9244-006008269001 */
        LsaTraceEventGuid_QueryInfoTrustedDomain,
        0x2306fe33,
        0xdbf6,
        0x11d2,
        0x92, 0x44, 0x00, 0x60, 0x08, 0x26, 0x90, 0x01
        );

DEFINE_GUID ( /* 2306fe32-dbf6-11d2-9244-006008269001 */
        LsaTraceEventGuid_SetInformationTrustedDomain,
        0x2306fe32,
        0xdbf6,
        0x11d2,
        0x92, 0x44, 0x00, 0x60, 0x08, 0x26, 0x90, 0x01
        );

// DEFINE_GUID ( /* 2306fe31-dbf6-11d2-9244-006008269001 */
//         LsaTraceEventGuid_QueryInformationPolicy2,
//         0x2306fe31,
//         0xdbf6,
//         0x11d2,
//         0x92, 0x44, 0x00, 0x60, 0x08, 0x26, 0x90, 0x01
//         );

// DEFINE_GUID ( /* 2306fe30-dbf6-11d2-9244-006008269001 */
//         LsaTraceEventGuid_SetInformationPolicy2,
//         0x2306fe30,
//         0xdbf6,
//         0x11d2,
//         0x92, 0x44, 0x00, 0x60, 0x08, 0x26, 0x90, 0x01
//         );

DEFINE_GUID ( /* 2306fe2f-dbf6-11d2-9244-006008269001 */
        LsaTraceEventGuid_QueryTrustedDomainInfoByName,
        0x2306fe2f,
        0xdbf6,
        0x11d2,
        0x92, 0x44, 0x00, 0x60, 0x08, 0x26, 0x90, 0x01
        );

DEFINE_GUID ( /* 2306fe2e-dbf6-11d2-9244-006008269001 */
        LsaTraceEventGuid_SetTrustedDomainInfoByName,
        0x2306fe2e,
        0xdbf6,
        0x11d2,
        0x92, 0x44, 0x00, 0x60, 0x08, 0x26, 0x90, 0x01
        );

DEFINE_GUID ( /* 2306fe2d-dbf6-11d2-9244-006008269001 */
        LsaTraceEventGuid_EnumerateTrustedDomainsEx,
        0x2306fe2d,
        0xdbf6,
        0x11d2,
        0x92, 0x44, 0x00, 0x60, 0x08, 0x26, 0x90, 0x01
        );

DEFINE_GUID ( /* 2306fe2c-dbf6-11d2-9244-006008269001 */
        LsaTraceEventGuid_CreateTrustedDomainEx,
        0x2306fe2c,
        0xdbf6,
        0x11d2,
        0x92, 0x44, 0x00, 0x60, 0x08, 0x26, 0x90, 0x01
        );

DEFINE_GUID ( /* 2306fe2b-dbf6-11d2-9244-006008269001 */
        LsaTraceEventGuid_QueryDomainInformationPolicy,
        0x2306fe2b,
        0xdbf6,
        0x11d2,
        0x92, 0x44, 0x00, 0x60, 0x08, 0x26, 0x90, 0x01
        );

DEFINE_GUID ( /* 2306fe2a-dbf6-11d2-9244-006008269001 */
        LsaTraceEventGuid_SetDomainInformationPolicy,
        0x2306fe2a,
        0xdbf6,
        0x11d2,
        0x92, 0x44, 0x00, 0x60, 0x08, 0x26, 0x90, 0x01
        );

DEFINE_GUID ( /* 2306fe29-dbf6-11d2-9244-006008269001 */
        LsaTraceEventGuid_OpenTrustedDomainByName,
        0x2306fe29,
        0xdbf6,
        0x11d2,
        0x92, 0x44, 0x00, 0x60, 0x08, 0x26, 0x90, 0x01
        );

DEFINE_GUID ( /* e28ee0eb-6181-49df-b859-2f3fd289a2d1 */
        LsaTraceEventGuid_QueryForestTrustInformation,
        0xe28ee0eb,
        0x6181,
        0x49df,
        0xb8, 0x59, 0x2f, 0x3f, 0xd2, 0x89, 0xa2, 0xd1
        );

DEFINE_GUID ( /* 3d2c9e3e-bb19-4617-8489-cabb9787de7d */
        LsaTraceEventGuid_SetForestTrustInformation,
        0x3d2c9e3e,
        0xbb19,
        0x4617,
        0x84, 0x89, 0xca, 0xbb, 0x97, 0x87, 0xde, 0x7d
        );

DEFINE_GUID ( /* 2484dc26-49d3-4085-a6e4-4972115cb3c0 */
        LsaTraceEventGuid_LookupIsolatedNameInTrustedDomains,
        0x2484dc26,
        0x49d3,
        0x4085,
        0xa6, 0xe4, 0x49, 0x72, 0x11, 0x5c, 0xb3, 0xc0
      );

#endif /* _LSAWMI_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\base\lsa\server\negsupp.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995.
//
//  File:       negsupp.cxx
//
//  Contents:   General (both win9x and nt) functions
//
//  Classes:
//
//  Functions:
//
//  History:    02-09-00   RichardW     Created - split from negotiat.cxx
//
//----------------------------------------------------------------------------

#include <lsapch.hxx>

extern "C"
{
#include <align.h>
#include <lm.h>
#include <dsgetdc.h>
#include <cryptdll.h>
#include <spmgr.h>
#include "sesmgr.h"
#include "spinit.h"
}

#include "negotiat.hxx"
#include <stdio.h>

BOOL            fSPNEGOModuleStarted = FALSE;

SECURITY_STATUS
SpnegoInitAsn(
    IN OUT ASN1encoding_t * pEnc,
    IN OUT ASN1decoding_t * pDec
    )
{
    ASN1error_e Asn1Err;
    SECURITY_STATUS SecStatus = SEC_E_OK;

    if (!fSPNEGOModuleStarted)
    {
        RtlEnterCriticalSection( &NegLogonSessionListLock );
        
        if (!fSPNEGOModuleStarted)
        {
            SPNEGO_Module_Startup();
            fSPNEGOModuleStarted = TRUE;
        }
        
        RtlLeaveCriticalSection( &NegLogonSessionListLock );
    }

    if (pEnc != NULL)
    {
        Asn1Err = ASN1_CreateEncoder(
                                 SPNEGO_Module,
                                 pEnc,
                                 NULL,           // pbBuf
                                 0,              // cbBufSize
                                 NULL            // pParent
                                 );
    }
    else
    {
        Asn1Err = ASN1_CreateDecoder(
                                 SPNEGO_Module,
                                 pDec,
                                 NULL,           // pbBuf
                                 0,              // cbBufSize
                                 NULL            // pParent
                                 );
    }

    if (ASN1_SUCCESS != Asn1Err)
    {
        DebugLog((DEB_ERROR, "Failed to init ASN1: 0x%x\n",Asn1Err));
        SecStatus = SpnegoAsnErrorToSecStatus( Asn1Err );
        goto Cleanup;
    }

Cleanup:

    return SecStatus;
}


VOID
SpnegoTermAsn(
        IN ASN1encoding_t pEnc,
        IN ASN1decoding_t pDec
    )
{
    if (pEnc != NULL)
    {
        ASN1_CloseEncoder(pEnc);
    }
    else if (pDec != NULL)
    {
        ASN1_CloseDecoder(pDec);
    }

        //SPNEGO_Module_Cleanup();
}

SECURITY_STATUS
SpnegoAsnErrorToSecStatus(
    IN   ASN1error_e Asn1Err
    )
{
    switch( Asn1Err )
    {
        case ASN1_SUCCESS:
        {
            return SEC_E_OK;
        }

        case ASN1_ERR_MEMORY:
        {
            return SEC_E_INSUFFICIENT_MEMORY;
        }
        
        default:
        {
            return SEC_E_INVALID_TOKEN;
        }
    }
}

SECURITY_STATUS
SpnegoUnpackData(
    IN PUCHAR Data,
    IN ULONG DataSize,
    IN ULONG PduValue,
    OUT PVOID * DecodedData
    )
{
    ULONG OldPduValue;
    ASN1decoding_t pDec = NULL;
    ASN1error_e Asn1Err;
    SECURITY_STATUS SecStatus;

    if ((DataSize == 0) || (Data == NULL))
    {
        DebugLog((DEB_ERROR,"Trying to unpack NULL data\n"));
        return SEC_E_INVALID_TOKEN;
    }


    SecStatus = SpnegoInitAsn(
                NULL,
                &pDec           // we are decoding
                );
    if (!NT_SUCCESS(SecStatus))
    {
        return SecStatus;
    }


    *DecodedData = NULL;
    Asn1Err = ASN1_Decode(
                                pDec,
                                DecodedData,
                                PduValue,
                                ASN1DECODE_SETBUFFER,
                                (BYTE *) Data,
                                DataSize
                                );

    if (!ASN1_SUCCEEDED(Asn1Err))
    {
        
        SecStatus = SpnegoAsnErrorToSecStatus( Asn1Err );
        
        if ((ASN1_ERR_BADARGS == Asn1Err) ||
            (ASN1_ERR_EOD == Asn1Err))
        {
            DebugLog((DEB_TRACE,"More input required to decode data %d.\n",PduValue));
        }
        else
        {
            DebugLog((DEB_WARN,"Failed to decode data: %d\n", Asn1Err ));
        }
        *DecodedData = NULL;
    }

    SpnegoTermAsn(NULL, pDec);

    return SecStatus;

}


SECURITY_STATUS
SpnegoPackData(
    IN PVOID Data,
    IN ULONG PduValue,
    OUT PULONG DataSize,
    OUT PUCHAR * MarshalledData
    )
{
    PUCHAR Buffer = NULL;
    ASN1encoding_t pEnc = NULL;
    ASN1error_e Asn1Err;
    SECURITY_STATUS SecStatus;

    SecStatus = SpnegoInitAsn(
                &pEnc,          // we are encoding
                NULL
                );
    if (!NT_SUCCESS(SecStatus))
    {
        return SecStatus;
    }

    //
    // Encode the data type.
    //
    Asn1Err = ASN1_Encode(
                            pEnc,
                            Data,
                            PduValue,
                            ASN1ENCODE_ALLOCATEBUFFER,
                            NULL,                       // pbBuf
                            0                           // cbBufSize
                            );

    if (!ASN1_SUCCEEDED(Asn1Err))
    {
        DebugLog((DEB_ERROR,"Failed to encode data: %d\n",Asn1Err));
        SecStatus = SpnegoAsnErrorToSecStatus( Asn1Err );
        goto Cleanup;
    }
    else
    {
        //
        // when the oss compiler was used the allocation routines were configurable.
        // therefore, the encoded data could just be free'd using our
        // deallocator.  in the new model we cannot configure the allocation routines
        // for encoding.

        // so we do not have to go and change every place where a free
        // of an encoded buffer is done, use our allocator to allocate a new buffer,
        // then copy the encoded data to it, and free the buffer that was allocated by
        // the encoding engine.
        //

        *MarshalledData = (PUCHAR)LsapAllocateLsaHeap(pEnc->len);
        if (*MarshalledData == NULL)
        {
            SecStatus = SEC_E_INSUFFICIENT_MEMORY;
            *DataSize = 0;
        }
        else
        {
            RtlCopyMemory(*MarshalledData, pEnc->buf, pEnc->len);
            *DataSize = pEnc->len;

            //DebugLog((DEB_ERROR,"encoded pdu size: %d\n",pEnc->len));
            //PrintBytes(pEnc->buf, pEnc->len);
        }

        ASN1_FreeEncoded(pEnc, pEnc->buf);
    }

Cleanup:
    SpnegoTermAsn(pEnc, NULL);

    return SecStatus;
}


VOID
SpnegoFreeData(
    IN ULONG PduValue,
    IN PVOID Data
    )
{
    ASN1decoding_t pDec = NULL;

    if (ARGUMENT_PRESENT(Data))
    {
        SECURITY_STATUS SecStatus;
        
        SecStatus = SpnegoInitAsn(
                    NULL,
                    &pDec       // this is a decoded structure
                    );

        if ( NT_SUCCESS(SecStatus) )
        {
            ASN1_FreeDecoded(pDec, Data, PduValue);

            SpnegoTermAsn(NULL, pDec);
        }
    }

}


//+---------------------------------------------------------------------------
//
//  Function:   NegpFreeObjectId
//
//  Synopsis:   Frees an object ID structure created by us
//
//  Arguments:  [Id] -- Id to free
//
//  History:    8-09-96   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
VOID
NegpFreeObjectId(
    ObjectID    Id)
{
    ObjectID    Next;

    while (Id) {

        Next = Id->next;

        LsapFreeLsaHeap( Id );

        Id = Next ;

    } ;

}

//+---------------------------------------------------------------------------
//
//  Function:   NegpFreeMechList
//
//  Synopsis:   Frees a Mechlist created by NecpCopyMechList
//
//  Arguments:  [Id] -- Id to free
//
//  History:    8-09-96   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
VOID
NegpFreeMechList(
    struct MechTypeList *MechList)
{
    struct MechTypeList *Next;

    Next = MechList;
    while (Next != NULL)
    {

        NegpFreeObjectId(Next->value);

        Next = Next->next ;

    } while ( Next );

    LsapFreeLsaHeap(MechList);

}


//+---------------------------------------------------------------------------
//
//  Function:   NegpDecodeObjectId
//
//  Synopsis:   Create an Object ID struct from a BER encoded Object ID
//
//  Arguments:  [Id]  --
//              [Len] --
//
//  History:    8-09-96   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
ObjectID
NegpDecodeObjectId(
    PUCHAR  Id,
    DWORD   Len)
{
    ObjectID    Root;
    ObjectID    Tail;
    ObjectID    Current;
    DWORD       i, j;
    DWORD       value;

    if ( Len < 3 )
    {
        return( NULL );
    }

    //
    // Check for BER type OBJECT_ID
    //

    if ( Id[ 0 ] != 0x06 )
    {
        return( NULL );
    }

    if ( Id[ 1 ] > 127 )
    {
        return( NULL );
    }

    Root = (struct ASN1objectidentifier_s *) LsapAllocateLsaHeap( sizeof( struct ASN1objectidentifier_s ) );

    Tail = (struct ASN1objectidentifier_s *) LsapAllocateLsaHeap( sizeof( struct ASN1objectidentifier_s ) );

    if ( !Root || !Tail )
    {
        if ( Root )
        {
            LsapFreeLsaHeap( Root );
        }

        if ( Tail )
        {
            LsapFreeLsaHeap( Tail );
        }

        return( NULL );
    }

    Root->value = (WORD) Id[2] / 40 ;

    Tail->value = (WORD) Id[2] % 40 ;

    Root->next = Tail ;

    i = 3 ;

    while ( i < Len )
    {
        j = 0;

        value = Id[ i ] & 0x7F ;

        while ( Id[i] & 0x80 )
        {
            value <<= 7;

            i++;

            j++;

            if ( (i >= Len) || ( j > sizeof( ULONG ) ) )
            {
                NegpFreeObjectId( Root );

                return( NULL );
            }

            value |= Id[ i ] & 0x7F ;
        }

        i++;

        Current = (struct ASN1objectidentifier_s *) LsapAllocateLsaHeap( sizeof( struct ASN1objectidentifier_s ) );

        if ( Current )
        {
            Current->value = value ;
            Current->next = NULL ;

            Tail->next = Current ;

            Tail = Current ;

        }
        else
        {
            NegpFreeObjectId( Root );

            return( NULL );
        }

    }

    return( Root );

}

//+---------------------------------------------------------------------------
//
//  Function:   NegpCompareOid
//
//  Synopsis:   Standard compare function for OIDs:
//
//  Arguments:  [A] --
//              [B] --
//
//  Returns:    < 0 if A is "less than" B
//              > 0 if A is "greater than" B
//              0 if A equals B
//
//  History:    8-22-96   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
int
NegpCompareOid(
    ObjectID    A,
    ObjectID    B)
{
    while ( A )
    {
        if ( A->value < B->value )
        {
            return( -1 );
        }
        if ( A->value > B->value )
        {
            return( 1 );
        }

        A = A->next ;

        B = B->next ;

        if ( ( A == NULL ) && ( B == NULL ) )
        {
            return( 0 );
        }

        if ( !B )
        {
            return( 1 );
        }

        if ( !A )
        {
            return( -1 );
        }
    }

    //
    // Never reached
    //
    return( 0 );
}

//+---------------------------------------------------------------------------
//
//  Function:   NegpDumpOid
//
//  Synopsis:   Debug-only dumper
//
//  Arguments:  [Banner] --
//              [Id]     --
//
//  History:    9-17-96   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
VOID
NegpDumpOid(
    PSTR        Banner,
    ObjectID    Id
    )
{
    CHAR    Oid[128];
    PSTR    Next;
    int     Count;

    Next = Oid;

    while ( Id )
    {
        Count = sprintf(Next, "%d.", Id->value );

        Next += Count;

        Id = Id->next;
    }

    DebugLog(( DEB_TRACE_NEG, "%s: %s\n", Banner, Oid ));

}


//+---------------------------------------------------------------------------
//
//  Function:   NegpBuildMechListFromCreds
//
//  Synopsis:   Builds a MechList from a credential struct
//
//  Arguments:  [Creds] -- Creds
//              [fPackageReq]
//              [MechList] -- Constructed mechlist
//
//  History:    9-27-96   RichardW   Created
//
//  Notes:      Returned MechList should be freed in a single call to LsapFreeHeap
//
//----------------------------------------------------------------------------
SECURITY_STATUS
NegpBuildMechListFromCreds(
    PNEG_CREDS  Creds,
    ULONG       fPackageReq,
    ULONG       MechAttributes,
    struct MechTypeList ** MechList)
{
    struct MechTypeList *pMechs = NULL;
    ULONG iCred, iMech = 0 ;
    SECURITY_STATUS Status = STATUS_SUCCESS;
    PNEG_PACKAGE Package ;

    NegReadLockCreds( Creds );

    if ( Creds->Count != 0 )
    {

        pMechs = (struct MechTypeList *) LsapAllocateLsaHeap(
                                    sizeof( struct MechTypeList ) * ( Creds->Count) );

        if ( pMechs )
        {
            for ( iCred = 0 ; iCred < Creds->Count ; iCred++ )
            {
                Package = Creds->Creds[ iCred ].Package ;

                if ( (Package->PackageFlags & fPackageReq) != fPackageReq)
                {
                    continue;
                }
                pMechs[ iMech ].next = &pMechs[ iMech + 1 ];

                pMechs[ iMech ].value = Package->ObjectId ;

                iMech++ ;

            }

            if ( iMech != 0 )
            {
                pMechs[ iMech - 1 ].next = NULL ;
            }

        }
        else
        {
            Status = SEC_E_INSUFFICIENT_MEMORY;
        }
    }

    NegUnlockCreds( Creds );

    *MechList = pMechs;
    return( Status );

}


//+---------------------------------------------------------------------------
//
//  Function:   NegpCopyObjectId
//
//  Synopsis:   Duplicates an ObjectId
//
//  Arguments:  [ObjectId] = Object Id to copy
//
//  History:    9-27-96   RichardW   Created
//
//  Notes:      Returned ObjectId should be freed with NegpFreeObjectId
//
//----------------------------------------------------------------------------
ObjectID
NegpCopyObjectId(
    IN ObjectID Id
    )
{
    ObjectID RootId = NULL;
    ObjectID NewId = NULL;
    ObjectID LastId = NULL;
    ObjectID NextId = NULL;

    NextId = Id;
    while (NextId != NULL)
    {
        NewId = (struct ASN1objectidentifier_s *) LsapAllocateLsaHeap(sizeof(struct ASN1objectidentifier_s));
        if (NewId == NULL)
        {
            goto Cleanup;
        }
        NewId->next = NULL;
        NewId->value = NextId->value;

        if (RootId == NULL)
        {
            RootId = NewId;
        }

        if (LastId != NULL)
        {
            LastId->next = NewId;
        }
        LastId = NewId;
        NextId= NextId->next;
    }
    return(RootId);

Cleanup:
    if (RootId != NULL)
    {
        NegpFreeObjectId(RootId);
    }
    return(NULL);

}


//+---------------------------------------------------------------------------
//
//  Function:   NegpCopyMechList
//
//  Synopsis:   Duplicates a MechList
//
//  Arguments:  [Creds] -- Creds
//
//  History:    9-27-96   RichardW   Created
//
//  Notes:      Returned MechList should be freed with NegpFreeMechList
//
//----------------------------------------------------------------------------
struct MechTypeList *
NegpCopyMechList(
    struct MechTypeList *MechList)
{
    struct MechTypeList *pMechs;
    struct MechTypeList *NextMech;
    ULONG i, Count;

    Count = 0;
    NextMech = MechList;
    while (NextMech != NULL)
    {
        Count++;
        NextMech = NextMech->next;
    }

    if (Count == 0)
    {
        return(NULL);
    }

    pMechs = (struct MechTypeList *) LsapAllocateLsaHeap(
                                sizeof( struct MechTypeList ) * Count );

    if ( pMechs == NULL )
    {
        goto Cleanup;
    }

    RtlZeroMemory(
        pMechs,
        sizeof(struct MechTypeList) * Count
        );

    i = 0;

    NextMech = MechList;
    while (NextMech != NULL)
    {
        pMechs[i].value = NegpCopyObjectId(NextMech->value);
        if (pMechs[i].value == NULL)
        {
            goto Cleanup;
        }
        pMechs[i].next = NULL;
        if (i != 0)
        {
            pMechs[i-1].next = &pMechs[i];
        }
        NextMech = NextMech->next;
        i++;
    }

    return( pMechs );
Cleanup:
    if (pMechs != NULL)
    {
        NegpFreeMechList (pMechs);
    }
    return(NULL);

}


int
Neg_der_read_length(
     unsigned char **buf,
     LONG *bufsize,
     LONG * headersize
     )
{
   unsigned char sf;
   LONG ret;

   if (*bufsize < 1)
      return(-1);
   *headersize = 0;
   sf = *(*buf)++;
   (*bufsize)--;
   (*headersize)++;
   if (sf & 0x80) {
      if ((sf &= 0x7f) > ((*bufsize)-1))
         return(-1);
      if (sf > sizeof(LONG))
          return (-1);
      ret = 0;
      for (; sf; sf--) {
         ret = (ret<<8) + (*(*buf)++);
         (*bufsize)--;
         (*headersize)++;
      }
   } else {
      ret = sf;
   }

   return(ret);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\base\lsa\server\policy.cxx ===
//+-----------------------------------------------------------------------
//
// Microsoft Windows
//
// Copyright (c) Microsoft Corporation 1992 - 1994
//
// File:        policy.cxx
//
// Contents:    SpmBuildCairoToken
//
//
// History:     23-May-1994     MikeSw      Created
//
//------------------------------------------------------------------------

#include <lsapch.hxx>
extern "C"
{
#include "adtp.h"
}


//+-------------------------------------------------------------------------
//
//  Function:   LsapCreateToken
//
//  Synopsis:   Builds a token from the various pieces of information
//              generated during a logon.
//
//  Effects:
//
//  Arguments:  pUserSid - sid of user to create token for
//              pTokenGroups - groups passed in to LogonUser or from PAC to
//                  be put in token
//              pTokenPrivs - privileges from PAC to put in token
//              TokenType - type of token to create
//              pTokenSource - source of the token
//              pLogonId - Gets logon ID
//              phToken - Get handle to token
//
//  Requires:
//
//  Returns:
//
//  Notes:      TokenInformation is always freed, even on failure.
//
//
//--------------------------------------------------------------------------


NTSTATUS NTAPI
LsapCreateToken(
    IN PLUID LogonId,
    IN PTOKEN_SOURCE TokenSource,
    IN SECURITY_LOGON_TYPE LogonType,
    IN SECURITY_IMPERSONATION_LEVEL ImpersonationLevel,
    IN LSA_TOKEN_INFORMATION_TYPE InputTokenInformationType,
    IN PVOID InputTokenInformation,
    IN PTOKEN_GROUPS LocalGroups,
    IN PUNICODE_STRING AccountName,
    IN PUNICODE_STRING AuthorityName,
    IN PUNICODE_STRING WorkstationName,
    IN OPTIONAL PUNICODE_STRING ProfilePath,
    OUT PHANDLE Token,
    OUT PNTSTATUS SubStatus
    )
{
    SECPKG_PRIMARY_CRED PrimaryCredential;

    ZeroMemory( &PrimaryCredential, sizeof(PrimaryCredential) );


    if( AccountName != NULL )
    {
        PrimaryCredential.DownlevelName = *AccountName;
    }

    if( AuthorityName != NULL )
    {
        PrimaryCredential.DomainName = *AuthorityName;
    }

    return LsapCreateTokenEx(
                LogonId,
                TokenSource,
                LogonType,
                ImpersonationLevel,
                InputTokenInformationType,
                InputTokenInformation,
                LocalGroups,
                WorkstationName,
                ProfilePath,
                &PrimaryCredential,
                SecSessionPrimaryCred,
                Token,
                SubStatus
                );

}

//+-------------------------------------------------------------------------
//
//  Function:   LsapCreateTokenEx
//
//  Synopsis:   Builds a token from the various pieces of information
//              generated during a logon.
//
//  Effects:
//
//  Arguments:  pUserSid - sid of user to create token for
//              pTokenGroups - groups passed in to LogonUser or from PAC to
//                  be put in token
//              pTokenPrivs - privileges from PAC to put in token
//              TokenType - type of token to create
//              pTokenSource - source of the token
//              pLogonId - Gets logon ID
//              phToken - Get handle to token
//
//  Requires:
//
//  Returns:
//
//  Notes:      TokenInformation is always freed, even on failure.
//
//
//--------------------------------------------------------------------------


NTSTATUS NTAPI
LsapCreateTokenEx(
    IN PLUID LogonId,
    IN PTOKEN_SOURCE TokenSource,
    IN SECURITY_LOGON_TYPE LogonType,
    IN SECURITY_IMPERSONATION_LEVEL ImpersonationLevel,
    IN LSA_TOKEN_INFORMATION_TYPE InputTokenInformationType,
    IN PVOID InputTokenInformation,
    IN PTOKEN_GROUPS LocalGroups,
    IN PUNICODE_STRING WorkstationName,
    IN PUNICODE_STRING ProfilePath,
    IN PVOID SessionInformation,
    IN SECPKG_SESSIONINFO_TYPE SessionInformationType,
    OUT PHANDLE Token,
    OUT PNTSTATUS SubStatus
    )
{
    NTSTATUS Status;
    PPRIVILEGE_SET PrivilegesAssigned = NULL;
    PLSA_TOKEN_INFORMATION_V2 TokenInformationV2 = NULL;
    PLSA_TOKEN_INFORMATION_NULL TokenInformationNull = NULL;
    LSA_TOKEN_INFORMATION_TYPE OriginalTokenType = InputTokenInformationType;
    QUOTA_LIMITS QuotaLimits;
    PUNICODE_STRING NewAccountName = NULL;
    PUNICODE_STRING NewAuthorityName = NULL;
    PUNICODE_STRING NewProfilePath = NULL;
    UNICODE_STRING LocalAccountName = { 0 };
    UNICODE_STRING LocalAuthorityName =  { 0 };
    UNICODE_STRING LocalProfilePath = { 0 };
    PSID NewUserSid = NULL;
    LSA_TOKEN_INFORMATION_TYPE TokenInformationType = InputTokenInformationType;
    PVOID TokenInformation = InputTokenInformation;

    PSECPKG_PRIMARY_CRED PrimaryCredential;
    PUNICODE_STRING AccountName;
    PUNICODE_STRING AuthorityName;


    *Token = NULL;
    *SubStatus = STATUS_SUCCESS;

    if( SessionInformationType != SecSessionPrimaryCred )
    {
        return STATUS_INVALID_PARAMETER;
    }

    PrimaryCredential = (PSECPKG_PRIMARY_CRED)SessionInformation;

    AccountName = &PrimaryCredential->DownlevelName;
    AuthorityName = &PrimaryCredential->DomainName;

    //
    // Pass the token information through the Local Security Policy
    // Filter/Augmentor.  This may cause some or all of the token
    // information to be replaced/augmented.
    //

    Status = LsapAuUserLogonPolicyFilter(
                 LogonType,
                 &TokenInformationType,
                 &TokenInformation,
                 LocalGroups,
                 &QuotaLimits,
                 &PrivilegesAssigned,
                 FALSE
                 );




    if ( !NT_SUCCESS(Status) ) {

        goto Cleanup;
    }

    //
    // Check if we only allow admins to logon.  We do allow null session
    // connections since they are severly restricted, though. Since the
    // token type may have been changed, we use the token type originally
    // returned by the package.
    //

    if (LsapAllowAdminLogonsOnly &&
        ((OriginalTokenType == LsaTokenInformationV1) ||
        (OriginalTokenType == LsaTokenInformationV2))&&
        !LsapSidPresentInGroups(
            ((PLSA_TOKEN_INFORMATION_V2) TokenInformation)->Groups,
            (SID *)LsapAliasAdminsSid)) {

        //
        // Set the status to be invalid workstation, since all accounts
        // except administrative ones are locked out for this
        // workstation.
        //

        *SubStatus = STATUS_INVALID_WORKSTATION;
        Status = STATUS_ACCOUNT_RESTRICTION;
        goto Cleanup;
    }

    //
    // Case on the token information returned (and subsequently massaged)
    // to create the correct kind of token.
    //

    switch (TokenInformationType) {

    case LsaTokenInformationNull:

        TokenInformationNull = (PLSA_TOKEN_INFORMATION_NULL) TokenInformation;

        //
        // The user hasn't logged on to any particular account.
        // An impersonation token with WORLD as owner
        // will be created.
        //


        Status = LsapCreateNullToken(
                     LogonId,
                     TokenSource,
                     TokenInformationNull,
                     Token
                     );

        if ( !NT_SUCCESS(Status) ) {
            goto Cleanup;
        }


        break;




    case LsaTokenInformationV1:
    case LsaTokenInformationV2:

        TokenInformationV2 = (PLSA_TOKEN_INFORMATION_V2) TokenInformation;

        //
        // the type of token created depends upon the type of logon
        // being requested:
        //
        //        InteractiveLogon => PrimaryToken
        //        BatchLogon       => PrimaryToken
        //        NetworkLogon     => ImpersonationToken
        //

        if (LogonType != Network) {

            //
            // Primary token
            //

            Status = LsapCreateV2Token(
                         LogonId,
                         TokenSource,
                         TokenInformationV2,
                         TokenPrimary,
                         ImpersonationLevel,
                         Token
                         );

            if ( !NT_SUCCESS(Status) ) {
                goto Cleanup;
            }


        } else {

            //
            // Impersonation token
            //

            Status = LsapCreateV2Token(
                         LogonId,
                         TokenSource,
                         TokenInformationV2,
                         TokenImpersonation,
                         ImpersonationLevel,
                         Token
                         );

            if ( !NT_SUCCESS(Status) ) {
                goto Cleanup;
            }


        }

        //
        // Copy out the User Sid
        //

        Status = LsapDuplicateSid( &NewUserSid, TokenInformationV2->User.User.Sid );

        if ( !NT_SUCCESS( Status )) {
            goto Cleanup;
        }

        break;

    }

    //
    // Audit special privilege assignment, if there were any
    //

    if ( PrivilegesAssigned != NULL ) {

        //
        // Examine the list of privileges being assigned, and
        // audit special privileges as appropriate.
        //

        LsapAdtAuditSpecialPrivileges( PrivilegesAssigned, *LogonId, NewUserSid );

    }


    NewAccountName = &LocalAccountName ;
    NewAuthorityName = &LocalAuthorityName ;


    //
    // If the original was a null session, set the user name & domain name
    // to be anonymous.
    //

    if (OriginalTokenType == LsaTokenInformationNull)
    {
        NewAccountName->Buffer = (LPWSTR) LsapAllocateLsaHeap(WellKnownSids[LsapAnonymousSidIndex].Name.MaximumLength);
        if (NewAccountName->Buffer == NULL)
        {
            Status = STATUS_INSUFFICIENT_RESOURCES;
            goto Cleanup;
        }
        NewAccountName->MaximumLength = WellKnownSids[LsapAnonymousSidIndex].Name.MaximumLength;
        RtlCopyUnicodeString(
            NewAccountName,
            &WellKnownSids[LsapAnonymousSidIndex].Name
            );

        NewAuthorityName->Buffer = (LPWSTR) LsapAllocateLsaHeap(WellKnownSids[LsapAnonymousSidIndex].DomainName.MaximumLength);
        if (NewAuthorityName->Buffer == NULL)
        {
            Status = STATUS_INSUFFICIENT_RESOURCES;
            goto Cleanup;
        }
        NewAuthorityName->MaximumLength = WellKnownSids[LsapAnonymousSidIndex].DomainName.MaximumLength;
        RtlCopyUnicodeString(
            NewAuthorityName,
            &WellKnownSids[LsapAnonymousSidIndex].DomainName
            );

    }
    else
    {
        NewAccountName->Buffer = (LPWSTR) LsapAllocateLsaHeap(AccountName->MaximumLength);
        if (NewAccountName->Buffer == NULL)
        {
            Status = STATUS_INSUFFICIENT_RESOURCES;
            goto Cleanup;
        }
        NewAccountName->MaximumLength = AccountName->MaximumLength;
        RtlCopyUnicodeString(
            NewAccountName,
            AccountName
            );

        NewAuthorityName->Buffer = (LPWSTR) LsapAllocateLsaHeap(AuthorityName->MaximumLength);
        if (NewAuthorityName->Buffer == NULL)
        {
            Status = STATUS_INSUFFICIENT_RESOURCES;
            goto Cleanup;
        }
        NewAuthorityName->MaximumLength = AuthorityName->MaximumLength;
        RtlCopyUnicodeString(
            NewAuthorityName,
            AuthorityName
            );

        if (ARGUMENT_PRESENT(ProfilePath) ) {
            NewProfilePath = &LocalProfilePath ;

            NewProfilePath->Buffer = (LPWSTR) LsapAllocateLsaHeap(ProfilePath->MaximumLength);
            if (NewProfilePath->Buffer == NULL)
            {
                Status = STATUS_INSUFFICIENT_RESOURCES;
                goto Cleanup;
            }
            NewProfilePath->MaximumLength = ProfilePath->MaximumLength;
            RtlCopyUnicodeString(
                NewProfilePath,
                ProfilePath
                );

        }
    }


    Status = LsapSetLogonSessionAccountInfo(
                LogonId,
                NewAccountName,
                NewAuthorityName,
                NewProfilePath,
                &NewUserSid,
                LogonType,
                PrimaryCredential
                );

    if (!NT_SUCCESS(Status))
    {
        goto Cleanup;
    }

    LocalAccountName.Buffer = NULL ;
    LocalAuthorityName.Buffer = NULL ;
    LocalProfilePath.Buffer = NULL ;

    //
    // Set the token on the session
    //

    Status = LsapSetSessionToken( *Token, LogonId );

    if ( !NT_SUCCESS(Status) ) {
        goto Cleanup;
    }


Cleanup:

    //
    // Clean up on failure
    //

    if ( !NT_SUCCESS(Status) ) {

        //
        // If we successfully built the token,
        //  free it.
        //

        if ( *Token != NULL ) {
            NtClose( *Token );
            *Token = NULL;
        }
    }


    //
    // Always free the token information because the policy filter
    // changes it.
    //

    switch (TokenInformationType) {

        case LsaTokenInformationNull:

            LsapFreeTokenInformationNull( (PLSA_TOKEN_INFORMATION_NULL) TokenInformation );
            break;

        case LsaTokenInformationV1:

            LsapFreeTokenInformationV1( (PLSA_TOKEN_INFORMATION_V1) TokenInformation );
            break;

        case LsaTokenInformationV2:

            LsapFreeTokenInformationV2( (PLSA_TOKEN_INFORMATION_V2) TokenInformation );
            break;

    }

    if ( LocalAccountName.Buffer != NULL )
    {
        LsapFreeLsaHeap( LocalAccountName.Buffer );
    }

    if ( LocalAuthorityName.Buffer != NULL )
    {
        LsapFreeLsaHeap( LocalAuthorityName.Buffer );
    }

    if ( LocalProfilePath.Buffer != NULL )
    {
        LsapFreeLsaHeap( LocalProfilePath.Buffer );
    }

    if (NewUserSid != NULL) {
        LsapFreeLsaHeap( NewUserSid );
    }
    if ( PrivilegesAssigned != NULL ) {

        MIDL_user_free( PrivilegesAssigned );
    }
    return(Status);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\base\lsa\server\negotiat.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995.
//
//  File:       negotiat.cxx
//
//  Contents:
//
//  Classes:
//
//  Functions:
//
//  History:    11-15-95   RichardW     Created for Cairo
//              07-25-96   RichardW     Added SNEGO support
//              06-24-97   MikeSw       Modified for SPNEGO
//
//----------------------------------------------------------------------------

#include <lsapch.hxx>

extern "C"
{
#include <align.h>
#include <lm.h>
#include <dsgetdc.h>
#include <cryptdll.h>
#include <spmgr.h>
#include "sesmgr.h"
#include "spinit.h"
}

#include "negotiat.hxx"
#include <stdio.h>

//
// Possible states for the Accept and Init calls.
//

#define FIRST_CALL_NO_INPUT     0
#define FIRST_CALL_WITH_INPUT   1
#define LATER_CALL_NO_INPUT     2
#define LATER_CALL_WITH_INPUT   3

#define LATER_CALL_BIT      2
#define BUFFER_PRESENT_BIT  1


//
// This define controls the proposed MA behavior v. the existing MA
// behavior
//

#define NEW_MUTUAL_AUTH


//
// This defines the minimum buffer that spnego can use, when
// fragment-to-fit is requested.  This is 5 bytes, enough in
// BER to encode the start of a 64K buffer.  The five bytes,
// for the curious, are:
//
//      0x60 0x8x 0xLL 0xLL 0xLL
//
// or application[0], and four bytes of length specifier.
//
#define SPNEGO_MINIMUM_BUFFER   5


ULONG NegpUseSpnego = 1;
ULONG NegpUseSnegoServer = 0;
ULONG SyncTest = 0;

SECPKG_FUNCTION_TABLE   NegTable = {
            NULL,
            NULL,
            NegCallPackage,
            NegLogoffNotify,
            NegCallPackage,         // UNTRUSTED Is the same!
            NegCallPackagePassthrough,
            NULL,
            NegLogonUserEx2,
            NegInitialize,
            NegShutdown,
            NegGetInfo,
            NegAcceptCredentials,
            NegAcquireCredentialsHandle,
            NegQueryCredentialsAttributes,
            NegFreeCredentialsHandle,
            NegSaveCredentials,
            NegGetCredentials,
            NegDeleteCredentials,
            NegInitLsaModeContext,
            NegAcceptLsaModeContext,
            NegDeleteLsaModeContext,
            NegApplyControlToken,
            NegGetUserInfo,
            NegGetExtendedInformation,
            NegQueryContextAttributes,
            NULL
            };

//
// Microsoft Security Mechanisms OID Branch:
//
// iso(1) org(3) dod(6) internet(1) private(4) enterprise(1) microsoft(311)
//   security(2)
//     mechanisms(2)
//
//          Loopback Detect (9)
//          <RPCID> - The RPC Id is stuck here, e.g.
//          NTLM (10)
//          SSL (12)
//

UCHAR           NegSpnegoMechEncodedOid[] =
                                       { 0x06, 0x7,
                                         0x2b, 0x6,0x1,0x5,0x5,0x2};
ObjectID        NegSpnegoMechOid;
UCHAR           NegMSMechanismsOid[] = { 0x06, 0x0a,                // DER prefix
                                         0x2b, 0x06, 0x01, 0x04, 0x01,
                                         0x82, 0x37, 0x02, 0x02, 0x00 };

const UCHAR     NegKerberosOid[]     = { 0x06, 0x09,                // DER prefix
                                         0x2a, 0x86, 0x48, 0x86, 0xf7,
                                         0x12, 0x01, 0x02, 0x02 };

const UCHAR     NegKerberosLegacyOid[] = { 0x06, 0x09,              // DER prefix
                                         0x2a, 0x86, 0x48, 0x82, 0xf7,
                                         0x12, 0x01, 0x02, 0x02 };



UNICODE_STRING  NegLocalHostName_U ;
WCHAR           NegLocalHostName[] = L"localhost";
DWORD_PTR       NegPackageId;
DWORD_PTR       NtlmPackageId = NEG_INVALID_PACKAGE;
ObjectID        NegNtlmMechOid ;

WCHAR           NegPackageName[] = NEGOSSP_NAME ;
WCHAR           NegPackageComment[] = TEXT("Microsoft Package Negotiator");
NT_PRODUCT_TYPE NegProductType;

// computer names (protected by NegComputerNamesLock)
UNICODE_STRING  NegNetbiosComputerName_U;
UNICODE_STRING  NegDnsComputerName_U;
LIST_ENTRY      NegPackageList;
LIST_ENTRY      NegCredList;
LIST_ENTRY      NegDefaultCredList ;
RTL_RESOURCE    NegLock;
PLSAP_SECURITY_PACKAGE NegLsaPackage ;
LIST_ENTRY      NegLoopbackList ;
LIST_ENTRY      NegLogonSessionList ;
RTL_CRITICAL_SECTION NegLogonSessionListLock ;
RTL_CRITICAL_SECTION NegTrustListLock ;
PNEG_TRUST_LIST NegTrustList ;
LARGE_INTEGER   NegTrustTime ;
RTL_CRITICAL_SECTION    NegComputerNamesLock;
RTL_RESOURCE         NegCredListLock;
PVOID           NegNotifyHandle;
DWORD           NegPackageCount;
PUCHAR          NegBlob;
DWORD           NegBlobSize;
DWORD           NegOptions;
ULONG           NegMachineState;
BOOL            NegUplevelDomain ;
ULONG           NegNegotiationControl = 1 ;
HANDLE          NegRegistryWatchEvent ;
WCHAR           NegComputerName[ DNS_MAX_NAME_LENGTH ];

typedef struct _NEG_CONTEXT_REQ_MAP {
#define NEG_CONFIG_REQUIRED     0x00000001
#define NEG_CONFIG_OPTIONAL     0x00000002

    ULONG   Level ;
    ULONG   ConfigFlags ;
    ULONG   ContextReq ;
    ULONG   PackageFlag ;
} NEG_CONTEXT_REQ_MAP, * PNEG_CONTEXT_REQ_MAP ;


NEG_CONTEXT_REQ_MAP
NegContextReqMap[] = {
    { 0, NEG_CONFIG_REQUIRED, (ISC_REQ_REPLAY_DETECT | ISC_REQ_SEQUENCE_DETECT | ISC_REQ_INTEGRITY), SECPKG_FLAG_INTEGRITY },
    { 0, NEG_CONFIG_REQUIRED, (ISC_REQ_CONFIDENTIALITY) , SECPKG_FLAG_PRIVACY },
    { 2, NEG_CONFIG_OPTIONAL, (ISC_REQ_MUTUAL_AUTH), SECPKG_FLAG_MUTUAL_AUTH },
    { 0, 0, 0, 0 }
};

typedef DWORD (APIENTRY LOGON_NOTIFY)(
    LPCWSTR, PLUID, LPCWSTR, LPVOID,
    LPCWSTR, LPVOID, LPWSTR, LPVOID,
    LPWSTR * );

typedef LOGON_NOTIFY * PLOGON_NOTIFY;

VOID
NegpNotifyNetworkProviders(
    IN PUNICODE_STRING UserName,
    IN PSECPKG_PRIMARY_CRED PrimaryCred
    );

//
// Primary and secondary credentials used for LocalSystem
//

SECPKG_PRIMARY_CRED       NegPrimarySystemCredentials;



extern "C"
SECURITY_STATUS
SEC_ENTRY
NegpValidateBuffer(
    PUCHAR Buffer,
    ULONG Length
    )
{
    UCHAR Test ;
    ULONG ClaimedLength ;
    ULONG ByteCount ;
    ULONG i ;

    if ( Length == 0 )
    {
        return STATUS_SUCCESS ;
    }
    //
    // This does a poor man's validation of the BER encoded SNEGO buffer
    //

    //
    // First, make sure the first byte is a BER value for Context Specific
    //

    Test = Buffer[0] & 0xC0 ;


    if ( (Test != 0x80 ) &&
         (Test != 0x40 ) )
    {
        DebugLog(( DEB_ERROR, "Neg:  Buffer does not lead off with 'Context' or 'Application' specific\n"));
        goto Bad_Buffer ;
    }

    //
    // Now, check the claimed size in the header with the size we were passed:
    //

    Buffer++ ;
    ClaimedLength = 0 ;

    if (*Buffer & 0x80)
    {
        ByteCount = *Buffer++ & 0x7f;

        for (i = 0; i < ByteCount ; i++ )
        {
            ClaimedLength <<= 8;
            ClaimedLength += *Buffer++;
        }
    }
    else
    {
        ByteCount = 0;
        ClaimedLength = *Buffer++;
    }

    if ( (ClaimedLength + 2 + ByteCount) != Length )
    {
        DebugLog(( DEB_ERROR, "Neg: Packet claimed length %x, actual length is %x\n",
                    ClaimedLength + 2 + ByteCount, Length ));

        goto Bad_Buffer ;
    }

    return STATUS_SUCCESS ;

Bad_Buffer:

    return STATUS_DATA_ERROR ;


}





//+---------------------------------------------------------------------------
//
//  Function:   NegpFindPackage
//
//  Synopsis:   Scans the list of negotiable packages for a package id
//
//  Arguments:  [PackageId] --
//
//  History:    8-13-96   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
PNEG_PACKAGE
NegpFindPackage(
    ULONG_PTR PackageId )
{
    PNEG_PACKAGE    Scan;

    NegReadLockList();

    Scan = (PNEG_PACKAGE) NegPackageList.Flink ;

    while ( Scan != (PNEG_PACKAGE) &NegPackageList )
    {
        if ( Scan->LsaPackage->dwPackageID == PackageId )
        {
            break;
        }

        Scan = (PNEG_PACKAGE) Scan->List.Flink ;

    }

    NegUnlockList();

    if ( Scan != (PNEG_PACKAGE) &NegPackageList )
    {
        return( Scan );
    }

    return( NULL );
}

//+---------------------------------------------------------------------------
//
//  Function:   NegpFindPackageByName
//
//  Synopsis:   Scans the list of negotiable packages for a package name
//
//  Arguments:  [PackageId] --
//
//  History:    8-13-96   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
PNEG_PACKAGE
NegpFindPackageByName(
    PUNICODE_STRING PackageName )
{
    PNEG_PACKAGE    Scan;

    NegReadLockList();

    Scan = (PNEG_PACKAGE) NegPackageList.Flink ;

    while ( Scan != (PNEG_PACKAGE) &NegPackageList )
    {
        if ( RtlEqualUnicodeString(
                &Scan->LsaPackage->Name,
                PackageName,
                TRUE            // case insensitive
                ))
        {
            break;
        }

        Scan = (PNEG_PACKAGE) Scan->List.Flink ;

    }

    NegUnlockList();

    if ( Scan != (PNEG_PACKAGE) &NegPackageList )
    {
        return( Scan );
    }

    return( NULL );
}

//+---------------------------------------------------------------------------
//
//  Function:   NegpFindPackageByOid
//
//  Synopsis:   Locates a security package by OID.
//
//  Arguments:  [Id] --
//
//  History:    4-23-97   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
PNEG_PACKAGE
NegpFindPackageByOid(
    ObjectID    Id
    )
{
    PNEG_PACKAGE    Scan ;
    PLIST_ENTRY List ;
    ULONG i ;

    NegReadLockList();

    List = NegPackageList.Flink ;
    Scan = NULL ;

    while ( List != &NegPackageList )
    {
        Scan = CONTAINING_RECORD( List, NEG_PACKAGE, List );

        if ( NegpCompareOid( Id, Scan->ObjectId ) == 0 )
        {
            break;
        }

        List = List->Flink ;
        Scan = NULL ;
    }

    NegUnlockList();

    return Scan ;
}




ULONG
NegGetPackageCaps(
    ULONG ContextReq
    )
{
    ULONG PackageCap = 0;
    PNEG_CONTEXT_REQ_MAP Scan ;

    Scan = NegContextReqMap ;

    while ( Scan->ContextReq )
    {
        if ( Scan->ConfigFlags & NEG_CONFIG_REQUIRED )
        {
            if ( (Scan->ContextReq & ContextReq ) != 0 )
            {
                PackageCap |= Scan->PackageFlag ;
            }
        }
        else if ( Scan->ConfigFlags & NEG_CONFIG_OPTIONAL )
        {
            if ( NegNegotiationControl >= Scan->Level )
            {
                if ( ( Scan->ContextReq & ContextReq ) != 0 )
                {
                    PackageCap |= Scan->PackageFlag ;
                }
            }
            else
            {
                PackageCap |= 0 ;
            }
        }

        Scan++ ;
    }

    return PackageCap ;

}


//+---------------------------------------------------------------------------
//
//  Function:   NegPackageLoad
//
//  Synopsis:   Called by LSA whenever a package is loaded
//
//  Arguments:  [p] --
//
//  History:    7-30-96   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
DWORD
WINAPI
NegPackageLoad(
    PVOID   p)
{
    NTSTATUS Status ;
    PSECPKG_EVENT_NOTIFY Notify;
    PSECPKG_EVENT_PACKAGE_CHANGE Load;
    PNEG_PACKAGE Package;
    PNEG_PACKAGE ExtraPackage ;
    PLSAP_SECURITY_PACKAGE LsaPackage;
    PSECPKG_EXTENDED_INFORMATION Info ;
    SECPKG_EXTENDED_INFORMATION LocalInfo ;
    ObjectID ClaimedOid = NULL;
    UCHAR Prefix[ NEGOTIATE_MAX_PREFIX ] = { 0 };
    ULONG PrefixLength = 0 ;
    ULONG ExtraOidsCount = 0 ;
    ULONG i ;
    BOOLEAN fKerberosPackage = FALSE;

    Notify = (PSECPKG_EVENT_NOTIFY) p;

    if ( Notify->EventClass != NOTIFY_CLASS_PACKAGE_CHANGE )
    {
        return( 0 );
    }


    Load = ( PSECPKG_EVENT_PACKAGE_CHANGE ) Notify->EventData ;

    DebugLog((DEB_TRACE_NEG, "Package Change Event %d:  %ws (%p) \n",
            Load->ChangeType, Load->PackageName.Buffer, Load->PackageId ));

    if ( Load->PackageId == NegPackageId )
    {
        DebugLog((DEB_TRACE_NEG, "Skipping own load notification\n"));

        NegLsaPackage = SpmpLocatePackage( NegPackageId );

        return( 0 );
    }

    //
    // If this is a package load, add the package to our list:
    //

    if ( Load->ChangeType == SECPKG_PACKAGE_CHANGE_LOAD )
    {
        Info = NULL ;

        LsaPackage = SpmpLookupPackage( &Load->PackageName );

        if (LsaPackage == NULL)
        {
            return( 0 );
        }

        if ( !( LsaPackage->fCapabilities & SECPKG_FLAG_NEGOTIABLE ) )
        {
            return( 0 );
        }

        //
        // If the package supports SP_INFO, query it to see if it has an
        // OID to use in negotiation.
        //

        if ( LsaPackage->fPackage & SP_INFO )
        {
            Status = LsapGetExtendedPackageInfo( LsaPackage,
                                                 SecpkgGssInfo,
                                                 &Info );

            if ( !NT_SUCCESS( Status ) )
            {
                Info = NULL ;
            }

            //
            // Make sure that the claimed OID doesn't conflict with
            // someone already loaded.
            //

            if ( Info )
            {
                ClaimedOid = NegpDecodeObjectId( Info->Info.GssInfo.EncodedId,
                                                 Info->Info.GssInfo.EncodedIdLength );

                RtlCopyMemory( Prefix,
                               Info->Info.GssInfo.EncodedId,
                               Info->Info.GssInfo.EncodedIdLength );

                PrefixLength = Info->Info.GssInfo.EncodedIdLength ;

                //
                // note whether the primary GSS Oid is the kerberos Oid.
                // This allows us to swap the order of the Primary Oid with the legacy Oid
                // later on.
                //

                if ( (Info->Info.GssInfo.EncodedIdLength == sizeof(NegKerberosOid)) &&
                     (memcmp(Info->Info.GssInfo.EncodedId, NegKerberosOid, sizeof(NegKerberosOid)) == 0 )
                    )
                {
                    fKerberosPackage = TRUE;
                }

                LsapFreeLsaHeap( Info );
                if (ClaimedOid == NULL)
                {
                     Info = NULL;
                }
                else if ( NegpFindPackageByOid( ClaimedOid ) )
                {
                    NegpFreeObjectId( ClaimedOid );

                    return 0 ;
                }
            }

            //
            // Check if the package has any additional OIDs to support, or to compensate
            // for a spnego encoding problem.
            //

            Status = LsapGetExtendedPackageInfo( LsaPackage,
                                                 SecpkgExtraOids,
                                                 &Info );

            if ( !NT_SUCCESS( Status ) )
            {
                Info = NULL ;
            }

            LocalInfo.Class = SecpkgMutualAuthLevel ;
            LocalInfo.Info.MutualAuthLevel.MutualAuthLevel = NegNegotiationControl ;

            LsapSetExtendedPackageInfo(
                LsaPackage,
                SecpkgMutualAuthLevel,
                &LocalInfo );


        }

        //
        // If no ID, and Info is NULL, skip it.
        //

        if ( (LsaPackage->dwRPCID == SECPKG_ID_NONE) &&
             (ClaimedOid == NULL ) )
        {
            if( Info != NULL )
            {
                LsapFreeLsaHeap( Info );
            }

            return( 0 );
        }

        if ( ( Info != NULL ) &&
             ( Info->Class == SecpkgExtraOids ) )
        {
            ExtraOidsCount = Info->Info.ExtraOids.OidCount ;

        }


        Package = (PNEG_PACKAGE) LsapAllocateLsaHeap( sizeof( NEG_PACKAGE ) );

        if ( Package )
        {
            Package->LsaPackage = LsaPackage ;
            Package->Flags = NEG_PACKAGE_INBOUND | NEG_PACKAGE_OUTBOUND ;

            if ( LsaPackage->fPackage & SP_PREFERRED )
            {
                Package->Flags |= NEG_PREFERRED ;
            }

            if ( LsaPackage->dwRPCID == RPC_C_AUTHN_WINNT )
            {
                Package->Flags |= NEG_NT4_COMPAT ;

                NtlmPackageId = Load->PackageId;

                //
                // Cheap and sleazy way of loading the necessary information
                // into the logon session, once we have all the packages loaded.
                //

                NegLsaPolicyChangeCallback( PolicyNotifyDnsDomainInformation );

            }

            Package->TokenSize = LsaPackage->TokenSize ;
            Package->PackageFlags = LsaPackage->fCapabilities ;
            Package->PrefixLen = PrefixLength ;
            RtlCopyMemory( Package->Prefix,
                           Prefix,
                           PrefixLength );

            //
            // add slack space for negotiate header.
            //

            NegLsaPackage->TokenSize = max( (LsaPackage->TokenSize+128),
                                            NegLsaPackage->TokenSize );


            DebugLog(( DEB_TRACE_NEG, "Loaded package %ws\n",
                                Load->PackageName.Buffer ));

            NegWriteLockList();

            if ( ClaimedOid )
            {
                Package->ObjectId = ClaimedOid ;

                NegDumpOid( "Package claimed OID", Package->ObjectId );
            }
            else
            {

                NegMSMechanismsOid[ 0xb ] = (UCHAR) LsaPackage->dwRPCID ;

                Package->ObjectId = NegpDecodeObjectId( NegMSMechanismsOid,
                                                sizeof( NegMSMechanismsOid ) );

                NegDumpOid( "Assigned package OID", Package->ObjectId );

                if ( Package->Flags & NEG_NT4_COMPAT )
                {
                    NegNtlmMechOid = NegpDecodeObjectId( NegMSMechanismsOid,
                                                sizeof( NegMSMechanismsOid ) );
                }

            }

            InsertTailList( &NegPackageList,
                            &Package->List );

            NegPackageCount ++;

            if ( ExtraOidsCount )
            {
                Package->Flags |= NEG_PACKAGE_HAS_EXTRAS ;

                DebugLog(( DEB_TRACE_NEG, "Creating extra packages for %ws\n",
                           Load->PackageName.Buffer ));

                for ( i = 0 ; i < ExtraOidsCount ; i++ )
                {
                    ClaimedOid = NegpDecodeObjectId( Info->Info.ExtraOids.Oids[ i ].OidValue,
                                                     Info->Info.ExtraOids.Oids[ i ].OidLength );


                    if ( !NegpFindPackageByOid( ClaimedOid ))
                    {
                        //
                        // If no one else has used this OID, allow it.
                        //


                        NegDumpOid( "Package claimed extra OID", ClaimedOid );

                        ExtraPackage = (PNEG_PACKAGE) LsapAllocateLsaHeap( sizeof( NEG_PACKAGE ) );

                        if ( ExtraPackage )
                        {
                            ExtraPackage->LsaPackage = Package->LsaPackage ;
                            ExtraPackage->ObjectId = ClaimedOid ;
                            ExtraPackage->RealPackage = Package ;
                            ExtraPackage->Flags = NEG_PACKAGE_EXTRA_OID ;

                            if ( Info->Info.ExtraOids.Oids[ i ].OidAttributes & SECPKG_CRED_INBOUND )
                            {
                                ExtraPackage->Flags |= NEG_PACKAGE_INBOUND ;
                            }

                            if ( Info->Info.ExtraOids.Oids[ i ].OidAttributes & SECPKG_CRED_OUTBOUND )
                            {
                                ExtraPackage->Flags |= NEG_PACKAGE_OUTBOUND ;
                            }

                            ExtraPackage->TokenSize = Package->TokenSize ;
                            ExtraPackage->PackageFlags = Package->PackageFlags ;

                            RtlCopyMemory(
                                ExtraPackage->Prefix,
                                Info->Info.ExtraOids.Oids[ i ].OidValue,
                                Info->Info.ExtraOids.Oids[ i ].OidLength );

                            ExtraPackage->PrefixLen = Info->Info.ExtraOids.Oids[ i ].OidLength ;

                            //
                            // **** NOTE: ****
                            // For legacy compatibility reasons,
                            // the broken Kerberos package Oid is re-ordered ahead
                            // of the correct Oid value.  The was done in order
                            // to avoid an extra round-trip when communicating with
                            // Win2000 machines.  The negotiate protocol itself
                            // recovers with additional round-trips; however,
                            // Wininet is unable to reliably handle such a
                            // circumstance.
                            //

                            if( fKerberosPackage &&
                                (Info->Info.ExtraOids.Oids[ i ].OidLength == sizeof(NegKerberosLegacyOid)) &&
                                (memcmp(Info->Info.ExtraOids.Oids[ i ].OidValue, NegKerberosLegacyOid, sizeof(NegKerberosLegacyOid)) == 0)
                                )
                            {
                                ObjectID SwapOid;

                                DebugLog((DEB_TRACE_NEG, "Re-ordering legacy Kerberos Oid\n"));

                                SwapOid = Package->ObjectId;

                                Package->ObjectId = ExtraPackage->ObjectId;
                                ExtraPackage->ObjectId = SwapOid;
                            }

                            InsertTailList( &NegPackageList,
                                            &ExtraPackage->List );

                            NegPackageCount ++;

                        }
                        else
                        {
                            //
                            // Free the OID, skip this extra package
                            //

                            NegpFreeObjectId( ClaimedOid );
                        }
                    }
                    else
                    {
                        //
                        // Free it
                        //

                        NegpFreeObjectId( ClaimedOid );
                    }


                }


            }
            NegUnlockList();

        }

        if( Info != NULL )
        {
            LsapFreeLsaHeap( Info );
            Info = NULL;
        }

    }
    else
    {
        //
        // It's either a select or an unload:
        //



        Package = NegpFindPackage( Load->PackageId );

        //
        // if we don't have this package (it may not have been negotiable)
        // return now.
        //

        if (Package == NULL)
        {
            return(0);
        }

        if ( Load->ChangeType == SECPKG_PACKAGE_CHANGE_SELECT )
        {
            Package->Flags |= NEG_PREFERRED ;
        }
        else
        {
            NegWriteLockList();

            RemoveEntryList( &Package->List );

            NegUnlockList();

            NegpFreeObjectId( Package->ObjectId );

            LsapFreeLsaHeap( Package );

        }
    }

    return( 0 );

}


//+---------------------------------------------------------------------------
//
//  Function:   NegpParseBuffers
//
//  Synopsis:   Parse out juicy bits
//
//  Arguments:  [pMessage] --
//              [pToken]   --
//              [pEmpty]   --
//
//  History:    8-19-96   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
SECURITY_STATUS
NegpParseBuffers(
    PSecBufferDesc  pMessage,
    BOOL            Map,
    PSecBuffer *    pToken,
    PSecBuffer *    pEmpty)
{
    ULONG       i;
    SECURITY_STATUS scRet ;
    PSecBuffer  pFirstBlank = NULL;
    PSecBuffer  pWholeMessage = NULL;
    PSecBuffer  pFirstToken = NULL;

    scRet = SEC_E_OK ;

    for (i = 0 ; i < pMessage->cBuffers ; i++ )
    {
        if ( (pMessage->pBuffers[i].BufferType & (~SECBUFFER_ATTRMASK)) == SECBUFFER_TOKEN )
        {
            pWholeMessage = &pMessage->pBuffers[i];

            if ( pFirstToken == NULL )
            {
                pFirstToken = pWholeMessage;
            }

            if ( Map )
            {
                scRet = LsapMapClientBuffer( pWholeMessage, pWholeMessage );
            }

            if (pFirstBlank)
            {
                break;
            }
        }
        else if ( (pMessage->pBuffers[i].BufferType & (~SECBUFFER_ATTRMASK)) == SECBUFFER_EMPTY )
        {
            pFirstBlank = &pMessage->pBuffers[i];
            if (pWholeMessage)
            {
                break;
            }
        }
    }

    if (pToken)
    {
//        *pToken = pWholeMessage;

        //
        // NTBUG: 405976
        // down-level RDR supplies 2 SECBUFFER_TOKEN buffers, the second
        // one containing creds.  Insure we return the first one.
        //

        *pToken = pFirstToken;
    }

    if (pEmpty)
    {
        *pEmpty = pFirstBlank;
    }

    return( scRet );

}




//+---------------------------------------------------------------------------
//
//  Function:   NegInitialize
//
//  Synopsis:   Initialize the built in negotiate package
//
//  Arguments:  [dwProtocol]    --
//              [dwPackageID]   --
//              [pParameters]   --
//              [pPkgFunctions] --
//
//  History:    7-26-96   RichardW   Created
//
//  Notes:      This package must be the last package, since it must query
//              the others to find out their capabilities.
//
//----------------------------------------------------------------------------
SECURITY_STATUS
SEC_ENTRY
NegInitialize(
                ULONG_PTR           dwPackageID,
                PSECPKG_PARAMETERS  pParameters,
                PLSA_SECPKG_FUNCTION_TABLE  Table)
{
    HKEY LsaKey ;
    int err ;
    DWORD size ;
    DWORD type ;
    NTSTATUS Status ;

    NegPackageId = dwPackageID;

    Status = RtlInitializeCriticalSection( &NegComputerNamesLock );

    if ( !NT_SUCCESS( Status ) )
    {
        return Status ;
    }

    NegNotifyHandle = LsaIRegisterNotification( NegPackageLoad,
                                                0,
                                                NOTIFIER_TYPE_NOTIFY_EVENT,
                                                NOTIFY_CLASS_PACKAGE_CHANGE,
                                                0,
                                                0,
                                                0 );

    InitializeListHead( &NegDefaultCredList );

    InitializeListHead( &NegLoopbackList );

    InitializeListHead( &NegLogonSessionList );


    Status = RtlInitializeCriticalSection( &NegLogonSessionListLock );

    if ( !NT_SUCCESS( Status ) )
    {
        return Status ;
    }

    Status = RtlInitializeCriticalSection( &NegTrustListLock );

    if ( !NT_SUCCESS( Status ) )
    {
        return Status ;
    }

    RtlInitUnicodeString( &NegLocalHostName_U, NegLocalHostName );

    __try
    {

        RtlInitializeResource( &NegLock );
        Status = STATUS_SUCCESS ;
    }
    __except( EXCEPTION_EXECUTE_HANDLER )
    {
        Status = GetExceptionCode();
    }

    if ( !NT_SUCCESS( Status ) )
    {
        return Status ;
    }

    InitializeListHead( &NegPackageList );

    __try
    {
        RtlInitializeResource( &NegCredListLock );
        Status = STATUS_SUCCESS ;
    }
    __except( EXCEPTION_EXECUTE_HANDLER )
    {
        Status = GetExceptionCode();
    }

    if ( !NT_SUCCESS( Status ) )
    {
        return Status ;
    }

    InitializeListHead( &NegCredList );

    NegPackageCount = 0;

    NegSpnegoMechOid = NegpDecodeObjectId(NegSpnegoMechEncodedOid, sizeof(NegSpnegoMechEncodedOid));
    if (NegSpnegoMechOid == NULL)
    {
        return(STATUS_INSUFFICIENT_RESOURCES);
    }

    NegMachineState = pParameters->MachineState;

    if ( ( pParameters->DomainSid != NULL ) &&
         ( pParameters->DnsDomainName.Length != 0 ) )
    {
        NegUplevelDomain = TRUE ;
    }

    //
    // Ignore the status - if we don't get a callback, then we can't support
    // dynamic domain change.  If it succeeds, then great.
    //

    LsaIRegisterPolicyChangeNotificationCallback(
                NegLsaPolicyChangeCallback,
                PolicyNotifyDnsDomainInformation );

    LsaIRegisterNotification( NegParamChange,
                              0,
                              NOTIFIER_TYPE_NOTIFY_EVENT,
                              NOTIFY_CLASS_REGISTRY_CHANGE,
                              0,
                              0,
                              0 );
    //
    // get the product type for loopback logic.
    //

    if (!RtlGetNtProductType( &NegProductType ) )
    {
        NegProductType = NtProductWinNt;
    }

    err = RegOpenKeyEx(
                HKEY_LOCAL_MACHINE,
                TEXT("System\\CurrentControlSet\\Control\\Lsa"),
                0,
                KEY_READ,
                &LsaKey );

    if ( err == 0 )
    {
        NegpReadRegistryParameters( LsaKey );

        RegCloseKey( LsaKey );
    }

    return(S_OK);
}


VOID
NegpReadRegistryParameters(
    HKEY LsaKey
    )
{
    DWORD size ;
    DWORD type ;
    int err ;

    //
    // These values are not MP sensitive, so we just blast the new value
    // into them.
    //

    size = sizeof( DWORD );

    err = RegQueryValueEx(
            LsaKey,
            TEXT("NegotiationLevel"),
            NULL,
            &type,
            (LPBYTE) &NegNegotiationControl,
            &size );

    if ( err != 0 )
    {
        NegNegotiationControl = NEG_NEGLEVEL_COMPATIBILITY ;
    }

    size = sizeof( DWORD );

    err = RegQueryValueEx(
            LsaKey,
            TEXT("NegotiationLogLevel"),
            NULL,
            &type,
            (LPBYTE) &NegEventLogLevel,
            &size );

    if ( err )
    {
        NegEventLogLevel = (1 << EVENTLOG_ERROR_TYPE ) |
                           (1 << EVENTLOG_WARNING_TYPE ) ;
    }
}


//+---------------------------------------------------------------------------
//
//  Function:   NegGetInfo
//
//  Synopsis:   Negotiate Package GetInfo call
//
//  Arguments:  [pInfo] --
//
//  History:    7-26-96   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
SECURITY_STATUS
SEC_ENTRY
NegGetInfo(PSecPkgInfo pInfo)
{

    pInfo->wVersion         = 1;
    pInfo->wRPCID           = NEGOSSP_RPCID ;

    if( NegLsaPackage == NULL )
    {
        pInfo->fCapabilities    = SECPKG_FLAG_INTEGRITY |
                                    SECPKG_FLAG_PRIVACY |
                                    SECPKG_FLAG_CONNECTION |
                                    SECPKG_FLAG_MULTI_REQUIRED |
                                    SECPKG_FLAG_EXTENDED_ERROR |
                                    SECPKG_FLAG_IMPERSONATION |
                                    SECPKG_FLAG_ACCEPT_WIN32_NAME |
                                    SECPKG_FLAG_NEGOTIABLE |
                                    SECPKG_FLAG_GSS_COMPATIBLE |
                                    SECPKG_FLAG_LOGON;
    
        pInfo->cbMaxToken       = 500;
    
    } else {
        pInfo->fCapabilities    = NegLsaPackage->fCapabilities;
        pInfo->cbMaxToken       = NegLsaPackage->TokenSize ;
    }

    pInfo->Name             = NEGOSSP_NAME;
    pInfo->Comment          = NegPackageComment;

    return(S_OK);
}


//+---------------------------------------------------------------------------
//
//  Function:   NegAcceptCredentials
//
//  Synopsis:   Notification of a logon
//
//  Arguments:  [LogonType]         --
//              [UserName]          --
//              [PrimaryCred]       --
//              [SupplementalCreds] --
//
//  History:    7-30-96   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
SECURITY_STATUS SEC_ENTRY
NegAcceptCredentials(
    IN SECURITY_LOGON_TYPE LogonType,
    IN PUNICODE_STRING UserName,
    IN PSECPKG_PRIMARY_CRED PrimaryCred,
    IN PSECPKG_SUPPLEMENTAL_CRED SupplementalCreds)
{
    LUID     SystemId = SYSTEM_LUID;
    NTSTATUS Status;

    if (RtlEqualLuid(&PrimaryCred->LogonId, &SystemId))
    {
        //
        // Stash away the LocalSystem credentials to use
        // for NetworkService logons later on.
        //

        RtlEnterCriticalSection( &NegComputerNamesLock );

        Status = NegpCopyCredsToBuffer(PrimaryCred,
                                       NULL,
                                       &NegPrimarySystemCredentials,
                                       NULL);

        RtlLeaveCriticalSection(&NegComputerNamesLock);

        return Status;

    }
    else if (LogonType == Service)
    {
        LUID  LocalServiceId   = LOCALSERVICE_LUID;
        LUID  NetworkServiceId = NETWORKSERVICE_LUID;

        //
        // Notify the network providers of the logon.  Don't notify
        // for SYSTEM, LocalService, or NetworkService.
        //

        if (!RtlEqualLuid(&PrimaryCred->LogonId, &LocalServiceId)
             &&
            !RtlEqualLuid(&PrimaryCred->LogonId, &NetworkServiceId))
        {
            NegpNotifyNetworkProviders(UserName, PrimaryCred);
        }
    }

    return SEC_E_OK;
}


//+-------------------------------------------------------------------------
//
//  Function:   NegpNotifyNetworkProviders
//
//  Synopsis:   Notifies network providers of a logon
//
//  Effects:
//
//  Arguments:  [UserName]    --
//              [PrimaryCred] --
//
//  Requires:
//
//  Returns:  Nothing since this is an advisory service to
//            other network providers.
//
//  Notes:
//
//--------------------------------------------------------------------------

VOID
NegpNotifyNetworkProviders(
    IN PUNICODE_STRING UserName,
    IN PSECPKG_PRIMARY_CRED PrimaryCred
    )
{
    MSV1_0_INTERACTIVE_LOGON    OldLogon;
    MSV1_0_INTERACTIVE_LOGON    NewLogon;
    static HMODULE              s_hMprDll = NULL;
    PLOGON_NOTIFY               pfLogonNotify = NULL;
    LPWSTR                      lpLogonScripts = NULL;
    DWORD                       dwStatus;

    if (s_hMprDll == NULL)
    {
        s_hMprDll = LoadLibrary(L"mpr.dll");
    }

    if (s_hMprDll != NULL)
    {
        pfLogonNotify = (PLOGON_NOTIFY) GetProcAddress(s_hMprDll,
                                                       "WNetLogonNotify");

        if (pfLogonNotify != NULL)
        {
            NewLogon.MessageType     = MsV1_0InteractiveLogon;
            NewLogon.LogonDomainName = PrimaryCred->DomainName;
            NewLogon.UserName        = *UserName;
            NewLogon.Password        = PrimaryCred->Password;

            RtlCopyMemory(&OldLogon, &NewLogon, sizeof(NewLogon));

            dwStatus = pfLogonNotify(L"Windows NT Network Provider",
                                     &PrimaryCred->LogonId,
                                     L"MSV1_0:Interactive",
                                     &NewLogon,
                                     L"MSV1_0:Interactive",
                                     &OldLogon,
                                     L"SvcCtl",            // StationName
                                     NULL,                 // StationHandle
                                     &lpLogonScripts);     // LogonScripts

            if (dwStatus == NO_ERROR)
            {
                LocalFree(lpLogonScripts);
            }
        }
    }
}


//+-------------------------------------------------------------------------
//
//  Function:   NegpCopyCredsToBuffer
//
//  Synopsis:   Copies primary and supplemental creds into the supplied
//              buffers
//
//  Effects:
//
//  Arguments:  [PrimaryCred]          --
//              [SupplementalCred]     --
//              [PrimaryCredCopy]      --
//              [SupplementalCredCopy] --
//
//  Requires:
//
//  Returns:
//
//  Notes:      Leaves the SID and LUID blank.  It is the caller's
//              responsibility to fill these fields in.
//
//--------------------------------------------------------------------------

NTSTATUS
NegpCopyCredsToBuffer(
    IN  PSECPKG_PRIMARY_CRED      PrimaryCred,
    IN  PSECPKG_SUPPLEMENTAL_CRED SupplementalCred,
    OUT PSECPKG_PRIMARY_CRED      PrimaryCredCopy OPTIONAL,
    OUT PSECPKG_SUPPLEMENTAL_CRED SupplementalCredCopy OPTIONAL
    )
{
    NTSTATUS Status = STATUS_SUCCESS;

    if (PrimaryCredCopy)
    {
        Status = LsapDuplicateString(&PrimaryCredCopy->DomainName,
                                     &PrimaryCred->DomainName);

        if (!NT_SUCCESS(Status))
        {
            goto ErrorExit;
        }

        Status = LsapDuplicateString(&PrimaryCredCopy->DownlevelName,
                                     &PrimaryCred->DownlevelName);

        if (!NT_SUCCESS(Status))
        {
            goto ErrorExit;
        }

        Status = LsapDuplicateString(&PrimaryCredCopy->Password,
                                     &PrimaryCred->Password);

        if (!NT_SUCCESS(Status))
        {
            goto ErrorExit;
        }

        PrimaryCredCopy->Flags = PRIMARY_CRED_CLEAR_PASSWORD;
    }

    if (SupplementalCredCopy)
    {
        Status = LsapDuplicateString(&SupplementalCredCopy->PackageName,
                                     &SupplementalCred->PackageName);

        if (!NT_SUCCESS(Status))
        {
            goto ErrorExit;
        }

        SupplementalCredCopy->Credentials = (PUCHAR) (SupplementalCredCopy + 1);

        RtlCopyMemory(SupplementalCredCopy,
                      SupplementalCred->Credentials,
                      SupplementalCred->CredentialSize);

    }

    return Status;

ErrorExit:

    if (PrimaryCredCopy)
    {
        LsapFreeLsaHeap(PrimaryCredCopy->DomainName.Buffer);
        RtlZeroMemory(&PrimaryCredCopy->DomainName, sizeof(UNICODE_STRING));

        LsapFreeLsaHeap(PrimaryCredCopy->DownlevelName.Buffer);
        RtlZeroMemory(&PrimaryCredCopy->DownlevelName, sizeof(UNICODE_STRING));

        LsapFreeLsaHeap(PrimaryCredCopy->Password.Buffer);
        RtlZeroMemory(&PrimaryCredCopy->Password, sizeof(UNICODE_STRING));
    }

    return Status;
}


//+-------------------------------------------------------------------------
//
//  Function:   NegpCaptureSuppliedCreds
//
//  Synopsis:   Captures a SEC_WINNT_AUTH_IDENTITY_EX structure from
//              the client
//
//  Effects:
//
//  Arguments:  AuthorizationData - Client address of auth data
//              PackageList - List of packages from the auth data.
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------

NTSTATUS
NegpCaptureSuppliedCreds(
    IN PVOID AuthorizationData,
    OUT PNEG_PACKAGE ** ReturnedPackageList,
    OUT PULONG ReturnedPackageCount,
    OUT PBOOL ExplicitCreds,
    OUT PBOOL DomainExplicitCreds
    )
{
    NTSTATUS Status = STATUS_SUCCESS;
    SEC_WINNT_AUTH_IDENTITY_EXW IdentityEx = {0};
    SEC_WINNT_AUTH_IDENTITY_W * Identity;
    PSTR PackageList = NULL;
    UNICODE_STRING PackageString = {0};
    ULONG PackageListLength;
    ULONG CharSize = sizeof(WCHAR);
    ULONG Index;
    ULONG PackageCount;
    ULONG PackageIndex;
    ULONG ExclusionIndex ;
    ULONG FinalIndex ;
    ULONG PossiblePackageCount ;
    ULONG i, j;
    PNEG_PACKAGE * LocalPackageList = NULL;
    PNEG_PACKAGE * ExclusionList = NULL ;
    PNEG_PACKAGE * FinalList = NULL ;
    PNEG_PACKAGE Package ;
    PLIST_ENTRY List ;
    PNEG_PACKAGE PackageScan ;
    UNICODE_STRING TempString;
    PWSTR Scan, EndPoint, Comma ;



    *ReturnedPackageList = NULL;
    *ReturnedPackageCount = 0;

    *ExplicitCreds = FALSE ;
    *DomainExplicitCreds = FALSE ;


    //
    // First capture the base structure
    //

    Status =  LsapCopyFromClientBuffer(
                    NULL,
                    sizeof(SEC_WINNT_AUTH_IDENTITY_W),
                    &IdentityEx,
                    AuthorizationData
                    );
    if (!NT_SUCCESS(Status))
    {
        DebugLog((DEB_ERROR,"Failed to copy auth data from %p client address: 0x%x\n",
            AuthorizationData, Status ));
        *ExplicitCreds = TRUE ;
        Status = STATUS_SUCCESS;
        goto Cleanup;
    }

    //
    // Check if this is the right structure
    //

    if (IdentityEx.Version != SEC_WINNT_AUTH_IDENTITY_VERSION)
    {
        Identity = (PSEC_WINNT_AUTH_IDENTITY_W) &IdentityEx ;

        if ( (Identity->UserLength > 0 ) ||
             (Identity->DomainLength > 0 ) ||
             (Identity->PasswordLength > 0 ||
              Identity->Password != NULL) )
        {
            *ExplicitCreds = TRUE ;

            if( Identity->DomainLength )
            {
                *DomainExplicitCreds = TRUE;
            }
        }
        goto Cleanup;
    }

    //
    // Copy the whole data structure now
    //

    Status =  LsapCopyFromClientBuffer(
                    NULL,
                    sizeof(SEC_WINNT_AUTH_IDENTITY_EXW),
                    &IdentityEx,
                    AuthorizationData
                    );
    if (!NT_SUCCESS(Status))
    {
        DebugLog((DEB_ERROR,"Failed to copy auth data from %p client address: 0x%x\n",
            AuthorizationData, Status ));
        *ExplicitCreds = TRUE ;
        //
        // Mask this error, as it may have been data for another package.
        //
        Status = STATUS_SUCCESS;
        goto Cleanup;
    }

    //
    // Check to see if this contains a list of packages
    //
    //


    if (IdentityEx.Flags & SEC_WINNT_AUTH_IDENTITY_ANSI)
    {
        CharSize = sizeof(CHAR);
    }


    //
    // If there was no packge list in the data, return now.
    //

    if ( ( IdentityEx.UserLength > 0 ) ||
         ( IdentityEx.DomainLength > 0 ) ||
         ( IdentityEx.PasswordLength > 0 ||
           IdentityEx.Password != NULL ) )
    {
        *ExplicitCreds = TRUE ;

        if( IdentityEx.DomainLength )
        {
            *DomainExplicitCreds = TRUE;
        }
    }

    if ((IdentityEx.Length < sizeof(SEC_WINNT_AUTH_IDENTITY_EXW)) ||
        (IdentityEx.PackageList == NULL) ||
        (IdentityEx.PackageListLength == 0))
    {
        Status = STATUS_SUCCESS;
        goto Cleanup;
    }

    if ( (IdentityEx.PackageListLength + 1) * CharSize < IdentityEx.PackageListLength )
    {
        //
        // Passed size is too large (we rolled over)
        //

        Status = STATUS_INVALID_PARAMETER ;
        goto Cleanup ;
    }

    //
    // Capture the package list itself
    //

    SafeAllocaAllocate(PackageList, CharSize * (IdentityEx.PackageListLength + 1));

    if (PackageList == NULL)
    {
        Status = SEC_E_INSUFFICIENT_MEMORY;
        goto Cleanup;
    }

    Status = LsapCopyFromClientBuffer(
                NULL,
                CharSize * IdentityEx.PackageListLength,
                PackageList,
                IdentityEx.PackageList
                );
    if (!NT_SUCCESS(Status))
    {
        DebugLog((DEB_ERROR,"Failed to copy package list\n"));
        goto Cleanup;
    }


    //
    // Conver the package list into a useable form, including changing
    // character sets.
    //

    if (CharSize == sizeof(CHAR))
    {
        ((LPSTR)PackageList)[IdentityEx.PackageListLength] = '\0';
        if ( !RtlCreateUnicodeStringFromAsciiz(
                    &PackageString,
                    PackageList
                    ) )
        {
            goto Cleanup;
        }
    }
    else
    {
        ((LPWSTR)PackageList)[IdentityEx.PackageListLength] = L'\0';
        RtlInitUnicodeString(
            &PackageString,
            (LPWSTR) PackageList
            );
        PackageList = NULL;
    }

    //
    // Scan through counting for ',' separators to get a count of packages.
    //

    PackageCount = 1;
    for (Index = 0; Index < PackageString.Length / sizeof(WCHAR) ; Index++ )
    {
        if (PackageString.Buffer[Index] == L',')
        {
            PackageCount++;
        }
    }

    //
    // If there was nothing in the list, continue as if it wasn't there
    //

    if (PackageCount == 0)
    {
        Status = STATUS_SUCCESS;
        goto Cleanup;
    }

    //
    // Allocate the package list
    //

    SafeAllocaAllocate(LocalPackageList, PackageCount * sizeof(PNEG_PACKAGE));

    if (LocalPackageList == NULL)
    {
        Status = SEC_E_INSUFFICIENT_MEMORY;
        goto Cleanup;
    }

    SafeAllocaAllocate(ExclusionList, PackageCount * sizeof(PNEG_PACKAGE));

    if ( ExclusionList == NULL )
    {
        Status = SEC_E_INSUFFICIENT_MEMORY ;
        goto Cleanup ;
    }


    //
    // Now go through the string of packages and build the list
    //

    PackageIndex = 0;
    ExclusionIndex = 0;
    TempString.Buffer = PackageString.Buffer;
    TempString.Length = 0;
    TempString.MaximumLength = PackageString.MaximumLength;

    Index = 0;
    Scan = PackageString.Buffer ;
    EndPoint = Scan + (PackageString.Length / sizeof( WCHAR ));

    while ( Scan < EndPoint )
    {
        Comma = wcschr( Scan, L',' );

        if ( Comma )
        {
            *Comma = L'\0' ;
        }
        if ( *Scan == L'!' )
        {
            //
            // This entry is an exclusion.  Skip past the ! char,
            // and try to find a package
            //

            Scan++ ;

            if ( Scan != Comma )
            {
                RtlInitUnicodeString( &TempString, Scan );

                ExclusionList[ ExclusionIndex ] = NegpFindPackageByName( &TempString );

                if ( ExclusionList[ ExclusionIndex ] != NULL )
                {
                    ExclusionIndex++ ;
                }
            }
        }
        else
        {
            //
            // This entry is a request.  Try to find the package
            //

            RtlInitUnicodeString( &TempString, Scan );

            LocalPackageList[ PackageIndex ] = NegpFindPackageByName( &TempString );

            if ( LocalPackageList[ PackageIndex ] != NULL )
            {
                PackageIndex++ ;
            }

        }

        if ( Comma )
        {
            *Comma = L',';
            Scan = Comma + 1 ;
        }
        else
        {
            Scan = EndPoint ;
        }
    }

    //
    // Now, we have two lists.  We have an ExclusionList, of packages that the caller
    // does not want, and a package list, a list of things that the caller does want.
    // Merge the list according to the requests
    //

    PossiblePackageCount = NegPackageCount ;
    FinalIndex = 0 ;
    FinalList = (PNEG_PACKAGE *) LsapAllocateLsaHeap( PossiblePackageCount * sizeof( PNEG_PACKAGE ) );

    if ( FinalList == NULL )
    {
        Status = SEC_E_INSUFFICIENT_MEMORY ;
        goto Cleanup ;
    }

    for ( i = 0 ; i < PackageIndex ; i++ )
    {
        //
        // Pick a package off the request list
        //

        Package = LocalPackageList[ i ];

        //
        // Scan through the exclusion list, see if we need to skip it.
        //

        for ( j = 0 ; j < ExclusionIndex ; j++ )
        {
            if ( Package == ExclusionList[ j ] )
            {
                break;
            }
        }

        if ( j < ExclusionIndex )
        {
            //
            // if we broke out of the loop, we found this on the exclusion list.
            // skip it by continuing the for-i loop.
            //

            continue;
        }

        //
        // Ok, this package is not excluded.  So add it to the final list
        //

        FinalList[ FinalIndex ] = Package;
        FinalIndex++ ;

        //
        // See if this package has "extra" packages by the same name with
        // other OIDs associated with it
        //

        if ( (Package->Flags & NEG_PACKAGE_HAS_EXTRAS) != 0 )
        {
            //
            // Ok, there are a set of packages associated with this package.  Walk the
            // package list, and stick the extras into this one.
            //

            NegReadLockList();

            List = NegPackageList.Flink ;

            while ( List != &NegPackageList )
            {
                PackageScan = CONTAINING_RECORD( List, NEG_PACKAGE, List );

                if ( PackageScan->RealPackage == Package )
                {
                    FinalList[ FinalIndex ] = PackageScan ;
                    FinalIndex++ ;
                }

                List = List->Flink ;
            }

            NegUnlockList();

        }

    }

    if ( (PackageIndex == 0) &&
         (ExclusionIndex != 0 ) )
    {
        //
        // Only an exclusion list was provided.  Walk all the packages,
        // and add those that are not excluded.
        //

        NegReadLockList();


        for (List = NegPackageList.Flink; List != &NegPackageList; List = List->Flink)
        {
            PackageScan = CONTAINING_RECORD( List, NEG_PACKAGE, List );

            if ( ( PackageScan->Flags & NEG_PACKAGE_EXTRA_OID ) != 0 )
            {
                Package = PackageScan->RealPackage ;
            }
            else
            {
                Package = PackageScan ;
            }

            for ( i = 0 ; i < ExclusionIndex ; i++ )
            {
                if ( Package == ExclusionList[ i ] )
                {
                    break;
                }
            }

            if ( i < ExclusionIndex )
            {
                continue;
            }

            FinalList[ FinalIndex ] = PackageScan ;
            FinalIndex++ ;

        }

        NegUnlockList();
    }

    //
    // If no packages succeeded, return an error
    //

    if (PackageIndex == 0)
    {
        Status = SEC_E_SECPKG_NOT_FOUND;
        goto Cleanup;
    }
    *ReturnedPackageCount = FinalIndex;
    *ReturnedPackageList = FinalList;
    FinalList = NULL;

Cleanup:


    if (PackageList != NULL)
    {

        SafeAllocaFree(PackageList);

        if (PackageString.Buffer != NULL)
        {
            RtlFreeUnicodeString( &PackageString );
        }
    }
    else
    {

        SafeAllocaFree(PackageString.Buffer);
    }

    SafeAllocaFree(LocalPackageList);
    SafeAllocaFree(ExclusionList);

    if ( FinalList != NULL )
    {
        LsapFreeLsaHeap( FinalList );
    }

    return(Status);
}


//+-------------------------------------------------------------------------
//
//  Function:   NegpBuildPackageList
//
//  Synopsis:   Builds the list of packages for the caller
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------

NTSTATUS
NegpBuildPackageList(
    IN ULONG_PTR LogonPackageId,
    IN ULONG fCredentials,
    OUT PNEG_PACKAGE ** ReturnedPackageList,
    OUT PULONG ReturnedPackageCount
    )
{
    NTSTATUS Status = STATUS_SUCCESS;
    PNEG_PACKAGE Package;
    PNEG_PACKAGE ClientNegPackage = NULL;
    PNEG_PACKAGE *PackageList = NULL;
    PLIST_ENTRY Scan ;
    ULONG PackageIndex = 0;
    ULONG PackageMask ;

    *ReturnedPackageList = NULL;
    *ReturnedPackageCount = 0;

    PackageList = (PNEG_PACKAGE *) LsapAllocateLsaHeap(NegPackageCount * sizeof(PNEG_PACKAGE));
    if (PackageList == NULL)
    {
        Status = SEC_E_INSUFFICIENT_MEMORY;
        goto Cleanup;
    }

    //
    // Find the client's logon package
    //

    Scan = NegPackageList.Flink ;

    Package = (PNEG_PACKAGE) NegPackageList.Flink ;

    while ( Scan != &NegPackageList )
    {
        Package = CONTAINING_RECORD( Scan, NEG_PACKAGE, List );

        if (Package->LsaPackage->dwPackageID == LogonPackageId)
        {
            ClientNegPackage = Package;
            break;
        }
        Scan = Scan->Flink ;

    }

    //
    // Compute a mask of package flags to use as part of the selection
    // process.  This is currently based on the credential use flags passed in
    //

    PackageMask = 0 ;

    if ( fCredentials & SECPKG_CRED_INBOUND )
    {
        PackageMask |= NEG_PACKAGE_INBOUND ;
    }

    if ( fCredentials & SECPKG_CRED_OUTBOUND )
    {
        PackageMask |= NEG_PACKAGE_OUTBOUND ;
    }

    //
    // Build the list of packages, with the logon package first
    //


    if ( ClientNegPackage )
    {
        PackageList[ PackageIndex ] = ClientNegPackage ;
        PackageIndex = 1;
    }

    Scan = NegPackageList.Flink ;

    while ( Scan != &NegPackageList )
    {
        Package = CONTAINING_RECORD( Scan, NEG_PACKAGE, List );

        //
        // ClientNegPackage has already been processed, skip it
        //

        if ( Package != ClientNegPackage )
        {
            //
            // Make sure that the package flags support the request.
            //

            if ( (Package->Flags & PackageMask ) == PackageMask )
            {
                PackageList[PackageIndex] = Package;
                PackageIndex++;
            }

        }

        Scan = Scan->Flink ;
    }

    *ReturnedPackageList = PackageList;
    PackageList = NULL;
    *ReturnedPackageCount = PackageIndex;
Cleanup:
    if (PackageList != NULL)
    {
        LsapFreeLsaHeap(PackageList);
    }
    return(Status);

}


//+-------------------------------------------------------------------------
//
//  Function:   NegpCheckForDuplicateCreds
//
//  Synopsis:   Check to see if this is a duplicate of another
//              credential
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------
BOOLEAN
NegpCheckForDuplicateCreds(
    IN PNEG_CREDS * Credential
    )
{
    PLIST_ENTRY Next;
    PNEG_CREDS MatchCred;
    PNEG_CREDS LocalCred = *Credential;

    NegReadLockCredList();

    for (Next = NegCredList.Flink; Next != &NegCredList; Next = Next->Flink )
    {
        MatchCred = CONTAINING_RECORD(
                        Next,
                        NEG_CREDS,
                        List
                        );

        if(!( MatchCred->ClientProcessId == LocalCred->ClientProcessId ) )
        {
            continue;
        }

        if(!RtlEqualLuid( &MatchCred->ClientLogonId, &LocalCred->ClientLogonId ) )
        {
            continue;
        }

        //
        // Check if this credential has the same credentials
        // as the one we just created.  Make sure they are both
        // from user or kernel mode (don't mix'n'match)
        //

        if ( ( MatchCred->Count == LocalCred->Count ) &&
             ( MatchCred->Flags == LocalCred->Flags ) &&
             ( (MatchCred->Flags & NEGCRED_DUP_MASK ) == (LocalCred->Flags & NEGCRED_DUP_MASK ) ) )
        {
            if ( !RtlEqualMemory(
                        MatchCred->Creds,
                        LocalCred->Creds,
                        LocalCred->Count * sizeof( NEG_CRED_HANDLE ) ) )
            {
                ULONG i ;

                DebugLog(( DEB_TRACE_NEG, "Same Process, same count, differing handles?\n" ));
                for ( i = 0 ; i < LocalCred->Count ; i++ )
                {
                    DebugLog(( DEB_TRACE_NEG, "  %d: new <%p : %p> existing (%p : %p)\n",
                               i,
                               LocalCred->Creds[i].Handle.dwLower,
                               LocalCred->Creds[i].Handle.dwUpper,
                               MatchCred->Creds[i].Handle.dwLower,
                               MatchCred->Creds[i].Handle.dwUpper ));

                }
            }
            else
            {
                ULONG_PTR PackageId;
                ULONG i ;

                NegWriteLockCreds( MatchCred );

                if( MatchCred->RefCount == 0 )
                {
                    NegUnlockCreds( MatchCred );
                    continue;
                }

                MatchCred->RefCount++ ;

                NegUnlockCreds( MatchCred );
                NegUnlockCredList();

                //
                // blot out the handle so the refcount is kept in sync
                // with what the underlying packages believe.
                //

                PackageId = GetCurrentPackageId();

                for ( i = 0 ; i < LocalCred->Count ; i++ )
                {
                    if( (LocalCred->Creds[i].Flags & NEG_CREDHANDLE_EXTRA_OID) == 0 )
                    {
                        WLsaFreeCredHandle( &LocalCred->Creds[i].Handle );
                    }

                    LocalCred->Creds[i].Handle.dwLower = NEG_INVALID_PACKAGE;
                    LocalCred->Creds[i].Handle.dwUpper = NEG_INVALID_PACKAGE;
                }

                SetCurrentPackageId( PackageId );

                NegpReleaseCreds( LocalCred, FALSE );

                *Credential = MatchCred ;

                return TRUE;
            }
        }
    }

    NegUnlockCredList( );

    return FALSE;

}



SECURITY_STATUS
NegpAcquireCredHandle(
    PSECURITY_STRING    psPrincipal,
    ULONG               fCredentials,
    PLUID               pLogonID,
    PVOID               pvAuthData,
    PVOID               pvGetKeyFn,
    PVOID               pvGetKeyArgument,
    PULONG_PTR          pdwHandle,
    PTimeStamp          ptsExpiry)
{

    NEG_CRED_HANDLE Creds[ NEG_MECH_LIMIT ];
    PNEG_CRED_HANDLE pCreds = NULL;
    DWORD i = 0;
    ULONG Index, ExtraCredFlags = 0;
    BOOL        FreeCreds = FALSE;
    PNEG_PACKAGE Package;
    PNEG_PACKAGE ClientNegPackage = NULL;
    PNEG_PACKAGE * AuthPackageList = NULL;
    ULONG AuthPackageCount = 0;
    SECURITY_STATUS scRet = STATUS_SUCCESS;
    TimeStamp   Expiry = { 0 };

    PNEG_CREDS  pNegCreds = NULL ;
    ULONG_PTR PackageId;
    SECPKG_CLIENT_INFO ClientInfo;
    PLSA_CALL_INFO CallInfo ;
    PLSAP_LOGON_SESSION LogonSession = NULL;
    PNEG_LOGON_SESSION NegLogonSession = NULL ;
    PSession pSession ;
    TimeStamp MinExpiry = { 0xFFFFFFFF, 0x7FFFFFFF };
    PLUID ClientLogonId;
    ULONG_PTR ClientPackage = -1;
    ULONG_PTR ClientDefaultPackage = -1;
    BOOL ExplicitCreds = FALSE ;
    BOOL DomainExplicitCreds = FALSE ;
    LUID LocalSystem = SYSTEM_LUID ;
    BOOLEAN EnableLoopback = TRUE;
    
    DebugLog(( DEB_TRACE_NEG, "NegAcquireCredentialsHandle: Get a Negotiate CredHandle:\n"));

    //
    // Determine caller info
    //

    scRet = LsapGetClientInfo(&ClientInfo);
    if (!NT_SUCCESS(scRet))
    {
        goto Cleanup;
    }

    CallInfo = LsapGetCurrentCall();

    pSession = GetCurrentSession();

    //
    // Get the callers Logon ID so we can determine what package to try first
    //

    if (ARGUMENT_PRESENT(pLogonID) && ((pLogonID->LowPart != 0) || (pLogonID->HighPart != 0)))
    {
        ClientLogonId = pLogonID;
    }
    else
    {
        ClientLogonId = &ClientInfo.LogonId;
    }

    //
    // Now find out what package logged this user on
    //

    NegLogonSession = NegpLocateLogonSession( ClientLogonId );

    if ( NegLogonSession == NULL )
    {
        LogonSession = LsapLocateLogonSession( ClientLogonId );
        if (LogonSession != NULL)
        {
            PLSAP_SECURITY_PACKAGE  LsaPackage ;
            BOOLEAN                LocalAccount;

            
            ClientPackage = LogonSession->CreatingPackage; 
            LocalAccount = RtlEqualUnicodeString(
                            &LogonSession->AuthorityName,
                            &MachineName,
                            TRUE
                            );
            
            LsapReleaseLogonSession( LogonSession );

            //
            // If this was done by an old style package, that is,
            // an NT4 style auth pkg, *or* some one calling MSV in
            // the old fashioned way, reset the value to the negotiate
            // ID to allow full negotiation range.
            //

            LsaPackage = SpmpLocatePackage( ClientPackage );

            if ( LsaPackage )
            {
                if ( ( LsaPackage->fPackage & SPM_AUTH_PKG_FLAG ) != 0 )
                {
                    ClientPackage = NegPackageId ;
                }
                else if ( !LocalAccount && LsaPackage->dwRPCID == NTLMSP_RPCID  )
                {
                    //
                    // On NTLM generated ASC contexts, make sure that we can still
                    // use kerberos, if appropriate.  This allows constrained delegation
                    // to work.
                    //
                    DebugLog(( DEB_TRACE_NEG, "Switching NTLM ASC session to unknown\n"));
                    ClientPackage = NEG_INVALID_PACKAGE;
                    ExtraCredFlags |= NEGCRED_ALLOW_NTLM;
                }
            }
            
        }
    }
    else
    {
        ClientPackage = NegLogonSession->DefaultPackage ;

        NegpDerefLogonSession( NegLogonSession );

        NegLogonSession = NULL ;
    }

    ClientDefaultPackage = ClientPackage;

    NegReadLockList();

    //
    // If authentication data was passed in, capture it now to see
    // if it includes a subset of the packages to use.
    //

    if (ARGUMENT_PRESENT(pvAuthData))
    {
        ClientPackage = NEG_INVALID_PACKAGE ;

        scRet = NegpCaptureSuppliedCreds(
                    pvAuthData,
                    &AuthPackageList,
                    &AuthPackageCount,
                    &ExplicitCreds,
                    &DomainExplicitCreds
                    );
        if (!NT_SUCCESS(scRet))
        {
            NegUnlockList();
            goto Cleanup;
        }
    }


    //
    // turn off loopback detection when:
    // 1. explicit credentials were supplied.
    // 2. Product is domain controller, and client is local system account
    //    (this will cause system->system to auth using machine account.)
    //

    if( ExplicitCreds )
    {
        EnableLoopback = FALSE;
    }

    if (!RtlEqualLuid( ClientLogonId, &LocalSystem ))
    {
        if( ClientPackage == NegPackageId )
        {
            ExplicitCreds = TRUE ;
        }
    } else {
        if( NegProductType == NtProductLanManNt )
        {
            EnableLoopback = FALSE;
        }
    }

    //
    // Build the list of packages that we'll call to get credentials
    //

    if (AuthPackageCount == 0)
    {
        scRet = NegpBuildPackageList(
                    ClientPackage,
                    fCredentials,
                    &AuthPackageList,
                    &AuthPackageCount
                    );

        if (!NT_SUCCESS(scRet))
        {
            NegUnlockList();
            goto Cleanup;
        }
    }

    if ( AuthPackageCount < NEG_MECH_LIMIT )
    {
        pCreds = Creds;
        ZeroMemory( Creds, sizeof(Creds) );
    }
    else
    {

        SafeAllocaAllocate(pCreds, NegPackageCount * sizeof(NEG_CRED_HANDLE));

        if ( !pCreds )
        {
            NegUnlockList();

            scRet = SEC_E_INSUFFICIENT_MEMORY;
            goto Cleanup;
        }
    }

    i = 0;

    for (Index = 0; Index < AuthPackageCount ; Index++ )
    {
        BOOLEAN SkipAcquire = FALSE;

        PackageId = GetCurrentPackageId();

        ULONG_PTR ThisPackageId = (ULONG_PTR)AuthPackageList[Index]->LsaPackage->dwPackageID;
        DWORD j;

        //
        // mask off the DEFAULT flag, since only we understand it
        //

        //
        // skip calling the package if there are multiple aliases (oids)
        // that point to the same underlying package.
        // note: NegpReleaseCreds() duplicate handle values are ignored
        // during credential release.
        //

        for( j = 0 ; j < i ; j ++ )
        {
            if( pCreds[j].Handle.dwLower == ThisPackageId )
            {
                CopyMemory( &pCreds[i].Handle, &pCreds[j].Handle, sizeof(pCreds[i].Handle) );

                SkipAcquire = TRUE;
                break;
            }
        }

        if( !SkipAcquire )
        {
            scRet = WLsaAcquireCredHandle(  psPrincipal,
                                            &AuthPackageList[Index]->LsaPackage->Name,
                                            fCredentials & ( SECPKG_CRED_BOTH),
                                            pLogonID,
                                            pvAuthData,
                                            pvGetKeyFn,
                                            pvGetKeyArgument,
                                            &pCreds[i].Handle,
                                            &Expiry );

            pCreds[i].Flags = 0;

        } else {

            //
            // no need to AddCredHandle(), as, that would put us out of sync with
            // the underlying package ref count.
            //

            pCreds[i].Flags = NEG_CREDHANDLE_EXTRA_OID;

            scRet = SEC_E_OK;
        }

        SetCurrentPackageId( PackageId );

        if ( NT_SUCCESS( scRet ) )
        {
            if( !SkipAcquire )
            {
                DebugLog((DEB_TRACE_NEG, "   Added %p:%p, %ws\n",
                        pCreds[i].Handle.dwUpper, pCreds[i].Handle.dwLower,
                        AuthPackageList[Index]->LsaPackage->Name.Buffer ));
            } else {
                DebugLog((DEB_TRACE_NEG, " Skipped %p:%p, %ws (duplicate)\n",
                            pCreds[i].Handle.dwUpper, pCreds[i].Handle.dwLower,
                            AuthPackageList[Index]->LsaPackage->Name.Buffer ));
            }

            if ( Expiry.QuadPart < MinExpiry.QuadPart )
            {
                MinExpiry.QuadPart = Expiry.QuadPart ;
            }

            pCreds[i].Package = AuthPackageList[Index];

            i++;
        }
        else
        {
            DebugLog((DEB_TRACE_NEG, "Failed %x to get a cred handle for %ws\n",
                        scRet, AuthPackageList[Index]->LsaPackage->Name.Buffer ));
        }

    }

    NegUnlockList();

    if ( i == 0 )
    {
        //
        // Did not get any subordinate credentials, return an error now
        //
        scRet = SEC_E_NO_CREDENTIALS;
        goto Cleanup;
    }

    //
    // Now, allocate our cred structure, and copy all the found cred handles
    // into it.
    //

    pNegCreds = (PNEG_CREDS) LsapAllocateLsaHeap( sizeof( NEG_CREDS ) +
                                        sizeof( NEG_CRED_HANDLE ) * ( i - ANYSIZE_ARRAY ) );

    if ( pNegCreds == NULL)
    {
        scRet = SEC_E_INSUFFICIENT_MEMORY;
        goto Cleanup;
    }

    FreeCreds = TRUE ;

    pNegCreds->Count = i;
    pNegCreds->Flags = ExtraCredFlags ;
    pNegCreds->Tag = NEGCRED_TAG ;
    pNegCreds->DefaultPackage = ClientDefaultPackage;

    if ( fCredentials & NEGOTIATE_ALLOW_NTLM )
    {
        pNegCreds->Flags |= NEGCRED_ALLOW_NTLM ;
    }

    if ( fCredentials & NEGOTIATE_NEG_NTLM )
    {
        pNegCreds->Flags |= NEGCRED_NEG_NTLM ;
    }

    //
    // WARNING:  Change to w2k behavior.  Enabling loopback detection
    // to switch to NTLM
    //

    if ( EnableLoopback )
    {
        pNegCreds->Flags |= NEGCRED_NTLM_LOOPBACK ;
    }

    pNegCreds->ClientLogonId = *ClientLogonId ;

    pNegCreds->ClientProcessId = ClientInfo.ProcessID;

    pNegCreds->Expiry = MinExpiry ;

    RtlCopyMemory(
        pNegCreds->Creds,
        pCreds,
        i * sizeof( NEG_CRED_HANDLE ) );

    if ( ( CallInfo->CallInfo.Attributes & SECPKG_CALL_KERNEL_MODE ) != 0 )
    {
        pNegCreds->Flags |= NEGCRED_KERNEL_CALLER ;
    }

    if ( ExplicitCreds )
    {
        pNegCreds->Flags |= NEGCRED_EXPLICIT_CREDS ;

        if( DomainExplicitCreds )
        {
            pNegCreds->Flags |= NEGCRED_DOMAIN_EXPLICIT_CREDS ;
        }
    }

    //
    // If this isn't a duplicate, return
    // a new credential
    //

    if (!NegpCheckForDuplicateCreds(
            &pNegCreds
            ))
    {

        //
        // Finish creating the credential
        //

        scRet = RtlInitializeCriticalSection( &pNegCreds->CredLock );

        if ( !NT_SUCCESS( scRet ) )
        {
            goto Cleanup ;
        }

        pNegCreds->RefCount = 1;

        NegWriteLockCredList();

        InsertTailList( &NegCredList,
                        &pNegCreds->List );

        NegUnlockCredList();
    }

    *pdwHandle = (ULONG_PTR) pNegCreds ;

    *ptsExpiry = pNegCreds->Expiry;

    scRet = SEC_E_OK;

    FreeCreds = FALSE ;


Cleanup:

    if (!NT_SUCCESS(scRet))
    {
        //
        // Free all the handles. Because the WLsa calls set the package
        // ID make sure we always reset it.
        //

        PackageId = GetCurrentPackageId();

        while ( i-- )
        {
            if( (pCreds[i].Flags & NEG_CREDHANDLE_EXTRA_OID) == 0 )
            {
                WLsaFreeCredHandle( &pCreds[i].Handle );
            }

            SetCurrentPackageId( PackageId );
        }
    }

    if ( FreeCreds )
    {
        if ( pNegCreds )
        {
            LsapFreeLsaHeap( pNegCreds );
        }
    }

    if (pCreds != Creds)
    {
        SafeAllocaFree(pCreds);
    }

    if (AuthPackageList != NULL)
    {
        LsapFreeLsaHeap(AuthPackageList);
    }

    DsysAssert( NegLogonSession == NULL );

    DebugLog(( DEB_TRACE_NEG, "NegAcquireCredentialsHandle: returned 0x%x\n", scRet));
    return(scRet);
}


//+---------------------------------------------------------------------------
//
//  Function:   NegAcquireCredentialsHandle
//
//  Synopsis:   Acquire a Negotiate credential handle
//
//  Arguments:  [psPrincipal]      --
//              [fCredentials]     --
//              [pLogonID]         --
//              [pvAuthData]       --
//              [pvGetKeyFn]       --
//              [pvGetKeyArgument] --
//              [pdwHandle]        --
//              [ptsExpiry]        --
//
//  Requires:
//
//  Returns:
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:
//
//  History:    7-26-96   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
SECURITY_STATUS SEC_ENTRY
NegAcquireCredentialsHandle(
            PSECURITY_STRING    psPrincipal,
            ULONG               fCredentials,
            PLUID               pLogonID,
            PVOID               pvAuthData,
            PVOID               pvGetKeyFn,
            PVOID               pvGetKeyArgument,
            PULONG_PTR          pdwHandle,
            PTimeStamp          ptsExpiry)
{


    return  NegpAcquireCredHandle(
                psPrincipal,
                fCredentials,
                pLogonID,
                pvAuthData,
                pvGetKeyFn,
                pvGetKeyArgument,
                pdwHandle,
                ptsExpiry );



}


//+---------------------------------------------------------------------------
//
//  Function:   SpQueryCredentialsAttributes
//
//  Synopsis:   Implements QueryCredentialsAttributes by passing off to the
//              first package that we got a cred handle from.
//
//  Arguments:  [dwCredHandle] --
//              [dwAttribute]  --
//              [Buffer]       --
//
//  History:    9-17-96   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
SECURITY_STATUS
NegQueryCredentialsAttributes(
    LSA_SEC_HANDLE dwCredHandle,
    ULONG   dwAttribute,
    PVOID   Buffer)
{
    PNEG_CREDS  Creds;
    SECURITY_STATUS Status;
    ULONG_PTR PackageId ;
    CredHandle TempCredHandle;

    Creds = (PNEG_CREDS) dwCredHandle ;

    NegReadLockCreds( Creds );
    TempCredHandle = Creds->Creds[0].Handle;
    NegUnlockCreds( Creds );

    PackageId = GetCurrentPackageId();

    Status = WLsaQueryCredAttributes(
                &TempCredHandle,
                dwAttribute,
                Buffer );

    SetCurrentPackageId( PackageId );

    return( Status );
}

//+---------------------------------------------------------------------------
//
//  Function:   NegpReleaseCreds
//
//  Synopsis:   Releases credential storage when ref count goes to zero
//
//  Arguments:  [pCreds] --
//
//  History:    8-12-96   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
VOID
NegpReleaseCreds(
    PNEG_CREDS  pCreds,
    BOOLEAN     CleanupCall
    )
{
    BOOL NoLock = FALSE ;

    //
    // Remove it from the list:
    //


    if ( pCreds->List.Flink )
    {
        RemoveEntryList( &pCreds->List );
        DebugLog(( DEB_TRACE_NEG, "Releasing credentials %p\n", pCreds ));
    }
    else
    {
        NoLock = TRUE ;
        DebugLog(( DEB_TRACE_NEG, "Releasing credentials %p (dups or lockless)\n", pCreds ));
    }

    if ( !NoLock )
    {
        NegUnlockCreds( pCreds );

        RtlDeleteCriticalSection( &pCreds->CredLock );
    }

    //
    // free the embedded package creds.
    //

    if( !CleanupCall )
    {
        ULONG_PTR PackageId;
        DWORD   i;

        //
        // Free all associated handles:
        //

        i = pCreds->Count;

        PackageId = GetCurrentPackageId();

        while ( i-- )
        {
            if (((pCreds->Creds[i].Flags & NEG_CREDHANDLE_EXTRA_OID) == 0) &&
                 (pCreds->Creds[i].Handle.dwLower != 0) &&
                 (pCreds->Creds[i].Handle.dwLower != SPMGR_PKG_ID ) )
            {
                NTSTATUS scRet;

                scRet = WLsaFreeCredHandle( &pCreds->Creds[i].Handle );

                if( !NT_SUCCESS(scRet) )
                {
                    DebugLog(( DEB_ERROR, "Failed freeing credential %p:%p %x\n",
                                    pCreds->Creds[i].Handle.dwUpper,
                                    pCreds->Creds[i].Handle.dwLower,
                                    scRet ));

                    //DsysAssert( NT_SUCCESS(scRet) );
                }
            }

            SetCurrentPackageId( PackageId );
        }
    }

    LsapFreeLsaHeap( pCreds );
}

//+---------------------------------------------------------------------------
//
//  Function:   NegFreeCredentialsHandle
//
//  Synopsis:   Release a negotiate cred handle
//
//  Arguments:  [dwHandle] --
//
//  History:    7-26-96   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------

SECURITY_STATUS
SEC_ENTRY
NegFreeCredentialsHandle(
    LSA_SEC_HANDLE dwHandle
    )
{
    PNEG_CREDS  pCreds;
    ULONG DereferenceCount = 1;
    BOOLEAN CleanupCall = FALSE;

    SECPKG_CALL_INFO CallInfo;

    if(LsapGetCallInfo(&CallInfo))
    {
        //
        // nego internally calls NegFreeCredentialsHandle, so, insure
        // the refcount is always non-zero.
        // realistically speaking, the callcount is only > 1 on cleanup
        // disposition, but there is no reason to potentially destabilize
        // this already tenuous issue.
        //

        if( CallInfo.CallCount )
        {
            DereferenceCount = CallInfo.CallCount;
        }

        CleanupCall = ( (CallInfo.Attributes & SECPKG_CALL_CLEANUP) != 0 );
    }

    pCreds = (PNEG_CREDS) dwHandle ;

    NegWriteLockCreds( pCreds );

    ASSERT( pCreds->RefCount >= DereferenceCount );

    pCreds->RefCount -= DereferenceCount;

    if ( pCreds->RefCount == 0 )
    {
        NegUnlockCreds( pCreds );

        NegWriteLockCredList();
        NegWriteLockCreds( pCreds );

        if( pCreds->RefCount == 0 )
        {
            NegpReleaseCreds( pCreds, CleanupCall );
        } else {
            NegUnlockCreds( pCreds );
        }

        NegUnlockCredList();

    }
    else
    {
        NegUnlockCreds( pCreds );
    }

    return( SEC_E_OK );
}

//+---------------------------------------------------------------------------
//
//  Function:   NegpCreateContext
//
//  Synopsis:   Creates and zeroes a context
//
//  Arguments:  (none)
//
//  History:    10-05-96   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
PNEG_CONTEXT
NegpCreateContext(
    VOID
    )
{
    PNEG_CONTEXT    Context ;

    Context = (PNEG_CONTEXT) LsapAllocatePrivateHeap( sizeof( NEG_CONTEXT ) );

    if ( Context )
    {
        ZeroMemory( Context, sizeof( NEG_CONTEXT ) );

        Context->CheckMark = NEGCONTEXT_CHECK ;

        Context->Flags |= NEG_CONTEXT_UPLEVEL ;
    }

    return( Context );
}

//+---------------------------------------------------------------------------
//
//  Function:   NegpDeleteContext
//
//  Synopsis:   Free the data behind a context
//
//  Arguments:  [Context] --
//
//  History:    10-05-96   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
VOID
NegpDeleteContext(
    PNEG_CONTEXT    Context
    )
{
    ULONG_PTR PackageId;

    if ( !Context )
    {
        return ;
    }

    DsysAssert( Context->CheckMark == NEGCONTEXT_CHECK );

    if (Context->CheckMark != NEGCONTEXT_CHECK )
    {
        return;
    }

    if ( Context->Target.Buffer )
    {
        LsapFreePrivateHeap( Context->Target.Buffer );
    }

    if ( Context->Check && Context->Buffer )
    {
        Context->Check->Finish( & Context->Buffer );
    }

    if ( Context->MappedBuffer.pvBuffer != NULL)
    {
        LsapFreeLsaHeap(
            Context->MappedBuffer.pvBuffer
            );
    }

    if ( Context->Message )
    {
        LsapFreeLsaHeap( Context->Message );
    }

    if ( ( Context->Handle.dwLower != 0 ) &&
         ( Context->Handle.dwLower != SPMGR_PKG_ID ) )
    {
        PackageId = GetCurrentPackageId();

        WLsaDeleteContext( &Context->Handle );
        SetCurrentPackageId(PackageId);
    }

    //
    // If we referenced the credential, free it now.
    //

    if (Context->Creds != NULL)
    {
        NegFreeCredentialsHandle((ULONG_PTR) Context->Creds);
    }
    if (Context->SupportedMechs != NULL)
    {
        if ((Context->Flags & NEG_CONTEXT_FREE_EACH_MECH))
        {
            NegpFreeMechList(Context->SupportedMechs);
        }
        else
        {
            LsapFreeLsaHeap(Context->SupportedMechs);
        }
    }

    DebugLog(( DEB_TRACE_NEG, "Deleting context %x\n", Context ));

    LsapFreePrivateHeap( Context );

}

//+---------------------------------------------------------------------------
//
//  Function:   NegpFindPackageForOid
//
//  Synopsis:   Returns index for a package matching the OID passed in
//
//  Arguments:  [Creds] --
//              [Oid]   --
//
//  History:    9-25-96   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
ULONG_PTR
NegpFindPackageForOid(
    PNEG_CREDS  Creds,
    ObjectID    Oid)
{
    ULONG i;

    NegDumpOid( "Compare Mechanism", Oid );

    for ( i = 0 ; i < Creds->Count ; i++ )
    {
        if ( NegpCompareOid( Oid,
                             Creds->Creds[i].Package->ObjectId ) == 0 )
        {
            return( i );
        }

    }

    return( NEG_INVALID_PACKAGE );
}


//+---------------------------------------------------------------------------
//
//  Function:   NegBreakoutOnExplictCredentials
//
//  Synopsis:   
//
//  Effects:    Some errors from kerberos are not going to be continuable through NTLM.
//              For example, trying to use net use /smartcard could return a whole class of
//              errors we shouldn't be downgrading on..
//
//  Arguments:  
//
//  History:    4/15/2002 Todds Created
//
//  Notes:
//
//---

BOOLEAN
NegBreakoutOnExplictCredentials(
    SECURITY_STATUS ScRet,
    ULONG           CredFlags
    )
{   
    switch (ScRet)
    {
        case STATUS_LOGON_FAILURE:
        case STATUS_WRONG_PASSWORD:
            if (( CredFlags & NEGCRED_DOMAIN_EXPLICIT_CREDS ) != 0)
            {
                DebugLog(( DEB_TRACE_NEG, "Breakout due to %x on domain creds\n", ScRet));
                return TRUE;
            }
            break;          
        case STATUS_SMARTCARD_SUBSYSTEM_FAILURE:
        case STATUS_SMARTCARD_WRONG_PIN:
        case STATUS_SMARTCARD_NO_CARD:
        case STATUS_PASSWORD_MUST_CHANGE:
        case STATUS_SMARTCARD_CERT_REVOKED:
        case STATUS_PKINIT_CLIENT_FAILURE:
        case STATUS_SMARTCARD_CERT_EXPIRED:
        case STATUS_ISSUING_CA_UNTRUSTED:
        case STATUS_SMARTCARD_CARD_NOT_AUTHENTICATED:
        case STATUS_SMARTCARD_CARD_BLOCKED:  
        case STATUS_SMARTCARD_SILENT_CONTEXT:
            DebugLog((DEB_TRACE_NEG, "Breakout due to PKI error %x\n", ScRet));
            return TRUE;
        default:
            return FALSE;
    }                    

    return FALSE;
}


//+---------------------------------------------------------------------------
//
//  Function:   NegBuildRequestToken
//
//  Synopsis:   Generates a NegotiateRequest token, for either client or server
//              side inits.  Generates a NEG_CONTEXT and the token to be sent
//              to the other side.
//
//  Effects:    Lots of work
//
//  Arguments:  [ServerSideInit] --
//              [Creds]          --
//              [pszTargetName]  --
//              [fContextReq]    --
//              [TargetDataRep]  --
//              [ServerMechs]    --
//              [pContext]       --
//              [pOutput]        --
//
//  History:    9-30-96   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
SECURITY_STATUS
NegBuildRequestToken(
    IN BOOL                ServerSideInit,
    IN PNEG_CREDS          Creds,
    IN PSECURITY_STRING    pszTargetName,
    IN ULONG               fContextReq,
    IN ULONG               TargetDataRep,
    IN struct MechTypeList *ServerMechs,
    IN PSECURITY_STRING    NegotiateHint,
    OUT PNEG_CONTEXT *     pContext,
    OUT PSecBufferDesc     pOutput,
    PTimeStamp             ptsExpiry)
{
    InitialNegToken    Request ;
    SECURITY_STATUS     scRet ;
    SECURITY_STATUS     scRetPrior = STATUS_SUCCESS;
    struct MechTypeList CommonMechs[ NEG_MECH_LIMIT ];
    struct MechTypeList *MechList = CommonMechs;
    ULONG               MatchingPackages[ NEG_MECH_LIMIT ];
    struct MechTypeList *pMechs ;
    struct MechTypeList *SourceMechs  = NULL;
    PVOID               SourceMechsToFree = NULL ;
    ULONG               MechCount ;
    ULONG               i ;
    ULONG_PTR           CredIndex ;
    PNEG_CONTEXT        Context = NULL ;
    PSession            pSession ;
    SecPkgCredentials_NamesW Names ;
    DWORD               NameLength ;
    ANSI_STRING         NarrowName  = {0};
    PSession            pClientClone ;
    ULONG_PTR           PackageId ;
    PNEG_PACKAGE        Package ;
    SecBuffer           DesiredToken = { 0 } ;
    SecBuffer           InputBuffer ;
    SecBufferDesc       DTDescription ;
    SecBufferDesc       DTInput ;
    SecBufferDesc       NullInput = { 0 };
    PSecBuffer          pToken ;
    CtxtHandle          InitialHandle ;
    ASN1octetstring_t   EncodedData = {0};
    SECURITY_STATUS     Result ;
    ULONG               PackageReq = 0 ;
    BOOL                DirectSecurityPacket = FALSE ;
    BOOL                UseHint = FALSE ;
    BOOL                HintPresent = FALSE ;
    ULONG               PackageReqFlags ;
    BOOL                BufferSizeReset = FALSE ;
    BOOL                OrderByMech = FALSE ;
    BOOL                MechListReordered = FALSE ;
    CredHandle          TempCredHandle;
    PNEG_PACKAGE        LastPackage = NULL ;
    LUID                SystemLuid = SYSTEM_LUID;
    BOOLEAN             fLocalSystem = FALSE;
    PLSA_CALL_INFO      CallInfo ;

    //
    // Make sure there is an output buffer
    //

    scRet = NegpParseBuffers( pOutput, TRUE, &pToken, NULL );

    if ( !NT_SUCCESS( scRet ) )
    {
        DebugLog(( DEB_ERROR, "NegBuildRequestToken failed to map buffers, %x\n", scRet ));
        goto Cleanup ;
    }

    //
    // If there is no output buffer, fail now
    //

    if (pToken == NULL)
    {
        scRet = SEC_E_INVALID_TOKEN;
        DebugLog((DEB_ERROR,"NegBuildRequestToken no output token\n"));
        goto Cleanup;
    }

    CallInfo = LsapGetCurrentCall();

    if ( !ServerSideInit )
    {

        if ( CallInfo->CallInfo.Attributes & SECPKG_CALL_KERNEL_MODE )
        {
            //
            // Mask off the mutual bit for now
            //

            PackageReq = NegGetPackageCaps( fContextReq & (~(ISC_REQ_MUTUAL_AUTH)) );
        }
        else
        {
            PackageReq = NegGetPackageCaps( fContextReq );
        }
    }
    else
    {
        PackageReq = 0xFFFFFFFF ;
    }

    //
    // First, gather up the mechanisms that the other guys supports.  If
    // we don't know, assume all of ours:
    //

    if ( ServerMechs )
    {
        SourceMechs = ServerMechs ;
    }
    else
    {
        scRet = NegpBuildMechListFromCreds(
                        Creds,
                        PackageReq,
                        (ServerSideInit ? SECPKG_CRED_INBOUND : SECPKG_CRED_OUTBOUND ),
                        &SourceMechs );

        if ( !NT_SUCCESS(scRet) )
        {
            return( scRet );
        }
        //
        // Save a copy of this pointer.  The list may be rearranged later, but
        // we need to free this "original" pointer.
        //

        SourceMechsToFree = SourceMechs ;
    }


    //
    // Initialize some pointers so we know if we need to free anything.
    //

    DesiredToken.pvBuffer = NULL ;
    Context = NULL ;

    //
    // if we're honoring server hints, then go by the mech list
    //

    OrderByMech = ( ( NegOptions & NEGOPT_HONOR_SERVER_PREF ) != 0 );

    //
    // Special case the local loopback to use NTLM.  Analyze the target name.  If it
    // is an SPN, and it is our hostname in there, rearrange the mech list to put
    // NTLM first (note, for local case, NTLM will essentially dup the token).  This
    // function cannot fail.
    //

    if (((Creds->Flags & NEGCRED_NTLM_LOOPBACK) != 0))
    {
        if ( NegpRearrangeMechsIfNeccessary( &SourceMechs, pszTargetName, &DirectSecurityPacket ) )
        {
            OrderByMech = TRUE ;
            MechListReordered = TRUE ;
        }
    }

    //
    // Scan through the list, building up the list of common mechanisms.
    // Also, maintain a count, and determine the first matching package to
    // generate our desired token.  Depending on local configuration, we
    // will either honor the server's preferences, or our own.
    //

    pMechs = SourceMechs ;

    MechCount = 0;

    NegReadLockCreds( Creds );

    //
    // BUGUG: check for supported options for the context requirements.
    //

    if ( OrderByMech )
    {
        //
        // Walk the server list first.
        //

        while ( pMechs )
        {
            CredIndex = NegpFindPackageForOid( Creds, pMechs->value );

            if ( CredIndex != NEG_INVALID_PACKAGE )
            {
                CommonMechs[ MechCount ].value =
                                Creds->Creds[ CredIndex ].Package->ObjectId ;

                CommonMechs[ MechCount ].next = &CommonMechs[ MechCount + 1 ];

                MatchingPackages[ MechCount] = (ULONG) CredIndex;
                MechCount ++ ;

                if (MechCount == NEG_MECH_LIMIT)
                {
                    break;
                }
            }

            pMechs = pMechs->next ;
        }
    }
    else
    {
        //
        // Walk the local cred list first:
        //

        for ( i = 0 ; i < Creds->Count ; i++ )
        {
            pMechs = SourceMechs ;

            while ( pMechs )
            {
                if ( NegpCompareOid( pMechs->value,
                                    Creds->Creds[ i ].Package->ObjectId ) == 0 )
                {
                    CommonMechs[ MechCount ].value =
                                     Creds->Creds[ i ].Package->ObjectId ;

                    CommonMechs[ MechCount ].next = &CommonMechs[ MechCount + 1 ];

                    MatchingPackages[ MechCount] = i;

                    MechCount++;

                    break;
                }


                //
                // Note:  Right now, the limit on protocols is 16.  We may need to
                // increase that.
                //

                if (MechCount == NEG_MECH_LIMIT)
                {
                    break;
                }


                pMechs = pMechs->next ;
            }
        }
    }

    //
    // Ok, at this point, we have the desired security package (cred handle)
    // in MatchingPackage, MechCount contains the number of mechs in common.
    //
    // Note:  These can be zero, that is that we have no mechs in common.
    //

    NegUnlockCreds( Creds );

    if ( MechCount == 0 )
    {
        //
        // No common packages:
        //

        DebugLog(( DEB_TRACE_NEG, "No common packages\n"));

        scRet = SEC_E_INVALID_TOKEN ;

        goto Cleanup ;
    }

    //
    // Patch up list:
    //

    CommonMechs[ MechCount - 1 ].next = NULL ;



    //
    // Start assembling request token:
    //

    ZeroMemory( &Request, sizeof( Request ) );


    //
    // Create the negotiate context
    //

    Context = NegpCreateContext() ;

    if ( !Context )
    {
        scRet = SEC_E_INSUFFICIENT_MEMORY ;

        goto Cleanup ;

    }

    if ( !ServerSideInit )
    {

        //
        // Store target name away
        //

        scRet = LsapDuplicateString2( &Context->Target, pszTargetName );

        if ( !NT_SUCCESS( scRet ) )
        {
            goto Cleanup ;
        }

        //
        // Use the supplied mechs. If these were passed from the server,
        // make sure we don't free them before using them.
        //


        if ( Context->SupportedMechs )
        {
            DebugLog((DEB_TRACE_NEG, "Context %p already has MechList ?\n", Context ));
        }

        if ( ( SourceMechs == ServerMechs ) ||
             ( MechListReordered ) )
        {
            Context->SupportedMechs = NegpCopyMechList(MechList);
            if (Context->SupportedMechs == NULL)
            {
                scRet = SEC_E_INSUFFICIENT_MEMORY;
                goto Cleanup;
            }
            Context->Flags |= NEG_CONTEXT_FREE_EACH_MECH;
        }
        else
        {

            Context->SupportedMechs = SourceMechs;
            SourceMechs = NULL;
        }

        if ( fContextReq & ISC_REQ_MUTUAL_AUTH )
        {
            Context->Flags |= NEG_CONTEXT_MUTUAL_AUTH ;
        }
    }



    if (Context->Creds == NULL)
    {
        Context->Creds = Creds ;

        //
        // Reference the credentials so they don't go away unexpectedly
        //

        NegWriteLockCreds(Creds);

        Creds->RefCount++;

        NegUnlockCreds(Creds);
    }

    PackageReqFlags = fContextReq | ISC_REQ_MUTUAL_AUTH ;
    PackageReqFlags &= (~(ISC_REQ_ALLOCATE_MEMORY ));

    if( RtlEqualLuid( &Creds->ClientLogonId, &SystemLuid ) )
    {
        fLocalSystem = TRUE;
    }

    i = 0;
    do
    {
        UseHint = FALSE ;
        HintPresent = FALSE  ;

        Context->CredIndex = MatchingPackages[i] ;

        NegReadLockCreds( Creds );

        Package = Creds->Creds[ MatchingPackages[i] ].Package ;

        if ( NegNegotiationControl < NEG_NEGLEVEL_NO_DOWNGRADE )
        {
            //
            // If we're allowing downgrade, if the next package is
            // the NT4 compatibility package, and we are not
            // responding to a server list of mechs, and we haven't
            // reordered the list specifically to use NTLM for loopback,
            // go direct
            //

            if ( ( (Package->Flags & NEG_NT4_COMPAT ) != 0 ) &&
                 ( ServerMechs == NULL )  &&
                 ( (Creds->Flags & NEGCRED_NEG_NTLM ) == 0 ) &&
                 ( !MechListReordered ) )
            {
                DebugLog(( DEB_TRACE_NEG, "Dropping back to pure NTLM\n" ));
                DirectSecurityPacket = TRUE ;
            }
        }

        //
        // Now, divergent behavior.  For a server side request token, we need to
        // grab some hint data.  On a client side request, we ping the desired
        // mechanism to generate a "hopeful" blob for the server.
        //

        if ( ServerSideInit )
        {
            NTSTATUS TempStatus;

            if ( Creds->ServerBufferLength == 0 )
            {


                DebugLog(( DEB_TRACE_NEG, "Gathering up server name for hint\n" ));

                //
                // We need to query credential handle 0 to find out
                // what the name of the person is, so that we can send it
                // back in the hints.  However, just calling querycredattributes
                // would make the package write the data to the client process,
                // when we need it here.  So, we swap out our session, and substitute
                // a clone of the client session, with the INPROC flag set.  The
                // helpers will check for this flag, and do a little dance to
                // keep the memory local.
                //

                pSession = GetCurrentSession();

                TempStatus = CloneSession( pSession, &pClientClone, SESFLAG_INPROC );

                //
                // WARNING:  This code block has the braces only in NT builds, not
                // in Win9x builds.  Balance them carefully if you modify this portion.
                //

                if ( NT_SUCCESS( TempStatus ) )
                {
                    SpmpReferenceSession( pClientClone );

                    SetCurrentSession( pClientClone );

                    PackageId = GetCurrentPackageId();

                    //
                    // Make a copy of the handle because we can't hold a lock
                    // while calling outside the Negotiate package.
                    //

                    TempCredHandle = Creds->Creds[0].Handle;

                    NegUnlockCreds(Creds);

                    TempStatus = WLsaQueryCredAttributes(
                                    &TempCredHandle,
                                    SECPKG_CRED_ATTR_NAMES,
                                    &Names );

                    SetCurrentPackageId( PackageId );
                    NegReadLockCreds( Creds);

                    if ( NT_SUCCESS( TempStatus ) )
                    {
                        UNICODE_STRING TempString;

                        RtlInitUnicodeString(
                            &TempString,
                            Names.sUserName
                            );

                        TempStatus = RtlUnicodeStringToAnsiString(
                                        &NarrowName,
                                        &TempString,
                                        TRUE            // allocate destination
                                        );
                        if (NT_SUCCESS(TempStatus))
                        {

                            Request.negToken.u.negTokenInit.bit_mask |= NegTokenInit_negHints_present ;

                            Request.negToken.u.negTokenInit.negHints.hintName = NarrowName.Buffer ;

                            Request.negToken.u.negTokenInit.negHints.bit_mask |= hintName_present;

                        }

                        LsapFreeLsaHeap( Names.sUserName );
                    }

                    //
                    // Ignore failures from above because it was really only a hint.
                    //

                    scRet = STATUS_SUCCESS;

                    SetCurrentSession( pSession );

                    //
                    // Deref and clean up clone session
                    //

                    SpmpDereferenceSession( pClientClone );

                }
            }

            NegUnlockCreds( Creds );
        }
        else
        {
            CredHandle TempCredHandle;

            //
            // Make a copy of the handle because we can't hold a lock
            // while calling outside the Negotiate package.
            //

            TempCredHandle = Creds->Creds[0].Handle;

            NegUnlockCreds(Creds);

            //
            // Client side call.  Here, we call down to the desired package,
            // and have it generate a blob to be encoded and sent over to the
            // server.
            //

            if ( DesiredToken.pvBuffer )
            {
                //
                // If we're coming through this loop again, free the current buffer
                // and allocate one of appropriate size for the current package.
                //

                LsapFreeLsaHeap( DesiredToken.pvBuffer );
            }

            DesiredToken.pvBuffer = LsapAllocateLsaHeap( Package->TokenSize );
            if (DesiredToken.pvBuffer == NULL)
            {
                scRet = SEC_E_INSUFFICIENT_MEMORY;
                goto Cleanup;
            }
            DesiredToken.cbBuffer = Package->TokenSize ;
            DesiredToken.BufferType = SECBUFFER_TOKEN ;

            DTDescription.ulVersion = SECBUFFER_VERSION ;
            DTDescription.cBuffers = 1;
            DTDescription.pBuffers = &DesiredToken ;

            DTInput.ulVersion = SECBUFFER_VERSION;

            //
            // If negotiation information was provided, use it
            //

            if (ARGUMENT_PRESENT(NegotiateHint) &&
                (NegotiateHint->Length != 0) &&
                ( NegNegotiationControl < NEG_NEGLEVEL_COMPATIBILITY ))
            {
                DTInput.cBuffers = 1;
                DTInput.pBuffers = &InputBuffer;
                InputBuffer.pvBuffer = NegotiateHint->Buffer;
                InputBuffer.cbBuffer = NegotiateHint->Length;
                InputBuffer.BufferType = SECBUFFER_NEGOTIATION_INFO;
                HintPresent = TRUE ;
            }
            else
            {
                DTInput.cBuffers = 0;
                DTInput.pBuffers = 0;
                HintPresent = FALSE ;

            }

            InitialHandle.dwUpper = 0;
            InitialHandle.dwLower = 0;

            DebugLog(( DEB_TRACE_NEG, "Getting initial token from preferred package '%ws'\n",
                        Package->LsaPackage->Name.Buffer ));

            PackageId = GetCurrentPackageId();

RetryWithHintPoint:
            //
            // This goto label is used for retry with hint in low security setting, and
            // retry with a larger buffer in the case where kerberos exceeds its max token
            // value.
            //

            //
            //  Move this into a local.  The WLsaInit code will blot out the cred handle
            // for the secur32.dll if the context changes.
            //

            TempCredHandle = Creds->Creds[ MatchingPackages[i] ].Handle ;
            LastPackage = Creds->Creds[ MatchingPackages[ i ] ].Package ;

            if( NT_SUCCESS( scRetPrior ) ||
                (TempCredHandle.dwLower != Creds->Creds[ MatchingPackages[i-1] ].Handle.dwLower)
                )
            {

                scRet = WLsaInitContext(&TempCredHandle,
                                        &InitialHandle,
                                        pszTargetName,
                                        PackageReqFlags,
                                        0,
                                        TargetDataRep,
                                        (UseHint ? &DTInput : &NullInput ),
                                        0,
                                        &Context->Handle,
                                        &DTDescription,
                                        &Context->Attributes,
                                        ptsExpiry,
                                        &Context->Mapped,
                                        &Context->MappedBuffer
                                        );

                scRetPrior = scRet;
            }

            SetCurrentPackageId( PackageId );

            DebugLog(( DEB_TRACE_NEG, "WLsaInitContext( %ws, %ws ) returned %x\n",
                            pszTargetName->Buffer,
                            Creds->Creds[ MatchingPackages[i] ].Package->LsaPackage->Name.Buffer,
                            scRet ));

            Context->CallCount++ ;


            if ( !NT_SUCCESS( scRet ) )
            {
                DebugLog(( DEB_TRACE_NEG, "Failed %x getting token from preferred package '%ws'\n",
                            scRet, Package->LsaPackage->Name.Buffer ));

                if ( ( scRet == STATUS_BUFFER_TOO_SMALL ) &&
                     ( BufferSizeReset == FALSE ) )
                {
                    LsapFreeLsaHeap( DesiredToken.pvBuffer );

                    //
                    // This is technically not multi thread safe, but this is a comparatively
                    // rare event.    The buffer size will never be set less than the original
                    // claimed size from the package, so at worst, we'll get stuck in this realloc
                    // loop twice.
                    //

                    if ( DesiredToken.cbBuffer > Package->TokenSize )
                    {
                        Package->TokenSize = DesiredToken.cbBuffer ;
                    }

                    DesiredToken.pvBuffer = LsapAllocateLsaHeap( DesiredToken.cbBuffer );

                    if ( DesiredToken.pvBuffer == NULL )
                    {
                        scRet = SEC_E_INSUFFICIENT_MEMORY ;
                    }
                    else
                    {
                        BufferSizeReset = TRUE ;

                        scRetPrior = STATUS_SUCCESS;
                        goto RetryWithHintPoint ;
                    }


                }

                if ( (HintPresent)  &&
                     (!(UseHint)) &&
                     ( ( scRet == SEC_E_TARGET_UNKNOWN ) ||
                       ( scRet == STATUS_NO_TRUST_SAM_ACCOUNT ) ||
                       ( scRet == STATUS_NO_LOGON_SERVERS ) ) &&
                     (NegNegotiationControl < NEG_NEGLEVEL_COMPATIBILITY ) )
                {
                    DebugLog(( DEB_TRACE_NEG, "Retrying with hint name %ws\n",
                              NegotiateHint->Buffer ));
                    UseHint = TRUE ;

                    scRetPrior = STATUS_SUCCESS;
                    goto RetryWithHintPoint ;
                }

                if ( DesiredToken.pvBuffer )
                {
                    LsapFreeLsaHeap( DesiredToken.pvBuffer );

                    DesiredToken.pvBuffer = NULL ;
                }

            }
            else
            {
                //
                // On success, check for a null session indication.  If we got a "null
                // session" from the security package, then we need to make sure that it
                // is not uplevel, if NTLM is enabled on the machine.
                //

                if ( ( Context->Attributes & ISC_RET_NULL_SESSION ) != 0 )
                {
                    if ( NtlmPackageId != NEG_INVALID_PACKAGE )
                    {
                        //
                        // NTLM is enabled.  If this is not NTLM, blow away the context
                        // until we get to NTLM.  First, override the returned status with
                        // a "special" status code that will get us through the retry logic
                        // below.  Then, delete the existing context.
                        //

                        if ( (Creds->Creds[ MatchingPackages[ i ] ].Package->Flags & NEG_NT4_COMPAT) == 0 )
                        {
                            scRet = SEC_E_BAD_PKGID ;

                            WLsaDeleteContext( &Context->Handle );
                            Context->Attributes = 0 ;
                        }
                    }
                }
            }

            Context->LastStatus = scRet ;
            Context->Flags |= NEG_CONTEXT_PACKAGE_CALLED;
        }

        //
        // If the packages failed, take it out of the list
        //

        if (!NT_SUCCESS(scRet))
        {
            MechList = CommonMechs[i].next;
            MechCount--;

            //
            // kerberos can authoritatively return STATUS_WRONG_PASSWORD
            // if the creds were not valid.  No reason to continue at that point.
            //
            // Smartcard errors w/ explicit credentials should also not
            // try the downgrade to NTLM...
            // 
            if ((Creds->Flags & NEGCRED_EXPLICIT_CREDS ) != 0)
            {
                if (NegBreakoutOnExplictCredentials( scRet, Creds->Flags ))
                {
                    DebugLog(( DEB_TRACE_NEG, "Status code %x from Initialize causing us to break out\n",
                               scRet ));
                    break;
                }
            }                              

            if (( NegNegotiationControl > NEG_NEGLEVEL_NO_SECURITY ) &&
                ( ( Creds->Flags & NEGCRED_EXPLICIT_CREDS ) == 0 ) &&
                ( ( Creds->Flags & NEGCRED_ALLOW_NTLM ) == 0 ) )
            {
                BOOL BreakOut ;
                BOOL Downgrade = TRUE;

                //
                // Ok, we need to do some advance filtering on the
                // return status, to see if we should progress or not.
                //

                switch ( scRet )
                {
                    //
                    // Special case for null session going to NTLM:
                    //

                    case SEC_E_BAD_PKGID:
                        BreakOut = FALSE ;
                        break;

                    case SEC_E_TARGET_UNKNOWN:
                    case STATUS_NO_TRUST_SAM_ACCOUNT:
                    case STATUS_KDC_UNKNOWN_ETYPE:
                    case STATUS_NETWORK_UNREACHABLE:
                    case SEC_E_NO_CREDENTIALS:          // eg, Kerberos has no creds for local account case

                        BreakOut = FALSE ;
                        break;
                    case STATUS_WRONG_PASSWORD:
                    case STATUS_LOGON_FAILURE:
                    case STATUS_TIME_DIFFERENCE_AT_DC:
                    case SEC_E_TIME_SKEW:
                    case STATUS_SMARTCARD_SUBSYSTEM_FAILURE:
                    case STATUS_SMARTCARD_WRONG_PIN:
                    case STATUS_SMARTCARD_NO_CARD:
                    case STATUS_PASSWORD_MUST_CHANGE:
                    case STATUS_SMARTCARD_CERT_REVOKED:
                    case STATUS_PKINIT_CLIENT_FAILURE:
                    case STATUS_SMARTCARD_CERT_EXPIRED:
                    case STATUS_ISSUING_CA_UNTRUSTED:
                    case STATUS_SMARTCARD_CARD_NOT_AUTHENTICATED:
                    case STATUS_SMARTCARD_CARD_BLOCKED:
                    case STATUS_PASSWORD_EXPIRED:
                    case STATUS_SMARTCARD_SILENT_CONTEXT:
                    case STATUS_AUTHENTICATION_FIREWALL_FAILED:
                    {
                        BreakOut = TRUE;
                        Downgrade = FALSE;
                        break;
                    }

                    //
                    // DFS currently does initial session setup as SYSTEM.
                    // until DFS is fixed to call as user, allow no_such_user
                    // from SYSTEM context.
                    //

                    case STATUS_NO_SUCH_USER:
                    {
                        if( fLocalSystem )
                        {
                            BreakOut = FALSE ;
                            break;
                        }

                        Downgrade = FALSE;
                        BreakOut = TRUE;
                        break;
                    }
                    

                    case STATUS_NO_LOGON_SERVERS:
                    {
                        //
                        // If we truly logged on with NTLM, keep going
                        //
                        if (Creds->DefaultPackage == NtlmPackageId )
                        {
                            BreakOut = FALSE;
                        } else {
                            BreakOut = TRUE;
                        }
                        break;
                    }

                    default:
                        BreakOut = TRUE ;
                        break;
                }

                DebugLog(( DEB_TRACE_NEG, "Status code %x causing us to %s\n",
                           scRet, (BreakOut ? "break out" : "continue") ));

                if ( BreakOut )
                {
                    NegpReportEvent(
                        EVENTLOG_WARNING_TYPE,
                        NEGOTIATE_DOWNGRADE_DETECTED,
                        CATEGORY_NEGOTIATE,
                        scRet,
                        2,
                        pszTargetName,
                        &LastPackage->LsaPackage->Name
                        );

                    if( Downgrade )
                    {
                        //
                        // Tell the caller the explicit reason for the failure since
                        //  NTLM might very well have suceeded.
                        //
                        scRet = STATUS_DOWNGRADE_DETECTED;
                    }

                    break;
                }
            }
        }

        i++;

    } while (!NT_SUCCESS(scRet) && (MechCount != 0));

    if (!NT_SUCCESS(scRet))
    {
        NegpReportEvent(
            EVENTLOG_WARNING_TYPE,
            NEGOTIATE_INVALID_SERVER,
            CATEGORY_NEGOTIATE,
            scRet,
            1,
            pszTargetName
            );

        DebugLog((DEB_ERROR,"No packages could initialize\n"));
        goto Cleanup;
    }

    if ( MechCount == 0 )
    {
        NegpReportEvent(
            EVENTLOG_WARNING_TYPE,
            NEGOTIATE_INVALID_SERVER,
            CATEGORY_NEGOTIATE,
            0,
            1,
            pszTargetName
            );

        scRet = SEC_E_INVALID_TOKEN ;

        //
        // No common packages:
        //

        DebugLog(( DEB_TRACE_NEG, "No common packages\n"));

        goto Cleanup ;
    }

    if ( LastPackage )
    {
        NegpReportEvent(
            EVENTLOG_INFORMATION_TYPE,
            NEGOTIATE_PACKAGE_SELECTED,
            CATEGORY_NEGOTIATE,
            0,
            2,
            pszTargetName,
            &LastPackage->LsaPackage->Name
            );
    }

    if ( !DirectSecurityPacket )
    {
        Request.negToken.choice = negTokenInit_chosen ;

        Request.negToken.u.negTokenInit.mechTypes = MechList ;
        Request.negToken.u.negTokenInit.bit_mask |= NegTokenInit_mechTypes_present ;

        //
        // Okay, now we have all the pieces.  Assemble the token:
        //

        if ( DesiredToken.pvBuffer )
        {
            Request.negToken.u.negTokenInit.mechToken.length = DesiredToken.cbBuffer ;
            Request.negToken.u.negTokenInit.mechToken.value = (PUCHAR) DesiredToken.pvBuffer ;

            Request.negToken.u.negTokenInit.bit_mask |= NegTokenInit_mechToken_present ;

        }

        //
        // Add in the SPNEGO mechanism id
        //

        Request.spnegoMech = NegSpnegoMechOid;


        Result = SpnegoPackData(
                    &Request,
                    InitialNegToken_PDU,
                    &(EncodedData.length),
                    &(EncodedData.value));


        if ( !NT_SUCCESS(Result) )
        {
            DebugLog((DEB_ERROR, "Failed to encode data: %d\n", Result ));

            scRet = Result;
            goto Cleanup ;

        }
    }
    else
    {
        EncodedData.length = DesiredToken.cbBuffer ;
        EncodedData.value = (PUCHAR) DesiredToken.pvBuffer ;

        DesiredToken.pvBuffer = NULL ;
    }


    //
    // Okay, got the token into a contiguous mass.  Package it up for the caller
    //


    if ( fContextReq & ISC_REQ_ALLOCATE_MEMORY )
    {
        //
        // Easy:  The caller asked for us to allocate memory for them, so
        // let the LSA do it.
        //

        pToken->pvBuffer = EncodedData.value ;
        pToken->cbBuffer = EncodedData.length ;
        EncodedData.value = NULL;

    }
    else
    {
        //
        // The caller has a buffer that we're supposed to use.  Make sure we
        // can fit.
        //

        if ( (ULONG) EncodedData.length < pToken->cbBuffer  )
        {
            RtlCopyMemory(  pToken->pvBuffer,
                            EncodedData.value,
                            EncodedData.length );

            pToken->cbBuffer = EncodedData.length ;

        }
        else if ( ( ( fContextReq & ISC_REQ_FRAGMENT_TO_FIT ) != 0 ) &&
                  ( pToken->cbBuffer >= SPNEGO_MINIMUM_BUFFER ) )
        {
            //
            // Ok, we need to whack the context to indicate that we are
            // fragmenting, and return only what the caller can handle.
            //

            Context->Message = EncodedData.value ;
            Context->TotalSize = EncodedData.length ;
            Context->Flags |= NEG_CONTEXT_FRAGMENTING ;

            //
            // set this to NULL so it doesn't get freed later
            //

            EncodedData.value = NULL ;
            RtlCopyMemory(
                pToken->pvBuffer,
                Context->Message,
                pToken->cbBuffer );

            Context->CurrentSize = pToken->cbBuffer ;
        }
        else
        {
            DebugLog(( DEB_TRACE_NEG, "Supplied buffer is too small\n" ));

            scRet = SEC_E_INSUFFICIENT_MEMORY ;

            goto Cleanup ;
        }
    }


    //
    // We have created the token, encoded it, and stuck it in a return buffer.
    // We have created the context record, and it is ready.  We're done!
    //


    if ( !DirectSecurityPacket )
    {
        *pContext = Context ;
        Context = NULL;

        scRet =  SEC_I_CONTINUE_NEEDED ;
    }
    else
    {
        DebugLog(( DEB_TRACE_NEG, "Replacing handle, current status is %x\n", scRet ));

        LsapChangeHandle(   HandleReplace,
                            NULL,
                            &Context->Handle );

        *pContext = NULL ;

        Context->Handle.dwLower = 0 ;
        Context->Handle.dwUpper = 0 ;

        //
        // Context will be freed during cleanup.
        //
    }

Cleanup:

    if ( !ServerMechs )
    {
        //
        // No server mechs means we allocated and used one based on our
        // cred handle.  Free it.
        //

        if (SourceMechs != NULL)
        {
            if ( MechListReordered )
            {
                LsapFreeLsaHeap( SourceMechsToFree );
            }
            else
            {
                LsapFreeLsaHeap( SourceMechs );
            }
        }
    }

    if (EncodedData.value != NULL)
    {
        LsapFreeLsaHeap(EncodedData.value);
    }

    if ( DesiredToken.pvBuffer )
    {
        LsapFreeLsaHeap( DesiredToken.pvBuffer );
    }

    if ( Context )
    {
        NegpDeleteContext( Context );
    }

    if (NarrowName.Buffer != NULL)
    {
        RtlFreeAnsiString(&NarrowName);
    }

    return( scRet );
}

//+---------------------------------------------------------------------------
//
//  Function:   NegGenerateInitialToken
//
//  Synopsis:   Client side init
//
//  Arguments:  [dwCreds]       --
//              [Target]        --
//              [fContextReq]   --
//              [TargetDataRep] --
//              [pInput]        --
//              [pdwNewContext] --
//              [pOutput]       --
//              [pfContextAttr] --
//              [ptsExpiry]     --
//              [pfMapContext]  --
//              [pContextData]  --
//
//  History:    9-30-96   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
SECURITY_STATUS
NegGenerateInitialToken(
    ULONG_PTR dwCreds,
    PSECURITY_STRING Target,
    ULONG   fContextReq,
    ULONG TargetDataRep,
    PSecBufferDesc  pInput,
    PULONG_PTR pdwNewContext,
    PSecBufferDesc  pOutput,
    PULONG  pfContextAttr,
    PTimeStamp          ptsExpiry,
    PBYTE               pfMapContext,
    PSecBuffer          pContextData)
{
    SECURITY_STATUS scRet;
    PSecBuffer  Buffer;
    PNEG_CREDS  Creds;
    PNEG_CONTEXT Context;

    //
    // Initialize stuff:
    //

    Creds = (PNEG_CREDS) dwCreds ;

    //
    // Fall through to common code with normal initial token:
    //

    scRet = NegBuildRequestToken(   FALSE,
                                    Creds,
                                    Target,
                                    fContextReq,
                                    TargetDataRep,
                                    NULL,
                                    NULL,
                                    &Context,
                                    pOutput,
                                    ptsExpiry );

    if ( NT_SUCCESS( scRet ) )
    {
        //
        // Successfully built token.  Set flags:
        //

        *pfContextAttr = ( ISC_RET_INTERMEDIATE_RETURN ) |
                         ( fContextReq & ISC_REQ_ALLOCATE_MEMORY ?
                                ISC_RET_ALLOCATED_MEMORY : 0 ) ;

        *pfMapContext = FALSE ;

        if ( Context )
        {
            *pdwNewContext = (DWORD_PTR) Context ;
        }

    }

    return( scRet );
}

//+---------------------------------------------------------------------------
//
//  Function:   NegGenerateServerRequest
//
//  Synopsis:   Server side init
//
//  Arguments:  [dwCreds]       --
//              [fContextReq]   --
//              [TargetDataRep] --
//              [pInput]        --
//              [pdwNewContext] --
//              [pOutput]       --
//              [pfContextAttr] --
//              [ptsExpiry]     --
//              [pfMapContext]  --
//              [pContextData]  --
//
//  History:    9-30-96   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
SECURITY_STATUS
NegGenerateServerRequest(
    ULONG_PTR dwCreds,
    ULONG   fContextReq,
    ULONG TargetDataRep,
    PSecBufferDesc  pInput,
    PULONG_PTR pdwNewContext,
    PSecBufferDesc  pOutput,
    PULONG  pfContextAttr,
    PTimeStamp          ptsExpiry,
    PBYTE               pfMapContext,
    PSecBuffer          pContextData)
{
    SECURITY_STATUS scRet;
    PSecBuffer  Buffer;
    PNEG_CREDS  Creds;
    PNEG_CONTEXT Context;

    //
    // Initialize stuff:
    //

    Creds = (PNEG_CREDS) dwCreds ;

    //
    // Fall through to common code with normal initial token:
    //

    scRet = NegBuildRequestToken(   TRUE,
                                    Creds,
                                    NULL,
                                    fContextReq,
                                    TargetDataRep,
                                    NULL,
                                    NULL,
                                    &Context,
                                    pOutput,
                                    ptsExpiry );

    if ( NT_SUCCESS( scRet ) )
    {
        //
        // Successfully built token.  Set flags:
        //

        *pfContextAttr = ( fContextReq & ASC_REQ_ALLOCATE_MEMORY ?
                                ASC_RET_ALLOCATED_MEMORY : 0 ) ;

        *pfMapContext = FALSE ;

        *pdwNewContext = (DWORD_PTR) Context ;
    }

    return( scRet );
}



//+---------------------------------------------------------------------------
//
//  Function:   NegCrackServerRequestAndReply
//
//  Synopsis:   Client side Init with Neg token from the server
//
//  Arguments:  [dwCreds]       --
//              [Target]        --
//              [fContextReq]   --
//              [TargetDataRep] --
//              [pInput]        --
//              [pdwNewContext] --
//              [pOutput]       --
//              [pfContextAttr] --
//              [ptsExpiry]     --
//              [pfMapContext]  --
//              [pContextData]  --
//
//  History:    9-30-96   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
SECURITY_STATUS
NegCrackServerRequestAndReply(
    ULONG_PTR dwCreds,
    PSECURITY_STRING Target,
    ULONG   fContextReq,
    ULONG TargetDataRep,
    PSecBufferDesc  pInput,
    PULONG_PTR pdwNewContext,
    PSecBufferDesc  pOutput,
    PULONG  pfContextAttr,
    PTimeStamp          ptsExpiry,
    PBYTE               pfMapContext,
    PSecBuffer          pContextData)
{
    SECURITY_STATUS scRet;
    struct InitialNegToken * Request = NULL ;
    ASN1octetstring_t EncodedData;
    ULONG Pdu = InitialNegToken_PDU;
    PSecBuffer  Buffer;
    struct MechTypeList *pMechs = NULL;
    PNEG_CREDS Creds ;
    PNEG_CONTEXT Context = NULL ;
    UNICODE_STRING NegotiateHint = {0};
    ANSI_STRING AnsiHint = {0};

    RtlInitUnicodeString(
        &NegotiateHint,
        NULL
        );


    //
    // Initialize stuff:
    //

    //
    // First, verify the input buffer contains a Request token, and crack it.
    //

    scRet = NegpParseBuffers( pInput, TRUE, &Buffer, NULL );

    if ( !NT_SUCCESS( scRet ) )
    {
        DebugLog(( DEB_ERROR, "NegCrackServerRequestAndReply Failed to map buffers, %x\n", scRet ));
        goto Cleanup;
    }

    if ( !Buffer )
    {
        DebugLog(( DEB_ERROR, "NegCrackServerRequestAndReply failed to map buffers (NULL)\n"));
        scRet = SEC_E_INVALID_TOKEN;
        goto Cleanup;
    }


    Creds = (PNEG_CREDS) dwCreds ;

    EncodedData.value = (PUCHAR) Buffer->pvBuffer ;
    EncodedData.length = Buffer->cbBuffer ;
    Request = NULL ;

    scRet = SpnegoUnpackData(
                                EncodedData.value,
                                EncodedData.length,
                                Pdu,
                                (PVOID *)&Request);

    if ( !NT_SUCCESS(scRet) )
    {
        goto Cleanup;
    }

    //
    // This function only handles Request tokens.  If we ended up with a reply,
    // then the server is in trouble, or we are...
    //

    if ( (Pdu != InitialNegToken_PDU) ||
         (Request->negToken.choice == negTokenTarg_chosen) ||
          NegpCompareOid(
            Request->spnegoMech,
            NegSpnegoMechOid)
            )
    {
        scRet =  SEC_E_INVALID_TOKEN;
        goto Cleanup;
    }


    //
    // Okay, the server has sent us a list of the packages that he supports,
    // possibly some hints as well.  We need to go through the list, and figure
    // our common subset.  At the same time, we need to select the one that we
    // want to use, preferably the same as the first one from the server.
    //

    if ((Request->negToken.u.negTokenInit.bit_mask & NegTokenInit_mechTypes_present) != 0)
    {
        pMechs = Request->negToken.u.negTokenInit.mechTypes ;
    }


    //
    // Get the negotation hint out.
    //

    if ((Request->negToken.u.negTokenInit.bit_mask & NegTokenInit_negHints_present) != 0)
    {
        if ((Request->negToken.u.negTokenInit.negHints.bit_mask & hintName_present) != 0)
        {
            RtlInitString(
                &AnsiHint,
                Request->negToken.u.negTokenInit.negHints.hintName
                );
            scRet = RtlAnsiStringToUnicodeString(
                        &NegotiateHint,
                        &AnsiHint,
                        TRUE                // allocate destination
                        );
            if (!NT_SUCCESS(scRet))
            {
                scRet= SEC_E_INSUFFICIENT_MEMORY;
                goto Cleanup;
            }
        }
    }

    //
    // Fall through to common code with normal initial token:
    //


    scRet = NegBuildRequestToken(
                FALSE,                      // not server side
                Creds,
                Target,
                fContextReq,
                TargetDataRep,
                pMechs,
                &NegotiateHint,
                &Context,
                pOutput,
                ptsExpiry );





Cleanup:

    if ( Request )
    {
        SpnegoFreeData( Pdu, Request );
    }
    if (NegotiateHint.Buffer != NULL)
    {
        RtlFreeUnicodeString(&NegotiateHint);
    }

    if ( NT_SUCCESS( scRet ) )
    {
        //
        // Successfully built token.  Set flags:
        //

        *pfContextAttr = ( ISC_RET_INTERMEDIATE_RETURN ) |
                         ( fContextReq & ISC_REQ_ALLOCATE_MEMORY ?
                                ISC_RET_ALLOCATED_MEMORY : 0 ) ;

        *pfMapContext = FALSE ;

        *pdwNewContext = (DWORD_PTR) Context ;
    }

    return( scRet );
}

//+---------------------------------------------------------------------------
//
//  Function:   NegpCrackRequest
//
//  Synopsis:   Crack a Request package, and, based on the creds, determine
//              what is supported.
//
//  Arguments:  [Creds]          -- Creds to compare against
//              [Request]        -- Request to crack
//              [MechIndex]      -- selected package
//              [MechList]       -- Receives mech list from request
//              [pPackage]       -- Package pointer
//
//  History:    9-25-96   RichardW   Created
//
//  Notes:      Creds must be locked
//
//----------------------------------------------------------------------------
SECURITY_STATUS
NegpCrackRequest(
    IN PNEG_CREDS  Creds,
    IN NegotiationToken * Request,
    OUT PULONG_PTR MechIndex,
    OUT struct MechTypeList ** MechList,
    OUT PNEG_PACKAGE * pPackage,
    OUT NEG_MATCH * pDesiredMatch)
{
    DWORD i;
    DWORD j;
    ULONG MatchingPackage = (ULONG) -1;
    struct MechTypeList *pMechs;
    PNEG_PACKAGE Package;
    NEG_MATCH DesiredMatch;
    ULONG MechCount ;

    pMechs = Request->u.negTokenInit.mechTypes ;

    //
    // First, support the "standard" by going through the whole list,
    // and determining which ones we support.
    //


    Package = NULL ;

    DesiredMatch = MatchUnknown ;


    //
    // For each mechanism, see if we have it in the creds.  If we have it,
    // mark it as acceptible.  If this is the first acceptible mech, capture
    // it as the now preferred mechanism.
    //


    while ( pMechs )
    {
        NegDumpOid( "Incoming Mechanism", pMechs->value );

        for ( i = 0 ; i < Creds->Count ; i++ )
        {
            NegDumpOid( "Comparing to Mechanism", Creds->Creds[i].Package->ObjectId );

            if ( NegpCompareOid( pMechs->value,
                                 Creds->Creds[i].Package->ObjectId ) == 0 )
            {
                if ( !Package )
                {
                    Package = Creds->Creds[i].Package ;

                    if ( DesiredMatch == MatchUnknown )
                    {
                        DesiredMatch = PreferredSucceed ;
                    }
                    else
                    {
                        DesiredMatch = MatchSucceed ;
                    }

                    MatchingPackage = i;
                    break;

                }
            }

        }


        pMechs = pMechs->next ;

        if ( DesiredMatch == MatchUnknown )
        {
            DesiredMatch = MatchFailed ;
        }

    }


    *MechIndex = MatchingPackage ;

    *pPackage = Package ;

    *MechList = Request->u.negTokenInit.mechTypes ;

    *pDesiredMatch = DesiredMatch ;


    return( 0 );
}

//+---------------------------------------------------------------------------
//
//  Function:   NegHandleSubsequentClientRequest
//
//  Synopsis:   Handles a client request after the initial NegTokenInit
//
//  Arguments:
//
//  History:    5-26-97         MikeSw          Created
//
//  Notes:
//
//----------------------------------------------------------------------------

SECURITY_STATUS
NegHandleSubsequentClientRequest(
    ULONG_PTR dwCreds,
    PNEG_CONTEXT Context,
    ULONG fContextReq,
    ULONG TargetDataRep,
    ULONG Pdu,
    NegotiationToken * Request,
    PULONG_PTR pdwNewContext,
    PSecBufferDesc pOutput,
    PULONG  pfContextAttr,
    PTimeStamp ptsExpiry,
    PBYTE pfMapContext,
    PSecBuffer  pContextData )
{
    SECURITY_STATUS scRet = SEC_E_OK;
    PNEG_CREDS  Creds ;
    NegotiationToken Reply;
    CredHandle TempCredHandle;
    CtxtHandle TempHandle;
    SecBufferDesc AcceptBufferDesc;
    SecBuffer AcceptBuffer;
    SecBufferDesc ResponseBufferDesc;
    SecBuffer ResponseBuffer;
    SecBuffer MappedBuffer;
    PSecBuffer pToken;
    BOOLEAN MappedContext;
    ULONG_PTR PackageId;
    ASN1octetstring_t EncodedData;
    SECURITY_STATUS Result;
    PNEG_PACKAGE Package ;


    EncodedData.value = NULL;
    EncodedData.length = 0;

    RtlZeroMemory(
        &ResponseBuffer,
        sizeof(SecBuffer)
        );

    RtlZeroMemory(
        &MappedBuffer,
        sizeof(SecBuffer)
        );

    //
    // The negotiation context should have been created during the first call
    // to AcceptSecurityContext, so if it isn't present this is an
    // error.
    //

    if (Context == NULL)
    {
        scRet = SEC_E_INVALID_HANDLE;
        goto Cleanup;
    }

    //
    // Verify that there is an output token to return something in.
    //

    scRet = NegpParseBuffers( pOutput, TRUE, &pToken, NULL );

    if ( !NT_SUCCESS( scRet ) )
    {
        DebugLog((DEB_ERROR, "NegHandleSubsequentClientRequest failed to map output, %x\n", scRet));
        goto Cleanup;
    }

    if (pToken == NULL)
    {
        DebugLog((DEB_ERROR, "NegHandleSubsequentClientRequest failed to map output (NULL)\n"));
        scRet = SEC_E_INVALID_TOKEN;
        goto Cleanup;
    }

    //
    // Verify the creds passed in
    //

    Creds = (PNEG_CREDS) dwCreds ;

    if (Creds == NULL)
    {
        Creds = Context->Creds;
    }
    else if (Creds != Context->Creds)
    {
        DebugLog((DEB_TRACE_NEG, "Bad context handle passed to Accept: 0x%p instead of 0x%p\n",
            Creds, Context->Creds ));
        scRet = SEC_E_INVALID_HANDLE;
        goto Cleanup;
    }

    //
    // if the security token area is empty, but the mechListMIC is
    // present, then the client has completed (and we should have,
    // also), and we should verify the mechListMIC.
    //

    if ( ( ( Request->u.negTokenTarg.responseToken.length == 0 ) &&
           ( ( Context->Flags & NEG_CONTEXT_UPLEVEL ) != 0 ) ) ||
         ( Request->u.negTokenTarg.bit_mask == 0 ) )
    {
        //
        // Check the MIC:
        //

        Request = NULL;

        if ( Context->LastStatus != STATUS_SUCCESS )
        {
            return SEC_E_INVALID_TOKEN ;
        }

        if (Context->Mapped)
        {
            *pfMapContext = Context->Mapped;
            *pContextData = Context->MappedBuffer;
            RtlZeroMemory(
                &Context->MappedBuffer,
                sizeof(SecBuffer)
                );
        }

        //
        // Whack the output handle with the one returned from the
        // package.
        //

        LsapChangeHandle(   HandleReplace,
                            NULL,
                            &Context->Handle );

        Context->Handle.dwLower = 0 ;
        Context->Handle.dwUpper = 0 ;

        pToken->cbBuffer = 0 ;

        *ptsExpiry = Context->Expiry ;

        Context = NULL ;

        return STATUS_SUCCESS ;

    }

    //
    // Get the locked information out of the credentials
    //

    NegReadLockCreds(Creds);

    TempCredHandle = Creds->Creds[ Context->CredIndex ].Handle;
    Package = Creds->Creds[Context->CredIndex].Package;

    NegUnlockCreds(Creds);

    //
    // Build the input to AcceptSecurityContext
    //

    if ( Request->u.negTokenTarg.responseToken.length != 0 )
    {
        AcceptBuffer.pvBuffer = Request->u.negTokenTarg.responseToken.value;
        AcceptBuffer.cbBuffer = Request->u.negTokenTarg.responseToken.length;
        Context->Flags |= NEG_CONTEXT_UPLEVEL ;
    }
    else if ( Request->u.negTokenTarg.mechListMIC.length != 0 )
    {
        AcceptBuffer.pvBuffer = Request->u.negTokenTarg.mechListMIC.value ;
        AcceptBuffer.cbBuffer = Request->u.negTokenTarg.mechListMIC.length ;
    }

    AcceptBuffer.BufferType = SECBUFFER_READONLY | SECBUFFER_TOKEN ;

    AcceptBufferDesc.ulVersion = SECBUFFER_VERSION ;
    AcceptBufferDesc.cBuffers = 1;
    AcceptBufferDesc.pBuffers = &AcceptBuffer ;

    ResponseBuffer.cbBuffer = Package->LsaPackage->TokenSize ;
    ResponseBuffer.BufferType = SECBUFFER_TOKEN ;

    SafeAllocaAllocate(ResponseBuffer.pvBuffer, ResponseBuffer.cbBuffer);

    if ( ResponseBuffer.pvBuffer == NULL )
    {
        scRet = SEC_E_INSUFFICIENT_MEMORY ;

        goto Cleanup ;
    }

    ResponseBufferDesc.ulVersion = SECBUFFER_VERSION ;
    ResponseBufferDesc.cBuffers = 1;
    ResponseBufferDesc.pBuffers = &ResponseBuffer ;

    if ((Context->Flags & NEG_CONTEXT_PACKAGE_CALLED) != 0)
    {
        TempHandle = Context->Handle ;
    }
    else
    {
        TempHandle.dwUpper = TempHandle.dwLower = 0;
    }


    PackageId = GetCurrentPackageId();

    //
    // Call the package. Note that if the package has already mapped the
    // context we don't want it overwriting the existing mapping. Hence,
    // don't pass in the real value.
    //

    scRet = WLsaAcceptContext(
                &TempCredHandle,
                &TempHandle,
                &AcceptBufferDesc,
                (fContextReq & (~(ASC_REQ_ALLOCATE_MEMORY))),
                TargetDataRep,
                &Context->Handle,
                &ResponseBufferDesc,
                &Context->Attributes,
                &Context->Expiry,
                &MappedContext,
                &MappedBuffer );

#if DBG
    NegReadLockCreds( Creds );

    DebugLog(( DEB_TRACE_NEG, "WLsaAcceptContext( %ws ) returned %x\n",
                    Creds->Creds[ Context->CredIndex ].Package->LsaPackage->Name.Buffer,
                    scRet ));

    NegUnlockCreds(Creds);
#endif

    Context->CallCount++ ;

    SetCurrentPackageId( PackageId );

    //
    // Done with request data
    //

    Request = NULL;

    if ( !NT_SUCCESS( scRet ) )
    {
        DebugLog((DEB_TRACE, "Neg Failure from package %d, %#x\n",
            Context->CredIndex, scRet ));

        DsysAssert( scRet != SEC_E_INVALID_HANDLE )

        goto Cleanup;
    }

    Context->Flags |= NEG_CONTEXT_PACKAGE_CALLED;

    Context->LastStatus = scRet ;

    //
    // Build the output token, another NegTokenTarg.
    //

    Reply.choice = negTokenTarg_chosen;
    Reply.u.negTokenTarg.bit_mask = negResult_present;
    if (ResponseBuffer.cbBuffer != 0)
    {
        Reply.u.negTokenTarg.bit_mask |= responseToken_present;
    }

    Reply.u.negTokenTarg.responseToken.value = (PUCHAR) ResponseBuffer.pvBuffer;
    Reply.u.negTokenTarg.responseToken.length = (int) ResponseBuffer.cbBuffer;

    //
    // Fill in the negotation result field. In addition, fill in any
    // context mapping data.
    //

    if ( MappedContext )
    {
        DsysAssert( !Context->Mapped );

        Context->Mapped = TRUE ;
        Context->MappedBuffer = MappedBuffer ;

        RtlZeroMemory(
            &MappedBuffer,
            sizeof(SecBuffer)
            );
    }

    //
    // generate the MIC on the last blob
    //
    if ( scRet == SEC_E_OK )
    {
        //
        // Once the mic is generated, the
        // list of mechs is no longer needed.
        //

        if ( Context->SupportedMechs )
        {
            DebugLog(( DEB_TRACE_NEG, "Freeing mech list for %p\n", Context ));

            if ((Context->Flags & NEG_CONTEXT_FREE_EACH_MECH))
            {
                NegpFreeMechList(Context->SupportedMechs);
            }
            else
            {
                LsapFreeLsaHeap(Context->SupportedMechs);
            }

            Context->SupportedMechs = NULL ;
        }
    }

    if ( Context->LastStatus == SEC_E_OK )
    {
        Reply.u.negTokenTarg.negResult = accept_completed;
    }
    else
    {
        Reply.u.negTokenTarg.negResult = accept_incomplete;
    }

    if (scRet == SEC_E_OK)
    {
        if (Context->Mapped)
        {
            *pfMapContext = Context->Mapped;
            *pContextData = Context->MappedBuffer;
            RtlZeroMemory(
                &Context->MappedBuffer,
                sizeof(SecBuffer)
                );
        }
        else if (MappedContext)
        {
            *pfMapContext = TRUE;
            *pContextData = MappedBuffer;
            RtlZeroMemory(
                &MappedBuffer,
                sizeof(SecBuffer)
                );
        }
    }


    *ptsExpiry = Context->Expiry;
    *pfContextAttr = Context->Attributes;

    //
    // Encode reply token:
    //


    Result = SpnegoPackData(
                                &Reply,
                                NegotiationToken_PDU,
                                &(EncodedData.length),
                                &(EncodedData.value));

    if (!NT_SUCCESS(Result))
    {
        scRet = Result;
        goto Cleanup;
    }

    DsysAssert( NT_SUCCESS(NegpValidateBuffer( EncodedData.value, EncodedData.length ) ) );

    if ( fContextReq & ASC_REQ_ALLOCATE_MEMORY )
    {
        pToken->pvBuffer = EncodedData.value ;

        *pfContextAttr |= ASC_RET_ALLOCATED_MEMORY ;

        EncodedData.value = NULL ;

        pToken->cbBuffer = EncodedData.length ;

    }
    else
    {
        if ( pToken->cbBuffer >= (ULONG) EncodedData.length )
        {
            RtlCopyMemory(  pToken->pvBuffer,
                            EncodedData.value,
                            EncodedData.length );

            pToken->cbBuffer = EncodedData.length ;


        }
        else if ( ( ( fContextReq & ASC_REQ_FRAGMENT_TO_FIT ) != 0 ) &&
                  ( pToken->cbBuffer >= SPNEGO_MINIMUM_BUFFER ) )
        {
            //
            // Ok, we need to whack the context to indicate that we are
            // fragmenting, and return only what the caller can handle.
            //

            Context->Message = EncodedData.value ;
            Context->TotalSize = EncodedData.length ;
            Context->Flags |= NEG_CONTEXT_FRAGMENTING ;

            //
            // set this to NULL so it doesn't get freed later
            //

            EncodedData.value = NULL ;
            RtlCopyMemory(
                pToken->pvBuffer,
                Context->Message,
                pToken->cbBuffer );

            Context->CurrentSize = pToken->cbBuffer ;
        }
        else
        {
            scRet = SEC_E_INSUFFICIENT_MEMORY ;

            goto Cleanup ;
        }
    }


    if (scRet == SEC_E_OK)
    {
        //
        // Whack the output handle with the one returned from the
        // package.
        //

        LsapChangeHandle(   HandleReplace,
                            NULL,
                            &Context->Handle );

        Context->Handle.dwLower = 0 ;
        Context->Handle.dwUpper = 0 ;

        Context = NULL ;

    }
    else
    {
        //
        // Make sure we never say that we mapped when we are in the
        // intermediate state.
        //

        DsysAssert( !(*pfMapContext) );
    }

Cleanup:
    if (EncodedData.value != NULL)
    {
        LsapFreeLsaHeap(EncodedData.value);
    }

    SafeAllocaFree(ResponseBuffer.pvBuffer);

    if (MappedBuffer.pvBuffer != NULL)
    {
        LsapFreeLsaHeap(MappedBuffer.pvBuffer);
    }

    return(scRet);
}


//+-------------------------------------------------------------------------
//
//  Function:   NegHandleClientRequest
//
//  Synopsis:   Handles a call to AcceptSecurityContext other than an
//              initial one with no input. This routine either figures our
//              what package to call or calls a package already selected to
//              do the Accept.
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------
SECURITY_STATUS
NegHandleClientRequest(
    ULONG_PTR dwCreds,
    PNEG_CONTEXT pContext,
    ULONG   fContextReq,
    ULONG   TargetDataRep,
    PSecBufferDesc  pInput,
    PULONG_PTR pdwNewContext,
    PSecBufferDesc  pOutput,
    PULONG  pfContextAttr,
    PTimeStamp  ptsExpiry,
    PBYTE   pfMapContext,
    PSecBuffer  pContextData
    )
{
    PNEG_CREDS          Creds ;
    PNEG_CONTEXT        Context ;
    SECURITY_STATUS     scRet ;
    SECURITY_STATUS     MapStatus ;
    NegotiationToken *  Request = NULL ;
    InitialNegToken *   InitialRequest = NULL;
    NegotiationToken    Response = {0};
    ASN1octetstring_t   EncodedData ;
    SECURITY_STATUS     Result ;
    ULONG               Pdu = InitialNegToken_PDU;
    PSecBuffer          Buffer ;
    PSecBuffer          pToken ;
    PNEG_PACKAGE        Package;
    NEG_MATCH           DesiredMatch;
    SecBufferDesc       AcceptBufferDesc;
    SecBuffer           AcceptBuffer;
    SecBufferDesc       ResponseBufferDesc;
    SecBuffer           ResponseBuffer;
    SecBuffer           UserResponseBuffer; // use user buffer for in-place operations if large enough

    struct MechTypeList *MechList = NULL;
    CtxtHandle          TempHandle;
    struct _enum1 * Results;
    ULONG_PTR           PackageId;
    BOOLEAN             CredentialReferenced = FALSE;


    //
    // Initialize stuff:
    //

    ResponseBuffer.pvBuffer = NULL;

    Creds = (PNEG_CREDS) dwCreds ;
    Context = pContext ;

    if ( ( Creds == NULL ) &&
         ( Context != NULL ) )
    {
        Creds = Context->Creds ;
    }

    //
    // First, verify the input buffer contains a Request token, and crack it.
    //

    scRet = NegpParseBuffers( pInput, TRUE, &Buffer, NULL );


    if ( !NT_SUCCESS( scRet ) )
    {
        DebugLog(( DEB_ERROR, "NegHandleClientRequest failed to map input buffers, %x\n", scRet ));
        return( scRet );
    }

    if ( Buffer == NULL )
    {
        DebugLog(( DEB_ERROR, "NegHandleClientRequest failed to map input buffers (NULL)\n" ));
        return SEC_E_INVALID_TOKEN;
    }


    //
    // Verify that we have an output buffer
    //


    scRet = NegpParseBuffers( pOutput, TRUE, &pToken, NULL );

    if ( !NT_SUCCESS( scRet ) )
    {
        DebugLog(( DEB_ERROR, "NegHandleClientRequest failed to map output buffers (NULL)\n" ));
        goto Cleanup ;
    }

    //
    // We need a return token
    //

    if (pToken == NULL)
    {
        DebugLog((DEB_ERROR,"No output token for NegHandleClientRequest\n"));
        scRet = SEC_E_INVALID_TOKEN;
        goto Cleanup;
    }

    //
    // Compatibility:
    //
    // If we get a zero length blob, and the context has completed,
    // it means we're dealing with old clients
    //

    if ( ( Buffer->cbBuffer == 0 ) &&
         ( Context ) )
    {
        pToken->cbBuffer = 0 ;

        if ( Context->LastStatus != STATUS_SUCCESS )
        {   
            return SEC_E_INVALID_TOKEN ;
        }

        if (Context->Mapped)
        {
            *pfMapContext = Context->Mapped;
            *pContextData = Context->MappedBuffer;
            RtlZeroMemory(
                &Context->MappedBuffer,
                sizeof(SecBuffer)
                );
        }

        //
        // Whack the output handle with the one returned from the
        // package.
        //

        LsapChangeHandle(   HandleReplace,
                            NULL,
                            &Context->Handle );

        Context->Handle.dwLower = 0 ;
        Context->Handle.dwUpper = 0 ;

        *ptsExpiry = Context->Expiry ;

        pToken->cbBuffer = 0 ;

        Context = NULL ;

        return STATUS_SUCCESS ;
    }

    EncodedData.value = (PUCHAR) Buffer->pvBuffer ;
    EncodedData.length = Buffer->cbBuffer ;
    Request = NULL ;

    Result = SpnegoUnpackData(
                                EncodedData.value,
                                EncodedData.length,
                                Pdu,
                                (PVOID *)&InitialRequest);

    //
    // If unable, try it as a second-pass.
    //

    if ( !NT_SUCCESS(Result) )
    {
        Pdu = NegotiationToken_PDU;
        Result = SpnegoUnpackData(
                                EncodedData.value,
                                EncodedData.length,
                                Pdu,
                                (PVOID *)&Request);

        //
        // if the token didn't match either, give up now.
        //

        if (!NT_SUCCESS(Result))
        {
            NegpReportEvent(
                EVENTLOG_WARNING_TYPE,
                NEGOTIATE_UNKNOWN_PACKET,
                CATEGORY_NEGOTIATE,
                0,
                0 );

            return Result;
        }
    }
    else
    {
        Request = &InitialRequest->negToken;
    }

    //
    // This function only handles Negotiation tokens.  If we ended up with
    // anything else, something is wrong.
    //

    if ( (Pdu != NegotiationToken_PDU) &&
         (Pdu != InitialNegToken_PDU) )
    {
        scRet = SEC_E_INVALID_TOKEN ;

        goto Cleanup ;
    }

    //
    // If this is an initial request, verify the OID
    //

    if (InitialRequest != NULL)
    {
        if (NegpCompareOid(
                NegSpnegoMechOid,
                InitialRequest->spnegoMech
                ))
        {
            scRet = SEC_E_INVALID_TOKEN;
            goto Cleanup;
        }
    }

    //
    // Check to see if we already called Accept once on a package. If so,
    // we want to use the existing context handle.
    //


    if ( Request->choice == negTokenTarg_chosen )
    {
        scRet = NegHandleSubsequentClientRequest(
                    dwCreds,
                    pContext,
                    fContextReq,
                    TargetDataRep,
                    Pdu,
                    Request,
                    pdwNewContext,
                    pOutput,
                    pfContextAttr,
                    ptsExpiry,
                    pfMapContext,
                    pContextData );

        if (InitialRequest != NULL)
        {
            SpnegoFreeData( Pdu, InitialRequest );
        }
        else if ( Request )
        {
            SpnegoFreeData( Pdu, Request );
        }

        return scRet;
    }


    //
    // Ok, we have a request blob.  Figure out what they want,
    //

    NegReadLockCreds( Creds );

    scRet = NegpCrackRequest(   Creds,
                                Request,
                                & PackageId,
                                & MechList,
                                & Package,
                                & DesiredMatch );

    if ( !NT_SUCCESS( scRet ) )
    {

        NegUnlockCreds( Creds );

        goto Cleanup ;
    }



    if (DesiredMatch == MatchFailed)
    {
        //
        // There were no common packages, so return an error.
        //

        NegUnlockCreds( Creds );

        NegpReportEvent(
            EVENTLOG_WARNING_TYPE,
            NEGOTIATE_UNKNOWN_PACKAGE,
            CATEGORY_NEGOTIATE,
            0,
            0 );

        DebugLog(( DEB_TRACE, "No common packages for negotiator\n"));

        scRet = SEC_E_INVALID_TOKEN;
        goto Cleanup;
    }


    DsysAssert( Package != NULL );

    //
    // Found a common package.  Was it the first one in the request
    // list?  If so, then check for a desired token and pass it down
    // to the other package
    //

    DebugLog(( DEB_TRACE_NEG, "Common Package is %ws\n",
                Package->LsaPackage->Name.Buffer ));

    Response.choice = negTokenTarg_chosen ;
    Response.u.negTokenTarg.supportedMech = Package->ObjectId ;
    Response.u.negTokenTarg.bit_mask |= supportedMech_present | negResult_present;

    if ( !Context )
    {
        Context = NegpCreateContext();

        if ( !Context )
        {
            NegUnlockCreds( Creds );

            scRet = SEC_E_INSUFFICIENT_MEMORY ;

            goto Cleanup ;
        }
    }


    //
    // Save away the mechlist for the mic at the end
    //

    if ( Context->SupportedMechs )
    {
        if ((Context->Flags & NEG_CONTEXT_FREE_EACH_MECH))
        {
            NegpFreeMechList(Context->SupportedMechs);
        }
        else
        {
            LsapFreeLsaHeap(Context->SupportedMechs);
        }

    }

    Context->SupportedMechs = NegpCopyMechList(MechList);
    if (Context->SupportedMechs == NULL)
    {
        NegUnlockCreds(Creds);
        scRet = SEC_E_INSUFFICIENT_MEMORY;
        goto Cleanup ;
    }
    Context->Flags |= NEG_CONTEXT_FREE_EACH_MECH;
    DebugLog(( DEB_TRACE_NEG, "Adding mech list for %p\n", Context));



    //
    // Reference the credentials so they don't go away before we
    // finish with the context.
    //

    if (Context->Creds == NULL)
    {
        Context->Creds = Creds ;

        NegUnlockCreds(Creds);
        NegWriteLockCreds(Creds);

        Creds->RefCount++;

        NegUnlockCreds(Creds);
        NegReadLockCreds(Creds);
    }

    Context->CredIndex = PackageId ;

    if ( ( DesiredMatch == PreferredSucceed ) &&
         ( Request->u.negTokenInit.bit_mask & NegTokenInit_mechToken_present ) )
    {
        CredHandle TempCredHandle;

        NegpReportEvent(
            EVENTLOG_INFORMATION_TYPE,
            NEGOTIATE_MESSAGE_DECODED,
            CATEGORY_NEGOTIATE,
            0,
            1,
            &Package->LsaPackage->Name
            );

        DebugLog(( DEB_TRACE_NEG, "Desired Package match with token!\n"));

        TempHandle = Context->Handle ;

        PackageId = GetCurrentPackageId();

        TempCredHandle = Creds->Creds[ Context->CredIndex ].Handle;

        //
        // Unlock the credentials while we make the call
        //

        NegUnlockCreds(Creds);



        //
        // Build up a buffer for accept
        //

        AcceptBuffer.pvBuffer = Request->u.negTokenInit.mechToken.value;
        AcceptBuffer.cbBuffer = Request->u.negTokenInit.mechToken.length;
        AcceptBuffer.BufferType = SECBUFFER_READONLY | SECBUFFER_TOKEN ;

        AcceptBufferDesc.ulVersion = SECBUFFER_VERSION ;
        AcceptBufferDesc.cBuffers = 1;
        AcceptBufferDesc.pBuffers = &AcceptBuffer ;

        ResponseBufferDesc.ulVersion = SECBUFFER_VERSION ;
        ResponseBufferDesc.cBuffers = 1;

        if( pToken->cbBuffer >= Package->LsaPackage->TokenSize )
        {
            UserResponseBuffer.cbBuffer = pToken->cbBuffer;
            UserResponseBuffer.BufferType = SECBUFFER_TOKEN ;

            UserResponseBuffer.pvBuffer = pToken->pvBuffer;

            ResponseBufferDesc.pBuffers = &UserResponseBuffer ;
        } else {
            ResponseBuffer.cbBuffer = Package->LsaPackage->TokenSize ;
            ResponseBuffer.BufferType = SECBUFFER_TOKEN ;

            ResponseBuffer.pvBuffer = LsapAllocateLsaHeap(
                                                ResponseBuffer.cbBuffer );

            if ( ResponseBuffer.pvBuffer == NULL )
            {
                scRet = SEC_E_INSUFFICIENT_MEMORY ;

                goto Cleanup ;
            }

            ResponseBufferDesc.pBuffers = &ResponseBuffer ;
        }


        scRet = WLsaAcceptContext(
                        &TempCredHandle,
                        &TempHandle,
                        &AcceptBufferDesc,
                        (fContextReq & (~(ASC_REQ_ALLOCATE_MEMORY))),
                        SECURITY_NATIVE_DREP,
                        &Context->Handle,
                        &ResponseBufferDesc,
                        &Context->Attributes,
                        &Context->Expiry,
                        &Context->Mapped,
                        &Context->MappedBuffer );

        SetCurrentPackageId( PackageId );

        Context->CallCount++ ;

        DebugLog(( DEB_TRACE_NEG, "WLsaAcceptContext( %ws ) returned %x\n",
                    Creds->Creds[ Context->CredIndex ].Package->LsaPackage->Name.Buffer,
                    scRet ));

        if ( !NT_SUCCESS( scRet ) )
        {
            DebugLog((DEB_TRACE, "Neg Failure from package %ws, %#x\n",
                        Package->LsaPackage->Name.Buffer, scRet ));

            if( ResponseBuffer.pvBuffer )
            {
                LsapFreeLsaHeap( ResponseBuffer.pvBuffer );
            }

            goto Cleanup ;

        }

        NegReadLockCreds(Creds);


        //
        // Now:  push that info back out to our caller,
        //

        Context->LastStatus = scRet ;


        //
        // Mark the context to indicate that we already called
        // AcceptSecurityContext once.
        //

        Context->Flags |= NEG_CONTEXT_PACKAGE_CALLED;

        //
        // Set the response pointers up so they get folded in to the
        // response packet
        //

        Response.u.negTokenTarg.responseToken.length = ResponseBufferDesc.pBuffers[0].cbBuffer ;
        Response.u.negTokenTarg.responseToken.value = (PUCHAR) ResponseBufferDesc.pBuffers[0].pvBuffer ;

        Response.u.negTokenTarg.bit_mask |= responseToken_present ;


        *ptsExpiry = Context->Expiry;
        *pfContextAttr = Context->Attributes;

        if (scRet == STATUS_SUCCESS)
        {
            Response.u.negTokenTarg.negResult = accept_completed;

            //
            // Generate a MIC here
            //

            //
            // Get rid of the mech list now, since
            // it has been mic'd.  As it were.
            //

            if ( Context->SupportedMechs )
            {
                DebugLog(( DEB_TRACE_NEG, "Freeing mech list for %p\n", Context ));

                NegpFreeMechList( Context->SupportedMechs );

                Context->SupportedMechs = NULL ;
            }

            // scRet = SEC_I_CONTINUE_NEEDED ;
        }
        else
        {
            DsysAssert((scRet == SEC_I_CONTINUE_NEEDED) ||
                       (scRet == SEC_I_COMPLETE_NEEDED) ||
                       (scRet == SEC_I_COMPLETE_AND_CONTINUE))
            Response.u.negTokenTarg.negResult = accept_incomplete;
        }

        //
        // Fall through to rest of handling
        //

    }
    else
    {
        //
        // We have a common package, but either there is no desired token
        // present, or the common package was not the desired one.  The
        // selected package is in the structure already, so we don't have
        // to do anything here.
        //

        NegpReportEvent(
            EVENTLOG_INFORMATION_TYPE,
            NEGOTIATE_MESSAGE_DECODED_NO_TOKEN,
            CATEGORY_NEGOTIATE,
            0,
            1,
            &Package->LsaPackage->Name
            );

        scRet = SEC_I_CONTINUE_NEEDED;

        DebugLog(( DEB_TRACE_NEG, "Common package has no token\n"));
        Response.u.negTokenTarg.negResult = accept_incomplete;
    }

    NegUnlockCreds( Creds );

    //
    // Assemble reply token:
    //

    EncodedData.value = 0 ;
    EncodedData.length = 0 ;

    Result = SpnegoPackData(
                            &Response,
                            NegotiationToken_PDU,
                            &(EncodedData.length),
                            &(EncodedData.value));


    //
    // Clean up:
    //

    if ( ResponseBuffer.pvBuffer )
    {
        LsapFreeLsaHeap( ResponseBuffer.pvBuffer );

        ResponseBuffer.pvBuffer = NULL ;
    }

    if (InitialRequest != NULL)
    {
        SpnegoFreeData( Pdu, InitialRequest );
        InitialRequest = NULL;
        Request = NULL;
    }
    else if ( Request )
    {
        SpnegoFreeData( Pdu, Request );
        Request = NULL;
    }


    if ( !NT_SUCCESS(Result) )
    {
        DebugLog((DEB_ERROR, "Failed to encode data: %d\n", Result ));

        scRet = Result;
        goto Cleanup ;

    }
    else
    {
        if ( fContextReq & ASC_REQ_ALLOCATE_MEMORY )
        {
            pToken->pvBuffer = EncodedData.value ;

            *pfContextAttr |= ASC_RET_ALLOCATED_MEMORY ;

            EncodedData.value = NULL ;
            pToken->cbBuffer = EncodedData.length ;

        }
        else
        {
            if ( pToken->cbBuffer >= (ULONG) EncodedData.length )
            {
                RtlCopyMemory(  pToken->pvBuffer,
                                EncodedData.value,
                                EncodedData.length );

                pToken->cbBuffer = EncodedData.length ;
            }
            else if ( ( ( fContextReq & ASC_REQ_FRAGMENT_TO_FIT ) != 0 ) &&
                      ( pToken->cbBuffer >= SPNEGO_MINIMUM_BUFFER ) )
            {
                //
                // Ok, we need to whack the context to indicate that we are
                // fragmenting, and return only what the caller can handle.
                //

                Context->Message = EncodedData.value ;
                Context->TotalSize = EncodedData.length ;
                Context->Flags |= NEG_CONTEXT_FRAGMENTING ;

                //
                // set this to NULL so it doesn't get freed later
                //

                EncodedData.value = NULL ;
                RtlCopyMemory(
                    pToken->pvBuffer,
                    Context->Message,
                    pToken->cbBuffer );

                Context->CurrentSize = pToken->cbBuffer ;
            }
            else
            {
                scRet = SEC_E_INSUFFICIENT_MEMORY ;

                goto Cleanup ;
            }
        }



        //
        // If the context has been mapped by the underlying package,
        // get out of the way:
        //

        if ( scRet == SEC_E_OK )
        {
            if ( Context->Mapped )
            {
                *pfContextAttr = Context->Attributes ;

                if ( fContextReq & ASC_REQ_ALLOCATE_MEMORY )
                {

                    *pfContextAttr |= ASC_RET_ALLOCATED_MEMORY ;

                }
                *ptsExpiry = Context->Expiry ;
                *pfMapContext = Context->Mapped ;
                *pContextData = Context->MappedBuffer ;

                //
                // Set this to NULL so we don't later try
                // to free it.
                //

                Context->MappedBuffer.pvBuffer = NULL ;

            }

            LsapChangeHandle(   HandleReplace,
                                NULL,
                                &Context->Handle );

            Context->Handle.dwLower = 0 ;
            Context->Handle.dwUpper = 0 ;


            if ( !pContext )
            {
                //
                // If we created this context during this call, get
                // rid of it now
                //

                NegpDeleteContext( Context );
            }
            Context = NULL ;
        }
        else
        {
            *pdwNewContext = (DWORD_PTR) Context ;
        }

    }

    if ( EncodedData.value )
    {
        LsapFreeLsaHeap( EncodedData.value );
    }

    return( scRet );

Cleanup:

    if (InitialRequest != NULL)
    {
        SpnegoFreeData( Pdu, InitialRequest );
    }
    else if ( Request )
    {
        SpnegoFreeData( Pdu, Request );
    }

    if ( Context )
    {
        if ( Context->Handle.dwLower )
        {
            WLsaDeleteContext( &Context->Handle );
            Context->Handle.dwLower = 0;
        }

        if ( pContext == NULL )
        {
            NegpDeleteContext( Context );
        }
    }

    return( scRet );
}


//+-------------------------------------------------------------------------
//
//  Function:   NegHandleServerReply
//
//  Synopsis:   Handles a subsequent call to InitializeSecurityContext
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------


SECURITY_STATUS
NegHandleServerReply(
    ULONG_PTR dwCreds,
    PNEG_CONTEXT pContext,
    PSECURITY_STRING Target,
    ULONG   fContextReq,
    ULONG TargetDataRep,
    PSecBufferDesc  pInput,
    PULONG_PTR pdwNewContext,
    PSecBufferDesc  pOutput,
    PULONG  pfContextAttr,
    PTimeStamp          ptsExpiry,
    PBYTE               pfMapContext,
    PSecBuffer          pContextData)
{
    SECURITY_STATUS scRet;
    NegotiationToken * Reply = NULL ;
    NegotiationToken Request;
    ASN1octetstring_t EncodedData = {0};
    SECURITY_STATUS Result;
    ULONG Pdu = NegotiationToken_PDU;
    PSecBuffer  Buffer;
    struct MechTypeList *pMechs;
    PNEG_CREDS Creds;
    PNEG_CONTEXT Context ;
    ULONG_PTR PackageIndex ;
    PNEG_PACKAGE Package ;
    SecBuffer       InitBuffer ;
    SecBufferDesc   InitBufferDesc ;
    ULONG_PTR PackageId ;
    PCtxtHandle pInitHandle ;
    CtxtHandle TempHandle = { 0, 0 };
    ULONG LocalContextReq = fContextReq;
    ULONG LocalContextAttr = 0 ;
    BOOLEAN ClientFinished = FALSE;
    BOOLEAN ServerFinished = FALSE;
    SecBuffer           OutputToken = {0};
    SecBufferDesc       OutputDescription ;
    PSecBuffer OutputBuffer = NULL;
    CredHandle TempCredHandle ;

    RtlZeroMemory(
        &Request,
        sizeof(NegotiationToken)
        );
    RtlZeroMemory(
        &OutputToken,
        sizeof(SecBuffer)
        );

    //
    // Find the token buffer:
    //

    scRet = NegpParseBuffers( pInput, TRUE, &Buffer, NULL );

    if ( !NT_SUCCESS( scRet ) )
    {
        DebugLog(( DEB_ERROR, "NegHandleServerReply failed to map input buffers, %x\n", scRet ));
        return( scRet );
    }

    if ( !Buffer )
    {
        DebugLog(( DEB_ERROR, "NegHandleServerReply failed to map input buffers (NULL)\n" ));
        return( SEC_E_INVALID_TOKEN );
    }

    scRet = NegpParseBuffers( pOutput, TRUE, &OutputBuffer, NULL );
    if (!NT_SUCCESS(scRet))
    {
        DebugLog(( DEB_ERROR, "NegHandleServerReply failed to map output buffers, %x\n", scRet ));
        goto HSR_ErrorReturn;
    }

    //
    // Get the credential handle. If it wasn't passed in, use the one from
    // the context.
    //

    if (dwCreds != 0)
    {
        Creds = (PNEG_CREDS) dwCreds ;
    }
    else
    {
        Creds = pContext->Creds;
    }

    Context = pContext ;

    NegpValidContext( Context );

    //
    // Decode the reply token:
    //

    EncodedData.value = (PUCHAR) Buffer->pvBuffer ;
    EncodedData.length = Buffer->cbBuffer ;
    Reply = NULL ;

    Result = SpnegoUnpackData(
                                EncodedData.value,
                                EncodedData.length,
                                Pdu,
                                (PVOID *)&Reply);

    //
    // Reset the encoded data value so we don't free it accidentally
    //

    EncodedData.value = NULL;

    if ( !NT_SUCCESS(Result) )
    {
        DebugLog(( DEB_TRACE_NEG, "Unknown token from server: %d\n", Result ));

        scRet = Result;
        goto HSR_ErrorReturn ;
    }

    if ( Reply->choice != negTokenTarg_chosen )
    {
        DebugLog(( DEB_TRACE_NEG, "Found Request token, expecting Reply token\n" ));

        scRet = SEC_E_INVALID_TOKEN ;

        goto HSR_ErrorReturn ;
    }

    if ((Reply->u.negTokenTarg.bit_mask & negResult_present) != 0)
    {
        if (Reply->u.negTokenTarg.negResult == reject)
        {
            DebugLog((DEB_TRACE_NEG,"Server rejected\n"));
            scRet = SEC_E_LOGON_DENIED;
            goto HSR_ErrorReturn;
        }
        if (Reply->u.negTokenTarg.negResult == accept_completed)
        {
            ServerFinished = TRUE;
        }
    }

    //
    // Ok, see what the server sent us.  In an ideal world, the server will send
    // us a preferred, chosen token.
    //

    InitBuffer.pvBuffer = NULL ;
    InitBuffer.cbBuffer = 0 ;
    InitBuffer.BufferType = SECBUFFER_TOKEN ;

    InitBufferDesc.ulVersion = SECBUFFER_VERSION ;
    InitBufferDesc.cBuffers = 1 ;
    InitBufferDesc.pBuffers = &InitBuffer ;

    if ( Reply->u.negTokenTarg.bit_mask & supportedMech_present )
    {
        NegReadLockCreds( Creds );

        PackageIndex = NegpFindPackageForOid( Creds,
                                            Reply->u.negTokenTarg.supportedMech );


        if ( PackageIndex == NEG_INVALID_PACKAGE )
        {
            NegUnlockCreds( Creds );

            NegDumpOid( "Invalid OID returned by server",
                        Reply->u.negTokenTarg.supportedMech );

            scRet = SEC_E_INVALID_TOKEN ;

            goto HSR_ErrorReturn ;
        }

        Package = Creds->Creds[ PackageIndex ].Package ;
        NegUnlockCreds( Creds );

        DebugLog(( DEB_TRACE_NEG, "Server supports %ws!\n",
                                Package->LsaPackage->Name.Buffer ));

        if ( Reply->u.negTokenTarg.bit_mask & responseToken_present )
        {
            //
            // Oh boy!  A Token too!
            //

            InitBuffer.pvBuffer = Reply->u.negTokenTarg.responseToken.value ;
            InitBuffer.cbBuffer = (ULONG) Reply->u.negTokenTarg.responseToken.length ;

            Context->Flags |= NEG_CONTEXT_UPLEVEL ;

        }
        else if ( Reply->u.negTokenTarg.bit_mask & NegTokenTarg_mechListMIC_present )
        {
            InitBuffer.pvBuffer = Reply->u.negTokenTarg.mechListMIC.value ;
            InitBuffer.cbBuffer = Reply->u.negTokenTarg.mechListMIC.length ;
        }

    }
    else
    {
        //
        // If we haven't settled on a package yet, we need a mechanism.
        //

        if ((Context->Flags & NEG_CONTEXT_PACKAGE_CALLED ) == 0)
        {
            //
            // No token specified, nor preferred mechanism.  Find the first
            // acceptible package in the returned list
            //

            DebugLog((DEB_TRACE_NEG, "No preferred mech from the server?\n"));

            DebugLog(( DEB_TRACE_NEG, "We must drop into GSS only mode for this to work\n"));

            DebugLog(( DEB_ERROR, "No preferred mech from server, not handled yet\n"));

            return( SEC_E_INVALID_TOKEN );
        }

        NegReadLockCreds( Creds );

        Package = Creds->Creds[ Context->CredIndex ].Package ;
        PackageIndex = Context->CredIndex;
        NegUnlockCreds( Creds );

        if ( Reply->u.negTokenTarg.bit_mask & responseToken_present )
        {
            //
            // Oh boy!  A Token too!
            //

            InitBuffer.pvBuffer = Reply->u.negTokenTarg.responseToken.value ;
            InitBuffer.cbBuffer = (ULONG) Reply->u.negTokenTarg.responseToken.length ;

            Context->Flags |= NEG_CONTEXT_UPLEVEL ;

        }
        else if ( Reply->u.negTokenTarg.bit_mask & NegTokenTarg_mechListMIC_present )
        {
            InitBuffer.pvBuffer = Reply->u.negTokenTarg.mechListMIC.value ;
            InitBuffer.cbBuffer = Reply->u.negTokenTarg.mechListMIC.length ;
        }

    }

    DebugLog(( DEB_TRACE_NEG, "Calling package %ws\n",
                        Package->LsaPackage->Name.Buffer ));

    //
    // Call into the package, possibly again, possibly the first time, and
    // let the package have at it.
    //

    if ( (Context->CredIndex != PackageIndex) &&
         ((Context->Flags & NEG_CONTEXT_PACKAGE_CALLED) != 0) )
    {
        DebugLog(( DEB_TRACE_NEG, "Switched packages, package %ws not selected anymore\n",
                    Creds->Creds[Context->CredIndex].Package->LsaPackage->Name.Buffer ));

        //
        // Got to delete the context:
        //

        PackageId = GetCurrentPackageId();

        WLsaDeleteContext( &Context->Handle );

        SetCurrentPackageId( PackageId );
        Context->Flags &= ~NEG_CONTEXT_PACKAGE_CALLED;

        //
        // Clean up the context information in the handle
        //

        if ( Context->MappedBuffer.pvBuffer != NULL)
        {
            LsapFreeLsaHeap(
                Context->MappedBuffer.pvBuffer
                );

            Context->MappedBuffer.pvBuffer = NULL;
            Context->MappedBuffer.cbBuffer = 0;
        }
        Context->Mapped = FALSE;


        //
        // Reset the last status to make sure we call Initailize again.
        //

        Context->LastStatus = SEC_I_CONTINUE_NEEDED;

        //
        // Don't modify TempHandle which is already set to 0,0
        //

    }
    else
    {
        TempHandle = Context->Handle ;
    }

    if ( Context->LastStatus == SEC_I_CONTINUE_NEEDED )
    {
        BOOLEAN LocalContextMapped = FALSE;
        SecBuffer LocalContextData = {0,0,NULL};

        PackageId = GetCurrentPackageId();

        //
        // Client side call.  Here, we call down to the desired package,
        // and have it generate a blob to be encoded and sent over to the
        // server.
        //


        OutputToken.pvBuffer = NULL;
        OutputToken.cbBuffer = 0;
        OutputToken.BufferType = SECBUFFER_TOKEN ;

        OutputDescription.ulVersion = SECBUFFER_VERSION ;
        OutputDescription.cBuffers = 1;
        OutputDescription.pBuffers = &OutputToken ;
        LocalContextReq |= ISC_REQ_ALLOCATE_MEMORY ;
        LocalContextAttr = 0;

        TempCredHandle = Creds->Creds[ PackageIndex ].Handle ;

        scRet = WLsaInitContext(&TempCredHandle,
                                &TempHandle,
                                &Context->Target,
                                LocalContextReq,
                                0,
                                TargetDataRep,
                                &InitBufferDesc,
                                0,
                                &Context->Handle,
                                &OutputDescription,
                                &LocalContextAttr,
                                ptsExpiry,
                                &LocalContextMapped,
                                &LocalContextData );

        DebugLog(( DEB_TRACE_NEG, "Subsequent call to WLsaInitContext( %ws ) returned %x\n",
                Creds->Creds[ PackageIndex ].Package->LsaPackage->Name.Buffer,
                scRet ));

        SetCurrentPackageId( PackageId );

        Context->CallCount++ ;
        Context->LastStatus = scRet;

        if (!NT_SUCCESS(scRet))
        {
            goto HSR_ErrorReturn;
        }

        Context->Flags |= NEG_CONTEXT_PACKAGE_CALLED;


        if (NT_SUCCESS(scRet) && LocalContextMapped)
        {
            if (Context->Mapped)
            {
                DebugLog((DEB_ERROR,"Package tried to map a context twice!\n"));
                scRet = SEC_E_INTERNAL_ERROR;
                LsapFreeLsaHeap(LocalContextData.pvBuffer);
                goto HSR_ErrorReturn;

            }
            Context->Mapped = LocalContextMapped;
            Context->MappedBuffer = LocalContextData;
            Context->Expiry = *ptsExpiry ;
        }

    }
    else
    {

        DebugLog(( DEB_TRACE_NEG, "Package did not need to be called again.\n"));


        if (OutputBuffer != NULL )
        {
            OutputBuffer->cbBuffer = 0;
        }

        scRet = STATUS_SUCCESS;
    }

    if ( Reply != NULL )
    {
        SpnegoFreeData( Pdu, Reply );

        Reply = NULL ;
    }

    //
    // Build reply buffer:
    //


    Request.choice = negTokenTarg_chosen;
    Request.u.negTokenTarg.bit_mask = 0 ;

    //
    // If there was an output buffer, package it up to ship back to the server.
    //

    if ((OutputToken.cbBuffer != 0) && (OutputToken.pvBuffer != NULL))
    {
        if (ServerFinished)
        {
            NegpReportEvent(
                EVENTLOG_WARNING_TYPE,
                NEGOTIATE_UNBALANCED_EXCHANGE,
                CATEGORY_NEGOTIATE,
                0,
                2,
                Target,
                &Creds->Creds[PackageIndex].Package->LsaPackage->Name
                );

            DebugLog((DEB_ERROR,"Server finished but client sending back data\n"));
            scRet = SEC_E_INTERNAL_ERROR;
            goto HSR_ErrorReturn;
        }

        //
        //
        // mechSpecInfo is evil, try to take it out.
        //

        Request.u.negTokenTarg.bit_mask = responseToken_present;
        Request.u.negTokenTarg.responseToken.value = (PUCHAR) OutputToken.pvBuffer;
        Request.u.negTokenTarg.responseToken.length = (int) OutputToken.cbBuffer;


    }


    //
    // Compute the MIC of the mechList, so that the other
    // guy knows we weren't tampered on the wire
    //

    if ( scRet == STATUS_SUCCESS )
    {
        //
        // not yet
        //

        NOTHING ;
    }

    if ( ( OutputToken.cbBuffer != 0 ) )
    {
        //
        // Encode request token:
        //

        EncodedData.value = 0 ;
        EncodedData.length = 0 ;

        Result = SpnegoPackData(
                    &Request,
                    NegotiationToken_PDU,
                    &(EncodedData.length),
                    &(EncodedData.value));

        if ( !NT_SUCCESS(Result) )
        {
            DebugLog((DEB_ERROR, "Failed to encode data: %d\n", Result ));

            scRet = Result;
            goto HSR_ErrorReturn ;

        }
        else
        {
            if ( fContextReq & ISC_REQ_ALLOCATE_MEMORY )
            {
                OutputBuffer->pvBuffer = EncodedData.value ;
                OutputBuffer->cbBuffer = EncodedData.length ;

                *pfContextAttr = LocalContextAttr;

                EncodedData.value = NULL ;

            }
            else
            {
                if ( OutputBuffer->cbBuffer >= (ULONG) EncodedData.length )
                {
                    RtlCopyMemory(  OutputBuffer->pvBuffer,
                                    EncodedData.value,
                                    EncodedData.length );

                    *pfContextAttr = LocalContextAttr & ~ISC_RET_ALLOCATED_MEMORY;
                    OutputBuffer->cbBuffer = EncodedData.length ;
                }
                else if ( ( ( fContextReq & ISC_REQ_FRAGMENT_TO_FIT ) != 0 ) &&
                          ( OutputBuffer->cbBuffer >= SPNEGO_MINIMUM_BUFFER ) )
                {
                    //
                    // Ok, we need to whack the context to indicate that we are
                    // fragmenting, and return only what the caller can handle.
                    //

                    Context->Message = EncodedData.value ;
                    Context->TotalSize = EncodedData.length ;
                    Context->Flags |= NEG_CONTEXT_FRAGMENTING ;

                    //
                    // set this to NULL so it doesn't get freed later
                    //

                    EncodedData.value = NULL ;
                    RtlCopyMemory(
                        OutputBuffer->pvBuffer,
                        Context->Message,
                        OutputBuffer->cbBuffer );

                    Context->CurrentSize = OutputBuffer->cbBuffer ;
                }
                else
                {
                    scRet = SEC_E_INSUFFICIENT_MEMORY ;

                    goto HSR_ErrorReturn ;
                }
            }


        }
    }
    else
    {
        if ( OutputBuffer )
        {
            OutputBuffer->cbBuffer = 0 ;
        }


    }

    if ( scRet == STATUS_SUCCESS )
    {
        if ( ( Context->Flags & NEG_CONTEXT_FRAGMENTING ) ||
             ( ServerFinished == FALSE ) )
        {
            scRet = SEC_I_CONTINUE_NEEDED ;
        }
        else
        {
            ClientFinished = TRUE ;
        }

    }

    //
    // On success, we push the handle back to the client.  From this point on,
    // the selected package is in charge.
    //


    if ( ClientFinished )
    {
        //
        // If the data was mapped by the package the first time make sure
        // we copy it down now.
        //

        *pfContextAttr = Context->Attributes ;

        *ptsExpiry = Context->Expiry ;

        if (Context->Mapped)
        {
            *pfMapContext = Context->Mapped;
            *pContextData = Context->MappedBuffer;

            //
            // Set these to FALSE & NULL so we don't try to
            // free them later.
            //

            Context->MappedBuffer.pvBuffer = NULL;
        }

        LsapChangeHandle( HandleReplace,
                          NULL,
                          &Context->Handle );

        Context->Handle.dwLower = 0 ;
        Context->Handle.dwUpper = 0 ;

        if ( pContext == NULL )
        {
            NegpDeleteContext( Context );
        }

        // NegpDeleteContext( Context );
    }

HSR_ErrorReturn:

    if ( OutputToken.pvBuffer )
    {
        LsapFreeLsaHeap(OutputToken.pvBuffer);
        OutputToken.pvBuffer = NULL ;
    }

    if ( EncodedData.value )
    {
        LsapFreeLsaHeap( EncodedData.value );
    }


    if ( Reply )
    {
        SpnegoFreeData( Pdu, Reply );
    }

    return( scRet );

}


SECURITY_STATUS
NegAddFragmentToContext(
    PNEG_CONTEXT Context,
    PSecBuffer  Fragment
    )
{
    if ( Fragment->cbBuffer <= (Context->TotalSize - Context->CurrentSize) )
    {

        RtlCopyMemory(
            Context->Message + Context->CurrentSize,
            Fragment->pvBuffer,
            Fragment->cbBuffer );

        Context->CurrentSize += Fragment->cbBuffer ;

        if ( Context->CurrentSize == Context->TotalSize )
        {
            Context->Flags &= (~(NEG_CONTEXT_FRAGMENTING));
            return STATUS_SUCCESS ;
        }

        DebugLog((DEB_TRACE_FRAG, "Adding %i to context %p (%i remains) \n", Fragment->cbBuffer, Context, (Context->TotalSize - Context->CurrentSize)));

        return SEC_I_CONTINUE_NEEDED ;

    }

    return SEC_E_INSUFFICIENT_MEMORY ;
}

SECURITY_STATUS
SEC_ENTRY
NegCreateContextFromFragment(
   LSA_SEC_HANDLE  dwCredHandle,
   LSA_SEC_HANDLE  dwCtxtHandle,
   PSecBuffer      Buffer,
   ULONG           fContextReq,
   ULONG           TargetDataRep,
   PLSA_SEC_HANDLE pdwNewContext,
   PSecBufferDesc  pOutput,
   PULONG          pfContextAttr
   )
{
    NEG_CONTEXT * Context ;
    NEG_CREDS * Creds ;
    LONG ExpectedSize ;
    LONG HeaderSize ;
    PUCHAR Message ;
    LONG MessageSize ;
    SECURITY_STATUS scRet ;
    PSecBuffer OutBuf ;
    ObjectID DecodedOid = NULL;
    NTSTATUS Status;

    Creds = (NEG_CREDS *) dwCredHandle ;

    if ( Buffer->cbBuffer > MAXLONG )
    {
        return SEC_E_INVALID_TOKEN ;
    }
    if ( Buffer->cbBuffer <= 1 )
    {
        return SEC_E_INVALID_TOKEN ;
    }

    Message = (PUCHAR) Buffer->pvBuffer ;

    if ( (*Message != 0xa0 ) &&
         (*Message != 0x60 ) )
    {
        return SEC_E_INVALID_TOKEN ;
    }

    MessageSize = Buffer->cbBuffer ;

    Message++ ;
    MessageSize -- ;


    ExpectedSize = Neg_der_read_length(
                    &Message,
                    &MessageSize,
                    &HeaderSize );

    if ( ExpectedSize > 0 )
    {
        //
        // Header size + 1 since we already incremented above
        //
        ExpectedSize += HeaderSize + 1;
    }

    if ( ExpectedSize < 0 )
    {
        return SEC_E_INVALID_TOKEN ;
    }

    if ( (ULONG) ExpectedSize < Buffer->cbBuffer )
    {
        return SEC_E_INVALID_TOKEN ;
    }


    //
    // Get the OID from the token, if possible, to see if it is for SPNEGO
    //

    Status = NegpGetTokenOid(
                (PUCHAR) Buffer->pvBuffer,
                Buffer->cbBuffer,
                &DecodedOid
                );

    if (!NT_SUCCESS(Status))
    {
        return(Status);
    }

    //
    // Check for spnego
    //

    if (NegpCompareOid(
            DecodedOid,
            NegSpnegoMechOid
            ) != 0)
    {
        NegpFreeObjectId(DecodedOid);
        return(SEC_E_INVALID_TOKEN);
    }
    NegpFreeObjectId(DecodedOid);

    if ( (ULONG) ExpectedSize == Buffer->cbBuffer )
    {
        *pdwNewContext = 0 ;

        return SEC_E_OK ;
    }

    Context = NegpCreateContext();

    if ( !Context )
    {
        return SEC_E_INSUFFICIENT_MEMORY ;
    }

    Context->Flags = NEG_CONTEXT_FRAGMENTING ;

    Context->Message = (PUCHAR) LsapAllocateLsaHeap( ExpectedSize ) ;

    if ( !Context->Message )
    {
        NegpDeleteContext( Context );

        return SEC_E_INSUFFICIENT_MEMORY ;
    }

    Context->CurrentSize = 0 ;
    Context->TotalSize = ExpectedSize ;


    scRet = NegAddFragmentToContext(
                Context,
                Buffer );

    if ( !NT_SUCCESS( scRet ) )
    {
        NegpDeleteContext( Context );
    }
    else
    {
        *pdwNewContext = (LSA_SEC_HANDLE) Context ;

        DsysAssert( scRet != SEC_E_OK );

        NegpParseBuffers( pOutput, FALSE, &OutBuf, NULL );

        if ( OutBuf )
        {
            OutBuf->cbBuffer = 0 ;
        }

        Context->Creds = Creds ;

        //
        // Reference the credentials so they don't go away unexpectedly
        //

        NegWriteLockCreds(Creds);

        Creds->RefCount++;

        NegUnlockCreds(Creds);


        DebugLog((DEB_TRACE_FRAG, "Context %p is a frag \n", Context));
        DebugLog((DEB_TRACE_FRAG, "Total %i : Current %i \n", Context->TotalSize, Context->CurrentSize ));    
    }

    return scRet ;

}

//+---------------------------------------------------------------------------
//
//  Function:   NegInitLsaModeContext
//
//  Synopsis:   Initialize a client side context
//
//  Arguments:  [dwCredHandle]  --
//              [dwCtxtHandle]  --
//              [pszTargetName] --
//              [fContextReq]   --
//              [TargetDataRep] --
//              [pInput]        --
//              [pdwNewContext] --
//              [pOutput]       --
//              [pfContextAttr] --
//              [ptsExpiry]     --
//              [pfMapContext]  --
//              [pContextData]  --
//
//  History:    7-26-96   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
SECURITY_STATUS SEC_ENTRY
NegInitLsaModeContext(
                LSA_SEC_HANDLE      dwCredHandle,
                LSA_SEC_HANDLE      dwCtxtHandle,
                PSECURITY_STRING    pszTargetName,
                ULONG               fContextReq,
                ULONG               TargetDataRep,
                PSecBufferDesc      pInput,
                PLSA_SEC_HANDLE     pdwNewContext,
                PSecBufferDesc      pOutput,
                PULONG              pfContextAttr,
                PTimeStamp          ptsExpiry,
                PBYTE               pfMapContext,
                PSecBuffer          pContextData)
{
    SECURITY_STATUS scRet = SEC_E_OK;
    PSecBuffer Buffer  = NULL;
    SecBuffer LocalBuffer  = {0};
    PSecBuffer OutBuf = NULL;
    PNEG_CONTEXT Context  = NULL;
    ULONG PackageIndex ;
    ULONG CallState ;

    CallState = 0 ;

    if ( dwCtxtHandle )
    {
        CallState |= LATER_CALL_BIT ;
    }

    scRet = NegpParseBuffers( pInput, FALSE, &Buffer, NULL );

    if ( !NT_SUCCESS( scRet ) )
    {
        DebugLog(( DEB_ERROR, "NegInitLsaModeContext failed to map input buffers, %x\n", scRet ));
        return scRet ;
    }

    if ( ( Buffer != NULL ) &&
         ( Buffer->cbBuffer != 0 ) )
    {
        CallState |= BUFFER_PRESENT_BIT ;
    }

    if ( fContextReq & ISC_REQ_DATAGRAM )
    {
        return SEC_E_UNSUPPORTED_FUNCTION ;
    }


    switch ( CallState )
    {
        case FIRST_CALL_WITH_INPUT:
            //
            // Initial case:  Server initiated blob, may be
            // fragmented
            //


            scRet = NegCreateContextFromFragment(
                        dwCredHandle,
                        dwCtxtHandle,
                        Buffer,
                        fContextReq,
                        TargetDataRep,
                        pdwNewContext,
                        pOutput,
                        pfContextAttr );

            if ( scRet == SEC_E_OK )
            {
                Context = (PNEG_CONTEXT) *pdwNewContext ;

                if ( Context )
                {
                    //
                    // final
                    //
                    *pdwNewContext = 0 ;

                    LocalBuffer.BufferType = SECBUFFER_TOKEN ;
                    LocalBuffer.cbBuffer = Context->TotalSize ;
                    LocalBuffer.pvBuffer = Context->Message ;

                    //
                    // Reset frag buffer to NULL - this will be
                    // freed when the call completes by the LSA wrappers.
                    // hence the ChangeBuffer call below:
                    //

                    Context->Message = NULL ;

                    LsapChangeBuffer( Buffer, &LocalBuffer );

                    //
                    // Get rid of the context - we have the whole
                    // message
                    //

                    NegpDeleteContext( Context );
                }
            }
            else if ( NT_SUCCESS( scRet ) )
            {
                //
                // building a context, so return now
                //

                break;
            }


            if ( !NT_SUCCESS( scRet ) )
            {
                //
                // Check the package in use. It is possible that we are being
                // sent the context token from a totally separate package and
                // are being asked to dispatch to the appropriate package.
                //

                scRet = NegpDetermineTokenPackage(
                            dwCredHandle,
                            Buffer,
                            &PackageIndex
                            );



            }
            else
            {
                PackageIndex = (ULONG) -1 ;
            }

            if ( PackageIndex != (ULONG) -1 )
            {
                CtxtHandle TempCtxtHandle = {0};
                CtxtHandle TempInputCtxtHandle = {0};
                CredHandle TempCredHandle;
                PNEG_CREDS Creds = (PNEG_CREDS) dwCredHandle;

                NegpReportEvent(
                    EVENTLOG_INFORMATION_TYPE,
                    NEGOTIATE_RAW_PACKET,
                    CATEGORY_NEGOTIATE,
                    0,
                    1,
                    &Creds->Creds[PackageIndex].Package->LsaPackage->Name
                    );

                //
                // Call into another package to do the accept
                //

                NegReadLockCreds(Creds);
                TempCredHandle = Creds->Creds[PackageIndex].Handle;
                NegUnlockCreds(Creds);

                DebugLog(( DEB_TRACE_NEG, "Got a blob directly for package %x\n",
                            TempCredHandle.dwLower ));

                scRet = WLsaInitContext(
                            &TempCredHandle,
                            &TempInputCtxtHandle,
                            pszTargetName,
                            fContextReq,
                            0,
                            TargetDataRep,
                            pInput,
                            0,
                            &TempCtxtHandle,
                            pOutput,
                            pfContextAttr,
                            ptsExpiry,
                            pfMapContext,
                            pContextData
                            );

                if (NT_SUCCESS(scRet))
                {
                    LsapChangeHandle(
                        HandleReplace,
                        NULL,
                        &TempCtxtHandle
                        );
                }
            }
            else
            {
                scRet = NegCrackServerRequestAndReply(
                                dwCredHandle,
                                pszTargetName,
                                fContextReq | ISC_REQ_MUTUAL_AUTH,
                                TargetDataRep,
                                pInput,
                                pdwNewContext,
                                pOutput,
                                pfContextAttr,
                                ptsExpiry,
                                pfMapContext,
                                pContextData );

            }

            //
            // if we couldn't parse it, try to go without the hint:
            //

            if ( scRet != SEC_E_INVALID_TOKEN )
            {
                break;
            }
            DebugLog(( DEB_TRACE_NEG, "Unidentified token, trying without it\n" ));

        case FIRST_CALL_NO_INPUT:

            //
            // First call, but server has provided some hints as to
            // what to do.
            //

            scRet = NegGenerateInitialToken(
                            dwCredHandle,
                            pszTargetName,
                            fContextReq,
                            TargetDataRep,
                            pInput,
                            pdwNewContext,
                            pOutput,
                            pfContextAttr,
                            ptsExpiry,
                            pfMapContext,
                            pContextData);

            DebugLog(( DEB_TRACE_NEG, "NegGenerateInitialToken returned %x\n", scRet ));

            break;

        case LATER_CALL_WITH_INPUT:

            //
            // Subsequent call, with a context working and
            // a blob from the server.  May be fragmented
            //


            if ( NegpIsValidContext( dwCtxtHandle ) )
            {
                //
                // See if we're doing fragment reassembly:
                //

                Context = (PNEG_CONTEXT) dwCtxtHandle ;

                if ( Context->Flags & NEG_CONTEXT_FRAGMENTING )
                {
                    scRet = NegAddFragmentToContext(
                                Context,
                                Buffer );

                    //
                    // More trips needed to construct the fragments.
                    //
                    if (scRet == SEC_I_CONTINUE_NEEDED)
                    {
                        NegpParseBuffers( pOutput, FALSE, &OutBuf, NULL );

                        if ( OutBuf )
                        {
                            OutBuf->cbBuffer = 0 ;
                        }
                        
                        return scRet;  
                    }
                    else if ( scRet != SEC_E_OK )
                    {
                        return scRet ;
                    }

                    //
                    // That was the final blob.  Reset the message
                    // to be the whole thing
                    //

                    LocalBuffer.BufferType = SECBUFFER_TOKEN ;
                    LocalBuffer.cbBuffer = Context->TotalSize ;
                    LocalBuffer.pvBuffer = Context->Message ;

                    //
                    // Reset frag buffer to NULL - this will be
                    // freed when the call completes by the LSA wrappers.
                    // hence the ChangeBuffer call below:
                    //

                    Context->Message = NULL ;

                    

                    scRet = LsapChangeBuffer( Buffer, &LocalBuffer );

                    if ( !NT_SUCCESS( scRet ) )
                    {
                        return scRet ;
                    }

                    //
                    // Fall through to the normal processing
                    //


                }

            }
            else
            {
                return SEC_E_INVALID_HANDLE;
            }

            if (NegpIsValidContext(dwCtxtHandle))
            {

                scRet = NegHandleServerReply(
                                dwCredHandle,
                                (PNEG_CONTEXT) dwCtxtHandle,
                                pszTargetName,
                                fContextReq,
                                TargetDataRep,
                                pInput,
                                pdwNewContext,
                                pOutput,
                                pfContextAttr,
                                ptsExpiry,
                                pfMapContext,
                                pContextData );

            }
            else
            {
                scRet = SEC_E_INVALID_HANDLE ;
            }

            break;

        case LATER_CALL_NO_INPUT:

            //
            // No data from the server,

            if ( NegpIsValidContext( dwCtxtHandle ) )
            {
                //
                // See if we're doing fragment reassembly:
                //

                Context = (PNEG_CONTEXT) dwCtxtHandle ;

                if ( ( Context->Flags & NEG_CONTEXT_FRAGMENTING ) &&
                     ( fContextReq & ISC_REQ_FRAGMENT_TO_FIT ) )
                {
                    //
                    // Pull the next chunk off the stored context:
                    //

                    scRet = NegpParseBuffers( pOutput, FALSE, &Buffer, NULL );

                    if ( ( Buffer != NULL ) &&
                         ( NT_SUCCESS( scRet ) ) )
                    {
                        Buffer->cbBuffer = min( Buffer->cbBuffer,
                                                (Context->TotalSize - Context->CurrentSize) );

                        RtlCopyMemory(
                            Buffer->pvBuffer,
                            Context->Message + Context->CurrentSize,
                            Buffer->cbBuffer );

                        Context->CurrentSize += Buffer->cbBuffer ;

                        if ( Context->CurrentSize == Context->TotalSize )
                        {
                            //
                            // Sent the whole thing
                            //

                            Context->Flags &= (~(NEG_CONTEXT_FRAGMENTING) );
                            Context->TotalSize = 0 ;
                            Context->CurrentSize = 0 ;
                            LsapFreeLsaHeap( Context->Message );
                            Context->Message = NULL ;

                            scRet = Context->LastStatus ;

                            if ( scRet == SEC_E_OK )
                            {
                                *pfMapContext = Context->Mapped;

                                *pContextData = Context->MappedBuffer;

                                *pfContextAttr = Context->Attributes ;

                                RtlZeroMemory(
                                    &Context->MappedBuffer,
                                    sizeof(SecBuffer)
                                    );

                                LsapChangeHandle(   HandleReplace,
                                                    NULL,
                                                    &Context->Handle );

                                Context->Handle.dwLower = 0xFFFFFFFF ;
                            }
                        }
                        else
                        {
                            scRet = SEC_I_CONTINUE_NEEDED ;
                        }
                    }
                    else
                    {
                        DebugLog((DEB_TRACE_NEG, "NegInitLsaModeContext: No buffer found (1)\n" ));
                        scRet = SEC_E_INVALID_TOKEN ;
                    }
                }
                else
                {
                    //
                    // Last round trip for signed blobs:
                    //

                    if ( Context->LastStatus == SEC_E_OK )
                    {
                        *pfMapContext = Context->Mapped;

                        *pContextData = Context->MappedBuffer;

                        *pfContextAttr = Context->Attributes ;

                        RtlZeroMemory(
                            &Context->MappedBuffer,
                            sizeof(SecBuffer)
                            );

                        scRet = NegpParseBuffers( pOutput, FALSE, &Buffer, NULL );

                        if ( Buffer &&
                            NT_SUCCESS( scRet ) )
                        {
                            Buffer->cbBuffer = 0 ;
                        }


                        scRet = SEC_E_OK ;

                        LsapChangeHandle(   HandleReplace,
                                            NULL,
                                            &Context->Handle );

                        Context->Handle.dwLower = 0xFFFFFFFF ;
                    }
                    else
                    {
                        DebugLog(( DEB_TRACE_NEG, "NegInitLsaModeContext:  Signed exchange not ok\n" ));
                        scRet = SEC_E_INVALID_TOKEN ;
                    }
                }
            }
            else
            {
                scRet = SEC_E_INVALID_TOKEN ;
            }
            break;

        default:
            DsysAssert( FALSE );
            scRet = SEC_E_INTERNAL_ERROR ;
    }

    return scRet ;
}


SECURITY_STATUS SEC_ENTRY
NegMoveContextToUser(
    LSA_SEC_HANDLE       dwCtxtHandle,
    PSecBuffer  pContextBuffer
    )
{
    return( SEC_E_UNSUPPORTED_FUNCTION );
}

//+---------------------------------------------------------------------------
//
//  Function:   NegDeleteLsaModeContext
//
//  Synopsis:   Deletes the LSA portion of the context
//
//  Arguments:  [dwCtxtHandle] --
//
//  History:    9-24-96   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
SECURITY_STATUS
SEC_ENTRY
NegDeleteLsaModeContext( LSA_SEC_HANDLE dwCtxtHandle)
{
    SECURITY_STATUS scRet = SEC_E_INVALID_HANDLE;
    PNEG_CONTEXT    Context;
    PSession        pSession = GetCurrentSession();

    Context = (PNEG_CONTEXT) dwCtxtHandle ;

    __try
    {
        if (NegpIsValidContext( Context ))
        {
            //
            // If the session is being run down, don't call WLsaDeleteContext,
            // it will complicate things (that entry may already have been
            // deleted.
            //

            if ( pSession->fSession & SESFLAG_CLEANUP )
            {
                Context->Handle.dwLower = 0 ;
                Context->Handle.dwUpper = 0 ;
            }

            NegpDeleteContext( Context );
            scRet = SEC_E_OK ;
        }
    }
    __except( EXCEPTION_EXECUTE_HANDLER ) {}

    return( scRet );
}

SECURITY_STATUS SEC_ENTRY
NegApplyControlToken( LSA_SEC_HANDLE dwCtxtHandle,
                      PSecBufferDesc  pInput)
{
    return(SEC_E_UNSUPPORTED_FUNCTION);
}


VOID
SEC_ENTRY
NegLogoffNotify(
    PLUID  pLogonId
    )
{
    NegpDerefLogonSessionById( pLogonId );
}

#define TOKEN_MATCHES(_buf_,_oid_,_oidlen_) \
    (((_buf_)->cbBuffer >= (_oidlen_)) && \
      RtlEqualMemory( \
        (_buf_)->pvBuffer, \
        (_oid_), \
        (_oidlen_) \
        ))


//+-------------------------------------------------------------------------
//
//  Function:
//
//  Synopsis:
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------



/*
 * Copyright 1993 by OpenVision Technologies, Inc.
 *
 * Permission to use, copy, modify, distribute, and sell this software
 * and its documentation for any purpose is hereby granted without fee,
 * provided that the above copyright notice appears in all copies and
 * that both that copyright notice and this permission notice appear in
 * supporting documentation, and that the name of OpenVision not be used
 * in advertising or publicity pertaining to distribution of the software
 * without specific, written prior permission. OpenVision makes no
 * representations about the suitability of this software for any
 * purpose.  It is provided "as is" without express or implied warranty.
 *
 * OPENVISION DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE,
 * INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO
 * EVENT SHALL OPENVISION BE LIABLE FOR ANY SPECIAL, INDIRECT OR
 * CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF
 * USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
 * OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
 * PERFORMANCE OF THIS SOFTWARE.
 */

NTSTATUS
NegpGetTokenOid(
     IN PUCHAR Buf,
     OUT ULONG BufSize,
     OUT ObjectID * ObjectId
     )
{
    UCHAR sf;
    ULONG TokenSize;
    ULONG OidLength;

    //
    // Check for the encoding indicator
    //

    if (BufSize < 2)
    {
        return SEC_E_INVALID_TOKEN;
    }

    if ( (*Buf == 0x60) ||
         (*Buf == 0xa0) )
    {
        Buf++;
    }
    else
    {
        return SEC_E_INVALID_TOKEN;
    }

    sf = *(Buf)++;

    (BufSize)--;

    if (sf & 0x80)
    {
        if ((sf &= 0x7f) > ((BufSize)-1))
        {
            return(SEC_E_INVALID_TOKEN);
        }
        if (sf > sizeof(ULONG))
        {
            return (SEC_E_INVALID_TOKEN);
        }
        TokenSize = 0;
        for (; sf; sf--)
        {
            TokenSize = (TokenSize<<8) + (*(Buf)++);
            (BufSize)--;
        }
   } else {
      TokenSize = sf;
   }

   if ((--BufSize == 0) || *Buf != 0x06)
   {
       return(SEC_E_INVALID_TOKEN);
   }
   if (--BufSize == 0)
   {
       return(SEC_E_INVALID_TOKEN);
   }
   OidLength = *(Buf+1) + 2; // two extra for OID tag & length field

   //
   // Now buf should point to the encoded oid
   //

   *ObjectId = NegpDecodeObjectId(Buf,OidLength);
   if (ObjectId == NULL)
   {
       return(SEC_E_INVALID_TOKEN);
   }

   return(STATUS_SUCCESS);
}

//+-------------------------------------------------------------------------
//
//  Function:   NegpDetermineTokenPackage
//
//  Synopsis:   Determines the package that generated an initial
//              context token
//
//  Effects:
//
//  Arguments:  CredHandle - handle to the server's credentials
//              InitialToken -Initial context token from client
//              Package - NULL if spnego, otherwise the package
//                      that generated the token.
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------

NTSTATUS
NegpDetermineTokenPackage(
    IN ULONG_PTR CredHandle,
    IN PSecBuffer InitialToken,
    OUT PULONG PackageIndex
    )
{
    NTSTATUS Status = STATUS_SUCCESS;
    ULONG Index;
    PNEG_CREDS Credentials = (PNEG_CREDS) CredHandle;
    ObjectID DecodedOid = NULL;
    int Length ;
    PUCHAR Buffer ;
    LONG Header ;
    LONG Size ;
    ULONG_PTR Package ;

    *PackageIndex = (ULONG) -1;



    //
    // Get the OID from the token, if possible
    //

    Status = NegpGetTokenOid(
                (PUCHAR) InitialToken->pvBuffer,
                InitialToken->cbBuffer,
                &DecodedOid
                );

    if (NT_SUCCESS(Status))
    {
        Status = SEC_E_INVALID_TOKEN;

        //
        // First check for spnego
        //

        if (NegpCompareOid(
                DecodedOid,
                NegSpnegoMechOid
                ) == 0)
        {
            Status = STATUS_SUCCESS;
        }
        else
        {
            //
            // Try the oid for each mech in the credential
            //

            NegReadLockCreds(Credentials);

            Package = NegpFindPackageForOid( Credentials, DecodedOid );

            if ( Package != NEG_INVALID_PACKAGE )
            {
                *PackageIndex = (ULONG) Package ;
                Status = STATUS_SUCCESS ;
            }
            else
            {
                Status = SEC_E_SECPKG_NOT_FOUND ;
            }

            NegUnlockCreds(Credentials);
        }
        NegpFreeObjectId(DecodedOid);
    }
    else
    {
        if (TOKEN_MATCHES(InitialToken,NTLMSSP_SIGNATURE,sizeof(NTLMSSP_SIGNATURE)))
        {
            //
            // Find the NTLM package in the list of packages
            //

            NegReadLockCreds(Credentials);
            for (Index = 0; Index < Credentials->Count ; Index++ )
            {
                if (Credentials->Creds[Index].Package->LsaPackage->dwRPCID == NTLMSP_RPCID)
                {
                    *PackageIndex = Index;
                    Status = STATUS_SUCCESS;
                    break;
                }
            }

            //
            // If we didn't find ntlm, return invalid token.
            //

            NegUnlockCreds(Credentials);

            if ( NT_SUCCESS( Status ) )
            {
                return Status;
            }
        }

        Size = InitialToken->cbBuffer ;
        Buffer = (PUCHAR) InitialToken->pvBuffer ;
        Buffer ++ ;

        Length = Neg_der_read_length(
                    &Buffer,
                    &Size,
                    &Header );

        if ( Length > 0 )
        {
            //
            // Could be kerb, could be snego.  Poke a little to find out
            //

            if ( (*Buffer & 0xC0) == 0x40 )
            {
                NegReadLockCreds(Credentials);
                for (Index = 0; Index < Credentials->Count ; Index++ )
                {
                    if (Credentials->Creds[Index].Package->LsaPackage->dwRPCID == RPC_C_AUTHN_GSS_KERBEROS)
                    {
                        *PackageIndex = Index;
                        Status = STATUS_SUCCESS;
                        break;
                    }
                }

                //
                // If we didn't find kerberos, return invalid token.
                //

                NegUnlockCreds(Credentials);

            }

        }

    }

    return(Status);

}





SECURITY_STATUS
NegGetExpectedBufferLength(
    IN PSecBuffer Buffer,
    IN OUT PLONG ExpectedBuffer
    )
{
    
    SECURITY_STATUS Status;
    LONG ExpectedSize = 0;

    PUCHAR Message ;
    LONG MessageSize ; 
    LONG HeaderSize ;

    *ExpectedBuffer = 0;

    if ( Buffer->cbBuffer > MAXLONG )
    {
        DsysAssert(FALSE);
        return SEC_E_INVALID_TOKEN ;
    }

    if ( Buffer->cbBuffer <= 1 )
    {                     
        DsysAssert(FALSE);
        return SEC_E_INVALID_TOKEN ;
    }

    Message = (PUCHAR) Buffer->pvBuffer ;

    if ( (*Message != 0xa0 ) &&
         (*Message != 0x60 ) &&
         (*Message != 0xa1 ) )
    {
        DebugLog((DEB_ERROR, "Missing ASN encoding in NegGetExpectedBufferLength\n"));
        return SEC_E_INVALID_TOKEN ;
    }  


    MessageSize = Buffer->cbBuffer ;

    Message++ ;
    MessageSize -- ;
      
    ExpectedSize = Neg_der_read_length(
                        &Message,
                        &MessageSize,
                        &HeaderSize );

    if ( ExpectedSize > 0 )
    {
        //
        // Header size + 1 since we already incremented above
        //
        ExpectedSize += HeaderSize + 1;
    }
    
    if ( ExpectedSize < 0 )
    {   
        return SEC_E_INVALID_TOKEN ;
    }
    
    DebugLog((DEB_TRACE_FRAG, "Expected Size %i :: Buffer %i\n\n", ExpectedSize, MessageSize ));   
    
    if ( (ULONG) ExpectedSize < Buffer->cbBuffer )
    {
        DsysAssert(FALSE);
        return SEC_E_INVALID_TOKEN ;
    }

    if ( (ULONG) ExpectedSize == Buffer->cbBuffer )
    {
        DebugLog((DEB_TRACE_FRAG, "We have the complete buffer\n"));
        return S_OK;
    }

    *ExpectedBuffer = ExpectedSize;  

    return SEC_I_CONTINUE_NEEDED;
}
     


SECURITY_STATUS
SEC_ENTRY
NegAcceptLsaModeContext(
   LSA_SEC_HANDLE  dwCredHandle,
   LSA_SEC_HANDLE  dwCtxtHandle,
   PSecBufferDesc  pInput,
   ULONG           fContextReq,
   ULONG           TargetDataRep,
   PLSA_SEC_HANDLE pdwNewContext,
   PSecBufferDesc  pOutput,
   PULONG          pfContextAttr,
   PTimeStamp      ptsExpiry,
   PBYTE           pfMapContext,
   PSecBuffer      pContextData)
{
    SECURITY_STATUS scRet = STATUS_SUCCESS;
    ULONG PackageIndex = 0;
    PSecBuffer  Buffer;
    SecBufferDesc LocalDesc ;
    SecBuffer LocalBuffer ;
    PSecBuffer OutBuf = NULL;
    PNEG_CONTEXT Context = NULL ;
    PNEG_CREDS Cred ;
    PNEG_CREDS AltCreds ;
    PLIST_ENTRY Scan ;
    BOOL LocalUseSpnego ;
    ULONG CallState ;
    LONG ExpectedSize ;


    CallState = 0 ;

    if ( dwCtxtHandle )
    {
        CallState |= LATER_CALL_BIT ;
    }

    scRet = NegpParseBuffers( pInput, FALSE, &Buffer, NULL );

    if ( !NT_SUCCESS( scRet ) )
    {
        DebugLog(( DEB_ERROR, "NegAcceptLsaModeContext failed to map input buffers, %x\n", scRet ));
        return scRet ;
    }

    if ( ( Buffer != NULL ) &&
         ( Buffer->cbBuffer != 0 ) )
    {
        CallState |= BUFFER_PRESENT_BIT ;
    }

    ULONG_PTR PackageId = GetCurrentPackageId();

    DebugLog(( DEB_TRACE_NEG, "AcceptLsaModeContext( %x, %x )\n",
                dwCredHandle, dwCtxtHandle ));

    ptsExpiry->QuadPart = (LONGLONG) MAXLONGLONG;

    switch ( CallState )
    {
        case FIRST_CALL_NO_INPUT:

            scRet = NegGenerateServerRequest(
                                                dwCredHandle,
                                                fContextReq,
                                                TargetDataRep,
                                                pInput,
                                                pdwNewContext,
                                                pOutput,
                                                pfContextAttr,
                                                ptsExpiry,
                                                pfMapContext,
                                                pContextData );
            break;

        case FIRST_CALL_WITH_INPUT:

            //
            // Determine if this is a fragment, and if so, is it the
            // last fragment:
            //

            scRet = NegCreateContextFromFragment(
                        dwCredHandle,
                        dwCtxtHandle,
                        Buffer,
                        fContextReq,
                        TargetDataRep,
                        pdwNewContext,
                        pOutput,
                        pfContextAttr );

            *pfMapContext = FALSE ;


            if ( scRet == SEC_E_OK )
            {
                Context = (PNEG_CONTEXT) *pdwNewContext ;

                if ( Context )
                {
                    //
                    // final
                    //
                    *pdwNewContext = 0 ;

                    LocalBuffer.BufferType = SECBUFFER_TOKEN ;
                    LocalBuffer.cbBuffer = Context->TotalSize ;
                    LocalBuffer.pvBuffer = Context->Message ;

                    //
                    // Reset frag buffer to NULL - this will be
                    // freed when the call completes by the LSA wrappers.
                    // hence the ChangeBuffer call below:
                    //

                    Context->Message = NULL ;

                    LsapChangeBuffer( Buffer, &LocalBuffer );

                    //
                    // Get rid of the context - we have the whole
                    // message
                    //

                    NegpDeleteContext( Context );
                }
            }
            else if ( NT_SUCCESS( scRet ) )
            {
                //
                // building a context, so return now
                //

                return scRet ;
            }


            if ( !NT_SUCCESS( scRet ) )
            {
                //
                // Check the package in use. It is possible that we are being
                // sent the context token from a totally separate package and
                // are being asked to dispatch to the appropriate package.
                //

                scRet = NegpDetermineTokenPackage(
                            dwCredHandle,
                            Buffer,
                            &PackageIndex
                            );

            }
            else
            {
                PackageIndex = (ULONG) -1 ;
            }

            //
            // Older clients will send data that returns an error
            //

            if (!NT_SUCCESS(scRet) || (PackageIndex == (ULONG) -1))
            {

                scRet = NegHandleClientRequest(
                                            dwCredHandle,
                                            NULL,
                                            fContextReq,
                                            TargetDataRep,
                                            pInput,
                                            pdwNewContext,
                                            pOutput,
                                            pfContextAttr,
                                            ptsExpiry,
                                            pfMapContext,
                                            pContextData );

            }
            else
            {
                CtxtHandle TempCtxtHandle = {0};
                CtxtHandle TempInputCtxtHandle = {0};
                CredHandle TempCredHandle;
                PNEG_CREDS Creds = (PNEG_CREDS) dwCredHandle;

                NegpReportEvent(
                    EVENTLOG_INFORMATION_TYPE,
                    NEGOTIATE_RAW_PACKET,
                    CATEGORY_NEGOTIATE,
                    0,
                    1,
                    &Creds->Creds[PackageIndex].Package->LsaPackage->Name
                    );

                //
                // Call into another package to do the accept
                //

                NegReadLockCreds(Creds);
                TempCredHandle = Creds->Creds[PackageIndex].Handle;
                NegUnlockCreds(Creds);

                DebugLog(( DEB_TRACE_NEG, "Got a blob directly for package %x\n",
                            TempCredHandle.dwLower ));


                PackageId = GetCurrentPackageId();

                scRet = WLsaAcceptContext(
                            &TempCredHandle,
                            &TempInputCtxtHandle,
                            pInput,
                            fContextReq,
                            TargetDataRep,
                            &TempCtxtHandle,
                            pOutput,
                            pfContextAttr,
                            ptsExpiry,
                            pfMapContext,
                            pContextData
                            );

                SetCurrentPackageId(PackageId);

                if (Context)
                {
                    Context->CallCount++ ;
                }

                if (NT_SUCCESS(scRet))
                {
                    LsapChangeHandle(
                        HandleReplace,
                        NULL,
                        &TempCtxtHandle
                        );
                }
            }

            break;

        case LATER_CALL_NO_INPUT:

            DebugLog(( DEB_TRACE_NEG, "Missing Input Buffer?\n"));

            scRet = SEC_E_INVALID_HANDLE ;

            break;

        case LATER_CALL_WITH_INPUT:

            Context = (PNEG_CONTEXT) dwCtxtHandle ;

            if ( !NegpIsValidContext( dwCtxtHandle ) )
            {
                return SEC_E_INVALID_HANDLE ;
            }

            if ( Context->Flags & NEG_CONTEXT_FRAGMENTING )
            {
                scRet = NegAddFragmentToContext(
                            Context,
                            Buffer );

                //
                // More trips needed to reconstruct the fragment.
                //
                if (scRet == SEC_I_CONTINUE_NEEDED)
                {
                    NegpParseBuffers( pOutput, FALSE, &OutBuf, NULL );

                    if ( OutBuf )
                    {
                        OutBuf->cbBuffer = 0 ;
                    }
                    return scRet;
                }
                else if ( scRet != SEC_E_OK )
                {
                    return scRet ;
                }

                //
                // That was the final blob.  Reset the message
                // to be the whole thing
                //

                LocalBuffer.BufferType = SECBUFFER_TOKEN ;
                LocalBuffer.cbBuffer = Context->TotalSize ;
                LocalBuffer.pvBuffer = Context->Message ;

                //
                // Reset frag buffer to NULL - this will be
                // freed when the call completes by the LSA wrappers.
                // hence the ChangeBuffer call below:
                //

                Context->Message = NULL ;
                Context->Flags &= ~NEG_CONTEXT_FRAGMENTING;
                Context->TotalSize = 0;
                Context->CurrentSize = 0;
                
                scRet = LsapChangeBuffer( Buffer, &LocalBuffer );

                if ( !NT_SUCCESS( scRet ) )
                {
                    return scRet ;
                }

                //
                // Fall through to the normal processing
                //

            }
            else
            {
                //
                // There's a chance that we're restarting the authentication.
                // Check on the size of the input buffer compared to the der
                // header
                // 
                scRet = NegGetExpectedBufferLength( Buffer, &ExpectedSize );

                if ( scRet == SEC_I_CONTINUE_NEEDED )
                {
                    *pfMapContext = FALSE ;

                    DebugLog((DEB_TRACE_FRAG, "%p needs to re-gather fragments\n", Context));
                    Context->TotalSize = ExpectedSize;
                    Context->Flags |= NEG_CONTEXT_FRAGMENTING;
                    Context->Message = (PUCHAR) LsapAllocateLsaHeap( ExpectedSize ) ;

                    if ( !Context->Message )
                    {
                        NegpDeleteContext( Context ); 
                        return SEC_E_INSUFFICIENT_MEMORY ;
                    }
                                                      
                    scRet = NegAddFragmentToContext(
                                   Context,
                                   Buffer
                                   );


                    DsysAssert(scRet == SEC_I_CONTINUE_NEEDED);

                    NegpParseBuffers( pOutput, FALSE, &OutBuf, NULL );

                    if ( OutBuf )
                    {
                        OutBuf->cbBuffer = 0 ;
                    }    

                    return scRet;

                }
                else if (!NT_SUCCESS( scRet ))
                {
                    DebugLog((DEB_ERROR, "NegGetExpectedBufferLength failed %x\n", scRet));
                    return scRet;
                }
                
                //
                // Fall through to normal processing.
                //
            }     

            scRet = NegHandleClientRequest(
                            dwCredHandle,
                            (PNEG_CONTEXT) dwCtxtHandle,
                            fContextReq,
                            TargetDataRep,
                            pInput,
                            pdwNewContext,
                            pOutput,
                            pfContextAttr,
                            ptsExpiry,
                            pfMapContext,
                            pContextData );

            break;

        default:

            DsysAssert(FALSE);
            scRet = SEC_E_INTERNAL_ERROR ;
            break;
    }

    return scRet ;

}


NTSTATUS
NegCallPackage(
    IN PLSA_CLIENT_REQUEST ClientRequest,
    IN PVOID ProtocolSubmitBuffer,
    IN PVOID ClientBufferBase,
    IN ULONG SubmitBufferLength,
    OUT PVOID *ProtocolReturnBuffer,
    OUT PULONG ReturnBufferLength,
    OUT PNTSTATUS ProtocolStatus
    )
{
    PULONG_PTR MessageTypePtr ;
    NEGOTIATE_MESSAGES Messages ;

    if ( SubmitBufferLength < sizeof( ULONG_PTR ) )
    {
        return STATUS_INVALID_PARAMETER ;
    }

    MessageTypePtr = (PULONG_PTR) ProtocolSubmitBuffer ;

    if ( *MessageTypePtr >= NegCallPackageMax )
    {
        return STATUS_INVALID_PARAMETER ;
    }

    switch ( *MessageTypePtr )
    {
        case NegEnumPackagePrefixes:
            return NegEnumPackagePrefixesCall(
                        ClientRequest,
                        ProtocolSubmitBuffer,
                        ClientBufferBase,
                        SubmitBufferLength,
                        ProtocolReturnBuffer,
                        ReturnBufferLength,
                        ProtocolStatus );
            break;
        case NegGetCallerName:
            return NegGetCallerNameCall(
                        ClientRequest,
                        ProtocolSubmitBuffer,
                        ClientBufferBase,
                        SubmitBufferLength,
                        ProtocolReturnBuffer,
                        ReturnBufferLength,
                        ProtocolStatus );
            break;
        default:
            DsysAssert( FALSE );
            return STATUS_NOT_IMPLEMENTED ;

    }
}

NTSTATUS
NegCallPackageUntrusted(
    IN PLSA_CLIENT_REQUEST ClientRequest,
    IN PVOID ProtocolSubmitBuffer,
    IN PVOID ClientBufferBase,
    IN ULONG SubmitBufferLength,
    OUT PVOID *ProtocolReturnBuffer,
    OUT PULONG ReturnBufferLength,
    OUT PNTSTATUS ProtocolStatus
    )
{
    return( SEC_E_UNSUPPORTED_FUNCTION );
}

NTSTATUS
NegCallPackagePassthrough(
    IN PLSA_CLIENT_REQUEST ClientRequest,
    IN PVOID ProtocolSubmitBuffer,
    IN PVOID ClientBufferBase,
    IN ULONG SubmitBufferLength,
    OUT PVOID *ProtocolReturnBuffer,
    OUT PULONG ReturnBufferLength,
    OUT PNTSTATUS ProtocolStatus
    )
{
    return( SEC_E_UNSUPPORTED_FUNCTION );
}



SECURITY_STATUS SEC_ENTRY
NegShutdown(void)
{
    return(SEC_E_UNSUPPORTED_FUNCTION);
}

SECURITY_STATUS SEC_ENTRY
NegSystemLogon( PSECURITY_STRING    pName,
               DWORD               cbKey,
               PBYTE               pbKey,
               DWORD *             pdwHandle,
               PTimeStamp          ptsExpiry)
{
    return(SEC_E_UNSUPPORTED_FUNCTION);
}

SECURITY_STATUS SEC_ENTRY
NegGetUserInfo(  PLUID                   pLogonId,
                ULONG                   fFlags,
                PSecurityUserData *     ppUserInfo)
{
    return(SEC_E_UNSUPPORTED_FUNCTION);
}





//+---------------------------------------------------------------------------
//
//  Function:   NegSaveCredentials
//
//  Synopsis:   Store credentials (not supported)
//
//  Arguments:  [dwCredHandle] --
//              [CredType]     --
//              [pCredentials] --
//
//
//  History:    7-26-96   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
SECURITY_STATUS SEC_ENTRY
NegSaveCredentials( LSA_SEC_HANDLE    dwCredHandle,
                    PSecBuffer        pCredentials)
{
    return(SEC_E_UNSUPPORTED_FUNCTION);
}


//+---------------------------------------------------------------------------
//
//  Function:   NegGetCredentials
//
//  Synopsis:   Get Credentials (not supported)
//
//  Arguments:  [dwCredHandle] --
//              [CredType]     --
//              [pCredentials] --
//
//  History:    7-26-96   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
SECURITY_STATUS SEC_ENTRY
NegGetCredentials(  LSA_SEC_HANDLE    dwCredHandle,
                    PSecBuffer        pCredentials)
{
    return(SEC_E_UNSUPPORTED_FUNCTION);
}

//+---------------------------------------------------------------------------
//
//  Function:   NegDeleteCredentials
//
//  Synopsis:   Delete stored creds (not supported)
//
//  Arguments:  [dwCredHandle] --
//              [CredType]     --
//              [pKey]         --
//
//  History:    7-26-96   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
SECURITY_STATUS SEC_ENTRY
NegDeleteCredentials( LSA_SEC_HANDLE    dwCredHandle,
                      PSecBuffer        pKey)
{
    return(SEC_E_UNSUPPORTED_FUNCTION);
}




NTSTATUS
NegGetExtendedInformation(
    IN  SECPKG_EXTENDED_INFORMATION_CLASS Class,
    OUT PSECPKG_EXTENDED_INFORMATION * ppInformation
    )
{
    PSECPKG_EXTENDED_INFORMATION Thunks ;
    NTSTATUS Status ;

    switch ( Class )
    {
        case SecpkgContextThunks:
            Thunks = (PSECPKG_EXTENDED_INFORMATION) LsapAllocateLsaHeap( sizeof( SECPKG_EXTENDED_INFORMATION ) + sizeof( DWORD ));
            if ( Thunks )
            {
                Thunks->Class = SecpkgContextThunks;
                Thunks->Info.ContextThunks.InfoLevelCount = 2 ;
                Thunks->Info.ContextThunks.Levels[0] = SECPKG_ATTR_PACKAGE_INFO;
                Thunks->Info.ContextThunks.Levels[1] = SECPKG_ATTR_SIZES ;
                Status = STATUS_SUCCESS ;
            }
            else
            {
                Status = STATUS_NO_MEMORY ;
            }
            *ppInformation = Thunks ;


            break;

        default:
            *ppInformation = NULL ;
            Status = STATUS_INVALID_INFO_CLASS ;
            break;
    }

    return Status ;
}

//+---------------------------------------------------------------------------
//
//  Function:   NegQueryContextAttributes
//
//  Synopsis:   
//
//  Arguments:  [ContextHandle]    -- 
//              [ContextAttribute] -- 
//              [Buffer]           -- 
//
//  Returns:    
//
//  Notes:      
//
//----------------------------------------------------------------------------

NTSTATUS
NegQueryContextAttributes(
    IN LSA_SEC_HANDLE ContextHandle,
    IN ULONG ContextAttribute,
    IN OUT PVOID Buffer)
{
    SecPkgContext_NegotiationInfoW NegInfo = {0};
    SecPkgContext_Sizes Sizes ;
    NTSTATUS Status = STATUS_SUCCESS;
    PNEG_CONTEXT Context = (PNEG_CONTEXT) ContextHandle ;
    SECPKG_CALL_INFO CallInfo ;
    SecPkgInfoW PackageInfo ;

    LsapGetCallInfo( &CallInfo );

    switch ( ContextAttribute )
    {
        case SECPKG_ATTR_NEGOTIATION_INFO :

            if ( CallInfo.Attributes & SECPKG_CALL_KERNEL_MODE )
            {
                Status = LsapCopyFromClient(
                            Buffer,
                            &NegInfo,
                            sizeof( NegInfo ) );
            }

            if ( (Context->Flags & NEG_CONTEXT_NEGOTIATING) != 0 )
            {
                NegInfo.NegotiationState = SECPKG_NEGOTIATION_IN_PROGRESS ;
            }
            else
            {
                NegInfo.NegotiationState = SECPKG_NEGOTIATION_OPTIMISTIC ;
            }

            if ( NegInfo.NegotiationState == SECPKG_NEGOTIATION_OPTIMISTIC )
            {
                if ( ( CallInfo.Attributes & SECPKG_CALL_KERNEL_MODE ) == 0 )
                {
                    Status = WLsaQueryPackageInfo(
                                &Context->Creds->Creds[ Context->CredIndex ].Package->LsaPackage->Name,
                                &NegInfo.PackageInfo
                                );
                }
                else
                {

                    //
                    // For kernel mode callers, we can't return the package info
                    // this way due to VM risks.  So, we just put the package ID 
                    // into the pointer, and ksec looks it up in kernel space.
                    //

                    PackageInfo.wRPCID = (WORD) Context->Creds->Creds[ Context->CredIndex ].Package->LsaPackage->dwRPCID;
                    PackageInfo.fCapabilities = Context->Creds->Creds[ Context->CredIndex ].Package->LsaPackage->fCapabilities ;
                    PackageInfo.cbMaxToken = Context->Creds->Creds[ Context->CredIndex ].Package->LsaPackage->TokenSize ;

                    Status = LsapCopyToClient(
                                &PackageInfo,
                                NegInfo.PackageInfo,
                                sizeof( PackageInfo ) );
                }
            }

            if (NT_SUCCESS(Status))
            {
                Status = LsapCopyToClient( &NegInfo, Buffer, sizeof( NegInfo ) );
                if (!NT_SUCCESS(Status))
                {
                    if (( NegInfo.PackageInfo != NULL ) &&
                        ( ( CallInfo.Attributes & SECPKG_CALL_KERNEL_MODE ) == 0 ) )
                    {
                        LsapClientFree(NegInfo.PackageInfo);
                    }
                }
            }

            return Status ;

        case SECPKG_ATTR_SIZES:
            Sizes.cbMaxToken = NegLsaPackage->TokenSize ;
            Sizes.cbMaxSignature = 64 ;
            Sizes.cbBlockSize = 8 ;
            Sizes.cbSecurityTrailer =  64 ;

            Status = LsapCopyToClient( &Sizes, Buffer, sizeof( Sizes ) );

            return Status ;

        default:
            return SEC_E_UNSUPPORTED_FUNCTION ;

    }

    return SEC_E_UNSUPPORTED_FUNCTION ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\base\lsa\server\protos.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1993.
//
//  File:       protos.h
//
//  Contents:
//
//  Classes:
//
//  Functions:
//
//  History:    9-21-94   RichardW   Created
//
//----------------------------------------------------------------------------

#ifndef __PROTOS_H__
#define __PROTOS_H__

//
// General arrary count.
//

#ifndef COUNTOF
    #define COUNTOF(s) ( sizeof( (s) ) / sizeof( *(s) ) )
#endif // COUNTOF

BOOL
AddPackageToRegistry(
    PSECURITY_STRING    Package
    );

NTSTATUS
LoadParameters(
    BOOLEAN DynamicOnly
    );

VOID
LsapShutdownInprocDll(
    VOID
    );

BOOL
SpConsoleHandler(
    ULONG dwCtrlType
    );

NTSTATUS
ServerStop(
    void
    );

NTSTATUS
StopRPC(
    void
    );

//
// Control constants for LsapBuildSD
//
#define BUILD_KSEC_SD    0
#define BUILD_LPC_SD     1

NTSTATUS
LsapBuildSD(
    IN ULONG dwType,
    OUT PSECURITY_DESCRIPTOR *ppSD  OPTIONAL
    );

NTSTATUS
StartLpcThread(
    void
    );

NTSTATUS
StopLpcThread(
    void
    );

HANDLE
SpmCreateEvent(
    LPSECURITY_ATTRIBUTES lpsa,
    BOOL fManualReset,
    BOOL fInitialState,
    LPWSTR pszEventName
    );

HANDLE
SpmOpenEvent(
    ACCESS_MASK DesiredAccess,
    BOOL fInherit,
    LPWSTR pszEventName
    );

BOOLEAN
SpmpIsSetupPass( VOID );

BOOLEAN
SpmpIsMiniSetupPass( VOID );


NTSTATUS
SPException(
    NTSTATUS Status,
    ULONG_PTR PackageId
    );

BOOL
LsapInitializeScavenger(
    VOID
    );


BOOLEAN
NTAPI
LsapEventNotify(
    ULONG       Class,
    ULONG       Flags,
    ULONG       EventSize,
    PVOID       Event);


BOOL
SpmpInitializePackageControl(
    VOID
    );

BOOL
SpmpLoadDll(
    PWSTR               pszDll,
    PSECPKG_PARAMETERS  pParameters);

BOOL
SpmpLoadAuthPkgDll(
    PWSTR   pszDll);

#if DBG
BOOL
SpmpLoadBuiltinAuthPkg(
    PSECPKG_FUNCTION_TABLE  pTable);
#endif

PLSAP_SECURITY_PACKAGE
SpmpValidRequest(
    ULONG_PTR PackageHandle,
    ULONG   ApiCode);

PLSAP_SECURITY_PACKAGE
SpmpValidateHandle(
    ULONG_PTR PackageHandle);

PLSAP_SECURITY_PACKAGE
SpmpLocatePackage(
    ULONG_PTR   PackageId);

PLSAP_SECURITY_PACKAGE
SpmpLookupPackage(
    PUNICODE_STRING    pszPackageName);

PLSAP_SECURITY_PACKAGE
SpmpLookupPackageByRpcId(
    ULONG RpcId);

#ifdef __cplusplus
extern "C"
#endif
DWORD
SpmpGetRpcPackageId(
    ULONG_PTR   PackageId
    );

PLSAP_SECURITY_PACKAGE
SpmpLookupPackageAndRequest(
    PUNICODE_STRING    pszPackageName,
    ULONG               ApiCode);

PLSAP_SECURITY_PACKAGE
SpmpIteratePackagesByRequest(
    PLSAP_SECURITY_PACKAGE pInitialPackage,
    ULONG       ApiCode);

ULONG
SpmpCurrentPackageCount(
    VOID);

NTSTATUS
SpmpBootAuthPackage(
    PLSAP_SECURITY_PACKAGE     pPackage);

BOOL
SpmpLoadBuiltin(
    ULONG   Flags,
    PSECPKG_FUNCTION_TABLE  pTable,
    PSECPKG_PARAMETERS  pParameters);

VOID
LsapAddPackageHandle(
    ULONG_PTR PackageId,
    BOOL IsContext
    );

VOID
LsapDelPackageHandle(
    PLSAP_SECURITY_PACKAGE Package,
    BOOL IsContext
    );

//
// NOTE:  NOT FOR EXPORT TO SECURITY PACKAGES!
//

PVOID
LsapAssignThread(LPTHREAD_START_ROUTINE pFunction,
                PVOID                   pvParameter,
                PSession                pSession,
                BOOLEAN                 fUrgent);

BOOL
CreateSubordinateQueue(
    PSession    pSession,
    PLSAP_TASK_QUEUE  pOriginalQueue);

BOOL
DeleteSubordinateQueue(
    PLSAP_TASK_QUEUE  pQueue,
    ULONG       Flags
    );

#define DELETEQ_SYNC_DRAIN  0x00000001


PKSEC_LSA_MEMORY_HEADER
LsapCreateKsecBuffer(
    SIZE_T InitialSize
    );

PVOID
LsapAllocateFromKsecBuffer(
    PKSEC_LSA_MEMORY_HEADER Header,
    ULONG Size
    );

VOID
LsapLpcContextCleanup(
    PSPM_LPC_MESSAGE pMessage
    );

BOOL
LsapChangeHandle(
    SECHANDLE_OPS   HandleOp,
    PSecHandle  OldHandle,
    PSecHandle  NewHandle
    );

NTSTATUS
LsapChangeBuffer(
    PSecBuffer Old,
    PSecBuffer New
    );

// Worker functions:
NTSTATUS
WLsaEstablishCreds(PUNICODE_STRING, PUNICODE_STRING, ULONG, PBYTE, PCredHandle, PTimeStamp);
NTSTATUS
WLsaLogonUser(PUNICODE_STRING, ULONG, PBYTE, ULONG, ULONG *, PBYTE, NTSTATUS *);
NTSTATUS
WLsaAcquireCredHandle(PUNICODE_STRING, PUNICODE_STRING, ULONG, PLUID, PVOID, PVOID, PVOID, PCredHandle, PTimeStamp);
NTSTATUS
WLsaInitContext(PCredHandle, PCtxtHandle, PUNICODE_STRING, ULONG, ULONG, ULONG, PSecBufferDesc, ULONG, PCtxtHandle, PSecBufferDesc, ULONG *, PTimeStamp, PBOOLEAN, PSecBuffer);
NTSTATUS
WLsaAcceptContext(PCredHandle, PCtxtHandle, PSecBufferDesc, ULONG, ULONG, PCtxtHandle, PSecBufferDesc, ULONG *, PTimeStamp, PBOOLEAN, PSecBuffer);
NTSTATUS
WLsaFreeCredHandle(PCredHandle phCred);
NTSTATUS
WLsaDeleteContext(PCtxtHandle phContext );

NTSTATUS
WLsaGetSecurityUserInfo(PLUID pLogonId, ULONG fFlags, PSecurityUserData * pUserInfo);

NTSTATUS
WLsaGetBinding( ULONG_PTR            dwPackageID,
                PSEC_PACKAGE_BINDING_INFO   BindingInfo,
                PULONG              TotalSize,
                PWSTR *             Base);

NTSTATUS
WLsaFindPackage(PUNICODE_STRING pssName, PULONG_PTR pulPackageId);
NTSTATUS
WLsaEnumeratePackages(PULONG pcPackages, PSecPkgInfo * ppPackageInfo);
NTSTATUS
WLsaApplyControlToken(PCtxtHandle phContext, PSecBufferDesc pInput);
NTSTATUS
WLsaQueryPackageInfo(PUNICODE_STRING pssPackageName, PSecPkgInfo  * ppPackageInfo);
NTSTATUS
WLsaDeletePackage(
    PSECURITY_STRING PackageName);

NTSTATUS
WLsaAddPackage(
    PSECURITY_STRING PackageName,
    PSECURITY_PACKAGE_OPTIONS Options);

NTSTATUS
WLsaQueryContextAttributes( PCtxtHandle, ULONG, PVOID );

NTSTATUS
WLsaSetContextAttributes(
    PCtxtHandle phContext,
    ULONG       ulAttribute,
    PVOID       pvBuffer,
    ULONG       cbBuffer
    );

NTSTATUS
WLsaQueryCredAttributes(
    PCredHandle phCredentials,
    ULONG ulAttribute,
    PVOID pBuffer
    );

NTSTATUS
WLsaAddCredentials(
    PCredHandle     phCredential,
    PSECURITY_STRING    pPrincipal,
    PSECURITY_STRING    pSecPackage,
    DWORD               fCredentialUse,
    PVOID               pvAuthData,
    PVOID               pvGetKeyFn,
    PVOID               pvGetKeyArgument,
    PTimeStamp          ptsExpiry);

NTSTATUS
WLsaEnumerateLogonSession(
    PULONG Count,
    PLUID * Sessions
    );

NTSTATUS
WLsaGetLogonSessionData(
    PLUID LogonId,
    PVOID * LogonData
    );

NTSTATUS
LsapSetSessionOptions(
    ULONG       Request,
    ULONG_PTR    Argument,
    PULONG_PTR   Resonse
    );


LSA_DISPATCH_FN DispatchAPIDirect;
extern PLSA_DISPATCH_FN DllCallbackHandler ;

NTSTATUS
GetRegistryString(HKEY hKey,
                  PWSTR pwszSubKey,
                  PWSTR pwszValue,
                  PWSTR pwszData,
                  PULONG pdwCount);

BOOL
InitializeThreadPool(
    void
    );

NTSTATUS
LsapGetExtendedPackageInfo(
    PLSAP_SECURITY_PACKAGE  Package,
    SECPKG_EXTENDED_INFORMATION_CLASS Class,
    PSECPKG_EXTENDED_INFORMATION * Info
    );

NTSTATUS
LsapSetExtendedPackageInfo(
    PLSAP_SECURITY_PACKAGE  Package,
    SECPKG_EXTENDED_INFORMATION_CLASS Class,
    PSECPKG_EXTENDED_INFORMATION Info
    );

#ifdef __cplusplus
extern "C"
#endif
NTSTATUS
LsapDuplicateSid(
    OUT PSID * DestinationSid,
    IN PSID SourceSid
    );

#ifdef __cplusplus
extern "C"
#endif
NTSTATUS
LsapDuplicateSid2(
    OUT PSID * DestinationSid,
    IN PSID SourceSid
    );

#ifdef __cplusplus
extern "C"
#endif
PSID
LsapMakeDomainRelativeSid(
    IN PSID DomainId,
    IN ULONG RelativeId
    );

#ifdef __cplusplus
extern "C"
#endif
PSID
LsapMakeDomainRelativeSid2(
    IN PSID DomainId,
    IN ULONG RelativeId
    );

//
// Debug helpers to track down bogus handle use
//

#if DBG > 0
#define SpmSetEvent(hHandle)     ASSERT(SetEvent(hHandle))
#else
#define SpmSetEvent(hHandle)       SetEvent(hHandle)
#endif

ULONG
SpmpReportEvent(
    IN BOOL Unicode,
    IN WORD EventType,
    IN ULONG EventId,
    IN ULONG Category,
    IN ULONG SizeOfRawData,
    IN PVOID RawData,
    IN ULONG NumberOfStrings,
    ...
    );

ULONG
SpmpReportEventU(
    IN WORD EventType,
    IN ULONG EventId,
    IN ULONG Category,
    IN ULONG SizeOfRawData,
    IN PVOID RawData,
    IN ULONG NumberOfStrings,
    ...
    );

#endif // __PROTOS_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\base\lsa\server\neglsa.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995.
//
//  File:       neglsa.cxx
//
//  Contents:   General (both win9x and nt) functions
//
//  Classes:
//
//  Functions:
//
//  History:    02-09-00   RichardW     Created - split from negotiat.cxx
//
//----------------------------------------------------------------------------

#include <lsapch.hxx>

extern "C"
{
#include <align.h>
#include <lm.h>
#include <dsgetdc.h>
#include <cryptdll.h>
#include <netlib.h>
#include <spmgr.h>
#include "sesmgr.h"
#include "spinit.h"
}

#include "negotiat.hxx"

#include <stdio.h>


GUID         GUID_NULL = {0L, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
TOKEN_SOURCE LsapTokenSource = {"LSA", 0};

//
// Hardcoded english strings for LocalService and NetworkService
// since the account names may come from the registry (which isn't
// localized).
//

#define  LOCALSERVICE_NAME    L"LocalService"
#define  NETWORKSERVICE_NAME  L"NetworkService"
#define  NTAUTHORITY_NAME     L"NT AUTHORITY"

UNICODE_STRING  LocalServiceName = { sizeof(LOCALSERVICE_NAME) - 2,
                                     sizeof(LOCALSERVICE_NAME),
                                     LOCALSERVICE_NAME };

UNICODE_STRING  NetworkServiceName = { sizeof(NETWORKSERVICE_NAME) - 2,
                                       sizeof(NETWORKSERVICE_NAME),
                                       NETWORKSERVICE_NAME };

UNICODE_STRING  NTAuthorityName = { sizeof(NTAUTHORITY_NAME) - 2,
                                    sizeof(NTAUTHORITY_NAME),
                                    NTAUTHORITY_NAME };
HANDLE NegEventLogHandle = NULL ;
ULONG NegEventLogLevel = 3 ;

EXTERN RTL_CRITICAL_SECTION    NegComputerNamesLock;

//
// RELOCATE_ONE - Relocate a single pointer in a client buffer.
//
// Note: this macro is dependent on parameter names as indicated in the
//       description below.  On error, this macro goes to 'Cleanup' with
//       'Status' set to the NT Status code.
//
// The MaximumLength is forced to be Length.
//
// Define a macro to relocate a pointer in the buffer the client passed in
// to be relative to 'ProtocolSubmitBuffer' rather than being relative to
// 'ClientBufferBase'.  The result is checked to ensure the pointer and
// the data pointed to is within the first 'SubmitBufferSize' of the
// 'ProtocolSubmitBuffer'.
//
// The relocated field must be aligned to a WCHAR boundary.
//
//  _q - Address of UNICODE_STRING structure which points to data to be
//       relocated
//

#define RELOCATE_ONE( _q ) \
    {                                                                       \
        ULONG_PTR Offset;                                                   \
                                                                            \
        Offset = (((PUCHAR)((_q)->Buffer)) - ((PUCHAR)ClientBufferBase));   \
        if ( Offset >= SubmitBufferSize ||                                  \
             Offset + (_q)->Length > SubmitBufferSize ||                    \
             !COUNT_IS_ALIGNED( Offset, ALIGN_WCHAR) ) {                    \
                                                                            \
            Status = STATUS_INVALID_PARAMETER;                              \
            goto Cleanup;                                                   \
        }                                                                   \
                                                                            \
        (_q)->Buffer = (PWSTR)(((PUCHAR)ProtocolSubmitBuffer) + Offset);    \
        (_q)->MaximumLength = (_q)->Length ;                                \
    }

//
// NULL_RELOCATE_ONE - Relocate a single (possibly NULL) pointer in a client
//  buffer.
//
// This macro special cases a NULL pointer then calls RELOCATE_ONE.  Hence
// it has all the restrictions of RELOCATE_ONE.
//
//
//  _q - Address of UNICODE_STRING structure which points to data to be
//       relocated
//

#define NULL_RELOCATE_ONE( _q ) \
    {                                                                       \
        if ( (_q)->Buffer == NULL ) {                                       \
            if ( (_q)->Length != 0 ) {                                      \
                Status = STATUS_INVALID_PARAMETER;                          \
                goto Cleanup;                                               \
            }                                                               \
        } else if ( (_q)->Length == 0 ) {                                   \
            (_q)->Buffer = NULL;                                            \
        } else {                                                            \
            RELOCATE_ONE( _q );                                             \
        }                                                                   \
    }

#define MAX_EVENT_STRINGS   8


extern SECPKG_PRIMARY_CRED       NegPrimarySystemCredentials;


//
// Local function prototypes
//

NTSTATUS
NegpMakeServiceToken(
    IN ULONG ulAccountId,
    OUT PLUID pLogonId,
    OUT PVOID *ProfileBuffer,
    OUT PULONG ProfileBufferLength,
    OUT PNTSTATUS ApiSubStatus,
    OUT PLSA_TOKEN_INFORMATION_TYPE TokenInformationType,
    OUT PVOID *TokenInformation,
    OUT PUNICODE_STRING *AccountName,
    OUT PUNICODE_STRING *AuthenticatingAuthority,
    OUT PUNICODE_STRING *MachineName,
    OUT PSECPKG_PRIMARY_CRED PrimaryCredentials,
    OUT PSECPKG_SUPPLEMENTAL_CRED_ARRAY * CachedCredentials
    );

BOOL
NegpIsLocalOrNetworkService(
    IN PVOID ProtocolSubmitBuffer,
    IN PVOID ClientBufferBase,
    IN ULONG SubmitBufferSize,
    OUT PUNICODE_STRING *AccountName,
    OUT PUNICODE_STRING *AuthenticatingAuthority,
    OUT PUNICODE_STRING *MachineName,
    OUT PULONG pulAccountId
    );


#ifdef _WIN64

NTSTATUS
NegpConvertWOWInteractiveLogonBuffer(
    IN     PVOID                   ProtocolSubmitBuffer,
    IN     PVOID                   ClientBufferBase,
    IN OUT PULONG                  pSubmitBufferSize,
    OUT    PVOID                   *ppTempSubmitBuffer
    );

#endif  // _WIN64


VOID
NegpReportEvent(
    IN WORD EventType,
    IN DWORD EventId,
    IN DWORD Category,
    IN NTSTATUS Status,
    IN DWORD NumberOfStrings,
    ...
    )
{
    va_list arglist;
    ULONG i;
    PWSTR Strings[ MAX_EVENT_STRINGS ];
    BOOLEAN Allocated[ MAX_EVENT_STRINGS ] = { 0 };
    WCHAR StatusString[ MAX_PATH ];
    WCHAR FinalStatus[ MAX_PATH ];
    HANDLE Dll ;
    DWORD rv;

    if (NegEventLogHandle == NULL )
    {
        //
        // only log identical event once per hour.
        // note that LSA doesn't cleanup this 'handle' during shutdown,
        // to avoid preventing log failures during shutdown.
        //

        NegEventLogHandle = NetpEventlogOpen( L"LSASRV", 60000*60 );

        if ( NegEventLogHandle == NULL )
        {
            return ;
        }
    }

    //
    // We're not supposed to be logging this, so nuke it
    //
    if ((NegEventLogLevel & (1 << EventType)) == 0)
    {
        return ;
    }

    //
    // Look at the strings, if they were provided
    //
    va_start( arglist, NumberOfStrings );

    if (NumberOfStrings > MAX_EVENT_STRINGS) {
        NumberOfStrings = MAX_EVENT_STRINGS;
    }

    for (i=0; i<NumberOfStrings; i++) {

        PUNICODE_STRING String = va_arg( arglist, PUNICODE_STRING );

        //
        // Make sure strings are NULL-terminated.  Do it in place for
        // those strings whose buffers can accomodate an additional character,
        // and allocate memory for the rest.
        //

        if ( String->MaximumLength > String->Length ) {

            Strings[i] = String->Buffer;

        } else {

            SafeAllocaAllocate(Strings[i], String->Length + sizeof( WCHAR ));

            if ( Strings[i] == NULL ) {

                goto Cleanup;
            }

            Allocated[i] = TRUE;

            RtlCopyMemory( Strings[i], String->Buffer, String->Length );
        }

        Strings[i][String->Length / sizeof( WCHAR )] = L'\0';

    }

    if ( Status != 0 )
    {
        static HMODULE NtDll;
        static HMODULE Kernel32;

        //
        // Map the status code:
        //

        //
        // The value "type" is not known.  Try and figure out what it
        // is.
        //

        if ( (Status & 0xC0000000) == 0xC0000000 )
        {
            //
            // Easy:  NTSTATUS failure case
            //

            if( NtDll == NULL )
            {
                NtDll = GetModuleHandleW( L"NTDLL.DLL" );
            }

            Dll = NtDll;
        }
        else if ( ( Status & 0xF0000000 ) == 0xD0000000 )
        {
            //
            // HRESULT from NTSTATUS
            //

            if( NtDll == NULL )
            {
                NtDll = GetModuleHandleW( L"NTDLL.DLL" );
            }

            Dll = NtDll;

            Status &= 0xCFFFFFFF ;
        }
        else if ( ( Status & 0x80000000 ) == 0x80000000 )
        {
            //
            // Note, this can overlap with NTSTATUS warning area.  In that
            // case, force the NTSTATUS.
            //


            if( Kernel32 == NULL )
            {
                Kernel32 = GetModuleHandleW( L"KERNEL32.DLL" );
            }

            Dll = Kernel32;
        }
        else
        {
            //
            // Sign bit is off.  Explore some known ranges:
            //

            if ( (Status >= WSABASEERR) && (Status <= WSABASEERR + 1000 ))
            {
                Dll = LoadLibraryExW(L"ws2_32.dll",
                                     NULL,
                                     LOAD_LIBRARY_AS_DATAFILE);
            }
            else if ( ( Status >= NERR_BASE ) && ( Status <= MAX_NERR ) )
            {
                Dll = LoadLibraryExW(L"netmsg.dll",
                                     NULL,
                                     LOAD_LIBRARY_AS_DATAFILE);
            }
            else
            {
                if( Kernel32 == NULL )
                {
                    Kernel32 = GetModuleHandleW( L"KERNEL32.DLL" );
                }

                Dll = Kernel32;
            }
        }

        if (!FormatMessage(
                        FORMAT_MESSAGE_IGNORE_INSERTS |
                            FORMAT_MESSAGE_FROM_HMODULE,
                        Dll,
                        Status,
                        0,
                        StatusString,
                        MAX_PATH,
                        NULL ) )
        {
            StatusString[0] = L' ';
            StatusString[1] = L'\0';
        }

        if ( Status < 0 )
        {
            _snwprintf( FinalStatus, MAX_PATH, L"\"%ws (%#x)\"", StatusString, Status );
        }
        else
        {
            _snwprintf( FinalStatus, MAX_PATH, L"\"%ws (%#x, %d)\"", StatusString, Status, Status );
        }

        if ( NumberOfStrings < MAX_EVENT_STRINGS )
        {
            Strings[ NumberOfStrings++ ] = FinalStatus ;
        }

    }


    //
    // Report the event to the eventlog service
    //

    NetpEventlogWriteEx(
                    NegEventLogHandle,
                    EventType,
                    Category,
                    EventId,
                    NumberOfStrings,
                    sizeof(NTSTATUS),
                    Strings,
                    &Status
                    );

Cleanup:

    for ( i = 0 ; i < NumberOfStrings ; i++ ) {

        if ( Allocated[i] ) {

            SafeAllocaFree( Strings[i] );
        }
    }
}


//+---------------------------------------------------------------------------
//
//  Function:   NegLsaPolicyChangeCallback
//
//  Synopsis:   Called by the policy engine in the LSA when local policy changes,
//              allowing us to update our state about the machine account, etc.
//
//  Arguments:  ChangedInfoClass    - Class of policy that changed
//
//  History:    2-9-00   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
VOID
NTAPI
NegLsaPolicyChangeCallback(
    IN POLICY_NOTIFICATION_INFORMATION_CLASS ChangedInfoClass
    )
{
    PLSAPR_POLICY_INFORMATION Policy = NULL ;
    NTSTATUS Status ;
    GUID GuidNull = GUID_NULL ;
    PLSAP_LOGON_SESSION LogonSession = NULL ;
    BOOL Uplevel ;
    UNICODE_STRING TmpDomainName = {0};
    

    //
    // Right now, only domain information is interesting
    //

    if ( ChangedInfoClass != PolicyNotifyDnsDomainInformation )
    {
        return ;
    }

    DebugLog(( DEB_TRACE_NEG, "Domain change, updating state\n" ));

    //
    // Reset the trust list.  The next time someone asks for the trust
    // list, it will have expired and they will get a fresh one.
    //

    NegTrustTime.QuadPart = 0 ;


    //
    // Obtain the new policy settings
    //

    Status = LsaIQueryInformationPolicyTrusted(
                PolicyDnsDomainInformation,
                &Policy );

    if ( NT_SUCCESS( Status ) )
    {
        //
        // If the domain has a GUID, then it is an uplevel domain
        //

        if ( Policy->PolicyDnsDomainInfo.DomainGuid == GuidNull )
        {
            Uplevel = FALSE ;
        }
        else
        {
            Uplevel = TRUE ;            
        }

        RtlEnterCriticalSection(&NegComputerNamesLock);

        Status = LsapDuplicateString(
                    &TmpDomainName,
                    (PUNICODE_STRING) &Policy->PolicyDnsDomainInfo.DnsDomainName
                    );          

        if (NT_SUCCESS(Status))
        {  

            //
            // Time to update the primary system credentials.
            //
                       
            if ( TmpDomainName.Buffer )
            {   
                LsapFreeString( &NegPrimarySystemCredentials.DnsDomainName );
                NegPrimarySystemCredentials.DnsDomainName = TmpDomainName;
                TmpDomainName.Buffer = NULL;
            }
            
            Status = LsapDuplicateString(
                        &TmpDomainName,
                        (PUNICODE_STRING) &Policy->PolicyDnsDomainInfo.Name
                        );          

            if (NT_SUCCESS(Status))
            {  
                if ( TmpDomainName.Buffer )
                {   
                    LsapFreeString( &NegPrimarySystemCredentials.DomainName );
                    NegPrimarySystemCredentials.DomainName = TmpDomainName;
                    TmpDomainName.Buffer = NULL;
                }
            }
            
        }

        RtlLeaveCriticalSection(&NegComputerNamesLock);   

        //
        // Done with the policy info
        //

        LsaIFree_LSAPR_POLICY_INFORMATION(
            PolicyDnsDomainInformation,
            Policy
            );


        NegUplevelDomain = Uplevel ;

        //
        // Update the package ID for the local system logon session
        // Note, any additional special logon sessions will need to be
        // updated as well.
        //

        LogonSession = LsapLocateLogonSession( &SystemLogonId );

        if ( LogonSession )
        {
            if ( Uplevel )
            {
                LogonSession->CreatingPackage = NegPackageId ;
            }
            else
            {
                LogonSession->CreatingPackage = NtlmPackageId ;
            }
            LsapReleaseLogonSession( LogonSession );
        }

    }

    {
    ULONG Size;

    static WCHAR NegNetbiosComputerName[ MAX_COMPUTERNAME_LENGTH + 1 ];
    static WCHAR NegDnsComputerName[ DNS_MAX_NAME_BUFFER_LENGTH + 1 ];

    //
    // refresh the computer names.
    // note we could avoid taking the lock around these calls if we dyna-alloc'd
    // and freed the existing buffers.  We don't expect this path to be hit often,
    // so avoid the hassle.
    //

    NegWriteLockComputerNames();

    Size = sizeof(NegDnsComputerName) / sizeof(WCHAR);

    //
    // Note, if this fails, it's ok.  We just won't be able to make
    // some optimizations later.
    //

    if(!GetComputerNameExW(
                    ComputerNamePhysicalDnsFullyQualified,
                    NegDnsComputerName,
                    &Size
                    ))
    {
        NegDnsComputerName[ 0 ] = L'\0';
    }

    RtlInitUnicodeString( &NegDnsComputerName_U, NegDnsComputerName );


    Size = sizeof(NegNetbiosComputerName) / sizeof(WCHAR);

    if(!GetComputerNameExW(
                    ComputerNamePhysicalNetBIOS,
                    NegNetbiosComputerName,
                    &Size
                    ))
    {
        NegNetbiosComputerName[ 0 ] = L'\0';
    }


    RtlInitUnicodeString( &NegNetbiosComputerName_U, NegNetbiosComputerName );

    NegUnlockComputerNames();

    }


}

//+---------------------------------------------------------------------------
//
//  Function:   NegParamChange
//
//  Synopsis:   Called by LSA whenever the LSA registry key changes
//
//  Arguments:  [p] --
//
//  History:    5-11-00   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
DWORD
WINAPI
NegParamChange(
    PVOID   p
    )
{
    NTSTATUS Status ;
    PSECPKG_EVENT_NOTIFY Notify;
    HKEY LsaKey ;


    Notify = (PSECPKG_EVENT_NOTIFY) p;

    if ( Notify->EventClass != NOTIFY_CLASS_REGISTRY_CHANGE )
    {
        return( 0 );
    }

    if ( RegOpenKeyEx(
                HKEY_LOCAL_MACHINE,
                TEXT("System\\CurrentControlSet\\Control\\Lsa"),
                0,
                KEY_READ,
                &LsaKey ) == 0 )
    {
        NegpReadRegistryParameters( LsaKey );

        RegCloseKey( LsaKey );
    }

    return 0 ;

}

//+---------------------------------------------------------------------------
//
//  Function:   NegEnumPackagePrefixesCall
//
//  Synopsis:   LsaCallPackage routine to identify the prefxes (or OIDs) for
//              all the packages, for SASL support.
//
//  Arguments:
//
//  History:
//
//  Notes:
//
//----------------------------------------------------------------------------
NTSTATUS
NegEnumPackagePrefixesCall(
    IN PLSA_CLIENT_REQUEST ClientRequest,
    IN PVOID ProtocolSubmitBuffer,
    IN PVOID ClientBufferBase,
    IN ULONG SubmitBufferLength,
    OUT PVOID *ProtocolReturnBuffer,
    OUT PULONG ReturnBufferLength,
    OUT PNTSTATUS ProtocolStatus
    )
{
    UCHAR PrefixBuffer[ NEGOTIATE_MAX_PREFIX ];
    NTSTATUS Status ;
    PNEGOTIATE_PACKAGE_PREFIXES Prefixes ;
    PNEGOTIATE_PACKAGE_PREFIX Prefix ;
    PNEGOTIATE_PACKAGE_PREFIX_WOW PrefixWow ;
    ULONG PackageCount ;
    BOOL WowClient = FALSE ;
    PNEG_PACKAGE    Package ;
    PLIST_ENTRY Scan ;
    SECPKG_CALL_INFO CallInfo ;
    ULONG Size ;

    LsapGetCallInfo( &CallInfo );

    if ( CallInfo.Attributes & SECPKG_CALL_WOWCLIENT )
    {
        WowClient = TRUE;
    }

    NegReadLockList();

    Size = sizeof( NEGOTIATE_PACKAGE_PREFIXES ) +
           sizeof( NEGOTIATE_PACKAGE_PREFIX ) * ( NegPackageCount + 1 );

    SafeAllocaAllocate(Prefixes, Size);

    if ( !Prefixes )
    {
        NegUnlockList();

        return SEC_E_INSUFFICIENT_MEMORY ;
    }

    Prefixes->MessageType = NegEnumPackagePrefixes ;
    Prefixes->Offset = sizeof( NEGOTIATE_PACKAGE_PREFIXES );

    //
    // We're going to do one or the other, but initializing them both
    // makes the compiler happier.
    //

    Prefix = (PNEGOTIATE_PACKAGE_PREFIX) ( Prefixes + 1 );

    PrefixWow = (PNEGOTIATE_PACKAGE_PREFIX_WOW) ( Prefixes + 1);

    if ( WowClient )
    {
        PrefixWow->PackageId = (ULONG) NegPackageId ;
        PrefixWow->PrefixLen = sizeof( NegSpnegoMechEncodedOid );
        PrefixWow->PackageDataA = NULL ;
        PrefixWow->PackageDataW = NULL ;
        RtlCopyMemory( PrefixWow->Prefix,
                       NegSpnegoMechEncodedOid,
                       sizeof( NegSpnegoMechEncodedOid ) );

        PrefixWow++ ;
    }
    else
    {
        Prefix->PackageId = NegPackageId ;
        Prefix->PrefixLen = sizeof( NegSpnegoMechEncodedOid );
        Prefix->PackageDataA = NULL ;
        Prefix->PackageDataW = NULL ;
        RtlCopyMemory( Prefix->Prefix,
                       NegSpnegoMechEncodedOid,
                       sizeof( NegSpnegoMechEncodedOid ) );

        Prefix++ ;
    }

    PackageCount = 1 ;
    Scan = NegPackageList.Flink ;

    while ( Scan != &NegPackageList )
    {
        Package = CONTAINING_RECORD( Scan, NEG_PACKAGE, List );

        if ( !WowClient )
        {
            Prefix->PackageId = Package->LsaPackage->dwPackageID ;
            Prefix->PrefixLen = Package->PrefixLen ;
            Prefix->PackageDataA = NULL ;
            Prefix->PackageDataW = NULL ;
            RtlCopyMemory( Prefix->Prefix,
                           Package->Prefix,
                           Package->PrefixLen );

            Prefix++ ;
            PackageCount++ ;
        }
        else
        {
            if ( Package->LsaPackage->fPackage & SP_WOW_SUPPORT )
            {
                PrefixWow->PackageId = (ULONG) Package->LsaPackage->dwPackageID ;
                PrefixWow->PrefixLen = Package->PrefixLen ;
                PrefixWow->PackageDataA = NULL ;
                PrefixWow->PackageDataW = NULL ;
                RtlCopyMemory( PrefixWow->Prefix,
                               Package->Prefix,
                               Package->PrefixLen );

                PrefixWow++ ;
                PackageCount++ ;

            }
        }

        Scan = Scan->Flink ;
    }


    NegUnlockList();

    //
    // Set the final count of packages:
    //

    Prefixes->PrefixCount = PackageCount ;

    Status = LsapAllocateClientBuffer(
                NULL,
                Size,
                ProtocolReturnBuffer );

    if ( NT_SUCCESS( Status ) )
    {
        Status = LsapCopyToClient(
                    Prefixes,
                    *ProtocolReturnBuffer,
                    Size );

        *ReturnBufferLength = Size ;
    }

    SafeAllocaFree(Prefixes);

    return Status ;
}


NTSTATUS
NegGetCallerNameCall(
    IN PLSA_CLIENT_REQUEST ClientRequest,
    IN PVOID ProtocolSubmitBuffer,
    IN PVOID ClientBufferBase,
    IN ULONG SubmitBufferLength,
    OUT PVOID *ProtocolReturnBuffer,
    OUT PULONG ReturnBufferLength,
    OUT PNTSTATUS ProtocolStatus
    )
{
    PNEGOTIATE_CALLER_NAME_REQUEST Request ;
    PNEGOTIATE_CALLER_NAME_RESPONSE Response ;
    PNEGOTIATE_CALLER_NAME_RESPONSE_WOW ResponseWow ;
    SECPKG_CLIENT_INFO ClientInfo ;
    SECPKG_CALL_INFO CallInfo ;
    NTSTATUS Status ;
    PNEG_LOGON_SESSION LogonSession ;
    ULONG ClientSize ;
    PUCHAR Where ;
    PVOID ClientBuffer ;
    BOOL ReCheckAccess = FALSE ;

    *ProtocolReturnBuffer = NULL ;
    *ReturnBufferLength = 0 ;
    *ProtocolStatus = 0 ;

    if ( SubmitBufferLength != sizeof( NEGOTIATE_CALLER_NAME_REQUEST ) )
    {
        return STATUS_INVALID_PARAMETER ;
    }

    Request = (PNEGOTIATE_CALLER_NAME_REQUEST) ProtocolSubmitBuffer ;

    Status = LsapGetClientInfo( &ClientInfo );

    if ( !NT_SUCCESS( Status ) )
    {
        return Status ;
    }

    LsapGetCallInfo( &CallInfo );

    if ( RtlIsZeroLuid( &Request->LogonId ) )
    {
        Request->LogonId = ClientInfo.LogonId ;
    }
    else
    {
        if ( !RtlEqualLuid( &ClientInfo.LogonId, &Request->LogonId ) )
        {
            ReCheckAccess = TRUE ;
        }
    }

    LogonSession = NegpLocateLogonSession( &Request->LogonId );

    if ( LogonSession )
    {
        if ( ReCheckAccess )
        {
            if ( !RtlEqualLuid( &ClientInfo.LogonId, &LogonSession->ParentLogonId ) )
            {
                Status = STATUS_ACCESS_DENIED ;

                goto AccessDeniedError ;
            }
        }

        if ( LogonSession->AlternateName.Buffer == NULL )
        {
            //
            // No alternate ID
            //

            Status = STATUS_NO_SUCH_LOGON_SESSION ;

            goto AccessDeniedError ;
        }

        ClientSize = sizeof( NEGOTIATE_CALLER_NAME_RESPONSE ) +
                      LogonSession->AlternateName.Length + sizeof( WCHAR );

        SafeAllocaAllocate(Response, ClientSize);

        if ( Response )
        {
            RtlZeroMemory(Response, ClientSize);

            ClientBuffer = LsapClientAllocate( ClientSize );

            if ( ClientBuffer )
            {
                Where = (PUCHAR) ClientBuffer + sizeof( NEGOTIATE_CALLER_NAME_RESPONSE ) ;

                //
                // If a WOW client, copy these to the 32bit locations.  Note
                // that this will leave a "hole," but that's ok.
                //

                if ( CallInfo.Attributes & SECPKG_CALL_WOWCLIENT )
                {
                    ResponseWow = (PNEGOTIATE_CALLER_NAME_RESPONSE_WOW) Response ;
                    ResponseWow->MessageType = NegGetCallerName ;
                    ResponseWow->CallerName = PtrToUlong(Where) ;
                }
                else
                {
                    Response->MessageType = NegGetCallerName ;
                    Response->CallerName = (PWSTR) Where ;
                }

                RtlCopyMemory( (Response + 1),
                               LogonSession->AlternateName.Buffer,
                               LogonSession->AlternateName.Length );

                *ProtocolReturnBuffer = ClientBuffer ;
                *ReturnBufferLength = ClientSize ;
                *ProtocolStatus = 0 ;
                Status = LsapCopyToClient( Response,
                                           ClientBuffer,
                                           ClientSize ) ;
            }
            else
            {
                Status = STATUS_NO_MEMORY ;
            }

            SafeAllocaFree(Response);
        }

AccessDeniedError:

        NegpDerefLogonSession( LogonSession );

    }
    else
    {

        Status = STATUS_NO_SUCH_LOGON_SESSION ;
    }


    *ProtocolStatus = Status ;

    return STATUS_SUCCESS ;
}



PNEG_LOGON_SESSION
NegpBuildLogonSession(
    PLUID LogonId,
    ULONG_PTR LogonPackage,
    ULONG_PTR DefaultPackage
    )
{
    PNEG_LOGON_SESSION LogonSession ;

    LogonSession = (PNEG_LOGON_SESSION) LsapAllocatePrivateHeap( sizeof( NEG_LOGON_SESSION ) );

    if ( LogonSession )
    {
        LogonSession->LogonId = *LogonId ;
        LogonSession->CreatingPackage = LogonPackage ;
        LogonSession->DefaultPackage = DefaultPackage ;
        LogonSession->RefCount = 2 ;

        RtlEnterCriticalSection( &NegLogonSessionListLock );

        InsertHeadList( &NegLogonSessionList, &LogonSession->List );

        RtlLeaveCriticalSection( &NegLogonSessionListLock );

    }

    return LogonSession ;
}

VOID
NegpDerefLogonSession(
    PNEG_LOGON_SESSION LogonSession
    )
{
    BOOL FreeIt = FALSE ;

    RtlEnterCriticalSection( &NegLogonSessionListLock );

    LogonSession->RefCount-- ;

    if ( LogonSession->RefCount == 0 )
    {
        RemoveEntryList( &LogonSession->List );

        FreeIt = TRUE ;
    }

    RtlLeaveCriticalSection( &NegLogonSessionListLock );

    if ( FreeIt )
    {
        if ( LogonSession->AlternateName.Buffer )
        {
            LsapFreePrivateHeap( LogonSession->AlternateName.Buffer );
        }

        LsapFreePrivateHeap( LogonSession );
    }

}

VOID
NegpDerefLogonSessionById(
    PLUID LogonId
    )
{
    BOOL FreeIt = FALSE ;
    PLIST_ENTRY Scan ;
    PNEG_LOGON_SESSION LogonSession = NULL;

    RtlEnterCriticalSection( &NegLogonSessionListLock );

    Scan = NegLogonSessionList.Flink ;

    while ( Scan != &NegLogonSessionList )
    {
        LogonSession = CONTAINING_RECORD( Scan, NEG_LOGON_SESSION, List );

        if ( RtlEqualLuid( LogonId, &LogonSession->LogonId ) )
        {
            LogonSession->RefCount -- ;

            if ( LogonSession->RefCount == 0 )
            {
                RemoveEntryList( &LogonSession->List );

                FreeIt = TRUE ;

            }

            break;
        }

        LogonSession = NULL ;

        Scan = Scan->Flink ;
    }

    RtlLeaveCriticalSection( &NegLogonSessionListLock );


    if ( FreeIt )
    {
        DsysAssert( LogonSession != NULL );

        if ( LogonSession->AlternateName.Buffer )
        {
            LsapFreePrivateHeap( LogonSession->AlternateName.Buffer );
        }

        LsapFreePrivateHeap( LogonSession );
    }

}

PNEG_LOGON_SESSION
NegpLocateLogonSession(
    PLUID LogonId
    )
{
    PLIST_ENTRY Scan ;
    PNEG_LOGON_SESSION LogonSession = NULL;

    RtlEnterCriticalSection( &NegLogonSessionListLock );

    Scan = NegLogonSessionList.Flink ;

    while ( Scan != &NegLogonSessionList )
    {
        LogonSession = CONTAINING_RECORD( Scan, NEG_LOGON_SESSION, List );

        if ( RtlEqualLuid( LogonId, &LogonSession->LogonId ) )
        {
            break;
        }

        LogonSession = NULL ;

        Scan = Scan->Flink ;
    }

    if ( LogonSession )
    {
        LogonSession->RefCount++ ;
    }

    RtlLeaveCriticalSection( &NegLogonSessionListLock );

    return LogonSession ;
}





NTSTATUS
NTAPI
NegpMapLogonRequest(
    IN PVOID ProtocolSubmitBuffer,
    IN PVOID ClientBufferBase,
    IN ULONG SubmitBufferSize,
    OUT PMSV1_0_INTERACTIVE_LOGON * LogonInfo
    )
{
    NTSTATUS Status = STATUS_SUCCESS ;
    PMSV1_0_INTERACTIVE_LOGON Authentication = NULL;
    PSECURITY_SEED_AND_LENGTH SeedAndLength;
    UCHAR Seed;


    //
    // Ensure this is really an interactive logon.
    //

    Authentication =
        (PMSV1_0_INTERACTIVE_LOGON) ProtocolSubmitBuffer;

    if ( Authentication->MessageType != MsV1_0InteractiveLogon ) {
        DebugLog(( DEB_ERROR, "Neg:  Bad Validation Class %d\n",
                   Authentication->MessageType));
        Status = STATUS_BAD_VALIDATION_CLASS;
        goto Cleanup;
    }



    //
    // If the password length is greater than 255 (i.e., the
    // upper byte of the length is non-zero) then the password
    // has been run-encoded for privacy reasons.  Get the
    // run-encode seed out of the upper-byte of the length
    // for later use.
    //
    //



    SeedAndLength = (PSECURITY_SEED_AND_LENGTH)
                    &Authentication->Password.Length;
    Seed = SeedAndLength->Seed;
    SeedAndLength->Seed = 0;

    //
    // Enforce length restrictions on username and password.
    //

    if ( Authentication->UserName.Length > UNLEN ||
        Authentication->Password.Length > PWLEN ) {
        DebugLog(( DEB_ERROR, "Neg: Name or password too long\n"));
        Status = STATUS_NAME_TOO_LONG;
        goto Cleanup;
    }


    //
    // Relocate any pointers to be relative to 'Authentication'
    //

    NULL_RELOCATE_ONE( &Authentication->LogonDomainName );

    RELOCATE_ONE( &Authentication->UserName );

    NULL_RELOCATE_ONE( &Authentication->Password );

    //
    // Now decode the password, if necessary
    //

    if (Seed != 0 ) {
        __try {
            RtlRunDecodeUnicodeString( Seed, &Authentication->Password);
        } __except(EXCEPTION_EXECUTE_HANDLER) {
            Status = STATUS_ILL_FORMED_PASSWORD;
            goto Cleanup;
        }
    }

    *LogonInfo = Authentication ;

Cleanup:

    return Status ;

}

VOID
NegpDerefTrustList(
    PNEG_TRUST_LIST TrustList
    )
{
    RtlEnterCriticalSection( &NegTrustListLock );

    TrustList->RefCount-- ;

    if ( TrustList->RefCount == 0 )
    {
        if( NegTrustList == TrustList )
        {
            NegTrustList = NULL;
        }

        RtlLeaveCriticalSection( &NegTrustListLock );

        NetApiBufferFree( TrustList->Trusts );

        LsapFreePrivateHeap( TrustList );

        return;
    }

    RtlLeaveCriticalSection( &NegTrustListLock );

}

PNEG_TRUST_LIST
NegpGetTrustList(
    VOID
    )
{
    PDS_DOMAIN_TRUSTS Trusts = NULL;
    DWORD TrustCount ;
    PNEG_TRUST_LIST TrustList = NULL ;
    DWORD NetStatus ;
    LARGE_INTEGER Now ;

    BOOLEAN TrustListLocked = TRUE;

    GetSystemTimeAsFileTime( (LPFILETIME) &Now );


    RtlEnterCriticalSection( &NegTrustListLock );

    if ( Now.QuadPart > NegTrustTime.QuadPart + FIFTEEN_MINUTES )
    {
        if( NegTrustList != NULL && NegTrustList->RefCount == 1 )
        {
            NegpDerefTrustList( NegTrustList );
            NegTrustList = NULL;
        }
    }



    if( NegTrustList != NULL )
    {
        TrustList = NegTrustList ;
        TrustList->RefCount++ ;
        goto Cleanup;
    }


    RtlLeaveCriticalSection( &NegTrustListLock );
    TrustListLocked = FALSE;


    NetStatus = DsEnumerateDomainTrustsW( NULL,
                                          DS_DOMAIN_IN_FOREST |
                                            DS_DOMAIN_PRIMARY,
                                          &Trusts,
                                          &TrustCount );

    if ( NetStatus != 0 )
    {
        goto Cleanup;
    }



    TrustList = (PNEG_TRUST_LIST) LsapAllocatePrivateHeap( sizeof( NEG_TRUST_LIST ) );

    if( TrustList == NULL )
    {
        goto Cleanup;
    }

    TrustList->RefCount = 2 ;
    TrustList->TrustCount = TrustCount ;
    TrustList->Trusts = Trusts ;



    RtlEnterCriticalSection( &NegTrustListLock );
    TrustListLocked = TRUE;

    if( NegTrustList != NULL )
    {
        PNEG_TRUST_LIST FreeTrustList = TrustList;

        TrustList = NegTrustList ;
        TrustList->RefCount++ ;

        RtlLeaveCriticalSection( &NegTrustListLock );
        TrustListLocked = FALSE;

        LsapFreePrivateHeap( FreeTrustList );
        goto Cleanup;
    }

    Trusts = NULL;

    NegTrustList = TrustList ;
    NegTrustTime = Now ;

Cleanup:

    if( TrustListLocked )
    {
        RtlLeaveCriticalSection( &NegTrustListLock );
    }

    if( Trusts != NULL )
    {
        NetApiBufferFree( Trusts );
    }

    return TrustList ;
}


NEG_DOMAIN_TYPES
NegpIsUplevelDomain(
    PLUID LogonId,
    SECURITY_LOGON_TYPE LogonType,
    PUNICODE_STRING Domain
    )
{
    PNEG_TRUST_LIST TrustList ;
    UNICODE_STRING String ;
    ULONG i ;
    BOOL IsUplevel = FALSE ;
    LONG Error ;
    PDOMAIN_CONTROLLER_INFOW Info ;

    UNREFERENCED_PARAMETER(LogonId);


    //
    // Case #1.  Local logons are not uplevel, and should be allowed to
    // use NTLM right off the bat.  Therefore, return false
    //

    if ( RtlEqualUnicodeString(
            Domain,
            &MachineName,
            TRUE ) )
    {
        return NegLocalDomain;
    }

    if ( LogonType == CachedInteractive )
    {
        return NegUpLevelDomain;
    }



    //
    // Case #2.  We logged on to a domain, but we need to check if it is
    // an uplevel domain in our forest.  If it is, then return true, otherwise
    // it's not an uplevel domain and NTLM is acceptable.  If we can't obtain the
    // trust list, assume downlevel.
    //

    TrustList = NegpGetTrustList();

    if ( TrustList )
    {
        for ( i = 0 ; i < TrustList->TrustCount ; i++ )
        {
            RtlInitUnicodeString( &String, TrustList->Trusts[i].NetbiosDomainName );

            if ( RtlEqualUnicodeString( Domain,
                                        &String,
                                        TRUE ) )
            {
                //
                // Hit, check it
                //

                if ( ( TrustList->Trusts[i].DnsDomainName != NULL ) &&
                     ( TrustList->Trusts[i].Flags & DS_DOMAIN_IN_FOREST ) )
                {
                    IsUplevel = TRUE ;
                    break;
                }

            }
        }

        NegpDerefTrustList( TrustList );

    }

    if ( IsUplevel )
    {
        return NegUpLevelDomain ;
    }

    //
    // Case #3 - if this is an uplevel domain we live in, then the answer returned
    // by netlogon is authoritative:
    //
    if ( NegUplevelDomain )
    {
        return NegDownLevelDomain ;
    }

    //
    // Case #4 - if we are living in a downlevel domain, netlogon won't know if the domain
    // we just talked to is uplevel or downlevel.  So, we need to figure out directly.
    //

    Error = DsGetDcNameW(
                NULL,
                Domain->Buffer,
                NULL,
                NULL,
                DS_DIRECTORY_SERVICE_REQUIRED,
                &Info );

    if ( Error == 0 )
    {
        IsUplevel = TRUE ;
        NetApiBufferFree( Info );
    }
    else
    {
        IsUplevel = FALSE ;
    }

    return ( IsUplevel ? NegUpLevelTrustedDomain : NegDownLevelDomain );

}



//+-------------------------------------------------------------------------
//
//  Function:   NegpCloneLogonSession
//
//  Synopsis:   Handles a NewCredentials type of logon.
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------
NTSTATUS
NTAPI
NegpCloneLogonSession(
    IN PVOID ProtocolSubmitBuffer,
    IN PVOID ClientBufferBase,
    IN ULONG SubmitBufferSize,
    OUT PVOID *ProfileBuffer,
    OUT PULONG ProfileBufferLength,
    OUT PLUID NewLogonId,
    OUT PNTSTATUS ApiSubStatus,
    OUT PLSA_TOKEN_INFORMATION_TYPE TokenInformationType,
    OUT PVOID *TokenInformation,
    OUT PUNICODE_STRING *AccountName,
    OUT PUNICODE_STRING *AuthenticatingAuthority,
    OUT PUNICODE_STRING *MachineName,
    OUT PSECPKG_PRIMARY_CRED PrimaryCredentials,
    OUT PSECPKG_SUPPLEMENTAL_CRED_ARRAY * CachedCredentials
    )
{
    NTSTATUS Status;
    HANDLE hToken;
    UCHAR   SmallBuffer[ 128 ];
    PLSA_TOKEN_INFORMATION_V1 TokenInfo = NULL;
    PTOKEN_USER User = NULL;
    PTOKEN_GROUPS Groups = NULL;
    PTOKEN_GROUPS FinalGroups = NULL;
    PTOKEN_PRIMARY_GROUP PrimaryGroup = NULL;
    TOKEN_STATISTICS TokenStats;
    PLSAP_LOGON_SESSION LogonSession = NULL;
    PNEG_LOGON_SESSION NegLogonSession;
    LUID LogonId;
    LUID LocalServiceLuid = LOCALSERVICE_LUID;
    LUID NetworkServiceLuid = NETWORKSERVICE_LUID;
    LUID LocalSystemLuid = SYSTEM_LUID;
    BOOL fFilterGroups;
    PMSV1_0_INTERACTIVE_LOGON Authentication = NULL;
    DWORD Size;
    ULONG i;
    ULONG j;
    PWSTR AltName, AltNameScan;

    Status = LsapImpersonateClient();

    if ( !NT_SUCCESS( Status ) )
    {
        return Status ;
    }

    //
    // Open the token for the lifetime of this call.  This makes sure that the
    // client doesn't die on us, taking out the logon session (potentially).
    //

    Status = NtOpenThreadToken(
                NtCurrentThread(),
                TOKEN_QUERY,
                TRUE,
                &hToken );

    RevertToSelf();

    if ( !NT_SUCCESS( Status ) )
    {
        return Status ;
    }

    //
    // Grovel the token, and build up a list of groups that we will use for
    // the new token.  Only non-builtin groups will be used.
    //

    TokenInfo = (PLSA_TOKEN_INFORMATION_V1) LsapAllocateLsaHeap(
                                    sizeof( LSA_TOKEN_INFORMATION_V1) );

    if ( !TokenInfo )
    {
        Status = STATUS_NO_MEMORY ;

        goto Clone_Exit ;
    }

    Status = NtQueryInformationToken(
                hToken,
                TokenStatistics,
                &TokenStats,
                sizeof( TokenStats ),
                &Size );

    if ( !NT_SUCCESS( Status ) )
    {
        goto Clone_Exit ;
    }

    TokenInfo->ExpirationTime = TokenStats.ExpirationTime ;

    User = (PTOKEN_USER) SmallBuffer ;
    Size = sizeof( SmallBuffer );

    Status = NtQueryInformationToken(
                hToken,
                TokenUser,
                User,
                Size,
                &Size );

    if ( ( Status == STATUS_BUFFER_OVERFLOW ) ||
         ( Status == STATUS_BUFFER_TOO_SMALL ) )
    {
        SafeAllocaAllocate(User, Size);

        if ( User )
        {
            Status = NtQueryInformationToken(
                        hToken,
                        TokenUser,
                        User,
                        Size,
                        &Size );
        }
        else
        {
            Status = STATUS_NO_MEMORY ;
        }

    }

    if ( !NT_SUCCESS( Status ) )
    {
        goto Clone_Exit ;
    }


    TokenInfo->User.User.Attributes = 0 ;
    TokenInfo->User.User.Sid = LsapAllocateLsaHeap( RtlLengthSid( User->User.Sid ) );

    if ( TokenInfo->User.User.Sid )
    {
        RtlCopyMemory( TokenInfo->User.User.Sid,
                       User->User.Sid,
                       RtlLengthSid( User->User.Sid ) );
    }
    else
    {
        Status = STATUS_NO_MEMORY ;

        goto Clone_Exit ;
    }

    if ( User != (PTOKEN_USER) SmallBuffer )
    {
        SafeAllocaFree( User );
    }

    User = NULL ;

    Status = NtQueryInformationToken(
                    hToken,
                    TokenGroups,
                    NULL,
                    0,
                    &Size );

    if ( ( Status != STATUS_BUFFER_OVERFLOW ) &&
         ( Status != STATUS_BUFFER_TOO_SMALL ) )
    {
        goto Clone_Exit ;
    }

    SafeAllocaAllocate(Groups, Size);

    if ( !Groups )
    {
        Status = STATUS_NO_MEMORY ;

        goto Clone_Exit ;
    }

    Status = NtQueryInformationToken(
                    hToken,
                    TokenGroups,
                    Groups,
                    Size,
                    &Size );

    if ( !NT_SUCCESS( Status ) )
    {
        goto Clone_Exit ;
    }

    //
    // Grovel through the group list, and ditch those we don't care about.
    // i always travels ahead of j.  Skip groups that have one or two RIDs,
    // because those are the builtin ones.
    //

    FinalGroups = (PTOKEN_GROUPS) LsapAllocatePrivateHeap( sizeof( TOKEN_GROUPS ) +
                                                       Groups->GroupCount * sizeof( SID_AND_ATTRIBUTES ) );

    if ( !FinalGroups )
    {
        goto Clone_Exit ;
    }

    //
    // Don't filter out groups for tokens where the LSA has hardcoded info on
    // how to build the token.  If we filter in those cases, we strip out SIDs
    // that won't be replaced by the LSA policy/filter routines later on.
    //

    fFilterGroups = !RtlEqualLuid(&TokenStats.AuthenticationId, &LocalSystemLuid) &&
                    !RtlEqualLuid(&TokenStats.AuthenticationId, &LocalServiceLuid) &&
                    !RtlEqualLuid(&TokenStats.AuthenticationId, &NetworkServiceLuid);

    for ( i = 0, j = 0  ; i < Groups->GroupCount ; i++ )
    {
        if ( !fFilterGroups || *RtlSubAuthorityCountSid( Groups->Groups[ i ].Sid ) > 2 )
        {
            FinalGroups->Groups[ j ].Attributes = Groups->Groups[ i ].Attributes ;
            Status = LsapDuplicateSid2( &FinalGroups->Groups[ j ].Sid,
                                       Groups->Groups[ i ].Sid );
            j++ ;

            if( !NT_SUCCESS(Status) )
            {
                break;
            }
        }
    }

    FinalGroups->GroupCount = j ;

    if ( !NT_SUCCESS( Status ) )
    {
        goto Clone_Exit ;
    }


    //
    // whew.  Set this in the token info, and null out the other pointer
    // so we don't free it inadvertantly.
    //

    TokenInfo->Groups = FinalGroups ;

    FinalGroups = NULL ;

    //
    // Determine the primary group:
    //


    PrimaryGroup = (PTOKEN_PRIMARY_GROUP) SmallBuffer ;
    Size = sizeof( SmallBuffer );

    Status = NtQueryInformationToken(
                hToken,
                TokenPrimaryGroup,
                PrimaryGroup,
                Size,
                &Size );

    if ( ( Status == STATUS_BUFFER_OVERFLOW ) ||
         ( Status == STATUS_BUFFER_TOO_SMALL ) )
    {
        SafeAllocaAllocate(PrimaryGroup, Size);

        Status = NtQueryInformationToken(
                    hToken,
                    TokenPrimaryGroup,
                    PrimaryGroup,
                    Size,
                    &Size );
    }

    if ( !NT_SUCCESS( Status ) )
    {
        goto Clone_Exit ;
    }

    TokenInfo->PrimaryGroup.PrimaryGroup = LsapAllocateLsaHeap(RtlLengthSid(PrimaryGroup->PrimaryGroup));

    if ( TokenInfo->PrimaryGroup.PrimaryGroup )
    {
        RtlCopyMemory( TokenInfo->PrimaryGroup.PrimaryGroup,
                       PrimaryGroup->PrimaryGroup,
                       RtlLengthSid( PrimaryGroup->PrimaryGroup ) );
    }
    else
    {
        Status = STATUS_NO_MEMORY ;

        goto Clone_Exit ;
    }

    if ( PrimaryGroup != (PTOKEN_PRIMARY_GROUP) SmallBuffer )
    {
        SafeAllocaFree(PrimaryGroup);
    }

    PrimaryGroup = NULL ;

    //
    // Almost there -- now dupe the privileges.
    //

    TokenInfo->Privileges = NULL ;

    Size = 0;

    Status = NtQueryInformationToken(
                hToken,
                TokenPrivileges,
                TokenInfo->Privileges,
                Size,
                &Size );

    if ( ( Status == STATUS_BUFFER_OVERFLOW ) ||
         ( Status == STATUS_BUFFER_TOO_SMALL ) )
    {
        TokenInfo->Privileges = (PTOKEN_PRIVILEGES) LsapAllocateLsaHeap(Size);

        if (TokenInfo->Privileges == NULL)
        {
            Status = STATUS_NO_MEMORY;
        }
        else
        {
            Status = NtQueryInformationToken(
                        hToken,
                        TokenPrivileges,
                        TokenInfo->Privileges,
                        Size,
                        &Size);
        }
    }

    if ( !NT_SUCCESS( Status ) )
    {
        goto Clone_Exit ;
    }


    //
    // Ok, we have completed the Token Information.  Now, we need to parse
    // the supplied buffer to come up with creds for the other packages, since
    // that's what this is all about
    //

    Status = NegpMapLogonRequest(
                    ProtocolSubmitBuffer,
                    ClientBufferBase,
                    SubmitBufferSize,
                    &Authentication );

    if ( !NT_SUCCESS( Status ) )
    {
        goto Clone_Exit ;
    }

    //
    // Stuff the names:
    //

    *AccountName = (PUNICODE_STRING) LsapAllocateLsaHeap( sizeof( UNICODE_STRING ) );

    if ( ! ( *AccountName ) )
    {
        Status = STATUS_NO_MEMORY ;

        goto Clone_Exit ;
    }

    *AuthenticatingAuthority = (PUNICODE_STRING) LsapAllocateLsaHeap( sizeof( UNICODE_STRING ) );

    if ( ! ( *AuthenticatingAuthority ) )
    {
        Status = STATUS_NO_MEMORY ;

        goto Clone_Exit ;
    }

    *MachineName = (PUNICODE_STRING) LsapAllocateLsaHeap( sizeof( UNICODE_STRING ) );

    if ( ! ( *MachineName ) )
    {
        Status = STATUS_NO_MEMORY ;

        goto Clone_Exit ;
    }

    //
    // Tokens that the LSA normally constructs (SYSTEM, LocalService, NetworkService)
    // have special names for returned as part of SID --> name lookups that don't
    // necessarily match what's in the token as the account/authority names.  Cruft
    // up the new token with these special names instead of the standard ones.
    //

    if (fFilterGroups)
    {
        Status = LsapGetLogonSessionAccountInfo(
                    &TokenStats.AuthenticationId,
                    (*AccountName),
                    (*AuthenticatingAuthority) );
    }
    else
    {
        LSAP_WELL_KNOWN_SID_INDEX dwIndex = LsapLocalSystemSidIndex;

        if (RtlEqualLuid(&TokenStats.AuthenticationId, &LocalServiceLuid))
        {
            dwIndex = LsapLocalServiceSidIndex;
        }
        else if (RtlEqualLuid(&TokenStats.AuthenticationId, &NetworkServiceLuid))
        {
            dwIndex = LsapNetworkServiceSidIndex;
        }

        Status = LsapDuplicateString(*AccountName,
                                     LsapDbWellKnownSidName(dwIndex));

        if ( !NT_SUCCESS( Status ) )
        {
            goto Clone_Exit ;
        }

        Status = LsapDuplicateString(*AuthenticatingAuthority,
                                     LsapDbWellKnownSidDescription(dwIndex));
    }

    if ( !NT_SUCCESS( Status ) )
    {
        goto Clone_Exit ;
    }

    //
    // Construct the credential data to pass on to the other packages:
    //

    Status = LsapDuplicateString( &PrimaryCredentials->DomainName,
                                  &Authentication->LogonDomainName );

    if ( !NT_SUCCESS( Status ) )
    {
        goto Clone_Exit ;
    }

    Status = LsapDuplicateString( &PrimaryCredentials->DownlevelName,
                                  &Authentication->UserName );

    if ( !NT_SUCCESS( Status ) )
    {
        goto Clone_Exit ;
    }

    Status = LsapDuplicateString( &PrimaryCredentials->Password,
                                  &Authentication->Password );

    if ( !NT_SUCCESS( Status ) )
    {
        goto Clone_Exit ;
    }

    Status = LsapDuplicateSid( &PrimaryCredentials->UserSid,
                               TokenInfo->User.User.Sid );

    if ( !NT_SUCCESS( Status ) )
    {
        goto Clone_Exit ;
    }

    PrimaryCredentials->Flags = PRIMARY_CRED_CLEAR_PASSWORD ;


    //
    // Let the LSA do the rest:
    //

    NtAllocateLocallyUniqueId( &LogonId );

    Status = LsapCreateLogonSession( &LogonId );

    if ( !NT_SUCCESS( Status ) )
    {
        goto Clone_Exit ;
    }

    //
    // save away username and domainname for auditing
    //

    LogonSession = LsapLocateLogonSession( &LogonId );

    if (LogonSession == NULL)
    {
        ASSERT(LogonSession != NULL);
        Status = STATUS_NO_SUCH_LOGON_SESSION;
        goto Clone_Exit;
    }

    Status = LsapDuplicateString( &LogonSession->NewAuthorityName,
                &Authentication->LogonDomainName );

    if ( !NT_SUCCESS( Status ) )
    {
        goto Clone_Exit ;
    }

    Status = LsapDuplicateString( &LogonSession->NewAccountName,
                &Authentication->UserName );

    if ( !NT_SUCCESS( Status ) )
    {
        goto Clone_Exit ;
    }

    NegLogonSession = NegpBuildLogonSession( &LogonId,
                                             NegPackageId,
                                             NegPackageId );

    if ( !NegLogonSession )
    {
        Status = STATUS_NO_MEMORY ;
        goto Clone_Exit;
    }

    AltName = (PWSTR) LsapAllocatePrivateHeap( Authentication->UserName.Length +
                                               Authentication->LogonDomainName.Length +
                                               2 * sizeof( WCHAR ) );

    if ( AltName )
    {
        AltNameScan = AltName ;
        RtlCopyMemory( AltNameScan,
                       Authentication->LogonDomainName.Buffer,
                       Authentication->LogonDomainName.Length );

        AltNameScan += Authentication->LogonDomainName.Length / sizeof(WCHAR) ;

        *AltNameScan++ = L'\\';

        RtlCopyMemory( AltNameScan,
                       Authentication->UserName.Buffer,
                       Authentication->UserName.Length );

        AltNameScan += Authentication->UserName.Length / sizeof( WCHAR ) ;

        *AltNameScan++ = L'\0';

        RtlInitUnicodeString( &NegLogonSession->AlternateName, AltName );
    }

    NegLogonSession->ParentLogonId = TokenStats.AuthenticationId ;

    NegpDerefLogonSession( NegLogonSession );

    PrimaryCredentials->LogonId = LogonId ;

    *ProfileBuffer = NULL ;

    *ProfileBufferLength = 0 ;

    *NewLogonId = LogonId ;

    *ApiSubStatus = STATUS_SUCCESS ;

    *TokenInformationType = LsaTokenInformationV1 ;

    *TokenInformation = TokenInfo ;

    TokenInfo = NULL ;

    *CachedCredentials = NULL ;


Clone_Exit:

    SafeAllocaFree(Groups);

    if ( FinalGroups )
    {
        LsapFreeTokenGroups( FinalGroups );
    }

    if ( TokenInfo )
    {
        if ( TokenInfo->User.User.Sid )
        {
            LsapFreeLsaHeap( TokenInfo->User.User.Sid );
        }

        if ( TokenInfo->Groups )
        {
            LsapFreeTokenGroups( TokenInfo->Groups );
        }

        if ( TokenInfo->Privileges )
        {
            LsapFreeLsaHeap( TokenInfo->Privileges );
        }

        LsapFreeLsaHeap( TokenInfo );
    }

    if (User != (PTOKEN_USER) SmallBuffer)
    {
        SafeAllocaFree(User);
    }

    if ( PrimaryGroup != (PTOKEN_PRIMARY_GROUP) SmallBuffer )
    {
        SafeAllocaFree(PrimaryGroup);
    }

    if ( hToken != NULL )
    {
        NtClose( hToken );
    }

    if ( !NT_SUCCESS( Status ) )
    {
        if ( *AuthenticatingAuthority )
        {
            if ( (*AuthenticatingAuthority)->Buffer )
            {
                LsapFreeLsaHeap( (*AuthenticatingAuthority)->Buffer );
            }

            LsapFreeLsaHeap( *AuthenticatingAuthority );
            *AuthenticatingAuthority = NULL;
        }

        if ( *AccountName )
        {
            if ( (*AccountName)->Buffer )
            {
                LsapFreeLsaHeap( (*AccountName)->Buffer );
            }

            LsapFreeLsaHeap( *AccountName );
            *AccountName = NULL;
        }

        if ( *MachineName )
        {
            if ( (*MachineName)->Buffer )
            {
                LsapFreeLsaHeap( (*MachineName)->Buffer );
            }

            LsapFreeLsaHeap( *MachineName );
            *MachineName = NULL;
        }
    }

    if (LogonSession) 
    {
        LsapReleaseLogonSession(LogonSession);
    }

    return Status;
}


//+-------------------------------------------------------------------------
//
//  Function:   NegLogonUserEx2
//
//  Synopsis:   Handles service, batch, and interactive logons
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------
NTSTATUS
NTAPI
NegLogonUserEx2(
    IN PLSA_CLIENT_REQUEST ClientRequest,
    IN SECURITY_LOGON_TYPE LogonType,
    IN PVOID ProtocolSubmitBuffer,
    IN PVOID ClientBufferBase,
    IN ULONG SubmitBufferSize,
    OUT PVOID *ProfileBuffer,
    OUT PULONG ProfileBufferLength,
    OUT PLUID NewLogonId,
    OUT PNTSTATUS ApiSubStatus,
    OUT PLSA_TOKEN_INFORMATION_TYPE TokenInformationType,
    OUT PVOID *TokenInformation,
    OUT PUNICODE_STRING *AccountName,
    OUT PUNICODE_STRING *AuthenticatingAuthority,
    OUT PUNICODE_STRING *MachineName,
    OUT PSECPKG_PRIMARY_CRED PrimaryCredentials,
    OUT PSECPKG_SUPPLEMENTAL_CRED_ARRAY * CachedCredentials
    )
{
    NTSTATUS Status = STATUS_NO_LOGON_SERVERS;
    PNEG_PACKAGE Package;
    PVOID LocalSubmitBuffer = ProtocolSubmitBuffer;
    ULONG_PTR CurrentPackageId = GetCurrentPackageId();
    PLSAP_SECURITY_PACKAGE * LogonPackages = NULL;
    PNEG_LOGON_SESSION LogonSession ;
    PWSTR AltName, AltNameScan ;
    NEG_DOMAIN_TYPES DomainType ;

    ULONG LogonPackageCount = 0;
    ULONG Index;

    if ( LogonType == NewCredentials )
    {
        ULONG  ulTempSize = SubmitBufferSize;

#if _WIN64

        Status = NegpConvertWOWInteractiveLogonBuffer(ProtocolSubmitBuffer,
                                                      ClientBufferBase,
                                                      &ulTempSize,
                                                      &LocalSubmitBuffer);

        if (!NT_SUCCESS(Status))
        {
            return Status;
        }

#endif // _WIN64

        Status = NegpCloneLogonSession(LocalSubmitBuffer,
                                       ClientBufferBase,
                                       ulTempSize,
                                       ProfileBuffer,
                                       ProfileBufferLength,
                                       NewLogonId,
                                       ApiSubStatus,
                                       TokenInformationType,
                                       TokenInformation,
                                       AccountName,
                                       AuthenticatingAuthority,
                                       MachineName,
                                       PrimaryCredentials,
                                       CachedCredentials);

#if _WIN64

        if (ProtocolSubmitBuffer != LocalSubmitBuffer)
        {
            ZeroMemory(LocalSubmitBuffer, ulTempSize);
            LsapFreePrivateHeap(LocalSubmitBuffer);
        }

#endif  // _WIN64

        return Status;
    }


    //
    // Allocate a local copy of the submit buffer so each package can
    // mark it up.
    //

    LocalSubmitBuffer = LsapAllocateLsaHeap(SubmitBufferSize);
    if (LocalSubmitBuffer == NULL)
    {
        return(STATUS_INSUFFICIENT_RESOURCES);
    }


    if ( LogonType == Service )
    {
        ULONG  ulAccountId;

        //
        // Copy the submit buffer for the package to mark up
        //

        RtlCopyMemory(
            LocalSubmitBuffer,
            ProtocolSubmitBuffer,
            SubmitBufferSize
            );

        if (NegpIsLocalOrNetworkService(
                LocalSubmitBuffer,
                ClientBufferBase,
                SubmitBufferSize,
                AccountName,
                AuthenticatingAuthority,
                MachineName,
                &ulAccountId))
        {
            Status = NegpMakeServiceToken(
                        ulAccountId,
                        NewLogonId,
                        ProfileBuffer,
                        ProfileBufferLength,
                        ApiSubStatus,
                        TokenInformationType,
                        TokenInformation,
                        AccountName,
                        AuthenticatingAuthority,
                        MachineName,
                        PrimaryCredentials,
                        CachedCredentials
                        );

            goto Cleanup;
        }
    }

    SafeAllocaAllocate(LogonPackages, NegPackageCount * sizeof(PLSAP_SECURITY_PACKAGE));

    if (LogonPackages == NULL)
    {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto Cleanup;
    }

    NegReadLockList();

    Package = (PNEG_PACKAGE) NegPackageList.Flink ;
    while ( (PVOID) Package != (PVOID) &NegPackageList )
    {
        if (((Package->LsaPackage->fCapabilities & SECPKG_FLAG_LOGON) != 0) &&
            ((Package->Flags & NEG_PACKAGE_EXTRA_OID ) == 0 ) &&
            (Package->LsaPackage->FunctionTable.LogonUserEx2 != NULL))
        {
            LogonPackages[LogonPackageCount++] = Package->LsaPackage;
        }
        Package = (PNEG_PACKAGE) Package->List.Flink ;
    }
    NegUnlockList();

    for (Index = 0; Index < LogonPackageCount; Index++)
    {

        //
        // Cleanup the old audit strings so they don't get leaked
        // when the package re-allocates them.
        //

        if ((*MachineName) != NULL) {
            if ((*MachineName)->Buffer != NULL) {
                LsapFreeLsaHeap( (*MachineName)->Buffer );
            }
            LsapFreeLsaHeap( (*MachineName) );
            (*MachineName) = NULL;
        }
        if ((*AccountName) != NULL) {
            if ((*AccountName)->Buffer != NULL) {
                LsapFreeLsaHeap( (*AccountName)->Buffer );
            }
            LsapFreeLsaHeap( (*AccountName) );
            (*AccountName) = NULL ;
        }

        if ((*AuthenticatingAuthority) != NULL) {
            if ((*AuthenticatingAuthority)->Buffer != NULL) {
                LsapFreeLsaHeap( (*AuthenticatingAuthority)->Buffer );
            }
            LsapFreeLsaHeap( (*AuthenticatingAuthority) );
            (*AuthenticatingAuthority) = NULL ;
        }

        //
        // Copy the submit buffer for the package to mark up
        //

        RtlCopyMemory(
            LocalSubmitBuffer,
            ProtocolSubmitBuffer,
            SubmitBufferSize
            );


        SetCurrentPackageId(LogonPackages[Index]->dwPackageID);

        Status = LogonPackages[Index]->FunctionTable.LogonUserEx2(
                                    ClientRequest,
                                    LogonType,
                                    LocalSubmitBuffer,
                                    ClientBufferBase,
                                    SubmitBufferSize,
                                    ProfileBuffer,
                                    ProfileBufferLength,
                                    NewLogonId,
                                    ApiSubStatus,
                                    TokenInformationType,
                                    TokenInformation,
                                    AccountName,
                                    AuthenticatingAuthority,
                                    MachineName,
                                    PrimaryCredentials,
                                    CachedCredentials
                                    );
        SetCurrentPackageId(CurrentPackageId);

        //
        // Bug 226401 If the local machine secret is different from the
        // machine account password, kerberos can't decrpyt the workstation
        // ticket and returns STATUS_TRUSTED_RELATIONSHIP_FAILURE (used to
        // return STATUS_TRUST_FAILURE). If this is a DC, we
        // should fall back to NTLM.
        //

        if (Status == STATUS_TRUST_FAILURE ||
            Status == STATUS_TRUSTED_RELATIONSHIP_FAILURE)
        {
            if (NegMachineState & SECPKG_STATE_DOMAIN_CONTROLLER)
            {
                Status = STATUS_NO_LOGON_SERVERS;
            }
        }


        if ((Status != STATUS_NO_LOGON_SERVERS) &&
            (Status != STATUS_NETLOGON_NOT_STARTED) &&
            (Status != SEC_E_NO_AUTHENTICATING_AUTHORITY) &&
            (Status != SEC_E_ETYPE_NOT_SUPP) &&
            (Status != STATUS_KDC_UNKNOWN_ETYPE) &&
            (Status != STATUS_NO_TRUST_SAM_ACCOUNT) &&
            (Status != STATUS_INVALID_PARAMETER) &&
            (Status != STATUS_INVALID_LOGON_TYPE) &&
            (Status != STATUS_INVALID_INFO_CLASS ) &&
            (Status != STATUS_NETWORK_UNREACHABLE) &&
            (Status != STATUS_BAD_VALIDATION_CLASS) )
        {
            break;
        }

    }

    if ( NT_SUCCESS( Status ) )
    {
        LogonSession = NegpBuildLogonSession(
                            NewLogonId,
                            LogonPackages[ Index ]->dwPackageID,
                            LogonPackages[ Index ]->dwPackageID );

        if ( LogonSession )
        {
            if ( LogonPackages[ Index ]->dwRPCID == NTLMSP_RPCID )
            {
                DebugLog(( DEB_TRACE_NEG, "NTLM Logon\n" ));

                //
                // Check if this is an uplevel or downlevel domain
                //

                DomainType =  NegpIsUplevelDomain( NewLogonId, LogonType, *AuthenticatingAuthority );

                if( DomainType == NegLocalDomain )
                {
                    //
                    // change from Win2k:
                    // allow full negotiation range by default for local logons.
                    // Kerberos now quickly fails local account originated operations.
                    //

                    LogonSession->DefaultPackage = NegPackageId ;
                }

                if ( DomainType == NegUpLevelDomain )
                {
                    if( (LogonType == CachedInteractive) &&
                       ((PrimaryCredentials->Flags >> PRIMARY_CRED_LOGON_PACKAGE_SHIFT) == NTLMSP_RPCID)
                        )
                    {
                        //
                        // leave the package as NTLM.
                        //

                    } else {
                        LogonSession->DefaultPackage = NEG_INVALID_PACKAGE ;
                    }
                }
                else if ( DomainType == NegUpLevelTrustedDomain )
                {
                    LogonSession->DefaultPackage = NegPackageId ;
                }
                else
                {
                    //
                    // leave the DefaultPackage as NTLM.
                    //

                    NOTHING;
                }

            }

            //
            // Create the name:
            //


            AltName = (PWSTR) LsapAllocatePrivateHeap(
                                                (*AccountName)->Length +
                                                (*AuthenticatingAuthority)->Length +
                                                2 * sizeof( WCHAR ) );

            if ( AltName )
            {
                AltNameScan = AltName ;
                RtlCopyMemory( AltNameScan,
                               (*AuthenticatingAuthority)->Buffer,
                               (*AuthenticatingAuthority)->Length );

                AltNameScan += (*AuthenticatingAuthority)->Length / sizeof(WCHAR) ;

                *AltNameScan++ = L'\\';

                RtlCopyMemory( AltNameScan,
                               (*AccountName)->Buffer,
                               (*AccountName)->Length );

                AltNameScan += (*AccountName)->Length / sizeof( WCHAR ) ;

                *AltNameScan++ = L'\0';

                RtlInitUnicodeString( &LogonSession->AlternateName, AltName );
            }

            NegpDerefLogonSession( LogonSession );
        }

    }


Cleanup:

    SafeAllocaFree(LogonPackages);

    if( LocalSubmitBuffer )
    {
        ZeroMemory(LocalSubmitBuffer, SubmitBufferSize);
        LsapFreeLsaHeap(LocalSubmitBuffer);
    }

    return(Status);

}


//+-------------------------------------------------------------------------
//
//  Function:   NegpMakeServiceToken
//
//  Synopsis:   Handles the logon for LocalService and NetworkService
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:      On error, this routine frees the buffers allocated by
//              the prior call to NegpIsLocalOrNetworkService
//
//--------------------------------------------------------------------------

NTSTATUS
NegpMakeServiceToken(
    IN ULONG ulAccountId,
    OUT PLUID pLogonId,
    OUT PVOID *ProfileBuffer,
    OUT PULONG ProfileBufferLength,
    OUT PNTSTATUS ApiSubStatus,
    OUT PLSA_TOKEN_INFORMATION_TYPE TokenInformationType,
    OUT PVOID *TokenInformation,
    OUT PUNICODE_STRING *AccountName,
    OUT PUNICODE_STRING *AuthenticatingAuthority,
    OUT PUNICODE_STRING *MachineName,
    OUT PSECPKG_PRIMARY_CRED PrimaryCredentials,
    OUT PSECPKG_SUPPLEMENTAL_CRED_ARRAY * CachedCredentials
    )
{
    NTSTATUS Status;
    LPBYTE   pBuffer;
    UINT     i;
    ULONG    ulTokenLength = 0;
    PSID     Owner;
    PSID     UserSid;
    ULONG    DaclLength;
    PACL     pDacl;
    DWORD    dwSidLen;
    HMODULE  hStringsResource;
    LUID     SystemId = SYSTEM_LUID;

    PTOKEN_GROUPS              pGroups;
    PSID_AND_ATTRIBUTES        pSidAndAttrs;
    TIME_FIELDS                TimeFields;
    SECPKG_CLIENT_INFO         ClientInfo;
    SID_IDENTIFIER_AUTHORITY   IdentifierAuthority = SECURITY_NT_AUTHORITY;
    PLSA_TOKEN_INFORMATION_V2  pTokenInfo = NULL;
    PLSAP_LOGON_SESSION        pLogonSession = NULL;
    SAMPR_PSID_ARRAY           SidArray;
    SAMPR_SID_INFORMATION      SidInfo;
    PSAMPR_PSID_ARRAY          ResourceGroups = NULL;

    //
    // Don't allow untrusted clients to call this API.
    //

    Status = LsapGetClientInfo(&ClientInfo);

    if (!NT_SUCCESS(Status))
    {
        goto ErrorExit;
    }

    if (!RtlEqualLuid(&ClientInfo.LogonId, &SystemId))
    {
        Status = STATUS_ACCESS_DENIED;
        goto ErrorExit;
    }

    if (ulAccountId == LSAP_SID_NAME_LOCALSERVICE)
    {
        LUID LocalServiceId = LOCALSERVICE_LUID;
        UNICODE_STRING EmptyString = {0, 0, NULL};

        UserSid = LsapLocalServiceSid;
        PrimaryCredentials->LogonId = LocalServiceId;
        *pLogonId = LocalServiceId;

        Status = LsapDuplicateSid(&PrimaryCredentials->UserSid,
                                  UserSid);

        if (!NT_SUCCESS(Status))
        {
            goto ErrorExit;
        }

        Status = LsapDuplicateString(&PrimaryCredentials->DomainName,
                                     &EmptyString);

        if (!NT_SUCCESS(Status))
        {
            goto ErrorExit;
        }

        Status = LsapDuplicateString(&PrimaryCredentials->DownlevelName,
                                     &EmptyString);

        if (!NT_SUCCESS(Status))
        {
            goto ErrorExit;
        }

        Status = LsapDuplicateString(&PrimaryCredentials->Password,
                                     &EmptyString);

        if (!NT_SUCCESS(Status))
        {
            goto ErrorExit;
        }
    }
    else
    {
        LUID NetworkServiceId = NETWORKSERVICE_LUID;

        ASSERT( ulAccountId == LSAP_SID_NAME_NETWORKSERVICE );

        UserSid = LsapNetworkServiceSid;

        RtlEnterCriticalSection(&NegComputerNamesLock);

        Status = NegpCopyCredsToBuffer(&NegPrimarySystemCredentials,
                                       NULL,
                                       PrimaryCredentials,
                                       NULL);

        RtlLeaveCriticalSection(&NegComputerNamesLock);

        if (!NT_SUCCESS(Status))
        {
            goto ErrorExit;
        }

        PrimaryCredentials->LogonId = NetworkServiceId;
        *pLogonId = NetworkServiceId;

        Status = LsapDuplicateSid(&PrimaryCredentials->UserSid,
                                  UserSid);

        if (!NT_SUCCESS(Status))
        {
            goto ErrorExit;
        }
    }

    *CachedCredentials = NULL;

    ASSERT(UserSid != NULL);

    //
    // Make sure there's a logon session for this account
    //

    pLogonSession = LsapLocateLogonSession(pLogonId);

    if (pLogonSession == NULL)
    {
        Status = LsapCreateLogonSession(pLogonId);

        pLogonSession = LsapLocateLogonSession(pLogonId);

        if( pLogonSession == NULL )
        {
            if (!NT_SUCCESS(Status))
            {
                goto ErrorExit;
            }

            ASSERT(pLogonSession != NULL);
            Status = STATUS_NO_SUCH_LOGON_SESSION;
            goto ErrorExit;
        }

        Status = STATUS_SUCCESS;
    }


    //
    // Compute the length of the default DACL for the token
    //

    DaclLength = (ULONG) sizeof(ACL)
                     + 2 * ((ULONG) sizeof(ACCESS_ALLOWED_ACE) - sizeof(ULONG))
                     + RtlLengthSid( LsapLocalSystemSid )
                     + RtlLengthSid( UserSid );

    //
    // Make sure SAM has been opened.
    //

    Status = LsapAuOpenSam( FALSE );

    if (!NT_SUCCESS(Status))
    {
        goto ErrorExit;
    }

    //
    // Expand out the account domain group information from the SAM.  Builtin
    // domain expansion will be done by the LSA's logon filter routines.
    //

    SidInfo.SidPointer = (PRPC_SID) UserSid;
    SidArray.Count     = 1;
    SidArray.Sids      = &SidInfo;

    Status = SamIGetResourceGroupMembershipsTransitive(LsapAccountDomainHandle,
                                                       &SidArray,
                                                       0,
                                                       &ResourceGroups);

    if (!NT_SUCCESS(Status))
    {
        goto ErrorExit;
    }

    for (i = 0; i < ResourceGroups->Count; i++)
    {
        ulTokenLength += RtlLengthSid(ResourceGroups->Sids[i].SidPointer);
    }

#define NUM_INHERENT_TOKEN_GROUPS   1

    //
    // The SIDs are 4-byte aligned so this shouldn't cause problems
    // with unaligned accesses (as long as the DACL stays at the
    // end of the buffer).
    //

    ulTokenLength += sizeof(LSA_TOKEN_INFORMATION_V2)
                          + RtlLengthSid( UserSid )            // User
                          + sizeof(TOKEN_GROUPS) - sizeof(SID_AND_ATTRIBUTES)
                          + NUM_INHERENT_TOKEN_GROUPS * sizeof(SID_AND_ATTRIBUTES)
                          + ResourceGroups->Count * sizeof(SID_AND_ATTRIBUTES)
                          + RtlLengthSid( UserSid )            // Primary group
                          + RtlLengthSid( LsapAliasUsersSid )
                          + RtlLengthSid( UserSid )            // Owner
                          + DaclLength;                        // DefaultDacl


    pTokenInfo = (PLSA_TOKEN_INFORMATION_V2) LsapAllocateLsaHeap(ulTokenLength);

    if (pTokenInfo == NULL)
    {
        Status = STATUS_NO_MEMORY;
        goto ErrorExit;
    }

    //
    // Set up expiration time
    //

    TimeFields.Year = 3000;
    TimeFields.Month = 1;
    TimeFields.Day = 1;
    TimeFields.Hour = 1;
    TimeFields.Minute = 1;
    TimeFields.Second = 1;
    TimeFields.Milliseconds = 1;
    TimeFields.Weekday = 1;

    RtlTimeFieldsToTime( &TimeFields, &pTokenInfo->ExpirationTime );

    //
    // Set up the groups -- do this first so the nested pointers
    // don't cause 64-bit alignment faults
    //

    pGroups      = (PTOKEN_GROUPS) (pTokenInfo + 1);
    pSidAndAttrs = pGroups->Groups;
    pBuffer      = (LPBYTE) (pSidAndAttrs + NUM_INHERENT_TOKEN_GROUPS + ResourceGroups->Count);

    pGroups->GroupCount = NUM_INHERENT_TOKEN_GROUPS + ResourceGroups->Count;

    //
    // Add the Inherent token groups
    //
    // Add the Users alias because of a timing window after a DC demote.  The SCE makes
    // Authenticated Users a member of the Users alias on the first boot after the DC demote.
    // However, by that time, the local service token will already have been created.
    // Unfortunately, except for that timing window, the following code results in a duplicate
    // Users alias sid being in the token.
    //

    dwSidLen = RtlLengthSid(LsapAliasUsersSid);
    RtlCopySid(dwSidLen, pBuffer, LsapAliasUsersSid);
    pSidAndAttrs[0].Sid = (PSID) pBuffer;
    pBuffer += dwSidLen;
    pSidAndAttrs[0].Attributes = (SE_GROUP_MANDATORY          |
                                  SE_GROUP_ENABLED_BY_DEFAULT |
                                  SE_GROUP_ENABLED);

    //
    // Add the resource groups
    //

    for (i = 0; i < ResourceGroups->Count; i++)
    {
        dwSidLen = RtlLengthSid(ResourceGroups->Sids[i].SidPointer);
        RtlCopySid(dwSidLen, pBuffer, ResourceGroups->Sids[i].SidPointer);

        pSidAndAttrs[i+NUM_INHERENT_TOKEN_GROUPS].Sid        = (PSID) pBuffer;
        pSidAndAttrs[i+NUM_INHERENT_TOKEN_GROUPS].Attributes = (SE_GROUP_MANDATORY          |
                                                                SE_GROUP_ENABLED_BY_DEFAULT |
                                                                SE_GROUP_ENABLED);

        pBuffer += dwSidLen;
    }

#undef NUM_INHERENT_TOKEN_GROUPS


    SamIFreeSidArray(ResourceGroups);
    ResourceGroups = NULL;

    pTokenInfo->Groups = pGroups;


    //
    // Set up the user ID
    //

    dwSidLen = RtlLengthSid(UserSid);
    RtlCopySid(dwSidLen, (PSID) pBuffer, UserSid);
    pTokenInfo->User.User.Sid        = (PSID) pBuffer;
    pTokenInfo->User.User.Attributes = 0;
    pBuffer += dwSidLen;


    //
    // Establish the primary group
    //

    dwSidLen = RtlLengthSid(UserSid);
    RtlCopySid(dwSidLen, (PSID) pBuffer, UserSid);
    pTokenInfo->PrimaryGroup.PrimaryGroup = (PSID) pBuffer;
    pBuffer += dwSidLen;

    //
    // Set the default owner
    //

    dwSidLen = RtlLengthSid(UserSid);
    RtlCopySid(dwSidLen, (PSID) pBuffer, UserSid);
    pTokenInfo->Owner.Owner = (PSID) pBuffer;
    pBuffer += dwSidLen;


    //
    // Privileges -- none by default (set by policy)
    //

    pTokenInfo->Privileges = NULL;

    //
    // Set up the default DACL for token.  Give system full reign of terror.
    //

    pDacl = (PACL) pBuffer;

    Status = RtlCreateAcl(pDacl, DaclLength, ACL_REVISION2);
    ASSERT( NT_SUCCESS(Status) );

    Status = RtlAddAccessAllowedAce(pDacl,
                                    ACL_REVISION2,
                                    GENERIC_ALL,
                                    LsapLocalSystemSid);

    ASSERT( NT_SUCCESS(Status) );

    Status = RtlAddAccessAllowedAce(pDacl,
                                    ACL_REVISION2,
                                    GENERIC_ALL,
                                    UserSid);

    ASSERT( NT_SUCCESS(Status) );

    RtlCopyMemory(pBuffer, pDacl, DaclLength);

    pTokenInfo->DefaultDacl.DefaultDacl = (PACL) pBuffer;

    pBuffer += DaclLength;

    ASSERT( (ULONG)(ULONG_PTR)(pBuffer - (LPBYTE) pTokenInfo) == ulTokenLength );

    //
    // Now fill in the out parameters
    //

    //
    // LocalService/NetworkService have no profile
    //

    *ProfileBuffer        = NULL;
    *ProfileBufferLength  = 0;
    *TokenInformationType = LsaTokenInformationV2;
    *TokenInformation     = pTokenInfo;

    LsapReleaseLogonSession(pLogonSession);

    *ApiSubStatus = STATUS_SUCCESS;
    return STATUS_SUCCESS;

ErrorExit:

    if (*AuthenticatingAuthority)
    {
        LsapFreeLsaHeap((*AuthenticatingAuthority)->Buffer);
        LsapFreeLsaHeap(*AuthenticatingAuthority);
        *AuthenticatingAuthority = NULL;
    }

    if (*AccountName)
    {
        LsapFreeLsaHeap((*AccountName)->Buffer);
        LsapFreeLsaHeap(*AccountName);
        *AccountName = NULL;
    }

    if (*MachineName)
    {
        LsapFreeLsaHeap((*MachineName)->Buffer);
        LsapFreeLsaHeap(*MachineName);
        *MachineName = NULL;
    }

    LsapFreeLsaHeap(PrimaryCredentials->UserSid);
    PrimaryCredentials->UserSid = NULL;

    LsapFreeLsaHeap(PrimaryCredentials->DomainName.Buffer);
    RtlZeroMemory(&PrimaryCredentials->DomainName, sizeof(UNICODE_STRING));

    LsapFreeLsaHeap(PrimaryCredentials->DownlevelName.Buffer);
    RtlZeroMemory(&PrimaryCredentials->DownlevelName, sizeof(UNICODE_STRING));

    LsapFreeLsaHeap(PrimaryCredentials->Password.Buffer);
    RtlZeroMemory(&PrimaryCredentials->Password, sizeof(UNICODE_STRING));

    SamIFreeSidArray(ResourceGroups);

    if (pLogonSession)
    {
        LsapReleaseLogonSession(pLogonSession);
    }

    LsapFreeLsaHeap(pTokenInfo);

    *ApiSubStatus = Status;
    return Status;
}


//+-------------------------------------------------------------------------
//
//  Function:   NegpIsLocalOrNetworkService
//
//  Synopsis:   Allocates memory for the account name, machine name,
//              and authenticating authority for LocalService and
//              NetworkService logons
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:      The caller is responsible for freeing the allocated
//              buffers if this routine succeeds
//
//--------------------------------------------------------------------------

BOOL
NegpIsLocalOrNetworkService(
    IN PVOID ProtocolSubmitBuffer,
    IN PVOID ClientBufferBase,
    IN ULONG SubmitBufferSize,
    OUT PUNICODE_STRING *AccountName,
    OUT PUNICODE_STRING *AuthenticatingAuthority,
    OUT PUNICODE_STRING *MachineName,
    OUT PULONG pulAccountId
    )
{
    NTSTATUS  Status;

    PUNICODE_STRING  pTempAccount;
    PUNICODE_STRING  pTempAuthority;

    PMSV1_0_INTERACTIVE_LOGON  Authentication = NULL;


    *AccountName = NULL;
    *AuthenticatingAuthority = NULL;
    *MachineName = NULL;

    //
    // Parse the supplied buffer to come up with creds
    //

    Status = NegpMapLogonRequest(
                    ProtocolSubmitBuffer,
                    ClientBufferBase,
                    SubmitBufferSize,
                    &Authentication);

    if (!NT_SUCCESS(Status))
    {
        goto ErrorExit ;
    }


    //
    // Get the info to compare for LocalService first.  Check both the
    // localized version and the non-localized version (which could come
    // from the registry).
    //

    pTempAuthority = &WellKnownSids[LsapLocalServiceSidIndex].DomainName;
    pTempAccount   = &WellKnownSids[LsapLocalServiceSidIndex].Name;

    if (RtlCompareUnicodeString(&NTAuthorityName,
                                &Authentication->LogonDomainName,
                                TRUE) == 0)
    {
        //
        // Hardcoded "NT AUTHORITY" -- check hardcoded
        // "LocalService" and "NetworkService" and
        // localize it here on a match.
        //

        if (RtlCompareUnicodeString(&LocalServiceName,
                                    &Authentication->UserName,
                                    TRUE) == 0)
        {
            pTempAccount = &WellKnownSids[LsapLocalServiceSidIndex].Name;
            *pulAccountId = LSAP_SID_NAME_LOCALSERVICE;
            Status = STATUS_SUCCESS;
        }
        else if (RtlCompareUnicodeString(&NetworkServiceName,
                                         &Authentication->UserName,
                                         TRUE) == 0)
        {
            pTempAccount = &WellKnownSids[LsapNetworkServiceSidIndex].Name;
            *pulAccountId = LSAP_SID_NAME_NETWORKSERVICE;
            Status = STATUS_SUCCESS;
        }
        else
        {
            Status = STATUS_NO_SUCH_USER;
        }
    }
    else
    {
        Status = STATUS_NO_SUCH_USER;
    }


    //
    // Hardcoded comparison failed -- try localized versions.  Note that
    // we have to check again (rather than using an "else" with the "if"
    // above) since "NT AUTHORITY" may be both the hardcoded and the
    // localized name (e.g., in English).  Since Status is already a
    // failure code, let the failure cases trickle through.
    //

    if (!NT_SUCCESS(Status))
    {
        if (RtlCompareUnicodeString(pTempAuthority,
                                    &Authentication->LogonDomainName,
                                    TRUE) == 0)
        {
            //
            // Localized "NT AUTHORITY" -- check localized
            // "LocalService" and "NetworkService"
            //

            pTempAccount = &WellKnownSids[LsapLocalServiceSidIndex].Name;

            if (RtlCompareUnicodeString(pTempAccount,
                                        &Authentication->UserName,
                                        TRUE) == 0)
            {
                *pulAccountId = LSAP_SID_NAME_LOCALSERVICE;
                Status = STATUS_SUCCESS;
            }
            else
            {
                pTempAccount = &WellKnownSids[LsapNetworkServiceSidIndex].Name;

                if (RtlCompareUnicodeString(pTempAccount,
                                            &Authentication->UserName,
                                            TRUE) == 0)
                {
                    *pulAccountId = LSAP_SID_NAME_NETWORKSERVICE;
                    Status = STATUS_SUCCESS;
                }
                else
                {
                    Status = STATUS_NO_SUCH_USER;
                }
            }
        }
        else
        {
            Status = STATUS_NO_SUCH_USER;
        }
    }

    if (!NT_SUCCESS(Status))
    {
        goto ErrorExit;
    }


    //
    // Stuff the names:
    //

    *AccountName = (PUNICODE_STRING) LsapAllocateLsaHeap(sizeof(UNICODE_STRING));

    if (!(*AccountName))
    {
        Status = STATUS_NO_MEMORY;
        goto ErrorExit;
    }

    Status = LsapDuplicateString(*AccountName,
                                 pTempAccount);

    if (!NT_SUCCESS(Status))
    {
        goto ErrorExit;
    }

    *AuthenticatingAuthority = (PUNICODE_STRING) LsapAllocateLsaHeap(sizeof(UNICODE_STRING));

    if (!(*AuthenticatingAuthority))
    {
        Status = STATUS_NO_MEMORY;
        goto ErrorExit;
    }

    Status = LsapDuplicateString(*AuthenticatingAuthority,
                                 pTempAuthority);

    if (!NT_SUCCESS(Status))
    {
        goto ErrorExit;
    }

    *MachineName = (PUNICODE_STRING) LsapAllocateLsaHeap(sizeof(UNICODE_STRING));

    if (!(*MachineName))
    {
        Status = STATUS_NO_MEMORY;
        goto ErrorExit ;
    }

    return TRUE;


ErrorExit:

    if (*AuthenticatingAuthority)
    {
        LsapFreeLsaHeap((*AuthenticatingAuthority)->Buffer);
        LsapFreeLsaHeap(*AuthenticatingAuthority);
        *AuthenticatingAuthority = NULL;
    }

    if (*AccountName)
    {
        LsapFreeLsaHeap((*AccountName)->Buffer);
        LsapFreeLsaHeap(*AccountName);
        *AccountName = NULL;
    }

    if (*MachineName)
    {
        LsapFreeLsaHeap((*MachineName)->Buffer);
        LsapFreeLsaHeap(*MachineName);
        *MachineName = NULL;
    }

    return FALSE;
}

BOOL
NegpRearrangeMechsIfNeccessary(
    struct MechTypeList ** RealMechList,
    PSECURITY_STRING    Target,
    PBOOL               DirectPacket
    )
{
    PWSTR FirstSlash ;
    PWSTR SecondSlash = NULL;
    PNEG_TRUST_LIST TrustList = NULL ;
    UNICODE_STRING TargetHost ;
    UNICODE_STRING SpnPrefix;
    UNICODE_STRING HttpPrefix;
    struct MechTypeList * MechList ;
    struct MechTypeList * Reorder = NULL ;
    struct MechTypeList * Trailer ;
    BOOL Rearranged = FALSE ;
    BOOL HttpSpn = FALSE;
    BOOLEAN PortInstance = FALSE;

    if ( Target == NULL )
    {
        DebugLog(( DEB_TRACE_NEG, "Loopback detected for local target (no targetname)\n"));
        goto loopback;
    }

    if ( Target->Length == 0 )
    {
        DebugLog(( DEB_TRACE_NEG, "Loopback detected for local target (no targetname)\n"));
        goto loopback;
    }

    //
    // Now, examine the target and determine if it is referring to us
    //

    FirstSlash = wcschr( Target->Buffer, L'/' );

    if ( !FirstSlash )
    {
        //
        // Not an SPN, we're out of here
        //

        return FALSE ;
    } else {

       *FirstSlash = L'\0';

    }

    //
    // HACK HACK HACK:  We've got to call NTLM directly in
    // the loopback case, or Wininet can't handle our "extra" nego trips....
    //
    RtlInitUnicodeString(
       &SpnPrefix,
       Target->Buffer
       );

    RtlInitUnicodeString(
       &HttpPrefix,
       L"HTTP"
       );

    if (RtlEqualUnicodeString(
                  &SpnPrefix,
                  &HttpPrefix,
                  TRUE
                  ))
    {
       HttpSpn = TRUE;
       DebugLog((DEB_TRACE_NEG, "Found HTTP SPN, about to force NTLM directly\n"));
    }

    *FirstSlash = L'/';
    // END HACK END HACK

    FirstSlash++ ;

    //
    // if this is a svc/instance:port/domain style SPN, ignore the trailer
    // portion
    // trailer portion can be a port, domain, or both.
    // the port instance will occur first...
    //

    SecondSlash = wcschr( FirstSlash, L':' );

    if ( SecondSlash )
    {
        //
        // found a port instance.
        //

        *SecondSlash = L'\0';
        PortInstance = TRUE;

    } else {

        //
        // look for a realm/domain instance!
        //

        SecondSlash = wcschr( FirstSlash, L'/' );

        if ( SecondSlash )
        {
            *SecondSlash = L'\0';
        }
    }

    RtlInitUnicodeString( &TargetHost, FirstSlash );

    NegReadLockComputerNames();

    if (!RtlEqualUnicodeString( &TargetHost, &NegDnsComputerName_U, TRUE ) &&
        !RtlEqualUnicodeString( &TargetHost, &NegNetbiosComputerName_U, TRUE ) &&
        !RtlEqualUnicodeString( &TargetHost, &NegLocalHostName_U, TRUE ) )
    {
        NegUnlockComputerNames();
        goto Cleanup ;
    }

    NegUnlockComputerNames();

    //
    // We have a loopback condition.  The target we are going to is our own host
    // name.  So, scan through the mech list, and find the NTLM mech (if present)
    // and bump it up.
    //
#if DBG
    if ( SecondSlash )
    {
        //
        // for debug builds, reset the string now for the dump message, so that
        // we can make sure the right targets are being caught.  Free builds will
        // reset this at the cleanup stage.
        //
        *SecondSlash = L'/';
        SecondSlash = NULL ;
    }
#endif

    DebugLog(( DEB_TRACE_NEG, "Loopback detected for target %ws\n", Target->Buffer ));

loopback:

    MechList = *RealMechList ;
    Trailer = NULL ;

    while ( MechList )
    {
        if ( (MechList->value != NULL) &&
             (NegpCompareOid( MechList->value, NegNtlmMechOid ) == 0)
            )
        {
            //
            // Found NTLM.  Unlink it and put it at the head of the new list
            //

            Reorder = MechList ;
            if ( Trailer )
            {
                Trailer->next = MechList->next ;
            }
            else
            {
                // update original pointer
                *RealMechList = MechList->next ;
            }
            MechList = MechList->next ;
            Reorder->next = NULL ;
        }
        else
        {
            Trailer = MechList ;
            MechList = MechList->next ;
        }

    }

    //
    // Reorder points to the NTLM element, if there are NTLM creds.  If not, this is NULL.
    // Now, append the rest of the list
    //
    if ( Reorder )
    {
        Reorder->next = *RealMechList ;
        *RealMechList = Reorder ;
        Rearranged = TRUE ;
    }

    // Only set this if everything else went well
    // HACK PART 2
    *DirectPacket = HttpSpn;

Cleanup:

    if ( SecondSlash )
    {
        if ( !PortInstance )
        {
            *SecondSlash = L'/';
        } else {
            *SecondSlash = L':';
        }
    }

    return Rearranged ;

}


#ifdef _WIN64

//
// WOW structure definitions
//

typedef UNICODE_STRING32     UNICODE_STRING_WOW64;
typedef UNICODE_STRING_WOW64 *PUNICODE_STRING_WOW64;

typedef struct _MSV1_0_INTERACTIVE_LOGON_WOW64 {
    MSV1_0_LOGON_SUBMIT_TYPE MessageType;
    UNICODE_STRING_WOW64 LogonDomainName;
    UNICODE_STRING_WOW64 UserName;
    UNICODE_STRING_WOW64 Password;
} MSV1_0_INTERACTIVE_LOGON_WOW64, *PMSV1_0_INTERACTIVE_LOGON_WOW64;


//
// Useful macros to thunk WOW structures to native structures
//

#define RELOCATE_WOW_UNICODE_STRING(WOWString, NativeString, Offset)  \
            NativeString.Length        = WOWString.Length;                             \
            NativeString.MaximumLength = WOWString.MaximumLength;                      \
            NativeString.Buffer        = (LPWSTR) ((LPBYTE) UlongToPtr(WOWString.Buffer) + Offset);


//+-------------------------------------------------------------------------
//
//  Function:   NegpConvertWOWInteractiveLogonBuffer
//
//  Synopsis:   Converts logon buffers passed in from WOW clients to 64-bit
//
//  Effects:
//
//  Arguments:  ProtocolSubmitBuffer -- original 32-bit logon buffer
//              pSubmitBufferSize    -- size of the 32-bit logon buffer
//              MessageType          -- format of the logon buffer
//              ppTempSubmitBuffer   -- filled in with the converted buffer
//
//  Requires:
//
//  Returns:
//
//  Notes:      This routine allocates the converted buffer and returns it
//              on success.  It is the caller's responsibility to free it
//              iff the returned OUT buffer is different from the original
//              IN buffer (since native calls return the buffer untouched).
//
//--------------------------------------------------------------------------

NTSTATUS
NegpConvertWOWInteractiveLogonBuffer(
    IN     PVOID                   ProtocolSubmitBuffer,
    IN     PVOID                   ClientBufferBase,
    IN OUT PULONG                  pSubmitBufferSize,
    OUT    PVOID                   *ppTempSubmitBuffer
    )
{
    NTSTATUS  Status;
    PVOID     pTempBuffer  = NULL;
    ULONG     dwBufferSize = *pSubmitBufferSize;

    SECPKG_CALL_INFO                CallInfo;
    PMSV1_0_INTERACTIVE_LOGON       Logon;
    PMSV1_0_INTERACTIVE_LOGON_WOW64 LogonWOW;
    DWORD                           dwOffset;
    DWORD                           dwWOWOffset;


    //
    // Pacify the compiler
    //

    UNREFERENCED_PARAMETER(ClientBufferBase);

    Status = LsapGetCallInfo(&CallInfo);

    if (!NT_SUCCESS(Status))
    {
        return Status;
    }

    if ((CallInfo.Attributes & SECPKG_CALL_WOWCLIENT) == 0)
    {
        //
        // Native 64-bit call -- no thunking required.
        //

        *ppTempSubmitBuffer = ProtocolSubmitBuffer;
        return STATUS_SUCCESS;
    }

    //
    // Scale up the size
    //

    dwBufferSize += sizeof(MSV1_0_INTERACTIVE_LOGON)
                        - sizeof(MSV1_0_INTERACTIVE_LOGON_WOW64);

    if (dwBufferSize < sizeof(MSV1_0_INTERACTIVE_LOGON))
    {
        Status = STATUS_INVALID_PARAMETER;
        goto Cleanup;
    }

    pTempBuffer = LsapAllocatePrivateHeap(dwBufferSize);

    if (pTempBuffer == NULL)
    {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto Cleanup;
    }

    Logon    = (PMSV1_0_INTERACTIVE_LOGON) pTempBuffer;
    LogonWOW = (PMSV1_0_INTERACTIVE_LOGON_WOW64) ProtocolSubmitBuffer;

    Logon->MessageType = LogonWOW->MessageType;

    dwOffset    = sizeof(MSV1_0_INTERACTIVE_LOGON);
    dwWOWOffset = sizeof(MSV1_0_INTERACTIVE_LOGON_WOW64);


    //
    // Copy the variable-length data
    //

    RtlCopyMemory((LPBYTE) Logon + dwOffset,
                  (LPBYTE) LogonWOW + dwWOWOffset,
                  *pSubmitBufferSize - dwWOWOffset);

    //
    // Set up the pointers in the native struct
    //

    RELOCATE_WOW_UNICODE_STRING(LogonWOW->LogonDomainName,
                                Logon->LogonDomainName,
                                dwOffset - dwWOWOffset);

    RELOCATE_WOW_UNICODE_STRING(LogonWOW->UserName,
                                Logon->UserName,
                                dwOffset - dwWOWOffset);

    RELOCATE_WOW_UNICODE_STRING(LogonWOW->Password,
                                Logon->Password,
                                dwOffset - dwWOWOffset);

    *pSubmitBufferSize  = dwBufferSize;
    *ppTempSubmitBuffer = pTempBuffer;

    return STATUS_SUCCESS;

Cleanup:

    if (pTempBuffer)
    {
        LsapFreePrivateHeap(pTempBuffer);
    }

    return Status;
}

#endif  // _WIN64
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\base\lsa\server\param.cxx ===
//+-----------------------------------------------------------------------
//
// File:        PARAM.CXX
//
// Contents:    Parameter code
//
//
// History:     28 Feb 92   RichardW    Created
//
//------------------------------------------------------------------------


#include <lsapch.hxx>
extern "C"
{
extern PWSTR    pszPreferred;
}

WCHAR   szLsaPath[]       = L"System\\CurrentControlSet\\Control\\Lsa";
WCHAR   szOthersValue[]   = L"Security Packages";
WCHAR   szOldValue[]      = L"Authentication Packages";
WCHAR   szPreferredPackage[] = L"Preferred";

PWSTR   ppszDefault[] = {L"Kerberos", L"NTLM", NULL};

// Will build an argv style array of DLLs to load as packages here:
extern PWSTR *  ppszPackages;
extern PWSTR *  ppszOldPkgs;
extern PWSTR    pszPreferred;


//+-------------------------------------------------------------------------
//
//  Function:   GetRegistryString
//
//  Synopsis:   Gets a string from the registry
//
//  Effects:    If type is REG_EXPAND_SZ, string is expanded.
//              If type is REG_MULTI_SZ, string is (left alone?)
//
//  Arguments:  hRootKey    -- HKEY to start at
//              pszSubKey   -- Key to look at
//              pszValue    -- Value to look at
//              pszData     -- Buffer to place string
//              pcbData     -- Size (in/out) of buffer
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//--------------------------------------------------------------------------
NTSTATUS
GetRegistryString(  HKEY        hRootKey,
                    PWSTR       pszSubkey,
                    PWSTR       pszValue,
                    PWSTR       pszData,
                    PDWORD      pcbData)
{
    HKEY        hKey;
    int         Status;
    ULONG       type;
    DWORD       dwSize = *pcbData;


    Status = RegOpenKey(hRootKey, pszSubkey, &hKey);
    if (Status != ERROR_SUCCESS)
    {
        DebugLog((DEB_ERROR, "Open of %ws failed, %d\n", pszSubkey, Status));

        return(STATUS_OBJECT_NAME_NOT_FOUND);
    }


    // First, call query value and make sure this is a correct type


    Status = RegQueryValueEx(   hKey,
                                pszValue,
                                NULL,
                                &type,
                                NULL,
                                &dwSize);

    if ((Status != ERROR_SUCCESS) && (Status != ERROR_MORE_DATA))
    {
        DebugLog((DEB_TRACE, "QueryValueEx of %ws failed, %d\n", pszValue, Status));
        (void) RegCloseKey(hKey);
        if (Status == ERROR_FILE_NOT_FOUND)
        {
            return(STATUS_OBJECT_NAME_NOT_FOUND);
        }
        return(STATUS_UNSUCCESSFUL);
    }

    if ((type != REG_SZ) && (type != REG_MULTI_SZ) && (type != REG_EXPAND_SZ) )
    {
        DebugLog((DEB_ERROR, "Type = %d, returning now\n", type));

        (void) RegCloseKey(hKey);

        return(STATUS_UNSUCCESSFUL);   
    }


    Status = RegQueryValueEx(   hKey,
                                pszValue,
                                NULL,
                                &type,
                                (PBYTE) pszData,
                                pcbData);


    (void) RegCloseKey(hKey);

    if (Status != ERROR_SUCCESS)
    {
        if (Status == ERROR_INSUFFICIENT_BUFFER)
        {
            return(STATUS_BUFFER_TOO_SMALL);
        }

        DebugLog((DEB_ERROR, "QueryValueEx of %ws returned %d\n", pszValue, Status));
        return(STATUS_UNSUCCESSFUL);
    }

    if (type == REG_EXPAND_SZ)
    {
        *pcbData = ExpandEnvironmentStrings(pszData, pszData, dwSize);
    }

    return(STATUS_SUCCESS);

}

typedef struct _LSAP_REG_PARAMETER {

    WCHAR * Name;
    DWORD * Address;
    DWORD DefaultValue;
    BOOL ReverseSense; // 0 means TRUE

} LSAP_REG_PARAMETER, *PLSAP_REG_PARAMETER;

//+---------------------------------------------------------------------------
//
//  Function:   GetRegistryDword
//
//  Synopsis:   Gets a set of DWORDs from the registry
//
//  Effects:
//
//  Arguments:  [hPrimaryKey] --    Key to start from
//              [pszKey] --         Name of the subkey
//              [Count] --          Number of values
//              [Values] --         returned values
//
//  Returns:    S_OK, or SEC_E_INVALID_HANDLE
//
//  History:    3-31-93   RichardW   Created
//              10-14-01  MarkPu     Enabled multiple values
//
//----------------------------------------------------------------------------

HRESULT
GetRegistryDwords(
    IN HKEY       hPrimaryKey,
    IN PWSTR      pszKey,
    IN ULONG      Count,
    IN PLSAP_REG_PARAMETER Values
    )
{
    HKEY    hKey;
    int     err;

    err = RegOpenKey(hPrimaryKey, pszKey, &hKey);

    if (err) {
        return(SEC_E_INVALID_HANDLE);
    }

    while ( Count-- > 0 ) {

        DWORD   dwType;
        DWORD   dwValue;
        DWORD   cbDword = sizeof(DWORD);

        err = RegQueryValueEx(  hKey,
                                Values[Count].Name,
                                NULL,
                                &dwType,
                                (PBYTE) &dwValue,
                                &cbDword);

        if ( err || ( dwType != REG_DWORD )) {

            *Values[Count].Address = Values[Count].DefaultValue;

        } else if ( Values[Count].ReverseSense ) {

            *Values[Count].Address = !dwValue;

        } else {

            *Values[Count].Address = dwValue;
        }
    }

    (void) RegCloseKey(hKey);

    return S_OK;
}


HRESULT
SpmGetMachineName(void)
{
    HRESULT     hr = S_OK;
    WCHAR       wszMachName [MAX_COMPUTERNAME_LENGTH + 1]; 
    DWORD       dwSize = MAX_COMPUTERNAME_LENGTH + 1;

    if (!GetComputerName(
            wszMachName,
            &dwSize))
    {
        return(STATUS_UNSUCCESSFUL);
    }
    MachineName.Buffer = (LPWSTR) LsapAllocateLsaHeap((wcslen(wszMachName)+1) * sizeof(WCHAR));
    if (MachineName.Buffer == NULL)
    {
        return(STATUS_INSUFFICIENT_RESOURCES);
    }
    wcscpy(MachineName.Buffer, wszMachName);
    RtlInitUnicodeString(
        &MachineName,
        MachineName.Buffer
        );
    return(STATUS_SUCCESS);
}

//+---------------------------------------------------------------------------
//
//  Function:   LoadParameters
//
//  Synopsis:   Loads operating parameters from the registry
//
//  Effects:
//
//  Arguments:
//      DynamicOnly is TRUE if we are to check variables that are allowed to
//      change within the boot lifetime.
//
//  Requires:
//
//  Returns:
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:
//
//  History:    3-31-93   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------

NTSTATUS
LoadParameters(
    BOOLEAN DynamicOnly
    )
{
    int             lcPackages = 0;
    int             cOldPkgs = 0;
    int             iPackage = 0;
    PWSTR           pszAlternate;
    PWSTR           pszOldPkgs;
    PWSTR           pszScan;
    DWORD           dwBuffer = 64;
    DWORD           dwValue;
    HRESULT scRet;
    LSAP_REG_PARAMETER Parameters[] =
    {
        { L"NoDefaultAdminOwner",       &LsapGlobalSetAdminOwner,        TRUE,  TRUE  },
        { L"EveryoneIncludesAnonymous", &LsapGlobalRestrictNullSessions, TRUE,  TRUE  },
        { L"TurnOffAnonymousBlock",     &LsapGlobalRestrictAnonymous,    TRUE,  TRUE  }, // What do I name this?  RestrictAnonymous is taken
    };

    //
    // Get the parameters that can change during a boot.
    //

    scRet = GetRegistryDwords(
                HKEY_LOCAL_MACHINE,
                szLsaPath,
                sizeof( Parameters ) / sizeof( Parameters[0]),
                Parameters
                );

    //
    // return now if dynamic only.
    //

    if( DynamicOnly )
    {
        return STATUS_SUCCESS;
    }

    //
    // parameters that cannot change.
    //

    //
    // Get the machine name
    //

    scRet = SpmGetMachineName();

    if (!NT_SUCCESS(scRet)) {
        return(scRet);
    }

    //
    // Get the preferred package
    //

    dwBuffer = 128 ;

    pszPreferred = (PWSTR) LsapAllocateLsaHeap( dwBuffer );

    if ( !pszPreferred )
    {
        dwBuffer = 0 ;
    }

    scRet = GetRegistryString(  HKEY_LOCAL_MACHINE,
                                szLsaPath,
                                szPreferredPackage,
                                pszPreferred,
                                &dwBuffer);

    if (scRet == STATUS_BUFFER_TOO_SMALL)
    {
        LsapFreeLsaHeap(pszPreferred);

        pszPreferred = (PWSTR)LsapAllocateLsaHeap(dwBuffer);

        if ( pszPreferred )
        {
            scRet = GetRegistryString(  HKEY_LOCAL_MACHINE,
                                        szLsaPath,
                                        szPreferredPackage,
                                        pszPreferred,
                                        &dwBuffer);
        }
    }
    else
    {
        if ( pszPreferred )
        {
            LsapFreeLsaHeap( pszPreferred );

            pszPreferred = NULL ;
        }
    }

    //
    // Set the default packages
    //

    ppszPackages = ppszDefault;

    //
    // Now, find out all the other ones.  First, NT5 packages:
    //

    dwBuffer = 128;

    pszAlternate = (PWSTR)LsapAllocateLsaHeap(dwBuffer);
    if (!pszAlternate)
    {
        return(STATUS_INSUFFICIENT_RESOURCES);
    }
    *pszAlternate = L'\0';

    scRet = GetRegistryString(  HKEY_LOCAL_MACHINE,
                                szLsaPath,
                                szOthersValue,
                                pszAlternate,
                                &dwBuffer);

    if (scRet == STATUS_BUFFER_TOO_SMALL)
    {
        LsapFreeLsaHeap(pszAlternate);

        pszAlternate = (PWSTR)LsapAllocateLsaHeap(dwBuffer);
        if (!pszAlternate)
        {
            return(STATUS_INSUFFICIENT_RESOURCES);
        }
        *pszAlternate = L'\0';

        scRet = GetRegistryString(  HKEY_LOCAL_MACHINE,
                                    szLsaPath,
                                    szOthersValue,
                                    pszAlternate,
                                    &dwBuffer);

        if (FAILED(scRet)) {
            return(scRet);
        }

    }
    if (NT_SUCCESS(scRet))
    {

        pszScan = pszAlternate;

        while (*pszScan)
        {
            while (*pszScan) {
                pszScan++;
            }

            lcPackages++;
            pszScan++;
        }

    } else if (scRet != STATUS_OBJECT_NAME_NOT_FOUND) {
        LsapFreeLsaHeap(pszAlternate);
        pszAlternate = NULL;
        return(scRet);
    } else {
        LsapFreeLsaHeap(pszAlternate);
        pszAlternate = NULL;
    }

    dwBuffer = 128;
    pszOldPkgs = (PWSTR)LsapAllocateLsaHeap(dwBuffer);
    if (!pszOldPkgs)
    {
        return(STATUS_INSUFFICIENT_RESOURCES);
    }

    *pszOldPkgs = L'\0';

    scRet = GetRegistryString(  HKEY_LOCAL_MACHINE,
                                szLsaPath,
                                szOldValue,
                                pszOldPkgs,
                                &dwBuffer);

    if (scRet == STATUS_BUFFER_TOO_SMALL)
    {
        LsapFreeLsaHeap(pszOldPkgs);

        pszOldPkgs = (PWSTR)LsapAllocateLsaHeap(dwBuffer);
        if (!pszOldPkgs)
        {
            return(STATUS_INSUFFICIENT_RESOURCES);
        }
        *pszOldPkgs = L'\0';
        scRet = GetRegistryString(  HKEY_LOCAL_MACHINE,
                                    szLsaPath,
                                    szOldValue,
                                    pszOldPkgs,
                                    &dwBuffer);

        if (!NT_SUCCESS(scRet)) {
            return(scRet);
        }

    }

    if (NT_SUCCESS(scRet))
    {
        pszScan = pszOldPkgs;

        while (*pszScan)
        {
            while (*pszScan) {
                pszScan++;
            }

            cOldPkgs++;
            pszScan++;
        }
    } else if (scRet != STATUS_OBJECT_NAME_NOT_FOUND) {
        LsapFreeLsaHeap(pszOldPkgs);
        pszOldPkgs = NULL;
        return(scRet);
    } else {
        LsapFreeLsaHeap(pszOldPkgs);
        pszOldPkgs = NULL;
    }

    ppszPackages = (PWSTR *)LsapAllocateLsaHeap((lcPackages + 1) * sizeof(PWSTR));
    if (!ppszPackages)
    {
        return(STATUS_INSUFFICIENT_RESOURCES);
    }

    //
    // Add any alternate packages
    //

    if (pszAlternate != NULL)
    {
        pszScan = pszAlternate;

        while (*pszScan)
        {
            ppszPackages[iPackage++] = pszScan;
            while (*pszScan++);
        }
    }

    ppszPackages[iPackage] = NULL;

    //
    // Note:  we don't allocate one extra, since we don't actually include
    // the MSV package name here (we simulate the package in msvlayer.c)
    //

    ppszOldPkgs = (PWSTR *)LsapAllocateLsaHeap((cOldPkgs+1) * sizeof(PWSTR));
    if (!ppszOldPkgs)
    {
        return(STATUS_INSUFFICIENT_RESOURCES);
    }

    iPackage = 0;
    if (pszOldPkgs != NULL)
    {
        pszScan = pszOldPkgs;

        while (*pszScan)
        {
            ppszOldPkgs[iPackage++] = pszScan;
            while (*pszScan++);
        }
    }

    cOldPkgs = iPackage;
    ppszOldPkgs[iPackage] = NULL;

    return(S_OK);
}


BOOL
AddPackageToRegistry(
    PSECURITY_STRING    Package
    )
{
    PWSTR   Buffer;
    DWORD   Length;
    DWORD   Type;
    int     err;
    HKEY    hKey;

    err = RegOpenKeyEx( HKEY_LOCAL_MACHINE,
                        szLsaPath,
                        0,
                        KEY_READ | KEY_WRITE,
                        &hKey );

    if ( err )
    {
        return( FALSE );
    }

    Length = 0;

    err = RegQueryValueEx(  hKey,
                            szOthersValue,
                            0,
                            &Type,
                            NULL,
                            &Length );

    Buffer = (PWSTR) LsapAllocateLsaHeap( Length + Package->Length + 2 );

    if ( !Buffer )
    {
        RegCloseKey( hKey );

        return FALSE ;
    }

    RegQueryValueEx(    hKey,
                        szOthersValue,
                        0,
                        &Type,
                        (PUCHAR) Buffer,
                        &Length );

    CopyMemory( &Buffer[Length + 1],
                Package->Buffer,
                Package->Length + 2 );

    Length = Length + Package->Length + 2;

    RegSetValueEx(  hKey,
                    szOthersValue,
                    0,
                    REG_MULTI_SZ,
                    (PUCHAR) Buffer,
                    Length );

    RegCloseKey( hKey );

    return( TRUE );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\base\lsa\server\safemode.h ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    safeboot.h

Abstract:

    Header for module to determine what boot mode the system was boot into.

Author:

    Colin Brace         (ColinBr)    May 27, 1997.

Environment:

    User mode

Revision History:

--*/

NTSTATUS
LsapCheckBootMode(
    VOID
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\base\lsa\server\samhooks.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1997.
//
//  File:       samhooks.cxx
//
//  Contents:   SAM Hooks for security packages
//
//  Classes:
//
//  Functions:
//
//  History:    3-10-97   RichardW   Created
//
//----------------------------------------------------------------------------

#include <lsapch.hxx>

#include <lmcons.h>
#include <ntsam.h>
#include <samrpc.h>
#include <samisrv.h>
#include <ntmsv1_0.h>
#include <pac.hxx>
#include "samhooks.hxx"


//+---------------------------------------------------------------------------
//
//  Function:   LsapMakeDomainRelativeSid
//
//  Synopsis:   Build a new SID based on a domain SID and a RID
//
//  Arguments:  [DomainId]   --
//              [RelativeId] --
//
//  History:    3-11-97   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
PSID
LsapMakeDomainRelativeSid(
    IN PSID DomainId,
    IN ULONG RelativeId
    )

{
    UCHAR DomainIdSubAuthorityCount;
    ULONG Size;
    PSID Sid;

    if ( !DomainId ) {

        return( NULL );
    }

    //
    // Allocate a Sid which has one more sub-authority than the domain ID.
    //

    DomainIdSubAuthorityCount = *(RtlSubAuthorityCountSid( DomainId ));
    Size = RtlLengthRequiredSid(DomainIdSubAuthorityCount+1);

    if ((Sid = LsapAllocateLsaHeap( Size )) == NULL ) {
        return NULL;
    }

    //
    // Initialize the new SID to have the same inital value as the
    // domain ID.
    //

    if ( !NT_SUCCESS( RtlCopySid( Size, Sid, DomainId ) ) ) {
        LsapFreeLsaHeap( Sid );
        return NULL;
    }

    //
    // Adjust the sub-authority count and
    //  add the relative Id unique to the newly allocated SID
    //

    (*(RtlSubAuthorityCountSid( Sid ))) ++;
    *RtlSubAuthoritySid( Sid, DomainIdSubAuthorityCount ) = RelativeId;


    return Sid;
}

PSID
LsapMakeDomainRelativeSid2(
    IN PSID DomainId,
    IN ULONG RelativeId
    )

{
    UCHAR DomainIdSubAuthorityCount;
    ULONG Size;
    PSID Sid;

    if ( !DomainId ) {

        return( NULL );
    }

    //
    // Allocate a Sid which has one more sub-authority than the domain ID.
    //

    DomainIdSubAuthorityCount = *(RtlSubAuthorityCountSid( DomainId ));
    Size = RtlLengthRequiredSid(DomainIdSubAuthorityCount+1);

    if ((Sid = LsapAllocatePrivateHeap( Size )) == NULL ) {
        return NULL;
    }

    //
    // Initialize the new SID to have the same inital value as the
    // domain ID.
    //

    if ( !NT_SUCCESS( RtlCopySid( Size, Sid, DomainId ) ) ) {
        LsapFreePrivateHeap( Sid );
        return NULL;
    }

    //
    // Adjust the sub-authority count and
    //  add the relative Id unique to the newly allocated SID
    //

    (*(RtlSubAuthorityCountSid( Sid ))) ++;
    *RtlSubAuthoritySid( Sid, DomainIdSubAuthorityCount ) = RelativeId;

    return Sid;
}


//+-------------------------------------------------------------------------
//
//  Function:   LsapDuplicateSid
//
//  Synopsis:   Duplicates a SID
//
//  Effects:    allocates memory with LsaFunctions.AllocateLsaHeap
//
//  Arguments:  DestinationSid - Receives a copy of the SourceSid
//              SourceSid - SID to copy
//
//  Requires:
//
//  Returns:    STATUS_SUCCESS - the copy succeeded
//              STATUS_INSUFFICIENT_RESOURCES - the call to allocate memory
//                  failed
//
//  Notes:
//
//
//--------------------------------------------------------------------------

NTSTATUS
LsapDuplicateSid(
    OUT PSID * DestinationSid,
    IN PSID SourceSid
    )
{
    ULONG SidSize;

    DsysAssert(RtlValidSid(SourceSid));

    SidSize = RtlLengthSid(SourceSid);

    *DestinationSid = (PSID) LsapAllocateLsaHeap( SidSize );

    if (*DestinationSid == NULL)
    {
        return(STATUS_INSUFFICIENT_RESOURCES);
    }

    RtlCopyMemory(
        *DestinationSid,
        SourceSid,
        SidSize
        );

    return(STATUS_SUCCESS);
}


NTSTATUS
LsapDuplicateSid2(
    OUT PSID * DestinationSid,
    IN PSID SourceSid
    )
{
    ULONG SidSize;

    DsysAssert(RtlValidSid(SourceSid));

    SidSize = RtlLengthSid(SourceSid);

    *DestinationSid = (PSID) LsapAllocatePrivateHeap( SidSize );

    if (*DestinationSid == NULL)
    {
        return(STATUS_INSUFFICIENT_RESOURCES);
    }

    RtlCopyMemory(
        *DestinationSid,
        SourceSid,
        SidSize
        );

    return(STATUS_SUCCESS);
}


//+---------------------------------------------------------------------------
//
//  Function:   LsapCaptureSamInfo
//
//  Synopsis:   Capture current SAM info for building a PAC
//
//  Arguments:  [DomainSid]   -- Returns domain SID
//              [DomainName]  -- returns domain name
//              [MachineName] -- returns current machine name
//
//  History:    3-14-97   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------

NTSTATUS
LsapCaptureSamInfo(
    IN PSID *  DomainSid,
    OUT PUNICODE_STRING DomainName,
    OUT PUNICODE_STRING MachineName
    )
{
    NTSTATUS Status;
    PLSAPR_POLICY_INFORMATION PolicyInformation = NULL;
    UNICODE_STRING String;
    WCHAR LocalMachineName[ CNLEN + 1 ];
    DWORD Size ;
    PSID Sid ;

    Size = CNLEN + 1;

    if ( GetComputerName( LocalMachineName, &Size ) )
    {
        RtlInitUnicodeString( &String, LocalMachineName );

        Status = LsapDuplicateString( MachineName, &String );
    }
    else
    {
        MachineName->Buffer = (PWSTR) LsapAllocateLsaHeap( Size *
                                            sizeof(WCHAR) + 2 );

        if ( MachineName->Buffer )
        {
            MachineName->MaximumLength = (USHORT) (Size * sizeof(WCHAR) + 2);

            if ( GetComputerName( MachineName->Buffer, &Size ))
            {
                MachineName->Length = (USHORT) (Size * sizeof( WCHAR ) );;

                Status = STATUS_SUCCESS ;
            }
            else
            {
                ASSERT( FALSE ); // how's this possible?
                Status = STATUS_INTERNAL_ERROR;
            }
        }
        else
        {
            Status = STATUS_NO_MEMORY ;
        }
    }

    if ( !NT_SUCCESS( Status ) )
    {
        DebugLog(( DEB_ERROR, "Failed to get computer name, %x\n", Status ));
        goto Cleanup;
    }

    Status = LsarQueryInformationPolicy(
                LsapPolicyHandle,
                PolicyAccountDomainInformation,
                &PolicyInformation
                );

    if (!NT_SUCCESS(Status))
    {
        DebugLog((DEB_ERROR,"Failed to query information policy: 0x%x\n",Status));
        goto Cleanup;
    }

    Status = LsapDuplicateString(
                DomainName,
                (PUNICODE_STRING) &PolicyInformation->PolicyAccountDomainInfo.DomainName
                );

    if (!NT_SUCCESS(Status))
    {
        goto Cleanup;
    }

    Sid = (PSID) LocalAlloc(0, RtlLengthSid(
                        PolicyInformation->PolicyAccountDomainInfo.DomainSid)
                       );

    if ( Sid == NULL )
    {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto Cleanup;
    }

    RtlCopyMemory(
        Sid,
        PolicyInformation->PolicyAccountDomainInfo.DomainSid,
        RtlLengthSid(PolicyInformation->PolicyAccountDomainInfo.DomainSid)
        );

    *DomainSid = Sid ;

Cleanup:

    if (PolicyInformation != NULL)
    {
        LsaIFree_LSAPR_POLICY_INFORMATION(
                PolicyPrimaryDomainInformation,
                PolicyInformation
                );
    }

    return( Status );
}


//+---------------------------------------------------------------------------
//
//  Function:   LsaOpenSamUser
//
//  Synopsis:   Opens a handle to the SAM user as specified by Name and NameType
//
//  Arguments:  [Name]       -- Name of user to find
//              [NameType]   -- SAM or AlternateId
//              [Prefix]     -- Prefix for AlternateId lookup
//              [AllowGuest] -- Open guest if user not found
//              [Reserved]   --
//              [UserHandle] -- Returned user handle
//
//  History:    3-14-97   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------

NTSTATUS
NTAPI
LsaOpenSamUser(
    PSECURITY_STRING Name,
    SECPKG_NAME_TYPE NameType,
    PSECURITY_STRING Prefix,
    BOOLEAN AllowGuest,
    ULONG Reserved,
    PVOID * UserHandle
    )
{
    NTSTATUS Status = STATUS_NOT_IMPLEMENTED ;
    SECURITY_STRING CombinedName ;
    PSECURITY_STRING EffectiveName ;
    SAMPR_ULONG_ARRAY RelativeIdArray;
    SAMPR_ULONG_ARRAY UseArray;
    UNICODE_STRING TempString;

    RelativeIdArray.Element = NULL;
    UseArray.Element = NULL;

    if ( NameType == SecNameAlternateId )
    {
        if ( !Prefix )
        {
            return STATUS_INVALID_PARAMETER ;
        }

        CombinedName.MaximumLength = Name->Length + Prefix->Length +
                                        2 * sizeof( WCHAR );

        CombinedName.Length = CombinedName.MaximumLength - sizeof( WCHAR );

        CombinedName.Buffer = (PWSTR) LsapAllocateLsaHeap( CombinedName.MaximumLength );

        if ( CombinedName.Buffer )
        {
            CopyMemory( CombinedName.Buffer, Prefix->Buffer, Prefix->Length );

            CombinedName.Buffer[ Prefix->Length / sizeof( WCHAR ) ] = L':';

            CopyMemory( &CombinedName.Buffer[ Prefix->Length / sizeof( WCHAR ) + 1],
                        Name->Buffer,
                        Name->Length );

            CombinedName.Buffer[CombinedName.Length / sizeof( WCHAR )] = L'\0';

            EffectiveName = &CombinedName ;
        }
        else
        {
            return SEC_E_INSUFFICIENT_MEMORY ;
        }
    }
    else
    {
        EffectiveName = Name ;
    }

    if ( NameType == SecNameSamCompatible )
    {
        Status = SamrLookupNamesInDomain(
                    LsapAccountDomainHandle,
                    1,
                    (PRPC_UNICODE_STRING) Name,
                    &RelativeIdArray,
                    &UseArray
                    );

        if (!NT_SUCCESS(Status))
        {
            DebugLog((DEB_ERROR,"Failed to lookup name %wZ in domain: 0x%x\n",
                Name, Status));

            goto CheckGuest ;
        }

        if (UseArray.Element[0] != SidTypeUser)
        {
            Status = STATUS_NO_SUCH_USER;

            goto CheckGuest ;
        }

        Status = SamrOpenUser(
                    LsapAccountDomainHandle,
                    USER_ALL_ACCESS,
                    RelativeIdArray.Element[0],
                    UserHandle
                    );

        SamIFree_SAMPR_ULONG_ARRAY( &RelativeIdArray );
        SamIFree_SAMPR_ULONG_ARRAY( &UseArray );

        RelativeIdArray.Element = NULL;
        UseArray.Element = NULL;

        if (!NT_SUCCESS(Status))
        {
            DebugLog((DEB_ERROR,"Failed to open user by relative ID: 0x%x\n",Status));

            goto CheckGuest ;
        }
    }
    else if ( NameType == SecNameAlternateId )
    {

        Status = SamIOpenUserByAlternateId(
                        LsapAccountDomainHandle,
                        USER_ALL_ACCESS,
                        EffectiveName,
                        UserHandle );

        if ( !NT_SUCCESS( Status ) )
        {
            DebugLog(( DEB_TRACE_SAM, "Failed to find user by alternate id, %x\n", Status ));

            goto CheckGuest ;
        }
    }
    else
    {
        Status = STATUS_NOT_IMPLEMENTED ;

        AllowGuest = FALSE ;
    }

    if ( RelativeIdArray.Element )
    {
        SamIFree_SAMPR_ULONG_ARRAY( &RelativeIdArray );

        RelativeIdArray.Element = NULL;
    }
    if ( UseArray.Element )
    {
        SamIFree_SAMPR_ULONG_ARRAY( &UseArray );

        UseArray.Element = NULL;
    }

    if ( EffectiveName == &CombinedName )
    {
        LsapFreeLsaHeap( EffectiveName->Buffer );
    }

    return Status ;

CheckGuest:

    if ( RelativeIdArray.Element )
    {
        SamIFree_SAMPR_ULONG_ARRAY( &RelativeIdArray );

        RelativeIdArray.Element = NULL;
    }

    if ( UseArray.Element )
    {
        SamIFree_SAMPR_ULONG_ARRAY( &UseArray );

        UseArray.Element = NULL;
    }

    if ( AllowGuest )
    {
        Status = SamrOpenUser(
                        LsapAccountDomainHandle,
                        USER_ALL_ACCESS,
                        DOMAIN_USER_RID_GUEST,
                        UserHandle );
    }

    if ( EffectiveName == &CombinedName )
    {
        LsapFreeLsaHeap( EffectiveName->Buffer );
    }

    return Status ;
}


//+---------------------------------------------------------------------------
//
//  Function:   LsaCloseSamUser
//
//  Synopsis:   Close a SAM user opened by LsaOpenSamUser
//
//  Arguments:  [UserHandle] --
//
//  History:    3-14-97   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
NTSTATUS
NTAPI
LsaCloseSamUser(
    PVOID UserHandle
    )
{
     return SamrCloseHandle( &((SAMPR_HANDLE) UserHandle) );
}


NTSTATUS
NTAPI
LsaGetUserAuthData(
    PVOID UserHandle,
    PUCHAR * UserAuthData,
    PULONG UserAuthDataSize
    )
{
    PSAMPR_USER_ALL_INFORMATION UserAll = NULL ;
    PSAMPR_USER_INFO_BUFFER UserAllInfo = NULL ;
    NTSTATUS Status ;
    PPACTYPE pNewPac = NULL ;
    PSAMPR_GET_GROUPS_BUFFER GroupsBuffer = NULL ;
    PPACTYPE Pac ;
    UNICODE_STRING Domain ;
    UNICODE_STRING Machine ;
    PSID Sid ;

    Sid = NULL ;
    Machine.Buffer = NULL ;
    Domain.Buffer = NULL ;

    *UserAuthData = NULL ;

    Status = SamrQueryInformationUser(
                    (SAMPR_HANDLE) UserHandle,
                    UserAllInformation,
                    &UserAllInfo );

    if ( !NT_SUCCESS( Status ) )
    {
        return( Status );
    }

    UserAll = &UserAllInfo->All ;

    if ( UserAll->UserAccountControl & USER_ACCOUNT_DISABLED )
    {
        Status = STATUS_ACCOUNT_DISABLED ;

        goto GetPac_Cleanup;
    }

    Status = SamrGetGroupsForUser(
                    (SAMPR_HANDLE) UserHandle,
                    &GroupsBuffer );

    if ( !NT_SUCCESS( Status ) )
    {
        goto GetPac_Cleanup ;
    }

    Status = LsapCaptureSamInfo( &Sid, &Domain, &Machine );

    if ( !NT_SUCCESS( Status ) )
    {
        goto GetPac_Cleanup ;
    }

    Status = PAC_Init( UserAll,
                       GroupsBuffer,
                       NULL,            // no extra groups
                       Sid,
                       &Domain,
                       &Machine,
                       0,               // no signature
                       0,               // no additional data
                       NULL,            // no additional data
                       &Pac );

    if ( !NT_SUCCESS( Status ) )
    {
        goto GetPac_Cleanup ;
    }

    *UserAuthDataSize = PAC_GetSize( Pac );

    *UserAuthData = (PUCHAR) LsapAllocateLsaHeap( *UserAuthDataSize );

    if ( *UserAuthData )
    {
       PAC_Marshal( Pac, *UserAuthDataSize, *UserAuthData );
    }
    else
    {
        Status = SEC_E_INSUFFICIENT_MEMORY ;
    }

    MIDL_user_free( Pac );

GetPac_Cleanup:

    if ( UserAllInfo )
    {
        SamIFree_SAMPR_USER_INFO_BUFFER( UserAllInfo, UserAllInformation );
    }

    if ( GroupsBuffer )
    {
        SamIFree_SAMPR_GET_GROUPS_BUFFER( GroupsBuffer );
    }
    if ( Sid )
    {
        LsapFreeLsaHeap( Sid );
    }

    if ( Domain.Buffer )
    {
        LsapFreeLsaHeap( Domain.Buffer );
    }

    if ( Machine.Buffer )
    {
        LsapFreeLsaHeap( Machine.Buffer );
    }

    return( Status );
}


//+-------------------------------------------------------------------------
//
//  Function:   LsapMakeTokenInformationV1
//
//  Synopsis:   This routine makes copies of all the pertinent
//              information from the UserInfo and generates a
//              LSA_TOKEN_INFORMATION_V1 data structure.
//
//  Effects:
//
//  Arguments:
//
//    UserInfo - Contains the validation information which is
//        to be copied into the TokenInformation.
//
//    TokenInformation - Returns a pointer to a properly Version 1 token
//        information structures.  The structure and individual fields are
//        allocated properly as described in ntlsa.h.
//
//  Requires:
//
//  Returns:    STATUS_SUCCESS - Indicates the service completed successfully.
//
//              STATUS_INSUFFICIENT_RESOURCES -  This error indicates that
//                      the logon could not be completed because the client
//                      does not have sufficient quota to allocate the return
//                      buffer.
//
//  Notes:      stolen from kerberos\client2\krbtoken.cxx, where it was
//              stolen from msv1_0\nlp.c:NlpMakeTokenInformationV1
//
//
//--------------------------------------------------------------------------
NTSTATUS
LsapMakeTokenInformationV1(
    IN  PNETLOGON_VALIDATION_SAM_INFO3 UserInfo,
    OUT PLSA_TOKEN_INFORMATION_V1 *TokenInformation
    )
{
    NTSTATUS Status;
    PLSA_TOKEN_INFORMATION_V1 V1;
    ULONG Size, i;

    //
    // Allocate the structure itself
    //

    Size = (ULONG)sizeof(LSA_TOKEN_INFORMATION_V1);
    V1 = (PLSA_TOKEN_INFORMATION_V1) LsapAllocateLsaHeap( Size );
    if ( V1 == NULL ) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlZeroMemory(
        V1,
        Size
        );

    V1->User.User.Sid = NULL;
    V1->Groups = NULL;
    V1->PrimaryGroup.PrimaryGroup = NULL;
    OLD_TO_NEW_LARGE_INTEGER( UserInfo->KickOffTime, V1->ExpirationTime );

    //
    // Make a copy of the user SID (a required field)
    //

    V1->User.User.Attributes = 0;

    //
    // Allocate an array to hold the groups
    //

    Size = ( (ULONG)sizeof(TOKEN_GROUPS)
       + (UserInfo->GroupCount * (ULONG)sizeof(SID_AND_ATTRIBUTES))
       - (ANYSIZE_ARRAY * (ULONG)sizeof(SID_AND_ATTRIBUTES))
           );

    //
    // If there are extra SIDs, add space for them
    //

    if (UserInfo->UserFlags & LOGON_EXTRA_SIDS) {

        Size += UserInfo->SidCount * (ULONG)sizeof(SID_AND_ATTRIBUTES);
    }

    //
    // If there are resource groups, add space for them
    //
    if (UserInfo->UserFlags & LOGON_RESOURCE_GROUPS) {

        Size += UserInfo->ResourceGroupCount * (ULONG)sizeof(SID_AND_ATTRIBUTES);

        if ((UserInfo->ResourceGroupCount != 0) &&
            ((UserInfo->ResourceGroupIds == NULL) ||
             (UserInfo->ResourceGroupDomainSid == NULL)))
        {

            Status = STATUS_INVALID_PARAMETER;
            goto Cleanup;
        }
    }

    V1->Groups = (PTOKEN_GROUPS) LsapAllocatePrivateHeap( Size );

    if ( V1->Groups == NULL ) {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto Cleanup;
    }

    RtlZeroMemory(
        V1->Groups,
        Size
        );

    V1->Groups->GroupCount = 0;

    //
    // Start copying SIDs into the structure
    //

    //
    // If the UserId is non-zero, then it contians the users RID.
    //

    if ( UserInfo->UserId ) {
        V1->User.User.Sid =
                LsapMakeDomainRelativeSid( UserInfo->LogonDomainId,
                                          UserInfo->UserId );

        if( V1->User.User.Sid == NULL ) {
            Status = STATUS_INSUFFICIENT_RESOURCES;
            goto Cleanup;
        }
    }

    //
    // Make a copy of the primary group (a required field).
    //

    V1->PrimaryGroup.PrimaryGroup = LsapMakeDomainRelativeSid(
                                            UserInfo->LogonDomainId,
                                            UserInfo->PrimaryGroupId );

    if ( V1->PrimaryGroup.PrimaryGroup == NULL ) {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto Cleanup;
    }

    //
    // Copy over all the groups passed as RIDs
    //

    for ( i=0; i < UserInfo->GroupCount; i++ ) {

        V1->Groups->Groups[V1->Groups->GroupCount].Attributes = UserInfo->GroupIds[i].Attributes;

        V1->Groups->Groups[V1->Groups->GroupCount].Sid = LsapMakeDomainRelativeSid2(
                                         UserInfo->LogonDomainId,
                                         UserInfo->GroupIds[i].RelativeId );

        if( V1->Groups->Groups[V1->Groups->GroupCount].Sid == NULL ) {

            Status = STATUS_INSUFFICIENT_RESOURCES;
            goto Cleanup;
        }

        V1->Groups->GroupCount++;
    }

    //
    // Add in the extra SIDs
    //

    if (UserInfo->UserFlags & LOGON_EXTRA_SIDS) {

        ULONG index = 0;

        //
        // If the user SID wasn't passed as a RID, it is the first
        // SID.
        //

        if ( !V1->User.User.Sid ) {

            if ( UserInfo->SidCount <= index ) {

                Status = STATUS_INSUFFICIENT_LOGON_INFO;
                goto Cleanup;
            }

            Status = LsapDuplicateSid(
                        &V1->User.User.Sid,
                        UserInfo->ExtraSids[index].Sid
                        );

            if (!NT_SUCCESS(Status)) {
                goto Cleanup;
            }

            index++;
        }

        //
        // Copy over all additional SIDs as groups.
        //

        for ( ; index < UserInfo->SidCount; index++ ) {

            V1->Groups->Groups[V1->Groups->GroupCount].Attributes =
                UserInfo->ExtraSids[index].Attributes;

            Status = LsapDuplicateSid2(
                        &V1->Groups->Groups[V1->Groups->GroupCount].Sid,
                        UserInfo->ExtraSids[index].Sid
                        );

            if (!NT_SUCCESS(Status) ) {

                goto Cleanup;
            }

            V1->Groups->GroupCount++;
        }
    }

    //
    // Check to see if any resouce groups exist
    //

    if (UserInfo->UserFlags & LOGON_RESOURCE_GROUPS) {


        for ( i=0; i < UserInfo->ResourceGroupCount; i++ ) {

            V1->Groups->Groups[V1->Groups->GroupCount].Attributes = UserInfo->ResourceGroupIds[i].Attributes;

            V1->Groups->Groups[V1->Groups->GroupCount].Sid = LsapMakeDomainRelativeSid2(
                                             UserInfo->ResourceGroupDomainSid,
                                             UserInfo->ResourceGroupIds[i].RelativeId );

            if( V1->Groups->Groups[V1->Groups->GroupCount].Sid == NULL ) {
                Status = STATUS_INSUFFICIENT_RESOURCES;
                goto Cleanup;
            }

            V1->Groups->GroupCount++;
        }
    }

    if (!V1->User.User.Sid) {

        Status = STATUS_INSUFFICIENT_LOGON_INFO;
        goto Cleanup;
    }

    //
    // There are no default privileges supplied.
    // We don't have an explicit owner SID.
    // There is no default DACL.
    //

    V1->Privileges = NULL;
    V1->Owner.Owner = NULL;
    V1->DefaultDacl.DefaultDacl = NULL;

    //
    // Return the Validation Information to the caller.
    //

    *TokenInformation = V1;
    return STATUS_SUCCESS;

    //
    // Deallocate any memory we've allocated
    //

Cleanup:

    if ( V1->User.User.Sid != NULL ) {
        LsapFreeLsaHeap( V1->User.User.Sid );
    }

    if ( V1->Groups != NULL ) {
        LsapFreeTokenGroups( V1->Groups );
    }

    if ( V1->PrimaryGroup.PrimaryGroup != NULL ) {
        LsapFreeLsaHeap( V1->PrimaryGroup.PrimaryGroup );
    }

    LsapFreeLsaHeap( V1 );

    return Status;
}


//+---------------------------------------------------------------------------
//
//  Function:   LsaFreeTokenInfo
//
//  Synopsis:   Frees a TokenInformation structure that was allocated by
//              the LSA
//
//  Arguments:  [TokenInfoType]    --
//              [TokenInformation] --
//
//  History:    3-14-97   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------

NTSTATUS
NTAPI
LsaFreeTokenInfo(
    LSA_TOKEN_INFORMATION_TYPE TokenInfoType,
    PVOID TokenInformation
    )
{
    switch (TokenInfoType) {

        case LsaTokenInformationNull:

            LsapFreeTokenInformationNull( (PLSA_TOKEN_INFORMATION_NULL) TokenInformation );
            break;

        case LsaTokenInformationV1:

            LsapFreeTokenInformationV1( (PLSA_TOKEN_INFORMATION_V1) TokenInformation );
            break;

        case LsaTokenInformationV2:

            LsapFreeTokenInformationV2( (PLSA_TOKEN_INFORMATION_V2) TokenInformation );
            break;
    }

    return STATUS_SUCCESS ;
}


//+---------------------------------------------------------------------------
//
//  Function:   LsaConvertAuthDataToToken
//
//  Synopsis:   Convert an opaque PAC structure into a token.
//
//  Arguments:  [UserAuthData]         --
//              [UserAuthDataSize]     --
//              [TokenInformation]     --
//              [TokenInformationType] --
//
//  History:    3-14-97   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------

NTSTATUS
NTAPI
LsaConvertAuthDataToToken(
    IN PVOID UserAuthData,
    IN ULONG UserAuthDataSize,
    IN SECURITY_IMPERSONATION_LEVEL ImpersonationLevel,
    IN PTOKEN_SOURCE TokenSource,
    IN SECURITY_LOGON_TYPE LogonType,
    IN PUNICODE_STRING AuthorityName,
    OUT PHANDLE TokenHandle,
    OUT PLUID LogonId,
    OUT PUNICODE_STRING AccountName,
    OUT PNTSTATUS SubStatus
    )
{
    NTSTATUS Status ;
    PPACTYPE Pac = NULL ;
    PPAC_INFO_BUFFER LogonInfo = NULL ;
    PNETLOGON_VALIDATION_SAM_INFO3 ValidationInfo = NULL ;
    PLSA_TOKEN_INFORMATION_V1 TokenInfo = NULL ;

    LogonId->HighPart = LogonId->LowPart = 0;
    *TokenHandle = NULL;
    RtlInitUnicodeString(
        AccountName,
        NULL
        );

    *SubStatus = STATUS_SUCCESS;

    Pac = (PPACTYPE) UserAuthData ;

    if ( PAC_UnMarshal( Pac, UserAuthDataSize ) == 0 )
    {
        DebugLog(( DEB_ERROR, "Failed to unmarshall pac\n" ));

        Status = STATUS_INVALID_PARAMETER ;

        goto CreateToken_Cleanup ;
    }

    LogonInfo = PAC_Find( Pac, PAC_LOGON_INFO, NULL );

    if ( !LogonInfo )
    {
        DebugLog(( DEB_ERROR, "Failed to find logon info in pac\n" ));

        Status = STATUS_INVALID_PARAMETER ;

        goto CreateToken_Cleanup ;
    }

    Status = PAC_UnmarshallValidationInfo(
                &ValidationInfo,
                LogonInfo->Data,
                LogonInfo->cbBufferSize
                );

    if (!NT_SUCCESS(Status))
    {
        DebugLog((DEB_ERROR,"Failed to unmarshall validation info: 0x%x\n",
            Status));

        goto CreateToken_Cleanup;
    }

    //
    // Now we need to build a LSA_TOKEN_INFORMATION_V1 from the validation
    // information
    //

    Status = LsapMakeTokenInformationV1(
                ValidationInfo,
                &TokenInfo
                );

    if (!NT_SUCCESS(Status))
    {
        DebugLog((DEB_ERROR,"Failed to make token informatin v1: 0x%x\n",
            Status));
        goto CreateToken_Cleanup;
    }

    //
    // Now, copy the user name.
    //

    Status = LsapDuplicateString( AccountName, &ValidationInfo->EffectiveName );

    if ( !NT_SUCCESS( Status ) )
    {
        goto CreateToken_Cleanup ;
    }

    //
    // Now create a logon session
    //

    Status = LsapCreateLogonSession( LogonId );

    if (!NT_SUCCESS(Status))
    {
        goto CreateToken_Cleanup;
    }

    //
    // Now create the token
    //

    Status = LsapCreateToken(
                LogonId,
                TokenSource,
                LogonType,
                ImpersonationLevel,
                LsaTokenInformationV1,
                TokenInfo,
                NULL,                   // no token groups
                AccountName,
                AuthorityName,
                NULL,
                &ValidationInfo->ProfilePath,
                TokenHandle,
                SubStatus
                );

    //
    // NULL out the TokenInfo pointer.  LsapCreateToken will
    // free the memory under all conditions
    //

    TokenInfo = NULL ;

    if (!NT_SUCCESS(Status))
    {
        goto CreateToken_Cleanup;
    }

    //
    // We don't need to free the token information because CreateToken does
    // that for us.
    //

    MIDL_user_free(ValidationInfo);
    return Status ;

CreateToken_Cleanup:

    if ( TokenInfo )
    {
        LsaFreeTokenInfo( LsaTokenInformationV1, TokenInfo );
    }

    if ((LogonId->LowPart != 0) || (LogonId->HighPart != 0))
    {
        LsapDeleteLogonSession(LogonId);
    }

    LsapFreeString(
        AccountName
        );

    if (ValidationInfo != NULL)
    {
        MIDL_user_free(ValidationInfo);
    }

    return Status ;
}


//+---------------------------------------------------------------------------
//
//  Function:   LsaGetAuthDataForUser
//
//  Synopsis:   Helper function - retrieves all auth data for a user
//              based on Name, NameType, and prefix
//
//  Arguments:  [Name]             -- Name to search for
//              [NameType]         -- Type of name supplied
//              [Prefix]           -- String prefix for name
//              [UserAuthData]     --
//              [UserAuthDataSize] --
//
//  History:    6-08-98   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------

NTSTATUS
LsaGetAuthDataForUser(
    PSECURITY_STRING Name,
    SECPKG_NAME_TYPE NameType,
    OPTIONAL PSECURITY_STRING Prefix,
    PUCHAR * UserAuthData,
    PULONG UserAuthDataSize,
    OPTIONAL PUNICODE_STRING UserFlatName
    )
{
    NTSTATUS Status ;
    ULONG SamFlags ;
    PUNICODE_STRING AccountName ;
    UNICODE_STRING CombinedName = { 0 };
    SID_AND_ATTRIBUTES_LIST ReverseMembership ;
    PSAMPR_USER_ALL_INFORMATION UserAll = NULL ;
    PSAMPR_USER_INFO_BUFFER UserAllInfo = NULL ;
    PPACTYPE pNewPac = NULL ;
    PPACTYPE Pac ;
    UNICODE_STRING Domain ;
    UNICODE_STRING Machine ;
    PSID Sid ;

    Sid = NULL ;
    Machine.Buffer = NULL ;
    Domain.Buffer = NULL ;

    ReverseMembership.Count = 0 ;

    *UserAuthData = NULL ;

    if ( UserFlatName )
    {
        ZeroMemory( UserFlatName, sizeof( UNICODE_STRING ) );
    }

    SamFlags = 0 ;
    switch ( NameType )
    {
        case SecNameSamCompatible:
            AccountName = Name ;
            break;

        case SecNameAlternateId:
            SamFlags |= SAM_OPEN_BY_ALTERNATE_ID ;
            if ( !Prefix )
            {
                return STATUS_INVALID_PARAMETER ;
            }

            CombinedName.MaximumLength = Name->Length + Prefix->Length +
                                            2 * sizeof( WCHAR );

            CombinedName.Length = CombinedName.MaximumLength - sizeof( WCHAR );

            CombinedName.Buffer = (PWSTR) LsapAllocateLsaHeap( CombinedName.MaximumLength );

            if ( CombinedName.Buffer )
            {
                CopyMemory( CombinedName.Buffer, Prefix->Buffer, Prefix->Length );

                CombinedName.Buffer[ Prefix->Length / sizeof( WCHAR ) ] = L':';

                CopyMemory( &CombinedName.Buffer[ Prefix->Length / sizeof( WCHAR ) + 1],
                            Name->Buffer,
                            Name->Length );

                CombinedName.Buffer[CombinedName.Length / sizeof( WCHAR )] = L'\0';

                AccountName = &CombinedName ;
            }
            else
            {
                return SEC_E_INSUFFICIENT_MEMORY ;
            }

            break;

        case SecNameFlat:
            SamFlags |= SAM_OPEN_BY_UPN ;
            AccountName = Name ;
            break;

        case SecNameSPN:
            SamFlags |= SAM_OPEN_BY_SPN ;
            AccountName = Name ;
            break;

        default:
            return STATUS_INVALID_PARAMETER ;
    }

    Status = SamIGetUserLogonInformation(
                    LsapAccountDomainHandle,
                    SamFlags,
                    AccountName,
                    &UserAllInfo,
                    &ReverseMembership,
                    NULL );


    //
    // Free the combined name (if appropriate)
    //

    if ( CombinedName.Buffer )
    {
        LsapFreeLsaHeap( CombinedName.Buffer );
    }

    if ( !NT_SUCCESS( Status ) )
    {
        return( Status );
    }

    UserAll = &UserAllInfo->All ;

    if ( UserFlatName )
    {
        Status = LsapDuplicateString(
                        UserFlatName,
                        (PUNICODE_STRING) &UserAll->UserName );

        if ( !NT_SUCCESS( Status ) )
        {
            goto GetPac_Cleanup;
        }
    }

    if ( UserAll->UserAccountControl & USER_ACCOUNT_DISABLED )
    {
        Status = STATUS_ACCOUNT_DISABLED ;

        goto GetPac_Cleanup;
    }

    if ( UserAll->UserAccountControl & USER_ACCOUNT_AUTO_LOCKED )
    {
        Status = STATUS_ACCOUNT_LOCKED_OUT ;

        goto GetPac_Cleanup ;
    }

    Status = LsapCaptureSamInfo( &Sid, &Domain, &Machine );

    if ( !NT_SUCCESS( Status ) )
    {
        goto GetPac_Cleanup ;
    }

    Status = PAC_Init( UserAll,
                       NULL,
                       &ReverseMembership,            // no extra groups
                       Sid,
                       &Domain,
                       &Machine,
                       0,               // no signature
                       0,               // no additional data
                       NULL,            // no additional data
                       &Pac );

    if ( !NT_SUCCESS( Status ) )
    {
        goto GetPac_Cleanup ;
    }

    *UserAuthDataSize = PAC_GetSize( Pac );

    *UserAuthData = (PUCHAR) LsapAllocateLsaHeap( *UserAuthDataSize );

    if ( *UserAuthData )
    {
       PAC_Marshal( Pac, *UserAuthDataSize, *UserAuthData );
    }
    else
    {
        Status = SEC_E_INSUFFICIENT_MEMORY ;
    }

    MIDL_user_free( Pac );

GetPac_Cleanup:

    if ( UserAllInfo )
    {
        SamIFree_SAMPR_USER_INFO_BUFFER( UserAllInfo, UserAllInformation );
    }

    if ( ReverseMembership.Count )
    {
        SamIFreeSidAndAttributesList( &ReverseMembership );
    }

    if ( Sid )
    {
        LsapFreeLsaHeap( Sid );
    }

    if ( Domain.Buffer )
    {
        LsapFreeLsaHeap( Domain.Buffer );
    }

    if ( Machine.Buffer )
    {
        LsapFreeLsaHeap( Machine.Buffer );
    }

    return( Status );
}


NTSTATUS
NTAPI
LsaCrackSingleName(
    ULONG FormatOffered,
    BOOLEAN PerformAtGC,
    PUNICODE_STRING NameInput,
    OPTIONAL PUNICODE_STRING Prefix,
    ULONG RequestedFormat,
    PUNICODE_STRING CrackedName,
    PUNICODE_STRING DnsDomainName,
    PULONG SubStatus
    )
{
    NTSTATUS Status = STATUS_SUCCESS ;
    UNICODE_STRING DnsDomain ;
    UNICODE_STRING Name ;
    DWORD Ret ;
    DWORD DnsDomainLength ;
    DWORD NameLength ;
    UNICODE_STRING CombinedName = { 0 };
    PUNICODE_STRING AccountName ;

    if ( !SampUsingDsData() )
    {
        return SEC_E_UNSUPPORTED_FUNCTION ;
    }

    //
    // Cruft up the call to the DS
    //


    Name.Buffer = (PWSTR) LsapAllocateLsaHeap( MAX_PATH * sizeof(WCHAR) * 2 );
    DnsDomain.Buffer = (PWSTR) LsapAllocateLsaHeap( MAX_PATH * sizeof(WCHAR) );

    if ( Name.Buffer && DnsDomain.Buffer )
    {
        Name.MaximumLength = MAX_PATH * sizeof(WCHAR) * 2 ;
        Name.Length = 0 ;

        DnsDomain.MaximumLength = MAX_PATH * sizeof(WCHAR) ;
        DnsDomain.Length = 0 ;

        NameLength = MAX_PATH * 2 ;
        DnsDomainLength = MAX_PATH ;

        Name.Buffer[ 0 ] = L'\0';
        DnsDomain.Buffer[ 0 ] = L'\0';

        if ( Prefix )
        {
            CombinedName.MaximumLength = NameInput->Length + Prefix->Length +
                                            2 * sizeof( WCHAR );

            CombinedName.Length = CombinedName.MaximumLength - sizeof( WCHAR );

            CombinedName.Buffer = (PWSTR) LsapAllocatePrivateHeap( CombinedName.MaximumLength );

            if ( CombinedName.Buffer )
            {
                CopyMemory( CombinedName.Buffer, Prefix->Buffer, Prefix->Length );

                CombinedName.Buffer[ Prefix->Length / sizeof( WCHAR ) ] = L':';

                CopyMemory( &CombinedName.Buffer[ Prefix->Length / sizeof( WCHAR ) + 1],
                            NameInput->Buffer,
                            NameInput->Length );

                CombinedName.Buffer[CombinedName.Length / sizeof( WCHAR )] = L'\0';

                AccountName = &CombinedName ;
            }
            else
            {
                AccountName = NULL ;
            }
        }
        else
        {
            AccountName = NameInput ;
        }

        if ( AccountName )
        {
            __try
            {
                Ret = CrackSingleName(
                            FormatOffered,
                            PerformAtGC ?
                                DS_NAME_FLAG_GCVERIFY : 0,
                            AccountName->Buffer,
                            RequestedFormat,
                            &DnsDomainLength,
                            DnsDomain.Buffer,
                            &NameLength,
                            Name.Buffer,
                            SubStatus );

                if ( Ret != 0 )
                {
                    Status = STATUS_UNSUCCESSFUL ;
                }
                else
                {
                    Status = STATUS_SUCCESS ;

                    RtlInitUnicodeString( &DnsDomain, DnsDomain.Buffer );
                    RtlInitUnicodeString( &Name, Name.Buffer );

                    *CrackedName = Name ;
                    *DnsDomainName = DnsDomain ;
                }
            }
            __except( EXCEPTION_EXECUTE_HANDLER )
            {
                Status = STATUS_UNSUCCESSFUL ;
            }

            if ( CombinedName.Buffer )
            {
                LsapFreePrivateHeap( CombinedName.Buffer );
            }
        }
    }
    else
    {
        Status = SEC_E_INSUFFICIENT_MEMORY ;
    }

    if ( !NT_SUCCESS( Status ) )
    {
        if ( Name.Buffer )
        {
            LsapFreeLsaHeap( Name.Buffer );
        }

        if ( DnsDomain.Buffer )
        {
            LsapFreeLsaHeap( DnsDomain.Buffer );
        }
    }

    return Status ;
}


NTSTATUS
LsapBuildPacSidList(
    IN  PNETLOGON_VALIDATION_SAM_INFO3 UserInfo,
    OUT PSAMPR_PSID_ARRAY Sids
    )
{
    ULONG Size = 0, i;
    NTSTATUS Status = STATUS_SUCCESS ;

    Sids->Count = 0;
    Sids->Sids = NULL;

    if (UserInfo->UserId != 0)
    {
        Size += sizeof( SAMPR_SID_INFORMATION );
    }

    Size += UserInfo->GroupCount * (ULONG)sizeof( SAMPR_SID_INFORMATION );

    //
    // If there are extra SIDs, add space for them
    //

    if (UserInfo->UserFlags & LOGON_EXTRA_SIDS)
    {
        Size += UserInfo->SidCount * (ULONG)sizeof(SAMPR_SID_INFORMATION);
    }

    Sids->Sids = (PSAMPR_SID_INFORMATION) MIDL_user_allocate( Size );

    if ( Sids->Sids == NULL )
    {
        Status = STATUS_NO_MEMORY ;
        goto Cleanup;
    }

    RtlZeroMemory(
        Sids->Sids,
        Size
        );

    //
    // Start copying SIDs into the structure
    //

    i = 0;

    //
    // If the UserId is non-zero, then it contians the users RID.
    //

    if ( UserInfo->UserId )
    {
        Sids->Sids[0].SidPointer = (PRPC_SID)
                LsapMakeDomainRelativeSid( UserInfo->LogonDomainId,
                                            UserInfo->UserId );

        if( Sids->Sids[0].SidPointer == NULL )
        {
            Status = STATUS_NO_MEMORY ;
            goto Cleanup;
        }

        Sids->Count++;
    }

    //
    // Copy over all the groups passed as RIDs
    //

    for ( i=0; i < UserInfo->GroupCount; i++ )
    {

        Sids->Sids[Sids->Count].SidPointer = (PRPC_SID)
                                    LsapMakeDomainRelativeSid(
                                         UserInfo->LogonDomainId,
                                         UserInfo->GroupIds[i].RelativeId );

        if( Sids->Sids[Sids->Count].SidPointer == NULL )
        {
            Status = STATUS_NO_MEMORY ;
            goto Cleanup;
        }

        Sids->Count++;
    }

    //
    // Add in the extra SIDs
    //

    //
    // No need to allocate these, but...
    //

    if (UserInfo->UserFlags & LOGON_EXTRA_SIDS)
    {
        for ( i = 0; i < UserInfo->SidCount; i++ )
        {
            Status = LsapDuplicateSid(
                                (PSID *) &Sids->Sids[Sids->Count].SidPointer,
                                UserInfo->ExtraSids[i].Sid );

            if ( !NT_SUCCESS( Status ) )
            {
                goto Cleanup ;
            }

            Sids->Count++;
        }
    }

    //
    // Deallocate any memory we've allocated
    //

Cleanup:

    if (!NT_SUCCESS( Status ))
    {
        if (Sids->Sids != NULL)
        {
            for (i = 0; i < Sids->Count ;i++ )
            {
                if (Sids->Sids[i].SidPointer != NULL)
                {
                    MIDL_user_free(Sids->Sids[i].SidPointer);
                }
            }
            MIDL_user_free(Sids->Sids);
            Sids->Sids = NULL;
            Sids->Count = 0;
        }
    }

    return Status ;
}


NTSTATUS
NTAPI
LsaExpandAuthDataForDomain(
    IN PUCHAR UserAuthData,
    IN ULONG UserAuthDataSize,
    IN PVOID Reserved,
    OUT PUCHAR * ExpandedAuthData,
    OUT PULONG ExpandedAuthDataSize
    )
{
    NTSTATUS Status = STATUS_SUCCESS ;
    PPACTYPE Pac = NULL ;
    PPAC_INFO_BUFFER LogonInfo = NULL ;
    PNETLOGON_VALIDATION_SAM_INFO3 ValidationInfo = NULL ;
    PLSA_TOKEN_INFORMATION_V1 TokenInfo = NULL ;
    SAMPR_PSID_ARRAY SidList = {0};
    PSAMPR_PSID_ARRAY ResourceGroups = NULL;
    PPACTYPE NewPac = NULL ;
    ULONG Index ;

    Pac = (PPACTYPE) UserAuthData ;

    if ( PAC_UnMarshal( Pac, UserAuthDataSize ) == 0 )
    {
        DebugLog(( DEB_ERROR, "Failed to unmarshall pac\n" ));

        Status = STATUS_INVALID_PARAMETER ;

        goto Expand_Cleanup ;
    }

    LogonInfo = PAC_Find( Pac, PAC_LOGON_INFO, NULL );

    if ( !LogonInfo )
    {
        DebugLog(( DEB_ERROR, "Failed to find logon info in pac\n" ));

        Status = STATUS_INVALID_PARAMETER ;

        goto Expand_Cleanup ;
    }

    Status = PAC_UnmarshallValidationInfo(
                &ValidationInfo,
                LogonInfo->Data,
                LogonInfo->cbBufferSize
                );

    if (!NT_SUCCESS(Status))
    {
        DebugLog((DEB_ERROR,"Failed to unmarshall validation info: 0x%x\n",
            Status));

        goto Expand_Cleanup;
    }

    Status = LsapBuildPacSidList(
                ValidationInfo,
                &SidList );

    if ( !NT_SUCCESS( Status ) )
    {
        goto Expand_Cleanup ;
    }

    //
    // Call SAM to get the sids
    //

    Status = SamIGetResourceGroupMembershipsTransitive(
                LsapAccountDomainHandle,
                &SidList,
                0,              // no flags
                &ResourceGroups
                );

    if (!NT_SUCCESS(Status))
    {
        DebugLog((DEB_ERROR,"Failed to get resource groups: 0x%x\n",Status));
        goto Expand_Cleanup;
    }

    //
    // Now build a new pac
    //

    Status = PAC_InitAndUpdateGroups(
                ValidationInfo,
                ResourceGroups,
                Pac,
                &NewPac
                );

    if ( !NT_SUCCESS( Status ) )
    {
        goto Expand_Cleanup ;
    }

    *ExpandedAuthDataSize = PAC_GetSize( NewPac );

    *ExpandedAuthData = (PUCHAR) LsapAllocateLsaHeap( *ExpandedAuthDataSize );

    if ( *ExpandedAuthData )
    {
       PAC_Marshal( NewPac, *ExpandedAuthDataSize, *ExpandedAuthData );
    }
    else
    {
        Status = STATUS_NO_MEMORY ;
    }

    MIDL_user_free( NewPac );

Expand_Cleanup:

    if ( ValidationInfo )
    {
        MIDL_user_free( ValidationInfo );
    }

    if (SidList.Sids != NULL)
    {
        for (Index = 0; Index < SidList.Count ;Index++ )
        {
            if (SidList.Sids[Index].SidPointer != NULL)
            {
                MIDL_user_free(SidList.Sids[Index].SidPointer);
            }
        }

        MIDL_user_free(SidList.Sids);
    }

    SamIFreeSidArray(
        ResourceGroups
        );

    return Status ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\base\lsa\server\scavenge.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1993.
//
//  File:       scavenge.c
//
//  Contents:   Home of the LSA scavenger thread
//
//  Classes:
//
//  Functions:
//
//  History:    6-08-93   RichardW   Created
//
//----------------------------------------------------------------------------

#include <lsapch.hxx>

#include "scavenge.hxx"

#define SCAV_INTERNAL_NO_TRACE  0x10000000

ULONG                   ScavNotifyCount;

LIST_ENTRY              NotifyList ;
LIST_ENTRY              NotifyEvents ;
LIST_ENTRY              ScavList ;

RTL_CRITICAL_SECTION    NotifyLock ;
RTL_CRITICAL_SECTION    ScavLock ;

HKEY  LsaRegistryKey ;
HANDLE  LsaRegistryWatchEvent ;

#define SCAV_TABLE 8
PVOID                   DeadScavItems[ SCAV_TABLE ];
ULONG                   DeadScavIndex ;

#define SCAVENGER_WAIT_INTERVAL 60000L

//
// Internal flags:
//

#define SCAVFLAG_NOTIFY_EVENT   0x01000000
#define SCAVFLAG_ASYNC_TIMER_DELETE 0x00400000

#define NOTIFY_FLAG_SYNCHRONOUS 0x00000001

#define LockScavenger() RtlEnterCriticalSection( &ScavLock )
#define UnlockScavenger() RtlLeaveCriticalSection( &ScavLock )

#define LockNotify()    RtlEnterCriticalSection( &NotifyLock )
#define UnlockNotify()  RtlLeaveCriticalSection( &NotifyLock )


//
// Define locking macros for the scav list
//

#define LsapRefScavItem( Item )     \
        {                           \
            RtlEnterCriticalSection( &ScavLock ); \
            ((PLSAP_SCAVENGER_ITEM) Item)->RefCount++ ; \
            RtlLeaveCriticalSection( &ScavLock ); \
        }

#define LsapRefScavItemUnsafe( Item )   \
        {                               \
            ((PLSAP_SCAVENGER_ITEM) Item)->RefCount++ ; \
        }



DWORD
WINAPI
LsapScavengerThread(
    PVOID   Ignored
    );


BOOLEAN         LsapBreakEveryMinute = FALSE;
BOOLEAN         LsapDebuggerOk = FALSE ;

VOID
FreeScavengerItem(
    IN PLSAP_SCAVENGER_ITEM Item
    )
{
    ASSERT( Item->List.Flink == NULL );
    ASSERT( Item->PackageList.Flink == NULL );

    LsapFreePrivateHeap( Item );
}

VOID
LsapInternalBreak(
    VOID
    )
{
    if ( !LsapDebuggerOk )
    {
        return;
        
    }

    DbgBreakPoint();
}

ULONG
NTAPI
LsapScavengerBreak(
    PVOID Param
    )
{
    if (LsapBreakEveryMinute)
    {
        LsapInternalBreak();
    }

    HANDLE hToken;
    DWORD ReturnLength;

    TOKEN_STATISTICS TokenStats;

    NTSTATUS Status;

    Status = NtOpenProcessToken(
                 NtCurrentProcess(),
                 TOKEN_QUERY,
                 &hToken
                 );

    if (NT_SUCCESS( Status )) {

        Status = NtQueryInformationToken (
                     hToken,
                     TokenStatistics,
                     &TokenStats,
                     sizeof( TOKEN_STATISTICS ),
                     &ReturnLength
                     );

        if (NT_SUCCESS( Status )) {

            if (TokenStats.ExpirationTime.QuadPart == 0i64) {

                LsapInternalBreak();
            }
        }

        NtClose( hToken );
    }

    return(0);
}



//+---------------------------------------------------------------------------
//
//  Function:   LsapRegistryWatch
//
//  Synopsis:   Callback that handles registry changes in the LSA key
//
//  Arguments:  [Ignored] 
//
//  History:    05-10-00    RichardW
//
//  Notes:
//
//----------------------------------------------------------------------------
DWORD
LsapRegistryWatch(
    PVOID Ignored
    )
{
    //
    // refresh dynamically changable parameters.
    //

    LoadParameters( TRUE );

    RegNotifyChangeKeyValue(
            LsaRegistryKey,
            TRUE,
            REG_NOTIFY_CHANGE_NAME |
                REG_NOTIFY_CHANGE_LAST_SET,
            LsaRegistryWatchEvent,
            TRUE );

    LsapEventNotify(
        NOTIFY_CLASS_REGISTRY_CHANGE,
        0,
        0,
        NULL );

    return 0 ;

}


//+---------------------------------------------------------------------------
//
//  Function:   LsapDerefScavItem
//
//  Synopsis:   Dereference, optionally freeing a scavenger item
//
//  Arguments:  [Item] --
//
//  History:    6-03-97   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
VOID
LsapDerefScavItem(
    PLSAP_SCAVENGER_ITEM Item
    )
{
    HANDLE TimerDeleteHandle ;

    LockScavenger();

    Item->RefCount-- ;

    if ( Item->RefCount == 0 )
    {
        DebugLog(( DEB_TRACE_SCAV, "Removing item %x\n", Item ));

        if ( Item->List.Flink )
        {
            RemoveEntryList( &Item->List );

            Item->List.Flink = NULL ;
        }

        if ( Item->PackageList.Flink )
        {
            RemoveEntryList( &Item->PackageList );

            Item->PackageList.Flink = NULL ;
        }

        //
        // Because the rtl thread pool is asynchronous to this one,
        // we need to keep track of recently deceased scavenger items
        // to prevent them from being used in an RTL thread.  The add
        // function will scan the table to remove any potential duplicates.
        //

        DeadScavItems[ DeadScavIndex ] = Item ;
        DeadScavIndex ++ ;
        DeadScavIndex &= (SCAV_TABLE - 1);

        UnlockScavenger();

        if ( Item->Type == NOTIFIER_TYPE_INTERVAL )
        {
            //
            // Kill the timerq handle:
            //

            if ( Item->TimerHandle != INVALID_HANDLE_VALUE &&
                 Item->TimerHandle != NULL )
            {
                if ( (Item->Flags & SCAVFLAG_ASYNC_TIMER_DELETE) != 0 )
                {
                    TimerDeleteHandle = 0 ;
                }
                else
                {
                    TimerDeleteHandle = INVALID_HANDLE_VALUE ;
                }

                DeleteTimerQueueTimer( NULL,
                                       Item->TimerHandle,
                                       TimerDeleteHandle );
            }
        }
        else if ( Item->Type == NOTIFIER_TYPE_HANDLE_WAIT )
        {
            if ( Item->TimerHandle != INVALID_HANDLE_VALUE &&
                 Item->TimerHandle != NULL )
            {
                UnregisterWaitEx( Item->TimerHandle,
                                  INVALID_HANDLE_VALUE );
            }
        }

        if ( ( Item->Type != NOTIFIER_TYPE_NOTIFY_EVENT ) &&
             ( Item->Type != NOTIFIER_TYPE_IMMEDIATE ) )
        {
            //
            // Yield to let the other thread remove the item
            //

            Sleep( 100 );
        }

        Item->ScavCheck = SCAVMAGIC_FREE ;

        FreeScavengerItem( Item );
    }
    else
    {
        UnlockScavenger();
    }
}


//+---------------------------------------------------------------------------
//
//  Function:   LsapScavengerTrigger
//
//  Synopsis:   Actual Trigger
//
//  Arguments:  [Parameter] -- Item to call
//
//  History:    5-24-97   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------

ULONG
LsapScavengerTrigger(
    PVOID   Parameter
    )
{
    PLSAP_SCAVENGER_ITEM Item ;
#ifdef LSAP_VERIFY_PACKAGE_ID
    ULONG_PTR dwPackageID, dwCurId;
#endif
    
    if ( ShutdownBegun )
    {
        return 0;
    }

    SetCurrentSession( pDefaultSession );

    Item = (PLSAP_SCAVENGER_ITEM) Parameter ;

    DsysAssert( Item->ScavCheck == SCAVMAGIC_ACTIVE );

    __try
    {
#ifdef LSAP_VERIFY_PACKAGE_ID
        dwPackageID = Item->PackageId;
        dwCurId = GetCurrentPackageId();

        if ((dwCurId != SPMGR_ID) || (dwPackageID != SPMGR_ID))
#endif
        {
            SetCurrentPackageId( Item->PackageId );
        }

        (VOID) Item->Function( Item->Parameter );

#ifdef LSAP_VERIFY_PACKAGE_ID
        if (dwPackageID != SPMGR_ID)
#endif
        {
            SetCurrentPackageId( SPMGR_ID );
        }
    }
    __except( SP_EXCEPTION )
    {
        SPException( GetExceptionCode(), Item->PackageId );
    }

    LsapDerefScavItem( Item );

    return 0 ;
}


//+---------------------------------------------------------------------------
//
//  Function:   LsapTimerCallback
//
//  Synopsis:   Callback from thread pool for scavenger items
//
//  Arguments:  [Context] --
//              [Timeout] --
//
//  History:    7-01-98   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------

VOID
LsapTimerCallback(
    PVOID Context,
    BOOLEAN Timeout
    )
{
    PLSAP_SCAVENGER_ITEM Item ;
    ULONG i ;
    BOOL OneShot ;

    SetCurrentSession( pDefaultSession );

    Item = (PLSAP_SCAVENGER_ITEM) Context ;

    //
    // We only scan for handle and timer events.  Things executed
    // by QueueUserWorkItem don't end up in this list, but that's
    // okay, since those items go directly to LsapScavengerTrigger
    //

    LockScavenger();

    for ( i = 0 ; i < SCAV_TABLE ; i++ )
    {
        if ( DeadScavItems[ i ] == Item )
        {
            break;
        }
    }

    if ( i != SCAV_TABLE )
    {
        //
        // uh oh, a dead one that was still in the queue in this
        // rtl worker thread.  Ignore it.
        //

        UnlockScavenger();

        return ;
    }

    if ( Item->Flags & SCAVFLAG_ASYNC_TIMER_DELETE )
    {
        //
        // This is a bad condition.  An item that should have
        // been fired once has shown up again.  Ignore it.
        //

        UnlockScavenger();

        return;
    }

    LsapRefScavItemUnsafe( Item );

    OneShot = ( Item->Flags & NOTIFIER_FLAG_ONE_SHOT ) != 0 ;

    if ( OneShot )
    {
        //
        // This flag has the side effect of preventing further
        // callbacks.  That lets us delete is asynchronously later.
        //

        Item->Flags |= SCAVFLAG_ASYNC_TIMER_DELETE ;
        
    }

    UnlockScavenger();

    if ( (Item->Flags & SCAV_INTERNAL_NO_TRACE ) == 0 )
    {
        DebugLog(( DEB_TRACE_SCAV, "Triggering item %x, type %d\n",
                    Item, Item->Type ));
    }

    LsapScavengerTrigger( Item );

    //
    // If this is a one-shot item that's in the list, then it was
    // a delayed or otherwise "real" one-shot.  Deref it again to 
    // kill it.
    //
    if ( OneShot )
    {
        LsapDerefScavItem( Item );
    }
}


//+---------------------------------------------------------------------------
//
//  Function:   LsapScavengerHandleNotify
//
//  Synopsis:   Called whenever a notification event goes off.
//
//  Arguments:  [Ignored] --
//
//  History:    5-23-97   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------

DWORD
WINAPI
LsapScavengerHandleNotify(
    PVOID Ignored
    )
{
    PLIST_ENTRY NotifyScan ;
    PLIST_ENTRY EventScan ;
    PLSAP_NOTIFY_EVENT Event ;
    PLSAP_SCAVENGER_ITEM Item ;

    do
    {
        LockNotify();

        if ( !IsListEmpty( &NotifyEvents ) )
        {
            EventScan = RemoveHeadList( &NotifyEvents );
        }
        else
        {
            EventScan = NULL ;
        }

        UnlockNotify();

        if ( EventScan )
        {
            Event = CONTAINING_RECORD( EventScan, LSAP_NOTIFY_EVENT, List );

            LockScavenger();

            NotifyScan = NotifyList.Flink ;

            while ( NotifyScan != &NotifyList )
            {
                Item = CONTAINING_RECORD( NotifyScan, LSAP_SCAVENGER_ITEM, List );

                if ( Item->Class == Event->Notify.EventClass )
                {
                    Event->Notify.PackageParameter = Item->Parameter ;

                    Item->Function( &Event->Notify );
                }

                NotifyScan = NotifyScan->Flink ;
            }

            UnlockScavenger();

            if ( Event->Flags & NOTIFY_FLAG_SYNCHRONOUS )
            {
                SetEvent( Event->hSync );
            }

            LsapFreeLsaHeap( Event );
        }
    } while ( EventScan );

    return 0 ;
}


//+---------------------------------------------------------------------------
//
//  Function:   LsaIRegisterNotification
//
//  Synopsis:   Registers a callback, to be called on either a handle signalled,
//              or an time based interval, or special async events
//
//  Arguments:  [pFunction]   -- Callback function
//              [pvParameter] -- Parameter to pass
//              [Type]        -- Type of callback
//              [Class]       -- Event class
//              [fItem]       -- Flags
//              [Interval]    -- Interval to call
//              [hEvent]      -- Handle to wait on
//
//  History:    6-03-97   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
PVOID
NTAPI
LsaIRegisterNotification(
    IN LPTHREAD_START_ROUTINE pFunction,
    IN PVOID pvParameter,
    IN ULONG Type,
    IN ULONG Class,
    IN ULONG fItem,
    IN ULONG Interval,
    IN HANDLE hEvent)
{
    PLSAP_SCAVENGER_ITEM Item ;
    PLIST_ENTRY List = NULL ;
    BOOL Success ;
    DWORD DueTime ;
    ULONG i;

    Item = (PLSAP_SCAVENGER_ITEM) LsapAllocatePrivateHeap(
                                    sizeof( LSAP_SCAVENGER_ITEM ) );

    if ( !Item )
    {
        return NULL ;
    }

    Item->List.Flink = NULL ;
    Item->PackageList.Flink = NULL ;

    Item->Type = Type ;
    Item->Function = pFunction ;
    Item->Parameter = pvParameter ;
    Item->RefCount = 1 ;
    Item->PackageId = GetCurrentPackageId();
    Item->ScavCheck = SCAVMAGIC_ACTIVE;
    Item->Flags = fItem ;
    Item->TimerHandle = INVALID_HANDLE_VALUE;

    //
    // Okay, we have set up the item, more or less.  Now, insert it
    // into the list we have selected for it.
    //

    DebugLog(( DEB_TRACE_SCAV, "Created scavenger item %x, type %d\n",
                    Item, Item->Type ));

    switch ( Type )
    {
        case NOTIFIER_TYPE_IMMEDIATE:

            Item->Flags |= NOTIFIER_FLAG_ONE_SHOT ;

            Success = QueueUserWorkItem( LsapScavengerTrigger,
                                         Item,
                                         FALSE );

            //
            // And that's all.  the item may in fact be freed by now, since the
            // worker thread could have completed.  So, return success now,
            //

            return (Item);

            break;

        case NOTIFIER_TYPE_INTERVAL:
        case NOTIFIER_TYPE_HANDLE_WAIT:

            LockScavenger();

            InsertTailList( &ScavList, &Item->List );

            //
            // Make sure this pointer doesn't show up in the list of dead ones.
            // this can happen due to heap reuse.
            //

            for ( i = 0 ; i < SCAV_TABLE ; i++ )
            {
                if ( DeadScavItems[ i ] == Item )
                {
                    DeadScavItems[ i ] = NULL ;
                }
            }

            UnlockScavenger();

            if ( Type == NOTIFIER_TYPE_INTERVAL )
            {
                if ( fItem & NOTIFIER_FLAG_SECONDS )
                {
                    Interval *= 60 ;
                }

                Interval *= 1000 ;

                Success = CreateTimerQueueTimer(
                                        &Item->TimerHandle,
                                        NULL,
                                        LsapTimerCallback,
                                        Item,
                                        Interval,
                                        (fItem & NOTIFIER_FLAG_ONE_SHOT ?
                                            0 : Interval ),
                                        0 );
            }
            else
            {
                ASSERT( Type == NOTIFIER_TYPE_HANDLE_WAIT );

                Item->TimerHandle = RegisterWaitForSingleObjectEx(
                                            hEvent,
                                            LsapTimerCallback,
                                            Item,
                                            INFINITE,
                                            (fItem & NOTIFIER_FLAG_NEW_THREAD ?
                                                0 : WT_EXECUTEINWAITTHREAD ) );

                Success = (Item->TimerHandle != NULL);
            }

            if ( !Success )
            {
                LsapDerefScavItem( Item );

                return NULL ;
            }

            break;

        case NOTIFIER_TYPE_NOTIFY_EVENT:

            Item->Class = Class ;
            Item->Flags |= SCAVFLAG_NOTIFY_EVENT ;

            LockScavenger();

            InsertTailList( &NotifyList, &Item->List );

            UnlockScavenger();

            Success = TRUE ;

            break;

        default:

            Success = FALSE ;

            FreeScavengerItem( Item );

            break;
    }

    return Item ;
}


//+---------------------------------------------------------------------------
//
//  Function:   LsaICancelNotification
//
//  Arguments:  [pvScavHandle] --
//
//  History:    5-26-97   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------

NTSTATUS
NTAPI
LsaICancelNotification(
    PVOID       pvScavHandle
    )
{
    PLSAP_SCAVENGER_ITEM Item ;

    Item = (PLSAP_SCAVENGER_ITEM) pvScavHandle ;

    if ( Item->ScavCheck != SCAVMAGIC_ACTIVE )
    {
        return STATUS_INVALID_PARAMETER ;
    }

    LsapDerefScavItem( Item );

    return STATUS_SUCCESS ;
}


//+---------------------------------------------------------------------------
//
//  Function:   LsapEventNotify
//
//  Synopsis:   Notify waiters of a security package event
//
//  Arguments:  [Class]     -- Event Class
//              [Flags]     -- Flags
//              [EventSize] -- Size of event data
//              [EventData] -- ptr to event data
//
//  History:    5-26-97   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------

BOOLEAN
NTAPI
LsapEventNotify(
    ULONG       Class,
    ULONG       Flags,
    ULONG       EventSize,
    PVOID       EventData)
{
    PLSAP_NOTIFY_EVENT Event ;
    HANDLE        hEvent = NULL;

    Event = (PLSAP_NOTIFY_EVENT) LsapAllocateLsaHeap( sizeof( LSAP_NOTIFY_EVENT ) + EventSize );
    if (Event)
    {
        Event->Notify.EventClass = Class;
        Event->Notify.EventDataSize = EventSize;
        Event->Notify.EventData = (PUCHAR) ( Event + 1 );

        RtlCopyMemory(  Event->Notify.EventData,
                        EventData,
                        EventSize );

        Event->Flags = Flags;

        if (Flags & NOTIFY_FLAG_SYNCHRONOUS)
        {
            hEvent = CreateEvent( NULL, TRUE, FALSE, NULL );

            Event->hSync = hEvent ;

            if (!Event->hSync)
            {
                LsapFreeLsaHeap( Event );
                return(FALSE);
            }
        }
        else
        {
            Event->hSync = NULL ;
        }

        //
        // Insert event into list
        //

        LockNotify();

        InsertTailList( &NotifyEvents, &Event->List );

        UnlockNotify();

        DebugLog((DEB_TRACE_SCAV, "EventNotify( %d ) - Data at %x\n",
                    Class, Event->Notify.EventData ));

        //
        // Wake up the scavenger thread
        //

        SetEvent( hStateChangeEvent );

        //
        // If told to wait, block until scav thread signals the event
        //

        if (Flags & NOTIFY_FLAG_SYNCHRONOUS)
        {
            WaitForSingleObjectEx(  hEvent,
                                    INFINITE,
                                    FALSE );

            CloseHandle( hEvent );
        }

        return( TRUE );
    }

    return( FALSE );
}


//+---------------------------------------------------------------------------
//
//  Function:   LsapInitializeScavenger
//
//  Synopsis:   Initialize Scavenger,
//
//  Arguments:  (none)
//
//  History:    5-26-97   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------

BOOL
LsapInitializeScavenger(
    VOID
    )
{
    ULONG i ;
    PVOID hNotify ;
    HANDLE hThread ;
    DWORD tid ;
    DWORD Debugger ;
    DWORD dwSize ;
    DWORD dwType ;
    SYSTEM_KERNEL_DEBUGGER_INFORMATION KdInfo ;

    //
    // Initialize the lists
    //

    InitializeListHead( &NotifyList );

    InitializeListHead( &NotifyEvents );

    InitializeListHead( &ScavList );

    RtlInitializeCriticalSection( &ScavLock );

    RtlInitializeCriticalSection( &NotifyLock );

    //
    // Event set whenever there is a notification.
    //

    hStateChangeEvent = CreateEvent(NULL, FALSE, FALSE, NULL);

    //
    // Create basic entries
    //

    hNotify = LsaIRegisterNotification( LsapScavengerHandleNotify,
                                        0,
                                        NOTIFIER_TYPE_HANDLE_WAIT,
                                        0,
                                        NOTIFIER_FLAG_NEW_THREAD,
                                        0,
                                        hStateChangeEvent );


    if ( RegOpenKeyEx( HKEY_LOCAL_MACHINE,
                        TEXT("System\\CurrentControlSet\\Control\\Lsa"),
                        0,
                        KEY_READ,
                        &LsaRegistryKey ) == 0 )
    {
        LsaRegistryWatchEvent = CreateEvent( NULL, FALSE, FALSE, NULL );

        if ( LsaRegistryWatchEvent )
        {
            hNotify = LsaIRegisterNotification(
                                LsapRegistryWatch,
                                NULL,
                                NOTIFIER_TYPE_HANDLE_WAIT,
                                0,
                                NOTIFIER_FLAG_NEW_THREAD,
                                0,
                                LsaRegistryWatchEvent );

            if ( hNotify )
            {
                //
                // Call it once to start the registry watch
                //
                LsapRegistryWatch( NULL );
            }
            else 
            {
                CloseHandle( LsaRegistryWatchEvent );
            }
        }
        else 
        {
            RegCloseKey( LsaRegistryKey );
        }
    }

    //
    // If we are under a debugger, or a kernel debugger is attached, or the
    // flag is in the registry, turn on the watch thread
    //

    Debugger = 0 ;
    dwSize = sizeof( Debugger );

    RegQueryValueEx( LsaRegistryKey,
                     TEXT("EnableDebugCheck"),
                     0,
                     &dwType,
                     (PBYTE) &Debugger,
                     &dwSize );

    NtQuerySystemInformation(
        SystemKernelDebuggerInformation,
        &KdInfo,
        sizeof( KdInfo ),
        NULL );


    if ( (KdInfo.KernelDebuggerEnabled) || 
         (NtCurrentPeb()->BeingDebugged) ||
         (Debugger != 0 ) )
    {

        LsapDebuggerOk = TRUE ;

        (void) LsaIRegisterNotification(
                        LsapScavengerBreak,
                        NULL,
                        NOTIFIER_TYPE_INTERVAL,
                        0,          // no class
                        SCAV_INTERNAL_NO_TRACE,          // no flags
                        60,         // every minute
                        NULL        // no handle
                        );
    }

    return TRUE ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\base\lsa\server\sesmgr.h ===
//+-----------------------------------------------------------------------
//
// Microsoft Windows
//
// Copyright (c) Microsoft Corporation 1991 - 1992
//
// File:        SesMgr.h
//
// Contents:    "Session" manager structures.
//
//
// History:     27 May 92   RichardW    Created from ether
//
//------------------------------------------------------------------------

#ifndef __SESMGR_H__
#define __SESMGR_H__

#ifdef __cplusplus
extern "C" {
#endif

#include "handle.h"

//
// Forward definition so that we can reference it
//

struct _Session;

//
// Shared Section structure.  This allows packages to create shared
// sections with client processes.
//

typedef struct _LSAP_SHARED_SECTION {
    LIST_ENTRY  List;                       // List of sections for a session
    PVOID       Base;                       // Base pointer
    HANDLE      Heap;                       // Heap handle
    struct _Session * Session;              // Session pointer
    HANDLE      Section;                    // Handle to section object
} LSAP_SHARED_SECTION, * PLSAP_SHARED_SECTION ;

typedef struct _LSAP_THREAD_TASK {
    LIST_ENTRY              Next;
    struct _Session *       pSession;
    LPTHREAD_START_ROUTINE  pFunction;
    PVOID                   pvParameter;
} LSAP_THREAD_TASK, * PLSAP_THREAD_TASK;

typedef enum _LSAP_TASK_QUEUE_TYPE {
    QueueShared,                            // Queue shared by many threads
    QueueSingle,                            // Queue owned/run by single thread
    QueueShareRead,                         // Queue with dedicated thread, but
                                            // linked to other queue
    QueueZombie                             // Queue pending deletion
} LSAP_TASK_QUEUE_TYPE;

typedef struct _LSAP_TASK_QUEUE {
    LSAP_TASK_QUEUE_TYPE        Type;           // Type of Queue
    HANDLE                      hSemaphore;     // Semaphore to gate access
    CRITICAL_SECTION            Lock;           // Per-q lock
    LONG                        Tasks;          // Number of Tasks
    LIST_ENTRY                  pTasks;         // List of tasks
    struct _LSAP_TASK_QUEUE *   pNext;          // Next Queue
    struct _LSAP_TASK_QUEUE *   pShared;        // Shared Queue
    LONG                        TotalThreads;   // Total Threads (for Shared)
    LONG                        IdleThreads;    // Idle Threads (for Shared)
    struct _LSAP_TASK_QUEUE *   pOriginal;      // "Parent" queue for shareread
    struct _Session *           OwnerSession;   // Owning session record
    LONGLONG                    TaskCounter;    // Total number of tasks
    LONGLONG                    QueuedCounter;  // Total number queued
    HANDLE                      StartSync;      // Event for start syncing
    LONG                        MissedTasks;    // Number of tasks grabbed by other threads
    LONG                        ReqThread ;     // Number of times had to start another thd
    LONG                        MaxThreads ;    // Max # threads
    LONG                        TaskHighWater ; // Max # tasks
} LSAP_TASK_QUEUE, * PLSAP_TASK_QUEUE;

typedef 
NTSTATUS (LSAP_SESSION_CONNECT_FN)(
    struct _Session *   Session,
    PVOID               Parameter
    );

typedef LSAP_SESSION_CONNECT_FN * PLSAP_SESSION_CONNECT_FN ;

typedef struct _LSAP_SESSION_CONNECT {
    LIST_ENTRY  List ;
    PLSAP_SESSION_CONNECT_FN    Callback ;
    ULONG   ConnectFilter ;
    PVOID Parameter ;
} LSAP_SESSION_CONNECT, * PLSAP_SESSION_CONNECT ;

typedef HRESULT (LSAP_SESSION_RUNDOWN_FN)(
    struct _Session *   Session,
    PVOID               Parameter
    );

typedef LSAP_SESSION_RUNDOWN_FN * PLSAP_SESSION_RUNDOWN_FN ;

typedef struct _LSAP_SESSION_RUNDOWN {
    LIST_ENTRY List ;
    PLSAP_SESSION_RUNDOWN_FN Rundown ;
    PVOID Parameter ;
} LSAP_SESSION_RUNDOWN, * PLSAP_SESSION_RUNDOWN ;

typedef struct _LSAP_SHARED_SESSION_DATA {
    PVOID            CredTable ;
    PVOID            ContextTable ;
    PLSAP_TASK_QUEUE pQueue ;
    PHANDLE_PACKAGE CredHandlePackage ;
    PHANDLE_PACKAGE ContextHandlePackage ;
    ULONG       cRefs ;
} LSAP_SHARED_SESSION_DATA, * PLSAP_SHARED_SESSION_DATA ;

typedef struct _Session {
    LIST_ENTRY          List ;
    DWORD               dwProcessID;            // ID of the calling process
    PLSAP_SHARED_SESSION_DATA SharedData ;      // Shared data for kernel sessions
    HANDLE              hPort;                  // Comm port used by this ses
    DWORD               fSession;               // Flags
    HANDLE              hProcess;               // Handle to the process
    CRITICAL_SECTION    SessionLock;            // Session Lock
    LONG                RefCount;               // Reference Count
    DWORD               ThreadId;               // Dedicated Thread (possible)
    LPWSTR              ClientProcessName;      // name of the registering process
    ULONG               SessionId;              // Hydra Session Id
    LIST_ENTRY          SectionList;            // List of sharedsections
    LIST_ENTRY          RundownList ;           // List of rundown hooks
    LONGLONG            CallCount ;             // Calls processed
    ULONG               Tick ;                  // Tick Count last snap
    LSAP_SHARED_SESSION_DATA DefaultData ;
} Session, * PSession;

#define SESFLAG_TCB_PRIV    0x00000002      // Client has TCB privilege
#define SESFLAG_CLONE       0x00000004      // Assumed identity
#define SESFLAG_IMPERSONATE 0x00000008      // Session is an impersonation
#define SESFLAG_UNTRUSTED   0x00000020      // Session didn't require TCB priv
#define SESFLAG_INPROC      0x00000040      // Session is an inprocess clone
#define SESFLAG_DEFAULT     0x00000100      // Default session for inactive
#define SESFLAG_UNLOADING   0x00000200      // Session called SpmUnload
#define SESFLAG_CLEANUP     0x00000800      // Session is being deleted
#define SESFLAG_KERNEL      0x00001000      // Handle list is shared kernel-mode list
#define SESFLAG_MAYBEKERNEL 0x00004000      // might be kernel (see sesmgr.cxx)
#define SESFLAG_EFS         0x00008000      // EFS session
#define SESFLAG_WOW_PROCESS 0x00020000      // WOW64 Process

extern  PSession    pDefaultSession;
extern  PSession    pEfsSession ;
extern  LSAP_TASK_QUEUE   GlobalQueue;

BOOL
InitSessionManager( void);

VOID
LsapFindEfsSession(
    VOID
    );

VOID
LsapUpdateEfsSession(
    PSession pSession
    );

HRESULT
CreateSession(  CLIENT_ID * pCid,
                BOOL        fOpenImmediate,
                PWCHAR      ClientProcessName,
                ULONG       Flags,
                PSession *  ppSession);

HRESULT
CloneSession(   PSession    pOriginalSession,
                PSession *  ppSession,
                ULONG       Flags );

void
FreeSession(PSession    pSession);


VOID
SpmpReferenceSession(
    PSession    pSession);

VOID
SpmpDereferenceSession(
    PSession    pSession);

VOID
LsapSessionDisconnect(
    PSession    pSession
    );

BOOL
AddRundown( PSession            pSession,
            PLSAP_SESSION_RUNDOWN_FN RundownFn,
            PVOID               pvParameter);

BOOL
DelRundown( PSession            pSession,
            PLSAP_SESSION_RUNDOWN_FN RundownFn
            );

BOOLEAN
AddCredHandle(  PSession    pSession,
                PCredHandle phCred,
                ULONG Flags );

BOOLEAN
AddContextHandle(   PSession    pSession,
                    PCtxtHandle phContext,
                    ULONG Flags);

NTSTATUS
ValidateContextHandle(  
    PSession    pSession,
    PCtxtHandle phContext,
    PVOID *     pKey
    );

VOID
DerefContextHandle(
    PSession    pSession,
    PCtxtHandle phContext,
    PVOID       Key OPTIONAL
    );

NTSTATUS
ValidateAndDerefContextHandle(
    PSession pSession,
    PCtxtHandle phContext
    );

NTSTATUS
ValidateCredHandle(  
    PSession    pSession,
    PCtxtHandle phCred,
    PVOID *     pKey
    );

VOID
DerefCredHandle(
    PSession    pSession,
    PCtxtHandle phCred,
    PVOID       Key OPTIONAL
    );

NTSTATUS
ValidateAndDerefCredHandle(
    PSession pSession,
    PCtxtHandle phCred
    );                

//
// PSession
// GetCurrentSession( VOID );
//
#define GetCurrentSession() ((PSession) TlsGetValue( dwSession ))

//
// VOID
// SetCurrentSession( PSession pSession );
//
#define SetCurrentSession( p ) TlsSetValue( dwSession, (PVOID) p )

//
// VOID
// LockSession( PSession pSession );
//
#define LockSession( p )    RtlEnterCriticalSection( &(((PSession) p)->SessionLock) )

//
// VOID
// UnlockSession( PSession pSession );
//
#define UnlockSession( p )  RtlLeaveCriticalSection( &(((PSession) p)->SessionLock) )

#define GetCurrentPackageId()   ((ULONG_PTR) TlsGetValue(dwThreadPackage))

#ifdef LSAP_VERIFY_PACKAGE_ID
extern BOOL RefSetCurrentPackageId(DWORD dwPackageId);
#define SetCurrentPackageId(p)  RefSetCurrentPackageId((DWORD) p)
#else
#define SetCurrentPackageId(p)  TlsSetValue(dwThreadPackage, (PVOID)p)
#endif // LSAP_VERIFY_PACKAGE_ID

#ifdef __cplusplus
} // extern C
#endif

#endif // __SESMGR_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\base\lsa\server\shmem.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1997.
//
//  File:      shmem.cxx
//
//  Contents:
//
//  History:
//             RichardW   12/17/1996    Created
//
//----------------------------------------------------------------------------

#include <lsapch.hxx>

#define LSA_SHARED_HEAP_FLAGS   (HEAP_NO_SERIALIZE | \
                                HEAP_GENERATE_EXCEPTIONS | \
                                HEAP_ZERO_MEMORY | \
                                HEAP_REALLOC_IN_PLACE_ONLY | \
                                HEAP_TAIL_CHECKING_ENABLED | \
                                HEAP_FREE_CHECKING_ENABLED | \
                                HEAP_DISABLE_COALESCE_ON_FREE | \
                                HEAP_CREATE_ALIGN_16 | \
                                HEAP_CREATE_ENABLE_TRACING )

#if DBG

#define LSA_DEFAULT_HEAP_FLAGS  (HEAP_ZERO_MEMORY | \
                                HEAP_TAIL_CHECKING_ENABLED | \
                                HEAP_FREE_CHECKING_ENABLED )

#else

#define LSA_DEFAULT_HEAP_FLAGS  (HEAP_ZERO_MEMORY)

#endif

//+---------------------------------------------------------------------------
//
//  Function:   LsapCreateSharedSection
//
//  Synopsis:   Internal worker that creates a section mapped into the process
//              indicated by pSession
//
//  Effects:
//
//  Arguments:  [pSession]    -- Session where section should be mapped
//              [HeapFlags]   -- Heap flags for section
//              [InitialSize] -- Initial size
//              [MaxSize]     -- Maximum size
//
//  History:    1-29-97   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
PLSAP_SHARED_SECTION
LsapCreateSharedSection(
    PSession pSession,
    ULONG   HeapFlags,
    ULONG   InitialSize,
    ULONG   MaxSize
    )
{
    HANDLE  Section ;
    PLSAP_SHARED_SECTION SharedSection ;
    LARGE_INTEGER SectionOffset ;
    NTSTATUS Status ;
    PVOID ClientBase ;
    SIZE_T ViewSize ;

    //
    // Create the section.  The security descriptor is defaulted to
    // local system for now, although this will fixed.
    //

    Section = CreateFileMapping( INVALID_HANDLE_VALUE,
                                 NULL,  
                                 PAGE_READWRITE |
                                    SEC_RESERVE,
                                 0,
                                 MaxSize,
                                 NULL );

    if ( Section == NULL )
    {
        return NULL ;
    }

    SharedSection = (PLSAP_SHARED_SECTION ) LsapAllocateLsaHeap( sizeof( LSAP_SHARED_SECTION ) );

    if ( !SharedSection )
    {
        CloseHandle( Section );

        return NULL ;
    }

    SharedSection->Section = Section ;


    //
    // Map the shared section into our address space:
    //

    SharedSection->Base = MapViewOfFileEx( Section,
                                           FILE_MAP_READ | FILE_MAP_WRITE,
                                           0,
                                           0,
                                           0,
                                           NULL );

    if ( !SharedSection->Base )
    {
        CloseHandle( Section );
        LsapFreeLsaHeap( SharedSection );
        return NULL ;
    }

    //
    // Map it into the client's address space
    //

    SectionOffset.QuadPart = 0;

    ClientBase = SharedSection->Base ;
    ViewSize = 0 ;

    Status = NtMapViewOfSection( Section,
                                 pSession->hProcess,
                                 &ClientBase,
                                 0L,
                                 0L,
                                 NULL,
                                 &ViewSize,
                                 ViewUnmap,
                                 0L,
                                 PAGE_READWRITE );

    if ( !NT_SUCCESS( Status ) )
    {
        UnmapViewOfFile( SharedSection->Base );
        CloseHandle( SharedSection->Section );
        LsapFreeLsaHeap( SharedSection );

        return NULL ;
    }

    //
    // Okay, now commit the initial size, and start the heap on it.
    //

    if ( NULL == VirtualAllocEx(
                     GetCurrentProcess(),
                     SharedSection->Base,
                     InitialSize,
                     MEM_COMMIT,
                     PAGE_READWRITE ))
    {
        UnmapViewOfFile( SharedSection->Base );
        CloseHandle( SharedSection->Section );
        LsapFreeLsaHeap( SharedSection );

        return NULL;
    }

    HeapFlags &= LSA_SHARED_HEAP_FLAGS ;

    SharedSection->Heap = RtlCreateHeap( HeapFlags,
                                         SharedSection->Base,
                                         MaxSize,
                                         InitialSize,
                                         NULL,
                                         NULL );

    if ( !SharedSection->Heap )
    {
        UnmapViewOfFile( SharedSection->Base );
        CloseHandle( SharedSection->Section );
        LsapFreeLsaHeap( SharedSection );

        return NULL ;
    }

    return SharedSection ;
}


//+---------------------------------------------------------------------------
//
//  Function:   LsapDeleteSharedSection
//
//  Synopsis:   Internal worker that deletes a shared section
//
//  Arguments:  [SharedSection] -- section to delete
//
//  History:    1-29-97   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------

BOOL
LsapDeleteSharedSection(
    PLSAP_SHARED_SECTION SharedSection
    )
{
    RtlDestroyHeap( SharedSection->Heap );

    NtUnmapViewOfSection(   SharedSection->Session->hProcess,
                            SharedSection->Base );

    NtUnmapViewOfSection(   NtCurrentProcess(),
                            SharedSection->Base );

    CloseHandle( SharedSection->Section );

    LsapFreeLsaHeap( SharedSection );

    return TRUE;
}


HRESULT
LsapSharedSectionRundown(
    PSession    Session,
    PVOID       Ignored
    )
{
    PLIST_ENTRY List ;
    PLSAP_SHARED_SECTION Section ;

    while ( !IsListEmpty( &Session->SectionList ) )
    {
        List = RemoveHeadList( &Session->SectionList );

        Section = (PLSAP_SHARED_SECTION) List ;

        LsapDeleteSharedSection( Section );
    }

    return SEC_E_OK ;
}


//////////////////////////////////////////////////////////////////////////////
//
//   Functions exported to security packages for shared memory
//
//////////////////////////////////////////////////////////////////////////////

//+---------------------------------------------------------------------------
//
//  Function:   LsaCreateSharedMemory
//
//  Synopsis:   "Public" function to create the shared memory segment
//
//  Arguments:  [MaxSize]     --
//              [InitialSize] --
//
//  History:    1-29-97   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------

PVOID
NTAPI
LsaCreateSharedMemory(
    ULONG   InitialSize,
    ULONG   MaxSize
    )
{
    PSession    pSession ;
    PLSAP_SHARED_SECTION SharedSection ;

    pSession = GetCurrentSession();

    //
    // Validate that we are running in a real call with a real client
    //

    if (pSession->dwProcessID == GetCurrentProcessId())
    {
        return NULL ;
    }

    //
    // Try to create the shared section
    //

    SharedSection = LsapCreateSharedSection(
                        pSession,
                        LSA_DEFAULT_HEAP_FLAGS,
                        InitialSize,
                        MaxSize
                        );

    if ( SharedSection )
    {
        SharedSection->Session = pSession ;

        LockSession( pSession );

        if ( IsListEmpty( &pSession->SectionList ) )
        {
            if ( FALSE == AddRundown( pSession, LsapSharedSectionRundown, NULL ))
            {
                UnlockSession( pSession );
                LsapDeleteSharedSection( SharedSection );
                SharedSection = NULL;
            }
        }
    }

    if ( SharedSection )
    {
        InsertTailList( &pSession->SectionList,
                        &SharedSection->List );

        UnlockSession( pSession );
    }

    return SharedSection ;
}


//+---------------------------------------------------------------------------
//
//  Function:   LsaAllocateSharedMemory
//
//  Synopsis:   Allocates memory out of a shared section.
//
//  Arguments:  [Shared] -- Handle to shared section
//              [Size]   -- Size of allocation.
//
//  History:    1-29-97   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
PVOID
NTAPI
LsaAllocateSharedMemory(
    PVOID   Shared,
    ULONG   Size
    )
{
    PLSAP_SHARED_SECTION SharedSection = (PLSAP_SHARED_SECTION) Shared ;

    return RtlAllocateHeap( SharedSection->Heap, 0, Size );
}


//+---------------------------------------------------------------------------
//
//  Function:   LsaFreeSharedMemory
//
//  Synopsis:   Frees memory allocated out of a section
//
//  Arguments:  [Shared] --
//              [Memory] --
//
//  History:    1-29-97   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------

VOID
NTAPI
LsaFreeSharedMemory(
    PVOID   Shared,
    PVOID   Memory
    )
{
    PLSAP_SHARED_SECTION SharedSection = (PLSAP_SHARED_SECTION) Shared ;

    HeapFree( SharedSection->Heap, 0, Memory );
}


//+---------------------------------------------------------------------------
//
//  Function:   LsaDeleteSharedMemory
//
//  Synopsis:   Public wrapper to delete the shared section
//
//  Arguments:  [Shared] -- handle to shared section
//
//  History:    1-29-97   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------

BOOLEAN
NTAPI
LsaDeleteSharedMemory(
    PVOID   Shared
    )
{
    PLSAP_SHARED_SECTION SharedSection ;
    PSession pSession ;
    BOOL Success ;

    pSession = GetCurrentSession();

    SharedSection = (PLSAP_SHARED_SECTION) Shared ;

    if ( pSession != SharedSection->Session )
    {
        DebugLog(( DEB_WARN, "Package tried to delete shared memory for a different process\n" ));

        return FALSE ;
    }

    LockSession( pSession );

    RemoveEntryList( &SharedSection->List );

    Success = LsapDeleteSharedSection( SharedSection );

    if ( IsListEmpty( &pSession->SectionList ) )
    {
        DelRundown( pSession, LsapSharedSectionRundown );
    }

    UnlockSession( pSession );

    return ( Success != 0 ) ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\base\lsa\server\sidcache.h ===
//+-----------------------------------------------------------------------------
//
// Microsoft Windows
//
// Copyright (c) Microsoft Corporation 1992 - 1994
//
// File:        sidcache.h
//
// Contents:    types and prototypes for sid cache management
//
//
// History:     15-May-1997     MikeSw          Created
//
//------------------------------------------------------------------------------

#ifndef __SIDCACHE_H__
#define __SIDCACHE_H__


////////////////////////////////////////////////////////////////////////////////
//
// Sid Cache Data types exported for lsaexts
//
////////////////////////////////////////////////////////////////////////////////

typedef struct _LSAP_DB_SID_CACHE_ENTRY {

    struct _LSAP_DB_SID_CACHE_ENTRY * Next;

    //
    // Cache data
    //
    PSID Sid;
    UNICODE_STRING AccountName;
    SID_NAME_USE SidType;
    PSID DomainSid;
    UNICODE_STRING DomainName;

    //
    // These time values are only used for SID cache 
    // entries that aren't associated with an actual logon session.
    //
    LARGE_INTEGER ExpirationTime;
    LARGE_INTEGER RefreshTime;
    LARGE_INTEGER CreateTime;
    LARGE_INTEGER LastUse;
    ULONG         Flags;

    //
    // InUseCount is only used for SID cache entries that are
    // currently associated with an actual logon session.  As long as
    // InUseCount is nonzero, ExpirationTime will not be checked.
    // Once InUseCount is zero, ExpirationTime will be set.
    //
    LONG          InUseCount;

} LSAP_DB_SID_CACHE_ENTRY, *PLSAP_DB_SID_CACHE_ENTRY;


//
// Flags to describe the cache entry
//

//
// The name in the AccountName and DomainName fields represents
// a SAM account name
//
#define LSAP_SID_CACHE_SAM_ACCOUNT_NAME 0x00000001

//
// The AccountName is a UPN
//
#define LSAP_SID_CACHE_UPN              0x00000002


////////////////////////////////////////////////////////////////////////////////
//
// Exported Sid Cache functions
//
////////////////////////////////////////////////////////////////////////////////

NTSTATUS
LsapDbInitSidCache(
    VOID
    );
VOID
LsapSidCacheReadParameters(
    HKEY hKey
    );

VOID
LsapDbUpdateCacheWithSids(
    IN PSID *Sids,
    IN ULONG Count,
    IN OUT PLSAPR_REFERENCED_DOMAIN_LIST ReferencedDomains,
    IN PLSA_TRANSLATED_NAME_EX TranslatedNames
    );

VOID
LsapDbUpdateCacheWithNames(
    IN PUNICODE_STRING AccountNames,
    IN PUNICODE_STRING DomainNames,
    IN ULONG Count,
    IN OUT PLSAPR_REFERENCED_DOMAIN_LIST ReferencedDomains,
    IN PLSAPR_TRANSLATED_SID_EX2 TranslatedSids
    );

NTSTATUS
LsapDbMapCachedSids(
    IN PSID *Sids,
    IN ULONG Count,
    IN BOOLEAN UseOldEntries,
    IN OUT PLSAPR_REFERENCED_DOMAIN_LIST ReferencedDomains,
    OUT PLSAPR_TRANSLATED_NAMES_EX TranslatedNames,
    OUT PULONG MappedCount
    );

NTSTATUS
LsapDbMapCachedNames(
    IN ULONG           LookupOptions,
    IN PUNICODE_STRING AccountNames,
    IN PUNICODE_STRING DomainNames,
    IN ULONG Count,
    IN BOOLEAN UseOldEntries,
    IN OUT PLSAPR_REFERENCED_DOMAIN_LIST ReferencedDomains,
    OUT PLSAPR_TRANSLATED_SIDS_EX2 TranslatedSids,
    OUT PULONG MappedCount
    );

VOID
LsapDbAddLogonNameToCache(
    IN PUNICODE_STRING AccountName,
    IN PUNICODE_STRING DomainName,
    IN PSID AccountSid
    );

VOID
LsapDbReleaseLogonNameFromCache(
    IN PSID Sid
    );

#endif // __SIDCACHE_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\base\lsa\server\sources.inc ===
!IF 0

Copyright (c) 1989  Microsoft Corporation

Module Name:

    sources.

Abstract:

    This file specifies the target component being built and the list of
    sources files needed to build that component.  Also specifies optional
    compiler switches and libraries that are unique for the component being
    built.


Author:

    Steve Wood (stevewo) 12-Apr-1990

NOTE:   Commented description of this file is in \nt\bak\bin\sources.tpl

!ENDIF

MAJORCOMP=lsa
MINORCOMP=server

TARGETPATH=obj
TARGETTYPE=DYNLINK

DLLDEF=..\lsasrv.def

INCLUDES=..;..\..\inc;..\..\..\inc;  \
         ..\..\idl;                  \
         ..\..\idl\$(O);             \
         $(DS_GLOBAL_INC);           \
         $(NTDS_INC);                \
         $(SECURITY_INC);            \
         $(BASE_INC_PATH);           \
         $(COM_INC_PATH);            \
         $(DS_INC_PATH);             \
         $(DS_INC_PATH)\crypto;      \
         $(DRIVERS_INC_PATH);        \
         $(ENDUSER_INC_PATH);        \
         $(WINDOWS_INC_PATH);        \
         $(NET_INC_PATH);

NTLEGO=1

# Strict warning, can be used to detect uninitialized vars. Picks up random
# stuff too

COMPILER_WARNINGS=$(COMPILER_WARNINGS) -FI$(SECURITY_INC)\secwarn.h
C_DEFINES=-DRPC_NO_WINDOWS_H -DUNICODE -DLSA_SERVER_COMPILED

!IF "$(WIN64)" == "1"
NO_SSPI_SIGNATURES=1
!ENDIF

!IF "$(NO_SSPI_SIGNATURES)" != ""
LSA_IGNORE_SIGNATURE=1
!ENDIF

!IF "$(LSA_IGNORE_SIGNATURE)" != ""
C_DEFINES=$(C_DEFINES) -DLSA_IGNORE_SIGNATURE
!ENDIF

SOURCES= \
         ..\bndcache.cxx \
         ..\credapi.cxx \
         ..\credmgr.cxx \
         ..\ctxtapi.cxx \
         ..\debug.cxx \
         ..\efssrv.cxx   \
         ..\efsapi.cxx   \
         ..\efsinit.cxx   \
         ..\efscert.cxx  \
         ..\efssrv.cxx   \
         ..\klpc.cxx    \
         ..\klpcstub.cxx \
         ..\lht.cxx \
         ..\lsawmi.c \
         ..\lsastr.c \
         ..\msvlayer.cxx \
         ..\negotiat.cxx \
         ..\negsupp.cxx \
         ..\neglsa.cxx \
         ..\param.cxx \
         ..\policy.cxx \
         ..\shmem.cxx \
         ..\samhooks.cxx \
         ..\scavenge.cxx \
         ..\sesmgr.cxx  \
         ..\sht.cxx \
         ..\sphelp.cxx \
         ..\spinit.cxx \
         ..\spmgr.cxx \
         ..\sputil.cxx \
         ..\thdpool.cxx \
         ..\userkey.cxx \
         ..\util.cxx \
         ..\logons.cxx \
         ..\efsrpc_s_stub.c \
         ..\lsa_rev.rc  \
         ..\lsarpc_s_stub.c  \
         ..\spnego.c

UMTYPE=windows
UMRES=$(O)\lsa_rev.res
UMLIBS=$(SDK_LIB_PATH)\lsasrv.lib                        \
       $(SDK_LIB_PATH)\rpcrt4.lib                        \
       $(SDK_LIB_PATH)\samlib.lib                        \
       $(SDK_LIB_PATH)\samsrv.lib                        \
       $(SDK_LIB_PATH)\ntdll.lib


LINKLIBS=                                                            \
       ..\cfiles\$(O)\lsalib.lib                                     \
       ..\dspolicy\$(O)\lpolicy.lib                          \
       $(SDK_LIB_PATH)\ntdsa.lib                                     \
       $(SECURITY_LIB_PATH)\dsrolsrv.lib                                \
       $(SECURITY_LIB_PATH)\dpapisvc.lib


TARGETLIBS= \
       ..\..\common\$(O)\lsacomm.lib                     \
       $(SECURITY_LIB_PATH)\dsysdbg.lib                  \
       $(SECURITY_LIB_PATH)\secmisc.lib                  \
       $(SDK_LIB_PATH)\rpcutil.lib                       \
       $(SDK_LIB_PATH)\rpcrt4.lib                        \
       $(SDK_LIB_PATH)\kernel32.lib                      \
       ..\..\security\dll\$(O)\secur32p.lib              \
       $(SDK_LIB_PATH)\user32.lib                        \
       $(SDK_LIB_PATH)\advapip.lib                       \
       $(SDK_LIB_PATH)\samsrv.lib                        \
       $(SDK_LIB_PATH)\msasn1.lib                        \
       $(DS_GLOBAL_LIB_PATH)\nlrepl.lib                  \
       $(DS_LIB_PATH)\rsa32.lib                          \
       $(SDK_LIB_PATH)\ntdsa.lib                         \
       $(SDK_LIB_PATH)\netlib.lib                        \
       $(DS_LIB_PATH)\netapi32p.lib                      \
       $(SDK_LIB_PATH)\wldap32.lib                       \
       $(SDK_LIB_PATH)\dnsapi.lib                        \
       $(SDK_LIB_PATH)\samlib.lib                        \
       $(SDK_LIB_PATH)\ntdsetup.lib                      \
       $(SDK_LIB_PATH)\mpr.lib                           \
       $(SDK_LIB_PATH)\crypt32.lib                       \
       $(SDK_LIB_PATH)\cryptui.lib                       \
       $(SDK_LIB_PATH)\userenv.lib                       \
       $(SDK_LIB_PATH)\ntdsapi.lib                       \
       $(DS_LIB_PATH)\certclip.lib                       \
       $(SDK_LIB_PATH)\shlwapi.lib                       \
       $(DS_GLOBAL_LIB_PATH)\wxapicli.lib                \
       $(DS_LIB_PATH)\alloca.lib                         \
       $(PROJECT_LIB_PATH)\pautoenr.lib                  \
       $(SECURITY_LIB_PATH)\sclogon2.lib                 \
       $(SECURITY_LIB_PATH)\sclgnrpc.lib


#
# This line makes the lsasrv.dll use crtdll.dll instead of libc.lib
#

USE_CRTDLL=1

PRECOMPILED_INCLUDE=..\lsapch.hxx
PRECOMPILED_OBJ=lsapch.obj
PRECOMPILED_PCH=lsapch.pch

DELAYLOAD=dnsapi.dll;crypt32.dll;wldap32.dll;ntdsetup.dll;cryptui.dll;userenv.dll;certcli.dll;ntdsa.dll;shlwapi.dll;pautoenr.dll
DLOAD_ERROR_HANDLER=kernel32
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\base\lsa\server\sesmgr.cxx ===
//+-----------------------------------------------------------------------
//
// Microsoft Windows
//
// Copyright (c) Microsoft Corporation 1991 - 1992
//
// File:        SesMgr.c
//
// Contents:    "Session" manager implementation
//
// Functions:   InitSessionManager          -- Sets up the session manager
//              CreateSession               -- Create a session
//              DeleteSession               -- Delete a session
//              LocateSession               -- Locates a session based on CallerContext
//              GetAndSetSession            -- Sticks session in TLS
//              FreeSession                 -- Frees a session from a thread
//              AddCredHandle               -- Adds a cred handle to session
//              DelCredHandle               -- Deletes a cred handle from a session
//
// History:
//
//------------------------------------------------------------------------

#include <lsapch.hxx>
extern "C"
{
#include <adtp.h>
}

#define SESSION_CONNECT_TRUSTED     0x00000001
#define SESSION_CONNECT_UNTRUSTED   0x00000002
#define SESSION_CONNECT_KERNEL      0x00000004

NTSTATUS
LsapCleanUpHandles(
    PSession    pSession,
    PVOID       Ignored
    );

NTSTATUS
I_DeleteSession(PSession  pSession);

RTL_CRITICAL_SECTION    csSessionMgr;

#if DBG

ULONG   SessionLock;

#define LockSessions(x)     RtlEnterCriticalSection(&csSessionMgr); SessionLock = x
#define UnlockSessions()    SessionLock = 0; RtlLeaveCriticalSection(&csSessionMgr)

#else

#define LockSessions(x)     RtlEnterCriticalSection(&csSessionMgr)
#define UnlockSessions()    RtlLeaveCriticalSection(&csSessionMgr)

#endif

#define SM_ICREATE      1
#define SM_DELETE       2
#define SM_ADDRUNDOWN   3
#define SM_DELRUNDOWN   4
#define SM_ADDHANDLE    5
#define SM_DELHANDLE    6
#define SM_VALIDHANDLE  7
#define SM_CLONE        9
#define SM_CLEANUP      10
#define SM_FINDEFS      11
#define SM_UPDATEEFS    12
#define SM_ADDCONNECT   13

PSession    pDefaultSession;
PSession    pEfsSession ;

LIST_ENTRY  SessionList ;
LIST_ENTRY  SessionConnectList ;

VOID
LsapContextRundown(
    PSecHandle phContext,
    PVOID Context,
    ULONG RefCount
    );

VOID
LsapCredentialRundown(
    PSecHandle phCreds,
    PVOID Context,
    ULONG RefCount
    );

//+-------------------------------------------------------------------------
//
//  Function:   InitSessionManager()
//
//  Synopsis:   Initializes whatever is needed to track sessions
//
//  Effects:    csSessionMgr, psSessionList;
//
//  Arguments:  void
//
//  Requires:
//
//  Returns:    TRUE if success, FALSE otherwise.
//
//  Notes:
//
//--------------------------------------------------------------------------

BOOL
InitSessionManager(void)
{
    NTSTATUS    scRet = STATUS_SUCCESS;
    PSession    pSession;
    Session     sSess;

    //
    // Fake a session during init:
    //


    SetCurrentPackageId( SPMGR_ID );

    SetCurrentSession( &sSess );

    scRet = RtlInitializeCriticalSection(&csSessionMgr);

    if (FAILED(scRet))
    {
        return(FALSE);
    }

    SmallHandlePackage.Initialize();
    LargeHandlePackage.Initialize();

    InitializeListHead( &SessionList );

    InitializeListHead( &SessionConnectList );

    scRet = CreateSession(
                &NtCurrentTeb()->ClientId,
                FALSE,
                LSA_PROCESS_NAME,
                0,                      // no flags
                &pSession
                );

    if (FAILED(scRet))
    {
        return(FALSE);
    }

    pSession->fSession |= SESFLAG_DEFAULT | SESFLAG_TCB_PRIV ;

    pDefaultSession = pSession;

    SetCurrentSession( pSession );

    return(TRUE);
}

VOID
LsapFindEfsSession(
    VOID
    )
{
    PLIST_ENTRY Scan ;
    PSession pSession ;

    LockSessions( SM_FINDEFS );

    Scan = SessionList.Flink ;

    while ( Scan != &SessionList )
    {
        pSession = CONTAINING_RECORD( Scan, Session, List );

        if ( (pSession->dwProcessID == pDefaultSession->dwProcessID) &&
             ((pSession->fSession & SESFLAG_KERNEL) != 0 ) )
        {
            pEfsSession = pSession ;
            break;
        }

        Scan = Scan->Flink ;
    }

    UnlockSessions();

    if ( !pEfsSession )
    {
        DebugLog(( DEB_ERROR, "EFS Session not found\n" ));
    }

}


VOID
LsapUpdateEfsSession(
    PSession pSession
    )
{
    if ( !pEfsSession )
    {
        return ;
    }

    LockSessions( SM_UPDATEEFS );
    LockSession( pSession );
    LockSession( pEfsSession );

    pEfsSession->SharedData = pSession->SharedData ;
    pSession->SharedData->cRefs++ ;
    pEfsSession->fSession |= SESFLAG_EFS ;

    UnlockSession( pEfsSession );
    UnlockSession( pSession );
    UnlockSessions();

}

//+-------------------------------------------------------------------------
//
//  Function:   CreateSession()
//
//  Synopsis:   Creates a new session.
//
//  Effects:    Session list.
//
//  Arguments:  fOpenImmediate - TRUE indicates the process should be opened
//
//              ppSession - receives a pointer to the session.
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//--------------------------------------------------------------------------

NTSTATUS
CreateSession(  CLIENT_ID * pClientId,
                BOOL        fOpenImmediate,
                PWCHAR      ClientProcessName,
                ULONG       Flags,
                PSession *  ppSession)
{
    NTSTATUS     scRet = STATUS_SUCCESS;
    PSession    pSession;
    LPWSTR      ClientName;
    PLIST_ENTRY Scan ;
    PLSAP_SESSION_CONNECT Connect ;
    ULONG ConnectType = 0 ;

    DebugLog(( DEB_TRACE, "Creating session for [%x.%x]\n",
                    pClientId->UniqueProcess, pClientId->UniqueThread ));

    *ppSession = NULL;

    if ( *ClientProcessName )
    {
        ConnectType |= SESSION_CONNECT_TRUSTED ;

        ClientName = (LPWSTR) LsapAllocatePrivateHeap(
                                    (wcslen(ClientProcessName)+1) * sizeof(WCHAR));

        if (ClientName == NULL)
        {
            return(STATUS_INSUFFICIENT_RESOURCES);
        }

        wcscpy(ClientName,ClientProcessName);
    }
    else
    {
        ConnectType |= SESSION_CONNECT_UNTRUSTED ;

        ClientName = NULL;
    }


    pSession = (PSession) LsapAllocatePrivateHeap( sizeof( Session ) );
    if (!pSession)
    {
        *ppSession = NULL;
        if( ClientName != NULL )
        {
            LsapFreePrivateHeap( ClientName );
        }

        return(STATUS_INSUFFICIENT_RESOURCES);
    }

    RtlZeroMemory(pSession, sizeof(Session));

    //
    // Initialize stuff:
    //

    pSession->fSession = Flags;

    //
    // Bail out now if critsec creation fails.  We can't use the common
    // cleanup as it relies on the session having an initialized lock.
    //

    scRet = RtlInitializeCriticalSection( &pSession->SessionLock );

    if (!NT_SUCCESS(scRet))
    {
        LsapFreePrivateHeap(pSession);

        *ppSession = NULL;

        if( ClientName != NULL )
        {
            LsapFreePrivateHeap( ClientName );
        }

        return scRet;
    }

    InitializeListHead( &pSession->SectionList );
    InitializeListHead( &pSession->RundownList );

    pSession->ClientProcessName = ClientName;
    pSession->dwProcessID   = HandleToUlong(pClientId->UniqueProcess);

    //
    // Store the handle cleanup as a rundown function
    //

    if ( !AddRundown( pSession,
                      LsapCleanUpHandles,
                      NULL ) )
    {
        scRet = STATUS_NO_MEMORY ;
    }

    //
    // Lock the sessions now so we know that no new kernel sessions
    // will be created
    //

    LockSessions(SM_ICREATE);

    //
    // Add the session to the list
    //

    InsertTailList( &SessionList, &pSession->List );

    //
    // *Now* check if we're doing ok:
    //

    if ( !NT_SUCCESS( scRet ))
    {
        UnlockSessions();

        goto Cleanup;
    }

    //
    // If the caller is from kernel mode, look for an existing kernel
    // session to use the handle list from.
    //

    if ((Flags & SESFLAG_MAYBEKERNEL) != 0)
    {
        PSession pTrace = NULL;

        //
        // Find a kernel-mode session and use its handle list.  Make sure
        // it's not the default LSA session, although it is ok to use the
        // session tagged as the EFS one.  This will keep the EFS session
        // and the (primary) rdr session in sync.
        //

        Scan = SessionList.Flink ;

        while ( Scan != &SessionList )
        {
            pTrace = CONTAINING_RECORD( Scan, Session, List );

            if ( pTrace != pSession )
            {
                if ( ( (pTrace->fSession & SESFLAG_KERNEL) != 0 ) &&
                   ( ( (pTrace->fSession & SESFLAG_EFS) != 0 ) ||
                     ( pTrace->dwProcessID != pDefaultSession->dwProcessID ) ) )
                {
                    break;
                }
            }

            pTrace = NULL ;

            Scan = Scan->Flink ;

        }

        //
        // If we found a session, use its handle list and queue
        //

        if (pTrace != NULL)
        {
            pTrace->SharedData->cRefs++;
            pSession->SharedData = pTrace->SharedData;
            DebugLog(( DEB_TRACE, "Linking session %p to %p\n",
                       pSession, pTrace ));
        }

        //
        // ConnectType is not definite, it is a hint to others
        // watching for new sessions
        //

        ConnectType |= SESSION_CONNECT_KERNEL ;
    }

    //
    // If we don't have a handle list yet, create one and set it to NULL
    //

    if (pSession->SharedData == NULL)
    {
        if ( pSession->fSession & SESFLAG_MAYBEKERNEL )
        {
            pSession->SharedData = (PLSAP_SHARED_SESSION_DATA) LsapAllocatePrivateHeap(
                                        sizeof( LSAP_SHARED_SESSION_DATA ) );
        }
        else
        {
            pSession->SharedData = &pSession->DefaultData ;
        }

        if ( pSession->SharedData )
        {

            RtlZeroMemory(
                    pSession->SharedData,
                    sizeof( LSAP_SHARED_SESSION_DATA ) );

            //
            // Create Handle Tables:
            //

            pSession->SharedData->CredHandlePackage = &SmallHandlePackage ;
            pSession->SharedData->ContextHandlePackage = &LargeHandlePackage ;

            pSession->SharedData->CredTable = pSession->SharedData->CredHandlePackage->Create(
                                HANDLE_PACKAGE_CALLBACK_ON_DELETE,
                                NULL,
                                LsapCredentialRundown );

            pSession->SharedData->ContextTable = pSession->SharedData->ContextHandlePackage->Create(
                                HANDLE_PACKAGE_CALLBACK_ON_DELETE,
                                NULL,
                                LsapContextRundown );

            if ((pSession->SharedData->CredTable == NULL) || (pSession->SharedData->ContextTable == NULL))
            {
                scRet = STATUS_INSUFFICIENT_RESOURCES;
            }

            pSession->SharedData->cRefs = 1;
        }
        else
        {
            scRet = STATUS_INSUFFICIENT_RESOURCES ;
        }

    }

    UnlockSessions();

    //
    // Check for callbacks when a client connects.  Note, this does
    // not need to be under the session list lock, because it is
    // sufficient that no client is using the session until the
    // callbacks are complete. Since the connection attempt is
    // stalled until this returns, that requirement is met.
    //

    Scan = SessionConnectList.Flink ;
    while ( Scan != &SessionConnectList )
    {
        Connect = CONTAINING_RECORD( Scan, LSAP_SESSION_CONNECT, List );

        if ( Connect->ConnectFilter & ConnectType )
        {
            Connect->Callback( pSession, Connect->Parameter );
        }

        Scan = Scan->Flink ;
    }


    *ppSession = pSession ;

    if (fOpenImmediate & (NT_SUCCESS(scRet)))
    {
        scRet = LsapOpenCaller(pSession);
    }

    //
    // If we failed somewhere, cleanup now.
    //

Cleanup:

    if (!NT_SUCCESS(scRet))
    {
        I_DeleteSession(pSession);
        *ppSession = NULL;
    }

    return(scRet);
}



//+---------------------------------------------------------------------------
//
//  Function:   CloneSession
//
//  Synopsis:   Temporary copy of a session for scavenger threads
//
//  Arguments:  [pOriginalSession] --
//              [ppSession]        --
//
//  History:    5-18-95   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
NTSTATUS
CloneSession(
    PSession    pOriginalSession,
    PSession *  ppSession,
    ULONG       Flags )
{
    PSession    pSession;
    NTSTATUS    Status ;
    BOOL        LockInitialized = FALSE ;

    pSession = (PSession) LsapAllocatePrivateHeap( sizeof( Session ) );

    if ( !pSession )
    {
        *ppSession = NULL ;

        return STATUS_NO_MEMORY ;
    }

    //
    // Make sure there is no one else mucking with general session stuff
    //

    LockSessions(SM_CLONE);

    Status = STATUS_SUCCESS ;

    //
    // Copy all the interesting bits
    //

    CopyMemory(pSession, pOriginalSession, sizeof(Session));

    //
    // Make sure it has its own critical section
    //

    Status = RtlInitializeCriticalSection( &pSession->SessionLock );

    if ( NT_SUCCESS( Status ) )
    {
        //
        // Use common unlock/cleanup below
        //

        LockInitialized = TRUE ;
    }

    //
    // note that it is a clone
    //

    pSession->fSession |= ( SESFLAG_CLONE | Flags );

    //
    // Initialize our own rundown list.
    //

    InitializeListHead( &pSession->RundownList );

    //
    // Use our own rundown
    //

    if ( LockInitialized )
    {
        if ( AddRundown( pSession, LsapCleanUpHandles, NULL ) )
        {
            pOriginalSession->SharedData->cRefs++;
        }
        else
        {
            Status = STATUS_NO_MEMORY ;
        }
    }

    UnlockSessions();

    if ( !NT_SUCCESS( Status ) )
    {
        if ( LockInitialized )
        {
            RtlDeleteCriticalSection( &pSession->SessionLock );
        }

        LsapFreePrivateHeap( pSession );

        *ppSession = NULL ;

        return Status ;
    }

    //
    // Set the reference count of the clone to -1, so that the a single
    // ref/deref will kill it.
    //

    pSession->RefCount = -1;

    //
    // Clones do *NOT* get added to the session list.
    //

    *ppSession = pSession;

    return(STATUS_SUCCESS);
}


VOID
WINAPI
LsapDeleteContextWrap(
    PSecHandle  Handle,
    PVOID Context,
    ULONG RefCount
    )
{
    PLSA_CALL_INFO CallInfo ;

    CallInfo = LsapGetCurrentCall();

    CallInfo->CallInfo.CallCount = RefCount ;

    WLsaDeleteContext( Handle );

    CallInfo->CallInfo.CallCount = 0 ;
}

VOID
WINAPI
LsapFreeCredWrap(
    PSecHandle  Handle,
    PVOID Context,
    ULONG RefCount
    )
{
    PLSA_CALL_INFO CallInfo ;

    CallInfo = LsapGetCurrentCall();

    CallInfo->CallInfo.CallCount = RefCount ;

    WLsaFreeCredHandle( Handle );

    CallInfo->CallInfo.CallCount = 0;
}

//+---------------------------------------------------------------------------
//
//  Function:   LsapCleanUpHandles
//
//  Synopsis:   Closes all context and credential handles for a session
//
//  Arguments:  [pSession] --
//              [Ignored]  --
//
//  History:    5-15-97   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
NTSTATUS
LsapCleanUpHandles(
    PSession    pSession,
    PVOID       Ignored
    )
{
    NTSTATUS     scRet = STATUS_SUCCESS;
    PSession    pSave;
    ULONG HandleRefs;
    PLIST_ENTRY ListEntry;
    LSA_CALL_INFO CallInfo ;
    HANDLE hImp ;


    //
    // If this is the last user of the handle lists, cleanup
    //

    if ( pSession->SharedData == NULL )
    {
        return STATUS_SUCCESS ;
    }

    LockSessions(SM_CLEANUP);

    pSession->SharedData->cRefs--;
    HandleRefs = pSession->SharedData->cRefs;

    UnlockSessions();

    if (HandleRefs == 0)
    {

        LsapInitializeCallInfo( &CallInfo,
                                FALSE );

        CallInfo.CallInfo.Attributes |= SECPKG_CALL_CLEANUP ;

        LsapSetCurrentCall( &CallInfo );

        pSave = GetCurrentSession();

        SetCurrentSession( pSession );


        if (pSession->SharedData->ContextTable != NULL)
        {
            pSession->SharedData->ContextHandlePackage->Delete( pSession->SharedData->ContextTable,
                                                LsapDeleteContextWrap );
        }

        if (pSession->SharedData->CredTable != NULL)
        {
            pSession->SharedData->CredHandlePackage->Delete( pSession->SharedData->CredTable,
                                                LsapFreeCredWrap );
        }

        if ( pSession->fSession & SESFLAG_KERNEL )
        {
            LsapFreePrivateHeap( pSession->SharedData );
        }

        SetCurrentSession( pSave );

        LsapSetCurrentCall( NULL );
    }

    pSession->SharedData = NULL;

    return(scRet);
}


//+-------------------------------------------------------------------------
//
//  Function:   I_DeleteSession()
//
//  Synopsis:   Deletes the session indicated
//
//  Effects:    Frees memory
//
//  Arguments:  pSession    Session to delete
//
//  Notes:
//
//--------------------------------------------------------------------------
NTSTATUS
I_DeleteSession(PSession  pSession)
{
    PSession        pTrace;
    PLIST_ENTRY     List ;
    PLSAP_SESSION_RUNDOWN Rundown ;
    int             i;

    DebugLog(( DEB_TRACE, "DeleteSession( %x )\n", pSession ));

    DsysAssertMsg(pSession, "DeleteSession passed null pointer");

    pSession->fSession |= SESFLAG_CLEANUP;


    //
    // Clones aren't in the list, so don't try to unlink it
    //

    if ( ( pSession->fSession & SESFLAG_CLONE ) == 0 )
    {
        LockSessions(SM_DELETE);

        RemoveEntryList( &pSession->List );

        UnlockSessions();
    }

    //
    // Execute the rundown functions
    //

    LockSession( pSession );

    while ( !IsListEmpty( &pSession->RundownList ) )
    {
        List = RemoveHeadList( &pSession->RundownList );

        Rundown = CONTAINING_RECORD( List, LSAP_SESSION_RUNDOWN, List );

        Rundown->Rundown( pSession, Rundown->Parameter );

        LsapFreePrivateHeap( Rundown );
    }

    UnlockSession( pSession );

    RtlDeleteCriticalSection( &pSession->SessionLock );

    if (pSession->fSession & SESFLAG_CLONE)
    {
        //
        // Clones are not part of the global list, and are
        // around just for bookkeepping for scavenger threads
        //

        pSession->dwProcessID = 0xFFFFFFFF;

        LsapFreePrivateHeap( pSession );

        return(STATUS_SUCCESS);
    }

    //
    // Close our handles
    //

    if (pSession->hProcess)
        NtClose(pSession->hProcess);

    if (pSession->hPort)
    {
        NtClose(pSession->hPort);
    }

    pSession->dwProcessID = 0xFFFFFFFF;


    if( pSession->ClientProcessName )
    {
        LsapFreePrivateHeap( pSession->ClientProcessName );
    }

    LsapFreePrivateHeap( pSession );

    return(STATUS_SUCCESS);
}


HRESULT
LsapDeleteWorkQueue(
    PSession pSession,
    PVOID Parameter
    )
{
    if ( pSession->SharedData->pQueue )
    {
        DeleteSubordinateQueue( pSession->SharedData->pQueue, 0 );

        pSession->SharedData->pQueue = NULL ;
    }

    return STATUS_SUCCESS ;
}


//+---------------------------------------------------------------------------
//
//  Function:   SpmpReferenceSession
//
//  Synopsis:   Ups the ref count on a session
//
//  Arguments:  [pSession] --
//
//  History:    5-18-95   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
VOID
SpmpReferenceSession(
    PSession    pSession)
{
    InterlockedIncrement(&pSession->RefCount);
}


//+---------------------------------------------------------------------------
//
//  Function:   SpmpDereferenceSession
//
//  Synopsis:   Derefs a session.  If the session goes negative, it gets
//              deleted.
//
//  Arguments:  [pSession] --
//
//  History:    5-18-95   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
VOID
SpmpDereferenceSession(
    PSession    pSession)
{
    LONG RefCount = InterlockedDecrement(&pSession->RefCount);

    if( RefCount < 0 )
    {
        if ( pSession == pDefaultSession )
        {
            pSession->RefCount = 1 ;
        }
        else 
        {
            DsysAssert( (pSession->RefCount == -1) && (RefCount == -1) );
            I_DeleteSession(pSession);
        }
    }
}


VOID
LsapSessionDisconnect(
    PSession    pSession
    )
{
    if ( pSession->SharedData->cRefs == 1 )
    {
        LsapDeleteWorkQueue( pSession, NULL );
    }
}


//+-------------------------------------------------------------------------
//
//  Function:   FreeSession
//
//  Synopsis:   Frees a session
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//--------------------------------------------------------------------------
void
FreeSession(PSession    pSession)
{
    if (pSession == NULL)
    {
        pSession = GetCurrentSession();
    }

    if (!pSession)
    {
        DebugLog((DEB_ERROR, "FreeSession:  No Session?\n"));
        return;
    }

    TlsSetValue(dwSession, pDefaultSession);
}


//
// Rundown Semantics:
//
// Rundowns allow other functions to be called when a session is closed.  This
// is useful if you need to keep something around as long as a client is
// connected, but need to clean up afterwards.
//
// Rules:  You cannot call back into or reference the client process.  This is
// because the process has already terminated.
//


//+---------------------------------------------------------------------------
//
//  Function:   AddRundown
//
//  Synopsis:   Adds a function to be called when the session is terminated
//
//  Arguments:  [pSession]    --
//              [RundownFn]   --
//              [pvParameter] --
//
//  History:    5-18-95   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
BOOL
AddRundown(
    PSession            pSession,
    PLSAP_SESSION_RUNDOWN_FN RundownFn,
    PVOID               pvParameter)
{
    PLSAP_SESSION_RUNDOWN Rundown ;

    Rundown = (PLSAP_SESSION_RUNDOWN) LsapAllocatePrivateHeap(
                                        sizeof( LSAP_SESSION_RUNDOWN ) );

    if ( Rundown )
    {
        Rundown->Rundown = RundownFn ;
        Rundown->Parameter = pvParameter ;

        LockSession( pSession );

        InsertTailList( &pSession->RundownList, &Rundown->List );

        UnlockSession( pSession );

        return TRUE ;
    }

    return FALSE ;
}


//+---------------------------------------------------------------------------
//
//  Function:   DelRundown
//
//  Synopsis:   Removes a rundown function from a session
//
//  Arguments:  [pSession]  --
//              [RundownFn] --
//
//  History:    5-18-95   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
BOOL
DelRundown(
    PSession            pSession,
    PLSAP_SESSION_RUNDOWN_FN RundownFn
    )
{
    PLIST_ENTRY Scan;
    PLSAP_SESSION_RUNDOWN Rundown ;

    LockSession( pSession );

    Scan = pSession->RundownList.Flink ;

    Rundown = NULL ;

    while ( Scan != &pSession->RundownList )
    {
        Rundown = (PLSAP_SESSION_RUNDOWN) Scan ;

        if ( Rundown->Rundown == RundownFn )
        {
            RemoveEntryList( &Rundown->List );

            break;
        }

        Rundown = NULL ;

        Scan = Scan->Flink ;
    }

    UnlockSession( pSession );

    if ( Rundown )
    {
        LsapFreePrivateHeap( Rundown );

        return TRUE ;
    }

    return FALSE ;
}


VOID
LsapCredentialRundown(
    PSecHandle phCreds,
    PVOID Context,
    ULONG RefCount
    )
{
    PSession pSession = (PSession) Context ;
    NTSTATUS       scRet;
    PLSAP_SECURITY_PACKAGE pPackage;
    PSession Previous ;

    Previous = GetCurrentSession();

    if ( ( ( pSession->fSession & SESFLAG_KERNEL ) != 0 ) &&
         ( ( Previous->fSession & SESFLAG_KERNEL ) != 0 ) )
    {
        NOTHING ;
    }
    else
    {
        SetCurrentSession( pSession );
    }

    DebugLog((DEB_TRACE, "[%x] CredentialRundown (%p:%p) RefCount=%lu\n",
                pSession->dwProcessID, phCreds->dwUpper, phCreds->dwLower, RefCount));

    pPackage = SpmpValidRequest(phCreds->dwLower,
                                SP_ORDINAL_FREECREDHANDLE );

    if (pPackage)
    {
        PLSA_CALL_INFO CallInfo;
        ULONG OldRefCount;

        SetCurrentPackageId(phCreds->dwLower);

        StartCallToPackage( pPackage );

        ASSERT( RefCount );

        CallInfo = LsapGetCurrentCall();
        OldRefCount = CallInfo->CallInfo.CallCount;
        CallInfo->CallInfo.CallCount = RefCount;

        __try
        {
            scRet = pPackage->FunctionTable.FreeCredentialsHandle(
                                                    phCreds->dwUpper);
        }
        __except (SP_EXCEPTION)
        {
            scRet = GetExceptionCode();
            scRet = SPException(scRet, phCreds->dwLower);
        }

        CallInfo->CallInfo.CallCount = OldRefCount;

        EndCallToPackage( pPackage );

        LsapDelPackageHandle( pPackage, FALSE );
    }

    SetCurrentSession( Previous );
}


VOID
LsapContextRundown(
    PSecHandle phContext,
    PVOID Context,
    ULONG RefCount
    )
{
    PSession Session = (PSession) Context;
    PSession Previous ;
    PLSAP_SECURITY_PACKAGE     pspPackage;
    PLSA_CALL_INFO CallInfo;
    ULONG OldRefCount;

    NTSTATUS scRet ;

    Previous = GetCurrentSession();

    if ( ( ( Session->fSession & SESFLAG_KERNEL ) != 0 ) &&
         ( ( Previous->fSession & SESFLAG_KERNEL ) != 0 ) )
    {
        NOTHING ;
    }
    else
    {
        SetCurrentSession( Session );

    }

    pspPackage = SpmpValidRequest(  phContext->dwLower,
                                    SP_ORDINAL_DELETECTXT);

    if (! pspPackage )
    {
        DebugLog((DEB_ERROR,"[%x] Invalid request for DeleteContext, package: %d\n",
                    Session->dwProcessID, phContext->dwLower));
        return ;
    }

    DebugLog(( DEB_TRACE, "[%x] ContextRundown(%p:%p)\n",
                    Session->dwProcessID, phContext->dwUpper,
                    phContext->dwLower ));

    SetCurrentPackageId(phContext->dwLower);

    StartCallToPackage( pspPackage );

    CallInfo = LsapGetCurrentCall();
    OldRefCount = CallInfo->CallInfo.CallCount;
    CallInfo->CallInfo.CallCount = RefCount;

    __try
    {
        scRet = pspPackage->FunctionTable.DeleteContext( phContext->dwUpper );
    }
    __except (SP_EXCEPTION)
    {
        scRet = GetExceptionCode();
        scRet = SPException( scRet, pspPackage->dwPackageID);
    }

    CallInfo->CallInfo.CallCount = OldRefCount;
    EndCallToPackage( pspPackage );

#if DBG
    if ( !NT_SUCCESS( scRet ) )
    {
        DebugLog((DEB_ERROR, "[%x] package %ws failed DeleteContext with %x\n",
                  Session->dwProcessID,
                  pspPackage->Name.Buffer,
                  scRet ));

    }
#endif

    DebugLog(( DEB_TRACE_WAPI, "[%x] return code %x\n", Session->dwProcessID,
                scRet ));

    SetCurrentPackageId( SPMGR_ID );

    SetCurrentSession( Previous );

    LsapDelPackageHandle( pspPackage, TRUE );
}


//+-------------------------------------------------------------------------
//
//  Function:   AddCredHandle
//
//  Synopsis:   Adds an obtained cred handle to the list for this session
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//--------------------------------------------------------------------------
BOOLEAN
AddCredHandle(  PSession    pSession,
                PCredHandle phCred,
                ULONG Flags)
{

    if (pSession->fSession & SESFLAG_CLONE)
    {
        DebugLog((DEB_ERROR, "Attempt to add a credhandle to a clone session\n"));
        return FALSE;
    }

    if ( pSession->fSession & SESFLAG_KERNEL )
    {
        pSession = pEfsSession ;
    }

    DebugLog(( DEB_TRACE_HANDLES, "Adding Cred %p : %p to %p\n",
               phCred->dwUpper, phCred->dwLower, pSession ));

    if(pSession->SharedData->CredHandlePackage->AddHandle(
                            pSession->SharedData->CredTable,
                            phCred,
                            pSession,
                            Flags))
    {

        LsapAddPackageHandle( phCred->dwLower, FALSE );
        return TRUE;
    }

    return FALSE;
}


//+---------------------------------------------------------------------------
//
//  Function:   AddContextHandle
//
//  Synopsis:   Adds a context handle to this session
//
//  Arguments:  [phContext] --
//
//  History:    5-18-95   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
BOOLEAN
AddContextHandle(   PSession    pSession,
                    PCtxtHandle phContext,
                    ULONG Flags)
{
    if (pSession->fSession & SESFLAG_CLONE)
    {
        DebugLog((DEB_ERROR, "Attempt to add a ctxthandle to a clone session\n"));
        return FALSE;
    }

    if ( pSession->fSession & SESFLAG_KERNEL )
    {
        pSession = pEfsSession ;
    }

    DebugLog(( DEB_TRACE_HANDLES, "Adding Context %p : %p to %p\n",
               phContext->dwUpper, phContext->dwLower, pSession ));


    //
    // Find out where this 0:0 handle is coming from:
    //

    DsysAssertMsg( (phContext->dwLower | phContext->dwUpper), "Null context handle added\n");

    if(pSession->SharedData->ContextHandlePackage->AddHandle(
                                        pSession->SharedData->ContextTable,
                                        phContext,
                                        pSession,
                                        Flags
                                        ))
    {
        LsapAddPackageHandle( phContext->dwLower, TRUE );
        return TRUE;
    }

    return FALSE;
}


//+---------------------------------------------------------------------------
//
//  Function:   ValidateContextHandle
//
//  Synopsis:   Validate the context handle against the session list
//
//  Arguments:  [pSession]  --
//              [phContext] --
//
//  History:    5-18-95   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
NTSTATUS
ValidateContextHandle(
    PSession    pSession,
    PCtxtHandle phContext,
    PVOID *     pKey
    )
{

    *pKey = pSession->SharedData->ContextHandlePackage->RefHandle(
                            pSession->SharedData->ContextTable,
                            phContext );

    DebugLog(( DEB_TRACE_HANDLES, "Validate context (%p : %p) for %p returned %p\n",
               phContext->dwUpper, phContext->dwLower,
               pSession, *pKey ));

    if ( *pKey )
    {
        return SEC_E_OK ;
    }
    else
    {
        return SEC_E_INVALID_HANDLE ;
    }
}


VOID
DerefContextHandle(
    PSession    pSession,
    PCtxtHandle phContext,
    PVOID       Key OPTIONAL
    )
{
    if ( Key )
    {
#if DBG
        PSEC_HANDLE_ENTRY Entry = (PSEC_HANDLE_ENTRY) Key ;

        DebugLog(( DEB_TRACE_HANDLES, "Deref context handle by key ( %p : %p ) for %p \n",
                   Entry->Handle.dwUpper, Entry->Handle.dwLower,
                   pSession ));
#endif
        pSession->SharedData->ContextHandlePackage->DerefHandleKey(
                pSession->SharedData->ContextTable,
                Key );
    }
    else
    {
        pSession->SharedData->ContextHandlePackage->DeleteHandle(
                pSession->SharedData->ContextTable,
                phContext,
                0 );

        DebugLog(( DEB_TRACE_HANDLES, "Deref context handle by handle (%p : %p) for %p\n",
                   phContext->dwUpper, phContext->dwLower,
                   pSession ));
    }
}


NTSTATUS
ValidateAndDerefContextHandle(
    PSession pSession,
    PCtxtHandle phContext
    )
{
    DebugLog(( DEB_TRACE_HANDLES, "ValidateAndDeref Context (%p : %p)\n",
                    phContext->dwUpper, phContext->dwLower ));

    if ( pSession->SharedData->ContextHandlePackage->ValidateHandle(
                            pSession->SharedData->ContextTable,
                            phContext,
                            TRUE ) )
    {
        return SEC_E_OK ;
    }

    return SEC_E_INVALID_HANDLE ;
}


//+---------------------------------------------------------------------------
//
//  Function:   ValidateCredHandle
//
//  Synopsis:   Validate the context handle against the session list
//
//  Arguments:  [pSession]  --
//              [phCred] --
//
//  History:    5-18-95   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
NTSTATUS
ValidateCredHandle(
    PSession    pSession,
    PCtxtHandle phCred,
    PVOID *     pKey
    )
{
    *pKey = pSession->SharedData->CredHandlePackage->RefHandle(
                            pSession->SharedData->CredTable,
                            phCred );

    DebugLog(( DEB_TRACE_HANDLES, "Validate cred (%p : %p) for %p returned %p\n",
               phCred->dwUpper, phCred->dwLower,
               pSession, *pKey ));

    if ( *pKey )
    {
        return SEC_E_OK ;
    }
    else
    {
        return SEC_E_INVALID_HANDLE ;
    }
}


VOID
DerefCredHandle(
    PSession    pSession,
    PCtxtHandle phCred,
    PVOID       Key OPTIONAL
    )
{
    if ( Key )
    {
#if DBG
        PSEC_HANDLE_ENTRY Entry = (PSEC_HANDLE_ENTRY) Key ;

        DebugLog(( DEB_TRACE_HANDLES, "Deref cred ( %p : %p ) for %p \n",
                   Entry->Handle.dwUpper, Entry->Handle.dwLower,
                   pSession ));
#endif
        pSession->SharedData->CredHandlePackage->DerefHandleKey(
                pSession->SharedData->CredTable,
                Key );
    }
    else
    {
        pSession->SharedData->CredHandlePackage->DeleteHandle(
                pSession->SharedData->CredTable,
                phCred,
                0 );

        DebugLog(( DEB_TRACE_HANDLES, "Deref cred (%p : %p) for %p\n",
                   phCred->dwUpper, phCred->dwLower,
                   pSession ));
    }
}


NTSTATUS
ValidateAndDerefCredHandle(
    PSession pSession,
    PCtxtHandle phCred
    )
{
    DebugLog(( DEB_TRACE_HANDLES, "ValidateAndDeref Cred (%p : %p)\n",
                    phCred->dwUpper, phCred->dwLower ));

    if ( pSession->SharedData->CredHandlePackage->ValidateHandle(
                            pSession->SharedData->CredTable,
                            phCred,
                            TRUE ) )
    {
        return SEC_E_OK ;
    }

    return SEC_E_INVALID_HANDLE ;
}


NTSTATUS
LsapValidLogonProcess(
    IN PVOID Request,
    IN ULONG RequestSize,
    IN PCLIENT_ID ClientId,
    OUT PLUID LogonId,
    OUT PULONG Flags
    )

/*++

Routine Description:

    This function checks to see if a calling process qualifies as a logon
    process.  If so, a logon process context is created for the caller and
    returned.

    A logon process must hold the SeTcbPrivilege privilege.  Since there
    is no way to impersonate a connection requestor (that would be way
    too easy), we have to open the client thread and then open that thread's
    token.


Arguments:

    ClientId - Pointer to the client Id of the sender of the logon
        message.  This is used to locate and open the calling thread or
        process.


Return Value:

    STATUS_SUCCESS - Indicates the caller is a legitimate logon process
        and a logon process context block is being returned.

    any other value - Indicates the caller is NOT a legitimate logon
        process and a logon process context block is NOT being returned.
        The value returned indicates the reason why the client is not
        acceptable.

--*/

{
    NTSTATUS Status, TempStatus;
    BOOLEAN PrivilegeHeld;
    HANDLE ClientThread, ClientProcess, ClientToken;
    PRIVILEGE_SET Privilege;
    OBJECT_ATTRIBUTES NullAttributes;
    BOOLEAN Untrusted = FALSE;
    TOKEN_STATISTICS TokenStats;
    PLSAP_AU_REGISTER_CONNECT_INFO_EX ConnectionRequest = (PLSAP_AU_REGISTER_CONNECT_INFO_EX) Request;
    ULONG TokenStatsSize = sizeof(TokenStats);
    LSAP_AU_REGISTER_CONNECT_INFO NullConnectInfo;

    *Flags = 0;

    RtlZeroMemory(
        &NullConnectInfo,
        sizeof(NullConnectInfo)
        );

    //
    // If the connect message is all zeros, setup an untrusted connection.
    //

    if (RtlEqualMemory(
            &NullConnectInfo,
            ConnectionRequest,
            sizeof(NullConnectInfo))) {

        Untrusted = TRUE;
        *Flags |= SESFLAG_UNTRUSTED;
    }

    InitializeObjectAttributes( &NullAttributes, NULL, 0, NULL, NULL );

    //
    // Open the client thread and that thread's token
    //

    Status = NtOpenThread(
                 &ClientThread,
                 THREAD_QUERY_INFORMATION,
                 &NullAttributes,
                 ClientId
                 );

    if ( !NT_SUCCESS(Status) ) {
        return Status;
    }

    Status = NtOpenThreadToken(
                 ClientThread,
                 TOKEN_QUERY,
                 TRUE,
                 &ClientToken
                 );

    TempStatus = NtClose( ClientThread );
    DsysAssert( NT_SUCCESS(TempStatus) );

    //
    // Make sure we succeeded in opening the token
    //

    if ( !NT_SUCCESS(Status) ) {
        if ( Status != STATUS_NO_TOKEN ) {
            return Status;

        } else {

            //
            // Open the client process.  This is needed to:
            //
            //         1) Access the client's virtual memory (to copy arguments),
            //         2) Duplicate token handles into the process,
            //         3) Open the process's token to see if it qualifies as
            //            a logon process.
            //

            Status = NtOpenProcess(
                         &ClientProcess,
                         PROCESS_QUERY_INFORMATION |       // To open primary token
                         PROCESS_VM_OPERATION |            // To allocate memory
                         PROCESS_VM_READ |                 // To read memory
                         PROCESS_VM_WRITE |                // To write memory
                         PROCESS_DUP_HANDLE,               // To duplicate a handle into
                         &NullAttributes,
                         ClientId
                         );
            if ( !NT_SUCCESS(Status) ) {
                return Status;
            }

            //
            // The thread isn't impersonating...open the process's token.
            //

            Status = NtOpenProcessToken(
                         ClientProcess,
                         TOKEN_QUERY,
                         &ClientToken
                         );


            TempStatus = NtClose( ClientProcess );
            DsysAssert( NT_SUCCESS(TempStatus) );

            //
            // Make sure we succeeded in opening the token
            //

            if ( !NT_SUCCESS(Status) ) {
                return Status;
            }
        }
    } else {
        *Flags |= SESFLAG_IMPERSONATE;
    }

    //
    // If the caller has the kernel flag set in the LPC message, this is
    // probably a kernel session, but we can't be sure until the first
    // request is made and the LPC_KERNELMODE_MESSAGE flag is set.  The
    // handlers will check that, but until then, set the maybe-flag.
    //

    if (!Untrusted &&
        RequestSize == sizeof( LSAP_AU_REGISTER_CONNECT_INFO_EX) &&
        ((ConnectionRequest->ClientMode & LSAP_AU_KERNEL_CLIENT) != 0) )
    {
        *Flags |= SESFLAG_MAYBEKERNEL;
    }

    //
    // OK, we have a token open
    //

    //
    // Get the logon id.
    //

    Status = NtQueryInformationToken(
                ClientToken,
                TokenStatistics,
                (PVOID) &TokenStats,
                TokenStatsSize,
                &TokenStatsSize
                );

    if (!NT_SUCCESS(Status)) {
        TempStatus = NtClose( ClientToken );
        DsysAssert(NT_SUCCESS(TempStatus));
        return(Status);
    }

    *LogonId = TokenStats.AuthenticationId;

    Status = STATUS_SUCCESS ;

    if (((*Flags) & SESFLAG_MAYBEKERNEL) == 0) {
        //
        // Check for the privilege to execute this service.
        //

        Privilege.PrivilegeCount = 1;
        Privilege.Control = PRIVILEGE_SET_ALL_NECESSARY;
        Privilege.Privilege[0].Luid = LsapTcbPrivilege;
        Privilege.Privilege[0].Attributes = 0;

        Status = NtPrivilegeCheck(
                     ClientToken,
                     &Privilege,
                     &PrivilegeHeld
                     );
        DsysAssert( NT_SUCCESS(Status) );

        //
        // For untrusted clients who didn't really need TCB anyway don't
        // bother with an audit. If they do have the privilege, by all
        // means audit it.
        //

        if (!Untrusted || PrivilegeHeld) {

            //
            // Generate any necessary audits
            //

            TempStatus = NtPrivilegedServiceAuditAlarm (
                             &LsapLsaAuName,
                             &LsapRegisterLogonServiceName,
                             ClientToken,
                             &Privilege,
                             PrivilegeHeld
                             );

            if ( !PrivilegeHeld ) {

                TempStatus = NtClose( ClientToken );
                DsysAssert( NT_SUCCESS(TempStatus) );

                return STATUS_PRIVILEGE_NOT_HELD;
            }
        }

        if (PrivilegeHeld)
        {
            *Flags |= SESFLAG_TCB_PRIV;
        }
    }

    TempStatus = NtClose( ClientToken );
    DsysAssert( NT_SUCCESS(TempStatus) );

    if (!Untrusted && ((*Flags & SESFLAG_KERNEL) == 0))
    {
        LsapAdtAuditLogonProcessRegistration( ConnectionRequest );
    }

    return(STATUS_SUCCESS);
}


//+---------------------------------------------------------------------------
//
//  Function:   LsapSetSessionOptions
//
//  Synopsis:   Allows clients to adjust session options
//
//  Arguments:  [Request]  --
//              [Response] --
//
//  History:    8-05-96   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
NTSTATUS
LsapSetSessionOptions(
    ULONG       Request,
    ULONG_PTR    Argument,
    PULONG_PTR   Response
    )
{
    PSession    pSession;
    PLSAP_TASK_QUEUE  pQueue;
    NTSTATUS    Status ;

    pSession = GetCurrentSession();

    DebugLog(( DEB_TRACE, "[%d] SetSession( %d )\n",
                pSession->dwProcessID, Request ));

    Status = STATUS_SUCCESS ;

    LockSession( pSession );

    switch ( Request )
    {
        case SETSESSION_GET_STATUS:
            *Response = 0;
            break;

        case SETSESSION_ADD_WORKQUEUE:
            if ( pSession->SharedData->pQueue == NULL )
            {
                if ( CreateSubordinateQueue( pSession, &GlobalQueue ) )
                {
                    //
                    // If they're going to be that busy, convert the cred list
                    // to be a large table
                    //

                    AddRundown( pSession, LsapDeleteWorkQueue, NULL );

                    pSession->SharedData->CredTable = LhtConvertSmallToLarge(
                                    pSession->SharedData->CredTable );

                    pSession->SharedData->CredHandlePackage = &LargeHandlePackage ;
                }
                else
                {
                    Status = STATUS_UNSUCCESSFUL ;
                }
            }
            break;

        case SETSESSION_REMOVE_WORKQUEUE:
            break;

        case SETSESSION_GET_DISPATCH:
            if ( pSession->dwProcessID == GetCurrentProcessId() )
            {
                Status = InitializeDirectDispatcher();

                if ( NT_SUCCESS( Status ) )
                {
                    DllCallbackHandler = (PLSA_DISPATCH_FN) Argument ;
                    *Response = (ULONG_PTR) DispatchAPIDirect;
                }
            }
            else
            {
                Status = STATUS_ACCESS_DENIED ;
            }
            break;
    }

    UnlockSession( pSession );

    return( Status );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\base\lsa\server\sht.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1997.
//
//  File:       sht.cxx
//
//  Contents:   Small Handle table implementation
//
//  Classes:
//
//  Functions:
//
//  History:    2-03-97   RichardW   Created
//
//----------------------------------------------------------------------------


#include <lsapch.hxx>

#include "sht.hxx"

#if DBG
#define DBG_SHT 1
#else
#define DBG_SHT 0
#endif


#define SHT_ACTION_ADDREF       0
#define SHT_ACTION_DELREF       1
#define SHT_ACTION_FORCEDEL     2
#define SHT_ACTION_VALIDATE     3
#define SHT_ACTION_ADDHANDLE    4
#define SHT_ACTION_DELHANDLE    5

#define SHT_ACTION_MASK     0x0000FFFF
#define SHT_ACTION_LOCKED   0x00010000
#define SHTP_HANDLE_CHECKED 0x20000000

#define ShtLockTable( t ) \
            if ( (((PSMALL_HANDLE_TABLE) t)->Flags & SHT_NO_SERIALIZE ) == 0 ) \
            {                                                                  \
                RtlEnterCriticalSection( &((PSMALL_HANDLE_TABLE)t)->Lock ); \
            }

#define ShtUnlockTable( t ) \
            if ( (((PSMALL_HANDLE_TABLE) t)->Flags & SHT_NO_SERIALIZE ) == 0 ) \
            {                                                                  \
                RtlLeaveCriticalSection( &((PSMALL_HANDLE_TABLE)t)->Lock ); \
            }


HP_INITIALIZE_FN    ShtInitialize ;
HP_CREATE_FN        ShtCreate ;
HP_DELETE_FN        ShtDelete ;
HP_ADD_HANDLE_FN    ShtAddHandle ;
HP_DELETE_HANDLE_FN ShtDeleteHandle ;
HP_VALIDATE_HANDLE_FN ShtValidateHandle ;
HP_REF_HANDLE_FN    ShtRefHandle ;
HP_DEREF_HANDLE_KEY_FN ShtDerefHandleKey ;
HP_GET_HANDLE_CONTEXT_FN ShtGetHandleContext ;
HP_RELEASE_CONTEXT_FN ShtReleaseContext ;

HANDLE_PACKAGE  SmallHandlePackage = {
                    sizeof( SMALL_HANDLE_TABLE),
                    ShtInitialize,
                    ShtCreate,
                    ShtDelete,
                    ShtAddHandle,
                    ShtDeleteHandle,
                    ShtValidateHandle,
                    ShtRefHandle,
                    ShtDerefHandleKey,
                    ShtGetHandleContext,
                    ShtReleaseContext
                    };


//+---------------------------------------------------------------------------
//
//  Function:   ShtInitialize
//
//  Synopsis:   Initialize the small handle table package
//
//  Arguments:  (none)
//
//  History:    3-04-97   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
BOOL
ShtInitialize(
    VOID
    )
{
    return TRUE ;
}


//+---------------------------------------------------------------------------
//
//  Function:   ShtCreate
//
//  Synopsis:   Create a small handle table
//
//  Arguments:  [Flags]         -- Options
//              [HandleTable]   -- Space to fill
//
//  History:    3-04-97   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
PVOID
ShtCreate(
    IN ULONG Flags,
    IN PVOID HandleTable OPTIONAL,
    IN PHP_ENUM_CALLBACK_FN Callback OPTIONAL
    )
{
    PSMALL_HANDLE_TABLE Table ;

    if ( HandleTable )
    {
        Table = (PSMALL_HANDLE_TABLE) HandleTable ;
    }
    else
    {
        Table = (PSMALL_HANDLE_TABLE) LsapAllocatePrivateHeap( sizeof( SMALL_HANDLE_TABLE ) );
    }

    if ( Table )
    {
        Table->Tag = SHT_TAG ;
        Table->Count = 0 ;
        Table->Flags = 0 ;

        InitializeListHead( &Table->List );

        //
        // Turn on general flags:
        //

        Table->Flags = (Flags & HANDLE_PACKAGE_GENERAL_FLAGS);

        if ( Flags & HANDLE_PACKAGE_NO_SERIALIZE )
        {
            Table->Flags |= SHT_NO_SERIALIZE ;
        }
        else
        {
            NTSTATUS Status = RtlInitializeCriticalSectionAndSpinCount(
                                                    &Table->Lock,
                                                    LsaTuningParameters.CritSecSpinCount
                                                    );

            if (!NT_SUCCESS(Status))
            {
                if ( !HandleTable )
                {
                    LsapFreePrivateHeap( Table );
                }

                Table = NULL ;
            }
        }

        if ( Table )
        {

            if ( Flags & HANDLE_PACKAGE_CALLBACK_ON_DELETE )
            {
                Table->DeleteCallback = Callback ;
            }

            if ( HandleTable )
            {
                Table->Flags |= SHT_NO_FREE ;
            }
        }

    }

    return Table ;
}

//+---------------------------------------------------------------------------
//
//  Function:   ShtDelete
//
//  Synopsis:   Deletes a handle table.  Callback is called for every handle in
//              the table.
//
//  Arguments:  [HandleTable] --
//              [Callback]    --
//
//  History:    3-04-97   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
BOOL
ShtDelete(
    PVOID   HandleTable,
    PHP_ENUM_CALLBACK_FN Callback
    )
{
    PSMALL_HANDLE_TABLE Table ;
    PSEC_HANDLE_ENTRY Entry ;
    PLIST_ENTRY Scan ;
    ULONG RefCount ;

    Table = (PSMALL_HANDLE_TABLE) HandleTable ;

    ShtLockTable( Table );

    Table->Flags |= SHT_DELETE_PENDING ;

    while ( !IsListEmpty( &Table->List ) )
    {
        Scan = RemoveHeadList( &Table->List );

        Table->Count--;

        Entry = (PSEC_HANDLE_ENTRY) Scan ;

        Table->PendingHandle = Entry ;

        Entry->Flags |= SEC_HANDLE_FLAG_DELETE_PENDING ;

        RefCount = Entry->HandleCount ;
        Entry->HandleCount = 1;
        Entry->RefCount = 1 ;

        if ( ( Callback ) &&
             ( ( Entry->Flags & SEC_HANDLE_FLAG_NO_CALLBACK ) == 0 ) )
        {
            Callback( &Entry->Handle, Entry->Context, RefCount );
        }

        LsapFreePrivateHeap( Entry );

    }

    DsysAssert( Table->Count == 0 );

    if ( ( Table->Flags & SHT_NO_SERIALIZE ) == 0 )
    {
        RtlDeleteCriticalSection( &Table->Lock );
    }

    if ( (Table->Flags & SHT_NO_FREE) == 0 )
    {
        LsapFreePrivateHeap( Table );
    }

    return TRUE ;
}



#if DBG_SHT
//+---------------------------------------------------------------------------
//
//  Function:   ShtpValidateList
//
//  Synopsis:   Debug only - validates a handle table
//
//  Arguments:  [Table] --
//
//  History:    3-04-97   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
VOID
ShtpValidateList(
    PSMALL_HANDLE_TABLE Table,
    BOOL Locked
    )
{
    PLIST_ENTRY List ;
    PSEC_HANDLE_ENTRY Entry ;
    PSEC_HANDLE_ENTRY Back ;
    ULONG Count ;

    if ( !Locked )
    {
        ShtLockTable( Table );
    }

    List = Table->List.Flink ;
    Count = 0 ;

    while ( List && (List != &Table->List) )
    {
        Entry = (PSEC_HANDLE_ENTRY) List ;

        if ( List->Blink != &Table->List )
        {
            Back = (PSEC_HANDLE_ENTRY) List->Blink ;

            DsysAssertMsg( Back->Handle.dwUpper <= Entry->Handle.dwUpper, "Handle Table Corrupt (1)" );
        }

        List = List->Flink ;
        Count++ ;
    }

    DsysAssertMsg( List, "Handle Table Corrupt (2)" );
    DsysAssertMsg( Count == Table->Count, "Handle Table Corrupt (3)" );

    if ( !Locked )
    {
        ShtUnlockTable( Table );
    }
}

#endif


//+---------------------------------------------------------------------------
//
//  Function:   ShtpFindHandle
//
//  Synopsis:   General worker function for locating handles in the table
//
//  Arguments:  [Table]   -- Table to search
//              [Handle]  -- Handle to find
//              [Action]  -- Action to take
//              [Removed] -- Flag if it was removed or just deref'd
//
//  History:    3-04-97   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
PSEC_HANDLE_ENTRY
ShtpFindHandle(
    PSMALL_HANDLE_TABLE Table,
    PSecHandle  Handle,
    ULONG   Action,
    PBOOL  Removed OPTIONAL
    )
{
    PLIST_ENTRY Scan ;
    PSEC_HANDLE_ENTRY Entry ;
    BOOL Delete = FALSE ;
    Entry = NULL ;
    BOOL Locked ;
    BOOL Checked ;


    Locked = (Action & SHT_ACTION_LOCKED) == SHT_ACTION_LOCKED ;
    Checked = (Action & SHTP_HANDLE_CHECKED) == SHTP_HANDLE_CHECKED ;
    Action = Action & SHT_ACTION_MASK ;


#if DBG_SHT
    ShtpValidateList( Table, Locked );
#endif

    if ( !Locked )
    {
        ShtLockTable( Table );
    }

    if ( ( Table->Flags & SHT_DELETE_PENDING ) &&
         ( Table->PendingHandle ) )
    {
        if ( (Handle->dwUpper == Table->PendingHandle->Handle.dwUpper) &&
             (Handle->dwLower == Table->PendingHandle->Handle.dwLower) )
        {
            Entry = Table->PendingHandle ;

            DsysAssert( Entry->Flags & SEC_HANDLE_FLAG_DELETE_PENDING );

            goto FoundEntry ;
        }
    }


    Scan = Table->List.Flink ;

    while ( Scan != &Table->List )
    {
        Entry = (PSEC_HANDLE_ENTRY) Scan ;

        if ( Entry->Handle.dwUpper == Handle->dwUpper )
        {
            if ( Entry->Handle.dwLower == Handle->dwLower )
            {
                break;
            }
        }

        if ( Entry->Handle.dwUpper > Handle->dwUpper )
        {
            Entry = NULL ;
            break;
        }

        Scan = Entry->List.Flink ;

        Entry = NULL ;
    }

    if ( Entry && 
         ((Entry->Flags & SEC_HANDLE_FLAG_DELETE_PENDING) != 0 ) ) 
    {
        DebugLog(( DEB_WARN, "Entry %p on list but marked delete pending\n", Entry ));
        Entry = NULL ;
    }

    if ( Entry &&
         ( Entry->HandleCount == 0 ) &&
         ( !Checked ) )
    {
        DebugLog(( DEB_TRACE_HANDLES, "Entry %p has handle count 0, no ref for %p:%p \n", 
                   Entry,
                   Entry->Handle.dwUpper,
                   Entry->Handle.dwLower ));

        Entry = NULL ;
    }

FoundEntry :

    if ( Entry )
    {
        switch ( Action )
        {
            case SHT_ACTION_ADDHANDLE:

                Entry->HandleIssuedCount++;
                Entry->HandleCount++ ;

                //
                // Fall through to the ADDREF behavior:
                //

            case SHT_ACTION_ADDREF:

                Entry->RefCount++;

                break;

            case SHT_ACTION_DELHANDLE:

                if ( Entry->HandleCount )
                {
                    Entry->HandleCount-- ;
                }
                else 
                {
                    break;
                }

                //
                // Fall through to the DELREF behavior
                //

            case SHT_ACTION_DELREF:
            case SHT_ACTION_FORCEDEL:

                Entry->RefCount -- ;

                DsysAssert( Entry->RefCount >= Entry->HandleCount );

                if ( ( Entry->RefCount == 0 ) ||
                       ( Action == SHT_ACTION_FORCEDEL ) )
                {
                    if ( ( Entry->Flags & SEC_HANDLE_FLAG_DELETE_PENDING ) == 0 )
                    {
                        RemoveEntryList( &Entry->List );

                        Table->Count-- ;
                    }

                    Delete = TRUE ;
                }


                break;

            case SHT_ACTION_VALIDATE:
            default:
                break;

        }
    }

    if ( !Locked )
    {
        ShtUnlockTable( Table );
    }

    if ( Removed )
    {
        *Removed = Delete ;
    }


#if DBG_SHT
    ShtpValidateList( Table, Locked );
#endif

    return Entry ;

}

//+---------------------------------------------------------------------------
//
//  Function:   ShtpPopHandle
//
//  Synopsis:   Private function for the large package.  Pops a handle out of
//              the table for redistribution.
//
//  Arguments:  [Table] --
//
//  History:    3-04-97   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
PSEC_HANDLE_ENTRY
ShtpPopHandle(
    PSMALL_HANDLE_TABLE Table
    )
{
    PLIST_ENTRY List ;

    ShtLockTable( Table );

    if ( !IsListEmpty( &Table->List ) )
    {
        List = RemoveHeadList( &Table->List );

        Table->Count-- ;
    }
    else
    {
        List = NULL ;
    }

    ShtUnlockTable( Table );

#if DBG_SHT
    ShtpValidateList( Table, FALSE );
#endif

    return ((PSEC_HANDLE_ENTRY) List );
}

//+---------------------------------------------------------------------------
//
//  Function:   ShtpInsertHandle
//
//  Synopsis:   Worker function for lht.  Inserts an existing entry into a table
//
//  Arguments:  [Table] --
//              [Entry] --
//
//  History:    3-04-97   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
VOID
ShtpInsertHandle(
    PSMALL_HANDLE_TABLE Table,
    PSEC_HANDLE_ENTRY Entry
    )
{
    PLIST_ENTRY Scan ;
    PSEC_HANDLE_ENTRY Compare ;

    ShtLockTable( Table );

    Scan = Table->List.Flink ;

    while ( Scan != &Table->List )
    {
        Compare = (PSEC_HANDLE_ENTRY) Scan ;

        if ( Compare->Handle.dwUpper >= Entry->Handle.dwUpper )
        {
            break;
        }

        Scan = Compare->List.Flink ;

        Compare = NULL ;

    }

    InsertTailList( Scan, &Entry->List );

    Table->Count++;

    ShtUnlockTable( Table );

#if DBG_SHT
    ShtpValidateList( Table, FALSE );
#endif
}

//+---------------------------------------------------------------------------
//
//  Function:   ShtAddHandle
//
//  Synopsis:   Add a handle to the table.
//
//  Arguments:  [HandleTable] --
//              [Handle]      --
//
//  History:    3-04-97   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
BOOL
ShtAddHandle(
    PVOID   HandleTable,
    PSecHandle  Handle,
    PVOID Context,
    ULONG Flags
    )
{
    PSMALL_HANDLE_TABLE Table ;
    PSEC_HANDLE_ENTRY Entry ;
    PSEC_HANDLE_ENTRY Compare ;
    PLIST_ENTRY Scan ;

    Table = (PSMALL_HANDLE_TABLE) HandleTable ;

    //
    // Need to make whole add operation atomic
    //

    ShtLockTable( Table );

    if ( ShtpFindHandle( Table,
                         Handle,
                         SHT_ACTION_ADDHANDLE | SHT_ACTION_LOCKED,
                         NULL ) )
    {
        ShtUnlockTable( Table );

        if ( Table->Flags & HANDLE_PACKAGE_REQUIRE_UNIQUE )
        {
            return FALSE ;
        }

        return TRUE ;
    }

    Entry = (PSEC_HANDLE_ENTRY) LsapAllocatePrivateHeap(
                                    sizeof( SEC_HANDLE_ENTRY ) );

    if ( Entry )
    {
        Entry->RefCount = 1;
        Entry->HandleCount = 1;
        Entry->Handle = *Handle ;
        Entry->Context = Context ;
        Entry->HandleIssuedCount = 1;

        Scan = Table->List.Flink ;

        while ( Scan != &Table->List )
        {
            Compare = (PSEC_HANDLE_ENTRY) Scan ;

            if ( Compare->Handle.dwUpper >= Handle->dwUpper )
            {
                break;
            }

            Scan = Compare->List.Flink ;

            Compare = NULL ;

        }

        Entry->Flags = Flags ;

        InsertTailList( Scan, &Entry->List );

        Table->Count++;

        ShtUnlockTable( Table );

#if DBG_SHT
    ShtpValidateList( Table, FALSE );
#endif
        return TRUE ;
    }

    ShtUnlockTable( Table );

    return FALSE ;

}

//+---------------------------------------------------------------------------
//
//  Function:   ShtDeleteHandle
//
//  Synopsis:   Deletes a handle from the table
//
//  Arguments:  [HandleTable] --
//              [Handle]      --
//              [Force]       --
//
//  History:    3-04-97   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
BOOL
ShtDeleteHandle(
    PVOID       HandleTable,
    PSecHandle  Handle,
    ULONG       Options
    )
{
    PSEC_HANDLE_ENTRY Entry ;
    BOOL Delete ;

    Entry = ShtpFindHandle( (PSMALL_HANDLE_TABLE) HandleTable,
                           Handle,
                           (Options & DELHANDLE_FORCE) ? 
                                SHT_ACTION_FORCEDEL : SHT_ACTION_DELHANDLE,
                           &Delete );

    if ( Entry )
    {
        if ( Delete )
        {
            PSMALL_HANDLE_TABLE Table = (PSMALL_HANDLE_TABLE) HandleTable ;

            if ( ( Table->DeleteCallback ) &&
                 ( ( Options & DELHANDLE_NO_CALLBACK ) == 0 ) &&
                 ( ( Entry->Flags & SEC_HANDLE_FLAG_NO_CALLBACK ) == 0 ) )
            {
                Table->DeleteCallback(
                                &Entry->Handle,
                                Entry->Context,
                                Entry->HandleIssuedCount    // Entry->RefCount
                                );
            }

            if ( (Entry->Flags & SEC_HANDLE_FLAG_DELETE_PENDING) == 0 )
            {
                LsapFreePrivateHeap( Entry );
            }

        }

        return TRUE ;
    }

    return FALSE ;
}

//+---------------------------------------------------------------------------
//
//  Function:   ShtValidateHandle
//
//  Synopsis:   Validates a handle is listed in the table.
//
//  Arguments:  [HandleTable] --
//              [Handle]      --
//
//  History:    3-04-97   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
BOOL
ShtValidateHandle(
    PVOID       HandleTable,
    PSecHandle  Handle,
    BOOL        Deref
    )
{
    PSEC_HANDLE_ENTRY Entry ;
    BOOL Delete = FALSE ;
    PSMALL_HANDLE_TABLE Table = (PSMALL_HANDLE_TABLE) HandleTable ;

    Entry = ShtpFindHandle( Table,
                            Handle,
                            (Deref ? SHT_ACTION_DELHANDLE : SHT_ACTION_VALIDATE),
                            &Delete );

    if ( Entry )
    {
        if ( Delete )
        {
            if ( ( Table->DeleteCallback ) &&
                 ( ( Entry->Flags & SEC_HANDLE_FLAG_NO_CALLBACK ) == 0 ) )
            {
                Table->DeleteCallback(
                                &Entry->Handle,
                                Entry->Context,
                                Entry->HandleIssuedCount    // Entry->HandleCount
                                );
            }

            if ( ( Entry->Flags & SEC_HANDLE_FLAG_DELETE_PENDING ) == 0 )
            {
                LsapFreePrivateHeap( Entry );
            }
        }
        return TRUE ;
    }
    else
    {
        return FALSE ;
    }
}

PVOID
ShtRefHandle(
    PVOID HandleTable,
    PSecHandle Handle
    )
{
    PSEC_HANDLE_ENTRY Entry ;

    Entry = ShtpFindHandle( (PSMALL_HANDLE_TABLE) HandleTable,
                            Handle,
                            SHT_ACTION_ADDREF,
                            NULL );

    return Entry ;

}

VOID
ShtDerefHandleKey(
    PVOID HandleTable,
    PVOID HandleKey
    )
{
    PSMALL_HANDLE_TABLE Table = (PSMALL_HANDLE_TABLE) HandleTable ;
    PSEC_HANDLE_ENTRY Entry = (PSEC_HANDLE_ENTRY) HandleKey ;
    BOOL Delete = FALSE ;

    ShtLockTable( Table );

    Entry->RefCount -- ;

    DsysAssert( Entry->RefCount >= Entry->HandleCount );

    if ( ( Entry->Flags & SEC_HANDLE_FLAG_DELETE_PENDING ) == 0 )
    {
        if ( Entry->RefCount == 0 )
        {
            RemoveEntryList( &Entry->List );

            Delete = TRUE ;

            Table->Count-- ;
        }
    }

    ShtUnlockTable( Table );

    if ( Delete )
    {
        if ( ( Table->DeleteCallback ) &&
             ( ( Entry->Flags & SEC_HANDLE_FLAG_NO_CALLBACK ) == 0 ) )
        {
            Table->DeleteCallback( &Entry->Handle, Entry->Context, Entry->HandleCount );
        }

        if ( ( Entry->Flags & SEC_HANDLE_FLAG_DELETE_PENDING ) == 0 )
        {
            LsapFreePrivateHeap( Entry );
        }
    }

}

//+---------------------------------------------------------------------------
//
//  Function:   ShtGetHandleContext
//
//  Synopsis:   Returns the context pointer associated with the handle
//
//  Arguments:  [HandleTable] --
//              [Handle]      --
//
//  History:    8-17-98   RichardW   Created
//
//  Notes:      Adds a reference so it can't be deleted while in use.
//
//----------------------------------------------------------------------------
PVOID
ShtGetHandleContext(
    PVOID HandleTable,
    PSecHandle Handle
    )
{
    PSEC_HANDLE_ENTRY Entry ;

    Entry = ShtpFindHandle( (PSMALL_HANDLE_TABLE) HandleTable,
                            Handle,
                            SHT_ACTION_ADDREF,
                            NULL );

    if ( Entry )
    {
        return Entry->Context ;
    }

    return NULL ;
}


//+---------------------------------------------------------------------------
//
//  Function:   ShtReleaseContext
//
//  Synopsis:   Deref's a handle entry
//
//  Arguments:  [HandleTable] --
//              [Handle]      --
//
//  History:    8-17-98   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
BOOL
ShtReleaseContext(
    PVOID HandleTable,
    PSecHandle Handle
    )
{
    PSEC_HANDLE_ENTRY Entry ;
    BOOL Delete ;

    Entry = ShtpFindHandle( (PSMALL_HANDLE_TABLE) HandleTable,
                           Handle,
                           SHT_ACTION_DELREF,
                           &Delete );

    if ( Entry )
    {
        if ( Delete )
        {
            PSMALL_HANDLE_TABLE Table = (PSMALL_HANDLE_TABLE) HandleTable ;

            if ( ( Table->DeleteCallback ) &&
                 ( ( Entry->Flags & SEC_HANDLE_FLAG_NO_CALLBACK ) == 0 ) )
            {
                Table->DeleteCallback( &Entry->Handle, Entry->Context, Entry->RefCount );
            }

            if ( ( Entry->Flags & SEC_HANDLE_FLAG_DELETE_PENDING ) == 0 )
            {
                LsapFreePrivateHeap( Entry );
            }
        }

        return TRUE ;
    }

    return FALSE ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\base\lsa\server\spinit.h ===
//+-----------------------------------------------------------------------
//
// Microsoft Windows
//
// Copyright (c) Microsoft Corporation 1991 - 1992
//
// File:        SPINIT.H
//
// Contents:    Common structures and functions for the SPINIT
//
//
// History:     20 May 92   RichardW    Documented existing stuff
//
//------------------------------------------------------------------------



#ifndef __SPINIT_H__
#define __SPINIT_H__


HRESULT   LoadPackages( PWSTR * ppszPackageList,
                        PWSTR * ppszOldPkgs,
                        PWSTR pszPreferred );

void    InitThreadData(void);
void    InitSystemLogon(void);
BOOLEAN LsapEnableCreateTokenPrivilege(void);

extern
SECPKG_FUNCTION_TABLE   NegTable ;


#endif  __SPINIT_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\base\lsa\server\sphelp.cxx ===
//+-----------------------------------------------------------------------
//
// Microsoft Windows
//
// Copyright (c) Microsoft Corporation 1991 - 1992
//
// File:        sphelp.c
//
// Contents:    Security Package Helper functions (see isecpkg.doc)
//
// Functions    LsapUnloadPackage
//              LsapAllocate
//              LsapFree
//              LsapClientAllocate
//              LsapCopyToClient
//              LsapCopyFromClient
//              LsapClientFree
//              LsapOpenClientProcess
//              LsapOpenClientThread
//              LsapDuplicateHandle
//              LsapGetWindow
//              LsapCreateThread
//              LsapMapClientBuffer
//
//
// Notes:       By defining TRACK_MEM, we will track all use of memory
//              allocated through the LsapAllocate.  DBG_MEM will track
//              memory leaks.
//
// History:     20 May 92   RichardW    Created
//
//------------------------------------------------------------------------

#include <lsapch.hxx>

extern "C"
{
#include "sesmgr.h"
#include "klpcstub.h"

}

typedef struct _LSAP_THREAD_START {
    LPTHREAD_START_ROUTINE  lpStart;
    LPVOID                  lpParm;
    ULONG_PTR               dwPackageID;
} LSAP_THREAD_START, *PLSAP_THREAD_START;

extern LSA_CALL_INFO LsapDefaultCallInfo ;

ULONG_PTR   LsapUserModeLimit ;

//
// private heaps defines.
//

//
// HEAP_HEADER should always be size even multiple of heap allocation granularity
//

typedef struct {
    HANDLE      hHeap;
    SIZE_T      Magic;
} HEAP_HEADER_LSA, *PHEAP_HEADER_LSA;

#define HEAP_COUNT_MAX  32
#define HEAP_MAGIC_TAG  0x66677766

HANDLE gHeaps[ HEAP_COUNT_MAX ];
DWORD gcHeaps;

LSA_SECPKG_FUNCTION_TABLE LsapSecpkgFunctionTable = {
    LsapCreateLogonSession,
    LsapDeleteLogonSession,
    LsapAddCredential,
    LsapGetCredentials,
    LsapDeleteCredential,
    LsapAllocateLsaHeap,
    LsapFreeLsaHeap,
    LsapAllocateClientBuffer,
    LsapFreeClientBuffer,
    LsapCopyToClientBuffer,
    LsapCopyFromClientBuffer,
    LsapImpersonateClient,
    LsapUnloadPackage,
    LsapDuplicateHandle,
    NULL,                       // LsapSaveSupplementalCredentials,
    LsapCreateThread,
    LsapGetClientInfo,
    LsaIRegisterNotification,
    LsaICancelNotification,
    LsapMapClientBuffer,
    LsapCreateToken,
    LsapAuditLogon,
    LsaICallPackage,
    LsaIFreeReturnBuffer,
    LsapGetCallInfo,
    LsaICallPackageEx,
    LsaCreateSharedMemory,
    LsaAllocateSharedMemory,
    LsaFreeSharedMemory,
    LsaDeleteSharedMemory,
    LsaOpenSamUser,
    NULL,                       // LsaGetUserCredentials
    LsaGetUserAuthData,
    LsaCloseSamUser,
    LsaConvertAuthDataToToken,
    LsaClientCallback,
    LsapUpdateCredentials,
    LsaGetAuthDataForUser,
    LsaCrackSingleName,
    LsaIAuditAccountLogon,
    LsaICallPackagePassthrough,
    CrediRead,
    CrediReadDomainCredentials,
    CrediFreeCredentials,
    LsaProtectMemory,
    LsaUnprotectMemory,
    LsapOpenTokenByLogonId,
    LsaExpandAuthDataForDomain,
    LsapAllocatePrivateHeap,
    LsapFreePrivateHeap,
    LsapCreateTokenEx,
    CrediWrite
    };


//+-------------------------------------------------------------------------
//
//  Function:   LsapOpenCaller
//
//  Synopsis:   Opens the calling process
//
//  Effects:
//
//  Arguments:  phProcess   -- receives handle to process
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//--------------------------------------------------------------------------

NTSTATUS
LsapOpenCaller(
    IN OUT PSession pSession
    )
{
    HANDLE hProcess;
    NTSTATUS Status;
    OBJECT_ATTRIBUTES ObjectAttributes;
    CLIENT_ID ClientId;
    PVOID Ignored ;

    ClientId.UniqueThread = NULL;
    ClientId.UniqueProcess = (HANDLE) LongToHandle(pSession->dwProcessID);

    InitializeObjectAttributes(
        &ObjectAttributes,
        NULL,
        0,
        NULL,
        NULL
        );

    Status = NtOpenProcess(
                &hProcess,
                PROCESS_DUP_HANDLE |        // Duplicate Handles
                    PROCESS_QUERY_INFORMATION | // Get token
                    PROCESS_VM_OPERATION |      // Allocate
                    PROCESS_VM_READ |           // Read memory
                    PROCESS_VM_WRITE,           // Write memory
                &ObjectAttributes,
                &ClientId
                );

    if (!NT_SUCCESS(Status))
    {
        DebugLog((DEB_ERROR, "Did not open process %08x, error %08x\n",
            pSession->dwProcessID, Status));

        return( Status );
    }

    pSession->hProcess = hProcess;

    Status = NtQueryInformationProcess(
                    hProcess,
                    ProcessSessionInformation,
                    &pSession->SessionId,
                    sizeof( ULONG ),
                    NULL );

#if _WIN64
    Status = NtQueryInformationProcess(
                    hProcess,
                    ProcessWow64Information,
                    &Ignored,
                    sizeof( Ignored ),
                    NULL );

    if ( NT_SUCCESS( Status ) )
    {
        if ( Ignored != 0 )
        {
            pSession->fSession |= SESFLAG_WOW_PROCESS ;
        }
    }
#endif

    return( STATUS_SUCCESS );
}


//+-------------------------------------------------------------------------
//
//  Function:   CheckCaller
//
//  Synopsis:   Checks if calling process has been opened, opens if it
//              hasn't.
//
//  Effects:
//
//  Arguments:  pSession -  Current session
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//--------------------------------------------------------------------------

NTSTATUS
CheckCaller(
    IN PSession pSession
    )
{
    NTSTATUS       Status;

    if (!pSession->hProcess)
    {
        Status = LsapOpenCaller(pSession);
        if (FAILED(Status))
        {
            DebugLog((DEB_ERROR, "Could not open client (%x)\n", Status));
            return(Status);
        }

    }
    return(STATUS_SUCCESS);

}


//+-------------------------------------------------------------------------
//
//  Function:   LsapUnloadPackage
//
//  Synopsis:   Unloads the calling package in case of catastrophic problems
//
//  Effects:    Unloads the DLL that generated this call.
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:      Calling thread is terminated through a special exception.
//
//--------------------------------------------------------------------------

NTSTATUS NTAPI
LsapUnloadPackage(
    VOID
    )
{
    ULONG_PTR PackageId;
    PSession    pSession = GetCurrentSession();

    PackageId = GetCurrentPackageId();

    pSession->fSession |= SESFLAG_UNLOADING;

    RaiseException((ULONG) SEC_E_BAD_PKGID, 0, 0, NULL);

    return(STATUS_SUCCESS);
}


BOOLEAN
LsapHeapInitialize(
    IN BOOLEAN Server
    )
{
    if( !Server )
    {
        NT_PRODUCT_TYPE ProductType;

        if ( RtlGetNtProductType( &ProductType ) &&
             (ProductType == NtProductServer || ProductType == NtProductLanManNt)
             )
        {
            Server = TRUE;
        }
    }

    if ( Server )
    {
        SYSTEM_INFO si;
        DWORD Heaps;
        DWORD i, cHeapsCreated;
        RTL_HEAP_PARAMETERS HeapParameters;
        ULONG Value;

        GetSystemInfo( &si );

        if( si.dwNumberOfProcessors == 0 )
        {
            Heaps = 1;
        }
        else if( si.dwNumberOfProcessors > HEAP_COUNT_MAX )
        {
            Heaps = HEAP_COUNT_MAX;
        }
        else
        {
            Heaps = si.dwNumberOfProcessors;
        }

        ZeroMemory( &HeapParameters, sizeof(HeapParameters) );
        HeapParameters.Length = sizeof(HeapParameters);
        HeapParameters.DeCommitTotalFreeThreshold = 8 * LsapPageSize ;

        cHeapsCreated = 0;

        for( i = 0 ; i < Heaps ; i++ )
        {
            gHeaps[ cHeapsCreated ] = RtlCreateHeap(
                                        HEAP_GROWABLE,
                                        NULL,
                                        0,
                                        0,
                                        NULL,
                                        &HeapParameters
                                        );

            if( gHeaps[ cHeapsCreated ] != NULL )
            {

                //
                // enable low-frag heap.
                //

                Value = 2;

                HeapSetInformation(
                                gHeaps[ cHeapsCreated ],
                                HeapCompatibilityInformation,
                                &Value,
                                sizeof(Value)
                                );

                cHeapsCreated++;
            }
        }

        gcHeaps = cHeapsCreated;


        //
        // enable low-frag heap on process heap.
        //

        Value = 2;

        HeapSetInformation(
                        GetProcessHeap(),
                        HeapCompatibilityInformation,
                        &Value,
                        sizeof(Value)
                        );
    }

    if( gHeaps[ 0 ] == NULL )
    {
        gHeaps[ 0 ] = RtlProcessHeap();
        gcHeaps = 1;
    }

    return TRUE;
}


//+-------------------------------------------------------------------------
//
//  Function:   LsapAllocateLsaHeap
//
//  Synopsis:   Allocates memory on process heap
//
//  Effects:
//
//  Arguments:  cbMemory    -- Size of block needed
//
//  Requires:
//
//  Returns:    ptr to memory
//
//  Notes:      if DBGMEM or TRACK_MEM defined, extra work is done for
//              tracking purposes.
//
//              Can raise the exception STATUS_NO_MEMORY
//
//              Per object reuse rules of C2 and above, we zero any memory
//              allocated through this function
//
//--------------------------------------------------------------------------
PVOID NTAPI
LsapAllocateLsaHeap(
    IN ULONG cbMemory
    )
{
    return(RtlAllocateHeap(
                RtlProcessHeap(),
                HEAP_ZERO_MEMORY,
                cbMemory
                ));
}


//+-------------------------------------------------------------------------
//
//  Function:   LsapFreeLsaHeap
//
//  Synopsis:   Frees memory allocated by LsapAllocateLsaHeap
//
//  Effects:
//
//  Arguments:  pvMemory
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//--------------------------------------------------------------------------

void NTAPI
LsapFreeLsaHeap(
    IN PVOID pvMemory
    )
{
    RtlFreeHeap(
                RtlProcessHeap(),
                0,
                pvMemory
                );

}


//+-------------------------------------------------------------------------
//
//  Function:   LsapAllocatePrivateHeap
//
//  Synopsis:   Allocates memory on private heap(s)
//
//  Effects:
//
//  Arguments:  cbMemory    -- Size of block needed
//
//  Requires:
//
//  Returns:    ptr to memory
//
//              Per object reuse rules of C2 and above, we zero any memory
//              allocated through this function
//
//--------------------------------------------------------------------------
PVOID
NTAPI
LsapAllocatePrivateHeap(
    IN SIZE_T cbMemory
    )
{
    HANDLE hHeap;

    PHEAP_HEADER_LSA memory;

    hHeap = LsapGetCurrentHeap();

    if( hHeap == NULL )
    {
        static ULONG heapindex;
        ULONG LocalHeapIndex;

        LocalHeapIndex = (ULONG)InterlockedIncrement( (PLONG)&heapindex );
        LocalHeapIndex %= gcHeaps;

        hHeap = gHeaps[ LocalHeapIndex ];

        LsapSetCurrentHeap( hHeap );
    }

    memory = (PHEAP_HEADER_LSA)RtlAllocateHeap(
                hHeap,
                HEAP_ZERO_MEMORY,
                cbMemory+sizeof(HEAP_HEADER_LSA)
                );

    if( memory != NULL )
    {

        memory->hHeap = hHeap;
        memory->Magic = (unsigned char*)HEAP_MAGIC_TAG-(unsigned char*)hHeap;

        return ( (unsigned char*)memory+sizeof(HEAP_HEADER_LSA) );
    }

    DebugLog((DEB_ERROR,"LsapAllocatePrivateHeap: %p failed allocate %lu bytes\n", hHeap, cbMemory));

    return NULL;
}


PVOID
NTAPI
LsapAllocatePrivateHeapNoZero(
    IN SIZE_T cbMemory
    )
{
    HANDLE hHeap;

    PHEAP_HEADER_LSA memory;


    hHeap = LsapGetCurrentHeap();

    if( hHeap == NULL )
    {
        static ULONG heapindex;
        ULONG LocalHeapIndex;

        LocalHeapIndex = (ULONG)InterlockedIncrement( (PLONG)&heapindex );
        LocalHeapIndex %= gcHeaps;

        hHeap = gHeaps[ LocalHeapIndex ];

        LsapSetCurrentHeap( hHeap );
    }

    memory = (PHEAP_HEADER_LSA)RtlAllocateHeap(
                hHeap,
                0,
                cbMemory+sizeof(HEAP_HEADER_LSA)
                );

    if( memory != NULL )
    {
        memory->hHeap = hHeap;
        memory->Magic = (unsigned char*)HEAP_MAGIC_TAG-(unsigned char*)hHeap;

        return ( (unsigned char*)memory+sizeof(HEAP_HEADER_LSA) );
    }

    DebugLog((DEB_ERROR,"LsapAllocatePrivateHeapNoZero: %p failed allocate %lu bytes\n", hHeap, cbMemory));

    return NULL;
}


//+-------------------------------------------------------------------------
//
//  Function:   LsapFreePrivateHeap
//
//  Synopsis:   Frees memory allocated by LsapAllocatePrivateHeap
//
//  Effects:
//
//  Arguments:  pvMemory
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//--------------------------------------------------------------------------
void
NTAPI
LsapFreePrivateHeap(
    IN PVOID pvMemory
    )
{
    PHEAP_HEADER_LSA HeapEntry;

    if( pvMemory == NULL )
    {
        return ;
    }

    HeapEntry = (PHEAP_HEADER_LSA)((unsigned char*)pvMemory-sizeof(HEAP_HEADER_LSA));

    if( HeapEntry->Magic + ((unsigned char*)HeapEntry->hHeap) != (unsigned char*)HEAP_MAGIC_TAG )
    {
        DebugLog((DEB_ERROR, "LsapFreePrivateHeap tried to free %p from wrong heap\n",
            pvMemory));

        DsysAssert( pvMemory == NULL );
        return;
    }

    RtlFreeHeap(
                HeapEntry->hHeap,
                0,
                HeapEntry
                );

}


//+-------------------------------------------------------------------------
//
//  Function:   LsapClientAllocate
//
//  Synopsis:   Allocates memory in client process
//
//  Effects:
//
//  Arguments:  cbMemory    -- Size of block to allocate
//
//  Requires:
//
//  Returns:    pointer to memory in client address space
//
//  Notes:      pointer is not valid in this process, only in client
//
//--------------------------------------------------------------------------
PVOID NTAPI
LsapClientAllocate(
    IN ULONG cbMemory
    )
{
    NTSTATUS        Status;
    PSession        pSession;
    void *          pClientMemory = NULL;
    SIZE_T          cbMem = cbMemory;
    PLSA_CALL_INFO  CallInfo ;

    CallInfo = LsapGetCurrentCall();

    pSession = GetCurrentSession() ;

    if ( pSession == NULL )
    {
        pSession = pDefaultSession ;
    }

    if ( CallInfo == NULL )
    {
        CallInfo = &LsapDefaultCallInfo ;
    }

    if (FAILED(CheckCaller(pSession)))
    {
        return(NULL);
    }

    //
    // If the INPROC flag is set, allocate out of the heap.  The copy functions
    // will also honor this.
    //

    if ( pSession->fSession & SESFLAG_INPROC )
    {
        pClientMemory = LsapAllocateLsaHeap( (ULONG) cbMem );

        return( pClientMemory );
    }

    if ( CallInfo->Flags & CALL_FLAG_KERNEL_POOL )
    {
        if ( ( CallInfo->Flags & CALL_FLAG_KMAP_USED ) != 0 )
        {

            pClientMemory = LsapAllocateFromKsecBuffer(
                                CallInfo->KMap,
                                (ULONG) cbMem );

            DebugLog((DEB_TRACE_HELPERS, "[%x] LsapClientAllocate(%d) = %p in KMap %p\n",
                        pSession->dwProcessID, cbMem,
                        pClientMemory, CallInfo->KMap ));

            return pClientMemory ;
        }
    }

    Status = NtAllocateVirtualMemory(pSession->hProcess,
                                    &pClientMemory,
                                    0,
                                    &cbMem,
                                    MEM_COMMIT,
                                    PAGE_READWRITE);

    if (!NT_SUCCESS(Status))
    {
        DebugLog((DEB_ERROR, "[%x] Could not allocate client memory (%x)\n",
                        pSession->dwProcessID, Status));

        pClientMemory = NULL;
    }

    DebugLog((DEB_TRACE_HELPERS, "[%x] LsapClientAllocate(%d) = %p\n",
                    pSession->dwProcessID, cbMemory, pClientMemory));

    if ( pClientMemory )
    {
        // Save pointer so that FreeContextBuffer will use
        // correct 'free' function.
        if(CallInfo->Allocs < MAX_BUFFERS_IN_CALL)
        {
            CallInfo->Buffers[ CallInfo->Allocs++ ] = pClientMemory ;
        }
    }

    return(pClientMemory);
}


//+-------------------------------------------------------------------------
//
//  Function:   LsapCopyToClient
//
//  Synopsis:   Copies data into client process
//
//  Effects:
//
//  Arguments:  pLocalMemory    -- pointer to data in this process
//              pClientMemory   -- pointer to destination in client process
//              cbMemory        -- how much to copy
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//--------------------------------------------------------------------------
NTSTATUS NTAPI
LsapCopyToClient(
    IN PVOID pLocalMemory,
    OUT PVOID pClientMemory,
    IN ULONG cbMemory
    )
{
    NTSTATUS     Status;
    PSession    pSession;
    PLSA_CALL_INFO CallInfo;
    PKSEC_LSA_MEMORY_HEADER Header ;
    ULONG i ;
    ULONG_PTR Basis ;
    ULONG_PTR Limit ;
    BOOL Tried = FALSE ;

    if (cbMemory == 0)
    {
        return(STATUS_SUCCESS);
    }

    pSession = GetCurrentSession();

    if ( !pSession )
    {
        pSession = pDefaultSession ;
    }

    CallInfo = LsapGetCurrentCall();

    if ( ( pLocalMemory == NULL ) ||
         ( pClientMemory == NULL ) )
    {
        return STATUS_ACCESS_VIOLATION ;
    }

    if (FAILED(Status = CheckCaller(pSession)))
    {
        return(Status);
    }

    //
    // Cases for a direct copy:
    //
    //  - The current session is the default session
    //  - This is an inproc call
    //  - We're using a KMap buffer
    //

    if (CallInfo &&
        CallInfo->Flags & CALL_FLAG_KERNEL_POOL )
    {

        Header = CallInfo->KMap ;

        if ( (ULONG_PTR) pClientMemory > LsapUserModeLimit )
        {
            //
            // Someone is trying to deal with a pool address directly.
            // we can handle this if it was copied into the KMap already
            //

            for ( i = 0 ; i < Header->MapCount ; i++ )
            {
                Limit  = (ULONG_PTR) Header->PoolMap[ i ].Pool + Header->PoolMap[ i ].Size ;

                if ( ((ULONG_PTR) pClientMemory >= (ULONG_PTR) Header->PoolMap[ i ].Pool ) &&
                    ( (ULONG_PTR) pClientMemory < Limit ) )
                {
                    //
                    // Found an overlap, this is promising.  Check the bounds:
                    //

                    Basis = (ULONG_PTR) pClientMemory -
                                (ULONG_PTR) Header->PoolMap[ i ].Pool ;

                    if (  Basis + cbMemory <= Header->PoolMap[ i ].Size )
                    {
                        //
                        // Found it!
                        //
                        __try
                        {
                            RtlCopyMemory(
                                (PUCHAR) Header +
                                        (Header->PoolMap[ i ].Offset +
                                         Basis),
                                pLocalMemory,
                                cbMemory );

                            Status = STATUS_SUCCESS ;
                        }
                        __except (EXCEPTION_EXECUTE_HANDLER)
                        {
                            Status = GetExceptionCode();
                        }
                    }

                    Tried = TRUE ;
                    break;

                }
            }

            if ( !Tried )
            {
                Status = STATUS_ACCESS_VIOLATION ;
            }
        }
        else if ( LsapIsBlockInKMap( CallInfo->KMap, pClientMemory ) )
        {
            __try
            {

                RtlCopyMemory( pClientMemory, pLocalMemory, cbMemory );

                Status = STATUS_SUCCESS ;
            }
            __except (EXCEPTION_EXECUTE_HANDLER)
            {
                Status = GetExceptionCode();
            }
        }
        else
        {

            Status = NtWriteVirtualMemory(pSession->hProcess,
                                        pClientMemory,
                                        pLocalMemory,
                                        cbMemory,
                                        NULL);
        }

    } else if ( (pSession->dwProcessID == pDefaultSession->dwProcessID) ||
         (pSession->fSession & SESFLAG_INPROC) ||
         (CallInfo->Flags & CALL_FLAG_KMAP_USED ) )
    {
        __try
        {

            RtlCopyMemory( pClientMemory, pLocalMemory, cbMemory );

            Status = STATUS_SUCCESS ;
        }
        __except ( EXCEPTION_EXECUTE_HANDLER )
        {
            Status = GetExceptionCode();
        }
    }
    else
    {

        Status = NtWriteVirtualMemory(  pSession->hProcess,
                                        pClientMemory,
                                        pLocalMemory,
                                        cbMemory,
                                        NULL);
    }

    DebugLog((DEB_TRACE_HELPERS, "[%x] LsapCopyToClient(%p, %p, %d) = %x\n",
                pSession->dwProcessID, pLocalMemory, pClientMemory, cbMemory,
                Status ));

    return(Status);
}


//+-------------------------------------------------------------------------
//
//  Function:   LsapCopyFromClient
//
//  Synopsis:   Copies memory from client to this process
//
//  Effects:
//
//  Arguments:  pClientMemory   -- Pointer to data in client space
//              pLocalMemory    -- Pointer to destination in this process
//              cbMemory        -- How much
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//--------------------------------------------------------------------------

NTSTATUS NTAPI
LsapCopyFromClient(
    IN PVOID pClientMemory,
    OUT PVOID pLocalMemory,
    IN ULONG cbMemory
    )
{
    NTSTATUS       Status;
    PSession    pSession;
    PLSA_CALL_INFO CallInfo ;
    PKSEC_LSA_MEMORY_HEADER Header ;
    ULONG i ;
    ULONG_PTR Basis ;
    ULONG_PTR Limit ;
    BOOL Tried = FALSE ;

    if (cbMemory == 0)
    {
        return(STATUS_SUCCESS);
    }

    if ( ( pClientMemory == NULL ) ||
         ( pLocalMemory == NULL ) )
    {
        return STATUS_ACCESS_VIOLATION ;
    }

    pSession = GetCurrentSession();

    if ( pSession == NULL )
    {
        pSession = pDefaultSession ;
    }

    CallInfo = LsapGetCurrentCall();

    if (FAILED(Status = CheckCaller(pSession)))
    {
        return(Status);
    }

    if (CallInfo &&
        CallInfo->Flags & CALL_FLAG_KERNEL_POOL )
    {
        Header = CallInfo->KMap ;

        if ( (ULONG_PTR) pClientMemory > LsapUserModeLimit )
        {
            //
            // Someone is trying to deal with a pool address directly.
            // we can handle this if it was copied into the KMap already
            //

            for ( i = 0 ; i < Header->MapCount ; i++ )
            {
                Limit  = (ULONG_PTR) Header->PoolMap[ i ].Pool + Header->PoolMap[ i ].Size ;

                if ( ((ULONG_PTR) pClientMemory >= (ULONG_PTR) Header->PoolMap[ i ].Pool ) &&
                    ( (ULONG_PTR) pClientMemory < Limit ) )
                {
                    //
                    // Found an overlap, this is promising.  Check the bounds:
                    //

                    Basis = (ULONG_PTR) pClientMemory -
                                (ULONG_PTR) Header->PoolMap[ i ].Pool ;

                    if (  Basis + cbMemory <= Header->PoolMap[ i ].Size )
                    {
                        //
                        // Found it!
                        //
                        __try
                        {
                            RtlCopyMemory(
                                pLocalMemory,
                                (PUCHAR) Header +
                                        (Header->PoolMap[ i ].Offset +
                                         Basis),
                                cbMemory );


                            Status = STATUS_SUCCESS ;
                        }
                        __except (EXCEPTION_EXECUTE_HANDLER)
                        {
                            Status = GetExceptionCode();
                        }
                    }

                    Tried = TRUE ;
                    break;
                }
            }

            if ( !Tried )
            {
                Status = STATUS_ACCESS_VIOLATION ;
            }

        }
        else if ( LsapIsBlockInKMap( CallInfo->KMap, pClientMemory ) )
        {
            __try
            {

                RtlCopyMemory( pLocalMemory, pClientMemory, cbMemory );

                Status = STATUS_SUCCESS ;
            }
            __except (EXCEPTION_EXECUTE_HANDLER)
            {
                Status = GetExceptionCode();
            }
        }
        else
        {
            Status = NtReadVirtualMemory(pSession->hProcess,
                                        pClientMemory,
                                        pLocalMemory,
                                        cbMemory,
                                        NULL);
        }

    }
    else if ( (pSession->dwProcessID == pDefaultSession->dwProcessID) ||
         (pSession->fSession & SESFLAG_INPROC ) )
    {
        __try
        {
            RtlCopyMemory( pLocalMemory, pClientMemory, cbMemory );

            Status = STATUS_SUCCESS ;
        }
        __except (EXCEPTION_EXECUTE_HANDLER)
        {
            Status = GetExceptionCode();
        }
    }
    else
    {
        Status = NtReadVirtualMemory(pSession->hProcess,
                                    pClientMemory,
                                    pLocalMemory,
                                    cbMemory,
                                    NULL);
    }

    DebugLog((DEB_TRACE_HELPERS, "[%x] LsapCopyFromClient(%p, %p, %d) = %x\n",
                pSession->dwProcessID, pClientMemory, pLocalMemory, cbMemory,
                Status));

    return(Status);
}


//+-------------------------------------------------------------------------
//
//  Function:   LsapClientFree
//
//  Synopsis:   Frees memory allocated in client space
//
//  Effects:
//
//  Arguments:  pClientMemory   -- pointer to memory to free
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//--------------------------------------------------------------------------
NTSTATUS NTAPI
LsapClientFree(
    IN PVOID pClientMemory
    )
{
    NTSTATUS       Status;
    SIZE_T         cbMem = 0;
    PSession    pSession;
    PLSA_CALL_INFO  CallInfo ;

    CallInfo = LsapGetCurrentCall();
    if ( CallInfo == NULL )
    {
        CallInfo = &LsapDefaultCallInfo ;
    }

    if (!pClientMemory)
    {
        return(STATUS_SUCCESS);
    }

    pSession = GetCurrentSession();

    if ( pSession == NULL )
    {
        pSession = pDefaultSession ;
    }

    if (FAILED(Status = CheckCaller(pSession)))
    {
        return(Status);
    }

    if ( pSession->fSession & SESFLAG_INPROC )
    {
        LsapFreeLsaHeap( pClientMemory );

        return( STATUS_SUCCESS );
    }

#if DBG
    if ( pSession->dwProcessID == pDefaultSession->dwProcessID )
    {
        DebugLog(( DEB_ERROR, "Freeing VM in LSA:  %x\n", pClientMemory ));
    }
#endif

    Status = NtFreeVirtualMemory(pSession->hProcess,
                                &pClientMemory,
                                &cbMem,
                                MEM_RELEASE);

    if ( pClientMemory )
    {
        ULONG i;

        // Remove this pointer from our list.
        for(i = 0; i < CallInfo->Allocs; i++)
        {
            if(CallInfo->Buffers[i] == pClientMemory)
            {
                if(i < CallInfo->Allocs - 1)
                {
                    memcpy(&CallInfo->Buffers[i],
                           &CallInfo->Buffers[i+1],
                           sizeof(PVOID) * (CallInfo->Allocs - i - 1));
                }
                CallInfo->Allocs--;
                break;
            }
        }
    }

    DebugLog((DEB_TRACE_HELPERS, "[%x] LsapClientFree(%x) == %x\n",
            pSession->dwProcessID, pClientMemory, Status));

    return(Status);
}


//+-------------------------------------------------------------------------
//
//  Function:   LsapDuplicateHandle
//
//  Synopsis:   Duplicates a handle to an NT object into the calling process
//
//  Effects:    A new handle is generated, referencing the object
//
//  Arguments:  hObject     -- handle to the object
//              hNewObject  -- New handle valid in calling process
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//--------------------------------------------------------------------------
NTSTATUS NTAPI
LsapDuplicateHandle(
    IN HANDLE hObject,
    OUT PHANDLE phNewObject
    )

{
    NTSTATUS     Status;
    PSession    pSession;

    pSession = GetCurrentSession();

    if ( pSession == NULL )
    {
        pSession = pDefaultSession ;
    }

    if (Status = CheckCaller(pSession))
    {
        DebugLog((DEB_ERROR, "CheckCaller returned %d\n", Status));
        return(Status);
    }

    Status = NtDuplicateObject(  NtCurrentProcess(),
                                hObject,
                                pSession->hProcess,
                                phNewObject,
                                0,
                                0,
                                DUPLICATE_SAME_ACCESS);


    DebugLog((DEB_TRACE_HELPERS, "[%x] LsapDupHandle(%x, %x (@%x)) = %x\n",
            pSession->dwProcessID, hObject, *phNewObject, phNewObject, Status));

    return(Status);
}


//+---------------------------------------------------------------------------
//
//  Function:   LsapImpersonateClient
//
//  Synopsis:   Impersonate the client of the API call.
//
//  Arguments:  (none)
//
//  History:    6-05-95   RichardW   Created
//
//  Notes:      Threads should call RevertToSelf() when done.
//
//----------------------------------------------------------------------------

NTSTATUS NTAPI
LsapImpersonateClient(
    VOID
    )
{
    PSession            pSession;
    PLSA_CALL_INFO      CallInfo ;
    PSPM_LPC_MESSAGE    pApiMessage;
    NTSTATUS            Status;

    CallInfo = LsapGetCurrentCall() ;

    if ( CallInfo->InProcCall )
    {
        if ( CallInfo->InProcToken )
        {
            Status = NtSetInformationThread(
                        NtCurrentThread(),
                        ThreadImpersonationToken,
                        (PVOID) &CallInfo->InProcToken,
                        sizeof(HANDLE)
                        );
        }
        else
        {
            Status = RtlImpersonateSelf(SecurityImpersonation);
        }
    }
    else
    {
        pSession = GetCurrentSession() ;

        if ( !pSession )
        {
            pSession = pDefaultSession ;
        }

        Status = NtImpersonateClientOfPort(
                    pSession->hPort,
                    (PPORT_MESSAGE) CallInfo->Message);
    }

    return(Status);
}


//+-------------------------------------------------------------------------
//
//  Function:   LsapDuplicateString
//
//  Synopsis:
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//--------------------------------------------------------------------------
NTSTATUS
LsapDuplicateString(
    OUT PUNICODE_STRING pDest,
    IN PUNICODE_STRING pSrc
    )

{
    pDest->Length = 0;
    if (pSrc == NULL)
    {
        pDest->Buffer = NULL;
        pDest->MaximumLength = 0;
        return(STATUS_SUCCESS);
    }

    pDest->Buffer = (LPWSTR) LsapAllocateLsaHeap(pSrc->Length + sizeof(WCHAR));
    if (pDest->Buffer)
    {
        pDest->MaximumLength = pSrc->Length + sizeof(WCHAR);
        RtlCopyMemory(
            pDest->Buffer,
            pSrc->Buffer,
            pSrc->Length
            );
        pDest->Buffer[pSrc->Length/sizeof(WCHAR)] = L'\0';
        pDest->Length = pSrc->Length;
        return(STATUS_SUCCESS);

    }
    else
    {
        pDest->MaximumLength = 0;
        return(STATUS_INSUFFICIENT_RESOURCES);
    }
}


NTSTATUS
LsapDuplicateString2(
    OUT PUNICODE_STRING pDest,
    IN PUNICODE_STRING pSrc
    )
/*++

    Same as LsapDuplicateString(), but uses LsapPrivateHeap routines.

--*/
{
    pDest->Length = 0;
    if (pSrc == NULL)
    {
        pDest->Buffer = NULL;
        pDest->MaximumLength = 0;
        return(STATUS_SUCCESS);
    }

    pDest->Buffer = (LPWSTR) LsapAllocatePrivateHeap(pSrc->Length + sizeof(WCHAR));
    if (pDest->Buffer)
    {
        pDest->MaximumLength = pSrc->Length + sizeof(WCHAR);
        RtlCopyMemory(
            pDest->Buffer,
            pSrc->Buffer,
            pSrc->Length
            );
        pDest->Buffer[pSrc->Length/sizeof(WCHAR)] = L'\0';
        pDest->Length = pSrc->Length;
        return(STATUS_SUCCESS);

    } else
    {
        pDest->MaximumLength = 0;
        return(STATUS_INSUFFICIENT_RESOURCES);
    }
}


//+-------------------------------------------------------------------------
//
//  Function:   LsapFreeString
//
//  Synopsis:   Frees a string allocated by LsapDuplicateString
//
//  Effects:
//
//  Arguments:  String - Optionally points to a UNICODE_STRING
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------


VOID
LsapFreeString(
    IN OPTIONAL PUNICODE_STRING String
    )
{
    if (ARGUMENT_PRESENT(String) && String->Buffer != NULL)
    {
        LsapFreeLsaHeap(String->Buffer);
        String->Buffer = NULL;
    }
}


//+-------------------------------------------------------------------------
//
//  Function:   LsapThreadBase
//
//  Synopsis:   Thread start routine
//
//  Effects:    Sets up all the TLS data for a thread, then executes
//              the "real" base function.
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//--------------------------------------------------------------------------

void
LsapThreadBase(
    PLSAP_THREAD_START pThread)
{
    NTSTATUS Status;
    PSession        pSession;
    LSAP_THREAD_START tStart = *pThread;

    LsapFreePrivateHeap(pThread);

    SetCurrentSession( pDefaultSession );

    SpmpReferenceSession( pDefaultSession );

    // Initialize Session information:

    SetCurrentPackageId(tStart.dwPackageID);


    DebugLog((DEB_TRACE, "Thread start @%x\n", tStart.lpStart));

    // If this is a debug build, all threads are started in a protective
    // try-except block.  For retail, only threads started by packages
    // will be run this way.  Retail builds, we assume that the SPM is
    // debugged and running correctly, and threads started this way can
    // be trusted.

#if DBG == 0
    if (tStart.dwPackageID != SPMGR_ID)
#endif
    {
        __try
        {
            tStart.lpStart(tStart.lpParm);
        }
        __except (SP_EXCEPTION)
        {
            Status = GetExceptionCode();
            Status = SPException(Status, tStart.dwPackageID);
        }
    }
#if DBG == 0
    else
    {
        tStart.lpStart(tStart.lpParm);
    }
#endif

    pSession = GetCurrentSession();

    SpmpDereferenceSession( pSession );

    if ( pSession != pDefaultSession )
    {
        DebugLog(( DEB_ERROR, "Thread completing in session other than default!\n" ));
    }

    DebugLog((DEB_TRACE, "Thread exit\n" ));

}


//+-------------------------------------------------------------------------
//
//  Function:   LsapCreateThread
//
//  Synopsis:   Creates a thread with all the proper Tls stuff
//
//  Effects:
//
//  Arguments:  same as CreateThread
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//--------------------------------------------------------------------------

HANDLE NTAPI
LsapCreateThread(
    IN LPSECURITY_ATTRIBUTES lpSA,
    IN ULONG cbStack,
    IN LPTHREAD_START_ROUTINE lpStart,
    IN LPVOID lpvThreadParm,
    IN ULONG fCreate,
    OUT PULONG lpTID
    )
{
    PLSAP_THREAD_START pThread;
    HANDLE hThread;

    pThread = (PLSAP_THREAD_START) LsapAllocatePrivateHeap(sizeof(LSAP_THREAD_START));
    if (pThread == NULL)
    {
        DebugLog((DEB_ERROR, "LsapCreateThread, memory allocation failed.\n"));
        SetLastError(ERROR_OUTOFMEMORY);
        return(NULL);
    }

    pThread->lpStart = lpStart;
    pThread->lpParm = lpvThreadParm;
    pThread->dwPackageID = GetCurrentPackageId();

    hThread = CreateThread(
                        lpSA,
                        cbStack,
                        (LPTHREAD_START_ROUTINE) LsapThreadBase,
                        pThread,
                        fCreate,
                        lpTID
                        );

    if( hThread == NULL )
    {
        DebugLog((DEB_ERROR, "LsapCreateThread, failed thread creation (%lu)\n", GetLastError()));

        LsapFreePrivateHeap( pThread );
    }

    return hThread;
}


//+-------------------------------------------------------------------------
//
//  Function:   LsapGetClientInfo
//
//  Synopsis:
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//--------------------------------------------------------------------------
NTSTATUS NTAPI
LsapGetClientInfo(
    OUT PSECPKG_CLIENT_INFO ClientInfo
    )
{
    PSession pSession = GetCurrentSession();
    PPORT_MESSAGE pMessage;
    HANDLE ClientToken;
    NTSTATUS Status;
    NTSTATUS ExtraStatus ;
    TOKEN_STATISTICS TokenStats;
    ULONG TokenStatsSize = sizeof(TOKEN_STATISTICS);
    PLSA_CALL_INFO CallInfo ;
    HANDLE Thread = NULL ;
    OBJECT_ATTRIBUTES NullAttributes = { 0 };
    KERNEL_USER_TIMES Times ;

    RtlZeroMemory(
        ClientInfo,
        sizeof(SECPKG_CLIENT_INFO)
        );

    if ( !pSession )
    {
        pSession = pDefaultSession ;
    }

    //
    // First, fill in the easy stuff from the session record. If we are
    // running with the LSA session then we want to ignore the LPC message
    // because it may be referring to somebody elses message (we may be
    // being called on behalf of someone doing authenticated RPC in response
    // to an LPC request)
    //

    CallInfo = LsapGetCurrentCall();

    if ( CallInfo )
    {
        ClientInfo->ProcessID  = CallInfo->CallInfo.ProcessId ;
        ClientInfo->ThreadID = CallInfo->CallInfo.ThreadId ;

        if (((pSession->fSession & SESFLAG_TCB_PRIV) != 0) ||
            ((pSession->fSession & SESFLAG_KERNEL) != 0))
        {
            ClientInfo->HasTcbPrivilege = TRUE;
        }
        else
        {
            ClientInfo->HasTcbPrivilege = FALSE;
        }

        if(CallInfo->CachedTokenInfo)
        {
            ClientInfo->LogonId = CallInfo->LogonId;
            ClientInfo->Restricted = CallInfo->Restricted;
            ClientInfo->Impersonating = CallInfo->Impersonating;
            ClientInfo->ImpersonationLevel = CallInfo->ImpersonationLevel;

            return STATUS_SUCCESS;
        }

        Status = LsapImpersonateClient();


        if ( !NT_SUCCESS( Status ) )
        {
            if ( Status == STATUS_BAD_IMPERSONATION_LEVEL )
            {
                Status = NtOpenThread(
                            &Thread,
                            THREAD_QUERY_INFORMATION,
                            &NullAttributes,
                            &CallInfo->Message->pmMessage.ClientId );
            }
            else if ( ( Status == STATUS_REPLY_MESSAGE_MISMATCH ) ||
                      ( Status == STATUS_INVALID_CID ) ||
                      ( Status == STATUS_PORT_DISCONNECTED ) )
            {
                //
                // This is a special status returned by the LPC layer to indicate
                // that the client thread has disappeared, or the process is
                // terminating.  Set a flag to indicate this:
                //

                ClientInfo->ClientFlags |= SECPKG_CLIENT_THREAD_TERMINATED ;

                CallInfo->CallInfo.Attributes |= SECPKG_CALL_THREAD_TERM ;
                //
                // Check the process.  If the process has started to exit, set that
                // flag as well.
                //

                ExtraStatus = NtQueryInformationProcess(
                                pSession->hProcess,
                                ProcessTimes,
                                &Times,
                                sizeof( Times ),
                                NULL );

                if ( NT_SUCCESS( ExtraStatus ) )
                {
                    if ( Times.ExitTime.QuadPart != 0 )
                    {
                        ClientInfo->ClientFlags |= SECPKG_CLIENT_PROCESS_TERMINATED ;
                        CallInfo->CallInfo.Attributes |= SECPKG_CALL_PROCESS_TERM ;
                    }
                }

                DebugLog(( DEB_TRACE, "Client %x.%x has terminated\n",
                           ClientInfo->ProcessID, ClientInfo->ThreadID ));

                return STATUS_SUCCESS ;
            }

        }
        else
        {
            Thread = NtCurrentThread();
        }

        if (!NT_SUCCESS(Status))
        {
            DebugLog((DEB_WARN,"Failed to impersonate client: 0x%x\n",Status));
            return(Status);
        }

        Status = NtOpenThreadToken(
                    Thread,
                    TOKEN_QUERY,
                    TRUE,               // use LSA security context
                    &ClientToken
                    );
        if (NT_SUCCESS(Status))
        {
            ClientInfo->Restricted = ( IsTokenRestricted(ClientToken) != 0 );

            Status = NtQueryInformationToken(
                        ClientToken,
                        TokenStatistics,
                        (PVOID) &TokenStats,
                        TokenStatsSize,
                        &TokenStatsSize
                        );
            NtClose(ClientToken);
            if (NT_SUCCESS(Status))
            {
                ClientInfo->LogonId = TokenStats.AuthenticationId;
                ClientInfo->Impersonating = (TokenStats.TokenType == TokenPrimary) ? FALSE : TRUE;
                if( ClientInfo->Impersonating )
                {
                    ClientInfo->ImpersonationLevel = TokenStats.ImpersonationLevel;
                } else {
                    ClientInfo->ImpersonationLevel = SecurityImpersonation;
                }
            }
        }
        RevertToSelf();
        if ( Thread != NtCurrentThread() )
        {
            NtClose( Thread );
        }

        if(NT_SUCCESS(Status))
        {
            CallInfo->LogonId = ClientInfo->LogonId;
            CallInfo->Restricted = ClientInfo->Restricted;
            CallInfo->Impersonating = ClientInfo->Impersonating;
            CallInfo->ImpersonationLevel = ClientInfo->ImpersonationLevel;
            CallInfo->CachedTokenInfo = TRUE;
        }

        return(Status);

    }
    else
    {
        ClientInfo->ProcessID = GetCurrentProcessId();
        ClientInfo->ThreadID = GetCurrentThreadId();
        ClientInfo->HasTcbPrivilege = TRUE;
        ClientInfo->Impersonating = FALSE;
        ClientInfo->ImpersonationLevel = SecurityImpersonation;
        ClientInfo->LogonId = SystemLogonId;
        return(STATUS_SUCCESS);
    }
}

//+---------------------------------------------------------------------------
//
//  Function:   LsapGetCallInfo
//
//  Synopsis:   Gets call information
//
//  Arguments:  [Info] --
//
//  History:    10-06-96   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
BOOLEAN
LsapGetCallInfo(
    PSECPKG_CALL_INFO   Info
    )
{
    PLSA_CALL_INFO CallInfo ;

    CallInfo = LsapGetCurrentCall() ;

    if ( CallInfo )
    {
        *Info = CallInfo->CallInfo ;
        if ( CallInfo->InProcCall )
        {
            Info->Attributes |= SECPKG_CALL_IN_PROC ;
        }

        return TRUE ;
    } else {
        Info->ProcessId = GetCurrentProcessId();
        Info->ThreadId = GetCurrentThreadId();
        Info->Attributes = SECPKG_CALL_IN_PROC |
                                SECPKG_CALL_IS_TCB ;
        Info->CallCount = 0;

        return TRUE;
    }
}

//+-------------------------------------------------------------------------
//
//  Function:   LsapMapClientBuffer
//
//  Synopsis:   Maps a client's SecBuffer into the caller's address space
//
//  Effects:    Clears the SECBUFFER_UNMAPPED field of the BufferType of
//              the return SecBuffer
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:      Doesn't modify pOutput until the end, so it is o.k. to pass
//              the same thing for pInput and pOutput.
//
//
//--------------------------------------------------------------------------
NTSTATUS
LsapMapClientBuffer(
    IN PSecBuffer pInput,
    OUT PSecBuffer pOutput
    )
{
    NTSTATUS Status = STATUS_SUCCESS ;
    SecBuffer Output ;
    Output = *pInput ;
    PLSA_CALL_INFO CallInfo = LsapGetCurrentCall();

    //
    // If the buffer is already mapped or it doesn't exist (is NULL) we
    // are done.
    //

    if (!(pInput->BufferType & SECBUFFER_UNMAPPED) ||
        (!pInput->cbBuffer))
    {
        return( STATUS_SUCCESS );
    }
    else
    {
        Output.BufferType &= ~SECBUFFER_UNMAPPED;
    }

    if ( pInput->BufferType & SECBUFFER_KERNEL_MAP )
    {
        //
        // This one is already in process space
        //

        if ( ( CallInfo->CallInfo.Attributes & SECPKG_CALL_KERNEL_MODE ) == 0 )
        {
            //
            // If this call did not come from kernel mode with
            // the kernel-pool flag set, then this is an attempted
            // hack on the LSA.  Reject it.
            //

            Status = STATUS_ACCESS_VIOLATION ;

        }
        else
        {
            //
            // The buffer is already in memory.  Mark the call as
            // using kernel-pool memory, so we allocate correctly
            // on the return.
            //

            CallInfo->Flags |= CALL_FLAG_KERNEL_POOL ;
            DebugLog((DEB_TRACE_SPECIAL, "Kernel Pool Map at %p [%x,%x]\n",
                        Output.pvBuffer, Output.BufferType, Output.cbBuffer ));
        }


    }
    else
    {
        Output.pvBuffer = LsapAllocateLsaHeap( Output.cbBuffer );

        if ( Output.pvBuffer != NULL )
        {
            Status = LsapCopyFromClient(
                pInput->pvBuffer,
                Output.pvBuffer,
                Output.cbBuffer );

            if ( !NT_SUCCESS( Status ) )
            {
                //
                // STATUS_ACCESS_VIOLATION most likely due to STATUS_INVALID_PARAMETER
                //

                if (STATUS_ACCESS_VIOLATION == Status)
                {
                    Status = STATUS_INVALID_PARAMETER;
                }

                LsapFreeLsaHeap(Output.pvBuffer);
            }

        }
        else
        {

            Status = STATUS_NO_MEMORY ;
        }


    }

    if ( NT_SUCCESS( Status ) )
    {
        *pOutput = Output ;
    }

    return( Status );
}


//+-------------------------------------------------------------------------
//
//  Function:   LsaICallPackage
//
//  Synopsis:   Function to call another security package
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------

extern "C"
NTSTATUS
LsaICallPackage(
    IN PUNICODE_STRING AuthenticationPackage,
    IN PVOID ProtocolSubmitBuffer,
    IN ULONG SubmitBufferLength,
    OUT PVOID *ProtocolReturnBuffer,
    OUT PULONG ReturnBufferLength,
    OUT PNTSTATUS ProtocolStatus
    )
{
    return LsaICallPackageEx( AuthenticationPackage,
                              ProtocolSubmitBuffer,   // client buffer base is same as local buffer
                              ProtocolSubmitBuffer,
                              SubmitBufferLength,
                              ProtocolReturnBuffer,
                              ReturnBufferLength,
                              ProtocolStatus );

}

//+-------------------------------------------------------------------------
//
//  Function:   LsaICallPackageEx
//
//  Synopsis:   Function to call another security package
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------

extern "C"
NTSTATUS
LsaICallPackageEx(
    IN PUNICODE_STRING AuthenticationPackage,
    IN PVOID ClientBufferBase,
    IN PVOID ProtocolSubmitBuffer,
    IN ULONG SubmitBufferLength,
    OUT PVOID *ProtocolReturnBuffer,
    OUT PULONG ReturnBufferLength,
    OUT PNTSTATUS ProtocolStatus
    )
{
    NTSTATUS Status = STATUS_SUCCESS;
    PLSAP_SECURITY_PACKAGE Package;
    PSession OldSession;
    ULONG_PTR OldPackageId;

    Package = SpmpLookupPackageAndRequest(
                AuthenticationPackage,
                SP_ORDINAL_CALLPACKAGE
                );

    if (Package == NULL)
    {
        DebugLog((DEB_WARN,"LsapCallPackage failed: package %wZ not found\n",
            AuthenticationPackage ));
        Status = STATUS_NO_SUCH_PACKAGE;
        goto Cleanup;
    }

    //
    // Set the session to be the LSA's so calls to allocate memory
    // will allocate in the correct process
    //

    OldSession = GetCurrentSession();
    SetCurrentSession( pDefaultSession );


    //
    // Set the package id
    //

    OldPackageId = GetCurrentPackageId();

    SetCurrentPackageId(Package->dwPackageID);


    //
    // Call into the security package.
    //

    Status = Package->FunctionTable.CallPackage(
                NULL,
                ProtocolSubmitBuffer,
                ClientBufferBase,
                SubmitBufferLength,
                ProtocolReturnBuffer,
                ReturnBufferLength,
                ProtocolStatus
                );

    //
    // Restore the original package id
    //

    SetCurrentPackageId(OldPackageId);


    //
    // Restore our original session
    //

    SetCurrentSession( OldSession );


Cleanup:

    return(Status);

}

//+-------------------------------------------------------------------------
//
//  Function:   LsaICallPackagePassthrough
//
//  Synopsis:   Function to call another security package for pass-through request
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------

extern "C"
NTSTATUS
LsaICallPackagePassthrough(
    IN PUNICODE_STRING AuthenticationPackage,
    IN PVOID ClientBufferBase,
    IN PVOID ProtocolSubmitBuffer,
    IN ULONG SubmitBufferLength,
    OUT PVOID *ProtocolReturnBuffer,
    OUT PULONG ReturnBufferLength,
    OUT PNTSTATUS ProtocolStatus
    )
{
    NTSTATUS Status = STATUS_SUCCESS;
    PLSAP_SECURITY_PACKAGE Package;
    PSession OldSession;

    Package = SpmpLookupPackageAndRequest(
                AuthenticationPackage,
                SP_ORDINAL_CALLPACKAGE
                );

    if (Package == NULL)
    {
        DebugLog((DEB_WARN,"LsapCallPackage failed: package %wZ not found\n",
            AuthenticationPackage ));
        Status = STATUS_NO_SUCH_PACKAGE;
        goto Cleanup;
    }

    //
    // Set the session to be the LSA's so calls to allocate memory
    // will allocate in the correct process
    //

    OldSession = GetCurrentSession();
    SetCurrentSession( pDefaultSession );

    Status = Package->FunctionTable.CallPackagePassthrough(
                NULL,
                ProtocolSubmitBuffer,
                ClientBufferBase,
                SubmitBufferLength,
                ProtocolReturnBuffer,
                ReturnBufferLength,
                ProtocolStatus
                );

    //
    // Restore our original session
    //

    SetCurrentSession( OldSession );


Cleanup:

    return(Status);

}

extern "C"
VOID
LsaIFreeReturnBuffer(
    IN PVOID Buffer
    )
/*++

Routine Description:

    Some of the LSA authentication services allocate memory buffers to
    hold returned information.  This service is used to free those buffers
    when no longer needed.

Arguments:

    Buffer - Supplies a pointer to the return buffer to be freed.

Return Status:

    STATUS_SUCCESS - Indicates the service completed successfully.

    Others - returned by NtFreeVirtualMemory().

--*/

{

    SIZE_T Length;

    Length = 0;

    DebugLog(( DEB_TRACE_HELPERS, "LsaIFreeReturnBuffer - freeing VM at %x\n", Buffer ));
    if (((ULONG_PTR) Buffer & 0xfff) != 0)
    {
        DbgPrint("Freeing non-page address: %p\n",Buffer);
        DbgBreakPoint();
    }

    NtFreeVirtualMemory(
        NtCurrentProcess(),
        &Buffer,
        &Length,
        MEM_RELEASE
        );

}

NTSTATUS
LsaClientCallback(
    PCHAR   Callback,
    ULONG_PTR Argument1,
    ULONG_PTR Argument2,
    PSecBuffer Input,
    PSecBuffer Output
    )
{
    PSession Session ;
    ULONG Type ;

    Session = GetCurrentSession();

    if ( !Session )
    {
        Session = pDefaultSession ;
    }
    if ( !Session->hPort &&
         ((Session->fSession & SESFLAG_DEFAULT) == 0) )
    {
        return SEC_E_INVALID_HANDLE ;
    }

    if ( (ULONG_PTR) Callback < 0x00010000 )
    {
        Type = SPM_CALLBACK_PACKAGE ;
    }
    else
    {
        Type = SPM_CALLBACK_EXPORT ;
    }

    return LsapClientCallback(  Session,
                                Type,
                                Callback,
                                (PVOID) Argument1,
                                (PVOID) Argument2,
                                Input,
                                Output );
}


//+-------------------------------------------------------------------------
//
//  Function:   LsapUpdateCredentials
//
//  Synopsis:   This function provides a mechanism for one package to notify
//              another package that the credentials for a logon session
//              have changed.
//
//  Effects:
//
//  Arguments:  PrimaryCredentials - Primary information about the user.
//                      All fields may be NULL but the LogonId
//              Credentials - Array of credentials for different packages
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------

NTSTATUS
LsapUpdateCredentials(
    IN PSECPKG_PRIMARY_CRED PrimaryCredentials,
    IN OPTIONAL PSECPKG_SUPPLEMENTAL_CRED_ARRAY Credentials
    )
{
    return(LsapUpdateCredentialsWorker(
                (SECURITY_LOGON_TYPE) 0,              // no logon type
                NULL,           // no account name
                PrimaryCredentials,
                Credentials ));
}


//+-------------------------------------------------------------------------
//
//  Function:   LsapUpdateCredentialsWorker
//
//  Synopsis:   Worker function for updated credentials - calls all package
//              with specified credentials
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------

NTSTATUS
LsapUpdateCredentialsWorker(
    IN SECURITY_LOGON_TYPE LogonType,
    IN PUNICODE_STRING AccountName,
    IN PSECPKG_PRIMARY_CRED PrimaryCredentials,
    IN OPTIONAL PSECPKG_SUPPLEMENTAL_CRED_ARRAY Credentials
    )
{
    NTSTATUS Status;
    ULONG_PTR CurrentPackageId;
    PLSAP_SECURITY_PACKAGE SupplementalPackage;
    SupplementalPackage = SpmpIteratePackagesByRequest( NULL, SP_ORDINAL_ACCEPTCREDS );

    CurrentPackageId = GetCurrentPackageId();
    while (SupplementalPackage)
    {

        if (SupplementalPackage->dwPackageID != CurrentPackageId)
        {
            ULONG Index;
            PSECPKG_SUPPLEMENTAL_CRED SuppCreds;

            //
            // For all packages,  do the accept call so the
            // package can associate the credentials with
            // the logon session.
            //

            DebugLog((DEB_TRACE_WAPI, "Whacking package %ws with %x:%x = %wZ\n",
                        SupplementalPackage->Name.Buffer,
                        PrimaryCredentials->LogonId.HighPart, PrimaryCredentials->LogonId.LowPart,
                        AccountName));


            SetCurrentPackageId( SupplementalPackage->dwPackageID );

            //
            // Find any supplmental credentials
            //

            SuppCreds = NULL;
            if (Credentials != NULL)
            {
                for (Index = 0; Index < Credentials->CredentialCount ; Index++ ) {
                    if (RtlEqualUnicodeString(
                            &Credentials->Credentials[Index].PackageName,
                            &SupplementalPackage->Name,
                            TRUE))
                    {
                        SuppCreds = &Credentials->Credentials[Index];
                        break;
                    }

                }
            }

            __try
            {
                Status = SupplementalPackage->FunctionTable.AcceptCredentials(
                                LogonType,
                                AccountName,
                                PrimaryCredentials,
                                SuppCreds
                                );
            }
            __except (SP_EXCEPTION)
            {
                Status = GetExceptionCode();
                Status = SPException(Status, SupplementalPackage->dwPackageID);
            }

            // Note:  if an exception occurs, we don't fail the logon, we just
            // do the magic on the package that blew.  If the package blows,
            // the other packages may succeed, and so the user may not be able
            // to use that provider.

        }

        SupplementalPackage = SpmpIteratePackagesByRequest(
                                SupplementalPackage,
                                SP_ORDINAL_ACCEPTCREDS
                                );

    }

    return(STATUS_SUCCESS);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\base\lsa\server\sphelp.h ===
//+-----------------------------------------------------------------------
//
// Microsoft Windows
//
// Copyright (c) Microsoft Corporation 1991 - 1992
//
// File:        SPHELP.H
//
// Contents:    Headers and prototypes for the sp helper functions
//
//
// History:     21 May 92   RichardW    Created
//
//------------------------------------------------------------------------

#ifndef __SPHELP_H__
#define __SPHELP_H__

extern LSA_SECPKG_FUNCTION_TABLE LsapSecpkgFunctionTable;

#pragma warning(4:4276) // Disable warning

LSA_IMPERSONATE_CLIENT LsapImpersonateClient;
LSA_UNLOAD_PACKAGE LsapUnloadPackage;
LSA_DUPLICATE_HANDLE LsapDuplicateHandle;
LSA_CREATE_THREAD LsapCreateThread;
LSA_GET_CLIENT_INFO LsapGetClientInfo;
LSA_MAP_BUFFER LsapMapClientBuffer;
LSA_CREATE_TOKEN LsapCreateToken;
LSA_CREATE_TOKEN_EX LsapCreateTokenEx;
LSA_AUDIT_LOGON LsapAuditLogon;

LSA_GET_CALL_INFO LsapGetCallInfo;
LSA_CREATE_SHARED_MEMORY LsaCreateSharedMemory;
LSA_ALLOCATE_SHARED_MEMORY LsaAllocateSharedMemory;
LSA_FREE_SHARED_MEMORY LsaFreeSharedMemory;
LSA_DELETE_SHARED_MEMORY LsaDeleteSharedMemory;
LSA_OPEN_SAM_USER LsaOpenSamUser ;
LSA_GET_USER_AUTH_DATA LsaGetUserAuthData ;
LSA_CLOSE_SAM_USER LsaCloseSamUser ;
LSA_CONVERT_AUTH_DATA_TO_TOKEN LsaConvertAuthDataToToken ;
LSA_CLIENT_CALLBACK LsaClientCallback ;
LSA_GET_AUTH_DATA_FOR_USER LsaGetAuthDataForUser ;
LSA_CRACK_SINGLE_NAME LsaCrackSingleName ;
LSA_EXPAND_AUTH_DATA_FOR_DOMAIN LsaExpandAuthDataForDomain;

PVOID NTAPI
LsapClientAllocate(
    IN ULONG cbMemory
    );

NTSTATUS NTAPI
LsapCopyToClient(
    IN PVOID pLocalMemory,
    OUT PVOID pClientMemory,
    IN ULONG cbMemory
    );

NTSTATUS NTAPI
LsapCopyFromClient(
    IN PVOID pClientMemory,
    OUT PVOID pLocalMemory,
    IN ULONG cbMemory
    );

NTSTATUS NTAPI
LsapClientFree(
    IN PVOID pClientMemory
    );


NTSTATUS
LsapOpenCaller(
    IN OUT PSession pSession
    );

NTSTATUS
CheckCaller(
    IN PSession pSession
    );

NTSTATUS
LsapDuplicateString(
    OUT PUNICODE_STRING pDest,
    IN PUNICODE_STRING pSrc
    );

NTSTATUS
LsapDuplicateString2(
    OUT PUNICODE_STRING pDest,
    IN PUNICODE_STRING pSrc
    );

VOID
LsapFreeString(
    IN OPTIONAL PUNICODE_STRING String
    );

NTSTATUS
LsapUpdateCredentials(
    IN PSECPKG_PRIMARY_CRED PrimaryCredentials,
    IN OPTIONAL PSECPKG_SUPPLEMENTAL_CRED_ARRAY Credentials
    );

NTSTATUS
LsapUpdateCredentialsWorker(
    IN SECURITY_LOGON_TYPE LogonType,
    IN PUNICODE_STRING AccountName,
    IN PSECPKG_PRIMARY_CRED PrimaryCredentials,
    IN OPTIONAL PSECPKG_SUPPLEMENTAL_CRED_ARRAY Credentials
    );


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\base\lsa\server\spmgr.h ===
//+-----------------------------------------------------------------------
//
// Microsoft Windows
//
// Copyright (c) Microsoft Corporation 1991 - 1992
//
// File:        SPMGR.H
//
// Contents:    Common structures and functions for the SPMgr
//
//
// History:     20 May 92   RichardW    Documented existing stuff
//              22 Jul 93   RichardW    Revised to be the one include file
//                                      for the spm directory
//
//------------------------------------------------------------------------

#ifndef __SPMGR_H__
#define __SPMGR_H__
#define SECURITY_WIN32
#define SECURITY_PACKAGE
#include <security.h>
#include <secint.h>
#include <spmlpc.h>
#include <lsapmsgs.h>   // event log events

// SPM-wide structure definitions:

// This is the function table for a security package.  All functions are
// dispatched through this table.


struct _DLL_BINDING;


// This is the Security Package Control structure.  All control information
// relating to packages is stored here.


typedef struct _LSAP_SECURITY_PACKAGE {
    ULONG_PTR       dwPackageID;        // Assigned package ID
    DWORD           PackageIndex;       // Package Index in DLL
    DWORD           fPackage;           // Flags about the package
    DWORD           fCapabilities;      // Capabilities that the package reported
    DWORD           dwRPCID;            // RPC ID
    DWORD           Version;
    DWORD           TokenSize;
    DWORD           ContextHandles ;    // Number of outstanding contexts
    DWORD           CredentialHandles ; //  ditto for credentials
    LONG            CallsInProgress ;   // Number of calls to this package
    SECURITY_STRING Name;               // Name of the package
    SECURITY_STRING Comment;
    struct _DLL_BINDING *   pBinding;   // Binding of DLL
    PSECPKG_EXTENDED_INFORMATION Thunks ;   // Thunked Context levels
    LIST_ENTRY      ScavengerList ;
    SECURITY_STRING WowClientDll ;
    SECPKG_FUNCTION_TABLE FunctionTable;    // Dispatch table
} LSAP_SECURITY_PACKAGE, * PLSAP_SECURITY_PACKAGE;

#define SP_INVALID          0x00000001  // Package is now invalid for use
#define SP_PREFERRED        0x00000002  // The preferred package
#define SP_INFO             0x00000004  // Supports Extended Info
#define SP_SHUTDOWN         0x00000008  // Shutdown has completed
#define SP_WOW_SUPPORT      0x00000010  // Package can support WOW6432 clients

#define StartCallToPackage( p ) \
    InterlockedIncrement( &((PLSAP_SECURITY_PACKAGE)(p))->CallsInProgress )

#define EndCallToPackage( p ) \
    InterlockedDecrement( &((PLSAP_SECURITY_PACKAGE)(p))->CallsInProgress )

typedef struct _DLL_BINDING {
    DWORD           Flags;              // Flags about the DLL
    HANDLE          hInstance;          // Instance Handle
    SECURITY_STRING Filename;           // Full path name
    DWORD           RefCount;           // Reference Count
    DWORD           PackageCount;       // Number of Packages in DLL

    LSAP_SECURITY_PACKAGE      Packages[1];
} DLL_BINDING, * PDLL_BINDING;

#define DLL_BUILTIN     0x00000001      // DLL is really built-in code
#define DLL_SIGNED      0x00000002      // DLL is signed

//
// Ordinals to the function pointers, for validating calls
//

#define SP_ORDINAL_LSA_INIT                     0
#define SP_ORDINAL_LOGONUSER                    1
#define SP_ORDINAL_CALLPACKAGE                  2
#define SP_ORDINAL_LOGONTERMINATED              3
#define SP_ORDINAL_CALLPACKAGEUNTRUSTED         4
#define SP_ORDINAL_CALLPACKAGEPASSTHROUGH       5
#define SP_ORDINAL_LOGONUSEREX                  6
#define SP_ORDINAL_LOGONUSEREX2                 7
#define SP_ORDINAL_INITIALIZE                   8
#define SP_ORDINAL_SHUTDOWN                     9
#define SP_ORDINAL_GETINFO                      10
#define SP_ORDINAL_ACCEPTCREDS                  11
#define SP_ORDINAL_ACQUIRECREDHANDLE            12
#define SP_ORDINAL_QUERYCREDATTR                13
#define SP_ORDINAL_FREECREDHANDLE               14
#define SP_ORDINAL_SAVECRED                     15
#define SP_ORDINAL_GETCRED                      16
#define SP_ORDINAL_DELETECRED                   17
#define SP_ORDINAL_INITLSAMODECTXT              18
#define SP_ORDINAL_ACCEPTLSAMODECTXT            19
#define SP_ORDINAL_DELETECTXT                   20
#define SP_ORDINAL_APPLYCONTROLTOKEN            21
#define SP_ORDINAL_GETUSERINFO                  22
#define SP_ORDINAL_GETEXTENDEDINFORMATION       23
#define SP_ORDINAL_QUERYCONTEXTATTRIBUTES       24
#define SP_ORDINAL_ADDCREDENTIALS               25
#define SP_ORDINAL_SETEXTENDEDINFORMATION       26
#define SP_ORDINAL_SETCONTEXTATTRIBUTES         27

#define SP_MAX_TABLE_ORDINAL            (SP_ORDINAL_SETCONTEXTATTRIBUTES + 1)
#define SP_MAX_AUTHPKG_ORDINAL          (SP_ORDINAL_LOGONUSEREX)

#define SP_ORDINAL_MASK                 0x0000FFFF
#define SP_ITERATE_FILTER_WOW           0x00010000

typedef struct _LsaState {
    DWORD   cPackages ;
    DWORD   cNewPackages ;
} LsaState ;

typedef enum _SECHANDLE_OPS {
    HandleSet,                          // Just set the new handle
    HandleReplace,                      // Replace the existing one
    HandleRemoveReplace                 // Remove provided, replace with provided
} SECHANDLE_OPS ;

typedef struct _LSA_TUNING_PARAMETERS {
    ULONG   ThreadLifespan ;                // lifespan for threads in gen. pool
    ULONG   SubQueueLifespan ;              // lifespan for dedicated threads
    ULONG   Options ;                       // Option flags
    ULONG   CritSecSpinCount ;              // spin count of critical sections
} LSA_TUNING_PARAMETERS, * PLSA_TUNING_PARAMETERS ;

#define TUNE_SRV_HIGH_PRIORITY  0x00000001
#define TUNE_TRIM_WORKING_SET   0x00000002
#define TUNE_PRIVATE_HEAP       0x00000010

//
// Redefine IsOkayToExec
//

#define IsOkayToExec(x)

// For some tracking purposes, the package ID for the SPMgr is a well known
// constant:

#define SPMGR_ID        ((LSA_SEC_HANDLE) INVALID_HANDLE_VALUE)
#define SPMGR_PKG_ID    ((LSA_SEC_HANDLE) INVALID_HANDLE_VALUE)

//
// Value to pass to shutdown handler
//

#define SPM_SHUTDOWN_VALUE  0xD0

//
// Creating process name for LSA sessions
//

#define LSA_PROCESS_NAME L"LSA Server"
//
// ID of the primary package
//

#define PRIMARY_ID      0

typedef struct _SpmExceptDbg {
    DWORD       ThreadId;
    PVOID       pInstruction;
    PVOID       pMemory;
    ULONG_PTR   Access;
} SpmExceptDbg, * PSpmExceptDbg;

//
// Internal Exception Handling:
//
// If we hit an exception in a debug build, we store away some useful stuff
// otherwise, we go to the default case:
//

LONG    SpExceptionFilter(PVOID, EXCEPTION_POINTERS *);

#define SP_EXCEPTION    SpExceptionFilter(GetCurrentSession(), GetExceptionInformation())

//
// Include other component header files
//

#ifdef __cplusplus
extern "C" {
#endif

#include "sesmgr.h"     // Session manager support
#include "sphelp.h"     // Internal helper functions
#include "protos.h"     // Internal Prototypes
#include "debug.h"      // Debugging Support:

#ifdef __cplusplus
}
#endif

typedef struct _LSAP_DBG_LOG_CONTEXT {
    PSession    Session ;               // Session used
    SecHandle   Handle ;                // Handle used
} LSAP_DBG_LOG_CONTEXT, *PLSAP_DBG_LOG_CONTEXT ;

typedef struct _LSAP_API_LOG_ENTRY {
    ULONG           MessageId ;         // LPC Message ID
    ULONG           ThreadId ;          // Thread ID handling call
    PVOID           pvMessage ;         // LPC Message
    PVOID           WorkItem ;          // Work item for API
    LARGE_INTEGER   QueueTime ;         // Time Queued
    LARGE_INTEGER   WorkTime ;          // Work Time
    PVOID           Reserved ;          // Alignment
    LSAP_DBG_LOG_CONTEXT Context ;      // Context
} LSAP_API_LOG_ENTRY, * PLSAP_API_LOG_ENTRY ;

typedef struct _LSAP_API_LOG {
    ULONG               TotalSize ;
    ULONG               Current ;
    ULONG               ModSize ;
    ULONG               Align ;
    LSAP_API_LOG_ENTRY  Entries[ 1 ];
} LSAP_API_LOG, * PLSAP_API_LOG ;

PLSAP_API_LOG
ApiLogCreate(
    ULONG Entries
    );

PLSAP_API_LOG_ENTRY
ApiLogAlloc(
    PLSAP_API_LOG Log
    );

PLSAP_API_LOG_ENTRY
ApiLogLocate(
    PLSAP_API_LOG Log,
    ULONG MessageId
    );

#define DEFAULT_LOG_SIZE    32

//#if DBG
#define DBG_TRACK_API 1
//#endif

#if DBG_TRACK_API

#define DBG_DISPATCH_PROLOGUE_EX( Entry, pMessage, CallInfo ) \
    if ( Entry )                                                                \
    {                                                                           \
        Entry->ThreadId = GetCurrentThreadId() ;                                \
        CallInfo.LogContext = & Entry->Context ;                                \
        GetSystemTimeAsFileTime( (LPFILETIME) &Entry->WorkTime ) ;              \
    }                                                                           \
    else                                                                        \
    {                                                                           \
        CallInfo.LogContext = NULL ;                                            \
    }

#define DBG_DISPATCH_PROLOGUE( Table, pMessage, CallInfo ) \
    PLSAP_API_LOG_ENTRY Entry ;                                                 \
                                                                                \
    Entry = ApiLogLocate( Table, ((PPORT_MESSAGE) pMessage)->MessageId );       \
    DBG_DISPATCH_PROLOGUE_EX( Entry, pMessage, CallInfo )                                                                            \

#define DBG_DISPATCH_POSTLOGUE( Status, ApiCode ) \
    if ( Entry )                                                                \
    {                                                                           \
        LARGE_INTEGER EndTime ;                                                 \
        GetSystemTimeAsFileTime( (LPFILETIME) & EndTime );                      \
        Entry->Reserved = ULongToPtr(Entry->ThreadId);                          \
        Entry->ThreadId = (DWORD) 0xFFFFFFFF ;                                  \
        Entry->WorkItem = (PVOID) Status ;                                      \
        Entry->pvMessage = (PVOID) ApiCode ;                                    \
        Entry->QueueTime.QuadPart = EndTime.QuadPart ;                          \
        Entry->WorkTime.QuadPart = EndTime.QuadPart - Entry->WorkTime.QuadPart ; \
    }

#else
#define DBG_DISPATCH_PROLOGUE_EX( Entry, pMessage, CallInfo ) CallInfo.LogContext = NULL
#define DBG_DISPATCH_PROLOGUE( Table, pApi, CallInfo ) CallInfo.LogContext = NULL
#define DBG_DISPATCH_POSTLOGUE( Status, ApiCode )
#endif

typedef struct _LSA_CALL_INFO {
    PSPM_LPC_MESSAGE        Message ;
    struct _LSA_CALL_INFO * PreviousCall ;
    PSession Session ;
    PLSAP_DBG_LOG_CONTEXT LogContext ;
    SECPKG_CALL_INFO    CallInfo ;

    //
    // LogonId, ImpersonationLevel, Impersonating, Restricted
    // are considered valid CachedTokenInfo is TRUE
    //

    LUID                            LogonId ;
    SECURITY_IMPERSONATION_LEVEL    ImpersonationLevel;
    BOOLEAN                         Impersonating;
    BOOLEAN                         Restricted;
    BOOLEAN                         CachedTokenInfo;

    HANDLE InProcToken ;
    BOOL InProcCall ;
    ULONG Flags ;
    ULONG Allocs ;
    PKSEC_LSA_MEMORY_HEADER KMap ;
    PVOID Buffers[ MAX_BUFFERS_IN_CALL ];
    BYTE IpAddress[ LSAP_ADDRESS_LENGTH ];
} LSA_CALL_INFO, * PLSA_CALL_INFO ;

#define LsapGetCurrentCall()    ((PLSA_CALL_INFO) TlsGetValue( dwCallInfo ))
#define LsapSetCurrentCall(x)   TlsSetValue( dwCallInfo, x )

#define CALL_FLAG_IMPERSONATING 0x00000001
#define CALL_FLAG_IN_PROC_CALL  0x00000002
#define CALL_FLAG_SUPRESS_AUDIT 0x00000004
#define CALL_FLAG_NO_HANDLE_CHK 0x00000008
#define CALL_FLAG_KERNEL_POOL   0x00000010  // Kernel mode call, using pool
#define CALL_FLAG_KMAP_USED     0x00000020  // KMap is valid

//
//BOOL
//LsapIsBlockInKMap( KMap, Block )
//

#define LsapIsBlockInKMap( KMap, Block ) \
    ( KMap ? (((ULONG_PTR) KMap ^ (ULONG_PTR) Block ) < (ULONG_PTR) KMap->Commit) : FALSE )

NTSTATUS
InitializeDirectDispatcher(
    VOID
    );

VOID
LsapInitializeCallInfo(
    PLSA_CALL_INFO CallInfo,
    BOOL InProcess
    );

NTSTATUS
LsapBuildCallInfo(
    PSPM_LPC_MESSAGE    pApiMessage,
    PLSA_CALL_INFO CallInfo,
    PHANDLE Impersonated,
    PSession * NewSession,
    PSession * OldSession
    );

VOID
LsapInternalBreak(
    VOID
    );

#define LsapLogCallInfo( CallInfo, pSession, cHandle ) \
    if ( CallInfo &&  ( CallInfo->LogContext ) )                 \
    {                                                            \
        CallInfo->LogContext->Session = pSession ;                \
        CallInfo->LogContext->Handle = cHandle;                   \
    }                                                            \

//
// Global variables
//

extern  LSA_SECPKG_FUNCTION_TABLE  LsapSecpkgFunctionTable;
                                            // Dispatch table of helper functions
extern  LUID            SystemLogonId;      // System LogonID for packages.
extern  SECURITY_STRING MachineName;        // Computer name
extern  HANDLE          hStateChangeEvent;  // Event set when the system state is changed
extern  HANDLE          hShutdownEvent;
extern LSA_CALL_INFO    LsapDefaultCallInfo ;

extern  ULONG           LsapPageSize ;      // Set to the page size during init
extern  ULONG_PTR       LsapUserModeLimit ; // Set the to max user mode address

//
// Thread Local Storage variables
//
// These are actually all indices into the tls area, accessed through the
// TlsXxx functions.  These are all initialized by the InitThreadData()
// function
//

extern  DWORD           dwSession;          // Session pointer
extern  DWORD           dwExceptionInfo;    // Gets a pointer to exception info
extern  DWORD           dwThreadPackage;    // Package ID for thread
extern  DWORD           dwCallInfo ;        // CallInfo pointer
extern  DWORD           dwThreadHeap;       // Heap assigned to current thread.

// Last known workstation status:

extern  BOOLEAN         SetupPhase;         // If true, setup is running
extern  BOOL            ShutdownBegun ;     // when true, shutdown is running

extern  LSA_TUNING_PARAMETERS   LsaTuningParameters ;
extern  LsaState    lsState ;

extern PWSTR * ppszPackages;       // Contains a null terminated array of dll names
extern PWSTR * ppszOldPkgs;        // Contains a null terminated array of old pkgs

//
// Maximum size of a buffer that can be passed across an LPC call
//

#define LSAP_MAX_LPC_BUFFER_LENGTH (1024 * 1024)

#endif // __SPMGR_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\base\lsa\server\spmgr.cxx ===
//+-----------------------------------------------------------------------
//
// Microsoft Windows
//
// Copyright (c) Microsoft Corporation 1991 - 1992
//
// File:        spmgr.c
//
// Contents:    Main file of the SPMgr component
//
// History:     27 May 92,  RichardW    Commented
//
//------------------------------------------------------------------------

#include <lsapch.hxx>
extern "C"
{
#include "spinit.h"
}


///////////////////////////////////////////////////////////////////////////
//
//
//    Global "Variables"
//
//
//    Most of these variables are set during initialization, and are used
//    in a read-only fashion afterwards.
//
//
///////////////////////////////////////////////////////////////////////////

LUID    SystemLogonId = SYSTEM_LUID;    // Logon Session for the system (should be 999:0)

DWORD   dwSession;          // TLS: Thread Session ptr
DWORD   dwExceptionInfo;    // TLS: Thread exception info
DWORD   dwCallInfo;         // TLS: Thread LPC message ptr
DWORD   dwThreadPackage;    // TLS: Thread Package ID
DWORD   dwThreadHeap;       // TLS: Thread Heap

BOOLEAN SetupPhase;

HANDLE  hShutdownEvent;     // Shutdown synch event
HANDLE  hStateChangeEvent;  // State change event

SECURITY_STRING MachineName;

PWSTR * ppszPackages;       // Contains a null terminated array of dll names
PWSTR * ppszOldPkgs;        // Contains a null terminated array of old pkgs

LsaState    lsState;        // State of the process, for relay to the dll

LSA_TUNING_PARAMETERS   LsaTuningParameters ;
BOOL ShutdownBegun ;

//
// Name of event which says that the LSA RPC server is ready
//

#define LSA_RPC_SERVER_ACTIVE           L"\\BaseNamedObjects\\LSA_RPC_SERVER_ACTIVE"

DWORD
ShutdownWorker(
    PVOID Ignored
    )
{
    NTSTATUS Status ;
    PLSAP_SECURITY_PACKAGE     pAuxPackage;
    ULONG_PTR iPackage ;
    DWORD Tick ;
    DWORD TickMax ;

    //
    // Stop any new calls from getting through
    //

    ShutdownBegun = TRUE ;

    LsapShutdownInprocDll();

    if ( LsaTuningParameters.Options & TUNE_SRV_HIGH_PRIORITY )
    {
        TickMax = 100 ;
    }
    else 
    {
        TickMax = 10 ;
    }

    pAuxPackage = SpmpIteratePackagesByRequest( NULL, SP_ORDINAL_SHUTDOWN );

    while (pAuxPackage)
    {
        iPackage = pAuxPackage->dwPackageID;
        pAuxPackage->fPackage |= SP_SHUTDOWN ;

        DebugLog((DEB_TRACE, "Shutting down package %ws\n",
            pAuxPackage->Name.Buffer ));

        //
        // Spin wait for the calls in progress to complete
        //

        Tick = 0 ;

        while ( (pAuxPackage->CallsInProgress > 0) &&
                ( Tick < TickMax ) )
        {
            Sleep( 100 );

            Tick++ ;
        }

        if ( Tick == TickMax )
        {
            DebugLog(( DEB_ERROR, "Package %ws did not respond in %d seconds for shutdown\n",
                       pAuxPackage->Name.Buffer,
                       Tick / 10 ));

            pAuxPackage = SpmpIteratePackagesByRequest( pAuxPackage,
                                                        SP_ORDINAL_SHUTDOWN );

            continue;
        }

        SetCurrentPackageId( iPackage );

        __try
        {
            Status = pAuxPackage->FunctionTable.Shutdown();
        }
        __except (EXCEPTION_EXECUTE_HANDLER)
        {
            Status = (NTSTATUS) GetExceptionCode();
        }

        pAuxPackage = SpmpIteratePackagesByRequest( pAuxPackage,
                                                    SP_ORDINAL_SHUTDOWN );

    }

    SetCurrentPackageId( SPMGR_ID );

    SetEvent( hShutdownEvent );

    return 0;
}


//+-------------------------------------------------------------------------
//
//  Function:   ServerStop
//
//  Synopsis:   Stop the SPM.  Clean shutdown
//
//--------------------------------------------------------------------------

HRESULT
ServerStop(void)
{
    // First, see if we are already in the middle of a shutdown.  The
    // hShutdownEvent handle will be non-null.

    if (hShutdownEvent)
    {
        return(0);
    }

    DebugLog((DEB_TRACE, "LSA shutdown:\n"));

    hShutdownEvent = SpmCreateEvent(NULL, TRUE, FALSE, NULL);

    QueueUserWorkItem( ShutdownWorker, NULL, FALSE );

    return(S_OK);
}

#if DBG
void
SpmpThreadStartupEx(void)
{
    PSpmExceptDbg pExcept;

    pExcept = (PSpmExceptDbg) LsapAllocateLsaHeap(sizeof(SpmExceptDbg));
    TlsSetValue(dwExceptionInfo, pExcept);
}

void
SpmpThreadExitEx(void)
{
    PSpmExceptDbg   pExcept;

    pExcept = (PSpmExceptDbg) TlsGetValue(dwExceptionInfo);
    if (pExcept)
    {
        LsapFreeLsaHeap(pExcept);
    }
}
#endif // DBG


//+-------------------------------------------------------------------------
//
//  Function:   SpControlHandler
//
//  Synopsis:   Console Control Function handler
//
//  Effects:    Handles system shutdown
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//--------------------------------------------------------------------------
BOOL
SpConsoleHandler(DWORD  dwCtrlType)
{
    SpmpThreadStartup();

    DebugLog((DEB_TRACE, "Entered SpConsoleHandler(%d)\n", dwCtrlType));
    switch (dwCtrlType)
    {
        case CTRL_C_EVENT:
        case CTRL_BREAK_EVENT:
            SpmpThreadExit();
            return(FALSE);
            break;

        case CTRL_CLOSE_EVENT:
        case CTRL_SHUTDOWN_EVENT:
            DebugLog((DEB_TRACE, "Shutdown event received\n"));

            LsapState.SystemShutdownPending = TRUE;
            (void) ServerStop();
            (void) WaitForSingleObject(hShutdownEvent, 10000L);

            DebugLog((DEB_TRACE, "Shutdown complete\n"));

            // Fall through to:

        default:
            SpmpThreadExit();
            return(FALSE);

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\base\lsa\server\spnego.c ===
#include <windows.h>
#include "spnego.h"

ASN1module_t SPNEGO_Module = NULL;

static int ASN1CALL ASN1Enc_SavedMechTypeList(ASN1encoding_t enc, ASN1uint32_t tag, SavedMechTypeList *val);
static int ASN1CALL ASN1Enc_MechTypeList(ASN1encoding_t enc, ASN1uint32_t tag, PMechTypeList *val);
static int ASN1CALL ASN1Enc_NegHints(ASN1encoding_t enc, ASN1uint32_t tag, NegHints *val);
static int ASN1CALL ASN1Enc_NegTokenInit(ASN1encoding_t enc, ASN1uint32_t tag, NegTokenInit *val);
static int ASN1CALL ASN1Enc_NegTokenInit2(ASN1encoding_t enc, ASN1uint32_t tag, NegTokenInit2 *val);
static int ASN1CALL ASN1Enc_NegTokenTarg(ASN1encoding_t enc, ASN1uint32_t tag, NegTokenTarg *val);
static int ASN1CALL ASN1Enc_NegotiationToken(ASN1encoding_t enc, ASN1uint32_t tag, NegotiationToken *val);
static int ASN1CALL ASN1Enc_InitialNegToken(ASN1encoding_t enc, ASN1uint32_t tag, InitialNegToken *val);
static int ASN1CALL ASN1Dec_SavedMechTypeList(ASN1decoding_t dec, ASN1uint32_t tag, SavedMechTypeList *val);
static int ASN1CALL ASN1Dec_MechTypeList(ASN1decoding_t dec, ASN1uint32_t tag, PMechTypeList *val);
static int ASN1CALL ASN1Dec_NegHints(ASN1decoding_t dec, ASN1uint32_t tag, NegHints *val);
static int ASN1CALL ASN1Dec_NegTokenInit(ASN1decoding_t dec, ASN1uint32_t tag, NegTokenInit *val);
static int ASN1CALL ASN1Dec_NegTokenInit2(ASN1decoding_t dec, ASN1uint32_t tag, NegTokenInit2 *val);
static int ASN1CALL ASN1Dec_NegTokenTarg(ASN1decoding_t dec, ASN1uint32_t tag, NegTokenTarg *val);
static int ASN1CALL ASN1Dec_NegotiationToken(ASN1decoding_t dec, ASN1uint32_t tag, NegotiationToken *val);
static int ASN1CALL ASN1Dec_InitialNegToken(ASN1decoding_t dec, ASN1uint32_t tag, InitialNegToken *val);
static void ASN1CALL ASN1Free_SavedMechTypeList(SavedMechTypeList *val);
static void ASN1CALL ASN1Free_MechTypeList(PMechTypeList *val);
static void ASN1CALL ASN1Free_NegHints(NegHints *val);
static void ASN1CALL ASN1Free_NegTokenInit(NegTokenInit *val);
static void ASN1CALL ASN1Free_NegTokenInit2(NegTokenInit2 *val);
static void ASN1CALL ASN1Free_NegTokenTarg(NegTokenTarg *val);
static void ASN1CALL ASN1Free_NegotiationToken(NegotiationToken *val);
static void ASN1CALL ASN1Free_InitialNegToken(InitialNegToken *val);

typedef ASN1BerEncFun_t ASN1EncFun_t;
static const ASN1EncFun_t encfntab[3] = {
    (ASN1EncFun_t) ASN1Enc_SavedMechTypeList,
    (ASN1EncFun_t) ASN1Enc_NegotiationToken,
    (ASN1EncFun_t) ASN1Enc_InitialNegToken,
};
typedef ASN1BerDecFun_t ASN1DecFun_t;
static const ASN1DecFun_t decfntab[3] = {
    (ASN1DecFun_t) ASN1Dec_SavedMechTypeList,
    (ASN1DecFun_t) ASN1Dec_NegotiationToken,
    (ASN1DecFun_t) ASN1Dec_InitialNegToken,
};
static const ASN1FreeFun_t freefntab[3] = {
    (ASN1FreeFun_t) ASN1Free_SavedMechTypeList,
    (ASN1FreeFun_t) ASN1Free_NegotiationToken,
    (ASN1FreeFun_t) ASN1Free_InitialNegToken,
};
static const ULONG sizetab[3] = {
    SIZE_SPNEGO_Module_PDU_0,
    SIZE_SPNEGO_Module_PDU_1,
    SIZE_SPNEGO_Module_PDU_2,
};

/* forward declarations of values: */
/* definitions of value components: */
/* definitions of values: */

void ASN1CALL SPNEGO_Module_Startup(void)
{
    SPNEGO_Module = ASN1_CreateModule(0x10000, ASN1_BER_RULE_DER, ASN1FLAGS_NONE, 3, (const ASN1GenericFun_t *) encfntab, (const ASN1GenericFun_t *) decfntab, freefntab, sizetab, 0x656e7073);
}

void ASN1CALL SPNEGO_Module_Cleanup(void)
{
    ASN1_CloseModule(SPNEGO_Module);
    SPNEGO_Module = NULL;
}

static int ASN1CALL ASN1Enc_SavedMechTypeList(ASN1encoding_t enc, ASN1uint32_t tag, SavedMechTypeList *val)
{
    if (!ASN1Enc_MechTypeList(enc, tag, val))
    {
        return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_SavedMechTypeList(ASN1decoding_t dec, ASN1uint32_t tag, SavedMechTypeList *val)
{
    if (!ASN1Dec_MechTypeList(dec, tag, val))
    {
        return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_SavedMechTypeList(SavedMechTypeList *val)
{
    if (val) {
        ASN1Free_MechTypeList(val);
    }
}

static int ASN1CALL ASN1Enc_MechTypeList(ASN1encoding_t enc, ASN1uint32_t tag, PMechTypeList *val)
{
    PMechTypeList f;
    ASN1uint32_t nLenOff;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
    {
        return 0;
    }

    for (f = *val; f; f = f->next) {
        if (!ASN1BEREncObjectIdentifier(enc, 0x6, &f->value))
        {
            return 0;
        }
    }

    if (!ASN1BEREncEndOfContents(enc, nLenOff))
    {
        return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_MechTypeList(ASN1decoding_t dec, ASN1uint32_t tag, PMechTypeList *val)
{
    PMechTypeList *f;
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1uint32_t t;

    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
    {
        return 0;
    }

    f = val;

    while (ASN1BERDecNotEndOfContents(dd, di)) {
        if (!ASN1BERDecPeekTag(dd, &t))
        {
            return 0;
        }

        if (!(*f = (PMechTypeList)ASN1DecAlloc(dd, sizeof(**f))))
        {
            return 0;
        }
        if (!ASN1BERDecObjectIdentifier(dd, 0x6, &(*f)->value))
        {
            return 0;
        }
        f = &(*f)->next;
    }

    *f = NULL;

    if (!ASN1BERDecEndOfContents(dec, dd, di))
    {
        return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_MechTypeList(PMechTypeList *val)
{
    PMechTypeList f, ff;
    if (val) {
        for (f = *val; f; f = ff) {
            ASN1objectidentifier_free(&f->value);
            ff = f->next;
            ASN1Free(f);
        }
    }
}

static int ASN1CALL ASN1Enc_NegHints(ASN1encoding_t enc, ASN1uint32_t tag, NegHints *val)
{
    ASN1uint32_t nLenOff;
    ASN1uint32_t t;
    ASN1uint32_t nLenOff0;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    if ((val)->o[0] & 0x80) {
	t = lstrlenA((val)->hintName);
	if (!ASN1BEREncExplicitTag(enc, 0x80000000, &nLenOff0))
	    return 0;
	if (!ASN1DEREncCharString(enc, 0x1b, t, (val)->hintName))
	    return 0;
	if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	    return 0;
    }
    if ((val)->o[0] & 0x40) {
	if (!ASN1BEREncExplicitTag(enc, 0x80000001, &nLenOff0))
	    return 0;
	if (!ASN1DEREncOctetString(enc, 0x4, ((val)->hintAddress).length, ((val)->hintAddress).value))
	    return 0;
	if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	    return 0;
    }
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_NegHints(ASN1decoding_t dec, ASN1uint32_t tag, NegHints *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1uint32_t t;
    ASN1decoding_t dd0;
    ASN1octet_t *di0;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    ZeroMemory((val)->o, 1);
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000000) {
	(val)->o[0] |= 0x80;
	if (!ASN1BERDecExplicitTag(dd, 0x80000000, &dd0, &di0))
	    return 0;
	if (!ASN1BERDecZeroCharString(dd0, 0x1b, &(val)->hintName))
	    return 0;
	if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	    return 0;
    }
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000001) {
	(val)->o[0] |= 0x40;
	if (!ASN1BERDecExplicitTag(dd, 0x80000001, &dd0, &di0))
	    return 0;
	if (!ASN1BERDecOctetString(dd0, 0x4, &(val)->hintAddress))
	    return 0;
	if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	    return 0;
    }
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_NegHints(NegHints *val)
{
    if (val) {
	if ((val)->o[0] & 0x80) {
	    ASN1ztcharstring_free((val)->hintName);
	}
	if ((val)->o[0] & 0x40) {
	    ASN1octetstring_free(&(val)->hintAddress);
	}
    }
}

static int ASN1CALL ASN1Enc_NegTokenInit(ASN1encoding_t enc, ASN1uint32_t tag, NegTokenInit *val)
{
    ASN1uint32_t nLenOff;
    ASN1uint32_t nLenOff0;
    ASN1uint32_t r;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1BEREncExplicitTag(enc, 0x80000000, &nLenOff0))
	    return 0;
	if (!ASN1Enc_MechTypeList(enc, 0, &(val)->mechTypes))
	    return 0;
	if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	    return 0;
    }
    if ((val)->o[0] & 0x40) {
	r = ((val)->reqFlags).length;
	ASN1BEREncRemoveZeroBits(&r, ((val)->reqFlags).value);
	if (!ASN1BEREncExplicitTag(enc, 0x80000001, &nLenOff0))
	    return 0;
	if (!ASN1DEREncBitString(enc, 0x3, r, ((val)->reqFlags).value))
	    return 0;
	if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	    return 0;
    }
    if ((val)->o[0] & 0x20) {
	if (!ASN1BEREncExplicitTag(enc, 0x80000002, &nLenOff0))
	    return 0;
	if (!ASN1DEREncOctetString(enc, 0x4, ((val)->mechToken).length, ((val)->mechToken).value))
	    return 0;
	if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	    return 0;
    }
    if ((val)->o[0] & 0x10) {
	if (!ASN1BEREncExplicitTag(enc, 0x80000003, &nLenOff0))
	    return 0;
	if (!ASN1Enc_NegHints(enc, 0, &(val)->negHints))
	    return 0;
	if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	    return 0;
    }
    if ((val)->o[0] & 0x8) {
	if (!ASN1BEREncExplicitTag(enc, 0x80000004, &nLenOff0))
	    return 0;
	if (!ASN1DEREncOctetString(enc, 0x4, ((val)->mechListMIC).length, ((val)->mechListMIC).value))
	    return 0;
	if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	    return 0;
    }
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_NegTokenInit(ASN1decoding_t dec, ASN1uint32_t tag, NegTokenInit *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1uint32_t t;
    ASN1decoding_t dd0;
    ASN1octet_t *di0;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    ZeroMemory((val)->o, 1);
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000000) {
	(val)->o[0] |= 0x80;
	if (!ASN1BERDecExplicitTag(dd, 0x80000000, &dd0, &di0))
	    return 0;
	if (!ASN1Dec_MechTypeList(dd0, 0, &(val)->mechTypes))
	    return 0;
	if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	    return 0;
    }
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000001) {
	(val)->o[0] |= 0x40;
	if (!ASN1BERDecExplicitTag(dd, 0x80000001, &dd0, &di0))
	    return 0;
	if (!ASN1BERDecBitString(dd0, 0x3, &(val)->reqFlags))
	    return 0;
	if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	    return 0;
    }
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000002) {
	(val)->o[0] |= 0x20;
	if (!ASN1BERDecExplicitTag(dd, 0x80000002, &dd0, &di0))
	    return 0;
	if (!ASN1BERDecOctetString(dd0, 0x4, &(val)->mechToken))
	    return 0;
	if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	    return 0;
    }
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000003) {
	(val)->o[0] |= 0x10;
	if (!ASN1BERDecExplicitTag(dd, 0x80000003, &dd0, &di0))
	    return 0;
	if (!ASN1Dec_NegHints(dd0, 0, &(val)->negHints))
	    return 0;
	if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	    return 0;
    }
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000004) {
	(val)->o[0] |= 0x8;
	if (!ASN1BERDecExplicitTag(dd, 0x80000004, &dd0, &di0))
	    return 0;
	if (!ASN1BERDecOctetString(dd0, 0x4, &(val)->mechListMIC))
	    return 0;
	if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	    return 0;
    }
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_NegTokenInit(NegTokenInit *val)
{
    if (val) {
	if ((val)->o[0] & 0x80) {
	    ASN1Free_MechTypeList(&(val)->mechTypes);
	}
	if ((val)->o[0] & 0x40) {
	    ASN1bitstring_free(&(val)->reqFlags);
	}
	if ((val)->o[0] & 0x20) {
	    ASN1octetstring_free(&(val)->mechToken);
	}
	if ((val)->o[0] & 0x10) {
	    ASN1Free_NegHints(&(val)->negHints);
	}
	if ((val)->o[0] & 0x8) {
	    ASN1octetstring_free(&(val)->mechListMIC);
	}
    }
}

static int ASN1CALL ASN1Enc_NegTokenInit2(ASN1encoding_t enc, ASN1uint32_t tag, NegTokenInit2 *val)
{
    ASN1uint32_t nLenOff;
    ASN1uint32_t nLenOff0;
    ASN1uint32_t r;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1BEREncExplicitTag(enc, 0x80000000, &nLenOff0))
	    return 0;
	if (!ASN1Enc_MechTypeList(enc, 0, &(val)->mechTypes))
	    return 0;
	if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	    return 0;
    }
    if ((val)->o[0] & 0x40) {
	r = ((val)->reqFlags).length;
	ASN1BEREncRemoveZeroBits(&r, ((val)->reqFlags).value);
	if (!ASN1BEREncExplicitTag(enc, 0x80000001, &nLenOff0))
	    return 0;
	if (!ASN1DEREncBitString(enc, 0x3, r, ((val)->reqFlags).value))
	    return 0;
	if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	    return 0;
    }
    if ((val)->o[0] & 0x20) {
	if (!ASN1BEREncExplicitTag(enc, 0x80000002, &nLenOff0))
	    return 0;
	if (!ASN1DEREncOctetString(enc, 0x4, ((val)->mechToken).length, ((val)->mechToken).value))
	    return 0;
	if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	    return 0;
    }
    if ((val)->o[0] & 0x10) {
	if (!ASN1BEREncExplicitTag(enc, 0x80000003, &nLenOff0))
	    return 0;
	if (!ASN1DEREncOctetString(enc, 0x4, ((val)->mechListMIC).length, ((val)->mechListMIC).value))
	    return 0;
	if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	    return 0;
    }
    if ((val)->o[0] & 0x8) {
	if (!ASN1BEREncExplicitTag(enc, 0x80000004, &nLenOff0))
	    return 0;
	if (!ASN1Enc_NegHints(enc, 0, &(val)->negHints))
	    return 0;
	if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	    return 0;
    }
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_NegTokenInit2(ASN1decoding_t dec, ASN1uint32_t tag, NegTokenInit2 *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1uint32_t t;
    ASN1decoding_t dd0;
    ASN1octet_t *di0;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    ZeroMemory((val)->o, 1);
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000000) {
	(val)->o[0] |= 0x80;
	if (!ASN1BERDecExplicitTag(dd, 0x80000000, &dd0, &di0))
	    return 0;
	if (!ASN1Dec_MechTypeList(dd0, 0, &(val)->mechTypes))
	    return 0;
	if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	    return 0;
    }
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000001) {
	(val)->o[0] |= 0x40;
	if (!ASN1BERDecExplicitTag(dd, 0x80000001, &dd0, &di0))
	    return 0;
	if (!ASN1BERDecBitString(dd0, 0x3, &(val)->reqFlags))
	    return 0;
	if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	    return 0;
    }
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000002) {
	(val)->o[0] |= 0x20;
	if (!ASN1BERDecExplicitTag(dd, 0x80000002, &dd0, &di0))
	    return 0;
	if (!ASN1BERDecOctetString(dd0, 0x4, &(val)->mechToken))
	    return 0;
	if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	    return 0;
    }
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000003) {
	(val)->o[0] |= 0x10;
	if (!ASN1BERDecExplicitTag(dd, 0x80000003, &dd0, &di0))
	    return 0;
	if (!ASN1BERDecOctetString(dd0, 0x4, &(val)->mechListMIC))
	    return 0;
	if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	    return 0;
    }
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000004) {
	(val)->o[0] |= 0x8;
	if (!ASN1BERDecExplicitTag(dd, 0x80000004, &dd0, &di0))
	    return 0;
	if (!ASN1Dec_NegHints(dd0, 0, &(val)->negHints))
	    return 0;
	if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	    return 0;
    }
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_NegTokenInit2(NegTokenInit2 *val)
{
    if (val) {
	if ((val)->o[0] & 0x80) {
	    ASN1Free_MechTypeList(&(val)->mechTypes);
	}
	if ((val)->o[0] & 0x40) {
	    ASN1bitstring_free(&(val)->reqFlags);
	}
	if ((val)->o[0] & 0x20) {
	    ASN1octetstring_free(&(val)->mechToken);
	}
	if ((val)->o[0] & 0x10) {
	    ASN1octetstring_free(&(val)->mechListMIC);
	}
	if ((val)->o[0] & 0x8) {
	    ASN1Free_NegHints(&(val)->negHints);
	}
    }
}

static int ASN1CALL ASN1Enc_NegTokenTarg(ASN1encoding_t enc, ASN1uint32_t tag, NegTokenTarg *val)
{
    ASN1uint32_t nLenOff;
    ASN1uint32_t nLenOff0;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1BEREncExplicitTag(enc, 0x80000000, &nLenOff0))
	    return 0;
	if (!ASN1BEREncU32(enc, 0xa, (val)->negResult))
	    return 0;
	if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	    return 0;
    }
    if ((val)->o[0] & 0x40) {
	if (!ASN1BEREncExplicitTag(enc, 0x80000001, &nLenOff0))
	    return 0;
	if (!ASN1BEREncObjectIdentifier(enc, 0x6, &(val)->supportedMech))
	    return 0;
	if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	    return 0;
    }
    if ((val)->o[0] & 0x20) {
	if (!ASN1BEREncExplicitTag(enc, 0x80000002, &nLenOff0))
	    return 0;
	if (!ASN1DEREncOctetString(enc, 0x4, ((val)->responseToken).length, ((val)->responseToken).value))
	    return 0;
	if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	    return 0;
    }
    if ((val)->o[0] & 0x10) {
	if (!ASN1BEREncExplicitTag(enc, 0x80000003, &nLenOff0))
	    return 0;
	if (!ASN1DEREncOctetString(enc, 0x4, ((val)->mechListMIC).length, ((val)->mechListMIC).value))
	    return 0;
	if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	    return 0;
    }
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_NegTokenTarg(ASN1decoding_t dec, ASN1uint32_t tag, NegTokenTarg *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1uint32_t t;
    ASN1decoding_t dd0;
    ASN1octet_t *di0;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    ZeroMemory((val)->o, 1);
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000000) {
	(val)->o[0] |= 0x80;
	if (!ASN1BERDecExplicitTag(dd, 0x80000000, &dd0, &di0))
	    return 0;
	if (!ASN1BERDecU32Val(dd0, 0xa, (ASN1uint32_t *) &(val)->negResult))
	    return 0;
	if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	    return 0;
    }
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000001) {
	(val)->o[0] |= 0x40;
	if (!ASN1BERDecExplicitTag(dd, 0x80000001, &dd0, &di0))
	    return 0;
	if (!ASN1BERDecObjectIdentifier(dd0, 0x6, &(val)->supportedMech))
	    return 0;
	if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	    return 0;
    }
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000002) {
	(val)->o[0] |= 0x20;
	if (!ASN1BERDecExplicitTag(dd, 0x80000002, &dd0, &di0))
	    return 0;
	if (!ASN1BERDecOctetString(dd0, 0x4, &(val)->responseToken))
	    return 0;
	if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	    return 0;
    }
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000003) {
	(val)->o[0] |= 0x10;
	if (!ASN1BERDecExplicitTag(dd, 0x80000003, &dd0, &di0))
	    return 0;
	if (!ASN1BERDecOctetString(dd0, 0x4, &(val)->mechListMIC))
	    return 0;
	if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	    return 0;
    }
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_NegTokenTarg(NegTokenTarg *val)
{
    if (val) {
	if ((val)->o[0] & 0x40) {
	    ASN1objectidentifier_free(&(val)->supportedMech);
	}
	if ((val)->o[0] & 0x20) {
	    ASN1octetstring_free(&(val)->responseToken);
	}
	if ((val)->o[0] & 0x10) {
	    ASN1octetstring_free(&(val)->mechListMIC);
	}
    }
}

static int ASN1CALL ASN1Enc_NegotiationToken(ASN1encoding_t enc, ASN1uint32_t tag, NegotiationToken *val)
{
    ASN1uint32_t nLenOff0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1BEREncExplicitTag(enc, 0x80000000, &nLenOff0))
	    return 0;
	if (!ASN1Enc_NegTokenInit(enc, 0, &(val)->u.negTokenInit))
	    return 0;
	if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	    return 0;
	break;
    case 2:
	if (!ASN1BEREncExplicitTag(enc, 0x80000001, &nLenOff0))
	    return 0;
	if (!ASN1Enc_NegTokenTarg(enc, 0, &(val)->u.negTokenTarg))
	    return 0;
	if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	    return 0;
	break;
    case 3:
	if (!ASN1BEREncExplicitTag(enc, 0x80000002, &nLenOff0))
	    return 0;
	if (!ASN1Enc_NegTokenInit2(enc, 0, &(val)->u.negTokenInit2))
	    return 0;
	if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	    return 0;
	break;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_NegotiationToken(ASN1decoding_t dec, ASN1uint32_t tag, NegotiationToken *val)
{
    ASN1uint32_t t;
    ASN1decoding_t dd0;
    ASN1octet_t *di0;
    if (!ASN1BERDecPeekTag(dec, &t))
	return 0;
    switch (t) {
    case 0x80000000:
	(val)->choice = 1;
	if (!ASN1BERDecExplicitTag(dec, 0x80000000, &dd0, &di0))
	    return 0;
	if (!ASN1Dec_NegTokenInit(dd0, 0, &(val)->u.negTokenInit))
	    return 0;
	if (!ASN1BERDecEndOfContents(dec, dd0, di0))
	    return 0;
	break;
    case 0x80000001:
	(val)->choice = 2;
	if (!ASN1BERDecExplicitTag(dec, 0x80000001, &dd0, &di0))
	    return 0;
	if (!ASN1Dec_NegTokenTarg(dd0, 0, &(val)->u.negTokenTarg))
	    return 0;
	if (!ASN1BERDecEndOfContents(dec, dd0, di0))
	    return 0;
	break;
    case 0x80000002:
	(val)->choice = 3;
	if (!ASN1BERDecExplicitTag(dec, 0x80000002, &dd0, &di0))
	    return 0;
	if (!ASN1Dec_NegTokenInit2(dd0, 0, &(val)->u.negTokenInit2))
	    return 0;
	if (!ASN1BERDecEndOfContents(dec, dd0, di0))
	    return 0;
	break;
    default:
	ASN1DecSetError(dec, ASN1_ERR_CORRUPT);
	return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_NegotiationToken(NegotiationToken *val)
{
    if (val) {
        switch ((val)->choice) {
        case 1:
            ASN1Free_NegTokenInit(&(val)->u.negTokenInit);
            break;
        case 2:
            ASN1Free_NegTokenTarg(&(val)->u.negTokenTarg);
            break;
        case 3:
            ASN1Free_NegTokenInit2(&(val)->u.negTokenInit2);
            break;
        }
    }
}

static int ASN1CALL ASN1Enc_InitialNegToken(ASN1encoding_t enc, ASN1uint32_t tag, InitialNegToken *val)
{
    ASN1uint32_t nLenOff;

    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x40000000, &nLenOff))
    {
        return 0;
    }

    if (!ASN1BEREncObjectIdentifier(enc, 0x6, &(val)->spnegoMech))
    {
        return 0;
    }

    if (!ASN1Enc_NegotiationToken(enc, 0, &(val)->negToken))
    {
        return 0;
    }

    if (!ASN1BEREncEndOfContents(enc, nLenOff))
    {
        return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_InitialNegToken(ASN1decoding_t dec, ASN1uint32_t tag, InitialNegToken *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;

    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x40000000, &dd, &di))
    {
        return 0;
    }

    if (!ASN1BERDecObjectIdentifier(dd, 0x6, &(val)->spnegoMech))
    {
        return 0;
    }

    if (!ASN1Dec_NegotiationToken(dd, 0, &(val)->negToken))
    {
        return 0;
    }

    if (!ASN1BERDecEndOfContents(dec, dd, di))
    {
        return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_InitialNegToken(InitialNegToken *val)
{
    if (val) {
        ASN1objectidentifier_free(&(val)->spnegoMech);
        ASN1Free_NegotiationToken(&(val)->negToken);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\base\lsa\server\spinit.cxx ===
//+-----------------------------------------------------------------------
//
// Microsoft Windows
//
// Copyright (c) Microsoft Corporation 1991 - 1992
//
// File:        SPInit.cxx
//
// Contents:    Initialization code for SPMgr/LSA
//
// Functions:   LoadPackages                -- Loads all the packages
//              InitThreadData              -- Creates TLS values
//              InitSystemLogon             -- Initializes the System logon
//              LsapEnableCreateTokenPrivilege  -- Enables the privilege
//              InitLocatorAndOle           -- Initializes Locator cache, Ole
//              InitKDCData                 -- Initializes knowledge about KDC
//
//
// History:     08 Sep 92,  RichardW    Created from spmgr.c, etc.
//              26 Mar 93,  MikeSw      Converted from C->C++
//
//------------------------------------------------------------------------

//
// precompiled headers
//

#include <lsapch.hxx>
extern "C"
{
#include "spinit.h"
#include <lmcons.h>
#include <crypt.h>
#include <logonmsv.h>
#include <ssi.h>
#include <lsads.h>
}


//+-------------------------------------------------------------------------
//
//  Function:   LoadPackages
//
//  Synopsis:   Loads all the specified security packages
//
//  Effects:    Packages loaded, global structures updated
//
//  Arguments:  comma-separated list of package names (DLL names)
//
//  Requires:
//
//  Returns:    SUCCESS, or some failures
//
//  Notes:      This is run during SPM Init, while the process is still
//              single threaded, and not handling any calls.
//
//--------------------------------------------------------------------------

extern "C"
NTSTATUS
LoadPackages(   PWSTR * ppszPackages,
                PWSTR * ppszOldPkgs,
                PWSTR   pszPreferred)
{
    PWSTR           pszPackage;
    NTSTATUS scRet;
    SECURITY_STRING sStr;
    SECPKG_PARAMETERS Parameters;
    ULONG           iPackage = 0;
    ULONG           iOldPkg = 0;
    ULONG           LoadCount = 0;
    ULONG           NewCount = 0;
    ULONG           PreferredPackage = 0;
    PLSAPR_POLICY_DNS_DOMAIN_INFO DnsDomainInfo = NULL;
    PLSAP_SECURITY_PACKAGE Package;
    SECPKG_EVENT_PACKAGE_CHANGE Event;
    NT_PRODUCT_TYPE ProductType ;

    if (!SpmpInitializePackageControl())
    {
        return( STATUS_INSUFFICIENT_RESOURCES );
    }

    //
    // Build up the initialization message, to give the packages a better idea
    // of what is going on, and reduce their later calls for the same info.
    //

    Parameters.MachineState = SECPKG_STATE_ENCRYPTION_PERMITTED;
    Parameters.MachineState |= SECPKG_STATE_STRONG_ENCRYPTION_PERMITTED;

    Parameters.SetupMode = SetupPhase;

    scRet = LsaIQueryInformationPolicyTrusted(
                PolicyDnsDomainInformation,
                (PLSAPR_POLICY_INFORMATION *) &DnsDomainInfo
                );

    if (!NT_SUCCESS(scRet))
    {
        DebugLog((DEB_ERROR,"Failed to get primary domain info: 0x%x\n",scRet));
        return(scRet);
    }

    Parameters.DomainName = * (PUNICODE_STRING) &DnsDomainInfo->Name;
    Parameters.DnsDomainName = * (PUNICODE_STRING) &DnsDomainInfo->DnsDomainName;
    Parameters.DomainSid = (PSID) DnsDomainInfo->Sid;
    Parameters.DomainGuid = (GUID) DnsDomainInfo->DomainGuid;

    if ( RtlGetNtProductType( &ProductType ) )
    {
        if ( ProductType == NtProductLanManNt )
        {
            Parameters.MachineState |= SECPKG_STATE_DOMAIN_CONTROLLER ;
        }
        else
        {
            if (Parameters.DomainSid != NULL)
            {
                Parameters.MachineState |= SECPKG_STATE_WORKSTATION;
            }
            else
            {
                Parameters.MachineState |= SECPKG_STATE_STANDALONE;
            }
        }
    }
    else
    {
        Parameters.MachineState |= SECPKG_STATE_STANDALONE;
    }

    LoadCount = 0;
    NewCount = 0;

    DebugLog((DEB_TRACE_INIT, "Init Parameters = %d, %s\n",
                Parameters.MachineState,
                (Parameters.SetupMode ? "Setup" : "Normal") ));

    //
    // Add the built in Negotiate package first.  It will hook all subsequent
    // package loads and unloads, so that it can keep a table running of all
    // the packages and their negotiate options.
    //

    if ( SpmpLoadBuiltin( 0, &NegTable, &Parameters ) )
    {
        LoadCount ++ ;
    }

    //
    // Set the preferred package to be the first non-negotiate package
    //

    PreferredPackage = LoadCount;

    //
    // Now load the new DLLs:
    //

    while (pszPackage = ppszPackages[iPackage])
    {
        if (SpmpLoadDll( pszPackage, &Parameters ))
        {
            LoadCount++;
            NewCount++;
        }

        iPackage++;
    }

    //
    // Now, load old style packages, or just the MSV package for now.
    //

    while (pszPackage = ppszOldPkgs[iOldPkg])
    {
        if (SpmpLoadAuthPkgDll( pszPackage ))
        {
            LoadCount++;
        }

        iOldPkg++;
    }

    //
    // Select the preferred package.
    //

    if ( pszPreferred == NULL )
    {
        Package = SpmpLocatePackage( PreferredPackage );
    }
    else
    {
        RtlInitUnicodeString( &sStr, pszPreferred );

        Package = SpmpLookupPackage( &sStr );
    }

    //
    // If there are no new packages, do not enabled a preferred
    // package.  It will mess up the negotiate package
    //

    if ( NewCount == 0 )
    {
        Package = NULL ;
    }

    if ( Package )
    {
        Package->fPackage |= SP_PREFERRED ;

        Event.PackageId = Package->dwPackageID;
        Event.PackageName = Package->Name;
        Event.ChangeType = SECPKG_PACKAGE_CHANGE_SELECT ;

        LsapEventNotify(
                    NOTIFY_CLASS_PACKAGE_CHANGE,
                    0,
                    sizeof( Event ),
                    &Event );
    }

    //
    // All the strings are actually offsets from the zeroth string
    //

    if (ppszPackages[0] != NULL)
    {
        LsapFreeLsaHeap(ppszPackages[0]);
    }

    //
    // Finally, free the array:
    //

    LsapFreeLsaHeap(ppszPackages);

    //
    // Get rid of the old package array, as well:
    //

    if (ppszOldPkgs[0] != NULL)
    {
        LsapFreeLsaHeap(ppszOldPkgs[0]);
    }

    LsapFreeLsaHeap(ppszOldPkgs);

#if DBG
    SpmpLoadBuiltinAuthPkg( &DbgTable );
#endif 

    //
    // Free the primary domain info
    //

    LsaIFree_LSAPR_POLICY_INFORMATION(
        PolicyDnsDomainInformation,
        (PLSAPR_POLICY_INFORMATION) DnsDomainInfo
        );

    //
    // If at least the primary loaded, then return OK.  If not that,
    // then return an error:
    //

    if ( LoadCount )
    {
        return(S_OK);
    }
    else
    {
        return(SEC_E_CANNOT_INSTALL);
    }
}


//+-------------------------------------------------------------------------
//
//  Function:   InitThreadData
//
//  Synopsis:   Initializes Tls* data slots
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//--------------------------------------------------------------------------
extern "C"
void
InitThreadData(void)
{
    dwSession = TlsAlloc();
    dwExceptionInfo = TlsAlloc();
    dwCallInfo = TlsAlloc();
    dwThreadPackage = TlsAlloc();
    LsapDsThreadState = TlsAlloc();
    dwThreadHeap = TlsAlloc();

#ifdef DBG
    //
    // See dbp.h for the number of locks parameter
    //
    SafeLockInit( 12, TRUE );
#endif
}

#ifdef LSAP_VERIFY_PACKAGE_ID
BOOL RefSetCurrentPackageId(ULONG_PTR dwPackageId)
{
    ULONG_PTR dwCurId;
    char szTmp[32];
    WCHAR szw[64];
    
    dwCurId = (ULONG_PTR) TlsGetValue(dwThreadPackage);
    
    _snprintf(szTmp, sizeof( szTmp ), "%ld (%ld)", dwPackageId, dwCurId);

//     wsprintf(szw, L"*** %x ==> %d\n", GetCurrentThreadId(), dwPackageId);
//     OutputDebugString(szw);
    
    if (dwCurId == SPMGR_ID)
    {
        DsysAssertMsg(dwPackageId != SPMGR_ID, szTmp);
    }

    return TlsSetValue(dwThreadPackage, (PVOID)dwPackageId);
}
#endif // LSAP_VERIFY_PACKAGE_ID


//+-------------------------------------------------------------------------
//
//  Function:   InitSystemLogon
//
//  Synopsis:   Creates system logon credentials
//
//  Effects:    Creates credentials for NTLM and Kerberos for the Machine
//              in the system logon.
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//--------------------------------------------------------------------------

extern "C"
void
InitSystemLogon(void)
{
    UNICODE_STRING ComputerPrincipalName;
    PLSAP_SECURITY_PACKAGE     pAuxPackage;
    PSession        pSession = GetCurrentSession();
    UNICODE_STRING  SecretName;
    ULONG_PTR       iPackage;
    NTSTATUS        scRet;
    SECPKG_PRIMARY_CRED PrimaryCred;
    PLSAPR_POLICY_INFORMATION PolicyInfo = NULL;
    PLSAPR_POLICY_INFORMATION DnsPolicyInfo = NULL;
    PLSAPR_CR_CIPHER_VALUE CrWkstaPassword = NULL;
    PLSAPR_CR_CIPHER_VALUE CrWkstaOldPassword = NULL;
    SID             SystemSid = {SID_REVISION, 1,
                                 SECURITY_NT_AUTHORITY,
                                 SECURITY_LOCAL_SYSTEM_RID};
    LSAPR_HANDLE SecretHandle = NULL;
    UNICODE_STRING DomainCopy ;
    UNICODE_STRING MachineCopy ;
    PSID SidCopy ;

    RtlZeroMemory(
        &PrimaryCred,
        sizeof(PrimaryCred)
        );

    ComputerPrincipalName.Buffer = NULL;

    //
    // Build the computer principal name, which is the computer name followed
    // by a '$'
    //

    ComputerPrincipalName.Length = MachineName.Length + sizeof(WCHAR);
    ComputerPrincipalName.MaximumLength = MachineName.Length + 2 * sizeof(WCHAR);

    SafeAllocaAllocate(ComputerPrincipalName.Buffer, ComputerPrincipalName.MaximumLength);

    if (ComputerPrincipalName.Buffer == NULL)
    {
        goto Cleanup;
    }

    RtlCopyMemory(
        ComputerPrincipalName.Buffer,
        MachineName.Buffer,
        MachineName.Length
        );
    ComputerPrincipalName.Buffer[MachineName.Length/sizeof(WCHAR)] =
        SSI_ACCOUNT_NAME_POSTFIX_CHAR;
    ComputerPrincipalName.Buffer[1+MachineName.Length/sizeof(WCHAR)] =
        L'\0';

    PrimaryCred.LogonId = SystemLogonId;
    PrimaryCred.UserSid = &SystemSid;
    PrimaryCred.DownlevelName.Buffer = wcsrchr(ComputerPrincipalName.Buffer,L'\\');
    if (PrimaryCred.DownlevelName.Buffer == NULL)
    {
        PrimaryCred.DownlevelName = ComputerPrincipalName;
    }
    else
    {
        PrimaryCred.DownlevelName.Buffer++;
        RtlInitUnicodeString(
            &PrimaryCred.DownlevelName,
            PrimaryCred.DownlevelName.Buffer
            );
    }

    //
    // Get the machine account password, if there is one
    //

    RtlInitUnicodeString(
        &SecretName,
        SSI_SECRET_NAME
        );

    scRet = LsarOpenSecret(
                LsapPolicyHandle,
                (PLSAPR_UNICODE_STRING) &SecretName,
                SECRET_ALL_ACCESS,
                &SecretHandle
                );

    if (NT_SUCCESS(scRet))
    {
        scRet = LsarQuerySecret(
                    SecretHandle,
                    &CrWkstaPassword,
                    NULL,               // we don't want current val set time
                    &CrWkstaOldPassword,
                    NULL                // ditto for old val
                    );
    }

    //
    // We don't want to fail to boot if we don't have a password, so continue
    // after an error
    //

    if (NT_SUCCESS(scRet) && (CrWkstaPassword != NULL))
    {
        PrimaryCred.Password.Buffer = (LPWSTR) CrWkstaPassword->Buffer;
        PrimaryCred.Password.Length = (USHORT) CrWkstaPassword->Length;
        PrimaryCred.Password.MaximumLength = (USHORT) CrWkstaPassword->MaximumLength;
        PrimaryCred.Flags = PRIMARY_CRED_CLEAR_PASSWORD;

        if (CrWkstaOldPassword != NULL)
        {
            PrimaryCred.OldPassword.Buffer = (LPWSTR) CrWkstaOldPassword->Buffer;
            PrimaryCred.OldPassword.Length = (USHORT) CrWkstaOldPassword->Length;
            PrimaryCred.OldPassword.MaximumLength = (USHORT) CrWkstaOldPassword->MaximumLength;
        }
    }

    scRet = LsaIQueryInformationPolicyTrusted(
                PolicyDnsDomainInformation,
                &DnsPolicyInfo
                );

    if(!NT_SUCCESS(scRet))
    {
        scRet = LsaIQueryInformationPolicyTrusted(
                    PolicyPrimaryDomainInformation,
                    &PolicyInfo
                    );

        if (NT_SUCCESS(scRet))
        {
            PrimaryCred.DomainName = *(PUNICODE_STRING) &PolicyInfo->PolicyPrimaryDomainInfo.Name;
        }

    } else {

        PrimaryCred.DomainName = *(PUNICODE_STRING) &DnsPolicyInfo->PolicyDnsDomainInfo.Name;
        PrimaryCred.DnsDomainName = *(PUNICODE_STRING) &DnsPolicyInfo->PolicyDnsDomainInfo.DnsDomainName;
    }

    //
    // Update the logon session with the "real" name:
    //

    scRet = LsapDuplicateString(
                    &DomainCopy,
                    &PrimaryCred.DomainName );

    if ( NT_SUCCESS( scRet ) )
    {
        scRet = LsapDuplicateString(
                    &MachineCopy,
                    &PrimaryCred.DownlevelName );

        if ( NT_SUCCESS( scRet ) )
        {
            scRet = LsapDuplicateSid(
                        &SidCopy,
                        PrimaryCred.UserSid );

            if ( NT_SUCCESS( scRet ) )
            {
                LsapSetLogonSessionAccountInfo(
                        &SystemLogonId,
                        &MachineCopy,
                        &DomainCopy,
                        NULL,
                        &SidCopy,
                        (SECURITY_LOGON_TYPE) 0,
                        &PrimaryCred
                        );

                //
                // If successful, LsapSetLogonSessionAccountInfo will have taken
                // ownership of UserSid
                //

                if ( SidCopy != NULL ) {
                    LsapFreeLsaHeap( SidCopy );
                }
            }
        }
    }

    DebugLog((DEB_TRACE_INIT, "Establishing credentials for machine %ws\n", MachineName.Buffer));

    pAuxPackage = SpmpIteratePackagesByRequest( NULL, SP_ORDINAL_ACCEPTCREDS );

    while (pAuxPackage)
    {
        iPackage = pAuxPackage->dwPackageID;

        DebugLog((DEB_TRACE_INIT, "Whacking package %ws with %x:%x = %ws\n",
            pAuxPackage->Name.Buffer,
            SystemLogonId.HighPart, SystemLogonId.LowPart,
            MachineName.Buffer));

        SetCurrentPackageId(iPackage);

        __try
        {
            scRet = pAuxPackage->FunctionTable.AcceptCredentials(
                        Interactive,
                        &ComputerPrincipalName,
                        &PrimaryCred,
                        NULL            // no supplemental credentials
                        );
        }
        __except (EXCEPTION_EXECUTE_HANDLER)
        {
            scRet = (NTSTATUS) GetExceptionCode();
            scRet = SPException(scRet, iPackage);
        }

        // Note:  if an exception occurs, we don't fail the logon, we just
        // do the magic on the package that blew.  If the package blows,
        // the other packages may succeed, and so the user may not be able
        // to use that provider.

        pAuxPackage = SpmpIteratePackagesByRequest( pAuxPackage,
                                                    SP_ORDINAL_ACCEPTCREDS );
    }

Cleanup:

    //
    // Finally, set this thread back to being a SPM thread:
    //

    SetCurrentPackageId( SPMGR_ID );

    if (CrWkstaPassword != NULL)
    {
        LsaIFree_LSAPR_CR_CIPHER_VALUE(
            CrWkstaPassword
            );
    }
    if (CrWkstaOldPassword != NULL)
    {
        LsaIFree_LSAPR_CR_CIPHER_VALUE(
            CrWkstaOldPassword
            );
    }
    if (SecretHandle != NULL)
    {
        LsarClose(&SecretHandle);
    }
    if (PolicyInfo != NULL)
    {
        LsaIFree_LSAPR_POLICY_INFORMATION(
            PolicyPrimaryDomainInformation,
            PolicyInfo
            );
    }
    if (DnsPolicyInfo != NULL)
    {
        LsaIFree_LSAPR_POLICY_INFORMATION(
            PolicyDnsDomainInformation,
            DnsPolicyInfo
            );
    }

    SafeAllocaFree(ComputerPrincipalName.Buffer);
}


HANDLE
SpmpOpenEvent( IN PWSTR EventName )
{
    NTSTATUS NtStatus;
    HANDLE InstallationEvent;
    OBJECT_ATTRIBUTES EventAttributes;
    UNICODE_STRING UnicodeEventName;

    //
    // If the following event exists, it is an indication that
    // installation is in progress and that further security
    // initialization should be delayed until the event is
    // signalled.  This is expected to be a NOTIFICATION event.
    //

    RtlInitUnicodeString( &UnicodeEventName, EventName);
    InitializeObjectAttributes( &EventAttributes, &UnicodeEventName, 0, 0, NULL );

    NtStatus = NtOpenEvent(
                   &InstallationEvent,
                   SYNCHRONIZE,
                   &EventAttributes
                   );

    if (NT_SUCCESS(NtStatus))
    {
        return(InstallationEvent);
    }
    else
    {
        return(NULL);
    }
}


HANDLE
SpmpOpenSetupEvent( VOID )
{
    return( SpmpOpenEvent(L"\\INSTALLATION_SECURITY_HOLD"));
}


extern "C"
BOOLEAN
SpmpIsSetupPass( VOID )
{
    HANDLE  hEvent;

    if (hEvent = SpmpOpenSetupEvent())
    {
        NtClose(hEvent);
        return(TRUE);
    }

    return(FALSE);
}


extern "C"
BOOLEAN
SpmpIsMiniSetupPass( VOID )
{
    DWORD       rc;
    DWORD       d = 0;
    DWORD       Type;
    HKEY        hKey;

    //
    // See if this is a "mini" setup, in which case we
    // don't need to generate the domain SID.
    //
    rc = RegOpenKeyExW( HKEY_LOCAL_MACHINE,
                       L"System\\Setup",
                       0,
                       KEY_READ,
                       &hKey );
    if( rc == ERROR_SUCCESS ) {

        //
        // Just get the size (ALPHA workaround).  All
        // we care about is if the key exists...
        //
        rc = RegQueryValueExW( hKey,
                              L"MiniSetupInProgress",
                              NULL,
                              &Type,
                              (LPBYTE)NULL,
                              &d );

        RegCloseKey( hKey );

        if( rc == ERROR_SUCCESS ) {
            return( TRUE );
        }
    }
    return( FALSE );
}


NTSTATUS
LsapInstallationPause( VOID )

/*++

Routine Description:

    This function checks to see if the system is in an
    installation state.  If so, it suspends further initialization
    until the installation state is complete.

    Installation state is signified by the existance of a well known
    event.


Arguments:

    None.

Return Value:

        STATUS_SUCCESS - Proceed with initialization.

        Other status values are unexpected.

--*/

{
    HANDLE      InstallationEvent;
    NTSTATUS    NtStatus;
    NTSTATUS    TmpStatus;

    InstallationEvent = SpmpOpenSetupEvent();

    if ( InstallationEvent ) {

        //
        // The event exists - installation created it and will signal it
        // when it is ok to proceed with security initialization.
        // Installation code is responsible for deleting the event after
        // signalling it.
        //

        NtStatus = NtWaitForSingleObject( InstallationEvent, TRUE, 0 );
        TmpStatus = NtClose( InstallationEvent );
        ASSERT(NT_SUCCESS(TmpStatus));

        //
        // Now, strobe the state changed event, to indicate to the
        // rest of the threads that life has changed
        //

        SpmSetEvent(hStateChangeEvent);

    } else {
        NtStatus = STATUS_SUCCESS; // Indicate everything is as expected
    }

    return(NtStatus);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\base\lsa\server\spnego.h ===
#ifndef _SPNEGO_Module_H_
#define _SPNEGO_Module_H_

#include "msber.h"

#ifdef __cplusplus
extern "C" {
#endif

typedef struct MechTypeList * PMechTypeList;

typedef ASN1objectidentifier_t MechType;

typedef PMechTypeList SavedMechTypeList;
#define SavedMechTypeList_PDU 0
#define SIZE_SPNEGO_Module_PDU_0 sizeof(SavedMechTypeList)

typedef ASN1bitstring_t ContextFlags;
#define delegFlag 0x80
#define mutualFlag 0x40
#define replayFlag 0x20
#define sequenceFlag 0x10
#define anonFlag 0x8
#define confFlag 0x4
#define integFlag 0x2

typedef ASN1octetstring_t MechSpecInfo;

typedef enum NegResult {
    accept_completed = 0,
    accept_incomplete = 1,
    reject = 2,
} NegResult;

typedef struct MechTypeList {
    PMechTypeList next;
    MechType value;
} MechTypeList_Element;

typedef struct NegHints {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
#   define hintName_present 0x80
    ASN1ztcharstring_t hintName;
#   define hintAddress_present 0x40
    ASN1octetstring_t hintAddress;
} NegHints;

typedef struct NegTokenInit {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
#   define NegTokenInit_mechTypes_present 0x80
    PMechTypeList mechTypes;
#   define NegTokenInit_reqFlags_present 0x40
    ContextFlags reqFlags;
#   define NegTokenInit_mechToken_present 0x20
    ASN1octetstring_t mechToken;
#   define NegTokenInit_negHints_present 0x10
    NegHints negHints;
#   define NegTokenInit_mechListMIC_present 0x8
    ASN1octetstring_t mechListMIC;
} NegTokenInit;

typedef struct NegTokenInit2 {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
#   define NegTokenInit2_mechTypes_present 0x80
    PMechTypeList mechTypes;
#   define NegTokenInit2_reqFlags_present 0x40
    ContextFlags reqFlags;
#   define NegTokenInit2_mechToken_present 0x20
    ASN1octetstring_t mechToken;
#   define NegTokenInit2_mechListMIC_present 0x10
    ASN1octetstring_t mechListMIC;
#   define NegTokenInit2_negHints_present 0x8
    NegHints negHints;
} NegTokenInit2;

typedef struct NegTokenTarg {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
#   define negResult_present 0x80
    NegResult negResult;
#   define supportedMech_present 0x40
    MechType supportedMech;
#   define responseToken_present 0x20
    ASN1octetstring_t responseToken;
#   define NegTokenTarg_mechListMIC_present 0x10
    ASN1octetstring_t mechListMIC;
} NegTokenTarg;

typedef struct NegotiationToken {
    ASN1choice_t choice;
    union {
#	define negTokenInit_chosen 1
	NegTokenInit negTokenInit;
#	define negTokenTarg_chosen 2
	NegTokenTarg negTokenTarg;
#	define negTokenInit2_chosen 3
	NegTokenInit2 negTokenInit2;
    } u;
} NegotiationToken;
#define NegotiationToken_PDU 1
#define SIZE_SPNEGO_Module_PDU_1 sizeof(NegotiationToken)

typedef struct InitialNegToken {
    MechType spnegoMech;
    NegotiationToken negToken;
} InitialNegToken;
#define InitialNegToken_PDU 2
#define SIZE_SPNEGO_Module_PDU_2 sizeof(InitialNegToken)


extern ASN1module_t SPNEGO_Module;
extern void ASN1CALL SPNEGO_Module_Startup(void);
extern void ASN1CALL SPNEGO_Module_Cleanup(void);

/* Prototypes of element functions for SEQUENCE OF and SET OF constructs */

#ifdef __cplusplus
} /* extern "C" */
#endif

#endif /* _SPNEGO_Module_H_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\base\lsa\server\userkey.h ===
/*++

Copyright (c) 1997-1999  Microsoft Corporation

Module Name:

    efssrv.hxx

Abstract:

    EFS (Encrypting File System) function prototypes.

Author:

    Robert Reichel      (RobertRe)
    Robert Gu           (RobertG)

Environment:

Revision History:

--*/

#ifndef _USERKEY_
#define _USERKEY_

#ifdef __cplusplus
extern "C" {
#endif


//
// Exported functions
//


LONG
GetCurrentKey(
    IN  PEFS_USER_INFO pEfsUserInfo,
    OUT HCRYPTKEY  * hKey           OPTIONAL,
	OUT HCRYPTPROV * hProv          OPTIONAL,
    OUT LPWSTR     * ContainerName,
    OUT LPWSTR     * ProviderName,
    OUT PDWORD       ProviderType,
    OUT LPWSTR     * DisplayInfo,
    OUT PBYTE      * pbHash,
    OUT PDWORD       cbHash
    );

DWORD
GetKeyInfoFromCertHash(
    IN OUT PEFS_USER_INFO pEfsUserInfo,
    IN PBYTE         pbHash,
    IN DWORD         cbHash,
    OUT HCRYPTKEY  * hKey,
    OUT HCRYPTPROV * hProv,
    OUT LPWSTR     * ContainerName,
    OUT LPWSTR     * ProviderName,
    OUT LPWSTR     * DisplayInfo,
    OUT PBOOLEAN     pbIsValid OPTIONAL
    );

BOOLEAN
CurrentHashOK(
    IN PEFS_USER_INFO pEfsUserInfo, 
    IN PBYTE         pbHash, 
    IN DWORD         cbHash,
    OUT DWORD        *dFlag
    );

DWORD
GetCurrentHash(
     IN  PEFS_USER_INFO pEfsUserInfo, 
     OUT PBYTE          *pbHash, 
     OUT DWORD          *cbHash
     );

#ifdef __cplusplus
} // extern C
#endif

#endif // _USERKEY_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\base\lsa\server\userkey.cxx ===
/*++

Copyright (c) 1997 - 1999  Microsoft Corporation

Module Name:

    userkey.cxx

Abstract:

    EFS (Encrypting File System) Server

Author:

    Robert Reichel      (RobertRe)     July 4, 1997
    Robert Gu           (RobertG)      January 23, 1998

Environment:

Revision History:

--*/

#include <lsapch.hxx>

extern "C" {
#include <nt.h>
#include <ntdef.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <wincrypt.h>
#include <cryptui.h>
#include <stdio.h>
#include <malloc.h>
#include <certca.h>
#include "lsasrvp.h"
#include "efssrv.hxx"
#include "userkey.h"
#include "lsaitf.h"    // LOGONSES_FLAG_* flags
}

#define PROVIDER       TEXT("Provider")
#define CONTAINER      TEXT("Container")
#define PROVIDER_TYPE  TEXT("Type")
#define CERT_HASH      TEXT("CertificateHash")
#define CERT_FLAG      TEXT("Flag")

#define KEYPATH  TEXT("%ws\\Software\\Microsoft\\Windows NT\\CurrentVersion\\EFS\\CurrentKeys")
#define KEYPATHROOT HKEY_USERS

#define YEARCOUNT (LONGLONG) 10000000*3600*24*365 // One Year's tick count

#define AutoEnrollChainLevel    5 // This should be well enough for the EFS cert.


#ifndef wszCERTTYPE_EFS
#define wszCERTTYPE_EFS             L"EFS"
#endif

#ifndef wszCERTTYPE_EFS_RECOVERY
#define wszCERTTYPE_EFS_RECOVERY  L"EFSRecovery"
#endif

extern DWORD RsaKeyLength;
LONG UserCertIsValidating = 0;

//
// Forward references
//

BOOL
EfspCreateSelfSignedCert(
    OUT HCRYPTKEY  * hKey,
    OUT HCRYPTPROV * hProv,
    OUT LPWSTR     * lpContainerName,
    OUT LPWSTR     * lpProviderName,
    IN  PEFS_USER_INFO pEfsUserInfo,
    OUT PBYTE      * pbHash,
    OUT PDWORD       cbHash,
    OUT LPWSTR     * lpDisplayInfo,
    OUT PCCERT_CONTEXT *pCertContext
    );

DWORD
GenerateUserKey (
    IN  PEFS_USER_INFO pEfsUserInfo,
    OUT HCRYPTKEY  * hKey   OPTIONAL,
    OUT HCRYPTPROV * hProv  OPTIONAL,
    OUT LPWSTR     * ContainerName,
    OUT LPWSTR     * ProviderName,
    OUT PDWORD       ProviderType,
    OUT LPWSTR     * DisplayInfo,
    OUT PBYTE      * pbHash,
    OUT PDWORD       cbHash
    );

PWCHAR
ConstructKeyPath(
    PWCHAR      SidString
    )

/*++

Routine Description:

    This routine constructs the path to the current user key, in the form

    <user-sid>\Software\Microsoft\Windows NT\CurrentVersion\EFS\CurrentKeys

Arguments:

    None.

Return Value:

    Returns the path the the current user keyset

--*/

{
    PWCHAR      KeyPath = NULL;

    if (SidString) {

        DWORD KeyPathLength = wcslen( KEYPATH );

        //
        // Subtract 3 for %ws and add 1 for NULL
        //

        DWORD StringLength = ( KeyPathLength - 3 + wcslen( SidString ) + 1) * sizeof( WCHAR );

        KeyPath = (PWCHAR)LsapAllocateLsaHeap( StringLength );

        if (KeyPath) {

            swprintf( KeyPath, KEYPATH, SidString );
            KeyPath[StringLength/sizeof( WCHAR ) - 1] = UNICODE_NULL;
        }

    }

    return( KeyPath );
}


NTSTATUS
EfspGetTokenUser(
    IN  OUT PEFS_USER_INFO pEfsUserInfo
    )
/*++

Routine Description:

    This routine returns the TOKEN_USER structure for the
    current user, and optionally, the AuthenticationId from his
    token.

Arguments:

    pEfsUserInfo - User Info.

Return Value:

    NtStatus code
    
--*/

{
    NTSTATUS Status;
    HANDLE TokenHandle;
    ULONG ReturnLength;
    TOKEN_STATISTICS TokenStats;
    PTOKEN_USER pTokenUser = NULL;
    BOOLEAN b = FALSE;
    BYTE  PefBuffer[1024];

    Status = NtOpenThreadToken(
                 NtCurrentThread(),
                 TOKEN_QUERY,
                 TRUE,                    // OpenAsSelf
                 &TokenHandle
                 );

    if (NT_SUCCESS( Status )) {

        Status = NtQueryInformationToken (
                     TokenHandle,
                     TokenUser,
                     PefBuffer,
                     sizeof (PefBuffer),
                     &ReturnLength
                     );

        if ( NT_SUCCESS( Status ) || (Status == STATUS_BUFFER_TOO_SMALL)) {

            pEfsUserInfo->pTokenUser = (PTOKEN_USER)LsapAllocateLsaHeap( ReturnLength );

            if (pEfsUserInfo->pTokenUser) {

                if (NT_SUCCESS( Status )) {

                    RtlCopyMemory(pEfsUserInfo->pTokenUser, PefBuffer, ReturnLength);

                    //
                    // Fix the SID pointer
                    //

                    pEfsUserInfo->pTokenUser->User.Sid = (PSID)((PBYTE)(pEfsUserInfo->pTokenUser) + sizeof(SID_AND_ATTRIBUTES));

                    ASSERT(RtlValidSid(pEfsUserInfo->pTokenUser->User.Sid));

                } else {

                    //
                    // The stack performance buffer is not bigger enough
                    //

                    Status = NtQueryInformationToken (
                                 TokenHandle,
                                 TokenUser,
                                 pEfsUserInfo->pTokenUser,
                                 ReturnLength,
                                 &ReturnLength
                                 );

                }
    
                if ( NT_SUCCESS( Status )) {

                    Status = NtQueryInformationToken (
                                 TokenHandle,
                                 TokenStatistics,
                                 (PVOID)&TokenStats,
                                 sizeof( TOKEN_STATISTICS ),
                                 &ReturnLength
                                 );

                    if ( NT_SUCCESS( Status )) {

                        NTSTATUS Status1;

                        pEfsUserInfo->AuthId = TokenStats.AuthenticationId;
                        b = TRUE;

                        //
                        // If we failed to get the group info, we assume the user is not interactively logged on.
                        // The fail should not stop us, we could go without cache at the worst.
                        //

                        Status1 = NtQueryInformationToken (
                                     TokenHandle,
                                     TokenGroups,
                                     PefBuffer,
                                     sizeof (PefBuffer),
                                     &ReturnLength
                                     );

                        if (NT_SUCCESS( Status1 ) || (Status1 == STATUS_BUFFER_TOO_SMALL)) {

                            PTOKEN_GROUPS pGroups = NULL;
                            PTOKEN_GROUPS pAllocGroups = NULL;

                            if ( NT_SUCCESS( Status1 ) ) {

                                pGroups = (PTOKEN_GROUPS) PefBuffer;

                            } else {

                                SafeAllocaAllocate(pAllocGroups, ReturnLength);

                                Status1 = NtQueryInformationToken (
                                             TokenHandle,
                                             TokenGroups,
                                             pAllocGroups,
                                             ReturnLength,
                                             &ReturnLength
                                             );

                                if ( NT_SUCCESS( Status1 )) {

                                   pGroups = pAllocGroups;
                                }
                            }

                
                            if (pGroups) {
                
                                //
                                // Search the interactive SID. Looks like this SID tends to appear at the
                                // end of the list. We search from back to the first.
                                //

                                int SidIndex;

                                for ( SidIndex = (int)(pGroups->GroupCount - 1); SidIndex >= 0; SidIndex--) {
                                    if (RtlEqualSid(LsapInteractiveSid, pGroups->Groups[SidIndex].Sid)) {
                                        pEfsUserInfo->InterActiveUser = USER_INTERACTIVE;
                                        break;
                                    }
                                }
                                if (pEfsUserInfo->InterActiveUser != USER_INTERACTIVE) {
                                    pEfsUserInfo->InterActiveUser = USER_REMOTE;
                                }

                            }

                            SafeAllocaFree( pAllocGroups );
                        }

                        // LsapInteractiveSid

                    }
                }

                if (!b) {

                    //
                    // Something failed, clean up what we were going to return
                    //

                    LsapFreeLsaHeap( pEfsUserInfo->pTokenUser );
                    pEfsUserInfo->pTokenUser = NULL;
                }

            } else {

               Status = STATUS_INSUFFICIENT_RESOURCES;
            }

        }

        NtClose( TokenHandle );
    }

    return( Status );
}



PWCHAR
ConvertSidToWideCharString(
    PSID Sid
    )

/*++

Routine Description:


    This function generates a printable unicode string representation
    of a SID.

    The resulting string will take one of two forms.  If the
    IdentifierAuthority value is not greater than 2^32, then
    the SID will be in the form:


        S-1-281736-12-72-9-110
              ^    ^^ ^^ ^ ^^^
              |     |  | |  |
              +-----+--+-+--+---- Decimal



    Otherwise it will take the form:


        S-1-0x173495281736-12-72-9-110
            ^^^^^^^^^^^^^^ ^^ ^^ ^ ^^^
             Hexidecimal    |  | |  |
                            +--+-+--+---- Decimal






Arguments:



    UnicodeString - Returns a unicode string that is equivalent to
        the SID. The maximum length field is only set if
        AllocateDestinationString is TRUE.

    Sid - Supplies the SID that is to be converted to unicode.

    AllocateDestinationString - Supplies a flag that controls whether or
        not this API allocates the buffer space for the destination
        string.  If it does, then the buffer must be deallocated using
        RtlFreeUnicodeString (note that only storage for
        DestinationString->Buffer is allocated by this API).

Return Value:

    SUCCESS - The conversion was successful

    STATUS_INVALID_SID - The sid provided does not have a valid structure,
        or has too many sub-authorities (more than SID_MAX_SUB_AUTHORITIES).

    STATUS_NO_MEMORY - There was not sufficient memory to allocate the
        target string.  This is returned only if AllocateDestinationString
        is specified as TRUE.

    STATUS_BUFFER_OVERFLOW - This is returned only if
        AllocateDestinationString is specified as FALSE.


--*/

{
    UNICODE_STRING Result;

    if ( STATUS_SUCCESS != RtlConvertSidToUnicodeString( &Result, Sid, TRUE )) {

        return NULL;
    }

    return Result.Buffer;
}

BOOLEAN
EfspIsSystem(
    PEFS_USER_INFO pEfsUserInfo,
    OUT PBOOLEAN System
    )
/*++

Routine Description:

    Determines if the current user is running in system context or not.

Arguments:

    System - Receives whether or not the current user is system.

Return Value:

    TRUE on success, FALSE on failure.

--*/

{

    *System = RtlEqualSid(LsapLocalSystemSid, pEfsUserInfo->pTokenUser->User.Sid);

    return( TRUE );
}

BOOL
EfspIsDomainUser(
    IN  LPWSTR   lpDomainName,
    OUT PBOOLEAN IsDomain
    )
/*++

Routine Description:

    Determines if the current user is logged on to a domain account
    or a local machine account.

Arguments:

    lpDomainName - Supplies the domain name.

    IsDomain - Returns TRUE if the current user is logged on to a domain
        account, FALSE otherwise.

Return Value:

    TRUE on success, FALSE on failure.

--*/

{

    *IsDomain = (wcscmp( EfsComputerName, lpDomainName ) != 0);

    return( TRUE );
}


BOOL
EnrollKeyPair(
    IN  PEFS_USER_INFO pEfsUserInfo,
    OUT HCRYPTKEY  * hKey,
    OUT HCRYPTPROV * hProv,
    OUT LPWSTR     * lpContainerName,
    OUT LPWSTR     * lpProviderName,
    IN  DWORD        dwProviderType,
    OUT PBYTE      * pbHash,
    OUT PDWORD       cbHash,
    OUT LPWSTR     * lpDisplayInfo
    )
/*++

Routine Description:

    This routine takes a keypair and attempts to enroll it.

Arguments:

    hKey - Optionally returns a handle to the user's key.

    hProv - Optionally returns a handle to the user's key's provider.

    lpContainerName - Returns the name of the user's key container.

    lpProviderName - Returns the name of the user's key provider.

    ProviderType - Returns the type of the provider.

    pbHash - Returns the hash of the user's certificate.

    cbHash - Returns the length in bytes of the certificate hash.

    DisplayInfo - Returns the display information associated with this
        certificate.

Return Value:

    TRUE on success, FALSE on failure.  Call GetLastError() for details.

--*/
{
    BOOL b = FALSE;
    BOOL fResult = FALSE;
    DWORD rc = ERROR_SUCCESS;
    DWORD ImpersonationError;

    HCRYPTKEY   hLocalKey = NULL;
    HCRYPTPROV  hLocalProv = NULL;

    PCCERT_CONTEXT pCertContext = NULL ;
    //
    // Initialize OUT parameters
    //

    *pbHash          = NULL;
    *lpDisplayInfo   = NULL;
    *lpContainerName = NULL;
    *lpProviderName  = NULL;
    *cbHash          = 0;

    *hKey = NULL;
    *hProv = NULL;

    //
    // Initialize output parameters
    //

    if (pEfsUserInfo->bDomainAccount) {

        HRESULT AutoEnrollSuccess = S_OK;

        //
        // Attempt to create the auto-enroll object so that this cert re-enrolls.
        //
        // DLL is demand load.
        //

        __try {

            AutoEnrollSuccess = CACreateLocalAutoEnrollmentObject(
                                    wszCERTTYPE_EFS,
                                    NULL,
                                    NULL,
                                    CERT_SYSTEM_STORE_CURRENT_USER
                                    );

        } __except (EXCEPTION_EXECUTE_HANDLER) {

            rc = GetExceptionCode();
            AutoEnrollSuccess = (HRESULT)rc;
        }

        if (S_OK == AutoEnrollSuccess) {

            HCERTTYPE       hCertType = 0;

            CRYPTUI_WIZ_CERT_REQUEST_INFO         CertRequest;
            CRYPTUI_WIZ_CERT_REQUEST_PVK_NEW      NewKeyInfo;
            CRYPT_KEY_PROV_INFO                   KeyProvInfo;
            CRYPTUI_WIZ_CERT_TYPE                 CertType;

            memset( &CertRequest, 0, sizeof( CRYPTUI_WIZ_CERT_REQUEST_INFO ));

            KeyProvInfo.pwszContainerName = NULL;
            if (RsaKeyLength > RSA1024BIT_KEY) {

                //
                // Base Provider is no longer good
                //

                KeyProvInfo.pwszProvName = MS_ENHANCED_PROV;

            } else {

                KeyProvInfo.pwszProvName  = NULL;

            }
            
            KeyProvInfo.dwProvType        = dwProviderType;
            KeyProvInfo.dwFlags           = 0;
            KeyProvInfo.cProvParam        = 0;
            KeyProvInfo.rgProvParam       = NULL;
            KeyProvInfo.dwKeySpec         = AT_KEYEXCHANGE;

            memset( &NewKeyInfo, 0, sizeof( CRYPTUI_WIZ_CERT_REQUEST_PVK_NEW ));

            NewKeyInfo.dwSize        = sizeof( CRYPTUI_WIZ_CERT_REQUEST_PVK_NEW );
            NewKeyInfo.pKeyProvInfo  = &KeyProvInfo;
            NewKeyInfo.dwGenKeyFlags = RsaKeyLength | CRYPT_EXPORTABLE;

            LPWSTR lpwstr          = wszCERTTYPE_EFS;
            CertType.dwSize        = sizeof( CRYPTUI_WIZ_CERT_TYPE );
            CertType.cCertType     = 1;
            CertType.rgwszCertType = &lpwstr;

            //
            // Fill in the fields of the CertRequest structure
            //

            CertRequest.dwSize                 = sizeof( CRYPTUI_WIZ_CERT_REQUEST_INFO );   // required
            CertRequest.dwPurpose              = CRYPTUI_WIZ_CERT_ENROLL;                   // enroll the certificate
            CertRequest.pwszMachineName        = NULL;
            CertRequest.pwszAccountName        = NULL;
            CertRequest.pAuthentication        = NULL;                                      // must be NULL
            CertRequest.pCertRequestString     = NULL;                                      // Reserved, must be NULL
            CertRequest.pwszDesStore           = NULL;                                      // defaults to MY store
            CertRequest.pszHashAlg             = NULL;
            CertRequest.pRenewCertContext      = NULL;                                      // We're enrolling, not renewing
            CertRequest.dwPvkChoice            = CRYPTUI_WIZ_CERT_REQUEST_PVK_CHOICE_NEW;   // Create keyset
            CertRequest.pPvkNew                = &NewKeyInfo;
            CertRequest.pwszCALocation         = NULL;
            CertRequest.pwszCAName             = NULL;
            CertRequest.dwPostOption           = 0;
            CertRequest.pCertRequestExtensions = NULL;
            CertRequest.dwCertChoice           = CRYPTUI_WIZ_CERT_REQUEST_CERT_TYPE;
            CertRequest.pCertType              = &CertType;
            CertRequest.pwszCertDNName         = L"CN=EFS";
            CertRequest.pwszFriendlyName       = NULL;                                      // Optional  if CRYPTUI_WIZ_CERT_ENROLL is set in dwPurpose
            CertRequest.pwszDescription        = NULL;                                      // Optional  if CRYPTUI_WIZ_CERT_ENROLL is set in dwPurpose

            DWORD CAdwStatus = 0 ;
            BOOL CryptUiResult ;

            __try {

                CryptUiResult = CryptUIWizCertRequest(
                                       CRYPTUI_WIZ_NO_UI,
                                       NULL,
                                       NULL,
                                       &CertRequest,
                                       &pCertContext,
                                       &CAdwStatus
                                       );
            }

            __except (EXCEPTION_EXECUTE_HANDLER) {

                CryptUiResult = FALSE ;
                SetLastError( GetExceptionCode() );
            }

            if (CryptUiResult)  {

                //
                // Got back success, see if we got a cert back
                //

                if (CAdwStatus == CRYPTUI_WIZ_CERT_REQUEST_STATUS_SUCCEEDED) {

                    //
                    // We got back a valid Cert Context.
                    // Get the hash out of it.
                    //

                    *pbHash = GetCertHashFromCertContext(
                                  pCertContext,
                                  cbHash
                                  );

                    *lpDisplayInfo = EfspGetCertDisplayInformation( pCertContext );

                    if (*pbHash && *lpDisplayInfo) {

                        PCRYPT_KEY_PROV_INFO pCryptKeyProvInfo = GetKeyProvInfo( pCertContext );

                        if (pCryptKeyProvInfo) {

                           //
                           // According to Xiaohong, we always get back container name and provider name here.
                           // There is no need for us to check NULL here.
                           //


                            *lpContainerName = (LPWSTR)LsapAllocateLsaHeap( wcslen(pCryptKeyProvInfo->pwszContainerName) * sizeof( WCHAR ) + sizeof( UNICODE_NULL ));
                            *lpProviderName =  (LPWSTR)LsapAllocateLsaHeap( wcslen(pCryptKeyProvInfo->pwszProvName)      * sizeof( WCHAR ) + sizeof( UNICODE_NULL ));

                            if (*lpContainerName && *lpProviderName) {

                                wcscpy( *lpContainerName, pCryptKeyProvInfo->pwszContainerName );
                                wcscpy( *lpProviderName,  pCryptKeyProvInfo->pwszProvName );

                                if (CryptAcquireContext( hProv, *lpContainerName, *lpProviderName, PROV_RSA_FULL, CRYPT_SILENT )) {

                                    if (CryptGetUserKey(*hProv, AT_KEYEXCHANGE, hKey)) {

                                        fResult = TRUE;

                                    } else {

                                        rc = GetLastError();

                                    }

                                } else {

                                    rc = GetLastError();
                                }

                            } else {

                                rc = ERROR_NOT_ENOUGH_MEMORY;
                            }

                            LsapFreeLsaHeap( pCryptKeyProvInfo );

                        } else {

                            rc = GetLastError();
                        }

                    } else {

                        rc = GetLastError();
                    }

                   // CertFreeCertificateContext( pCertContext );

                } else {

                    //
                    // We failed.  Get the error. This error will be overwritten in the following code.
                    // It only helps debug for now.
                    //

                    rc = GetLastError(); 
                }

            } else {

                rc = GetLastError();
                if (pEfsUserInfo->NonKerberos && (ERROR_OUTOFMEMORY != rc)) {

                    EfsLogEntry(
                        EVENTLOG_ERROR_TYPE,
                        0,
                        EFS_NTLM_ERROR,
                        0,
                        sizeof(DWORD),
                        NULL,
                        &rc
                        );

                }

            }

            if (!fResult) {

                //
                // We failed to get one from the CA.  Issue a self-signed cert.
                //

                //
                // Free the memory allocated above first
                //

                if (*pbHash) {
                    LsapFreeLsaHeap( *pbHash );
                    *pbHash = NULL;
                }
        
                if (*lpDisplayInfo) {
                    LsapFreeLsaHeap( *lpDisplayInfo );
                    *lpDisplayInfo = NULL;
                }
        
                if (*lpContainerName) {
                    LsapFreeLsaHeap( *lpContainerName );
                    *lpContainerName = NULL;
                }
        
                if (*lpProviderName) {
                    LsapFreeLsaHeap( *lpProviderName );
                    *lpProviderName = NULL;
                }

                if (pCertContext) {
                    CertFreeCertificateContext( pCertContext );
                }
        
                if ( *hKey) {
                    CryptDestroyKey( *hKey );
                    *hKey = NULL;
                }
        
                if ( *hProv) {
                    CryptReleaseContext( *hProv, 0 );
                    *hProv = NULL;
                }

                if (EfspCreateSelfSignedCert( hKey,
                                              hProv,
                                              lpContainerName,
                                              lpProviderName,
                                              pEfsUserInfo,
                                              pbHash,
                                              cbHash,
                                              lpDisplayInfo,
                                              &pCertContext
                                              )) {
                    fResult = TRUE;

                } else {

                    rc = GetLastError();
                }
            }

        } else {

            DebugLog((DEB_WARN, "Unable to create auto-enrollment object, error = %x\n" , AutoEnrollSuccess));
            rc = AutoEnrollSuccess;
        }

    } else {

        //
        // It's not a domain account, which means we can't get to the CA.
        // Issue a self-signed cert.
        //

        if (EfspCreateSelfSignedCert( hKey,
                                      hProv,
                                      lpContainerName,
                                      lpProviderName,
                                      pEfsUserInfo,
                                      pbHash,
                                      cbHash,
                                      lpDisplayInfo,
                                      &pCertContext
                                      )) {
            fResult = TRUE;

        } else {

            rc = GetLastError();
        }
    }

    //
    // Let's add this cert to the local store
    //

    if (fResult) {
        rc  = EfsAddCertToCertStore(
                    pCertContext,
                    TRUSTEDPEOPLE,
                    &ImpersonationError
                    );

        if ( ERROR_SUCCESS != rc ) {

            DebugLog((DEB_ERROR, "Failed to add the cert to LM CA store, error = %x\n" , rc));
            if (ImpersonationError) {

                //
                // We got serious error. We reverted but could not impersonate back.
                // Quit the procedure. This should not happen.
                //

                DebugLog((DEB_ERROR, "Failed to impersonate after revert.\n"));
                fResult = FALSE;

            } else {

                //
                // Fail to add the cert to the store should not prevent us continue.
                //

                rc = ERROR_SUCCESS;
            }
        } else {

            //
            //  Let's update the registry. This is the best effort. No need to see if succeed or not.
            //

            EfsMarkCertAddedToStore(pEfsUserInfo, CERTINLMTRUSTEDSTORE);

        }
    }



    //
    //  Now check if we need create the cache
    //

    //
    // Create the cache node.
    // We could have a cache node which is not validated or no cache at all.
    // We could also have a valid cache but was not allowed to use since it
    // is being freed.
    //

    if (fResult && !pEfsUserInfo->UserCacheStop) {

        //
        // Cache is allowed now
        //

        if (!pEfsUserInfo->pUserCache || (pEfsUserInfo->pUserCache->CertValidated != CERT_VALIDATED)) {

            //
            // Let's create the cache
            //

            PUSER_CACHE pCacheNode;
            PSID  pUserID = NULL;
            ULONG SidLength = 0;

            pCacheNode = (PUSER_CACHE) LsapAllocateLsaHeap(sizeof(USER_CACHE));

            if (pEfsUserInfo->InterActiveUser != USER_INTERACTIVE) {

                SidLength = RtlLengthSid(pEfsUserInfo->pTokenUser->User.Sid);
                pUserID = (PSID) LsapAllocateLsaHeap(SidLength);

            }

            if (pCacheNode && ((SidLength == 0) || (pUserID))) {

                NTSTATUS Status = STATUS_SUCCESS;

                memset( pCacheNode, 0, sizeof( USER_CACHE ));

                if (pUserID) {

                    Status = RtlCopySid(
                                 SidLength,
                                 pUserID,
                                 pEfsUserInfo->pTokenUser->User.Sid
                                 );
                }

                if ( NT_SUCCESS( Status ) && NT_SUCCESS( NtQuerySystemTime(&(pCacheNode->TimeStamp)))){

                    if (EfspInitUserCacheNode(
                                 pCacheNode,
                                 pUserID,
                                 *pbHash,
                                 *cbHash,
                                 *lpContainerName,
                                 *lpProviderName,
                                 *lpDisplayInfo,
                                 &(pCertContext->pCertInfo->NotAfter),
                                 *hKey,
                                 *hProv,
                                 pUserID? NULL: &(pEfsUserInfo->AuthId),
                                 CERT_VALIDATED
                                 )){

                        //
                        //  Cache node created and ready for use. Do not delete or close the info
                        //  we just got.
                        //

                        *lpContainerName = NULL;
                        *lpProviderName = NULL;
                        *lpDisplayInfo = NULL;
                        *pbHash = NULL;
                        *cbHash = NULL;
                        *hProv = NULL;
                        *hKey = NULL;

                        if (pEfsUserInfo->pUserCache) {

                            //
                            // We had a not validated cache
                            //

                            EfspReleaseUserCache(pEfsUserInfo->pUserCache);

                        }

                        pEfsUserInfo->pUserCache = pCacheNode;


                    } else {

                        LsapFreeLsaHeap(pCacheNode);
                        pCacheNode = NULL;
                        if (pUserID) {
                            LsapFreeLsaHeap(pUserID);
                            pUserID = NULL;
                        }

                    }

                } else {

                    LsapFreeLsaHeap(pCacheNode);
                    pCacheNode = NULL;
                    if (pUserID) {
                        LsapFreeLsaHeap(pUserID);
                        pUserID = NULL;
                    }

                }

            } else {

                if (pCacheNode) {
                   LsapFreeLsaHeap(pCacheNode);
                   pCacheNode = NULL;
                }
                if (pUserID) {
                    LsapFreeLsaHeap(pUserID);
                    pUserID = NULL;
                }

            }
        }

        //
        // Even if cache failed to create, but we can proceed without cache
        //

    }

    if (pCertContext) {
        CertFreeCertificateContext( pCertContext );
        pCertContext = NULL;
    }

    if (!fResult) {

        //
        // Something failed, free all the OUT parameters
        // that were allocated.
        //

        if (*pbHash) {
            LsapFreeLsaHeap( *pbHash );
            *pbHash = NULL;
        }

        if (*lpDisplayInfo) {
            LsapFreeLsaHeap( *lpDisplayInfo );
            *lpDisplayInfo = NULL;
        }

        if (*lpContainerName) {
            LsapFreeLsaHeap( *lpContainerName );
            *lpContainerName = NULL;
        }

        if (*lpProviderName) {
            LsapFreeLsaHeap( *lpProviderName );
            *lpProviderName = NULL;
        }

        if ( *hKey) {
            CryptDestroyKey( *hKey );
            *hKey = NULL;
        }

        if ( *hProv) {
            CryptReleaseContext( *hProv, 0 );
            *hProv = NULL;
        }
    }

    SetLastError( rc );

    return ( fResult );
}


BOOL
EfspCreateSelfSignedCert(
    OUT HCRYPTKEY  * hKey,
    OUT HCRYPTPROV * hProv,
    OUT LPWSTR     * lpContainerName,
    OUT LPWSTR     * lpProviderName,
    IN  PEFS_USER_INFO pEfsUserInfo,
    OUT PBYTE      * pbHash,
    OUT PDWORD       cbHash,
    OUT LPWSTR     * lpDisplayInfo,
    OUT PCCERT_CONTEXT *pCertContext
    )
/*++

Routine Description:

    This routine sets up and creates a self-signed certificate.

Arguments:

    lpContainerName - Returns the container name of the new certificate.

    lpProviderName - Returns the provider name of the new certificate.

    pbHash - Returns the hash of the new certificate.

    cbHash - Returns the length in bytes of the new certificate hash.

    lpDisplayInfo - Returns the display string for the new certificate.

Return Value:

    TRUE on success, FALSE on failure.  Call GetLastError() for more details.

--*/

{
    BOOL b = FALSE;
    DWORD rc = ERROR_SUCCESS;
    //
    // Initialize OUT parameters
    //

    *lpContainerName = NULL;
    *lpProviderName  = NULL;
    *pbHash          = NULL;
    *lpDisplayInfo   = NULL;
    *pCertContext    = NULL;

    *hKey            = NULL;
    *hProv           = NULL;

    RPC_STATUS       RpcStatus; 

    //
    // Croft up a key pair
    //

    //
    // Container name
    //

    GUID    guidContainerName;

    RpcStatus = UuidCreate(&guidContainerName);
    if ((RpcStatus != RPC_S_OK) && (RpcStatus != RPC_S_UUID_LOCAL_ONLY)) {
        SetLastError(RpcStatus);
        return b;
    }

    LPWSTR TmpContainerName;
    DWORD  ProviderNameLen;

    if (ERROR_SUCCESS == UuidToStringW(&guidContainerName, &TmpContainerName )) {

        //
        // Copy the container name into LSA heap memory
        //

        *lpContainerName = (LPWSTR)LsapAllocateLsaHeap( (wcslen( TmpContainerName ) + 1) * sizeof( WCHAR ) );

        if (*lpContainerName) {

            wcscpy( *lpContainerName, TmpContainerName );

            if (RsaKeyLength > RSA1024BIT_KEY) {

                //
                // Base Provider is no longer good
                //

                ProviderNameLen = wcslen( MS_ENHANCED_PROV ) + 1;

            } else {

                ProviderNameLen = wcslen( MS_DEF_PROV ) + 1;

            }

            *lpProviderName = (PWCHAR)LsapAllocateLsaHeap( ProviderNameLen * sizeof( WCHAR ) );

            if (*lpProviderName == NULL) {

                rc = ERROR_NOT_ENOUGH_MEMORY;

            } else {

                if (RsaKeyLength > RSA1024BIT_KEY) {
                    wcscpy( *lpProviderName, MS_ENHANCED_PROV );
                } else {
                    wcscpy( *lpProviderName, MS_DEF_PROV );
                }


                //
                // Create the key container
                //

                if (CryptAcquireContext(hProv, *lpContainerName, *lpProviderName, PROV_RSA_FULL, CRYPT_NEWKEYSET | CRYPT_SILENT )) {

                    if (CryptGenKey(*hProv, AT_KEYEXCHANGE, RsaKeyLength | CRYPT_EXPORTABLE, hKey)) {

                        //
                        // Construct the subject name information
                        //

                        LPWSTR UPNName = NULL;
                        LPWSTR SubName = NULL;

                        //*lpDisplayInfo = MakeDNName( FALSE, pEfsUserInfo);
                        rc = EfsMakeCertNames(
                                    pEfsUserInfo,
                                    lpDisplayInfo,
                                    &SubName,
                                    &UPNName
                                    );

                        if (ERROR_SUCCESS == rc) {

                            //
                            // Use this piece of code to create the PCERT_NAME_BLOB going into CertCreateSelfSignCertificate()
                            //

                            CERT_NAME_BLOB SubjectName;

                            SubjectName.cbData = 0;

                            if(CertStrToNameW(
                                   CRYPT_ASN_ENCODING,
                                   SubName,
                                   0,
                                   NULL,
                                   NULL,
                                   &SubjectName.cbData,
                                   NULL)) {

                                SafeAllocaAllocate(SubjectName.pbData, SubjectName.cbData);

                                if (SubjectName.pbData) {

                                    if (CertStrToNameW(
                                            CRYPT_ASN_ENCODING,
                                            SubName,
                                            0,
                                            NULL,
                                            SubjectName.pbData,
                                            &SubjectName.cbData,
                                            NULL) ) {

                                        //
                                        //  Make the UPN Name
                                        //

                                        PCERT_EXTENSION altNameExt = NULL;


                                        if (EfsGetAltNameExt(&altNameExt, UPNName)) {

                                            //
                                            // Make the basic restrain extension
                                            //

                                            PCERT_EXTENSION basicRestraint = NULL;

                                            if (EfsGetBasicConstraintExt(&basicRestraint)) {

                                                //
                                                // Make the enhanced key usage
                                                //
        
                                                CERT_ENHKEY_USAGE certEnhKeyUsage;
                                                LPSTR lpstr;
                                                CERT_EXTENSION certExt[3];
        
                                                lpstr = szOID_EFS_CRYPTO;
                                                certEnhKeyUsage.cUsageIdentifier = 1;
                                                certEnhKeyUsage.rgpszUsageIdentifier  = &lpstr;
        
                                                // now call CryptEncodeObject to encode the enhanced key usage into the extension struct
        
                                                certExt[0].Value.cbData = 0;
                                                certExt[0].Value.pbData = NULL;
                                                certExt[0].fCritical = FALSE;
                                                certExt[0].pszObjId = szOID_ENHANCED_KEY_USAGE;
        
                                                //
                                                // Encode it
                                                //
        
                                                if (EncodeAndAlloc(
                                                        CRYPT_ASN_ENCODING,
                                                        X509_ENHANCED_KEY_USAGE,
                                                        &certEnhKeyUsage,
                                                        &certExt[0].Value.pbData,
                                                        &certExt[0].Value.cbData
                                                        )) {
        
                                                    //
                                                    // finally, set up the array of extensions in the certInfo struct
                                                    // any further extensions need to be added to this array.
                                                    //
        
                                                    CERT_EXTENSIONS certExts;
        
                                                    certExts.cExtension = sizeof(certExt) / sizeof(CERT_EXTENSION);
                                                    certExts.rgExtension = &certExt[0];
                                                    certExt[1] = *altNameExt;
                                                    certExt[2] = *basicRestraint;
        
                                                    CRYPT_KEY_PROV_INFO KeyProvInfo;
        
                                                    memset( &KeyProvInfo, 0, sizeof( CRYPT_KEY_PROV_INFO ));
        
                                                    KeyProvInfo.pwszContainerName = *lpContainerName;
                                                    KeyProvInfo.pwszProvName      = *lpProviderName;
                                                    KeyProvInfo.dwProvType        = PROV_RSA_FULL;
                                                    KeyProvInfo.dwKeySpec         = AT_KEYEXCHANGE;
        
                                                    //
                                                    // Make the expiration time very very long (100 years)
                                                    //
        
                                                    SYSTEMTIME  StartTime;
                                                    FILETIME    FileTime;
                                                    LARGE_INTEGER TimeData;
                                                    SYSTEMTIME  EndTime;
        
                                                    GetSystemTime(&StartTime);
                                                    SystemTimeToFileTime(&StartTime, &FileTime);
                                                    TimeData.LowPart = FileTime.dwLowDateTime; 
                                                    TimeData.HighPart = (LONG) FileTime.dwHighDateTime;
                
                                                    TimeData.QuadPart += YEARCOUNT * 100;
                                                    FileTime.dwLowDateTime = TimeData.LowPart;
                                                    FileTime.dwHighDateTime = (DWORD) TimeData.HighPart; 
                
                                                    FileTimeToSystemTime(&FileTime, &EndTime);
        
                                                    *pCertContext = CertCreateSelfSignCertificate(
                                                                       *hProv,
                                                                       &SubjectName,
                                                                       0,
                                                                       &KeyProvInfo,
                                                                       NULL,
                                                                       &StartTime,
                                                                       &EndTime,
                                                                       &certExts
                                                                       );
        
                                                    if (*pCertContext) {
        
                                                        *pbHash = GetCertHashFromCertContext(
                                                                      *pCertContext,
                                                                      cbHash
                                                                      );
        
                                                        if (*pbHash) {
        
                                                            HCERTSTORE hStore;
        
                                                            // hStore = CertOpenSystemStoreW( NULL, L"MY" );
                                                            hStore = CertOpenStore(
                                                                                CERT_STORE_PROV_SYSTEM_REGISTRY_W,
                                                                                0,       // dwEncodingType
                                                                                0,       // hCryptProv,
                                                                                CERT_SYSTEM_STORE_CURRENT_USER,
                                                                                L"My"
                                                                                );
        
                                                            if (hStore) {
        
                                                                //
                                                                // save the temp cert
                                                                //
        
                                                                if(CertAddCertificateContextToStore(
                                                                       hStore,
                                                                       *pCertContext,
                                                                       CERT_STORE_ADD_NEW,
                                                                       NULL) ) {
        
                                                                    b = TRUE;
        
                                                                } else {
        
                                                                    rc = GetLastError();
                                                                }
        
                                                                CertCloseStore( hStore, 0 );
        
                                                            } else {
        
                                                                rc = GetLastError();
                                                            }
        
                                                        } else {
        
                                                            rc = GetLastError();
                                                        }
        
        
                                                    } else {
        
                                                        rc = GetLastError();
                                                    }
        
                                                    LsapFreeLsaHeap( certExt[0].Value.pbData );
        
                                                } else {
        
                                                    rc = GetLastError();
                                                }
    
                                                LsapFreeLsaHeap(basicRestraint->Value.pbData);
                                                LsapFreeLsaHeap(basicRestraint);

                                            } else {

                                                rc = GetLastError();

                                            }

                                            LsapFreeLsaHeap(altNameExt->Value.pbData);
                                            LsapFreeLsaHeap(altNameExt);
                                                
                                        } else {

                                            rc = GetLastError();

                                        }


                                    } else {

                                        rc = GetLastError();
                                    }

                                    SafeAllocaFree( SubjectName.pbData );

                                } else {

                                    rc = ERROR_NOT_ENOUGH_MEMORY;
                                }
                            } else {

                                rc = GetLastError();

                            }

                        }

                        LsapFreeLsaHeap(UPNName);
                        LsapFreeLsaHeap(SubName);

                    } else {

                        //
                        // We create the container but failed to get the keys. We need to
                        // clean up the useless container here.
                        //

                        rc = GetLastError();
                        CryptReleaseContext( *hProv, 0 );
                        CryptAcquireContext(hProv, *lpContainerName, *lpProviderName, PROV_RSA_FULL, CRYPT_DELETEKEYSET | CRYPT_SILENT );

                        //
                        // No need to call CryptReleaseContext any more.
                        //

                        *hProv = NULL;

                    }

                } else {

                    rc = GetLastError();
                    if (pEfsUserInfo->NonKerberos && (ERROR_OUTOFMEMORY != rc)) {

                        EfsLogEntry(
                            EVENTLOG_ERROR_TYPE,
                            0,
                            EFS_NTLM_ERROR,
                            0,
                            sizeof(DWORD),
                            NULL,
                            &rc
                            );

                        rc = ERROR_BAD_LOGON_SESSION_STATE;
                    }

                }
            }

        } else {

            rc = ERROR_NOT_ENOUGH_MEMORY;
        }

        RpcStringFree( &TmpContainerName );

    } else {

        rc = ERROR_NOT_ENOUGH_MEMORY;
    }

    if (!b) {

        //
        // Something failed, clean up whatever we allocated
        //

        if (*pbHash) {
            LsapFreeLsaHeap( *pbHash );
            *pbHash = NULL;
        }

        if (*lpDisplayInfo) {
            LsapFreeLsaHeap( *lpDisplayInfo );
            *lpDisplayInfo = NULL;
        }

        if (*lpContainerName) {
            LsapFreeLsaHeap( *lpContainerName );
            *lpContainerName = NULL;
        }

        if (*lpProviderName) {
            LsapFreeLsaHeap( *lpProviderName );
            *lpProviderName = NULL;
        }

        if ( *pCertContext ) {

            CertFreeCertificateContext( *pCertContext );
            *pCertContext = NULL;

        }

        if (*hKey) {
            CryptDestroyKey( *hKey );
            *hKey = NULL;
        }

        if (*hProv) {
            CryptReleaseContext( *hProv, 0 );
            *hProv = NULL;
        }
    }

    SetLastError( rc );

    return( b );
}

DWORD
GenerateUserKey (
    IN  PEFS_USER_INFO pEfsUserInfo,
    OUT HCRYPTKEY  * hKey       OPTIONAL,
    OUT HCRYPTPROV * hProv      OPTIONAL,
    OUT LPWSTR     * lpContainerName,
    OUT LPWSTR     * lpProviderName,
    OUT PDWORD       ProviderType,
    OUT LPWSTR     * DisplayInfo,
    OUT PBYTE      * pbHash,
    OUT PDWORD       cbHash
    )
/*++

Routine Description:

    This routine will construct a default user key for the current user
    and install it in the registry.  The constructed key takes the form

    <UserName>_<MachineName>_EFS_<i>

    Where i is increased as necessary to construct a valid key name.

Arguments:

    hKey - Optionally returns a handle to the new key.  This key must
        be destroyed by the caller via CryptDestroyKey().

    hProv - Optionally returns a handle to the provider of the new key.
        This handle must be closed by the user via CryptReleaseContext().

    lpContainerName - Returns a pointer to the name of the new key.  This
        buffer must be freed via LsapFreeHeap().

    lpProviderName - Returns a pointer to the provider of the new key.  This
        buffer must be freed via LsapFreeHeap().

    ProviderType - Returns the type of the provider of the new key.

    pbHash - Returns a pointer to the certificate hash for this key.

    cbHash - Returns the size fo the pbHash buffer.

Return Value:

    ERROR_SUCCESS for succeed.
    
--*/

{
    BOOL       fSuccess      = FALSE;

    DWORD      Disposition   = 0;
    DWORD      dwDataLength  = 0;

    HCRYPTKEY  LocalhKey     = 0;
    HCRYPTPROV LocalhProv    = 0;

    HKEY       KeyHandle     = NULL;

    LONG       rc            = ERROR_SUCCESS;

    //
    // Initialize our output parameters
    //

    *ProviderType    = PROV_RSA_FULL;
    *lpProviderName  = NULL;
    *lpContainerName = NULL;
    *DisplayInfo     = NULL;
    *pbHash          = NULL;

    if (ARGUMENT_PRESENT(hKey)) {
        *hKey = NULL;
    }

    if (ARGUMENT_PRESENT(hProv)) {
        *hProv = NULL;
    }

    //
    // Use the user name as a mutex name to synchronize access to the following
    // code.  This way we don't hang up every thread to come through here, only
    // ones from this user.
    //

    HANDLE hMutex = CreateMutex( NULL, TRUE, pEfsUserInfo->lpUserName );

    if (hMutex != NULL) {

        if (GetLastError() == ERROR_SUCCESS) {

            //
            // If we're here, we have the mutex, so we can proceed.
            //
            // Note that it is possible for some other thread to have
            // come through here and created keys for the user while
            // we were busy doing all of this.  We will attempt to create
            // the registry key where we will store the key information,
            // and if it's already there, we will assume that someone
            // came in and did all this while we were on our way.
            //

            //
            // Create the registry path, if it does not already exist.
            //

            rc = RegCreateKeyEx( KEYPATHROOT,
                                 pEfsUserInfo->lpKeyPath,
                                 0,
                                 TEXT("REG_SZ"),
                                 REG_OPTION_NON_VOLATILE,
                                 KEY_READ | KEY_WRITE,
                                 NULL,
                                 &KeyHandle,
                                 &Disposition
                                 );


            if (rc == ERROR_SUCCESS) {

                //
                // The key didn't exist.  Create a cert
                //

                if (EnrollKeyPair( pEfsUserInfo,
                                   &LocalhKey,
                                   &LocalhProv,
                                   lpContainerName,
                                   lpProviderName,
                                   PROV_RSA_FULL,
                                   pbHash,
                                   cbHash,
                                   DisplayInfo
                                   )) {

                    PBYTE      pbLocalHash;
                    DWORD      cbLocalHash;

                    //
                    // Write the hash value to the registry
                    //

                    if (*pbHash) {
                        pbLocalHash = *pbHash;
                        cbLocalHash = *cbHash;
                    } else {

                        ASSERT(pEfsUserInfo->pUserCache);

                        pbLocalHash = pEfsUserInfo->pUserCache->pbHash;
                        cbLocalHash = pEfsUserInfo->pUserCache->cbHash;

                    }

                    rc = RegSetValueEx(
                              KeyHandle,  // handle of key to set value for
                              CERT_HASH,
                              0,
                              REG_BINARY,
                              pbLocalHash,
                              cbLocalHash
                              );

                    if (rc == ERROR_SUCCESS) {

                        //
                        // Mark entire operation as successful
                        //

                        fSuccess = TRUE;
                    }

                } else {

                    rc = GetLastError();
                }

                RegCloseKey( KeyHandle );

            } else {

                KeyHandle = NULL; // paranoia

                //
                // We couldn't create the registry key for some reason,
                // fail the entire operation.
                //
            }

        } else {

            if (GetLastError() == ERROR_ALREADY_EXISTS) {

                DebugLog((DEB_TRACE_EFS, "KeyGen mutex %ws exists\n", pEfsUserInfo->lpUserName   ));

                //
                // Some other thread is in here trying to create the keys.
                // Wait on this mutex, and assume that once we come back,
                // the other thread is done and we can just leave and
                // try to get the keys again.
                //

                WaitForSingleObject( hMutex, INFINITE );

            } else {

                //
                // If we're here, then CreateMutex did not fail, but GetLastError is
                // set to something other than success or ERROR_ALREADY_EXISTS.  Is
                // this an error?
                //

                ASSERT(FALSE);
            }

            rc = ERROR_RETRY;
        }

        DebugLog((DEB_TRACE_EFS, "Closing mutex handle\n"   ));

        ReleaseMutex( hMutex );
        CloseHandle( hMutex );

    } else {

        DebugLog((DEB_ERROR, "CreateMutex failed, error = %x\n", GetLastError()    ));
        rc = GetLastError();
    }


    if (fSuccess) {

        //
        // Return these to the caller
        //

        if (ARGUMENT_PRESENT( hKey ) && ARGUMENT_PRESENT( hProv )) {

            //
            // If the caller passed this in, he wants
            // the key and provider passed back
            //

            *hKey = LocalhKey;
            *hProv = LocalhProv;

        } else {

            if ( LocalhKey ) {
                CryptDestroyKey( LocalhKey );
            }

            if ( LocalhProv ) {
                CryptReleaseContext( LocalhProv, 0 );
            }

        }

    } else {

        //
        // We failed somewhere, free what we were going
        // to return.
        //

        if (*lpProviderName != NULL) {
            LsapFreeLsaHeap( *lpProviderName );
            *lpProviderName = NULL;
        }

        if (*lpContainerName != NULL) {
            LsapFreeLsaHeap( *lpContainerName );
            *lpContainerName = NULL;
        }

        if (*DisplayInfo != NULL) {
            LsapFreeLsaHeap( *DisplayInfo );
            *DisplayInfo = NULL;
        }

        if (*pbHash) {
            LsapFreeLsaHeap( *pbHash );
            *pbHash = NULL;
        }

        if (LocalhKey != 0) {
            CryptDestroyKey( LocalhKey );
        }

        if (LocalhProv != 0) {
            CryptReleaseContext(LocalhProv, 0);
        }

    }

    return( rc );
}


BOOL
EqualCertPublicKeys(
    PCERT_PUBLIC_KEY_INFO pKey1,
    PCERT_PUBLIC_KEY_INFO pKey2
    )

/*++

Routine Description:

    Helper routine to compare the public key portions of two certificates.

Arguments:

    pKey1 - One of the public key info structures.

    pKey2 - The other one.


Return Value:

    TRUE on match, FALSE on failure.

--*/
{

    CRYPT_BIT_BLOB * PublicKey1 = &pKey1->PublicKey;
    CRYPT_BIT_BLOB * PublicKey2 = &pKey2->PublicKey;

    if (PublicKey1->cbData == PublicKey2->cbData) {

        if (memcmp(PublicKey1->pbData, PublicKey2->pbData, PublicKey2->cbData) == 0) {
            return( TRUE );
        }
    }

    return( FALSE );
}


LONG
SearchMyStoreForEFSCert(
    IN  PEFS_USER_INFO pEfsUserInfo,
    OUT HCRYPTKEY  * hKey       OPTIONAL,
    OUT HCRYPTPROV * hProv      OPTIONAL,
    OUT LPWSTR     * ContainerName,
    OUT LPWSTR     * ProviderName,
    OUT LPWSTR     * DisplayInfo,
    OUT PBYTE      * pbHash,
    OUT PDWORD       cbHash
    )

/*++

Routine Description:

    description-of-function.

Arguments:

    argument-name - Supplies | Returns description of argument.
    .
    .

Return Value:

    return-value - Description of conditions needed to return value. - or -
    None.

--*/

{
    DWORD rc = ERROR_NO_USER_KEYS;
    HKEY hRegKey;
    DWORD Disposition = 0;
    HCRYPTPROV hLocalProv = NULL;
    NTSTATUS status;
    DWORD ImpersonationError = 0;

    //
    // Initialize required return values.
    //

    *ProviderName = NULL;
    *ContainerName = NULL;
    *DisplayInfo = NULL;
    *pbHash = NULL;
    *cbHash = 0;

    //
    // Initialize optional return values
    //

    if (ARGUMENT_PRESENT(hKey)) {
        *hKey = NULL;
    }

    if (ARGUMENT_PRESENT(hProv)) {
        *hProv = NULL;
    }

    //
    // Assume that there's no current EFS information
    // for this guy.  Create the registry key.
    //

    rc = RegCreateKeyEx(
             KEYPATHROOT,
             pEfsUserInfo->lpKeyPath,
             0,
             TEXT("REG_SZ"),
             REG_OPTION_NON_VOLATILE,
             KEY_ALL_ACCESS,
             NULL,
             &hRegKey,
             &Disposition    // address of disposition value buffer
             );

    //
    // Open up the user's MY store and see if there's an EFS
    // certificate floating around in there somewhere.
    //

    if (rc == ERROR_SUCCESS) {

        CERT_ENHKEY_USAGE certEnhKeyUsage;

        LPSTR lpstr = szOID_EFS_CRYPTO;
        certEnhKeyUsage.cUsageIdentifier = 1;
        certEnhKeyUsage.rgpszUsageIdentifier  = &lpstr;

        PCCERT_CONTEXT pCertContext = NULL;

        //
        // If this fails, there's no cert that matches.
        //

        HCERTSTORE hStore = CertOpenStore(
                            CERT_STORE_PROV_SYSTEM_REGISTRY_W,
                            0,       // dwEncodingType
                            0,       // hCryptProv,
                            CERT_SYSTEM_STORE_CURRENT_USER,
                            L"My"
                            );

        // hStore = CertOpenSystemStoreW( NULL, L"MY");

        if (hStore) {

            do {

                //
                // This will go to success if everything works...
                //

                rc = ERROR_NO_USER_KEYS;

                pCertContext = CertFindCertificateInStore(
                                   hStore,
                                   X509_ASN_ENCODING,
                                   0, //CERT_FIND_EXT_ONLY_ENHKEY_USAGE_FLAG,
                                   CERT_FIND_ENHKEY_USAGE,
                                   &certEnhKeyUsage,
                                   pCertContext
                                   );

                if (pCertContext) {

                    DebugLog((DEB_TRACE_EFS, "Found matching cert in MY store\n"   ));

                    //
                    // Do cert validity checking.
                    //


                    if ( CertVerifyTimeValidity(
                            NULL,
                            pCertContext->pCertInfo
                            )){

                        rc = CERT_E_EXPIRED;

                    } else {

                        //
                        // Test the cert usage here.
                        // CERT_E_WRONG_USAGE
                        //

                        BOOL OidFound;
                        

                        rc = EfsFindCertOid(
                                szOID_KP_EFS,
                                pCertContext,
                                &OidFound
                                );

                        if (ERROR_SUCCESS == rc) {

                            rc = ERROR_NO_USER_KEYS;

                            if (OidFound) {

                                *pbHash = GetCertHashFromCertContext(
                                              pCertContext,
                                              cbHash
                                              );
    
                                if (*pbHash) {
    
                                    //
                                    // See if we can get container and provider info.
                                    //
                                    // Once we've got them, make sure we can call CryptAcquireContext
                                    // and have it work.  That guarantees there's a private key available.
                                    //
    
                                    PCRYPT_KEY_PROV_INFO pCryptKeyProvInfo = GetKeyProvInfo( pCertContext );
    
                                    if (pCryptKeyProvInfo) {
    
                                        if (!wcscmp(pCryptKeyProvInfo->pwszProvName, MS_DEF_PROV_W) ||
                                            !wcscmp(pCryptKeyProvInfo->pwszProvName, MS_ENHANCED_PROV_W) ||
                                            !wcscmp(pCryptKeyProvInfo->pwszProvName, MS_STRONG_PROV_W)) {
    
                                            if (CryptAcquireContext(
                                                    &hLocalProv,
                                                    pCryptKeyProvInfo->pwszContainerName,
                                                    pCryptKeyProvInfo->pwszProvName,
                                                    pCryptKeyProvInfo->dwProvType,
                                                    pCryptKeyProvInfo->dwFlags | CRYPT_SILENT
                                                    )) {
        
                                                //
                                                // Make sure the public key in the cert matches the one
                                                // that's in this context.
                                                //
        
                                                DWORD cbPubKeyInfo = 0;
        
                                                PCERT_PUBLIC_KEY_INFO pPubKeyInfo = ExportPublicKeyInfo(
                                                                                        hLocalProv,
                                                                                        pCryptKeyProvInfo->dwKeySpec,
                                                                                        X509_ASN_ENCODING,
                                                                                        &cbPubKeyInfo
                                                                                        );
        
                                                if (pPubKeyInfo) {
        
                                                    //
                                                    // Get the public key from the cert context
                                                    //
        
                                                    PCERT_INFO pCertInfo = pCertContext->pCertInfo;
                                                    PCERT_PUBLIC_KEY_INFO pSubjectPublicKeyInfo = &pCertInfo->SubjectPublicKeyInfo;
        
                                                    if (EqualCertPublicKeys( pPubKeyInfo, pSubjectPublicKeyInfo )) {
        
                                                        //
                                                        // They match.  We want to make sure not to return
                                                        // an error indicating that we didn't find a key.
                                                        // The next call will reset the value of rc
                                                        //
        
                                                        rc = RegSetValueEx(
                                                                hRegKey,  // handle of key to set value for
                                                                CERT_HASH,
                                                                0,
                                                                REG_BINARY,
                                                                *pbHash,
                                                                *cbHash
                                                                );
        
                                                        if (rc == ERROR_SUCCESS) {
        
                                                            if (pCryptKeyProvInfo->pwszProvName) {
                                                               *ProviderName = (LPWSTR)LsapAllocateLsaHeap( wcslen(pCryptKeyProvInfo->pwszProvName) * sizeof( WCHAR ) + sizeof(L'\0') );
                                                               if (*ProviderName) {
                                                                  wcscpy( *ProviderName, pCryptKeyProvInfo->pwszProvName );
                                                               } else {
                                                                  rc = ERROR_NOT_ENOUGH_MEMORY;
                                                               }
                                                            }
                                                            if (pCryptKeyProvInfo->pwszContainerName) {
                                                               *ContainerName = (LPWSTR)LsapAllocateLsaHeap( wcslen(pCryptKeyProvInfo->pwszContainerName) * sizeof( WCHAR ) + sizeof(L'\0') );
                                                               if (*ContainerName) {
                                                                  wcscpy( *ContainerName, pCryptKeyProvInfo->pwszContainerName );
                                                               } else {
                                                                  rc = ERROR_NOT_ENOUGH_MEMORY;
                                                               }
                                                            }
        
                                                            if (rc == ERROR_SUCCESS) {
           
                                                               if (!(*DisplayInfo = EfspGetCertDisplayInformation( pCertContext ))) {
           
                                                                   //
                                                                   // At least for now, we do not accept Cert without display name
                                                                   //
                                                                   rc = GetLastError();
           
                                                               }
                                                            }

                                                            //
                                                            // Let's add it to OtherPeople Store
                                                            //

                                                            if (ERROR_SUCCESS == (rc = EfsAddCertToCertStore(pCertContext, OTHERPEOPLE, &ImpersonationError))) {

                                                                DWORD StoreId = CERTINLMOTHERSTORE;

                                                                //
                                                                // Mark it in the store. Fail will not stop us.
                                                                //

                                                                (void) RegSetValueEx(
                                                                        hRegKey,  // handle of key to set value for
                                                                        CERT_FLAG,
                                                                        0,
                                                                        REG_DWORD,
                                                                        (LPBYTE)&StoreId,
                                                                        sizeof (DWORD)
                                                                        );
                                                            } else {
                                                                if (!ImpersonationError) {

                                                                    //
                                                                    //  Any error other than impersonation would not stop us here.
                                                                    //  Put the cert in the OtherPeople store is just a best effort.
                                                                    //

                                                                    rc = ERROR_SUCCESS;

                                                                
                                                                }
                                                            }
    
                                                            //
                                                            // Create the cache node.
                                                            // We could have a cache node which is not validated or no cache at all.
                                                            // We could also have a valid cache but was not allowed to use since it
                                                            // is being freed.
                                                            //
    
                                                            if ((rc == ERROR_SUCCESS) && !pEfsUserInfo->UserCacheStop) {
    
                                                                //
                                                                // Cache is allowed now
                                                                //
    
                                                                if (!pEfsUserInfo->pUserCache || (pEfsUserInfo->pUserCache->CertValidated != CERT_VALIDATED)) {
    
                                                                    //
                                                                    // Let's create the cache
                                                                    //
    
                                                                    PUSER_CACHE pCacheNode;
                                                                    PSID  pUserID = NULL;
                                                                    ULONG SidLength = 0;
                                            
                                                                    pCacheNode = (PUSER_CACHE) LsapAllocateLsaHeap(sizeof(USER_CACHE));

                                                                    if (pEfsUserInfo->InterActiveUser != USER_INTERACTIVE) {
                                                        
                                                                        SidLength = RtlLengthSid(pEfsUserInfo->pTokenUser->User.Sid);
                                                                        pUserID = (PSID) LsapAllocateLsaHeap(SidLength);
                                                        
                                                                    }
                                            
                                                                    if (pCacheNode && ((SidLength == 0) || (pUserID))) {
                                            
                                                                        status = STATUS_SUCCESS;
                                                        
                                                                        memset( pCacheNode, 0, sizeof( USER_CACHE ));
                                                        
                                                                        if (pUserID) {
                                                        
                                                                            status = RtlCopySid(
                                                                                         SidLength,
                                                                                         pUserID,
                                                                                         pEfsUserInfo->pTokenUser->User.Sid
                                                                                         );
                                                                        }
                                                                                    
                                                                        if (NT_SUCCESS( status )  && NT_SUCCESS( status = NtQuerySystemTime(&(pCacheNode->TimeStamp)))){
    
                                                                            HCRYPTKEY  hLocalKey;
                                            
                                                                            if (CryptGetUserKey( hLocalProv, AT_KEYEXCHANGE, &hLocalKey )){
    
                                                                                if (EfspInitUserCacheNode(
                                                                                             pCacheNode,
                                                                                             pUserID,
                                                                                             *pbHash,
                                                                                             *cbHash,
                                                                                             *ContainerName,
                                                                                             *ProviderName,
                                                                                             *DisplayInfo,
                                                                                             &(pCertContext->pCertInfo->NotAfter),
                                                                                             hLocalKey,
                                                                                             hLocalProv,
                                                                                             pUserID? NULL: &(pEfsUserInfo->AuthId),
                                                                                             CERT_VALIDATED
                                                                                             )){
                                                
                                                                                    //
                                                                                    //  Cache node created and ready for use. Do not delete or close the info
                                                                                    //  we just got.
                                                                                    //
                                                
                                                                                    *ContainerName = NULL;
                                                                                    *ProviderName = NULL;
                                                                                    *DisplayInfo = NULL;
                                                                                    *pbHash = NULL;
                                                                                    *cbHash = NULL;
                                                                                    hLocalProv = NULL;
        
                                                                                    if (pEfsUserInfo->pUserCache) {
        
                                                                                        //
                                                                                        // We had a not validated cache
                                                                                        //
        
                                                                                        EfspReleaseUserCache(pEfsUserInfo->pUserCache);
        
                                                                                    }
        
                                                                                    pEfsUserInfo->pUserCache = pCacheNode;
                                                
                                                                                } else {
        
                                                                                    if (hLocalKey) {
                                                                                        CryptDestroyKey( hLocalKey );
                                                                                    }
                                                
                                                                                    LsapFreeLsaHeap(pCacheNode);
                                                                                    pCacheNode = NULL;
                                                                                    if (pUserID) {
                                                                                        LsapFreeLsaHeap(pUserID);
                                                                                        pUserID = NULL;
                                                                                    }
                                                
                                                                                }
                                                                            } else {
    
                                                                                rc = GetLastError();
                                                                                LsapFreeLsaHeap(pCacheNode);
                                                                                pCacheNode = NULL;
                                                                                if (pUserID) {
                                                                                    LsapFreeLsaHeap(pUserID);
                                                                                    pUserID = NULL;
                                                                                }
    
                                                                            }
                                                
                                                                        } else {
                                            
                                                                            rc = RtlNtStatusToDosError( status );
                                                                            LsapFreeLsaHeap(pCacheNode);
                                                                            pCacheNode = NULL;
                                                                            if (pUserID) {
                                                                                LsapFreeLsaHeap(pUserID);
                                                                                pUserID = NULL;
                                                                            }
                                            
                                                                        }
                                                
                                                                    } else {                                                               
                                                                        if (pCacheNode) {
                                                                           LsapFreeLsaHeap(pCacheNode);
                                                                           pCacheNode = NULL;
                                                                        }
                                                                        if (pUserID) {
                                                                            LsapFreeLsaHeap(pUserID);
                                                                            pUserID = NULL;
                                                                        }
                                                                    }
    
                                                                }
    
                                                            }
    
                                                        }
        
                                                    } else {
        
                                                        rc = ERROR_NO_USER_KEYS;
                                                    }
        
                                                    LsapFreeLsaHeap( pPubKeyInfo );
                                                }
                                            }
                                        }
    
                                        LsapFreeLsaHeap( pCryptKeyProvInfo );
                                    }
    
                                    if (rc != ERROR_SUCCESS) {
                                        LsapFreeLsaHeap( *pbHash );
                                        *pbHash = NULL;
                                    }
    
                                } else {
    
                                    //
                                    // If we failed for any reason other than running
                                    // out of memory, assume that there is no key of
                                    // use to us and return an appropriate error.
                                    //
    
                                    rc = GetLastError();
                                }
                            }

                        }                        
                    }

                }

                //
                // We want to keep trying until we're out of certificates or we get
                // an unexpected error (like out of memory).
                //

                if (rc != ERROR_SUCCESS) {

                    //
                    // Something failed, clean up anything we allocated that
                    // we were going to return.
                    //

                    if (*ProviderName) {
                        LsapFreeLsaHeap( *ProviderName );
                        *ProviderName = NULL;
                    }

                    if (*ContainerName) {
                        LsapFreeLsaHeap( *ContainerName );
                        *ContainerName = NULL;
                    }

                    if (*DisplayInfo) {
                        LsapFreeLsaHeap( *DisplayInfo );
                        *DisplayInfo = NULL;
                    }

                    if (*pbHash) {
                        LsapFreeLsaHeap( *pbHash );
                        *pbHash = NULL;
                    }

                    if (hLocalProv) {
                        CryptReleaseContext( hLocalProv, 0 );
                        hLocalProv = NULL;
                    }
                }

            } while ( pCertContext && rc != ERROR_SUCCESS && !ImpersonationError);

            if (pCertContext) {
                CertFreeCertificateContext( pCertContext );
            }

            CertCloseStore( hStore, 0 );

            if (ARGUMENT_PRESENT(hKey) && ARGUMENT_PRESENT(hProv) && (rc == ERROR_SUCCESS) && (*pbHash)) {

                *hProv = hLocalProv;
                CryptGetUserKey( *hProv, AT_KEYEXCHANGE, hKey );

            } else {

                if (hLocalProv) {
                    CryptReleaseContext( hLocalProv, 0 );
                }
            }

        } else {

            //
            // If we couldn't open the store, return
            // no user keys and continue.
            //

            rc = ERROR_NO_USER_KEYS;

        }

        RegCloseKey( hRegKey );
    }

    return( rc );
}


LONG
GetInfoFromCertHash(
    IN  PEFS_USER_INFO pEfsUserInfo,
    OUT HCRYPTKEY  * hKey       OPTIONAL,
    OUT HCRYPTPROV * hProv      OPTIONAL,
    OUT LPWSTR     * ContainerName,
    OUT LPWSTR     * ProviderName,
    OUT LPWSTR     * DisplayInfo,
    OUT PBYTE      * pbHash,
    OUT PDWORD       cbHash
    )

/*++

Routine Description:

    This routine will query the cert hash from the registry for this user and
    return the useful information from the corresponding cert.

Arguments:

    KeyPath - Supplies the fully formed path to the user's EFS key.

    hKey - Optionally returns a handle to a key context.

    hProv - Optionally returns a handle to a provider context.

    ContainerName - Returns the name of the key container for this key.

    ProviderName - Returns the name of the provider for this key.

    DisplayInfo - Returns the display information from this certificate.

    pbHash - Returns the hash found in the registry.

    cbHash - Returns the size of the hash in bytes.

Return Value:

    return-value - Description of conditions needed to return value. - or -
    None.

--*/

{
    DWORD rc;
    HKEY hRegKey = NULL;
    BOOLEAN bIsValid = TRUE;

    //
    // Initialize non-optional parameters
    //

    *ProviderName = NULL;
    *ContainerName = NULL;
    *DisplayInfo = NULL;
    *pbHash = NULL;
    *cbHash = 0;

    //
    // Initialize optional parameters
    //

    if (hKey) {
        *hKey = NULL;
    }

    if (hProv) {
        *hProv = NULL;
    }

    rc = RegOpenKeyEx(
             KEYPATHROOT,
             pEfsUserInfo->lpKeyPath,
             0,
             GENERIC_READ | KEY_SET_VALUE,
             &hRegKey
             );

    if (rc == ERROR_SUCCESS) {

        //
        // If there's a certificate thumbprint there, get it and use it.
        //

        DWORD Type;

        rc = RegQueryValueEx(
                hRegKey,
                CERT_HASH,
                NULL,
                &Type,
                NULL,
                cbHash
                );

        if (rc == ERROR_SUCCESS) {

            //
            // Query out the thumbprint, find the cert, and return the key information.
            //

            if (*pbHash = (PBYTE)LsapAllocateLsaHeap( *cbHash )) {

                rc = RegQueryValueEx(
                        hRegKey,
                        CERT_HASH,
                        NULL,
                        &Type,
                        *pbHash,
                        cbHash
                        );

                if (rc == ERROR_SUCCESS) {

                    rc = GetKeyInfoFromCertHash(
                            pEfsUserInfo,
                            *pbHash,
                            *cbHash,
                            hKey,
                            hProv,
                            ContainerName,
                            ProviderName,
                            DisplayInfo,
                            &bIsValid
                            );

                    if (((*hKey == NULL) && (pEfsUserInfo->pUserCache) && (pEfsUserInfo->pUserCache->CertValidated != CERT_VALIDATED))
                        || !bIsValid) {

                        rc = ERROR_NO_USER_KEYS;
                    }
                    if ((rc == ERROR_SUCCESS) && (*hKey == NULL)) {

                        //
                        // The key in the cache is current. Free the pbHash
                        //

                        if (*pbHash) {
                            LsapFreeLsaHeap( *pbHash );
                            *pbHash = NULL;
                        }

                    }
                }

            } else {

                rc = ERROR_NOT_ENOUGH_MEMORY;
            }

        }

        RegCloseKey( hRegKey );
    }

    if (rc != ERROR_SUCCESS) {

        //
        // Something failed, clean up anything we allocated that
        // we were going to return.
        //

        if (*ProviderName) {
            LsapFreeLsaHeap( *ProviderName );
            *ProviderName = NULL;
        }

        if (*ContainerName) {
            LsapFreeLsaHeap( *ContainerName );
            *ContainerName = NULL;
        }

        if (*DisplayInfo) {
            LsapFreeLsaHeap( *DisplayInfo );
            *DisplayInfo = NULL;
        }

        if (*pbHash) {
            LsapFreeLsaHeap( *pbHash );
            *pbHash = NULL;
        }

        if (hKey && *hKey) {
            CryptDestroyKey( *hKey );
            *hKey = NULL;
        }

        if (hProv && *hProv) {
            CryptReleaseContext( *hProv, 0 );
            *hProv = NULL;
        }

        //
        // If anything other out out of memory failed, assume that there are no keys
        // for this user.
        //

        if (rc != ERROR_NOT_ENOUGH_MEMORY) {
            rc = ERROR_NO_USER_KEYS;
        }
    }

    return( rc );
}

LONG
GetCurrentKey(
    IN  PEFS_USER_INFO pEfsUserInfo,
    OUT HCRYPTKEY    * hKey           OPTIONAL,
    OUT HCRYPTPROV   * hProv          OPTIONAL,
    OUT LPWSTR       * ContainerName,
    OUT LPWSTR       * ProviderName,
    OUT PDWORD         ProviderType,
    OUT LPWSTR       * DisplayInfo,
    OUT PBYTE        * pbHash,
    OUT PDWORD         cbHash
    )

/*++

Routine Description:

    This is the top level routine to get the user's current EFS key.
    It will do the following, in order:

    1) Open the registry and attempt to find a certificate hash for
        the user.  If it finds one, it will attempt to find this hash
        in the user's MY store and obtain all the useful information
        with it.

    2) If that fails, it will check to see if there's old key data
        (beta 1 and before) in the registry, and if it finds it, it
        will convert that key data into a certificate and return
        all the needed information.

    3) If that doesn't work, it will search the user's MY store for
        an EFS certificate.  If it finds one, it will install this as
        the user's current EFS key.

    4) If that doesn't work, it will generate a new user key from scratch.

    If that doesn't work, the operation fails.

Arguments:

    hKey - Optionally returns a handle to the user's key.

    hProv - Optionally returns a handle to the user's key's provider.

    ContainerName - Returns the name of the user's key container.

    ProviderName - Returns the name of the user's key provider.

    ProviderType - Returns the type of the provider.

    DisplayInfo - Returns the display information associated with this
        certificate.

    pbHash - Returns the hash of the user's certificate.

    cbHash - Returns the length in bytes of the certificate hash.

Return Value:

    ERROR_SUCCESS or Win32 error.

--*/

{
    DWORD rc = ERROR_SUCCESS;

    //
    // There are four places we can get key information:
    //
    // 1) There's a hash in the registry.  This is the typical
    //    case and the one we're going to try first.
    //
    // 2) Previous stuff left over from the last release of the
    //    system.
    //
    // 3) There's a cert in the user's MY store.
    //
    // 4) There's nothing.
    //

    //
    // First, look for a hash.
    //

    if (pEfsUserInfo->pUserCache) {

        if (pEfsUserInfo->pUserCache->CertValidated == CERT_VALIDATED){

            //
            // We will use the cache for current key
            //

            *ProviderName = NULL;
            *ContainerName = NULL;
            *DisplayInfo = NULL;
            *pbHash = NULL;
            *cbHash = 0;
        
            //
            // Initialize optional parameters
            //
        
            if (hKey) {
                *hKey = NULL;
            }
        
            if (hProv) {
                *hProv = NULL;
            }
        } else {

            rc = ERROR_NO_USER_KEYS;

        }

    } else {

        rc = ERROR_NO_USER_KEYS;

    }

    if (rc != ERROR_SUCCESS) {

        if (!EfspLoadUserProfile( pEfsUserInfo, TRUE )){
    
            //
            // Profile Load Failure
            //
    
            return GetLastError();
    
        }

        rc = GetInfoFromCertHash(
                     pEfsUserInfo,
                     hKey,
                     hProv,
                     ContainerName,
                     ProviderName,
                     DisplayInfo,
                     pbHash,
                     cbHash
                     );

    }

    if ((ERROR_SUCCESS == rc) && ( NULL == *pbHash)) {

        LARGE_INTEGER  TimeStamp;

        //
        // We are using the cache
        //

        ASSERT( pEfsUserInfo->pUserCache );

        //
        // Check if we need to validate the cert again
        //

        if (NT_SUCCESS( NtQuerySystemTime(&TimeStamp)) && 
            (TimeStamp.QuadPart - pEfsUserInfo->pUserCache->TimeStamp.QuadPart > CACHE_CERT_VALID_TIME )){

            //
            // It is due to check the certificate.
            // Do cert validity checking. 
            //

            LONG IsCertBeingValidated;
    
            IsCertBeingValidated = InterlockedExchange(&UserCertIsValidating, 1);

            if (IsCertBeingValidated != 1) {


                if ( EfsTimeExp(&(pEfsUserInfo->pUserCache->CertExpTime))){

                    rc = ERROR_NO_USER_KEYS;
                    pEfsUserInfo->pUserCache->CertValidated = CERT_NOT_VALIDATED;
                    EfspReleaseUserCache(pEfsUserInfo->pUserCache);
                    pEfsUserInfo->pUserCache = NULL;

                } else {


                    //
                    //  Reset the time stamp.
                    //  Do I need the sync object to protect this?
                    //  Mixing the high word and low word is not a big problem here.
                    //

                    pEfsUserInfo->pUserCache->TimeStamp = TimeStamp;

                    
                }

                if (IsCertBeingValidated != 1) {

                    InterlockedExchange(&UserCertIsValidating, IsCertBeingValidated);

                }

            }
    
        }


    }

    if (rc == ERROR_NO_USER_KEYS) {

        //
        // That didn't work.  Look for a cert in the
        // user's MY store and use it.
        //

        rc = SearchMyStoreForEFSCert(
                         pEfsUserInfo,
                         hKey,
                         hProv,
                         ContainerName,
                         ProviderName,
                         DisplayInfo,
                         pbHash,
                         cbHash
                         );

        if (rc == ERROR_NO_USER_KEYS) {

            //
            // That didn't work.  Last resort:
            // generate a new keyset for the user.
            //

            rc = GenerateUserKey(
                        pEfsUserInfo,
                        hKey,
                        hProv,
                        ContainerName,
                        ProviderName,
                        ProviderType,
                        DisplayInfo,
                        pbHash,
                        cbHash
                        );

            if (rc == ERROR_RETRY) {

                //
                // There was another thread creating keys.
                // Try one more time to get them.
                // If this fails, fail the entire attempt.
                //

                rc = GetInfoFromCertHash(
                             pEfsUserInfo,
                             hKey,
                             hProv,
                             ContainerName,
                             ProviderName,
                             DisplayInfo,
                             pbHash,
                             cbHash
                             );
            }
        }
    }

    return( rc );
}

NTSTATUS
EfspGetUserName(
    IN OUT PEFS_USER_INFO pEfsUserInfo
    )

/*++

Routine Description:

    This routine is the LSA Server worker routine for the LsaGetUserName
    API.


    WARNING:  This routine allocates memory for its output.  The caller is
    responsible for freeing this memory after use.  See description of the
    Names parameter.

Arguments:

    UserName - Receives name of the current user.

    DomainName - Optionally receives domain name of the current user.

Return Values:

    NTSTATUS - Standard Nt Result Code

        STATUS_SUCCESS - The call completed successfully and all Sids have
            been translated to names.

        STATUS_INSUFFICIENT_RESOURCES - Insufficient system resources
            such as memory to complete the call.
--*/

{
    PUNICODE_STRING AccountName = NULL;
    PUNICODE_STRING AuthorityName = NULL;
    PUNICODE_STRING ProfilePath = NULL;
    PLSAP_LOGON_SESSION LogonSession;
    NTSTATUS Status;


    //
    // Let's see if we're trying to look up the currently logged on
    // user.
    //
    //
    // TokenUserInformation from this call must be freed by calling
    // LsapFreeLsaHeap().
    //

    Status = EfspGetTokenUser( pEfsUserInfo );

    if ( NT_SUCCESS( Status ) ) {

        pEfsUserInfo->lpUserSid = ConvertSidToWideCharString( pEfsUserInfo->pTokenUser->User.Sid );

        if (pEfsUserInfo->lpUserSid) {

            //
            // If the user ID is Anonymous then there is no name and domain in the
            // logon session
            //
    
            if (RtlEqualSid(
                    pEfsUserInfo->pTokenUser->User.Sid,
                    LsapAnonymousSid
                    )) {
    
                DebugLog((DEB_WARN, "Current user is Anonymous\n"   ));
                AccountName = &WellKnownSids[LsapAnonymousSidIndex].Name;
                AuthorityName = &WellKnownSids[LsapAnonymousSidIndex].DomainName;
                ProfilePath = NULL;
    
            } else {
    
                LogonSession = LsapLocateLogonSession ( &(pEfsUserInfo->AuthId) );
    
                //
                // During setup, we may get NULL returned for the logon session.
                //

                if (LogonSession) {


                    if (LogonSession->LogonType == Network){

                        if (LogonSession->PackageSpecificAttr & LOGONSES_FLAG_NTLM_DOWNLEVEL) {

                            Status = STATUS_BAD_LOGON_SESSION_STATE;
    
                            EfsLogEntry(
                                EVENTLOG_ERROR_TYPE,
                                0,
                                EFS_NTLM_ERROR,
                                0,
                                sizeof(NTSTATUS),
                                NULL,
                                &Status
                                );
                                 
                        } else {

                            if (RPC_C_AUTHN_WINNT == SpmpGetRpcPackageId(LogonSession->CreatingPackage)){

                                //
                                // This flag is just for error code.
                                //
    
                                pEfsUserInfo->NonKerberos = TRUE;
                            }

                        }

                    }

                    if (NT_SUCCESS( Status )) {
                        //
                        // Got a match.  Get the username and domain information
                        // from the LogonId
                        //

                        AccountName   = &LogonSession->AccountName;
                        AuthorityName = &LogonSession->AuthorityName;
                        ProfilePath   = &LogonSession->ProfilePath;
                    }
                
                    LsapReleaseLogonSession( LogonSession );

                } else {
                    Status = STATUS_NO_SUCH_LOGON_SESSION;
                }
            }
    
    
            if (Status == STATUS_SUCCESS) {
    
    
                pEfsUserInfo->lpUserName = (PWSTR)LsapAllocateLsaHeap(AccountName->Length + sizeof(UNICODE_NULL));
    
                if (pEfsUserInfo->lpUserName != NULL) {
    
                    memcpy( pEfsUserInfo->lpUserName, AccountName->Buffer, AccountName->Length );
                    (pEfsUserInfo->lpUserName)[AccountName->Length/sizeof(WCHAR)] = UNICODE_NULL;
    
    
                    pEfsUserInfo->lpDomainName = (PWSTR)LsapAllocateLsaHeap(AuthorityName->Length + sizeof(UNICODE_NULL));
    
                    if (pEfsUserInfo->lpDomainName != NULL) {
    
                        memcpy( pEfsUserInfo->lpDomainName, AuthorityName->Buffer, AuthorityName->Length );
                        (pEfsUserInfo->lpDomainName)[AuthorityName->Length/sizeof(WCHAR)] = UNICODE_NULL;
    
                    } else {
    
                        Status = STATUS_INSUFFICIENT_RESOURCES;
                    }
    
                    if ((ProfilePath != NULL) && (ProfilePath->Length != 0)) {
    
                        pEfsUserInfo->lpProfilePath = (PWSTR)LsapAllocateLsaHeap(ProfilePath->Length + sizeof(UNICODE_NULL));
    
                        if (pEfsUserInfo->lpProfilePath != NULL) {
    
                            memcpy( pEfsUserInfo->lpProfilePath, ProfilePath->Buffer, ProfilePath->Length );
                            (pEfsUserInfo->lpProfilePath)[ProfilePath->Length/sizeof(WCHAR)] = UNICODE_NULL;
    
                        } else {
    
                            Status = STATUS_INSUFFICIENT_RESOURCES;
                        }
                    }

                    pEfsUserInfo->lpKeyPath = ConstructKeyPath(pEfsUserInfo->lpUserSid);
                    if ( pEfsUserInfo->lpKeyPath == NULL ) {

                        Status = STATUS_INSUFFICIENT_RESOURCES;

                    }
    
                } else {
    
                    Status = STATUS_INSUFFICIENT_RESOURCES;
                }
            }
        } else {

            Status = STATUS_INSUFFICIENT_RESOURCES;

        }
    } 

    if (!NT_SUCCESS( Status )) {

        //
        // Something failed, clean up what we were going to return
        //

        EfspFreeUserInfo( pEfsUserInfo );
        memset( pEfsUserInfo, 0, sizeof( EFS_USER_INFO ));

    }

    return(Status);
}

DWORD
EfspReplaceUserKeyInformation(
    PEFS_USER_INFO pEfsUserInfo
    )

/*++

Routine Description:

    Forces the regeneration of the user's EFS key.

Arguments:

    None.

Return Value:

    Win32 error or ERROR_SUCCESS

--*/

{
    LPWSTR ProviderName;
    LPWSTR ContainerName;
    LPWSTR DisplayInfo;
    DWORD ProviderType;
    DWORD cbHash;
    PBYTE pbHash;
    DWORD rc;

    if (pEfsUserInfo->pUserCache) {

        //
        // We are going to create a new key. The current cache is going away.
        // We will insert a new cache node in the header.
        //

        EfspReleaseUserCache(pEfsUserInfo->pUserCache);
        pEfsUserInfo->pUserCache = NULL;

    }

    rc = RegDeleteKey(
             KEYPATHROOT,
             pEfsUserInfo->lpKeyPath
             );

    if (rc == ERROR_SUCCESS) {

        rc = GenerateUserKey(
                    pEfsUserInfo,
                    NULL,
                    NULL,
                    &ContainerName,
                    &ProviderName,
                    &ProviderType,
                    &DisplayInfo,
                    &pbHash,
                    &cbHash
                    );

        if (rc == ERROR_SUCCESS) {

            if (ContainerName) {
                LsapFreeLsaHeap( ContainerName );
            }
            if (ProviderName) {
                LsapFreeLsaHeap( ProviderName );
            }
            if (DisplayInfo) {
                LsapFreeLsaHeap( DisplayInfo );
            }
            if (pbHash) {
                LsapFreeLsaHeap( pbHash );
            }
        }
    }

    return( rc );
}

DWORD
EfspInstallCertAsUserKey(
    PEFS_USER_INFO pEfsUserInfo,
    PENCRYPTION_CERTIFICATE pEncryptionCertificate
    )
{
    //
    // Find the passed certificate in the user's MY store.
    // If it's not there, we don't use the cert.
    //

    DWORD rc = ERROR_SUCCESS;
    PCCERT_CONTEXT pCertContext = NULL;
    DWORD cbHash  = 0;
    PBYTE pbHash = NULL;
    BOOLEAN bIsValid;

    //
    // If this fails, there's no cert that matches.
    //

    __try{

        pCertContext = CertCreateCertificateContext(
                          pEncryptionCertificate->pCertBlob->dwCertEncodingType,
                          pEncryptionCertificate->pCertBlob->pbData,
                          pEncryptionCertificate->pCertBlob->cbData
                          );

        if (pCertContext) {

            if (CertGetCertificateContextProperty(
                    pCertContext,
                    CERT_SHA1_HASH_PROP_ID,
                    NULL,
                    &cbHash
                    )) {

                SafeAllocaAllocate(pbHash, cbHash);

                if (pbHash) {

                    if (CertGetCertificateContextProperty(
                                pCertContext,
                                CERT_SHA1_HASH_PROP_ID,
                                pbHash,
                                &cbHash
                                )) {

                        HCRYPTKEY hKey;
                        HCRYPTPROV hProv;
                        LPWSTR ContainerName;
                        LPWSTR ProviderName;
                        LPWSTR DisplayInfo;

                        if (pEfsUserInfo->pUserCache) {

                            //
                            // We are going to create a new key. The current cache is going away.
                            // We will insert a new cache node in the header.
                            //

                            EfspReleaseUserCache(pEfsUserInfo->pUserCache);
                            pEfsUserInfo->pUserCache = NULL;

                        }

                        rc = GetKeyInfoFromCertHash(
                                 pEfsUserInfo,
                                 pbHash,
                                 cbHash,
                                 &hKey,
                                 &hProv,
                                 &ContainerName,
                                 &ProviderName,
                                 &DisplayInfo,
                                 &bIsValid
                                 );

                        if (ERROR_SUCCESS == rc) {

                            //
                            // We don't care about any of the stuff that came back,
                            // all we care about is that it was all found, meaning
                            // that the key exists and can be used.  Now that we know
                            // that, we can jam the hash into the registry.
                            //

                            HKEY KeyHandle;
                            DWORD Disposition;

                            rc = RegCreateKeyEx(
                                       KEYPATHROOT,
                                       pEfsUserInfo->lpKeyPath,
                                       0,
                                       TEXT("REG_SZ"),
                                       REG_OPTION_NON_VOLATILE,
                                       KEY_READ | KEY_WRITE,
                                       NULL,
                                       &KeyHandle,
                                       &Disposition    // address of disposition value buffer
                                       );

                            if (ERROR_SUCCESS == rc) {

                                rc = RegSetValueEx(
                                          KeyHandle,  // handle of key to set value for
                                          CERT_HASH,
                                          0,
                                          REG_BINARY,
                                          pbHash,
                                          cbHash
                                          );

                                RegCloseKey( KeyHandle );
                            }

                            if (hKey) {

                                //
                                //  hKey not NULL means we have not put the data in the cache.
                                //

                                CryptDestroyKey( hKey );
                                CryptReleaseContext( hProv, 0 );
                                LsapFreeLsaHeap( ContainerName );
                                LsapFreeLsaHeap( ProviderName );
                                LsapFreeLsaHeap( DisplayInfo );

                            }
                        }

                    } else {

                        rc = GetLastError();
                    }

                    SafeAllocaFree( pbHash );
                    pbHash = NULL;

                } else {

                    rc = ERROR_NOT_ENOUGH_MEMORY;
                }

            } else {

                rc = GetLastError();
            }

            CertFreeCertificateContext( pCertContext );

        } else {

            rc = GetLastError();
        }
    } __except (EXCEPTION_EXECUTE_HANDLER) {

        rc = ERROR_INVALID_PARAMETER;

        if (pCertContext) {
            CertFreeCertificateContext( pCertContext );
        }

        if (pbHash) {
            SafeAllocaFree( pbHash );
        }

        EfspLogAttack(pEfsUserInfo, CORRUPT_DATA_8);

    }



    return( rc );
}

BOOLEAN
CurrentHashOK(
    IN PEFS_USER_INFO pEfsUserInfo, 
    IN PBYTE          pbHash, 
    IN DWORD          cbHash,
    OUT DWORD         *dFlag
    )

/*++

Routine Description:

    See if the value pbHash is already in the user's key. If not, try to see if we can add it back.
    
Arguments:

    pEfsUserInfo -- User Info
    
    pbHash -- Hash value
    
    cbHash -- Hash length
    
    dFlag  -- Cert Flag to indicate if the cert has been added to the LM intermediate store

Return Value:

    TRUE if the pbHash found or added successfully
    
--*/
{

    DWORD rc;
    BOOLEAN b = FALSE;
    HKEY hRegKey = NULL;
    PBYTE         pbLocalHash; 
    DWORD         cbLocalHash;

    rc = RegOpenKeyEx(
             KEYPATHROOT,
             pEfsUserInfo->lpKeyPath,
             0,
             GENERIC_READ,
             &hRegKey
             );

    *dFlag = 0;

    if (rc == ERROR_SUCCESS) {

        //
        // If there's a certificate thumbprint there, get it and use it.
        //

        DWORD Type;

        rc = RegQueryValueEx(
                hRegKey,
                CERT_HASH,
                NULL,
                &Type,
                NULL,
                &cbLocalHash
                );

        if (rc == ERROR_SUCCESS) {

            if (cbLocalHash == cbHash) {
                //
                // Query out the thumbprint, find the cert, and return the key information.
                //

                SafeAllocaAllocate(pbLocalHash, cbLocalHash);

                if (pbLocalHash != NULL) {
    
                    rc = RegQueryValueEx(
                            hRegKey,
                            CERT_HASH,
                            NULL,
                            &Type,
                            pbLocalHash,
                            &cbLocalHash
                            );
    
                    if (rc == ERROR_SUCCESS) {

                        //
                        //  Check if the hash value matches
                        //

                        if (RtlEqualMemory( pbLocalHash, pbHash, cbHash)){

                            b = TRUE;
                            cbLocalHash = sizeof (DWORD);
                            if (RegQueryValueEx(
                                    hRegKey,
                                    CERT_FLAG,
                                    NULL,
                                    &Type,
                                    (LPBYTE) dFlag,
                                    &cbLocalHash
                                    )){
                                //
                                // Make sure dFlag set to 0 if error occurs. This may not be needed.
                                //

                                *dFlag = 0;
                            }
                        }
                    }

                    SafeAllocaFree(pbLocalHash);
                }
            } 
        }

        RegCloseKey( hRegKey );

    } 
         
    if (rc != ERROR_SUCCESS) {

        //
        // Let's see if we can create one
        //

        DWORD Disposition = 0;
    
        //
        // Assume that there's no current EFS information
        // for this guy.  Create the registry key.
        //
    
        rc = RegCreateKeyEx(
                 KEYPATHROOT,
                 pEfsUserInfo->lpKeyPath,
                 0,
                 TEXT("REG_SZ"),
                 REG_OPTION_NON_VOLATILE,
                 KEY_ALL_ACCESS,
                 NULL,
                 &hRegKey,
                 &Disposition    // address of disposition value buffer
                 );
        
        if (rc == ERROR_SUCCESS) {

            rc = RegSetValueEx(
                    hRegKey,  // handle of key to set value for
                    CERT_HASH,
                    0,
                    REG_BINARY,
                    pbHash,
                    cbHash
                    );

            if (rc == ERROR_SUCCESS) {

                b = TRUE;

            }

            RegCloseKey( hRegKey );
        }
    }

    return b;
}

DWORD
GetCurrentHash(
     IN  PEFS_USER_INFO pEfsUserInfo, 
     OUT PBYTE          *pbHash, 
     OUT DWORD          *cbHash
     )
{
    HKEY hRegKey = NULL;
    DWORD rc;

    ASSERT(pbHash);
    ASSERT(cbHash);

    *pbHash = NULL;

    rc = RegOpenKeyEx(
             KEYPATHROOT,
             pEfsUserInfo->lpKeyPath,
             0,
             GENERIC_READ,
             &hRegKey
             );

    if (rc == ERROR_SUCCESS) {

        DWORD Type;

        rc = RegQueryValueEx(
                hRegKey,
                CERT_HASH,
                NULL,
                &Type,
                NULL,
                cbHash
                );

        if (rc == ERROR_SUCCESS) {
    
            if (*pbHash = (PBYTE)LsapAllocateLsaHeap( *cbHash )) {
            
                rc = RegQueryValueEx(
                        hRegKey,
                        CERT_HASH,
                        NULL,
                        &Type,
                        *pbHash,
                        cbHash
                        );
            
                if (rc != ERROR_SUCCESS) {

                    LsapFreeLsaHeap(*pbHash);
                    *pbHash = NULL;

                }
            } else {

                rc = GetLastError();

            }
        }

        RegCloseKey( hRegKey );

    }

    return rc;

}


BOOLEAN    
EfspInitUserCacheNode(
     IN OUT PUSER_CACHE pCacheNode,
     IN PSID pUserID,
     IN PBYTE pbHash,
     IN DWORD cbHash,
     IN LPWSTR ContainerName,
     IN LPWSTR ProviderName,
     IN LPWSTR DisplayInformation,
     IN LPFILETIME CertExpTime,
     IN HCRYPTKEY hKey,
     IN HCRYPTPROV hProv,
     IN LUID *AuthId,
     IN LONG CertValidated
     )
/*++

Routine Description:

    Initialize the cache node and insert it into the list.
        
Arguments:

     pCacheNode -- Node to be inserted

     pUserID    -- User SID

     pbHash     -- User Cert Hash

     cbHash     -- Length of the hash data

     ContainerName -- Container name

     ProviderName -- Provider name

     DisplayInformation -- Display information

     CertExpTime -- Certificate expiration time

     hKey       -- User Key

     hProv      -- Provider handle
     
     AuthId     -- Authentication ID

     CertValidated -- Cert validation info

Return Value:

    TRUE if successful
    
--*/
{
    if (!pCacheNode) {
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }
    pCacheNode->UserId = pUserID;
    pCacheNode->pbHash = pbHash;
    pCacheNode->cbHash = cbHash;
    pCacheNode->ContainerName = ContainerName;
    pCacheNode->ProviderName = ProviderName;
    pCacheNode->DisplayInformation = DisplayInformation;
    pCacheNode->CertExpTime = *CertExpTime;
    pCacheNode->hUserKey = hKey;
    pCacheNode->hProv = hProv;
    pCacheNode->CertValidated = CertValidated; 
    pCacheNode->UseRefCount = 1; // The caller's hold on this node
    pCacheNode->StopUseCount = 0;
    if (AuthId) {

        //
        // pCacheNode->AuthId would be 0 if AuthId == NULL. Init in the caller.
        //

        pCacheNode->AuthId = *AuthId;
    }
    
    return (EfspAddUserCache(pCacheNode));
}

BOOL
EfsGetBasicConstraintExt(
   IN OUT PCERT_EXTENSION *basicRestraint
   )
{

    BOOL bRet = TRUE;
    CERT_BASIC_CONSTRAINTS2_INFO CertConstraints2;
    DWORD rc = ERROR_SUCCESS;

    RtlZeroMemory( &CertConstraints2, sizeof(CERT_BASIC_CONSTRAINTS2_INFO) );

    *basicRestraint = (PCERT_EXTENSION) LsapAllocateLsaHeap(sizeof(CERT_EXTENSION));
    if (*basicRestraint) {

        bRet = CryptEncodeObject(
                   X509_ASN_ENCODING,
                   X509_BASIC_CONSTRAINTS2,
                   &CertConstraints2,
                   NULL,
                   &((*basicRestraint)->Value.cbData)
                   );

        if (bRet) {

            (*basicRestraint)->Value.pbData = (PBYTE) LsapAllocateLsaHeap( (*basicRestraint)->Value.cbData );
            if ((*basicRestraint)->Value.pbData) {

                bRet = CryptEncodeObject(
                           X509_ASN_ENCODING,
                           X509_BASIC_CONSTRAINTS2,
                           &CertConstraints2,
                           (*basicRestraint)->Value.pbData,
                           &((*basicRestraint)->Value.cbData)
                           );

                if (bRet) {
                    (*basicRestraint)->pszObjId = szOID_BASIC_CONSTRAINTS2;
                    (*basicRestraint)->fCritical = FALSE;
                } else {
        
                    rc = GetLastError();
                    LsapFreeLsaHeap((*basicRestraint)->Value.pbData);
                    SetLastError(rc);
        
                }
            } else {
                bRet = FALSE;
                SetLastError(ERROR_NOT_ENOUGH_MEMORY);
            }
        }

        if (!bRet) {

            rc = GetLastError();
            LsapFreeLsaHeap(*basicRestraint);
            SetLastError(rc);
            *basicRestraint = NULL;

        }

    } else {
        bRet = FALSE;
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
    }

    return bRet;

}

BOOL
EfsGetAltNameExt(
    IN OUT PCERT_EXTENSION *altNameExt, 
    IN LPWSTR UPNName
    )
{
    BOOL bRet = TRUE;
    DWORD cbData = 0;
    DWORD rc = ERROR_SUCCESS;
    CERT_NAME_VALUE prnName;
    CERT_OTHER_NAME certOtherName;
    CERT_ALT_NAME_ENTRY altName;
    CERT_ALT_NAME_INFO nameInfo;

    *altNameExt = (PCERT_EXTENSION) LsapAllocateLsaHeap(sizeof(CERT_EXTENSION));
    if (*altNameExt) {
        prnName.dwValueType = CERT_RDN_UTF8_STRING;
        prnName.Value.cbData = (wcslen(UPNName) + 1) * sizeof(WCHAR);
        prnName.Value.pbData = (BYTE *)UPNName;
    
        bRet = CryptEncodeObject(
                   X509_ASN_ENCODING,
                   X509_UNICODE_ANY_STRING,
                   &prnName,
                   NULL,
                   &certOtherName.Value.cbData
                   );
        if (bRet) {

            SafeAllocaAllocate(certOtherName.Value.pbData,  certOtherName.Value.cbData);

            if (certOtherName.Value.pbData) {
    
                bRet = CryptEncodeObject(
                           X509_ASN_ENCODING,
                           X509_UNICODE_ANY_STRING,
                           &prnName,
                           certOtherName.Value.pbData,
                           &certOtherName.Value.cbData
                           );
    
                if (bRet) {
    
                    altName.dwAltNameChoice = CERT_ALT_NAME_OTHER_NAME;
                    certOtherName.pszObjId = szOID_NT_PRINCIPAL_NAME;
                    altName.pOtherName = &certOtherName;
                    nameInfo.cAltEntry = 1;
                    nameInfo.rgAltEntry = &altName;
    
                    bRet = CryptEncodeObject(
                               X509_ASN_ENCODING,
                               szOID_SUBJECT_ALT_NAME,
                               &nameInfo,
                               NULL,
                               &((*altNameExt)->Value.cbData)
                               );
                    if (bRet) {

                        (*altNameExt)->Value.pbData = (PBYTE) LsapAllocateLsaHeap( (*altNameExt)->Value.cbData );
                        if ((*altNameExt)->Value.pbData) {

                            bRet = CryptEncodeObject(
                                       X509_ASN_ENCODING,
                                       szOID_SUBJECT_ALT_NAME,
                                       &nameInfo,
                                       (*altNameExt)->Value.pbData,
                                       &((*altNameExt)->Value.cbData)
                                       );
                            if (bRet) {
                                (*altNameExt)->pszObjId = szOID_SUBJECT_ALT_NAME2;
                                (*altNameExt)->fCritical = FALSE;
                            } else {

                                DWORD rc = GetLastError();
                                LsapFreeLsaHeap((*altNameExt)->Value.pbData);
                                SetLastError(rc);

                            }

                        } else {

                            bRet = FALSE;
                            SetLastError(ERROR_NOT_ENOUGH_MEMORY);
                        }
                    }
                }

                rc = GetLastError();
                SafeAllocaFree(certOtherName.Value.pbData);
                SetLastError(rc);
                
            } else {
                bRet = FALSE;
                SetLastError(ERROR_NOT_ENOUGH_MEMORY);
            }
        }

        if (!bRet) {

            GetLastError();
            LsapFreeLsaHeap(*altNameExt);
            SetLastError(rc);
            *altNameExt = NULL;

        }

    } else {
        bRet = FALSE;
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
    }

    return bRet;

}

VOID
EfsMarkCertAddedToStore(
    IN PEFS_USER_INFO pEfsUserInfo,
    IN DWORD StoreId
    )
/*++

Routine Description:

    Mark in the registry that we have add the cert to the LM store.
        
Arguments:

    pEfsUserInfo -- User Info
    
Return Value:

    None.
    
--*/
{
    HKEY hRegKey = NULL;
    DWORD rc;

    rc = RegOpenKeyEx(
             KEYPATHROOT,
             pEfsUserInfo->lpKeyPath,
             0,
             GENERIC_READ | GENERIC_WRITE,
             &hRegKey
             );

    if (rc == ERROR_SUCCESS) {

        RegSetValueEx(
                hRegKey,  // handle of key to set value for
                CERT_FLAG,
                0,
                REG_DWORD,
                (LPBYTE)&StoreId,
                sizeof (DWORD)
                );

        RegCloseKey( hRegKey );
    }

    return;
}



DWORD
EfsTryRenewCert(
    IN PEFS_USER_INFO pEfsUserInfo,
    IN PCCERT_CONTEXT pCertContext,
    OUT PCCERT_CONTEXT *pNewCertContext
    )

/*++

Routine Description:

    This routine takes a cert context. Will try to see if a replacement cert is ready. We will do no more than 
    five level chase and does not check to see if the private key is available.
    
    If YES, it verifies the cert is good for EFS and refresh the EFS current cert hash. 

Arguments:

    pEfsUserInfo - User Information
    
    pCertContext - Old EFS cert
    
    CurrentBadCert - If TRUE, current cert hash will be set to a bogus one so that next GetCurrentKey will do
                     a research for performance.
    
    pNewCertContext  - *pNewCertContext non-zero if cert is renewed.


Return Value:

    ERROR_SUCCESS - No Error.
    
--*/

{
    PCCERT_CONTEXT pTmpCertContext = NULL;
    PCCERT_CONTEXT pNewTmpCertContext = NULL;
    DWORD          rc = ERROR_SUCCESS;
    PBYTE          newCertHash[AutoEnrollChainLevel];
    DWORD          cbNewCertHash[AutoEnrollChainLevel];
    DWORD          newHashes;
    DWORD          goodHashNo = 0;
    DWORD          ii;
    BOOL           CircleRef = FALSE;
    BOOL           HasProperty;


    *pNewCertContext = NULL;
    newHashes = 0;
    RtlZeroMemory(newCertHash, sizeof( newCertHash ));
    RtlZeroMemory(cbNewCertHash, sizeof( cbNewCertHash ));
    pTmpCertContext = pCertContext;

    while (newHashes < AutoEnrollChainLevel) {

        //
        // The hash has a length of 20 bytes. If this changes in the future,
        // the code will not have problem at all. Set init value to 32 is faster than
        // than set to NULL and adjust later.
        //

        cbNewCertHash[newHashes] = 32; 
        SafeAllocaAllocate(newCertHash[newHashes], cbNewCertHash[newHashes]);
        HasProperty = FALSE;

        if (newCertHash[newHashes] != NULL) {
            HasProperty = CertGetCertificateContextProperty(
                             pTmpCertContext,
                             CERT_RENEWAL_PROP_ID,
                             newCertHash[newHashes],
                             &cbNewCertHash[newHashes]
                             );
            if (!HasProperty) {
    
                if (ERROR_MORE_DATA == (rc = GetLastError())) {
    
                    SafeAllocaFree(newCertHash[newHashes]);
                    SafeAllocaAllocate(newCertHash[newHashes], cbNewCertHash[newHashes]);
    
                    if (newCertHash[newHashes] != NULL) {
                        HasProperty = CertGetCertificateContextProperty(
                                         pTmpCertContext,
                                         CERT_RENEWAL_PROP_ID,
                                         newCertHash[newHashes],
                                         &cbNewCertHash[newHashes]
                                         );
                        if (!HasProperty) {
                            rc = GetLastError();
                        }
                    }
                }
            }
        }


        if (HasProperty){
            
            //
            // Now make sure the new cert is good for EFS.
            //

            pNewTmpCertContext = GetCertContextFromCertHash(
                                  newCertHash[newHashes],
                                  cbNewCertHash[newHashes],
                                  CERT_SYSTEM_STORE_CURRENT_USER,
                                  0
                                  );

            if (pNewTmpCertContext) {

                //
                //  We got the cert. Let's see if the cert is good for EFS.
                //  EFSOid is already checked in GetCertContextFromCertHash.
                //


                if ( !CertVerifyTimeValidity(
                        NULL,
                        pNewTmpCertContext->pCertInfo
                        )){

                    ii = newHashes;
                    while (ii > 0) {

                        if (cbNewCertHash[ii-1] == cbNewCertHash[newHashes]) {
                
                            if (memcmp(newCertHash[ii-1], newCertHash[newHashes], cbNewCertHash[ii-1]) == 0) {
                
                                //
                                // Circular reference. Break to avoid dead lock. This is unlikely.
                                // Malicious user could cause this.
                                //

                                if (*pNewCertContext) {
                                    CertFreeCertificateContext( *pNewCertContext );
                                }
        
                                CertFreeCertificateContext( pNewTmpCertContext );
                                if ((pTmpCertContext != pCertContext) && (pTmpCertContext != *pNewCertContext) ) {
        
                                    //
                                    // Free the old cert context. 
                                    //
        
                                    CertFreeCertificateContext( pTmpCertContext );
                                    pTmpCertContext = NULL;
                                }
                                *pNewCertContext = NULL;
                                ii = 0;
                                while (ii <= newHashes) {
                                    if (newCertHash[ii]) {
                                        SafeAllocaFree(newCertHash[ii]);
                                        newCertHash[ii] = NULL;
                                    }
                                    ii++;
                                }
                                CircleRef = TRUE;
                                newHashes = 0;
                                break;
                
                            }
                        }
                        ii--;
                    }

                    if (CircleRef) {
                        break;
                    }

                    goodHashNo = newHashes; 
                    newHashes++;
                    if (*pNewCertContext) {
                        if (*pNewCertContext == pTmpCertContext) {
                            pTmpCertContext = NULL;
                        }
                        CertFreeCertificateContext( *pNewCertContext );
                    }
                    *pNewCertContext = pNewTmpCertContext;


                } else {

                    newHashes++;
                    rc = CERT_E_EXPIRED;

                }

                if (pTmpCertContext && (pTmpCertContext != pCertContext) && (pTmpCertContext != *pNewCertContext)) {

                    //
                    // Free the old cert context. 
                    //

                    CertFreeCertificateContext( pTmpCertContext );
                }
                pTmpCertContext = pNewTmpCertContext;
                pNewTmpCertContext = NULL;
                

            } else {

                //
                // The cert pointed is non-existing. Take the last good one.
                //

                rc = GetLastError();
                break; 


            }
            
        } else {

            if (newCertHash[newHashes] == NULL) {
                rc = ERROR_NOT_ENOUGH_MEMORY;
            } else {
                SafeAllocaFree(newCertHash[newHashes]);
                newCertHash[newHashes] = NULL;
            }
    
            //
            // Chain ends. This could be a normal path.
            //

            break; 
    
        }
    }

    if (pTmpCertContext && (pTmpCertContext != pCertContext) && (pTmpCertContext != *pNewCertContext)) {

        //
        // Free the old cert context. 
        //

        CertFreeCertificateContext( pTmpCertContext );
        pTmpCertContext = NULL;
    }

    if (*pNewCertContext) {

        //
        // We got a good cert. Reset the error.
        //

        rc = ERROR_SUCCESS;

        //
        // Now let's update the current EFS cert
        //

        HKEY KeyHandle;
        DWORD Disposition;

        rc = RegCreateKeyEx(
                   KEYPATHROOT,
                   pEfsUserInfo->lpKeyPath,
                   0,
                   TEXT("REG_SZ"),
                   REG_OPTION_NON_VOLATILE,
                   KEY_READ | KEY_WRITE,
                   NULL,
                   &KeyHandle,
                   &Disposition    // address of disposition value buffer
                   );

        if (ERROR_SUCCESS == rc) {

            rc = RegSetValueEx(
                      KeyHandle,  // handle of key to set value for
                      CERT_HASH,
                      0,
                      REG_BINARY,
                      newCertHash[goodHashNo],
                      cbNewCertHash[goodHashNo]
                      );

            RegCloseKey( KeyHandle );
        }
    }

    if (ERROR_SUCCESS != rc) {

        //
        // Can't write the new hash.
        //

        if (*pNewCertContext) {
            CertFreeCertificateContext( *pNewCertContext );
            *pNewCertContext = NULL;
        }
        
    }

    ii = 0;
    while (ii < AutoEnrollChainLevel) {
        if (newCertHash[ii]) {
            SafeAllocaFree(newCertHash[ii]);
        }
        ii++;
    }

    return rc;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\base\lsa\server\sputil.cxx ===
//+-----------------------------------------------------------------------
//
// Microsoft Windows
//
// Copyright (c) Microsoft Corporation 1991 - 1992
//
// File:        sputil.c
//
// Contents:    Security package utility functions.  Functions for maintaining
//              the list of available packages are kept here.
//
//
//
// History:      9 Dec 91,  richardw    Created
//              11 Mar 92,  RichardW    Recreated, reworked, etc.
//              21 Mar 94,  MikeSw      Removed RPC stubs
//
//------------------------------------------------------------------------

#include <lsapch.hxx>

extern "C"
{
#include "sesmgr.h"
#include <stddef.h>
}

//
// Global variables and structures:
//


//
// Debug stuff:
//
#if DBG
ULONG       NoUnload = 0;
#endif

extern WCHAR szLsaPath[] ;

PDLL_BINDING *  pPackageDllList;
ULONG           PackageDllCount;
ULONG           PackageDllTotal;
PLSAP_SECURITY_PACKAGE *   pPackageControlList;
ULONG           PackageControlCount;
ULONG           PackageControlTotal;

#define INITIAL_PACKAGE_DLL_SIZE        8
#define INITIAL_PACKAGE_CONTROL_SIZE    8


#define PKG_LIST_LOCKS_MAX   4
// insure power of 2.
C_ASSERT( (PKG_LIST_LOCKS_MAX % 2) == 0 );

ULONG PackageListLockCount;
RTL_RESOURCE PackageListLock[ PKG_LIST_LOCKS_MAX ];

#define ReadLockPackageList()   \
    RtlAcquireResourceShared(&PackageListLock[NtCurrentTeb()->IdealProcessor & (PackageListLockCount-1)] ,TRUE)

#define ReadUnlockPackageList() \
    RtlReleaseResource(&PackageListLock[NtCurrentTeb()->IdealProcessor & (PackageListLockCount-1)])

#define WriteLockPackageList()  \
{                               \
    ULONG LockIndex;            \
                                \
    for( LockIndex = 0 ; LockIndex < PackageListLockCount ; LockIndex++ )   \
    {                                                                       \
        RtlAcquireResourceExclusive(&PackageListLock[ LockIndex ] ,TRUE);   \
    }                           \
}                               \

#define WriteUnlockPackageList()    \
{                                   \
    ULONG LockIndex;                \
                                    \
    for( LockIndex = 0 ; LockIndex < PackageListLockCount ; LockIndex++ )   \
    {                                                                       \
        RtlReleaseResource( &PackageListLock[ LockIndex ]);                 \
    }                                                                       \
}


PDLL_BINDING
SpmpFindDll(
    PWSTR   DllName);



//+---------------------------------------------------------------------------
//
//  Function:   BindOldPackage
//
//  Synopsis:   Loads an old style authentication package DLL
//
//  Arguments:  [hDll]   --
//              [pTable] --
//
//  History:    11-17-95   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
BOOL
BindOldPackage( HANDLE          hDll,
                PSECPKG_FUNCTION_TABLE  pTable)
{

    pTable->InitializePackage = (PLSA_AP_INITIALIZE_PACKAGE)
                        GetProcAddress((HMODULE)hDll, LSA_AP_NAME_INITIALIZE_PACKAGE);

    if (pTable->InitializePackage == NULL)
    {
        return(FALSE);
    }

    //
    // The package needs to support one of LogonUser, LogonUserEx, or LogonUserEx2
    pTable->LogonUserEx2 = (PLSA_AP_LOGON_USER_EX2)
                        GetProcAddress((HMODULE)hDll, LSA_AP_NAME_LOGON_USER_EX2);

    //
    // If this is NULL, then the package should have exported a LsaApLogonUser or Ex
    //

    if (pTable->LogonUserEx2 == NULL)
    {
        pTable->LogonUserEx = (PLSA_AP_LOGON_USER_EX)
                        GetProcAddress((HMODULE)hDll, LSA_AP_NAME_LOGON_USER_EX);
        if (pTable->LogonUserEx == NULL)
        {
            pTable->LogonUser = (PLSA_AP_LOGON_USER)
                            GetProcAddress((HMODULE)hDll, LSA_AP_NAME_LOGON_USER);
            if (pTable->LogonUser == NULL)
            {
                return(FALSE);
            }
        }
        }

    pTable->CallPackage = (PLSA_AP_CALL_PACKAGE)
                        GetProcAddress((HMODULE)hDll, LSA_AP_NAME_CALL_PACKAGE);
    if (pTable->CallPackage == NULL)
    {
        return(FALSE);
    }

    //
    // CallPackageUntrusted is optional
    //

    pTable->CallPackageUntrusted = (PLSA_AP_CALL_PACKAGE_UNTRUSTED)
                        GetProcAddress((HMODULE)hDll, LSA_AP_NAME_CALL_PACKAGE_UNTRUSTED);

    pTable->CallPackagePassthrough = (PLSA_AP_CALL_PACKAGE_PASSTHROUGH)
                        GetProcAddress((HMODULE)hDll, LSA_AP_NAME_CALL_PACKAGE_PASSTHROUGH);

    pTable->LogonTerminated = (PLSA_AP_LOGON_TERMINATED)
                        GetProcAddress((HMODULE)hDll, LSA_AP_NAME_LOGON_TERMINATED);
    if (pTable->LogonTerminated == NULL)
    {
        return(FALSE);
    }

    //
    // If the package supports accept credentials, great. Otherwise
    // just leave this blank.
    //

    pTable->AcceptCredentials = (SpAcceptCredentialsFn *)
                        GetProcAddress((HMODULE) hDll,  SP_ACCEPT_CREDENTIALS_NAME);

    return(TRUE);
}



//+-------------------------------------------------------------------------
//
//  Function:   WLsaEnumeratePackages()
//
//  Synopsis:   Worker function for LsaEnumeratePackages
//
//  Effects:    Fills in an array of SecPkgInfo structures
//
//  Arguments:  pcEntries - receives the number of packages
//
//              pPackages - receives all the SecPkgInfo structures
//
//  Requires:
//
//  Returns:    success
//
//  Notes:
//
//--------------------------------------------------------------------------

static LPWSTR szInvalidPackage = L"Invalid Package";

NTSTATUS
WLsaEnumeratePackages(  PULONG              pcEntries,
                        PSecPkgInfo *       pPackages)
{
    unsigned int    i;
    PSession        pSession = GetCurrentSession();
    ULONG           cbSize;
    PSecPkgInfo     pInfo;
    PSecPkgInfo     pLocalInfo = NULL, pClientInfo = NULL;
    LONG            cbMark, cbLength;
    NTSTATUS         scRet;
    PLSAP_SECURITY_PACKAGE     pPackage;
    PLSA_CALL_INFO CallInfo ;
    ULONG Filter ;

    Filter = SP_ORDINAL_GETINFO ;

    CallInfo = LsapGetCurrentCall();

    if ( CallInfo->CallInfo.Attributes & SECPKG_CALL_WOWCLIENT )
    {
        Filter |= SP_ITERATE_FILTER_WOW ;
    }

    cbSize = sizeof(SecPkgInfo) * lsState.cPackages;

    SafeAllocaAllocate(pInfo, cbSize);

    if (!pInfo)
    {
        return(SEC_E_INSUFFICIENT_MEMORY);
    }

    pPackage = SpmpIteratePackagesByRequest( NULL, Filter );

    i = 0;

    while (pPackage)
    {
        SetCurrentPackageId( pPackage->dwPackageID );

        __try
        {
            (VOID) pPackage->FunctionTable.GetInfo( &pInfo[i] );
            cbSize += (wcslen(pInfo[i].Name) + 1) * sizeof(WCHAR);
            cbSize += (wcslen(pInfo[i].Comment) + 1) * sizeof(WCHAR);
        }
        __except (SP_EXCEPTION)
        {
            SPException( GetExceptionCode(), pPackage->dwPackageID );

            //
            // Catch it, kill the package, proceed...
            //
        }

        pPackage = SpmpIteratePackagesByRequest( pPackage,
                                                 Filter );
        i ++;

    }

    *pcEntries = i;

    SafeAllocaAllocate(pLocalInfo, cbSize);

    if (!pLocalInfo)
    {
        scRet = SEC_E_INSUFFICIENT_MEMORY;
        goto Cleanup;
    }

    pClientInfo = (PSecPkgInfo) LsapClientAllocate(cbSize);

    if (!pClientInfo)
    {
        scRet = SEC_E_INSUFFICIENT_MEMORY;
        goto Cleanup;
    }

    //
    // Compute the offset to adjust the pointers by
    //

    cbMark = *pcEntries * sizeof(SecPkgInfo);

    RtlCopyMemory(pLocalInfo,pInfo,cbMark);

    for (i = 0; i < *pcEntries ; i++ )
    {

        cbLength = (wcslen(pInfo[i].Name)+1)*sizeof(WCHAR);
        RtlCopyMemory(
            (PBYTE) pLocalInfo + cbMark,
            pInfo[i].Name,
            cbLength);

        pLocalInfo[i].Name = (LPWSTR) ((PBYTE) pClientInfo + cbMark);
        cbMark += cbLength;

        cbLength = (wcslen(pInfo[i].Comment)+1)*sizeof(WCHAR);
        RtlCopyMemory(
            (PBYTE) pLocalInfo + cbMark,
            pInfo[i].Comment,
            cbLength);

        pLocalInfo[i].Comment = (LPWSTR) ((PBYTE) pClientInfo + cbMark);
        cbMark += cbLength;

    }

    SetCurrentPackageId( SPMGR_ID );

    scRet = LsapCopyToClient(pLocalInfo,pClientInfo,cbSize);

    if (SUCCEEDED(scRet))
    {
        *pPackages = pClientInfo;
    }


Cleanup:

    if (FAILED(scRet) && (pClientInfo != NULL))
    {
        LsapClientFree(pClientInfo);
    }

    SafeAllocaFree(pLocalInfo);
    SafeAllocaFree(pInfo);

    return(scRet);
}



//+-------------------------------------------------------------------------
//
//  Function:   WLsaGetBinding()
//
//  Synopsis:   Gets the full path/DLL name for a package, based on ID
//
//  Effects:
//
//  Arguments:  dwPackageID - ID of the package the caller needs the path for
//              pssPackageName - returns the name of package caller
//
//              pszModuleName - Receives the name of the package.
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//--------------------------------------------------------------------------

NTSTATUS
WLsaGetBinding( ULONG_PTR           dwPackageID,
                PSEC_PACKAGE_BINDING_INFO   BindingInfo,
                PULONG              TotalSize,
                PWSTR *             Base)
{
    PLSAP_SECURITY_PACKAGE pPackage;
    PWSTR   Buffer;
    PLSA_CALL_INFO CallInfo ;
    PSECURITY_STRING DllPath ;
    SECURITY_STRING NullString = { 0 };

    ZeroMemory( BindingInfo, sizeof( SEC_PACKAGE_BINDING_INFO ) );

    pPackage = SpmpValidateHandle(dwPackageID);

    CallInfo = LsapGetCurrentCall();

    if ( (pPackage != NULL ) &&
         ( CallInfo->CallInfo.Attributes & SECPKG_CALL_WOWCLIENT ) != 0 )
    {
        //
        // If this is a WOW client, only return bindings for the packages
        // that support WOW clients.
        //

        if ( ( pPackage->fPackage & SP_WOW_SUPPORT ) == 0 )
        {
            pPackage = NULL ;
        }
    }

    if (pPackage)
    {
        //
        // Easy stuff:
        //

        BindingInfo->fCapabilities = pPackage->fCapabilities;
        BindingInfo->PackageIndex = pPackage->PackageIndex ;
        BindingInfo->Version = pPackage->Version ;
        BindingInfo->RpcId = pPackage->dwRPCID ;
        BindingInfo->TokenSize = pPackage->TokenSize ;

        if (pPackage->fPackage & SPM_AUTH_PKG_FLAG)
        {
            BindingInfo->Flags = PACKAGEINFO_AUTHPKG;
            //
            // Old style package:  no remote binding
            //

            return( SEC_E_INVALID_HANDLE );
        }

        DllPath = &pPackage->pBinding->Filename ;

        if ( pPackage->pBinding->Flags & DLL_BUILTIN )
        {
            BindingInfo->Flags = PACKAGEINFO_BUILTIN ;
            DllPath = &NullString ;
        }

        if ( pPackage->pBinding->Flags & DLL_SIGNED )
        {
            BindingInfo->Flags |= PACKAGEINFO_SIGNED ;
        }

        if ( ( pPackage->fPackage & SP_WOW_SUPPORT ) &&
             ( CallInfo->CallInfo.Attributes & SECPKG_CALL_WOWCLIENT ) )
        {
            DllPath = &pPackage->WowClientDll ;
        }


        //
        // If context thunks are present, copy them in:
        //

        if ( pPackage->Thunks )
        {
            BindingInfo->ContextThunksCount =
                            pPackage->Thunks->Info.ContextThunks.InfoLevelCount ;

            if ( pPackage->Thunks->Info.ContextThunks.InfoLevelCount <
                            PACKAGEINFO_THUNKS )
            {

                CopyMemory( BindingInfo->ContextThunks,
                            pPackage->Thunks->Info.ContextThunks.Levels,
                            BindingInfo->ContextThunksCount * sizeof(DWORD) );
            }
            else
            {
                CopyMemory( BindingInfo->ContextThunks,
                            pPackage->Thunks->Info.ContextThunks.Levels,
                            PACKAGEINFO_THUNKS * sizeof( DWORD ) );

            }
        }
        else
        {
            BindingInfo->ContextThunksCount = 0 ;
        }

        //
        // Compute Sizes:
        //

        *TotalSize = pPackage->Name.Length + 2 +
                     pPackage->Comment.Length + 2 +
                     DllPath->Length + 2 ;

        Buffer = (PWSTR) LsapAllocateLsaHeap( *TotalSize );

        if ( !Buffer )
        {
            return( SEC_E_INSUFFICIENT_MEMORY );
        }

        BindingInfo->PackageName.Buffer = Buffer ;
        BindingInfo->PackageName.Length = pPackage->Name.Length ;
        BindingInfo->PackageName.MaximumLength = pPackage->Name.Length + 2;

        CopyMemory( BindingInfo->PackageName.Buffer,
                    pPackage->Name.Buffer,
                    BindingInfo->PackageName.MaximumLength );

        BindingInfo->Comment.Buffer = BindingInfo->PackageName.Buffer +
                            BindingInfo->PackageName.MaximumLength / 2 ;

        BindingInfo->Comment.Length = pPackage->Comment.Length;
        BindingInfo->Comment.MaximumLength = BindingInfo->Comment.Length + 2;

        CopyMemory( BindingInfo->Comment.Buffer,
                    pPackage->Comment.Buffer,
                    BindingInfo->Comment.MaximumLength );


        if ( DllPath->Buffer )
        {
            BindingInfo->ModuleName.Buffer = BindingInfo->Comment.Buffer +
                                        BindingInfo->Comment.MaximumLength / 2;

            BindingInfo->ModuleName.Length = DllPath->Length;
            BindingInfo->ModuleName.MaximumLength = BindingInfo->ModuleName.Length + 2;

            CopyMemory( BindingInfo->ModuleName.Buffer,
                        DllPath->Buffer,
                        BindingInfo->ModuleName.MaximumLength );

        }


        *Base = Buffer ;

        return( SEC_E_OK );
    }

    return( SEC_E_INVALID_HANDLE );

}

//+---------------------------------------------------------------------------
//
//  Function:   LsapFindPackage
//
//  Synopsis:   Internal function for the security DLL to reference packages
//              by ID
//
//  Arguments:  [pPackage]     -- name of package
//              [pdwPackageId] -- returned id
//
//  Returns:    STATUS_SUCCESS          -- Package found
//              SEC_E_SECPKG_NOT_FOUND  -- Package not found
//
//  History:    5-26-93   RichardW   Created
//
//----------------------------------------------------------------------------

NTSTATUS
WLsaFindPackage(PUNICODE_STRING    pPackageName,
                ULONG_PTR *        pdwPackageId)
{
    PLSAP_SECURITY_PACKAGE pPackage;

    pPackage = SpmpLookupPackage(pPackageName);
    if (!pPackage)
    {
        *pdwPackageId = SPMGR_ID;
        return(SEC_E_SECPKG_NOT_FOUND);
    }
    else
    {
        *pdwPackageId = pPackage->dwPackageID;
        return(S_OK);
    }
}

//+---------------------------------------------------------------------------
//
//  Function:   WLsaAddPackage
//
//  Synopsis:   Adds a security package to the system
//
//  Arguments:  [PackageName] -- Package Name
//              [Options]     -- Options
//
//  History:    9-18-96   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
NTSTATUS
WLsaAddPackage(
    PSECURITY_STRING PackageName,
    PSECURITY_PACKAGE_OPTIONS Options)
{

    SECPKG_PARAMETERS Parameters;
    PLSAP_SECURITY_PACKAGE Package;
    SECPKG_EVENT_PACKAGE_CHANGE Event;
    BOOL Success;
    SECURITY_STATUS scRet;
    PLSAPR_POLICY_DNS_DOMAIN_INFO DnsDomainInfo = NULL;
    HKEY hKey ;


    DebugLog(( DEB_TRACE, "Adding Package %ws\n", PackageName->Buffer ));

    //
    // Make sure the caller has the rights to do this by impersonating them,
    // then opening the registry key.
    //

    scRet = LsapImpersonateClient();

    if ( NT_SUCCESS( scRet ) )
    {
        int err ;

        err = RegOpenKeyEx(
                    HKEY_LOCAL_MACHINE,
                    szLsaPath,
                    0,
                    KEY_READ | KEY_WRITE,
                    &hKey );

        if ( err != 0 )
        {
            scRet = NtCurrentTeb()->LastStatusValue ;
        }
        else
        {
            RegCloseKey( hKey );
        }

        RevertToSelf();
    }

    if ( !NT_SUCCESS( scRet ) )
    {
        return scRet ;
    }

    //
    // Build up the initialization message, to give the packages a better idea
    // of what is going on, and reduce their later calls for the same info.
    //

    Parameters.MachineState = (ULONG) 0;
    Parameters.SetupMode = SetupPhase;

    //
    // Make sure we haven't been through this already:
    //

    if ( SpmpFindDll( PackageName->Buffer ) )
    {
        DebugLog(( DEB_TRACE, "AddPackage:  DLL %ws already loaded\n", PackageName->Buffer ));
        return STATUS_SUCCESS ;
    }

    scRet = LsaIQueryInformationPolicyTrusted(
                PolicyDnsDomainInformation,
                (PLSAPR_POLICY_INFORMATION *) &DnsDomainInfo
                );

    if (!NT_SUCCESS(scRet))
    {
        DebugLog((DEB_ERROR,"Failed to get primary domain info: 0x%x\n",scRet));
        return(scRet);
    }

    Parameters.DomainName = * (PUNICODE_STRING) &DnsDomainInfo->Name;
    Parameters.DnsDomainName = * (PUNICODE_STRING) &DnsDomainInfo->DnsDomainName;
    Parameters.DomainSid = (PSID) DnsDomainInfo->Sid;


    DebugLog((DEB_TRACE_INIT, "Init Parameters = %d, %s\n",
                Parameters.MachineState,
                (Parameters.SetupMode ? "Setup" : "Normal") ));

    if (SpmpLoadDll( PackageName->Buffer, &Parameters ))
    {
        //
        // Successful Load!  Update the registry!
        //

        if ( Options->Flags & SECPKG_OPTIONS_PERMANENT )
        {
            Success = AddPackageToRegistry( PackageName );
        }
        else
        {
            Success = TRUE ;
        }

        if ( !Success )
        {
            //
            // Unload it!
            //
        }
    }
    else
    {
        Success = FALSE ;
    }

    LsaIFree_LSAPR_POLICY_INFORMATION(
        PolicyDnsDomainInformation,
        (PLSAPR_POLICY_INFORMATION) DnsDomainInfo
        );


    if ( Success )
    {
        return( SEC_E_OK );
    }

    return( SEC_E_SECPKG_NOT_FOUND );

}

//+---------------------------------------------------------------------------
//
//  Function:   WLsaDeletePackage
//
//  Synopsis:   Delete a security package
//
//  Arguments:  [PackageName] --
//
//  History:    9-18-96   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
NTSTATUS
WLsaDeletePackage(
    PSECURITY_STRING PackageName)
{
    return( SEC_E_NOT_SUPPORTED );
}


//+-------------------------------------------------------------------------
//
//  Function:   SpmCreateEvent
//
//  Synopsis:   Just like the Win32 function, except that it allows
//              for names at the root of the namespace.
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//--------------------------------------------------------------------------
HANDLE
SpmCreateEvent( LPSECURITY_ATTRIBUTES   lpsa,
                BOOL                    fManualReset,
                BOOL                    fInitialState,
                LPTSTR                  pszEventName)
{
    HANDLE              hEvent;
    OBJECT_ATTRIBUTES   EventAttr;
    UNICODE_STRING      usName;
    NTSTATUS            Status;
    ULONG               ulWin32Error;

    RtlInitUnicodeString(&usName, pszEventName);

    if (lpsa)
    {
        InitializeObjectAttributes(&EventAttr, &usName,
                                   (lpsa->bInheritHandle ? OBJ_INHERIT : 0),
                                   NULL,
                                   lpsa->lpSecurityDescriptor);
    }
    else
    {
        InitializeObjectAttributes(&EventAttr, &usName, 0, NULL, NULL);
    }

    Status = NtCreateEvent( &hEvent,
                            EVENT_ALL_ACCESS,
                            &EventAttr,
                            (fManualReset ? NotificationEvent : SynchronizationEvent),
                            (BOOLEAN) fInitialState);

    if (!NT_SUCCESS(Status))
    {
        ulWin32Error = RtlNtStatusToDosError( Status );
        SetLastError(ulWin32Error);
        return(NULL);
    }
    return(hEvent);
}


//+-------------------------------------------------------------------------
//
//  Function:   SpmOpenEvent
//
//  Synopsis:   Just like Win32 OpenEvent, except that this supports \ in name
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//--------------------------------------------------------------------------
HANDLE
SpmOpenEvent(   ULONG       fdwAccess,
                BOOL        fInherit,
                LPTSTR      pszEventName)
{
    HANDLE              hEvent;
    OBJECT_ATTRIBUTES   EventAttr;
    UNICODE_STRING      usName;
    NTSTATUS            Status;
    ULONG               ulWin32Error;

    RtlInitUnicodeString(&usName, pszEventName);

    InitializeObjectAttributes(&EventAttr, &usName, OBJ_CASE_INSENSITIVE |
                               (fInherit ? OBJ_INHERIT : 0), NULL, NULL);

    Status = NtOpenEvent(   &hEvent,
                            fdwAccess,
                            &EventAttr);

    if (!NT_SUCCESS(Status))
    {
        ulWin32Error = RtlNtStatusToDosError( Status );
        SetLastError(ulWin32Error);
        return(NULL);
    }
    return(hEvent);

}



////////////////////////////////////////////////////////////////////////////
//
//
//  Package List Manipulation:
//
//
////////////////////////////////////////////////////////////////////////////

//+---------------------------------------------------------------------------
//
//  Function:   SpmpAddPackage
//
//  Synopsis:   Adds a package to the list.
//
//  Arguments:  [pPackage] -- Package to add
//
//  History:    7-26-96   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
ULONG
SpmpAddPackage(
    PLSAP_SECURITY_PACKAGE pPackage)
{
    PLSAP_SECURITY_PACKAGE *   pList;
    ULONG           PackageId;

    //
    // Grab excluse access to the list:
    //

    WriteLockPackageList();


    //
    // If we don't have any left over space in the array, realloc it
    //

    if ( PackageControlCount == PackageControlTotal )
    {
        pList = (PLSAP_SECURITY_PACKAGE *) LsapAllocateLsaHeap( sizeof(PLSAP_SECURITY_PACKAGE) *
                                (PackageControlTotal + INITIAL_PACKAGE_CONTROL_SIZE));
        if (!pList)
        {
            WriteUnlockPackageList();
            return( 0xFFFFFFFF );
        }

        CopyMemory( pList,
                    pPackageControlList,
                    sizeof( PLSAP_SECURITY_PACKAGE ) * PackageControlTotal );

        PackageControlTotal += INITIAL_PACKAGE_CONTROL_SIZE;

        LsapFreeLsaHeap( pPackageControlList );

        pPackageControlList = pList;
    }

    //
    // Obtain a new package id (and slot)
    //

    PackageId = PackageControlCount++;

    pPackageControlList[ PackageId ] = pPackage;

    pPackage->pBinding->RefCount++;

    pPackage->dwPackageID = PackageId;

    WriteUnlockPackageList();

    return( PackageId );
}

//+---------------------------------------------------------------------------
//
//  Function:   SpmpRemovePackage
//
//  Synopsis:   Removes a package from the list
//
//  Arguments:  [PackageId] --
//
//  History:    7-26-96   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
VOID
SpmpRemovePackage(
    ULONG PackageId)
{
    WriteLockPackageList();

    pPackageControlList[ PackageId ] = NULL;

    //
    // If the counter hasn't moved on, reclaim the index
    //

    if (PackageId == PackageControlCount - 1)
    {
        PackageControlCount--;
    }

    WriteUnlockPackageList();

}


//+---------------------------------------------------------------------------
//
//  Function:   SpmpAddDll
//
//  Synopsis:   Add a DLL binding
//
//  Arguments:  [pBinding] --
//
//  History:    7-26-96   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
BOOL
SpmpAddDll(
    PDLL_BINDING    pBinding)
{
    PDLL_BINDING *  pList;
    ULONG           DllId;

    WriteLockPackageList();

    if ( PackageDllCount == PackageDllTotal )
    {
        pList = (PDLL_BINDING *) LsapAllocateLsaHeap( sizeof(PDLL_BINDING) *
                                (PackageDllTotal + INITIAL_PACKAGE_DLL_SIZE));
        if (!pList)
        {
            WriteUnlockPackageList();
            return( FALSE );
        }

        CopyMemory( pList,
                    pPackageDllList,
                    sizeof( PDLL_BINDING ) * PackageDllTotal );

        PackageDllTotal += INITIAL_PACKAGE_DLL_SIZE;

        LsapFreeLsaHeap( pPackageDllList );

        pPackageDllList = pList;
    }

    pPackageDllList[ PackageDllCount++ ] = pBinding;

    WriteUnlockPackageList();

    return( TRUE );

}


//+---------------------------------------------------------------------------
//
//  Function:   SpmpRemoveDll
//
//  Synopsis:   Removes a DLL binding
//
//  Arguments:  [pBinding] --
//
//  History:    7-26-96   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
VOID
SpmpRemoveDll(
    PDLL_BINDING    pBinding)
{
    ULONG i;

    WriteLockPackageList();

    if (pPackageDllList[PackageDllCount - 1] == pBinding )
    {
        PackageDllCount --;

        pPackageDllList[ PackageDllCount ] = NULL;
    }
    else
    {

        for (i = 0; i < PackageDllCount ; i++ )
        {
            if (pPackageDllList[ i ] == pBinding)
            {
                pPackageDllList[ i ] = NULL;
                break;
            }
        }
    }

    WriteUnlockPackageList();

}

//+---------------------------------------------------------------------------
//
//  Function:   SpmpFindDll
//
//  Synopsis:   Searches set of DLLs already loaded for a DLL name
//
//  Arguments:  [DllName] -- absolute or relative path name
//
//  History:    9-20-96   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
PDLL_BINDING
SpmpFindDll(
    PWSTR   DllName)
{
    WCHAR   DllPath[ MAX_PATH ];
    PWSTR   FilePart;
    DWORD   Length;
    UNICODE_STRING  Search;
    PDLL_BINDING pBinding;
    DWORD   i;

    pBinding = NULL ;

    Length = SearchPath(NULL,
                        DllName,
                        TEXT(".DLL"),
                        MAX_PATH,
                        DllPath,
                        &FilePart );

    if ( Length )
    {
        //
        // Name hit, see if we've loaded it already:
        //

        Search.Buffer = DllPath;
        Search.Length = (USHORT) (Length * sizeof( WCHAR ));
        Search.MaximumLength = Search.Length + sizeof( WCHAR ) ;


        ReadLockPackageList();

        for ( i = 0 ; i < PackageDllCount ; i++ )
        {
            if ( RtlEqualUnicodeString( &Search,
                                        &(pPackageDllList[i]->Filename),
                                        TRUE) )
            {
                pBinding = pPackageDllList[ i ];
                break;
            }
        }

        ReadUnlockPackageList();

    }

    return( pBinding );

}

//+---------------------------------------------------------------------------
//
//  Function:   LsapGetExtendedPackageInfo
//
//  Synopsis:   Wrapper to get extended information from a package
//
//  Arguments:  [Package] -- Package to query
//              [Class]   -- Information class
//              [Info]    -- returned data
//
//  History:    3-04-97   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
NTSTATUS
LsapGetExtendedPackageInfo(
    PLSAP_SECURITY_PACKAGE  Package,
    SECPKG_EXTENDED_INFORMATION_CLASS Class,
    PSECPKG_EXTENDED_INFORMATION * Info
    )
{
    NTSTATUS Status ;

    if ( (Package->fPackage & SP_INFO) == 0 )
    {
        return SEC_E_NOT_SUPPORTED ;
    }

    DebugLog(( DEB_TRACE, "Getting extended information (%d) from %ws\n",
                Class, Package->Name.Buffer ));
    __try
    {
        Status = Package->FunctionTable.GetExtendedInformation( Class, Info );
    }
    __except (SP_EXCEPTION)
    {
        Status = SPException(GetExceptionCode(), Package->dwPackageID);
    }

    return Status ;
}

NTSTATUS
LsapSetExtendedPackageInfo(
    PLSAP_SECURITY_PACKAGE  Package,
    SECPKG_EXTENDED_INFORMATION_CLASS Class,
    PSECPKG_EXTENDED_INFORMATION Info
    )
{
    NTSTATUS Status ;

    if ( ((Package->fPackage & SP_INFO) == 0 ) ||
         ( Package->FunctionTable.SetExtendedInformation == NULL ) )
    {
        return SEC_E_NOT_SUPPORTED ;
    }

    DebugLog(( DEB_TRACE, "Setting extended information (%d) from %ws\n",
                Class, Package->Name.Buffer ));
    __try
    {
        Status = Package->FunctionTable.SetExtendedInformation( Class, Info );
    }
    __except (SP_EXCEPTION)
    {
        Status = SPException(GetExceptionCode(), Package->dwPackageID);
    }

    return Status ;
}


//+---------------------------------------------------------------------------
//
//  Function:   LsapAuditPackageBoot
//
//  Synopsis:   Audit a package boot (load)
//
//  Arguments:  [pPackage] --
//
//  History:    5-06-97   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
VOID
LsapAuditPackageBoot(
    IN PLSAP_SECURITY_PACKAGE pPackage
    )
{
    WCHAR   PackageAndDll[ MAX_PATH ] = {0};
    UNICODE_STRING AuditName;

    _snwprintf( PackageAndDll, COUNTOF(PackageAndDll) - 1,
        L"%s : %s",
        pPackage->pBinding->Filename.Buffer,
        pPackage->Name.Buffer );

    RtlInitUnicodeString( &AuditName, PackageAndDll );

    LsapAdtAuditPackageLoad( &AuditName );
}

//+---------------------------------------------------------------------------
//
//  Function:   SpmpBootPackage
//
//  Synopsis:   Initializes a package by calling it's entry points
//
//  Arguments:  [pPackage]    -- Package to initialize
//              [pParameters] -- Initialization parameters
//
//  History:    7-26-96   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
BOOL
SpmpBootPackage(
    IN PLSAP_SECURITY_PACKAGE pPackage,
    IN PSECPKG_PARAMETERS pParameters
    )
{
    SECURITY_STATUS scRetCode;
    SecPkgInfo spiPackage = { 0 };
    UNICODE_STRING TempString;
    PSECPKG_EXTENDED_INFORMATION WowClient ;

    //
    // Break now so debugging people can set breakpoints in the newly loaded
    // DLL.
    //

    BreakOnError(BREAK_ON_LOAD);


    // Call the packages initialize function.  This gives the package a chance
    // to do whatever initialization it needs to do.  E.g. the kerberos package
    // runs out and finds the KDC.


    //
    // Set the session ID for tracking and so forth.
    //

    SetCurrentPackageId(pPackage->dwPackageID);

    __try
    {
        scRetCode = pPackage->FunctionTable.Initialize(
                        pPackage->dwPackageID,
                        pParameters,
                        &LsapSecpkgFunctionTable
                        );


    }
    __except (SP_EXCEPTION)
    {
        //
        // Well, this is odd.  The initialization function blew chunks.  That
        // means that the package itself can't be trusted.  So, let's change
        // this to an error return, and let the error logic blow away the
        // package.
        //

        scRetCode = SEC_E_CANNOT_INSTALL;

    }


    //
    // Let's see if the package loaded.  Hmm.
    //

    if (FAILED(scRetCode))
    {
        goto Cleanup;
    }

    //
    // Hey, a good one.  Now, determine the capabilities of the package by
    // calling it's getinfo function.
    //

    __try
    {
        scRetCode = pPackage->FunctionTable.GetInfo( &spiPackage );
    }
    __except (SP_EXCEPTION)
    {
        //
        // If it blows, catch it, and kill the package.
        //

        scRetCode = SPException(GetExceptionCode(), pPackage->dwPackageID);
    }

    //
    // Reset the session ID.
    //

    SetCurrentPackageId( SPMGR_ID );

    //
    // If it failed, note that and return.  Note, if there was an exception
    // then SPException() will have tagged the package appropriately.
    //

    if (FAILED(scRetCode))
    {
        goto Cleanup;
    }

    pPackage->fCapabilities = spiPackage.fCapabilities;
    pPackage->dwRPCID = spiPackage.wRPCID;
    pPackage->Version = spiPackage.wVersion ;
    pPackage->TokenSize = spiPackage.cbMaxToken ;

    RtlInitUnicodeString(
        &TempString,
        spiPackage.Name
        );

    scRetCode = LsapDuplicateString(
                    &pPackage->Name,
                    &TempString
                    );

    if (!NT_SUCCESS(scRetCode))
    {
        goto Cleanup;
    }

    RtlInitUnicodeString( &TempString, spiPackage.Comment );

    scRetCode = LsapDuplicateString(
                    &pPackage->Comment,
                    &TempString );

    if ( !NT_SUCCESS( scRetCode ) )
    {
        goto Cleanup;
    }

    //
    // Find out if the package supports extended information.  If so,
    // find out what context attrs it wants thunked to LSA mode.
    //

    if ( pPackage->FunctionTable.GetExtendedInformation )
    {
        pPackage->fPackage |= SP_INFO ;

        scRetCode = LsapGetExtendedPackageInfo(
                                        pPackage,
                                        SecpkgContextThunks,
                                        &pPackage->Thunks );

        if ( scRetCode != STATUS_SUCCESS )
        {
            pPackage->Thunks = NULL ;

            scRetCode = 0 ;
        }

        scRetCode = LsapGetExtendedPackageInfo(
                                        pPackage,
                                        SecpkgWowClientDll,
                                        &WowClient );

        if ( scRetCode == STATUS_SUCCESS )
        {
            scRetCode = LsapDuplicateString(
                            &pPackage->WowClientDll,
                            &WowClient->Info.WowClientDll.WowClientDllPath);

            if ( NT_SUCCESS( scRetCode ) )
            {
                pPackage->fPackage |= SP_WOW_SUPPORT ;
            }

        }
    }


    DebugLog((DEB_TRACE_INIT | DEB_TRACE, "Loaded %ws, assigned ID %d, flags %#x\n",
                spiPackage.Name,
                pPackage->dwPackageID,
                pPackage->fPackage ));

    lsState.cPackages++;
    if ((pPackage->fPackage & SPM_AUTH_PKG_FLAG) == 0)
    {
        lsState.cNewPackages ++;
    }

    //
    // And write the audit
    //

    LsapAuditPackageBoot( pPackage );


    return( TRUE );

Cleanup:

    return( FALSE );
}

//+---------------------------------------------------------------------------
//
//  Function:   SpmpBootAuthPackage
//
//  Synopsis:   Initializes an old-style authentication package.
//
//  Arguments:  [pPackage] --
//
//  History:    5-06-97   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
NTSTATUS
SpmpBootAuthPackage(
    PLSAP_SECURITY_PACKAGE     pPackage)
{
    NTSTATUS scRet;
    PSTRING         pNlsName;

    DebugLog((DEB_TRACE_LSA_AU, "Initializing package %d\n",
                    pPackage->dwPackageID));


    __try
    {
        scRet = pPackage->FunctionTable.InitializePackage(
                        (ULONG) pPackage->dwPackageID,
                        (PLSA_DISPATCH_TABLE) &LsapSecpkgFunctionTable,
                        NULL,
                        NULL,
                        &pNlsName);

        if (NT_SUCCESS(scRet))
        {
            scRet = RtlAnsiStringToUnicodeString(
                        &pPackage->Name,
                        pNlsName,
                        TRUE        // allocate destination
                        );

            //
            // NTBUG 395189
            // Do not free the returned name.  There is no correct way to do
            // this, and some vendors do not separately allocate the string
            // and structure, and some might use some other part of memory.
            // So allow this potential leak, but since they are loaded only once
            // and at boot time, that's ok.
            //

#if 0
            //
            // Free the returned name
            //

            LsapFreeLsaHeap(pNlsName->Buffer);
            LsapFreeLsaHeap(pNlsName);
#endif
        }

    }
    __except (SP_EXCEPTION)
    {
        scRet = SPException(GetExceptionCode(), pPackage->dwPackageID);
    }

    if (SUCCEEDED(scRet))
    {
        lsState.cPackages ++;

        LsapAuditPackageBoot( pPackage );
    }


    return(scRet);
}


//+---------------------------------------------------------------------------
//
//  Function:   SpmpLoadPackage
//
//  Synopsis:   Loads a specific package from a DLL binding
//
//  Arguments:  [pBinding]    -- Binding to work from
//              [Package]     -- Package index to load
//              [pParameters] -- Parameters to pass for initialization
//
//  History:    7-26-96   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
BOOL
SpmpLoadPackage(
    PDLL_BINDING pBinding,
    ULONG Package,
    PSECPKG_PARAMETERS pParameters)
{
    ULONG           PackageId;
    PLSAP_SECURITY_PACKAGE     pPackage;
    SECPKG_EVENT_PACKAGE_CHANGE Event;

    //
    // Get the package dispatch table:
    //

    pPackage = &pBinding->Packages[Package];

    //
    // Update its binding entry
    //

    pPackage->pBinding = pBinding;

    pPackage->PackageIndex = Package ;

    //
    // Add it as a package to run
    //

    PackageId = SpmpAddPackage( pPackage );

    if ( PackageId != 0xFFFFFFFF )
    {
        //
        // Boot it, so it is initialized
        //

        if ( SpmpBootPackage(pPackage, pParameters) )
        {
            //
            // Notify any listeners:
            //

            Event.ChangeType = SECPKG_PACKAGE_CHANGE_LOAD ;
            Event.PackageName = pPackage->Name ;
            Event.PackageId = PackageId ;

            LsapEventNotify(
                        NOTIFY_CLASS_PACKAGE_CHANGE,
                        0,
                        sizeof( Event ),
                        &Event );


            return( TRUE );
        }

        SpmpRemovePackage( PackageId );
    }


    return( FALSE );

}




//+---------------------------------------------------------------------------
//
//  Function:   SpmpLoadDll
//
//  Synopsis:   Loads a new DLL, determines the packages, and loads them
//
//  Arguments:  [pszDll]      -- DLL name
//              [pParameters] -- Parameters for initialization
//
//  History:    7-26-96   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
BOOL
SpmpLoadDll(
    PWSTR               pszDll,
    PSECPKG_PARAMETERS  pParameters)
{
    HANDLE hDll;
    DLL_BINDING *   pBinding = NULL ;
    PDLL_BINDING *  pList;
    SpLsaModeInitializeFn   Init;
    ULONG PackageVersion;
    SECURITY_STATUS scRet;
    PSECPKG_FUNCTION_TABLE  pTables;
    HINSTANCE   hInstance = NULL ;
    ULONG PackageCount;
    PWSTR   pszPath;
    ULONG cchPath;
    ULONG i;
    ULONG SuccessCount;
    BOOL IsSigned ;


    hInstance = LoadLibrary( pszDll );
    if (hInstance)
    {

        Init = (SpLsaModeInitializeFn) GetProcAddress(
                                                hInstance,
                                                SECPKG_LSAMODEINIT_NAME);

        if (Init)
        {
            scRet = Init(   SECPKG_INTERFACE_VERSION,
                            &PackageVersion,
                            &pTables,
                            &PackageCount );

            if (SUCCEEDED(scRet))
            {
                pBinding = (PDLL_BINDING) LsapAllocateLsaHeap( sizeof( DLL_BINDING ) +
                                                (PackageCount - 1) *
                                                    sizeof( LSAP_SECURITY_PACKAGE ) );

                if (pBinding)
                {
                    pBinding->hInstance = hInstance;

                    SafeAllocaAllocate(pszPath, MAX_PATH * 2 * 2);

                    if (pszPath)
                    {
                        UNICODE_STRING TempString;
                        cchPath = GetModuleFileName(  hInstance,
                                                      pszPath,
                                                      MAX_PATH * 2 );

                        RtlInitUnicodeString(
                            &TempString,
                            pszPath
                            );
                        scRet = LsapDuplicateString(
                                    &pBinding->Filename,
                                    &TempString
                                    );

                        SafeAllocaFree(pszPath);


                        if (!NT_SUCCESS(scRet))
                        {
                            //
                            // Bail out:
                            //

                            goto LoadDll_Error;
                        }

#ifdef LSA_IGNORE_SIGNATURE
                        IsSigned = TRUE;
#else
                        IsSigned = FALSE;

                        {
                            const LPWSTR ExclusionList[] = {
                                    L"msv1_0",
                                    L"kerberos",
                                    L"schannel",
                                    L"wdigest",
                                    NULL
                                    };
                            ULONG ExclusionIndex = 0;

                            while( ExclusionList[ExclusionIndex] != NULL )
                            {
                                if( lstrcmpiW( pszDll, ExclusionList[ExclusionIndex] ) == 0 )
                                {
                                    IsSigned = TRUE;
                                    break;
                                }
                                ExclusionIndex++;
                            }
                        }

                        if( !IsSigned )
                        {
                            IsSigned = RtlCheckSignatureInFile( pBinding->Filename.Buffer );
                        }
#endif
                        if ( IsSigned )
                        {
                            pBinding->Flags |= DLL_SIGNED ;
                        }
                    }

                    pBinding->PackageCount = PackageCount;

                    SuccessCount = 0;

                    for (i = 0 ; i < PackageCount ; i++ )
                    {

                        //
                        // Old auth packages contain all functions up to but not including
                        //  SetContextAttributes.
                        //
                        if ( PackageVersion == SECPKG_INTERFACE_VERSION ) {

                            //
                            // Copy the exported table and zero the rest.
                            //

                            CopyMemory( &pBinding->Packages[i].FunctionTable,
                                        &pTables[i],
                                        offsetof(SECPKG_FUNCTION_TABLE, SetContextAttributes ) );

                            ZeroMemory( ((LPBYTE)(&pBinding->Packages[i].FunctionTable)) +
                                            offsetof(SECPKG_FUNCTION_TABLE, SetContextAttributes),
                                        sizeof(SECPKG_FUNCTION_TABLE) -
                                            offsetof(SECPKG_FUNCTION_TABLE, SetContextAttributes) );

                        } else {

                            CopyMemory( &pBinding->Packages[i].FunctionTable,
                                        &pTables[i],
                                        sizeof(SECPKG_FUNCTION_TABLE) );
                        }

                        if (SpmpLoadPackage( pBinding, i, pParameters ))
                        {
                            SuccessCount ++;
                        }
                    }

                    if (SuccessCount)
                    {
                        SpmpAddDll( pBinding );

                        return( TRUE );

                    }
                }
            }
        }
    }

LoadDll_Error :

    if ( pBinding != NULL )
    {
        LsapFreeLsaHeap( pBinding );
    }

    if ( hInstance != NULL )
    {
        FreeLibrary( hInstance );
    }

    return( FALSE );

}

//+---------------------------------------------------------------------------
//
//  Function:   SpmpLoadAuthPkgDll
//
//  Synopsis:   Loads an old (msv1_0 style) DLL
//
//  Arguments:  [pszDll] --
//
//  History:    7-26-96   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
BOOL
SpmpLoadAuthPkgDll(
    PWSTR   pszDll)
{
    SECURITY_STATUS scRet;
    HINSTANCE       hInstance;
    PDLL_BINDING    pBinding = NULL ;
    PLSAP_SECURITY_PACKAGE     pPackage;
    ULONG           PackageId;
    UNICODE_STRING  PackageDll ;
    PWSTR           pszPath ;

    DebugLog((DEB_TRACE_INIT, "Loading Old package %ws\n", pszDll));


    hInstance = LoadLibrary( pszDll );

    if ( hInstance )
    {
        pBinding = (PDLL_BINDING) LsapAllocateLsaHeap( sizeof( DLL_BINDING ) );
        if (pBinding)
        {

            pszPath = (PWSTR) LsapAllocateLsaHeap( MAX_PATH * 2 * 2 );

            if (pszPath)
            {
                UNICODE_STRING TempString;
                DWORD cchPath ;

                cchPath = GetModuleFileName(  hInstance,
                                              pszPath,
                                              MAX_PATH * 2 );

                RtlInitUnicodeString(
                    &TempString,
                    pszPath
                    );
                scRet = LsapDuplicateString(
                            &pBinding->Filename,
                            &TempString
                            );

                LsapFreeLsaHeap( pszPath );

                if (!NT_SUCCESS(scRet))
                {
                    goto LoadAuthDll_Error ;
                }

            }


            pBinding->Flags = 0;
            pBinding->hInstance = hInstance;
            pPackage = pBinding->Packages;
            pPackage->pBinding = pBinding;
            pBinding->PackageCount = 1;

            if (BindOldPackage( hInstance, &pPackage->FunctionTable))
            {
                pPackage->fPackage = SPM_AUTH_PKG_FLAG;
                pPackage->fCapabilities = SPM_AUTH_PKG_FLAG;
                pPackage->dwRPCID = SECPKG_ID_NONE;

                PackageId = SpmpAddPackage( pPackage );
                if (PackageId != (ULONG) 0xFFFFFFFF)
                {
                    if ( SpmpAddDll( pBinding ) )
                    {
                        BreakOnError(BREAK_ON_LOAD);

                        scRet = SpmpBootAuthPackage( pPackage );

                        if (SUCCEEDED(scRet))
                        {
                            return( TRUE );
                        }

                        SpmpRemoveDll( pBinding );

                    }


                    LsapFreeString( &pBinding->Filename );

                    pBinding->Filename.Buffer = NULL ;

                    SpmpRemovePackage( PackageId );
                }
            }
        }
    }

LoadAuthDll_Error:

    if ( pBinding )
    {
        if ( pBinding->Filename.Buffer )
        {
            LsapFreeString( &pBinding->Filename );

        }

        LsapFreeLsaHeap( pBinding );
    }

    if ( hInstance )
    {
        FreeLibrary( hInstance );
    }

    return( FALSE );

}


//+---------------------------------------------------------------------------
//
//  Function:   SpmpLoadBuiltin
//
//  Synopsis:   Loads a builtin package
//
//  Arguments:  [Flags]       -- Flags for the package
//              [pTable]      -- Dispatch table
//              [pParameters] -- init parameters
//
//  History:    7-26-96   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
BOOL
SpmpLoadBuiltin(
    ULONG Flags,
    PSECPKG_FUNCTION_TABLE  pTable,
    PSECPKG_PARAMETERS  pParameters)
{
    PDLL_BINDING    pBinding;
    PLSAP_SECURITY_PACKAGE     pPackage;
    SECURITY_STATUS scRetCode;
    SecPkgInfo      spiPackage;
    ULONG           PackageId;
    SECPKG_EVENT_PACKAGE_CHANGE Event;
    WCHAR           Path[ MAX_PATH ];
    SECURITY_STRING TempString ;

    pBinding = (PDLL_BINDING) LsapAllocateLsaHeap( sizeof( DLL_BINDING ) );

    if (pBinding)
    {
        ZeroMemory( pBinding, sizeof( DLL_BINDING ) );

        pBinding->Flags = DLL_BUILTIN;
        pBinding->PackageCount = 1;
        pBinding->hInstance = GetModuleHandle( L"lsasrv.dll" );

        GetModuleFileName( (HINSTANCE) pBinding->hInstance,
                            Path, MAX_PATH );

        Path[MAX_PATH-1] = L'\0';

        RtlInitUnicodeString( &TempString, Path );
        scRetCode = LsapDuplicateString( &pBinding->Filename, &TempString );

        if ( NT_SUCCESS( scRetCode ) )
        {
            pPackage = pBinding->Packages;
            pPackage->pBinding = pBinding;
            pPackage->fPackage = Flags | SP_WOW_SUPPORT ;

            CopyMemory( &pPackage->FunctionTable,
                        pTable,
                        sizeof(SECPKG_FUNCTION_TABLE) );

            //
            // Fake up the DLL binding:
            //

            if ( SpmpAddDll( pBinding ) )
            {
                //
                // Add the package to the table:
                //

                PackageId = SpmpAddPackage( pPackage );

                if ( PackageId != 0xFFFFFFFF )
                {
                    //
                    // Initialize the package
                    //

                    if (SpmpBootPackage(pPackage, pParameters))
                    {

                        //
                        // Notify any listeners:
                        //

                        Event.PackageName = pPackage->Name ;
                        Event.PackageId = PackageId ;
                        Event.ChangeType = SECPKG_PACKAGE_CHANGE_LOAD ;

                        LsapEventNotify(
                                    NOTIFY_CLASS_PACKAGE_CHANGE,
                                    0,
                                    sizeof( Event ),
                                    &Event );

                        return( TRUE );
                    }

                    SpmpRemovePackage( PackageId );
                }

                SpmpRemoveDll( pBinding );

            }

        }

        LsapFreeLsaHeap( pBinding->Filename.Buffer );

        LsapFreeLsaHeap( pBinding );

    }

    return( FALSE );
}

#if DBG

BOOL
SpmpLoadBuiltinAuthPkg(
    PSECPKG_FUNCTION_TABLE  pTable)
{
    PDLL_BINDING    pBinding;
    ULONG           PackageId;
    PLSAP_SECURITY_PACKAGE     pPackage;
    SECURITY_STATUS scRet;
    WCHAR           Path[ MAX_PATH ];
    SECURITY_STRING TempString ;

    pBinding = (PDLL_BINDING) LsapAllocateLsaHeap( sizeof( DLL_BINDING ) );
    if (pBinding)
    {
        pBinding->Flags = DLL_BUILTIN;
        pBinding->PackageCount = 1;
        pBinding->hInstance = GetModuleHandle( L"lsasrv.dll" );
        GetModuleFileName( (HINSTANCE) pBinding->hInstance,
                            Path, MAX_PATH );

        RtlInitUnicodeString( &TempString, Path );
        scRet = LsapDuplicateString( &pBinding->Filename, &TempString );

        if ( NT_SUCCESS( scRet ) )
        {
            pPackage = pBinding->Packages;
            pPackage->pBinding = pBinding;

            CopyMemory( &pPackage->FunctionTable,
                        pTable,
                        sizeof( SECPKG_FUNCTION_TABLE ) );

            pPackage->fPackage = SPM_AUTH_PKG_FLAG;
            pPackage->fCapabilities = SPM_AUTH_PKG_FLAG;
            pPackage->dwRPCID = SECPKG_ID_NONE;

            PackageId = SpmpAddPackage( pPackage );
            if (PackageId != (ULONG) 0xFFFFFFFF)
            {
                if ( SpmpAddDll( pBinding ) )
                {
                    BreakOnError(BREAK_ON_LOAD);

                    scRet = SpmpBootAuthPackage( pPackage );

                    if (SUCCEEDED(scRet))
                    {
                        return( TRUE );
                    }

                    SpmpRemoveDll( pBinding );
                }

                SpmpRemovePackage( PackageId );
            }

            LsapFreeLsaHeap( pBinding );
        }
    }

    return( FALSE );
}

#endif

//+---------------------------------------------------------------------------
//
//  Function:   SpmpLocatePackage
//
//  Synopsis:   Locates the package
//
//  Arguments:  [PackageId] --
//
//  History:    11-15-95   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
PLSAP_SECURITY_PACKAGE
SpmpLocatePackage(
    ULONG_PTR PackageId)
{
    PLSAP_SECURITY_PACKAGE pControl = NULL;

    ReadLockPackageList();

    if( (ULONG)PackageId < PackageControlCount )
    {
        pControl = pPackageControlList[PackageId];
    }

    ReadUnlockPackageList();

    return( pControl );

}



//+---------------------------------------------------------------------------
//
//  Function:   SpmpValidateHandle
//
//  Synopsis:   Validates a package handle
//
//  Arguments:  [PackageHandle] --
//
//  History:    11-15-95   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
PLSAP_SECURITY_PACKAGE
SpmpValidateHandle(
    ULONG_PTR PackageHandle)
{
    PLSAP_SECURITY_PACKAGE pControl = NULL;

    ReadLockPackageList();

    if ( PackageHandle < PackageControlCount )
    {
        pControl = pPackageControlList[ PackageHandle ];
    }

    ReadUnlockPackageList();

    return( pControl );
}



//+---------------------------------------------------------------------------
//
//  Function:   SpmpValidRequest
//
//  Synopsis:   Validates package handle, requested API code.
//
//  Arguments:  [PackageHandle] --
//              [ApiCode]       --
//
//  History:    11-15-95   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
PLSAP_SECURITY_PACKAGE
SpmpValidRequest(
    ULONG_PTR PackageHandle,
    ULONG   ApiCode)
{
    PLSAP_SECURITY_PACKAGE pControl = NULL;
    PVOID *     pTable;

    ReadLockPackageList();

    if ( PackageHandle < PackageControlCount )
    {
        pControl = pPackageControlList[ PackageHandle ];
    }

    ReadUnlockPackageList();

    if (pControl)
    {
        if (pControl->fPackage & (SP_INVALID | SP_SHUTDOWN) )
        {
            pControl = NULL;
        }
    }

    if (pControl)
    {
        pTable = (PVOID *) &pControl->FunctionTable;
        if (pTable[ApiCode])
        {
            return( pControl );
        }

        pControl = NULL;
    }

    return( pControl );


}

//+---------------------------------------------------------------------------
//
//  Function:   SpmpLookupPackage
//
//  Synopsis:   Looks up a package based on name
//
//  Arguments:  [pssPackageName] --
//
//  History:    7-30-96   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
PLSAP_SECURITY_PACKAGE
SpmpLookupPackage(
    PUNICODE_STRING    pssPackageName)
{
    ULONG           iPack;
    PLSAP_SECURITY_PACKAGE     pPackage;
    PVOID *         pTable;

    ReadLockPackageList();

    for (iPack = 0; iPack < PackageControlCount ; iPack++ )
    {
        pPackage = pPackageControlList[ iPack ];

        if ( pPackage )
        {

            if (RtlEqualUnicodeString(
                    pssPackageName,
                    &pPackageControlList[ iPack ]->Name,
                    TRUE))      // case insensitive
            {
                ReadUnlockPackageList();

                return( pPackage );
            }
        }
    }

    ReadUnlockPackageList();
    return(NULL);
}

//+---------------------------------------------------------------------------
//
//  Function:   SpmpLookupPackageByRpcId
//
//  Synopsis:   Looks up a package based on RPC ID
//
//  Arguments:  [RpcId] --
//
//  History:    7-30-96   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
PLSAP_SECURITY_PACKAGE
SpmpLookupPackageByRpcId(
    ULONG RpcId)
{
    ULONG           iPack;
    PLSAP_SECURITY_PACKAGE     pPackage;
    PVOID *         pTable;

    ReadLockPackageList();

    for (iPack = 0; iPack < PackageControlCount ; iPack++ )
    {
        pPackage = pPackageControlList[ iPack ];

        if ( pPackage )
        {
            if (RpcId == pPackageControlList[iPack]->dwRPCID)
            {
                ReadUnlockPackageList();

                return( pPackage );
            }
        }
    }

    ReadUnlockPackageList();
    return(NULL);
}

DWORD
SpmpGetRpcPackageId(
    ULONG_PTR   PackageId
    )
{
    PLSAP_SECURITY_PACKAGE     pPackage;

    if( PackageId > (PackageControlCount-1) )
    {
        return SECPKG_ID_NONE;
    }

    ReadLockPackageList();

    pPackage = pPackageControlList[ PackageId ];

    if ( pPackage )
    {
        DWORD dwRPCID = pPackageControlList[ PackageId ]->dwRPCID ;

        ReadUnlockPackageList();

        return dwRPCID;
    }

    ReadUnlockPackageList();

    return SECPKG_ID_NONE;
}

//+---------------------------------------------------------------------------
//
//  Function:   SpmpLookupPackageAndRequest
//
//  Synopsis:   Returns a package pointer based on a name and the API code
//
//  Arguments:  [pssPackageName] -- Package name
//              [ApiCode]        -- Code
//
//  History:    7-30-96   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
PLSAP_SECURITY_PACKAGE
SpmpLookupPackageAndRequest(
    PUNICODE_STRING    pssPackageName,
    ULONG               ApiCode)
{
    ULONG           iPack;
    PLSAP_SECURITY_PACKAGE     pPackage;
    PVOID *         pTable;

    ReadLockPackageList();

    for (iPack = 0; iPack < PackageControlCount ; iPack++ )
    {
        pPackage = pPackageControlList[ iPack ];

        if ( pPackage )
        {

            if (RtlEqualUnicodeString(
                    pssPackageName,
                    &pPackageControlList[ iPack ]->Name,
                    TRUE))      // case insensitive
            {
                ReadUnlockPackageList();
                if ((pPackage->fPackage & ( SP_INVALID | SP_SHUTDOWN )) == 0)
                {
                    pTable = (PVOID *) &pPackage->FunctionTable;

                    if (pTable[ApiCode])
                    {
                        return( pPackage );
                    }
                }
                return( NULL );
            }
        }
    }

    ReadUnlockPackageList();
    return(NULL);
}




//+---------------------------------------------------------------------------
//
//  Function:   SpmpIteratePackagesByRequest
//
//  Synopsis:   Cycle through packages by request code, returning packages
//              that support supplied API
//
//  Arguments:  [pInitialPackage] --
//              [ApiCode]         --
//
//  History:    7-30-96   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
PLSAP_SECURITY_PACKAGE
SpmpIteratePackagesByRequest(
    PLSAP_SECURITY_PACKAGE pInitialPackage,
    ULONG       ApiCode)
{
    ULONG_PTR       NextPackage;
    PLSAP_SECURITY_PACKAGE     pPackage = NULL;
    PVOID *         pTable;
    ULONG           Ordinal ;
    ULONG           FlagMaskOn = 0 ;
    ULONG           FlagMaskOff = SP_INVALID | SP_SHUTDOWN ;

    Ordinal = ApiCode & SP_ORDINAL_MASK ;

    if ( ApiCode & SP_ITERATE_FILTER_WOW )
    {
        FlagMaskOn |= SP_WOW_SUPPORT ;
    }

    ReadLockPackageList();

    if (pInitialPackage)
    {
        NextPackage = pInitialPackage->dwPackageID + 1;
    }
    else
    {
        NextPackage = 0;
    }

    //
    // Walk through the list of packages, filtering on package flags
    // and whether the package supported the requested function
    //

    while (NextPackage < PackageControlCount)
    {
        pPackage = pPackageControlList[ NextPackage ];

        if ( pPackage )
        {
            if ( ( pPackage->fPackage & FlagMaskOff ) == 0 )
            {
                if ( ( pPackage->fPackage & FlagMaskOn ) == FlagMaskOn )
                {
                    pTable = (PVOID *) &pPackage->FunctionTable;

                    if ( pTable[ Ordinal ] )
                    {
                        //
                        // Found one!
                        //

                        break;
                    }
                }
            }

            pPackage = NULL;

        }

        NextPackage++;

    }

    ReadUnlockPackageList();

    return( pPackage );


}


//+---------------------------------------------------------------------------
//
//  Function:   SpmpCurrentPackageCount
//
//  Synopsis:   Returns the current package count
//
//  Arguments:  (none)
//
//  History:    7-30-96   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
ULONG
SpmpCurrentPackageCount(
    VOID)
{
    ULONG   Count;

    ReadLockPackageList();

    Count = PackageControlCount;

    ReadUnlockPackageList();

    return( Count );

}

//+---------------------------------------------------------------------------
//
//  Function:   LsapAddPackageHandle
//
//  Synopsis:   Increases the package handle count
//
//  Arguments:  [PackageId] --
//
//  History:    10-08-96   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
VOID
LsapAddPackageHandle(
    ULONG_PTR PackageId,
    BOOL IsContext
    )
{
#if DBG

    PLSAP_SECURITY_PACKAGE Package ;

    Package = pPackageControlList[ PackageId ];

    if ( IsContext )
    {
        InterlockedIncrement( (PLONG)&Package->ContextHandles );
    }
    else
    {
        InterlockedIncrement( (PLONG)&Package->CredentialHandles );
    }

#else
    UNREFERENCED_PARAMETER( PackageId );
    UNREFERENCED_PARAMETER( IsContext );
#endif
}

//+---------------------------------------------------------------------------
//
//  Function:   LsapDelPackageHandle
//
//  Synopsis:   Decrements the package handle count
//
//  Arguments:  [PackageId] --
//
//  History:    10-08-96   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
VOID
LsapDelPackageHandle(
    PLSAP_SECURITY_PACKAGE Package,
    BOOL IsContext
    )
{
#ifdef DBG

    if ( IsContext )
    {
        InterlockedDecrement( (PLONG)&Package->ContextHandles );
    }
    else
    {
        InterlockedDecrement( (PLONG)&Package->CredentialHandles );
    }

#else
    UNREFERENCED_PARAMETER( Package );
    UNREFERENCED_PARAMETER( IsContext );
#endif


}


//+---------------------------------------------------------------------------
//
//  Function:   SpmpInitializePackageControl
//
//  Synopsis:   Initialize the package controls
//
//  Arguments:  (none)
//
//  History:    11-15-95   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
BOOL
SpmpInitializePackageControl(
    VOID)
{
    NT_PRODUCT_TYPE ProductType;
    ULONG LockIndex;
    NTSTATUS Status = STATUS_SUCCESS;


    PackageListLockCount = 1;


    RtlGetNtProductType( &ProductType );

    if( ProductType == NtProductLanManNt ||
        ProductType == NtProductServer )
    {

        SYSTEM_INFO si;

        GetSystemInfo( &si );

        //
        // if not an even power of two, bump it up.
        //

        if( si.dwNumberOfProcessors & 1 )
        {
            si.dwNumberOfProcessors++;
        }

        //
        // insure it fits in the confines of the max allowed.
        //

        if( si.dwNumberOfProcessors > PKG_LIST_LOCKS_MAX )
        {
            si.dwNumberOfProcessors = PKG_LIST_LOCKS_MAX;
        }

        if( si.dwNumberOfProcessors )
        {
            PackageListLockCount = si.dwNumberOfProcessors;
        }

    }


    //
    // list count is 1, or a power of two, for index purposes.
    //

    ASSERT( (PackageListLockCount == 1) || ((PackageListLockCount % 2) == 0) );

    for( LockIndex=0 ; LockIndex < PackageListLockCount ; LockIndex++ )
    {
        __try {
            RtlInitializeResource (&PackageListLock[LockIndex]);
        } __except(EXCEPTION_EXECUTE_HANDLER)
        {
            Status = STATUS_INSUFFICIENT_RESOURCES;
            break;
        }
    }

    if(!NT_SUCCESS(Status))
    {
        return FALSE;
    }


    WriteLockPackageList();

    pPackageDllList = (PDLL_BINDING *) LsapAllocateLsaHeap( sizeof(PDLL_BINDING) *
                            INITIAL_PACKAGE_DLL_SIZE );

    if (pPackageDllList)
    {
        PackageDllCount = 0;
        PackageDllTotal = INITIAL_PACKAGE_DLL_SIZE;

        pPackageControlList = (PLSAP_SECURITY_PACKAGE *) LsapAllocateLsaHeap( sizeof(PLSAP_SECURITY_PACKAGE) *
                                INITIAL_PACKAGE_CONTROL_SIZE );

        if (pPackageControlList)
        {
            PackageControlCount = 0;
            PackageControlTotal = INITIAL_PACKAGE_CONTROL_SIZE;

            WriteUnlockPackageList();

            return( TRUE );
        }

        LsapFreeLsaHeap( pPackageDllList );
    }

    //
    // KEEP the lock, so that nothing else tries to use the package list
    //

    return( FALSE );

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\base\lsa\server\cfiles\adtdebug.h ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    adtdebug.h

Abstract:

    debugging helper functions for auditing code

Author:

    06-November-2001  kumarp

--*/

#include <dsysdbg.h>

#if DBG
#ifdef __cplusplus
extern "C" {
#endif // __cplusplus

    DECLARE_DEBUG2( Adt )

#ifdef __cplusplus
}
#endif

//
// define auditing specific debug flags
// (note that DEB_ERROR/WARN/TRACE are predefined to be 1/2/4)
//
// To add your own flag, add a #define DEB_* flag below and
// also add the corresponding key to AdtDebugKeys array in
// adtdebug.c
//

#define DEB_PUA        0x0008
#define DEB_AUDIT_STRS 0x0010

//
// flag controlled debug output.
//
// Use as shown below. Note the extra set of parens.
//
// AdtDebugOut((DEB_PUA, "allocation failed: %x", Status))
//

#define AdtDebugOut( args ) AdtDebugPrint args

//
// define the assert macro
// it is ok if _AdtFormatMessage returns NULL because
// _DsysAssertEx handles this condition.
//
// Use as shown below. Note the extra set of parens.
//
// AdtAssert(NT_SUCCESS(Status), ("LsapAdtLogAuditFailureEvent failed: %x", Status))
// 

#define AdtAssert( condition, msg ) \
        { \
          if (!(condition)) \
          { \
            char *FormattedMsg; \
            FormattedMsg = _AdtFormatMessage msg; \
            _DsysAssertEx( #condition, __FILE__, __LINE__, \
                           FormattedMsg, \
                           DSYSDBG_ASSERT_DEBUGGER); \
            if ( FormattedMsg ) LsapFreeLsaHeap( FormattedMsg );\
          }\
        }

//
// helper function to format the message
//
char *
_AdtFormatMessage(
    char *Format,
    ...
    );

#else // retail build

#define AdtDebugOut( args ) 
#define AdtAssert( condition, msg )


#endif

void
LsapAdtInitDebug();
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\base\lsa\server\cfiles\adtdebug.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    adtdebug.c

Abstract:

    debugging helper functions for auditing code

Author:

    06-November-2001  kumarp

--*/

#include <lsapch2.h>
#include "adtdebug.h"

#if DBG

DEFINE_DEBUG2(Adt);

//
// To add your own flag, add an entry below and define the flag value
// in adtdebug.h. The string in the flag/string pair will be used in
// the actual debug output as shown below.
//
// 468.512> Adt-PUA: LsapAdtLogAuditFailureEvent failed: 0xc0000001
//
DEBUG_KEY   AdtDebugKeys[] =
{
    {DEB_ERROR,         "Error"},
    {DEB_WARN,          "Warn" },
    {DEB_TRACE,         "Trace"},
    {DEB_PUA,           "PUA"  },
    {DEB_AUDIT_STRS,    "STRS" },
    {0,                 NULL}
};

//
// max size of the formatted string returned by _AdtFormatMessage
//

#define MAX_ADT_DEBUG_BUFFER_SIZE 256

char *
_AdtFormatMessage(
    char *Format,
    ...
    )
/*++

Routine Description:

    Allocate a buffer, put formatted string in it and return a pointer to it.

Arguments:

    Format -- printf style format specifier string
    ...    -- var args

Return Value:

    Allocated & formatted buffer. This is freed using LsapFreeLsaHeap

Notes:

--*/
{
    char *Buffer=NULL;
    int NumCharsWritten=0;
    va_list arglist;
    
    Buffer = LsapAllocateLsaHeap( MAX_ADT_DEBUG_BUFFER_SIZE );

    if ( Buffer )
    {
        va_start(arglist, Format);

        NumCharsWritten =
            _vsnprintf( Buffer, MAX_ADT_DEBUG_BUFFER_SIZE-1, Format, arglist );

        //
        // if _vsnprintf fails for some reason, at least copy the format string
        //

        if ( NumCharsWritten == 0 )
        {
            strncpy( Buffer, Format, MAX_ADT_DEBUG_BUFFER_SIZE-1 );
        }
    }
    else
    {
        AdtDebugOut((DEB_ERROR, "_AdtFormatMessage: failed to allocate buffer"));
    }

    return Buffer;
}


#endif // if DBG


void
LsapAdtInitDebug()
/*++

Routine Description:

    Initialize debug helper functions.

Arguments:

    None.

Return Value:

    None

Notes:

--*/
{
#if DBG
    AdtInitDebug( AdtDebugKeys );
#endif
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\base\lsa\server\cfiles\adtbuild.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    adtbuild.c

Abstract:

    Local Security Authority - Audit Log Management

    Functions in this module build unicode strings for
    various parameter types.  Some parameter string build
    routines may also be found in other modules (such as
    LsapAdtBuildAccessesString() in adtobjs.c).

Author:

    Jim Kelly           (JimK)         29-Oct-1992


Environment:

Revision History:

--*/

#include <lsapch2.h>
#include "adtp.h"
#include "wsautils.h"


////////////////////////////////////////////////////////////////////////
//                                                                    //
//  Local Macro definitions and local function prototypes             //
//                                                                    //
////////////////////////////////////////////////////////////////////////

const LONGLONG ADT_DURATION_ONE_SEC = (LONGLONG)(10000000i64);              // no of 100ns intervals per second
const LONGLONG ADT_DURATION_ONE_DAY = (LONGLONG)(24 * 3600 * 10000000i64);  // no of 100ns intervals per day




////////////////////////////////////////////////////////////////////////
//                                                                    //
//  Data types used within this module                                //
//                                                                    //
////////////////////////////////////////////////////////////////////////




////////////////////////////////////////////////////////////////////////
//                                                                    //
//  Variables global within this module                               //
//                                                                    //
////////////////////////////////////////////////////////////////////////




////////////////////////////////////////////////////////////////////////
//                                                                    //
//  Services exported by this module.                                 //
//                                                                    //
////////////////////////////////////////////////////////////////////////


NTSTATUS
LsapAdtBuildUlongString(
    IN ULONG Value,
    OUT PUNICODE_STRING ResultantString,
    OUT PBOOLEAN FreeWhenDone
    )

/*++

Routine Description:

    This function builds a unicode string representing the passed value.

    The resultant string will be formatted as a decimal value with not
    more than 10 digits.


Arguments:

    Value - The value to be transformed to printable format (Unicode string).

    ResultantString - Points to the unicode string header.  The body of this
        unicode string will be set to point to the resultant output value
        if successful.  Otherwise, the Buffer field of this parameter
        will be set to NULL.

    FreeWhenDone - If TRUE, indicates that the buffer of the ResultantString
        must be freed to process heap when no longer needed.


Return Values:

    STATUS_NO_MEMORY - indicates memory could not be allocated
        for the string body.

    All other Result Codes are generated by called routines.

--*/

{
    NTSTATUS                Status;



    //
    // Maximum length is 10 wchar characters plus a null termination character.
    //

    ResultantString->Length        = 0;
    ResultantString->MaximumLength = 11 * sizeof(WCHAR); // 10 digits & null termination

    ResultantString->Buffer = RtlAllocateHeap( RtlProcessHeap(), 0,
                                               ResultantString->MaximumLength);
    if (ResultantString->Buffer == NULL) {
        return(STATUS_NO_MEMORY);
    }


    Status = RtlIntegerToUnicodeString( Value, 10, ResultantString );
    ASSERT(NT_SUCCESS(Status));


    (*FreeWhenDone) = TRUE;
    return(STATUS_SUCCESS);
}


NTSTATUS
LsapAdtBuildHexUlongString(
    IN ULONG Value,
    OUT PUNICODE_STRING ResultantString,
    OUT PBOOLEAN FreeWhenDone
    )

/*++

Routine Description:

    This function builds a unicode string representing the passed value.

    The resultant string will be formatted as a hexidecimal value with not
    more than 10 digits.


Arguments:

    Value - The value to be transformed to printable format (Unicode string).

    ResultantString - Points to the unicode string header.  The body of this
        unicode string will be set to point to the resultant output value
        if successful.  Otherwise, the Buffer field of this parameter
        will be set to NULL.

    FreeWhenDone - If TRUE, indicates that the buffer of the ResultantString
        must be freed to process heap when no longer needed.


Return Values:

    STATUS_NO_MEMORY - indicates memory could not be allocated
        for the string body.

    All other Result Codes are generated by called routines.

--*/

{
    NTSTATUS                Status;



    //
    // Maximum length is 10 wchar characters plus a null termination character.
    //

    ResultantString->Length        = 0;
    ResultantString->MaximumLength = 11 * sizeof(WCHAR); // 8 digits, a 0x, & null termination

    ResultantString->Buffer = RtlAllocateHeap( RtlProcessHeap(), 0,
                                               ResultantString->MaximumLength);
    if (ResultantString->Buffer == NULL)
    {
        return(STATUS_NO_MEMORY);
    }


    ResultantString->Buffer[0] = L'0';
    ResultantString->Buffer[1] = L'x';
    ResultantString->Buffer += 2;

    Status = RtlIntegerToUnicodeString( Value, 16, ResultantString );
    ASSERT(NT_SUCCESS(Status));

    //
    // Subtract off the two
    //

    ResultantString->Buffer -= 2;
    ResultantString->Length += 2 * sizeof(WCHAR);

    (*FreeWhenDone) = TRUE;
    return(STATUS_SUCCESS);
}


NTSTATUS
LsapAdtBuildHexInt64String(
    IN PULONGLONG Value,
    OUT PUNICODE_STRING ResultantString,
    OUT PBOOLEAN FreeWhenDone
    )

/*++

Routine Description:

    This function builds a unicode string representing the passed value.

    The resultant string will be formatted as a hexidecimal value with not
    more than 18 digits.


Arguments:

    Value - The value to be transformed to printable format (Unicode string).

    ResultantString - Points to the unicode string header.  The body of this
        unicode string will be set to point to the resultant output value
        if successful.  Otherwise, the Buffer field of this parameter
        will be set to NULL.

    FreeWhenDone - If TRUE, indicates that the buffer of the ResultantString
        must be freed to process heap when no longer needed.


Return Values:

    STATUS_NO_MEMORY - indicates memory could not be allocated
        for the string body.

    All other Result Codes are generated by called routines.

--*/

{
    NTSTATUS                Status;
    int                     Length;


    //
    // Maximum length is 18 wchar characters plus a null termination character.
    //

    ResultantString->Length        = 0;
    ResultantString->MaximumLength = 19 * sizeof(WCHAR); // '0x' & 16 digits & null termination

    ResultantString->Buffer = LsapAllocateLsaHeap(ResultantString->MaximumLength);

    if (ResultantString->Buffer == NULL)
    {
        return STATUS_NO_MEMORY;
    }

    Length = _snwprintf(ResultantString->Buffer,
                        19,
                        L"0x%I64X",
                        *Value);

    ASSERT(3 <= Length && Length <= 18);

    ResultantString->Length = (USHORT)(Length * sizeof(WCHAR));

    (*FreeWhenDone) = TRUE;

    return STATUS_SUCCESS;
}


NTSTATUS
LsapAdtBuildPtrString(
    IN  PVOID Value,
    OUT PUNICODE_STRING ResultantString,
    OUT PBOOLEAN FreeWhenDone
    )

/*++

Routine Description:

    This function builds a unicode string representing the passed pointer.

    The resultant string will be formatted as a decimal value.


Arguments:

    Value - The value to be transformed to printable format (Unicode string).

    ResultantString - Points to the unicode string header.  The body of this
        unicode string will be set to point to the resultant output value
        if successful.  Otherwise, the Buffer field of this parameter
        will be set to NULL.

    FreeWhenDone - If TRUE, indicates that the buffer of the ResultantString
        must be freed to process heap when no longer needed.


Return Values:

    STATUS_NO_MEMORY - indicates memory could not be allocated
        for the string body.

    All other Result Codes are generated by called routines.

--*/

{
    NTSTATUS Status = STATUS_SUCCESS;
    USHORT NumChars;
    PCWSTR szFormat;
    
    ResultantString->Length        = 0;
    //
    // Maximum length: sign (+ / -) + 20 decimal digits + null + 2 bonus == 24 chars
    //
    ResultantString->MaximumLength = 24 * sizeof(WCHAR);

    ResultantString->Buffer = RtlAllocateHeap( RtlProcessHeap(), 0,
                                               ResultantString->MaximumLength);
    if (ResultantString->Buffer == NULL) {
    
        Status = STATUS_NO_MEMORY;

    } else {

#if _WIN64
        szFormat = L"%I64d";
#else
        szFormat = L"%ld";
#endif
    
        NumChars = (USHORT) wsprintf( ResultantString->Buffer, szFormat, Value );

        ResultantString->Length = NumChars * sizeof(WCHAR);

        DsysAssertMsg( ResultantString->Length <= ResultantString->MaximumLength,
                       "LsapAdtBuildPtrString" );

        (*FreeWhenDone) = TRUE;
    }
    
    return Status;
}


NTSTATUS
LsapAdtBuildLuidString(
    IN PLUID Value,
    OUT PUNICODE_STRING ResultantString,
    OUT PBOOLEAN FreeWhenDone
    )

/*++

Routine Description:

    This function builds a unicode string representing the passed LUID.

    The resultant string will be formatted as follows:

        (0x00005678,0x12340000)

Arguments:

    Value - The value to be transformed to printable format (Unicode string).

    ResultantString - Points to the unicode string header.  The body of this
        unicode string will be set to point to the resultant output value
        if successful.  Otherwise, the Buffer field of this parameter
        will be set to NULL.

    FreeWhenDone - If TRUE, indicates that the buffer of the ResultantString
        must be freed to process heap when no longer needed.


Return Values:

    STATUS_NO_MEMORY - indicates memory could not be allocated
        for the string body.

    All other Result Codes are generated by called routines.

--*/

{
    NTSTATUS                Status;
    UNICODE_STRING          IntegerString;
    WCHAR                   Buffer[16];


    IntegerString.Buffer = (PWCHAR)&Buffer[0];
    IntegerString.MaximumLength = sizeof(Buffer);


    //
    // Length (in WCHARS) is  3 for   (0x
    //                       10 for   1st hex number
    //                        3 for   ,0x
    //                       10 for   2nd hex number
    //                        1 for   )
    //                        1 for   null termination
    //

    ResultantString->Length        = 0;
    ResultantString->MaximumLength = 28 * sizeof(WCHAR);

    ResultantString->Buffer = RtlAllocateHeap( RtlProcessHeap(), 0,
                                               ResultantString->MaximumLength);
    if (ResultantString->Buffer == NULL) {
        return(STATUS_NO_MEMORY);
    }



    Status = RtlAppendUnicodeToString( ResultantString, L"(0x" );
    ASSERT(NT_SUCCESS(Status));


    Status = RtlIntegerToUnicodeString( Value->HighPart, 16, &IntegerString );
    ASSERT(NT_SUCCESS(Status));
    Status = RtlAppendUnicodeToString( ResultantString, IntegerString.Buffer );
    ASSERT(NT_SUCCESS(Status));


    Status = RtlAppendUnicodeToString( ResultantString, L",0x" );
    ASSERT(NT_SUCCESS(Status));

    Status = RtlIntegerToUnicodeString( Value->LowPart, 16, &IntegerString );
    ASSERT(NT_SUCCESS(Status));
    Status = RtlAppendUnicodeToString( ResultantString, IntegerString.Buffer );
    ASSERT(NT_SUCCESS(Status));

    Status = RtlAppendUnicodeToString( ResultantString, L")" );
    ASSERT(NT_SUCCESS(Status));


    (*FreeWhenDone) = TRUE;
    return(STATUS_SUCCESS);



}


NTSTATUS
LsapAdtBuildSidString(
    IN PSID Value,
    OUT PUNICODE_STRING ResultantString,
    OUT PBOOLEAN FreeWhenDone
    )

/*++

Routine Description:

    This function builds a unicode string representing the passed LUID.

    The resultant string will be formatted as follows:

        S-1-281736-12-72-9-110
              ^    ^^ ^^ ^ ^^^
              |     |  | |  |
              +-----+--+-+--+---- Decimal

Arguments:

    Value - The value to be transformed to printable format (Unicode string).

    ResultantString - Points to the unicode string header.  The body of this
        unicode string will be set to point to the resultant output value
        if successful.  Otherwise, the Buffer field of this parameter
        will be set to NULL.

    FreeWhenDone - If TRUE, indicates that the buffer of the ResultantString
        must be freed to process heap when no longer needed.


Return Values:

    STATUS_NO_MEMORY - indicates memory could not be allocated
        for the string body.

    All other Result Codes are generated by called routines.

--*/

{
    NTSTATUS Status=STATUS_NO_MEMORY;
    LPWSTR   UniBuffer=NULL;
    USHORT   Len;
    USHORT   MaxLen;
    
    *FreeWhenDone = FALSE;

    //
    // Longhorn-ISSUE-2002/03/11-kumarp : replace 256 by the constant that Kedar
    //                                    is going to define
    //

    //
    // Note: RtlConvertSidToUnicodeString also uses a hard-coded const 256
    //       to generate the string SID.
    //
    MaxLen    = (256+3) * sizeof(WCHAR);
    UniBuffer = LsapAllocateLsaHeap(MaxLen);

    if (UniBuffer)
    {
        ResultantString->Buffer        = UniBuffer+2;
        ResultantString->MaximumLength = MaxLen;
        Status = RtlConvertSidToUnicodeString( ResultantString, Value, FALSE );

        if (Status == STATUS_SUCCESS)
        {
            *FreeWhenDone = TRUE;
            UniBuffer[0] = L'%';
            UniBuffer[1] = L'{';
            Len = ResultantString->Length / sizeof(WCHAR);
            UniBuffer[Len+2] = L'}';
            UniBuffer[Len+3] = UNICODE_NULL;
            ResultantString->Buffer = UniBuffer;
            ResultantString->Length = (Len+3)*sizeof(WCHAR);
        }
        else
        {
            LsapFreeLsaHeap(UniBuffer);
        }
    }

    return(Status);
}



NTSTATUS
LsapAdtBuildDashString(
    OUT PUNICODE_STRING ResultantString,
    OUT PBOOLEAN FreeWhenDone
    )

/*++

Routine Description:

    This function returns a string containing a dash ("-").
    This is commonly used to represent "No value" in audit records.


Arguments:


    ResultantString - Points to the unicode string header.  The body of this
        unicode string will be set to point to the resultant output value
        if successful.  Otherwise, the Buffer field of this parameter
        will be set to NULL.

    FreeWhenDone - If TRUE, indicates that the buffer of the ResultantString
        must be freed to process heap when no longer needed.


Return Values:

    STATUS_SUCCESS only.

--*/

{
    RtlInitUnicodeString(ResultantString, L"-");

    (*FreeWhenDone) = FALSE;

    return STATUS_SUCCESS;
}



NTSTATUS
LsapAdtBuildLogonIdStrings(
    IN PLUID LogonId,
    OUT PUNICODE_STRING ResultantString1,
    OUT PBOOLEAN FreeWhenDone1,
    OUT PUNICODE_STRING ResultantString2,
    OUT PBOOLEAN FreeWhenDone2,
    OUT PUNICODE_STRING ResultantString3,
    OUT PBOOLEAN FreeWhenDone3
    )

/*++

Routine Description:

    This function builds a 3 unicode strings representing the specified
    logon ID.  These strings will contain the username, domain, and
    LUID string of the specified logon session (respectively).


Arguments:

    Value - The logon ID.

    ResultantString1 - Points to the unicode string header.  The body of this
        unicode string will be set to point to the resultant output value
        if successful.  Otherwise, the Buffer field of this parameter
        will be set to NULL.

        This parameter will contain the username.


    FreeWhenDone1 - If TRUE, indicates that the buffer of ResultantString1
        must be freed to process heap when no longer needed.

    ResultantString2 - Points to the unicode string header.  The body of this
        unicode string will be set to point to the resultant output value
        if successful.  Otherwise, the Buffer field of this parameter
        will be set to NULL.

        This parameter will contain the username.


    FreeWhenDone2 - If TRUE, indicates that the buffer of ResultantString2
        must be freed to process heap when no longer needed.

    ResultantString3 - Points to the unicode string header.  The body of this
        unicode string will be set to point to the resultant output value
        if successful.  Otherwise, the Buffer field of this parameter
        will be set to NULL.

        This parameter will contain the username.


    FreeWhenDone3 - If TRUE, indicates that the buffer of ResultantString3
        must be freed to process heap when no longer needed.


Return Values:

    STATUS_NO_MEMORY - indicates memory could not be allocated
        for the string body.

    All other Result Codes are generated by called routines.

--*/

{
    NTSTATUS                Status;

    //
    // Try to convert the LUID first.
    //

    Status = LsapAdtBuildLuidString( LogonId, ResultantString3, FreeWhenDone3 );

    if (NT_SUCCESS(Status)) {


        //
        // Now get the username and domain names
        //

        Status = LsapGetLogonSessionAccountInfo( LogonId,
                                                 ResultantString1,
                                                 ResultantString2
                                                 );

        if (NT_SUCCESS(Status)) {

            (*FreeWhenDone1) = TRUE;
            (*FreeWhenDone2) = TRUE;

        } else {

            //
            // The LUID may be the system LUID
            //

            LUID SystemLuid = SYSTEM_LUID;

            if ( RtlEqualLuid( LogonId, &SystemLuid )) {

                RtlInitUnicodeString(ResultantString1, L"SYSTEM");
                RtlInitUnicodeString(ResultantString2, L"SYSTEM");

                (*FreeWhenDone1) = FALSE;
                (*FreeWhenDone2) = FALSE;

                Status = STATUS_SUCCESS;

            } else if ( Status == STATUS_NO_SUCH_LOGON_SESSION ) {

                //
                // if the logon session went away (due to a logoff)
                // before we could generate this audit, just use '-'
                // for user/domain name. We still have the logon ID
                // which can be used to locate the logon audit to get
                // user/domain info.
                //

                RtlInitUnicodeString(ResultantString1, L"-");
                RtlInitUnicodeString(ResultantString2, L"-");

                (*FreeWhenDone1) = FALSE;
                (*FreeWhenDone2) = FALSE;

                Status = STATUS_SUCCESS;
            
            } else {

                //
                // We have no clue what this is, just free what we've
                // allocated.
                //

                if ((FreeWhenDone3)) {
                    LsapFreeLsaHeap( ResultantString3->Buffer );
                }
            }
        }
    }

    return(Status);

}



NTSTATUS
LsapAdtBuildTimeString(
    IN PLARGE_INTEGER Value,
    OUT PUNICODE_STRING ResultantString,
    OUT PBOOLEAN FreeWhenDone
    )

/*++

Routine Description:

    This function builds a unicode string representing the passed time.

Arguments:

    Value - The value to be transformed to printable format (Unicode string).

    ResultantString - Points to the unicode string header.  The body of this
        unicode string will be set to point to the resultant output value
        if successful.  Otherwise, the Buffer field of this parameter
        will be set to NULL.

    FreeWhenDone - If TRUE, indicates that the buffer of the ResultantString
        must be freed to process heap when no longer needed.


Return Values:

    STATUS_NO_MEMORY - indicates memory could not be allocated
        for the string body.

    All other Result Codes are generated by called routines.

--*/

{
    NTSTATUS    Status        = STATUS_UNSUCCESSFUL;
    BOOL        b             = TRUE;
    SYSTEMTIME  SystemTime    = {0};
    FILETIME    LocalFileTime = {0};
    USHORT      Length        = 0;
    WCHAR       DataString[128];


    //
    // Check whether the time is valid.
    // A valid time must be > 0.
    //

    if (Value->QuadPart <= ADT_DURATION_ONE_DAY)
    {
        RtlInitUnicodeString(ResultantString, L"-");

        *FreeWhenDone = FALSE;

        return STATUS_SUCCESS;
    }


    //
    // First convert time to readable format.
    //

    b = FileTimeToLocalFileTime(
            (PFILETIME)Value,
            &LocalFileTime
            );

    if (!b)
    {
        return Status;
    }

    b = FileTimeToSystemTime(
            &LocalFileTime,
            &SystemTime
            );

    if (!b)
    {
        return Status;
    }

    if (0 == GetTimeFormat(
                LOCALE_SYSTEM_DEFAULT,
                LOCALE_NOUSEROVERRIDE,
                &SystemTime,
                NULL,
                DataString,
                128
                ))
    {
        return Status;
    }

    Length = (USHORT) wcslen( DataString );

    ResultantString->MaximumLength = sizeof(WCHAR) * Length;
    ResultantString->Length        = sizeof(WCHAR) * Length;
    ResultantString->Buffer        = LsapAllocateLsaHeap(sizeof(WCHAR) * Length);

    if (ResultantString->Buffer == NULL)
    {
        return(STATUS_NO_MEMORY);
    }

    RtlCopyMemory(
        ResultantString->Buffer,
        DataString,
        sizeof(WCHAR) * Length
        );

    *FreeWhenDone = TRUE;
    
    return STATUS_SUCCESS;
}



NTSTATUS
LsapAdtBuildDateString(
    IN PLARGE_INTEGER Value,
    OUT PUNICODE_STRING ResultantString,
    OUT PBOOLEAN FreeWhenDone
    )

/*++

Routine Description:

    This function builds a unicode string representing the passed date.

Arguments:

    Value - The value to be transformed to printable format (Unicode string).

    ResultantString - Points to the unicode string header.  The body of this
        unicode string will be set to point to the resultant output value
        if successful.  Otherwise, the Buffer field of this parameter
        will be set to NULL.

    FreeWhenDone - If TRUE, indicates that the buffer of the ResultantString
        must be freed to process heap when no longer needed.


Return Values:

    STATUS_NO_MEMORY - indicates memory could not be allocated
        for the string body.

    All other Result Codes are generated by called routines.

--*/

{
    NTSTATUS    Status        = STATUS_UNSUCCESSFUL;
    BOOL        b             = TRUE;
    SYSTEMTIME  SystemTime    = {0};
    FILETIME    LocalFileTime = {0};
    USHORT      Length        = 0;
    WCHAR       DataString[128];


    //
    // Check whether the time is valid.
    // A valid time must be > 0.
    //

    if (Value->QuadPart <= ADT_DURATION_ONE_DAY)
    {
        RtlInitUnicodeString(ResultantString, L"-");

        *FreeWhenDone = FALSE;

        return STATUS_SUCCESS;
    }


    //
    // Convert time to readable format.
    //

    b = FileTimeToLocalFileTime(
            (PFILETIME)Value,
            &LocalFileTime
            );

    if (!b)
    {
        return Status;
    }

    b = FileTimeToSystemTime(
            &LocalFileTime,
            &SystemTime
            );

    if (!b)
    {
        return Status;
    }

    if (0 == GetDateFormat(
                LOCALE_SYSTEM_DEFAULT,
                LOCALE_NOUSEROVERRIDE,
                &SystemTime,
                NULL,
                DataString,
                128
                ))
    {
        return Status;
    }

    Length = (USHORT) wcslen( DataString );
    
    ResultantString->MaximumLength = sizeof(WCHAR) * Length;
    ResultantString->Length        = sizeof(WCHAR) * Length;
    ResultantString->Buffer        = LsapAllocateLsaHeap(sizeof(WCHAR) * Length);

    if (ResultantString->Buffer == NULL)
    {
        return(STATUS_NO_MEMORY);
    }

    RtlCopyMemory(
        ResultantString->Buffer,
        DataString,
        sizeof(WCHAR) * Length
        );

    *FreeWhenDone = TRUE;
    
    return STATUS_SUCCESS;
}



NTSTATUS
LsapAdtBuildDateTimeString(
    IN PLARGE_INTEGER Value,
    OUT PUNICODE_STRING ResultantString,
    OUT PBOOLEAN FreeWhenDone
    )

/*++

Routine Description:

    This function builds a unicode string representing the passed
    date and time.

Arguments:

    Value - The value to be transformed to printable format (Unicode string).

    ResultantString - Points to the unicode string header.  The body of this
        unicode string will be set to point to the resultant output value
        if successful.  Otherwise, the Buffer field of this parameter
        will be set to NULL.

    FreeWhenDone - If TRUE, indicates that the buffer of the ResultantString
        must be freed to process heap when no longer needed.


Return Values:

    STATUS_NO_MEMORY - indicates memory could not be allocated
        for the string body.

    All other Result Codes are generated by called routines.

--*/

{
    NTSTATUS    Status        = STATUS_UNSUCCESSFUL;
    BOOL        b             = TRUE;
    SYSTEMTIME  SystemTime    = {0};
    FILETIME    LocalFileTime = {0};
    USHORT      Length        = 0;
    USHORT      DateLength    = 0;
    USHORT      TimeLength    = 0;
    WCHAR       DateString[128];
    WCHAR       TimeString[128];


    //
    // Check whether the time is valid.
    // A valid time must be > 0.
    //

    if (Value->QuadPart <= ADT_DURATION_ONE_DAY)
    {
        RtlInitUnicodeString(ResultantString, L"-");

        *FreeWhenDone = FALSE;

        return STATUS_SUCCESS;
    }


    //
    // First convert time to readable format.
    //

    b = FileTimeToLocalFileTime(
            (PFILETIME)Value,
            &LocalFileTime
            );

    if (!b)
    {
        return Status;
    }

    b = FileTimeToSystemTime(
            &LocalFileTime,
            &SystemTime
            );

    if (!b)
    {
        return Status;
    }

    if (0 == GetDateFormat(
                LOCALE_SYSTEM_DEFAULT,
                LOCALE_NOUSEROVERRIDE,
                &SystemTime,
                NULL,
                DateString,
                128
                ))
    {
        return Status;
    }

    if (0 == GetTimeFormat(
                LOCALE_SYSTEM_DEFAULT,
                LOCALE_NOUSEROVERRIDE,
                &SystemTime,
                NULL,
                TimeString,
                128
                ))
    {
        return Status;
    }

    DateLength = (USHORT) wcslen(DateString);
    TimeLength = (USHORT) wcslen(TimeString);

    Length  = DateLength;
    Length += 1;    // for the blank
    Length += TimeLength;

    ResultantString->MaximumLength = sizeof(WCHAR) * Length;
    ResultantString->Length        = sizeof(WCHAR) * Length;
    ResultantString->Buffer        = LsapAllocateLsaHeap(
                                         ResultantString->MaximumLength);

    if (ResultantString->Buffer == NULL)
    {
        return STATUS_NO_MEMORY;
    }

    *FreeWhenDone = TRUE;

    RtlCopyMemory(
        ResultantString->Buffer,
        DateString,
        sizeof(WCHAR) * DateLength
        );

    RtlCopyMemory(
        ResultantString->Buffer + DateLength,
        L" ",
        sizeof(WCHAR) * 1
        );

    RtlCopyMemory(
        ResultantString->Buffer + DateLength + 1,
        TimeString,
        sizeof(WCHAR) * TimeLength
        );

    return STATUS_SUCCESS;
}



NTSTATUS
LsapAdtBuildDurationString(
    IN PLARGE_INTEGER Value,
    OUT PUNICODE_STRING ResultantString,
    OUT PBOOLEAN FreeWhenDone
    )

/*++

Routine Description:

    This function builds a unicode string representing the passed 
    duration in seconds.


Arguments:

    Value - The value to be transformed to printable format (Unicode string).

    ResultantString - Points to the unicode string header.  The body of this
        unicode string will be set to point to the resultant output value
        if successful.  Otherwise, the Buffer field of this parameter
        will be set to NULL.

    FreeWhenDone - If TRUE, indicates that the buffer of the ResultantString
        must be freed to process heap when no longer needed.


Return Values:

    STATUS_NO_MEMORY - indicates memory could not be allocated
        for the string body.

    All other Result Codes are generated by called routines.

--*/

{
    NTSTATUS    Status        = STATUS_SUCCESS;
    LONGLONG    Seconds       = Value->QuadPart;
    ULONG       Length        = 0;

    *FreeWhenDone = FALSE;


    //
    // Check whether we got a negative value.
    // In the kernel, durations are expressed as negative numbers.
    //

    if (Seconds < 0)
    {
        Seconds *= -1;
    }


    //
    // Display the duration as a number of seconds.
    //

    Seconds /= ADT_DURATION_ONE_SEC; // get from 100ns intervals to seconds.


    //
    // Maximum length is 13 wchar characters plus a null termination character.
    //

    ResultantString->Length         = 0;
    ResultantString->MaximumLength  = 16 * sizeof(WCHAR);
    ResultantString->Buffer         = LsapAllocateLsaHeap(ResultantString->MaximumLength);

    if (ResultantString->Buffer == NULL)
    {
        return STATUS_NO_MEMORY;
    }

    *FreeWhenDone = TRUE;

    Length = _snwprintf(ResultantString->Buffer,
                        16,
                        L"%I64u",
                        Seconds);

    ASSERT(1 <= Length && Length <= 15);

    ResultantString->Length = (USHORT)(Length * sizeof(WCHAR));

    return STATUS_SUCCESS;
}


NTSTATUS
LsapAdtBuildGuidString(
    IN  LPGUID pGui