/

    if (!WriteDataRegister(deviceExtension,
        ((PFOUR_BYTE)&noncachedExtension->MailboxPA)->Byte2)) {
        return FALSE;
    }

    //
    // Send the middle byte of the mailbox physical address.
    //

    if (!WriteDataRegister(deviceExtension,
        ((PFOUR_BYTE)&noncachedExtension->MailboxPA)->Byte1)) {
        return FALSE;
    }

    //
    // Send the least significant byte of the mailbox physical address.
    //

    if (!WriteDataRegister(deviceExtension,
        ((PFOUR_BYTE)&noncachedExtension->MailboxPA)->Byte0)) {
        return FALSE;
    }

#ifdef FORCE_DMA_SPEED
    //
    // Set the DMA transfer speed to 5.0 MB/second. This is because
    // faster transfer speeds cause data corruption on 486/33 machines.
    // This overrides the card jumper setting.
    //

    if (!WriteCommandRegister(deviceExtension, AC_SET_TRANSFER_SPEED, TRUE)) {

        DebugPrint((1,"Can't set dma transfer speed\n"));

    } else if (!WriteDataRegister(deviceExtension, DMA_SPEED_50_MBS)) {

        DebugPrint((1,"Can't set dma transfer speed\n"));
    }

    //
    // Wait for interrupt.
    //

    if (!SpinForInterrupt(deviceExtension,TRUE)) {
        DebugPrint((1,"Timed out waiting for adapter command to complete\n"));
    }
#endif

    //
    // Override default setting for bus on time. This makes floppy
    // drives work better with this adapter.
    //

    if (!WriteCommandRegister(deviceExtension, AC_SET_BUS_ON_TIME, TRUE)) {

        DebugPrint((1,"Can't set bus on time\n"));

    } else if (!WriteDataRegister(deviceExtension, 0x07)) {

        DebugPrint((1,"Can't set bus on time\n"));
    }

    //
    // Wait for interrupt.
    //

    if (!SpinForInterrupt(deviceExtension,TRUE)) {
        DebugPrint((1,"Timed out waiting for adapter command to complete\n"));
    }

#if defined(_SCAM_ENABLED)
        //
        // SCAM because we're a154xResetBus
        //
    PerformScamProtocol(deviceExtension);
#endif
    return TRUE;


} // end A154xResetBus()


UCHAR
MapError(
    IN PVOID HwDeviceExtension,
    IN PSCSI_REQUEST_BLOCK Srb,
    IN PCCB Ccb
    )

/*++

Routine Description:

    Translate A154x error to SRB error, and log an error if necessary.

Arguments:

    HwDeviceExtension - The hardware device extension.

    Srb - The failing Srb.

    Ccb - Command Control Block contains error.

Return Value:

    SRB Error

--*/

{
    PHW_DEVICE_EXTENSION deviceExtension = HwDeviceExtension;
    UCHAR status;
    ULONG logError;
    ULONG residualBytes;

    switch (Ccb->HostStatus) {

        case CCB_SELECTION_TIMEOUT:

            return SRB_STATUS_SELECTION_TIMEOUT;

        case CCB_COMPLETE:

            if (Ccb->TargetStatus == SCSISTAT_CHECK_CONDITION) {

                //
                // Update SRB with number of bytes transferred.
                //

                THREE_TO_FOUR((PFOUR_BYTE)&residualBytes,
                          &Ccb->DataLength);

                DebugPrint((2, "Aha154x MapError: Underrun occured. Request length = %lx, Residual length = %lx\n", Srb->DataTransferLength, residualBytes));
                if (Srb->DataTransferLength < residualBytes) {
                    DebugPrint((0,
                               "A154xInterrupt: Overrun occured. Request length = %lx, Residual length = %lx\n",
                               Srb->DataTransferLength,
                               residualBytes));
                    //
                    // Seems to be a FW bug in some revs. where
                    // residual comes back as a negative number, yet the
                    // request is successful.
                    //

                    Srb->DataTransferLength = 0;
                    Srb->SrbStatus = SRB_STATUS_PHASE_SEQUENCE_FAILURE;

                    //
                    // Log the event and then the residual byte count.
                    //

                    ScsiPortLogError(HwDeviceExtension,
                                     NULL,
                                     0,
                                     deviceExtension->HostTargetId,
                                     0,
                                     SP_PROTOCOL_ERROR,
                                     0xc << 8);

                    return(SRB_STATUS_PHASE_SEQUENCE_FAILURE);

                } else {
                    Srb->DataTransferLength -= residualBytes;
                }

            }

            return SRB_STATUS_ERROR;

        case CCB_DATA_OVER_UNDER_RUN:


            //
            // Check for data underrun if using scatter/gather
            // command with residual bytes.
            //

            if (deviceExtension->CcbScatterGatherCommand == SCATTER_GATHER_COMMAND) {

                THREE_TO_FOUR((PFOUR_BYTE)&residualBytes,
                      &Ccb->DataLength);

                if (residualBytes) {
                    if (Srb->DataTransferLength < residualBytes) {

                        DebugPrint((0,
                                   "A154xInterrupt: Overrun occured. Request length = %lx, Residual length = %lx\n",
                                   Srb->DataTransferLength,
                                   residualBytes));
                        //
                        // Seems to be a FW bug in some revs. where
                        // residual comes back as a negative number, yet the
                        // request is successful.
                        //

                        Srb->DataTransferLength = 0;
                        Srb->SrbStatus = SRB_STATUS_PHASE_SEQUENCE_FAILURE;

                        //
                        // Log the event and then the residual byte count.
                        //

                        ScsiPortLogError(HwDeviceExtension,
                                         NULL,
                                         0,
                                         deviceExtension->HostTargetId,
                                         0,
                                         SP_PROTOCOL_ERROR,
                                         0xd << 8);

                        return(SRB_STATUS_PHASE_SEQUENCE_FAILURE);

                    } else {
                        Srb->DataTransferLength -= residualBytes;
                    }

                    return SRB_STATUS_DATA_OVERRUN; //##BW this look good
                } else {
                    logError = SP_PROTOCOL_ERROR;
                }
            }

                        //
                        //  Return instead of posting DU/DO to the log file.
                        //
            //status = SRB_STATUS_DATA_OVERRUN;
            return SRB_STATUS_DATA_OVERRUN;
            break;

        case CCB_UNEXPECTED_BUS_FREE:
            status = SRB_STATUS_UNEXPECTED_BUS_FREE;
            logError = SP_UNEXPECTED_DISCONNECT;
            break;

        case CCB_PHASE_SEQUENCE_FAIL:
        case CCB_INVALID_DIRECTION:
            status = SRB_STATUS_PHASE_SEQUENCE_FAILURE;
            logError = SP_PROTOCOL_ERROR;
            break;

        case CCB_INVALID_OP_CODE:

            //
            // Try CCB commands without residual bytes.
            //

            deviceExtension->CcbScatterGatherCommand = SCATTER_GATHER_OLD_COMMAND;
            deviceExtension->CcbInitiatorCommand = SCSI_INITIATOR_OLD_COMMAND;
            status = SRB_STATUS_INVALID_REQUEST;
            logError = SP_BAD_FW_WARNING;
            break;

        case CCB_INVALID_CCB:
        case CCB_BAD_MBO_COMMAND:
        case CCB_BAD_LINKED_LUN:
        case CCB_DUPLICATE_CCB:
            status = SRB_STATUS_INVALID_REQUEST;
            logError = SP_INTERNAL_ADAPTER_ERROR;
            break;

        default:
            status = SRB_STATUS_ERROR;
            logError = SP_INTERNAL_ADAPTER_ERROR;
            break;
        }

    ScsiPortLogError(
            HwDeviceExtension,
            Srb,
            Srb->PathId,
            Srb->TargetId,
            Srb->Lun,
            logError,
            (2 << 8) | Ccb->HostStatus
            );

    return(status);

} // end MapError()


BOOLEAN
ReadCommandRegister(
    IN PHW_DEVICE_EXTENSION DeviceExtension,
    OUT PUCHAR DataByte,
    IN BOOLEAN TimeOutFlag
    )

/*++

Routine Description:

    Read command register.

Arguments:

    DeviceExtesion - Pointer to adapder extension
    DataByte - Byte read from register

Return Value:

    TRUE if command register read.
    FALSE if timed out waiting for adapter.

--*/

{
    PBASE_REGISTER baseIoAddress = DeviceExtension->BaseIoAddress;
    ULONG i;

    //
    // Wait up to 5000 microseconds for adapter to be ready.
    //

    for (i=0; i<5000; i++) {

        if (ScsiPortReadPortUchar(&baseIoAddress->StatusRegister) &
            IOP_DATA_IN_PORT_FULL) {

            //
            // Adapter ready. Break out of loop.
            //

            break;

        } else {

            //
            // Stall 1 microsecond before
            // trying again.
            //

            ScsiPortStallExecution(1);
        }
    }

    if ( (i==5000) && (TimeOutFlag == TRUE)) {

        ScsiPortLogError(
            DeviceExtension,
            NULL,
            0,
            DeviceExtension->HostTargetId,
            0,
            SP_INTERNAL_ADAPTER_ERROR,
            3 << 8
            );

        DebugPrint((1, "Aha154x:ReadCommandRegister:  Read command timed out\n"));
        return FALSE;
    }

    *DataByte = ScsiPortReadPortUchar(&baseIoAddress->CommandRegister);

    return TRUE;

} // end ReadCommandRegister()


BOOLEAN
WriteCommandRegister(
    IN PHW_DEVICE_EXTENSION DeviceExtension,
    IN UCHAR AdapterCommand,
    IN BOOLEAN WaitForIdle
    )

/*++

Routine Description:

    Write operation code to command register.

Arguments:

    DeviceExtension - Pointer to adapter extension
    AdapterCommand - Value to be written to register
    WaitForIdle - Indicates if the idle bit needs to be checked

Return Value:

    TRUE if command sent.
    FALSE if timed out waiting for adapter.

--*/

{
    PBASE_REGISTER baseIoAddress = DeviceExtension->BaseIoAddress;
    ULONG i;
    UCHAR status;

    //
    // Wait up to 500 milliseconds for adapter to be ready.
    //

    for (i=0; i<5000; i++) {

        status = ScsiPortReadPortUchar(&baseIoAddress->StatusRegister);

        if ((status & IOP_COMMAND_DATA_OUT_FULL) ||
            ( WaitForIdle && !(status & IOP_SCSI_HBA_IDLE))) {

            //
            // Stall 100 microseconds before
            // trying again.
            //

            ScsiPortStallExecution(100);

        } else {

            //
            // Adapter ready. Break out of loop.
            //

            break;
        }
    }

    if (i==5000) {

        ScsiPortLogError(
            DeviceExtension,
            NULL,
            0,
            DeviceExtension->HostTargetId,
            0,
            SP_INTERNAL_ADAPTER_ERROR,
            (4 << 8) | status
            );


        DebugPrint((1, "Aha154x:WriteCommandRegister:  Write command timed out\n"));
        return FALSE;
    }

    ScsiPortWritePortUchar(&baseIoAddress->CommandRegister, AdapterCommand);

    return TRUE;

} // end WriteCommandRegister()


BOOLEAN
WriteDataRegister(
    IN PHW_DEVICE_EXTENSION DeviceExtension,
    IN UCHAR DataByte
    )

/*++

Routine Description:

    Write data byte to data register.

Arguments:

    DeviceExtension - Pointer to adapter extension
    DataByte - Value to be written to register

Return Value:

    TRUE if byte sent.
    FALSE if timed out waiting for adapter.

--*/

{
    PBASE_REGISTER baseIoAddress = DeviceExtension->BaseIoAddress;
    ULONG i;

    //
    // Wait up to 500 microseconds for adapter to be idle
    // and ready for next byte.
    //

    for (i=0; i<500; i++) {

        if (ScsiPortReadPortUchar(&baseIoAddress->StatusRegister) &
            IOP_COMMAND_DATA_OUT_FULL) {

            //
            // Stall 1 microsecond before
            // trying again.
            //

            ScsiPortStallExecution(1);

        } else {

            //
            // Adapter ready. Break out of loop.
            //

            break;
        }
    }

    if (i==500) {

        ScsiPortLogError(
            DeviceExtension,
            NULL,
            0,
            DeviceExtension->HostTargetId,
            0,
            SP_INTERNAL_ADAPTER_ERROR,
            8 << 8
            );

        DebugPrint((1, "Aha154x:WriteDataRegister:  Write data timed out\n"));
        return FALSE;
    }

    ScsiPortWritePortUchar(&baseIoAddress->CommandRegister, DataByte);

    return TRUE;

} // end WriteDataRegister()


BOOLEAN
FirmwareBug (
    IN PVOID HwDeviceExtension
    )

/*++

Routine Description:

    Check to see if the host adapter firmware has the scatter/gather
    bug.

Arguments:

    HwDeviceExtension - HBA miniport driver's adapter data storage

Return Value:

    Return FALSE if there is no firmware bug.
    Return TRUE if firmware has scatter/gather bug.

--*/

{
    PHW_DEVICE_EXTENSION deviceExtension = HwDeviceExtension;
    PBASE_REGISTER baseIoAddress = deviceExtension->BaseIoAddress;
    UCHAR ch;
    int i;

    //
    // Issue a RETURN SETUP DATA command
    // If timeout then return TRUE to indicate that there is a firmware bug.
    //

    if ((WriteCommandRegister(HwDeviceExtension,
        AC_RETURN_SETUP_DATA,FALSE)) == FALSE) {
        return TRUE;
    }


    //
    // Tell the adapter we want to read in 0x11 bytes.
    //

    if (WriteDataRegister(HwDeviceExtension,0x11) == FALSE) {
        return TRUE;
    }

    //
    // Now try to read in 0x11 bytes.
    //

    for (i = 0; i< 0x11; i++) {
        if (ReadCommandRegister(HwDeviceExtension,&ch,TRUE) == FALSE) {
            return TRUE;
        }
    }

    //
    // Wait for HACC interrupt.
    //

    SpinForInterrupt(HwDeviceExtension,FALSE);    // eddy


    //
    // Issue SET HA OPTION command.
    //

    if (WriteCommandRegister(HwDeviceExtension,
        AC_SET_HA_OPTION,FALSE) == FALSE) {
        return TRUE;
    }

    //
    // Delay 500 microseconds.
    //

    ScsiPortStallExecution(500);

    //
    // Check for invalid command.
    //

    if ( (ScsiPortReadPortUchar(&baseIoAddress->StatusRegister) &
            IOP_INVALID_COMMAND) ) {
        //
        // Clear adapter interrupt.
        //

        ScsiPortWritePortUchar(&baseIoAddress->StatusRegister,
            IOP_INTERRUPT_RESET);
        return TRUE;
    }

    //
    // send 01h
    //

    if (WriteDataRegister(HwDeviceExtension,0x01) == FALSE) {
        return TRUE;
    }

    //
    // Send same byte as was last received.
    //

    if (WriteDataRegister(HwDeviceExtension,ch) == FALSE) {
        return TRUE;
    }

    //
    // Clear adapter interrupt.
    //

    ScsiPortWritePortUchar(&baseIoAddress->StatusRegister,
            IOP_INTERRUPT_RESET);
    return FALSE;
} // end of FirmwareBug ()


BOOLEAN
GetHostAdapterBoardId (
    IN PVOID HwDeviceExtension,
    OUT PUCHAR BoardId
    )

/*++

Routine Description:

    Get board id, firmware id and hardware id from the host adapter.
    These info are used to determine if the host adapter supports
    scatter/gather.

Arguments:

    HwDeviceExtension - HBA miniport driver's adapter data storage

Return Value:

    Board id, hardware id and firmware id (in that order) by modyfing *BoardId
    If there is any error, it will just return with *BoardId unmodified

--*/

{
    PHW_DEVICE_EXTENSION deviceExtension = HwDeviceExtension;
    PBASE_REGISTER baseIoAddress = deviceExtension->BaseIoAddress;
    UCHAR firmwareId;
    UCHAR boardId;
    UCHAR hardwareId;

    ScsiPortWritePortUchar(&baseIoAddress->StatusRegister,
               IOP_INTERRUPT_RESET);

    if (!WriteCommandRegister(HwDeviceExtension,AC_ADAPTER_INQUIRY,FALSE)) {
        return FALSE;
    }

    //
    // Save byte 0 as board ID.
    //

    if ((ReadCommandRegister(HwDeviceExtension,&boardId,TRUE)) == FALSE) {
        return FALSE;
    }

    //
    // Ignore byte 1.  Use hardwareId as scrap storage.
    //

    if ((ReadCommandRegister(HwDeviceExtension,&hardwareId,TRUE)) == FALSE) {
        return FALSE;
    }

    //
    // Save byte 2 as hardware revision in hardwareId.
    //

    if ((ReadCommandRegister(HwDeviceExtension,&hardwareId,TRUE)) == FALSE) {
        return FALSE;
    }

    if ((ReadCommandRegister(HwDeviceExtension,&firmwareId,TRUE)) == FALSE) {
        return FALSE;
    }



    //
    // If timeout then return with *BoardId unmodified.  This means that
    // scatter/gather won't be supported.
    //

    if (!SpinForInterrupt(HwDeviceExtension, TRUE)) { // eddy
        return FALSE;
    }

    //
    // Clear adapter interrupt.
    //

    ScsiPortWritePortUchar(&baseIoAddress->StatusRegister,IOP_INTERRUPT_RESET);

    //
    // Return with appropriate ID's.
    //

    *BoardId++ = boardId;
    *BoardId++ = hardwareId;
    *BoardId++ = firmwareId;

    DebugPrint((2,"board id = %d, hardwareid = %d, firmware id = %d\n",
               boardId,
               hardwareId,
               firmwareId));

    return TRUE;

}  // end of GetHostAdapterBoardId ()


BOOLEAN
ScatterGatherSupported (
   IN PHW_DEVICE_EXTENSION HwDeviceExtension
   )

/*++

Routine Description:
   Determine if the host adapter supports scatter/gather.  On older
   boards, scatter/gather is not supported.  On some boards, there is
   a bug that causes data corruption on multi-segment WRITE commands.
   The algorithm to determine whether the board has the scatter/gather
   bug is not "clean" but there is no other way since the firmware revision
   levels returned by the host adapter are inconsistent with previous
   releases.

Arguments:

   HwDeviceExtension - HBA miniport driver's adapter data storage

Return Value:

   Return TRUE if the algorithm determines that there is no scatter/gather
   firmware bug.

   Return FALSE if the algorithm determines that the adapter is an older
   board or that the firmware contains the scatter gather bug

--*/
{
    PHW_DEVICE_EXTENSION deviceExtension = HwDeviceExtension;
    PBASE_REGISTER baseIoAddress = deviceExtension->BaseIoAddress;
    BOOLEAN status;
    UCHAR HostAdapterId[3];

    status = GetHostAdapterBoardId(HwDeviceExtension, HostAdapterId);

    //
    // Could not read the board id.  assume no scatter gather.
    //

    if(!status) {
        return FALSE;
    }

    //
    // If it's an older board then scatter/gather is not supported.
    //

    if ((HostAdapterId[BOARD_ID] == OLD_BOARD_ID1) ||
            (HostAdapterId[BOARD_ID] == OLD_BOARD_ID2) ) {
        return FALSE;
    }

    //
    // If 1540A/B then check for firmware bug.
    //

    if (HostAdapterId[BOARD_ID] == A154X_BOARD) {
        if (FirmwareBug(HwDeviceExtension)) {
            return FALSE;
       }
    }

    //
    // Now check hardware ID and firmware ID.
    //

    if (HostAdapterId[HARDWARE_ID] != A154X_BAD_HARDWARE_ID) {
        return TRUE;
    }

    if (HostAdapterId[FIRMWARE_ID] != A154X_BAD_FIRMWARE_ID) {
        return TRUE;
    }

    //
    // Host adapter has scatter/gather bug.
    // Clear interrupt on adapter.
    //

    ScsiPortWritePortUchar(&baseIoAddress->StatusRegister,IOP_INTERRUPT_RESET);

    return FALSE;

}  // end of ScatterGatherSupported ()


BOOLEAN
SpinForInterrupt(
    IN PHW_DEVICE_EXTENSION DeviceExtension,
    IN BOOLEAN TimeOutFlag
    )

/*++

Routine Description:

    Wait for interrupt.

Arguments:

    DeviceExtension - Pointer to adapter extension

Return Value:

    TRUE if interrupt occurred.
    FALSE if timed out waiting for interrupt.

--*/

{
    PBASE_REGISTER baseIoAddress = DeviceExtension->BaseIoAddress;
    ULONG i;

    //
    // Wait up to 5 millisecond for interrupt to occur.
    //

    for (i=0; i<5000; i++) {

        if (ScsiPortReadPortUchar(&baseIoAddress->InterruptRegister) & IOP_COMMAND_COMPLETE) {

            //
            // Interrupt occurred. Break out of wait loop.
            //

            break;

        } else {

            //
            // Stall one microsecond.
            //

            ScsiPortStallExecution(1);
        }
    }

    if ( (i==5000) && (TimeOutFlag == TRUE)) {

        ScsiPortLogError(DeviceExtension,
                NULL,
                0,
                DeviceExtension->HostTargetId,
                0,
                SP_INTERNAL_ADAPTER_ERROR,
                9 << 8
                );

        DebugPrint((1, "Aha154x:SpinForInterrupt:  Timed out waiting for interrupt\n"));

        return FALSE;

    } else {

        //
        // Clear interrupt on adapter.
        //

        ScsiPortWritePortUchar(&baseIoAddress->StatusRegister, IOP_INTERRUPT_RESET);

        return TRUE;
    }

} // end SpinForInterrupt()


BOOLEAN UnlockMailBoxes (
    IN PVOID HwDeviceExtension
    )

/*++

Routine Description:

    Unlock 1542B+ or 1542C mailboxes so that the driver
    can zero out mailboxes when it's initializing the adapter.

    The mailboxes are locked if:
    1. >1Gb option is enabled (this option is available for 154xB+ and
       154xC).

    2. Dynamic scan lock option is enabled (154xC board only)

    The reason the mailboxes are locked by the adapter's firmware is
    because the BIOS is now reporting 255/63 translation instead of 64/32.
    As such, if a user inadvertently enabled the >1Gb option (enabling
    255/63 translation) and still uses an old driver, hard disk data
    will be corrupted.  Therefore, the firmware will not allow mailboxes
    to be initialized unless the user knows what he is doing and updates
    his driver so that his disk won't be trashed.

Arguments:

    DeviceExtension - Pointer to adapter extension

Return Value:

    TRUE if mailboxes are unlocked.
    FALSE if mailboxes are not unlocked.
    Note that if the adapter is just a 154xB board (without the >1Gb
    option), this routine will return FALSE.

--*/

{
    UCHAR locktype;

    //
    // Request information.
    //

    if (WriteCommandRegister(HwDeviceExtension, AC_GET_BIOS_INFO, TRUE) == FALSE) {
       return FALSE;
    }


    //
    // Retrieve first byte.
    //

    if (ReadCommandRegister(HwDeviceExtension,&locktype,FALSE) == FALSE) {
        return FALSE;
    }

    //
    // Check for extended bios translation enabled option on 1540C and
    // 1540B with 1GB support.
    //

    if (locktype != TRANSLATION_ENABLED) {

        //
        // Extended translation is disabled.  Retrieve lock status.
        //

        if (ReadCommandRegister(HwDeviceExtension,&locktype,FALSE) == FALSE) {
            return FALSE;
        }

        //
        // Wait for HACC interrupt.
        //

        SpinForInterrupt(HwDeviceExtension,FALSE);  // eddy


        if (locktype == DYNAMIC_SCAN_LOCK) {
            return(SendUnlockCommand(HwDeviceExtension,locktype));
        }
        return FALSE;
    }

    //
    // Extended BIOS translation (255/63) is enabled.
    //


    if (ReadCommandRegister(HwDeviceExtension,&locktype,FALSE) == FALSE) {
        return FALSE;
    }

    //
    // Wait for HACC interrupt.
    //

    SpinForInterrupt(HwDeviceExtension,FALSE);  // eddy


    if ((locktype == TRANSLATION_LOCK) || (locktype == DYNAMIC_SCAN_LOCK)) {
        return(SendUnlockCommand(HwDeviceExtension,locktype));
    }

    return FALSE;
}  // end of UnlockMailBoxes ()


BOOLEAN
SendUnlockCommand(
    IN PVOID HwDeviceExtension,
    IN UCHAR locktype
    )

/*++

Routine Description:

    Send unlock command to 1542B+ or 1542C board so that the driver
    can zero out mailboxes when it's initializing the adapter.


Arguments:

    DeviceExtension - Pointer to adapter extension

Return Value:

    TRUE if commands are sent successfully.
    FALSE if not.

--*/

{
    PHW_DEVICE_EXTENSION deviceExtension = HwDeviceExtension;
    PBASE_REGISTER baseIoAddress = deviceExtension->BaseIoAddress;

    if (WriteCommandRegister(deviceExtension,
                AC_SET_MAILBOX_INTERFACE,TRUE) == FALSE) {
        return FALSE;
    }

    if (WriteDataRegister(deviceExtension,MAILBOX_UNLOCK) == FALSE) {
        return FALSE;
    }

    if (WriteDataRegister(deviceExtension,locktype) == FALSE) {
        return FALSE;
    }

    //
    // Clear interrupt on adapter.
    //


    ScsiPortWritePortUchar(&baseIoAddress->StatusRegister, IOP_INTERRUPT_RESET);

    return TRUE;
}  // end of SendUnlockCommand ()

CHAR
AhaToLower(
    IN CHAR C
    )
{
    CHAR c = C;
    if (c >= 'A' && c <= 'Z') {
	return (c - 'A' + 'a');
    }
    return c;
}

ULONG
AhaParseArgumentString(
    IN PCHAR String,
    IN PCHAR KeyWord
    )

/*++

Routine Description:

    This routine will parse the string for a match on the keyword, then
    calculate the value for the keyword and return it to the caller.

Arguments:

    String - The ASCII string to parse.
    KeyWord - The keyword for the value desired.

Return Values:

    Zero if value not found
    Value converted from ASCII to binary.

--*/

{
    PCHAR cptr;
    PCHAR kptr;
    ULONG value;
    ULONG stringLength = 0;
    ULONG keyWordLength = 0;
    ULONG index;

    //
    // Calculate the string length and lower case all characters.
    //
    cptr = String;
    while (*cptr) {
        cptr++;
        stringLength++;
    }

    //
    // Calculate the keyword length and lower case all characters.
    //
    cptr = KeyWord;
    while (*cptr) {
        cptr++;
        keyWordLength++;
    }

    if (keyWordLength > stringLength) {

        //
        // Can't possibly have a match.
        //
        return 0;
    }

    //
    // Now setup and start the compare.
    //
    cptr = String;

ContinueSearch:
    //
    // The input string may start with white space.  Skip it.
    //
    while (*cptr == ' ' || *cptr == '\t') {
        cptr++;
    }

    if (*cptr == '\0') {

        //
        // end of string.
        //
        return 0;
    }

    kptr = KeyWord;
    while (AhaToLower(*cptr) == AhaToLower(*kptr)) {
        
        cptr++;
        kptr++;

        if (*(cptr - 1) == '\0') {

            //
            // end of string
            //
	
            return 0;
        }
    }

    cptr++;
    kptr++;

    if (*(kptr - 1) == '\0') {

        //
        // May have a match backup and check for blank or equals.
        //

        cptr--;
        while (*cptr == ' ' || *cptr == '\t') {
            cptr++;
        }

        //
        // Found a match.  Make sure there is an equals.
        //
        if (*cptr != '=') {

            //
            // Not a match so move to the next semicolon.
            //
            while (*cptr) {
                if (*cptr++ == ';') {
                    goto ContinueSearch;
                }
            }
            return 0;
        }

        //
        // Skip the equals sign.
        //
        cptr++;

        //
        // Skip white space.
        //
        while ((*cptr == ' ') || (*cptr == '\t')) {
            cptr++;
        }

        if (*cptr == '\0') {

            //
            // Early end of string, return not found
            //
            return 0;
        }

        if (*cptr == ';') {

            //
            // This isn't it either.
            //
            cptr++;
            goto ContinueSearch;
        }

        value = 0;
        if ((*cptr == '0') && (AhaToLower(*(cptr + 1)) == 'x')) {

            //
            // Value is in Hex.  Skip the "0x"
            //
            cptr += 2;
            for (index = 0; *(cptr + index); index++) {

                if (*(cptr + index) == ' ' ||
                    *(cptr + index) == '\t' ||
                    *(cptr + index) == ';') {
                     break;
                }

                if ((*(cptr + index) >= '0') && (*(cptr + index) <= '9')) {
                    value = (16 * value) + (*(cptr + index) - '0');
                } else {
                    if ((AhaToLower(*(cptr + index)) >= 'a') && (AhaToLower(*(cptr + index)) <= 'f')) {
                        value = (16 * value) + AhaToLower((*(cptr + index)) - 'a' + 10);
                    } else {

                        //
                        // Syntax error, return not found.
                        //
                        return 0;
                    }
                }
            }
        } else {

            //
            // Value is in Decimal.
            //
            for (index = 0; *(cptr + index); index++) {

                if (*(cptr + index) == ' ' ||
                    *(cptr + index) == '\t' ||
                    *(cptr + index) == ';') {
                    break;
                }

                if ((*(cptr + index) >= '0') && (*(cptr + index) <= '9')) {
                    value = (10 * value) + (*(cptr + index) - '0');
                } else {

                    //
                    // Syntax error return not found.
                    //
                    return 0;
                }
            }
        }

        return value;
    } else {

        //
        // Not a match check for ';' to continue search.
        //
        while (*cptr) {
            if (*cptr++ == ';') {
                goto ContinueSearch;
            }
        }

        return 0;
    }
}

BOOLEAN
A4448ReadString(
    IN PHW_DEVICE_EXTENSION deviceExtension,
    PUCHAR theString,
    UCHAR  stringLength,
    UCHAR  stringCommand
    )
/*++

Routine Description:


Arguments:


Return Values:

    True if read was OK.
    False otherwise.

--*/
{
     ULONG ii;

     //
     // Send in the string command
     //
     if (!WriteCommandRegister(deviceExtension, stringCommand, TRUE)) {
         return FALSE;
     }

    //
    // Send in the string length
    //
    if (!WriteCommandRegister(deviceExtension, stringLength, FALSE)) {
        return FALSE;
    }

    //
    // Read each byte of the string
    //
    for (ii = 0; ii < stringLength; ++ii) {
        if (!ReadCommandRegister(deviceExtension, &theString[ii],FALSE)) {
            return FALSE;
        }
    }

    //
    // Wait for interrupt.
    //

    if (!SpinForInterrupt(deviceExtension,FALSE)) {
        return FALSE;
    }


    return TRUE;

} // End A4448ReadString


BOOLEAN
A4448IsAmi(
    IN PHW_DEVICE_EXTENSION  HwDeviceExtension,
    IN OUT PPORT_CONFIGURATION_INFORMATION ConfigInfo,
    ULONG portNumber
    )
/*++

Routine Description:

    This routine determines if the adapter this driver recognized is an
    AMI4448. Eddy Quicksall of AMI provided MS with this detection code.

Arguments:

    HwDeviceExtension - Pointer to driver device data area.
    ConfigInfo - Structure describing this adapter's configuration.
    portNumber - Indicates the ordinal of the card relative to this driver.

Return Values:

    True if an AMI board.
    False otherwise.

--*/
{

    PUCHAR     x330IoSpace;     // mapped I/O for 330
    ULONG      x330Address;     // unmapped 330
    PX330_REGISTER x330IoBase;  // mapped 330 for use with struct X330_REGISTER

    //
    // this string is only avalable if new BIOS
    // you will get INVDCMD if an old BIOS or some other manufacturer
    // if an old BIOS, there is nothing that can be done except to check
    // the Manufacturers ID if you are on an EISA system
    //
    struct _CONFIG_STRING {
        UCHAR companyString[4];     // AMI<0)
        UCHAR modelString[6];       // <0>
        UCHAR seriesString[6];      // 48<0>
        UCHAR versionString[6];     // 1.00<0)
    } configString;

    //
    // Get the system physical address for this card.  The card uses I/O space.
    // This actually just maps the I/O if necessary, it does not reserve it.
    //

    x330IoSpace = ScsiPortGetDeviceBase(
                        HwDeviceExtension,                  // HwDeviceExtension
                        ConfigInfo->AdapterInterfaceType,   // AdapterInterfaceType
                        ConfigInfo->SystemIoBusNumber,      // SystemIoBusNumber
                        ScsiPortConvertUlongToPhysicalAddress(portNumber),
                        4,                                  // NumberOfBytes
                        TRUE                                // InIoSpace
                        );


    //
    // Intel port number
    //

    x330Address = portNumber;

    //
    // Check to see if the adapter is present in the system.
    //

    x330IoBase = (PX330_REGISTER)(x330IoSpace);

    //
    // Criteria is IDLE and not STST,DIAGF,INVDCMD
    // but INIT, CDF, and DF are don't cares.
    //
    // Can't check for INIT because the driver may already be running if it
    // is the boot device.
    //

    if (((ScsiPortReadPortUchar((PUCHAR)x330IoBase)) & (~0x2C)) == 0x10) {

        if (A4448ReadString(HwDeviceExtension, (PUCHAR)&configString,
                                 sizeof(configString), AC_AMI_INQUIRY ) &&
                             configString.companyString[0] == 'A' &&
                             configString.companyString[1] == 'M' &&
                             configString.companyString[2] == 'I') {

            return TRUE;
        }
    }

    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\port\scsi\miniport\aha154x\makefile.inc ===
clean:
    del aha154dt.h $(O)\aha154x.bmf

$(O)\aha154x.mof: aha154x.mof

aha154dt.h: $(O)\aha154x.bmf
    wmimofck -haha154dt.h $(O)\aha154x.bmf
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\port\scsi\miniport\aha154x\support.h ===
BOOLEAN
ScsiPortCompareMemory(
    IN PVOID Source1,
    IN PVOID Source2,
    IN ULONG Length
    );

VOID
ScsiPortZeroMemory(
    IN PVOID Destination,
    IN ULONG Length
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\port\scsi\miniport\aha154x\aha154x.h ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    aha154x.h

Abstract:

    This module contains the structures, specific to the Adaptec aha154x
    host bus adapter, used by the SCSI miniport driver. Data structures
    that are part of standard ANSI SCSI will be defined in a header
    file that will be available to all SCSI device drivers.

Author:

    Mike Glass  December 1990
    Bill Williams (Adaptec)

Revision History:

--*/

#include "scsi.h"
#include "scsiwmi.h"

//
// The following definitions are used to convert ULONG addresses
// to Adaptec's 3 byte address format.
//

typedef struct _THREE_BYTE {
    UCHAR Msb;
    UCHAR Mid;
    UCHAR Lsb;
} THREE_BYTE, *PTHREE_BYTE;

//
// Convert four-byte Little Endian to three-byte Big Endian
//

#define FOUR_TO_THREE(Three, Four) {                \
    ASSERT(!((Four)->Byte3));                       \
    (Three)->Lsb = (Four)->Byte0;                   \
    (Three)->Mid = (Four)->Byte1;                   \
    (Three)->Msb = (Four)->Byte2;                   \
}

#define THREE_TO_FOUR(Four, Three) {                \
    (Four)->Byte0 = (Three)->Lsb;                   \
    (Four)->Byte1 = (Three)->Mid;                   \
    (Four)->Byte2 = (Three)->Msb;                   \
    (Four)->Byte3 = 0;                              \
}

//
// Context information for adapter scan/sniff
//

typedef struct _SCAN_CONTEXT {
    ULONG   adapterCount;
    ULONG   biosScanStart;
} SCAN_CONTEXT, *PSCAN_CONTEXT;

///////////////////////////////////////////////////////////////////////////////
//
// CCB - Adaptec SCSI Command Control Block
//
//    The CCB is a superset of the CDB (Command Descriptor Block)
//    and specifies detailed information about a SCSI command.
//
///////////////////////////////////////////////////////////////////////////////

//
//    Byte 0    Command Control Block Operation Code
//

#define SCSI_INITIATOR_OLD_COMMAND 0x00
#define TARGET_MODE_COMMAND       0x01
#define SCATTER_GATHER_OLD_COMMAND 0x02
#define SCSI_INITIATOR_COMMAND    0x03
#define SCATTER_GATHER_COMMAND    0x04

//
//    Byte 1    Address and Direction Control
//

#define CCB_TARGET_ID_SHIFT       0x06            // CCB Op Code = 00, 02
#define CCB_INITIATOR_ID_SHIFT    0x06            // CCB Op Code = 01
#define CCB_DATA_XFER_OUT         0x10            // Write
#define CCB_DATA_XFER_IN          0x08            // Read
#define CCB_LUN_MASK              0x07            // Logical Unit Number

//
//    Byte 2    SCSI_Command_Length - Length of SCSI CDB
//
//    Byte 3    Request Sense Allocation Length
//

#define FOURTEEN_BYTES            0x00            // Request Sense Buffer size
#define NO_AUTO_REQUEST_SENSE     0x01            // No Request Sense Buffer

//
//    Bytes 4, 5 and 6    Data Length             // Data transfer byte count
//
//    Bytes 7, 8 and 9    Data Pointer            // SGD List or Data Buffer
//
//    Bytes 10, 11 and 12 Link Pointer            // Next CCB in Linked List
//
//    Byte 13   Command Link ID                   // TBD (I don't know yet)
//
//    Byte 14   Host Status                       // Host Adapter status
//

#define CCB_COMPLETE              0x00            // CCB completed without error
#define CCB_LINKED_COMPLETE       0x0A            // Linked command completed
#define CCB_LINKED_COMPLETE_INT   0x0B            // Linked complete with interrupt
#define CCB_SELECTION_TIMEOUT     0x11            // Set SCSI selection timed out
#define CCB_DATA_OVER_UNDER_RUN   0x12
#define CCB_UNEXPECTED_BUS_FREE   0x13            // Target dropped SCSI BSY
#define CCB_PHASE_SEQUENCE_FAIL   0x14            // Target bus phase sequence failure
#define CCB_BAD_MBO_COMMAND       0x15            // MBO command not 0, 1 or 2
#define CCB_INVALID_OP_CODE       0x16            // CCB invalid operation code
#define CCB_BAD_LINKED_LUN        0x17            // Linked CCB LUN different from first
#define CCB_INVALID_DIRECTION     0x18            // Invalid target direction
#define CCB_DUPLICATE_CCB         0x19            // Duplicate CCB
#define CCB_INVALID_CCB           0x1A            // Invalid CCB - bad parameter

//
//    Byte 15   Target Status
//
//    See SCSI.H files for these statuses.
//

//
//    Bytes 16 and 17   Reserved (must be 0)
//

//
//    Bytes 18 through 18+n-1, where n=size of CDB  Command Descriptor Block
//

//
//    Bytes 18+n through 18+m-1, where m=buffer size Allocated for Sense Data
//

#define REQUEST_SENSE_BUFFER_SIZE 18

///////////////////////////////////////////////////////////////////////////////
//
// Scatter/Gather Segment List Definitions
//
///////////////////////////////////////////////////////////////////////////////

//
// Adapter limits
//

#define MAX_SG_DESCRIPTORS 17
#define MAX_TRANSFER_SIZE  64 * 1024
#define A154X_TYPE_MAX 5

//
// Scatter/Gather Segment Descriptor Definition
//

typedef struct _SGD {
    THREE_BYTE Length;
    THREE_BYTE Address;
} SGD, *PSGD;

typedef struct _SDL {
    SGD Sgd[MAX_SG_DESCRIPTORS];
} SDL, *PSDL;

#define SEGMENT_LIST_SIZE         MAX_SG_DESCRIPTORS * sizeof(SGD)

///////////////////////////////////////////////////////////////////////////////
//
// CCB Typedef
//

typedef struct _CCB {
    UCHAR OperationCode;
    UCHAR ControlByte;
    UCHAR CdbLength;
    UCHAR RequestSenseLength;
    THREE_BYTE DataLength;
    THREE_BYTE DataPointer;
    THREE_BYTE LinkPointer;
    UCHAR LinkIdentifier;
    UCHAR HostStatus;
    UCHAR TargetStatus;
    UCHAR Reserved[2];
    UCHAR Cdb[MAXIMUM_CDB_SIZE];
    PVOID SrbAddress;
    PVOID AbortSrb;
    SDL   Sdl;
    UCHAR RequestSenseBuffer[REQUEST_SENSE_BUFFER_SIZE];
} CCB, *PCCB;

//
// CCB and request sense buffer
//

#define CCB_SIZE sizeof(CCB)

///////////////////////////////////////////////////////////////////////////////
//
// Adapter Command Overview
//
//    Adapter commands are issued by writing to the Command/Data Out port.
//    They are used to initialize the host adapter and to establish control
//    conditions within the host adapter. They may not be issued when there
//    are outstanding SCSI commands.
//
//    All adapter commands except Start SCSI(02) and Enable Mailbox-Out
//    Interrupt(05) must be executed only when the IDLE bit (Status bit 4)
//    is one. Many commands require additional parameter bytes which are
//    then written to the Command/Data Out I/O port (base+1). Before each
//    byte is written by the host to the host adapter, the host must verify
//    that the CDF bit (Status bit 3) is zero, indicating that the command
//    port is ready for another byte of information. The host adapter usually
//    clears the Command/Data Out port within 100 microseconds. Some commands
//    require information bytes to be returned from the host adapter to the
//    host. In this case, the host monitors the DF bit (Status bit 2) to
//    determine when the host adapter has placed a byte in the Data In I/O
//    port for the host to read. The DF bit is reset automatically when the
//    host reads the byte. The format of each adapter command is strictly
//    defined, so the host adapter and host system can always agree upon the
//    correct number of parameter bytes to be transferred during a command.
//
//
///////////////////////////////////////////////////////////////////////////////

//
// Host Adapter Command Operation Codes
//

#define AC_NO_OPERATION           0x00
#define AC_MAILBOX_INITIALIZATION 0x01
#define AC_START_SCSI_COMMAND     0x02
#define AC_START_BIOS_COMMAND     0x03
#define AC_ADAPTER_INQUIRY        0x04
#define AC_ENABLE_MBO_AVAIL_INT   0x05
#define AC_SET_SELECTION_TIMEOUT  0x06
#define AC_SET_BUS_ON_TIME        0x07
#define AC_SET_BUS_OFF_TIME       0x08
#define AC_SET_TRANSFER_SPEED     0x09
#define AC_RET_INSTALLED_DEVICES  0x0A
#define AC_RET_CONFIGURATION_DATA 0x0B
#define AC_ENABLE_TARGET_MODE     0x0C
#define AC_RETURN_SETUP_DATA      0x0D
#define AC_WRITE_CHANNEL_2_BUFFER 0x1A
#define AC_READ_CHANNEL_2_BUFFER  0x1B
#define AC_WRITE_FIFO_BUFFER      0x1C
#define AC_READ_FIFO_BUFFER       0x1D
#define AC_ECHO_COMMAND_DATA      0x1F
#define AC_SET_HA_OPTION          0x21
#define AC_RETURN_EEPROM          0x23
#define AC_GET_BIOS_INFO          0x28
#define AC_SET_MAILBOX_INTERFACE  0x29
#define AC_EXTENDED_SETUP_INFO    0x8D

//
//Adapter commands new to the AHA-154xCP are defined below.
//
#define AC_SET_DMS_BUS_SPEED            0x2B
#define AC_TERMINATION_AND_CABLE_STATUS 0x2C
#define AC_DEVICE_INQUIRY               0x2D
#define AC_SCSI_DEVICE_TABLE            0x2E
#define AC_PERFORM_SCAM                 0x2F

//
// EEPROM define for SCAM
//
#define SCSI_BUS_CONTROL_FLAG           0x06
#define SCAM_ENABLED                    0x40

//
// DMA Transfer Speeds
//

#define DMA_SPEED_50_MBS          0x00

//
// I/O Port Interface
//

typedef struct _BASE_REGISTER {
    UCHAR StatusRegister;
    UCHAR CommandRegister;
    UCHAR InterruptRegister;
} BASE_REGISTER, *PBASE_REGISTER;

//
//    Base+0    Write: Control Register
//

#define IOP_HARD_RESET            0x80            // bit 7
#define IOP_SOFT_RESET            0x40            // bit 6
#define IOP_INTERRUPT_RESET       0x20            // bit 5
#define IOP_SCSI_BUS_RESET        0x10            // bit 4

//
//    Base+0    Read: Status
//

#define IOP_SELF_TEST             0x80            // bit 7
#define IOP_INTERNAL_DIAG_FAILURE 0x40            // bit 6
#define IOP_MAILBOX_INIT_REQUIRED 0x20            // bit 5
#define IOP_SCSI_HBA_IDLE         0x10            // bit 4
#define IOP_COMMAND_DATA_OUT_FULL 0x08            // bit 3
#define IOP_DATA_IN_PORT_FULL     0x04            // bit 2
#define IOP_INVALID_COMMAND       0X01            // bit 1

//
//    Base+1    Write: Command/Data Out
//

//
//    Base+1    Read: Data In
//

//
//    Base+2    Read: Interrupt Flags
//

#define IOP_ANY_INTERRUPT         0x80            // bit 7
#define IOP_SCSI_RESET_DETECTED   0x08            // bit 3
#define IOP_COMMAND_COMPLETE      0x04            // bit 2
#define IOP_MBO_EMPTY             0x02            // bit 1
#define IOP_MBI_FULL              0x01            // bit 0

///////////////////////////////////////////////////////////////////////////////
//
// Mailbox Definitions
//
//
///////////////////////////////////////////////////////////////////////////////

//
// Mailbox Definition
//

#define MB_COUNT                  0x08            // number of mailboxes

//
// Mailbox Out
//

typedef struct _MBO {
    UCHAR Command;
    THREE_BYTE Address;
} MBO, *PMBO;

//
// MBO Command Values
//

#define MBO_FREE                  0x00
#define MBO_START                 0x01
#define MBO_ABORT                 0x02

//
// Mailbox In
//

typedef struct _MBI {
    UCHAR Status;
    THREE_BYTE Address;
} MBI, *PMBI;

//
// MBI Status Values
//

#define MBI_FREE                  0x00
#define MBI_SUCCESS               0x01
#define MBI_ABORT                 0x02
#define MBI_NOT_FOUND             0x03
#define MBI_ERROR                 0x04

//
// Mailbox Initialization
//

typedef struct _MAILBOX_INIT {
    UCHAR Count;
    THREE_BYTE Address;
} MAILBOX_INIT, *PMAILBOX_INIT;

#define MAILBOX_UNLOCK      0x00
#define TRANSLATION_LOCK    0x01    // mailbox locked for extended BIOS
#define DYNAMIC_SCAN_LOCK   0x02    // mailbox locked for 154xC
#define TRANSLATION_ENABLED 0x08    // extended BIOS translation (1023/64)

//
// Scatter/Gather firmware bug detection
//

#define BOARD_ID                  0x00
#define HARDWARE_ID               0x01
#define FIRMWARE_ID               0x02
#define OLD_BOARD_ID1             0x00
#define OLD_BOARD_ID2             0x30
#define A154X_BOARD               0x41
#define A154X_BAD_HARDWARE_ID     0x30
#define A154X_BAD_FIRMWARE_ID     0x33

//
// MCA specific definitions.
//

#define NUMBER_POS_SLOTS 8
#define POS_IDENTIFIER   0x0F1F
#define POS_PORT_MASK    0xC7
#define POS_PORT_130     0x01
#define POS_PORT_134     0x41
#define POS_PORT_230     0x02
#define POS_PORT_234     0x42
#define POS_PORT_330     0x03
#define POS_PORT_334     0x43

typedef struct _POS_DATA {
    USHORT AdapterId;
    UCHAR  BiosEnabled;
    UCHAR  IoPortInformation;
    UCHAR  ScsiInformation;
    UCHAR  DmaInformation;
} POS_DATA, *PPOS_DATA;

typedef struct _INIT_DATA {

    ULONG AdapterId;
    ULONG CardSlot;
    POS_DATA PosData[NUMBER_POS_SLOTS];

} INIT_DATA, *PINIT_DATA;


//
// Real Mode Adapter Config Info
//
typedef struct _RM_SAVRES {
	UCHAR		SDTPar;
	UCHAR		TxSpeed;
	UCHAR		BusOnTime;
	UCHAR		BusOffTime;
	UCHAR		NumMailBoxes;
	UCHAR		MBAddrHiByte;
	UCHAR		MBAddrMiByte;
	UCHAR		MBAddrLoByte;
	UCHAR		SyncNeg[8];
	UCHAR		DisOpt;

} RM_CFG, *PRM_CFG;

#define RM_CFG_MAX_SIZE 0xFF

//
//AMI Detect Code
//
#define AC_AMI_INQUIRY  0x41    // Get model number, ect. (ASCIIZ)

//
// I/O Port Interface
//

typedef struct _X330_REGISTER {
    UCHAR StatusRegister;
    UCHAR CommandRegister;
    UCHAR InterruptRegister;
    UCHAR DiagRegister;
} X330_REGISTER, *PX330_REGISTER;

///////////////////////////////////////////////////////////////////////////////
//
// Structures
//
//
///////////////////////////////////////////////////////////////////////////////

//
// The following structure is allocated
// from noncached memory as data will be DMA'd to
// and from it.
//

typedef struct _NONCACHED_EXTENSION {

    //
    // Physical base address of mailboxes
    //

    ULONG MailboxPA;

    //
    // Mailboxes
    //

    MBO          Mbo[MB_COUNT];
    MBI          Mbi[MB_COUNT];

} NONCACHED_EXTENSION, *PNONCACHED_EXTENSION;

//
// Device extension
//

typedef struct _HW_DEVICE_EXTENSION {

    //
    // NonCached extension
    //

    PNONCACHED_EXTENSION NoncachedExtension;

    //
    // Adapter parameters
    //

    PBASE_REGISTER   BaseIoAddress;

    //
    // Host Target id.
    //

    UCHAR HostTargetId;

    //
    // Old in\out box indexes.
    //

    UCHAR MboIndex;

    UCHAR MbiIndex;

    //
    // Pending request.
    //

    BOOLEAN PendingRequest;

    //
    // Bus on time to use.
    //

    UCHAR BusOnTime;

    //
    // Scatter gather command
    //

    UCHAR CcbScatterGatherCommand;

    //
    // Non scatter gather command
    //

    UCHAR CcbInitiatorCommand;

    //
    // Don't send CDB's longer than this to any device on the bus
    // Ignored if the value is 0
    //

    UCHAR MaxCdbLength;

    //
    // Real Mode adapter config info
    //

    RM_CFG RMSaveState;

        #if defined(_SCAM_ENABLED)
        //
        // SCAM boolean, set to TRUE if miniport must control SCAM operation.
        //
        BOOLEAN PerformScam;
        #endif

    SCSI_WMILIB_CONTEXT WmiLibContext;
		
		
} HW_DEVICE_EXTENSION, *PHW_DEVICE_EXTENSION;

//
// Logical unit extension
//

typedef struct _HW_LU_EXTENSION {
    PSCSI_REQUEST_BLOCK CurrentSrb;
} HW_LU_EXTENSION, *PHW_LU_EXTENSION;

///////////////////////////////////////////////////////////////////////////////
//
// Common Prototypes to all Source Files
//
//
///////////////////////////////////////////////////////////////////////////////

BOOLEAN
A154xWmiSrb(
    IN     PHW_DEVICE_EXTENSION    HwDeviceExtension,
    IN OUT PSCSI_WMI_REQUEST_BLOCK Srb
    );

BOOLEAN
ReadCommandRegister(
    IN PHW_DEVICE_EXTENSION DeviceExtension,
    OUT PUCHAR DataByte,
    IN BOOLEAN TimeOutFlag
    );

BOOLEAN
WriteCommandRegister(
    IN PHW_DEVICE_EXTENSION DeviceExtension,
    IN UCHAR AdapterCommand,
    IN BOOLEAN LogError
    );

BOOLEAN
WriteDataRegister(
    IN PHW_DEVICE_EXTENSION DeviceExtension,
    IN UCHAR DataByte
    );

BOOLEAN
SpinForInterrupt(
    IN PHW_DEVICE_EXTENSION DeviceExtension,
    IN BOOLEAN TimeOutFlag
    );

void A154xWmiInitialize(
    IN PHW_DEVICE_EXTENSION HwDeviceExtension
    );


=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\port\scsi\miniport\aha154x\support.c ===
#include "miniport.h"
#include "scsi.h"

#define LONG_ALIGN (sizeof(LONG) - 1)

BOOLEAN
ScsiPortCompareMemory(
    IN PVOID Source1,
    IN PVOID Source2,
    IN ULONG Length
    )
/*++

Routine Description:

    Compares two blocks of memory and returns TRUE if they are identical.

Arguments:

    Source1 - block of memory to compare
    Source2 - block of memory to compare
    Length  - number of bytes to copy

Return Value:

    TRUE if the two buffers are identical.

--*/

{
    BOOLEAN identical = TRUE;

    //
    // See if the length, source and desitination are word aligned.
    //

    if ((Length & LONG_ALIGN) || 
        ((ULONG_PTR) Source1 & LONG_ALIGN) ||
        ((ULONG_PTR) Source2 & LONG_ALIGN)) {

        PCHAR source2 = Source2;
        PCHAR source  = Source1;

        for (; Length > 0 && identical; Length--) {
            if (*source2++ != *source++) {
               identical = FALSE;
            }
        }
    } else {

        PLONG source2 = Source2;
        PLONG source  = Source1;

        Length /= sizeof(LONG);
        for (; Length > 0 && identical; Length--) {
            if (*source2++ != *source++) {
               identical = FALSE;
            }
        }
    }

    return identical;

} // end ScsiPortCompareMemory()


VOID
ScsiPortZeroMemory(
    IN PVOID Destination,
    IN ULONG Length
    )
/*++

Routine Description:

    Fills a block of memory with zeros, given a pointer to the block and
    the length, in bytes, to be filled.

Arguments:

    Destination - Points to the memory to be filled with zeros.

    Length      - Specifies the number of bytes to be zeroed.

Return Value:

    None.

--*/

{
    //
    // See if the length, source and desitination are word aligned.
    //

    if (Length & LONG_ALIGN || (ULONG_PTR) Destination & LONG_ALIGN) {

        PUCHAR destination = Destination;

        for (; Length > 0; Length--) {
            *destination = 0;
            destination++;
        }
    } else {

        PULONG destination = Destination;

        Length /= sizeof(LONG);
        for (; Length > 0; Length--) {
            *destination = 0;
            destination++;
        }
    }

    return;

} // end ScsiPortZeroMemory()
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\port\scsi\miniport\aha154x\wmitest\aha154dc.c ===
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:

    aha154dc.c

Abstract:

    This is a Sample WMI Data Consumer.

    This user-mode app performs two WMI queries to the AHA154x driver for the
    Setup Data Guid and prints its findings to the console.

Authors:

    Alan Warwick
    Dan Markarian

Environment:

    User mode only.

Notes:

    None.

Revision History:

    - Based on "dc1" test code by Alan Warwick.
    - 17-Apr-1997, Original Revision, Dan Markarian

--*/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <ole2.h>
#include <stdio.h>
#include <stdlib.h>

#include "wmium.h"

//
// Macros.
//

#define OffsetToPtr(Base, Offset) ((PBYTE)((PBYTE)Base + Offset))

//
// WMI data block definitions.
//

#define Aha154xWmi_SetupData_InstanceName L"Aha154xAdapter"
#define Aha154xWmi_SetupData_Guid \
         { 0xea992010,0xb75b,0x11d0,0xa3,0x07,0x00,0xaa,0x00,0x6c,0x3f,0x30 }

GUID   AdapterSetupDataGuid = Aha154xWmi_SetupData_Guid;
PWCHAR AdapterSetupDataInstances[] = { Aha154xWmi_SetupData_InstanceName };

//
// Global variables.
//

BYTE  Buffer[4096];
ULONG BufferSize = sizeof(Buffer);

//
// Structure definitions.
//

typedef struct tagTESTGUID TESTGUID;

typedef BOOLEAN (*QADVALIDATION)(
   TESTGUID *TestGuid,
   PVOID Buffer,
   ULONG BufferSize
);

typedef ULONG (*QSINSET)(
   TESTGUID *TestGuid,
   PULONG *DataList,
   PULONG DataListSize,
    PBYTE *ValueBuffer,
   ULONG *ValueBufferSize,
   ULONG Instance
);

typedef ULONG (*QSITSET)(
   TESTGUID *TestGuid,
   PULONG *DataList,
   PULONG DataListSize,
    PBYTE *ValueBuffer,
   ULONG *ValueBufferSize,
   ULONG Instance,
   ULONG ItemId
   );

typedef BOOLEAN (*QSINTVALIDATION)(
   TESTGUID *TestGuid,
   PULONG *DataList,
   PULONG DataListSize,
    PVOID Buffer,
   ULONG BufferSize,
   ULONG Instance
   );

typedef PWCHAR (*GETINSTANCENAME)(
   TESTGUID *TestGuid,
    ULONG Instance
   );

typedef struct tagTESTGUID
{
   LPGUID Guid;
   HANDLE Handle;

   PULONG DataListSize;

   PULONG *InitDataList;
   PULONG *SINDataList;
   PULONG *SITDataList;

   PWCHAR *InstanceNames;

   QADVALIDATION QADValidation;
   ULONG QADFlags;

   ULONG InstanceCount;
    GETINSTANCENAME GetInstanceName;

   ULONG QSINTFlags;
   QSINTVALIDATION QSINTValidation;

   QSINSET QSINSet;

   ULONG ItemCount;
   QSITSET QSITSet;

} TESTGUID;

//
// Support functions.
//

void PrintOutAdapterSetupData(PULONG Data);

PWCHAR GetInstanceName(
   TESTGUID *TestGuid,
   ULONG Instance
   )
{
   return(TestGuid->InstanceNames[Instance]);
}

BOOLEAN AdapterSetupDataQADValidate(
   TESTGUID *TestGuid,
   PVOID Buffer,
   ULONG BufferSize
)
{
   PWNODE_ALL_DATA Wnode = Buffer;
   PULONG Data;

   //
   // Validate WNODE fields.
   //

   if ((Wnode->WnodeHeader.BufferSize == 0) ||
       (Wnode->WnodeHeader.ProviderId == 0) ||
       (Wnode->WnodeHeader.Version != 1) ||
       (Wnode->WnodeHeader.Linkage != 0) ||
       (Wnode->WnodeHeader.TimeStamp.HighPart == 0) ||
       (Wnode->WnodeHeader.TimeStamp.LowPart == 0) ||
       (memcmp(&Wnode->WnodeHeader.Guid, TestGuid->Guid, sizeof(GUID)) != 0) ||
       (Wnode->WnodeHeader.Flags != (WNODE_FLAG_ALL_DATA |
                                     WNODE_FLAG_FIXED_INSTANCE_SIZE |
                                     WNODE_FLAG_STATIC_INSTANCE_NAMES)) ||
       (Wnode->InstanceCount != 1) ||
       (Wnode->DataBlockOffset == 0) ||
       (Wnode->FixedInstanceSize != 0xff))
   {
      return(FALSE);
   }

   Data = (ULONG *)OffsetToPtr(Wnode, Wnode->DataBlockOffset);

   //
   // Check data here if you wish; actual values will depend on your
   // AHA154x adapter.
   //
   // [NOT IMPLEMENTED]
   //

   //
   // Print out adapter Setup Data to console.
   //

   PrintOutAdapterSetupData(Data);

   return(TRUE);
}

BOOLEAN AdapterSetupDataQSIValidate(
	TESTGUID * TestGuid,
	PULONG *   DataList,
	PULONG     DataListSize,
   PVOID      Buffer,
	ULONG      BufferSize,
	ULONG      Instance
	)
{
   PWNODE_SINGLE_INSTANCE Wnode = Buffer;
   PULONG Data;

   //
   // Validate WNODE fields.
   //

   if ((Wnode->WnodeHeader.BufferSize == 0) ||
       (Wnode->WnodeHeader.ProviderId == 0) ||
       (Wnode->WnodeHeader.Version != 1) ||
       (Wnode->WnodeHeader.Linkage != 0) ||
       (Wnode->WnodeHeader.TimeStamp.HighPart == 0) ||
       (Wnode->WnodeHeader.TimeStamp.LowPart == 0) ||
       (memcmp(&Wnode->WnodeHeader.Guid, TestGuid->Guid, sizeof(GUID)) != 0) ||
       (Wnode->WnodeHeader.Flags != (WNODE_FLAG_SINGLE_INSTANCE |
                                     WNODE_FLAG_STATIC_INSTANCE_NAMES) ) ||
       (Wnode->InstanceIndex != 0) ||
       (Wnode->SizeDataBlock != 0xff))
   {
      return(FALSE);
   }

   Data = (ULONG *)OffsetToPtr(Wnode, Wnode->DataBlockOffset);

   //
   // Check data here if you wish; actual values will depend on your
   // AHA154x adapter.
   //
   // [NOT IMPLEMENTED]
   //

   //
   // Print out adapter Setup Data to console.
   //

   PrintOutAdapterSetupData(Data);

   return TRUE;
}

//
// Tests.
//

TESTGUID TestList[] = {
    { &AdapterSetupDataGuid,       // LPGUID Guid
      0,                           // (reserved)
      NULL,                        // PULONG DataListSize
      NULL,                        // PULONG * InitDataList
      NULL,                        // PULONG * SINDataList
      NULL,                        // PULONG * SITDataList
      AdapterSetupDataInstances,   // PWCHAR * InstanceNames
      AdapterSetupDataQADValidate, // QADVALIDATION QADValidation
      (WNODE_FLAG_ALL_DATA | WNODE_FLAG_FIXED_INSTANCE_SIZE), // ULONG QADFlags
      1,                           // ULONG InstanceCount
      GetInstanceName,             // GETINSTANCENAME GetInstanceName
      WNODE_FLAG_SINGLE_INSTANCE,  // ULONG QSINTFlags
      AdapterSetupDataQSIValidate, // QDINTVALIDATION QSINTValidation
      NULL,                        // QSINSET QSINSet
      0,                           // ULONG ItemCount
      NULL }                       // QSITSET QSITSet
};

#define TestCount ( sizeof(TestList) / sizeof(TestList[0]) )

//
// Query-All-Data Generic Tester.
//

ULONG QADTest(void)
{
   ULONG i;
   ULONG status;

   for (i = 0; i < TestCount; i++)
   {
      status = WMIOpenBlock(TestList[i].Guid, &TestList[i].Handle);

      if (status != ERROR_SUCCESS)
      {
         printf("Error: QADTest: Couldn't open Handle %d %x\n", i, status);
         TestList[i].Handle = (HANDLE)NULL;
      }
   }

   for (i = 0; i < TestCount;i++)
   {
      if (TestList[i].Handle != (HANDLE)NULL)
      {
         BufferSize = sizeof(Buffer);
         status = WMIQueryAllData(TestList[i].Handle, &BufferSize, Buffer);

         if (status == ERROR_SUCCESS)
         {
            if (! (*TestList[i].QADValidation)(&TestList[i], Buffer, BufferSize))
            {
               printf("ERROR: QADValidation %d failed\n", i);
            }
         }
         else
         {
            printf("Error TestList WMIQueryAllData %d failed %x\n", i, status);
         }
      }
   }

   for (i = 0; i < TestCount;i++)
   {
      if (TestList[i].Handle != (HANDLE)NULL)
      {
         WMICloseBlock(TestList[i].Handle);
      }
   }
   return(ERROR_SUCCESS);
}

//
// Query-Single-Instance Generic Tester.
//

ULONG QSITest(void)
{
   ULONG  i,j;
   ULONG  status;
   PWCHAR InstanceName;
   PBYTE  ValueBuffer;
   ULONG  ValueBufferSize;

   for (i = 0; i < TestCount; i++)
   {
      status = WMIOpenBlock(TestList[i].Guid, &TestList[i].Handle);

      if (status != ERROR_SUCCESS)
      {
         printf("Error: QSINTest: Couldn't open Handle %d %x\n", i, status);
         TestList[i].Handle = (HANDLE)NULL;
      }

      for (j = 0; j < TestList[i].InstanceCount; j++)
      {
         InstanceName = ((*TestList[i].GetInstanceName)(&TestList[i], j));

         //
         // Initial value check
         BufferSize = sizeof(Buffer);

         status = WMIQuerySingleInstance(TestList[i].Handle,
                                         InstanceName,
                                         &BufferSize,
                                         Buffer);
         if (status == ERROR_SUCCESS)
         {
            if (! (*TestList[i].QSINTValidation)(&TestList[i],
                                                 TestList[i].InitDataList,
                                                 TestList[i].DataListSize,
                                                 Buffer, BufferSize, j))
            {
               printf("ERROR: QSINTest Init %d/%d Validation failed %x\n", i,j,status);
            }
         }
         else
         {
            printf("Error QSINTest WMIQuerySingleInstance %d/%d failed %x\n", i, j, status);
         }
      }
   }
   for (i = 0; i < TestCount;i++)
   {
      if (TestList[i].Handle != (HANDLE)NULL)
      {
         WMICloseBlock(TestList[i].Handle);
      }
   }
   return(ERROR_SUCCESS);
}

//
// Executable's entry point.
//

int _cdecl main(int argc, char *argv[])
{
   QADTest();
   QSITest();

   return(ERROR_SUCCESS);
}

//
// Routine to print out queried data from the data provider, for the AHA154x
// Setup Data Guid.
//

typedef struct { PCHAR on; PCHAR off; } BINTYPE;

BINTYPE BinSdtPar[8] =
{
   { "Reserved Bit 0 On", "" },
   { "Parity On", "Parity Off" },
   { "Reserved Bit 2 On", "" },
   { "Reserved Bit 3 On", "" },
   { "Reserved Bit 4 On", "" },
   { "Reserved Bit 5 On", "" },
   { "Reserved Bit 6 On", "" },
   { "Reserved Bit 7 On", "" }
};

BINTYPE BinDisOpt[8] =
{
   { "0", "" },
   { "1", "" },
   { "2", "" },
   { "3", "" },
   { "4", "" },
   { "5", "" },
   { "6", "" },
   { "7", "" }
};

void PrintBinaryFlags(char * string, BINTYPE * binType, UCHAR byte)
{
   int i;
   int none = 1;

   printf("%s", string);

   for (i = 0; i < 8; i++) {
      if (byte & 0x1) {
         if (*binType[i].on) {
            if (!none) {
               printf(", ");
            }
            printf("%s", binType[i].on);
            none = 0;
         }
      } else {
         if (*binType[i].off) {
            if (!none) {
               printf(", ");
            }
            printf("%s", binType[i].off);
            none = 0;
         }
      }
      byte = byte >> 1;
   }

   if (none) {
      printf("None.");
   }

   printf("\n");
}

void PrintTransferSpeed(char * string, UCHAR byte)
{
   printf("%s", string);

   if (byte == 0) {
      printf("5.0 Mb/s");
   } else if (byte == 1) {
      printf("6.7 Mb/s");
   } else if (byte == 2) {
      printf("8.0 Mb/s");
   } else if (byte == 3) {
      printf("10 Mb/s");
   } else if (byte == 4) {
      printf("5.7 Mb/s");
   } else if (byte == 0xff) {
      printf("3.3 Mb/s");
   } else {
      if (byte & 0x80) {
         printf("Bit 7 On, ");
      }

      if (byte & 0x08) {
         printf("Strobe 150ns, ");
      } else {
         printf("Strobe 100ns, ");
      }

      printf("Read Pulse ");
      switch ((byte >> 4) & 0x7) {
      case 0:
         printf("100ns");
         break;
      case 1:
         printf("150ns");
         break;
      case 2:
         printf("200ns");
         break;
      case 3:
         printf("250ns");
         break;
      case 4:
         printf("300ns");
         break;
      case 5:
         printf("350ns");
         break;
      case 6:
         printf("400ns");
         break;
      case 7:
         printf("450ns");
         break;
      }

      printf(", Write Pulse ");
      switch (byte & 0x7) {
      case 0:
         printf("100ns");
         break;
      case 1:
         printf("150ns");
         break;
      case 2:
         printf("200ns");
         break;
      case 3:
         printf("250ns");
         break;
      case 4:
         printf("300ns");
         break;
      case 5:
         printf("350ns");
         break;
      case 6:
         printf("400ns");
         break;
      case 7:
         printf("450ns");
         break;
      }
   }

   printf("\n");
}

void PrintSynTraAgr(char * string, UCHAR byte)
{
   printf("%s", string);

   if (byte & 0x80) {
      printf("Negotiated, ");
   } else {
      printf("Not Negotiated, ");
   }

   printf("Period %d ns, ", ((int)(byte>>4) & 0x07) * 50 + 100);

   if (byte & 0xF) {
      printf("Offset %d", (int)(byte&0xF));
   } else {
      printf("Offset Async");
   }

   printf("\n");
}

void PrintString(char * string, char * ptr, int length)
{
   int none = 1;

   printf("%s", string);

   for (; length; length--) {
      if (*ptr == 0) {
         break;
      }
      printf("%c",*ptr);
      none = 0;
      ptr++;
   }

   if (none) {
      printf("None.");
   }

   printf("\n");
}

void PrintSwitches(UCHAR byte)
{
   int i;

   printf("Adapter DIP Switches [7-0]: ");

   for (i = 0; i < 8; i++) {
      if (byte & 0x1) {
         printf("1");
      } else {
         printf("0");
      }
      byte = byte >> 1;
   }
   printf("\n");
}

void PrintOutAdapterSetupData(PULONG Data)
{
   PUCHAR ptr = (PUCHAR)Data;
   int  i;

   printf("- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n"
          "                  AHA154X ADAPTER SETUP DATA\n"
          "- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n");

   for (i = 0; i < 0xff; i++) {
      if ((i % 16) == 0) {
         printf("\n%02x: ", i);
      }
      printf("%02x ", *ptr);
      ptr++;
   }

   printf("\n\n");
   ptr = (PUCHAR) Data;

   PrintBinaryFlags("SDT and Parity Status: ", BinSdtPar, *ptr++);
   PrintTransferSpeed("Transfer Speed: ", *ptr++);

   printf("Bus On Time: %d ms\n", (int)*ptr++);
   printf("Bus Off Time: %d ms\n", (int)*ptr++);
   printf("Number Of Mailboxes: %d\n", (int)*ptr++);
   printf("Mailbox Address: 0x%02x%02x%02x\n", (int)*ptr, (int)*(ptr+1), (int)*(ptr+2));
   ptr += 3;

   PrintSynTraAgr("Sync Target 0 Agreements: ", *ptr++);
   PrintSynTraAgr("Sync Target 1 Agreements: ", *ptr++);
   PrintSynTraAgr("Sync Target 2 Agreements: ", *ptr++);
   PrintSynTraAgr("Sync Target 3 Agreements: ", *ptr++);
   PrintSynTraAgr("Sync Target 4 Agreements: ", *ptr++);
   PrintSynTraAgr("Sync Target 5 Agreements: ", *ptr++);
   PrintSynTraAgr("Sync Target 6 Agreements: ", *ptr++);
   PrintSynTraAgr("Sync Target 7 Agreements: ", *ptr++);

   PrintBinaryFlags("Disconnection Options: ", BinDisOpt, *ptr++);

   PrintString("Customer Banner: ", ptr, 20);
   ptr += 20;

   if (*ptr++) {
      printf("Auto Retry Options: NON-ZERO (BAD).\n");
   } else {
      printf("Auto Retry Options: None.\n");
   }

   PrintSwitches(*ptr++);

   printf("Firmware Checksum: 0x%02x%02x\n", (int)*ptr, (int)*(ptr+1) );
   ptr += 2;
   printf("BIOS Mailbox Address: 0x%02x%02x%02x\n", (int)*ptr, (int)*(ptr+1), (int)*(ptr+2));
   ptr += 3;
}



=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\port\scsi\miniport\atapi\atapi.c ===
/*++

Copyright (c) 1993-6  Microsoft Corporation

Module Name:

    atapi.c

Abstract:

    This is the miniport driver for ATAPI IDE controllers.

Author:

    Mike Glass (MGlass)
    Chuck Park (ChuckP)
    Joe Dai (joedai)

Environment:

    kernel mode only

Notes:

Revision History:

    george C.(georgioc)     Merged wtih Compaq code to make miniport driver function
                            with the 120MB floppy drive
                            Added support for MEDIA STATUS NOTIFICATION
                            Added support for SCSIOP_START_STOP_UNIT (eject media)

    joedai                  PCI Bus Master IDE Support
                            ATA Passthrough (temporary solution)
                            LBA with ATA drive > 8G
                            PCMCIA IDE support
                            Native mode support

--*/


#include "miniport.h"
#include "devioctl.h"
#include "atapi.h"               // includes scsi.h
#include "ntdddisk.h"
#include "ntddscsi.h"

#include "intel.h"

//
// Logical unit extension
//

typedef struct _HW_LU_EXTENSION {
   ULONG Reserved;
} HW_LU_EXTENSION, *PHW_LU_EXTENSION;

//
// control DMA detection
//
ULONG AtapiPlaySafe = 1;

//
// PCI IDE Controller List
//
CONTROLLER_PARAMETERS
PciControllerParameters[] = {
    {                     PCIBus,
                          "8086",                   // Intel
                               4,
                          "7111",                   // PIIX4 82371
                               4,
                               2,                   // NumberOfIdeBus
                           FALSE,                   // Dual FIFO
                            NULL,
            IntelIsChannelEnabled
    },
    {                     PCIBus,
                          "8086",                   // Intel
                               4,
                          "7010",                   // PIIX3 82371
                               4,
                               2,                   // NumberOfIdeBus
                           FALSE,                   // Dual FIFO
                            NULL,
            IntelIsChannelEnabled
    },
    {                     PCIBus,
                          "8086",                   // Intel
                               4,
                          "1230",                   // PIIX 82371
                               4,
                               2,                   // NumberOfIdeBus
                           FALSE,                   // Dual FIFO
                            NULL,
            IntelIsChannelEnabled
    },
    {                     PCIBus,
                          "1095",                   // CMD
                               4,
                          "0646",                   // 646
                               4,
                               2,                   // NumberOfIdeBus
                           FALSE,                   // Dual FIFO
                            NULL,
          ChannelIsAlwaysEnabled
    },
    {                     PCIBus,
                          "10b9",                   // ALi (Acer)
                               4,
                          "5219",                   // 5219
                               4,
                               2,                   // NumberOfIdeBus
                           FALSE,                   // Dual FIFO
                            NULL,
          ChannelIsAlwaysEnabled
    },
    {                     PCIBus,
                          "1039",                   // SiS
                               4,
                          "5513",                   // 5513
                               4,
                               2,                   // NumberOfIdeBus
                           FALSE,                   // Dual FIFO
                            NULL,
          ChannelIsAlwaysEnabled
    },
    {                     PCIBus,
                          "0e11",                   // Compaq
                               4,
                          "ae33",                   //
                               4,
                               2,                   // NumberOfIdeBus
                           FALSE,                   // Dual FIFO
                            NULL,
          ChannelIsAlwaysEnabled
    },
    {                     PCIBus,
                          "10ad",                   // WinBond
                               4,
                          "0105",                   // 105
                               4,
                               2,                   // NumberOfIdeBus
                           FALSE,                   // Dual FIFO
                            NULL,
          ChannelIsAlwaysEnabled
    },
    {                     PCIBus,
                          "105a",                   // Promise Technologies
                               4,
                          "4D33",                   // U33
                               4,
                               2,                   // NumberOfIdeBus
                           FALSE,                   // Dual FIFO
                            NULL,
          ChannelIsAlwaysEnabled
    },


// Broken PCI controllers
    {                     PCIBus,
                          "1095",                   // CMD
                               4,
                          "0640",                   // 640
                               4,
                               2,                   // NumberOfIdeBus
                            TRUE,                   // Single FIFO
                            NULL,
          ChannelIsAlwaysEnabled
    },
    {                     PCIBus,
                          "1039",                   // SiS
                               4,
                          "0601",                   // ????
                               4,
                               2,                   // NumberOfIdeBus
                            TRUE,                   // Single FIFO
                            NULL,
          ChannelIsAlwaysEnabled
    }
};
#define NUMBER_OF_PCI_CONTROLLER (sizeof(PciControllerParameters) / sizeof(CONTROLLER_PARAMETERS))

PSCSI_REQUEST_BLOCK
BuildMechanismStatusSrb (
    IN PVOID HwDeviceExtension,
    IN ULONG PathId,
    IN ULONG TargetId
    );

PSCSI_REQUEST_BLOCK
BuildRequestSenseSrb (
    IN PVOID HwDeviceExtension,
    IN ULONG PathId,
    IN ULONG TargetId
    );

VOID
AtapiHwInitializeChanger (
    IN PVOID HwDeviceExtension,
    IN ULONG TargetId,
    IN PMECHANICAL_STATUS_INFORMATION_HEADER MechanismStatus
    );

ULONG
AtapiSendCommand(
    IN PVOID HwDeviceExtension,
    IN PSCSI_REQUEST_BLOCK Srb
    );

VOID
AtapiZeroMemory(
    IN PCHAR Buffer,
    IN ULONG Count
    );

VOID
AtapiHexToString (
    ULONG Value,
    PCHAR *Buffer
    );

LONG
AtapiStringCmp (
    PCHAR FirstStr,
    PCHAR SecondStr,
    ULONG Count
    );

BOOLEAN
AtapiInterrupt(
    IN PVOID HwDeviceExtension
    );

BOOLEAN
AtapiHwInitialize(
    IN PVOID HwDeviceExtension
        );

ULONG
IdeBuildSenseBuffer(
    IN PVOID HwDeviceExtension,
    IN PSCSI_REQUEST_BLOCK Srb
    );

VOID
IdeMediaStatus(
    IN BOOLEAN EnableMSN,
    IN PVOID HwDeviceExtension,
    IN ULONG Channel
    );

VOID
DeviceSpecificInitialize(
    IN PVOID HwDeviceExtension
    );

BOOLEAN
PrepareForBusMastering(
    IN PVOID HwDeviceExtension,
    IN PSCSI_REQUEST_BLOCK Srb
    );

BOOLEAN
EnableBusMastering(
    IN PVOID HwDeviceExtension,
    IN PSCSI_REQUEST_BLOCK Srb
    );

VOID
SetBusMasterDetectionLevel (
    IN PVOID HwDeviceExtension,
    IN PCHAR userArgumentString
    );

BOOLEAN
AtapiDeviceDMACapable (
    IN PVOID HwDeviceExtension,
    IN ULONG deviceNumber
    );

#if defined (xDBG)
// Need to link to nt kernel
void KeQueryTickCount(PLARGE_INTEGER c);
LONGLONG lastTickCount = 0;
#define DebugPrintTickCount()     _DebugPrintTickCount (__LINE__)

//
// for performance tuning
//
void _DebugPrintTickCount (ULONG lineNumber)
{
    LARGE_INTEGER tickCount;

        KeQueryTickCount(&tickCount);
    DebugPrint ((1, "Line %u: CurrentTick = %u (%u ticks since last check)\n", lineNumber, tickCount.LowPart, (ULONG) (tickCount.QuadPart - lastTickCount)));
    lastTickCount = tickCount.QuadPart;
}
#else
#define DebugPrintTickCount()
#endif //DBG



BOOLEAN
IssueIdentify(
    IN PVOID HwDeviceExtension,
    IN ULONG DeviceNumber,
    IN ULONG Channel,
    IN UCHAR Command,
    IN BOOLEAN InterruptOff
    )

/*++

Routine Description:

    Issue IDENTIFY command to a device.

Arguments:

    HwDeviceExtension - HBA miniport driver's adapter data storage
    DeviceNumber - Indicates which device.
    Command - Either the standard (EC) or the ATAPI packet (A1) IDENTIFY.
    InterruptOff - should leave interrupt disabled

Return Value:

    TRUE if all goes well.

--*/

{
    PHW_DEVICE_EXTENSION deviceExtension = HwDeviceExtension;
    PIDE_REGISTERS_1     baseIoAddress1 = deviceExtension->BaseIoAddress1[Channel] ;
    PIDE_REGISTERS_2     baseIoAddress2 = deviceExtension->BaseIoAddress2[Channel];
    ULONG                waitCount = 20000;
    ULONG                i,j;
    UCHAR                statusByte;
    UCHAR                signatureLow,
                         signatureHigh;
    IDENTIFY_DATA        fullIdentifyData;

    DebugPrintTickCount();

    //
    // Select device 0 or 1.
    //

    ScsiPortWritePortUchar(&baseIoAddress1->DriveSelect,
                           (UCHAR)((DeviceNumber << 4) | 0xA0));

    //
    // Check that the status register makes sense.
    //

    GetBaseStatus(baseIoAddress1, statusByte);

    if (Command == IDE_COMMAND_IDENTIFY) {

        //
        // Mask status byte ERROR bits.
        //

        statusByte &= ~(IDE_STATUS_ERROR | IDE_STATUS_INDEX);

        DebugPrint((1,
                    "IssueIdentify: Checking for IDE. Status (%x)\n",
                    statusByte));

        //
        // Check if register value is reasonable.
        //

        if (statusByte != IDE_STATUS_IDLE) {

            //
            // Reset the controller.
            //

            AtapiSoftReset(baseIoAddress1,DeviceNumber, InterruptOff);

            ScsiPortWritePortUchar(&baseIoAddress1->DriveSelect,
                                   (UCHAR)((DeviceNumber << 4) | 0xA0));

            WaitOnBusy(baseIoAddress1,statusByte);

            signatureLow = ScsiPortReadPortUchar(&baseIoAddress1->CylinderLow);
            signatureHigh = ScsiPortReadPortUchar(&baseIoAddress1->CylinderHigh);

            if (signatureLow == 0x14 && signatureHigh == 0xEB) {

                //
                // Device is Atapi.
                //

                DebugPrintTickCount();
                return FALSE;
            }

            DebugPrint((1,
                        "IssueIdentify: Resetting controller.\n"));

            ScsiPortWritePortUchar(&baseIoAddress2->DeviceControl,IDE_DC_RESET_CONTROLLER | IDE_DC_DISABLE_INTERRUPTS);
            ScsiPortStallExecution(500 * 1000);
            if (InterruptOff) {
                ScsiPortWritePortUchar(&baseIoAddress2->DeviceControl, IDE_DC_DISABLE_INTERRUPTS);
            } else {
                ScsiPortWritePortUchar(&baseIoAddress2->DeviceControl, IDE_DC_REENABLE_CONTROLLER);
            }


            // We really should wait up to 31 seconds
            // The ATA spec. allows device 0 to come back from BUSY in 31 seconds!
            // (30 seconds for device 1)
            do {

                //
                // Wait for Busy to drop.
                //

                ScsiPortStallExecution(100);
                GetStatus(baseIoAddress1, statusByte);

            } while ((statusByte & IDE_STATUS_BUSY) && waitCount--);

            ScsiPortWritePortUchar(&baseIoAddress1->DriveSelect,
                                   (UCHAR)((DeviceNumber << 4) | 0xA0));

            //
            // Another check for signature, to deal with one model Atapi that doesn't assert signature after
            // a soft reset.
            //

            signatureLow = ScsiPortReadPortUchar(&baseIoAddress1->CylinderLow);
            signatureHigh = ScsiPortReadPortUchar(&baseIoAddress1->CylinderHigh);

            if (signatureLow == 0x14 && signatureHigh == 0xEB) {

                //
                // Device is Atapi.
                //

                DebugPrintTickCount();
                return FALSE;
            }

            statusByte &= ~IDE_STATUS_INDEX;

            if (statusByte != IDE_STATUS_IDLE) {

                //
                // Give up on this.
                //

                DebugPrintTickCount();
                return FALSE;
            }

        }

    } else {

        DebugPrint((1,
                    "IssueIdentify: Checking for ATAPI. Status (%x)\n",
                    statusByte));

    }

    //
    // Load CylinderHigh and CylinderLow with number bytes to transfer.
    //

    ScsiPortWritePortUchar(&baseIoAddress1->CylinderHigh, (0x200 >> 8));
    ScsiPortWritePortUchar(&baseIoAddress1->CylinderLow,  (0x200 & 0xFF));

    for (j = 0; j < 2; j++) {

        //
        // Send IDENTIFY command.
        //

        WaitOnBusy(baseIoAddress1,statusByte);

        ScsiPortWritePortUchar(&baseIoAddress1->Command, Command);

        WaitOnBusy(baseIoAddress1,statusByte);

        //
        // Wait for DRQ.
        //

        for (i = 0; i < 4; i++) {

            WaitForDrq(baseIoAddress1, statusByte);

            if (statusByte & IDE_STATUS_DRQ) {

                //
                // Read status to acknowledge any interrupts generated.
                //

                GetBaseStatus(baseIoAddress1, statusByte);

                //
                // One last check for Atapi.
                //


                signatureLow = ScsiPortReadPortUchar(&baseIoAddress1->CylinderLow);
                signatureHigh = ScsiPortReadPortUchar(&baseIoAddress1->CylinderHigh);

                if (signatureLow == 0x14 && signatureHigh == 0xEB) {

                    //
                    // Device is Atapi.
                    //

                    DebugPrintTickCount();
                    return FALSE;
                }

                break;
            }

            if (Command == IDE_COMMAND_IDENTIFY) {

                //
                // Check the signature. If DRQ didn't come up it's likely Atapi.
                //

                signatureLow = ScsiPortReadPortUchar(&baseIoAddress1->CylinderLow);
                signatureHigh = ScsiPortReadPortUchar(&baseIoAddress1->CylinderHigh);

                if (signatureLow == 0x14 && signatureHigh == 0xEB) {

                    //
                    // Device is Atapi.
                    //

                    DebugPrintTickCount();
                    return FALSE;
                }
            }

            WaitOnBusy(baseIoAddress1,statusByte);
        }

        if (i == 4 && j == 0) {

            //
            // Device didn't respond correctly. It will be given one more chances.
            //

            DebugPrint((1,
                        "IssueIdentify: DRQ never asserted (%x). Error reg (%x)\n",
                        statusByte,
                         ScsiPortReadPortUchar((PUCHAR)baseIoAddress1 + 1)));

            AtapiSoftReset(baseIoAddress1, DeviceNumber, InterruptOff);

            GetStatus(baseIoAddress1,statusByte);

            DebugPrint((1,
                       "IssueIdentify: Status after soft reset (%x)\n",
                       statusByte));

        } else {

            break;

        }
    }

    //
    // Check for error on really bad master devices that assert random
    // patterns of bits in the status register at the slave address.
    //

    if ((Command == IDE_COMMAND_IDENTIFY) && (statusByte & IDE_STATUS_ERROR)) {
        DebugPrintTickCount();
        return FALSE;
    }

    DebugPrint((1,
               "IssueIdentify: Status before read words %x\n",
               statusByte));

    //
    // Suck out 256 words. After waiting for one model that asserts busy
    // after receiving the Packet Identify command.
    //

    WaitOnBusy(baseIoAddress1,statusByte);

    if (!(statusByte & IDE_STATUS_DRQ)) {
        DebugPrintTickCount();
        return FALSE;
    }

    ReadBuffer(baseIoAddress1,
               (PUSHORT)&fullIdentifyData,
               sizeof (fullIdentifyData) / 2);

    //
    // Check out a few capabilities / limitations of the device.
    //

    if (fullIdentifyData.SpecialFunctionsEnabled & 1) {

        //
        // Determine if this drive supports the MSN functions.
        //

        DebugPrint((2,"IssueIdentify: Marking drive %d as removable. SFE = %d\n",
                    Channel * 2 + DeviceNumber,
                    fullIdentifyData.SpecialFunctionsEnabled));


        deviceExtension->DeviceFlags[(Channel * 2) + DeviceNumber] |= DFLAGS_REMOVABLE_DRIVE;
    }

    if (fullIdentifyData.MaximumBlockTransfer) {

        //
        // Determine max. block transfer for this device.
        //

        deviceExtension->MaximumBlockXfer[(Channel * 2) + DeviceNumber] =
            (UCHAR)(fullIdentifyData.MaximumBlockTransfer & 0xFF);
    }

    ScsiPortMoveMemory(&deviceExtension->IdentifyData[(Channel * 2) + DeviceNumber],&fullIdentifyData,sizeof(IDENTIFY_DATA2));

    if (deviceExtension->IdentifyData[(Channel * 2) + DeviceNumber].GeneralConfiguration & 0x20 &&
        Command != IDE_COMMAND_IDENTIFY) {

        //
        // This device interrupts with the assertion of DRQ after receiving
        // Atapi Packet Command
        //

        deviceExtension->DeviceFlags[(Channel * 2) + DeviceNumber] |= DFLAGS_INT_DRQ;

        DebugPrint((2,
                    "IssueIdentify: Device interrupts on assertion of DRQ.\n"));

    } else {

        DebugPrint((2,
                    "IssueIdentify: Device does not interrupt on assertion of DRQ.\n"));
    }

    if (((deviceExtension->IdentifyData[(Channel * 2) + DeviceNumber].GeneralConfiguration & 0xF00) == 0x100) &&
        Command != IDE_COMMAND_IDENTIFY) {

        //
        // This is a tape.
        //

        deviceExtension->DeviceFlags[(Channel * 2) + DeviceNumber] |= DFLAGS_TAPE_DEVICE;

        DebugPrint((2,
                    "IssueIdentify: Device is a tape drive.\n"));

    } else {

        DebugPrint((2,
                    "IssueIdentify: Device is not a tape drive.\n"));
    }

    //
    // Work around for some IDE and one model Atapi that will present more than
    // 256 bytes for the Identify data.
    //

    WaitOnBusy(baseIoAddress1,statusByte);

    for (i = 0; i < 0x10000; i++) {

        GetStatus(baseIoAddress1,statusByte);

        if (statusByte & IDE_STATUS_DRQ) {

            //
            // Suck out any remaining bytes and throw away.
            //

            ScsiPortReadPortUshort(&baseIoAddress1->Data);

        } else {

            break;

        }
    }

    DebugPrint((3,
               "IssueIdentify: Status after read words (%x)\n",
               statusByte));

    DebugPrintTickCount();
    return TRUE;

} // end IssueIdentify()


BOOLEAN
SetDriveParameters(
    IN PVOID HwDeviceExtension,
    IN ULONG DeviceNumber,
    IN ULONG Channel
    )

/*++

Routine Description:

    Set drive parameters using the IDENTIFY data.

Arguments:

    HwDeviceExtension - HBA miniport driver's adapter data storage
    DeviceNumber - Indicates which device.

Return Value:

    TRUE if all goes well.


--*/

{
    PHW_DEVICE_EXTENSION deviceExtension = HwDeviceExtension;
    PIDE_REGISTERS_1     baseIoAddress1 = deviceExtension->BaseIoAddress1[Channel];
    PIDE_REGISTERS_2     baseIoAddress2 = deviceExtension->BaseIoAddress2[Channel];
    PIDENTIFY_DATA2      identifyData   = &deviceExtension->IdentifyData[(Channel * 2) + DeviceNumber];
    ULONG i;
    UCHAR statusByte;

    DebugPrint((1,
               "SetDriveParameters: Number of heads %x\n",
               identifyData->NumberOfHeads));

    DebugPrint((1,
               "SetDriveParameters: Sectors per track %x\n",
                identifyData->SectorsPerTrack));

    //
    // Set up registers for SET PARAMETER command.
    //

    ScsiPortWritePortUchar(&baseIoAddress1->DriveSelect,
                           (UCHAR)(((DeviceNumber << 4) | 0xA0) | (identifyData->NumberOfHeads - 1)));

    ScsiPortWritePortUchar(&baseIoAddress1->BlockCount,
                           (UCHAR)identifyData->SectorsPerTrack);

    //
    // Send SET PARAMETER command.
    //

    ScsiPortWritePortUchar(&baseIoAddress1->Command,
                           IDE_COMMAND_SET_DRIVE_PARAMETERS);

    //
    // Wait for up to 30 milliseconds for ERROR or command complete.
    //

    for (i=0; i<30 * 1000; i++) {

        UCHAR errorByte;

        GetStatus(baseIoAddress1, statusByte);

        if (statusByte & IDE_STATUS_ERROR) {
            errorByte = ScsiPortReadPortUchar((PUCHAR)baseIoAddress1 + 1);
            DebugPrint((1,
                        "SetDriveParameters: Error bit set. Status %x, error %x\n",
                        errorByte,
                        statusByte));

            return FALSE;
        } else if ((statusByte & ~IDE_STATUS_INDEX ) == IDE_STATUS_IDLE) {
            break;
        } else {
            ScsiPortStallExecution(100);
        }
    }

    //
    // Check for timeout.
    //

    if (i == 30 * 1000) {
        return FALSE;
    } else {
        return TRUE;
    }

} // end SetDriveParameters()


BOOLEAN
AtapiResetController(
    IN PVOID HwDeviceExtension,
    IN ULONG PathId
    )

/*++

Routine Description:

    Reset IDE controller and/or Atapi device.

Arguments:

    HwDeviceExtension - HBA miniport driver's adapter data storage

Return Value:

    Nothing.


--*/

{
    PHW_DEVICE_EXTENSION deviceExtension = HwDeviceExtension;
    ULONG                numberChannels  = deviceExtension->NumberChannels;
    PIDE_REGISTERS_1 baseIoAddress1;
    PIDE_REGISTERS_2 baseIoAddress2;
    BOOLEAN result = FALSE;
    ULONG i,j;
    UCHAR statusByte;

    DebugPrint((2,"AtapiResetController: Reset IDE\n"));

    //
    // Check and see if we are processing an internal srb
    //
    if (deviceExtension->OriginalSrb) {
        deviceExtension->CurrentSrb = deviceExtension->OriginalSrb;
        deviceExtension->OriginalSrb = NULL;
    }

    //
    // Check if request is in progress.
    //

    if (deviceExtension->CurrentSrb) {

        //
        // Complete outstanding request with SRB_STATUS_BUS_RESET.
        //

        ScsiPortCompleteRequest(deviceExtension,
                                deviceExtension->CurrentSrb->PathId,
                                deviceExtension->CurrentSrb->TargetId,
                                deviceExtension->CurrentSrb->Lun,
                                (ULONG)SRB_STATUS_BUS_RESET);

        //
        // Clear request tracking fields.
        //

        deviceExtension->CurrentSrb = NULL;
        deviceExtension->WordsLeft = 0;
        deviceExtension->DataBuffer = NULL;

        //
        // Indicate ready for next request.
        //

        ScsiPortNotification(NextRequest,
                             deviceExtension,
                             NULL);
    }

    //
    // Clear DMA
    //
    if (deviceExtension->DMAInProgress) {

        for (j = 0; j < numberChannels; j++) {
            UCHAR dmaStatus;

            dmaStatus = ScsiPortReadPortUchar (&deviceExtension->BusMasterPortBase[j]->Status);
            ScsiPortWritePortUchar (&deviceExtension->BusMasterPortBase[j]->Command, 0);  // disable BusMastering
            ScsiPortWritePortUchar (&deviceExtension->BusMasterPortBase[j]->Status,
                                    (UCHAR) (dmaStatus & (BUSMASTER_DEVICE0_DMA_OK | BUSMASTER_DEVICE1_DMA_OK)));    // clear interrupt/error
        }
        deviceExtension->DMAInProgress = FALSE;
    }

    //
    // Clear expecting interrupt flag.
    //

    deviceExtension->ExpectingInterrupt = FALSE;
    deviceExtension->RDP = FALSE;

    for (j = 0; j < numberChannels; j++) {

        baseIoAddress1 = deviceExtension->BaseIoAddress1[j];
        baseIoAddress2 = deviceExtension->BaseIoAddress2[j];

        //
        // Do special processing for ATAPI and IDE disk devices.
        //

        for (i = 0; i < 2; i++) {

            //
            // Check if device present.
            //

            if (deviceExtension->DeviceFlags[i + (j * 2)] & DFLAGS_DEVICE_PRESENT) {

                //
                // Check for ATAPI disk.
                //

                if (deviceExtension->DeviceFlags[i + (j * 2)] & DFLAGS_ATAPI_DEVICE) {

                    //
                    // Issue soft reset and issue identify.
                    //

                    GetStatus(baseIoAddress1,statusByte);
                    DebugPrint((1,
                                "AtapiResetController: Status before Atapi reset (%x).\n",
                                statusByte));

                    AtapiSoftReset(baseIoAddress1,i, FALSE);

                    GetStatus(baseIoAddress1,statusByte);


                    if (statusByte == 0x0) {

                        IssueIdentify(HwDeviceExtension,
                                      i,
                                      j,
                                      IDE_COMMAND_ATAPI_IDENTIFY,
                                      FALSE);
                    } else {

                        DebugPrint((1,
                                   "AtapiResetController: Status after soft reset %x\n",
                                   statusByte));
                    }

                } else {

                    //
                    // Write IDE reset controller bits.
                    //

                    IdeHardReset(baseIoAddress1, baseIoAddress2,result);

                    if (!result) {
                        return FALSE;
                    }

                    //
                    // Set disk geometry parameters.
                    //

                    if (!SetDriveParameters(HwDeviceExtension,
                                            i,
                                            j)) {

                        DebugPrint((1,
                                   "AtapiResetController: SetDriveParameters failed\n"));
                    }

                    // re-enable MSN
                    IdeMediaStatus(TRUE, HwDeviceExtension, j * numberChannels + i);
                }
            }
        }
    }

    //
    // Call the HwInitialize routine to setup multi-block.
    //

    AtapiHwInitialize(HwDeviceExtension);

    return TRUE;

} // end AtapiResetController()



ULONG
MapError(
    IN PVOID HwDeviceExtension,
    IN PSCSI_REQUEST_BLOCK Srb
    )

/*++

Routine Description:

    This routine maps ATAPI and IDE errors to specific SRB statuses.

Arguments:

    HwDeviceExtension - HBA miniport driver's adapter data storage
    Srb - IO request packet

Return Value:

    SRB status

--*/

{
    PHW_DEVICE_EXTENSION deviceExtension = HwDeviceExtension;
    PIDE_REGISTERS_1     baseIoAddress1  = deviceExtension->BaseIoAddress1[Srb->TargetId >> 1];
    PIDE_REGISTERS_2     baseIoAddress2  = deviceExtension->BaseIoAddress2[Srb->TargetId >> 1];
    ULONG i;
    UCHAR errorByte;
    UCHAR srbStatus;
    UCHAR scsiStatus;

    //
    // Read the error register.
    //

    errorByte = ScsiPortReadPortUchar((PUCHAR)baseIoAddress1 + 1);
    DebugPrint((1,
               "MapError: Error register is %x\n",
               errorByte));

    if (deviceExtension->DeviceFlags[Srb->TargetId] & DFLAGS_ATAPI_DEVICE) {

        switch (errorByte >> 4) {
        case SCSI_SENSE_NO_SENSE:

            DebugPrint((1,
                       "ATAPI: No sense information\n"));
            scsiStatus = SCSISTAT_CHECK_CONDITION;
            srbStatus = SRB_STATUS_ERROR;
            break;

        case SCSI_SENSE_RECOVERED_ERROR:

            DebugPrint((1,
                       "ATAPI: Recovered error\n"));
            scsiStatus = 0;
            srbStatus = SRB_STATUS_SUCCESS;
            break;

        case SCSI_SENSE_NOT_READY:

            DebugPrint((1,
                       "ATAPI: Device not ready\n"));
            scsiStatus = SCSISTAT_CHECK_CONDITION;
            srbStatus = SRB_STATUS_ERROR;
            break;

        case SCSI_SENSE_MEDIUM_ERROR:

            DebugPrint((1,
                       "ATAPI: Media error\n"));
            scsiStatus = SCSISTAT_CHECK_CONDITION;
            srbStatus = SRB_STATUS_ERROR;
            break;

        case SCSI_SENSE_HARDWARE_ERROR:

            DebugPrint((1,
                       "ATAPI: Hardware error\n"));
            scsiStatus = SCSISTAT_CHECK_CONDITION;
            srbStatus = SRB_STATUS_ERROR;
            break;

        case SCSI_SENSE_ILLEGAL_REQUEST:

            DebugPrint((1,
                       "ATAPI: Illegal request\n"));
            scsiStatus = SCSISTAT_CHECK_CONDITION;
            srbStatus = SRB_STATUS_ERROR;
            break;

        case SCSI_SENSE_UNIT_ATTENTION:

            DebugPrint((1,
                       "ATAPI: Unit attention\n"));
            scsiStatus = SCSISTAT_CHECK_CONDITION;
            srbStatus = SRB_STATUS_ERROR;
            break;

        case SCSI_SENSE_DATA_PROTECT:

            DebugPrint((1,
                       "ATAPI: Data protect\n"));
            scsiStatus = SCSISTAT_CHECK_CONDITION;
            srbStatus = SRB_STATUS_ERROR;
            break;

        case SCSI_SENSE_BLANK_CHECK:

            DebugPrint((1,
                       "ATAPI: Blank check\n"));
            scsiStatus = SCSISTAT_CHECK_CONDITION;
            srbStatus = SRB_STATUS_ERROR;
            break;

        case SCSI_SENSE_ABORTED_COMMAND:
            DebugPrint((1,
                        "Atapi: Command Aborted\n"));
            scsiStatus = SCSISTAT_CHECK_CONDITION;
            srbStatus = SRB_STATUS_ERROR;
            break;

        default:

            DebugPrint((1,
                       "ATAPI: Invalid sense information\n"));
            scsiStatus = 0;
            srbStatus = SRB_STATUS_ERROR;
            break;
        }

    } else {

        scsiStatus = 0;
        //
        // Save errorByte,to be used by SCSIOP_REQUEST_SENSE.
        //

        deviceExtension->ReturningMediaStatus = errorByte;

        if (errorByte & IDE_ERROR_MEDIA_CHANGE_REQ) {
            DebugPrint((1,
                       "IDE: Media change\n"));
            scsiStatus = SCSISTAT_CHECK_CONDITION;
            srbStatus = SRB_STATUS_ERROR;

        } else if (errorByte & IDE_ERROR_COMMAND_ABORTED) {
            DebugPrint((1,
                       "IDE: Command abort\n"));
            srbStatus = SRB_STATUS_ABORTED;
            scsiStatus = SCSISTAT_CHECK_CONDITION;

            if (Srb->SenseInfoBuffer) {

                PSENSE_DATA  senseBuffer = (PSENSE_DATA)Srb->SenseInfoBuffer;

                senseBuffer->ErrorCode = 0x70;
                senseBuffer->Valid     = 1;
                senseBuffer->AdditionalSenseLength = 0xb;
                senseBuffer->SenseKey =  SCSI_SENSE_ABORTED_COMMAND;
                senseBuffer->AdditionalSenseCode = 0;
                senseBuffer->AdditionalSenseCodeQualifier = 0;

                srbStatus |= SRB_STATUS_AUTOSENSE_VALID;
            }

            deviceExtension->ErrorCount++;

        } else if (errorByte & IDE_ERROR_END_OF_MEDIA) {

            DebugPrint((1,
                       "IDE: End of media\n"));
            scsiStatus = SCSISTAT_CHECK_CONDITION;
            srbStatus = SRB_STATUS_ERROR;
            if (!(deviceExtension->DeviceFlags[Srb->TargetId] & DFLAGS_MEDIA_STATUS_ENABLED)){
                deviceExtension->ErrorCount++;
            }

        } else if (errorByte & IDE_ERROR_ILLEGAL_LENGTH) {

            DebugPrint((1,
                       "IDE: Illegal length\n"));
            srbStatus = SRB_STATUS_INVALID_REQUEST;

        } else if (errorByte & IDE_ERROR_BAD_BLOCK) {

            DebugPrint((1,
                       "IDE: Bad block\n"));
            srbStatus = SRB_STATUS_ERROR;
            scsiStatus = SCSISTAT_CHECK_CONDITION;
            if (Srb->SenseInfoBuffer) {

                PSENSE_DATA  senseBuffer = (PSENSE_DATA)Srb->SenseInfoBuffer;

                senseBuffer->ErrorCode = 0x70;
                senseBuffer->Valid     = 1;
                senseBuffer->AdditionalSenseLength = 0xb;
                senseBuffer->SenseKey =  SCSI_SENSE_MEDIUM_ERROR;
                senseBuffer->AdditionalSenseCode = 0;
                senseBuffer->AdditionalSenseCodeQualifier = 0;

                srbStatus |= SRB_STATUS_AUTOSENSE_VALID;
            }

        } else if (errorByte & IDE_ERROR_ID_NOT_FOUND) {

            DebugPrint((1,
                       "IDE: Id not found\n"));
            srbStatus = SRB_STATUS_ERROR;
            scsiStatus = SCSISTAT_CHECK_CONDITION;

            if (Srb->SenseInfoBuffer) {

                PSENSE_DATA  senseBuffer = (PSENSE_DATA)Srb->SenseInfoBuffer;

                senseBuffer->ErrorCode = 0x70;
                senseBuffer->Valid     = 1;
                senseBuffer->AdditionalSenseLength = 0xb;
                senseBuffer->SenseKey =  SCSI_SENSE_MEDIUM_ERROR;
                senseBuffer->AdditionalSenseCode = 0;
                senseBuffer->AdditionalSenseCodeQualifier = 0;

                srbStatus |= SRB_STATUS_AUTOSENSE_VALID;
            }

            deviceExtension->ErrorCount++;

        } else if (errorByte & IDE_ERROR_MEDIA_CHANGE) {

            DebugPrint((1,
                       "IDE: Media change\n"));
            scsiStatus = SCSISTAT_CHECK_CONDITION;
            srbStatus = SRB_STATUS_ERROR;

            if (Srb->SenseInfoBuffer) {

                PSENSE_DATA  senseBuffer = (PSENSE_DATA)Srb->SenseInfoBuffer;

                senseBuffer->ErrorCode = 0x70;
                senseBuffer->Valid     = 1;
                senseBuffer->AdditionalSenseLength = 0xb;
                senseBuffer->SenseKey =  SCSI_SENSE_UNIT_ATTENTION;
                senseBuffer->AdditionalSenseCode = SCSI_ADSENSE_MEDIUM_CHANGED;
                senseBuffer->AdditionalSenseCodeQualifier = 0;

                srbStatus |= SRB_STATUS_AUTOSENSE_VALID;
            }

        } else if (errorByte & IDE_ERROR_DATA_ERROR) {

            DebugPrint((1,
                   "IDE: Data error\n"));
            scsiStatus = SCSISTAT_CHECK_CONDITION;
            srbStatus = SRB_STATUS_ERROR;

            if (!(deviceExtension->DeviceFlags[Srb->TargetId] & DFLAGS_MEDIA_STATUS_ENABLED)){
                deviceExtension->ErrorCount++;
            }

            //
            // Build sense buffer
            //

            if (Srb->SenseInfoBuffer) {

                PSENSE_DATA  senseBuffer = (PSENSE_DATA)Srb->SenseInfoBuffer;

                senseBuffer->ErrorCode = 0x70;
                senseBuffer->Valid     = 1;
                senseBuffer->AdditionalSenseLength = 0xb;
                senseBuffer->SenseKey =  SCSI_SENSE_MEDIUM_ERROR;
                senseBuffer->AdditionalSenseCode = 0;
                senseBuffer->AdditionalSenseCodeQualifier = 0;

                srbStatus |= SRB_STATUS_AUTOSENSE_VALID;
            }
        }

        if ((deviceExtension->ErrorCount >= MAX_ERRORS) &&
            (!(deviceExtension->DeviceFlags[Srb->TargetId] & DFLAGS_USE_DMA))) {
            deviceExtension->DWordIO = FALSE;
            deviceExtension->MaximumBlockXfer[Srb->TargetId] = 0;

            DebugPrint((1,
                        "MapError: Disabling 32-bit PIO and Multi-sector IOs\n"));

            //
            // Log the error.
            //

            ScsiPortLogError( HwDeviceExtension,
                              Srb,
                              Srb->PathId,
                              Srb->TargetId,
                              Srb->Lun,
                              SP_BAD_FW_WARNING,
                              4);
            //
            // Reprogram to not use Multi-sector.
            //

            for (i = 0; i < 4; i++) {
                UCHAR statusByte;

                if (deviceExtension->DeviceFlags[i] & DFLAGS_DEVICE_PRESENT &&
                     !(deviceExtension->DeviceFlags[i] & DFLAGS_ATAPI_DEVICE)) {

                    //
                    // Select the device.
                    //

                    ScsiPortWritePortUchar(&baseIoAddress1->DriveSelect,
                                           (UCHAR)(((i & 0x1) << 4) | 0xA0));

                    //
                    // Setup sector count to reflect the # of blocks.
                    //

                    ScsiPortWritePortUchar(&baseIoAddress1->BlockCount,
                                           0);

                    //
                    // Issue the command.
                    //

                    ScsiPortWritePortUchar(&baseIoAddress1->Command,
                                           IDE_COMMAND_SET_MULTIPLE);

                    //
                    // Wait for busy to drop.
                    //

                    WaitOnBaseBusy(baseIoAddress1,statusByte);

                    //
                    // Check for errors. Reset the value to 0 (disable MultiBlock) if the
                    // command was aborted.
                    //

                    if (statusByte & IDE_STATUS_ERROR) {

                        //
                        // Read the error register.
                        //

                        errorByte = ScsiPortReadPortUchar((PUCHAR)baseIoAddress1 + 1);

                        DebugPrint((1,
                                    "AtapiHwInitialize: Error setting multiple mode. Status %x, error byte %x\n",
                                    statusByte,
                                    errorByte));
                        //
                        // Adjust the devExt. value, if necessary.
                        //

                        deviceExtension->MaximumBlockXfer[i] = 0;

                    }

                    deviceExtension->DeviceParameters[i].IdeReadCommand      = IDE_COMMAND_READ;
                    deviceExtension->DeviceParameters[i].IdeWriteCommand     = IDE_COMMAND_WRITE;
                    deviceExtension->DeviceParameters[i].MaxWordPerInterrupt = 256;
                    deviceExtension->MaximumBlockXfer[i] = 0;
                }
            }
        }
    }


    //
    // Set SCSI status to indicate a check condition.
    //

    Srb->ScsiStatus = scsiStatus;

    return srbStatus;

} // end MapError()


BOOLEAN
AtapiHwInitialize(
    IN PVOID HwDeviceExtension
    )

/*++

Routine Description:

Arguments:

    HwDeviceExtension - HBA miniport driver's adapter data storage

Return Value:

    TRUE - if initialization successful.
    FALSE - if initialization unsuccessful.

--*/

{
    PHW_DEVICE_EXTENSION deviceExtension = HwDeviceExtension;
    PIDE_REGISTERS_1     baseIoAddress;
    ULONG i;
    UCHAR statusByte, errorByte;


    for (i = 0; i < 4; i++) {
        if (deviceExtension->DeviceFlags[i] & DFLAGS_DEVICE_PRESENT) {

            if (!(deviceExtension->DeviceFlags[i] & DFLAGS_ATAPI_DEVICE)) {

                //
                // Enable media status notification
                //

                baseIoAddress = deviceExtension->BaseIoAddress1[i >> 1];

                IdeMediaStatus(TRUE,HwDeviceExtension,i);

                //
                // If supported, setup Multi-block transfers.
                //
                if (deviceExtension->MaximumBlockXfer[i]) {

                    //
                    // Select the device.
                    //

                    ScsiPortWritePortUchar(&baseIoAddress->DriveSelect,
                                           (UCHAR)(((i & 0x1) << 4) | 0xA0));

                    //
                    // Setup sector count to reflect the # of blocks.
                    //

                    ScsiPortWritePortUchar(&baseIoAddress->BlockCount,
                                           deviceExtension->MaximumBlockXfer[i]);

                    //
                    // Issue the command.
                    //

                    ScsiPortWritePortUchar(&baseIoAddress->Command,
                                           IDE_COMMAND_SET_MULTIPLE);

                    //
                    // Wait for busy to drop.
                    //

                    WaitOnBaseBusy(baseIoAddress,statusByte);

                    //
                    // Check for errors. Reset the value to 0 (disable MultiBlock) if the
                    // command was aborted.
                    //

                    if (statusByte & IDE_STATUS_ERROR) {

                        //
                        // Read the error register.
                        //

                        errorByte = ScsiPortReadPortUchar((PUCHAR)baseIoAddress + 1);

                        DebugPrint((1,
                                    "AtapiHwInitialize: Error setting multiple mode. Status %x, error byte %x\n",
                                    statusByte,
                                    errorByte));
                        //
                        // Adjust the devExt. value, if necessary.
                        //

                        deviceExtension->MaximumBlockXfer[i] = 0;

                    } else {
                        DebugPrint((2,
                                    "AtapiHwInitialize: Using Multiblock on Device %d. Blocks / int - %d\n",
                                    i,
                                    deviceExtension->MaximumBlockXfer[i]));
                    }
                }
            } else if (!(deviceExtension->DeviceFlags[i] & DFLAGS_CHANGER_INITED)){

                ULONG j;
                BOOLEAN isSanyo = FALSE;
                UCHAR vendorId[26];

                //
                // Attempt to identify any special-case devices - psuedo-atapi changers, atapi changers, etc.
                //

                for (j = 0; j < 13; j += 2) {

                    //
                    // Build a buffer based on the identify data.
                    //

                    vendorId[j] = ((PUCHAR)deviceExtension->IdentifyData[i].ModelNumber)[j + 1];
                    vendorId[j+1] = ((PUCHAR)deviceExtension->IdentifyData[i].ModelNumber)[j];
                }

                if (!AtapiStringCmp (vendorId, "CD-ROM  CDR", 11)) {

                    //
                    // Inquiry string for older model had a '-', newer is '_'
                    //

                    if (vendorId[12] == 'C') {

                        //
                        // Torisan changer. Set the bit. This will be used in several places
                        // acting like 1) a multi-lun device and 2) building the 'special' TUR's.
                        //

                        deviceExtension->DeviceFlags[i] |= (DFLAGS_CHANGER_INITED | DFLAGS_SANYO_ATAPI_CHANGER);
                        deviceExtension->DiscsPresent[i] = 3;
                        isSanyo = TRUE;
                    }
                }
            }

            //
            // We need to get our device ready for action before
            // returning from this function
            //
            // According to the atapi spec 2.5 or 2.6, an atapi device
            // clears its status BSY bit when it is ready for atapi commands.
            // However, some devices (Panasonic SQ-TC500N) are still
            // not ready even when the status BSY is clear.  They don't react
            // to atapi commands.
            //
            // Since there is really no other indication that tells us
            // the drive is really ready for action.  We are going to check BSY
            // is clear and then just wait for an arbitrary amount of time!
            //
            if (deviceExtension->DeviceFlags[i] & DFLAGS_ATAPI_DEVICE) {
                PIDE_REGISTERS_1     baseIoAddress1 = deviceExtension->BaseIoAddress1[i >> 1];
                PIDE_REGISTERS_2     baseIoAddress2 = deviceExtension->BaseIoAddress2[i >> 1];
                ULONG waitCount;

                // have to get out of the loop sometime!
                // 10000 * 100us = 1000,000us = 1000ms = 1s
                waitCount = 10000;
                GetStatus(baseIoAddress1, statusByte);
                while ((statusByte & IDE_STATUS_BUSY) && waitCount) {
                    //
                    // Wait for Busy to drop.
                    //
                    ScsiPortStallExecution(100);
                    GetStatus(baseIoAddress1, statusByte);
                    waitCount--;
                }

                // 5000 * 100us = 500,000us = 500ms = 0.5s
                waitCount = 5000;
                do {
                    ScsiPortStallExecution(100);
                } while (waitCount--);
            }
        }
    }

    return TRUE;

} // end AtapiHwInitialize()


VOID
AtapiHwInitializeChanger (
    IN PVOID HwDeviceExtension,
    IN ULONG TargetId,
    IN PMECHANICAL_STATUS_INFORMATION_HEADER MechanismStatus)
{
    PHW_DEVICE_EXTENSION deviceExtension = HwDeviceExtension;

    if (MechanismStatus) {
        deviceExtension->DiscsPresent[TargetId] = MechanismStatus->NumberAvailableSlots;
        if (deviceExtension->DiscsPresent[TargetId] > 1) {
            deviceExtension->DeviceFlags[TargetId] |= DFLAGS_ATAPI_CHANGER;
        }
    }
    return;
}



BOOLEAN
FindDevices(
    IN PVOID HwDeviceExtension,
    IN BOOLEAN AtapiOnly,
    IN ULONG   Channel
    )

/*++

Routine Description:

    This routine is called from AtapiFindController to identify
    devices attached to an IDE controller.

Arguments:

    HwDeviceExtension - HBA miniport driver's adapter data storage
    AtapiOnly - Indicates that routine should return TRUE only if
        an ATAPI device is attached to the controller.

Return Value:

    TRUE - True if devices found.

--*/

{
    PHW_DEVICE_EXTENSION deviceExtension = HwDeviceExtension;
    PIDE_REGISTERS_1     baseIoAddress1 = deviceExtension->BaseIoAddress1[Channel];
    PIDE_REGISTERS_2     baseIoAddress2 = deviceExtension->BaseIoAddress2[Channel];
    BOOLEAN              deviceResponded = FALSE,
                         skipSetParameters = FALSE;
    ULONG                waitCount = 10000;
    ULONG                deviceNumber;
    ULONG                i;
    UCHAR                signatureLow,
                         signatureHigh;
    UCHAR                statusByte;

    DebugPrintTickCount();

    //
    // Clear expecting interrupt flag and current SRB field.
    //

    deviceExtension->ExpectingInterrupt = FALSE;
    deviceExtension->CurrentSrb = NULL;

    // We are about to talk to our devices before our interrupt handler is installed
    // If our device uses sharable level sensitive interrupt, we may assert too
    // many bogus interrupts
    // Turn off device interrupt here
    for (deviceNumber = 0; deviceNumber < 2; deviceNumber++) {
        ScsiPortWritePortUchar(&baseIoAddress1->DriveSelect,
                               (UCHAR)((deviceNumber << 4) | 0xA0));
        ScsiPortWritePortUchar(&baseIoAddress2->DeviceControl, IDE_DC_DISABLE_INTERRUPTS);
    }

    //
    // Search for devices.
    //

    for (deviceNumber = 0; deviceNumber < 2; deviceNumber++) {

        //
        // Select the device.
        //

        ScsiPortWritePortUchar(&baseIoAddress1->DriveSelect,
                               (UCHAR)((deviceNumber << 4) | 0xA0));

        //
        // Check here for some SCSI adapters that incorporate IDE emulation.
        //

        GetStatus(baseIoAddress1, statusByte);
        if (statusByte == 0xFF) {
            continue;
        }

        DebugPrintTickCount();

        AtapiSoftReset(baseIoAddress1,deviceNumber, TRUE);

        DebugPrintTickCount();

        WaitOnBusy(baseIoAddress1,statusByte);

        DebugPrintTickCount();

        signatureLow = ScsiPortReadPortUchar(&baseIoAddress1->CylinderLow);
        signatureHigh = ScsiPortReadPortUchar(&baseIoAddress1->CylinderHigh);

        if (signatureLow == 0x14 && signatureHigh == 0xEB) {

            //
            // ATAPI signature found.
            // Issue the ATAPI identify command if this
            // is not for the crash dump utility.
            //

atapiIssueId:

            if (!deviceExtension->DriverMustPoll) {

                //
                // Issue ATAPI packet identify command.
                //

                if (IssueIdentify(HwDeviceExtension,
                                  deviceNumber,
                                  Channel,
                                  IDE_COMMAND_ATAPI_IDENTIFY,
                                  TRUE)) {

                    //
                    // Indicate ATAPI device.
                    //

                    DebugPrint((1,
                               "FindDevices: Device %x is ATAPI\n",
                               deviceNumber));

                    deviceExtension->DeviceFlags[deviceNumber + (Channel * 2)] |= DFLAGS_ATAPI_DEVICE;
                    deviceExtension->DeviceFlags[deviceNumber + (Channel * 2)] |= DFLAGS_DEVICE_PRESENT;

                    deviceResponded = TRUE;

                    GetStatus(baseIoAddress1, statusByte);
                    if (statusByte & IDE_STATUS_ERROR) {
                        AtapiSoftReset(baseIoAddress1, deviceNumber, TRUE);
                    }


                } else {

                    //
                    // Indicate no working device.
                    //

                    DebugPrint((1,
                               "FindDevices: Device %x not responding\n",
                               deviceNumber));

                    deviceExtension->DeviceFlags[deviceNumber + (Channel * 2)] &= ~DFLAGS_DEVICE_PRESENT;
                }

            }

        } else {

            //
            // Issue IDE Identify. If an Atapi device is actually present, the signature
            // will be asserted, and the drive will be recognized as such.
            //

            if (IssueIdentify(HwDeviceExtension,
                              deviceNumber,
                              Channel,
                              IDE_COMMAND_IDENTIFY,
                              TRUE)) {

                //
                // IDE drive found.
                //


                DebugPrint((1,
                           "FindDevices: Device %x is IDE\n",
                           deviceNumber));

                deviceExtension->DeviceFlags[deviceNumber + (Channel * 2)] |= DFLAGS_DEVICE_PRESENT;

                if (!AtapiOnly) {
                    deviceResponded = TRUE;
                }

                //
                // Indicate IDE - not ATAPI device.
                //

                deviceExtension->DeviceFlags[deviceNumber + (Channel * 2)] &= ~DFLAGS_ATAPI_DEVICE;


            } else {

                //
                // Look to see if an Atapi device is present.
                //

                AtapiSoftReset(baseIoAddress1, deviceNumber, TRUE);

                WaitOnBusy(baseIoAddress1,statusByte);

                signatureLow = ScsiPortReadPortUchar(&baseIoAddress1->CylinderLow);
                signatureHigh = ScsiPortReadPortUchar(&baseIoAddress1->CylinderHigh);

                if (signatureLow == 0x14 && signatureHigh == 0xEB) {
                    goto atapiIssueId;
                }
            }
        }

#if DBG
        if (deviceExtension->DeviceFlags[deviceNumber + (Channel * 2)] & DFLAGS_DEVICE_PRESENT) {
            {

                UCHAR string[41];

                for (i=0; i<8; i+=2) {
                    string[i] = deviceExtension->IdentifyData[Channel * MAX_CHANNEL + deviceNumber].FirmwareRevision[i + 1];
                    string[i + 1] = deviceExtension->IdentifyData[Channel * MAX_CHANNEL + deviceNumber].FirmwareRevision[i];
                }
                string[i] = 0;
                DebugPrint((1, "FindDevices: firmware version: %s\n", string));


                for (i=0; i<40; i+=2) {
                    string[i] = deviceExtension->IdentifyData[Channel * MAX_CHANNEL + deviceNumber].ModelNumber[i + 1];
                    string[i + 1] = deviceExtension->IdentifyData[Channel * MAX_CHANNEL + deviceNumber].ModelNumber[i];
                }
                string[i] = 0;
                DebugPrint((1, "FindDevices: model number: %s\n", string));
            }
        }
#endif
    }

    for (i = 0; i < 2; i++) {
        if ((deviceExtension->DeviceFlags[i + (Channel * 2)] & DFLAGS_DEVICE_PRESENT) &&
            (!(deviceExtension->DeviceFlags[i + (Channel * 2)] & DFLAGS_ATAPI_DEVICE)) && deviceResponded) {

            //
            // This hideous hack is to deal with ESDI devices that return
            // garbage geometry in the IDENTIFY data.
            // This is ONLY for the crashdump environment as
            // these are ESDI devices.
            //

            if (deviceExtension->IdentifyData[i].SectorsPerTrack ==
                    0x35 &&
                deviceExtension->IdentifyData[i].NumberOfHeads ==
                    0x07) {

                DebugPrint((1,
                           "FindDevices: Found nasty Compaq ESDI!\n"));

                //
                // Change these values to something reasonable.
                //

                deviceExtension->IdentifyData[i].SectorsPerTrack =
                    0x34;
                deviceExtension->IdentifyData[i].NumberOfHeads =
                    0x0E;
            }

            if (deviceExtension->IdentifyData[i].SectorsPerTrack ==
                    0x35 &&
                deviceExtension->IdentifyData[i].NumberOfHeads ==
                    0x0F) {

                DebugPrint((1,
                           "FindDevices: Found nasty Compaq ESDI!\n"));

                //
                // Change these values to something reasonable.
                //

                deviceExtension->IdentifyData[i].SectorsPerTrack =
                    0x34;
                deviceExtension->IdentifyData[i].NumberOfHeads =
                    0x0F;
            }


            if (deviceExtension->IdentifyData[i].SectorsPerTrack ==
                    0x36 &&
                deviceExtension->IdentifyData[i].NumberOfHeads ==
                    0x07) {

                DebugPrint((1,
                           "FindDevices: Found nasty UltraStor ESDI!\n"));

                //
                // Change these values to something reasonable.
                //

                deviceExtension->IdentifyData[i].SectorsPerTrack =
                    0x3F;
                deviceExtension->IdentifyData[i].NumberOfHeads =
                    0x10;
                skipSetParameters = TRUE;
            }


            if (!skipSetParameters) {

                //
                // Select the device.
                //

                ScsiPortWritePortUchar(&baseIoAddress1->DriveSelect,
                                       (UCHAR)((i << 4) | 0xA0));

                WaitOnBusy(baseIoAddress1,statusByte);

                if (statusByte & IDE_STATUS_ERROR) {

                    //
                    // Reset the device.
                    //

                    DebugPrint((2,
                                "FindDevices: Resetting controller before SetDriveParameters.\n"));

                    ScsiPortWritePortUchar(&baseIoAddress2->DeviceControl,IDE_DC_RESET_CONTROLLER | IDE_DC_DISABLE_INTERRUPTS);
                    ScsiPortStallExecution(500 * 1000);
                    ScsiPortWritePortUchar(&baseIoAddress2->DeviceControl, IDE_DC_DISABLE_INTERRUPTS);
                    ScsiPortWritePortUchar(&baseIoAddress1->DriveSelect,
                                           (UCHAR)((i << 4) | 0xA0));

                    do {

                        //
                        // Wait for Busy to drop.
                        //

                        ScsiPortStallExecution(100);
                        GetStatus(baseIoAddress1, statusByte);

                    } while ((statusByte & IDE_STATUS_BUSY) && waitCount--);
                }

                WaitOnBusy(baseIoAddress1,statusByte);
                DebugPrint((2,
                            "FindDevices: Status before SetDriveParameters: (%x) (%x)\n",
                            statusByte,
                            ScsiPortReadPortUchar(&baseIoAddress1->DriveSelect)));

                //
                // Use the IDENTIFY data to set drive parameters.
                //

                if (!SetDriveParameters(HwDeviceExtension,i,Channel)) {

                    DebugPrint((0,
                               "AtapHwInitialize: Set drive parameters for device %d failed\n",
                               i));

                    //
                    // Don't use this device as writes could cause corruption.
                    //

                    deviceExtension->DeviceFlags[i + Channel] = 0;
                    continue;

                }
                if (deviceExtension->DeviceFlags[deviceNumber + (Channel * 2)] & DFLAGS_REMOVABLE_DRIVE) {

                    //
                    // Pick up ALL IDE removable drives that conform to Yosemite V0.2...
                    //

                    AtapiOnly = FALSE;
                }


                //
                // Indicate that a device was found.
                //

                if (!AtapiOnly) {
                    deviceResponded = TRUE;
                }
            }
        }
    }

    //
    // Make sure master device is selected on exit.
    //

    ScsiPortWritePortUchar(&baseIoAddress1->DriveSelect, 0xA0);

    //
    // Reset the controller. This is a feeble attempt to leave the ESDI
    // controllers in a state that ATDISK driver will recognize them.
    // The problem in ATDISK has to do with timings as it is not reproducible
    // in debug. The reset should restore the controller to its poweron state
    // and give the system enough time to settle.
    //

    if (!deviceResponded) {

        ScsiPortWritePortUchar(&baseIoAddress2->DeviceControl,IDE_DC_RESET_CONTROLLER | IDE_DC_DISABLE_INTERRUPTS);
        ScsiPortStallExecution(50 * 1000);
        ScsiPortWritePortUchar(&baseIoAddress2->DeviceControl,IDE_DC_REENABLE_CONTROLLER);
    }

    // Turn device interrupt back on
    for (deviceNumber = 0; deviceNumber < 2; deviceNumber++) {
        ScsiPortWritePortUchar(&baseIoAddress1->DriveSelect,
                               (UCHAR)((deviceNumber << 4) | 0xA0));
        // Clear any pending interrupts
        GetStatus(baseIoAddress1, statusByte);
        ScsiPortWritePortUchar(&baseIoAddress2->DeviceControl, IDE_DC_REENABLE_CONTROLLER);
    }

    DebugPrintTickCount();

    return deviceResponded;

} // end FindDevices()


ULONG
AtapiParseArgumentString(
    IN PCHAR String,
    IN PCHAR KeyWord
    )

/*++

Routine Description:

    This routine will parse the string for a match on the keyword, then
    calculate the value for the keyword and return it to the caller.

Arguments:

    String - The ASCII string to parse.
    KeyWord - The keyword for the value desired.

Return Values:

    Zero if value not found
    Value converted from ASCII to binary.

--*/

{
    PCHAR cptr;
    PCHAR kptr;
    ULONG value;
    ULONG stringLength = 0;
    ULONG keyWordLength = 0;
    ULONG index;

    if (!String) {
        return 0;
    }
    if (!KeyWord) {
        return 0;
    }

    //
    // Calculate the string length and lower case all characters.
    //

    cptr = String;
    while (*cptr) {
        if (*cptr >= 'A' && *cptr <= 'Z') {
            *cptr = *cptr + ('a' - 'A');
        }
        cptr++;
        stringLength++;
    }

    //
    // Calculate the keyword length and lower case all characters.
    //

    cptr = KeyWord;
    while (*cptr) {

        if (*cptr >= 'A' && *cptr <= 'Z') {
            *cptr = *cptr + ('a' - 'A');
        }
        cptr++;
        keyWordLength++;
    }

    if (keyWordLength > stringLength) {

        //
        // Can't possibly have a match.
        //

        return 0;
    }

    //
    // Now setup and start the compare.
    //

    cptr = String;

ContinueSearch:

    //
    // The input string may start with white space.  Skip it.
    //

    while (*cptr == ' ' || *cptr == '\t') {
        cptr++;
    }

    if (*cptr == '\0') {

        //
        // end of string.
        //

        return 0;
    }

    kptr = KeyWord;
    while (*cptr++ == *kptr++) {

        if (*(cptr - 1) == '\0') {

            //
            // end of string
            //

            return 0;
        }
    }

    if (*(kptr - 1) == '\0') {

        //
        // May have a match backup and check for blank or equals.
        //

        cptr--;
        while (*cptr == ' ' || *cptr == '\t') {
            cptr++;
        }

        //
        // Found a match.  Make sure there is an equals.
        //

        if (*cptr != '=') {

            //
            // Not a match so move to the next semicolon.
            //

            while (*cptr) {
                if (*cptr++ == ';') {
                    goto ContinueSearch;
                }
            }
            return 0;
        }

        //
        // Skip the equals sign.
        //

        cptr++;

        //
        // Skip white space.
        //

        while ((*cptr == ' ') || (*cptr == '\t')) {
            cptr++;
        }

        if (*cptr == '\0') {

            //
            // Early end of string, return not found
            //

            return 0;
        }

        if (*cptr == ';') {

            //
            // This isn't it either.
            //

            cptr++;
            goto ContinueSearch;
        }

        value = 0;
        if ((*cptr == '0') && (*(cptr + 1) == 'x')) {

            //
            // Value is in Hex.  Skip the "0x"
            //

            cptr += 2;
            for (index = 0; *(cptr + index); index++) {

                if (*(cptr + index) == ' ' ||
                    *(cptr + index) == '\t' ||
                    *(cptr + index) == ';') {
                     break;
                }

                if ((*(cptr + index) >= '0') && (*(cptr + index) <= '9')) {
                    value = (16 * value) + (*(cptr + index) - '0');
                } else {
                    if ((*(cptr + index) >= 'a') && (*(cptr + index) <= 'f')) {
                        value = (16 * value) + (*(cptr + index) - 'a' + 10);
                    } else {

                        //
                        // Syntax error, return not found.
                        //
                        return 0;
                    }
                }
            }
        } else {

            //
            // Value is in Decimal.
            //

            for (index = 0; *(cptr + index); index++) {

                if (*(cptr + index) == ' ' ||
                    *(cptr + index) == '\t' ||
                    *(cptr + index) == ';') {
                     break;
                }

                if ((*(cptr + index) >= '0') && (*(cptr + index) <= '9')) {
                    value = (10 * value) + (*(cptr + index) - '0');
                } else {

                    //
                    // Syntax error return not found.
                    //
                    return 0;
                }
            }
        }

        return value;
    } else {

        //
        // Not a match check for ';' to continue search.
        //

        while (*cptr) {
            if (*cptr++ == ';') {
                goto ContinueSearch;
            }
        }

        return 0;
    }
}



BOOLEAN
AtapiAllocateIoBase (
    IN PVOID HwDeviceExtension,
    IN PCHAR ArgumentString,
    IN OUT PPORT_CONFIGURATION_INFORMATION ConfigInfo,
    IN OUT PFIND_STATE FindState,
    OUT PIDE_REGISTERS_1 CmdLogicalBasePort[2],
    OUT PIDE_REGISTERS_2 CtrlLogicalBasePort[2],
    OUT PIDE_BUS_MASTER_REGISTERS BmLogicalBasePort[2],
    OUT ULONG *NumIdeChannel,
    OUT PBOOLEAN PreConfig
)
/*++

Routine Description:

    Return ide controller io addresses for device detection

    This function populate these PORT_CONFIGURATION_INFORMATION
    entries

        1st ACCESS_RANGE - first channel command block register base
        2nd ACCESS_RANGE - first channel control block register base
        3rd ACCESS_RANGE - second channel command block register base
        4th ACCESS_RANGE - second channel control block register base
        5th ACCESS_RANGE - first channel bus master register base
        6th ACCESS_RANGE - second channel bus master register base

        InterruptMode           - first channel interrupt mode
        BusInterruptLevel       - first channel interrupt level
        InterruptMode2          - second channel interrupt mode
        BusInterruptLevel2      - second channel interrupt level
        AdapterInterfaceType
        AtdiskPrimaryClaimed
        AtdiskSecondaryClaimed


Arguments:

    HwDeviceExtension   - HBA miniport driver's adapter data storage
    ArgumentString      - registry user arugment
    ConfigInfo          = Scsi Port Config. Structure
    FindState           - Keep track of what addresses has been returned
    CmdLogicalBasePort  - command block register logical base address
    CtrlLogicalBasePort - control block register logical base address
    BmLogicalBasePort   - bus master register logical base address
    NumIdeChannel       - number of IDE channel base address returned
    PreConfig           - the reutrned address is user configured

Return Value:

    TRUE  - io address is returned.
    FASLE - no more io address to return.


--*/
{
    PHW_DEVICE_EXTENSION deviceExtension = HwDeviceExtension;

    ULONG cmdBasePort[2]                 = {0, 0};
    ULONG ctrlBasePort[2]                = {0, 0};
    ULONG bmBasePort[2]                  = {0, 0};
    BOOLEAN getDeviceBaseFailed;


    CmdLogicalBasePort[0]   = 0;
    CmdLogicalBasePort[1]   = 0;
    CtrlLogicalBasePort[0]  = 0;
    CtrlLogicalBasePort[1]  = 0;
    BmLogicalBasePort[0]    = 0;
    BmLogicalBasePort[1]    = 0;
    *PreConfig              = FALSE;

    //
    // check for pre-config controller (pcmcia)
    //
    cmdBasePort[0] = ScsiPortConvertPhysicalAddressToUlong((*ConfigInfo->AccessRanges)[0].RangeStart);
    ctrlBasePort[0] = ScsiPortConvertPhysicalAddressToUlong((*ConfigInfo->AccessRanges)[1].RangeStart);
    if (cmdBasePort[0] != 0) {
        *PreConfig      = TRUE;
        *NumIdeChannel  = 1;

        if (!ctrlBasePort[0]) {
            //
            // The pre-config init is really made for pcmcia ata disk
            // When we get pre-config data, both io access ranges are lumped together
            // the command registers are mapped to the first 7 address locations, and
            // the control registers are mapped to the 0xE th location
            //
            ctrlBasePort[0] = cmdBasePort[0] + 0xe;
        }

        DebugPrint ((2, "AtapiAllocateIoBase: found pre-config pcmcia controller\n"));
    }

    //
    // check for user defined controller (made for IBM Caroline ppc)
    //
    if ((cmdBasePort[0] == 0) && ArgumentString) {

        ULONG irq;

        irq            = AtapiParseArgumentString(ArgumentString, "Interrupt");
        cmdBasePort[0] = AtapiParseArgumentString(ArgumentString, "BaseAddress");
        if (irq && cmdBasePort[0]) {

            *NumIdeChannel = 1;

            // the control register offset is implied!!
            ctrlBasePort[0] = cmdBasePort[0] + 0x206;

            ConfigInfo->InterruptMode = Latched;
            ConfigInfo->BusInterruptLevel = irq;

            DebugPrint ((2, "AtapiAllocateIoBase: found user config controller\n"));
        }
    }

    //
    // PCI controller
    //
    if (cmdBasePort[0] == 0 &&
        (ConfigInfo->AdapterInterfaceType == Isa)) {

        PCI_SLOT_NUMBER     pciSlot;
        PUCHAR              vendorStrPtr;
        PUCHAR              deviceStrPtr;
        UCHAR               vendorString[5];
        UCHAR               deviceString[5];

        ULONG               pciBusNumber;
        ULONG               slotNumber;
        ULONG               logicalDeviceNumber;
        ULONG               ideChannel;
        PCI_COMMON_CONFIG   pciData;
        ULONG               cIndex;
        UCHAR               bmStatus;
        BOOLEAN             foundController;

        pciBusNumber        = FindState->BusNumber;
        slotNumber          = FindState->SlotNumber;
        logicalDeviceNumber = FindState->LogicalDeviceNumber;
        ideChannel          = FindState->IdeChannel;
        foundController     = FALSE;
        *NumIdeChannel      = 1;

        for (;pciBusNumber < 256 && !(cmdBasePort[0]); pciBusNumber++, slotNumber=logicalDeviceNumber=0) {
            pciSlot.u.AsULONG = 0;

            for (;slotNumber < PCI_MAX_DEVICES && !(cmdBasePort[0]); slotNumber++, logicalDeviceNumber=0) {
                pciSlot.u.bits.DeviceNumber = slotNumber;

                for (;logicalDeviceNumber < PCI_MAX_FUNCTION && !(cmdBasePort[0]); logicalDeviceNumber++, ideChannel=0) {

                    pciSlot.u.bits.FunctionNumber = logicalDeviceNumber;

                    for (;ideChannel < MAX_CHANNEL && !(cmdBasePort[0]); ideChannel++) {

                        if (!GetPciBusData(HwDeviceExtension,
                                                pciBusNumber,
                                                pciSlot,
                                                &pciData,
                                                offsetof (PCI_COMMON_CONFIG, DeviceSpecific))) {
                            break;
                        }

                        if (pciData.VendorID == PCI_INVALID_VENDORID) {
                            break;
                        }

                        //
                        // Translate hex ids to strings.
                        //
                        vendorStrPtr = vendorString;
                        deviceStrPtr = deviceString;
                        AtapiHexToString(pciData.VendorID, &vendorStrPtr);
                        AtapiHexToString(pciData.DeviceID, &deviceStrPtr);

                        DebugPrint((2,
                                   "AtapiAllocateIoBase: Bus %x Slot %x Function %x Vendor %s Product %s\n",
                                   pciBusNumber,
                                   slotNumber,
                                   logicalDeviceNumber,
                                   vendorString,
                                   deviceString));

                        //
                        // Search for controller we know about
                        //
                        ConfigInfo->AdapterInterfaceType = Isa;
                        foundController = FALSE;
                        *NumIdeChannel = 1;
                        for (cIndex = 0; cIndex < NUMBER_OF_PCI_CONTROLLER; cIndex++) {

                            if ((!AtapiStringCmp(vendorString,
                                        FindState->ControllerParameters[cIndex].VendorId,
                                        FindState->ControllerParameters[cIndex].VendorIdLength) &&
                                 !AtapiStringCmp(deviceString,
                                        FindState->ControllerParameters[cIndex].DeviceId,
                                        FindState->ControllerParameters[cIndex].DeviceIdLength))) {

                                foundController = TRUE;
                                deviceExtension->BMTimingControl = FindState->ControllerParameters[cIndex].TimingControl;
                                deviceExtension->IsChannelEnabled = FindState->ControllerParameters[cIndex].IsChannelEnabled;

                                if (FindState->ControllerParameters[cIndex].SingleFIFO) {
                                    DebugPrint ((0, "AtapiAllocateIoBase: hardcoded single FIFO pci controller\n"));
                                    *NumIdeChannel = 2;
                                }
                                break;
                            }
                        }

                        //
                        // Look for generic IDE controller
                        //
                        if (cIndex >= NUMBER_OF_PCI_CONTROLLER) {
                           if (pciData.BaseClass == 0x1) { // Mass Storage Device
                               if (pciData.SubClass == 0x1) { // IDE Controller

                                    DebugPrint ((0, "AtapiAllocateIoBase: found an unknown pci ide controller\n"));
                                    deviceExtension->BMTimingControl = NULL;
                                    deviceExtension->IsChannelEnabled = ChannelIsAlwaysEnabled;
                                    foundController = TRUE;
                                }
                            }
                        }

                        if (foundController) {

                            DebugPrint ((2, "AtapiAllocateIoBase: found pci ide controller 0x%4x 0x%4x\n", pciData.VendorID, pciData.DeviceID));

                            GetPciBusData(HwDeviceExtension,
                                          pciBusNumber,
                                          pciSlot,
                                          &pciData,
                                          sizeof (PCI_COMMON_CONFIG));

                            //
                            // Record pci device location
                            //
                            deviceExtension->PciBusNumber    = pciBusNumber;
                            deviceExtension->PciDeviceNumber = slotNumber;
                            deviceExtension->PciLogDevNumber = logicalDeviceNumber;

#if defined (DBG)
                            {
                                ULONG i, j;

                                DebugPrint ((2, "AtapiAllocateIoBase: PCI Configuration Data\n"));
                                for (i=0; i<sizeof(PCI_COMMON_CONFIG); i+=16) {
                                    DebugPrint ((2, "AtapiAllocateIoBase: "));
                                    for (j=0; j<16; j++) {
                                        if ((i + j) < sizeof(PCI_COMMON_CONFIG)) {
                                            DebugPrint ((2, "%02x ", ((PUCHAR)&pciData)[i + j]));
                                        } else {
                                            break;
                                        }
                                    }
                                    DebugPrint ((2, "\n"));
                                }
                            }
#endif //DBG

                            if (!AtapiPlaySafe) {
                                //
                                // Try to turn on the bus master bit in PCI space if it is not already on
                                //
                                if ((pciData.Command & PCI_ENABLE_BUS_MASTER) == 0) {

                                    DebugPrint ((0, "ATAPI: Turning on PCI Bus Master bit\n"));

                                    pciData.Command |= PCI_ENABLE_BUS_MASTER;

                                    SetPciBusData (HwDeviceExtension,
                                                   pciBusNumber,
                                                   pciSlot,
                                                   &pciData.Command,
                                                   offsetof (PCI_COMMON_CONFIG, Command),
                                                   sizeof(pciData.Command));

                                    GetPciBusData(HwDeviceExtension,
                                                  pciBusNumber,
                                                  pciSlot,
                                                  &pciData,
                                                  offsetof (PCI_COMMON_CONFIG, DeviceSpecific)
                                                  );

                                    if (pciData.Command & PCI_ENABLE_BUS_MASTER) {
                                        DebugPrint ((0, "ATAPI: If we play safe, we would NOT detect this IDE controller is busmaster capable\n"));
                                    }
                                }
                            }

                            //
                            // Check to see if the controller is bus master capable
                            //
                            bmStatus = 0;
                            if ((pciData.Command & PCI_ENABLE_BUS_MASTER) &&
                                (pciData.ProgIf & 0x80) &&
                                deviceExtension->UseBusMasterController) {

                                PIDE_BUS_MASTER_REGISTERS bmLogicalBasePort;

                                bmBasePort[0] = pciData.u.type0.BaseAddresses[4] & 0xfffffffc;
                                if ((bmBasePort[0] != 0) && (bmBasePort[0] != 0xffffffff)) {

                                    bmLogicalBasePort = (PIDE_BUS_MASTER_REGISTERS) ScsiPortGetDeviceBase(HwDeviceExtension,
                                                            ConfigInfo->AdapterInterfaceType,
                                                            ConfigInfo->SystemIoBusNumber,
                                                            ScsiPortConvertUlongToPhysicalAddress(bmBasePort[0]),
                                                            8,
                                                            TRUE);

                                    if (bmLogicalBasePort) {

                                        // Some controller (ALi M5219) doesn't implement the readonly simplex bit
                                        // We will try to clear it.  If it works, we will assume simplex bit
                                        // is not set
                                        bmStatus = ScsiPortReadPortUchar(&bmLogicalBasePort->Status);
                                        ScsiPortWritePortUchar(&bmLogicalBasePort->Status, (UCHAR) (bmStatus & ~BUSMASTER_DMA_SIMPLEX_BIT));


                                        bmStatus = ScsiPortReadPortUchar(&bmLogicalBasePort->Status);
                                        ScsiPortFreeDeviceBase(HwDeviceExtension, bmLogicalBasePort);

                                        DebugPrint ((2, "AtapiAllocateIoBase: controller is capable of bus mastering\n"));
                                    } else {
                                        bmBasePort[0] = 0;
                                        DebugPrint ((2, "AtapiAllocateIoBase: controller is NOT capable of bus mastering\n"));
                                    }
                                } else {
                                    bmBasePort[0] = 0;
                                    DebugPrint ((2, "AtapiAllocateIoBase: controller is NOT capable of bus mastering\n"));
                                }

                            } else {
                                bmBasePort[0] = 0;
                                DebugPrint ((2, "AtapiAllocateIoBase: controller is NOT capable of bus mastering\n"));
                            }

                            if (bmStatus & BUSMASTER_DMA_SIMPLEX_BIT) {
                                DebugPrint ((0, "AtapiAllocateIoBase: simplex bit is set.  single FIFO pci controller\n"));
                                *NumIdeChannel = 2;
                            }

                            if (*NumIdeChannel == 2) {
                                if (!((*deviceExtension->IsChannelEnabled) (&pciData,
                                                                            0) &&
                                     (*deviceExtension->IsChannelEnabled) (&pciData,
                                                                           0))) {
                                    //
                                    // if we have a single FIFO controller, but one of the channels
                                    // is not turned on.  We don't need to sync. access the both channels
                                    // We can pretend we have a single channel controller
                                    //
                                    *NumIdeChannel = 1;
                                }
                            }

                            //
                            //  figure out what io address the controller is using
                            //  If it is in native mode, get the address out of the PCI
                            //  config space.  If it is in legacy mode, it will be hard
                            //  wired to use standard primary (0x1f0) or secondary
                            //  (0x170) channel addresses
                            //
                            if (ideChannel == 0) {

                                if ((*deviceExtension->IsChannelEnabled) (&pciData,
                                                                          ideChannel)) {

                                    //
                                    // check to see if the controller has a single FIFO for both
                                    // IDE channel
                                    //
                                    if (bmStatus & BUSMASTER_DMA_SIMPLEX_BIT) {
                                        DebugPrint ((0, "AtapiAllocateIoBase: simplex bit is set.  single FIFO pci controller\n"));
                                        *NumIdeChannel = 2;
                                    }

                                    if ((pciData.ProgIf & 0x3) == 0x3 || (pciData.VendorID == 0x105A)) {
                                       
                                        // Native Mode
                                        cmdBasePort[0]  = pciData.u.type0.BaseAddresses[0] & 0xfffffffc;
                                        ctrlBasePort[0] = (pciData.u.type0.BaseAddresses[1] & 0xfffffffc) + 2;

                                        ConfigInfo->InterruptMode = LevelSensitive;
                                        ConfigInfo->BusInterruptVector    =
                                            ConfigInfo->BusInterruptLevel = pciData.u.type0.InterruptLine;
                                        ConfigInfo->AdapterInterfaceType = PCIBus;

                                    } else {
                                        // Legacy Mode
                                        cmdBasePort[0]  = 0x1f0;
                                        ctrlBasePort[0] = 0x1f0 + 0x206;

                                        ConfigInfo->InterruptMode       = Latched;
                                        ConfigInfo->BusInterruptLevel = 14;
                                    }
                                }
                                if (*NumIdeChannel == 2) {

                                    // grab both channels
                                    ideChannel++;

                                    if ((*deviceExtension->IsChannelEnabled) (&pciData,
                                                                              ideChannel)) {

                                        if (bmBasePort[0]) {
                                            bmBasePort[1] = bmBasePort[0] + 8;
                                        }

                                        if ((pciData.ProgIf & 0xc) == 0xc || (pciData.VendorID == 0x105A)) {
                                           
                                            // Native Mode
                                            cmdBasePort[1]  = pciData.u.type0.BaseAddresses[2] & 0xfffffffc;
                                            ctrlBasePort[1] = (pciData.u.type0.BaseAddresses[3] & 0xfffffffc) + 2;
                                        } else {
                                            // Legacy Mode
                                            cmdBasePort[1]  = 0x170;
                                            ctrlBasePort[1] = 0x170 + 0x206;

                                            ConfigInfo->InterruptMode2     = Latched;
                                            ConfigInfo->BusInterruptLevel2 = 15;
                                        }
                                    }
                                }
                            } else if (ideChannel == 1) {

                                if ((*deviceExtension->IsChannelEnabled) (&pciData,
                                                                          ideChannel)) {

                                    if (bmBasePort[0]) {
                                        bmBasePort[0] += 8;
                                    }

                                    if ((pciData.ProgIf & 0xc) == 0xc || (pciData.VendorID == 0x105A)) {

                                       if (pciData.VendorID == 0x105A) {

                                          DebugPrint((0, "Setting Native Mode on Promise controller"));

                                       }

                                        // Native Mode
                                        cmdBasePort[0]  = pciData.u.type0.BaseAddresses[2] & 0xfffffffc;
                                        ctrlBasePort[0] = (pciData.u.type0.BaseAddresses[3] & 0xfffffffc) + 2;

                                        ConfigInfo->InterruptMode = LevelSensitive;
                                        ConfigInfo->BusInterruptVector    =
                                            ConfigInfo->BusInterruptLevel = pciData.u.type0.InterruptLine;
                                        ConfigInfo->AdapterInterfaceType = PCIBus;

                                    } else {
                                        // Legacy Mode
                                        cmdBasePort[0]  = 0x170;
                                        ctrlBasePort[0] = 0x170 + 0x206;

                                        ConfigInfo->InterruptMode       = Latched;
                                        ConfigInfo->BusInterruptLevel   = 15;
                                    }
                                }
                            }
                        } else {
                            ideChannel = MAX_CHANNEL;
                        }
                        if (cmdBasePort[0])
                            break;
                    }
                    if (cmdBasePort[0])
                        break;
                }
                if (cmdBasePort[0])
                    break;
            }
            if (cmdBasePort[0])
                break;
        }
        FindState->BusNumber           = pciBusNumber;
        FindState->SlotNumber          = slotNumber;
        FindState->LogicalDeviceNumber = logicalDeviceNumber;
        FindState->IdeChannel          = ideChannel + 1;
    }

    //
    // look for legacy controller
    //
    if (cmdBasePort[0] == 0) {
        ULONG i;

        for (i = 0; FindState->DefaultIoPort[i]; i++) {
            if (FindState->IoAddressUsed[i] != TRUE) {

                *NumIdeChannel = 1;
                cmdBasePort[0]  = FindState->DefaultIoPort[i];
                ctrlBasePort[0] = FindState->DefaultIoPort[i] + 0x206;
                bmBasePort[0]   = 0;

                ConfigInfo->InterruptMode     = Latched;
                ConfigInfo->BusInterruptLevel = FindState->DefaultInterrupt[i];
                break;
            }
        }
    }

    if (cmdBasePort[0]) {
        ULONG i;

        // Mark io addresses used
        for (i = 0; FindState->DefaultIoPort[i]; i++) {
            if (FindState->DefaultIoPort[i] == cmdBasePort[0]) {
                FindState->IoAddressUsed[i] = TRUE;
            }
            if (FindState->DefaultIoPort[i] == cmdBasePort[1]) {
                FindState->IoAddressUsed[i] = TRUE;
            }
        }


        if (cmdBasePort[0] == 0x1f0) {
            ConfigInfo->AtdiskPrimaryClaimed = TRUE;
            deviceExtension->PrimaryAddress = TRUE;
        } else if (cmdBasePort[0] == 0x170) {
            ConfigInfo->AtdiskSecondaryClaimed = TRUE;
            deviceExtension->PrimaryAddress = FALSE;
        }

        if (cmdBasePort[1] == 0x1f0) {
            ConfigInfo->AtdiskPrimaryClaimed = TRUE;
        } else if (cmdBasePort[1] == 0x170) {
            ConfigInfo->AtdiskSecondaryClaimed = TRUE;
        }

        if (*PreConfig == FALSE) {

            (*ConfigInfo->AccessRanges)[0].RangeStart    = ScsiPortConvertUlongToPhysicalAddress(cmdBasePort[0]);
            (*ConfigInfo->AccessRanges)[0].RangeLength   = 8;
            (*ConfigInfo->AccessRanges)[0].RangeInMemory = FALSE;

            (*ConfigInfo->AccessRanges)[1].RangeStart    = ScsiPortConvertUlongToPhysicalAddress(ctrlBasePort[0]);
            (*ConfigInfo->AccessRanges)[1].RangeLength   = 1;
            (*ConfigInfo->AccessRanges)[1].RangeInMemory = FALSE;

            if (cmdBasePort[1]) {
                (*ConfigInfo->AccessRanges)[2].RangeStart    = ScsiPortConvertUlongToPhysicalAddress(cmdBasePort[1]);
                (*ConfigInfo->AccessRanges)[2].RangeLength   = 8;
                (*ConfigInfo->AccessRanges)[2].RangeInMemory = FALSE;

                (*ConfigInfo->AccessRanges)[3].RangeStart    = ScsiPortConvertUlongToPhysicalAddress(ctrlBasePort[1]);
                (*ConfigInfo->AccessRanges)[3].RangeLength   = 1;
                (*ConfigInfo->AccessRanges)[3].RangeInMemory = FALSE;
            }

            if (bmBasePort[0]) {
                (*ConfigInfo->AccessRanges)[4].RangeStart    = ScsiPortConvertUlongToPhysicalAddress(bmBasePort[0]);
                (*ConfigInfo->AccessRanges)[4].RangeLength   = 8;
                (*ConfigInfo->AccessRanges)[4].RangeInMemory = FALSE;
            }

            if (bmBasePort[1]) {
                (*ConfigInfo->AccessRanges)[5].RangeStart    = ScsiPortConvertUlongToPhysicalAddress(bmBasePort[1]);
                (*ConfigInfo->AccessRanges)[5].RangeLength   = 8;
                (*ConfigInfo->AccessRanges)[5].RangeInMemory = FALSE;
            }
        }


        //
        // map all raw io addresses to logical io addresses
        //
        getDeviceBaseFailed = FALSE;
        CmdLogicalBasePort[0]  = (PIDE_REGISTERS_1) ScsiPortGetDeviceBase(HwDeviceExtension,
                                                        ConfigInfo->AdapterInterfaceType,
                                                        ConfigInfo->SystemIoBusNumber,
                                                        (*ConfigInfo->AccessRanges)[0].RangeStart,
                                                        (*ConfigInfo->AccessRanges)[0].RangeLength,
                                                        (BOOLEAN) !((*ConfigInfo->AccessRanges)[0].RangeInMemory));
        if (!CmdLogicalBasePort[0]) {
            getDeviceBaseFailed = TRUE;
        }

        if (*PreConfig) {
            CtrlLogicalBasePort[0] = (PIDE_REGISTERS_2) ScsiPortGetDeviceBase(HwDeviceExtension,
                                                            ConfigInfo->AdapterInterfaceType,
                                                            ConfigInfo->SystemIoBusNumber,
                                                            ScsiPortConvertUlongToPhysicalAddress(ctrlBasePort[0]),
                                                            1,
                                                            (BOOLEAN) !((*ConfigInfo->AccessRanges)[0].RangeInMemory));

        } else {
            CtrlLogicalBasePort[0] = (PIDE_REGISTERS_2) ScsiPortGetDeviceBase(HwDeviceExtension,
                                                            ConfigInfo->AdapterInterfaceType,
                                                            ConfigInfo->SystemIoBusNumber,
                                                            (*ConfigInfo->AccessRanges)[1].RangeStart,
                                                            (*ConfigInfo->AccessRanges)[1].RangeLength,
                                                            (BOOLEAN) !((*ConfigInfo->AccessRanges)[1].RangeInMemory));
        }
        if (!CtrlLogicalBasePort[0]) {
            getDeviceBaseFailed = TRUE;
        }

        if (cmdBasePort[1]) {
            CmdLogicalBasePort[1]  = (PIDE_REGISTERS_1) ScsiPortGetDeviceBase(HwDeviceExtension,
                                                            ConfigInfo->AdapterInterfaceType,
                                                            ConfigInfo->SystemIoBusNumber,
                                                            (*ConfigInfo->AccessRanges)[2].RangeStart,
                                                            (*ConfigInfo->AccessRanges)[2].RangeLength,
                                                            (BOOLEAN) !((*ConfigInfo->AccessRanges)[2].RangeInMemory));
            if (!CmdLogicalBasePort[0]) {
                getDeviceBaseFailed = TRUE;
            }

            CtrlLogicalBasePort[1] = (PIDE_REGISTERS_2) ScsiPortGetDeviceBase(HwDeviceExtension,
                                                            ConfigInfo->AdapterInterfaceType,
                                                            ConfigInfo->SystemIoBusNumber,
                                                            (*ConfigInfo->AccessRanges)[3].RangeStart,
                                                            (*ConfigInfo->AccessRanges)[3].RangeLength,
                                                            (BOOLEAN) !((*ConfigInfo->AccessRanges)[3].RangeInMemory));
            if (!CtrlLogicalBasePort[0]) {
                getDeviceBaseFailed = TRUE;
            }
        }

        if (bmBasePort[0]) {
            BmLogicalBasePort[0] = (PIDE_BUS_MASTER_REGISTERS) ScsiPortGetDeviceBase(HwDeviceExtension,
                                                                   ConfigInfo->AdapterInterfaceType,
                                                                   ConfigInfo->SystemIoBusNumber,
                                                                   (*ConfigInfo->AccessRanges)[4].RangeStart,
                                                                   (*ConfigInfo->AccessRanges)[4].RangeLength,
                                                                   (BOOLEAN) !((*ConfigInfo->AccessRanges)[4].RangeInMemory));
            if (!BmLogicalBasePort[0]) {
                getDeviceBaseFailed = TRUE;
            }
        }
        if (bmBasePort[1]) {
            BmLogicalBasePort[1] = (PIDE_BUS_MASTER_REGISTERS) ScsiPortGetDeviceBase(HwDeviceExtension,
                                                                   ConfigInfo->AdapterInterfaceType,
                                                                   ConfigInfo->SystemIoBusNumber,
                                                                   (*ConfigInfo->AccessRanges)[5].RangeStart,
                                                                   (*ConfigInfo->AccessRanges)[5].RangeLength,
                                                                   (BOOLEAN) !((*ConfigInfo->AccessRanges)[5].RangeInMemory));
            if (!BmLogicalBasePort[1]) {
                getDeviceBaseFailed = TRUE;
            }
        }

        if (!getDeviceBaseFailed)
            return TRUE;
    }

    return FALSE;
}


BOOLEAN
AtapiFreeIoBase (
    IN PVOID HwDeviceExtension,
    IN OUT PPORT_CONFIGURATION_INFORMATION ConfigInfo,
    IN OUT PFIND_STATE FindState,
    OUT PIDE_REGISTERS_1 CmdLogicalBasePort[2],
    OUT PIDE_REGISTERS_2 CtrlLogicalBasePort[2],
    OUT PIDE_BUS_MASTER_REGISTERS BmLogicalBasePort[2]
)
/*++

Routine Description:

    free logical io addresses.

    This function is called when no device found on the io addresses

    This function clears these PORT_CONFIGURATION_INFORMATION entries

        AccessRanges
        BusInterruptLevel
        BusInterruptLevel2
        AtdiskPrimaryClaimed
        AtdiskSecondaryClaimed

Arguments:

    HwDeviceExtension   - HBA miniport driver's adapter data storage
    ConfigInfo          = Scsi Port Config. Structure
    FindState           - Keep track of what addresses has been returned
    CmdLogicalBasePort  - command block register logical base address
    CtrlLogicalBasePort - control block register logical base address
    BmLogicalBasePort   - bus master register logical base address

Return Value:

    TRUE  - always

--*/
{
    PHW_DEVICE_EXTENSION deviceExtension = HwDeviceExtension;

    if (CmdLogicalBasePort[0]) {
        ScsiPortFreeDeviceBase(HwDeviceExtension,
                               CmdLogicalBasePort[0]);
        (*ConfigInfo->AccessRanges)[0].RangeStart = ScsiPortConvertUlongToPhysicalAddress(0);
        CmdLogicalBasePort[0]   = 0;
    }
    if (CmdLogicalBasePort[1]) {
        ScsiPortFreeDeviceBase(HwDeviceExtension,
                               CmdLogicalBasePort[1]);
        (*ConfigInfo->AccessRanges)[1].RangeStart = ScsiPortConvertUlongToPhysicalAddress(0);
        CmdLogicalBasePort[1]   = 0;
    }
    if (CtrlLogicalBasePort[0]) {
        ScsiPortFreeDeviceBase(HwDeviceExtension,
                               CtrlLogicalBasePort[0]);
        (*ConfigInfo->AccessRanges)[2].RangeStart = ScsiPortConvertUlongToPhysicalAddress(0);
        CtrlLogicalBasePort[0]  = 0;
    }
    if (CtrlLogicalBasePort[1]) {
        ScsiPortFreeDeviceBase(HwDeviceExtension,
                               CtrlLogicalBasePort[1]);
        (*ConfigInfo->AccessRanges)[3].RangeStart = ScsiPortConvertUlongToPhysicalAddress(0);
        CtrlLogicalBasePort[1]  = 0;
    }
    if (BmLogicalBasePort[0]) {
        ScsiPortFreeDeviceBase(HwDeviceExtension,
                               BmLogicalBasePort[0]);
        (*ConfigInfo->AccessRanges)[4].RangeStart = ScsiPortConvertUlongToPhysicalAddress(0);
        BmLogicalBasePort[0]    = 0;
    }
    if (BmLogicalBasePort[1]) {
        ScsiPortFreeDeviceBase(HwDeviceExtension,
                               BmLogicalBasePort[1]);
        (*ConfigInfo->AccessRanges)[5].RangeStart = ScsiPortConvertUlongToPhysicalAddress(0);
        BmLogicalBasePort[1]    = 0;
    }

    ConfigInfo->AtdiskPrimaryClaimed    = FALSE;
    ConfigInfo->AtdiskSecondaryClaimed  = FALSE;
    ConfigInfo->BusInterruptLevel       = 0;
    ConfigInfo->BusInterruptLevel2      = 0;
    deviceExtension->PrimaryAddress     = FALSE;
    deviceExtension->BMTimingControl    = NULL;

    return TRUE;
}



BOOLEAN
AtapiAllocatePRDT(
    IN OUT PVOID HwDeviceExtension,
    IN OUT PPORT_CONFIGURATION_INFORMATION ConfigInfo
    )
/*++

Routine Description:

    allocate scatter/gather list for PCI IDE controller call
    Physical Region Descriptor Table (PRDT)

Arguments:

    HwDeviceExtension   - HBA miniport driver's adapter data storage
    ConfigInfo          = Scsi Port Config. Structure

Return Value:

    TRUE  - if successful
    FASLE - if failed


--*/
{
    PHW_DEVICE_EXTENSION deviceExtension = HwDeviceExtension;
    ULONG                bytesMapped;
    ULONG                totalBytesMapped;
    PUCHAR               buffer;
    PHYSICAL_ADDRESS     physAddr;
    ULONG                uncachedExtensionSize;
    INTERFACE_TYPE       oldAdapterInterfaceType;

    ConfigInfo->ScatterGather = TRUE;
    ConfigInfo->Master = TRUE;
    ConfigInfo->Dma32BitAddresses = TRUE;
    ConfigInfo->DmaWidth = Width16Bits;

    //
    // word align
    //
    ConfigInfo->AlignmentMask = 1;

    //
    // PRDT cannot cross a page boundary, so number of physical breaks
    // are limited by page size
    //
    ConfigInfo->NumberOfPhysicalBreaks = PAGE_SIZE / sizeof(PHYSICAL_REGION_DESCRIPTOR);

    //
    // MAX_TRANSFER_SIZE_PER_SRB can spread over
    // (MAX_TRANSFER_SIZE_PER_SRB / PAGE_SIZE) + 2 pages
    // Each page requires 8 bytes in the bus master descriptor table
    // To guarantee we will have a buffer that is big enough and does not
    // cross a page boundary, we will allocate twice of what we need.
    // Half of that will always be big enough and will not cross
    // any page boundary
    //
    uncachedExtensionSize = (MAX_TRANSFER_SIZE_PER_SRB / PAGE_SIZE) + 2;
    uncachedExtensionSize *= sizeof (PHYSICAL_REGION_DESCRIPTOR);
    uncachedExtensionSize *= 2;

    //
    // ScsiPortGetUncachedExtension() will allocate Adapter object,
    // change the AdapterInterfaceType to PCI temporarily so that
    // we don't inherit ISA DMA limitation.
    // We can't keep the AdapterInterfaceType to PCI because the
    // irq resources we are asking for are ISA resources
    //
    oldAdapterInterfaceType = ConfigInfo->AdapterInterfaceType;
    ConfigInfo->AdapterInterfaceType = PCIBus;

    buffer = ScsiPortGetUncachedExtension(HwDeviceExtension,
                                          ConfigInfo,
                                          uncachedExtensionSize);

    ConfigInfo->AdapterInterfaceType = oldAdapterInterfaceType;

    if (buffer) {

        deviceExtension->DataBufferDescriptionTableSize = 0;
        totalBytesMapped = 0;
        while (totalBytesMapped < uncachedExtensionSize) {
            physAddr = ScsiPortGetPhysicalAddress(HwDeviceExtension,
                                                  NULL,
                                                  buffer,
                                                  &bytesMapped);
            if (bytesMapped == 0) {
                break;
            }

            //
            // Find the biggest chuck of physically contiguous memory
            //
            totalBytesMapped += bytesMapped;
            while (bytesMapped) {
                ULONG chunkSize;

                chunkSize = PAGE_SIZE - (ScsiPortConvertPhysicalAddressToUlong(physAddr) & (PAGE_SIZE-1));
                if (chunkSize > bytesMapped)
                    chunkSize = bytesMapped;

                if (chunkSize > deviceExtension->DataBufferDescriptionTableSize) {
                    deviceExtension->DataBufferDescriptionTableSize = chunkSize;
                    deviceExtension->DataBufferDescriptionTablePtr = (PPHYSICAL_REGION_DESCRIPTOR) buffer;
                    deviceExtension->DataBufferDescriptionTablePhysAddr = physAddr;
                }
                buffer      += chunkSize;
                physAddr     = ScsiPortConvertUlongToPhysicalAddress
                                   (ScsiPortConvertPhysicalAddressToUlong(physAddr) + chunkSize);
                bytesMapped -= chunkSize;
            }
        }
        // Did we get at least the minimal amount (half of what we ask for)?
        if (deviceExtension->DataBufferDescriptionTableSize < (uncachedExtensionSize / 2)) {
            buffer = NULL;
        }
    }

    if (buffer) {
        return TRUE;
    } else {
        DebugPrint ((0, "atapi: unable to get buffer for physical descriptor table!\n"));
        ConfigInfo->ScatterGather = FALSE;
        ConfigInfo->Master = FALSE;
        ConfigInfo->Dma32BitAddresses = FALSE;
        return FALSE;
    }
}


ULONG
AtapiFindController(
    IN PVOID HwDeviceExtension,
    IN PFIND_STATE FindState,
    IN PVOID BusInformation,
    IN PCHAR ArgumentString,
    IN OUT PPORT_CONFIGURATION_INFORMATION ConfigInfo,
    OUT PBOOLEAN Again
    )
/*++

Routine Description:

    This function is called by the OS-specific port driver after
    the necessary storage has been allocated, to gather information
    about the adapter's configuration.

Arguments:

    HwDeviceExtension - HBA miniport driver's adapter data storage
    Context - Address of findstate
    ArgumentString - Used to determine whether driver is client of ntldr or crash dump utility.
    ConfigInfo - Configuration information structure describing HBA
    Again - Indicates search for adapters to continue

Return Value:

    ULONG

--*/

{
    PHW_DEVICE_EXTENSION deviceExtension = HwDeviceExtension;
    ULONG                i,j;
    ULONG                retryCount;
    PCI_SLOT_NUMBER      slotData;
    PPCI_COMMON_CONFIG   pciData;
    ULONG                pciBuffer;
    BOOLEAN              atapiOnly;
    UCHAR                statusByte;
    ULONG                ideChannel;
    BOOLEAN              foundDevice0 = FALSE;
    BOOLEAN              foundDevice1 = FALSE;

    PIDE_REGISTERS_1            cmdLogicalBasePort[2];
    PIDE_REGISTERS_2            ctrlLogicalBasePort[2];
    PIDE_BUS_MASTER_REGISTERS   bmLogicalBasePort[2];
    ULONG                       numIdeChannel;
    BOOLEAN                     preConfig = FALSE;
    PCHAR                       userArgumentString;


    if (!deviceExtension) {
        return SP_RETURN_ERROR;
    }

    //
    // set the dma detection level
    //
    SetBusMasterDetectionLevel (HwDeviceExtension, ArgumentString);

    *Again = TRUE;
    userArgumentString = ArgumentString;
    while (AtapiAllocateIoBase (HwDeviceExtension,
                                userArgumentString,
                                ConfigInfo,
                                FindState,
                                cmdLogicalBasePort,
                                ctrlLogicalBasePort,
                                bmLogicalBasePort,
                                &numIdeChannel,
                                &preConfig)) {

        // only use user argument string once
        userArgumentString = NULL;

        ConfigInfo->NumberOfBuses = 1;
        ConfigInfo->MaximumNumberOfTargets = (UCHAR) (2 * numIdeChannel);
        deviceExtension->NumberChannels = numIdeChannel;

        for (i = 0; i < 4; i++) {
            deviceExtension->DeviceFlags[i] &= ~(DFLAGS_ATAPI_DEVICE | DFLAGS_DEVICE_PRESENT | DFLAGS_TAPE_DEVICE);
        }

        for (ideChannel = 0; ideChannel < numIdeChannel; ideChannel++) {

            retryCount = 4;

    retryIdentifier:

            //
            // Select master.
            //

            ScsiPortWritePortUchar(&cmdLogicalBasePort[ideChannel]->DriveSelect, 0xA0);

            //
            // Check if card at this address.
            //

            ScsiPortWritePortUchar(&cmdLogicalBasePort[ideChannel]->CylinderLow, 0xAA);

            //
            // Check if indentifier can be read back.
            //

            if ((statusByte = ScsiPortReadPortUchar(&cmdLogicalBasePort[ideChannel]->CylinderLow)) != 0xAA) {

                DebugPrint((2,
                            "AtapiFindController: Identifier read back from Master (%x)\n",
                            statusByte));

                statusByte = ScsiPortReadPortUchar(&cmdLogicalBasePort[ideChannel]->Command);

                if (statusByte & IDE_STATUS_BUSY) {

                    i = 0;

                    //
                    // Could be the TEAC in a thinkpad. Their dos driver puts it in a sleep-mode that
                    // warm boots don't clear.
                    //

                    do {
                        ScsiPortStallExecution(1000);
                        statusByte = ScsiPortReadPortUchar(&cmdLogicalBasePort[ideChannel]->Command);
                        DebugPrint((3,
                                    "AtapiFindController: First access to status %x\n",
                                    statusByte));
                    } while ((statusByte & IDE_STATUS_BUSY) && ++i < 10);

                    if (retryCount-- && (!(statusByte & IDE_STATUS_BUSY))) {
                        goto retryIdentifier;
                    }
                }

                //
                // Select slave.
                //

                ScsiPortWritePortUchar(&cmdLogicalBasePort[ideChannel]->DriveSelect, 0xB0);

                //
                // See if slave is present.
                //

                ScsiPortWritePortUchar(&cmdLogicalBasePort[ideChannel]->CylinderLow, 0xAA);

                if ((statusByte = ScsiPortReadPortUchar(&cmdLogicalBasePort[ideChannel]->CylinderLow)) != 0xAA) {

                    DebugPrint((2,
                                "AtapiFindController: Identifier read back from Slave (%x)\n",
                                statusByte));

                    //
                    //
                    // No controller at this base address.
                    //

                    continue;
                }
            }

            //
            // Record base IO address.
            //

            deviceExtension->BaseIoAddress1[ideChannel] = cmdLogicalBasePort[ideChannel];
            deviceExtension->BaseIoAddress2[ideChannel] = ctrlLogicalBasePort[ideChannel];
            deviceExtension->BusMasterPortBase[ideChannel] = bmLogicalBasePort[ideChannel];
            if (bmLogicalBasePort[ideChannel]) {
                deviceExtension->ControllerFlags |= CFLAGS_BUS_MASTERING;
            } else {
                deviceExtension->ControllerFlags &= ~CFLAGS_BUS_MASTERING;
            }

            DebugPrint ((2, "atapi: command register logical base port: 0x%x\n", deviceExtension->BaseIoAddress1[ideChannel]));
            DebugPrint ((2, "atapi: control register logical base port: 0x%x\n", deviceExtension->BaseIoAddress2[ideChannel]));
            DebugPrint ((2, "atapi: busmaster register logical base port: 0x%x\n", deviceExtension->BusMasterPortBase[ideChannel]));

            //
            // Indicate maximum transfer length is 64k.
            //
            ConfigInfo->MaximumTransferLength = MAX_TRANSFER_SIZE_PER_SRB;

            DebugPrint((1,
                       "AtapiFindController: Found IDE at %x\n",
                       deviceExtension->BaseIoAddress1[ideChannel]));


            //
            // For Daytona, the atdisk driver gets the first shot at the
            // primary and secondary controllers.
            //

            if (preConfig == FALSE) {

                if (ConfigInfo->AtdiskPrimaryClaimed || ConfigInfo->AtdiskSecondaryClaimed) {

                    //
                    // Determine whether this driver is being initialized by the
                    // system or as a crash dump driver.
                    //

                    if (ArgumentString) {

                        if (AtapiParseArgumentString(ArgumentString, "dump") == 1) {
                            DebugPrint((3,
                                       "AtapiFindController: Crash dump\n"));
                            atapiOnly = FALSE;
                            deviceExtension->DriverMustPoll = TRUE;
                        } else {
                            DebugPrint((3,
                                       "AtapiFindController: Atapi Only\n"));
                            atapiOnly = TRUE;
                            deviceExtension->DriverMustPoll = FALSE;
                        }
                    } else {

                        DebugPrint((3,
                                   "AtapiFindController: Atapi Only\n"));
                        atapiOnly = TRUE;
                        deviceExtension->DriverMustPoll = FALSE;
                    }

                } else {
                    atapiOnly = FALSE;
                }

                //
                // If this is a PCI machine, pick up all devices.
                //


                pciData = (PPCI_COMMON_CONFIG)&pciBuffer;

                slotData.u.bits.DeviceNumber = 0;
                slotData.u.bits.FunctionNumber = 0;

                if (ScsiPortGetBusData(deviceExtension,
                                       PCIConfiguration,
                                       0,                  // BusNumber
                                       slotData.u.AsULONG,
                                       pciData,
                                       sizeof(ULONG))) {

                    atapiOnly = FALSE;

                    //
                    // Wait on doing this, until a reliable method
                    // of determining support is found.
                    //

        #if 0
                    deviceExtension->DWordIO = TRUE;
        #endif

                } else {
                    deviceExtension->DWordIO = FALSE;
                }

            } else {

                atapiOnly = FALSE;
                deviceExtension->DriverMustPoll = FALSE;

            }// preConfig check

            //
            // Save the Interrupe Mode for later use
            //
            deviceExtension->InterruptMode = ConfigInfo->InterruptMode;

            //
            // Search for devices on this controller.
            //

            if (FindDevices(HwDeviceExtension, atapiOnly, ideChannel)) {

                if (ideChannel == 0) {

                    foundDevice0 = TRUE;
                } else {

                    foundDevice1 = TRUE;
                }
            }
        }

        if ((!foundDevice0) && (!foundDevice1)) {
            AtapiFreeIoBase (HwDeviceExtension,
                             ConfigInfo,
                             FindState,
                             cmdLogicalBasePort,
                             ctrlLogicalBasePort,
                             bmLogicalBasePort);
        } else {

            ULONG deviceNumber;

            if ((foundDevice0) && (!foundDevice1)) {

                //
                // device on channel 0, but not on channel 1
                //

                ConfigInfo->BusInterruptLevel2 = 0;

            } else if ((!foundDevice0) && (foundDevice1)) {
    
                //
                // device on channel 1, but not on channel 0
                //
                ConfigInfo->BusInterruptLevel = ConfigInfo->BusInterruptLevel2;
                ConfigInfo->BusInterruptLevel2 = 0;
            }

            DeviceSpecificInitialize(HwDeviceExtension);

            for (deviceNumber = 0; deviceNumber < 4; deviceNumber++) {
                if (deviceExtension->DeviceFlags[deviceNumber] & DFLAGS_DEVICE_PRESENT) {
                    if (deviceExtension->DeviceFlags[deviceNumber] & DFLAGS_USE_DMA) {
                        ConfigInfo->NeedPhysicalAddresses = TRUE;
                    } else {
                        ConfigInfo->MapBuffers = TRUE;
                    }
                    break;
                }
            }
            if (ConfigInfo->NeedPhysicalAddresses) {
                if (!AtapiAllocatePRDT(HwDeviceExtension, ConfigInfo)) {
                    // Unable to get buffer descriptor table,
                    // go back to PIO mode
                    deviceExtension->ControllerFlags &= ~CFLAGS_BUS_MASTERING;
                    DeviceSpecificInitialize(HwDeviceExtension);
                    ConfigInfo->NeedPhysicalAddresses = FALSE;
                    ConfigInfo->MapBuffers = TRUE;
                }
            }

            if (!AtapiPlaySafe &&
                (deviceExtension->ControllerFlags & CFLAGS_BUS_MASTERING) &&
                (deviceExtension->BMTimingControl)) {
                (*deviceExtension->BMTimingControl) (deviceExtension);
            }

            return(SP_RETURN_FOUND);
        }
    }

    //
    // The entire table has been searched and no adapters have been found.
    // There is no need to call again and the device base can now be freed.
    // Clear the adapter count for the next bus.
    //

    *Again = FALSE;

    return(SP_RETURN_NOT_FOUND);

} // end AtapiFindController()


VOID
DeviceSpecificInitialize(
    IN PVOID HwDeviceExtension
    )
/*++

Routine Description:

    software-initialize devices on the ide bus

    figure out
        if the attached devices are dma capable
        if the attached devices are LBA ready


Arguments:

    HwDeviceExtension   - HBA miniport driver's adapter data storage

Return Value:

    none

--*/
{
    PHW_DEVICE_EXTENSION deviceExtension = HwDeviceExtension;
    ULONG deviceNumber;
    BOOLEAN pioDevicePresent;
    IDENTIFY_DATA2 * identifyData;
    struct _DEVICE_PARAMETERS * deviceParameters;
    BOOLEAN dmaCapable;
    ULONG pioCycleTime;
    ULONG standardPioCycleTime;
    ULONG dmaCycleTime;
    ULONG standardDmaCycleTime;

    //
    // Figure out who can do DMA and who cannot
    //
    for (deviceNumber = 0; deviceNumber < 4; deviceNumber++) {

        if (deviceExtension->DeviceFlags[deviceNumber] & DFLAGS_DEVICE_PRESENT) {

            //
            // check LBA capabilities
            //
            deviceExtension->DeviceFlags[deviceNumber] &= ~DFLAGS_LBA;

            // Some drives lie about their ability to do LBA
            // we don't want to do LBA unless we have to (>8G drive)
//            if (deviceExtension->IdentifyData[targetId].Capabilities & IDENTIFY_CAPABILITIES_LBA_SUPPORTED) {
//                deviceExtension->DeviceFlags[targetId] |= DFLAGS_LBA;
//            }
            if (deviceExtension->IdentifyData[deviceNumber].UserAddressableSectors > MAX_NUM_CHS_ADDRESSABLE_SECTORS) {
                // some device has a bogus value in the UserAddressableSectors field
                // make sure these 3 fields are max. out as defined in ATA-3 (X3T10 Rev. 6)
                if ((deviceExtension->IdentifyData[deviceNumber].NumberOfCylinders == 16383) &&
                    (deviceExtension->IdentifyData[deviceNumber].NumberOfHeads == 16) &&
                    (deviceExtension->IdentifyData[deviceNumber].SectorsPerTrack == 63)) {
                        deviceExtension->DeviceFlags[deviceNumber] |= DFLAGS_LBA;
                }
            }
            if (deviceExtension->DeviceFlags[deviceNumber] & DFLAGS_LBA) {
                DebugPrint ((1, "atapi: target %d supports LBA\n", deviceNumber));
            }

            //
            // Try to enable DMA
            //
            dmaCapable = FALSE;

            if (deviceExtension->ControllerFlags & CFLAGS_BUS_MASTERING) {
                UCHAR dmaStatus;
                dmaStatus = ScsiPortReadPortUchar (&deviceExtension->BusMasterPortBase[deviceNumber >> 1]->Status);
                if (deviceNumber & 1) {
                    if (dmaStatus & BUSMASTER_DEVICE1_DMA_OK) {
                        DebugPrint ((1, "atapi: target %d busmaster status 0x%x DMA capable bit is set\n", deviceNumber, dmaStatus));
                        dmaCapable = TRUE;
                    }
                } else {
                    if (dmaStatus & BUSMASTER_DEVICE0_DMA_OK) {
                        DebugPrint ((1, "atapi: target %d busmaster status 0x%x DMA capable bit is set\n", deviceNumber, dmaStatus));
                        dmaCapable = TRUE;
                    }
                }
            }

            //
            // figure out the shortest PIO cycle time the deivce supports
            //
            deviceExtension->DeviceParameters[deviceNumber].BestPIOMode           = INVALID_PIO_MODE;
            deviceExtension->DeviceParameters[deviceNumber].BestSingleWordDMAMode = INVALID_SWDMA_MODE;
            deviceExtension->DeviceParameters[deviceNumber].BestMultiWordDMAMode  = INVALID_MWDMA_MODE;
            pioCycleTime = standardPioCycleTime = UNINITIALIZED_CYCLE_TIME;
            deviceExtension->DeviceParameters[deviceNumber].IoReadyEnabled = FALSE;

            if (deviceExtension->IdentifyData[deviceNumber].TranslationFieldsValid & (1 << 1)) {
                if (deviceExtension->IdentifyData[deviceNumber].MinimumPIOCycleTimeIORDY) {
                    pioCycleTime = deviceExtension->IdentifyData[deviceNumber].MinimumPIOCycleTimeIORDY;
                }
            }

            if (deviceExtension->IdentifyData[deviceNumber].TranslationFieldsValid & (1 << 1)) {
                if (deviceExtension->IdentifyData[deviceNumber].AdvancedPIOModes & (1 << 1)) {
                    standardPioCycleTime = PIO_MODE4_CYCLE_TIME;
                    deviceExtension->DeviceParameters[deviceNumber].BestPIOMode = 4;
                } else if (deviceExtension->IdentifyData[deviceNumber].AdvancedPIOModes & (1 << 0)) {
                    standardPioCycleTime = PIO_MODE3_CYCLE_TIME;
                    deviceExtension->DeviceParameters[deviceNumber].BestPIOMode = 3;
                }
                if (pioCycleTime == UNINITIALIZED_CYCLE_TIME) {
                    pioCycleTime = standardPioCycleTime;
                }

            } else {

                if ((deviceExtension->IdentifyData[deviceNumber].PioCycleTimingMode & 0x00ff) == 2) {
                    standardPioCycleTime = PIO_MODE2_CYCLE_TIME;
                    deviceExtension->DeviceParameters[deviceNumber].BestPIOMode = 2;
                } else if ((deviceExtension->IdentifyData[deviceNumber].PioCycleTimingMode & 0x00ff) == 1) {
                    standardPioCycleTime = PIO_MODE1_CYCLE_TIME;
                    deviceExtension->DeviceParameters[deviceNumber].BestPIOMode = 1;
                } else {
                    standardPioCycleTime = PIO_MODE0_CYCLE_TIME;
                    deviceExtension->DeviceParameters[deviceNumber].BestPIOMode = 0;
                }

                if (pioCycleTime == UNINITIALIZED_CYCLE_TIME) {
                    pioCycleTime = standardPioCycleTime;
                }
            }

            deviceExtension->DeviceParameters[deviceNumber].PioCycleTime = pioCycleTime;
            if (deviceExtension->IdentifyData[deviceNumber].Capabilities & IDENTIFY_CAPABILITIES_IOREADY_SUPPORTED) {
                deviceExtension->DeviceParameters[deviceNumber].IoReadyEnabled = TRUE;
            }

            //
            // figure out the shortest DMA cycle time the device supports
            //
            // check min cycle time
            //
            dmaCycleTime = standardDmaCycleTime = UNINITIALIZED_CYCLE_TIME;
            if (deviceExtension->IdentifyData[deviceNumber].TranslationFieldsValid & (1 << 1)) {
                DebugPrint ((1, "atapi: target %d IdentifyData word 64-70 are valid\n", deviceNumber));

                if (deviceExtension->IdentifyData[deviceNumber].MinimumMWXferCycleTime &&
                    deviceExtension->IdentifyData[deviceNumber].RecommendedMWXferCycleTime) {
                    DebugPrint ((1,
                                 "atapi: target %d IdentifyData MinimumMWXferCycleTime = 0x%x\n",
                                 deviceNumber,
                                 deviceExtension->IdentifyData[deviceNumber].MinimumMWXferCycleTime));
                    DebugPrint ((1,
                                 "atapi: target %d IdentifyData RecommendedMWXferCycleTime = 0x%x\n",
                                 deviceNumber,
                                 deviceExtension->IdentifyData[deviceNumber].RecommendedMWXferCycleTime));
                    dmaCycleTime = deviceExtension->IdentifyData[deviceNumber].RecommendedMWXferCycleTime;
                }
            }
            //
            // check mulitword DMA timing
            //
            if (deviceExtension->IdentifyData[deviceNumber].MultiWordDMASupport) {
                DebugPrint ((1,
                             "atapi: target %d IdentifyData MultiWordDMASupport = 0x%x\n",
                             deviceNumber,
                             deviceExtension->IdentifyData[deviceNumber].MultiWordDMASupport));
                DebugPrint ((1,
                             "atapi: target %d IdentifyData MultiWordDMAActive = 0x%x\n",
                             deviceNumber,
                             deviceExtension->IdentifyData[deviceNumber].MultiWordDMAActive));

                if (deviceExtension->IdentifyData[deviceNumber].MultiWordDMASupport & (1 << 2)) {
                    standardDmaCycleTime = MWDMA_MODE2_CYCLE_TIME;
                    deviceExtension->DeviceParameters[deviceNumber].BestMultiWordDMAMode = 2;

                } else if (deviceExtension->IdentifyData[deviceNumber].MultiWordDMASupport & (1 << 1)) {
                    standardDmaCycleTime = MWDMA_MODE1_CYCLE_TIME;
                    deviceExtension->DeviceParameters[deviceNumber].BestMultiWordDMAMode = 1;

                } else if (deviceExtension->IdentifyData[deviceNumber].MultiWordDMASupport & (1 << 0)) {
                    standardDmaCycleTime = MWDMA_MODE0_CYCLE_TIME;
                    deviceExtension->DeviceParameters[deviceNumber].BestMultiWordDMAMode = 0;
                }
                if (dmaCycleTime == UNINITIALIZED_CYCLE_TIME) {
                    dmaCycleTime = standardDmaCycleTime;
                }
            }

            //
            // check singleword DMA timing
            //
            if (deviceExtension->IdentifyData[deviceNumber].SingleWordDMASupport) {
                DebugPrint ((1,
                             "atapi: target %d IdentifyData SingleWordDMASupport = 0x%x\n",
                             deviceNumber,
                             deviceExtension->IdentifyData[deviceNumber].SingleWordDMASupport));
                DebugPrint ((1,
                             "atapi: target %d IdentifyData SingleWordDMAActive = 0x%x\n",
                             deviceNumber,
                             deviceExtension->IdentifyData[deviceNumber].SingleWordDMAActive));

                if (deviceExtension->IdentifyData[deviceNumber].SingleWordDMASupport & (1 << 2)) {
                    standardDmaCycleTime = SWDMA_MODE2_CYCLE_TIME;
                    deviceExtension->DeviceParameters[deviceNumber].BestSingleWordDMAMode = 2;

                } else if (deviceExtension->IdentifyData[deviceNumber].SingleWordDMASupport & (1 << 1)) {
                    standardDmaCycleTime = SWDMA_MODE1_CYCLE_TIME;
                    deviceExtension->DeviceParameters[deviceNumber].BestSingleWordDMAMode = 1;

                } else if (deviceExtension->IdentifyData[deviceNumber].SingleWordDMASupport & (1 << 0)) {
                    standardDmaCycleTime = SWDMA_MODE0_CYCLE_TIME;
                    deviceExtension->DeviceParameters[deviceNumber].BestSingleWordDMAMode = 0;
                }
                if (dmaCycleTime == UNINITIALIZED_CYCLE_TIME) {
                    dmaCycleTime = standardDmaCycleTime;
                }
            }

            deviceExtension->DeviceParameters[deviceNumber].DmaCycleTime = dmaCycleTime;

//
// Study shows that even dma cycle time may be larger than pio cycle time, dma
// can still give better data throughput
//
//            if (dmaCycleTime > pioCycleTime) {
//                DebugPrint ((0, "atapi: target %d can do PIO (%d) faster than DMA (%d).  Turning off DMA...\n", deviceNumber, pioCycleTime, dmaCycleTime));
//                dmaCapable = FALSE;
//            } else {
//                if (!AtapiPlaySafe) {
//                    if (dmaCapable == FALSE) {
//                        DebugPrint ((0, "atapi: If we play safe, we would NOT detect target %d is DMA capable\n", deviceNumber));
//                    }
//                    dmaCapable = TRUE;
//                }
//            }

            if (((deviceExtension->IdentifyData[deviceNumber].TranslationFieldsValid & (1 << 1)) &&
                 (deviceExtension->IdentifyData[deviceNumber].SingleWordDMAActive == 0) &&
                 (deviceExtension->IdentifyData[deviceNumber].MultiWordDMAActive == 0)) 
                 &&
                ((deviceExtension->IdentifyData[deviceNumber].TranslationFieldsValid & (1 << 2)) &&
                 (deviceExtension->IdentifyData[deviceNumber].UltraDMAActive == 0))) {
                dmaCapable = FALSE;
            } else {
                if (!AtapiPlaySafe) {
                    if (dmaCapable == FALSE) {
                        DebugPrint ((0, "atapi: If we play safe, we would NOT detect target %d is DMA capable\n", deviceNumber));
                    }
                    dmaCapable = TRUE;
                }
            }

            //
            // Check for bad devices
            //
            if (AtapiDeviceDMACapable (deviceExtension, deviceNumber) == FALSE) {
                dmaCapable = FALSE;
            }

            if ((deviceExtension->ControllerFlags & CFLAGS_BUS_MASTERING) && dmaCapable) {
                deviceExtension->DeviceFlags[deviceNumber] |= DFLAGS_USE_DMA;
            } else {
                deviceExtension->DeviceFlags[deviceNumber] &= ~DFLAGS_USE_DMA;
            }
        }
    }




    //
    // Default everyone to pio if anyone of them cannot do DMA
    // We can remove this if it is ok to mix DMA and PIO devices on the same channel
    //
    // If we are going to allow mixing DMA and PIO, we need to change SCSIPORT
    // to allow setting both NeedPhysicalAddresses and MapBuffers to TRUE in
    // PORT_CONFIGURATION_INFORMATION
    //
    pioDevicePresent = FALSE;
    for (deviceNumber = 0; deviceNumber < 4 && !pioDevicePresent; deviceNumber++) {
        if (deviceExtension->DeviceFlags[deviceNumber] & DFLAGS_DEVICE_PRESENT) {
            if (!(deviceExtension->DeviceFlags[deviceNumber] & DFLAGS_USE_DMA)) {
                pioDevicePresent = TRUE;    // bummer!
            }
        }
    }

    if (pioDevicePresent) {
        for (deviceNumber = 0; deviceNumber < 4; deviceNumber++) {
            if (deviceExtension->DeviceFlags[deviceNumber] & DFLAGS_DEVICE_PRESENT) {
                deviceExtension->DeviceFlags[deviceNumber] &= ~DFLAGS_USE_DMA;
            }
        }
    }


    //
    // pick out the ATA or ATAPI r/w command we are going to use
    //
    for (deviceNumber = 0; deviceNumber < 4; deviceNumber++) {
        if (deviceExtension->DeviceFlags[deviceNumber] & DFLAGS_DEVICE_PRESENT) {

            DebugPrint ((0, "ATAPI: Base=0x%x Device %d is going to do ", deviceExtension->BaseIoAddress1[deviceNumber >> 1], deviceNumber));
            if (deviceExtension->DeviceFlags[deviceNumber] & DFLAGS_USE_DMA) {
                DebugPrint ((0, "DMA\n"));
            } else {
                DebugPrint ((0, "PIO\n"));
            }


            if (deviceExtension->DeviceFlags[deviceNumber] & DFLAGS_ATAPI_DEVICE) {

                deviceExtension->DeviceParameters[deviceNumber].MaxWordPerInterrupt = 256;

            } else {

                if (deviceExtension->DeviceFlags[deviceNumber] & DFLAGS_USE_DMA) {

                    DebugPrint ((2, "ATAPI: ATA Device (%d) is going to do DMA\n", deviceNumber));
                    deviceExtension->DeviceParameters[deviceNumber].IdeReadCommand = IDE_COMMAND_READ_DMA;
                    deviceExtension->DeviceParameters[deviceNumber].IdeWriteCommand = IDE_COMMAND_WRITE_DMA;
                    deviceExtension->DeviceParameters[deviceNumber].MaxWordPerInterrupt = MAX_TRANSFER_SIZE_PER_SRB / 2;

                } else {

                    if (deviceExtension->MaximumBlockXfer[deviceNumber]) {

                        DebugPrint ((2, "ATAPI: ATA Device (%d) is going to do PIO Multiple\n", deviceNumber));
                        deviceExtension->DeviceParameters[deviceNumber].IdeReadCommand = IDE_COMMAND_READ_MULTIPLE;
                        deviceExtension->DeviceParameters[deviceNumber].IdeWriteCommand = IDE_COMMAND_WRITE_MULTIPLE;
                        deviceExtension->DeviceParameters[deviceNumber].MaxWordPerInterrupt =
                            deviceExtension->MaximumBlockXfer[deviceNumber] * 256;
                    } else {

                        DebugPrint ((2, "ATAPI: ATA Device (%d) is going to do PIO Single\n", deviceNumber));
                        deviceExtension->DeviceParameters[deviceNumber].IdeReadCommand = IDE_COMMAND_READ;
                        deviceExtension->DeviceParameters[deviceNumber].IdeWriteCommand = IDE_COMMAND_WRITE;
                        deviceExtension->DeviceParameters[deviceNumber].MaxWordPerInterrupt = 256;
                    }
                }
            }
        }
    }

}


ULONG
Atapi2Scsi(
    IN PSCSI_REQUEST_BLOCK Srb,
    IN char *DataBuffer,
    IN ULONG ByteCount
    )
/*++

Routine Description:

    Convert atapi cdb and mode sense data to scsi format

Arguments:

    Srb         - SCSI request block
    DataBuffer  - mode sense data
    ByteCount   - mode sense data length

Return Value:

    word adjust

--*/
{
    ULONG bytesAdjust = 0;
    if (Srb->Cdb[0] == ATAPI_MODE_SENSE) {

        PMODE_PARAMETER_HEADER_10 header_10 = (PMODE_PARAMETER_HEADER_10)DataBuffer;
        PMODE_PARAMETER_HEADER header = (PMODE_PARAMETER_HEADER)DataBuffer;

        header->ModeDataLength = header_10->ModeDataLengthLsb;
        header->MediumType = header_10->MediumType;

        //
        // ATAPI Mode Parameter Header doesn't have these fields.
        //

        header->DeviceSpecificParameter = header_10->Reserved[0];
        header->BlockDescriptorLength = header_10->Reserved[1];

        ByteCount -= sizeof(MODE_PARAMETER_HEADER_10);
        if (ByteCount > 0)
            ScsiPortMoveMemory(DataBuffer+sizeof(MODE_PARAMETER_HEADER),
                               DataBuffer+sizeof(MODE_PARAMETER_HEADER_10),
                               ByteCount);

        //
        // Change ATAPI_MODE_SENSE opcode back to SCSIOP_MODE_SENSE
        // so that we don't convert again.
        //

        Srb->Cdb[0] = SCSIOP_MODE_SENSE;

        bytesAdjust = sizeof(MODE_PARAMETER_HEADER_10) -
                      sizeof(MODE_PARAMETER_HEADER);


    }

    //
    // Convert to words.
    //

    return bytesAdjust >> 1;
}


VOID
AtapiCallBack(
    IN PVOID HwDeviceExtension
    )
{
    PHW_DEVICE_EXTENSION deviceExtension = HwDeviceExtension;
    PSCSI_REQUEST_BLOCK  srb = deviceExtension->CurrentSrb;
    PATAPI_REGISTERS_1   baseIoAddress1;
    UCHAR statusByte;

    //
    // If the last command was DSC restrictive, see if it's set. If so, the device is
    // ready for a new request. Otherwise, reset the timer and come back to here later.
    //

    if (srb && (!(deviceExtension->ExpectingInterrupt))) {
#if DBG
        if (!IS_RDP((srb->Cdb[0]))) {
            DebugPrint((1,
                        "AtapiCallBack: Invalid CDB marked as RDP - %x\n",
                        srb->Cdb[0]));
        }
#endif

        baseIoAddress1 = (PATAPI_REGISTERS_1)deviceExtension->BaseIoAddress1[srb->TargetId >> 1];
        if (deviceExtension->RDP) {
            GetStatus(baseIoAddress1, statusByte);
            if (statusByte & IDE_STATUS_DSC) {

                ScsiPortNotification(RequestComplete,
                                     deviceExtension,
                                     srb);

                //
                // Clear current SRB.
                //

                deviceExtension->CurrentSrb = NULL;
                deviceExtension->RDP = FALSE;

                //
                // Ask for next request.
                //

                ScsiPortNotification(NextRequest,
                                     deviceExtension,
                                     NULL);


                return;

            } else {

                DebugPrint((3,
                            "AtapiCallBack: Requesting another timer for Op %x\n",
                            deviceExtension->CurrentSrb->Cdb[0]));

                ScsiPortNotification(RequestTimerCall,
                                     HwDeviceExtension,
                                     AtapiCallBack,
                                     1000);
                return;
            }
        }
    }

    DebugPrint((2,
                "AtapiCallBack: Calling ISR directly due to BUSY\n"));
    AtapiInterrupt(HwDeviceExtension);
}


BOOLEAN
AtapiInterrupt(
    IN PVOID HwDeviceExtension
    )

/*++

Routine Description:

    This is the interrupt service routine for ATAPI IDE miniport driver.

Arguments:

    HwDeviceExtension - HBA miniport driver's adapter data storage

Return Value:

    TRUE if expecting an interrupt.

--*/

{
    PHW_DEVICE_EXTENSION deviceExtension = HwDeviceExtension;
    PSCSI_REQUEST_BLOCK srb              = deviceExtension->CurrentSrb;
    PATAPI_REGISTERS_1 baseIoAddress1;
    PATAPI_REGISTERS_2 baseIoAddress2;
    ULONG wordCount = 0, wordsThisInterrupt = 256;
    ULONG status;
    ULONG i;
    UCHAR statusByte,interruptReason;
    BOOLEAN commandComplete = FALSE;
    BOOLEAN atapiDev = FALSE;
    UCHAR dmaStatus;

    if (srb) {
        // PCI Busmaster IDE Controller spec defines a bit in its status
        // register which indicates pending interrupt.  However,
        // CMD 646 (maybe some other one, too) doesn't always do that if
        // the interrupt is from a atapi device.  (strange, but true!)
        // Since we have to look at the interrupt bit only if we are sharing
        // interrupt, we will do just that
        if (deviceExtension->InterruptMode == LevelSensitive) {
            if (deviceExtension->ControllerFlags & CFLAGS_BUS_MASTERING) {
                dmaStatus = ScsiPortReadPortUchar (&deviceExtension->BusMasterPortBase[srb->TargetId >> 1]->Status);
                if ((dmaStatus & BUSMASTER_INTERRUPT) == 0) {
                    return FALSE;
                }
            }
        }

        baseIoAddress1 =    (PATAPI_REGISTERS_1)deviceExtension->BaseIoAddress1[srb->TargetId >> 1];
        baseIoAddress2 =    (PATAPI_REGISTERS_2)deviceExtension->BaseIoAddress2[srb->TargetId >> 1];
    } else {
        DebugPrint((2,
                    "AtapiInterrupt: CurrentSrb is NULL\n"));
        //
        // We can only support one ATAPI IDE master on Carolina, so find
        // the base address that is non NULL and clear its interrupt before
        // returning.
        //

#ifdef _PPC_

        if ((PATAPI_REGISTERS_1)deviceExtension->BaseIoAddress1[0] != NULL) {
           baseIoAddress1 = (PATAPI_REGISTERS_1)deviceExtension->BaseIoAddress1[0];
        } else {
           baseIoAddress1 = (PATAPI_REGISTERS_1)deviceExtension->BaseIoAddress1[1];
        }

        GetBaseStatus(baseIoAddress1, statusByte);
#else

        if (deviceExtension->InterruptMode == LevelSensitive) {
            if (deviceExtension->BaseIoAddress1[0] != NULL) {
               baseIoAddress1 = (PATAPI_REGISTERS_1)deviceExtension->BaseIoAddress1[0];
               GetBaseStatus(baseIoAddress1, statusByte);
            }
            if (deviceExtension->BaseIoAddress1[1] != NULL) {
               baseIoAddress1 = (PATAPI_REGISTERS_1)deviceExtension->BaseIoAddress1[1];
               GetBaseStatus(baseIoAddress1, statusByte);
            }
        }
#endif
        return FALSE;
    }

    if (!(deviceExtension->ExpectingInterrupt)) {

        DebugPrint((3,
                    "AtapiInterrupt: Unexpected interrupt.\n"));
        return FALSE;
    }

    //
    // Clear interrupt by reading status.
    //

    GetBaseStatus(baseIoAddress1, statusByte);

    DebugPrint((3,
                "AtapiInterrupt: Entered with status (%x)\n",
                statusByte));


    if (statusByte & IDE_STATUS_BUSY) {
        if (deviceExtension->DriverMustPoll) {

            //
            // Crashdump is polling and we got caught with busy asserted.
            // Just go away, and we will be polled again shortly.
            //

            DebugPrint((3,
                        "AtapiInterrupt: Hit BUSY while polling during crashdump.\n"));

            return TRUE;
        }

        //
        // Ensure BUSY is non-asserted.
        //

        for (i = 0; i < 10; i++) {

            GetBaseStatus(baseIoAddress1, statusByte);
            if (!(statusByte & IDE_STATUS_BUSY)) {
                break;
            }
            ScsiPortStallExecution(5000);
        }

        if (i == 10) {

            DebugPrint((2,
                        "AtapiInterrupt: BUSY on entry. Status %x, Base IO %x\n",
                        statusByte,
                        baseIoAddress1));

            ScsiPortNotification(RequestTimerCall,
                                 HwDeviceExtension,
                                 AtapiCallBack,
                                 500);
            return TRUE;
        }
    }


    if (deviceExtension->DMAInProgress) {
        deviceExtension->DMAInProgress = FALSE;
        dmaStatus = ScsiPortReadPortUchar (&deviceExtension->BusMasterPortBase[srb->TargetId >> 1]->Status);
        ScsiPortWritePortUchar (&deviceExtension->BusMasterPortBase[srb->TargetId >> 1]->Command,
                                0);  // disable BusMastering
        ScsiPortWritePortUchar (&deviceExtension->BusMasterPortBase[srb->TargetId >> 1]->Status,
                                (UCHAR) (dmaStatus | BUSMASTER_INTERRUPT | BUSMASTER_ERROR));    // clear interrupt/error

        deviceExtension->WordsLeft = 0;

        if ((dmaStatus & (BUSMASTER_INTERRUPT | BUSMASTER_ERROR | BUSMASTER_ACTIVE)) != BUSMASTER_INTERRUPT) { // dma ok?
            status = SRB_STATUS_ERROR;
            goto CompleteRequest;
        } else {
            deviceExtension->WordsLeft = 0;
        }

    }

    //
    // Check for error conditions.
    //

    if (statusByte & IDE_STATUS_ERROR) {

        if (srb->Cdb[0] != SCSIOP_REQUEST_SENSE) {

            //
            // Fail this request.
            //

            status = SRB_STATUS_ERROR;
            goto CompleteRequest;
        }
    }

    //
    // check reason for this interrupt.
    //


    if (deviceExtension->DeviceFlags[srb->TargetId] & DFLAGS_ATAPI_DEVICE) {

        interruptReason = (ScsiPortReadPortUchar(&baseIoAddress1->InterruptReason) & 0x3);
        atapiDev = TRUE;
        wordsThisInterrupt = 256;

    } else {

        if (statusByte & IDE_STATUS_DRQ) {

            if (deviceExtension->MaximumBlockXfer[srb->TargetId]) {
                wordsThisInterrupt = 256 * deviceExtension->MaximumBlockXfer[srb->TargetId];

            }

            if (srb->SrbFlags & SRB_FLAGS_DATA_IN) {

                interruptReason =  0x2;

            } else if (srb->SrbFlags & SRB_FLAGS_DATA_OUT) {
                interruptReason = 0x0;

            } else {
                status = SRB_STATUS_ERROR;
                goto CompleteRequest;
            }

        } else if (statusByte & IDE_STATUS_BUSY) {

            return FALSE;

        } else {

            if (deviceExtension->WordsLeft) {

                ULONG k;

                //
                // Funky behaviour seen with PCI IDE (not all, just one).
                // The ISR hits with DRQ low, but comes up later.
                //

                for (k = 0; k < 5000; k++) {
                    GetStatus(baseIoAddress1,statusByte);
                    if (!(statusByte & IDE_STATUS_DRQ)) {
                        ScsiPortStallExecution(100);
                    } else {
                        break;
                    }
                }

                if (k == 5000) {

                    //
                    // reset the controller.
                    //

                    DebugPrint((1,
                                "AtapiInterrupt: Resetting due to DRQ not up. Status %x, Base IO %x\n",
                                statusByte,
                                baseIoAddress1));

                    AtapiResetController(HwDeviceExtension,srb->PathId);
                    return TRUE;
                } else {

                    interruptReason = (srb->SrbFlags & SRB_FLAGS_DATA_IN) ? 0x2 : 0x0;
                }

            } else {

                //
                // Command complete - verify, write, or the SMART enable/disable.
                //
                // Also get_media_status

                interruptReason = 0x3;
            }
        }
    }

    if (interruptReason == 0x1 && (statusByte & IDE_STATUS_DRQ)) {

        //
        // Write the packet.
        //

        DebugPrint((2,
                    "AtapiInterrupt: Writing Atapi packet.\n"));

        //
        // Send CDB to device.
        //

        WriteBuffer(baseIoAddress1,
                    (PUSHORT)srb->Cdb,
                    6);

        switch (srb->Cdb[0]) {

            case SCSIOP_RECEIVE:
            case SCSIOP_SEND:
            case SCSIOP_READ:
            case SCSIOP_WRITE:
                if (deviceExtension->DeviceFlags[srb->TargetId] & DFLAGS_USE_DMA) {
                    EnableBusMastering(HwDeviceExtension, srb);
                }
                break;

            default:
                break;
        }

        return TRUE;

    } else if (interruptReason == 0x0 && (statusByte & IDE_STATUS_DRQ)) {

        //
        // Write the data.
        //

        if (deviceExtension->DeviceFlags[srb->TargetId] & DFLAGS_ATAPI_DEVICE) {

            //
            // Pick up bytes to transfer and convert to words.
            //

            wordCount =
                ScsiPortReadPortUchar(&baseIoAddress1->ByteCountLow);

            wordCount |=
                ScsiPortReadPortUchar(&baseIoAddress1->ByteCountHigh) << 8;

            //
            // Covert bytes to words.
            //

            wordCount >>= 1;

            if (wordCount != deviceExtension->WordsLeft) {
                DebugPrint((3,
                           "AtapiInterrupt: %d words requested; %d words xferred\n",
                           deviceExtension->WordsLeft,
                           wordCount));
            }

            //
            // Verify this makes sense.
            //

            if (wordCount > deviceExtension->WordsLeft) {
                wordCount = deviceExtension->WordsLeft;
            }

        } else {

            //
            // IDE path. Check if words left is at least 256.
            //

            if (deviceExtension->WordsLeft < wordsThisInterrupt) {

               //
               // Transfer only words requested.
               //

               wordCount = deviceExtension->WordsLeft;

            } else {

               //
               // Transfer next block.
               //

               wordCount = wordsThisInterrupt;
            }
        }

        //
        // Ensure that this is a write command.
        //

        if (srb->SrbFlags & SRB_FLAGS_DATA_OUT) {

           DebugPrint((3,
                      "AtapiInterrupt: Write interrupt\n"));

           WaitOnBusy(baseIoAddress1,statusByte);

           if (atapiDev || !deviceExtension->DWordIO) {

               WriteBuffer(baseIoAddress1,
                           deviceExtension->DataBuffer,
                           wordCount);
           } else {

               PIDE_REGISTERS_3 address3 = (PIDE_REGISTERS_3)baseIoAddress1;

               WriteBuffer2(address3,
                           (PULONG)(deviceExtension->DataBuffer),
                           wordCount / 2);
           }
        } else {

            DebugPrint((1,
                        "AtapiInterrupt: Int reason %x, but srb is for a write %x.\n",
                        interruptReason,
                        srb));

            //
            // Fail this request.
            //

            status = SRB_STATUS_ERROR;
            goto CompleteRequest;
        }


        //
        // Advance data buffer pointer and bytes left.
        //

        deviceExtension->DataBuffer += wordCount;
        deviceExtension->WordsLeft -= wordCount;

        return TRUE;

    } else if (interruptReason == 0x2 && (statusByte & IDE_STATUS_DRQ)) {


        if (deviceExtension->DeviceFlags[srb->TargetId] & DFLAGS_ATAPI_DEVICE) {

            //
            // Pick up bytes to transfer and convert to words.
            //

            wordCount =
                ScsiPortReadPortUchar(&baseIoAddress1->ByteCountLow);

            wordCount |=
                ScsiPortReadPortUchar(&baseIoAddress1->ByteCountHigh) << 8;

            //
            // Covert bytes to words.
            //

            wordCount >>= 1;

            if (wordCount != deviceExtension->WordsLeft) {
                DebugPrint((3,
                           "AtapiInterrupt: %d words requested; %d words xferred\n",
                           deviceExtension->WordsLeft,
                           wordCount));
            }

            //
            // Verify this makes sense.
            //

            if (wordCount > deviceExtension->WordsLeft) {
                wordCount = deviceExtension->WordsLeft;
            }

        } else {

            //
            // Check if words left is at least 256.
            //

            if (deviceExtension->WordsLeft < wordsThisInterrupt) {

               //
               // Transfer only words requested.
               //

               wordCount = deviceExtension->WordsLeft;

            } else {

               //
               // Transfer next block.
               //

               wordCount = wordsThisInterrupt;
            }
        }

        //
        // Ensure that this is a read command.
        //

        if (srb->SrbFlags & SRB_FLAGS_DATA_IN) {

           DebugPrint((3,
                      "AtapiInterrupt: Read interrupt\n"));

           WaitOnBusy(baseIoAddress1,statusByte);

           if (atapiDev || !deviceExtension->DWordIO) {
               ReadBuffer(baseIoAddress1,
                         deviceExtension->DataBuffer,
                         wordCount);

           } else {
               PIDE_REGISTERS_3 address3 = (PIDE_REGISTERS_3)baseIoAddress1;

               ReadBuffer2(address3,
                          (PULONG)(deviceExtension->DataBuffer),
                          wordCount / 2);
           }
        } else {

            DebugPrint((1,
                        "AtapiInterrupt: Int reason %x, but srb is for a read %x.\n",
                        interruptReason,
                        srb));

            //
            // Fail this request.
            //

            status = SRB_STATUS_ERROR;
            goto CompleteRequest;
        }

        //
        // Translate ATAPI data back to SCSI data if needed
        //

        if (srb->Cdb[0] == ATAPI_MODE_SENSE &&
            deviceExtension->DeviceFlags[srb->TargetId] & DFLAGS_ATAPI_DEVICE) {

            //
            //convert and adjust the wordCount
            //

            wordCount -= Atapi2Scsi(srb, (char *)deviceExtension->DataBuffer,
                                     wordCount << 1);
        }
        //
        // Advance data buffer pointer and bytes left.
        //

        deviceExtension->DataBuffer += wordCount;
        deviceExtension->WordsLeft -= wordCount;

        //
        // Check for read command complete.
        //

        if (deviceExtension->WordsLeft == 0) {

            if (deviceExtension->DeviceFlags[srb->TargetId] & DFLAGS_ATAPI_DEVICE) {

                //
                // Work around to make many atapi devices return correct sector size
                // of 2048. Also certain devices will have sector count == 0x00, check
                // for that also.
                //

                if ((srb->Cdb[0] == 0x25) &&
                    ((deviceExtension->IdentifyData[srb->TargetId].GeneralConfiguration >> 8) & 0x1f) == 0x05) {

                    deviceExtension->DataBuffer -= wordCount;
                    if (deviceExtension->DataBuffer[0] == 0x00) {

                        *((ULONG *) &(deviceExtension->DataBuffer[0])) = 0xFFFFFF7F;

                    }

                    *((ULONG *) &(deviceExtension->DataBuffer[2])) = 0x00080000;
                    deviceExtension->DataBuffer += wordCount;
                }
            } else {

                //
                // Completion for IDE drives.
                //


                if (deviceExtension->WordsLeft) {

                    status = SRB_STATUS_DATA_OVERRUN;

                } else {

                    status = SRB_STATUS_SUCCESS;

                }

                goto CompleteRequest;

            }
        }

        return TRUE;

    } else if (interruptReason == 0x3  && !(statusByte & IDE_STATUS_DRQ)) {

        //
        // Command complete.
        //

        if (deviceExtension->WordsLeft) {

            status = SRB_STATUS_DATA_OVERRUN;

        } else {

            status = SRB_STATUS_SUCCESS;

        }

CompleteRequest:

        //
        // Check and see if we are processing our secret (mechanism status/request sense) srb
        //
        if (deviceExtension->OriginalSrb) {

            ULONG srbStatus;

            if (srb->Cdb[0] == SCSIOP_MECHANISM_STATUS) {

                if (status == SRB_STATUS_SUCCESS) {
                    // Bingo!!
                    AtapiHwInitializeChanger (HwDeviceExtension,
                                              srb->TargetId,
                                              (PMECHANICAL_STATUS_INFORMATION_HEADER) srb->DataBuffer);

                    // Get ready to issue the original srb
                    srb = deviceExtension->CurrentSrb = deviceExtension->OriginalSrb;
                    deviceExtension->OriginalSrb = NULL;

                } else {
                    // failed!  Get the sense key and maybe try again
                    srb = deviceExtension->CurrentSrb = BuildRequestSenseSrb (
                                                          HwDeviceExtension,
                                                          deviceExtension->OriginalSrb->PathId,
                                                          deviceExtension->OriginalSrb->TargetId);
                }

                srbStatus = AtapiSendCommand(HwDeviceExtension, deviceExtension->CurrentSrb);
                if (srbStatus == SRB_STATUS_PENDING) {
                    return TRUE;
                }

            } else { // srb->Cdb[0] == SCSIOP_REQUEST_SENSE)

                PSENSE_DATA senseData = (PSENSE_DATA) srb->DataBuffer;

                if (status == SRB_STATUS_DATA_OVERRUN) {
                    // Check to see if we at least get mininum number of bytes
                    if ((srb->DataTransferLength - deviceExtension->WordsLeft) >
                        (offsetof (SENSE_DATA, AdditionalSenseLength) + sizeof(senseData->AdditionalSenseLength))) {
                        status = SRB_STATUS_SUCCESS;
                    }
                }

                if (status == SRB_STATUS_SUCCESS) {
                    if ((senseData->SenseKey != SCSI_SENSE_ILLEGAL_REQUEST) &&
                        deviceExtension->MechStatusRetryCount) {

                        // The sense key doesn't say the last request is illegal, so try again
                        deviceExtension->MechStatusRetryCount--;
                        srb = deviceExtension->CurrentSrb = BuildMechanismStatusSrb (
                                                              HwDeviceExtension,
                                                              deviceExtension->OriginalSrb->PathId,
                                                              deviceExtension->OriginalSrb->TargetId);
                    } else {

                        // last request was illegal.  No point trying again

                        AtapiHwInitializeChanger (HwDeviceExtension,
                                                  srb->TargetId,
                                                  (PMECHANICAL_STATUS_INFORMATION_HEADER) NULL);

                        // Get ready to issue the original srb
                        srb = deviceExtension->CurrentSrb = deviceExtension->OriginalSrb;
                        deviceExtension->OriginalSrb = NULL;
                    }

                    srbStatus = AtapiSendCommand(HwDeviceExtension, deviceExtension->CurrentSrb);
                    if (srbStatus == SRB_STATUS_PENDING) {
                        return TRUE;
                    }
                }
            }

            // If we get here, it means AtapiSendCommand() has failed
            // Can't recover.  Pretend the original srb has failed and complete it.

            if (deviceExtension->OriginalSrb) {
                AtapiHwInitializeChanger (HwDeviceExtension,
                                          srb->TargetId,
                                          (PMECHANICAL_STATUS_INFORMATION_HEADER) NULL);
                srb = deviceExtension->CurrentSrb = deviceExtension->OriginalSrb;
                deviceExtension->OriginalSrb = NULL;
            }

            // fake an error and read no data
            status = SRB_STATUS_ERROR;
            srb->ScsiStatus = 0;
            deviceExtension->DataBuffer = srb->DataBuffer;
            deviceExtension->WordsLeft = srb->DataTransferLength;
            deviceExtension->RDP = FALSE;

        } else if (status == SRB_STATUS_ERROR) {

            //
            // Map error to specific SRB status and handle request sense.
            //

            status = MapError(deviceExtension,
                              srb);

            deviceExtension->RDP = FALSE;

        } else {

            //
            // Wait for busy to drop.
            //

            for (i = 0; i < 30; i++) {
                GetStatus(baseIoAddress1,statusByte);
                if (!(statusByte & IDE_STATUS_BUSY)) {
                    break;
                }
                ScsiPortStallExecution(500);
            }

            if (i == 30) {

                //
                // reset the controller.
                //

                DebugPrint((1,
                            "AtapiInterrupt: Resetting due to BSY still up - %x. Base Io %x\n",
                            statusByte,
                            baseIoAddress1));
                AtapiResetController(HwDeviceExtension,srb->PathId);
                return TRUE;
            }

            //
            // Check to see if DRQ is still up.
            //

            if (statusByte & IDE_STATUS_DRQ) {

                for (i = 0; i < 500; i++) {
                    GetStatus(baseIoAddress1,statusByte);
                    if (!(statusByte & IDE_STATUS_DRQ)) {
                        break;
                    }
                    ScsiPortStallExecution(100);

                }

                if (i == 500) {

                    //
                    // reset the controller.
                    //

                    DebugPrint((1,
                                "AtapiInterrupt: Resetting due to DRQ still up - %x\n",
                                statusByte));
                    AtapiResetController(HwDeviceExtension,srb->PathId);
                    return TRUE;
                }

            }
        }


        //
        // Clear interrupt expecting flag.
        //

        deviceExtension->ExpectingInterrupt = FALSE;

        //
        // Sanity check that there is a current request.
        //

        if (srb != NULL) {

            //
            // Set status in SRB.
            //

            srb->SrbStatus = (UCHAR)status;

            //
            // Check for underflow.
            //

            if (deviceExtension->WordsLeft) {

                //
                // Subtract out residual words and update if filemark hit,
                // setmark hit , end of data, end of media...
                //

                if (!(deviceExtension->DeviceFlags[srb->TargetId] & DFLAGS_TAPE_DEVICE)) {
                if (status == SRB_STATUS_DATA_OVERRUN) {
                    srb->DataTransferLength -= deviceExtension->WordsLeft;
                } else {
                    srb->DataTransferLength = 0;
                }
                } else {
                    srb->DataTransferLength -= deviceExtension->WordsLeft;
                }
            }

            if (srb->Function != SRB_FUNCTION_IO_CONTROL) {

                //
                // Indicate command complete.
                //

                if (!(deviceExtension->RDP)) {
                    ScsiPortNotification(RequestComplete,
                                         deviceExtension,
                                         srb);

                }
            } else {

                PSENDCMDOUTPARAMS cmdOutParameters = (PSENDCMDOUTPARAMS)(((PUCHAR)srb->DataBuffer) + sizeof(SRB_IO_CONTROL));
                UCHAR             error = 0;

                if (status != SRB_STATUS_SUCCESS) {
                    error = ScsiPortReadPortUchar((PUCHAR)baseIoAddress1 + 1);
                }

                //
                // Build the SMART status block depending upon the completion status.
                //

                cmdOutParameters->cBufferSize = wordCount;
                cmdOutParameters->DriverStatus.bDriverError = (error) ? SMART_IDE_ERROR : 0;
                cmdOutParameters->DriverStatus.bIDEError = error;

                //
                // If the sub-command is return smart status, jam the value from cylinder low and high, into the
                // data buffer.
                //

                if (deviceExtension->SmartCommand == RETURN_SMART_STATUS) {
                    cmdOutParameters->bBuffer[0] = RETURN_SMART_STATUS;
                    cmdOutParameters->bBuffer[1] = ScsiPortReadPortUchar(&baseIoAddress1->InterruptReason);
                    cmdOutParameters->bBuffer[2] = ScsiPortReadPortUchar(&baseIoAddress1->Unused1);
                    cmdOutParameters->bBuffer[3] = ScsiPortReadPortUchar(&baseIoAddress1->ByteCountLow);
                    cmdOutParameters->bBuffer[4] = ScsiPortReadPortUchar(&baseIoAddress1->ByteCountHigh);
                    cmdOutParameters->bBuffer[5] = ScsiPortReadPortUchar(&baseIoAddress1->DriveSelect);
                    cmdOutParameters->bBuffer[6] = SMART_CMD;
                    cmdOutParameters->cBufferSize = 8;
                }

                //
                // Indicate command complete.
                //

                ScsiPortNotification(RequestComplete,
                                     deviceExtension,
                                     srb);

            }

        } else {

            DebugPrint((1,
                       "AtapiInterrupt: No SRB!\n"));
        }

        //
        // Indicate ready for next request.
        //

        if (!(deviceExtension->RDP)) {

            //
            // Clear current SRB.
            //

            deviceExtension->CurrentSrb = NULL;

            ScsiPortNotification(NextRequest,
                                 deviceExtension,
                                 NULL);
        } else {

            ScsiPortNotification(RequestTimerCall,
                                 HwDeviceExtension,
                                 AtapiCallBack,
                                 2000);
        }

        return TRUE;

    } else {

        //
        // Unexpected int.
        //

        DebugPrint((3,
                    "AtapiInterrupt: Unexpected interrupt. InterruptReason %x. Status %x.\n",
                    interruptReason,
                    statusByte));
        return FALSE;
    }

    return TRUE;

} // end AtapiInterrupt()


ULONG
IdeSendSmartCommand(
    IN PVOID HwDeviceExtension,
    IN PSCSI_REQUEST_BLOCK Srb
    )

/*++

Routine Description:

    This routine handles SMART enable, disable, read attributes and threshold commands.

Arguments:

    HwDeviceExtension - HBA miniport driver's adapter data storage
    Srb - IO request packet

Return Value:

    SRB status

--*/

{
    PHW_DEVICE_EXTENSION deviceExtension = HwDeviceExtension;
    PIDE_REGISTERS_1     baseIoAddress1  = deviceExtension->BaseIoAddress1[Srb->TargetId >> 1];
    PIDE_REGISTERS_2     baseIoAddress2  = deviceExtension->BaseIoAddress2[Srb->TargetId >> 1];
    PSENDCMDOUTPARAMS    cmdOutParameters = (PSENDCMDOUTPARAMS)(((PUCHAR)Srb->DataBuffer) + sizeof(SRB_IO_CONTROL));
    SENDCMDINPARAMS      cmdInParameters = *(PSENDCMDINPARAMS)(((PUCHAR)Srb->DataBuffer) + sizeof(SRB_IO_CONTROL));
    PIDEREGS             regs = &cmdInParameters.irDriveRegs;
    ULONG                i;
    UCHAR                statusByte,targetId;


    if (cmdInParameters.irDriveRegs.bCommandReg == SMART_CMD) {

        targetId = cmdInParameters.bDriveNumber;

        //TODO optimize this check

        if ((!(deviceExtension->DeviceFlags[targetId] & DFLAGS_DEVICE_PRESENT)) ||
             (deviceExtension->DeviceFlags[targetId] & DFLAGS_ATAPI_DEVICE)) {

            return SRB_STATUS_SELECTION_TIMEOUT;
        }

        deviceExtension->SmartCommand = cmdInParameters.irDriveRegs.bFeaturesReg;

        //
        // Determine which of the commands to carry out.
        //

        if ((cmdInParameters.irDriveRegs.bFeaturesReg == READ_ATTRIBUTES) ||
            (cmdInParameters.irDriveRegs.bFeaturesReg == READ_THRESHOLDS)) {

            WaitOnBusy(baseIoAddress1,statusByte);

            if (statusByte & IDE_STATUS_BUSY) {
                DebugPrint((1,
                            "IdeSendSmartCommand: Returning BUSY status\n"));
                return SRB_STATUS_BUSY;
            }

            //
            // Zero the ouput buffer as the input buffer info. has been saved off locally (the buffers are the same).
            //

            for (i = 0; i < (sizeof(SENDCMDOUTPARAMS) + READ_ATTRIBUTE_BUFFER_SIZE - 1); i++) {
                ((PUCHAR)cmdOutParameters)[i] = 0;
            }

            //
            // Set data buffer pointer and words left.
            //

            deviceExtension->DataBuffer = (PUSHORT)cmdOutParameters->bBuffer;
            deviceExtension->WordsLeft = READ_ATTRIBUTE_BUFFER_SIZE / 2;

            //
            // Indicate expecting an interrupt.
            //

            deviceExtension->ExpectingInterrupt = TRUE;

            ScsiPortWritePortUchar(&baseIoAddress1->DriveSelect,(UCHAR)(((targetId & 0x1) << 4) | 0xA0));
            ScsiPortWritePortUchar((PUCHAR)baseIoAddress1 + 1,regs->bFeaturesReg);
            ScsiPortWritePortUchar(&baseIoAddress1->BlockCount,regs->bSectorCountReg);
            ScsiPortWritePortUchar(&baseIoAddress1->BlockNumber,regs->bSectorNumberReg);
            ScsiPortWritePortUchar(&baseIoAddress1->CylinderLow,regs->bCylLowReg);
            ScsiPortWritePortUchar(&baseIoAddress1->CylinderHigh,regs->bCylHighReg);
            ScsiPortWritePortUchar(&baseIoAddress1->Command,regs->bCommandReg);

            //
            // Wait for interrupt.
            //

            return SRB_STATUS_PENDING;

        } else if ((cmdInParameters.irDriveRegs.bFeaturesReg == ENABLE_SMART) ||
                   (cmdInParameters.irDriveRegs.bFeaturesReg == DISABLE_SMART) ||
                   (cmdInParameters.irDriveRegs.bFeaturesReg == RETURN_SMART_STATUS) ||
                   (cmdInParameters.irDriveRegs.bFeaturesReg == ENABLE_DISABLE_AUTOSAVE) ||
                   (cmdInParameters.irDriveRegs.bFeaturesReg == EXECUTE_OFFLINE_DIAGS) ||
                   (cmdInParameters.irDriveRegs.bFeaturesReg == SAVE_ATTRIBUTE_VALUES)) {

            WaitOnBusy(baseIoAddress1,statusByte);

            if (statusByte & IDE_STATUS_BUSY) {
                DebugPrint((1,
                            "IdeSendSmartCommand: Returning BUSY status\n"));
                return SRB_STATUS_BUSY;
            }

            //
            // Zero the ouput buffer as the input buffer info. has been saved off locally (the buffers are the same).
            //

            for (i = 0; i < (sizeof(SENDCMDOUTPARAMS) - 1); i++) {
                ((PUCHAR)cmdOutParameters)[i] = 0;
            }

            //
            // Set data buffer pointer and indicate no data transfer.
            //

            deviceExtension->DataBuffer = (PUSHORT)cmdOutParameters->bBuffer;
            deviceExtension->WordsLeft = 0;

            //
            // Indicate expecting an interrupt.
            //

            deviceExtension->ExpectingInterrupt = TRUE;

            ScsiPortWritePortUchar(&baseIoAddress1->DriveSelect,(UCHAR)(((targetId & 0x1) << 4) | 0xA0));
            ScsiPortWritePortUchar((PUCHAR)baseIoAddress1 + 1,regs->bFeaturesReg);
            ScsiPortWritePortUchar(&baseIoAddress1->BlockCount,regs->bSectorCountReg);
            ScsiPortWritePortUchar(&baseIoAddress1->BlockNumber,regs->bSectorNumberReg);
            ScsiPortWritePortUchar(&baseIoAddress1->CylinderLow,regs->bCylLowReg);
            ScsiPortWritePortUchar(&baseIoAddress1->CylinderHigh,regs->bCylHighReg);
            ScsiPortWritePortUchar(&baseIoAddress1->Command,regs->bCommandReg);

            //
            // Wait for interrupt.
            //

            return SRB_STATUS_PENDING;
        }
    }

    return SRB_STATUS_INVALID_REQUEST;

} // end IdeSendSmartCommand()


ULONG
IdeReadWrite(
    IN PVOID HwDeviceExtension,
    IN PSCSI_REQUEST_BLOCK Srb
    )

/*++

Routine Description:

    This routine handles IDE read and writes.

Arguments:

    HwDeviceExtension - HBA miniport driver's adapter data storage
    Srb - IO request packet

Return Value:

    SRB status

--*/

{
    PHW_DEVICE_EXTENSION deviceExtension = HwDeviceExtension;
    PIDE_REGISTERS_1     baseIoAddress1  = deviceExtension->BaseIoAddress1[Srb->TargetId >> 1];
    PIDE_REGISTERS_2     baseIoAddress2  = deviceExtension->BaseIoAddress2[Srb->TargetId >> 1];
    ULONG                startingSector,i;
    ULONG                wordCount;
    UCHAR                statusByte,statusByte2;
    UCHAR                cylinderHigh,cylinderLow,drvSelect,sectorNumber;

    //
    // Select device 0 or 1.
    //

    ScsiPortWritePortUchar(&baseIoAddress1->DriveSelect,
                            (UCHAR)(((Srb->TargetId & 0x1) << 4) | 0xA0));

    WaitOnBusy(baseIoAddress1,statusByte2);

    if (statusByte2 & IDE_STATUS_BUSY) {
        DebugPrint((1,
                    "IdeReadWrite: Returning BUSY status\n"));
        return SRB_STATUS_BUSY;
    }

    if (deviceExtension->DeviceFlags[Srb->TargetId] & DFLAGS_USE_DMA) {
        if (!PrepareForBusMastering(HwDeviceExtension, Srb))
            return SRB_STATUS_ERROR;
    }

    //
    // Set data buffer pointer and words left.
    //

    deviceExtension->DataBuffer = (PUSHORT)Srb->DataBuffer;
    deviceExtension->WordsLeft = Srb->DataTransferLength / 2;

    //
    // Indicate expecting an interrupt.
    //

    deviceExtension->ExpectingInterrupt = TRUE;

    //
    // Set up sector count register. Round up to next block.
    //

    ScsiPortWritePortUchar(&baseIoAddress1->BlockCount,
                           (UCHAR)((Srb->DataTransferLength + 0x1FF) / 0x200));

    //
    // Get starting sector number from CDB.
    //

    startingSector = ((PCDB)Srb->Cdb)->CDB10.LogicalBlockByte3 |
                     ((PCDB)Srb->Cdb)->CDB10.LogicalBlockByte2 << 8 |
                     ((PCDB)Srb->Cdb)->CDB10.LogicalBlockByte1 << 16 |
                     ((PCDB)Srb->Cdb)->CDB10.LogicalBlockByte0 << 24;

    DebugPrint((2,
               "IdeReadWrite: Starting sector is %x, Number of bytes %x\n",
               startingSector,
               Srb->DataTransferLength));

    if (deviceExtension->DeviceFlags[Srb->TargetId] & DFLAGS_LBA) {

        ScsiPortWritePortUchar(&baseIoAddress1->DriveSelect,
                               (UCHAR) (((Srb->TargetId & 0x1) << 4) |
                                        0xA0 |
                                        IDE_LBA_MODE |
                                        ((startingSector & 0x0f000000) >> 24)));

        ScsiPortWritePortUchar(&baseIoAddress1->BlockNumber,
                               (UCHAR) ((startingSector & 0x000000ff) >> 0));
        ScsiPortWritePortUchar(&baseIoAddress1->CylinderLow,
                               (UCHAR) ((startingSector & 0x0000ff00) >> 8));
        ScsiPortWritePortUchar(&baseIoAddress1->CylinderHigh,
                               (UCHAR) ((startingSector & 0x00ff0000) >> 16));

    } else {  //CHS

        //
        // Set up sector number register.
        //

        sectorNumber =  (UCHAR)((startingSector % deviceExtension->IdentifyData[Srb->TargetId].SectorsPerTrack) + 1);
        ScsiPortWritePortUchar(&baseIoAddress1->BlockNumber,sectorNumber);

        //
        // Set up cylinder low register.
        //

        cylinderLow =  (UCHAR)(startingSector / (deviceExtension->IdentifyData[Srb->TargetId].SectorsPerTrack *
                               deviceExtension->IdentifyData[Srb->TargetId].NumberOfHeads));
        ScsiPortWritePortUchar(&baseIoAddress1->CylinderLow,cylinderLow);

        //
        // Set up cylinder high register.
        //

        cylinderHigh = (UCHAR)((startingSector / (deviceExtension->IdentifyData[Srb->TargetId].SectorsPerTrack *
                               deviceExtension->IdentifyData[Srb->TargetId].NumberOfHeads)) >> 8);
        ScsiPortWritePortUchar(&baseIoAddress1->CylinderHigh,cylinderHigh);

        //
        // Set up head and drive select register.
        //

        drvSelect = (UCHAR)(((startingSector / deviceExtension->IdentifyData[Srb->TargetId].SectorsPerTrack) %
                          deviceExtension->IdentifyData[Srb->TargetId].NumberOfHeads) |((Srb->TargetId & 0x1) << 4) | 0xA0);
        ScsiPortWritePortUchar(&baseIoAddress1->DriveSelect,drvSelect);

        DebugPrint((2,
                   "IdeReadWrite: Cylinder %x Head %x Sector %x\n",
                   startingSector /
                   (deviceExtension->IdentifyData[Srb->TargetId].SectorsPerTrack *
                   deviceExtension->IdentifyData[Srb->TargetId].NumberOfHeads),
                   (startingSector /
                   deviceExtension->IdentifyData[Srb->TargetId].SectorsPerTrack) %
                   deviceExtension->IdentifyData[Srb->TargetId].NumberOfHeads,
                   startingSector %
                   deviceExtension->IdentifyData[Srb->TargetId].SectorsPerTrack + 1));
    }

    //
    // Check if write request.
    //

    if (Srb->SrbFlags & SRB_FLAGS_DATA_IN) {

        //
        // Send read command.
        //
        ScsiPortWritePortUchar(&baseIoAddress1->Command,
                               deviceExtension->DeviceParameters[Srb->TargetId].IdeReadCommand);

    } else {


        //
        // Send write command.
        //

        ScsiPortWritePortUchar(&baseIoAddress1->Command,
                               deviceExtension->DeviceParameters[Srb->TargetId].IdeWriteCommand);

        if (!(deviceExtension->DeviceFlags[Srb->TargetId] & DFLAGS_USE_DMA)) {

            if (deviceExtension->WordsLeft < deviceExtension->DeviceParameters[Srb->TargetId].MaxWordPerInterrupt) {
                wordCount = deviceExtension->WordsLeft;
            } else {
                wordCount = deviceExtension->DeviceParameters[Srb->TargetId].MaxWordPerInterrupt;
            }
            //
            // Wait for BSY and DRQ.
            //

            WaitOnBaseBusy(baseIoAddress1,statusByte);

            if (statusByte & IDE_STATUS_BUSY) {

                DebugPrint((1,
                            "IdeReadWrite 2: Returning BUSY status %x\n",
                            statusByte));
                return SRB_STATUS_BUSY;
            }

            for (i = 0; i < 1000; i++) {
                GetBaseStatus(baseIoAddress1, statusByte);
                if (statusByte & IDE_STATUS_DRQ) {
                    break;
                }
                ScsiPortStallExecution(200);

            }

            if (!(statusByte & IDE_STATUS_DRQ)) {

                DebugPrint((1,
                           "IdeReadWrite: DRQ never asserted (%x) original status (%x)\n",
                           statusByte,
                           statusByte2));

                deviceExtension->WordsLeft = 0;

                //
                // Clear interrupt expecting flag.
                //

                deviceExtension->ExpectingInterrupt = FALSE;

                //
                // Clear current SRB.
                //

                deviceExtension->CurrentSrb = NULL;

                return SRB_STATUS_TIMEOUT;
            }

            //
            // Write next 256 words.
            //

            WriteBuffer(baseIoAddress1,
                        deviceExtension->DataBuffer,
                        wordCount);

            //
            // Adjust buffer address and words left count.
            //

            deviceExtension->WordsLeft -= wordCount;
            deviceExtension->DataBuffer += wordCount;

        }
    }

    if (deviceExtension->DeviceFlags[Srb->TargetId] & DFLAGS_USE_DMA) {
        EnableBusMastering(HwDeviceExtension, Srb);
    }

    //
    // Wait for interrupt.
    //

    return SRB_STATUS_PENDING;

} // end IdeReadWrite()



ULONG
IdeVerify(
    IN PVOID HwDeviceExtension,
    IN PSCSI_REQUEST_BLOCK Srb
    )

/*++

Routine Description:

    This routine handles IDE Verify.

Arguments:

    HwDeviceExtension - HBA miniport driver's adapter data storage
    Srb - IO request packet

Return Value:

    SRB status

--*/

{
    PHW_DEVICE_EXTENSION deviceExtension = HwDeviceExtension;
    PIDE_REGISTERS_1     baseIoAddress1  = deviceExtension->BaseIoAddress1[Srb->TargetId >> 1];
    PIDE_REGISTERS_2     baseIoAddress2  = deviceExtension->BaseIoAddress2[Srb->TargetId >> 1];
    ULONG                startingSector;
    ULONG                sectors;
    ULONG                endSector;
    USHORT               sectorCount;

    //
    // Drive has these number sectors.
    //

    sectors = deviceExtension->IdentifyData[Srb->TargetId].SectorsPerTrack *
              deviceExtension->IdentifyData[Srb->TargetId].NumberOfHeads *
              deviceExtension->IdentifyData[Srb->TargetId].NumberOfCylinders;

    DebugPrint((3,
                "IdeVerify: Total sectors %x\n",
                sectors));

    //
    // Get starting sector number from CDB.
    //

    startingSector = ((PCDB)Srb->Cdb)->CDB10.LogicalBlockByte3 |
                     ((PCDB)Srb->Cdb)->CDB10.LogicalBlockByte2 << 8 |
                     ((PCDB)Srb->Cdb)->CDB10.LogicalBlockByte1 << 16 |
                     ((PCDB)Srb->Cdb)->CDB10.LogicalBlockByte0 << 24;

    DebugPrint((3,
                "IdeVerify: Starting sector %x. Number of blocks %x\n",
                startingSector,
                ((PCDB)Srb->Cdb)->CDB10.TransferBlocksLsb));

    sectorCount = (USHORT)(((PCDB)Srb->Cdb)->CDB10.TransferBlocksMsb << 8 |
                           ((PCDB)Srb->Cdb)->CDB10.TransferBlocksLsb );
    endSector = startingSector + sectorCount;

    DebugPrint((3,
                "IdeVerify: Ending sector %x\n",
                endSector));

    if (endSector > sectors) {

        //
        // Too big, round down.
        //

        DebugPrint((1,
                    "IdeVerify: Truncating request to %x blocks\n",
                    sectors - startingSector - 1));

        ScsiPortWritePortUchar(&baseIoAddress1->BlockCount,
                               (UCHAR)(sectors - startingSector - 1));

    } else {

        //
        // Set up sector count register. Round up to next block.
        //

        if (sectorCount > 0xFF) {
            sectorCount = (USHORT)0xFF;
        }

        ScsiPortWritePortUchar(&baseIoAddress1->BlockCount,(UCHAR)sectorCount);
    }

    //
    // Set data buffer pointer and words left.
    //

    deviceExtension->DataBuffer = (PUSHORT)Srb->DataBuffer;
    deviceExtension->WordsLeft = Srb->DataTransferLength / 2;

    //
    // Indicate expecting an interrupt.
    //

    deviceExtension->ExpectingInterrupt = TRUE;


    if (deviceExtension->DeviceFlags[Srb->TargetId] & DFLAGS_LBA) { // LBA

        ScsiPortWritePortUchar(&baseIoAddress1->BlockNumber,
                               (UCHAR) ((startingSector & 0x000000ff) >> 0));

        ScsiPortWritePortUchar(&baseIoAddress1->CylinderLow,
                               (UCHAR) ((startingSector & 0x0000ff00) >> 8));

        ScsiPortWritePortUchar(&baseIoAddress1->CylinderHigh,
                               (UCHAR) ((startingSector & 0x00ff0000) >> 16));

        ScsiPortWritePortUchar(&baseIoAddress1->DriveSelect,
                               (UCHAR) (((Srb->TargetId & 0x1) << 4) |
                                        0xA0 |
                                        IDE_LBA_MODE |
                                        (startingSector & 0x0f000000 >> 24)));

        DebugPrint((2,
                   "IdeVerify: LBA: startingSector %x\n",
                   startingSector));

    } else {  //CHS

        //
        // Set up sector number register.
        //

        ScsiPortWritePortUchar(&baseIoAddress1->BlockNumber,
                               (UCHAR)((startingSector %
                               deviceExtension->IdentifyData[Srb->TargetId].SectorsPerTrack) + 1));

        //
        // Set up cylinder low register.
        //

        ScsiPortWritePortUchar(&baseIoAddress1->CylinderLow,
                               (UCHAR)(startingSector /
                               (deviceExtension->IdentifyData[Srb->TargetId].SectorsPerTrack *
                               deviceExtension->IdentifyData[Srb->TargetId].NumberOfHeads)));

        //
        // Set up cylinder high register.
        //

        ScsiPortWritePortUchar(&baseIoAddress1->CylinderHigh,
                               (UCHAR)((startingSector /
                               (deviceExtension->IdentifyData[Srb->TargetId].SectorsPerTrack *
                               deviceExtension->IdentifyData[Srb->TargetId].NumberOfHeads)) >> 8));

        //
        // Set up head and drive select register.
        //

        ScsiPortWritePortUchar(&baseIoAddress1->DriveSelect,
                               (UCHAR)(((startingSector /
                               deviceExtension->IdentifyData[Srb->TargetId].SectorsPerTrack) %
                               deviceExtension->IdentifyData[Srb->TargetId].NumberOfHeads) |
                               ((Srb->TargetId & 0x1) << 4) | 0xA0));

        DebugPrint((2,
                   "IdeVerify: CHS: Cylinder %x Head %x Sector %x\n",
                   startingSector /
                   (deviceExtension->IdentifyData[Srb->TargetId].SectorsPerTrack *
                   deviceExtension->IdentifyData[Srb->TargetId].NumberOfHeads),
                   (startingSector /
                   deviceExtension->IdentifyData[Srb->TargetId].SectorsPerTrack) %
                   deviceExtension->IdentifyData[Srb->TargetId].NumberOfHeads,
                   startingSector %
                   deviceExtension->IdentifyData[Srb->TargetId].SectorsPerTrack + 1));
    }

    //
    // Send verify command.
    //

    ScsiPortWritePortUchar(&baseIoAddress1->Command,
                           IDE_COMMAND_VERIFY);

    //
    // Wait for interrupt.
    //

    return SRB_STATUS_PENDING;

} // end IdeVerify()


VOID
Scsi2Atapi(
    IN PSCSI_REQUEST_BLOCK Srb
    )

/*++

Routine Description:

    Convert SCSI packet command to Atapi packet command.

Arguments:

    Srb - IO request packet

Return Value:

    None

--*/
{
    //
    // Change the cdb length
    //

    Srb->CdbLength = 12;

    switch (Srb->Cdb[0]) {
        case SCSIOP_MODE_SENSE: {
            PMODE_SENSE_10 modeSense10 = (PMODE_SENSE_10)Srb->Cdb;
            UCHAR PageCode = ((PCDB)Srb->Cdb)->MODE_SENSE.PageCode;
            UCHAR Length = ((PCDB)Srb->Cdb)->MODE_SENSE.AllocationLength;

            AtapiZeroMemory(Srb->Cdb,MAXIMUM_CDB_SIZE);

            modeSense10->OperationCode = ATAPI_MODE_SENSE;
            modeSense10->PageCode = PageCode;
            modeSense10->ParameterListLengthMsb = 0;
            modeSense10->ParameterListLengthLsb = Length;
            break;
        }

        case SCSIOP_MODE_SELECT: {
            PMODE_SELECT_10 modeSelect10 = (PMODE_SELECT_10)Srb->Cdb;
            UCHAR Length = ((PCDB)Srb->Cdb)->MODE_SELECT.ParameterListLength;

            //
            // Zero the original cdb
            //

            AtapiZeroMemory(Srb->Cdb,MAXIMUM_CDB_SIZE);

            modeSelect10->OperationCode = ATAPI_MODE_SELECT;
            modeSelect10->PFBit = 1;
            modeSelect10->ParameterListLengthMsb = 0;
            modeSelect10->ParameterListLengthLsb = Length;
            break;
        }

        case SCSIOP_FORMAT_UNIT:
        Srb->Cdb[0] = ATAPI_FORMAT_UNIT;
        break;
    }
}



ULONG
AtapiSendCommand(
    IN PVOID HwDeviceExtension,
    IN PSCSI_REQUEST_BLOCK Srb
    )

/*++

Routine Description:

    Send ATAPI packet command to device.

Arguments:

    HwDeviceExtension - HBA miniport driver's adapter data storage
    Srb - IO request packet

Return Value:


--*/

{
    PHW_DEVICE_EXTENSION deviceExtension = HwDeviceExtension;
    PATAPI_REGISTERS_1   baseIoAddress1  = (PATAPI_REGISTERS_1)deviceExtension->BaseIoAddress1[Srb->TargetId >> 1];
    PATAPI_REGISTERS_2   baseIoAddress2 =  (PATAPI_REGISTERS_2)deviceExtension->BaseIoAddress2[Srb->TargetId >> 1];
    ULONG i;
    ULONG flags;
    UCHAR statusByte,byteCountLow,byteCountHigh;

    //
    // We need to know how many platters our atapi cd-rom device might have.
    // Before anyone tries to send a srb to our target for the first time,
    // we must "secretly" send down a separate mechanism status srb in order to
    // initialize our device extension changer data.  That's how we know how
    // many platters our target has.
    //
    if (!(deviceExtension->DeviceFlags[Srb->TargetId] & DFLAGS_CHANGER_INITED) &&
        !deviceExtension->OriginalSrb) {

        ULONG srbStatus;

        //
        // Set this flag now. If the device hangs on the mech. status
        // command, we will not have the change to set it.
        //
        deviceExtension->DeviceFlags[Srb->TargetId] |= DFLAGS_CHANGER_INITED;

        deviceExtension->MechStatusRetryCount = 3;
        deviceExtension->CurrentSrb = BuildMechanismStatusSrb (
                                        HwDeviceExtension,
                                        Srb->PathId,
                                        Srb->TargetId);
        deviceExtension->OriginalSrb = Srb;

        srbStatus = AtapiSendCommand(HwDeviceExtension, deviceExtension->CurrentSrb);
        if (srbStatus == SRB_STATUS_PENDING) {
            return srbStatus;
        } else {
            deviceExtension->CurrentSrb = deviceExtension->OriginalSrb;
            deviceExtension->OriginalSrb = NULL;
            AtapiHwInitializeChanger (HwDeviceExtension,
                                      Srb->TargetId,
                                      (PMECHANICAL_STATUS_INFORMATION_HEADER) NULL);
            // fall out
        }
    }

    DebugPrint((2,
               "AtapiSendCommand: Command %x to TargetId %d lun %d\n",
               Srb->Cdb[0],
               Srb->TargetId,
               Srb->Lun));

    //
    // Make sure command is to ATAPI device.
    //

    flags = deviceExtension->DeviceFlags[Srb->TargetId];
    if (flags & (DFLAGS_SANYO_ATAPI_CHANGER | DFLAGS_ATAPI_CHANGER)) {
        if ((Srb->Lun) > (deviceExtension->DiscsPresent[Srb->TargetId] - 1)) {

            //
            // Indicate no device found at this address.
            //

            return SRB_STATUS_SELECTION_TIMEOUT;
        }
    } else if (Srb->Lun > 0) {
        return SRB_STATUS_SELECTION_TIMEOUT;
    }

    if (!(flags & DFLAGS_ATAPI_DEVICE)) {
        return SRB_STATUS_SELECTION_TIMEOUT;
    }

    //
    // Select device 0 or 1.
    //

    ScsiPortWritePortUchar(&baseIoAddress1->DriveSelect,
                           (UCHAR)(((Srb->TargetId & 0x1) << 4) | 0xA0));

    //
    // Verify that controller is ready for next command.
    //

    GetStatus(baseIoAddress1,statusByte);

    DebugPrint((2,
                "AtapiSendCommand: Entered with status %x\n",
                statusByte));

    if (statusByte & IDE_STATUS_BUSY) {
        DebugPrint((1,
                    "AtapiSendCommand: Device busy (%x)\n",
                    statusByte));
        return SRB_STATUS_BUSY;

    }

    if (statusByte & IDE_STATUS_ERROR) {
        if (Srb->Cdb[0] != SCSIOP_REQUEST_SENSE) {

            DebugPrint((1,
                        "AtapiSendCommand: Error on entry: (%x)\n",
                        statusByte));
            //
            // Read the error reg. to clear it and fail this request.
            //

            return MapError(deviceExtension,
                            Srb);
        }
    }

    //
    // If a tape drive has doesn't have DSC set and the last command is restrictive, don't send
    // the next command. See discussion of Restrictive Delayed Process commands in QIC-157.
    //

    if ((!(statusByte & IDE_STATUS_DSC)) &&
          (flags & DFLAGS_TAPE_DEVICE) && deviceExtension->RDP) {
        ScsiPortStallExecution(1000);
        DebugPrint((2,"AtapiSendCommand: DSC not set. %x\n",statusByte));
        return SRB_STATUS_BUSY;
    }

    if (IS_RDP(Srb->Cdb[0])) {

        deviceExtension->RDP = TRUE;

        DebugPrint((3,
                    "AtapiSendCommand: %x mapped as DSC restrictive\n",
                    Srb->Cdb[0]));

    } else {

        deviceExtension->RDP = FALSE;
    }

    if (statusByte & IDE_STATUS_DRQ) {

        DebugPrint((1,
                    "AtapiSendCommand: Entered with status (%x). Attempting to recover.\n",
                    statusByte));
        //
        // Try to drain the data that one preliminary device thinks that it has
        // to transfer. Hopefully this random assertion of DRQ will not be present
        // in production devices.
        //

        for (i = 0; i < 0x10000; i++) {

           GetStatus(baseIoAddress1, statusByte);

           if (statusByte & IDE_STATUS_DRQ) {

              ScsiPortReadPortUshort(&baseIoAddress1->Data);

           } else {

              break;
           }
        }

        if (i == 0x10000) {

            DebugPrint((1,
                        "AtapiSendCommand: DRQ still asserted.Status (%x)\n",
                        statusByte));

            AtapiSoftReset(baseIoAddress1,Srb->TargetId, FALSE);

            DebugPrint((1,
                         "AtapiSendCommand: Issued soft reset to Atapi device. \n"));

            //
            // Re-initialize Atapi device.
            //

            IssueIdentify(HwDeviceExtension,
                          (Srb->TargetId & 0x1),
                          (Srb->TargetId >> 1),
                          IDE_COMMAND_ATAPI_IDENTIFY,
                          FALSE);

            //
            // Inform the port driver that the bus has been reset.
            //

            ScsiPortNotification(ResetDetected, HwDeviceExtension, 0);

            //
            // Clean up device extension fields that AtapiStartIo won't.
            //

            deviceExtension->ExpectingInterrupt = FALSE;
            deviceExtension->RDP = FALSE;

            return SRB_STATUS_BUS_RESET;

        }
    }

    if (flags & (DFLAGS_SANYO_ATAPI_CHANGER | DFLAGS_ATAPI_CHANGER)) {

        //
        // As the cdrom driver sets the LUN field in the cdb, it must be removed.
        //

        Srb->Cdb[1] &= ~0xE0;

        if ((Srb->Cdb[0] == SCSIOP_TEST_UNIT_READY) && (flags & DFLAGS_SANYO_ATAPI_CHANGER)) {

            //
            // Torisan changer. TUR's are overloaded to be platter switches.
            //

            Srb->Cdb[7] = Srb->Lun;

        }
    }

    switch (Srb->Cdb[0]) {

        //
        // Convert SCSI to ATAPI commands if needed
        //
        case SCSIOP_MODE_SENSE:
        case SCSIOP_MODE_SELECT:
        case SCSIOP_FORMAT_UNIT:
            if (!(flags & DFLAGS_TAPE_DEVICE)) {
                Scsi2Atapi(Srb);
            }

            break;

        case SCSIOP_RECEIVE:
        case SCSIOP_SEND:
        case SCSIOP_READ:
        case SCSIOP_WRITE:
            if (deviceExtension->DeviceFlags[Srb->TargetId] & DFLAGS_USE_DMA) {
                if (!PrepareForBusMastering(HwDeviceExtension, Srb))
                    return SRB_STATUS_ERROR;
            }
            break;

        default:
            break;
    }


    //
    // Set data buffer pointer and words left.
    //

    deviceExtension->DataBuffer = (PUSHORT)Srb->DataBuffer;
    deviceExtension->WordsLeft = Srb->DataTransferLength / 2;

    WaitOnBusy(baseIoAddress1,statusByte);

    //
    // Write transfer byte count to registers.
    //

    byteCountLow = (UCHAR)(Srb->DataTransferLength & 0xFF);
    byteCountHigh = (UCHAR)(Srb->DataTransferLength >> 8);

    if (Srb->DataTransferLength >= 0x10000) {
        byteCountLow = byteCountHigh = 0xFF;
    }

    ScsiPortWritePortUchar(&baseIoAddress1->ByteCountLow,byteCountLow);
    ScsiPortWritePortUchar(&baseIoAddress1->ByteCountHigh, byteCountHigh);

    ScsiPortWritePortUchar((PUCHAR)baseIoAddress1 + 1,0);
    if ((Srb->Cdb[0] == SCSIOP_READ)  || 
        (Srb->Cdb[0] == SCSIOP_WRITE) ||
        (Srb->Cdb[0] == SCSIOP_SEND)  || 
        (Srb->Cdb[0] == SCSIOP_RECEIVE)) {
        if (deviceExtension->DeviceFlags[Srb->TargetId] & DFLAGS_USE_DMA) {
            ScsiPortWritePortUchar((PUCHAR)baseIoAddress1 + 1, 0x1);
        }
    }

    if (flags & DFLAGS_INT_DRQ) {

        //
        // This device interrupts when ready to receive the packet.
        //
        // Write ATAPI packet command.
        //

        ScsiPortWritePortUchar(&baseIoAddress1->Command,
                               IDE_COMMAND_ATAPI_PACKET);

        DebugPrint((3,
                   "AtapiSendCommand: Wait for int. to send packet. Status (%x)\n",
                   statusByte));

        deviceExtension->ExpectingInterrupt = TRUE;

        return SRB_STATUS_PENDING;

    } else {

        //
        // Write ATAPI packet command.
        //

        ScsiPortWritePortUchar(&baseIoAddress1->Command,
                               IDE_COMMAND_ATAPI_PACKET);

        //
        // Wait for DRQ.
        //

        WaitOnBusy(baseIoAddress1, statusByte);
        WaitForDrq(baseIoAddress1, statusByte);

        if (!(statusByte & IDE_STATUS_DRQ)) {

            DebugPrint((1,
                       "AtapiSendCommand: DRQ never asserted (%x)\n",
                       statusByte));
            return SRB_STATUS_ERROR;
        }
    }

    //
    // Need to read status register.
    //

    GetBaseStatus(baseIoAddress1, statusByte);

    //
    // Send CDB to device.
    //

    WaitOnBusy(baseIoAddress1,statusByte);

    WriteBuffer(baseIoAddress1,
                (PUSHORT)Srb->Cdb,
                6);

    //
    // Indicate expecting an interrupt and wait for it.
    //

    deviceExtension->ExpectingInterrupt = TRUE;

    switch (Srb->Cdb[0]) {

        case SCSIOP_RECEIVE:
        case SCSIOP_SEND:
        case SCSIOP_READ:
        case SCSIOP_WRITE:
            if (deviceExtension->DeviceFlags[Srb->TargetId] & DFLAGS_USE_DMA) {
                EnableBusMastering(HwDeviceExtension, Srb);
            }
            break;

        default:
            break;
    }

    return SRB_STATUS_PENDING;

} // end AtapiSendCommand()

ULONG
IdeSendCommand(
    IN PVOID HwDeviceExtension,
    IN PSCSI_REQUEST_BLOCK Srb
    )

/*++

Routine Description:

    Program ATA registers for IDE disk transfer.

Arguments:

    HwDeviceExtension - ATAPI driver storage.
    Srb - System request block.

Return Value:

    SRB status (pending if all goes well).

--*/

{
    PHW_DEVICE_EXTENSION deviceExtension = HwDeviceExtension;
    PIDE_REGISTERS_1     baseIoAddress1  = deviceExtension->BaseIoAddress1[Srb->TargetId >> 1];
    PIDE_REGISTERS_2     baseIoAddress2  = deviceExtension->BaseIoAddress2[Srb->TargetId >> 1];
    PCDB cdb;

    UCHAR statusByte,errorByte;
    ULONG status;
    ULONG i;
    PMODE_PARAMETER_HEADER   modeData;

    DebugPrint((2,
               "IdeSendCommand: Command %x to device %d\n",
               Srb->Cdb[0],
               Srb->TargetId));



    switch (Srb->Cdb[0]) {
    case SCSIOP_INQUIRY:

        //
        // Filter out all TIDs but 0 and 1 since this is an IDE interface
        // which support up to two devices.
        //

        if ((Srb->Lun != 0) ||
            (!(deviceExtension->DeviceFlags[Srb->TargetId] & DFLAGS_DEVICE_PRESENT))) {

            //
            // Indicate no device found at this address.
            //

            status = SRB_STATUS_SELECTION_TIMEOUT;
            break;

        } else {

            PINQUIRYDATA    inquiryData  = Srb->DataBuffer;
            PIDENTIFY_DATA2 identifyData = &deviceExtension->IdentifyData[Srb->TargetId];

            //
            // Zero INQUIRY data structure.
            //

            for (i = 0; i < Srb->DataTransferLength; i++) {
               ((PUCHAR)Srb->DataBuffer)[i] = 0;
            }

            //
            // Standard IDE interface only supports disks.
            //

            inquiryData->DeviceType = DIRECT_ACCESS_DEVICE;

            //
            // Set the removable bit, if applicable.
            //

            if (deviceExtension->DeviceFlags[Srb->TargetId] & DFLAGS_REMOVABLE_DRIVE) {
                inquiryData->RemovableMedia = 1;
            }

            //
            // Fill in vendor identification fields.
            //

            for (i = 0; i < 20; i += 2) {
               inquiryData->VendorId[i] =
                   ((PUCHAR)identifyData->ModelNumber)[i + 1];
               inquiryData->VendorId[i+1] =
                   ((PUCHAR)identifyData->ModelNumber)[i];
            }

            //
            // Initialize unused portion of product id.
            //

            for (i = 0; i < 4; i++) {
               inquiryData->ProductId[12+i] = ' ';
            }

            //
            // Move firmware revision from IDENTIFY data to
            // product revision in INQUIRY data.
            //

            for (i = 0; i < 4; i += 2) {
               inquiryData->ProductRevisionLevel[i] =
                   ((PUCHAR)identifyData->FirmwareRevision)[i+1];
               inquiryData->ProductRevisionLevel[i+1] =
                   ((PUCHAR)identifyData->FirmwareRevision)[i];
            }

            status = SRB_STATUS_SUCCESS;
        }

        break;

    case SCSIOP_MODE_SENSE:

        //
        // This is used to determine of the media is write-protected.
        // Since IDE does not support mode sense then we will modify just the portion we need
        // so the higher level driver can determine if media is protected.
        //

        if (deviceExtension->DeviceFlags[Srb->TargetId] & DFLAGS_MEDIA_STATUS_ENABLED) {

            ScsiPortWritePortUchar(&baseIoAddress1->DriveSelect,
                             (UCHAR)(((Srb->TargetId & 0x1) << 4) | 0xA0));
            ScsiPortWritePortUchar(&baseIoAddress1->Command,IDE_COMMAND_GET_MEDIA_STATUS);
            WaitOnBusy(baseIoAddress1,statusByte);

            if (!(statusByte & IDE_STATUS_ERROR)){

                //
                // no error occured return success, media is not protected
                //

                deviceExtension->ExpectingInterrupt = FALSE;
                status = SRB_STATUS_SUCCESS;

            } else {

                //
                // error occured, handle it locally, clear interrupt
                //

                errorByte = ScsiPortReadPortUchar((PUCHAR)baseIoAddress1 + 1);

                GetBaseStatus(baseIoAddress1, statusByte);
                deviceExtension->ExpectingInterrupt = FALSE;
                status = SRB_STATUS_SUCCESS;

                if (errorByte & IDE_ERROR_DATA_ERROR) {

                   //
                   //media is write-protected, set bit in mode sense buffer
                   //

                   modeData = (PMODE_PARAMETER_HEADER)Srb->DataBuffer;

                   Srb->DataTransferLength = sizeof(MODE_PARAMETER_HEADER);
                   modeData->DeviceSpecificParameter |= MODE_DSP_WRITE_PROTECT;
                }
            }
            status = SRB_STATUS_SUCCESS;
        } else {
            status = SRB_STATUS_INVALID_REQUEST;
        }
        break;

    case SCSIOP_TEST_UNIT_READY:

        if (deviceExtension->DeviceFlags[Srb->TargetId] & DFLAGS_MEDIA_STATUS_ENABLED) {

            //
            // Select device 0 or 1.
            //

            ScsiPortWritePortUchar(&baseIoAddress1->DriveSelect,
                            (UCHAR)(((Srb->TargetId & 0x1) << 4) | 0xA0));
            ScsiPortWritePortUchar(&baseIoAddress1->Command,IDE_COMMAND_GET_MEDIA_STATUS);

            //
            // Wait for busy. If media has not changed, return success
            //

            WaitOnBusy(baseIoAddress1,statusByte);

            if (!(statusByte & IDE_STATUS_ERROR)){
                deviceExtension->ExpectingInterrupt = FALSE;
                status = SRB_STATUS_SUCCESS;
            } else {
                errorByte = ScsiPortReadPortUchar((PUCHAR)baseIoAddress1 + 1);
                if (errorByte == IDE_ERROR_DATA_ERROR){

                    //
                    // Special case: If current media is write-protected,
                    // the 0xDA command will always fail since the write-protect bit
                    // is sticky,so we can ignore this error
                    //

                   GetBaseStatus(baseIoAddress1, statusByte);
                   deviceExtension->ExpectingInterrupt = FALSE;
                   status = SRB_STATUS_SUCCESS;

                } else {

                    //
                    // Request sense buffer to be build
                    //
                    deviceExtension->ExpectingInterrupt = TRUE;
                    status = SRB_STATUS_PENDING;
               }
            }
        } else {
            status = SRB_STATUS_SUCCESS;
        }

        break;

    case SCSIOP_READ_CAPACITY:

        //
        // Claim 512 byte blocks (big-endian).
        //

        ((PREAD_CAPACITY_DATA)Srb->DataBuffer)->BytesPerBlock = 0x20000;

        //
        // Calculate last sector.
        //
        if (deviceExtension->DeviceFlags[Srb->TargetId] & DFLAGS_LBA) {
            // LBA device
            i = deviceExtension->IdentifyData[Srb->TargetId].UserAddressableSectors - 1;

            DebugPrint((1,
                       "IDE LBA disk %x - total # of sectors = 0x%x\n",
                       Srb->TargetId,
                       deviceExtension->IdentifyData[Srb->TargetId].UserAddressableSectors));

        } else {
            // CHS device
            i = (deviceExtension->IdentifyData[Srb->TargetId].NumberOfHeads *
                 deviceExtension->IdentifyData[Srb->TargetId].NumberOfCylinders *
                 deviceExtension->IdentifyData[Srb->TargetId].SectorsPerTrack) - 1;

            DebugPrint((1,
                       "IDE CHS disk %x - #sectors %x, #heads %x, #cylinders %x\n",
                       Srb->TargetId,
                       deviceExtension->IdentifyData[Srb->TargetId].SectorsPerTrack,
                       deviceExtension->IdentifyData[Srb->TargetId].NumberOfHeads,
                       deviceExtension->IdentifyData[Srb->TargetId].NumberOfCylinders));

        }

        ((PREAD_CAPACITY_DATA)Srb->DataBuffer)->LogicalBlockAddress =
           (((PUCHAR)&i)[0] << 24) |  (((PUCHAR)&i)[1] << 16) |
           (((PUCHAR)&i)[2] << 8) | ((PUCHAR)&i)[3];


        status = SRB_STATUS_SUCCESS;
        break;

    case SCSIOP_VERIFY:
       status = IdeVerify(HwDeviceExtension,Srb);

       break;

    case SCSIOP_READ:
    case SCSIOP_WRITE:

       status = IdeReadWrite(HwDeviceExtension,
                                  Srb);
       break;

    case SCSIOP_START_STOP_UNIT:

       //
       //Determine what type of operation we should perform
       //
       cdb = (PCDB)Srb->Cdb;

       if (cdb->START_STOP.LoadEject == 1){

           //
           // Eject media,
           // first select device 0 or 1.
           //
           WaitOnBusy(baseIoAddress1,statusByte);

           ScsiPortWritePortUchar(&baseIoAddress1->DriveSelect,
                            (UCHAR)(((Srb->TargetId & 0x1) << 4) | 0xA0));
           ScsiPortWritePortUchar(&baseIoAddress1->Command,IDE_COMMAND_MEDIA_EJECT);
       }
       status = SRB_STATUS_SUCCESS;
       break;

    case SCSIOP_MEDIUM_REMOVAL:

       cdb = (PCDB)Srb->Cdb;

       WaitOnBusy(baseIoAddress1,statusByte);

       ScsiPortWritePortUchar(&baseIoAddress1->DriveSelect,
                              (UCHAR)(((Srb->TargetId & 0x1) << 4) | 0xA0));
       if (cdb->MEDIA_REMOVAL.Prevent == TRUE) {
           ScsiPortWritePortUchar(&baseIoAddress1->Command,IDE_COMMAND_DOOR_LOCK);
       } else {
           ScsiPortWritePortUchar(&baseIoAddress1->Command,IDE_COMMAND_DOOR_UNLOCK);
       }
       status = SRB_STATUS_SUCCESS;
       break;

    case SCSIOP_REQUEST_SENSE:
       // this function makes sense buffers to report the results
       // of the original GET_MEDIA_STATUS command

       if (deviceExtension->DeviceFlags[Srb->TargetId] & DFLAGS_MEDIA_STATUS_ENABLED) {
           status = IdeBuildSenseBuffer(HwDeviceExtension,Srb);
           break;
       }

    // ATA_PASSTHORUGH
    case SCSIOP_ATA_PASSTHROUGH:
        {
            PIDEREGS pIdeReg;
            pIdeReg = (PIDEREGS) &(Srb->Cdb[2]);

            pIdeReg->bDriveHeadReg &= 0x0f;
            pIdeReg->bDriveHeadReg |= (UCHAR) (((Srb->TargetId & 0x1) << 4) | 0xA0);

            if (pIdeReg->bReserved == 0) {      // execute ATA command

                ScsiPortWritePortUchar(&baseIoAddress1->DriveSelect,  pIdeReg->bDriveHeadReg);
                ScsiPortWritePortUchar((PUCHAR)baseIoAddress1 + 1,    pIdeReg->bFeaturesReg);
                ScsiPortWritePortUchar(&baseIoAddress1->BlockCount,   pIdeReg->bSectorCountReg);
                ScsiPortWritePortUchar(&baseIoAddress1->BlockNumber,  pIdeReg->bSectorNumberReg);
                ScsiPortWritePortUchar(&baseIoAddress1->CylinderLow,  pIdeReg->bCylLowReg);
                ScsiPortWritePortUchar(&baseIoAddress1->CylinderHigh, pIdeReg->bCylHighReg);
                ScsiPortWritePortUchar(&baseIoAddress1->Command,      pIdeReg->bCommandReg);

                ScsiPortStallExecution(1);                  // wait for busy to be set
                WaitOnBusy(baseIoAddress1,statusByte);      // wait for busy to be clear
                GetBaseStatus(baseIoAddress1, statusByte);
                if (statusByte & (IDE_STATUS_BUSY | IDE_STATUS_ERROR)) {

                    if (Srb->SenseInfoBuffer) {

                        PSENSE_DATA  senseBuffer = (PSENSE_DATA)Srb->SenseInfoBuffer;

                        senseBuffer->ErrorCode = 0x70;
                        senseBuffer->Valid     = 1;
                        senseBuffer->AdditionalSenseLength = 0xb;
                        senseBuffer->SenseKey =  SCSI_SENSE_ABORTED_COMMAND;
                        senseBuffer->AdditionalSenseCode = 0;
                        senseBuffer->AdditionalSenseCodeQualifier = 0;

                        Srb->SrbStatus = SRB_STATUS_AUTOSENSE_VALID;
                        Srb->ScsiStatus = SCSISTAT_CHECK_CONDITION;
                    }
                    status = SRB_STATUS_ERROR;
                } else {

                    if (statusByte & IDE_STATUS_DRQ) {
                        if (Srb->SrbFlags & SRB_FLAGS_DATA_IN) {
                            ReadBuffer(baseIoAddress1,
                                       (PUSHORT) Srb->DataBuffer,
                                       Srb->DataTransferLength / 2);
                        } else if (Srb->SrbFlags & SRB_FLAGS_DATA_OUT) {
                            WriteBuffer(baseIoAddress1,
                                        (PUSHORT) Srb->DataBuffer,
                                        Srb->DataTransferLength / 2);
                        }
                    }
                    status = SRB_STATUS_SUCCESS;
                }

            } else { // read task register

                ScsiPortWritePortUchar(&baseIoAddress1->DriveSelect,  pIdeReg->bDriveHeadReg);

                pIdeReg = (PIDEREGS) Srb->DataBuffer;
                pIdeReg->bDriveHeadReg    = ScsiPortReadPortUchar(&baseIoAddress1->DriveSelect);
                pIdeReg->bFeaturesReg     = ScsiPortReadPortUchar((PUCHAR)baseIoAddress1 + 1);
                pIdeReg->bSectorCountReg  = ScsiPortReadPortUchar(&baseIoAddress1->BlockCount);
                pIdeReg->bSectorNumberReg = ScsiPortReadPortUchar(&baseIoAddress1->BlockNumber);
                pIdeReg->bCylLowReg       = ScsiPortReadPortUchar(&baseIoAddress1->CylinderLow);
                pIdeReg->bCylHighReg      = ScsiPortReadPortUchar(&baseIoAddress1->CylinderHigh);
                pIdeReg->bCommandReg      = ScsiPortReadPortUchar(&baseIoAddress1->Command);
                status = SRB_STATUS_SUCCESS;
            }
        }
    break;

    default:

       DebugPrint((1,
                  "IdeSendCommand: Unsupported command %x\n",
                  Srb->Cdb[0]));

       status = SRB_STATUS_INVALID_REQUEST;

    } // end switch

    return status;

} // end IdeSendCommand()

VOID
IdeMediaStatus(
    BOOLEAN EnableMSN,
    IN PVOID HwDeviceExtension,
    ULONG Channel
    )
/*++

Routine Description:

    Enables disables media status notification

Arguments:

HwDeviceExtension - ATAPI driver storage.

--*/

{
    PHW_DEVICE_EXTENSION deviceExtension = HwDeviceExtension;
    PIDE_REGISTERS_1     baseIoAddress = deviceExtension->BaseIoAddress1[Channel >> 1];
    UCHAR statusByte,errorByte;


    if (EnableMSN == TRUE){

        //
        // If supported enable Media Status Notification support
        //

        if ((deviceExtension->DeviceFlags[Channel] & DFLAGS_REMOVABLE_DRIVE)) {

            //
            // enable
            //
            ScsiPortWritePortUchar(&baseIoAddress->DriveSelect,
                                   (UCHAR)(((Channel & 0x1) << 4) | 0xA0));
            ScsiPortWritePortUchar((PUCHAR)baseIoAddress + 1,(UCHAR) (0x95));
            ScsiPortWritePortUchar(&baseIoAddress->Command,
                                   IDE_COMMAND_ENABLE_MEDIA_STATUS);

            WaitOnBaseBusy(baseIoAddress,statusByte);

            if (statusByte & IDE_STATUS_ERROR) {
                //
                // Read the error register.
                //
                errorByte = ScsiPortReadPortUchar((PUCHAR)baseIoAddress + 1);

                DebugPrint((1,
                            "IdeMediaStatus: Error enabling media status. Status %x, error byte %x\n",
                             statusByte,
                             errorByte));
            } else {
                deviceExtension->DeviceFlags[Channel] |= DFLAGS_MEDIA_STATUS_ENABLED;
                DebugPrint((1,"IdeMediaStatus: Media Status Notification Supported\n"));
                deviceExtension->ReturningMediaStatus = 0;

            }

        }
    } else { // end if EnableMSN == TRUE

        //
        // disable if previously enabled
        //
        if ((deviceExtension->DeviceFlags[Channel] & DFLAGS_MEDIA_STATUS_ENABLED)) {

            ScsiPortWritePortUchar(&baseIoAddress->DriveSelect,
                                   (UCHAR)(((Channel & 0x1) << 4) | 0xA0));
            ScsiPortWritePortUchar((PUCHAR)baseIoAddress + 1,(UCHAR) (0x31));
            ScsiPortWritePortUchar(&baseIoAddress->Command,
                                   IDE_COMMAND_ENABLE_MEDIA_STATUS);

            WaitOnBaseBusy(baseIoAddress,statusByte);
            deviceExtension->DeviceFlags[Channel] &= ~DFLAGS_MEDIA_STATUS_ENABLED;
        }


    }



}

ULONG
IdeBuildSenseBuffer(
    IN PVOID HwDeviceExtension,
    IN PSCSI_REQUEST_BLOCK Srb
    )

/*++

Routine Description:

    Builts an artificial sense buffer to report the results of a GET_MEDIA_STATUS
    command. This function is invoked to satisfy the SCSIOP_REQUEST_SENSE.
Arguments:

    HwDeviceExtension - ATAPI driver storage.
    Srb - System request block.

Return Value:

    SRB status (ALWAYS SUCCESS).

--*/

{
    PHW_DEVICE_EXTENSION deviceExtension = HwDeviceExtension;
    ULONG status;
    PSENSE_DATA  senseBuffer = (PSENSE_DATA)Srb->DataBuffer;


    if (senseBuffer){


        if(deviceExtension->ReturningMediaStatus & IDE_ERROR_MEDIA_CHANGE) {

            senseBuffer->ErrorCode = 0x70;
            senseBuffer->Valid     = 1;
            senseBuffer->AdditionalSenseLength = 0xb;
            senseBuffer->SenseKey =  SCSI_SENSE_UNIT_ATTENTION;
            senseBuffer->AdditionalSenseCode = SCSI_ADSENSE_MEDIUM_CHANGED;
            senseBuffer->AdditionalSenseCodeQualifier = 0;
        } else if(deviceExtension->ReturningMediaStatus & IDE_ERROR_MEDIA_CHANGE_REQ) {

            senseBuffer->ErrorCode = 0x70;
            senseBuffer->Valid     = 1;
            senseBuffer->AdditionalSenseLength = 0xb;
            senseBuffer->SenseKey =  SCSI_SENSE_UNIT_ATTENTION;
            senseBuffer->AdditionalSenseCode = SCSI_ADSENSE_MEDIUM_CHANGED;
            senseBuffer->AdditionalSenseCodeQualifier = 0;
        } else if(deviceExtension->ReturningMediaStatus & IDE_ERROR_END_OF_MEDIA) {

            senseBuffer->ErrorCode = 0x70;
            senseBuffer->Valid     = 1;
            senseBuffer->AdditionalSenseLength = 0xb;
            senseBuffer->SenseKey =  SCSI_SENSE_NOT_READY;
            senseBuffer->AdditionalSenseCode = SCSI_ADSENSE_NO_MEDIA_IN_DEVICE;
            senseBuffer->AdditionalSenseCodeQualifier = 0;
        } else if(deviceExtension->ReturningMediaStatus & IDE_ERROR_DATA_ERROR) {

            senseBuffer->ErrorCode = 0x70;
            senseBuffer->Valid     = 1;
            senseBuffer->AdditionalSenseLength = 0xb;
            senseBuffer->SenseKey =  SCSI_SENSE_DATA_PROTECT;
            senseBuffer->AdditionalSenseCode = 0;
            senseBuffer->AdditionalSenseCodeQualifier = 0;
        }
        return SRB_STATUS_SUCCESS;
    }
    return SRB_STATUS_ERROR;

}// End of IdeBuildSenseBuffer




BOOLEAN
AtapiStartIo(
    IN PVOID HwDeviceExtension,
    IN PSCSI_REQUEST_BLOCK Srb
    )

/*++

Routine Description:

    This routine is called from the SCSI port driver synchronized
    with the kernel to start an IO request.

Arguments:

    HwDeviceExtension - HBA miniport driver's adapter data storage
    Srb - IO request packet

Return Value:

    TRUE

--*/

{
    PHW_DEVICE_EXTENSION deviceExtension = HwDeviceExtension;
    ULONG status;

    //
    // Determine which function.
    //

    switch (Srb->Function) {

    case SRB_FUNCTION_EXECUTE_SCSI:

        //
        // Sanity check. Only one request can be outstanding on a
        // controller.
        //

        if (deviceExtension->CurrentSrb) {

            DebugPrint((1,
                       "AtapiStartIo: Already have a request!\n"));
            Srb->SrbStatus = SRB_STATUS_BUSY;
            ScsiPortNotification(RequestComplete,
                                 deviceExtension,
                                 Srb);
            return FALSE;
        }

        //
        // Indicate that a request is active on the controller.
        //

        deviceExtension->CurrentSrb = Srb;

        //
        // Send command to device.
        //

        // ATA_PASSTHORUGH
        if (Srb->Cdb[0] == SCSIOP_ATA_PASSTHROUGH) {

           status = IdeSendCommand(HwDeviceExtension,
                                   Srb);

        } else if (deviceExtension->DeviceFlags[Srb->TargetId] & DFLAGS_ATAPI_DEVICE) {

           status = AtapiSendCommand(HwDeviceExtension,
                                     Srb);

        } else if (deviceExtension->DeviceFlags[Srb->TargetId] & DFLAGS_DEVICE_PRESENT) {

           status = IdeSendCommand(HwDeviceExtension,
                                   Srb);
        } else {

            status = SRB_STATUS_SELECTION_TIMEOUT;
        }

        break;

    case SRB_FUNCTION_ABORT_COMMAND:

        //
        // Verify that SRB to abort is still outstanding.
        //

        if (!deviceExtension->CurrentSrb) {

            DebugPrint((1, "AtapiStartIo: SRB to abort already completed\n"));

            //
            // Complete abort SRB.
            //

            status = SRB_STATUS_ABORT_FAILED;

            break;
        }

        //
        // Abort function indicates that a request timed out.
        // Call reset routine. Card will only be reset if
        // status indicates something is wrong.
        // Fall through to reset code.
        //

    case SRB_FUNCTION_RESET_BUS:

        //
        // Reset Atapi and SCSI bus.
        //

        DebugPrint((1, "AtapiStartIo: Reset bus request received\n"));

        if (!AtapiResetController(deviceExtension,
                             Srb->PathId)) {

              DebugPrint((1,"AtapiStartIo: Reset bus failed\n"));

            //
            // Log reset failure.
            //

            ScsiPortLogError(
                HwDeviceExtension,
                NULL,
                0,
                0,
                0,
                SP_INTERNAL_ADAPTER_ERROR,
                5 << 8
                );

              status = SRB_STATUS_ERROR;

        } else {

              status = SRB_STATUS_SUCCESS;
        }

        break;

    case SRB_FUNCTION_IO_CONTROL:

        if (deviceExtension->CurrentSrb) {

            DebugPrint((1,
                       "AtapiStartIo: Already have a request!\n"));
            Srb->SrbStatus = SRB_STATUS_BUSY;
            ScsiPortNotification(RequestComplete,
                                 deviceExtension,
                                 Srb);
            return FALSE;
        }

        //
        // Indicate that a request is active on the controller.
        //

        deviceExtension->CurrentSrb = Srb;

        if (AtapiStringCmp( ((PSRB_IO_CONTROL)(Srb->DataBuffer))->Signature,"SCSIDISK",strlen("SCSIDISK"))) {

            DebugPrint((1,
                        "AtapiStartIo: IoControl signature incorrect. Send %s, expected %s\n",
                        ((PSRB_IO_CONTROL)(Srb->DataBuffer))->Signature,
                        "SCSIDISK"));

            status = SRB_STATUS_INVALID_REQUEST;
            break;
        }

        switch (((PSRB_IO_CONTROL)(Srb->DataBuffer))->ControlCode) {

            case IOCTL_SCSI_MINIPORT_SMART_VERSION: {

                PGETVERSIONINPARAMS versionParameters = (PGETVERSIONINPARAMS)(((PUCHAR)Srb->DataBuffer) + sizeof(SRB_IO_CONTROL));
                UCHAR deviceNumber;

                //
                // Version and revision per SMART 1.03
                //

                versionParameters->bVersion = 1;
                versionParameters->bRevision = 1;
                versionParameters->bReserved = 0;

                //
                // Indicate that support for IDE IDENTIFY, ATAPI IDENTIFY and SMART commands.
                //

                versionParameters->fCapabilities = (CAP_ATA_ID_CMD | CAP_ATAPI_ID_CMD | CAP_SMART_CMD);

                //
                // This is done because of how the IOCTL_SCSI_MINIPORT
                // determines 'targetid's'. Disk.sys places the real target id value
                // in the DeviceMap field. Once we do some parameter checking, the value passed
                // back to the application will be determined.
                //

                deviceNumber = versionParameters->bIDEDeviceMap;

                if (!(deviceExtension->DeviceFlags[Srb->TargetId] & DFLAGS_DEVICE_PRESENT) ||
                    (deviceExtension->DeviceFlags[Srb->TargetId] & DFLAGS_ATAPI_DEVICE)) {

                    status = SRB_STATUS_SELECTION_TIMEOUT;
                    break;
                }

                //
                // NOTE: This will only set the bit
                // corresponding to this drive's target id.
                // The bit mask is as follows:
                //
                //     Sec Pri
                //     S M S M
                //     3 2 1 0
                //

                if (deviceExtension->NumberChannels == 1) {
                    if (deviceExtension->PrimaryAddress) {
                        deviceNumber = 1 << Srb->TargetId;
                    } else {
                        deviceNumber = 4 << Srb->TargetId;
                    }
                } else {
                    deviceNumber = 1 << Srb->TargetId;
                }

                versionParameters->bIDEDeviceMap = deviceNumber;

                status = SRB_STATUS_SUCCESS;
                break;
            }

            case IOCTL_SCSI_MINIPORT_IDENTIFY: {

                PSENDCMDOUTPARAMS cmdOutParameters = (PSENDCMDOUTPARAMS)(((PUCHAR)Srb->DataBuffer) + sizeof(SRB_IO_CONTROL));
                SENDCMDINPARAMS   cmdInParameters = *(PSENDCMDINPARAMS)(((PUCHAR)Srb->DataBuffer) + sizeof(SRB_IO_CONTROL));
                ULONG             i;
                UCHAR             targetId;


                if (cmdInParameters.irDriveRegs.bCommandReg == ID_CMD) {

                    //
                    // Extract the target.
                    //

                    targetId = cmdInParameters.bDriveNumber;

                    if (!(deviceExtension->DeviceFlags[Srb->TargetId] & DFLAGS_DEVICE_PRESENT) ||
                         (deviceExtension->DeviceFlags[Srb->TargetId] & DFLAGS_ATAPI_DEVICE)) {

                        status = SRB_STATUS_SELECTION_TIMEOUT;
                        break;
                    }

                    //
                    // Zero the output buffer
                    //

                    for (i = 0; i < (sizeof(SENDCMDOUTPARAMS) + IDENTIFY_BUFFER_SIZE - 1); i++) {
                        ((PUCHAR)cmdOutParameters)[i] = 0;
                    }

                    //
                    // Build status block.
                    //

                    cmdOutParameters->cBufferSize = IDENTIFY_BUFFER_SIZE;
                    cmdOutParameters->DriverStatus.bDriverError = 0;
                    cmdOutParameters->DriverStatus.bIDEError = 0;

                    //
                    // Extract the identify data from the device extension.
                    //

                    ScsiPortMoveMemory (cmdOutParameters->bBuffer, &deviceExtension->IdentifyData[targetId], IDENTIFY_DATA_SIZE);

                    status = SRB_STATUS_SUCCESS;


                } else {
                    status = SRB_STATUS_INVALID_REQUEST;
                }
                break;
            }

            case  IOCTL_SCSI_MINIPORT_READ_SMART_ATTRIBS:
            case  IOCTL_SCSI_MINIPORT_READ_SMART_THRESHOLDS:
            case  IOCTL_SCSI_MINIPORT_ENABLE_SMART:
            case  IOCTL_SCSI_MINIPORT_DISABLE_SMART:
            case  IOCTL_SCSI_MINIPORT_RETURN_STATUS:
            case  IOCTL_SCSI_MINIPORT_ENABLE_DISABLE_AUTOSAVE:
            case  IOCTL_SCSI_MINIPORT_SAVE_ATTRIBUTE_VALUES:
            case  IOCTL_SCSI_MINIPORT_EXECUTE_OFFLINE_DIAGS:

                status = IdeSendSmartCommand(HwDeviceExtension,Srb);
                break;

            default :

                status = SRB_STATUS_INVALID_REQUEST;
                break;

        }

        break;

    default:

        //
        // Indicate unsupported command.
        //

        status = SRB_STATUS_INVALID_REQUEST;

        break;

    } // end switch

    //
    // Check if command complete.
    //

    if (status != SRB_STATUS_PENDING) {

        DebugPrint((2,
                   "AtapiStartIo: Srb %x complete with status %x\n",
                   Srb,
                   status));

        //
        // Clear current SRB.
        //

        deviceExtension->CurrentSrb = NULL;

        //
        // Set status in SRB.
        //

        Srb->SrbStatus = (UCHAR)status;

        //
        // Indicate command complete.
        //

        ScsiPortNotification(RequestComplete,
                             deviceExtension,
                             Srb);

        //
        // Indicate ready for next request.
        //

        ScsiPortNotification(NextRequest,
                             deviceExtension,
                             NULL);
    }

    return TRUE;

} // end AtapiStartIo()


ULONG
DriverEntry(
    IN PVOID DriverObject,
    IN PVOID Argument2
    )

/*++

Routine Description:

    Installable driver initialization entry point for system.

Arguments:

    Driver Object

Return Value:

    Status from ScsiPortInitialize()

--*/

{
    HW_INITIALIZATION_DATA  hwInitializationData;
//    ULONG                  adapterCount;
    ULONG                   i;
    ULONG                   statusToReturn, newStatus;
    FIND_STATE              findState;
    ULONG                   AdapterAddresses[5] = {0x1F0, 0x170, 0x1e8, 0x168, 0};
    ULONG                   InterruptLevels[5]  = {   14,    15,    11,    10, 0};
    BOOLEAN                 IoAddressUsed[5]    = {FALSE, FALSE, FALSE, FALSE, 0};

    DebugPrint((1,"\n\nATAPI IDE MiniPort Driver\n"));

    DebugPrintTickCount();

    statusToReturn = 0xffffffff;

    //
    // Zero out structure.
    //

    AtapiZeroMemory(((PUCHAR)&hwInitializationData), sizeof(HW_INITIALIZATION_DATA));

    AtapiZeroMemory(((PUCHAR)&findState), sizeof(FIND_STATE));


    findState.DefaultIoPort    = AdapterAddresses;
    findState.DefaultInterrupt = InterruptLevels;
    findState.IoAddressUsed    = IoAddressUsed;

    //
    // Set size of hwInitializationData.
    //

    hwInitializationData.HwInitializationDataSize =
      sizeof(HW_INITIALIZATION_DATA);

    //
    // Set entry points.
    //

    hwInitializationData.HwInitialize = AtapiHwInitialize;
    hwInitializationData.HwResetBus = AtapiResetController;
    hwInitializationData.HwStartIo = AtapiStartIo;
    hwInitializationData.HwInterrupt = AtapiInterrupt;

    //
    // Specify size of extensions.
    //

    hwInitializationData.DeviceExtensionSize = sizeof(HW_DEVICE_EXTENSION);
    hwInitializationData.SpecificLuExtensionSize = sizeof(HW_LU_EXTENSION);

    hwInitializationData.NumberOfAccessRanges = 6;
    hwInitializationData.HwFindAdapter = AtapiFindController;

    hwInitializationData.AdapterInterfaceType = Isa;
    findState.ControllerParameters            = PciControllerParameters;

    newStatus = ScsiPortInitialize(DriverObject,
                                   Argument2,
                                   &hwInitializationData,
                                   &findState);
    if (newStatus < statusToReturn)
        statusToReturn = newStatus;


    //
    // Set up for MCA
    //

    hwInitializationData.AdapterInterfaceType = MicroChannel;

    newStatus =  ScsiPortInitialize(DriverObject,
                                    Argument2,
                                    &hwInitializationData,
                                    &findState);
    if (newStatus < statusToReturn)
        statusToReturn = newStatus;

    DebugPrintTickCount();

    return statusToReturn;

} // end DriverEntry()



LONG
AtapiStringCmp (
    PCHAR FirstStr,
    PCHAR SecondStr,
    ULONG Count
    )
{
    UCHAR  first ,last;

    if (Count) {
        do {

            //
            // Get next char.
            //

            first = *FirstStr++;
            last = *SecondStr++;

            if (first != last) {

                //
                // If no match, try lower-casing.
                //

                if (first>='A' && first<='Z') {
                    first = first - 'A' + 'a';
                }
                if (last>='A' && last<='Z') {
                    last = last - 'A' + 'a';
                }
                if (first != last) {

                    //
                    // No match
                    //

                    return first - last;
                }
            }
        }while (--Count && first);
    }

    return 0;
}


VOID
AtapiZeroMemory(
    IN PCHAR Buffer,
    IN ULONG Count
    )
{
    ULONG i;

    for (i = 0; i < Count; i++) {
        Buffer[i] = 0;
    }
}


VOID
AtapiHexToString (
    IN ULONG Value,
    IN OUT PCHAR *Buffer
    )
{
    PCHAR  string;
    PCHAR  firstdig;
    CHAR   temp;
    ULONG i;
    USHORT digval;

    string = *Buffer;

    firstdig = string;

    for (i = 0; i < 4; i++) {
        digval = (USHORT)(Value % 16);
        Value /= 16;

        //
        // convert to ascii and store. Note this will create
        // the buffer with the digits reversed.
        //

        if (digval > 9) {
            *string++ = (char) (digval - 10 + 'a');
        } else {
            *string++ = (char) (digval + '0');
        }

    }

    //
    // Reverse the digits.
    //

    *string-- = '\0';

    do {
        temp = *string;
        *string = *firstdig;
        *firstdig = temp;
        --string;
        ++firstdig;
    } while (firstdig < string);
}



PSCSI_REQUEST_BLOCK
BuildMechanismStatusSrb (
    IN PVOID HwDeviceExtension,
    IN ULONG PathId,
    IN ULONG TargetId
    )
{
    PHW_DEVICE_EXTENSION deviceExtension = HwDeviceExtension;
    PSCSI_REQUEST_BLOCK srb;
    PCDB cdb;

    srb = &deviceExtension->InternalSrb;

    AtapiZeroMemory((PUCHAR) srb, sizeof(SCSI_REQUEST_BLOCK));

    srb->PathId     = (UCHAR) PathId;
    srb->TargetId   = (UCHAR) TargetId;
    srb->Function   = SRB_FUNCTION_EXECUTE_SCSI;
    srb->Length     = sizeof(SCSI_REQUEST_BLOCK);

    //
    // Set flags to disable synchronous negociation.
    //
    srb->SrbFlags = SRB_FLAGS_DATA_IN | SRB_FLAGS_DISABLE_SYNCH_TRANSFER;

    //
    // Set timeout to 2 seconds.
    //
    srb->TimeOutValue = 4;

    srb->CdbLength          = 6;
    srb->DataBuffer         = &deviceExtension->MechStatusData;
    srb->DataTransferLength = sizeof(MECHANICAL_STATUS_INFORMATION_HEADER);

    //
    // Set CDB operation code.
    //
    cdb = (PCDB)srb->Cdb;
    cdb->MECH_STATUS.OperationCode       = SCSIOP_MECHANISM_STATUS;
    cdb->MECH_STATUS.AllocationLength[1] = sizeof(MECHANICAL_STATUS_INFORMATION_HEADER);

    return srb;
}


PSCSI_REQUEST_BLOCK
BuildRequestSenseSrb (
    IN PVOID HwDeviceExtension,
    IN ULONG PathId,
    IN ULONG TargetId
    )
{
    PHW_DEVICE_EXTENSION deviceExtension = HwDeviceExtension;
    PSCSI_REQUEST_BLOCK srb;
    PCDB cdb;

    srb = &deviceExtension->InternalSrb;

    AtapiZeroMemory((PUCHAR) srb, sizeof(SCSI_REQUEST_BLOCK));

    srb->PathId     = (UCHAR) PathId;
    srb->TargetId   = (UCHAR) TargetId;
    srb->Function   = SRB_FUNCTION_EXECUTE_SCSI;
    srb->Length     = sizeof(SCSI_REQUEST_BLOCK);

    //
    // Set flags to disable synchronous negociation.
    //
    srb->SrbFlags = SRB_FLAGS_DATA_IN | SRB_FLAGS_DISABLE_SYNCH_TRANSFER;

    //
    // Set timeout to 2 seconds.
    //
    srb->TimeOutValue = 4;

    srb->CdbLength          = 6;
    srb->DataBuffer         = &deviceExtension->MechStatusSense;
    srb->DataTransferLength = sizeof(SENSE_DATA);

    //
    // Set CDB operation code.
    //
    cdb = (PCDB)srb->Cdb;
    cdb->CDB6INQUIRY.OperationCode    = SCSIOP_REQUEST_SENSE;
    cdb->CDB6INQUIRY.AllocationLength = sizeof(SENSE_DATA);

    return srb;
}


BOOLEAN
PrepareForBusMastering(
    IN PVOID HwDeviceExtension,
    IN PSCSI_REQUEST_BLOCK Srb
    )
/*++

Routine Description:

    Get ready for IDE bus mastering

    init. PDRT
    init. bus master controller but keep it disabled

Arguments:

    HwDeviceExtension   - HBA miniport driver's adapter data storage
    Srb                 - scsi request block

Return Value:

    TRUE if successful
    FALSE if failed

--*/
{
    PHW_DEVICE_EXTENSION        deviceExtension = HwDeviceExtension;
    SCSI_PHYSICAL_ADDRESS       physAddr;
    ULONG                       bytesMapped;
    ULONG                       bytes;
    PUCHAR                      buffer;
    PPHYSICAL_REGION_DESCRIPTOR physAddrTablePtr;
    ULONG                       physAddrTableIndex;
    PIDE_BUS_MASTER_REGISTERS   busMasterBase;

    busMasterBase = deviceExtension->BusMasterPortBase[Srb->TargetId >> 1];

    buffer = Srb->DataBuffer;
    physAddrTablePtr = deviceExtension->DataBufferDescriptionTablePtr;
    physAddrTableIndex = 0;
    bytesMapped = 0;
    DebugPrint ((2, "ATAPI: Mapping 0x%x bytes\n", Srb->DataTransferLength));

    //
    // PDRT has these limitation
    //    each entry maps up to is 64K bytes
    //    each physical block mapped cannot cross 64K page boundary
    //
    while (bytesMapped < Srb->DataTransferLength) {
        ULONG bytesLeft;
        ULONG nextPhysicalAddr;
        ULONG bytesLeftInCurrent64KPage;

        physAddr = ScsiPortGetPhysicalAddress(HwDeviceExtension,
                                              Srb,
                                              buffer,
                                              &bytes);

        bytesLeft = bytes;
        nextPhysicalAddr = ScsiPortConvertPhysicalAddressToUlong(physAddr);
        while (bytesLeft > 0) {
            physAddrTablePtr[physAddrTableIndex].PhyscialAddress = nextPhysicalAddr;

            bytesLeftInCurrent64KPage = (0x10000 - (nextPhysicalAddr & 0xffff));

            if (bytesLeftInCurrent64KPage < bytesLeft) {

                //
                // Are we crossing 64K page
                // got to break it up.  Map up to the 64k boundary
                //
                physAddrTablePtr[physAddrTableIndex].ByteCount = bytesLeftInCurrent64KPage;
                bytesLeft -= bytesLeftInCurrent64KPage;
                nextPhysicalAddr += bytesLeftInCurrent64KPage;
                DebugPrint ((3, "PrepareForBusMastering: buffer crossing 64K Page!\n"));

            } else if (bytesLeft <= 0x10000) {
                //
                // got a perfect page, map all of it
                //
                physAddrTablePtr[physAddrTableIndex].ByteCount = bytesLeft & 0xfffe;
                bytesLeft = 0;
                nextPhysicalAddr += bytesLeft;

            } else {
                //
                // got a perfectly aligned 64k page, map all of it but the count
                // need to be 0
                //
                physAddrTablePtr[physAddrTableIndex].ByteCount = 0;  // 64K
                bytesLeft -= 0x10000;
                nextPhysicalAddr += 0x10000;
            }
        physAddrTablePtr[physAddrTableIndex].EndOfTable = 0;  // not end of table
        physAddrTableIndex++;
        }
        bytesMapped += bytes;
        buffer += bytes;
    }

    //
    // the bus master circutry need to know it hits the end of the PRDT
    //
    physAddrTablePtr[physAddrTableIndex - 1].EndOfTable = 1;  // end of table

    //
    // init bus master contoller, but keep it disabled
    //
    ScsiPortWritePortUchar (&busMasterBase->Command, 0);  // disable BM
    ScsiPortWritePortUchar (&busMasterBase->Status, 0x6);  // clear errors
    ScsiPortWritePortUlong (&busMasterBase->DescriptionTable,
        ScsiPortConvertPhysicalAddressToUlong(deviceExtension->DataBufferDescriptionTablePhysAddr));

    return TRUE;
}


BOOLEAN
EnableBusMastering(
    IN PVOID HwDeviceExtension,
    IN PSCSI_REQUEST_BLOCK Srb
    )
/*++

Routine Description:

    Enable bus mastering contoller

Arguments:

    HwDeviceExtension   - HBA miniport driver's adapter data storage
    Srb                 - scsi request block

Return Value:

    always TRUE

--*/
{
    PHW_DEVICE_EXTENSION deviceExtension = HwDeviceExtension;
    PIDE_BUS_MASTER_REGISTERS busMasterBase;
    UCHAR bmStatus = 0;

    busMasterBase = deviceExtension->BusMasterPortBase[Srb->TargetId >> 1];

    deviceExtension->DMAInProgress = TRUE;

    //
    // inidcate we are doing DMA
    //
    if (Srb->TargetId == 0)
        bmStatus = BUSMASTER_DEVICE0_DMA_OK;
    else
        bmStatus = BUSMASTER_DEVICE1_DMA_OK;

    //
    // clear the status bit
    //
    bmStatus |= BUSMASTER_INTERRUPT | BUSMASTER_ERROR;

    ScsiPortWritePortUchar (&busMasterBase->Status, bmStatus);

    //
    // on your mark...get set...go!!
    //
    if (Srb->SrbFlags & SRB_FLAGS_DATA_IN) {
        ScsiPortWritePortUchar (&busMasterBase->Command, 0x09);  // enable BM read
    } else {
        ScsiPortWritePortUchar (&busMasterBase->Command, 0x01);  // enable BM write
    }

    DebugPrint ((2, "ATAPI: BusMaster Status = 0x%x\n", ScsiPortReadPortUchar (&busMasterBase->Status)));

    return TRUE;
}



ULONG
GetPciBusData(
    IN PVOID                  HwDeviceExtension,
    IN ULONG                  SystemIoBusNumber,
    IN PCI_SLOT_NUMBER        SlotNumber,
    OUT PVOID                 PciConfigBuffer,
    IN ULONG                  NumByte
    )
/*++

Routine Description:

    read PCI bus data

    we can't always use ScsiPortSetBusDataByOffset directly because many Intel PIIXs
    are "hidden" from the function.  The PIIX is usually the second
    function of some other pci device (PCI-ISA bridge).  However, the
    mulit-function bit of the PCI-Isa bridge is not set. ScsiportGetBusData
    will not be able to find it.

    This function will try to figure out if we have the "bad" PCI-ISA bridge,
    and read the PIIX PCI space directly if necessary

Arguments:

    HwDeviceExtension   - HBA miniport driver's adapter data storage
    SystemIoBusNumber   - bus number
    SlotNumber          - pci slot and function numbers
    PciConfigBuffer     = pci data pointer

Return Value:

    byte returned

--*/
{
    ULONG           byteRead;
    PULONG          pciAddrReg;
    PULONG          pciDataReg;
    ULONG           i;
    ULONG           j;
    ULONG           data;
    PULONG          dataBuffer;

    USHORT          vendorId;
    USHORT          deviceId;
    UCHAR           headerType;

    //
    // If we have a hidden PIIX, it is always a function 1 of
    // some device (PCI-ISA bridge (0x8086\0x122e)
    // If we are NOT looking at function 1, skip the extra work
    //
    if (!AtapiPlaySafe && (SlotNumber.u.bits.FunctionNumber == 1)) {

        pciAddrReg = (PULONG) ScsiPortGetDeviceBase(HwDeviceExtension,
                                                    PCIBus,
                                                    0,
                                                    ScsiPortConvertUlongToPhysicalAddress(PCI_ADDR_PORT),
                                                    4,
                                                    TRUE);
        pciDataReg = (PULONG) ScsiPortGetDeviceBase(HwDeviceExtension,
                                                    PCIBus,
                                                    0,
                                                    ScsiPortConvertUlongToPhysicalAddress(PCI_DATA_PORT),
                                                    4,
                                                    TRUE);
    } else {
        pciAddrReg = pciDataReg = NULL;
    }

    if (pciAddrReg && pciDataReg) {
        //
        // get the vendor id and device id of the previous function
        //
        ScsiPortWritePortUlong(pciAddrReg, PCI_ADDRESS(SystemIoBusNumber,
                                                       SlotNumber.u.bits.DeviceNumber,
                                                       SlotNumber.u.bits.FunctionNumber - 1,    // looking at last function
                                                       0));
        data = ScsiPortReadPortUlong(pciDataReg);
        vendorId = (USHORT) ((data >>  0) & 0xffff);
        deviceId = (USHORT) ((data >> 16) & 0xffff);

        ScsiPortWritePortUlong(pciAddrReg, PCI_ADDRESS(SystemIoBusNumber,
                                                       SlotNumber.u.bits.DeviceNumber,
                                                       SlotNumber.u.bits.FunctionNumber - 1,    // looking at last function
                                                       3));
        data = ScsiPortReadPortUlong(pciDataReg);
        headerType = (UCHAR) ((data >> 16) & 0xff);

    } else {
        vendorId = PCI_INVALID_VENDORID;
    }

    //
    // The hidden PIIX is the pci function after the PCI-ISA bridge
    // When it is hidden, the PCI-ISA bridge PCI_MULTIFUNCTION bit is not set
    //
    byteRead = 0;
    if ((vendorId == 0x8086) &&                 // Intel
        (deviceId == 0x122e) &&                 // PCI-ISA Bridge
        !(headerType & PCI_MULTIFUNCTION)) {

        DebugPrint ((1, "ATAPI: found the hidden PIIX\n"));

        if (pciDataReg && pciAddrReg) {

            for (i=0, dataBuffer = (PULONG) PciConfigBuffer;
                 i < NumByte / 4;
                 i++, dataBuffer++) {
                ScsiPortWritePortUlong(pciAddrReg, PCI_ADDRESS(SystemIoBusNumber,
                                                               SlotNumber.u.bits.DeviceNumber,
                                                               SlotNumber.u.bits.FunctionNumber,
                                                               i));
                dataBuffer[0] = ScsiPortReadPortUlong(pciDataReg);
            }

            if (NumByte % 4) {
                ScsiPortWritePortUlong(pciAddrReg, PCI_ADDRESS(SystemIoBusNumber,
                                                               SlotNumber.u.bits.DeviceNumber,
                                                               SlotNumber.u.bits.FunctionNumber,
                                                               i));
                data = ScsiPortReadPortUlong(pciDataReg);
    
                for (j=0; j <NumByte%4; j++) {
                    ((PUCHAR)dataBuffer)[j] = (UCHAR) (data & 0xff);
                    data = data >> 8;
                }
            }
            byteRead = NumByte;
        }

        if ((((PPCI_COMMON_CONFIG)PciConfigBuffer)->VendorID != 0x8086) ||                 // Intel
            (((PPCI_COMMON_CONFIG)PciConfigBuffer)->DeviceID != 0x1230)) {                 // PIIX

            //
            // If the hidden device is not Intel PIIX, don't
            // show it
            //
            byteRead = 0;
        } else {
            DebugPrint ((0, "If we play safe, we would NOT detect hidden PIIX controller\n"));
        }

    }

    if (!byteRead) {
        //
        // Didn't find any hidden PIIX.  Get the PCI
        // data via the normal call (ScsiPortGetBusData)
        //
        byteRead = ScsiPortGetBusData(HwDeviceExtension,
                                      PCIConfiguration,
                                      SystemIoBusNumber,
                                      SlotNumber.u.AsULONG,
                                      PciConfigBuffer,
                                      NumByte);
    }

    if (pciAddrReg)
        ScsiPortFreeDeviceBase(HwDeviceExtension, pciAddrReg);
    if (pciDataReg)
        ScsiPortFreeDeviceBase(HwDeviceExtension, pciDataReg);

    return byteRead;
}


ULONG
SetPciBusData(
    IN PVOID              HwDeviceExtension,
    IN ULONG              SystemIoBusNumber,
    IN PCI_SLOT_NUMBER    SlotNumber,
    IN PVOID              Buffer,
    IN ULONG              Offset,
    IN ULONG              Length
    )
/*++

Routine Description:

    set PCI bus data

    we can't always use ScsiPortSetBusDataByOffset directly because many Intel PIIXs
    are "hidden" from the function.  The PIIX is usually the second
    function of some other pci device (PCI-ISA bridge).  However, the
    mulit-function bit of the PCI-Isa bridge is not set. ScsiPortSetBusDataByOffset
    will not be able to find it.

    This function will try to figure out if we have the "bad" PCI-ISA bridge,
    and write to the PIIX PCI space directly if necessary

Arguments:

    HwDeviceExtension   - HBA miniport driver's adapter data storage
    SystemIoBusNumber   - bus number
    SlotNumber          - pci slot and function numbers
    Buffer              - pci data buffer
    Offset              - byte offset into the pci space
    Length              - number of bytes to write

Return Value:

    byte written

--*/
{
    ULONG           byteWritten;
    PULONG          pciAddrReg;
    PULONG          pciDataReg;
    ULONG           i;
    ULONG           j;
    ULONG           data;
    PULONG          dataBuffer;

    USHORT          vendorId;
    USHORT          deviceId;
    UCHAR           headerType;

    //
    // If we have a hidden PIIX, it is always a function 1 of
    // some device (PCI-ISA bridge (0x8086\0x122e)
    // If we are NOT looking at function 1, skip the extra work
    //
    if (!AtapiPlaySafe && (SlotNumber.u.bits.FunctionNumber == 1)) {

        pciAddrReg = (PULONG) ScsiPortGetDeviceBase(HwDeviceExtension,
                                                    PCIBus,
                                                    0,
                                                    ScsiPortConvertUlongToPhysicalAddress(PCI_ADDR_PORT),
                                                    4,
                                                    TRUE);
        pciDataReg = (PULONG) ScsiPortGetDeviceBase(HwDeviceExtension,
                                                    PCIBus,
                                                    0,
                                                    ScsiPortConvertUlongToPhysicalAddress(PCI_DATA_PORT),
                                                    4,
                                                    TRUE);
    } else {
        pciAddrReg = pciDataReg = NULL;
    }

    if (pciAddrReg && pciDataReg) {
        //
        // get the vendor id and device id of the previous function
        //
        ScsiPortWritePortUlong(pciAddrReg, PCI_ADDRESS(SystemIoBusNumber,
                                                       SlotNumber.u.bits.DeviceNumber,
                                                       SlotNumber.u.bits.FunctionNumber - 1,    // looking at last function
                                                       0));
        data = ScsiPortReadPortUlong(pciDataReg);
        vendorId = (USHORT) ((data >>  0) & 0xffff);
        deviceId = (USHORT) ((data >> 16) & 0xffff);

        ScsiPortWritePortUlong(pciAddrReg, PCI_ADDRESS(SystemIoBusNumber,
                                                       SlotNumber.u.bits.DeviceNumber,
                                                       SlotNumber.u.bits.FunctionNumber - 1,    // looking at last function
                                                       3));
        data = ScsiPortReadPortUlong(pciDataReg);
        headerType = (UCHAR) ((data >> 16) & 0xff);

    } else {
        vendorId = PCI_INVALID_VENDORID;
    }

    //
    // The hidden PIIX is the pci function after the PCI-ISA bridge
    // When it is hidden, the PCI-ISA bridge PCI_MULTIFUNCTION bit is not set
    //
    byteWritten = 0;
    if ((vendorId == 0x8086) &&                 // Intel
        (deviceId == 0x122e) &&                 // PCI-ISA Bridge
        !(headerType & PCI_MULTIFUNCTION)) {

        ScsiPortWritePortUlong(pciAddrReg, PCI_ADDRESS(SystemIoBusNumber,
                                                       SlotNumber.u.bits.DeviceNumber,
                                                       SlotNumber.u.bits.FunctionNumber,
                                                       0));
        data = ScsiPortReadPortUlong(pciDataReg);
        vendorId = (USHORT) ((data >>  0) & 0xffff);
        deviceId = (USHORT) ((data >> 16) & 0xffff);

        if ((vendorId == 0x8086) &&                 // Intel
            (deviceId == 0x1230)) {                 // PIIX

            PCI_COMMON_CONFIG pciData;

            //
            // read the same range of data in first
            //
            for (i=0, dataBuffer = (((PULONG) &pciData) + Offset/4);
                 i<(Length+3)/4;
                 i++, dataBuffer++) {
                ScsiPortWritePortUlong(pciAddrReg, PCI_ADDRESS(SystemIoBusNumber,
                                                               SlotNumber.u.bits.DeviceNumber,
                                                               SlotNumber.u.bits.FunctionNumber,
                                                               i + Offset/4));
                data = ScsiPortReadPortUlong(pciDataReg);
                if (i < (Length/4)) {
                    dataBuffer[0] = data;
                } else {
                    for (j=0; j < Length%4; j++) {
                        ((PUCHAR)dataBuffer)[j] = (UCHAR) (data & 0xff);
                        data = data >> 8;
                    }
                }
            }

            //
            // Copy the new data over
            //
            for (i = 0; i<Length; i++) {
                ((PUCHAR)&pciData)[i + Offset] = ((PUCHAR)Buffer)[i];
            }

            //
            // write out the same range of data
            //
            for (i=0, dataBuffer = (((PULONG) &pciData) + Offset/4);
                 i<(Length+3)/4;
                 i++, dataBuffer++) {
                ScsiPortWritePortUlong(pciAddrReg, PCI_ADDRESS(SystemIoBusNumber,
                                                               SlotNumber.u.bits.DeviceNumber,
                                                               SlotNumber.u.bits.FunctionNumber,
                                                               i + Offset/4));
                ScsiPortWritePortUlong(pciDataReg, dataBuffer[0]);
            }

            byteWritten = Length;

        } else {

            // If the hidden device is not Intel PIIX, don't
            // write to it
            byteWritten = 0;
        }

    }

    if (!byteWritten) {
        //
        // Didn't find any hidden PIIX.  Write to the PCI
        // space via the normal call (ScsiPortSetBusDataByOffset)
        //
        byteWritten = ScsiPortSetBusDataByOffset(HwDeviceExtension,
                                                 PCIConfiguration,
                                                 SystemIoBusNumber,
                                                 SlotNumber.u.AsULONG,
                                                 Buffer,
                                                 Offset,
                                                 Length);
    }

    if (pciAddrReg)
        ScsiPortFreeDeviceBase(HwDeviceExtension, pciAddrReg);
    if (pciDataReg)
        ScsiPortFreeDeviceBase(HwDeviceExtension, pciDataReg);

    return byteWritten;
}

BOOLEAN
ChannelIsAlwaysEnabled (
    PPCI_COMMON_CONFIG PciData,
    ULONG Channel)
/*++

Routine Description:

    dummy routine that always returns TRUE

Arguments:

    PPCI_COMMON_CONFIG  - pci config data
    Channel             - ide channel number

Return Value:

    TRUE

--*/
{
    return TRUE;
}

VOID
SetBusMasterDetectionLevel (
    IN PVOID HwDeviceExtension,
    IN PCHAR userArgumentString
    )
/*++

Routine Description:

    check whether we should try to enable bus mastering

Arguments:

    HwDeviceExtension   - HBA miniport driver's adapter data storage
    ArgumentString      - register arguments

Return Value:

    TRUE

--*/
{
    PHW_DEVICE_EXTENSION    deviceExtension = HwDeviceExtension;
    BOOLEAN                 useBM;

    ULONG                   pciBusNumber;
    PCI_SLOT_NUMBER         pciSlot;
    ULONG                   slotNumber;
    ULONG                   logicalDeviceNumber;
    PCI_COMMON_CONFIG       pciData;
    ULONG                   DMADetectionLevel;

    useBM = TRUE;

    DMADetectionLevel = AtapiParseArgumentString(userArgumentString, "DMADetectionLevel");
    if (DMADetectionLevel == DMADETECT_SAFE) {
        AtapiPlaySafe = TRUE;
    } else if (DMADetectionLevel == DMADETECT_UNSAFE) {
        AtapiPlaySafe = FALSE;
    } else { // default is no busmastering
        useBM = FALSE;
    }


    //
    // search for bad chip set
    //
    for (pciBusNumber=0;
         pciBusNumber < 256 && useBM;
         pciBusNumber++) {

        pciSlot.u.AsULONG = 0;

        for (slotNumber=0;
             slotNumber < PCI_MAX_DEVICES && useBM;
             slotNumber++) {

            pciSlot.u.bits.DeviceNumber = slotNumber;

            for (logicalDeviceNumber=0;
                 logicalDeviceNumber < PCI_MAX_FUNCTION && useBM;
                 logicalDeviceNumber++) {

                pciSlot.u.bits.FunctionNumber = logicalDeviceNumber;

                if (!GetPciBusData(HwDeviceExtension,
                                   pciBusNumber,
                                   pciSlot,
                                   &pciData,
                                   offsetof (PCI_COMMON_CONFIG, DeviceSpecific)
                                   )) {
                    break;
                }

                if (pciData.VendorID == PCI_INVALID_VENDORID) {
                    break;
                }

                if ((pciData.VendorID == 0x8086) && // Intel
                    (pciData.DeviceID == 0x84c4) && // 82450GX/KX Pentium Pro Processor to PCI bridge
                    (pciData.RevisionID < 0x4)) {   // Stepping less than 4

                    DebugPrint((1,
                                "atapi: Find a bad Intel processor-pci bridge.  Disable PCI IDE busmastering...\n"));
                    useBM = FALSE;
                }
            }
        }
    }

    deviceExtension->UseBusMasterController = useBM;
    DebugPrint ((0, "ATAPI: UseBusMasterController = %d\n", deviceExtension->UseBusMasterController));

    if (deviceExtension->UseBusMasterController) {
        DebugPrint ((0, "ATAPI: AtapiPlaySafe = %d\n", AtapiPlaySafe));
    }

    return;
}



UCHAR PioDeviceModelNumber[][41] = {
    {"    Conner Peripherals 425MB - CFS425A   "},
    {"MATSHITA CR-581                          "},
    {"FX600S                                   "},
    {"CD-44E                                   "},
    {"QUANTUM TRB850A                          "},
    {"QUANTUM MARVERICK 540A                   "},
    {" MAXTOR MXT-540  AT                      "},
    {"Maxtor 71260 AT                          "},
    {"Maxtor 7850 AV                           "},
    {"Maxtor 7540 AV                           "},
    {"Maxtor 7213 AT                           "},
    {"Maxtor 7345                              "},
    {"Maxtor 7245 AT                           "},
    {"Maxtor 7245                              "},
    {"Maxtor 7211AU                            "},
    {"Maxtor 7171 AT                           "}
};
#define NUMBER_OF_PIO_DEVICES (sizeof(PioDeviceModelNumber) / (sizeof(UCHAR) * 41))

UCHAR SpecialWDDevicesFWVersion[][9] = {
    {"14.04E28"},
    {"25.26H35"},
    {"26.27J38"},
    {"27.25C38"},
    {"27.25C39"}
};
#define NUMBER_OF_SPECIAL_WD_DEVICES (sizeof(SpecialWDDevicesFWVersion) / (sizeof (UCHAR) * 9))

BOOLEAN
AtapiDeviceDMACapable (
    IN PVOID HwDeviceExtension,
    IN ULONG deviceNumber
    )
/*++

Routine Description:

    check the given device whether it is on our bad device list (non dma device)

Arguments:

    HwDeviceExtension   - HBA miniport driver's adapter data storage
    deviceNumber        - device number

Return Value:

    TRUE if dma capable
    FALSE if not dma capable

--*/
{
    PHW_DEVICE_EXTENSION    deviceExtension = HwDeviceExtension;
    UCHAR modelNumber[41];
    UCHAR firmwareVersion[9];
    ULONG i;
    BOOLEAN turnOffDMA = FALSE;
    PCI_SLOT_NUMBER     pciSlot;
    PCI_COMMON_CONFIG   pciData;

    if (!(deviceExtension->DeviceFlags[deviceNumber] & DFLAGS_DEVICE_PRESENT)) {
        return FALSE;
    }

    for (i=0; i<40; i+=2) {
        modelNumber[i + 0] = deviceExtension->IdentifyData[deviceNumber].ModelNumber[i + 1];
        modelNumber[i + 1] = deviceExtension->IdentifyData[deviceNumber].ModelNumber[i + 0];
    }
    modelNumber[i] = 0;

    for (i=0; i<NUMBER_OF_PIO_DEVICES; i++) {
        if (!AtapiStringCmp(modelNumber, PioDeviceModelNumber[i], 40)) {

            DebugPrint ((0, "ATAPI: device on the hall of shame list.  no DMA!\n"));

            turnOffDMA = TRUE;
        }
    }

    //
    // if we have a Western Digial device
    //     if the best dma mode is multi word dma mode 1
    //         if the identify data word offset 129 is not 0x5555
    //            turn off dma unless
    //            if the device firmware version is on the list and
    //            it is the only drive on the bus
    //
    if (!AtapiStringCmp(modelNumber, "WDC", 3)) {
        if (deviceExtension->DeviceParameters[deviceNumber].BestMultiWordDMAMode == 1) {

            for (i=0; i<8; i+=2) {
                firmwareVersion[i + 0] = deviceExtension->IdentifyData[deviceNumber].FirmwareRevision[i + 1];
                firmwareVersion[i + 1] = deviceExtension->IdentifyData[deviceNumber].FirmwareRevision[i + 0];
            }
            firmwareVersion[i] = 0;

            //
            // Check the special flag.  If not found, can't use dma
            //
            if (*(((PUSHORT)&deviceExtension->IdentifyData[deviceNumber]) + 129) != 0x5555) {

                DebugPrint ((0, "ATAPI: found mode 1 WD drive. no dma unless it is the only device\n"));

                turnOffDMA = TRUE;

                for (i=0; i<NUMBER_OF_SPECIAL_WD_DEVICES; i++) {

                    if (!AtapiStringCmp(firmwareVersion, SpecialWDDevicesFWVersion[i], 8)) {

                        ULONG otherDeviceNumber;

                        //
                        // 0 becomes 1
                        // 1 becomes 0
                        // 2 becomes 3
                        // 3 becomes 2
                        //
                        otherDeviceNumber = ((deviceNumber & 0x2) | ((deviceNumber & 0x1) ^ 1));

                        //
                        // if the device is alone on the bus, we can use dma
                        //
                        if (!(deviceExtension->DeviceFlags[otherDeviceNumber] & DFLAGS_DEVICE_PRESENT)) {
                            turnOffDMA = FALSE;
                            break;
                        }
                    }
                }
            }
        }
    }

    //
    // ALi IDE controller cannot busmaster with an ATAPI device
    //
    pciSlot.u.AsULONG = 0;
    pciSlot.u.bits.DeviceNumber = deviceExtension->PciDeviceNumber;
    pciSlot.u.bits.FunctionNumber = deviceExtension->PciLogDevNumber;
                
    if (GetPciBusData(HwDeviceExtension,
                           deviceExtension->PciBusNumber,
                           pciSlot,
                           &pciData,
                           offsetof (PCI_COMMON_CONFIG, DeviceSpecific)
                           )) {

        if ((pciData.VendorID == 0x10b9) &&
            (pciData.DeviceID == 0x5219)) {

            if (deviceExtension->DeviceFlags[deviceNumber] & DFLAGS_ATAPI_DEVICE) {

                DebugPrint ((0, "ATAPI: Can't do DMA because we have a ALi controller and a ATAPI device\n"));

                turnOffDMA = TRUE;



            }
        }
    }

    if (turnOffDMA) {
        return FALSE;
    } else {
        return TRUE;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\port\scsi\miniport\atapi\intel.c ===
#include "miniport.h"
#include "devioctl.h"
#include "atapi.h"
#include "ntdddisk.h"
#include "ntddscsi.h"
#include "intel.h"

BOOLEAN
PiixTimingControl (
    struct _HW_DEVICE_EXTENSION DeviceExtension
    )
{




    return TRUE;
}

BOOLEAN IntelIsChannelEnabled (
    PPCI_COMMON_CONFIG PciData,
    ULONG Channel)
{
    PUCHAR rawPciData = (PUCHAR) PciData;
    ULONG pciDataOffset;

    if (Channel == 0) {
        pciDataOffset = 0x41;
    } else {
        pciDataOffset = 0x43;
    }

    return (rawPciData[pciDataOffset] & 0x80);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\port\scsi\miniport\atapi\intel.h ===
BOOLEAN
PiixTimingControl (
    struct _HW_DEVICE_EXTENSION DeviceExtension
    );

BOOLEAN IntelIsChannelEnabled (
    PPCI_COMMON_CONFIG PciData,
    ULONG Channel);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\port\scsi\miniport\atapi\atapi.h ===
/*++

Copyright (c) 1993-1996  Microsoft Corporation

Module Name:

    atapi.h

Abstract:

    This module contains the structures and definitions for the ATAPI
    IDE miniport driver.

Author:

    Mike Glass


Revision History:

--*/

#include "scsi.h"
#include "stdio.h"
#include "string.h"

//
// Function Prototypes
//
ULONG
GetPciBusData(
    IN PVOID              DeviceExtension,
    IN ULONG              SystemIoBusNumber,
    IN PCI_SLOT_NUMBER    SlotNumber,
    OUT PVOID             PciConfigBuffer,
    IN ULONG              NumByte
    );

ULONG
SetPciBusData(
    IN PVOID              HwDeviceExtension,
    IN ULONG              SystemIoBusNumber,
    IN PCI_SLOT_NUMBER    SlotNumber,
    IN PVOID              Buffer,
    IN ULONG              Offset,
    IN ULONG              Length
    );

BOOLEAN
ChannelIsAlwaysEnabled (
    IN PPCI_COMMON_CONFIG PciData,
    IN ULONG Channel
    );

//
// IDE register definition
//

typedef struct _IDE_REGISTERS_1 {
    USHORT Data;
    UCHAR BlockCount;
    UCHAR BlockNumber;
    UCHAR CylinderLow;
    UCHAR CylinderHigh;
    UCHAR DriveSelect;
    UCHAR Command;
} IDE_REGISTERS_1, *PIDE_REGISTERS_1;

typedef struct _IDE_REGISTERS_2 {
    UCHAR DeviceControl;
    UCHAR DriveAddress;
} IDE_REGISTERS_2, *PIDE_REGISTERS_2;

typedef struct _IDE_REGISTERS_3 {
    ULONG Data;
    UCHAR Others[4];
} IDE_REGISTERS_3, *PIDE_REGISTERS_3;

//
// Bus Master Controller Register
//
typedef struct _IDE_BUS_MASTER_REGISTERS {
         UCHAR  Command;
         UCHAR  Reserved1;
         UCHAR  Status;
         UCHAR  Reserved2;
         ULONG  DescriptionTable;
} IDE_BUS_MASTER_REGISTERS, *PIDE_BUS_MASTER_REGISTERS;

//
// Device Extension Device Flags
//

#define DFLAGS_DEVICE_PRESENT        (1 << 0)    // Indicates that some device is present.
#define DFLAGS_ATAPI_DEVICE          (1 << 1)    // Indicates whether Atapi commands can be used.
#define DFLAGS_TAPE_DEVICE           (1 << 2)    // Indicates whether this is a tape device.
#define DFLAGS_INT_DRQ               (1 << 3)    // Indicates whether device interrupts as DRQ is set after
                                                 // receiving Atapi Packet Command
#define DFLAGS_REMOVABLE_DRIVE       (1 << 4)    // Indicates that the drive has the 'removable' bit set in
                                                 // identify data (offset 128)
#define DFLAGS_MEDIA_STATUS_ENABLED  (1 << 5)    // Media status notification enabled
#define DFLAGS_ATAPI_CHANGER         (1 << 6)    // Indicates atapi 2.5 changer present.
#define DFLAGS_SANYO_ATAPI_CHANGER   (1 << 7)    // Indicates multi-platter device, not conforming to the 2.5 spec.
#define DFLAGS_CHANGER_INITED        (1 << 8)    // Indicates that the init path for changers has already been done.
#define DFLAGS_USE_DMA               (1 << 9)    // Indicates whether device can use DMA
#define DFLAGS_LBA                   (1 << 10)   // support LBA addressing

//
// Controller Flags
//
#define CFLAGS_BUS_MASTERING              (1 << 0)    // The Controller is capable of doing bus mastering
                                                  // defined by SFF-8038i

//
// Used to disable 'advanced' features.
//

#define MAX_ERRORS                     4

//
// ATAPI command definitions
//

#define ATAPI_MODE_SENSE   0x5A
#define ATAPI_MODE_SELECT  0x55
#define ATAPI_FORMAT_UNIT  0x24

//
// ATAPI Command Descriptor Block
//

typedef struct _MODE_SENSE_10 {
        UCHAR OperationCode;
        UCHAR Reserved1;
        UCHAR PageCode : 6;
        UCHAR Pc : 2;
        UCHAR Reserved2[4];
        UCHAR ParameterListLengthMsb;
        UCHAR ParameterListLengthLsb;
        UCHAR Reserved3[3];
} MODE_SENSE_10, *PMODE_SENSE_10;

typedef struct _MODE_SELECT_10 {
        UCHAR OperationCode;
        UCHAR Reserved1 : 4;
        UCHAR PFBit : 1;
        UCHAR Reserved2 : 3;
        UCHAR Reserved3[5];
        UCHAR ParameterListLengthMsb;
        UCHAR ParameterListLengthLsb;
        UCHAR Reserved4[3];
} MODE_SELECT_10, *PMODE_SELECT_10;

typedef struct _MODE_PARAMETER_HEADER_10 {
    UCHAR ModeDataLengthMsb;
    UCHAR ModeDataLengthLsb;
    UCHAR MediumType;
    UCHAR Reserved[5];
}MODE_PARAMETER_HEADER_10, *PMODE_PARAMETER_HEADER_10;

//
// IDE command definitions
//

#define IDE_COMMAND_ATAPI_RESET             0x08
#define IDE_COMMAND_RECALIBRATE             0x10
#define IDE_COMMAND_READ                    0x20
#define IDE_COMMAND_WRITE                   0x30
#define IDE_COMMAND_VERIFY                  0x40
#define IDE_COMMAND_SEEK                    0x70
#define IDE_COMMAND_SET_DRIVE_PARAMETERS    0x91
#define IDE_COMMAND_ATAPI_PACKET            0xA0
#define IDE_COMMAND_ATAPI_IDENTIFY          0xA1
#define IDE_COMMAND_READ_MULTIPLE           0xC4
#define IDE_COMMAND_WRITE_MULTIPLE          0xC5
#define IDE_COMMAND_SET_MULTIPLE            0xC6
#define IDE_COMMAND_READ_DMA                0xC8
#define IDE_COMMAND_WRITE_DMA               0xCA
#define IDE_COMMAND_GET_MEDIA_STATUS        0xDA
#define IDE_COMMAND_ENABLE_MEDIA_STATUS     0xEF
#define IDE_COMMAND_IDENTIFY                0xEC
#define IDE_COMMAND_MEDIA_EJECT             0xED
#define IDE_COMMAND_DOOR_LOCK               0xDE
#define IDE_COMMAND_DOOR_UNLOCK             0xDF

//
// IDE status definitions
//

#define IDE_STATUS_ERROR             0x01
#define IDE_STATUS_INDEX             0x02
#define IDE_STATUS_CORRECTED_ERROR   0x04
#define IDE_STATUS_DRQ               0x08
#define IDE_STATUS_DSC               0x10
#define IDE_STATUS_DRDY              0x40
#define IDE_STATUS_IDLE              0x50
#define IDE_STATUS_BUSY              0x80

//
// IDE drive select/head definitions
//

#define IDE_DRIVE_SELECT_1           0xA0
#define IDE_DRIVE_SELECT_2           0x10

//
// IDE drive control definitions
//

#define IDE_DC_DISABLE_INTERRUPTS    0x02
#define IDE_DC_RESET_CONTROLLER      0x04
#define IDE_DC_REENABLE_CONTROLLER   0x00

//
// IDE error definitions
//

#define IDE_ERROR_BAD_BLOCK          0x80
#define IDE_ERROR_DATA_ERROR         0x40
#define IDE_ERROR_MEDIA_CHANGE       0x20
#define IDE_ERROR_ID_NOT_FOUND       0x10
#define IDE_ERROR_MEDIA_CHANGE_REQ   0x08
#define IDE_ERROR_COMMAND_ABORTED    0x04
#define IDE_ERROR_END_OF_MEDIA       0x02
#define IDE_ERROR_ILLEGAL_LENGTH     0x01

//
// ATAPI register definition
//

typedef struct _ATAPI_REGISTERS_1 {
    USHORT Data;
    UCHAR InterruptReason;
    UCHAR Unused1;
    UCHAR ByteCountLow;
    UCHAR ByteCountHigh;
    UCHAR DriveSelect;
    UCHAR Command;
} ATAPI_REGISTERS_1, *PATAPI_REGISTERS_1;

typedef struct _ATAPI_REGISTERS_2 {
    UCHAR DeviceControl;
    UCHAR DriveAddress;
} ATAPI_REGISTERS_2, *PATAPI_REGISTERS_2;


//
// ATAPI interrupt reasons
//

#define ATAPI_IR_COD 0x01
#define ATAPI_IR_IO  0x02

//
// IDENTIFY data
//
#pragma pack (1)
typedef struct _IDENTIFY_DATA {
    USHORT GeneralConfiguration;            // 00 00
    USHORT NumberOfCylinders;               // 02  1
    USHORT Reserved1;                       // 04  2
    USHORT NumberOfHeads;                   // 06  3
    USHORT UnformattedBytesPerTrack;        // 08  4
    USHORT UnformattedBytesPerSector;       // 0A  5
    USHORT SectorsPerTrack;                 // 0C  6
    USHORT VendorUnique1[3];                // 0E  7-9
    USHORT SerialNumber[10];                // 14  10-19
    USHORT BufferType;                      // 28  20
    USHORT BufferSectorSize;                // 2A  21
    USHORT NumberOfEccBytes;                // 2C  22
    UCHAR  FirmwareRevision[8];             // 2E  23-26
    UCHAR  ModelNumber[40];                 // 36  27-46
    UCHAR  MaximumBlockTransfer;            // 5E  47
    UCHAR  VendorUnique2;                   // 5F
    USHORT DoubleWordIo;                    // 60  48
    USHORT Capabilities;                    // 62  49
    USHORT Reserved2;                       // 64  50
    UCHAR  VendorUnique3;                   // 66  51
    UCHAR  PioCycleTimingMode;              // 67
    UCHAR  VendorUnique4;                   // 68  52
    UCHAR  DmaCycleTimingMode;              // 69
    USHORT TranslationFieldsValid:3;        // 6A  53
    USHORT Reserved3:13;
    USHORT NumberOfCurrentCylinders;        // 6C  54
    USHORT NumberOfCurrentHeads;            // 6E  55
    USHORT CurrentSectorsPerTrack;          // 70  56
    ULONG  CurrentSectorCapacity;           // 72  57-58
    USHORT CurrentMultiSectorSetting;       //     59
    ULONG  UserAddressableSectors;          //     60-61
    USHORT SingleWordDMASupport : 8;        //     62
    USHORT SingleWordDMAActive : 8;
    USHORT MultiWordDMASupport : 8;         //     63
    USHORT MultiWordDMAActive : 8;
    USHORT AdvancedPIOModes : 8;            //     64
    USHORT Reserved4 : 8;
    USHORT MinimumMWXferCycleTime;          //     65
    USHORT RecommendedMWXferCycleTime;      //     66
    USHORT MinimumPIOCycleTime;             //     67
    USHORT MinimumPIOCycleTimeIORDY;        //     68
    USHORT Reserved5[11];                   //     69-79
    USHORT MajorRevision;                   //     80
    USHORT MinorRevision;                   //     81
    USHORT Reserved6[6];                    //     82-87
    USHORT UltraDMASupport : 8;             //     88
    USHORT UltraDMAActive  : 8;             //
    USHORT Reserved7[38];                   //     89-126
    USHORT SpecialFunctionsEnabled;         //     127
    USHORT Reserved8[128];                  //     128-255
} IDENTIFY_DATA, *PIDENTIFY_DATA;

//
// Identify data without the Reserved4.
//

typedef struct _IDENTIFY_DATA2 {
    USHORT GeneralConfiguration;            // 00 00
    USHORT NumberOfCylinders;               // 02  1
    USHORT Reserved1;                       // 04  2
    USHORT NumberOfHeads;                   // 06  3
    USHORT UnformattedBytesPerTrack;        // 08  4
    USHORT UnformattedBytesPerSector;       // 0A  5
    USHORT SectorsPerTrack;                 // 0C  6
    USHORT VendorUnique1[3];                // 0E  7-9
    USHORT SerialNumber[10];                // 14  10-19
    USHORT BufferType;                      // 28  20
    USHORT BufferSectorSize;                // 2A  21
    USHORT NumberOfEccBytes;                // 2C  22
    UCHAR  FirmwareRevision[8];             // 2E  23-26
    UCHAR  ModelNumber[40];                 // 36  27-46
    UCHAR  MaximumBlockTransfer;            // 5E  47
    UCHAR  VendorUnique2;                   // 5F
    USHORT DoubleWordIo;                    // 60  48
    USHORT Capabilities;                    // 62  49
    USHORT Reserved2;                       // 64  50
    UCHAR  VendorUnique3;                   // 66  51
    UCHAR  PioCycleTimingMode;              // 67
    UCHAR  VendorUnique4;                   // 68  52
    UCHAR  DmaCycleTimingMode;              // 69
    USHORT TranslationFieldsValid:3;        // 6A  53
    USHORT Reserved3:13;
    USHORT NumberOfCurrentCylinders;        // 6C  54
    USHORT NumberOfCurrentHeads;            // 6E  55
    USHORT CurrentSectorsPerTrack;          // 70  56
    ULONG  CurrentSectorCapacity;           // 72  57-58
    USHORT CurrentMultiSectorSetting;       //     59
    ULONG  UserAddressableSectors;          //     60-61
    USHORT SingleWordDMASupport : 8;        //     62
    USHORT SingleWordDMAActive : 8;
    USHORT MultiWordDMASupport : 8;         //     63
    USHORT MultiWordDMAActive : 8;
    USHORT AdvancedPIOModes : 8;            //     64
    USHORT Reserved4 : 8;
    USHORT MinimumMWXferCycleTime;          //     65
    USHORT RecommendedMWXferCycleTime;      //     66
    USHORT MinimumPIOCycleTime;             //     67
    USHORT MinimumPIOCycleTimeIORDY;        //     68
    USHORT Reserved5[11];                   //     69-79
    USHORT MajorRevision;                   //     80
    USHORT MinorRevision;                   //     81
    USHORT Reserved6[6];                    //     82-87
    USHORT UltraDMASupport : 8;             //     88
    USHORT UltraDMAActive  : 8;             //
    USHORT Reserved7[38];                   //     89-126
    USHORT SpecialFunctionsEnabled;         //     127
    USHORT Reserved8[2];                    //     128-129
} IDENTIFY_DATA2, *PIDENTIFY_DATA2;
#pragma pack ()

#define IDENTIFY_DATA_SIZE sizeof(IDENTIFY_DATA)

//
// IDENTIFY capability bit definitions.
//

#define IDENTIFY_CAPABILITIES_DMA_SUPPORTED             (1 << 8)
#define IDENTIFY_CAPABILITIES_LBA_SUPPORTED             (1 << 9)
#define IDENTIFY_CAPABILITIES_IOREADY_CAN_BE_DISABLED   (1 << 10)
#define IDENTIFY_CAPABILITIES_IOREADY_SUPPORTED         (1 << 11)


//
// Select LBA mode when progran IDE device
//
#define IDE_LBA_MODE                                    (1 << 6)

//
// Beautification macros
//

#define GetStatus(BaseIoAddress, Status) \
    Status = ScsiPortReadPortUchar(&BaseIoAddress->Command);

#define GetBaseStatus(BaseIoAddress, Status) \
    Status = ScsiPortReadPortUchar(&BaseIoAddress->Command);

#define WriteCommand(BaseIoAddress, Command) \
    ScsiPortWritePortUchar(&BaseIoAddress->Command, Command);



#define ReadBuffer(BaseIoAddress, Buffer, Count) \
    ScsiPortReadPortBufferUshort(&BaseIoAddress->Data, \
                                 Buffer, \
                                 Count);

#define WriteBuffer(BaseIoAddress, Buffer, Count) \
    ScsiPortWritePortBufferUshort(&BaseIoAddress->Data, \
                                  Buffer, \
                                  Count);

#define ReadBuffer2(BaseIoAddress, Buffer, Count) \
    ScsiPortReadPortBufferUlong(&BaseIoAddress->Data, \
                             Buffer, \
                             Count);

#define WriteBuffer2(BaseIoAddress, Buffer, Count) \
    ScsiPortWritePortBufferUlong(&BaseIoAddress->Data, \
                              Buffer, \
                              Count);

#define WaitOnBusy(BaseIoAddress, Status) \
{ \
    ULONG i; \
    for (i=0; i<20000; i++) { \
        GetStatus(BaseIoAddress, Status); \
        if (Status & IDE_STATUS_BUSY) { \
            ScsiPortStallExecution(150); \
            continue; \
        } else { \
            break; \
        } \
    if (i == 20000) \
        DebugPrint ((0, "WaitOnBusy failed in %s line %u. status = 0x%x\n", __FILE__, __LINE__, (ULONG) (Status))); \
    } \
}

#define WaitOnBaseBusy(BaseIoAddress, Status) \
{ \
    ULONG i; \
    for (i=0; i<20000; i++) { \
        GetBaseStatus(BaseIoAddress, Status); \
        if (Status & IDE_STATUS_BUSY) { \
            ScsiPortStallExecution(150); \
            continue; \
        } else { \
            break; \
        } \
    } \
}

#define WaitForDrq(BaseIoAddress, Status) \
{ \
    ULONG i; \
    for (i=0; i<1000; i++) { \
        GetStatus(BaseIoAddress, Status); \
        if (Status & IDE_STATUS_BUSY) { \
            ScsiPortStallExecution(100); \
        } else if (Status & IDE_STATUS_DRQ) { \
            break; \
        } else { \
            ScsiPortStallExecution(200); \
        } \
    } \
}


#define WaitShortForDrq(BaseIoAddress, Status) \
{ \
    ULONG i; \
    for (i=0; i<2; i++) { \
        GetStatus(BaseIoAddress, Status); \
        if (Status & IDE_STATUS_BUSY) { \
            ScsiPortStallExecution(100); \
        } else if (Status & IDE_STATUS_DRQ) { \
            break; \
        } else { \
            ScsiPortStallExecution(100); \
        } \
    } \
}

#define AtapiSoftReset(BaseIoAddress, DeviceNumber, interruptOff) \
{\
    ULONG __i=0;\
    UCHAR statusByte; \
    DebugPrintTickCount(); \
    ScsiPortWritePortUchar(&BaseIoAddress->DriveSelect,(UCHAR)(((DeviceNumber & 0x1) << 4) | 0xA0)); \
    ScsiPortStallExecution(500);\
    ScsiPortWritePortUchar(&BaseIoAddress->Command, IDE_COMMAND_ATAPI_RESET); \
    ScsiPortStallExecution(10); \
    do {                        \
        WaitOnBusy(BaseIoAddress, statusByte); \
        __i++;                                   \
    } while ((statusByte & IDE_STATUS_BUSY) && (__i < 1000)); \
    ScsiPortWritePortUchar(&BaseIoAddress->DriveSelect,(UCHAR)((DeviceNumber << 4) | 0xA0)); \
    WaitOnBusy(BaseIoAddress, statusByte); \
    ScsiPortStallExecution(500);\
    if (interruptOff) { \
        ScsiPortWritePortUchar(&baseIoAddress2->DeviceControl, IDE_DC_DISABLE_INTERRUPTS); \
    } \
    DebugPrintTickCount(); \
}

#define IdeHardReset(BaseIoAddress1, BaseIoAddress2, result) \
{\
    UCHAR statusByte;\
    ULONG i;\
    ScsiPortWritePortUchar(&BaseIoAddress2->DeviceControl,IDE_DC_RESET_CONTROLLER );\
    ScsiPortStallExecution(50 * 1000);\
    ScsiPortWritePortUchar(&BaseIoAddress2->DeviceControl,IDE_DC_REENABLE_CONTROLLER);\
    for (i = 0; i < 1000 * 1000; i++) {\
        statusByte = ScsiPortReadPortUchar(&BaseIoAddress1->Command);\
        if (statusByte != IDE_STATUS_IDLE && statusByte != 0x0) {\
            ScsiPortStallExecution(5);\
        } else {\
            break;\
        }\
    }\
    if (i == 1000*1000) {\
        result = FALSE;\
    }\
    result = TRUE;\
}

#define IS_RDP(OperationCode)\
    ((OperationCode == SCSIOP_ERASE)||\
    (OperationCode == SCSIOP_LOAD_UNLOAD)||\
    (OperationCode == SCSIOP_LOCATE)||\
    (OperationCode == SCSIOP_REWIND) ||\
    (OperationCode == SCSIOP_SPACE)||\
    (OperationCode == SCSIOP_SEEK)||\
    (OperationCode == SCSIOP_WRITE_FILEMARKS))

struct _CONTROLLER_PARAMETERS;

//
// Keep trap off DriverEntry status
//
typedef struct _FIND_STATE {

    ULONG   BusNumber;
    ULONG   SlotNumber;
    ULONG   LogicalDeviceNumber;
    ULONG   IdeChannel;

    PULONG   DefaultIoPort;
    PULONG   DefaultInterrupt;
    PBOOLEAN IoAddressUsed;

    struct _CONTROLLER_PARAMETERS * ControllerParameters;

} FIND_STATE, * PFIND_STATE;

//
// Bus Master Physical Region Descriptor
//
#pragma pack (1)
typedef struct _PHYSICAL_REGION_DESCRIPTOR {
    ULONG PhyscialAddress;
    ULONG ByteCount:16;
    ULONG Reserved:15;
    ULONG EndOfTable:1;
} PHYSICAL_REGION_DESCRIPTOR, * PPHYSICAL_REGION_DESCRIPTOR;
#pragma pack ()

#define MAX_TRANSFER_SIZE_PER_SRB                   (0x20000)

#define MAX_DEVICE                          (2)
#define MAX_CHANNEL                         (2)

//
// Device extension
//
typedef struct _HW_DEVICE_EXTENSION {

    //
    // Current request on controller.
    //

    PSCSI_REQUEST_BLOCK CurrentSrb;

    //
    // Base register locations
    //

    PIDE_REGISTERS_1            BaseIoAddress1[2];
    PIDE_REGISTERS_2            BaseIoAddress2[2];
    PIDE_BUS_MASTER_REGISTERS   BusMasterPortBase[2];

    //
    // Interrupt level
    //

    ULONG InterruptLevel;

    //
    // Interrupt Mode (Level or Edge)
    //

    ULONG InterruptMode;

    //
    // Data buffer pointer.
    //

    PUSHORT DataBuffer;

    //
    // Data words left.
    //

    ULONG WordsLeft;

    //
    // Number of channels being supported by one instantiation
    // of the device extension. Normally (and correctly) one, but
    // with so many broken PCI IDE controllers being sold, we have
    // to support them.
    //

    ULONG NumberChannels;

    //
    // Count of errors. Used to turn off features.
    //

    ULONG ErrorCount;

    //
    // Indicates number of platters on changer-ish devices.
    //

    ULONG DiscsPresent[MAX_DEVICE * MAX_CHANNEL];

    //
    // Flags word for each possible device.
    //

    USHORT DeviceFlags[MAX_DEVICE * MAX_CHANNEL];

    //
    // Indicates the number of blocks transferred per int. according to the
    // identify data.
    //

    UCHAR MaximumBlockXfer[MAX_DEVICE * MAX_CHANNEL];

    //
    // Indicates expecting an interrupt
    //

    BOOLEAN ExpectingInterrupt;

    //
    // Indicates DMA is in progress
    //

    BOOLEAN DMAInProgress;


    //
    // Indicate last tape command was DSC Restrictive.
    //

    BOOLEAN RDP;

    //
    // Driver is being used by the crash dump utility or ntldr.
    //

    BOOLEAN DriverMustPoll;

    //
    // Indicates use of 32-bit PIO
    //

    BOOLEAN DWordIO;

    //
    // Indicates whether '0x1f0' is the base address. Used
    // in SMART Ioctl calls.
    //

    BOOLEAN PrimaryAddress;

    //
    // Placeholder for the sub-command value of the last
    // SMART command.
    //

    UCHAR SmartCommand;

    //
    // Placeholder for status register after a GET_MEDIA_STATUS command
    //

    UCHAR ReturningMediaStatus;

    UCHAR Reserved[1];

    //
    // Mechanism Status Srb Data
    //
    PSCSI_REQUEST_BLOCK OriginalSrb;
    SCSI_REQUEST_BLOCK InternalSrb;
    MECHANICAL_STATUS_INFORMATION_HEADER MechStatusData;
    SENSE_DATA MechStatusSense;
    ULONG MechStatusRetryCount;

    //
    // Identify data for device
    //
    IDENTIFY_DATA2 IdentifyData[MAX_DEVICE * MAX_CHANNEL];

    //
    // Bus Master Data
    //
    // Physcial Region Table for bus mastering
    PPHYSICAL_REGION_DESCRIPTOR DataBufferDescriptionTablePtr;
    ULONG                       DataBufferDescriptionTableSize;
    PHYSICAL_ADDRESS            DataBufferDescriptionTablePhysAddr;

    //
    // Controller Flags
    //
    USHORT ControllerFlags;

    //
    // Control whether we ship try to enable busmastering
    //
    BOOLEAN UseBusMasterController;

    //
    // Function to set bus master timing
    //
    BOOLEAN (*BMTimingControl) (struct _HW_DEVICE_EXTENSION * DeviceExtension);

    //
    // Function to set check whether a PCI IDE channel is enabled
    //
    BOOLEAN (*IsChannelEnabled) (PPCI_COMMON_CONFIG PciData, ULONG Channel);


    // PCI Address
    ULONG   PciBusNumber;
    ULONG   PciDeviceNumber;
    ULONG   PciLogDevNumber;

    //
    // Device Specific Info.
    //
    struct _DEVICE_PARAMETERS {

        ULONG   MaxWordPerInterrupt;

        UCHAR   IdeReadCommand;
        UCHAR   IdeWriteCommand;

        BOOLEAN IoReadyEnabled;
        ULONG   PioCycleTime;
        ULONG   DmaCycleTime;

        ULONG   BestPIOMode;
        ULONG   BestSingleWordDMAMode;
        ULONG   BestMultiWordDMAMode;

    } DeviceParameters[MAX_CHANNEL * MAX_DEVICE];

} HW_DEVICE_EXTENSION, *PHW_DEVICE_EXTENSION;


//
// PCI IDE Controller definition
//
typedef struct _CONTROLLER_PARAMETERS {

    INTERFACE_TYPE AdapterInterfaceType;

    PUCHAR  VendorId;
    USHORT  VendorIdLength;
    PUCHAR  DeviceId;
    USHORT  DeviceIdLength;

    ULONG   NumberOfIdeBus;

    BOOLEAN SingleFIFO;

    BOOLEAN (*TimingControl) (PHW_DEVICE_EXTENSION DeviceExtension);

    BOOLEAN (*IsChannelEnabled) (PPCI_COMMON_CONFIG PciData, ULONG Channel);

} CONTROLLER_PARAMETERS, * PCONTROLLER_PARAMETERS;

//
// max number of CHS addressable sectors
//
#define MAX_NUM_CHS_ADDRESSABLE_SECTORS     ((ULONG) (16515072 - 1))


//
// IDE Cycle Timing
//
#define PIO_MODE0_CYCLE_TIME        600
#define PIO_MODE1_CYCLE_TIME        383
#define PIO_MODE2_CYCLE_TIME        240
#define PIO_MODE3_CYCLE_TIME        180
#define PIO_MODE4_CYCLE_TIME        120

#define SWDMA_MODE0_CYCLE_TIME      960
#define SWDMA_MODE1_CYCLE_TIME      480
#define SWDMA_MODE2_CYCLE_TIME      240

#define MWDMA_MODE0_CYCLE_TIME      480
#define MWDMA_MODE1_CYCLE_TIME      150
#define MWDMA_MODE2_CYCLE_TIME      120

#define UNINITIALIZED_CYCLE_TIME    0xffffffff

//
// invalid mode values
//
#define INVALID_PIO_MODE        0xffffffff
#define INVALID_SWDMA_MODE        0xffffffff
#define INVALID_MWDMA_MODE        0xffffffff


//
// Bus Master Status Register
//
#define BUSMASTER_DMA_SIMPLEX_BIT     ((UCHAR) (1 << 7))
#define BUSMASTER_DEVICE1_DMA_OK      ((UCHAR) (1 << 6))
#define BUSMASTER_DEVICE0_DMA_OK      ((UCHAR) (1 << 5))
#define BUSMASTER_INTERRUPT           ((UCHAR) (1 << 2))
#define BUSMASTER_ERROR               ((UCHAR) (1 << 1))
#define BUSMASTER_ACTIVE              ((UCHAR) (1 << 0))


//
// PCI access port
//
#define PCI_ADDR_PORT               (0x0cf8)
#define PCI_DATA_PORT               (0x0cfc)
#define PCI_ADDRESS(bus, deviceNum, funcNum, offset) \
                                     ((1 << 31) |                 \
                                     ((bus & 0xff) << 16) |       \
                                     ((deviceNum & 0x1f) << 11) | \
                                     ((funcNum & 0x7) << 8) |     \
                                     ((offset & 0x3f) << 2))

// GET PAGE_SIZE into miniport.h
#ifdef ALPHA
#define PAGE_SIZE (ULONG)0x2000
#else // MIPS, PPC, I386
#define PAGE_SIZE (ULONG)0x1000
#endif

#define SCSIOP_ATA_PASSTHROUGH       (0xcc)

//
// valid DMA detection level
//
#define DMADETECT_PIO       0
#define DMADETECT_SAFE      1
#define DMADETECT_UNSAFE    2
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\port\scsi\miniport\aha154x\wmi.c ===
#include "miniport.h"
#include "aha154x.h"           // includes scsi.h
#include "wmistr.h"             // WMI definitions

#include "support.h"           // ScsiPortZeroMemory(), ScsiPortCompareMemory()
#include "aha154dt.h"

#define Aha154xWmi_MofResourceName        L"MofResource"

#define AHA154x_SETUP_GUID_INDEX 0

GUID A154xWmiSetupDataGuid = Aha154xWmi_SetupData_Guid;

UCHAR
A154xReadSetupData(
   IN  PHW_DEVICE_EXTENSION HwDeviceExtension,
   OUT PUCHAR               Buffer
   );

BOOLEAN
A154xQueryWmiDataBlock(
    IN PVOID Context,
    IN PSCSIWMI_REQUEST_CONTEXT RequestContext,
    IN ULONG GuidIndex,
    IN ULONG InstanceIndex,
    IN ULONG InstanceCount,
    IN OUT PULONG InstanceLengthArray,
    IN ULONG OutBufferSize,
    OUT PUCHAR Buffer
    );

UCHAR
A154xQueryWmiRegInfo(
    IN PVOID Context,
    IN PSCSIWMI_REQUEST_CONTEXT RequestContext,
    OUT PWCHAR *MofResourceName
    );

SCSIWMIGUIDREGINFO A154xGuidList[] =
{
   {&A154xWmiSetupDataGuid,
    1,
    0
   },
};

#define A154xGuidCount (sizeof(A154xGuidList) / sizeof(SCSIWMIGUIDREGINFO))


void A154xWmiInitialize(
    IN PHW_DEVICE_EXTENSION HwDeviceExtension
    )
{
    PSCSI_WMILIB_CONTEXT WmiLibContext;

    WmiLibContext = &HwDeviceExtension->WmiLibContext;

    WmiLibContext->GuidList = A154xGuidList;
    WmiLibContext->GuidCount = A154xGuidCount;
    WmiLibContext->QueryWmiRegInfo = A154xQueryWmiRegInfo;
    WmiLibContext->QueryWmiDataBlock = A154xQueryWmiDataBlock;
    WmiLibContext->SetWmiDataItem = NULL;
    WmiLibContext->SetWmiDataBlock = NULL;
    WmiLibContext->WmiFunctionControl = NULL;
    WmiLibContext->ExecuteWmiMethod = NULL;
}



BOOLEAN
A154xWmiSrb(
    IN     PHW_DEVICE_EXTENSION    HwDeviceExtension,
    IN OUT PSCSI_WMI_REQUEST_BLOCK Srb
    )
/*++

Routine Description:

   Process an SRB_FUNCTION_WMI request packet.

   This routine is called from the SCSI port driver synchronized with the
   kernel via Aha154xStartIo.   On completion of WMI processing, the SCSI
   port driver is notified that the adapter can take another request,  if
   any are available.

Arguments:

   HwDeviceExtension - HBA miniport driver's adapter data storage.

   Srb               - IO request packet.

Return Value:

   Value to return to Aha154xStartIo caller.   Always TRUE.

--*/
{
   UCHAR status;
   SCSIWMI_REQUEST_CONTEXT requestContext;
   ULONG retSize;
   BOOLEAN pending;

   //
   // Validate our assumptions.
   //

   ASSERT(Srb->Function == SRB_FUNCTION_WMI);
   ASSERT(Srb->Length == sizeof(SCSI_WMI_REQUEST_BLOCK));
   ASSERT(Srb->DataTransferLength >= sizeof(ULONG));
   ASSERT(Srb->DataBuffer);

   //
   // Check if the WMI SRB is targetted for the adapter or one of the disks
   if (!(Srb->WMIFlags & SRB_WMI_FLAGS_ADAPTER_REQUEST)) {

      //
      // This is targetted to one of the disks, since there are no per disk
      // wmi information we return an error. Note that if there was per
      // disk information, then you'd likely have a differen WmiLibContext
      // and a different set of guids.
      //
      Srb->DataTransferLength = 0;
      Srb->SrbStatus = SRB_STATUS_SUCCESS;

   } else {

       //
       // Process the incoming WMI request.
       //

       pending = ScsiPortWmiDispatchFunction(&HwDeviceExtension->WmiLibContext,
                                                Srb->WMISubFunction,
                                                HwDeviceExtension,
                                                &requestContext,
                                                Srb->DataPath,
                                                Srb->DataTransferLength,
                                                Srb->DataBuffer);

       //
       // We assune that the wmi request will never pend so that we can
       // allocate the requestContext from stack. If the WMI request could
       // ever pend then we'd need to allocate the request context from
       // the SRB extension.
       //
       ASSERT(! pending);

       retSize =  ScsiPortWmiGetReturnSize(&requestContext);
       status =  ScsiPortWmiGetReturnStatus(&requestContext);

       // We can do this since we assume it is done synchronously

       Srb->DataTransferLength = retSize;

       //
       // Adapter ready for next request.
       //

       Srb->SrbStatus = status;
   }

   ScsiPortNotification(RequestComplete, HwDeviceExtension, Srb);
   ScsiPortNotification(NextRequest,     HwDeviceExtension, NULL);

   return TRUE;
}



BOOLEAN
A154xQueryWmiDataBlock(
    IN PVOID Context,
    IN PSCSIWMI_REQUEST_CONTEXT RequestContext,
    IN ULONG GuidIndex,
    IN ULONG InstanceIndex,
    IN ULONG InstanceCount,
    IN OUT PULONG InstanceLengthArray,
    IN ULONG OutBufferSize,
    OUT PUCHAR Buffer
    )
/*++

Routine Description:

    This routine is a callback into the miniport to query for the contents of
    one or more instances of a data block. This callback may be called with
    an output buffer that is too small to return all of the data queried.
    In this case the callback is responsible to report the correct output
        buffer size needed.

    If the request can be completed immediately without pending,
        ScsiPortWmiPostProcess should be called from within this callback and
    FALSE returned.

    If the request cannot be completed within this callback then TRUE should
    be returned. Once the pending operations are finished the miniport should
    call ScsiPortWmiPostProcess and then complete the srb.

Arguments:

    DeviceContext is a caller specified context value originally passed to
        ScsiPortWmiDispatchFunction.

    RequestContext is a context associated with the srb being processed.

    GuidIndex is the index into the list of guids provided when the
        miniport registered

    InstanceIndex is the index that denotes first instance of the data block
        is being queried.

    InstanceCount is the number of instances expected to be returned for
        the data block.

    InstanceLengthArray is a pointer to an array of ULONG that returns the
        lengths of each instance of the data block. This may be NULL when
        there is not enough space in the output buffer to fufill the request.
        In this case the miniport should call ScsiPortWmiPostProcess with
        a status of SRB_STATUS_DATA_OVERRUN and the size of the output buffer
        needed to fufill the request.

    BufferAvail on entry has the maximum size available to write the data
        blocks in the output buffer. If the output buffer is not large enough
        to return all of the data blocks then the miniport should call
        ScsiPortWmiPostProcess with a status of SRB_STATUS_DATA_OVERRUN
        and the size of the output buffer needed to fufill the request.

    Buffer on return is filled with the returned data blocks. Note that each
        instance of the data block must be aligned on a 8 byte boundry. This
        may be NULL when there is not enough space in the output buffer to
        fufill the request. In this case the miniport should call
        ScsiPortWmiPostProcess with a status of SRB_STATUS_DATA_OVERRUN and
        the size of the output buffer needed to fufill the request.


Return Value:

    TRUE if request is pending else FALSE

--*/
{
    PHW_DEVICE_EXTENSION HwDeviceExtension = (PHW_DEVICE_EXTENSION)Context;
    ULONG size = 0;
    UCHAR status;

    //
    // Only ever registers 1 instance per guid
    ASSERT((InstanceIndex == 0) &&
           (InstanceCount == 1));

    switch (GuidIndex)
    {
        case AHA154x_SETUP_GUID_INDEX:
        {
            size = sizeof(AHA154SetupData)-1;
            if (OutBufferSize < size)
            {
                //
                // The buffer passed to return the data is too small
                //
                status = SRB_STATUS_DATA_OVERRUN;
                break;
            }

            if ( !A154xReadSetupData(HwDeviceExtension,
                                     Buffer))
            {
                ASSERT(FALSE);
                size = 0;
                status = SRB_STATUS_ERROR;
            } else {
                *InstanceLengthArray = size;
                status = SRB_STATUS_SUCCESS;
            }

            break;
        }

        default:
        {
            status = SRB_STATUS_ERROR;
        }
    }

    ScsiPortWmiPostProcess(RequestContext,
                           status,
                           size);

    return status;
}

UCHAR
A154xQueryWmiRegInfo(
    IN PVOID Context,
    IN PSCSIWMI_REQUEST_CONTEXT RequestContext,
    OUT PWCHAR *MofResourceName
    )
/*++

Routine Description:

    This routine is a callback into the driver to retrieve information about
    the guids being registered.

    Implementations of this routine may be in paged memory

Arguments:

    DeviceObject is the device whose registration information is needed

    *RegFlags returns with a set of flags that describe all of the guids being
        registered for this device. If the device wants enable and disable
        collection callbacks before receiving queries for the registered
        guids then it should return the WMIREG_FLAG_EXPENSIVE flag. Also the
        returned flags may specify WMIREG_FLAG_INSTANCE_PDO in which case
        the instance name is determined from the PDO associated with the
        device object. Note that the PDO must have an associated devnode. If
        WMIREG_FLAG_INSTANCE_PDO is not set then Name must return a unique
        name for the device. These flags are ORed into the flags specified
        by the GUIDREGINFO for each guid.

    InstanceName returns with the instance name for the guids if
        WMIREG_FLAG_INSTANCE_PDO is not set in the returned *RegFlags. The
        caller will call ExFreePool with the buffer returned.

    *RegistryPath returns with the registry path of the driver. This is
        required

    *MofResourceName returns with the name of the MOF resource attached to
        the binary file. If the driver does not have a mof resource attached
        then this can be returned as NULL.

    *Pdo returns with the device object for the PDO associated with this
        device if the WMIREG_FLAG_INSTANCE_PDO flag is retured in
        *RegFlags.

Return Value:

    status

--*/
{
    *MofResourceName = Aha154xWmi_MofResourceName;
    return SRB_STATUS_SUCCESS;
}


UCHAR
A154xReadSetupData(
   IN  PHW_DEVICE_EXTENSION HwDeviceExtension,
   OUT PUCHAR               Buffer
   )
/*++

Routine Description:

   Read the adapter setup information into the supplied buffer.  The buffer
   must be RM_CFG_MAX_SIZE (255) bytes large.

Arguments:

   HwDeviceExtension - HBA miniport driver's adapter data storage.

   Buffer - Buffer to hold adapter's setup information structure [manual 5-10].

Return Value:

   TRUE on success, FALSE on failure.

--*/
{
   UCHAR numberOfBytes = sizeof(AHA154SetupData)-1;

   //
   // Read off config data from AHA154X...
   //

   if (!WriteCommandRegister(HwDeviceExtension, AC_RETURN_SETUP_DATA, TRUE))
      return FALSE;

   if (!WriteDataRegister(HwDeviceExtension, numberOfBytes))
      return FALSE;

   for (; numberOfBytes; numberOfBytes--) {
      if (!(ReadCommandRegister(HwDeviceExtension, Buffer, TRUE)))
          return FALSE;
      Buffer++;
   }

   //
   // ...and wait for interrupt
   //

   if (!SpinForInterrupt(HwDeviceExtension, TRUE))
      return FALSE;

   return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\port\scsi\miniport\hbaapi_sample\wmi.c ===
#include "miniport.h"
#include "aha154x.h"           // includes scsi.h
#include "wmistr.h"             // WMI definitions

#include "support.h"           // ScsiPortZeroMemory(), ScsiPortCompareMemory()
#include "hbapiwmi.h"

#define Aha154xWmi_MofResourceName        L"MofResource"

#define NUMBEROFPORTS   8

UCHAR
QueryWmiDataBlock(
    IN PVOID Context,
    IN PVOID DispatchContext,
    IN ULONG GuidIndex,
    IN ULONG InstanceIndex,
    IN ULONG InstanceCount,
    IN OUT PULONG InstanceLengthArray,
    IN ULONG OutBufferSize,
    OUT PUCHAR Buffer
    );

UCHAR
QueryWmiRegInfo(
    IN PVOID Context,
    IN PSCSIWMI_REQUEST_CONTEXT DispatchContext,
    OUT PWCHAR *MofResourceName
    );
        
UCHAR
WmiFunctionControl (
    IN PVOID Context,
    IN PSCSIWMI_REQUEST_CONTEXT DispatchContext,
    IN ULONG GuidIndex,
    IN SCSIWMI_ENABLE_DISABLE_CONTROL Function,
    IN BOOLEAN Enable
    );

UCHAR
WmiExecuteMethod (
    IN PVOID Context,
    IN PSCSIWMI_REQUEST_CONTEXT DispatchContext,
    IN ULONG GuidIndex,
    IN ULONG InstanceIndex,
    IN ULONG MethodId,
    IN ULONG InBufferSize,
    IN ULONG OutBufferSize,
    IN OUT PUCHAR Buffer
    );

UCHAR
WmiSetDataItem (
    IN PVOID Context,
    IN PSCSIWMI_REQUEST_CONTEXT DispatchContext,
    IN ULONG GuidIndex,
    IN ULONG InstanceIndex,
    IN ULONG DataItemId,
    IN ULONG BufferSize,
    IN PUCHAR Buffer
    );

UCHAR
WmiSetDataBlock (
    IN PVOID Context,
    IN PSCSIWMI_REQUEST_CONTEXT DispatchContext,
    IN ULONG GuidIndex,
    IN ULONG InstanceIndex,
    IN ULONG BufferSize,
    IN PUCHAR Buffer
    );


//
// Define symbolic names for the guid indexes
#define MSFC_FibrePortHBAStatisticsGuidIndex    0
#define MSFC_FibrePortHBAAttributesGuidIndex    1
#define MSFC_FibrePortHBAMethodsGuidIndex    2
#define MSFC_FCAdapterHBAAttributesGuidIndex    3
#define MSFC_HBAPortMethodsGuidIndex    4
#define MSFC_HBAFc3MgmtMethodsGuidIndex    5
#define MSFC_HBAFCPInfoGuidIndex    6
//
// List of guids supported

GUID MSFC_FibrePortHBAStatisticsGUID = MSFC_FibrePortHBAStatisticsGuid;
GUID MSFC_FibrePortHBAAttributesGUID = MSFC_FibrePortHBAAttributesGuid;
GUID MSFC_FibrePortHBAMethodsGUID = MSFC_FibrePortHBAMethodsGuid;
GUID MSFC_FCAdapterHBAAttributesGUID = MSFC_FCAdapterHBAAttributesGuid;
GUID MSFC_HBAPortMethodsGUID = MSFC_HBAPortMethodsGuid;
GUID MSFC_HBAFc3MgmtMethodsGUID = MSFC_HBAFc3MgmtMethodsGuid;
GUID MSFC_HBAFCPInfoGUID = MSFC_HBAFCPInfoGuid;

//
// TODO: Make sure the instance count and flags are set properly for each
//       guid
SCSIWMIGUIDREGINFO HbaapiGuidList[] =
{
    {
        &MSFC_FibrePortHBAStatisticsGUID,                        // Guid
        NUMBEROFPORTS,                               // # of instances in each device
        0                                // Flags
    },
    {
        &MSFC_FibrePortHBAAttributesGUID,                        // Guid
        NUMBEROFPORTS,                               // # of instances in each device
        0                                // Flags
    },
    {
        &MSFC_FibrePortHBAMethodsGUID,                        // Guid
        NUMBEROFPORTS,                               // # of instances in each device
        0                                // Flags
    },
    {
        &MSFC_FCAdapterHBAAttributesGUID,                        // Guid
        1,                               // # of instances in each device
        0                                // Flags
    },
    {
        &MSFC_HBAPortMethodsGUID,                        // Guid
        1,                               // # of instances in each device
        0                                // Flags
    },
    {
        &MSFC_HBAFc3MgmtMethodsGUID,                        // Guid
        1,                               // # of instances in each device
        0                                // Flags
    },
    {
        &MSFC_HBAFCPInfoGUID,                        // Guid
        1,                               // # of instances in each device
        0                                // Flags
    }
};

#define HbaapiGuidCount (sizeof(HbaapiGuidList) / sizeof(SCSIWMIGUIDREGINFO))


void A154xWmiInitialize(
    IN PHW_DEVICE_EXTENSION HwDeviceExtension
    )
{
    PSCSI_WMILIB_CONTEXT WmiLibContext;

    WmiLibContext = &HwDeviceExtension->WmiLibContext;

    memset(WmiLibContext, 0, sizeof(SCSI_WMILIB_CONTEXT));
    
    WmiLibContext->GuidCount = HbaapiGuidCount;
    WmiLibContext->GuidList = HbaapiGuidList;    
    
    WmiLibContext->QueryWmiRegInfo = QueryWmiRegInfo;
    WmiLibContext->QueryWmiDataBlock = QueryWmiDataBlock;
    WmiLibContext->WmiFunctionControl = WmiFunctionControl;
    WmiLibContext->SetWmiDataBlock = WmiSetDataBlock;
    WmiLibContext->SetWmiDataItem = WmiSetDataItem;
    WmiLibContext->ExecuteWmiMethod = WmiExecuteMethod;
}



BOOLEAN
A154xWmiSrb(
    IN     PHW_DEVICE_EXTENSION    HwDeviceExtension,
    IN OUT PSCSI_WMI_REQUEST_BLOCK Srb
    )
/*++

Routine Description:

   Process an SRB_FUNCTION_WMI request packet.

   This routine is called from the SCSI port driver synchronized with the
   kernel via Aha154xStartIo.   On completion of WMI processing, the SCSI
   port driver is notified that the adapter can take another request,  if
   any are available.

Arguments:

   HwDeviceExtension - HBA miniport driver's adapter data storage.

   Srb               - IO request packet.

Return Value:

   Value to return to Aha154xStartIo caller.   Always TRUE.

--*/
{
   UCHAR status;
   SCSIWMI_REQUEST_CONTEXT requestContext;
   ULONG retSize;
   BOOLEAN pending;

   //
   // Validate our assumptions.
   //

   ASSERT(Srb->Function == SRB_FUNCTION_WMI);
   ASSERT(Srb->Length == sizeof(SCSI_WMI_REQUEST_BLOCK));
   ASSERT(Srb->DataTransferLength >= sizeof(ULONG));
   ASSERT(Srb->DataBuffer);

   //
   // Check if the WMI SRB is targetted for the adapter or one of the disks
   if (!(Srb->WMIFlags & SRB_WMI_FLAGS_ADAPTER_REQUEST)) {

      //
      // This is targetted to one of the disks, since there are no per disk
      // wmi information we return an error. Note that if there was per
      // disk information, then you'd likely have a differen WmiLibContext
      // and a different set of guids.
      //
      Srb->DataTransferLength = 0;
      Srb->SrbStatus = SRB_STATUS_SUCCESS;

   } else {

       //
       // Process the incoming WMI request.
       //

       pending = ScsiPortWmiDispatchFunction(&HwDeviceExtension->WmiLibContext,
                                                Srb->WMISubFunction,
                                                HwDeviceExtension,
                                                &requestContext,
                                                Srb->DataPath,
                                                Srb->DataTransferLength,
                                                Srb->DataBuffer);

       //
       // We assune that the wmi request will never pend so that we can
       // allocate the requestContext from stack. If the WMI request could
       // ever pend then we'd need to allocate the request context from
       // the SRB extension.
       //
       ASSERT(! pending);

       retSize =  ScsiPortWmiGetReturnSize(&requestContext);
       status =  ScsiPortWmiGetReturnStatus(&requestContext);

       // We can do this since we assume it is done synchronously

       Srb->DataTransferLength = retSize;

       //
       // Adapter ready for next request.
       //

       Srb->SrbStatus = status;
   }

   ScsiPortNotification(RequestComplete, HwDeviceExtension, Srb);
   ScsiPortNotification(NextRequest,     HwDeviceExtension, NULL);

   return TRUE;
}

#define CopyString(field, string, length) \
{ \
    PWCHAR p = field; \
    *p++ = length*sizeof(WCHAR); \
    ScsiPortMoveMemory(p, string, length*sizeof(WCHAR)); \
}


BOOLEAN
QueryWmiDataBlock(
    IN PVOID Context,
    IN PSCSIWMI_REQUEST_CONTEXT DispatchContext,
    IN ULONG GuidIndex,
    IN ULONG InstanceIndex,
    IN ULONG InstanceCount,
    IN OUT PULONG InstanceLengthArray,
    IN ULONG BufferAvail,
    OUT PUCHAR Buffer
    )
{
    PHW_DEVICE_EXTENSION CardPtr = (PHW_DEVICE_EXTENSION)Context;
    UCHAR status;
    ULONG SizeNeeded;
    ULONG i, LastIndex, InstanceSize;

    DebugPrint((1, "QueryWmiDataBlock (%x,\n%x,\n%x,\n%x,\n%x,\n%x,\n%x,\n%x,\n",
        Context,
        DispatchContext,
        GuidIndex,
        InstanceIndex,
        InstanceCount,
        InstanceLengthArray,
        BufferAvail,
        Buffer));
	
    switch(GuidIndex)
    {
        case MSFC_FibrePortHBAStatisticsGuidIndex:
        {
            PMSFC_FibrePortHBAStatistics PortStats;
            
            //
            // First thing to do is verify if there is enough room in
            // the output buffer to return all data requested
            //
            InstanceSize = (sizeof(MSFC_FibrePortHBAStatistics)+7)&~7;          
            SizeNeeded = InstanceCount * InstanceSize;
            
            if (BufferAvail >= SizeNeeded)
            {
                //
                // Yes, loop over all instances for the data block and
                // fill in the values for them
                //
                LastIndex = InstanceIndex + InstanceCount;
                for (i = InstanceIndex; i < LastIndex; i++)
                {
                    PortStats = (PMSFC_FibrePortHBAStatistics)Buffer;

                    //
                    // TODO: Initialize values in PortStats for the port
                    //
//                    memset(Buffer, (CHAR)i, InstanceSize);

                    //
                    // Establish a unique value for the port
                    //
                    PortStats->UniquePortId = ((ULONGLONG)CardPtr) + i;
                    
                    Buffer += InstanceSize;
                    *InstanceLengthArray++ = sizeof(MSFC_FibrePortHBAStatistics);
                }
                status = SRB_STATUS_SUCCESS;
            } else {
                status = SRB_STATUS_DATA_OVERRUN;
            }
            
            
            break;
        }

        case MSFC_FibrePortHBAAttributesGuidIndex:
        {
            PMSFC_FibrePortHBAAttributes PortAttributes;
            
            //
            // First thing to do is verify if there is enough room in
            // the output buffer to return all data requested
            //
            InstanceSize = (sizeof(MSFC_FibrePortHBAAttributes)+7)&~7;          
            SizeNeeded = InstanceCount * InstanceSize;
            
            if (BufferAvail >= SizeNeeded)
            {
                //
                // Yes, loop over all instances for the data block and
                // fill in the values for them
                //
                LastIndex = InstanceIndex + InstanceCount;
                for (i = InstanceIndex; i < LastIndex; i++)
                {
                    PortAttributes = (PMSFC_FibrePortHBAAttributes)Buffer;

                    //
                    // TODO: initialize port attribute values properly
                    //
                    memset(Buffer, (CHAR)i, InstanceSize);

#define PORTNAME L"FibrePortName"
                    CopyString(PortAttributes->Attributes.PortSymbolicName,
                               PORTNAME,
                               256);

#define OSDEVICENAME L"OsDeviceName"
                    CopyString(PortAttributes->Attributes.OSDeviceName,
                               OSDEVICENAME,
                               256);

                    //
                    // Establish a unique value for the port
                    //
                    PortAttributes->UniquePortId = ((ULONGLONG)CardPtr) + i;
                    
                    Buffer += InstanceSize;
                    *InstanceLengthArray++ = sizeof(MSFC_FibrePortHBAAttributes);
                }
                status = SRB_STATUS_SUCCESS;
            } else {
                status = SRB_STATUS_DATA_OVERRUN;
            }
            break;
        }

        case MSFC_FCAdapterHBAAttributesGuidIndex:
        {
            PMSFC_FCAdapterHBAAttributes AdapterAttributes;
            
            //
            // First thing to do is verify if there is enough room in
            // the output buffer to return all data requested
            //
            SizeNeeded = (sizeof(MSFC_FCAdapterHBAAttributes));
            
            if (BufferAvail >= SizeNeeded)
            {
                //
                // We know there is always only 1 instance for this
                // guid
                //
                AdapterAttributes = (PMSFC_FCAdapterHBAAttributes)Buffer;

                //
                // TODO: initialize adapter attribute values properly
                //
                memset(Buffer, (CHAR)7, SizeNeeded);
                AdapterAttributes->NumberOfPorts = 8;

#define  MANUFACTURER L"FibreAdapter Manufacturer"
                CopyString(AdapterAttributes->Manufacturer,
                           MANUFACTURER,
                           64);

#define SERIALNUMBER L"FibreAdapter SerialNumber"
                CopyString(AdapterAttributes->SerialNumber,
                           SERIALNUMBER,
                           64);

#define MODEL L"FibreAdapter Model"
                CopyString(AdapterAttributes->Model,
                           MODEL,
                           256);

#define MODELDESCRIPTION L"FibreAdapter ModelDescription"
                CopyString(AdapterAttributes->ModelDescription,
                           MODELDESCRIPTION,
                           256);

#define NODESYMBOLICNAME L"FibreAdapter NodeSymbolicName"
                CopyString(AdapterAttributes->NodeSymbolicName,
                           NODESYMBOLICNAME,
                           256);

#define HARDWAREVERSION L"FibreAdapter HardwareVersion"
                CopyString(AdapterAttributes->HardwareVersion,
                           HARDWAREVERSION,
                           256);

#define DRIVERVERSION L"FibreAdapter DriverVersion"
                CopyString(AdapterAttributes->DriverVersion,
                           DRIVERVERSION,
                           256);

#define OPTIONROMVERSION L"FibreAdapter OptionROMVersion"
                CopyString(AdapterAttributes->OptionROMVersion,
                           OPTIONROMVERSION,
                           256);

#define FIRMWAREVERSION L"FibreAdapter FirmwareVersion"
                CopyString(AdapterAttributes->FirmwareVersion,
                           FIRMWAREVERSION,
                           256);

#define DRIVERNAME L"FibreAdapter DriverName"
                CopyString(AdapterAttributes->DriverName,
                           DRIVERNAME,
                           256);

                
                //
                // Establish a unique value for the Adapter
                //
                AdapterAttributes->UniqueAdapterId = ((ULONGLONG)CardPtr);

                *InstanceLengthArray = sizeof(MSFC_FCAdapterHBAAttributes);
                status = SRB_STATUS_SUCCESS;
            } else {
                status = SRB_STATUS_DATA_OVERRUN;
            }
            break;
        }

        case MSFC_HBAFCPInfoGuidIndex:
        case MSFC_HBAFc3MgmtMethodsGuidIndex:
        case MSFC_FibrePortHBAMethodsGuidIndex:
        case MSFC_HBAPortMethodsGuidIndex:
        {
            //
            // Methods don't return data per se, but must respond to
            // queries with an empty data block. We know that all of
            // these method guids only have one instance
            //
            SizeNeeded = sizeof(ULONG);
            
            if (BufferAvail >= SizeNeeded)
            {
                status = SRB_STATUS_SUCCESS;
            } else {
                status = SRB_STATUS_DATA_OVERRUN;
            }
            break;
        }

        default:
        {
            status = SRB_STATUS_ERROR;
            break;
        }
    }

    ScsiPortWmiPostProcess(
                                  DispatchContext,
                                  status,
                                  SizeNeeded);

    return FALSE;
}

//
// Name of MOF resource as specified in the RC file
//
#define Wmi_MofResourceName        L"MofResource"

UCHAR
QueryWmiRegInfo(
    IN PVOID Context,
    IN PSCSIWMI_REQUEST_CONTEXT DispatchContext,
    OUT PWCHAR *MofResourceName
    )
{

//
// Mof for HBA api implementation is not needed so this is commented
// out. If adapter specific classes are added then you'll need to
// specify the MOF resource name to WMI
//
//    *MofResourceName = Wmi_MofResourceName;

    return SRB_STATUS_SUCCESS;
}

BOOLEAN
WmiExecuteMethod (
    IN PVOID Context,
    IN PSCSIWMI_REQUEST_CONTEXT DispatchContext,
    IN ULONG GuidIndex,
    IN ULONG InstanceIndex,
    IN ULONG MethodId,
    IN ULONG InBufferSize,
    IN ULONG OutBufferSize,
    IN OUT PUCHAR Buffer
    )
{
    PHW_DEVICE_EXTENSION CardPtr = (PHW_DEVICE_EXTENSION)Context;
    ULONG sizeNeeded = 0;
    UCHAR status;
    ULONG i;

    DebugPrint((1, "WmiExecuteMethod(%x,\n%x,\n%x,\n%x,\n%x,\n%x,\n%x,\n%x)\n",
        Context,
            DispatchContext,
                GuidIndex,
                    InstanceIndex,
                        MethodId,
                        InBufferSize,
                        OutBufferSize,
                             Buffer));
	
    switch(GuidIndex)
    {            
        case MSFC_FibrePortHBAMethodsGuidIndex:
        {
            switch(MethodId)
            {
                //
                //     void ResetStatistics();
                //
                case ResetStatistics:
                {
                    //
                    // No input or output buffers expected so no
                    // validation needed. InstanceIndex has the Port
                    // Index
                    //

                    //
                    // TODO: Do what is needed to reset port
                    //       statistics. The index to the port is the
                    //       InstanceIndex parameter
                    //
                    sizeNeeded = 0;
                    status = SRB_STATUS_SUCCESS;
                    break;
                }

                default:
                {
                    status = SRB_STATUS_ERROR;
                    break;
                }
            }
            break;
        }

        case MSFC_HBAPortMethodsGuidIndex:
        {
            switch(MethodId)
            {

                //              
                //    void GetDiscoveredPortAttributes(
                //            [in
                //             ] uint32 PortIndex,
                //
                //             [in] uint32 DiscoveredPortIndex,
                //
                //             [out,
                //              HBAType("HBA_PORTATTRIBUTES")
                //             ] MSFC_HBAPortAttributesResults PortAttributes);
                //
                case GetDiscoveredPortAttributes:
                {
                    //
                    // Validate that the input buffer is the correct
                    // size and the output buffer is large enough
                    //
                    if (InBufferSize >= sizeof(GetDiscoveredPortAttributes_IN))
                    {
                        sizeNeeded = sizeof(GetDiscoveredPortAttributes_OUT);
                        if (OutBufferSize >= sizeNeeded)
                        {
                            PGetDiscoveredPortAttributes_IN In;
                            PGetDiscoveredPortAttributes_OUT Out;

                            In = (PGetDiscoveredPortAttributes_IN)Buffer;
                            Out = (PGetDiscoveredPortAttributes_OUT)Buffer;

                            //
                            // TODO: Examine In->PortIndex and
                            //       In->DiscoveredPortIndex and
                            //       validate that they are correct.
                            //

                            //
                            // TODO: Fill Out->PortAttributes with
                            //       correct values.
                            //
                            memset(&Out->PortAttributes,
                                   3,
                                   sizeof(MSFC_HBAPortAttributesResults));
                            
                            CopyString(Out->PortAttributes.PortSymbolicName,
                                       PORTNAME,
                                       256);

                            CopyString(Out->PortAttributes.OSDeviceName,
                                       OSDEVICENAME,
                                       256);

                            status = SRB_STATUS_SUCCESS;
                        } else {
                            status = SRB_STATUS_DATA_OVERRUN;
                        }
                    } else {
                        status = SRB_STATUS_ERROR;
                    }
                    break;
                }

                case GetPortAttributesByWWN:
                {            
                    //
                    // Validate that the input buffer is the correct
                    // size and the output buffer is large enough
                    //
                    if (InBufferSize >= sizeof(GetPortAttributesByWWN_IN))
                    {
                        sizeNeeded = sizeof(GetPortAttributesByWWN_OUT);
                        if (OutBufferSize >= sizeNeeded)
                        {
                            PGetPortAttributesByWWN_IN In;
                            PGetPortAttributesByWWN_OUT Out;

                            In = (PGetPortAttributesByWWN_IN)Buffer;
                            Out = (PGetPortAttributesByWWN_OUT)Buffer;

                            //
                            // TODO: Examine In->wwn to                         //       In->DiscoveredPortIndex and
                            //       validate that it is correct.
                            //

                            //
                            // TODO: Fill Out->PortAttributes with
                            //       correct values.
                            //
                            memset(&Out->PortAttributes,
                                   3,
                                   sizeof(MSFC_HBAPortAttributesResults));
                            
                            CopyString(Out->PortAttributes.PortSymbolicName,
                                       PORTNAME,
                                       256);

                            CopyString(Out->PortAttributes.OSDeviceName,
                                       OSDEVICENAME,
                                       256);

                            status = SRB_STATUS_SUCCESS;
                        } else {
                            status = SRB_STATUS_DATA_OVERRUN;
                        }
                    } else {
                        status = SRB_STATUS_ERROR;
                    }
                    break;
                }

                default:
                {
                    status = SRB_STATUS_ERROR;
                    break;
                }
            }
            break;
        }

        case MSFC_HBAFc3MgmtMethodsGuidIndex:
        {
            switch(MethodId)
            {
                case SendCTPassThru:
                {
                    PSendCTPassThru_IN In;
                    PSendCTPassThru_OUT Out;
                    ULONG RequestCount, ResponseCount;
                    ULONG InSizeNeeded;
                    
                    //
                    // Validate that the input buffer is the correct
                    // size and the output buffer is large enough
                    //
                    if (InBufferSize >= sizeof(ULONG))
                    {
                        In = (PSendCTPassThru_IN)Buffer;
                        
                        RequestCount = In->RequestBufferCount;
                        InSizeNeeded = sizeof(SendCTPassThru_IN) - 1 + RequestCount;
                        if (InBufferSize >= InSizeNeeded)
                        {
#define RESPONSE_BUFFER_SIZE 0x1000
                            ResponseCount = RESPONSE_BUFFER_SIZE;
                            sizeNeeded = sizeof(SendCTPassThru_OUT) - 1 + ResponseCount;
                            
                            if (OutBufferSize >= sizeNeeded)
                            {
                                Out = (PSendCTPassThru_OUT)Buffer;

                                //
                                // TODO: Do the CT Pass thru
                                //

                                //
                                // TODO: Fill the output buffer with
                                //       results
                                //
                                Out->ResponseBufferCount = ResponseCount;
                                memset(Out->ResponseBuffer,
                                       7,
                                       ResponseCount);
                            

                                status = SRB_STATUS_SUCCESS;
                            } else {
                                status = SRB_STATUS_DATA_OVERRUN;
                            }
                        } else {
                            status = SRB_STATUS_ERROR;
                        }
                    } else {
                        status = SRB_STATUS_ERROR;
                    }
                    break;
                }

                case SendRNID:
                {            
                    PSendRNID_IN In;
                    PSendRNID_OUT Out;
                    ULONG ResponseCount;
                    ULONG InSizeNeeded;
                    
                    //
                    // Validate that the input buffer is the correct
                    // size and the output buffer is large enough
                    //
                    if (InBufferSize >= sizeof(SendRNID_IN))
                    {

                        ResponseCount = 72;
                        sizeNeeded = sizeof(SendRNID_OUT) - 1 + ResponseCount;

                        if (OutBufferSize >= sizeNeeded)
                        {
                            In = (PSendRNID_IN)Buffer;
                            Out = (PSendRNID_OUT)Buffer;

                            //
                            // TODO: Do the SendRNID
                            //

                            //
                            // TODO: Fill the output buffer with
                            //       results
                            //
                            Out->ResponseBufferCount = ResponseCount;
                            memset(Out->ResponseBuffer,
                                   7,
                                   ResponseCount);


                            status = SRB_STATUS_SUCCESS;
                        } else {
                            status = SRB_STATUS_DATA_OVERRUN;
                        }
                    } else {
                        status = SRB_STATUS_ERROR;
                    }
                    break;
                }

				case GetFC3MgmtInfo:
				{
					PGetFC3MgmtInfo_OUT Out;

					Out = (PGetFC3MgmtInfo_OUT)Buffer;
					
					sizeNeeded = sizeof(GetFC3MgmtInfo_OUT);
					if (OutBufferSize >= sizeNeeded)
					{
						memset(Buffer, 0x99, sizeNeeded);
						Out->HBAStatus = 0;
						status = SRB_STATUS_SUCCESS;
					} else {
						status = SRB_STATUS_DATA_OVERRUN;
					}
								 
					break;
				};

				case SetFC3MgmtInfo:
				{
					PSetFC3MgmtInfo_OUT Out;

					Out = (PSetFC3MgmtInfo_OUT)Buffer;
					
					sizeNeeded = sizeof(SetFC3MgmtInfo_OUT);
					if (OutBufferSize >= sizeNeeded)
					{
						Out->HBAStatus = 0;
						status = SRB_STATUS_SUCCESS;
					} else {
						status = SRB_STATUS_DATA_OVERRUN;
					}
					break;
				}

                default:
                {
                    status = SRB_STATUS_ERROR;
                    break;
                }
            }
            break;
        }

        case MSFC_HBAFCPInfoGuidIndex:
        {
            switch(MethodId)
            {
                case GetFcpTargetMapping:
                {
                    PGetFcpTargetMapping_OUT Out;
                    
                    //
                    // TODO: Change this code to return the correct
                    //       number of mappings and the correct
                    //       mappings
                    //
#define FCPTargetMappingCount 0x20                  
                    sizeNeeded = sizeof(GetFcpTargetMapping_OUT) -
                                 sizeof(HBAFCPScsiEntry) +
                                 FCPTargetMappingCount * sizeof(HBAFCPScsiEntry);
                    if (OutBufferSize >= sizeNeeded)
                    {
                        Out = (PGetFcpTargetMapping_OUT)Buffer;
                        Out->EntryCount = FCPTargetMappingCount;
                        for (i = 0; i < FCPTargetMappingCount; i++)
                        {
                            memset(&Out->Entry[i],
                                   3,
                                   sizeof(HBAFCPScsiEntry));
                            
                            CopyString(Out->Entry[i].ScsiId.OSDeviceName,
                                       OSDEVICENAME,
                                       256);
                        }
						
						status = SRB_STATUS_SUCCESS;						
                    } else {
						status = SRB_STATUS_DATA_OVERRUN;						
					}
                    break;
                }

                case GetFcpPersistentBinding:
                {
                    PGetFcpPersistentBinding_OUT Out;
                    
                    //
                    // TODO: Change this code to return the correct
                    //       number of mappings and the correct
                    //       mappings
                    //
#define FCPPersistentBindingCount 0x20                  
                    sizeNeeded = sizeof(GetFcpPersistentBinding_OUT) -
                                 sizeof(HBAFCPBindingEntry) +
                                 FCPPersistentBindingCount * sizeof(HBAFCPBindingEntry);
                    if (OutBufferSize >= sizeNeeded)
                    {
                        Out = (PGetFcpPersistentBinding_OUT)Buffer;
                        Out->EntryCount = FCPPersistentBindingCount;
                        for (i = 0; i < FCPPersistentBindingCount; i++)
                        {
                            memset(&Out->Entry[i],
                                   3,
                                   sizeof(HBAFCPBindingEntry));
                            
                            CopyString(Out->Entry[i].ScsiId.OSDeviceName,
                                       OSDEVICENAME,
                                       256);
                        }
						
						status = SRB_STATUS_SUCCESS;						
                    } else {
						status = SRB_STATUS_DATA_OVERRUN;						
                    }
                    break;
                }

                default:
                {
                    status = SRB_STATUS_ERROR;
                    break;
                }
            }
            break;
        }

        default:
        {
            status = SRB_STATUS_ERROR;
        }
    }

    ScsiPortWmiPostProcess(
                                  DispatchContext,
                                  status,
                                  sizeNeeded);

    return(FALSE);    
}


BOOLEAN
WmiSetDataBlock (
    IN PVOID Context,
    IN PSCSIWMI_REQUEST_CONTEXT DispatchContext,
    IN ULONG GuidIndex,
    IN ULONG InstanceIndex,
    IN ULONG BufferSize,
    IN PUCHAR Buffer
    )
{
    PHW_DEVICE_EXTENSION CardPtr = (PHW_DEVICE_EXTENSION)Context;
    UCHAR status;

    DebugPrint((1, "WmiSetDataBlock(%x,\n%x,\n%x,\n%x,\n%x,\n%x)\n",
        Context,
            DispatchContext,
                GuidIndex,
                    InstanceIndex,
                        BufferSize,
                             Buffer));

    switch(GuidIndex)
    {

        case MSFC_HBAFCPInfoGuidIndex:
        case MSFC_HBAFc3MgmtMethodsGuidIndex:
        case MSFC_FibrePortHBAMethodsGuidIndex:
        case MSFC_HBAPortMethodsGuidIndex:
        case MSFC_FibrePortHBAAttributesGuidIndex:
        case MSFC_FCAdapterHBAAttributesGuidIndex:
        case MSFC_FibrePortHBAStatisticsGuidIndex:
        {
            //
            // These are read only
            //
            status = SRB_STATUS_ERROR;
            break;
        }
        
        default:
        {
            status = SRB_STATUS_ERROR;
            break;
        }
    }

    ScsiPortWmiPostProcess(
                                  DispatchContext,
                                  status,
                                  0);
    return(FALSE);  
}

BOOLEAN
WmiSetDataItem (
    IN PVOID Context,
    IN PSCSIWMI_REQUEST_CONTEXT DispatchContext,
    IN ULONG GuidIndex,
    IN ULONG InstanceIndex,
    IN ULONG DataItemId,
    IN ULONG BufferSize,
    IN PUCHAR Buffer
    )
{
    UCHAR status;
    
    DebugPrint((1, "WmiSetDataItem(%x,\n%x,\n%x,\n%x,\n%x,\n%x,\n%x)\n",
        Context,
            DispatchContext,
                GuidIndex,
                    InstanceIndex,
                        DataItemId,
                        BufferSize,
                             Buffer));

	//
	// SetDataItem does not need to be supported
	//
	status = SRB_STATUS_ERROR;

    ScsiPortWmiPostProcess(
                                  DispatchContext,
                                  status,
                                  0);

    return(FALSE);    
}

    
BOOLEAN
WmiFunctionControl (
    IN PVOID Context,
    IN PSCSIWMI_REQUEST_CONTEXT DispatchContext,
    IN ULONG GuidIndex,
    IN SCSIWMI_ENABLE_DISABLE_CONTROL Function,
    IN BOOLEAN Enable
    )
{
    UCHAR status = SRB_STATUS_SUCCESS;

    DebugPrint((1, "WmiFunctionControl(%x,\n%x,\n%x,\n%x,\n%x)\n\n",
        Context,
            DispatchContext,
                GuidIndex,
                    Function,
                             Enable));
	
    switch(GuidIndex)
    {
        case MSFC_FibrePortHBAStatisticsGuidIndex:
        {
            //
            // TODO: Delete this entire case if data block does not have the
            //       WMIREG_FLAG_EXPENSIVE flag set
            //
            if (Enable)
            {
                //
                // TODO: Datablock collection is being enabled. If this
                //       data block has been marked as expensive in the
                //       guid list then this code will be called when the
                //       first data consumer opens this data block. If
                //       anything needs to be done to allow data to be 
                //       collected for this data block then it should be
                //       done here
                //
            } else {
                //
                // TODO: Datablock collection is being disabled. If this
                //       data block has been marked as expensive in the
                //       guid list then this code will be called when the
                //       last data consumer closes this data block. If
                //       anything needs to be done to cleanup after data has 
                //       been collected for this data block then it should be
                //       done here
                //
            }
            break;
        }

        case MSFC_FibrePortHBAAttributesGuidIndex:
        {
            //
            // TODO: Delete this entire case if data block does not have the
            //       WMIREG_FLAG_EXPENSIVE flag set
            //
            if (Enable)
            {
                //
                // TODO: Datablock collection is being enabled. If this
                //       data block has been marked as expensive in the
                //       guid list then this code will be called when the
                //       first data consumer opens this data block. If
                //       anything needs to be done to allow data to be 
                //       collected for this data block then it should be
                //       done here
                //
            } else {
                //
                // TODO: Datablock collection is being disabled. If this
                //       data block has been marked as expensive in the
                //       guid list then this code will be called when the
                //       last data consumer closes this data block. If
                //       anything needs to be done to cleanup after data has 
                //       been collected for this data block then it should be
                //       done here
                //
            }
            break;
        }

        case MSFC_FibrePortHBAMethodsGuidIndex:
        {
            //
            // TODO: Delete this entire case if data block does not have the
            //       WMIREG_FLAG_EXPENSIVE flag set
            //
            if (Enable)
            {
                //
                // TODO: Datablock collection is being enabled. If this
                //       data block has been marked as expensive in the
                //       guid list then this code will be called when the
                //       first data consumer opens this data block. If
                //       anything needs to be done to allow data to be 
                //       collected for this data block then it should be
                //       done here
                //
            } else {
                //
                // TODO: Datablock collection is being disabled. If this
                //       data block has been marked as expensive in the
                //       guid list then this code will be called when the
                //       last data consumer closes this data block. If
                //       anything needs to be done to cleanup after data has 
                //       been collected for this data block then it should be
                //       done here
                //
            }
            break;
        }

        case MSFC_FCAdapterHBAAttributesGuidIndex:
        {
            //
            // TODO: Delete this entire case if data block does not have the
            //       WMIREG_FLAG_EXPENSIVE flag set
            //
            if (Enable)
            {
                //
                // TODO: Datablock collection is being enabled. If this
                //       data block has been marked as expensive in the
                //       guid list then this code will be called when the
                //       first data consumer opens this data block. If
                //       anything needs to be done to allow data to be 
                //       collected for this data block then it should be
                //       done here
                //
            } else {
                //
                // TODO: Datablock collection is being disabled. If this
                //       data block has been marked as expensive in the
                //       guid list then this code will be called when the
                //       last data consumer closes this data block. If
                //       anything needs to be done to cleanup after data has 
                //       been collected for this data block then it should be
                //       done here
                //
            }
            break;
        }

        case MSFC_HBAPortMethodsGuidIndex:
        {
            //
            // TODO: Delete this entire case if data block does not have the
            //       WMIREG_FLAG_EXPENSIVE flag set
            //
            if (Enable)
            {
                //
                // TODO: Datablock collection is being enabled. If this
                //       data block has been marked as expensive in the
                //       guid list then this code will be called when the
                //       first data consumer opens this data block. If
                //       anything needs to be done to allow data to be 
                //       collected for this data block then it should be
                //       done here
                //
            } else {
                //
                // TODO: Datablock collection is being disabled. If this
                //       data block has been marked as expensive in the
                //       guid list then this code will be called when the
                //       last data consumer closes this data block. If
                //       anything needs to be done to cleanup after data has 
                //       been collected for this data block then it should be
                //       done here
                //
            }
            break;
        }

        case MSFC_HBAFc3MgmtMethodsGuidIndex:
        {
            //
            // TODO: Delete this entire case if data block does not have the
            //       WMIREG_FLAG_EXPENSIVE flag set
            //
            if (Enable)
            {
                //
                // TODO: Datablock collection is being enabled. If this
                //       data block has been marked as expensive in the
                //       guid list then this code will be called when the
                //       first data consumer opens this data block. If
                //       anything needs to be done to allow data to be 
                //       collected for this data block then it should be
                //       done here
                //
            } else {
                //
                // TODO: Datablock collection is being disabled. If this
                //       data block has been marked as expensive in the
                //       guid list then this code will be called when the
                //       last data consumer closes this data block. If
                //       anything needs to be done to cleanup after data has 
                //       been collected for this data block then it should be
                //       done here
                //
            }
            break;
        }

        case MSFC_HBAFCPInfoGuidIndex:
        {
            //
            // TODO: Delete this entire case if data block does not have the
            //       WMIREG_FLAG_EXPENSIVE flag set
            //
            if (Enable)
            {
                //
                // TODO: Datablock collection is being enabled. If this
                //       data block has been marked as expensive in the
                //       guid list then this code will be called when the
                //       first data consumer opens this data block. If
                //       anything needs to be done to allow data to be 
                //       collected for this data block then it should be
                //       done here
                //
            } else {
                //
                // TODO: Datablock collection is being disabled. If this
                //       data block has been marked as expensive in the
                //       guid list then this code will be called when the
                //       last data consumer closes this data block. If
                //       anything needs to be done to cleanup after data has 
                //       been collected for this data block then it should be
                //       done here
                //
            }
            break;
        }

        
        default:
        {
            status = SRB_STATUS_ERROR;
            break;
        }
    }
    
    ScsiPortWmiPostProcess(
                                  DispatchContext,
                                  status,
                                  0);

    return(FALSE);    
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\port\scsi\miniport\hipoint\hpt3xx\inc\dam.hpp ===
/*++
Copyright (c) HighPoint Technologies, Inc. 2000

Module Name:
    DAM.hpp

Abstract:
    Encapsulates the interface of Disk Array Management

Author:
    Liu Ge (LG)

Environment:
    Win32 User Mode Only    
    
Revision History:
    07-16-2000  Created initiallly
--*/
#ifndef DiskArrayManagement_HPP_
#define DiskArrayManagement_HPP_

#include "dam.h"

//  The following are defined only for applications 
//  just like the interface program of DAM

#ifndef AbstractIterator_H_
#include "..\OWF_TCK\EnumIt.h"
#endif
#ifndef Progress_Control_H_
#include "..\HPT_DEV\progress.h"
#endif

#pragma warning( disable : 4290 ) 

#define MAIN_BOOT_SECTOR    0

class XFailedToLoadLog{};

#ifdef KEEP_UNUSED_CODE

ostream & operator << (ostream & os, const St_DiskPhysicalId & id );
istream & operator >> (istream & is, St_DiskPhysicalId & id );

ostream & operator << (ostream & os, const St_DiskFailure & Data );
istream & operator >> (istream & is, St_DiskFailureInLog & Data );

ostream & operator << (ostream & os, const St_DiskArrayEvent & Data );
istream & operator >> (istream & is, St_DiskArrayEvent & Data ) throw (XFailedToLoadLog);

#endif

class ClDiskArrayIterator : public TypeIterator<St_FindDisk>
{
protected:
    St_FindDisk m_Info;
    HFIND_DISK m_hSearchHandle;
    BOOL m_hasFound;
public:
    ClDiskArrayIterator(HDISK hRoot) 
    { 
        m_hSearchHandle = ::DiskArray_FindFirst(hRoot, &m_Info);
        m_hasFound = (m_hSearchHandle != INVALID_HANDLE_VALUE);
    }
    ~ClDiskArrayIterator()
    {
        if( m_hSearchHandle != INVALID_HANDLE_VALUE )
        {
            ::DiskArray_FindClose(m_hSearchHandle);
        }
    }
    virtual operator int() const { return m_hasFound; }
	virtual Abs_Iterator & operator ++()
    {
        if( m_hSearchHandle != INVALID_HANDLE_VALUE )
        {
            m_hasFound = ::DiskArray_FindNext(m_hSearchHandle, &m_Info);
        }
        return *this;
    }
	virtual St_FindDisk & operator *() { return m_Info; }
};

#ifdef KEEP_UNUSED_CODE

class ClCreatingStripping : public St_ProgressControl
{
public:
    typedef void (*PFN_Notification)(ClCreatingStripping &);
    typedef struct
    {
        HDISK * pDisks;
        ULONG uDiskNum;
        int nStripSizeShift;
    }St_Parameters;

    struct St_Status : 
        public St_ProgressStatus, 
        public St_Parameters
    {
        HDISK hFailedDisk;
        ULONG uFailedBlock;
    };

    ClCreatingStripping(HDISK * pDisks, ULONG uDiskNum, int nStripSizeShift, PFN_Notification);

    BOOL getStatus(St_Status & Status)
    {
        (St_ProgressStatus &)Status = (St_ProgressStatus &)*this;
        (St_Parameters &)Status = m_Parameters;
        return TRUE;
    }

protected:
    St_Parameters m_Parameters;
    
    BOOL DoCreating();

    static DWORD WINAPI Creating(ClCreatingStripping * pCreating);
};
#endif // KEEP_UNUSED_CODE

class ClRebuildingMirror : public St_ProgressControl
{
public:
    typedef void (*PFN_Notification)(ClRebuildingMirror &);

    struct St_Status : public St_ProgressStatus
    {
        HDISK hMirror;
        HDISK hFailedDisk;
        ULONG uFailedBlock;
    };

    ClRebuildingMirror(HDISK hMirror, PFN_Notification);

    BOOL getStatus(St_Status & Status)
    {
        (St_ProgressStatus &)Status = (St_ProgressStatus &)*this;
        Status.hMirror = m_hBeingRebuilt;
        return TRUE;
    }
    virtual BOOL stop();
	//CZHANG ADD IT
	int   m_nRebuildType;
	// 0-----normal 
	// 1---- rebuild after  broken mirror
    // 2-----rebuild after create mirror immediately

    HDISK             m_hBeingRebuilt;
	BOOL				m_bValidateWhenAbort;
protected:
    HMIRROR_BUILDER   m_hBuilder;
	//CZHANG ADD IT
	ULONG             uLba;
	
    
    BOOL    DoRebuilding();

    static DWORD WINAPI Rebuilding(ClRebuildingMirror * pRebuilding);
};

#endif // DiskArrayManagement_HPP_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\port\scsi\miniport\hipoint\hpt3xx\inc\hpinfo.h ===
/*++
Copyright (c) 1999, HighPoint Technologies, Inc.

Module Name:
    HpInfo.h - include file 

Abstract:

Author:
    HongSheng Zhang (HS)

Environment:

Notes:

Revision History:
    12-02-99    Created initiallly

--*/
#ifndef __HPINFO_H__
#define __HPINFO_H__
					 
//#include "hptenum.h"
#include "hptioctl.h"

///////////////////////////////////////////////////////////////////////
// macro define area
///////////////////////////////////////////////////////////////////////
#if	!defined(EXTERNC)
	#if defined(__cplusplus)
		#define EXTERNC	extern "C"
	#else					  
		#define EXTERNC extern
	#endif	// __cplusplus
#endif	// EXTERNC
///////////////////////////////////////////////////////////////////////
// function declare area
///////////////////////////////////////////////////////////////////////
EXTERNC
   HANDLE WINAPI HptConnectPort(int iPortId);
EXTERNC	
   VOID WINAPI HptReleasePort(HANDLE hPort);
EXTERNC
   BOOL WINAPI HptGetPhysicalDeviceInfo(HANDLE hPort, int iDeviceId, PSt_PHYSICAL_DEVINFO pDeviceInfo);
EXTERNC
   BOOL WINAPI HptCreateDiskArray(HANDLE hPort, int iDeviceId1, int iDeviceId2, BOOL fStripe);
EXTERNC
   BOOL WINAPI HptRemoveDiskArray(HANDLE hPort, int iDeviceId1, int iDeviceId2);
EXTERNC
   VOID WINAPI HptSwitchPower(HANDLE hPort, ULONG bPowerState);
EXTERNC
   DWORD WINAPI HptWaitForWarning(HANDLE hStopEvent);
#endif	// __HPINFO_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\port\scsi\miniport\hipoint\hpt3xx\inc\hptenum.h ===
/*++
Copyright (c) 2000, HighPoint Technologies, Inc.

Module Name:
    HptEnum.h - include file 

Abstract:

Author:
    HongSheng Zhang (HS)

Environment:

Notes:

Revision History:
    02-22-2000  Created initiallly

--*/

#ifndef __HPT_ENUM_H__
#define __HPT_ENUM_H__

///////////////////////////////////////////////////////////////////////
// HPT controller adapter I/O control structure
///////////////////////////////////////////////////////////////////////
#include "pshpack1.h"	// make sure use pack 1
///////////////////////////////////////////////////////////////////////
// Enumerator define area
///////////////////////////////////////////////////////////////////////
//
// IDE id
//	In furure, this enumerator will be canceled. we'll use SCSI LUN sturture
// to indicate a device.
typedef enum  IDE_ID{
	IDE_PRIMARY_MASTER,
	IDE_PRIMARY_SLAVE,
	IDE_SECONDARY_MASTER,
	IDE_SECONDARY_SLAVE,
}IDE_ABS_DEVID;

//
// device type
//	same as SCSI declaration, except DEVTYPE_FLOPPY_DEVICE
typedef enum _eu_DEVICETYPE{
	DEVTYPE_DIRECT_ACCESS_DEVICE, DEVTYPE_DISK = DEVTYPE_DIRECT_ACCESS_DEVICE,
	DEVTYPE_SEQUENTIAL_ACCESS_DEVICE, DEVTYPE_TAPE = DEVTYPE_SEQUENTIAL_ACCESS_DEVICE,
	DEVTYPE_PRINTER_DEVICE,
	DEVTYPE_PROCESSOR_DEVICE,
	DEVTYPE_WRITE_ONCE_READ_MULTIPLE_DEVICE, DEVTYPE_WORM = DEVTYPE_WRITE_ONCE_READ_MULTIPLE_DEVICE,
	DEVTYPE_READ_ONLY_DIRECT_ACCESS_DEVICE, DEVTYPE_CDROM = DEVTYPE_READ_ONLY_DIRECT_ACCESS_DEVICE,
	DEVTYPE_SCANNER_DEVICE,
	DEVTYPE_OPTICAL_DEVICE,
	DEVTYPE_MEDIUM_CHANGER,
	DEVTYPE_COMMUNICATION_DEVICE,
	DEVTYPE_FLOPPY_DEVICE
}Eu_DEVICETYPE;
#include <poppack.h>	// pop the pack number
#endif	// __HPT_ENUM_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\port\scsi\miniport\hipoint\hpt3xx\inc\hptioctl.h ===
/*++
Copyright (c) 1999, HighPoint Technologies, Inc.

Module Name:
    HptIoctl.h - include file 

Abstract:

Author:
    HongSheng Zhang (HS)

Environment:

Notes:

Revision History:
    12-07-99    Created initiallly
	2-22-00		gmm modify ioctl code definition
--*/

#ifndef __HPTIOCTL_H__
#define __HPTIOCTL_H__

///////////////////////////////////////////////////////////////////////
// HPT controller adapter I/O control code
///////////////////////////////////////////////////////////////////////

#define HPT_IOCTL_BASE	0x0370
#define HPT_MINIDEVICE_TYPE HPT_IOCTL_BASE
	  
#ifndef CTL_CODE

#define CTL_CODE( DeviceType, Function, Method, Access ) \
			(((DeviceType) << 16) | ((Access) << 14) | ((Function) << 2) | (Method))
#define METHOD_BUFFERED                 0
#define METHOD_IN_DIRECT                1
#define METHOD_OUT_DIRECT               2
#define METHOD_NEITHER                  3
#define FILE_ANY_ACCESS                 0
#define FILE_READ_ACCESS          ( 0x0001 )    // file & pipe
#define FILE_WRITE_ACCESS         ( 0x0002 )    // file & pipe

#endif

#define HPT_CTL_CODE(x) \
			CTL_CODE(HPT_MINIDEVICE_TYPE, x, METHOD_BUFFERED, FILE_ANY_ACCESS)

///////////////////////////////////////////////////////////////////////
// HPT device I/O function code
///////////////////////////////////////////////////////////////////////
//
//Generic I/O function codes
//
#define IOCTL_HPT_GET_VERSION				HPT_CTL_CODE(0x900)
#define IOCTL_HPT_GET_IDENTIFY_INFO			HPT_CTL_CODE(0x901)
#define IOCTL_HPT_GET_CAPABILITY_DATA		HPT_CTL_CODE(0x902)
#define IOCTL_HPT_IDE_READ_SECTORS			HPT_CTL_CODE(0x903)
#define IOCTL_HPT_IDE_WRITE_SECTORS			HPT_CTL_CODE(0x904)
#define IOCTL_HPT_GET_FULL_IDENTIFY_INFO	HPT_CTL_CODE(0x905)
#define IOCTL_HPT_GET_LAST_ERROR			HPT_CTL_CODE(0x906)
#define IOCTL_HPT_LOCK_BLOCK				HPT_CTL_CODE(0x907)
#define IOCTL_HPT_UNLOCK_BLOCK				HPT_CTL_CODE(0x908)
#define IOCTL_HPT_EXECUTE_CDB				HPT_CTL_CODE(0x909)
#define IOCTL_HPT_GET_LAST_ERROR_DEVICE		HPT_CTL_CODE(0x90A)
#define IOCTL_HPT_SCSI_PASSTHROUGH			HPT_CTL_CODE(0x90B)
#define IOCTL_HPT_MINIPORT_SET_ARRAY_NAME	HPT_CTL_CODE(0x90C)
/* add for rescan the adapters and devices*/
#define IOCTL_HPT_MINIPORT_RESCAN_ALL		HPT_CTL_CODE(0x90D)

#define IOCTL_HPT_GET_DRIVER_CAPABILITIES   HPT_CTL_CODE(0x910)

//
//RAID I/O function codes
//
#define IOCTL_HPT_GET_RAID_INFO				HPT_CTL_CODE(0xA00)
#define IOCTL_HPT_GET_ARRAY					HPT_CTL_CODE(0xA01)
#define IOCTL_HPT_UPDATE_RAID_INFO			HPT_CTL_CODE(0xA02)
#define IOCTL_HPT_SET_NOTIFY_EVENT			HPT_CTL_CODE(0xA03)
#define IOCTL_HPT_REMOVE_NOTIFY_EVENT		HPT_CTL_CODE(0xA04)
#define IOCTL_HPT_CREATE_MIRROR				HPT_CTL_CODE(0xA05)
#define IOCTL_HPT_CREATE_STRIPE				HPT_CTL_CODE(0xA06)
#define IOCTL_HPT_CREATE_SPAN				HPT_CTL_CODE(0xA07)
#define IOCTL_HPT_REMOVE_RAID				HPT_CTL_CODE(0xA08)
#define IOCTL_HPT_CREATE_RAID10				HPT_CTL_CODE(0xA09)
#define IOCTL_HPT_CHECK_NOTIFY_EVENT		HPT_CTL_CODE(0xA0A)
//
//Hotswap I/O function codes
//																				
#define IOCTL_HPT_CHECK_HOTSWAP				HPT_CTL_CODE(0xB00)
#define IOCTL_HPT_SWITCH_POWER				HPT_CTL_CODE(0xB01)
#define IOCTL_HPT_REMOVE_DEVICE				HPT_CTL_CODE(0xB02)

//
// Raid enumerate I/O function codes for LiuGe
//
#define IOCTL_HPT_ENUM_GET_DEVICE_INFO 		HPT_CTL_CODE(0xC00)
#define IOCTL_HPT_ENUM_GET_DEVICE_CHILD 	HPT_CTL_CODE(0xC01)
#define IOCTL_HPT_ENUM_GET_DEVICE_SIBLING	HPT_CTL_CODE(0xC02)
#define IOCTL_HPT_ENUM_GET_CONTROLLER_NUMBER	HPT_CTL_CODE(0xC03)
#define IOCTL_HPT_ENUM_GET_CONTROLLER_INFO 	HPT_CTL_CODE(0xC04)
#define IOCTL_HPT_BEGIN_REBUILDING_MIRROR  	HPT_CTL_CODE(0xC05)
#define IOCTL_HPT_VALIDATE_MIRROR    		HPT_CTL_CODE(0xC06)
#define IOCTL_HPT_ABORT_MIRROR_REBUILDING   HPT_CTL_CODE(0xC07)

//
// XStore Pro I/O function codes
//
#define IOCTL_HPT_SET_XPRO					HPT_CTL_CODE(0xE00)

//
// Disable/Enable Device I/O function codes
//
#define IOCTL_HPT_ENABLE_DEVICE				HPT_CTL_CODE(0xE01)
#define IOCTL_HPT_DISABLE_DEVICE			HPT_CTL_CODE(0xE02)

//
// Add/Remove Disk I/O function codes
//
#define IOCTL_HPT_ADD_SPARE_DISK			HPT_CTL_CODE(0xE03)
#define IOCTL_HPT_DEL_SPARE_DISK			HPT_CTL_CODE(0xE04)
#define IOCTL_HPT_ADD_MIRROR_DISK			HPT_CTL_CODE(0xE05)

//
// All diagnostic I/O function codes
//
#define IOCTL_HPT_DIAG_RAISE_ERROR			HPT_CTL_CODE(0xF00)
#define IOCTL_HPT_STOP_BUZZER               HPT_CTL_CODE(0xF01)

///////////////////////////////////////////////////////////////////////
// HPT Miniport redefinitions
///////////////////////////////////////////////////////////////////////
#define IOCTL_HPT_MINIPORT_GET_VERSION					IOCTL_HPT_GET_VERSION
#define IOCTL_HPT_MINIPORT_GET_IDENTIFY_INFO	 		IOCTL_HPT_GET_IDENTIFY_INFO	 
#define IOCTL_HPT_MINIPORT_GET_CAPABILITY_DATA	 		IOCTL_HPT_GET_CAPABILITY_DATA	 
#define IOCTL_HPT_MINIPORT_IDE_READ_SECTORS		 		IOCTL_HPT_IDE_READ_SECTORS		 
#define IOCTL_HPT_MINIPORT_IDE_WRITE_SECTORS	 		IOCTL_HPT_IDE_WRITE_SECTORS	 
#define IOCTL_HPT_MINIPORT_GET_FULL_IDENTIFY_INFO		IOCTL_HPT_GET_FULL_IDENTIFY_INFO	  
#define IOCTL_HPT_MINIPORT_GET_LAST_ERROR				IOCTL_HPT_GET_LAST_ERROR
#define IOCTL_HPT_MINIPORT_LOCK_BLOCK  					IOCTL_HPT_LOCK_BLOCK  
#define IOCTL_HPT_MINIPORT_UNLOCK_BLOCK					IOCTL_HPT_UNLOCK_BLOCK
#define IOCTL_HPT_MINIPORT_EXECUTE_CDB					IOCTL_HPT_EXECUTE_CDB
#define IOCTL_HPT_MINIPORT_GET_LAST_ERROR_DEVICE		IOCTL_HPT_GET_LAST_ERROR_DEVICE
#define IOCTL_HPT_MINIPORT_SCSI_PASSTHROUGH				IOCTL_HPT_SCSI_PASSTHROUGH
#define IOCTL_HPT_MINIPORT_GET_RAID_INFO				IOCTL_HPT_GET_RAID_INFO       	
#define IOCTL_HPT_MINIPORT_GET_ARRAY	    			IOCTL_HPT_GET_ARRAY	   
#define IOCTL_HPT_MINIPORT_UPDATE_RAID_INFO				IOCTL_HPT_UPDATE_RAID_INFO
#define IOCTL_HPT_MINIPORT_SET_NOTIFY_EVENT	  			IOCTL_HPT_SET_NOTIFY_EVENT
#define IOCTL_HPT_MINIPORT_REMOVE_NOTIFY_EVENT			IOCTL_HPT_REMOVE_NOTIFY_EVENT
#define IOCTL_HPT_MINIPORT_CREATE_MIRROR   				IOCTL_HPT_CREATE_MIRROR	
#define IOCTL_HPT_MINIPORT_CREATE_STRIPE				IOCTL_HPT_CREATE_STRIPE	
#define IOCTL_HPT_MINIPORT_CREATE_SPAN					IOCTL_HPT_CREATE_SPAN	
#define IOCTL_HPT_MINIPORT_CREATE_RAID10				IOCTL_HPT_CREATE_RAID10	
#define IOCTL_HPT_MINIPORT_REMOVE_RAID					IOCTL_HPT_REMOVE_RAID
#define IOCTL_HPT_MINIPORT_CHECK_HOTSWAP 				IOCTL_HPT_CHECK_HOTSWAP
#define IOCTL_HPT_MINIPORT_SWITCH_POWER					IOCTL_HPT_SWITCH_POWER	
#define IOCTL_HPT_MINIPORT_REMOVE_DEVICE				IOCTL_HPT_REMOVE_DEVICE
#define IOCTL_HPT_MINIPORT_ENUM_GET_DEVICE_INFO			IOCTL_HPT_ENUM_GET_DEVICE_INFO
#define IOCTL_HPT_MINIPORT_ENUM_GET_DEVICE_CHILD		IOCTL_HPT_ENUM_GET_DEVICE_CHILD
#define IOCTL_HPT_MINIPORT_ENUM_GET_DEVICE_SIBLING		IOCTL_HPT_ENUM_GET_DEVICE_SIBLING
#define IOCTL_HPT_MINIPORT_ENUM_GET_CONTROLLER_NUMBER	IOCTL_HPT_ENUM_GET_CONTROLLER_NUMBER
#define IOCTL_HPT_MINIPORT_ENUM_GET_CONTROLLER_INFO		IOCTL_HPT_ENUM_GET_CONTROLLER_INFO
#define IOCTL_HPT_MINIPORT_BEGIN_REBUILDING_MIRROR      IOCTL_HPT_BEGIN_REBUILDING_MIRROR
#define IOCTL_HPT_MINIPORT_VALIDATE_MIRROR              IOCTL_HPT_VALIDATE_MIRROR
#define IOCTL_HPT_MINIPORT_ABORT_MIRROR_REBUILDING      IOCTL_HPT_ABORT_MIRROR_REBUILDING
#define IOCTL_HPT_MINIPORT_SET_XPRO 					IOCTL_HPT_SET_XPRO
#define IOCTL_HPT_MINIPORT_ENABLE_DEVICE				IOCTL_HPT_ENABLE_DEVICE
#define IOCTL_HPT_MINIPORT_DISABLE_DEVICE				IOCTL_HPT_DISABLE_DEVICE
#define IOCTL_HPT_MINIPORT_ADD_SPARE_DISK				IOCTL_HPT_ADD_SPARE_DISK
#define IOCTL_HPT_MINIPORT_DEL_SPARE_DISK				IOCTL_HPT_DEL_SPARE_DISK
#define IOCTL_HPT_MINIPORT_ADD_MIRROR_DISK				IOCTL_HPT_ADD_MIRROR_DISK
#define IOCTL_HPT_MINIPORT_DIAG_RAISE_ERROR             IOCTL_HPT_DIAG_RAISE_ERROR
#define IOCTL_HPT_MINIPORT_CHECK_NOTIFY_EVENT			IOCTL_HPT_CHECK_NOTIFY_EVENT
#define IOCTL_HPT_MINIPORT_STOP_BUZZER					IOCTL_HPT_STOP_BUZZER

///////////////////////////////////////////////////////////////////////
// HPT controller adapter I/O control structure
///////////////////////////////////////////////////////////////////////
#include "pshpack1.h"	// make sure use pack 1

#define RAID_DISK_ERROR	0x1234
#define RAID_DISK_WORK	0x4321
#define RAID_THREAD_STOP	0x5678
#define RAID_OTHER_ERROR	0xFFFF

typedef struct _St_DRIVER_CAPABILITIES {
	DWORD dwSize;
	
	UCHAR MaximumControllers;           /* maximum controllers the driver can support */
	UCHAR SupportCrossControllerRAID;   /* 1-support, 0-not support */
	UCHAR MinimumBlockSizeShift;        /* minimum block size shift */
	UCHAR MaximumBlockSizeShift;		/* maximum block size shift */
	
	UCHAR SupportDiskModeSetting;
	UCHAR SupportSparePool;

	UCHAR MaximumArrayNameLength;
	UCHAR reserved1;
	
	/* SupportedRAIDTypes is an array of bytes, one of each is an array type.
	 * Only non-zero values is valid. Bit0-3 represents the top level RAID type;
	 * bit4-7 represents the lower(child) level. i.e. 
	 *     RAID 0/1 is (AT_RAID1<<4) | AT_RAID0
	 *     RAID 5/0 is (AT_RAID0<<4) | AT_RAID5
	 */
	UCHAR SupportedRAIDTypes[16];
	/* maximum members in an array corresponding to SupportedRAIDTypes */
	UCHAR MaximumArrayMembers[16]; 
}
St_DRIVER_CAPABILITIES, *PSt_DRIVER_CAPABILITIES;

//
// Read/Write sectors parameter structure
//
typedef struct _st_HPT_RW_PARAM{	 
	ULONG	nTargetId;					// the Target device id
	ULONG	nLbaSector;					// the first sector to read/write, in LBA
	ULONG	cnSectors;					// How many sectors to read/write? max 256 sectors. 0x00 mean 256
	UCHAR	pBuffer[1];
} St_HPT_RW_PARAM, *PSt_HPT_RW_PARAM;

//
// Platform type id
//
typedef enum _eu_HPT_POWER_STATE{
	HPT_POWER_ON	=	0,
	HPT_POWER_OFF	=	0xFFFFFFFF
} Eu_HPT_POWER_STATE;

//	
// ATAPI identify data
//
typedef struct _st_IDENTIFY_DATA {
	ULONG	nNumberOfCylinders;			// max number of cylinders
	ULONG	nNumberOfHeads;				// max number of heads
	ULONG	nSectorsPerTrack;			// sector per track
	ULONG	nBytesPerSector;			// bytes per sector
	ULONG	nUserAddressableSectors;	// max sectors user can address
	UCHAR	st20_SerialNumber[20];		// device serial number given by manufacturer (in ASCII)
	UCHAR	st8_FirmwareRevision[8];	// firmware revision number (in ASCII)
	UCHAR	st40_ModelNumber[40];		// model number given by manufacturer (in ASCII)
} St_IDENTIFY_DATA, *PSt_IDENTIFY_DATA;

//
// Disk array information
//						 
typedef struct _st_DISK_ARRAY_INFO{
	ULARGE_INTEGER	uliGroupNumber;	// the array group number,
									// all disks in an array should have same group number

	ULONG	nMemberCount;			// indicate how many disks in this array

	ULONG	nDiskSets;				// indicate what set is this disk belong
									//		available value: 0,1,2,3
									//			0-1, 2-3	stripe set
									//			0-2, 1-3	mirror set

	ULONG	nCylinders;				// the arrayed disk cylinders
	ULONG	nHeads;					// the arrayed disk heads
	ULONG	nSectorsPerTrack;		// the arrayed disk sectors
	ULONG	nBytesPerSector;		// the bytes per sector
	ULONG	nCapacity;				// the capacity of arrayed disk in sector
}St_DISK_ARRAY_INFO, *PSt_DISK_ARRAY_INFO;

//
// Structure for updating RAID info
//
typedef struct _st_HPT_UPDATE_RAID{		   
	ULONG	nTargetId;
	St_DISK_ARRAY_INFO	raidInfo;
} St_HPT_UPDATE_RAID, *PSt_HPT_UPDATE_RAID;

///////////////////////////////////////////////////////////////////////
// Enumerator define area
///////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////////
// structure define area											   
///////////////////////////////////////////////////////////////////////
//
// SCSI inquiry data
//
//		This structure is defined as same as INQUIRYDATA which defined in DDK,
//	be care to use memcpy assign value to this structure for the future compatible.
typedef struct _st_CAPABILITY_DATA{
	UCHAR DeviceType : 5;
	UCHAR DeviceTypeQualifier : 3;
	UCHAR DeviceTypeModifier : 7;
	UCHAR RemovableMedia : 1;
	UCHAR Versions;
	UCHAR ResponseDataFormat;
	UCHAR AdditionalLength;
	UCHAR Reserved[2];
	UCHAR SoftReset : 1;
	UCHAR CommandQueue : 1;
	UCHAR Reserved2 : 1;
	UCHAR LinkedCommands : 1;
	UCHAR Synchronous : 1;
	UCHAR Wide16Bit : 1;
	UCHAR Wide32Bit : 1;
	UCHAR RelativeAddressing : 1;
}St_CAPABILITY_DATA, *PSt_CAPABILITY_DATA;


//   
// Physical device information
//
typedef struct _st_PHYSICAL_DEVINFO{
	ULONG	nSize;					   
	ULONG	nSignature;					// disk signature
	ULONG	nPartitionCount;
	St_IDENTIFY_DATA	IdentifyData;
	St_CAPABILITY_DATA	CapabilityData;
	St_DISK_ARRAY_INFO	DiskArrayInfo;
}St_PHYSICAL_DEVINFO, *PSt_PHYSICAL_DEVINFO;

//
// get array structure;
//
typedef struct _st_GET_ARRAY{ 
	ULONG	nPortId;
	ULONG	nTargetId;
	St_PHYSICAL_DEVINFO	rgPhysicalDevInfo[2][2]; // [MAX_PORT_ID][MAX_TARGET_ID]
}St_GET_ARRAY, *PSt_GET_ARRAY;

//
// Ioctl structure for Win95 platform
//
typedef struct _st_HPT_LUN{
	DWORD	nPathId;
	DWORD	nTargetId;
	union {
		DWORD	nLun;
		DWORD   nControllerId;
	};
	DWORD	resv;
}St_HPT_LUN, *PSt_HPT_LUN;

typedef struct _st_HPT_ERROR_RECORD{	
	DWORD	nLastError;
}St_HPT_ERROR_RECORD, *PSt_HPT_ERROR_RECORD;

typedef struct _st_HPT_NOTIFY_EVENT{		
	HANDLE	hEvent;
}St_HPT_NOTIFY_EVENT, *PSt_HPT_NOTIFY_EVENT;

typedef struct _st_HPT_ENUM_GET_DEVICE_INFO{		
	HDISK	hDeviceNode;				// HDISK, input parameter
	St_DiskStatus	DiskStatus;			// DISK_STATUS, input & output parameter
}St_HPT_ENUM_GET_DEVICE_INFO, *PSt_HPT_ENUM_GET_DEVICE_INFO;

typedef struct _st_HPT_ENUM_DEVICE_RELATION{		  
	HDISK	hNode;						// HDISK, input parameter
	HDISK	hRelationNode;				// HDISK, relation device node, output parameter
}St_HPT_ENUM_DEVICE_RELATION, *PSt_HPT_ENUM_DEVICE_RELATION;

typedef struct _st_HPT_ENUM_GET_CONTROLLER_NUMBER{
	ULONG	nControllerNumber;			// output parameter, the current controller number
}St_HPT_ENUM_GET_CONTROLLER_NUMBER, * PSt_HPT_ENUM_GET_CONTROLLER_NUMBER;

typedef struct _st_HPT_ENUM_GET_CONTROLLER_INFO{					
	int		iController;				// input parameter, the index of controller what get the info
	St_StorageControllerInfo stControllerInfo; //output parameter, the info of the controller 
	struct
	{
	    int iVendorID;
	    int iDeviceID;
	    int iSubSysNumber;
	    int iRevsionID;
	    int iBusNumber;
	    int iDeviceNumber;
	    int iFunctionNumber;
	}stDeviceNodeID;
}St_HPT_ENUM_GET_CONTROLLER_INFO, *PSt_HPT_ENUM_GET_CONTROLLER_INFO;

typedef struct _st_HPT_BLOCK{ 
	ULONG	nStartLbaAddress;			// the first LBA address of the block
	ULONG	nBlockSize;					// the block size in sectors of the block
}St_HPT_BLOCK, *PSt_HPT_BLOCK;

typedef struct _st_HPT_EXECUTE_CDB{
	ULONG	OperationFlags;				// the operation flags, see OPERATION_FLAGS
	UCHAR	CdbLength;
	UCHAR	reserved[3];				// adjust the size of structure
	UCHAR	Cdb[16];
}St_HPT_EXECUTE_CDB, *PSt_HPT_EXECUTE_CDB;													   

// the operation flags declare area
#define OPERATION_FLAGS_DATA_IN			0x00000001 // DATA_IN or DATA_OUT, refer SRB_FLAGS_DATA_XXX
#define OPERATION_FLAGS_ON_MIRROR_DISK	0x00000002 // read/write mirror array (1 or 0+1) mirror disk
#define OPERATION_FLAGS_ON_SOURCE_DISK 0x00000004 // read/write mirror array (1 or 0+1) source disk

typedef struct _st_HPT_CREATE_RAID{		  
	int		nDisks;
	HDISK	hRaidDisk;					// the disk handle of the created RAID disk 
	ULONG	nStripeBlockSizeShift;
	HDISK	aryhDisks[1];
}St_HPT_CREATE_RAID, *PSt_HPT_CREATE_RAID;

typedef struct _st_HPT_REMOVE_RAID{
	HDISK	hDisk;
}St_HPT_REMOVE_RAID, *PSt_HPT_REMOVE_RAID;

//
// Define the SCSI pass through structure.
//
typedef struct _st_HPT_SCSI_PASS_THROUGH {
	USHORT Length;
	UCHAR ScsiStatus;
	UCHAR PathId;
	UCHAR TargetId;
	UCHAR Lun;
	UCHAR CdbLength;
	UCHAR SenseInfoLength;
	UCHAR DataIn;
	ULONG DataTransferLength;
	ULONG TimeOutValue;
	ULONG DataBufferOffset;
	ULONG SenseInfoOffset;
	UCHAR Cdb[16];
}St_HPT_SCSI_PASS_THROUGH, *PSt_HPT_SCSI_PASS_THROUGH;


typedef struct _st_HPT_ADD_DISK{
	HDISK	hArray;
	HDISK	hDisk;
}St_HPT_ADD_DISK, *PSt_HPT_ADD_DISK;



#include <poppack.h>	// pop the pack number
#endif	// __HPTIOCTL_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\port\scsi\miniport\hipoint\hpt3xx\inc\hptver.h ===
/*++
Copyright (c) 1999-2000, HighPoint Technologies, Inc.

Module Name:
	HptVer.h: Hpt driver version structure declare header file

Abstract:

Author:
    HongSheng Zhang (HS)

Environment:
	Window32 platform
Notes:

Revision History:
    01-11-2000  Created initiallly

--*/
#ifndef __HPTVER_H__
#define __HPTVER_H__
//
// Platform type id
//
typedef enum _eu_HPT_PLATFORM_ID{
	PLATFORM_ID_WIN32_WINDOWS,
	PLATFORM_ID_WIN32_NT = 0x80000000,
	PLATFORM_ID_WIN32_2K
} Eu_HPT_PLATFORM_ID;	 

#define HPT_FUNCTION_RAID	0x00000001
#define HPT_FUNCTION_HSWAP	0x00000002
//
// Device version info structure
//
typedef	struct _st_HPT_VERSION_INFO{				 
	ULONG	dwVersionInfoSize;
	ULONG	dwPlatformId;
	ULONG	dwDriverVersion;
	USHORT	dwSupportFunction;
	UCHAR   ControllerId;
	UCHAR   reserve1;
} St_HPT_VERSION_INFO, *PSt_HPT_VERSION_INFO;

#define MAKE_VERSION_NUMBER(v1, v2, v3, date) ((v1)<<28 | (v2)<<24 | (v3)<<16 | date)
#define VERSION_NUMBER MAKE_VERSION_NUMBER(1,0,5,427)

#endif	//__HPTVER_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\port\scsi\miniport\hipoint\hpt3xx\inc\dam.h ===
/*++
Copyright (c) HighPoint Technologies, Inc. 2000

Module Name:
    DAM.h

Abstract:
    Defines the interface of Disk Array Management, including some constant 
    defintions, data structures and routine prototypes.

Author:
    Liu Ge (LG)
    
Environment:
    Win32 User Mode Only    

Revision History:
   03-17-2000  Created initiallly
	11-17-2000  SLeng Added functions to R/W Validity & RebuiltSector flag
	11-20-2000  GengXin Added DiskArray_GetDiskIsBroken function to get array of disk whether broken
	11-20-2000  SLeng Added DiskArray_SetDeviceFlag function to Enable/Disable a device
	11-21-2000  SLeng Added function DiskArray_VerifyMirrorBlock to verify mirror block
	11-23-2000  SLeng Added functions to Remove/Add spare disk
	11-29-2000  SLeng Added function to add a Mirror disk
--*/
#ifndef DiskArrayManagement_H_
#define DiskArrayManagement_H_

#include "RaidCtl.h"

#pragma pack(push, 1)

DECLARE_HANDLE(HFIND_DISK);
DECLARE_HANDLE(HFAILURE_MONITOR);
DECLARE_HANDLE(HMIRROR_BUILDER);

// The St_FindDisk structure describes a disk found by the DiskArray_FindFirstNext function.

typedef struct _St_FindDisk
{
    HDISK   hFoundDisk; //  The handle of the found disk
    int     iDiskType;  //  See Eu_DiskArrayType
    BOOL    isSpare;    //  Indicate if this disk is a spare disk
}St_FindDisk ,* PSt_FindDisk;

#pragma pack(pop)

#ifdef  __cplusplus
extern "C"
{
#endif

/*++
Function:
    RAIDController_GetNum

Description:
    Retrieve the number of RAID controllers in computer

Arguments:

Returns:
    return the number of RAID controllers in computer

See also:
    RAIDController_GetInfo
--*/
int WINAPI RAIDController_GetNum(void);

/*++
Function:
    RAIDController_GetInfo

Description:
    Retrieve the information of a controller

Arguments:
    iController - Specify the zero-base index of the controller
    pInfo - Points to a St_StorageControllerInfo structure that receives 
            the information about the specified controller.

Returns:
    return TRUE if success
    else return FALSE if failed.

See also:
    RAIDController_GetNum
--*/
BOOL WINAPI RAIDController_GetInfo( int iController, St_StorageControllerInfo * pInfo );

/*++
Function:
    DiskArray_FindFirst

Description:
    Search a compound disk for a child disk

Arguments:
    hRoot     - Specify the compound disk from which all child disks will be 
                found. This parameter can be NULL if the root is the whole system
    pFindData - Points to a St_FindDisk structure that receives information about the found
                disk.

Returns:
    return a search handle
    else return NULL if failed.

See also:
    DiskArray_FindNext
    DiskArray_FindClose
--*/
HFIND_DISK WINAPI DiskArray_FindFirst(HDISK hParent, PSt_FindDisk pFindData );

/*++
Function:
    DiskArray_FindNext

Description:
    Continue a disk search from a previous call to the DiskArray_FindFirst function

Arguments:
    hSearchHandle - Identifies a search handle returned by a previous call 
                    to the FindFirstFile function. 

    pFindData - Points to a St_FindDisk structure that receives information about the found
                disk.

Returns:
    return TRUE
    else return FALSE, if failed.

See also:
    DiskArray_FindFirst
    DiskArray_FindClose
--*/
BOOL WINAPI DiskArray_FindNext(HFIND_DISK hSearchHandle, PSt_FindDisk pFindData);

/*++
Function:
    DiskArray_FindClose

Description:
    Closes the specified search handle

Arguments:
    hSearchHandle - Identifies the search handle. This handle must have been previously 
                    opened by the DiskArray_FindFirst function. 

Returns:
    return TRUE,
    else return FALSE if failed.

See also:
    DiskArray_FindFirst
    DiskArray_FindNext
--*/
BOOL WINAPI DiskArray_FindClose(HFIND_DISK hSearchHandle);

/*++
Function:
    DiskArray_GetStatus

Description:
    Retrieve the status information of a disk, either a 
    physical disk or a virtual disk.

Arguments:
    hDisk -     Identifies the disk of which the status information will be
                retrieved.
    pStatus -   Points to a St_DiskStatus structure that describe the status
                of the disk

Returns:
    return TRUE,
    else return FALSE if failed.
--*/
BOOL WINAPI DiskArray_GetStatus( HDISK hDisk, PSt_DiskStatus pStatus );

/*++
Function:
    DiskArray_OpenFailureMonitor

Description:
    Create a failure monitor which will be signaled if a failure occur. The handle
    this routine return can be closed with DiskArray_OpenFailureMonitor

Arguments:

Returns:
    return the handle of the failure monitor, which can be passed to DiskArray_WaitForFailure
    else return NULL if failed.

See also:
    DiskArray_WaitForFailure
    DiskArray_CloseFailureMonitor
--*/
HFAILURE_MONITOR WINAPI DiskArray_OpenFailureMonitor(void);

/*++
Function:
    DiskArray_WaitForFailure

Description:
    Wait a monitor for a failure occurred if any.

Arguments:
    hFailureMonitor - Specify the monitor
    pInfo - Points to a St_DiskArrayEvent containing the detail information of a 
            failure.

Returns:
    return TRUE if a failure happened,
    else return FALSE if this monitor has been closed by a calling to
    DiskArray_CloseFailureMonitor

See also:
    DiskArray_OpenFailureMonitor
    DiskArray_CloseFailureMonitor
--*/
BOOL WINAPI DiskArray_WaitForFailure( HFAILURE_MONITOR hFailureMonitor, 
    PSt_DiskArrayEvent pInfo, HANDLE hProcessStopEvent );

/*++
Function:
    DiskArray_CloseFailureMonitor

Description:
    Close a failure monitor

Arguments:
    hFailureMonitor - Specify the monitor to be closed

Returns:
    return TRUE if success,
    else return FALSE if failed.

See also:
    DiskArray_OpenFailureMonitor
    DiskArray_CloseFailureMonitor
--*/
BOOL WINAPI DiskArray_CloseFailureMonitor( HFAILURE_MONITOR hFailureMonitor );

/*++
Function:
    DiskArray_CreateMirror

Description:
    Create a mirror array. 
    This function will return immediately without any wait for 
    the completion of the creation progress. That means the returned
    mirror array will not work until the creation complete. After this
    call, the interface will call the DiskArray_CreateMirrorBlock to 
    create all blocks sequently. If the creation failed or aborted, the
    DiskArray_RemoveMirror function ought to be called to destroy the
    uncompleted mirror array. If the creation complete, the 
    DiskArray_ValidateMirror function ought to be called to make the
    mirror work.

Arguments:
    pDisks -    The address of a array containing the handles of all 
                physical disks which will be associated as a mirror.
                
    uDiskNum -  The number of physical disks associated togather

Returns:
    return the handle of the new mirror array, the status of which is
    being created, i.e. this mirror array will not work until created.
    if failed, return NULL.

See also:
    DiskArray_CreateMirrorBlock
    DiskArray_ValidateMirror
    DiskArray_RemoveMirror
--*/
HDISK WINAPI DiskArray_CreateMirror( HDISK * pDisks, ULONG uDiskNum, UCHAR* sz_ArrayName);
BOOL WINAPI DiskArray_RemoveMirror( HDISK hMirror,BOOL bWriteDisks = TRUE);

//  The following two functions need not be implemented in this version
HDISK WINAPI DiskArray_ExpandMirror( HDISK hMirror, HDISK * pDisks, ULONG uDiskNum );
HDISK WINAPI DiskArray_ShrinkMirror( HDISK hMirror, HDISK * pDisks, ULONG uDiskNum );

/*++
Function:
    DiskArray_CreateStripping

Description:
    Create a stripe array. 
    This function will return immediately without any wait for 
    the completion of the creation progress. That means the returned
    stripe array will not work until the creation complete. After this
    call, the interface will call the DiskArray_CreateStrippingBlock to 
    create all blocks sequently. If the creation failed or aborted, the
    DiskArray_RemoveStripping function ought to be called to destroy the
    uncompleted stripe array.

Arguments:
    pDisks -    The address of a array containing the handles of all 
                physical disks which will be associated as a stripe array.
                
    uDiskNum -  The number of physical disks associated togather

    nStripSizeShift - The exponent of the number of blocks per strip, e.g. 
                      it is 7 if the strip size is 128 blocks, 3 if 8 blocks.

Returns:
    return the handle of the new stripe array, the status of which is
    being created, i.e. this stripe array will not work until created.
    if failed, return NULL.

See also:
    DiskArray_QueryAvailableStripSize
    DiskArray_CreateStrippingBlock
    DiskArray_RemoveStripping
--*/
HDISK WINAPI DiskArray_CreateStripping( HDISK * pDisks, ULONG uDiskNum, UINT nStripSizeShift, UCHAR* sz_ArrayName );		//modified by wx 12/25/00
HDISK WINAPI DiskArray_CreateRAID10( HDISK * pDisks, ULONG uDiskNum, UINT nStripSizeShift, UCHAR* sz_ArrayName );		//add by karl karl 2001/01/10
BOOL WINAPI DiskArray_CreateStrippingBlock( HDISK hStripping, ULONG uLba );
BOOL WINAPI DiskArray_RemoveStripping( HDISK hStripping );

//  The following two functions need not be implemented in this version
HDISK WINAPI DiskArray_ExpandStripping( HDISK hStripping, HDISK * pDisks, ULONG uDiskNum );
HDISK WINAPI DiskArray_ShrinkStripping( HDISK hStripping, HDISK * pDisks, ULONG uDiskNum );

/*++
Function:
    DiskArray_QueryAvailableStripSize

Description:
    Retrieve the available strip size which RAID system supports

Arguments:
    return 
                    
                    
                
Returns:
    return a bit mask representing all available strip size,
    Bit position 0 representing 1 block per strip, 1 representing 2,
    blocks per strip, 7 representing 128 blocks per strip etc.
    
    return FALSE if failed, 

See also:
    DiskArray_CreateStrippingBlock
--*/
DWORD WINAPI DiskArray_QueryAvailableStripSize(void);

/*++
Function:
    DiskArray_CreateSpan

Description:
    Create a span array. 

Arguments:
    pDisks -    The address of a array containing the handles of all 
                physical disks which will be associated as a stripe array.
                
    uDiskNum -  The number of physical disks associated togather

Returns:
    return the handle of the new stripe array, the status of which is
    being created, i.e. this stripe array will not work until created.
    if failed, return NULL.

See also:
    DiskArray_RemoveSpan
--*/
HDISK WINAPI DiskArray_CreateSpan( HDISK * pDisks, ULONG uDiskNum, UCHAR* sz_ArrayName );		//modified by wx 12/25/00
BOOL WINAPI DiskArray_RemoveSpan( HDISK hSpan );

//  The following two functions need not be implemented in this version
HDISK WINAPI DiskArray_ExpandSpan( HDISK hSpan, HDISK * pDisks, ULONG uDiskNum );
HDISK WINAPI DiskArray_ShrinkSpan( HDISK hSpan, HDISK * pDisks, ULONG uDiskNum );


/*++
Function:
    DiskArray_Plug

Description:
    Hot plug a physical disk. The plugged disk can be a child of a virtual
    disk. For example, it can be a child of stripe array.

Arguments:
    hParentDisk -   Identifies the parent disk under which the plugged
                    disk will be a child. If it is null, the plugged disk
                    have not any parent, i.e. which is not a child of 
                    any virtual disk.

Returns:
    return the handle of the plugged disk
    else return NULL if failed.

See also:
    DiskArray_Unplug
--*/
HDISK WINAPI DiskArray_Plug( HDISK hParentDisk );
BOOL WINAPI DiskArray_Unplug( HDISK hDisk );

//  No need to be implemented in this version
BOOL WINAPI DiskArray_FailDisk( HDISK hDisk );

/*++
Function:
    DiskArray_QueryRebuildingBlockSize

Description:
    Retrieve the maximum value of parameter 'nSectors' before calling
    DiskArray_RebuildMirrorBlock

Arguments:
	
Returns:
    return the maximum value.
    else return zero if failed.

See also:
    DiskArray_RebuildMirrorBlock
--*/
ULONG WINAPI DiskArray_QueryRebuildingBlockSize( void );

/*++
Function:
    DiskArray_BeginRebuildingMirror

Description:
    Begin to rebuild a failed mirror array.
    After this call, DiskArray_RebuildMirrorBlock will be called block by block.
    When the rebuilding complete, DiskArray_ValidateMirror ought to be called 
    to make the mirror array work.
    If the rebuilding progress is aborted, DiskArray_AbortMirrorRebuilding will be
    called.

Arguments:
    hMirror - Identifies the mirror array which is about to be rebuilt.
	
Returns:
    return a handle specifying a mirror builder.
    else return INVALID_HANDLE_VALUE if failed.

See also:
    DiskArray_RebuildMirrorBlock
    DiskArray_AbortMirrorRebuilding
    DiskArray_ValidateMirror
    DiskArray_QueryRebuildingBlockSize
--*/
HMIRROR_BUILDER WINAPI DiskArray_BeginRebuildingMirror( HDISK hMirror );

/*++
Function:
    DiskArray_RebuildMirrorBlock

Description:
    Rebuild the data of the specified block in a mirror array.
    The interface will call the this function block by block when
    rebuilding the data. If the rebuilding complete, the 
    DiskArray_ValidateMirror function ought to be called to make the
    mirror array work.
    If the rebuilding progress is aborted, DiskArray_AbortMirrorRebuilding will be
    called.

Arguments:
    hBuilder - Specifies the mirror builder created by DiskArray_BeginRebuildingMirror
    uLba  - A 32 bits value identifying the block which need to be rebuilt
	nSectors - Sectors of the block to rebuild, cann't be larger then 
    the result of calling DiskArray_QueryRebuildingBlockSize.
	
Returns:
    return TRUE
    else return FALSE if failed.

See also:
    DiskArray_BeginRebuildingMirror
    DiskArray_AbortMirrorRebuilding
    DiskArray_ValidateMirror
    DiskArray_QueryRebuildingBlockSize
--*/
BOOL WINAPI DiskArray_RebuildMirrorBlock( HMIRROR_BUILDER hBuilder, ULONG uLba, ULONG nSectors,int nRebuildType );

/*++
Function:
    DiskArray_AbortMirrorRebuilding

Description:
    Abort a mirror rebuilding progress.

Arguments:
    hBuilder - Specifies the mirror builder created by DiskArray_BeginRebuildingMirror
	
Returns:
    return TRUE if succeeded
    else return FALSE if failed.

See also:
    DiskArray_QueryRebuildingBlockSize
    DiskArray_BeginRebuildingMirror
    DiskArray_RebuildMirrorBlock
--*/
BOOL WINAPI DiskArray_AbortMirrorRebuilding( HMIRROR_BUILDER hBuilder );
 
/*++
Function:
    DiskArray_ValidateMirror

Description:
    When all blocks of a failed mirror array are built, this
    function ought to be called to make the mirror array work.

Arguments:
    hBuilder - Specifies the mirror builder created by DiskArray_BeginRebuildingMirror
	
Returns:
    return TRUE if succeeded
    else return FALSE if failed.

See also:
    DiskArray_QueryRebuildingBlockSize
    DiskArray_BeginRebuildingMirror
    DiskArray_RebuildMirrorBlock
    DiskArray_AbortMirrorRebuilding
--*/
BOOL WINAPI DiskArray_ValidateMirror( HMIRROR_BUILDER hBuilder );

/*++
Function:
    DiskArray_SetTransferMode

Description:
    Set the transfer mode of a disk.
    The transfer mode can be retrieved by calling the DiskArray_GetStatus funtion

Arguments:
    hDisk - Identifies the disk the transfer mode of which will be set
    nMode - The transfer mode
    nSubMode - The submode

Returns:
    return TRUE
    else return FALSE if failed.

See also:
    DiskArray_GetStatus

--*/
BOOL WINAPI DiskArray_SetTransferMode( HDISK hDisk, int nMode, int nSubMode );

/*++
Function:
    DiskArray_RaiseError

Description:
    Get  disk error link
Arguments:
    pInfo - Points to a St_DiskArrayEvent containing the detail information of a 
            failure.

Returns:
    return TRUE
    else return FALSE if failed.

See also:
    DiskArray_WaitForFailure

--*/
BOOL WINAPI DiskArray_RaiseError(PSt_DiskArrayEvent pInfo);


//////////////////////
					// Added by SLeng
					//
/*++
Function:
    DiskArray_GetValidFlag

Description:
	This function will read the Valid Flag of a mirror array disk

Arguments:
	hBuilder - Specifies the mirror builder created by DiskArray_BeginRebuildingMirror

Returns:
	The Valid Flag for a mirror array disk, if read fail,
	the return value is ARRAY_INVALID.

See also:

--*/
UCHAR WINAPI DiskArray_GetValidFlag( HMIRROR_BUILDER hBuilder );


/*++
Function:
    DiskArray_SetValidFlag

Description:
	This function will set the Valid Flag of a mirror array disk

Arguments:
	hBuilder - Specifies the mirror builder created by DiskArray_BeginRebuildingMirror
	flag     - Specifies the value of valid flag, ARRAY_VALID to enable the device, 
				and ARRAY_INVALID to disable the device.

Returns:
	return TRUE
	else return FALSE if failed.

See also:

--*/
BOOL WINAPI DiskArray_SetValidFlag( HMIRROR_BUILDER hBuilder, UCHAR Flag);
BOOL WINAPI DiskArray_SetValidFlagEx( HDISK hDisk, UCHAR Flag);

/*++
Function:
    DiskArray_GetRebuiltSector

Description:
	This function will read the rebuilt sector of a mirror array disk

Arguments:
	hBuilder - Specifies the mirror builder created by DiskArray_BeginRebuildingMirror

Returns:
	The Value of rebuilt sector

See also:

--*/
ULONG WINAPI DiskArray_GetRebuiltSector( HMIRROR_BUILDER hBuilder );
//
// ldx overrode this function 12/20/00
//
ULONG WINAPI DiskArray_GetRebuiltSectorEx( HDISK hDisk );


/*++
Function:
	DiskArray_SetRebuiltSector

Description:
	This function will set the rebuilt sector of a mirror array disk

Arguments:
	hBuilder - Specifies the mirror builder created by DiskArray_BeginRebuildingMirror
	lSector  - The Value of rebuilt sector

Returns:
	return TRUE
	else return FALSE if failed.

See also:

--*/
BOOL WINAPI DiskArray_SetRebuiltSector( HMIRROR_BUILDER hBuilder, ULONG lSector);
BOOL WINAPI DiskArray_SetRebuiltSectorEx( HDISK hDisk, ULONG lSector);

/*++
Function:
	DiskArray_SetDeviceFlag

Description:
	This function will Disable/Enable a device

Arguments:
	hBuilder - Specifies the mirror builder created by DiskArray_BeginRebuildingMirror
	flag  - TRUE to Enable a device, FALSE to Disable a device.

Returns:
	return TRUE
	else return FALSE if failed.

See also:

--*/
BOOL WINAPI DiskArray_SetDeviceFlag( HMIRROR_BUILDER hBuilder, BOOL flag);


/*++
Function:
	DiskArray_VerifyMirrorBlock

Description:
	This function will verify a block for a mirror

Arguments:
	hDiskSrc, hDiskDest - Specifies the disks to verify
	uLba     - The start lba for verify
	nSectors - Verify sectors number

Returns:
	return TRUE
	else return FALSE if failed.

See also:

--*/
BOOL WINAPI DiskArray_VerifyMirrorBlock( HDISK hMirror, ULONG uLba, ULONG nSectors, BOOL bFix, BOOL *pbFixed );


/*++
Function:
	DiskArray_RemoveSpareDisk

Description:
	This function will delete a spare disk from a mirror array

Arguments:
	hDisk - Specifies the disk to remove

Returns:
	return TRUE
	else return FALSE if failed.

See also:

--*/
BOOL WINAPI DiskArray_RemoveSpareDisk( HDISK hDisk );


/*++
Function:
	DiskArray_AddSpareDisk

Description:
	This function will add a spare disk to a mirror array

Arguments:
	hMirror - The mirror array
	hDisk   - Specifies the disk to add

Returns:
	return TRUE
	else return FALSE if failed.

See also:

--*/
BOOL WINAPI DiskArray_AddSpareDisk( HDISK hMirror, HDISK hDisk );


/*++
Function:
	DiskArray_AddMirrorDisk

Description:
	This function will add a mirror disk to a mirror array

Arguments:
	hMirror - The mirror array
	hDisk   - Specifies the disk to add

Returns:
	return TRUE
	else return FALSE if failed.

See also:

--*/
BOOL  WINAPI DiskArray_AddMirrorDisk( HDISK hMirror, HDISK hDisk);

//////////////////////


/*++
Function:
    DiskArray_GetDiskIsBroken

Description:
    Get  array of disk whether broken
Arguments:
    HMIRROR_BUILDER hBuilder
	BOOL &bBroken: output variable, if TRUE, then disk is broken
	int &type: output variable, if disk is broken, it is array type

Returns:
    return TRUE when success
    else return FALSE if failed.

Modify date:
	2000/11/20 by GengXin
--*/
BOOL WINAPI DiskArray_GetDiskIsBroken( HMIRROR_BUILDER hBuilder , BOOL &bBroken, int &type);

//gmm
BOOL WINAPI DiskArray_SetArrayName(HDISK hDisk, const char *name);
//ldx
BOOL WINAPI DiskArray_RescanAll();
BOOL WINAPI DiskArray_ReadPhysicalDiskSectors(int nControllerId,int nBusId,int nTargetId,
											  ULONG	nStartLba,ULONG	nSectors,LPVOID	lpOutBuffer);
BOOL WINAPI DiskArray_WritePhysicalDiskSectors(int nControllerId,int nBusId,int nTargetId,
											  ULONG	nStartLba,ULONG	nSectors,LPVOID	lpOutBuffer);

#ifdef  __cplusplus
}   //  extern C
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\port\scsi\miniport\hipoint\hpt3xx\inc\raidctl.h ===
/*++
Copyright (c) HighPoint Technologies, Inc. 2000

Module Name:
    RaidCtl.h

Abstract:
    Defines the common types shared by user and kernel code of Disk Array Management

Author:
    Liu Ge (LG)

Revision History:
    07-14-2000  Created initiallly
--*/
#ifndef DiskArrayIoCtl_H_
#define DiskArrayIoCtl_H_

#pragma pack(push, 1)

//  The following defines the type of disk in a disk array
typedef enum
{
    enDA_Nothing,
    enDA_NonDisk,
    enDA_Physical,
    //  The following are all compound disks, i.e. they all consist of multiple physical disks
    enDA_Stripping, enDA_RAID0 = enDA_Stripping,
    enDA_Mirror, enDA_RAID1 = enDA_Mirror,
    enDA_RAID2,
    enDA_RAID3,
    enDA_RAID4,
    enDA_RAID5,
    enDA_RAID6,
    enDA_Complex,   //  This constant is defined for Multiple Level RAID
	enDA_TAPE,
	enDA_CDROM,

    enDA_Vendor = 0x80,
    enDA_Span,
    
    enDA_Unknown = 0xFF
}Eu_DiskArrayType;

typedef enum
{
    enDiskStatus_Working,
    enDiskStatus_WorkingWithError,
    enDiskStatus_Disabled,
    enDiskStatus_BeingBuilt,
    enDiskStatus_NeedBuilding,
}Eu_DiskWorkingStatus;

#ifdef DECLARE_HANDLE
DECLARE_HANDLE(HDISK);
#else
typedef HANDLE HDISK;
#endif

#define MAX_DEVICES_PER_BUS 8
struct St_IoBusInfo
{
    HDISK vecDevices[MAX_DEVICES_PER_BUS];
    UINT  uDevices;
};
typedef struct St_IoBusInfo St_IoBusInfo;

#define MAX_BUSES_PER_CONTROLLER    8
typedef enum
{
    STORAGE_CONTROLLER_SUPPORT_BUSMASTER        = 0,
    STORAGE_CONTROLLER_SUPPORT_RAID0            = 1,
    STORAGE_CONTROLLER_SUPPORT_RAID1            = 2,
    STORAGE_CONTROLLER_SUPPORT_RAID2            = 4,
    STORAGE_CONTROLLER_SUPPORT_RAID3            = 8,
    STORAGE_CONTROLLER_SUPPORT_RAID4            = 0x10,
    STORAGE_CONTROLLER_SUPPORT_RAID5            = 0x20,
    STORAGE_CONTROLLER_SUPPORT_RAID6            = 0x40,
    STORAGE_CONTROLLER_SUPPORT_RESERVED         = 0x80,
    STORAGE_CONTROLLER_SUPPORT_VENDOR_SPEC      = 0x100,
    STORAGE_CONTROLLER_SUPPORT_SPAN             = 0x200,
    STORAGE_CONTROLLER_SUPPORT_RESERVED1        = 0x400,
    STORAGE_CONTROLLER_SUPPORT_CACHE            = 0x800,
    STORAGE_CONTROLLER_SUPPORT_POWER_PROTECTION = 0x1000,
    STORAGE_CONTROLLER_SUPPORT_HOTSWAP          = 0x2000,
    STORAGE_CONTROLLER_SUPPORT_BOOTABLE_DEVICE  = 0x4000
}Eu_StorageControllerCapability;

#define MAX_NAME_LENGTH 260
typedef struct
{
    TCHAR szProductID[MAX_NAME_LENGTH];
    TCHAR szVendorID[MAX_NAME_LENGTH];

    int iInterruptRequest;

    St_IoBusInfo vecBuses[MAX_BUSES_PER_CONTROLLER];
    UINT  uBuses;
    
    int     nFirmwareVersion;
    int     nBIOSVersion;
    
    DWORD   dwCapabilites;  //  Please see Eu_StorageControllerCapability
    int     nClockFrquency;
    
    int     nCacheSize;
    int     nCacheLineSize;
}St_StorageControllerInfo;

typedef struct
{
	/* For compatiblity keep iXXX as old names, nXXX as new names */
	union {
    	int iPathId;
    	int nControllerId;
    };
    union {
		int iAdapterId;
		int nPathId;
	};
    int iTargetId;
    int iLunId;
}St_DiskPhysicalId, * PSt_DiskPhysicalId;

typedef enum
{
    DEVTYPE_DIRECT_ACCESS_DEVICE, DEVTYPE_DISK = DEVTYPE_DIRECT_ACCESS_DEVICE,
    DEVTYPE_SEQUENTIAL_ACCESS_DEVICE, DEVTYPE_TAPE = DEVTYPE_SEQUENTIAL_ACCESS_DEVICE,
    DEVTYPE_PRINTER_DEVICE,
    DEVTYPE_PROCESSOR_DEVICE,
    DEVTYPE_WRITE_ONCE_READ_MULTIPLE_DEVICE, DEVTYPE_WORM = DEVTYPE_WRITE_ONCE_READ_MULTIPLE_DEVICE,
    DEVTYPE_READ_ONLY_DIRECT_ACCESS_DEVICE, DEVTYPE_CDROM = DEVTYPE_READ_ONLY_DIRECT_ACCESS_DEVICE,
    DEVTYPE_SCANNER_DEVICE,
    DEVTYPE_OPTICAL_DEVICE,
    DEVTYPE_MEDIUM_CHANGER,
    DEVTYPE_COMMUNICATION_DEVICE,
    DEVTYPE_FLOPPY_DEVICE
}En_DeviceType;

typedef struct              
{
    ULONG	nErrorNumber;
    UCHAR	aryCdb[16];
}St_DiskError;

#define DEV_FLAG_BOOTABLE			0x00000001
#define DEV_FLAG_NEWLY_CREATED		0x00000002
#define DEV_FLAG_NEED_AUTOREBUILD	0x00000004

typedef struct
{
    St_DiskPhysicalId   PhysicalId;
    WORD                iDiskType;  	//  See Eu_DiskArrayType
	WORD				iRawArrayType;  // arrayType defined in driver
    TCHAR               szModelName[40];

    ULONG               uTotalBlocks;  //  The total number of blocks of a disk
    int                 nStripSize;		//  Blocks per strip

    BOOL                isSpare;    	// Indicate if this disk is a spare disk
    DWORD               Flags;

    int                 nTransferMode;
    int                 nTransferSubMode;
    UCHAR					bestPIO;        /* Best PIO mode of this device */
    UCHAR 					bestDMA;        /* Best MW DMA mode of this device */
    UCHAR 					bestUDMA;		 /* Best Ultra DMA mode of this device */
	
    int                 iArrayNum;
    
    HDISK               hParentArray;   //  The handle of parent array if any
    DWORD               dwArrayStamp;   //  The stamp of an array
    
    int                 iOtherDeviceType;   //  See En_DeviceType

    int                 iWorkingStatus;     //  See Eu_DiskWorkingStatus
    
    St_DiskError        stLastError;    /* The last error occurred on this disk*/
	UCHAR				ArrayName[32];	//the name of array //added by wx 12/26/00
    
}St_DiskStatus, *PSt_DiskStatus;

typedef enum
{
    enDA_EventNothing,
    
    enDA_EventDiskFailure,

    enDA_EventPlug,
    enDA_EventUnplug,
    enDA_EventDisableDisk,
    enDA_EventEnableDisk,
}Eu_DiskArrayEventType;

typedef struct
{
    HDISK	hDisk;						//  The handle of the failed disk
    BYTE	vecCDB[16];					//  About CDB, please see scsi.h
    BOOL	bNeedRebuild;				//  indicate if a rebuilding progress should be invoked
	ULONG	HotPlug;					//  The flag of disk add by hotplug
}St_DiskFailure, * PSt_DiskFailure;

typedef struct
{
    St_DiskPhysicalId DiskId;				//  The physical id of the failed disk
    BYTE	vecCDB[16];					//  About CDB, please see scsi.h
    BOOL	bNeedRebuild;				//  indicate if a rebuilding progress should be invoked
}St_DiskFailureInLog, * PSt_DiskFailureInLog;

typedef struct tagDiskArrayEvent
{
    int iType;  //  See Eu_DiskArrayEventType;
    ULARGE_INTEGER u64DateTime;  //  The data time of the event, equal to FILETIME

    union
    {
        St_DiskFailure DiskFailure;     //  this field stores the runtime information
        St_DiskFailureInLog DiskFailureInLog;
        //  Above field stores the failure information loaded from log file

        struct
        {
            St_DiskPhysicalId DiskId;
        }Plug;
        struct
        {
            St_DiskPhysicalId DiskId;
        }Unplug;
    }u;

    ULONG uResult;  //  zero represents success, nonzero represents error code

    PVOID pToFree;  //  this pointer points to a memory block this structure allocated if any
                    //  So, it is user's responsibility to free this block
                    //  if this structure is used in C code but not C++.
#ifdef  __cplusplus
    tagDiskArrayEvent()
    {
        memset( this, 0, sizeof(tagDiskArrayEvent) );
    }

    ~tagDiskArrayEvent()
    {
        if( pToFree )
        {
            delete pToFree;
            pToFree = NULL;
        }
    }
#endif
}St_DiskArrayEvent, * PSt_DiskArrayEvent;

#define REBUILD_INITIALIZE	  1	 /* Clear Data */
#define BROKEN_MIRROR         2  /* broken mirror rebuild */
#define REBUILD_DUPLICATION   4  /* newly created mirror */
#define REBUILD_SYNCHRONIZE	  8  /* after reboot , synchronize */


#pragma pack(pop)

#define HROOT_DEVICE    NULL

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\port\scsi\miniport\hipoint\hpt3xx\winnt\arraydat.h ===
/*++
Copyright (c) 2000, HighPoint Technologies, Inc.

Module Name:
	ArrayDat.h : Define the Array Information in disk.

Abstract:

Author:
    LiuGe (LG)

Dependence:    none

Environment:
	Windows Kernel and User Mode
	BIOS Mode

Notes:

Revision History:
    07-25-2000    Created initiallly

--*/
#ifndef ArrayStructures_H_
#define ArrayStructures_H_

#include <pshpack1.h>
 
/*
 * The time when the error happend
 */
typedef struct _Time_Record {
   int         seconds:6;      /* 0 - 59 */
   int         minutes:6;      /* 0 - 59 */
   int         month:4;        /* 1 - 12 */
   int         hours:6;        /* 0 - 59 */
   int         day:5;          /* 1 - 31 */
   int         year:5;         /* 0=2000, 31=2031 */
} TimeRecord;

/*
 * Error Record
 */
typedef struct _ErrorLog {
   TimeRecord  Time;           /* the time when the error happend */
   UCHAR       ErrorReason;    /* Error Reason or command, see below */
   UCHAR       DiskSeq;        /* Which disk has the error */
   UCHAR       AtaStatus;      /* Ata error status (read from 1x7) */
   UCHAR       nSectors;       /* the number of sectors for I/O command */
   LONG        LBA;            /* the LBA of error location on the disk */
} ErrorLog, *PErrorLog;


/* ErrorReason : others == SCSI command */
#define ARRAY_BROKEN    0xFF   /* some members lost in the array */
#define DEVICE_REMOVED  0xFE   /* some members was removed by hot plug */
#define DEVICE_PLUGGED	0xFD   /* some members was added by hot plug */


#define MAX_ERROR_LOG  32      /* Maximum error log in the info block */

#define RECODR_LBA     9       /* the LBA of the information block on disk */

/*
 * Old version Data structure. No use now. Skip it
 */
typedef struct _ArrayOld {
    LONG       DataOk;         /* This block is vaild disk information block */
    BYTE       BootSelect;     /* This disk was selected as boot disk */
    WORD       BootMark;       /* The boot/set mark is vaild */
    BYTE       Set;            /* disk data transfer mode, 0-4 PIO0-4 */
                               /* 5-7 MW DMA0-3, 8-13 UDMA0-5, 0xFF default */
    LONG       Signature;		 /* This block is vaild disk information block */
    LONG       CreateTime;		 /* Create Time, BCD format */
    LONG       CreateDate;     /* Create Date, BCD format */

    BYTE       nDisk;          /* How many of disks in the array */
    BYTE       DeviceNum;      /* the sequence number of this disk in the array */

    BYTE       Max_Sector;     /* logic sectors in a logic track */
    BYTE       Max_Header;     /* logic head in array disk */
    WORD       Max_Cylinder;   /* logic cylinder in the array disk */
    LONG       capacity;       /* capacity of this array disk */

    WORD       Flag;           /* see below */
} ArrayOld;

/*
 * arrayold.Flag:
 */
#define OLDFLAG_REMAINED_MEMBER 1

/*
 * Array information block on disk (LBA == RECODR_LBA)
 */
typedef union _ArrayBlock {				  
	struct{
		ArrayOld	Old;            /* for compebility. No use now */

		ULONG		Signature;      /* 0 This block is vaild array info block */
		ULONG		StripeStamp;    /* 4 Group mark to link disks into array */
		ULONG		MirrorStamp;    /* 8 RAID 0+1 mark to link two RAID0 */  
		ULONG		order;          /*12 Mirror sequence. 0 - source, 1 - copy */

		UCHAR		nDisks;         /*16 How many of disks in the array */
		UCHAR		BlockSizeShift; /*17 Block size == (1 << BlockSizeShift) */
		UCHAR		ArrayType;      /*18 See below */
		UCHAR		DeviceNum;      /*19 The sequence number of this disk in the array */

		ULONG		capacity;       /*20 the capacity of the array */

		ULONG		DeviceModeSelect;/*24 disk data transfer mode, 0-4 PIO0-4 */
								    /* 5-7 MW DMA0-3, 8-13 UDMA0-5, 0xFF default */
		ULONG		ModeBootSig;    /*28 The BootDisk is vaild or ont */
		UCHAR		BootDisk;       /*32 AF_BOOT_DISK this disk was selected as
								    /*   boot disk. others is not */

		UCHAR		ProtectBootSector;/*33 AF_PROTECT_BS protect boot secter from writing */
		UCHAR		nErrorLog;      /*34 the number of error log in errorlog */
		UCHAR		ErrorLogStart;  /*35 the index of start one */
		ErrorLog	errorLog[MAX_ERROR_LOG]; /* 36 error log records */

		ULONG		lDevSpec;       /* Array Signature        */
		ULONG		lDevDate;       /* The time when the modify happend */
		ULONG		lDevTime;       /* The time when the modify happend */
		ULONG		lDevFlag;       /* Array sequence number of error happend */

		ULONG		RebuiltSector;	/* number of sectors that have been rebuilt */
		UCHAR		Validity;		/* The usable flag of the device, see below */
		union {
			struct {
				ULONG		Version;	// 00 The version of Array Info Block
				ULONG		Size;		// 04 The valid size of Array Info Block structure
				UCHAR		Resv[3];	// For 4-Byte alignment, DONOT USE!!!!(In v2.0919, CheckSum is ULONG)
				UCHAR		CheckSum;	// 08 The checksum of Array Info Block
			} bma;
			UCHAR		ArrayName[32];	/* The Name of the array */	//added by wx 12/25/00
		};
	};
	UCHAR		reserved[512];	  // to keep the arrayblock 512 bytes
} ArrayBlock;

/* Flag: Old Array only support RAID0 and RAID1 */
#define  AI_STRIPE     0x80    /* this is a stripe disk */
#define  AI_MIRROR     0x40    /* this is a mirror disk */



/* Signature */
#define HPT_ARRAY_OLD  0x5a7816fc /* this is old vaild array block */
#define HPT_ARRAY_NEW  0x5a7816f0 /* this is new vaild array block */
#define HPT_TMP_SINGLE 0x5a7816fd /* the array including this disk is broken */
#define HPT_CHK_BOOT   0x12345678 /* user set the boot mark */
#define HPT_MODE_SET   0x5a874600 /* user set the data transfer mode for it */
#define DEVICE_MODE_SET(x) ((x & 0xFFFFFF00)==HPT_MODE_SET)

#define SPECIALIZED_CHAR  0x5A1234A5 /* use to find lose device's Signature word */

/* order */
#define SET_STRIPE_STAMP   4
#define SET_MIRROR_STAMP   2
#define SET_ORDER_OK       1


/* ProtectBootSector */
#define AF_PROTECT_BS      0x69

/* DeviceModeSelect */
#define AF_AUTO_SELECT     0xFF

/* BootDisk */
#define AF_BOOT_DISK       0x80

#define MAX_MEMBERS       7    // Maximum members in an array 

#define MIRROR_DISK    (MAX_MEMBERS - 1)
#define SPARE_DISK     (MAX_MEMBERS - 2)

/* arrayType */
#define VD_RAID_0_STRIPE     0 /* RAID 0 stripe */
#define VD_RAID_1_MIRROR     1 /* RAID 1 mirror */
#define VD_RAID_01_2STRIPE   2 /* the first member of RAID 0+1 made of two RAID 0 */
#define VD_SPAN              3 /* Span */
#define VD_RAID_3            4 /* RAID 3, not implement now */
#define VD_RAID_5            5 /* RAID 5, not implement now */
#define VD_RAID_01_1STRIPE   6 /* RAID 0 + 1 single disk */
#define VD_RAID01_MIRROR     7 /* the second member of RAID 0+1 made of two RAID 0 */

#define VD_RAID_10_SOURCE    8 /* RAID 1+0 source disk */
#define VD_RAID_10_MIRROR    9 /* RAID 1+0 mirror disk */

#define VD_INVALID_TYPE 0xFF  /* invalid array type */

/* Validity */
#define ARRAY_VALID			0x00	/* The device is valid   */
#define ARRAY_INVALID		0xFF	/* The device is invalid */

#include <poppack.h>


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\port\scsi\miniport\hipoint\hpt3xx\winnt\array.h ===
/***************************************************************************
 * File:          array.h
 * Description:   This file include 2 data structures which used for RAID
 *                function.
 *                (2) Srb Extension for array operation 
 *                (3) Virtual disk informatiom
 * Author:        DaHai Huang    (DH)
 * Dependence:    
 *      arraydat.h
 *
 * Copyright (c)  2000 HighPoint Technologies, Inc. All rights reserved
 * History:       DH 5/10/2000 initial code
 *
 ***************************************************************************/

#ifndef _ARRAY_H_
#define _ARRAY_H_

#include <pshpack1.h>

#include "arraydat.h"
/***************************************************************************
 * Description:  Error Log
 ***************************************************************************/

ULONG GetStamp(void);
int  GetUserResponse(PDevice pDevice);

/***************************************************************************
 * Description:  Commmand
 ***************************************************************************/


/***************************************************************************
 * Description: Srb Extesion
 ***************************************************************************/

/*
 * The SrbExtension is used for spilting a logic <LBA, nSector> command	to
 * read, write and verify a striping/span/RAID3/5 to several related physical
 * <lba, nsector> command to do with the members
 * example:
 *	LBA = 17   nSector = 8	  BlockSizeShift = 2  nDisk = 3
 *
 *      (0)              (1)            (2)        sequence munber of the stripe
 * 0   1  2  3       4   5  6  7     8  9  10 11     Logic LBA
 * 12  13 14 15      16 (17 18 10    20 21 22 23     (same line )
 * 24) 25 26 27      28  29 30 31    32 33 34 35 ...
 *
 *   <8, 1>              <5, 3>         <4, 4>      physical <lba, nsectors>
 *
 * tmp = LBA >> BlockSizeShift = 17 >> 2 = 4
 * FirstMember = tmp % nDisk = 4 % 3 = 1
 * StartLBA = (tmp / nDisk) << BlockSizeShift = (4 / 3) << 2 = 4
 * FirstOffset = LBA & ((1 << BlockSizeShift) - 1) = 17 & 3 = 1
 * FirstSectors = (1 << BlockSizeShift) - FirstOffset = 4 - 1 = 3
 * LastMember = 0
 * LastSectors = 1
 * AllMemberBlocks = 0
 * InSameLine = FALSE
 */ 
typedef struct _SrbExtension {
    ULONG      StartLBA;       /* start physical LBA  */

    UCHAR      FirstMember;    /* the sequence number of the first member */
    UCHAR      LastMember;     /* the sequence number of the last member */
    UCHAR      InSameLine;     /* if the start and end on the same line */
    UCHAR      reserve1;

    USHORT     FirstSectors;   /* the number of sectors for the first member */
    USHORT     FirstOffset;    /* the offset from the StartLBA for the first member */

    USHORT     LastSectors;    /* the number of sectors for the last member */
    USHORT     AllMemberBlocks;/* the number of sectors for all member */

    SCAT_GATH  ArraySg[MAX_SG_DESCRIPTORS]; // must at the offset 16!!

    ADDRESS    DataBuffer;     /* pointer to buffer in main memory */
    USHORT     DataTransferLength; /* Transfer length */
    USHORT     SgFlags;        /* allways = 0x8000 */

    ULONG       WorkingFlags;
	PChannel    StartChannel;  // the channel on which the request is initialed
	
    ULONG      Lba;            /* start logic LBA */
    USHORT     JoinMembers;    /* bit map the members who join this IO */ 
    USHORT     WaitInterrupt;  /* bit map the members who wait interrupt */

#ifndef _BIOS_
    USHORT     MirrorJoinMembers;    /* bit map the members who join this IO */ 
    USHORT     MirrorWaitInterrupt;  /* bit map the members who wait interrupt */
    USHORT     nSector;              /* the number of sectors for the IO */
    UCHAR      pad3[3];
    UCHAR      SourceStatus;
    UCHAR      MirrorStatus; 
    UCHAR      member_status;

	UCHAR	   OriginalPathId;
	UCHAR	   OriginalTargetId;
	UCHAR	   OriginalLun;
	UCHAR      RequestSlot;
	void	 (*pfnCallBack)(PHW_DEVIEC_EXTENSION, PSCSI_REQUEST_BLOCK);
#else
    USHORT     nSector;        /* the number of sectors for the IO */
    UCHAR      SrbFlags;
    UCHAR      ScsiStatus;     /* IDE error status(1x7) */
    UCHAR      SrbStatus;      /* IDE completion status */
    UCHAR      Cdb[12];        /* Atapi command */
#endif

} SrbExtension, *PSrbExtension;

/* SRB Working flags define area */
#define	SRB_WFLAGS_USE_INTERNAL_BUFFER		0x00000001 // the transfer is using internal buffer
#define	SRB_WFLAGS_IGNORE_ARRAY				0x00000002 // the operation should ignore the array present
#define	SRB_WFLAGS_HAS_CALL_BACK			0x00000004 // the operation need call a call back routine when finish the working
#define	SRB_WFLAGS_MUST_DONE				0x00000008 // the operation must be done, ignore the locked block setting
#define	SRB_WFLAGS_ON_MIRROR_DISK			0x00000010 // the operation only vaild one mirror part of group
#define	SRB_WFLAGS_ON_SOURCE_DISK			0x00000020 // the operation only vaild one mirror part of group
#define ARRAY_FORCE_PIO   					0x00000040
#define SRB_WFLAGS_ARRAY_IO_STARTED         0x10000000 // StartArrayIo() has been called
#define SRB_WFLAGS_RETRY                    0x20000000

/***************************************************************************
 * Description: Virtual Device Table
 ***************************************************************************/

typedef struct _VirtualDevice {
    UCHAR   nDisk;             /* the number of disks in the stripe */
    UCHAR   BlockSizeShift;    /* the number of shift bit for a block */
    UCHAR   arrayType;         /* see the defination */
	UCHAR	BrokenFlag;			/* if TRUE then broken */
    
    WORD    ArrayNumBlock;     /* = (1 << BlockSizeShift) */
    UCHAR   last_read;       /* for load banlancing */
    UCHAR   pad_1;

    ULONG   Stamp;             /* array ID. all disks in a array has same ID */
	ULONG	MirrorStamp;		/* mirror stamp in RAID 0+1 */
	ULONG	RaidFlags;		   /* see RAID FLAGS delcare area */

	struct _Device  *pDevice[MAX_MEMBERS]; /* member list */

	UCHAR	ArrayName[32];	//the name of array //added by wx 12/26/00

#ifdef _BIOS_
	/* below 5 fields are used as struct Geomitry, DO NOT CHANGE! */
    ULONG   capacity;          /* The real capacity of this disk */
    USHORT  headerXsect_per_tck;/* = MaxSector * MaxHeader */
    USHORT  MaxCylinder;       /* Disk Maximum Logic cylinders */
    UCHAR   MaxSector;         /* Disk Maximum Logic sectors per track */
    UCHAR   MaxHeader;         /* Disk Maximum Logic head */

	UCHAR   far *os_lba9;
#else
    ULONG   capacity;          /* capacity for the array */
	UCHAR	os_lba9[512];       /* used to buffer OS's data on LBA 9(array info block) */
#endif
} VirtualDevice, *PVirtualDevice;

/* pDevice[MAX_MEMBERS] */
extern PVirtualDevice  pLastVD;	

/*
 * RAID FLAGS declare area
 */						  
#define RAID_FLAGS_NEED_SYNCHRONIZE		0x00000001
#define RAID_FLAGS_INVERSE_MIRROR_ORDER 0x00000002 
#define RAID_FLAGS_BEING_BUILT			0x00000004
#define RAID_FLAGS_DISABLED				0x00000008
#define RAID_FLAGS_BOOTDISK				0x00000010
#define RAID_FLAGS_NEWLY_CREATED		0x00000020
#define RAID_FLAGS_NEED_AUTOREBUILD		0x00000040

/* 
 * relationship between ArrayBlock and VirtualDevice
 * VirtualDevice                   | ArrayBlock
 * arrayType  pDevice[]             ArrayType StripeStamp MirrorStamp
 0 RAID 0      0-nDisk-1             0             use      ignore
 1 RAID 1      0,MIRROR_DISK         1             use      ignore
 2 RAID 0+1    0-nDisk-1             0             use      use
 3 SPAN        0-nDisk-1             3             use      ignore
 7 RAID 0+1                          0             use      use
 */

#include <poppack.h>

#endif //_ARRAY_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\port\scsi\miniport\hipoint\hpt3xx\winnt\array.c ===
/***************************************************************************
 * File:          array.c
 * Description:   Subroutines in the file are used to perform the operations
 *                of array which are called at Disk IO and check, create and 
 *                remove array
 * Author:        DaHai Huang    (DH)
 * Dependence:    none
 * Copyright (c)  2000 HighPoint Technologies, Inc. All rights reserved
 * History:   
 *     DH  05/10/2000 initial code
 *     GX  11/23/2000 process broken array in driver(Gengxin)
 *     SC  12/10/2000 add retry while reading RAID info block sector. This is
 *            			 caused by cable detection reset
 *     gmm 03/01/2001  Check for when lost members put back.
 *	   gmm 03/12/2001  add a bootable flag for each device, in DeviceFlags2
 ***************************************************************************/
#include "global.h"

/******************************************************************
 * Check if this disk is a member of array
 *******************************************************************/
void CheckArray(IN PDevice pDevice ARG_OS_EXT)
{
    PChannel             pChan = pDevice->pChannel;
    PVirtualDevice       pStripe, pMirror;
    UCHAR                Mode, i=0;
    LOC_ARRAY_BLK;

#ifndef _BIOS_
	/* gmm 2001-6-7
	 *  If a disk is faulted right here, we should remove that device
	 */
	if (!ReadWrite(pDevice, RECODR_LBA, IDE_COMMAND_READ ARG_ARRAY_BLK)) {
		pDevice->DeviceFlags2 |= DFLAGS_DEVICE_DISABLED;
		return;
	}
#else
    ReadWrite(pDevice, RECODR_LBA, IDE_COMMAND_READ ARG_ARRAY_BLK);
    Mode = (UCHAR)ArrayBlk.Signature;
	 while(Mode ==0 && i++<3) {
          ReadWrite(pDevice, RECODR_LBA, IDE_COMMAND_READ ARG_ARRAY_BLK);
          Mode = (UCHAR)ArrayBlk.Signature;
		    StallExec(1000L);
    }
#endif

    Mode = (UCHAR)ArrayBlk.DeviceModeSelect;
#if 0
    if(ArrayBlk.ModeBootSig == HPT_CHK_BOOT &&
       DEVICE_MODE_SET(ArrayBlk.DeviceModeSelect) &&
       Mode <= pDevice->Usable_Mode &&
       Mode != pDevice->DeviceModeSetting)
    {   //  set device timing mode
        DeviceSelectMode(pDevice, Mode);
    }
#endif

	// gmm 2001-8-14
	if (ArrayBlk.ModeBootSig == HPT_CHK_BOOT && ArrayBlk.BootDisk) {
		pDevice->DeviceFlags2 |= DFLAGS_BOOT_MARK;
	}

	if (ArrayBlk.Signature!=HPT_ARRAY_NEW || ArrayBlk.DeviceNum>MIRROR_DISK)
		goto os_check;
		
	/* check BMA structures, convert it */
	if (ArrayBlk.bma.Version==0x5AA50001 || ArrayBlk.bma.Version==0x00010000) {
		if (ArrayBlk.RebuiltSector==0 && ArrayBlk.Validity==0) {
			ArrayBlk.RebuiltSector = 0x7FFFFFFF;
			switch(ArrayBlk.ArrayType) {
			case VD_RAID_1_MIRROR:
				strcpy(ArrayBlk.ArrayName, "RAID_1");
				break;
			case VD_SPAN:
				strcpy(ArrayBlk.ArrayName, "JBOD");
				break;
			case VD_RAID_0_STRIPE:
			case VD_RAID_01_2STRIPE:
			case VD_RAID01_MIRROR:
				strcpy(ArrayBlk.ArrayName, "RAID_0");
				if (ArrayBlk.MirrorStamp==0)
					break;
				ArrayBlk.ArrayType = VD_RAID_01_2STRIPE;
				strcpy(&ArrayBlk.ArrayName[16], "RAID_01");
				break;
			}
			ReadWrite(pDevice, RECODR_LBA, IDE_COMMAND_WRITE ARG_ARRAY_BLK);
		}
	}

	// 2001-3-1
	if (ArrayBlk.Old.Flag & OLDFLAG_REMAINED_MEMBER)
		pDevice->DeviceFlags2 |= DFLAGS_REMAINED_MEMBER;

    pStripe = pMirror = 0;
    for(pStripe = VirtualDevices; pStripe < pLastVD; pStripe++) 
    {
        if(ArrayBlk.StripeStamp == pStripe->Stamp) 
        {   //  find out that this disk is a member of an existing array
            goto set_device;
        }
    }

    pStripe = pLastVD++;
    ZeroMemory(pStripe, sizeof(VirtualDevice));
#ifdef _BIOS_
    pStripe->os_lba9 = GET_ARRAY_LBA9_BUF(pStripe);
#endif
    pStripe->arrayType = ArrayBlk.ArrayType;
    pStripe->Stamp = ArrayBlk.StripeStamp;
	// gmm 2001-3-3:
    pStripe->MirrorStamp = ArrayBlk.MirrorStamp;

	// moved from below.
    pStripe->BlockSizeShift = ArrayBlk.BlockSizeShift;
    pStripe->ArrayNumBlock = 1<<ArrayBlk.BlockSizeShift;
    pStripe->capacity = ArrayBlk.capacity;

    /*+
     * gmm: We will clear Broken flag only on a array correctly constructed.
     *		Otherwise the GUI will report a wrong status.
     */
    pStripe->BrokenFlag = TRUE;
    //-*/

set_device:
	/* gmm */
	pDevice->RebuiltSector = ArrayBlk.RebuiltSector;

    if (pStripe->pDevice[ArrayBlk.DeviceNum] != 0)	//if the position exist disk then ...
	{												//for prevent a array destroied
#if 0
        ArrayBlk.Signature = 0;
        ReadWrite(pDevice, RECODR_LBA, IDE_COMMAND_WRITE ARG_ARRAY_BLK);
#endif
        goto os_check;
    }
    /* set array name. For compatibility with BMA driver, check array name validaty */
    {
    	UCHAR ch;
	    if(pStripe->ArrayName[0] == 0) {
			for(i=0; i<32; i++) {
				ch = ArrayBlk.ArrayName[i];
				if (ch<0x20 || ch>0x7f) ch=0;
				pStripe->ArrayName[i] = ch;
			}
			pStripe->ArrayName[15] = 0;
			pStripe->ArrayName[31] = 0;
		}
	}

//////////////////
				// Add by Gengxin, 11/22/2000
				// For enable process broken array
				// When pDevice[0] lost,
				// disk of after pDevice[0] change to pDevice[0],
				// otherwise driver will down.
#ifndef _BIOS_
	if( (ArrayBlk.Signature == HPT_TMP_SINGLE) &&
			(ArrayBlk.ArrayType == VD_RAID_1_MIRROR) &&
			(ArrayBlk.DeviceNum ==  MIRROR_DISK) )
	{
		ArrayBlk.DeviceNum= 0;
	}
	else if( (ArrayBlk.Signature == HPT_TMP_SINGLE) &&
		(ArrayBlk.ArrayType == VD_RAID_0_STRIPE) &&
		(pStripe->pDevice[0] ==0 ) &&  //if the stripe contain disk number>2, need the condition
		//||(ArrayBlk.ArrayType == VD_SPAN)
		(ArrayBlk.DeviceNum != 0) )  //if raid0 then it can't reach here, only for raid0+1
								//because if raid0 broken,then it will become physical disk
	{
		ArrayBlk.DeviceNum= 0;
	}

	/*-
	 * gmm: rem out this code. See also above code
	 *
	if( ArrayBlk.Signature == HPT_TMP_SINGLE )
	{
		pStripe->BrokenFlag= TRUE;
		pMirror->BrokenFlag= TRUE; // pMirror==NULL now
	}
	*/

#endif //_BIOS_
//////////////////
    
    pStripe->pDevice[ArrayBlk.DeviceNum] = pDevice;

    pDevice->ArrayNum  = ArrayBlk.DeviceNum;
    pDevice->ArrayMask = (1 << ArrayBlk.DeviceNum);
    pDevice->pArray    = pStripe;

    if(ArrayBlk.DeviceNum <= ArrayBlk.nDisks) {
        if(ArrayBlk.DeviceNum < ArrayBlk.nDisks) 
        {
            pStripe->nDisk++;
        }

        if(ArrayBlk.DeviceNum != 0) {
            pDevice->HidenLBA = (RECODR_LBA + 1);
            pDevice->capacity -= (RECODR_LBA + 1);
        }
        
        if(ArrayBlk.nDisks > 1)
        {
            pDevice->DeviceFlags |= DFLAGS_ARRAY_DISK;
        }

    } 
    else if(ArrayBlk.DeviceNum == MIRROR_DISK) 
    {

      pStripe->arrayType = (UCHAR)((ArrayBlk.nDisks == 1)? 
           VD_RAID_1_MIRROR : VD_RAID_01_1STRIPE);
//      if(pStripe->capacity)
//          pStripe->Stamp = ArrayBlk.order & SET_ORDER_OK;
      goto hiden;

    } 
    else if(ArrayBlk.DeviceNum == SPARE_DISK) 
    {
        goto hiden;
    }

   if( (pStripe->nDisk == ArrayBlk.nDisks)
//////////////
			// Added by Gengxin, 11/24/2000
			// For process array broken .
			// Let broken array may become a array.
#ifndef _BIOS_
		||(ArrayBlk.Signature == HPT_TMP_SINGLE)
#endif //_BIOS_
//////////////
		)
	{
 		//+
 		// gmm:
		// An array is completely setup.
		// Unhide pDevice[0].
		// Thus the hidden flag is consistent with BIOS setting interface.
		//
		pDevice->DeviceFlags |= DFLAGS_HIDEN_DISK; 
		if (pStripe->pDevice[0]) pStripe->pDevice[0]->DeviceFlags &= ~DFLAGS_HIDEN_DISK;
		//-*/
		
		// move to above. otherwise broken array will have no value
        /*
		pStripe->BlockSizeShift = ArrayBlk.BlockSizeShift;
        pStripe->ArrayNumBlock = 1<<ArrayBlk.BlockSizeShift;
        pStripe->capacity = ArrayBlk.capacity;
		*/

        //  check if there are some 0+1 arrays
        if(ArrayBlk.MirrorStamp) 
        {
            for(pMirror = VirtualDevices; pMirror < pLastVD; pMirror++) 
            {
                //  looking for another member array of the 0+1 array
                if( pMirror->arrayType != VD_INVALID_TYPE &&
					pMirror != pStripe && 
                    pMirror->capacity != 0 &&
                    ArrayBlk.MirrorStamp == pMirror->Stamp ) 
                {
					PVirtualDevice	pArrayNeedHide;
					
					//  find the sibling array of 'pStripe', it 'pMirror'
                    pStripe->pDevice[MIRROR_DISK] = pMirror->pDevice[0];
                    pMirror->pDevice[MIRROR_DISK] = pStripe->pDevice[0];
                    
                    //  If the order flag of this disk contains SET_ORDER_OK,
                    //  it belongs to the original array of the 0+1 array
                    if( ArrayBlk.order & SET_ORDER_OK )
                    {   //  so the 'pStripe' points to the original array
                        pStripe->arrayType = VD_RAID_01_2STRIPE;
                        pMirror->arrayType = VD_RAID01_MIRROR;
						pArrayNeedHide = pMirror;
                    }
                    else
                    {   //  else the disk belongs to the mirror array of the 0+1 array
                        //  so the 'pStripe' points to the mirror array
                        pStripe->arrayType = VD_RAID01_MIRROR;
                        pMirror->arrayType = VD_RAID_01_2STRIPE;
						
						// now save the true mirror stripe point to
						// pMirror
						pArrayNeedHide = pStripe;
                    }
                    
                    if(ArrayBlk.capacity < pMirror->capacity)
                    {
                        pMirror->capacity = ArrayBlk.capacity;
                    }

//                    pMirror->Stamp = ArrayBlk.order & SET_ORDER_OK;
					
					// now we need hide all disk in mirror group
					for(i = 0; i < pArrayNeedHide->nDisk; i++){
						pArrayNeedHide->pDevice[i]->DeviceFlags |= DFLAGS_HIDEN_DISK;
					}
                }
            }
            
            pStripe->Stamp = ArrayBlk.MirrorStamp;

        } 
//      else if(pStripe->pDevice[MIRROR_DISK])
//         pStripe->Stamp = ArrayBlk.order & SET_ORDER_OK;

    } else
hiden:
//////////
		// Add by Gengxin, 11/30/2000
		// If the disk belong to a broken array(stripe or mirror),
		// then its 'hidden_flag' disable .
	{
		if (
			(ArrayBlk.Signature == HPT_TMP_SINGLE) &&
				( pStripe->arrayType==VD_RAID_0_STRIPE ||
				  pStripe->arrayType==VD_RAID_1_MIRROR
				)
			)
			pDevice->DeviceFlags |= ~DFLAGS_HIDEN_DISK;
		else
			pDevice->DeviceFlags |= DFLAGS_HIDEN_DISK; 
	}
////////// for process broken array

    /*+
     * gmm: We will clear Broken flag only on a array correctly constructed.
     *		Otherwise the GUI will report a wrong status.
     */
    switch(pStripe->arrayType){
    case VD_RAID_0_STRIPE:
    case VD_RAID_01_2STRIPE:
    case VD_RAID01_MIRROR:
    case VD_SPAN:
	    if (pStripe->nDisk == ArrayBlk.nDisks)
	    	pStripe->BrokenFlag = FALSE;
	    break;
	case VD_RAID_1_MIRROR:
		if (pStripe->pDevice[0] && pStripe->pDevice[MIRROR_DISK])
			pStripe->BrokenFlag = FALSE;
		break;
	case VD_RAID_01_1STRIPE:
		if (pStripe->pDevice[0] && pStripe->pDevice[1] && pStripe->pDevice[MIRROR_DISK])
			pStripe->BrokenFlag = FALSE;
		/*
		 * for this type of 0+1 we should check which is the source disk.
		 */
		if (ArrayBlk.DeviceNum==MIRROR_DISK && (ArrayBlk.order & SET_ORDER_OK))
			pStripe->RaidFlags |= RAID_FLAGS_INVERSE_MIRROR_ORDER;
		break;
	default:
		break;
	}

	if (pStripe->capacity ==0 ) pStripe->capacity=ArrayBlk.capacity;

	if (!pStripe->BrokenFlag) {
		if (pStripe->pDevice[0]->RebuiltSector < pStripe->capacity)
			pStripe->RaidFlags |= RAID_FLAGS_NEED_SYNCHRONIZE;
	}
    //-*/

os_check:
	/* gmm 2001-6-13
	 *  Save ArrayBlk to pDev->real_lba9
	 */
	_fmemcpy(pDevice->real_lba9, &ArrayBlk, 512);
	/*
	 * gmm 2001-3-12
	 * check bootable flag.
	 */
#ifndef _BIOS_
	// only check single disks and array first member and RAID1 members
	if (!pDevice->pArray || !pDevice->ArrayNum || !pDevice->HidenLBA) {
		check_bootable(pDevice);
	}
	//-*/
#endif
	OS_Array_Check(pDevice); 
}

/***************************************************************************
 * Description:
 *   Adjust array settings after all device is checked
 *   Currently we call it from hwInitialize370 
 *   But it works only when one controller installed
 ***************************************************************************/
void Final_Array_Check(int no_use ARG_OS_EXT)
{
	int i, set_remained;
	UINT mask=0;
	PVirtualDevice pArray, pMirror;
	PDevice pDev;
	LOC_ARRAY_BLK;

	// gmm 2001-3-3
//check_again:
	for (i=0; i<pLastVD-VirtualDevices; i++)
	{
		if (mask & (1<<i)) continue;
		mask |= 1<<i;
		pArray = &VirtualDevices[i];
		if(pArray->arrayType != VD_INVALID_TYPE && pArray->MirrorStamp)
		{
			for (pMirror=pArray+1; pMirror<pLastVD; pMirror++)
			{
				if (pMirror->MirrorStamp==pArray->MirrorStamp)
				{
					mask |= 1<<(pMirror-VirtualDevices);
					/*
					 * if any member RAID0 is broken, they will not be linked
					 * in CheckArray(). We'll handle this case here.
					 */
					if (pArray->BrokenFlag || pMirror->BrokenFlag){
						int ii;
						PDevice pDev1=0, pDev2=0;
						if (pArray->BrokenFlag) {
							if (!pMirror->BrokenFlag) {
								// source is broken. Swap.
								PVirtualDevice tmp = pArray;
								pArray = pMirror;
								pMirror = tmp;
							}
							else
								pArray->RaidFlags |= RAID_FLAGS_DISABLED;
						}
						for (ii=0; ii<SPARE_DISK; ii++) if (pDev1=pArray->pDevice[ii]) break;
						for (ii=0; ii<SPARE_DISK; ii++) if (pDev2=pMirror->pDevice[ii]) break;
						if (pDev1 && pDev2) {
							pArray->pDevice[MIRROR_DISK] = pDev2;
							pMirror->pDevice[MIRROR_DISK] = pDev1;
						}
						pArray->arrayType = VD_RAID_01_2STRIPE;
						pMirror->arrayType = VD_RAID01_MIRROR;
						if (pArray->pDevice[0])
							pArray->pDevice[0]->DeviceFlags &= ~DFLAGS_HIDEN_DISK;
						if (pMirror->pDevice[0])
							pMirror->pDevice[0]->DeviceFlags |= DFLAGS_HIDEN_DISK;
						// gmm 2001-4-14 since it's broken, remove the flag
						pArray->RaidFlags &= ~RAID_FLAGS_NEED_SYNCHRONIZE;
						pMirror->RaidFlags &= ~RAID_FLAGS_NEED_SYNCHRONIZE;
					}
					else {
						/*
						 * now we only support RAID 0/1 with same block size.
						 * if it's an old version RAID 0/1 array, rebuild it 
						 */
						if (pArray->BlockSizeShift!=pMirror->BlockSizeShift) {
							pMirror->BlockSizeShift = pArray->BlockSizeShift;
							pArray->RaidFlags |= RAID_FLAGS_NEED_SYNCHRONIZE;
						}
					}					
					goto next_check;
				}
			}
			// no mirror found. Change mirror to source.
			pArray->arrayType = VD_RAID_01_2STRIPE;
			if (pArray->BrokenFlag) pArray->RaidFlags |= RAID_FLAGS_DISABLED;
		}
next_check:
		;
	}

	for (pArray=VirtualDevices; pArray<pLastVD; pArray++) {
		switch (pArray->arrayType){
		case VD_RAID_1_MIRROR:
			//
			// gmm 2001-3-1
			// if any previously lost members are put back,
			// we must not use it as normal.
			//
			if (!pArray->BrokenFlag) {
				if ((pArray->pDevice[0] && 
					(pArray->pDevice[0]->DeviceFlags2 & DFLAGS_REMAINED_MEMBER)) ||
					(pArray->pDevice[MIRROR_DISK] && 
					(pArray->pDevice[MIRROR_DISK]->DeviceFlags2 & DFLAGS_REMAINED_MEMBER)) ||
					(pArray->pDevice[SPARE_DISK] && 
					(pArray->pDevice[SPARE_DISK]->DeviceFlags2 & DFLAGS_REMAINED_MEMBER)))
				{
#if 1
					/* gmm 2001-4-13
					 *  Let GUI prompt user to rebuild the array.
					 *  Do not change array info.
					 */
					if ((pDev=pArray->pDevice[0]) && 
						!(pDev->DeviceFlags2 & DFLAGS_REMAINED_MEMBER)) {
						// swap source/target.
						PDevice pDev2 = pArray->pDevice[MIRROR_DISK];
						if (pDev2) {
							pArray->pDevice[0] = pDev2;
							pDev2->ArrayNum = 0;
							pDev2->ArrayMask = 1;
							pDev2->DeviceFlags &= ~DFLAGS_HIDEN_DISK;
							pArray->pDevice[MIRROR_DISK] = pDev;
							pDev->ArrayNum = MIRROR_DISK;
							pDev->ArrayMask = 1<<MIRROR_DISK;
							pDev->DeviceFlags |= DFLAGS_HIDEN_DISK;
							pArray->RaidFlags |= RAID_FLAGS_NEED_SYNCHRONIZE;
						}
					}
					if ((pDev=pArray->pDevice[MIRROR_DISK]) && 
						!(pDev->DeviceFlags2 & DFLAGS_REMAINED_MEMBER)) {
						if (pArray->pDevice[0])
							pArray->RaidFlags |= RAID_FLAGS_NEED_SYNCHRONIZE;
					}
#else
					// re-set previously lost member as single disk.
					if ((pDev=pArray->pDevice[0]) && 
						!(pDev->DeviceFlags2 & DFLAGS_REMAINED_MEMBER)) {
						pDev->pArray = NULL;
						pDev->DeviceFlags &= ~DFLAGS_HIDEN_DISK;
						pArray->pDevice[0] = NULL;
						pArray->BrokenFlag = TRUE;
						ReadWrite(pDev, RECODR_LBA, IDE_COMMAND_READ ARG_ARRAY_BLK);
						ArrayBlk.Signature = 0;
						ArrayBlk.ModeBootSig = 0;
						ReadWrite(pDev, RECODR_LBA, IDE_COMMAND_WRITE ARG_ARRAY_BLK);
						// gmm 2001-3-15: clear mbr.
						ZeroMemory(&ArrayBlk, 512);
						ReadWrite(pDev, 0, IDE_COMMAND_WRITE ARG_ARRAY_BLK);
						pDev->DeviceFlags2 &= ~DFLAGS_BOOTABLE_DEVICE;
					}
					if ((pDev=pArray->pDevice[MIRROR_DISK]) && 
						!(pDev->DeviceFlags2 & DFLAGS_REMAINED_MEMBER)) {
						pDev->pArray = NULL;
						pDev->DeviceFlags &= ~DFLAGS_HIDEN_DISK;
						pArray->pDevice[MIRROR_DISK]=NULL;
						pArray->BrokenFlag = TRUE;
						ReadWrite(pDev, RECODR_LBA, IDE_COMMAND_READ ARG_ARRAY_BLK);
						ArrayBlk.Signature = 0;
						ArrayBlk.ModeBootSig = 0;
						ReadWrite(pDev, RECODR_LBA, IDE_COMMAND_WRITE ARG_ARRAY_BLK);
						// gmm 2001-3-15: clear mbr.
						ZeroMemory(&ArrayBlk, 512);
						ReadWrite(pDev, 0, IDE_COMMAND_WRITE ARG_ARRAY_BLK);
						pDev->DeviceFlags2 &= ~DFLAGS_BOOTABLE_DEVICE;
					}
					if ((pDev=pArray->pDevice[SPARE_DISK]) && 
						!(pDev->DeviceFlags2 & DFLAGS_REMAINED_MEMBER)) {
						pDev->pArray = NULL;
						pDev->DeviceFlags &= ~DFLAGS_HIDEN_DISK;
						pArray->pDevice[SPARE_DISK]=NULL;
						/// DO NOT SET pArray->BrokenFlag = TRUE;
						ReadWrite(pDev, RECODR_LBA, IDE_COMMAND_READ ARG_ARRAY_BLK);
						ArrayBlk.Signature = 0;
						ArrayBlk.ModeBootSig = 0;
						ReadWrite(pDev, RECODR_LBA, IDE_COMMAND_WRITE ARG_ARRAY_BLK);
						// gmm 2001-3-15: clear mbr.
						ZeroMemory(&ArrayBlk, 512);
						ReadWrite(pDev, 0, IDE_COMMAND_WRITE ARG_ARRAY_BLK);
						pDev->DeviceFlags2 &= ~DFLAGS_BOOTABLE_DEVICE;
					}
#endif // 
				}
			}
			// gmm 2001-6-8
			set_remained = pArray->BrokenFlag? 1 : 0;
			/*
			 * if source lost. Change mirror disk to source.
			 */
			if ((!pArray->pDevice[0]) && pArray->pDevice[MIRROR_DISK]) {
				pDev = pArray->pDevice[MIRROR_DISK];
				pDev->ArrayMask = 1;
				pDev->ArrayNum = 0;
				pArray->pDevice[0] = pDev;
				pArray->pDevice[MIRROR_DISK] = NULL;
				pArray->nDisk = 1;
				pDev->DeviceFlags &= ~DFLAGS_HIDEN_DISK;
			}
			/* gmm 2001-3-4
			 * if mirror lost. Change spare disk to mirror.
			 */
#ifndef _BIOS_
			if (pArray->pDevice[0] && 
				!pArray->pDevice[MIRROR_DISK] && 
				pArray->pDevice[SPARE_DISK]) 
			{
				pDev = pArray->pDevice[SPARE_DISK];
				pDev->ArrayMask = 1<<MIRROR_DISK;
				pDev->ArrayNum = MIRROR_DISK;
				pArray->pDevice[MIRROR_DISK] = pDev;
				pArray->pDevice[SPARE_DISK] = NULL;
				pArray->nDisk = 1;
				pArray->BrokenFlag = FALSE;
				pArray->RaidFlags |= RAID_FLAGS_NEED_SYNCHRONIZE;
				/* 2001-9-13
				 * write a new array info to the two disks
				 */
				ReadWrite(pArray->pDevice[0], RECODR_LBA, IDE_COMMAND_READ ARG_ARRAY_BLK);
				ArrayBlk.StripeStamp++;
				ArrayBlk.Old.Flag = 0;
				ArrayBlk.RebuiltSector = 0;
				ArrayBlk.DeviceNum = 0;
				ReadWrite(pArray->pDevice[0], RECODR_LBA, IDE_COMMAND_WRITE ARG_ARRAY_BLK);
				ArrayBlk.DeviceNum = MIRROR_DISK;
				ReadWrite(pDev, RECODR_LBA, IDE_COMMAND_WRITE ARG_ARRAY_BLK);
			}
#endif // ! _BIOS_
			/* gmm 2001-6-8
			 *  Haven't set remained flag when only source ok in origional code?
			 *  Now it should work
			 */
#ifndef _BIOS_
			if (set_remained) {
				for (i=0; i<MAX_MEMBERS; i++) {
					pDev = pArray->pDevice[i];
					if (!pDev) continue;
					ReadWrite(pDev, RECODR_LBA, IDE_COMMAND_READ ARG_ARRAY_BLK);
					ArrayBlk.Old.Flag |= OLDFLAG_REMAINED_MEMBER;
					ArrayBlk.RebuiltSector = 0;
					ReadWrite(pDev, RECODR_LBA, IDE_COMMAND_WRITE ARG_ARRAY_BLK);
				}
			}
#endif
			break;
		case VD_RAID_0_STRIPE:
		case VD_SPAN:
			if (pArray->BrokenFlag)
				pArray->RaidFlags |= RAID_FLAGS_DISABLED;
			break;
		case VD_RAID_01_2STRIPE:
			// gmm 2001-4-13
			//  let GUI prompt user to duplicate.
#if 1
			{
				int has_remained=0, removed=0;
				pMirror=NULL;
				if (pArray->pDevice[MIRROR_DISK])
					pMirror=pArray->pDevice[MIRROR_DISK]->pArray;
				if (pMirror && !pArray->BrokenFlag && !pMirror->BrokenFlag) {
					for (i=0; i<pArray->nDisk; i++)
						if (pArray->pDevice[i]->DeviceFlags2 & DFLAGS_REMAINED_MEMBER) {
							has_remained = 1;

						}
						else
							removed = 1;
					if (!has_remained) for (i=0; i<pMirror->nDisk; i++)
						if (pMirror->pDevice[i]->DeviceFlags2 & DFLAGS_REMAINED_MEMBER) {
							has_remained = 1;

						}
						else
							removed = 2;
					if (has_remained) {
						if (removed==1) {
							PVirtualDevice tmp;
							// swap source/mirror
							tmp = pArray; pArray = pMirror; pMirror = tmp;
							pArray->arrayType = VD_RAID_01_2STRIPE;
							pMirror->arrayType = VD_RAID01_MIRROR;
							pArray->pDevice[0]->DeviceFlags &= ~DFLAGS_HIDEN_DISK;
							pMirror->pDevice[0]->DeviceFlags |= DFLAGS_HIDEN_DISK;
						}
						pArray->RaidFlags |= RAID_FLAGS_NEED_SYNCHRONIZE;
					}
				}
				/* gmm 2001-6-8
				 *  Set remained member flag.
				 */
				else {
					for (i=0; i<SPARE_DISK; i++) {
						pDev = pArray->pDevice[i];
						if (!pDev) continue;
						ReadWrite(pDev, RECODR_LBA, IDE_COMMAND_READ ARG_ARRAY_BLK);
						ArrayBlk.Old.Flag |= OLDFLAG_REMAINED_MEMBER;
						ArrayBlk.RebuiltSector = 0;
						ReadWrite(pDev, RECODR_LBA, IDE_COMMAND_WRITE ARG_ARRAY_BLK);
					}
					if (pMirror) for (i=0; i<SPARE_DISK; i++) {
						pDev = pMirror->pDevice[i];
						if (!pDev) continue;
						ReadWrite(pDev, RECODR_LBA, IDE_COMMAND_READ ARG_ARRAY_BLK);
						ArrayBlk.Old.Flag |= OLDFLAG_REMAINED_MEMBER;
						ArrayBlk.RebuiltSector = 0;
						ReadWrite(pDev, RECODR_LBA, IDE_COMMAND_WRITE ARG_ARRAY_BLK);
					}
				}
				//-*/
			}
#else
			// re-set previously lost member as single disk.
			{
				PDevice pDevs[MAX_MEMBERS*2];
				int nDev=0;
				PVirtualDevice pMirror=NULL;
				if (pArray->pDevice[MIRROR_DISK])
					pMirror=pArray->pDevice[MIRROR_DISK]->pArray;
				if (pMirror && !pArray->BrokenFlag && !pMirror->BrokenFlag) {
					for (i=0; i<pArray->nDisk; i++)
						if (pArray->pDevice[i]) pDevs[nDev++] = pArray->pDevice[i];
					for (i=0; i<pMirror->nDisk; i++) 
						if (pMirror->pDevice[i]) pDevs[nDev++] = pMirror->pDevice[i];
					for (i=0; i<nDev; i++) {
						if (pDevs[i]->DeviceFlags2 & DFLAGS_REMAINED_MEMBER) {
							int j;
							BOOL bHasRemoved = FALSE;
							for (j=0; j<nDev; j++) {
								if (!(pDevs[j]->DeviceFlags2 & DFLAGS_REMAINED_MEMBER)) {
									pDevs[j]->pArray->BrokenFlag = TRUE;
									pDevs[j]->pArray->nDisk = 0;
									pDevs[j]->pArray->RaidFlags |= RAID_FLAGS_DISABLED;
									pDevs[j]->pArray = NULL;
									if (pDevs[j]->HidenLBA) {
										pDevs[j]->capacity += (RECODR_LBA + 1);
										pDevs[j]->HidenLBA = 0;
									}
									pDevs[j]->DeviceFlags &= ~(DFLAGS_ARRAY_DISK|DFLAGS_HIDEN_DISK);
									ReadWrite(pDevs[j], RECODR_LBA, IDE_COMMAND_READ ARG_ARRAY_BLK);
									ArrayBlk.Signature = 0;
									ArrayBlk.ModeBootSig = 0;
									ReadWrite(pDevs[j], RECODR_LBA, IDE_COMMAND_WRITE ARG_ARRAY_BLK);
									bHasRemoved = TRUE;
									// gmm 2001-3-15: clear mbr.
									ZeroMemory(&ArrayBlk, 512);
									ReadWrite(pDevs[j], 0, IDE_COMMAND_WRITE ARG_ARRAY_BLK);
									pDevs[j]->DeviceFlags2 &= ~DFLAGS_BOOTABLE_DEVICE;
								}
							}
							for (j=0; j<MAX_MEMBERS; j++) {
								if (pArray->pDevice[j] && pArray->pDevice[j]->pArray==NULL)
									pArray->pDevice[j] = NULL;
							}
							for (j=0; j<MAX_MEMBERS; j++) {
								if (pMirror->pDevice[j] && pMirror->pDevice[j]->pArray==NULL)
									pMirror->pDevice[j] = NULL;
							}
							if (bHasRemoved) goto check_again;
							break;
						}
					}
				}
			}
#endif // 
			if (pArray->BrokenFlag)
				pArray->RaidFlags |= RAID_FLAGS_DISABLED;
			break;
		case VD_RAID01_MIRROR:
			if (pArray->BrokenFlag)
				pArray->RaidFlags |= RAID_FLAGS_DISABLED;
			break;
		}

#ifndef _BIOS_
		/*
		 *  check array bootable flag.
		 */
		pDev = pArray->pDevice[0];
		if (pDev && !(pDev->DeviceFlags & DFLAGS_HIDEN_DISK))
		{
			if (pDev->DeviceFlags2 & DFLAGS_BOOTABLE_DEVICE)
				pArray->RaidFlags |= RAID_FLAGS_BOOTDISK;
		}
#endif
	}
}

/***************************************************************************
 * Description:  Seperate a array int single disks
 ***************************************************************************/

void MaptoSingle(PVirtualDevice pArray, int flag)
{
    PDevice pDev;
    UINT    i;
//    LOC_ARRAY_BLK;

    if(flag == REMOVE_DISK) {
        i = MAX_MEMBERS;
        pDev = (PDevice)pArray;
        goto delete;
    }

    pArray->nDisk = 0;
    pArray->arrayType = VD_INVALID_TYPE;
    for(i = 0; i < MAX_MEMBERS; i++) {
        if((pDev = pArray->pDevice[i]) == 0)
            continue;
        pArray->pDevice[i] = 0;
delete:
        pDev->DeviceFlags &= ~(DFLAGS_HIDEN_DISK | DFLAGS_ARRAY_DISK);
        pDev->pArray = 0;
        if (pDev->HidenLBA) {
            pDev->capacity += (RECODR_LBA + 1);
            pDev->HidenLBA = 0;
        }
        pDev->DeviceFlags &= ~(DFLAGS_HIDEN_DISK | DFLAGS_ARRAY_DISK);
#ifdef _BIOS_
		ZeroMemory(&ArrayBlk, 512);
        ReadWrite(pDev, RECODR_LBA, IDE_COMMAND_WRITE ARG_ARRAY_BLK);
#endif        
    }
}

/***************************************************************************
 * Description:  Create Mirror
 ***************************************************************************/
void SetArray(PVirtualDevice pArray, int flag, ULONG MirrorStamp)
{
    PDevice        pDev;
    ULONG          Stamp = GetStamp();
    UINT           i, j;
    LOC_ARRAY_BLK;

	/* gmm 2001-4-13
	 *  set array stamp
	 */
	if (flag & SET_STRIPE_STAMP)
		pArray->Stamp = Stamp;
	if (flag & SET_MIRROR_STAMP)
		pArray->MirrorStamp = MirrorStamp;

    for(i = 0; i < MAX_MEMBERS; i++) {
        if((pDev = pArray->pDevice[i]) == 0)
            continue;

		ZeroMemory((char *)&ArrayBlk, 512);
    
		for(j=0; j<32; j++)
		   ArrayBlk.ArrayName[j] =	pArray->ArrayName[j];
		
        ArrayBlk.Signature = HPT_ARRAY_NEW; 
        ArrayBlk.order = flag;

        pDev->pArray = pArray;
        pDev->ArrayNum  = (UCHAR)i;
        pDev->ArrayMask = (1 << i);
	
        ArrayBlk.ArrayType    = pArray->arrayType;    
        ArrayBlk.StripeStamp  = Stamp;
        ArrayBlk.nDisks       = pArray->nDisk;            
        ArrayBlk.BlockSizeShift = pArray->BlockSizeShift;
        ArrayBlk.DeviceNum    = (UCHAR)i; 

        if(flag & SET_STRIPE_STAMP) {
            pDev->DeviceFlags |= DFLAGS_HIDEN_DISK;
            if(pArray->nDisk > 1)
                pDev->DeviceFlags |= DFLAGS_ARRAY_DISK;

            if(i == 0) {
                pDev->DeviceFlags &= ~DFLAGS_HIDEN_DISK;
                pArray->ArrayNumBlock = 1<<pArray->BlockSizeShift;
                pDev->HidenLBA = 0;
            } else if (i < SPARE_DISK) {
            	if (pDev->HidenLBA==0) {
                	pDev->capacity -= (RECODR_LBA + 1);
                	pDev->HidenLBA = (RECODR_LBA + 1);
                }
            }
        }

        if(flag & SET_MIRROR_STAMP) {
            ArrayBlk.MirrorStamp  = MirrorStamp;
            ArrayBlk.ArrayType    = VD_RAID_01_2STRIPE;    
        }

        ArrayBlk.capacity = pArray->capacity; 

		
#ifdef _BIOS_
        ArrayBlk.RebuiltSector = 0x7FFFFFFF;
        ReadWrite(pDev, RECODR_LBA, IDE_COMMAND_WRITE ARG_ARRAY_BLK);
#endif        
    }
}

/***************************************************************************
 * Description:  Create Array
 ***************************************************************************/

int CreateArray(PVirtualDevice pArray, int flags)
{
    PVirtualDevice pMirror;
    PDevice        pDev=0, pSec;
    ULONG          capacity, tmp;
    UINT           i;
    LOC_ARRAY_BLK;

    if(pArray->arrayType == VD_SPAN) {
        capacity = 0;
        for(i = 0; i < pArray->nDisk; i++)
            capacity += (pArray->pDevice[i]->capacity - RECODR_LBA - 1);
        goto  clear_array;
    }

    capacity = 0x7FFFFFFF;

    for(i = 0; i < pArray->nDisk; i++) {
        pSec = pArray->pDevice[i];
        tmp = (pSec->pArray)? pSec->pArray->capacity : pSec->capacity;
        if(tmp < capacity) {
            capacity = tmp;
            pDev = pSec;
        }
    }
    
    if (!pDev) return 0;

    switch(pArray->arrayType) {
        case VD_RAID_1_MIRROR:
        case VD_RAID_01_2STRIPE:
            if(pDev != pArray->pDevice[0]) 
                return(MIRROR_SMALL_SIZE);

            pSec = pArray->pDevice[1];

            if((pMirror = pSec->pArray) != 0 && pDev->pArray) {
                pArray = pDev->pArray;
                tmp = GetStamp();
                pMirror->capacity = pArray->capacity;
                SetArray(pArray, SET_MIRROR_STAMP | SET_ORDER_OK, tmp);
                SetArray(pMirror, SET_MIRROR_STAMP, tmp);
                pArray->pDevice[MIRROR_DISK] = pMirror->pDevice[0];
                pMirror->pDevice[MIRROR_DISK] = pArray->pDevice[0];
                pArray->arrayType = VD_RAID_01_2STRIPE;
                pMirror->arrayType = VD_RAID01_MIRROR;
                pSec->DeviceFlags |= DFLAGS_HIDEN_DISK;
                pArray->Stamp = SET_ORDER_OK;
                return(RELEASE_TABLE);
            } else if(pMirror) {
                i = SET_STRIPE_STAMP;
single_stripe:
                pMirror->capacity = capacity;
                pMirror->pDevice[MIRROR_DISK] = pDev;
                SetArray(pMirror, i, 0);
                pMirror->arrayType = VD_RAID_01_1STRIPE;
                pMirror->Stamp = i & SET_ORDER_OK;
                return(RELEASE_TABLE);
            } else if((pMirror = pDev->pArray) != 0) {
                pDev = pSec;
                i = SET_STRIPE_STAMP | SET_ORDER_OK;
                goto single_stripe;
            } else {
                pArray->nDisk = 1;
                pArray->capacity = capacity;
				pArray->arrayType = VD_RAID_1_MIRROR;
                pArray->pDevice[MIRROR_DISK] = pSec;
                pArray->pDevice[1] = 0;
                SetArray(pArray, SET_STRIPE_STAMP | SET_ORDER_OK, 0);
                pArray->arrayType = VD_RAID_1_MIRROR;
                pArray->Stamp = SET_ORDER_OK;
            }
            break;

        case VD_RAID_3:
        case VD_RAID_5:
            pArray->nDisk--;

        default:
            capacity -= (RECODR_LBA + 1);
            capacity &= ~((1 << pArray->BlockSizeShift) - 1);
            capacity = LongMul(capacity, pArray->nDisk);

            pArray->ArrayNumBlock = 1<<pArray->BlockSizeShift;
clear_array:
            if(flags)
                goto set_array;

            for(i = 0; i < MAX_MEMBERS; i++) {
                if((pDev = pArray->pDevice[i]) == 0)
                    continue;
                ZeroMemory((char *)&ArrayBlk, 512);
				
#ifdef _BIOS_
				// gmm 2001-4-28 DO NOT write this, win2k will has installation bug
				// write win2000 signature.
				//*(ULONG*)&((struct master_boot_record*)&ArrayBlk)->bootinst[440] = 0x5FDE642F;
//				((struct master_boot_record*)&ArrayBlk)->signature = 0xAA55;
                ReadWrite(pDev, 0, IDE_COMMAND_WRITE ARG_ARRAY_BLK);
#endif                
            }

set_array:
            pArray->capacity = capacity;

            SetArray(pArray, SET_STRIPE_STAMP, 0);
    }
    return(KEEP_TABLE);
}

/***************************************************************************
 * Description:  Remove a array
 ***************************************************************************/

void CreateSpare(PVirtualDevice pArray, PDevice pDev)
{

    pArray->pDevice[SPARE_DISK] = pDev;
#ifdef _BIOS_
	{
		LOC_ARRAY_BLK;	
		ReadWrite(pArray->pDevice[0], RECODR_LBA, IDE_COMMAND_READ ARG_ARRAY_BLK);
		ArrayBlk.DeviceNum = SPARE_DISK; 
		ReadWrite(pDev, RECODR_LBA, IDE_COMMAND_WRITE ARG_ARRAY_BLK);
	}
#endif    
    pDev->pArray = pArray;
    pDev->DeviceFlags |= DFLAGS_HIDEN_DISK;
    pDev->ArrayNum  = SPARE_DISK; 
}

/***************************************************************************
 * Description:  Remove a array
 ***************************************************************************/

void DeleteArray(PVirtualDevice pArray)
{
    int i, j;
    PDevice pTmp, pDev;

    LOC_ARRAY_BLK;
    
    pDev = pArray->pDevice[MIRROR_DISK];

    switch(pArray->arrayType) {
        case VD_RAID_01_1STRIPE:
            MaptoSingle((PVirtualDevice)pDev, REMOVE_DISK);
            i = 2;
            goto remove;

        case VD_RAID01_MIRROR:
        case VD_RAID_01_2STRIPE:
            for(i = 0; i < 2; i++, pArray = (pDev? pDev->pArray: NULL)) {
remove:
				if (!pArray) break;
                pArray->arrayType = VD_RAID_0_STRIPE;
                pArray->pDevice[MIRROR_DISK] = 0;
                for(j = 0; (UCHAR)j < SPARE_DISK; j++) 
                    if((pTmp = pArray->pDevice[j]) != 0)
                        pTmp->pArray = 0;
                if (pArray->nDisk)
					CreateArray(pArray, 1);
				else
					goto delete_default;
            }
            break;

        default:
delete_default:
#ifdef _BIOS_
            for(i = 0; i < SPARE_DISK; i++) {
                if((pDev = pArray->pDevice[i]) == 0)
                    continue;
                ReadWrite(pDev, 0, IDE_COMMAND_READ ARG_ARRAY_BLK);
                if(i == 0 && pArray->arrayType == VD_SPAN) {
                    partition *pPart = (partition *)((int)&ArrayBlk + 0x1be);
                    for(j = 0; j < 4; j++, pPart++) 
                        if(pPart->start_abs_sector + pPart->num_of_sector >=
                           pDev->capacity) 
                            ZeroMemory((char *)pPart, 0x10);

            	} else
                    ZeroMemory((char *)&ArrayBlk, 512);

				//*(ULONG*)&((struct master_boot_record*)&ArrayBlk)->bootinst[440] = 0x5FDE642F;
				//((struct master_boot_record*)&ArrayBlk)->signature = 0xAA55;
                ReadWrite(pDev, 0, IDE_COMMAND_WRITE ARG_ARRAY_BLK);
			}
#endif
        case VD_RAID_1_MIRROR:
  			   for(j=0; j<32; j++)
				    ArrayBlk.ArrayName[j] = 0;
        MaptoSingle(pArray, REMOVE_ARRAY);

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\port\scsi\miniport\hipoint\hpt3xx\winnt\atapi.h ===
/***************************************************************************
 * File:          atapi.h
 * Description:   Ata/Atapi Interface Defination
 * Author:        Dahai Huang
 * Dependence:    None
 * Reference:     AT Attachment Interface with Extensions (ATA-2)
 *                Revison 2K, Dec. 2, 1994
 *                ATA Packet Interface for CD-ROMs SFF-8020
 *                Revision 1.2 Feb. 24, 1994
 * Copyright (c)  2000 HighPoint Technologies, Inc. All rights reserved
 * History:       DH 5/10/2000 initial code
 *
 ***************************************************************************/


#ifndef _ATAPI_H_
#define _ATAPI_H_

#include <pshpack1.h>

/***************************************************************************
 *            IDE IO Register File
 ***************************************************************************/

/*
 * IDE IO Port definition
 */
typedef struct _IDE_REGISTERS_1 {
    USHORT Data;               /* RW: Data port                  */
    UCHAR BlockCount;			 /* RW: Sector count               */
    UCHAR BlockNumber;			 /* RW: Sector number & LBA 0-7    */
    UCHAR CylinderLow;			 /* RW: Cylinder low & LBA 8-15    */
    UCHAR CylinderHigh;			 /* RW: Cylinder hign & LBA 16-23  */
    UCHAR DriveSelect;			 /* RW: Drive/head & LBA 24-27     */
    UCHAR Command;				 /* RO: Status WR:Command          */
} IDE_REGISTERS_1, *PIDE_REGISTERS_1;


/*
 * IDE status definitions
 */
#define IDE_STATUS_ERROR             0x01 /* Error Occurred in Execution    */
#define IDE_STATUS_INDEX             0x02	/* is vendor specific             */
#define IDE_STATUS_CORRECTED_ERROR   0x04	/* Corrected Data                 */
#define IDE_STATUS_DRQ               0x08	/* Ready to transfer data         */
#define IDE_STATUS_DSC               0x10	/* not defined in ATA-2           */
#define IDE_STATUS_DWF               0x20	/* Device Fault has been detected */
#define IDE_STATUS_DRDY              0x40	/* Device Ready to accept command */
#define IDE_STATUS_IDLE              0x50	/* Device is OK                   */
#define IDE_STATUS_BUSY              0x80	/* Device Busy, must wait         */


#define IDE_ERROR_BAD_BLOCK          0x80 /* Reserved now                   */
#define IDE_ERROR_DATA_ERROR         0x40	/* Uncorreectable  Data Error     */
#define IDE_ERROR_MEDIA_CHANGE       0x20	/* Media Changed                  */
#define IDE_ERROR_ID_NOT_FOUND       0x10	/* ID Not Found                   */
#define IDE_ERROR_MEDIA_CHANGE_REQ   0x08	/* Media Change Requested         */
#define IDE_ERROR_COMMAND_ABORTED    0x04	/* Aborted Command                */
#define IDE_ERROR_TRACK0_NOT_FOUND   0x02	/* Track 0 Not Found              */
#define IDE_ERROR_ADDRESS_NOT_FOUND  0x01	/* Address Mark Not Found         */


#define LBA_MODE                     0x40

/*
 * IDE command definitions
 */

#define IDE_COMMAND_RECALIBRATE      0x10 /* Recalibrate                    */
#define IDE_COMMAND_READ             0x20	/* Read Sectors with retry        */
#define IDE_COMMAND_WRITE            0x30	/* Write Sectors with retry       */
#define IDE_COMMAND_VERIFY           0x40	/* Read Verify Sectors with Retry */
#define IDE_COMMAND_SEEK             0x70	/* Seek                           */
#define IDE_COMMAND_SET_DRIVE_PARAMETER   0x91 /* Initialize Device Parmeters */
#define IDE_COMMAND_GET_MEDIA_STATUS 0xDA
#define IDE_COMMAND_DOOR_LOCK        0xDE	/* Door Lock                      */
#define IDE_COMMAND_DOOR_UNLOCK      0xDF	/* Door Unlock 						 */
#define IDE_COMMAND_ENABLE_MEDIA_STATUS   0xEF /* Set Features              */
#define IDE_COMMAND_IDENTIFY         0xEC /* Identify Device                */
#define IDE_COMMAND_MEDIA_EJECT      0xED
#define IDE_COMMAND_SET_FEATURES     0xEF /* IDE set features command       */

#define IDE_COMMAND_FLUSH_CACHE      0xE7
#define IDE_COMMAND_STANDBY_IMMEDIATE 0xE0


#ifdef USE_MULTIPLE
#define IDE_COMMAND_READ_MULTIPLE    0xC4	/* Read Multiple                  */
#define IDE_COMMAND_WRITE_MULTIPLE   0xC5	/* Write Multiple                 */
#define IDE_COMMAND_SET_MULTIPLE     0xC6	/* Set Multiple Mode              */
#endif //USE_MULTIPLE

#ifdef USE_DMA
#define IDE_COMMAND_DMA_READ        0xc8  /* IDE DMA read command           */
#define IDE_COMMAND_DMA_WRITE       0xca  /* IDE DMA write command          */
#endif //USE_DMA

#ifdef SUPPORT_TCQ
#define IDE_COMMAND_READ_DMA_QUEUE   0xc7 /* IDE read DMA queue command     */
#define IDE_COMMAND_WRITE_DMA_QUEUE  0xcc /* IDE write DMA queue command	 */
#define IDE_COMMAND_SERVICE          0xA2 /* IDE service command command	 */
#define IDE_COMMAND_NOP              0x00 /* IDE NOP command 					 */
#define IDE_STATUS_SRV               0x10
#endif //SUPPORT_TCQ

/*
 * IDE_COMMAND_SET_FEATURES
 */
#define FT_USE_ULTRA        0x40    /* Set feature for Ultra DMA           */
#define FT_USE_MWDMA        0x20    /* Set feature for MW DMA					*/
#define FT_USE_SWDMA        0x10    /* Set feature for SW DMA					*/
#define FT_USE_PIO          0x8     /* Set feature for PIO						*/
#define FT_DISABLE_IORDY    0x10    /* Set feature for disabling IORDY		*/

/***************************************************************************
 *            IDE Control Register File 
 ***************************************************************************/

typedef struct _IDE_REGISTERS_2 {
    UCHAR AlternateStatus;     /* RW: device control port        */
} IDE_REGISTERS_2, *PIDE_REGISTERS_2;


/*
 * IDE drive control definitions
 */
#define IDE_DC_DISABLE_INTERRUPTS    0x02
#define IDE_DC_RESET_CONTROLLER      0x04
#define IDE_DC_REENABLE_CONTROLLER   0x00


/***************************************************************************
 *            ATAPI IO Register File  
 ***************************************************************************/

/*
 * ATAPI register definition
 */

typedef struct _ATAPI_REGISTERS_1 {
    USHORT Data;
    UCHAR InterruptReason;		 /* Atapi Phase Port               */
    UCHAR Unused1;
    UCHAR ByteCountLow;        /* Byte Count LSB                 */
    UCHAR ByteCountHigh;		 /* Byte Count MSB                 */
    UCHAR DriveSelect;
    UCHAR Command;
} ATAPI_REGISTERS_1, *PATAPI_REGISTERS_1;

/*
 *	Atapi Error Status
 */
#define IDE_ERROR_END_OF_MEDIA       IDE_ERROR_TRACK0_NOT_FOUND 
#define IDE_ERROR_ILLEGAL_LENGTH     IDE_ERROR_ADDRESS_NOT_FOUND

/*
 * ATAPI interrupt reasons
 */
#define ATAPI_IR_COD 0x01
#define ATAPI_IR_IO  0x02

/* sense key */
//#define NOERROR                0x00      /* No sense                       */
#define CORRECTED_DATA         0x01      /* Recovered Error                */
#define NOTREADYERROR          0x02      /* Not Ready Error                */
#define MEDIAERROR             0x03      /* Medium Error                   */
#define HARDWAREERROR          0x04      /* HardWare Error                 */
#define ILLEGALREQUSET         0x05      /* Illegal Request                */
#define UNITATTENTION          0x06      /* Unit Attention                 */
#define DATAPROTECT            0x07      /* Data Protect Error             */
#define BLANKCHECK             0x08      /* Blank Check                    */
#define VENDORSPECIFIC         0x09      /* Vendor Specific                */
#define COPYABROT              0x0a      /* Copy Aborted                   */
#define ABORETCOMMAND          0x0b      /* Aborted Command                */
#define EQUALCOMPARISON        0x0c      /* Equal Comparison satisfied     */
#define VOLUMOVERFLOW          0x0d      /* Volume Overflow                */
#define MISCOMPARE             0x0e      /* Miscompare                     */

/*
 * IDE command definitions ( for ATAPI )
 */

#define IDE_COMMAND_ATAPI_RESET      0x08 /* Atapi Software Reset command   */
#define IDE_COMMAND_ATAPI_PACKET     0xA0	/* Atapi Identify command         */
#define IDE_COMMAND_ATAPI_IDENTIFY   0xA1	/* Atapi Packet Command           */


/*
 * ATAPI command definitions
 */

#define ATAPI_MODE_SENSE   0x5A
#define ATAPI_MODE_SELECT  0x55
#define ATAPI_FORMAT_UNIT  0x24

#define MODE_DSP_WRITE_PROTECT  0x80

#ifndef _BIOS_
/*
 * ATAPI Command Descriptor Block
 */
typedef struct _MODE_SENSE_10 {
        UCHAR OperationCode;
        UCHAR Reserved1;
        UCHAR PageCode : 6;
        UCHAR Pc : 2;
        UCHAR Reserved2[4];
        UCHAR ParameterListLengthMsb;
        UCHAR ParameterListLengthLsb;
        UCHAR Reserved3[3];
} MODE_SENSE_10, *PMODE_SENSE_10;

typedef struct _MODE_SELECT_10 {
        UCHAR OperationCode;
        UCHAR Reserved1 : 4;
        UCHAR PFBit : 1;
        UCHAR Reserved2 : 3;
        UCHAR Reserved3[5];
        UCHAR ParameterListLengthMsb;
        UCHAR ParameterListLengthLsb;
        UCHAR Reserved4[3];
} MODE_SELECT_10, *PMODE_SELECT_10;

typedef struct _MODE_PARAMETER_HEADER_10 {
    UCHAR ModeDataLengthMsb;
    UCHAR ModeDataLengthLsb;
    UCHAR MediumType;
    UCHAR Reserved[5];
}MODE_PARAMETER_HEADER_10, *PMODE_PARAMETER_HEADER_10;

#endif //_BIOS_


/***************************************************************************
 *            ATAPI IO Register File  
 ***************************************************************************/


typedef struct _ATAPI_REGISTERS_2 {
    UCHAR AlternateStatus;
} ATAPI_REGISTERS_2, *PATAPI_REGISTERS_2;


/***************************************************************************
 *            ATAPI IO Register File  
 ***************************************************************************/

/*
 * IDENTIFY data
 */
typedef struct _IDENTIFY_DATA {
    USHORT GeneralConfiguration;            // 00 00
    USHORT NumberOfCylinders;               // 02  1
    USHORT Reserved1;                       // 04  2
    USHORT NumberOfHeads;                   // 06  3
    USHORT UnformattedBytesPerTrack;        // 08  4
    USHORT UnformattedBytesPerSector;       // 0A  5
    USHORT SectorsPerTrack;                 // 0C  6
    USHORT VendorUnique1[3];                // 0E  7-9
    USHORT SerialNumber[10];                // 14  10-19
    USHORT BufferType;                      // 28  20
    USHORT BufferSectorSize;                // 2A  21
    USHORT NumberOfEccBytes;                // 2C  22
    USHORT FirmwareRevision[4];             // 2E  23-26
    USHORT ModelNumber[20];                 // 36  27-46
    UCHAR  MaximumBlockTransfer;            // 5E  47
    UCHAR  VendorUnique2;                   // 5F
    USHORT DoubleWordIo;                    // 60  48
    USHORT Capabilities;                    // 62  49
    USHORT Reserved2;                       // 64  50
    UCHAR  VendorUnique3;                   // 66  51
    UCHAR  PioCycleTimingMode;              // 67
    UCHAR  VendorUnique4;                   // 68  52
    UCHAR  DmaCycleTimingMode;              // 69
    USHORT TranslationFieldsValid;          // 6A  53
    USHORT NumberOfCurrentCylinders;        // 6C  54
    USHORT NumberOfCurrentHeads;            // 6E  55
    USHORT CurrentSectorsPerTrack;          // 70  56
    ULONG  CurrentSectorCapacity;           // 72  57-58
    USHORT CurrentMultiSectorSetting;       // 76  59
    ULONG  UserAddressableSectors;          // 78  60-61
    USHORT SingleWordDMASupport : 8;        // 7C  62
    USHORT SingleWordDMAActive : 8;              // 7D
    USHORT MultiWordDMASupport : 8;         // 7E  63
    USHORT MultiWordDMAActive : 8;                 // 7F
    UCHAR  AdvancedPIOModes;                // 80  64
    UCHAR  Reserved4;                              // 81
    USHORT MinimumMWXferCycleTime;          // 82  65
    USHORT RecommendedMWXferCycleTime;      // 84  66
    USHORT MinimumPIOCycleTime;             // 86  67
    USHORT MinimumPIOCycleTimeIORDY;        // 88  68
    USHORT Reserved5[2];                    // 8A  69-70
    USHORT ReleaseTimeOverlapped;           // 8E  71
    USHORT ReleaseTimeServiceCommand;       // 90  72
    USHORT MajorRevision;                   // 92  73
    USHORT MinorRevision;                   // 94  74
    USHORT MaxQueueDepth;                   // 96  75
    USHORT Reserved6[10];                   // 98  76-85
    USHORT CommandSupport;                  //     86
    USHORT CommandEnable;                   //     87
    USHORT UtralDmaMode;                    /*     88 */
    USHORT Reserved7[11];                   //     89-99
    ULONG  Lba48BitLow;						//     101-100
    ULONG  Lba48BitHigh;					//     103-102
    USHORT Reserved8[23];                   //     104-126
    USHORT SpecialFunctionsEnabled;         //     127
    USHORT Reserved9[128];                  //     128-255

} IDENTIFY_DATA, *PIDENTIFY_DATA;

#ifdef SUPPORT_48BIT_LBA
#define IDE_COMMAND_READ_DMA_EXT       0x25
#define IDE_COMMAND_READ_QUEUE_EXT		0x26
#define IDE_COMMAND_READ_MULTIPLE_EXT	0x29
#define IDE_COMMAND_READ_MAX_ADDR		0x27
#define IDE_COMMAND_READ_EXT				0x24
#define IDE_COMMAND_VERIFY_EXT			0x42
#define IDE_COMMAND_SET_MULTIPLE_EXT	0x37
#define IDE_COMMAND_WRITE_DMA_EXT		0x35
#define IDE_COMMAND_WRITE_QUEUE_EXT		0x36
#define IDE_COMMAND_WRITE_EXT				0x34
#define IDE_COMMAND_WRITE_MULTIPLE_EXT	0x39
#endif // SUPPORT_48BIT_LBA

//
// Identify data without the Reserved4.
//
typedef struct _IDENTIFY_DATA2 {
    USHORT GeneralConfiguration;            // 00 00
    USHORT NumberOfCylinders;               // 02  1
    USHORT Reserved1;                       // 04  2
    USHORT NumberOfHeads;                   // 06  3
    USHORT UnformattedBytesPerTrack;        // 08  4
    USHORT UnformattedBytesPerSector;       // 0A  5
    USHORT SectorsPerTrack;                 // 0C  6
    USHORT VendorUnique1[3];                // 0E  7-9
    USHORT SerialNumber[10];                // 14  10-19
    USHORT BufferType;                      // 28  20
    USHORT BufferSectorSize;                // 2A  21
    USHORT NumberOfEccBytes;                // 2C  22
    USHORT FirmwareRevision[4];             // 2E  23-26
    USHORT ModelNumber[20];                 // 36  27-46
    UCHAR  MaximumBlockTransfer;            // 5E  47
    UCHAR  VendorUnique2;                   // 5F
    USHORT DoubleWordIo;                    // 60  48
    USHORT Capabilities;                    // 62  49
    USHORT Reserved2;                       // 64  50
    UCHAR  VendorUnique3;                   // 66  51
    UCHAR  PioCycleTimingMode;              // 67
    UCHAR  VendorUnique4;                   // 68  52
    UCHAR  DmaCycleTimingMode;              // 69
    USHORT TranslationFieldsValid:1;        // 6A  53
    USHORT Reserved3:15;
    USHORT NumberOfCurrentCylinders;        // 6C  54
    USHORT NumberOfCurrentHeads;            // 6E  55
    USHORT CurrentSectorsPerTrack;          // 70  56
    ULONG  CurrentSectorCapacity;           // 72  57-58
    USHORT CurrentMultiSectorSetting;       //     59
    ULONG  UserAddressableSectors;          //     60-61
    USHORT SingleWordDMASupport : 8;        //     62
    USHORT SingleWordDMAActive : 8;
    USHORT MultiWordDMASupport : 8;         //     63
    USHORT MultiWordDMAActive : 8;
    USHORT AdvancedPIOModes : 8;            //     64
    USHORT Reserved4 : 8;
    USHORT MinimumMWXferCycleTime;          //     65
    USHORT RecommendedMWXferCycleTime;      //     66
    USHORT MinimumPIOCycleTime;             //     67
    USHORT MinimumPIOCycleTimeIORDY;        //     68
    USHORT Reserved5[2];                    //     69-70
    USHORT ReleaseTimeOverlapped;           //     71
    USHORT ReleaseTimeServiceCommand;       //     72
    USHORT MajorRevision;                   //     73
    USHORT MinorRevision;                   //     74
//    USHORT Reserved6[14];                   //     75-88
} IDENTIFY_DATA2, *PIDENTIFY_DATA2;

#define IDENTIFY_DATA_SIZE sizeof(IDENTIFY_DATA2)

//
// IDENTIFY DMA timing cycle modes.
//

#define IDENTIFY_DMA_CYCLES_MODE_0 0x00
#define IDENTIFY_DMA_CYCLES_MODE_1 0x01
#define IDENTIFY_DMA_CYCLES_MODE_2 0x02

// Best PIO Mode definitions
#define PI_PIO_0    0x00
#define PI_PIO_1    0x01
#define PI_PIO_2    0x02
#define PI_PIO_3    0x03
#define PI_PIO_4    0x04
#define PI_PIO_5    0x05

#define    WDC_MW1_FIX_FLAG_OFFSET        129            
#define WDC_MW1_FIX_FLAG_VALUE        0x00005555  


#include <poppack.h>
#endif //_ATAPI_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\port\scsi\miniport\hipoint\hpt3xx\winnt\ata.c ===
/***************************************************************************
 * File:          ata.c
 * Copyright (c)  2000 HighPoint Technologies, Inc. All rights reserved
 * History:
 *	3/21/2001	gmm		reduce to PIO mode if interrupt lost for several times.
 *	3/22/2001	gmm		Fix "LDM configuration error" when using dynamic disk under win2k
 ***************************************************************************/

/* EMPTY, move to other files */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\port\scsi\miniport\hipoint\hpt3xx\winnt\buffer.c ===
#include "global.h"

#ifdef WIN95
#include "blockdev.h"
#endif									// WIN95

#define PAGEMAPGLOBAL       0x40000000
#pragma intrinsic(memcpy)

#ifdef SUPPORT_INTERNAL_BUFFER

SCAT_GATH ext_buf_sg[MAX_SG_DESCRIPTORS];
PUCHAR     ext_buf_start = 0;
PUCHAR __cdecl LOCK__HeapAllocate(int, int);
ULONG  __cdecl LOCK__LinPageLock(int, int, int);
ULONG ScsiPortDDB = 0;
ULONG __stdcall LOCK_Get_DDB (ULONG DeviceID, PCHAR pName) ;

void Create_Internal_Buffer(PHW_DEVICE_EXTENSION HwDeviceExtension)
{
    PUCHAR  dataPointer;
    ULONG   bytesLeft   = 1024 * 64;
    ULONG   physicalAddress[MAX_SG_DESCRIPTORS];
    ULONG   addressLength[MAX_SG_DESCRIPTORS];
    ULONG   addressCount = 0;
    ULONG   sgEnteries = 0;
    PSCAT_GATH psg = (PSCAT_GATH)ext_buf_sg;
    ULONG   length;
    ULONG   i;

	 if(ext_buf_start || (ext_buf_start = 
        LOCK__HeapAllocate(4096 * 17, 0)) == 0) // allocate 64KBytes
		  return;

	 if(ScsiPortDDB == 0) {
       ScsiPortDDB = LOCK_Get_DDB(0, "SCSIPORT");
       if(ScsiPortDDB == 0)
             return;
       ScsiPortDDB += 12;
    }

	 i = ((ULONG)ext_buf_start + 4096)>> 12;
	 i = LOCK__LinPageLock(i, 16, PAGEMAPGLOBAL); // lock 64KBytes
	 dataPointer =  ext_buf_start = (PUCHAR)i;

    do {
        physicalAddress[addressCount] =
            ScsiPortConvertPhysicalAddressToUlong(
            ScsiPortGetPhysicalAddress(HwDeviceExtension,
                    0,
                    dataPointer,
                    &length));

        if  (length > bytesLeft)
            length = bytesLeft;

        addressLength[addressCount] = length;

        dataPointer = (PUCHAR)dataPointer + length;
        bytesLeft  -= length;
        addressCount++;

    } while (bytesLeft);

    //
    // Create Scatter/Gather List
    //
    for (i = 0; i < addressCount; i++) {
        psg->SgAddress = physicalAddress[i];
        length = addressLength[i];

        while ((i+1 < addressCount) &&
               (psg->SgAddress+length == physicalAddress[i+1])) {
            i++;
            length += addressLength[i];
        }

        if ((psg->SgAddress & 0xFFFF0000) !=
            ((psg->SgAddress+length-1) & 0xFFFF0000)) {
            ULONG firstPart;

            firstPart = 0x10000 - (psg->SgAddress & 0xFFFF);
            psg->SgSize = (USHORT)firstPart;
            psg->SgFlag = 0;

            sgEnteries++;
            psg++;

            psg->SgAddress = (psg-1)->SgAddress + firstPart;
            length -= firstPart;
        } // skip 64K boundary

        psg->SgSize = (USHORT)length;
        psg->SgFlag = (i < addressCount-1) ? 0 : SG_FLAG_EOT;

        sgEnteries++;
        psg++;
    } 
}


void ScsiportMemcpySrb(PSCSI_REQUEST_BLOCK pSrb, PUCHAR pBuffer, BOOLEAN bToSrb)
{				
	IOP		*pIop = *(IOP**)(pSrb+1);
	int		nBytesLeft = pSrb->DataTransferLength;

	if(pIop->IOP_ior.IOR_flags & IORF_SCATTER_GATHER){

		_BlockDev_Scatter_Gather *pSgt;		
		int nBlockShift;
		pSgt = (_BlockDev_Scatter_Gather*)pIop->IOP_ior.IOR_buffer_ptr;
		nBlockShift = pIop->IOP_physical_dcb->DCB_apparent_blk_shift;

		while(nBytesLeft > 0){
			int	nBytesToCopy;								  
			nBytesToCopy = pSgt->BD_SG_Count << nBlockShift;
			nBytesLeft -= nBytesToCopy;
			if(nBytesLeft < 0){
				nBytesToCopy += nBytesLeft;
			}
			if(bToSrb){					// copy from buffer to SRB?
				memcpy(pSgt->BD_SG_Buffer_Ptr, pBuffer, nBytesToCopy); 
			}else{
				memcpy(pBuffer, pSgt->BD_SG_Buffer_Ptr, nBytesToCopy);
			}
			pSgt++;
			pBuffer += nBytesToCopy;
		}			   
	}else{
		if(bToSrb){					// copy from buffer to SRB?
			memcpy(pSrb->DataBuffer, pBuffer, nBytesLeft);
		}else{
			memcpy(pBuffer, pSrb->DataBuffer, nBytesLeft);
		}
	}				 
}

int Use_Internal_Buffer(
						IN PSCAT_GATH psg,
						IN PSCSI_REQUEST_BLOCK Srb
					   )
{
	PSCAT_GATH pExtSg =	ext_buf_sg;
	ULONG   bytesLeft   = Srb->DataTransferLength;

	if(btr(EXCLUDE_BUFFER) == 0)
		return (0);

	while(bytesLeft > 0) {
		*psg = *pExtSg;
		if(bytesLeft <= pExtSg->SgSize) {
			psg->SgSize = (USHORT)bytesLeft;
			psg->SgFlag = SG_FLAG_EOT;
			break;
		}
		psg->SgFlag = 0;
		
		bytesLeft -= pExtSg->SgSize;
		psg++;
		pExtSg++;
	}

	if(Srb->Cdb[0] == SCSIOP_WRITE) {
		ScsiportMemcpySrb(Srb, ext_buf_start, FALSE);
	}

	((PSrbExtension)(Srb->SrbExtension))->WorkingFlags |= SRB_WFLAGS_USE_INTERNAL_BUFFER;
	return(1);
}

void CopyTheBuffer(PSCSI_REQUEST_BLOCK Srb)
{
	if(Srb->Cdb[0] != SCSIOP_WRITE){
		ScsiportMemcpySrb(Srb, ext_buf_start, TRUE);
	}
	bts(EXCLUDE_BUFFER);
	((PSrbExtension)(Srb->SrbExtension))->WorkingFlags &= ~SRB_WFLAGS_USE_INTERNAL_BUFFER;
}

#endif //SUPPORT_INTERNAL_BUFFER
/*
 * Add by Robin
 */	 
#ifdef BUFFER_CHECK

#define BYTES_FOR_CHECK	256

#ifdef	WIN95
void CheckBuffer(PSCSI_REQUEST_BLOCK pSrb)
{							   
	PULONG plTmp;
	int nBlockShift;
	_BlockDev_Scatter_Gather *pSgt;
	char	tmpBuf[BUFFER_SIZE];

	IOP		*pIop = *(IOP**)(pSrb+1);
	int		nBytesLeft = pSrb->DataTransferLength;
	PUCHAR	pcTmp = pSrb->DataBuffer;	
	int		nBytesChecked = 0;

	if((pSrb->Cdb[0] != SCSIOP_READ)&&(pSrb->Cdb[0] != SCSIOP_WRITE)){
		return;
	}

	nBlockShift = pIop->IOP_physical_dcb->DCB_apparent_blk_shift;
	pSgt = (_BlockDev_Scatter_Gather*)pIop->IOP_ior.IOR_buffer_ptr;

	while(nBytesLeft > 0){
		if(pIop->IOP_ior.IOR_flags & IORF_SCATTER_GATHER){
			int	nBytesOfSgt;
			nBytesOfSgt = pSgt->BD_SG_Count << nBlockShift - nBytesChecked;
			if(nBytesOfSgt < sizeof(tmpBuf)){
				memcpy(tmpBuf, (pSgt->BD_SG_Buffer_Ptr+nBytesChecked), nBytesOfSgt);
				memcpy(&tmpBuf[nBytesOfSgt], (pSgt+1)->BD_SG_Buffer_Ptr, sizeof(tmpBuf)-nBytesOfSgt);
				pcTmp = tmpBuf;
			}else{
				pcTmp = (PUCHAR)(pSgt->BD_SG_Buffer_Ptr + nBytesChecked);
			}
			nBytesChecked += sizeof(tmpBuf);
			nBytesOfSgt -= nBytesChecked;
			if(nBytesOfSgt <= 0){
				pSgt++;		
				if(nBytesOfSgt == 0){
					nBytesChecked = 0;
				}else{
					nBytesChecked += nBytesOfSgt;
				}
			}
		}

		plTmp = (PULONG)pcTmp;
		if(((plTmp[0] == 0x03020100)||(plTmp[1] == 0x07060504))||
		   ((plTmp[0] == 0xFCFDFEFF)||(plTmp[1] == 0xF8F9FAFB))){
			if(*pcTmp != 0x1A){
				ScsiPortReadPortUchar((PUCHAR)0xcf0);
				_asm{
//					int 3;		   
				}
			}
		}
		nBytesLeft -= 0x100;
		pcTmp += 0x100;
	}
}			 
#else									// WIN95
void CheckBuffer(PSCSI_REQUEST_BLOCK pSrb)
{							   
	PULONG plTmp;
	int	i;

	int		nBytesLeft = pSrb->DataTransferLength;
	PUCHAR	pcTmp = pSrb->DataBuffer;	

	if((pSrb->Cdb[0] != SCSIOP_READ)&&(pSrb->Cdb[0] != SCSIOP_WRITE)){
		return;
	}

	while(nBytesLeft > 0){
		plTmp = (PULONG)pcTmp;
		if(((plTmp[0] == 0x03020100)||(plTmp[1] == 0x07060504))||
		   ((plTmp[0] == 0xFCFDFEFF)||(plTmp[1] == 0xF8F9FAFB))){
			if(*pcTmp != 0x1A){
				for(i = 0; i < BYTES_FOR_CHECK-1; i ++){
					int iTmp;
					iTmp = pcTmp[i] - pcTmp[i+1];

					if((iTmp != 1)&&(iTmp != -1)){
						if((i != 0x1B)&&(i!=0x1A)){
							ScsiPortReadPortUchar((PUCHAR)0xcf0);
						}
					}	
				}
			}
		}
		nBytesLeft -= BYTES_FOR_CHECK;
		pcTmp += BYTES_FOR_CHECK;
	}
}			 
#endif									// WIN95
#endif									// BUFFER_CHECK
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\port\scsi\miniport\hipoint\hpt3xx\winnt\atapi.c ===
#include "global.h"

#ifdef SUPPORT_ATAPI

/******************************************************************
 *  
 *******************************************************************/

void AtapiCommandPhase(PDevice pDevice DECL_SRB)
{
    PChannel pChan = pDevice->pChannel;
    PUCHAR   BMI = pChan->BMI;

    RepOUTS(pChan->BaseIoAddress1, (ADDRESS)Srb->Cdb, 6);
    if((pDevice->DeviceFlags & DFLAGS_REQUEST_DMA) != 0) {
    	SetSgPhysicalAddr(pChan);
        OutDWord((PULONG)(BMI + ((pDevice->UnitId & 0x10)>>2)
            + 0x60), pChan->Setting[pDevice->DeviceModeSetting]);
        OutPort(BMI, (UCHAR)((Srb->SrbFlags & SRB_FLAGS_DATA_IN)?
            BMI_CMD_STARTREAD : BMI_CMD_STARTWRITE));
        pDevice->DeviceFlags |= DFLAGS_DMAING;
        pDevice->DeviceFlags &= ~DFLAGS_REQUEST_DMA;
    }
} 


/******************************************************************
 *  
 *******************************************************************/

void AtapiInterrupt(PDevice pDevice)
{
    PChannel         pChan = pDevice->pChannel;
    PIDE_REGISTERS_1 IoPort = pChan->BaseIoAddress1;
    PIDE_REGISTERS_2 ControlPort = pChan->BaseIoAddress2;
    UINT   i;
    UCHAR  Reason;
	 LOC_SRB

    Reason = GetInterruptReason(IoPort) & 3;
    if(Reason & 1) 
        AtapiCommandPhase(pDevice ARG_SRB);
    else {
        i = (UINT)(GetByteLow(IoPort) | (GetByteHigh(IoPort) << 8));
        i >>= 1;
        if(Reason) // read
            OS_RepINS(IoPort, (ADDRESS)pChan->BufferPtr, i);
        else
            RepOUTS(IoPort, (ADDRESS)pChan->BufferPtr, i);
        pChan->BufferPtr += (i * 2);
        pChan->WordsLeft -=  i;
    } 
}


/******************************************************************
 *  
 *******************************************************************/

void StartAtapiCommand(PDevice pDevice DECL_SRB)
{
    PChannel         pChan = pDevice->pChannel;
    PIDE_REGISTERS_1 IoPort = pChan->BaseIoAddress1;
    PIDE_REGISTERS_2 ControlPort = pChan->BaseIoAddress2;
 
    pChan->BufferPtr = (ADDRESS)Srb->DataBuffer;
    pChan->WordsLeft = Srb->DataTransferLength / 2;
 

    SelectUnit(IoPort, pDevice->UnitId);
    if(WaitOnBusy(ControlPort) & IDE_STATUS_BUSY) {
         Srb->SrbStatus = SRB_STATUS_BUSY;
         return;
    }

    SetFeaturePort(IoPort, 
        (UCHAR)((pDevice->DeviceFlags & DFLAGS_REQUEST_DMA)? 1 : 0));

    SetCylinderLow(IoPort,0xFF);
    SetCylinderHigh(IoPort, 0xFF);
    IssueCommand(IoPort, 0xA0);

    pChan->pWorkDev = pDevice;
    pChan->CurrentSrb = Srb;

    if((pDevice->DeviceFlags & DFLAGS_INTR_DRQ) == 0) {
        WaitOnBusy(ControlPort);
        if(WaitForDrq(ControlPort) & IDE_STATUS_DRQ) 
            AtapiCommandPhase(pDevice ARG_SRB);
        else  {
            Srb->SrbStatus =  SRB_STATUS_ERROR;
				pChan->pWorkDev = 0;
				pChan->CurrentSrb = 0;
        }
    }
}


#endif //SUPPORT_ATAPI
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\port\scsi\miniport\hipoint\hpt3xx\winnt\device.c ===
/***************************************************************************
 * File:          device.c
 * Description:   Functions for IDE devices
 * Author:        Dahai Huang
 * Dependence:    global.h
 * Reference:     None
 *                
 * Copyright (c)  2000 HighPoint Technologies, Inc. All rights reserved
 * History:
 *		11/08/2000	HS.Zhang	Added this header
 *		01/20/2001	gmm			add retry in DeviceInterrupt
 *		03/12/2001	gmm			modified DeviceInterrupt() retry code
 *		03/15/2001  gmm			add retry in DeviceSelectMode to fix slave booting problem
 *
 ***************************************************************************/
#include "global.h"

/******************************************************************
 * Issue Identify Command
 *******************************************************************/

int IssueIdentify(PDevice pDev, UCHAR Cmd DECL_BUFFER)
{
    PChannel   pChan = pDev->pChannel;
    PIDE_REGISTERS_1  IoPort = pChan->BaseIoAddress1;
    PIDE_REGISTERS_2  ControlPort = pChan->BaseIoAddress2;
    int      i, retry=0;
	PULONG   SettingPort;
	ULONG    OldSettings;
	
    SettingPort = (PULONG)(pChan->BMI+ ((pDev->UnitId & 0x10)>> 2) + 0x60);
	OldSettings = InDWord(SettingPort);
	OutDWord(SettingPort, pChan->Setting[DEFAULT_TIMING]);

_retry_:
    SelectUnit(IoPort, pDev->UnitId);
    if(WaitOnBusy(ControlPort) & IDE_STATUS_BUSY)  {
		IdeHardReset(IoPort, ControlPort);
	}

	i=0;
	do {
    	SelectUnit(IoPort, pDev->UnitId);
    	StallExec(200);
    }
	while ((GetCurrentSelectedUnit(IoPort) != pDev->UnitId) && i++<100);
	// gmm 2001-3-19: NO: if(i>=100) return(FALSE);

    IssueCommand(IoPort, Cmd);

    for(i = 0; i < 5; i++)
        if(!(WaitOnBusy(ControlPort) & (IDE_STATUS_ERROR |IDE_STATUS_BUSY)))
            break;
    

    if (i < 5 && (WaitForDrq(ControlPort) & IDE_STATUS_DRQ)) {
         WaitOnBusy(ControlPort);
         GetBaseStatus(IoPort);
         OutPort(pChan->BMI + BMI_STS, BMI_STS_ERROR|BMI_STS_INTR);
         BIOS_IDENTIFY
         RepINS(IoPort, (ADDRESS)tmpBuffer, 256);
//			pDev->DeviceFlags = 0;
	      OutDWord(SettingPort, OldSettings);

         return(TRUE);
    }

	if (++retry < 4) goto _retry_;
    OutDWord(SettingPort, OldSettings);

    GetBaseStatus(IoPort);
    return(FALSE);
}

/******************************************************************
 * Select Device Mode
 *******************************************************************/


void DeviceSelectMode(PDevice pDev, UCHAR NewMode)
{
    PChannel   pChan = pDev->pChannel;
    PIDE_REGISTERS_1 IoPort = pChan->BaseIoAddress1;
    PIDE_REGISTERS_2 ControlPort = pChan->BaseIoAddress2;
	UCHAR      Feature;
	int        i=0;

	/*
	 * gmm 2001-3-15
	 *   Some disks connected as slave without master will not act correctly without retry.
	 */
_retry_:
	SelectUnit(IoPort, pDev->UnitId);
	StallExec(200);
	if ((GetCurrentSelectedUnit(IoPort) != pDev->UnitId) && i++<100) goto _retry_;
	//if(i>=100)   return;

#ifdef _BIOS_
	if(!no_reduce_mode && (pDev->DeviceFlags2 & DFLAGS_REDUCE_MODE))
		NewMode = 4;
#endif

    /* Set Feature */
    SetFeaturePort(IoPort, 3);
	if(NewMode < 5) {
        pDev->DeviceFlags &= ~(DFLAGS_DMA | DFLAGS_ULTRA);
		Feature = (UCHAR)(NewMode | FT_USE_PIO);
	} else if(NewMode < 8) {
        pDev->DeviceFlags |= DFLAGS_DMA;
		Feature = (UCHAR)((NewMode - 5)| FT_USE_MWDMA);
	} else {
        pDev->DeviceFlags |= DFLAGS_DMA | DFLAGS_ULTRA;
		Feature = (UCHAR)((NewMode - 8) | FT_USE_ULTRA);
    }

    SetBlockCount(IoPort, Feature);
	
	SetAtaCmd(pDev, IDE_COMMAND_SET_FEATURES);
	
	pDev->DeviceModeSetting = NewMode;
	OutDWord((PULONG)(pChan->BMI + ((pDev->UnitId & 0x10)>>2) + 
        0x60), pChan->Setting[(pDev->DeviceFlags & DFLAGS_ATAPI)? 
        pDev->bestPIO : NewMode]);
    
	//OutDWord(0xcf4, pChan->Setting[NewMode]);
}

/******************************************************************
 * Set Disk
 *******************************************************************/

void SetDevice(PDevice pDev)
{
    PChannel   pChan = pDev->pChannel;
    PIDE_REGISTERS_1 IoPort = pChan->BaseIoAddress1;
    PIDE_REGISTERS_2 ControlPort = pChan->BaseIoAddress2;
	int   i=0;
	 
_retry_:
	SelectUnit(IoPort, pDev->UnitId);
#if 1 // gmm 2001-3-19
    StallExec(200);
	if ((GetCurrentSelectedUnit(IoPort) != pDev->UnitId)&& i++<100)
        goto _retry_;
	if(i>=100) {
		/* set required members */
	    pDev->ReadCmd  = IDE_COMMAND_READ;
	    pDev->WriteCmd = IDE_COMMAND_WRITE;
	    pDev->MultiBlockSize= 256;
		return;
	}
#endif
    /* set parameter for disk */
    SelectUnit(IoPort, (UCHAR)(pDev->UnitId | (pDev->RealHeader-1)));
    SetBlockCount(IoPort,  (UCHAR)pDev->RealSector);
	 SetAtaCmd(pDev, IDE_COMMAND_SET_DRIVE_PARAMETER);

    /* recalibrate */
    SetAtaCmd(pDev, IDE_COMMAND_RECALIBRATE);

#ifdef USE_MULTIPLE
    if (pDev->MultiBlockSize  > 512) {
        /* Set to use multiple sector command */
        SetBlockCount(IoPort,  (UCHAR)(pDev->MultiBlockSize >> 8));
		SelectUnit(IoPort, pDev->UnitId);
        if (!(SetAtaCmd(pDev, IDE_COMMAND_SET_MULTIPLE) & (IDE_STATUS_BUSY | IDE_STATUS_ERROR))) {
            pDev->ReadCmd  = IDE_COMMAND_READ_MULTIPLE;
            pDev->WriteCmd = IDE_COMMAND_WRITE_MULTIPLE;
            pDev->DeviceFlags |= DFLAGS_MULTIPLE;
            return;
         }
    }
#endif //USE_MULTIPLE
    pDev->ReadCmd  = IDE_COMMAND_READ;
    pDev->WriteCmd = IDE_COMMAND_WRITE;
    pDev->MultiBlockSize= 256;
}

/******************************************************************
 * Reset Controller
 *******************************************************************/
	
void IdeResetController(PChannel pChan)
{
    LOC_IDENTIFY
	int i;
	PDevice pDev;
    PIDE_REGISTERS_1 IoPort = pChan->BaseIoAddress1;
    PIDE_REGISTERS_2 ControlPort = pChan->BaseIoAddress2;
	//PULONG    SettingPort;
    //ULONG     OldSettings, tmp;
    UCHAR intr_enabled;

	intr_enabled = !(InPort(pChan->BaseBMI+0x7A) & 0x10); // gmm 2001-4-9
	if (intr_enabled) DisableBoardInterrupt(pChan->BaseBMI);
	
    for(i = 0; i < 2; i++) {
        if((pDev = pChan->pDevice[i]) == 0)
			continue;
        if(pDev->DeviceFlags & DFLAGS_ATAPI) {
			GetStatus(ControlPort);
			AtapiSoftReset(IoPort, ControlPort, pDev->UnitId);
			if(GetStatus(ControlPort) == 0) 
				IssueIdentify(pDev, IDE_COMMAND_ATAPI_IDENTIFY ARG_IDENTIFY);
        } else {
#ifndef NOT_ISSUE_37
			Reset370IdeEngine(pChan, pDev->UnitId);
#endif // NOT_ISSUE_37

			// gmm 2001-3-20
			if (pDev->DeviceFlags2 & DFLAGS_DEVICE_DISABLED) continue;

			if(IdeHardReset(IoPort, ControlPort) == FALSE)
				continue;
			
			if (pDev->DeviceFlags & DFLAGS_DMAING) {
#ifdef _BIOS_
				if (++pDev->ResetCount > 0) {
					pDev->ResetCount = 0;
#else
				if ((++pDev->ResetCount & 3)==3) {
#endif
					pDev->IoSuccess = 0;
					if (pDev->DeviceModeSetting) pDev->DeviceModeSetting--;
				}
			}
			
			SetDevice(pDev);
			DeviceSelectMode(pDev, pDev->DeviceModeSetting);
		}
	}
	if (intr_enabled) EnableBoardInterrupt(pChan->BaseBMI);
}

/******************************************************************
 * PIO interrupt handler
 *******************************************************************/
BOOLEAN AtaPioInterrupt(PDevice pDevice)
{
    PVirtualDevice    pArray = pDevice->pArray;
    PChannel          pChan = pDevice->pChannel;
    PIDE_REGISTERS_1  IoPort = pChan->BaseIoAddress1;
    PSCAT_GATH        pSG;
    PUCHAR            BMI = pChan->BMI;
    UINT              wordCount, ThisWords, SgWords;
    LOC_SRB
    LOC_SRBEXT_PTR
 
    wordCount = MIN(pChan->WordsLeft, pDevice->MultiBlockSize);
    pChan->WordsLeft -= wordCount;

    if(((pDevice->DeviceFlags & DFLAGS_ARRAY_DISK) == 0)||
	   (pSrbExt->WorkingFlags & SRB_WFLAGS_IGNORE_ARRAY)) {
        if(Srb->SrbFlags & SRB_FLAGS_DATA_OUT) 
             RepOUTS(IoPort, (ADDRESS)pChan->BufferPtr, wordCount);
        else 
             RepINS(IoPort, (ADDRESS)pChan->BufferPtr, wordCount);
        pChan->BufferPtr += (wordCount * 2);
        goto end_io;
    }

    pSG = (PSCAT_GATH)pChan->BufferPtr;

    while(wordCount > 0) {
        if((SgWords	= pSG->SgSize) == 0)
           	SgWords = 0x8000;
		  else
				SgWords >>= 1;
        
        ThisWords = MIN(SgWords, wordCount);

        if(Srb->SrbFlags & SRB_FLAGS_DATA_OUT) 
             RepOUTS(IoPort, (ADDRESS)pSG->SgAddress, ThisWords);
        else 
             RepINS(IoPort, (ADDRESS)pSG->SgAddress, ThisWords);

        if((SgWords -= (USHORT)ThisWords) == 0) {
           wordCount -= ThisWords;
           pSG++;
       } else {
           pSG->SgAddress += (ThisWords * 2);
			  pSG->SgSize -= (ThisWords * 2);
           break;
        }
    }

    pChan->BufferPtr = (ADDRESS)pSG;

end_io:
#ifdef BUFFER_CHECK
	GetStatus(pChan->BaseIoAddress2);
#endif												 
	
	if(pChan->WordsLeft){
		pSrbExt->WaitInterrupt |= pDevice->ArrayMask;
	} else {
		if(Srb->SrbFlags & SRB_FLAGS_DATA_OUT)
			pSrbExt->WaitInterrupt |= pDevice->ArrayMask;

     	OutDWord((PULONG)(pChan->BMI + ((pDevice->UnitId & 0x10)>>2) + 0x60),
        pChan->Setting[pDevice->DeviceModeSetting]);
 	}
	
    return((BOOLEAN)(pChan->WordsLeft || 
       (Srb->SrbFlags & SRB_FLAGS_DATA_OUT)));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\port\scsi\miniport\hipoint\hpt3xx\winnt\device.h ===
/***************************************************************************
 * File:          device.h
 * Description:   Data structure for Device and IDE channel object
 * Author:        Dahai Huang
 * Dependence:    None
 * Reference:     None
 *                
 * Copyright (c)  2000 HighPoint Technologies, Inc. All rights reserved
 * History:       DH 5/10/2000 initial code
 *		11/07/2000	HS.Zhang	Added a member MiscControlAddr
 *		4/13/2000  gmm  Change type of "deviceFlags and DeviceFlags" from
 *					"UINT" to "ULONG"
 *
 ***************************************************************************/


#ifndef _DEVICE_H_
#define _DEVICE_H_

#include <pshpack1.h>
/***************************************************************************
 * Description:  Device Table
 ***************************************************************************/

typedef struct _Device {
    ULONG   DeviceFlags;       /* Device Flags, see below */
	ULONG	DeviceFlags2;	   /* Second Device Flags storage */

    UCHAR   UnitId;            /* Device ID: 0xA0 or 0x B0 */
    UCHAR   DeviceModeSetting; /* Current Data Transfer mode: 0-4 PIO 0-4 */
                               /* 5-7 MW DMA0-2, 8-13 UDMA0-5             */
    UCHAR   ReadCmd;           /* Read or Read Multiple */ 
    UCHAR   WriteCmd;          /* Write or Write Multiple */

    USHORT  MultiBlockSize;    /* Word count per interrupt */
    USHORT  RealHeadXsect;     /* Disk physical head */

    UCHAR   RealSector;        /* Disk physical sector per track */
    UCHAR   RealHeader;        /* Disk physical head */
    UCHAR   bestPIO;           /* Best PIO mode of this device */
    UCHAR   bestDMA;           /* Best MW DMA mode of this device */
    UCHAR   bestUDMA;          /* Best Ultra DMA mode of this device */
    UCHAR   Usable_Mode;       /* actual maximum data transfer mode */
    UCHAR   ArrayMask;         /* constant = (1 << ArrayNum) */
    UCHAR   ArrayNum;		   /* the sequence number in an array */

    ULONG   HidenLBA;          /* Hiden sectors for stripe disk */

    struct _Channel *pChannel; /* The channel this device attached */
    struct _VirtualDevice *pArray;/* the array this disk belong to */

	ULONG   RebuiltSector;
	UINT   IoCount; // times of device I/O
	UINT   ResetCount;
	UINT   IoSuccess;

#ifdef _BIOS_
	/* below 5 fields are used as struct Geomitry, DO NOT CHANGE! */
    ULONG   capacity;          /* The real capacity of this disk */
    USHORT  headerXsect_per_tck;/* = MaxSector * MaxHeader */
    USHORT  MaxCylinder;       /* Disk Maximum Logic cylinders */
    UCHAR   MaxSector;         /* Disk Maximum Logic sectors per track */
    UCHAR   MaxHeader;         /* Disk Maximum Logic head */
    
    USHORT  RealCylinder;      /* Disk Maximum physical cylinders */
    UCHAR   bios_num;          /* bios device letter: 0x80 = c: 0x81 = d: */
    UCHAR   Seq;               /* device sequence number when scanning device */
    UCHAR   LockNum;           /* How many lock commands have be received */
    UCHAR   BestModeSelect;    /* Best transfer mode of the disk */
    FDPT_Ext *pFdptExt;
	UCHAR far *real_lba9;
#else
    ULONG   capacity;          /* The real capacity of this disk */
    IDENTIFY_DATA2 IdentifyData;/* Identify Data of this device */
	USHORT  DiscsPresent;
    UCHAR   SmartCommand;      /* Last smart command */
    UCHAR   ReturningMediaStatus; /* Last Media status */
	ULONG	nLockedLbaStart;			/* the start LBA address of locked block */
	ULONG	nLockedLbaEnd;				/* the end LBA address of locked block */

	struct{	   
		ULONG	nLastError;				/* Last Error happend on this device */
		struct _Device	*pNextErrorDevice;		/* next device which has error */
		UCHAR	Cdb[16];
	}stErrorLog;

	UCHAR   real_lba9[512];  /* save lba 9'data here */
	
	#define MAX_DEVICE_QUEUE_LENGTH 32
	#define DEVICE_QUEUE_FULL(pDev) \
		((pDev->queue_last+1)%MAX_DEVICE_QUEUE_LENGTH==pDev->queue_first)
	#define DEVICE_QUEUE_LENGTH(pDev) \
		(pDev->queue_last>=pDev->queue_first? (pDev->queue_last-pDev->queue_first) : \
			MAX_DEVICE_QUEUE_LENGTH-(pDev->queue_first-pDev->queue_last))
	PSCSI_REQUEST_BLOCK wait_queue[MAX_DEVICE_QUEUE_LENGTH];
	USHORT queue_first;
	USHORT queue_last;

	PSCSI_REQUEST_BLOCK pWaitingSrbList; /* waiting for unlock */

#ifdef SUPPORT_TCQ
    UCHAR   MaxQueue;          /* the queue depth of the TCQ disk */
    UCHAR   CurrentQueued;	   /* how many commands are in disk queue */
    USHORT  reserved; 
    ULONG   TagIndex;          /* bit map for who is queued */
    PULONG  pTagTable;         /* point to the Tag list */
#endif
#endif
} Device, *PDevice;

/*First device flags declare*/
#define DFLAGS_LBA                  0x1    // Use LBA mode on drive
#define DFLAGS_DMA                  0x2    // Use DMA on the drive
#define DFLAGS_MULTIPLE             0x4    // Use Multi-Block commands
#define DFLAGS_ULTRA                0x8    // Support ultra DMA

#define DFLAGS_DMAING               0x10   // This Device is doing DMA 
#define DFLAGS_REQUEST_DMA          0x20   // This Device want to do DMA
#define DFLAGS_HIDEN_DISK           0x40   // This is a hiden disk in a array
#define DFLAGS_ARRAY_DISK           0x80   // This is member of an array

#define DFLAGS_ATAPI                0x100  // This is ATAPI device
#define DFLAGS_INTR_DRQ             0x4    // This ATAPI device need interrupt DRQ
#define DFLAGS_NEED_SWITCH          0x200  // This disk need fix HPT370 bug
#define DFLAGS_REMOVABLE_DRIVE      0x400  // ATA removable device (IDE ZIP)
#define DFLAGS_DEVICE_LOCKABLE      0x800  // This devices is lockable 

#define DFLAGS_CDROM_DEVICE         0x1000 // This is a CDROM device
#define DFLAGS_HARDDISK             0x2000 // This is a non-removable disk
#define DFLAGS_LS120                0x4000 // This is a LS-120 
#define DFLAGS_BOOT_SECTOR_PROTECT  0x8000 // Protect boot sector from write

#define DFLAGS_48BIT_LBA         	0x8000000

#ifndef _BIOS_
#define DFLAGS_FORCE_PIO            0x10000 // Force to do PIO 
#define DFLAGS_TAPE_RDP             0x20000 // Tape special commamds
#define DFLAGS_MEDIA_STATUS_ENABLED 0x40000 // This device receive 0xDA	command
#define DFLAGS_TAPE_DEVICE          0x80000 // TAPE device

#define DFLAGS_SET_CALL_BACK        0x100000 // in CallBack mode
#define DFLAGS_SORT_UP              0x200000 // Direction for sorting LBA
#define DFLAGS_ARRAY_WAIT_EXEC      0x400000 // Wait for executing Array command
#define DFLAGS_TCQ_WAIT_SERVICE     0x800000 // Wait TCQ service status

#define DFLAGS_WIN_SHUTDOWN			0x1000000
#define DFLAGS_WIN_FLUSH   			0x2000000
#define DFLAGS_HAS_LOCKED			0x4000000

#ifdef WIN95
#define DFLAGS_OPCODE_CONVERTED     0x10000000
#else
#define DFLAGS_CHANGER_INITED       0x10000000  // Indicates that the init path for changers has already been done.
#define DFLAGS_ATAPI_CHANGER        0x20000000  // Indicates atapi 2.5 changer present.
#define DFLAGS_SANYO_ATAPI_CHANGER  0x40000000  // Indicates multi-platter device, not conforming to the 2.5 spec.
#endif
#endif //_BIOS_

#define DFLAGS_SUPPORT_MSN			0x80000000 /* support media change notification */

/*Second device flags*/
#define DFLAGS_REDUCE_MODE	        0x00010000
#define DFLAGS_DEVICE_DISABLED	    0x00020000		// Indicates that the device disabled
#define DFLAGS_DEVICE_SWAPPED	    0x00040000		// A swapped mirror disk in 1+0 case
#define DFLAGS_BOOTABLE_DEVICE		0x00080000		// bootable disk
#define DFLAGS_BOOT_MARK			0x00100000  // has boot mark set in ArrayBlk
#define DFLAGS_WITH_601             0x00200000  // in HPT601 box
#define DFLAGS_NEW_ADDED			0x40000000  // newly added disk
/* used in FinaArrayCheck() */
#define DFLAGS_REMAINED_MEMBER		0x80000000

/*
 * Added by HS.Zhang
 * this structure is used to save transfer mode settings
 */
typedef union _st_XFER_TYPE_SETTING{
	struct{
		UCHAR	XferMode : 4;		// the MAX usable mode in this transfer type
		UCHAR	XferType : 4;		// the transfer type
	};
	UCHAR	Mode;
}ST_XFER_TYPE_SETTING;
						
#define XFER_TYPE_PIO		0x0			// transfer type is PIO
#define XFER_TYPE_MDMA		0x1			// transfer type is Multiwords DMA
#define XFER_TYPE_UDMA		0x2			// transfer type is Ultra DMA
#define	XFER_TYPE_AUTO		0xF			// auto detect tranfer mode

/***************************************************************************
 * Description: Bad Device 
 ***************************************************************************/

typedef struct _BadModeList {
    UCHAR      UltraDMAMode;	 /* 0xFF not support, others useable mode */
    UCHAR      DMAMode;			 /* 0xFF not support, others useable mode */
    UCHAR      PIOMode;			 /* 0xFF not support, others useable mode */
    UCHAR      length;			 /* length of identify string */
    UCHAR     *name;			 /* point to identify string */
} BadModeList, *PBadModeList;

#define HPT366_ONLY   0x20		 /* only modify if it is the HPT366 */
#define HPT368_ONLY   0x40		 /* only modify if it is the HPT368 */
#define HPT370_ONLY   0x80		 /* only modify if it is the HPT370 */

/***************************************************************************
 * Description: Bus Table
 ***************************************************************************/

typedef struct _Channel {
    PIDE_REGISTERS_1 BaseIoAddress1;  // IDE Base Port Address
    PIDE_REGISTERS_2 BaseIoAddress2;  // IDE Control Port Address
    PUCHAR           BMI;             // IDE DMA extended Port Addresss
    PUCHAR           BaseBMI;         // HPT370 IO base PCI config address
	
	PUCHAR			 NextChannelBMI;  // BMI address of another channel
	PUCHAR			 MiscControlAddr; // Misc. Control register base for this channel

    UCHAR            InterruptLevel;  // IRQ number for the channel  
    UCHAR            ChannelFlags;    // Channel Flags, see below
    UCHAR            RetryTimes;      // Don't insert any item at above
    UCHAR            pad[3];
    USHORT           nSector;         // Current Logic Disk command: N sector

    ULONG            Lba;             // Current Logic Disk command: LBA

    ADDRESS          BufferPtr;       // Data buffer that OS pass to
    UINT             WordsLeft;       // word length of data transfer

    UINT             exclude_index;   // exclusive resource allocate mark

    PSCSI_REQUEST_BLOCK CurrentSrb;   // current SRB
    PDevice          pWorkDev;        // current Working device

    PCI1_CFG_ADDR    pci1_cfg;        // PCI Address for the channel
    ULONG            *Setting;        // point to HPT3xx Timing table

    PDevice          pDevice[2];      // point to the exsiting devices */

    ULONG            SgPhysicalAddr;  // physcial address of SG table
    PSCAT_GATH       pSgTable;        // point to SG table of this channel

#ifndef _BIOS_
    struct _HW_DEVICE_EXTENSION *HwDeviceExtension;
    VOID   (* CallBack)(struct _Channel *);
    Device           Devices[2];
#ifdef WIN95
    UCHAR            OrgCdb[MAXIMUM_CDB_SIZE];
#else
    PSCSI_REQUEST_BLOCK OriginalSrb;
    SCSI_REQUEST_BLOCK InternalSrb;
    MECHANICAL_STATUS_INFORMATION_HEADER MechStatusData;
    SENSE_DATA MechStatusSense;
    ULONG MechStatusRetryCount;
#endif //WIN95
#endif //_BIOS_

} Channel, *PChannel;

/* ChannelFlags */
#define IS_HPT_370      1      /* This is a HPT370 Adapter */
#define IS_HPT_372      2      /* This is a HPT372 Adapter */
#define IS_HPT_372A     4      /* This is a HPT372A Adapter */
#define IS_DPLL_MODE    0x8    /* HPT370 is using DPLL */
#define IS_80PIN_CABLE  0x30   /* 80 pin cable attached */
#define IS_CABLE_CHECK  0x40   /* 80 pin cable attached */
#define PF_ACPI_INTR    0x80   /* hptpwr.c is waiting a interrupt */

#include <poppack.h>
#endif //_DEVICE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\port\scsi\miniport\hipoint\hpt3xx\winnt\devmgr.h ===
#ifndef DeviceManagement_H_
#define DeviceManagement_H_

#include "RaidCtl.h"

#define MAX_DISKS           8

int RAIDController_GetNum();
BOOL RAIDController_GetInfo( int iController, St_StorageControllerInfo* pInfo );

HDISK Device_GetHandle( PDevice pDevice );

BOOL Device_GetSibling( HDISK hNode, HDISK * pSilbingNode );
BOOL Device_GetChild( HDISK hParentNode, HDISK * pChildNode );
BOOL Device_GetInfo( HDISK hDeviceNode, St_DiskStatus * pInfo );

HDISK Device_CreateMirror( HDISK * pDisks, int nDisks );
HDISK Device_CreateStriping( HDISK *pDisks, int nDisks, int nStripSizeShift );
HDISK Device_CreateSpan( HDISK * pDisks, int nDisks );
BOOL Device_Remove( HDISK hDisk );
BOOL Device_AddSpare( HDISK hMirror, HDISK hDisk );
BOOL Device_DelSpare( HDISK hDisk );
BOOL Device_AddMirrorDisk( HDISK hMirror, HDISK hDisk );
BOOL Device_AddPhysicalDisk( IN PDevice pDev );

BOOL Device_BeginRebuildingMirror( HDISK hMirror );
BOOL Device_AbortMirrorBuilding( HDISK hMirror );
BOOL Device_ValidateMirror( HDISK hMirror );

void Device_SetArrayName(HDISK hDisk, char* arrayname);
BOOL Device_RescanAll();

BOOL Device_IsRemoved(PDevice pDev);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\port\scsi\miniport\hipoint\hpt3xx\winnt\devtree.c ===
/***************************************************************************
 * File:          devtree.c
 * Description:   ioctl support routines
 * Copyright (c)  2000 HighPoint Technologies, Inc. All rights reserved
 * History:   
 *		3/1/2001	gmm		add this header
 *		3/4/2001	gmm		Device_Remove, delete RAID0+1 to single disks
 *		3/12/2001	gmm		add DFLAGS_BOOTABLE_DEVICE, RAID_FLAGS_NEWLY_CREATED
 *		3/27/2001	gmm		put failed RAID1 members inside the array node.
 *
 ***************************************************************************/
#include "global.h"
#include "devmgr.h"

extern BOOL UnregisterLogicalDevice(PVOID pld);
extern int num_adapters;
extern PHW_DEVICE_EXTENSION hpt_adapters[];

/*
 * Array id: 32bit
 *  31   27          23      15      7          0
 *  -----+-----------+-------+-------+------------
 *  0x80 | child_seq |   0   | flags | array_seq 
 *  -----+-----------+-------+-------+------------
 */
#define IS_ARRAY_ID(hDisk)				(((DWORD)(hDisk) & 0xF0000000) == 0x80000000)
static UCHAR GET_ARRAY_NUM(PVirtualDevice pArray)
{
	int ha, i;
	for (ha=0; ha<num_adapters; ha++)
		for (i=0; i<MAX_DEVICES_PER_CHIP; i++)
			if (pArray==&hpt_adapters[ha]->_VirtualDevices[i])
				return (ha<<4)|i;
	return 0xFF;
}
#define MAKE_ARRAY_ID(pArray)			(HDISK)(0x80000000|GET_ARRAY_NUM(pArray))
#define MAKE_COMPOSED_ARRAY_ID(pArray)	(HDISK)(0x80000100|GET_ARRAY_NUM(pArray))
#define IS_COMPOSED_ARRAY(hDisk)		((DWORD)(hDisk) & 0x0100)
#define MAKE_CHILD_ARRAY_ID(pArray, iChild) \
										(HDISK)((DWORD)MAKE_ARRAY_ID(pArray) | ((iChild) & 0xF)<<24)
static PVirtualDevice ARRAY_FROM_ID(hDisk)
{
	int ha = ((DWORD)(hDisk) & 0xF0) >> 4;
	int i = (DWORD)(hDisk) & 0xF;
	if (ha>=num_adapters || i>=MAX_DEVICES_PER_CHIP) return 0;
	return &hpt_adapters[ha]->_VirtualDevices[i];
}
#define CHILDNUM_FROM_ID(hDisk)			(((DWORD)(hDisk))>>24 & 0xF)

/*
 * Device id: 32bit
 *  31    23            15        7     0
 *  ------+-------------+---------+------
 *   0xC0 | adapter_num | bus_num | id
 *  ------+-------------+---------+------
 */
#define IS_DEVICE_ID(hDisk) (((DWORD)(hDisk) & 0xF0000000) == 0xC0000000)
static HDISK MAKE_DEVICE_ID(PDevice pDev)
{
	int iAdapter, iChan, iDev;
	for (iAdapter=0; iAdapter<num_adapters; iAdapter++)
		for (iChan=0; iChan<2; iChan++)
			for (iDev=0; iDev<2; iDev++)
				if (hpt_adapters[iAdapter]->IDEChannel[iChan].pDevice[iDev] == pDev)
					return (HDISK)(0xC0000000 | iAdapter<<16 | iChan<<8 | iDev);
	return INVALID_HANDLE_VALUE;
}
static PDevice DEVICE_FROM_ID(HDISK hDisk)
{
	if (hDisk!=INVALID_HANDLE_VALUE)
		return 
		hpt_adapters[((DWORD)(hDisk) & 0x00FF0000)>>16]->
		IDEChannel[((DWORD)(hDisk) & 0xFF00)>>8].pDevice[(DWORD)(hDisk) & 0xFF];
	else
		return NULL;
}
#define ADAPTER_FROM_ID(hDisk) (((DWORD)(hDisk) & 0x00FF0000)>>16)
#define BUS_FROM_ID(hDisk) (((DWORD)(hDisk) & 0xFF00)>>8)
#define DEVID_FROM_ID(hDisk) ((DWORD)(hDisk) & 0xFF)

static const St_DiskPhysicalId VIRTUAL_DISK_ID = { -1, -1, -1, -1 };

static void GetPhysicalId(PDevice pDev, St_DiskPhysicalId * pId )
{
	int iAdapter, iChan, iDev;
	for (iAdapter=0; iAdapter<num_adapters; iAdapter++)
		for (iChan=0; iChan<2; iChan++)
			for (iDev=0; iDev<2; iDev++)
				if (hpt_adapters[iAdapter]->IDEChannel[iChan].pDevice[iDev] == pDev) {
					pId->nControllerId = iAdapter;
					pId->nPathId = iChan;
					pId->iTargetId = iDev;
					pId->iLunId = 0;
					return;
				}
	*pId = VIRTUAL_DISK_ID;
}

HDISK Device_GetHandle( PDevice pDevice )
{
    return MAKE_DEVICE_ID(pDevice);
}

static void SwapCopy(LPSTR sz, const char vec[], unsigned n)
{
    unsigned i;
    for(i = 0; i < n/( sizeof(unsigned short)/sizeof(char) ); ) {
        sz[i] = vec[i+1];
        sz[i+1] = vec[i];
        i ++; i ++;
    }
}

DWORD GetRAID0Capacity(PVirtualDevice pArray)
{
	int i, n=0;
	DWORD cap=0x7FFFFFFF, tmp;
	PDevice pDev;
	for (i=0; i<SPARE_DISK; i++) {
		if (pDev = pArray->pDevice[i]) {
			n++;
			tmp = i? pDev->capacity : (pDev->capacity - RECODR_LBA -1);
			if (cap > tmp) cap = tmp;
		}
	}
	return (cap & ~((1<<pArray->BlockSizeShift)-1)) * n;
}

BOOL Device_GetInfo( HDISK hDeviceNode, St_DiskStatus * pInfo )
{
	int iName=0;	//added by wx 12/26/00

    memset(pInfo, 0, sizeof(*pInfo));
	pInfo->hParentArray = INVALID_HANDLE_VALUE;

	if (IS_DEVICE_ID(hDeviceNode)) {
		PDevice pDev = DEVICE_FROM_ID(hDeviceNode);
		int nDeviceMode;

		if (!pDev) return FALSE;

        pInfo->iWorkingStatus = (pDev->DeviceFlags2 & DFLAGS_DEVICE_DISABLED)? 
			enDiskStatus_Disabled : enDiskStatus_Working;
        pInfo->stLastError.nErrorNumber = pDev->stErrorLog.nLastError;
        memcpy(pInfo->stLastError.aryCdb, pDev->stErrorLog.Cdb, 16);
		GetPhysicalId(pDev, &pInfo->PhysicalId);

		nDeviceMode = pDev->DeviceModeSetting;
            
		pInfo->bestPIO = pDev->bestPIO;
		pInfo->bestDMA = pDev->bestDMA;
		pInfo->bestUDMA = pDev->bestUDMA;

        if( pDev->DeviceFlags & DFLAGS_HARDDISK )
            pInfo->iDiskType = enDA_Physical;
        else if(pDev->DeviceFlags & DFLAGS_CDROM_DEVICE)
            pInfo->iDiskType = enDA_CDROM;
		else if(pDev->DeviceFlags &DFLAGS_ATAPI)
			pInfo->iDiskType = enDA_TAPE;
		else 
			pInfo->iDiskType = enDA_NonDisk;
            
        SwapCopy( pInfo->szModelName, (const char *)pDev->IdentifyData.ModelNumber, 
            sizeof(pDev->IdentifyData.ModelNumber) );
            
        pInfo->uTotalBlocks = pDev->capacity;
            
        if( pDev->pArray && !(pDev->DeviceFlags2 & DFLAGS_NEW_ADDED))
        {
            PVirtualDevice pDevArray = pDev->pArray;
			// gmm 2001-3-7
			pInfo->iArrayNum = pDev->ArrayNum;
			switch (pDevArray->arrayType) {
			case VD_RAID_01_2STRIPE:
				pInfo->hParentArray = MAKE_CHILD_ARRAY_ID(pDevArray, 1);
				break;
			case VD_RAID01_MIRROR:
				pInfo->hParentArray = MAKE_CHILD_ARRAY_ID(pDevArray, 2);
				break;
			case VD_RAID_01_1STRIPE:
				if (pDev->ArrayNum==MIRROR_DISK)
					pInfo->hParentArray = MAKE_COMPOSED_ARRAY_ID(pDevArray);
				else
					pInfo->hParentArray = MAKE_CHILD_ARRAY_ID(pDevArray, 1);
				break;
			default:
				pInfo->hParentArray = MAKE_ARRAY_ID(pDevArray);
				break;
			}
            if( pDevArray->arrayType == VD_RAID_1_MIRROR &&
                pDevArray->pDevice[SPARE_DISK] == pDev)
            {
                pInfo->isSpare = TRUE;
            }
        }
            
        if( nDeviceMode < 5 )
        {
            pInfo->nTransferMode = 0;
            pInfo->nTransferSubMode = nDeviceMode;
        }
        else if( nDeviceMode < 8 )
        {
            pInfo->nTransferMode = 1;
            pInfo->nTransferSubMode = nDeviceMode - 5;
        }
        else
        {
            pInfo->nTransferMode = 2;
            pInfo->nTransferSubMode = nDeviceMode - 8;
        }
        
        if (pDev->DeviceFlags2 & DFLAGS_BOOTABLE_DEVICE)
			pInfo->Flags |= DEV_FLAG_BOOTABLE;
#ifdef SUPPORT_HPT601
        if (pDev->DeviceFlags2 & DFLAGS_WITH_601)
			pInfo->Flags |= DEV_FLAG_WITH_601;
#endif
	}
	else if (IS_ARRAY_ID(hDeviceNode)) {
		PVirtualDevice pArray = ARRAY_FROM_ID(hDeviceNode);
		int iChildArray = CHILDNUM_FROM_ID(hDeviceNode);

		// in case when 0+1 source/mirror swapped 
		if (IS_COMPOSED_ARRAY(hDeviceNode) && pArray->arrayType==VD_RAID01_MIRROR)
			pArray = pArray->pDevice[MIRROR_DISK]->pArray;

		/*
		 * set working status 
		 */
		switch(pArray->arrayType){
		case VD_RAID_01_2STRIPE:
			if (!IS_COMPOSED_ARRAY(hDeviceNode))
				goto default_status;
			else {
				// check both source RAID0 and mirror RAID0
				PVirtualDevice pMirror=NULL;
				PDevice pMirrorDev = pArray->pDevice[MIRROR_DISK];
				if (pMirrorDev)	pMirror = pMirrorDev->pArray;
				if (!pMirror){
					if (pArray->RaidFlags & RAID_FLAGS_DISABLED)
						pInfo->iWorkingStatus = enDiskStatus_Disabled;
					else
						pInfo->iWorkingStatus = enDiskStatus_WorkingWithError;
				}
				else if ((pArray->RaidFlags & RAID_FLAGS_DISABLED || pArray->BrokenFlag) &&
					(pMirror->RaidFlags & RAID_FLAGS_DISABLED || pMirror->BrokenFlag))
					pInfo->iWorkingStatus = enDiskStatus_Disabled;
				else if (pArray->BrokenFlag || pMirror->BrokenFlag)
					pInfo->iWorkingStatus = enDiskStatus_WorkingWithError;
				else if (pArray->RaidFlags & RAID_FLAGS_BEING_BUILT)
					pInfo->iWorkingStatus = enDiskStatus_BeingBuilt;
				else if (pArray->RaidFlags & RAID_FLAGS_NEED_SYNCHRONIZE)
					pInfo->iWorkingStatus = enDiskStatus_NeedBuilding;
				else
					pInfo->iWorkingStatus = enDiskStatus_Working;
			}
			break;
		case VD_RAID_01_1STRIPE:
			if (!IS_COMPOSED_ARRAY(hDeviceNode))
				goto default_status;
			// VD_RAID_01_1STRIPE same as VD_RAID_1_MIRROR
		case VD_RAID_1_MIRROR:
			if (pArray->RaidFlags & RAID_FLAGS_DISABLED)
				pInfo->iWorkingStatus = enDiskStatus_Disabled;
			else if (pArray->BrokenFlag)
				pInfo->iWorkingStatus = enDiskStatus_WorkingWithError;
			else if (pArray->RaidFlags & RAID_FLAGS_BEING_BUILT)
				pInfo->iWorkingStatus = enDiskStatus_BeingBuilt;
			else if (pArray->RaidFlags & RAID_FLAGS_NEED_SYNCHRONIZE)
				pInfo->iWorkingStatus = enDiskStatus_NeedBuilding;
			else
				pInfo->iWorkingStatus = enDiskStatus_Working;
			break;
		default:
default_status:
			if (pArray->BrokenFlag || pArray->RaidFlags & RAID_FLAGS_DISABLED)
				pInfo->iWorkingStatus = enDiskStatus_Disabled;
			else
				pInfo->iWorkingStatus = enDiskStatus_Working;
			break;
		}
		
		if (pArray->pDevice[0])
			GetPhysicalId(pArray->pDevice[0], &pInfo->PhysicalId );
		else if (pArray->pDevice[MIRROR_DISK])
			GetPhysicalId(pArray->pDevice[MIRROR_DISK], &pInfo->PhysicalId );
		else {
			int ha, i;
			pInfo->PhysicalId = VIRTUAL_DISK_ID;
			for (ha=0; ha<num_adapters; ha++)
			for (i=0; i<MAX_DEVICES_PER_CHIP; i++)
				if (pArray==&hpt_adapters[ha]->_VirtualDevices[i]) {
					pInfo->PhysicalId.nControllerId = ha;
					goto id_found;
				}
id_found:	;
		}

		// gmm 2001-3-3
		if (IS_COMPOSED_ARRAY(hDeviceNode)) {
			for(iName=0; iName<16; iName++)
        		pInfo->ArrayName[iName] = pArray->ArrayName[iName+16];
		}else{
			for(iName=0; iName<16; iName++)
        		pInfo->ArrayName[iName] = pArray->ArrayName[iName];
		}

		if (iChildArray && !IS_COMPOSED_ARRAY(hDeviceNode)) {
			if (pArray->arrayType==VD_RAID01_MIRROR)
				pInfo->hParentArray = MAKE_COMPOSED_ARRAY_ID(pArray->pDevice[MIRROR_DISK]->pArray);
			else
				pInfo->hParentArray = MAKE_COMPOSED_ARRAY_ID(pArray);
		}
        
       	pInfo->iRawArrayType = pArray->arrayType;
		pInfo->nStripSize = 1<<pArray->BlockSizeShift;
        switch( pArray->arrayType )
        {
            case VD_RAID_0_STRIPE:
                pInfo->iDiskType = enDA_Stripping;
		        pInfo->uTotalBlocks = pArray->capacity;
                break;
            case VD_RAID_01_1STRIPE:
				if (!IS_COMPOSED_ARRAY(hDeviceNode)) {
					DWORD capacity = 0x7FFFFFFF;
					int i;
					for (i=0; i<SPARE_DISK; i++) {
						if (pArray->pDevice[i] && capacity>pArray->pDevice[i]->capacity)
							capacity = pArray->pDevice[i]->capacity;
					}
					pInfo->iDiskType = enDA_Stripping;
			        pInfo->uTotalBlocks = capacity * pArray->nDisk;
				}
				else {
					pInfo->iDiskType = enDA_Mirror;
			        pInfo->uTotalBlocks = pArray->capacity;
				}
				break;
			case VD_RAID01_MIRROR:
				pInfo->iDiskType = enDA_Stripping;
			    pInfo->uTotalBlocks = GetRAID0Capacity(pArray);
				break;
            case VD_RAID_01_2STRIPE:
				if (!IS_COMPOSED_ARRAY(hDeviceNode)) {
					pInfo->iDiskType = enDA_Stripping;
			        pInfo->uTotalBlocks = GetRAID0Capacity(pArray);
					break;
				}
				else {
					pInfo->iDiskType = enDA_Mirror;
					pInfo->uTotalBlocks = pArray->capacity;
					if (pArray->pDevice[MIRROR_DISK] &&
						pArray->pDevice[MIRROR_DISK]->pArray &&
						pArray->pDevice[MIRROR_DISK]->pArray->capacity < pInfo->uTotalBlocks)
						pInfo->uTotalBlocks = pArray->pDevice[MIRROR_DISK]->pArray->capacity;
					pInfo->isSpare = (pArray->pDevice[SPARE_DISK]!=NULL);
				}
				break;
            case VD_RAID_1_MIRROR:
				pInfo->iDiskType = enDA_Mirror;
		        pInfo->uTotalBlocks = pArray->capacity;
				pInfo->isSpare = (pArray->pDevice[SPARE_DISK]!=NULL);
                break;
            case VD_SPAN:
                pInfo->iDiskType = enDA_Span;
		        pInfo->uTotalBlocks = pArray->capacity;
                break;
            case VD_RAID_3:
                pInfo->iDiskType = enDA_RAID3;
		        pInfo->uTotalBlocks = pArray->capacity;
                break;
            case VD_RAID_5:
                pInfo->iDiskType = enDA_RAID5;
		        pInfo->uTotalBlocks = pArray->capacity;
                break;
            default:
                pInfo->iDiskType = enDA_Unknown;
        }

		pInfo->dwArrayStamp = pArray->Stamp;
		pInfo->iArrayNum = GET_ARRAY_NUM(pArray);

		if (pArray->RaidFlags & RAID_FLAGS_BOOTDISK)
			pInfo->Flags |= DEV_FLAG_BOOTABLE;
		if (pArray->RaidFlags & RAID_FLAGS_NEWLY_CREATED)
			pInfo->Flags |= DEV_FLAG_NEWLY_CREATED;
		if (pArray->RaidFlags & RAID_FLAGS_NEED_AUTOREBUILD)
			pInfo->Flags |= DEV_FLAG_NEED_AUTOREBUILD;
    }
	else
        return FALSE;
    return TRUE;
}

BOOL Device_GetChild( HDISK hParentNode, HDISK * pChildNode )
{
	PVirtualDevice pArray;
	PDevice pDev;
    if( hParentNode == HROOT_DEVICE )
    {
		int iAdapter, iChan, iDev;
		for (iAdapter=0; iAdapter<num_adapters; iAdapter++) {
			for (pArray=hpt_adapters[iAdapter]->_VirtualDevices; 
				 pArray<hpt_adapters[iAdapter]->_pLastVD; 
				 pArray++) {
				if (pArray->arrayType!=VD_INVALID_TYPE &&
					pArray->arrayType!=VD_RAID01_MIRROR) {
					switch(pArray->arrayType){
					case VD_RAID_01_1STRIPE:
					case VD_RAID_01_2STRIPE:
						*pChildNode = MAKE_COMPOSED_ARRAY_ID(pArray);
						break;
					default:
						*pChildNode = MAKE_ARRAY_ID(pArray);
						break;
					}
					return TRUE;
				}
			}
		}
		for (iAdapter=0; iAdapter<num_adapters; iAdapter++)
			for (iChan=0; iChan<2; iChan++)
				for (iDev=0; iDev<2; iDev++)
					if (pDev = hpt_adapters[iAdapter]->IDEChannel[iChan].pDevice[iDev]) {
						// failed disk may still have pArray set.
						// gmm 2001-3-27 put failed RAID1 members inside the array node.
						if (!pDev->pArray ||
							(pDev->pArray && (pDev->DeviceFlags2 & DFLAGS_DEVICE_DISABLED)
							&& pDev->pArray->pDevice[pDev->ArrayNum]!=pDev
							&& pDev->pArray->arrayType!=VD_RAID_1_MIRROR)) {
							*pChildNode = (HDISK)(0xC0000000 | iAdapter<<16 | iChan<<8 | iDev);
							return TRUE;
						}
					}
		return FALSE;
    }
    else if (IS_ARRAY_ID(hParentNode)) {
		int i;
		pArray = ARRAY_FROM_ID(hParentNode);
		// in case when 0+1 source/mirror swapped 
		if (IS_COMPOSED_ARRAY(hParentNode) && pArray->arrayType==VD_RAID01_MIRROR)
			pArray = pArray->pDevice[MIRROR_DISK]->pArray;
		switch(pArray->arrayType) {
		case VD_RAID_01_1STRIPE:
			if (IS_COMPOSED_ARRAY(hParentNode)) {
				for (i=0; i<SPARE_DISK; i++) {
					if (pArray->pDevice[i]) {
						*pChildNode = MAKE_CHILD_ARRAY_ID(pArray, 1);
						return TRUE;
					}
				}
				if (pArray->pDevice[MIRROR_DISK]) {
					*pChildNode = MAKE_DEVICE_ID(pArray->pDevice[MIRROR_DISK]);
					return TRUE;
				}
				return FALSE;
			} else {
				for (i=0; i<SPARE_DISK; i++) {
					if (pArray->pDevice[i] &&
						!(pArray->pDevice[i]->DeviceFlags2 & DFLAGS_NEW_ADDED)) {
						*pChildNode = MAKE_DEVICE_ID(pArray->pDevice[i]);
						return TRUE;
					}
				}
			}
			return FALSE;
		case VD_RAID_01_2STRIPE:
			if (IS_COMPOSED_ARRAY(hParentNode)) {
				for (i=0; i<SPARE_DISK; i++) {
					if (pArray->pDevice[i]) {
						*pChildNode = MAKE_CHILD_ARRAY_ID(pArray, 1);
						return TRUE;
					}
				}
				if (pArray->pDevice[MIRROR_DISK]) {
					*pChildNode = MAKE_ARRAY_ID(pArray->pDevice[MIRROR_DISK]->pArray);
					return TRUE;
				}
			}
			else
			{
				if (CHILDNUM_FROM_ID(hParentNode)==2) 
					if (pArray->pDevice[MIRROR_DISK])
						pArray = pArray->pDevice[MIRROR_DISK]->pArray;
					else
						pArray=NULL;
				if (pArray) {
					for (i=0; i<SPARE_DISK; i++) {
						if (pArray->pDevice[i] && 
							!(pArray->pDevice[i]->DeviceFlags2 & DFLAGS_NEW_ADDED)) {
							*pChildNode = MAKE_DEVICE_ID(pArray->pDevice[i]);
							return TRUE;
						}
					}
				}
			}
			return FALSE;
		default:
			for (i=0; i<MAX_MEMBERS; i++) {
				if (pArray->pDevice[i] && 
					!(pArray->pDevice[i]->DeviceFlags2 & DFLAGS_NEW_ADDED)) {
					*pChildNode = MAKE_DEVICE_ID(pArray->pDevice[i]);
					return TRUE;
				}
			}
        }
    }
    return FALSE;
}

BOOL Device_GetSibling( HDISK hNode, HDISK * pSilbingNode )
{
	PVirtualDevice pArray;
	PDevice pDev;
	int iAdapter, iChan, iDev;
    if( IS_ARRAY_ID(hNode))
    {
		int iChild;
		pArray = ARRAY_FROM_ID(hNode);
		iChild = CHILDNUM_FROM_ID(hNode);
		if (iChild==0) {
			// root level siblings
			for (iAdapter=0; iAdapter<num_adapters; iAdapter++)
				for (iDev=0; iDev<MAX_DEVICES_PER_CHIP; iDev++)
					if (pArray==&hpt_adapters[iAdapter]->_VirtualDevices[iDev])
						goto start_here;
			return FALSE;
start_here:
			if (++iDev >= MAX_DEVICES_PER_CHIP) { iDev = 0; iAdapter++; }
			for (; iAdapter<num_adapters; iAdapter++) {
				for (; iDev<MAX_DEVICES_PER_CHIP; iDev++) {
					pArray = &hpt_adapters[iAdapter]->_VirtualDevices[iDev];
					if (pArray<hpt_adapters[iAdapter]->_pLastVD &&
						pArray->arrayType!=VD_INVALID_TYPE &&
						pArray->arrayType!=VD_RAID01_MIRROR) {
						switch(pArray->arrayType){
						case VD_RAID_01_1STRIPE:
						case VD_RAID_01_2STRIPE:
							*pSilbingNode = MAKE_COMPOSED_ARRAY_ID(pArray);
							break;
						default:
							*pSilbingNode = MAKE_ARRAY_ID(pArray);
							break;
						}
						return TRUE;
					}
				}
				iDev = 0;
			}
			for (iAdapter=0; iAdapter<num_adapters; iAdapter++) {
				for( iChan= 0; iChan< 2; iChan++ ){
					for( iDev= 0; iDev< 2; iDev++ )	{
						if( pDev=hpt_adapters[iAdapter]->IDEChannel[iChan].pDevice[iDev]) {
							if (!pDev->pArray || 
								(pDev->DeviceFlags2 & DFLAGS_NEW_ADDED) ||
								(pDev->pArray && (pDev->DeviceFlags2 & DFLAGS_DEVICE_DISABLED)
									&& pDev->pArray->pDevice[pDev->ArrayNum]!=pDev
									// gmm 2001-3-27
									&& pDev->pArray->arrayType!=VD_RAID_1_MIRROR))
							{
								*pSilbingNode = MAKE_DEVICE_ID(pDev);
								return TRUE;
							}
						}
					}
				}
			}
		}
		else {
			switch(pArray->arrayType){
			case VD_RAID_01_1STRIPE:
				if (iChild==1) {
					if (pArray->pDevice[MIRROR_DISK]) {
						*pSilbingNode = MAKE_DEVICE_ID(pArray->pDevice[MIRROR_DISK]);
						return TRUE;
					}
				}
				break;
			case VD_RAID_01_2STRIPE:
				if (iChild==1) {
					if (pArray->pDevice[MIRROR_DISK]) {
						*pSilbingNode = MAKE_CHILD_ARRAY_ID(pArray->pDevice[MIRROR_DISK]->pArray, 2);
						return TRUE;
					}
				}
				break;
			}
		}
		return FALSE;
    }
    else if (IS_DEVICE_ID(hNode)) {
		pDev = DEVICE_FROM_ID(hNode);
		if (!pDev) return FALSE;
		if ((pArray=pDev->pArray) && 
			((!(pDev->DeviceFlags2 & DFLAGS_NEW_ADDED) 
				&& pArray->pDevice[pDev->ArrayNum]==pDev)
				// gmm 2001-3-27
				|| ((pDev->DeviceFlags2 & DFLAGS_DEVICE_DISABLED) 
					&& pArray->arrayType==VD_RAID_1_MIRROR))
			) {
			switch(pArray->arrayType) {
			case VD_RAID_1_MIRROR:
				if (pDev==pArray->pDevice[0]) {
					if (pArray->pDevice[MIRROR_DISK]) {
						*pSilbingNode = MAKE_DEVICE_ID(pArray->pDevice[MIRROR_DISK]);
						return TRUE;
					}else if (pArray->pDevice[SPARE_DISK]) {
						*pSilbingNode = MAKE_DEVICE_ID(pArray->pDevice[SPARE_DISK]);
						return TRUE;
					}
				}
				else if (pDev==pArray->pDevice[MIRROR_DISK]) {
					if (pArray->pDevice[SPARE_DISK]) {
						*pSilbingNode = MAKE_DEVICE_ID(pArray->pDevice[SPARE_DISK]);
						return TRUE;
					}
				}
				// gmm 2001-3-27 search failed RAID 1 members.
				if (pDev->DeviceFlags2 & DFLAGS_DEVICE_DISABLED) {
					iAdapter = ADAPTER_FROM_ID(hNode);
					iChan = BUS_FROM_ID(hNode);
					iDev = DEVID_FROM_ID(hNode);
					iDev++;
					if (iDev>1) { iDev=0; iChan++; }
					if (iChan>1) { iAdapter++; iChan=0; }
				}
				else {
					iAdapter = iChan = iDev = 0;
				}
				for (; iAdapter<num_adapters; iAdapter++) {
					for (; iChan<2; iChan++) {
						for (; iDev<2; iDev++) {
							if (pDev=hpt_adapters[iAdapter]->IDEChannel[iChan].pDevice[iDev]) {
								if (pDev->pArray==pArray && 
									pDev->DeviceFlags2 & DFLAGS_DEVICE_DISABLED)
								{
									*pSilbingNode = MAKE_DEVICE_ID(pDev);
									return TRUE;
								}
							}
						}
						iDev=0;
					}
					iChan=0;
				}
				//-*/
				break;
			case VD_RAID_01_1STRIPE:
			case VD_RAID_01_2STRIPE:
			case VD_RAID01_MIRROR:
			default:
				for (iDev=pDev->ArrayNum+1; iDev<SPARE_DISK; iDev++)
					if (pArray->pDevice[iDev] &&
						!(pArray->pDevice[iDev]->DeviceFlags2 & DFLAGS_NEW_ADDED)) {
						*pSilbingNode = MAKE_DEVICE_ID(pArray->pDevice[iDev]);
						return TRUE;
					}
				break;
			}
		}
		else{
			iAdapter = ADAPTER_FROM_ID(hNode);
			iChan = BUS_FROM_ID(hNode);
			iDev = DEVID_FROM_ID(hNode);
			iDev++;
			if (iDev>1) { iDev=0; iChan++; }
			if (iChan>1) { iAdapter++; iChan=0; }
			for (; iAdapter<num_adapters; iAdapter++) {
				for (; iChan<2; iChan++) {
					for (; iDev<2; iDev++) {
						if (pDev=hpt_adapters[iAdapter]->IDEChannel[iChan].pDevice[iDev]) {
							if (!pDev->pArray || 
								(pDev->DeviceFlags2 & DFLAGS_NEW_ADDED) ||
								(pDev->pArray && (pDev->DeviceFlags2 & DFLAGS_DEVICE_DISABLED)
									&& pDev->pArray->pDevice[pDev->ArrayNum]!=pDev
									// gmm 2001-3-27
									&& pDev->pArray->arrayType!=VD_RAID_1_MIRROR))
							{
								*pSilbingNode = MAKE_DEVICE_ID(pDev);
								return TRUE;
							}
						}
					}
					iDev=0;
				}
				iChan=0;
			}
		}
    }
    return FALSE;
}

int RAIDController_GetNum()
{
    return num_adapters;
}

BOOL RAIDController_GetInfo( int iController, St_StorageControllerInfo* pInfo )
{
    int iChannel;
    /* Name length is 35 characters! */
    if (hpt_adapters[iController]->IDEChannel[0].ChannelFlags & IS_HPT_372A)
    	strcpy( pInfo->szProductID, "HPT372A UDMA/ATA133 RAID Controller" );
    else if (hpt_adapters[iController]->IDEChannel[0].ChannelFlags & IS_HPT_372)
    	strcpy( pInfo->szProductID, "HPT372 UDMA/ATA133 RAID Controller" );
    else
    	strcpy( pInfo->szProductID, "HPT370/370A ATA100 RAID Controller" );
    strcpy( pInfo->szVendorID, "HighPoint Technologies, Inc" );
    pInfo->uBuses = 2;
    pInfo->iInterruptRequest = hpt_adapters[iController]->IDEChannel[0].InterruptLevel;
    
    for( iChannel = 0; iChannel < 2; iChannel ++ )
    {
        int iDevice;
        St_IoBusInfo * pBusInfo = &pInfo->vecBuses[iChannel];
        
        pBusInfo->uDevices = 0;
        
        for( iDevice = 0; iDevice < 2; iDevice ++ )
        {
            PDevice pDevice = hpt_adapters[iController]->IDEChannel[iChannel].pDevice[iDevice];
            
            if( pDevice )
            {
                pBusInfo->vecDevices[pBusInfo->uDevices] = Device_GetHandle( pDevice );
                pBusInfo->uDevices ++;
            }
        }
    }
    
    return TRUE;
}

HDISK Device_CreateMirror( HDISK * pDisks, int nDisks )
{
	PDevice pDevice0, pDevice1;
	PVirtualDevice pArray=NULL, pArray0, pArray1;
	if (nDisks<2) return INVALID_HANDLE_VALUE;

	pDevice0 = IS_DEVICE_ID(pDisks[0])? DEVICE_FROM_ID(pDisks[0]) : NULL;
	pDevice1 = IS_DEVICE_ID(pDisks[1])? DEVICE_FROM_ID(pDisks[1]) : NULL;
	pArray0 = IS_ARRAY_ID(pDisks[0])? ARRAY_FROM_ID(pDisks[0]) : NULL;
	pArray1 = IS_ARRAY_ID(pDisks[1])? ARRAY_FROM_ID(pDisks[1]) : NULL;

	if (pDevice0) {
		// gmm 2000-3-12: add a check
		if (pDevice0->pArray) return INVALID_HANDLE_VALUE;
		pDevice0->DeviceFlags2 &= ~DFLAGS_NEW_ADDED;
	}
	if (pDevice1) {
		if (pDevice1->pArray) return INVALID_HANDLE_VALUE;
		pDevice1->DeviceFlags2 &= ~DFLAGS_NEW_ADDED;
	}

    if( pDevice0 && pDevice1)
	{   //  mirror two physical disks
		if (pDevice0->pChannel->HwDeviceExtension != pDevice1->pChannel->HwDeviceExtension)
			return INVALID_HANDLE_VALUE;
        pArray = Array_alloc(pDevice0->pChannel->HwDeviceExtension);
		pArray->RaidFlags |= RAID_FLAGS_NEWLY_CREATED;
		if (pDevice0->DeviceFlags2 & DFLAGS_BOOTABLE_DEVICE)
			pArray->RaidFlags |= RAID_FLAGS_BOOTDISK;
        
        pArray->nDisk = 1;
        pArray->arrayType = VD_RAID_1_MIRROR;
		pArray->BlockSizeShift = 7;
        pArray->pDevice[0] = pDevice0;
        pDevice0->ArrayNum = 0;
		pDevice0->ArrayMask = (1 << 0);
		pDevice0->pArray = pArray;
		pDevice0->DeviceFlags &= ~DFLAGS_HIDEN_DISK;
		if (pDevice0->HidenLBA>0) {
			pDevice0->HidenLBA=0;
			pDevice0->capacity += (RECODR_LBA + 1);
		}

		pArray->pDevice[MIRROR_DISK] = pDevice1;
		pDevice1->ArrayNum = MIRROR_DISK;
		pDevice1->ArrayMask = (1 << MIRROR_DISK);
		pDevice1->pArray = pArray;
            
        if (nDisks > 2 && IS_DEVICE_ID(pDisks[2]))
        {   //  a spare disk has been specified
            if ((pArray->pDevice[SPARE_DISK] = DEVICE_FROM_ID(pDisks[2]))) {
				pArray->pDevice[SPARE_DISK]->ArrayNum = SPARE_DISK;
				pArray->pDevice[SPARE_DISK]->ArrayMask = (1 << SPARE_DISK);
				pArray->pDevice[SPARE_DISK]->pArray = pArray;
			}
        }
            
        pDevice1->DeviceFlags |= DFLAGS_HIDEN_DISK;
		if (pDevice1->HidenLBA>0) {
			pDevice1->HidenLBA=0;
			pDevice1->capacity += (RECODR_LBA + 1);
		}
        if (pArray->pDevice[SPARE_DISK]) {
            pArray->pDevice[SPARE_DISK]->DeviceFlags |= DFLAGS_HIDEN_DISK;
        }
		pArray->capacity = (pDevice0->capacity > pDevice1->capacity)? 
			pDevice1->capacity : pDevice0->capacity;
	}
    else if( pArray0 && pArray1 && 
        pArray0->arrayType == VD_RAID_0_STRIPE &&
        pArray1->arrayType == VD_RAID_0_STRIPE )
    {   //  mirror two striped arrays
    	if (pArray0->BrokenFlag || pArray1->BrokenFlag) 
    		return INVALID_HANDLE_VALUE;
		if (pArray0->pDevice[0]->pChannel->HwDeviceExtension != 
			pArray1->pDevice[0]->pChannel->HwDeviceExtension)
			return INVALID_HANDLE_VALUE;

        pArray = pArray0;

		pArray0->RaidFlags |= RAID_FLAGS_NEWLY_CREATED;
		pArray1->RaidFlags |= RAID_FLAGS_NEWLY_CREATED;

        pArray0->arrayType = VD_RAID_01_2STRIPE;
        pArray0->pDevice[MIRROR_DISK] = pArray1->pDevice[0];
        pArray1->arrayType = VD_RAID01_MIRROR;
        pArray1->pDevice[MIRROR_DISK] = pArray0->pDevice[0];
        pArray1->pDevice[0]->DeviceFlags |= DFLAGS_HIDEN_DISK;
		if (pArray0->capacity > pArray1->capacity) pArray->capacity=pArray1->capacity;
    }
    else
    {   //  Not support yet
        return INVALID_HANDLE_VALUE;
    }
   
	pArray->RaidFlags |= RAID_FLAGS_NEED_SYNCHRONIZE;
	if (pArray->arrayType==VD_RAID_1_MIRROR)
		return MAKE_ARRAY_ID(pArray);
	else
		return MAKE_COMPOSED_ARRAY_ID(pArray);
}

static HDISK CreateMultiDiskArray(
    int iArrayType,
    HDISK * pDisks, int nDisks, 
    int nStripSizeShift )
{    
    PVirtualDevice pArray;
    int i;
    PDevice pMember[MAX_MEMBERS];
	DWORD capacity=0x7FFFFFFF;
	PHW_DEVICE_EXTENSION ext=0;
	
	if (nDisks<2) return INVALID_HANDLE_VALUE;
    for( i = 0; i < nDisks; i ++ ) {
    	if (!IS_DEVICE_ID(pDisks[i])) return INVALID_HANDLE_VALUE;
    	pMember[i] = DEVICE_FROM_ID(pDisks[i]);
        if (!pMember[i] || pMember[i]->pArray)
			return INVALID_HANDLE_VALUE;
		if (ext==0) 
			ext = pMember[i]->pChannel->HwDeviceExtension;
		else if (ext!=pMember[i]->pChannel->HwDeviceExtension)
			return INVALID_HANDLE_VALUE;
	}

    for( i = 0; i < nDisks; i ++ )
		if (!UnregisterLogicalDevice(pMember[i])) return FALSE;

	pArray = Array_alloc(pMember[0]->pChannel->HwDeviceExtension);
	pArray->RaidFlags |= RAID_FLAGS_NEWLY_CREATED;
        
    pArray->nDisk = (BYTE)nDisks;
    pArray->arrayType = (BYTE)iArrayType;
    pArray->BlockSizeShift = (BYTE)nStripSizeShift;
	// DO NOT FORTET TO SET THIS:
	pArray->ArrayNumBlock = 1<<(BYTE)nStripSizeShift;
        
	pArray->capacity=0;

    for( i = 0; i < nDisks; i ++ )
    {
		PDevice pDev = pMember[i];
        pArray->pDevice[i] = pDev;
		/* 
		 * important to set pDev attributes.
		 */
		pDev->DeviceFlags |= DFLAGS_ARRAY_DISK; // gmm 2001-3-18 added
		pDev->DeviceFlags2 &= ~DFLAGS_NEW_ADDED;
		pDev->pArray = pArray;
		pDev->ArrayMask = 1<<i;
		pDev->ArrayNum = (UCHAR)i;
		ZeroMemory(&pDev->stErrorLog, sizeof(pDev->stErrorLog));

		/*
		 * calc capacity.
		 * we must take care on whether pDev has HidenLBA set
		 */
		if (pDev->HidenLBA>0) {
			pDev->HidenLBA = 0;
			pDev->capacity += (RECODR_LBA + 1);
		}
		if (iArrayType==VD_SPAN) {
			pArray->capacity += pDev->capacity - RECODR_LBA - 1;
		}
		else {
			// RAID0. will set pArray->capacity later.
			if (capacity > pDev->capacity) capacity = pDev->capacity;
		}
		
		if (i>0) {
			pDev->DeviceFlags |= DFLAGS_HIDEN_DISK;
			if (pDev->HidenLBA==0) {
				pDev->HidenLBA = (RECODR_LBA + 1);
				pDev->capacity -= (RECODR_LBA + 1);
			}
		}
		else
			pDev->DeviceFlags &= ~DFLAGS_HIDEN_DISK;
    }
    
	if (iArrayType==VD_RAID_0_STRIPE) {
		// gmm 2001-3-19
		capacity -= (RECODR_LBA + 1);
		capacity &= ~((1<<nStripSizeShift)-1);
		pArray->capacity = capacity*nDisks;
	}
    return MAKE_ARRAY_ID(pArray);
}

HDISK Device_CreateStriping( HDISK *pDisks, int nDisks, int nStripSizeShift )
{
    return CreateMultiDiskArray( VD_RAID_0_STRIPE, pDisks, nDisks, nStripSizeShift );
}

HDISK Device_CreateSpan( HDISK * pDisks, int nDisks )
{
    return CreateMultiDiskArray( VD_SPAN, pDisks, nDisks, 7 );
}

BOOL Device_Remove( HDISK hDisk )
{
	PVirtualDevice pArray;

    if(!IS_ARRAY_ID( hDisk )) return FALSE;
	if (CHILDNUM_FROM_ID(hDisk)) return FALSE;
	pArray = ARRAY_FROM_ID(hDisk);

	if (!UnregisterLogicalDevice(pArray)) return FALSE;
	/*+
	 * gmm: it's safe to call DeleteArray on a mirror.
	 */
	switch (pArray->arrayType) {
	case VD_RAID_1_MIRROR:
		{
			PDevice pDev;
			int iAdapter, iChan, iDev;
			DeleteArray(pArray);
			// gmm 2001-3-11
			for (iAdapter=0; iAdapter<num_adapters; iAdapter++)
				for (iChan=0; iChan<2; iChan++)
					for (iDev=0; iDev<2; iDev++)
						if (pDev = hpt_adapters[iAdapter]->IDEChannel[iChan].pDevice[iDev]) {
							// failed disk may still have pArray set.
							if (pDev->pArray==pArray) {
								pDev->pArray = NULL;
							}
						}
			//-*/
			Array_free(pArray);
			return TRUE;
		}
	case VD_RAID_0_STRIPE:
		{
			int i;
			PDevice pDev;
			for (i=0; i<SPARE_DISK; i++) {
				if (pDev=pArray->pDevice[i]) {
					pDev->pArray = 0;
					pDev->DeviceFlags &= ~(DFLAGS_HIDEN_DISK | DFLAGS_ARRAY_DISK);
					if (pDev->HidenLBA) {
						pDev->HidenLBA = 0;
						pDev->capacity += (RECODR_LBA+1);
					}
				}
			}
		}
		Array_free(pArray);
		return TRUE;
	case VD_RAID_01_2STRIPE:
	case VD_RAID01_MIRROR:
		/*
		 * map to single disks.
		 */
		{
			PDevice pDevs[MAX_MEMBERS*2];
			int i, nDev=0;
			PVirtualDevice pMirror=NULL;
			if (pArray->pDevice[MIRROR_DISK]) pMirror=pArray->pDevice[MIRROR_DISK]->pArray;

			for (i=0; i<SPARE_DISK; i++)
				if (pArray->pDevice[i]) pDevs[nDev++] = pArray->pDevice[i];
			if (pMirror) {
				for (i=0; i<SPARE_DISK; i++) 
					if (pMirror->pDevice[i]) pDevs[nDev++] = pMirror->pDevice[i];
			}
			for (i=0; i<nDev; i++) {
				pDevs[i]->pArray = NULL;
				pDevs[i]->DeviceFlags &= ~(DFLAGS_HIDEN_DISK | DFLAGS_ARRAY_DISK);
				if (pDevs[i]->HidenLBA) {
					pDevs[i]->HidenLBA = 0;
					pDevs[i]->capacity += (RECODR_LBA+1);
				}
			}
			Array_free(pArray);
			if (pMirror) Array_free(pMirror);
		}
#if 0
		/*
		 * map to 2 RAID 0.
		 */
		{
			PVirtualDevice pMirror=NULL;
			if (pArray->pDevice[MIRROR_DISK]) pMirror=pArray->pDevice[MIRROR_DISK]->pArray;
			pArray->pDevice[MIRROR_DISK]=0;
			pArray->arrayType = VD_RAID_0_STRIPE;
			if (pArray->pDevice[0])
				pArray->pDevice[0]->DeviceFlags &= ~DFLAGS_HIDEN_DISK;
			if (pMirror) {
				pMirror->pDevice[MIRROR_DISK]=0;
				pMirror->arrayType = VD_RAID_0_STRIPE;
				if (pMirror->pDevice[0])
					pMirror->pDevice[0]->DeviceFlags &= ~DFLAGS_HIDEN_DISK;
			}
		}
#endif
		return TRUE;
	case VD_RAID_01_1STRIPE:
		DeleteArray(pArray);
		return TRUE;

	default:
		/*
		 * gmm: Although it's unsafe to delete a stripe array,
		 * we delete it, give the responsibility of keeping data
		 * safe to the user. Otherwise the GUI can't keep consistent
		 * with driver and system must reboot.
		 */
		DeleteArray(pArray);
		Array_free(pArray);
		return TRUE;
	}
    return FALSE;
}

BOOL Device_BeginRebuildingMirror( HDISK hMirror )
{
    if( IS_ARRAY_ID( hMirror ) )
    {
		PVirtualDevice pArray = ARRAY_FROM_ID(hMirror);
		// in case when 0+1 source/mirror swapped 
		if (IS_COMPOSED_ARRAY(hMirror) && pArray->arrayType==VD_RAID01_MIRROR)
			pArray = pArray->pDevice[MIRROR_DISK]->pArray;

		pArray->RaidFlags &= ~RAID_FLAGS_NEED_AUTOREBUILD;

		if (!(pArray->RaidFlags & RAID_FLAGS_DISABLED)) {
            pArray->RaidFlags |= RAID_FLAGS_BEING_BUILT;
            return TRUE;
        }
    }
    return FALSE;
}

BOOL Device_AbortMirrorBuilding( HDISK hMirror )
{
    if( IS_ARRAY_ID( hMirror ) )
    {
		PVirtualDevice pArray = ARRAY_FROM_ID(hMirror);
		if (pArray->RaidFlags & RAID_FLAGS_BEING_BUILT) {
	            pArray->RaidFlags &= ~RAID_FLAGS_BEING_BUILT;
		}
        return TRUE;
    }
    return FALSE;
}

BOOL Device_ValidateMirror( HDISK hMirror )
{
    if( IS_ARRAY_ID( hMirror ) )
    {
		PVirtualDevice pArray = ARRAY_FROM_ID(hMirror);
		pArray->RaidFlags &= ~(RAID_FLAGS_BEING_BUILT | 
			RAID_FLAGS_NEED_SYNCHRONIZE | RAID_FLAGS_NEWLY_CREATED);
		return TRUE;
    }
    return FALSE;
}

//////////////////////////////
//
// Add spare disk to a mirror
BOOL Device_AddSpare( HDISK hMirror, HDISK hDisk)
{
	LOC_ARRAY_BLK;
	PVirtualDevice pArray;
	PDevice pDev;
	
	if (!IS_ARRAY_ID(hMirror) || !IS_DEVICE_ID(hDisk)) return FALSE;

	pArray = ARRAY_FROM_ID(hMirror);
	pDev  = DEVICE_FROM_ID(hDisk);
	// If the array is not Mirror
	if(pArray->arrayType != VD_RAID_1_MIRROR) return FALSE;
	if (pArray->BrokenFlag) return FALSE;
	if (!pDev || pDev->pArray) return FALSE;
	
	if (pArray->pDevice[0]->pChannel->HwDeviceExtension!=pDev->pChannel->HwDeviceExtension)
		return FALSE;
	
	// If the capacity of spare disk less than the array
	if(pDev->capacity < pArray->capacity ) return FALSE;

	if(pArray->pDevice[SPARE_DISK])	return FALSE;
	if (!UnregisterLogicalDevice(pDev)) return FALSE;


	pDev->ArrayNum     = SPARE_DISK;
	pDev->ArrayMask    = (1 << SPARE_DISK);
	pDev->DeviceFlags |= DFLAGS_HIDEN_DISK;
	pDev->DeviceFlags2 &= ~DFLAGS_NEW_ADDED; // otherwise it'll be shown at root level
	pDev->pArray       = pArray;
	pArray->pDevice[SPARE_DISK]	 = pDev;

	ReadWrite(pArray->pDevice[0] , RECODR_LBA, IDE_COMMAND_READ ARG_ARRAY_BLK);
	ArrayBlk.DeviceNum = SPARE_DISK;
	ReadWrite(pDev, RECODR_LBA, IDE_COMMAND_WRITE ARG_ARRAY_BLK);
	ZeroMemory(&ArrayBlk, 512);
	ReadWrite(pDev, 0, IDE_COMMAND_WRITE ARG_ARRAY_BLK);
	
	return TRUE;
}

// Del spare disk from a mirror
BOOL Device_DelSpare( HDISK hDisk)
{
	LOC_ARRAY_BLK;
	PVirtualDevice pArray;
	PDevice pDev;
	
	if (!IS_DEVICE_ID(hDisk)) return FALSE;

	pDev = DEVICE_FROM_ID(hDisk);
	if (!pDev) return FALSE;
	pArray = pDev->pArray;
	// If the array is not Mirror
	if(!pArray || pArray->arrayType != VD_RAID_1_MIRROR) return FALSE;
	
	if ((pDev!=pArray->pDevice[SPARE_DISK])) return FALSE;
	pDev->ArrayNum     = 0;
	pDev->ArrayMask    = 0;
	pDev->DeviceFlags &= ~DFLAGS_HIDEN_DISK;
	pDev->pArray       = NULL;
	pArray->pDevice[SPARE_DISK]	 = NULL;

	ZeroMemory((char *)&ArrayBlk, 512);
	ReadWrite(pDev, RECODR_LBA, IDE_COMMAND_WRITE ARG_ARRAY_BLK);
	
	return TRUE;
}

/*++
 Function:
	Device_AddMirrorDisk
	 
 Description:
	Add a source/mirror disk to a mirror array
 	 
 Argument:
	hMirror - The handle of the mirror array
	hDisk   - The handle of the disk to add

 Return:
	BOOL
++*/
BOOL Device_AddMirrorDisk( HDISK hMirror, HDISK hDisk )
{
	PVirtualDevice pArray;
	PDevice pDev;
	int ha, i;	
	
	if (!IS_ARRAY_ID(hMirror) || !IS_DEVICE_ID(hDisk)) return FALSE;

	pArray = ARRAY_FROM_ID(hMirror);
	pDev  = DEVICE_FROM_ID(hDisk);

	if (!pArray || !pDev) return FALSE;

	for (ha=0; ha<num_adapters; ha++)
	for (i=0; i<MAX_DEVICES_PER_CHIP; i++)
		if (pArray==&hpt_adapters[ha]->_VirtualDevices[i])
			if (pDev->pChannel->HwDeviceExtension==hpt_adapters[ha])
				goto ok;
	return FALSE;
ok:
	if(pArray->arrayType == VD_RAID_1_MIRROR)
	{		
		// if pDev belongs to other array, return
		if (pDev->pArray && pDev->pArray!=pArray) return FALSE;
		// If the capacity of mirror disk is less than the array
		if(pDev->capacity < pArray->capacity ) return FALSE;

		if (pArray->nDisk == 0 && pArray->pDevice[MIRROR_DISK])
		{
			// move mirror to pDevice[0]
			pArray->pDevice[0] = pArray->pDevice[MIRROR_DISK];
			pArray->nDisk = 1;
	
			// add as mirror disk
			pDev->ArrayNum  = MIRROR_DISK;
			pArray->RaidFlags |= RAID_FLAGS_NEED_SYNCHRONIZE;
		}
		else if (!pArray->pDevice[MIRROR_DISK])
		{
			// add as mirror disk
			pDev->ArrayNum  = MIRROR_DISK;
			pArray->RaidFlags |= RAID_FLAGS_NEED_SYNCHRONIZE;
		}
		else if (!pArray->pDevice[SPARE_DISK])
		{
			// add as spare disk
			pDev->ArrayNum  = SPARE_DISK;
		}
		else
			return FALSE;

		pDev->DeviceFlags2 &= ~DFLAGS_NEW_ADDED;
		pDev->ArrayMask = (1<<pDev->ArrayNum);
		pDev->pArray = pArray;
		pArray->pDevice[pDev->ArrayNum] = pDev;
		pArray->BrokenFlag = FALSE;		
		return TRUE;
	}
	else if (pArray->arrayType==VD_RAID_01_2STRIPE)
	{
		PVirtualDevice pMirror = NULL;
		if (pArray->pDevice[MIRROR_DISK])
			pMirror = pArray->pDevice[MIRROR_DISK]->pArray;
		if (pDev->pArray && pDev->pArray!=pArray && pDev->pArray!=pMirror) return FALSE;
		if (pArray->BrokenFlag)
		{
			// Swap source/mirror if possible
			if (pMirror && !pMirror->BrokenFlag) {
				PVirtualDevice tmp = pArray;
				pArray=pMirror;
				pMirror=tmp;
				pArray->arrayType = VD_RAID_01_2STRIPE;
				pMirror->arrayType = VD_RAID01_MIRROR;
				/*
				 * gmm 2001-3-14:
				 * swap RaidFlags too.
				 */
				{
					DWORD f = pMirror->RaidFlags & (RAID_FLAGS_NEED_SYNCHRONIZE |
													RAID_FLAGS_BEING_BUILT |
													RAID_FLAGS_BOOTDISK |
													RAID_FLAGS_NEWLY_CREATED);
					pMirror->RaidFlags &= ~f;
					pArray->RaidFlags |= f;
				}
				goto add_to_mirror;
			}
			// never allow add to source RAID0. 
			return FALSE;
		}
		else if (pMirror && pMirror->BrokenFlag)
		{
add_to_mirror:
			if (pArray->BrokenFlag) return FALSE;
			for (i=0; i<pArray->nDisk; i++)
				if (pDev==pMirror->pDevice[i]) goto add_it;
			for (i=0; i<pArray->nDisk; i++) {
				if (!pMirror->pDevice[i] ||
					(pMirror->pDevice[i]->DeviceFlags2 & DFLAGS_DEVICE_DISABLED))
					goto add_it;
			}
			return FALSE;
add_it:
			if (i && !pDev->HidenLBA) {
				pDev->HidenLBA = (RECODR_LBA + 1);
				pDev->capacity -= (RECODR_LBA + 1);
			}
			if (((pDev->capacity + pDev->HidenLBA - RECODR_LBA -1) 
				& ~((1<<pMirror->BlockSizeShift)-1)) * pArray->nDisk 
				< pMirror->capacity) return FALSE;
			// ok to put it back
			if (!UnregisterLogicalDevice(pDev)) return FALSE;
			
			if (pMirror->pDevice[i]) {
				pMirror->pDevice[i]->pArray = 0;
				if (pArray->pDevice[MIRROR_DISK]==pMirror->pDevice[i])
					pArray->pDevice[MIRROR_DISK] = pDev;
			}
			pDev->pArray = pMirror;
			pMirror->pDevice[i] = pDev;
			pDev->ArrayNum = (UCHAR)i;
			pDev->ArrayMask = (1<<i);
			pDev->DeviceFlags |= DFLAGS_ARRAY_DISK|DFLAGS_HIDEN_DISK;
			pDev->DeviceFlags2 &= ~DFLAGS_NEW_ADDED;

			for (i=0; i<pArray->nDisk; i++) {
				if (!pMirror->pDevice[i] || 
					(pMirror->pDevice[i]->DeviceFlags2 & DFLAGS_DEVICE_DISABLED) ||
					(pMirror->pDevice[i]->DeviceFlags2 & DFLAGS_NEW_ADDED))
				{
					return TRUE;
				}
			}
			pMirror->BrokenFlag = FALSE;
			pMirror->nDisk = pArray->nDisk;
			pMirror->RaidFlags &= ~RAID_FLAGS_DISABLED;
			pArray->RaidFlags |= RAID_FLAGS_NEED_SYNCHRONIZE;
			return TRUE;
		}
		else if (!pMirror)
		{
			if (pArray->BrokenFlag) return FALSE;
			if (pDev->HidenLBA>0) {
				pDev->HidenLBA = 0;
				pDev->capacity += (RECODR_LBA + 1);
			}
			if (((pDev->capacity + pDev->HidenLBA - RECODR_LBA -1) 
				& ~((1<<pArray->BlockSizeShift)-1)) * 2 
				< pArray->capacity)
				return FALSE;
			if (!UnregisterLogicalDevice(pDev)) return FALSE;

			pMirror = Array_alloc(pDev->pChannel->HwDeviceExtension);
			/// DO NOT add this flag!
			///pArray->RaidFlags |= RAID_FLAGS_NEWLY_CREATED;
			pMirror->nDisk = 0;
			pMirror->capacity = pArray->capacity;
			pMirror->BrokenFlag = TRUE;
			pMirror->RaidFlags = RAID_FLAGS_DISABLED;
			pMirror->arrayType = VD_RAID01_MIRROR;
			pMirror->BlockSizeShift = pArray->BlockSizeShift;
			pMirror->ArrayNumBlock = 1 << pMirror->BlockSizeShift;
			pMirror->Stamp = pArray->Stamp;
			pMirror->pDevice[0] = pDev;
			pMirror->pDevice[MIRROR_DISK] = pArray->pDevice[0];
			pArray->pDevice[MIRROR_DISK] = pDev;
			
			pDev->DeviceFlags |= DFLAGS_ARRAY_DISK|DFLAGS_HIDEN_DISK;

			pDev->DeviceFlags2 &= ~DFLAGS_NEW_ADDED;
			pDev->pArray = pMirror;
			pDev->ArrayMask = 1;
			pDev->ArrayNum = 0;

			return TRUE;
		}
		return FALSE;
	}
	else 
		return FALSE;
}

void Device_SetArrayName(HDISK hDisk, char* arrayname)
{
	int iName = 0;
	int iStart;
	int arrayType;
	PVirtualDevice pArray;

	if (!IS_ARRAY_ID(hDisk)) return;
	pArray = ARRAY_FROM_ID(hDisk);
	arrayType = pArray->arrayType;
		
	if (IS_COMPOSED_ARRAY(hDisk))
		iStart = 16;
	else
		iStart=0;
	
	for(iName=0; iName<16; iName++)
		pArray->ArrayName[iStart+iName] = arrayname[iName];

	if (IS_COMPOSED_ARRAY(hDisk) && arrayType==VD_RAID_01_2STRIPE) {
		PDevice pDev = pArray->pDevice[MIRROR_DISK];
		if (pDev && pDev->pArray) {
			for(iName=0; iName<16; iName++)
				pDev->pArray->ArrayName[16+iName] = arrayname[iName];
		}
	}
}

BOOL Device_RescanAll()
{
	int iChan;
	int iDev;
	int iAdapter;
	ST_XFER_TYPE_SETTING	osAllowedDeviceXferMode;

	PDevice pDevice;
	PChannel pChan;

	for (iAdapter=0; iAdapter<num_adapters; iAdapter++)
	    for( iChan = 0; iChan < 2; iChan ++ )
	    {
			pChan = &hpt_adapters[iAdapter]->IDEChannel[iChan];
			DisableBoardInterrupt(pChan->BaseBMI);
	        for( iDev = 0; iDev < 2; iDev ++ )
	        {
				osAllowedDeviceXferMode.Mode = 0xFF;
				pDevice=pChan->pDevice[iDev];
				if (!pDevice || (pDevice->DeviceFlags2 & DFLAGS_DEVICE_DISABLED))
				{
					/// pChan->pDevice[iDev] = 0;
					pDevice = &pChan->Devices[iDev];
					/// NO: ZeroMemory(pDevice,sizeof(struct _Device));
					pDevice->UnitId = (iDev)? 0xB0 : 0xA0;
					pDevice->pChannel = pChan;
					if(FindDevice(pDevice,osAllowedDeviceXferMode)) 
					{
						pChan->pDevice[iDev] = pDevice;

						if (pChan->pSgTable == NULL) 
							pDevice->DeviceFlags &= ~(DFLAGS_DMA | DFLAGS_ULTRA);
						
						//if(pDevice->DeviceFlags & DFLAGS_HARDDISK) {
						//	StallExec(1000000);
						//}

						if (pDevice->Usable_Mode>13 && !pChan->HwDeviceExtension->dpll66) {
							extern void set_dpll66(PChannel pChan);
							hpt_queue_dpc(pChan->HwDeviceExtension, (HPT_DPC)set_dpll66, 
								pChan->HwDeviceExtension->IDEChannel);
						}
						
						if((pDevice->DeviceFlags & DFLAGS_ATAPI) == 0 && 
							(pDevice->DeviceFlags & DFLAGS_SUPPORT_MSN))
							IdeMediaStatus(TRUE, pDevice);
						
						Nt2kHwInitialize(pDevice);

						// notify monitor application
						if(pDevice->DeviceFlags & DFLAGS_HARDDISK) {
							/*
							 * gmm: If it's a previously faulted member. We should
							 * be careful it may be the visible disk of an array.
							 * It's difficult to handle this case.
							 */
							// DO NOT CHECK THIS?
							//if (!pDevice->pArray)
								pDevice->DeviceFlags2 |= DFLAGS_NEW_ADDED;
							// notify.
							hpt_queue_dpc(pChan->HwDeviceExtension, disk_plugged_dpc, pDevice);
						}
					}
				}
				else {
					/*
					 * Check if device is still working.
					 * gmm 2001-3-21: DO NOT use Device_IsRemoved() since it won't wait
					 */
					PIDE_REGISTERS_1 IoPort = pChan->BaseIoAddress1;
					PIDE_REGISTERS_2 ControlPort = pChan->BaseIoAddress2;
					UCHAR statusByte, cnt=0;
				_retry_:
					SelectUnit(IoPort, pDevice->UnitId);
					SetBlockCount(IoPort, 0x7F); /* gmm 2001-11-14 */
					statusByte=WaitOnBusy(ControlPort);
					if ((statusByte & 0x7E)==0x7E) {
						goto device_removed;
					}
					else if (statusByte & IDE_STATUS_DWF) {
						/*
						 * gmm 2001-3-18
						 * Some disks will set IDE_STATUS_DWF for a while
						 * when the other disk on same channel get removed 
						 */
						statusByte= GetErrorCode(IoPort);
						DisableBoardInterrupt(pChan->BaseBMI);
						IssueCommand(IoPort, IDE_COMMAND_RECALIBRATE);
						EnableBoardInterrupt(pChan->BaseBMI);
						GetBaseStatus(IoPort);
						StallExec(10000);
						if(cnt++< 10) goto _retry_;
						statusByte = 0x7e; /* cause it to be removed */
					}
					else if(statusByte & IDE_STATUS_ERROR) {
						statusByte= GetErrorCode(IoPort);
						DisableBoardInterrupt(pChan->BaseBMI);
						IssueCommand(IoPort, IDE_COMMAND_RECALIBRATE);
						EnableBoardInterrupt(pChan->BaseBMI);
						GetBaseStatus(IoPort);
						if(cnt++< 10) goto _retry_;
						statusByte = 0x7e; /* cause it to be removed */
					}

					if((statusByte & 0x7e)== 0x7e || 
						((statusByte & (IDE_STATUS_DRDY|IDE_STATUS_BUSY))==0)) {
				device_removed:
						pDevice->DeviceFlags2 |= DFLAGS_DEVICE_DISABLED;
						hpt_queue_dpc(pChan->HwDeviceExtension, disk_failed_dpc, pDevice);
					}
				}
	        }
			
			EnableBoardInterrupt(pChan->BaseBMI);
	    }
	    
	return TRUE;
}

BOOL Device_IsRemoved(PDevice pDev)
{
	PChannel		 pChan = pDev->pChannel;
	PIDE_REGISTERS_1 IoPort = pChan->BaseIoAddress1;
	PIDE_REGISTERS_2 ControlPort = pChan->BaseIoAddress2;
	UCHAR            statusByte, cnt=0;

	if(btr(pChan->exclude_index)) {
	_retry_:
		SelectUnit(IoPort, pDev->UnitId);
		StallExec(1);
		statusByte=GetStatus(ControlPort);
		if (statusByte & IDE_STATUS_BUSY) {
			goto end_retry;
		}

		if ((GetCurrentSelectedUnit(IoPort) != pDev->UnitId)) {
			SelectUnit(IoPort, pDev->UnitId);
			WaitOnBusy(ControlPort);
			SetBlockCount(IoPort, 0x7F);
			statusByte=WaitOnBusy(ControlPort);
		}
		else {
			statusByte = 0x50;
			goto end_retry;
		}

		if (statusByte & IDE_STATUS_BUSY) {
			goto end_retry;
		}
		else 
		if ((statusByte & 0x7E)==0x7E) {
			goto end_retry;
		}
		else
		if (statusByte & IDE_STATUS_DWF) {
			/*
			 * gmm 2001-3-18
			 * Some disks will set IDE_STATUS_DWF for a while
			 * when the other disk on same channel get removed 
			 */
			statusByte= GetErrorCode(IoPort);
			DisableBoardInterrupt(pChan->BaseBMI);
			IssueCommand(IoPort, IDE_COMMAND_RECALIBRATE);
			EnableBoardInterrupt(pChan->BaseBMI);
			GetBaseStatus(IoPort);
			StallExec(10000);
			if(cnt++< 10) goto _retry_;
			statusByte = 0x7e; /* cause it to be removed */
		}
		else 
		if(statusByte & IDE_STATUS_ERROR) {
			statusByte= GetErrorCode(IoPort);
			DisableBoardInterrupt(pChan->BaseBMI);
			IssueCommand(IoPort, IDE_COMMAND_RECALIBRATE);
			EnableBoardInterrupt(pChan->BaseBMI);
			GetBaseStatus(IoPort);
			if(cnt++< 10) goto _retry_;
			statusByte = 0x7e; /* cause it to be removed */
		}
end_retry:
		bts(pChan->exclude_index);
		/*
		 * gmm 2001-3-14 
		 *    add '&& (statusByte & IDE_STATUS_BUSY)'
		 *    sometimes when one drive is faulted the other on the same channel 
		 *    may lock at busy state for a long time. If we do not add this check
		 *    this drive all also be reported to be removed.
		 */
		if((statusByte & 0x7e)== 0x7e || 
			((statusByte & (IDE_STATUS_DRDY|IDE_STATUS_BUSY))==0)) {
			return TRUE;
		}
	}
	return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\port\scsi\miniport\hipoint\hpt3xx\winnt\forwin.h ===
/***************************************************************************
 * File:          forwin.h
 * Description:   This file include major constant definition and
 *				  global for windows drivers.
 *				  
 * Author:        DaHai Huang    (DH)
 * Dependence:    none
 * Copyright (c)  2000 HighPoint Technologies, Inc. All rights reserved
 * History:
 *		11/08/2000	HS.Zhang	Added this header
 *		11/14/2000	HS.Zhang	Added m_nWinXferModeSetting member in
 *								HW_DEVICE_EXTENSION.
 *		11/22/2000	SLeng		Changed OS_Identify(x) to OS_Identify(pDev)
 *
 ***************************************************************************/
#ifndef _FORWIN_H_
#define _FORWIN_H_

#ifndef _BIOS_
//#define USE_PCI_CLK					// will use PCI clk to write date, mean 66Mhz

#ifndef USE_PCI_CLK
#define DPLL_SWITCH						// switch clk between read and write (only for 370)

#define FORCE_133                       /* 372 only, ignore on HPT370 */
//#define FORCE_100						// force use true ATA100 clock,
										// if undef this macro, will
										// use 9xMhz clk instead of 100mhz
//#define SUPPORT_HPT601										

#endif

/************************************************************************
**       FUNCTION SELECT
*************************************************************************/

#ifdef  WIN95
//#define SUPPORT_HPT370_2DEVNODE
#define SUPPORT_XPRO
//#define SUPPORT_HOTSWAP								 

// BUG FIX: create a internal buffer for small data block
//				otherwise it causes data compare error
#define SUPPORT_INTERNAL_BUFFER
#endif

//#define SUPPORT_TCQ
// gmm 2001-4-20 mark out for Adaptec
//#define SUPPORT_ATAPI


#pragma intrinsic (memset, memcpy)
#define ZeroMemory(a, b) memset(a, 0, b)

#define FAR

/************************************************************************
**  Special define for windows
*************************************************************************/

#define LOC_IDENTIFY IDENTIFY_DATA Identify;
#define ARG_IDENTIFY    , (PUSHORT)&Identify
#define LOC_ARRAY_BLK   ArrayBlock ArrayBlk
#define ARG_ARRAY_BLK	, (PUSHORT)&ArrayBlk
#define DECL_BUFFER     , PUSHORT tmpBuffer
#define ARG_BUFFER      , tmpBuffer 
#define DECL_SRB        , PSCSI_REQUEST_BLOCK Srb
#define ARG_SRB         , Srb
#define LOC_SRBEXT_PTR  PSrbExtension  pSrbExt = (PSrbExtension)Srb->SrbExtension;
#define DECL_SRBEXT_PTR , struct _SrbExtension  *pSrbExt
#define ARG_SRBEXT_PTR  , pSrbExt
#define ARG_SRBEXT(Srb)	, Srb->SrbExtension
#define LOC_SRB         PSCSI_REQUEST_BLOCK Srb = pChan->CurrentSrb;
#define WIN_DFLAGS      | DFLAGS_TAPE_RDP | DFLAGS_SET_CALL_BACK 
#define BIOS_IDENTIFY
#define BIOS_2STRIPE_NOTIFY
#define BIOS_CHK_TMP(x)
#define ARG_OS_EXT , PHW_DEVICE_EXTENSION HwDeviceExtension

/***************************************************************************
 * Description: include
 ***************************************************************************/
#include "miniport.h"

#ifndef WIN95	   
#include "devioctl.h"
#endif

#include "srb.h"
#include "scsi.h"

#include "stypes.h"						// share typedefs for window and bios

#ifdef WIN95
#ifndef __vtoolsc_h_
#include <dcb.h>
#include <ddb.h>
#include "ior.h"
#include "iop.h"
#endif

typedef struct _st_SRB_IO_CONTROL {
	ULONG HeaderLength;
	UCHAR Signature[8];
	ULONG Timeout;
	ULONG ControlCode;
	ULONG ReturnCode;
	ULONG Length;
} SRB_IO_CONTROL, *PSRB_IO_CONTROL;

#else

#include "ntdddisk.h"
#include "ntddscsi.h"

#endif

#include  "hptchip.h"
#include  "atapi.h"
#include  "device.h"
#include  "array.h"

typedef struct _logical_device {
	UCHAR   isArray;
	UCHAR   isValid;
	UCHAR	isInUse;
	UCHAR   reserved;
	PVOID   pLD;
}
LOGICAL_DEVICE;

typedef void (*HPT_DPC)(void*);
typedef struct st_HPT_DPC {
	HPT_DPC dpc;
	void *arg;
} ST_HPT_DPC;

typedef struct _HW_DEVICE_EXTENSION {
	Channel   IDEChannel[2];
	UCHAR    pci_bus, pci_dev;
	USHORT   dpll66 : 1;
	USHORT   MultipleRequestPerLu : 1;
	USHORT   dpc_pending: 1;
	USHORT   reservebits: 13;
	ULONG    io_space[5];
	UCHAR    pci_reg_0c;
	UCHAR    pci_reg_0d;
	USHORT   reserved2;
	VirtualDevice   _VirtualDevices[MAX_DEVICES_PER_CHIP];
	PVirtualDevice  _pLastVD;
	LOGICAL_DEVICE  _LogicalDevices[MAX_DEVICES_PER_CHIP];
	
	#define MAX_DPC 8
	ST_HPT_DPC DpcQueue[MAX_DPC];
	int DpcQueue_First;
	int DpcQueue_Last;
	
	#define MAX_PENDING_REQUESTS 32
	PSCSI_REQUEST_BLOCK PendingRequests[MAX_PENDING_REQUESTS];
	ULONG EmptyRequestSlots;

#ifdef WIN95
    #define ScsiStopAdapter 		1
    #define ScsiRestartAdapter 		2
    #define ScsiSetBootConfig 		3
    #define ScsiSetRunningConfig 	4
    #define ScsiAdapterControlSuccess 0
    #define ScsiAdapterControlUnsuccessful 1
	int (_stdcall *g_fnAdapterControl)(struct _HW_DEVICE_EXTENSION *ext, int type);
	int need_reinit;
#endif
} HW_DEVICE_EXTENSION, *PHW_DEVICE_EXTENSION;

#define VirtualDevices (HwDeviceExtension->_VirtualDevices)
#define LogicalDevices (HwDeviceExtension->_LogicalDevices)

extern HANDLE	g_hAppNotificationEvent;	// the event handle to notify application
extern PDevice	g_pErrorDevice;				// the most recent device which occurs errors

int hpt_queue_dpc(PHW_DEVICE_EXTENSION HwDeviceExtension, HPT_DPC dpc, void *arg);

/************************************************************************
**                  Rename	& Macro
*************************************************************************/

#define OutDWord(x, y)    ScsiPortWritePortUlong((PULONG)(x), y)
#define InDWord(x)        ScsiPortReadPortUlong((PULONG)(x))
#define OutPort(x, y)     ScsiPortWritePortUchar((PUCHAR)(x), y)
#define InPort(x)         ScsiPortReadPortUchar((PUCHAR)(x))
#define OutWord(x, y)     ScsiPortWritePortUshort((PUSHORT)(x), y)
#define InWord(x)         ScsiPortReadPortUshort((PUSHORT)(x))
#define RepINS(x,y,z)     ScsiPortReadPortBufferUshort(&x->Data, (PUSHORT)y, z)
#define RepOUTS(x,y,z)    ScsiPortWritePortBufferUshort(&x->Data, (PUSHORT)y, z)
#define RepINSD(x,y,z)    ScsiPortReadPortBufferUlong((PULONG)&x->Data, (PULONG)y, (z) >> 1)
#define RepOUTSD(x,y,z)   ScsiPortWritePortBufferUlong((PULONG)&x->Data, (PULONG)y, (z) >> 1)
#define OS_RepINS(x,y,z)  RepINS(x,y,z)
#define StallExec(x)      ScsiPortStallExecution(x)

#if 0
#define DEBUG_POINT(x) OutDWord(0xcf4, 0xAA550000|(x))
#else
#define DEBUG_POINT(x)
#endif

/***************************************************************************
 * Windows global data
 ***************************************************************************/

extern char HPT_SIGNATURE[];
extern ULONG excluded_flags;

#ifdef SUPPORT_INTERNAL_BUFFER
int  Use_Internal_Buffer(
						 IN PSCAT_GATH psg,
						 IN PSCSI_REQUEST_BLOCK Srb
						);
VOID Create_Internal_Buffer(PHW_DEVICE_EXTENSION HwDeviceExtension);
VOID CopyTheBuffer(PSCSI_REQUEST_BLOCK Srb);
#define CopyInternalBuffer(Srb) \
		if(((PSrbExtension)(Srb->SrbExtension))->WorkingFlags & SRB_WFLAGS_USE_INTERNAL_BUFFER)\
			CopyTheBuffer(Srb); else

#else //Not SUPPORT_INTERNAL_BUFFER
#define Use_Internal_Buffer(psg, Srb) 0
#define Create_Internal_Buffer(HwDeviceExtension)
#define CopyInternalBuffer(Srb)
#endif

#ifdef SUPPORT_TCQ
#define SetMaxCmdQueue(x, y) x->MaxQueue = (UCHAR)(y)
#else //Not SUPPORT_TCQ
#define SetMaxCmdQueue(x, y)
#endif // SUPPORT_TCQ


#ifdef SUPPORT_HOTSWAP
void CheckDeviceReentry(PChannel pChan, PSCSI_REQUEST_BLOCK Srb);
#else //Not SUPPORT_HOTSWAP
#define CheckDeviceReentry(pChan, Srb)
#endif //SUPPORT_HOTSWAP

#ifdef SUPPORT_XPRO
extern int  need_read_ahead;
VOID _cdecl start_ifs_hook(PCHAR pDriveName);
void _cdecl end_ifs_hook();
#else	 // Not 	SUPPORT_XPRO
#define start_ifs_hook(a)
#define end_ifs_hook()
#endif //SUPPORT_XPRO

/***************************************************************************
 * Windows Function prototype special for WIn98 /NT2k
 ***************************************************************************/

__inline void __enable(void) {
	_asm  sti  
}
__inline int __disable(void) {
	_asm { pushfd
			pop  eax
			test eax, 200h
			jz   disable_out
			cli
disable_out:
	}
}

#define ENABLE   if (old_flag & 0x200) { __enable();} else;
#define DISABLE  { old_flag = __disable();}
#define OLD_IRQL int old_flag;

#ifdef WIN95 //++++++++++++++++++++

#define Nt2kHwInitialize(pDevice)

#else // NT2K ++++++++++++++++++++

VOID  Nt2kHwInitialize(PDevice pDevice);

void IdeSendSmartCommand(IN PDevice pDev, IN PSCSI_REQUEST_BLOCK Srb);
PSCSI_REQUEST_BLOCK BuildMechanismStatusSrb (IN PChannel pChan,
											 IN ULONG PathId, IN ULONG TargetId);
PSCSI_REQUEST_BLOCK BuildRequestSenseSrb (IN PChannel pChan,
										  IN ULONG PathId, IN ULONG TargetId);

#ifdef WIN2000
SCSI_ADAPTER_CONTROL_STATUS AtapiAdapterControl(
												IN PHW_DEVICE_EXTENSION deviceExtension,
												IN SCSI_ADAPTER_CONTROL_TYPE ControlType,
												IN PVOID Parameters);
#endif //WIN2000

#endif //WIN95


/***************************************************************************
 * Windows Function prototype
 ***************************************************************************/


/* win95.c / winnt.c */
#ifdef SUPPORT_ATAPI
VOID  Start_Atapi(PDevice pDev DECL_SRB);
BOOLEAN AtapiInterrupt(PDevice pDev);
#endif


/* win.c */
UCHAR pci_read_config_byte(UCHAR bus, UCHAR dev, UCHAR func, UCHAR reg);
void pci_write_config_byte(UCHAR bus, UCHAR dev, UCHAR func, UCHAR reg, UCHAR v);
DWORD pci_read_config_dword(UCHAR bus, UCHAR dev, UCHAR func, UCHAR reg);
void pci_write_config_dword(UCHAR bus, UCHAR dev, UCHAR func, UCHAR reg, DWORD v);

ULONG DriverEntry(IN PVOID DriverObject, IN PVOID Argument2);
BOOLEAN AtapiStartIo(IN PHW_DEVICE_EXTENSION HwDeviceExtension, 
					 IN PSCSI_REQUEST_BLOCK Srb);
BOOLEAN AtapiHwInterrupt370(IN PChannel pChan);
BOOLEAN AtapiAdapterState(IN PVOID HwDeviceExtension, IN PVOID Context, 
						  IN BOOLEAN SaveState);
VOID AtapiCallBack(IN PChannel);
VOID AtapiCallBack370(IN PChannel);
BOOLEAN AtapiHwInitialize370(IN PHW_DEVICE_EXTENSION HwDeviceExtension);
BOOLEAN AtapiResetController(IN PHW_DEVICE_EXTENSION HwDeviceExtension, 
							 IN ULONG PathId);
ULONG AtapiFindController(
							 IN PHW_DEVICE_EXTENSION HwDeviceExtension,
							 IN PVOID Context,
							 IN PVOID BusInformation,
							 IN PCHAR ArgumentString,
							 IN OUT PPORT_CONFIGURATION_INFORMATION ConfigInfo,
							 OUT PBOOLEAN Again
							);
void do_dpc_routines(PHW_DEVICE_EXTENSION HwDeviceExtension);
void disk_failed_dpc(PDevice pDev);
void disk_plugged_dpc(PDevice pDev);

/* winio.c  */
void WinStartCommand(IN PDevice pDev, IN PSCSI_REQUEST_BLOCK Srb);
void CheckNextRequest(PChannel pChan, PDevice pWorkDev);
int  __fastcall btr (ULONG locate);
void  __fastcall bts (ULONG locate);
ULONG __fastcall MapLbaToCHS(ULONG Lba, WORD sectorXhead, BYTE head);
void IdeSendCommand(IN PDevice pDev, IN PSCSI_REQUEST_BLOCK Srb);
VOID IdeMediaStatus(BOOLEAN EnableMSN, IN PDevice pDev);
UCHAR IdeBuildSenseBuffer(IN PDevice pDev, IN PSCSI_REQUEST_BLOCK Srb);

PVirtualDevice Array_alloc(PHW_DEVICE_EXTENSION HwDeviceExtension);
void Array_free(PVirtualDevice pArray);
/*
 * for notify application
 * If for Win95, follow function are stored in xpro.c
 * else, follow functions are stored in winlog.c
 */	 
HANDLE __stdcall PrepareForNotification(HANDLE hEvent);
void __stdcall NotifyApplication(HANDLE hEvent);
void __stdcall CloseNotifyEventHandle(HANDLE hEvent);

LONG __stdcall GetCurrentTime();
LONG __stdcall GetCurrentDate();

#define IS_RDP(OperationCode)\
							 ((OperationCode == SCSIOP_ERASE)||\
							 (OperationCode == SCSIOP_LOAD_UNLOAD)||\
							 (OperationCode == SCSIOP_LOCATE)||\
							 (OperationCode == SCSIOP_REWIND) ||\
							 (OperationCode == SCSIOP_SPACE)||\
							 (OperationCode == SCSIOP_SEEK)||\
							 (OperationCode == SCSIOP_WRITE_FILEMARKS))

#pragma pack(push, 1)
typedef struct {
	UCHAR      status;     /* 0 nonbootable; 80h bootable */
	UCHAR      start_head;
	USHORT     start_sector;
	UCHAR      type;
	UCHAR      end_head;
	USHORT     end_sector;
	ULONG      start_abs_sector;
	ULONG      num_of_sector;
} partition;

struct fdisk_partition_table {
	unsigned char bootid;   /* bootable?  0=no, 128=yes  */
	unsigned char beghead;  /* beginning head number */
	unsigned char begsect;  /* beginning sector number */
	unsigned char begcyl;   /* 10 bit nmbr, with high 2 bits put in begsect */	
	unsigned char systid;   /* Operating System type indicator code */
	unsigned char endhead;  /* ending head number */
	unsigned char endsect;  /* ending sector number */
	unsigned char endcyl;   /* also a 10 bit nmbr, with same high 2 bit trick */
	int relsect;            /* first sector relative to start of disk */
	int numsect;            /* number of sectors in partition */
};
struct master_boot_record {
	char    bootinst[446];   /* space to hold actual boot code */
	struct fdisk_partition_table parts[4];
	unsigned short  signature;       /* set to 0xAA55 to indicate PC MBR format */
};
#pragma pack(pop)

//
// Find adapter context structure
//
typedef struct _HPT_FIND_CONTEXT{	  
	ULONG	nAdapterCount;
	PCI_SLOT_NUMBER	nSlot;
	ULONG	nBus;
}HPT_FIND_CONTEXT, *PHPT_FIND_CONTEXT;

/************************************************************************
**  Special define for windows
*************************************************************************/

#define LongDivLShift(x, y, z)  ((x / (ULONG)y) << z)
#define LongRShift(x, y)  (x  >> y)
#define LongRem(x, y)	  (x % (ULONG)y)
#define LongMul(x, y)	  (x * (ULONG)y)
#define MemoryCopy(x,y,z) memcpy((char *)(x), (char *)(y), z)
#define OS_Array_Check(pDevice)
#define OS_RemoveStrip(x)

#define OS_Identify(pDev)  ScsiPortMoveMemory((char *)&pDev->IdentifyData,\
						(char *)&Identify, sizeof(IDENTIFY_DATA2))

#define OS_Busy_Handle(pChan, pDev) { ScsiPortNotification(RequestTimerCall, \
									pChan->HwDeviceExtension, pChan->CallBack, 1000); \
									pDev->DeviceFlags |= DFLAGS_SET_CALL_BACK;	}

#define OS_Reset_Channel(pChan) \
								AtapiResetController(pChan->HwDeviceExtension,Srb->PathId);

#if 0
extern int __cdecl printk(const char *fmt, ...);
#define KdPrint(_x_) printk _x_
#else
#define KdPrint(_x_)
#endif

__inline BOOLEAN MarkPendingRequest(PHW_DEVICE_EXTENSION HwDeviceExtension, PSCSI_REQUEST_BLOCK Srb)
{
	ULONG i=HwDeviceExtension->EmptyRequestSlots;
	if (i==0) return 0;
	_asm bsf eax, i;
	_asm mov i, eax;
	HwDeviceExtension->PendingRequests[i] = Srb;
	HwDeviceExtension->EmptyRequestSlots &= ~(1<<i);
	((PSrbExtension)Srb->SrbExtension)->RequestSlot = (UCHAR)i;
	return 1;
}

__inline void ClearPendingRequest(PHW_DEVICE_EXTENSION HwDeviceExtension, PSCSI_REQUEST_BLOCK Srb)
{
	UCHAR i = ((PSrbExtension)Srb->SrbExtension)->RequestSlot;
	if (i!=0xFF) HwDeviceExtension->EmptyRequestSlots |= (1<<i);
}

__inline void OS_EndCmd_Interrupt(PChannel pChan DECL_SRB)
{
	PSrbExtension pSrbExtension = (PSrbExtension)(Srb->SrbExtension);
	PHW_DEVICE_EXTENSION HwDeviceExtension = pChan->HwDeviceExtension;
	
#ifdef BUFFER_CHECK
	void CheckBuffer(PSCSI_REQUEST_BLOCK pSrb);
	CheckBuffer(Srb);
#endif //BUFFER_CHECK

	if(pSrbExtension->WorkingFlags & SRB_WFLAGS_HAS_CALL_BACK){
		pSrbExtension->pfnCallBack(HwDeviceExtension, Srb);
	}
	
	ClearPendingRequest(HwDeviceExtension, Srb);
	
	if (HwDeviceExtension->EmptyRequestSlots==0xFFFFFFFF) {
		do_dpc_routines(HwDeviceExtension);
	}
	
	ScsiPortNotification(RequestComplete, HwDeviceExtension, Srb);
	
	if (HwDeviceExtension->dpc_pending) return;
	
	if (HwDeviceExtension->MultipleRequestPerLu)
		ScsiPortNotification(NextLuRequest, HwDeviceExtension, 
			Srb->PathId, Srb->TargetId, Srb->Lun);
	else
		ScsiPortNotification(NextRequest, HwDeviceExtension);
}			   

__inline PSCSI_REQUEST_BLOCK GetCommandFromQueue(PDevice pDev)
{
	PSCSI_REQUEST_BLOCK Srb=0;
	if (pDev->queue_first!=pDev->queue_last) {
		Srb = pDev->wait_queue[pDev->queue_first];
		pDev->queue_first++;
		pDev->queue_first %= MAX_DEVICE_QUEUE_LENGTH;
	}
	return Srb;
}

__inline BOOLEAN PutCommandToQueue(PDevice pDev, PSCSI_REQUEST_BLOCK Srb)
{
	int p = (pDev->queue_last+1) % MAX_DEVICE_QUEUE_LENGTH;
	if (p==pDev->queue_first)
		return FALSE;
	pDev->wait_queue[pDev->queue_last] = Srb;
	pDev->queue_last = (USHORT)p;
	return TRUE;
}

#define _fmemcpy(dst, src, size) memcpy(dst, src, size)

struct _Mode_6 {
	UCHAR DataLength;
	UCHAR Type;
	UCHAR Flag;
	UCHAR BlockSize;
	UCHAR LBA[4];
	UCHAR Density;
	UCHAR Length[3];
};

#endif //_BIOS_
#endif //_FORWIN_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\port\scsi\miniport\hipoint\hpt3xx\winnt\global.h ===
/***************************************************************************
 * File:          Global.h
 * Description:   This file include major constant definition and global
 *                functions and data.
 *                (1) Array Information in disk.
 *                (2) Srb Extension for array operation 
 *                (3) Virtual disk informatiom
 * Author:        DaHai Huang    (DH)
 * Dependence:    none
 * Copyright (c)  2000 HighPoint Technologies, Inc. All rights reserved
 * History:
 *		05/10/2000	DH.Huang	initial code
 *		11/06/2000	HS.Zhang	change the parameter in IdeHardReset
 *								routin.
 *		11/09/2000	GengXin(GX) add function declare for display flash
 *                              character in biosinit.c
 *		11/14/2000	HS.Zhang	Change the FindDevice function's
 *								Arguments
 ***************************************************************************/


#ifndef _GLOBAL_H_
#define _GLOBAL_H_

/***************************************************************************
 * Description: Function Selection
 ***************************************************************************/

//#define NOT_ISSUE_37

#define USE_MULTIPLE           // Support Read/Write Multiple command
#define USE_DMA                // Support DMA operation
#define SUPPORT_ARRAY          // Support Array Function
#define SUPPORT_48BIT_LBA

/***************************************************************************
 * Description: 
 ***************************************************************************/

#define MAX_MEMBERS       7    // Maximum members in an array 

#ifdef _BIOS_
#define MAX_HPT_BOARD     1
#else
#define MAX_HPT_BOARD     4    // Max Board we can supported in system
#endif

#define MAX_DEVICES_PER_CHIP  4
#define MAX_DEVICES       (MAX_HPT_BOARD * 4) // Each board has four device

#define MAX_V_DEVICE   MAX_DEVICES

#define DEFAULT_TIMING    0	 // Use Mode-0 as default timing

/************************************************************************
**                  Constat definition                                  *
*************************************************************************/

#define TRUE             1
#define FALSE            0

/* Don't use this, it will conflict with system defines */
//#define SUCCESS          0
//#define FAILED          -1

/* pasrameter for MaptoSingle */
#define REMOVE_ARRAY      1    // Remove this array forever
#define REMOVE_DISK       2    // Remove mirror disk from the array

/* return for CreateArray */
#define RELEASE_TABLE     0	 // Create array success and release array table
#define KEEP_TABLE        1    // Create array success and keep array table
#define MIRROR_SMALL_SIZE 2    // Create array failure and release array table

/* excluded_flags */
#define EXCLUDE_HPT366    0
#define EXCLUDE_BUFFER    15

/***************************************************************************
 * Description: include
 ***************************************************************************/

#include  "ver.h"

#ifdef _BIOS_

#include  "fordos.h"
#define DisableBoardInterrupt(x) 
#define EnableBoardInterrupt(x)	

/* gmm 2001-4-17
 *  DELL systems must use SG table under 640K memory
 *  Copy SG table to 640K base memory at initialization time 
 */
#define SetSgPhysicalAddr(pChan) \
	do {\
		if (pChan->SgPhysicalAddr)\
        	OutDWord((PULONG)(pChan->BMI + BMI_DTP), pChan->SgPhysicalAddr);\
        else {\
        	PSCAT_GATH p = pChan->pSgTable;\
        	SCAT_GATH _far *pFarSg = (SCAT_GATH _far *) \
        		(((rebuild_sg_phys & 0xF0000)<<12) | (rebuild_sg_phys & 0xFFFF)); \
        	while(1) {\
        		*pFarSg = *p;\
        		if (p->SgFlag) break;\
        		pFarSg++; p++;\
        	}\
        	OutDWord((PULONG)(pChan->BMI + BMI_DTP), rebuild_sg_phys);\
        }\
	} while (0)

#else

#include  "forwin.h" 
#define DisableBoardInterrupt(x) OutPort(x+0x7A, 0x10)
#define EnableBoardInterrupt(x)	OutPort(x+0x7A, 0x0)

#define SetSgPhysicalAddr(pChan) \
        OutDWord((PULONG)(pChan->BMI + BMI_DTP), pChan->SgPhysicalAddr)

#endif

/***************************************************************************
 * Global Data
 ***************************************************************************/

/* see data.c */

extern ULONG setting370_50_133[];
extern ULONG setting370_50_100[];
extern ULONG setting370_33[];
#ifdef _BIOS_
extern PVirtualDevice  pLastVD;
#else
#define pLastVD (HwDeviceExtension->_pLastVD)
#endif
extern UCHAR  Hpt_Slot;
extern UCHAR  Hpt_Bus;
extern UINT exlude_num;

/***************************************************************************
 * Function prototype
 ***************************************************************************/


/*
 * ata.c 
 */
BOOLEAN AtaPioInterrupt(PDevice pDevice);
void StartIdeCommand(PDevice pDevice DECL_SRB);
void NewIdeCommand(PDevice pDevice DECL_SRB);
void NewIdeIoCommand(PDevice pDevice DECL_SRB);

/* atapi.c */
#ifdef SUPPORT_ATAPI
void AtapiCommandPhase(PDevice pDevice DECL_SRB);
void StartAtapiCommand(PDevice pDevice DECL_SRB);
void AtapiInterrupt(PDevice pDev);
#endif

/* finddev.c */
/*
 *Changed By HS.Zhang
 *Added a parameter for windows driver dma settings
 */
int FindDevice(PDevice pDev, ST_XFER_TYPE_SETTING osAllowedDeviceXferMode);

/*
 * io.c
 */
UCHAR WaitOnBusy(PIDE_REGISTERS_2 BaseIoAddress) ;
UCHAR  WaitOnBaseBusy(PIDE_REGISTERS_1 BaseIoAddress);
UCHAR WaitForDrq(PIDE_REGISTERS_2 BaseIoAddress) ;
void AtapiSoftReset(PIDE_REGISTERS_1 BaseIoAddress, 
     PIDE_REGISTERS_2 BaseIoAddress2, UCHAR DeviceNumber) ;

/* gmm 2001-4-3 merge BMA fix
 * Changed by HS.Zhang
 * It's better that we check the DriveSelect register in reset flow.
 * That will make the reset process more safe.
 */
int  IdeHardReset(PIDE_REGISTERS_1 IoAddr1, PIDE_REGISTERS_2 BaseIoAddress);

UINT GetMediaStatus(PDevice pDev);
UCHAR NonIoAtaCmd(PDevice pDev, UCHAR cmd);
UCHAR SetAtaCmd(PDevice pDev, UCHAR cmd);
int ReadWrite(PDevice pDev, ULONG Lba, UCHAR Cmd DECL_BUFFER);
UCHAR StringCmp (PUCHAR FirstStr, PUCHAR SecondStr, UINT Count);
int IssueIdentify(PDevice pDev, UCHAR Cmd DECL_BUFFER);
void DeviceSelectMode(PDevice pDev, UCHAR NewMode);
void SetDevice(PDevice pDev);
void IdeResetController(PChannel pChan);
void FlushDrive(PDevice pDev, ULONG flag);
void FlushArray(PVirtualDevice pArray, ULONG flag);
void DeviceSetting(PChannel pChan, ULONG devID);
void ArraySetting(PVirtualDevice pArray);

/*
 * hptchip.c
 */
UCHAR Check_suppurt_Ata100(PDevice pDev, UCHAR mode);
PBadModeList check_bad_disk(char *ModelNumber, PChannel pChan);
PUCHAR ScanHptChip(IN PChannel deviceExtension,
    IN OUT PPORT_CONFIGURATION_INFORMATION ConfigInfo);
void SetHptChip(PChannel Primary, PUCHAR BMI);


/* array.c */
void ArrayInterrupt(PDevice pDev DECL_SRB);
void StartArrayIo(PVirtualDevice pArray DECL_SRB);
void CheckArray(IN PDevice pDevice ARG_OS_EXT);
void MaptoSingle(PVirtualDevice pArray, int flag) ;
void DeleteArray(PVirtualDevice pArray);
int  CreateArray(PVirtualDevice pArray, int flags);
void CreateSpare(PVirtualDevice pArray, PDevice pDev);
void Final_Array_Check(int no_use ARG_OS_EXT);
void check_bootable(PDevice pDevice);

/* stripe.c */
void Stripe_SG_Table(PDevice pDevice, PSCAT_GATH p DECL_SRBEXT_PTR);
void Stripe_Prepare(PVirtualDevice pArray DECL_SRBEXT_PTR);
void Stripe_Lba_Sectors(PDevice pDevice DECL_SRBEXT_PTR);

/* span.c */
void Span_SG_Table(PDevice pDevice, PSCAT_GATH p DECL_SRBEXT_PTR);
void Span_Prepare(PVirtualDevice pArray DECL_SRBEXT_PTR);
void Span_Lba_Sectors(PDevice pDevice DECL_SRBEXT_PTR);


/*  interrupt.c */
UCHAR DeviceInterrupt(PDevice pDev, PSCSI_REQUEST_BLOCK abortSrb);

/* OS Functions */
int   BuildSgl(PDevice pDev, PSCAT_GATH p DECL_SRB);
UCHAR MapAtaErrorToOsError(UCHAR errorcode DECL_SRB);
UCHAR MapAtapiErrorToOsError(UCHAR errorcode DECL_SRB);
BOOLEAN Atapi_End_Interrupt(PDevice pDevice DECL_SRB);

/*  biosutil.c */
//Add by GX, for display character in biosinit.c
void GD_Text_show_EnableFlash( int x, int y,char * szStr, int width, int color );

/* Minimum and maximum macros */
#define MAX(a, b)	(((a) > (b)) ? (a) : (b))
#define MIN(a, b)	(((a) < (b)) ? (a) : (b))  

/***************************************************************************
 * Define for beatufy
 ***************************************************************************/

#define GetStatus(IOPort2)           (UCHAR)InPort(&IOPort2->AlternateStatus)
#define UnitControl(IOPort2, Value)  OutPort(&IOPort2->AlternateStatus,(UCHAR)(Value))

#define GetErrorCode(IOPort)         (UCHAR)InPort((PUCHAR)&IOPort->Data+1)
#define SetFeaturePort(IOPort,x)     OutPort((PUCHAR)&IOPort->Data+1, x)
#define SetBlockCount(IOPort,x)      OutPort(&IOPort->BlockCount, x)
#define GetInterruptReason(IOPort)   (UCHAR)InPort(&IOPort->BlockCount)
#define SetBlockNumber(IOPort,x)     OutPort(&IOPort->BlockNumber, x)
#define GetBlockNumber(IOPort)       (UCHAR)InPort((PUCHAR)&IOPort->BlockNumber)
#define GetByteLow(IOPort)           (UCHAR)InPort(&IOPort->CylinderLow)
#define SetCylinderLow(IOPort,x)         OutPort(&IOPort->CylinderLow, x)
#define GetByteHigh(IOPort)          (UCHAR)InPort(&IOPort->CylinderHigh)
#define SetCylinderHigh(IOPort,x)    OutPort(&IOPort->CylinderHigh, x)
#define GetBaseStatus(IOPort)        (UCHAR)InPort(&IOPort->Command)
/*
 * RocketMate need write twice to drive/head register
 */
#define SelectUnit(IOPort,UnitId) \
	do { \
		OutPort(&IOPort->DriveSelect, (UCHAR)(UnitId));\
		OutPort(&IOPort->DriveSelect, (UCHAR)(UnitId));\
	} while (0)
	
#define GetCurrentSelectedUnit(IOPort) (UCHAR)InPort(&IOPort->DriveSelect)
#define IssueCommand(IOPort,Cmd)     OutPort(&IOPort->Command, (UCHAR)(Cmd))

/******************************************************************
 * Reset IDE
 *******************************************************************/
#ifndef NOT_ISSUE_37
#ifdef  ISSUE_37_ONLY
#define Reset370IdeEngine(pChan, UnitId) \
			do { \
				if(pChan->ChannelFlags & IS_HPT_370) \
					OutPort(pChan->BMI + (((UINT)pChan->BMI & 0xF)? 0x6C : 0x70), 0x37); \
			} while(0)
#else //ISSUE_37_ONLY
void __inline Reset370IdeEngine(PChannel pChan, UCHAR UnitId)
{
	/* gmm 2001-6-18 
	 * HS.Zhang, 2001-6-15 
	 *   I made a mistake. I thought the P_RST or S_RST are only for reset purpose
	 *   before, but after checking with Dr.Lin, when tri-state IDE bus, the X_RST
	 *   would not be tri-stated as you wish, and if you reset the HPT370
	 *   state-machine, X_RST may assert a RESET signal. Please refer the table I put
	 *   in section 4.a, only when both tri-state bit and X_RST bit set as 1, the
	 *   X_RST can be tri-stated.
	 *   Currently, because most of user don't use P_RST or S_RST, so they don't met
	 *   the problem. Please check the original code back, and check X_RST signal
	 *   with LA.
	 *
	 * gmm 2001-4-3 merge BMA fix
	 * HS.Zhang, 2001/2/16
	 *   We don't need write 0x80 or 0x40 to port BaseBMI+0x79, the PRST&SRST
	 *   never use in our adapter, this two pins are reserved for HOTSWAP
	 *   adapter, write to this port may cause the HDD power lost on HOTSWAP
	 *   adapter.
	 */
	if (pChan->ChannelFlags & IS_HPT_372) {
		PUCHAR tmpBMI = pChan->BMI + (((UINT)pChan->BMI & 0xF)? 0x6C : 0x70);
		OutPort(tmpBMI+3, 0x80);
		OutPort(tmpBMI, 0x37);
		OutPort(tmpBMI+3, 0);
	}
	else {
		PULONG  SettingPort;
		ULONG   OldSettings, tmp;
		PUCHAR  tmpBMI = pChan->BMI + (((UINT)pChan->BMI & 0xF)? 0x6C : 0x70);
		PUCHAR tmpBaseBMI = pChan->BaseBMI+0x79;

		OutPort(tmpBMI+3, 0x80);
		// tri-state the IDE bus
		OutPort(tmpBaseBMI, (UCHAR)(((UINT)tmpBMI & 0xF)? 0x80 : 0x40));
		// reset state machine
		OutPort(tmpBMI, 0x37);
		StallExec(2);
		// thing to avoid PCI bus hang-up
		SettingPort= (PULONG)(pChan->BMI+((UnitId &0x10) >>2)+ 0x60);
		OldSettings= InDWord(SettingPort);
		tmp= OldSettings & 0xfffffff;
		OutDWord(SettingPort, (tmp|0x80000000));
		OutWord(pChan->BaseIoAddress1, 0x0);
		StallExec(10);
		OutPort(tmpBMI, 0x37);
		StallExec(2);
		OutDWord(SettingPort, OldSettings);
		// set IDE bus to normal state
		OutPort(tmpBaseBMI, 0);
		OutPort(tmpBMI+3, 0);
	}		
}
#endif //ISSUE_37_ONLY

void __inline Switching370Clock(PChannel pChan, UCHAR ucClockValue)
{
	if((InPort(pChan->NextChannelBMI + BMI_STS) & BMI_STS_ACTIVE) == 0){
		PUCHAR PrimaryMiscCtrlRegister = pChan->BaseBMI + 0x70;
		PUCHAR SecondaryMiscCtrlRegister = pChan->BaseBMI + 0x74;

		OutPort(PrimaryMiscCtrlRegister+3, 0x80); // tri-state the primary channel
		OutPort(SecondaryMiscCtrlRegister+3, 0x80); // tri-state the secondary channel
		
		OutPort((PUCHAR)((ULONG)pChan->BaseBMI+0x7B), ucClockValue); // switching the clock
		
		OutPort((PUCHAR)((ULONG)pChan->BaseBMI+0x79), 0xC0); // reset two channels begin	  
		
		OutPort(PrimaryMiscCtrlRegister, 0x37); // reset primary channel state machine
		OutPort(SecondaryMiscCtrlRegister, 0x37); // reset secordary channel state machine

		OutPort((PUCHAR)((ULONG)pChan->BaseBMI+0x79), 0x00); // reset two channels finished
		
		OutPort(PrimaryMiscCtrlRegister+3, 0x00); // normal-state the primary channel
		OutPort(SecondaryMiscCtrlRegister+3, 0x00); // normal-state the secondary channel
	}
}
#endif //NOT_ISSUE_37

// The timer counter used by function MonitorDisk(5000000us = 5000ms = 5s)
#define	MONTOR_TIMER_COUNT		5000000

#ifdef SUPPORT_HPT601			
void __inline BeginAccess601(PIDE_REGISTERS_1 IoPort) 
{
	int i;
	for(i=0; i<5; i++) InPort(&IoPort->CylinderLow);
	for(i=0; i<6; i++) InPort(&IoPort->CylinderHigh);
	for(i=0; i<5; i++) InPort(&IoPort->CylinderLow);
}
void __inline EndAccess601(PIDE_REGISTERS_1 IoPort)
{
	OutPort(&IoPort->BlockNumber, 0x80);
}
#endif

#endif //_GLOBAL_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\port\scsi\miniport\hipoint\hpt3xx\winnt\hptchip.h ===
/***************************************************************************
 * File:          hptchip.h
 * Description:   Definiation of PCI configuration register
 * Author:        Dahai Huang
 * Dependence:    None
 * Reference:     HPT 366/368/370 Manual
 * Copyright (c)  2000 HighPoint Technologies, Inc. All rights reserved
 * History:       DH 5/10/2000 initial code
 *
 ***************************************************************************/


#ifndef _HPTCHIP_H_
#define _HPTCHIP_H_

#include <pshpack1.h>

/***************************************************************************
 * Description:  PCI
 ***************************************************************************/

typedef struct _PCI1_CFG_ADDR {
    USHORT    reg_num : 8;          // Register number
    USHORT    fun_num : 3;          // function number (0-1)
    USHORT    dev_num : 5;          // device number (0-20)

    USHORT    bus_num : 8;          // bus number (0)
    USHORT    reserved: 7;
    USHORT    enable  : 1;

}  PCI1_CFG_ADDR, *PPCI1_CFG_ADDR;
																  
#define MAX_PCI_BUS_NUMBER		0x10	// Maximum PCI device number
#define MAX_PCI_DEVICE_NUMBER   0x20  // Maximum PCI device number

#define  CFG_INDEX	0xCF8
#define  CFG_DATA	0xCFC

/*
 * PCI config Register offset
 */
#define REG_VID             0x00    // vender identification register
#define REG_DID             0x02    // device identification register
#define REG_PCICMD          0x04    // command register
#define REG_PCISTS          0x06    // PCI device status register
#define REG_RID             0x08    // revision identification register
#define REG_PI              0x09    // programming interface register
#define REG_SUBC            0x0a    // sub class code register
#define REG_BCC             0x0b    // base class code register
#define REG_MLT             0x0d    // master latency timer register
#define REG_HEDT            0x0e    // header type register
#define REG_IOPORT0         0x10    //
#define REG_IOPORT1         0x14    //
#define REG_BMIBA           0x20    // bus master interface base address reg
#define REG_MISC            0x50    // brooklyn,MISC.control register


#define PCI_IOSEN           0x01    // Enable IO space
#define PCI_BMEN            0x04    // Enable IDE bus master


/*
 * Bus Master Interface
 */

#define BMI_CMD             0       // Bus master IDE command register offset
#define BMI_STS             2       // Bus master IDE status register offset
#define BMI_DTP             4       // Bus master IDE descriptor table
                                    // pointer register offset

#define BMI_CMD_STARTREAD   9       // Start write (read from disk)
#define BMI_CMD_STARTWRITE  1       // Start read (write to disk)
#define BMI_CMD_STOP        0       // Stop BM DMI

#define BMI_STS_ACTIVE      1       // RO:   bus master IDE active
#define BMI_STS_ERROR       2       // R/WC: IDE dma error
#define BMI_STS_INTR        4       // R/WC: interrupt happen
#define BMI_STS_DRV0EN      0x20    // R/W:  drive0 is capable of DMA xfer
#define BMI_STS_DRV1EN      0x40    // R/W:  drive1 is capable of DMA xfer


/***************************************************************************
 * Description:  Scatter-gather table
 ***************************************************************************/


typedef struct _SCAT_GATH
{
    ULONG   SgAddress;					// Physical address of main memory
    USHORT  SgSize;                 // length of this block
    USHORT  SgFlag;                 // 0 following next SG, 0x8000 last SG
}   SCAT_GATH, *PSCAT_GATH;

#define SG_FLAG_EOT         0x8000  /* End flag of SG list */

/* if we set to 17, why Win98 does not work correctly? */
#ifdef _BIOS_
#define MAX_SG_DESCRIPTORS   17
#else
#define MAX_SG_DESCRIPTORS   33   /* 17 -- 4K */
#endif

/***************************************************************************
 * HPT Special
 ***************************************************************************/
#define  SIGNATURE_370   0x41103
#define  SIGNATURE_372A  0x51103

/*
 * 370-370A timing 
 */

#define PIO_370MODE      0
#define DMA_370MODE      0x2
#define UDMA_370MODE     1

#define DATA_HIGH370(x)  ((ULONG)x)
#define DATA_LOW370(x)   ((ULONG)x << 4)
#define UDMA_CYCLE370(x) ((ULONG)x << 18)
#define DATA_PRE370(x)   ((ULONG)x << 22)
#define CTRL_ENA370(x)   ((ULONG)x << 28)

#define CMD_HIGH370(x)   ((ULONG)x << 9)
#define CMD_LOW370(x)    ((ULONG)x << 13)
#define CMD_PRE370(x)    ((ULONG)x << 25)

#define CLK50_PIO370     (CTRL_ENA370(PIO_370MODE)|CMD_PRE370(5)|CMD_LOW370(15)|CMD_HIGH370(10))

#define CLK50_370PIO0    (CLK50_PIO370|DATA_PRE370(3)|DATA_LOW370(8)|DATA_HIGH370(10))
#define CLK50_370PIO1    (CLK50_PIO370|DATA_PRE370(3)|DATA_LOW370(6)|DATA_HIGH370(5))
#define CLK50_370PIO2    (CLK50_PIO370|DATA_PRE370(2)|DATA_LOW370(5)|DATA_HIGH370(4))
#define CLK50_370PIO3    (CLK50_PIO370|DATA_PRE370(2)|DATA_LOW370(4)|DATA_HIGH370(3))
#define CLK50_370PIO4    (CLK50_PIO370|DATA_PRE370(2)|DATA_LOW370(4)|DATA_HIGH370(2))

#define CLK50_DMA370     (CTRL_ENA370(DMA_370MODE)|CMD_PRE370(1)|CMD_LOW370(4)|CMD_HIGH370(1))
#define CLK50_370DMA0    (CLK50_DMA370|DATA_PRE370(2)|DATA_LOW370(14)|DATA_HIGH370(10))
#define CLK50_370DMA1    (CLK50_DMA370|DATA_PRE370(2)|DATA_LOW370(5)|DATA_HIGH370(4))
#define CLK50_370DMA2    (CLK50_DMA370|DATA_PRE370(2)|DATA_LOW370(4)|DATA_HIGH370(2))

#define CLK50_UDMA370    (CTRL_ENA370(UDMA_370MODE)|CMD_PRE370(1)|CMD_LOW370(4)|CMD_HIGH370(1))
#define CLK50_370UDMA0   (CLK50_UDMA370|UDMA_CYCLE370(6)|DATA_LOW370(14)|DATA_HIGH370(10))
#define CLK50_370UDMA1   (CLK50_UDMA370|UDMA_CYCLE370(5)|DATA_LOW370(5)|DATA_HIGH370(4))
#define CLK50_370UDMA2   (CLK50_UDMA370|UDMA_CYCLE370(3)|DATA_LOW370(4)|DATA_HIGH370(2))
#define CLK50_370UDMA3   (CLK50_UDMA370|UDMA_CYCLE370(3)|DATA_PRE370(2)|DATA_LOW370(4)|DATA_HIGH370(2))
#define CLK50_370UDMA4   (CLK50_UDMA370|UDMA_CYCLE370(11)|DATA_PRE370(2)|DATA_LOW370(4)|DATA_HIGH370(2))
#define CLK50_370UDMA5   (CLK50_UDMA370|UDMA_CYCLE370(1)|DATA_PRE370(2)|DATA_LOW370(4)|DATA_HIGH370(2))

#define CLK33_PIOCMD370  (CTRL_ENA370(PIO_370MODE)|CMD_PRE370(3)|CMD_LOW370(10)|CMD_HIGH370(7))
#define CLK33_370PIO0    (CLK33_PIOCMD370|DATA_PRE370(2)|DATA_LOW370(10)|DATA_HIGH370(7))
#define CLK33_370PIO1    (CLK33_PIOCMD370|DATA_PRE370(2)|DATA_LOW370(9)|DATA_HIGH370(3))
#define CLK33_370PIO2    (CLK33_PIOCMD370|DATA_PRE370(1)|DATA_LOW370(5)|DATA_HIGH370(3))
#define CLK33_370PIO3    (CLK33_PIOCMD370|DATA_PRE370(1)|DATA_LOW370(4)|DATA_HIGH370(2))
#define CLK33_370PIO4    (CLK33_PIOCMD370|DATA_PRE370(1)|DATA_LOW370(3)|DATA_HIGH370(1))

#define CLK33_DMACMD370  (CTRL_ENA370(DMA_370MODE)|CMD_PRE370(1)|CMD_LOW370(3)|CMD_HIGH370(6))
#define CLK33_370DMA0    (CLK33_DMACMD370|DATA_PRE370(1)|DATA_LOW370(9)|DATA_HIGH370(7))
#define CLK33_370DMA1    (CLK33_DMACMD370|DATA_PRE370(1)|DATA_LOW370(3)|DATA_HIGH370(3))
#define CLK33_370DMA2    (CLK33_DMACMD370|DATA_PRE370(1)|DATA_LOW370(3)|DATA_HIGH370(1))

#define CLK33_UDMACMD370 (CTRL_ENA370(UDMA_370MODE)|CMD_PRE370(1)|CMD_LOW370(3)|CMD_HIGH370(1))
#define CLK33_370UDMA0   (CLK33_UDMACMD370|UDMA_CYCLE370(4)|DATA_PRE370(1)|DATA_LOW370(9)|DATA_HIGH370(7))
#define CLK33_370UDMA1   (CLK33_UDMACMD370|UDMA_CYCLE370(3)|DATA_PRE370(1)|DATA_LOW370(3)|DATA_HIGH370(3))
#define CLK33_370UDMA2   (CLK33_UDMACMD370|UDMA_CYCLE370(2)|DATA_PRE370(1)|DATA_LOW370(3)|DATA_HIGH370(1))
#define CLK33_370UDMA3   (CLK33_UDMACMD370|UDMA_CYCLE370(11)|DATA_PRE370(1)|DATA_LOW370(3)|DATA_HIGH370(1))
#define CLK33_370UDMA4   (CLK33_UDMACMD370|UDMA_CYCLE370(1)|DATA_PRE370(1)|DATA_LOW370(3)|DATA_HIGH370(1))
//#define CLK33_370UDMA5    0x1a85f442
#define CLK33_370UDMA5   (CLK33_UDMACMD370|UDMA_CYCLE370(1)|DATA_PRE370(1)|DATA_LOW370(3)|DATA_HIGH370(1))


#include <poppack.h>
#endif //_HPTCHIP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\port\scsi\miniport\hipoint\hpt3xx\winnt\hptchip.c ===
/***************************************************************************
 * File:          Hptchip.c
 * Description:   This module include searching routines for scan PCI
 *				  devices
 * Author:        DaHai Huang    (DH)
 * Dependence:    none
 * Copyright (c)  2000 HighPoint Technologies, Inc. All rights reserved
 * History:
 *		11/06/2000	HS.Zhang	Added this header
 ***************************************************************************/
#include "global.h"

#define PCI_F_INDEX(nClkCount) \
	((nClkCount < 0x9C) ? 0 : \
	 (nClkCount < 0xb0) ? 1 : \
	 (nClkCount < 0xc8) ? 2 : 3)

int pci_xx_f[][4] = {
	{ 0x23, 0x29, 0x2D, 0x42 }, /* use 9xMhz clk instead of 100mhz */
	{ 0x20, 0x26, 0x2A, 0x3F }, /* ATA100 settings */
	{ 0x17, 0x23, 0x27, 0x3C }, /* ATA133 settings */
};

int f_cnt_initial=0;

/*===================================================================
 * Scan Chip
 *===================================================================*/   

#if defined(_BIOS_) || defined(WIN95)

PUCHAR
ScanHptChip(
    IN PChannel deviceExtension,
    IN OUT PPORT_CONFIGURATION_INFORMATION ConfigInfo
    )
{
    PCI1_CFG_ADDR  pci1_cfg = { 0, };
    ULONG devid;
     
    pci1_cfg.enable = 1;

    for ( ; ; ) {
        if(Hpt_Slot >= MAX_PCI_DEVICE_NUMBER * 2) {
            Hpt_Slot = 0;
            if(Hpt_Bus++ >= MAX_PCI_BUS_NUMBER)
                break;
        }

        do {
            pci1_cfg.dev_num = Hpt_Slot >> 1;
            pci1_cfg.fun_num= Hpt_Slot & 1;
            pci1_cfg.reg_num = 0;
            pci1_cfg.bus_num = Hpt_Bus;
 
            Hpt_Slot++;
            OutDWord(CFG_INDEX, *((PULONG)&pci1_cfg));

			devid = InDWord((PULONG)CFG_DATA);
            if (devid==SIGNATURE_370) {
				pci1_cfg.reg_num = REG_RID;
				OutDWord(CFG_INDEX, *((PULONG)&pci1_cfg));
				if (InPort(CFG_DATA)>=3) goto found; /* 370/370A/372 */
        	}
         	else if (devid==SIGNATURE_372A) {
found:
                 deviceExtension->pci1_cfg = pci1_cfg;
				 // fix
				 pci1_cfg.reg_num = 0x70;
				 OutDWord(CFG_INDEX, *((PULONG)&pci1_cfg));
				 OutPort(CFG_DATA, 0);
				 //
				 pci1_cfg.reg_num = REG_BMIBA;
				 OutDWord(CFG_INDEX, *((PULONG)&pci1_cfg));
				 return((PUCHAR)(InDWord(CFG_DATA) & ~1));
            }

        } while (Hpt_Slot < MAX_PCI_DEVICE_NUMBER * 2);
    }
    return (0);
}

#endif

/*===================================================================
 * Set Chip
 *===================================================================*/   

UINT exlude_num = EXCLUDE_HPT366;

void SetHptChip(PChannel Primary, PUCHAR BMI)
{
    ULONG          loop;
    int            f_low, f_high, adjust;
    PChannel       Secondry;
    UCHAR          version, clk_index;

    version = InPort(BMI+0x20+REG_DID)==5? (IS_HPT_370|IS_HPT_372|IS_HPT_372A) :
     		  InPort(BMI+0x20+REG_RID)>4? (IS_HPT_370|IS_HPT_372) : IS_HPT_370;

    OutWord((BMI + 0x20 + REG_PCICMD), 
        (USHORT)((InWord((BMI + 0x20 + REG_PCICMD)) & ~0x12) |
        PCI_BMEN | PCI_IOSEN));

    OutPort(BMI + 0x20 + REG_MLT, 0x40);

    Primary->BaseIoAddress1  = (PIDE_REGISTERS_1)(InDWord((PULONG)(BMI + 0x10)) & ~1);
    Primary->BaseIoAddress2 = (PIDE_REGISTERS_2)((InDWord((PULONG)(BMI + 0x14)) & ~1) + 2);
    Primary->BMI  = BMI;
    Primary->BaseBMI = BMI;

    Primary->InterruptLevel = (UCHAR)InPort(BMI + 0x5C);
    Primary->ChannelFlags  = (UCHAR)(0x20 | version);

	Secondry = &Primary[1];
    Primary->exclude_index  = (++exlude_num);
    Secondry->exclude_index  = (++exlude_num);
	Secondry->pci1_cfg = Primary->pci1_cfg;
	Secondry->BaseIoAddress1  = (PIDE_REGISTERS_1)(InDWord((PULONG)(BMI + 0x18)) & ~1);
	Secondry->BaseIoAddress2 = (PIDE_REGISTERS_2)((InDWord((PULONG)(BMI + 0x1C)) & ~1) + 2);
	Secondry->BMI  = BMI + 8;
	Secondry->BaseBMI = BMI;
	
	/*
	 * Added by HS.Zhang
	 *
	 * We need check the BMI state on another channel when do DPLL
	 * clock swithing.
	 */
	Primary->NextChannelBMI = BMI + 8;
	Secondry->NextChannelBMI = BMI;

	/*  Added by HS.Zhang
	 *  We need check the FIFO count when INTRQ generated. our chip
	 *  generated the INTR immediately when device generated a IRQ.
	 *  but at this moment, the DMA transfer may not finished, so we
	 *  need check FIFO count to determine whether the INTR is true
	 *  interrupt we need.
	 */
	Primary->MiscControlAddr = BMI + 0x20 + REG_MISC;
	Secondry->MiscControlAddr = BMI + 0x24 + REG_MISC;
	
	Secondry->InterruptLevel = (UCHAR)(InPort(BMI + 0x5C));
	Secondry->ChannelFlags  = (UCHAR)(0x10 | version);
	
	OutPort(BMI + 0x20 + REG_MISC, 5);        
	OutPort(BMI + 0x24 + REG_MISC, 5);        

	/* HPT372A new settings */	
	if (version & IS_HPT_372A) {
		OutPort(BMI+0x9C, 0x0E);
	}
	
	adjust = 1;
	if (!f_cnt_initial) {
		ULONG total=0;
#ifdef _BIOS_
		for (loop = 0; loop<(1<<7); loop++) {
			f_cnt_initial = InWord((PUSHORT)(BMI + 0x98)) & 0x1FF;
			KdPrint(("f_cnt=%x", f_cnt_initial));
			total += f_cnt_initial;
			StallExec(1000);
		}
		f_cnt_initial = total>>7;
		/* save f_CNT in IO 90-93h */
		OutDWord(BMI+0x90, 0xABCDE000|f_cnt_initial);
#else
		/* first check if BIOS has saved f_CNT */
		total = InDWord(BMI+0x90);
		if ((total & 0xFFFFF000)==0xABCDE000)
			f_cnt_initial = total & 0x1FF;
		else
			f_cnt_initial = 0x85; /* we cannot get correct f_CNT, just set it as PCI33 */
#endif
	}

#if defined(FORCE_133)
	clk_index = 1;
	/* if there is ATA/133 disk, use DPLL 66MHz */
	/* this will be called by second time initialize */
	if ((version & IS_HPT_372) && 
	    ((Primary->pDevice[0] && Primary->pDevice[0]->Usable_Mode>13) ||
		 (Primary->pDevice[1] && Primary->pDevice[1]->Usable_Mode>13) ||
		 (Secondry->pDevice[0] && Secondry->pDevice[0]->Usable_Mode>13) ||
		 (Secondry->pDevice[1] && Secondry->pDevice[1]->Usable_Mode>13)))
		clk_index = 2;
#elif defined(FORCE_100)
	clk_index = 1;
#else
	clk_index = 0;
#endif

#ifndef USE_PCI_CLK
	/* adjust DPLL clock */
	
	f_low = pci_xx_f[clk_index][PCI_F_INDEX(f_cnt_initial)];
	f_high = f_low + (f_cnt_initial<0xB0 ? 2 : 4);

reset_5C:
	OutDWord(BMI+0x7C, ((ULONG)f_high << 16) | f_low | 0x100);
	
	/* gmm 2001-4-3 merge BMA fix
	 * Modified by HS.Zhang
	 * Disable the MA15, MA16 as input pins
	 * We must do this, because if let PDIAG as a input pin, some
	 * disk, just like IBM-DTLA serial, will not get in ready when
	 * issue a hardware reset with a 40pins cable.
	 */
	OutPort(BMI + 0x7B, 0x21); //OutPort(BMI + 0x7B, 0x20);

wait_stable:
	for(loop = 0; loop < 0x5000; loop++) {
		StallExec(5);
		if (InPort(BMI + 0x7B) & 0x80) {
			for(loop = 0; loop < 0x1000; loop++)
				if((InPort(BMI + 0x7B) & 0x80) == 0) goto re_try;
			OutDWord(BMI+0x7C, InDWord(BMI+0x7C) & ~0x100);
#ifndef USE_PCI_CLK
			Primary->ChannelFlags |= IS_DPLL_MODE;
			Secondry->ChannelFlags |= IS_DPLL_MODE;
#endif
			goto dpll_ok;
		}
	}
re_try:
	if(++adjust < 5) {
		if (adjust & 1) {
			f_low--; f_high++; 
			goto  reset_5C;
		}
		else {
			OutDWord(BMI+0x7C, (ULONG)(f_high << 16) | f_low);
			goto wait_stable;
		}
	}
dpll_ok:
	/* HPT372A PostIo enable */	
#if 0
	if (version & IS_HPT_372A) {
		OutPort(BMI+0x9B, InPort(BMI+0x9B)|2);
	}
#endif

#else /* USE_PCI_CLK */
	/* gmm 2001-4-3 merge BMA fix
	 * Modified by HS.Zhang
	 * Disable the MA15, MA16 as input pins
	 */
	OutPort(BMI + 0x7B, 0x23); // OutPort(BMI + 0x7B, 0x22);
#endif
	Primary->Setting = Secondry->Setting = 
	   (Primary->ChannelFlags & IS_DPLL_MODE)? 
	   	((clk_index==2) ? setting370_50_133 : setting370_50_100) : setting370_33;

	/* new adding  4/25/01 */
	OutPort(BMI, BMI_CMD_STOP);
	OutPort(BMI+8, BMI_CMD_STOP);
	Reset370IdeEngine(Primary, 0xA0);
	Reset370IdeEngine(Secondry, 0xA0);
}


/*===================================================================
 * check if the disk is "bad" disk
 *===================================================================*/   

static BadModeList bad_disks[] = {
	{0xFF, 0xFF, 4, 8,  "TO-I79 5" },       // 0
	{3, 2, 4, 10,       "DW CCA6204" },     // 1
	{0xFF, 0xFF, 3, 10, "nIetrglaP " },     // 2
	{3, 2, 4, 10,       "DW CDW0000" },     // 3 reduce mode on AA series
	{0xFF, 2, 4, 10,    "aMtxro9 01"},      // 4 reduce mode on 91xxxDx series
	{0xFF, 2, 4, 14,    "aMtxro9 80544D"},  // 5 Maxtor 90845D4
	{0xFF, 0xFF, 4, 10, "eHlwte-taP"},      // 6 HP CD-Writer (0x5A cmd error)
	{0xFF, 2, 4, 8|HPT366_ONLY|HPT368_ONLY,  "DW CCA13" },         // 7
	{0xFF, 0xFF, 0, 16, "iPnoee rVD-DOR M"},// 8 PIONEER DVD-ROM
	{0xFF, 0xFF, 4, 10, "DCR- WC XR" },     // 9 SONY CD-RW   (0x5A cmd error)
	{0xFF, 0xFF, 0, 8,  "EN C    " },       // 10
	{0xFF, 1, 4, 18,    "UFIJST UPM3C60A5 H"}, 
	{0x2,  2, 4, 14,    "aMtxro9 80284U"},     // Maxtor 90882U4

	{0x3,  2, 4, 10|HPT368_ONLY,    "TS132002 A"},        // Seagate 10.2GB ST310220A
	{0x3,  2, 4, 10|HPT368_ONLY,    "TS136302 A"},        // Seagate 13.6GB ST313620A
	{0x3,  2, 4, 10|HPT368_ONLY,    "TS234003 A"},        // Seagate 20.4GB ST320430A
	{0x3,  2, 4, 10|HPT368_ONLY,    "TS232704 A"},        // Seagate 27.2GB ST327240A
	{0x3,  2, 4, 10|HPT368_ONLY,    "TS230804 A"},        // Seagate 28GB   ST328040A
	{0x3,  2, 4, 8|HPT368_ONLY,     "TS6318A0"},          // Seagate 6.8GB  ST36810A

	{3, 2, 4, 14,       "aMtxro9 02848U"},                // Maxtor 92048U8

	{0x3, 2, 4, 14|HPT368_ONLY,    "ASSMNU GVS5135"},	   // SUMSUNG SV1553D
	{0x3, 2, 4, 14|HPT368_ONLY,    "ASSMNU GVS0122"},	   // SUMSUNG SV1022D
	{0x3, 2, 4, 14|HPT368_ONLY,    "ASSMNU GGS5011"},	   // SUMSUNG SG0511D
	{0x3, 2, 4, 14|HPT368_ONLY,    "ASSMNU GGS0122"},	   // SUMSUNG SG1022D
	{0x3, 2, 4, 14|HPT368_ONLY,    "aMtxro9 80544D"},     // Maxtor 90845D4 
	{0x3, 2, 4, 14|HPT368_ONLY,    "aMtxro9 71828D"},     // Maxtor 91728D8 
	{0x3, 2, 4, 14|HPT368_ONLY,    "aMtxro9 02144U"},     // Maxtor 92041U4 
	{0x3, 2, 4, 8|HPT368_ONLY,     "TS8324A1"},	    // Seagate 28GB   ST38421A
	{0x3, 2, 4, 22|HPT368_ONLY,    "UQNAUT MIFERABLLC 8R4."},  //QUANTUM FIREBALL CR8.4A
	{0x3, 2, 4, 16|HPT368_ONLY,    "uFijst hPM3E01A2"},        // Fujitsh MPE3102A
	{0x3, 2, 4, 14|HPT368_ONLY,    "BI MJDAN739001"},	        // IBM DJNA370910
	{0x3,  2, 4, 16|HPT370_ONLY, "UFIJST UPM3D60A4"},// Fujitsu MPD3064AT 
//add new here !!

#ifdef FORCE_133
	{6,2,4,0,0}
#else
	{5,2,4,0,0}
#endif
};

#define MAX_BAD_DISKS (sizeof(bad_disks)/sizeof(BadModeList))


PBadModeList check_bad_disk(char *ModelNumber, PChannel pChan)
{
     int l;
     PBadModeList pbd;

    /*
     * kick out the "bad device" which do not work with our chip
     */
     for(l=0, pbd = bad_disks; l < MAX_BAD_DISKS - 1; pbd++,l++) {
        if(StringCmp(ModelNumber, pbd->name, pbd->length & 0x1F) == 0) {
          switch (l) {
          case 3:
            if(ModelNumber[3]== 'C' && ModelNumber[4]=='D' && ModelNumber[5]=='W' && 
                 ModelNumber[8]=='A' && (ModelNumber[11]=='A' || 
                 ModelNumber[10]=='A' || ModelNumber[9]=='A')) 
                 goto out;
          case 4:
            if(ModelNumber[0]== 'a' && ModelNumber[1]=='M' && ModelNumber[2]=='t' && 
                 ModelNumber[3]=='x' && ModelNumber[6]== '9' && ModelNumber[9]=='1' && 
                 ModelNumber[13] =='D')
                 goto out;
          case 6:
             if(ModelNumber[16]== 'D' && ModelNumber[17]=='C' && ModelNumber[18]=='W' && ModelNumber[19]=='-' &&
                ModelNumber[20]== 'i' && ModelNumber[21]=='r' && ModelNumber[22] =='e')
                 goto out;
          default:
                break;
			 }
        }
    }
out:
    if((pbd->length & (HPT366_ONLY | HPT368_ONLY | HPT370_ONLY)) == 0 ||
       ((pbd->length & HPT370_ONLY) && (pChan->ChannelFlags & IS_HPT_370)))
          return(pbd);
    return (&bad_disks[MAX_BAD_DISKS - 1]);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\port\scsi\miniport\hipoint\hpt3xx\winnt\finddev.c ===
#include "global.h"

/***************************************************************************
 * File:          Finddev.c
 * Description:   Subroutines in the file are used to scan devices
 * Author:        DaHai Huang    (DH)
 * Dependence:    none
 * Copyright (c)  2000 HighPoint Technologies, Inc. All rights reserved
 *                
 * History:     

 *	gmm 03/06/2001 add a retry in FindDevice()
 *	SC 12/06/2000  The cable detection will cause drive not
 *                ready when drive try to read RAID information block. There
 *                is a fix in "ARRAY.C" to retry several times
 *
 * SC 12/04/2000  In previous changes, the reset will cause
 *                hard disk detection failure if a ATAPI device is connected
 *                with hard disk on the same channel. Add a "drive select" 
 *                right after reset to fix this issue
 *
 *	SC 11/27/2000  modify cable detection (80-pin/40-pin)
 *
 *	SC 11/01/2000  remove hardware reset if master device
 *                is missing
 * DH 5/10/2000 initial code
 *
 ***************************************************************************/

/******************************************************************
 * Find Device
 *******************************************************************/

USHORT    pioTiming[6] = {960, 480, 240, 180, 120, 90};

#ifdef SUPPORT_HPT601
void Check601(PDevice pDev)
{
	PChannel   pChan = pDev->pChannel;
	PIDE_REGISTERS_1  IoPort = pChan->BaseIoAddress1;
	PIDE_REGISTERS_2  ControlPort = pChan->BaseIoAddress2;

	SelectUnit(IoPort, pDev->UnitId);
	WaitOnBusy(ControlPort);
	
	BeginAccess601(IoPort);
	OutPort(&IoPort->BlockCount, 0);
	if (InWord(&IoPort->Data)==0x5a3e) {
		pDev->DeviceFlags2 |= DFLAGS_WITH_601;
	}
	else
		pDev->DeviceFlags2 &= ~DFLAGS_WITH_601;
	EndAccess601(IoPort);
}
#else
#define Check601(pDev)
#endif

void SetDeviceProperties(PDevice pDev, IDENTIFY_DATA *pIdentifyData)
{
	PChannel pChan = pDev->pChannel;
	PBadModeList pbd;
	UCHAR mod;
	
    if (pIdentifyData->GeneralConfiguration & 0x80)
       pDev->DeviceFlags |= DFLAGS_REMOVABLE_DRIVE;
       
    if ((pIdentifyData->SpecialFunctionsEnabled & 3)==1)
    	pDev->DeviceFlags |= DFLAGS_SUPPORT_MSN;

    if(*(PULONG)pIdentifyData->ModelNumber == 0x2D314C53) // '-1LS')
          pDev->DeviceFlags |= DFLAGS_LS120;
 
#ifdef _BIOS_  
/*
 * gmm 2001-4-14 remove this
 * In previous BIOS DeviceFlags2 is 16bit UINT, there is no use of DFLAGS_REDUCE_MODE
 * gmm 2001-4-17 Use reduced mode. Otherwise Win98/2K installation will have problem
 */
#if 1
	// reduce mode for all Maxtor ATA-100 hard disk
	{
		PUCHAR modelnum= (PUCHAR)&pIdentifyData->ModelNumber;
		if(modelnum[0]=='a' && modelnum[1]=='M' && modelnum[2]=='t' &&
		   modelnum[3]=='x' && modelnum[4]=='r' && modelnum[13]=='H'){
			pDev->DeviceFlags2 = DFLAGS_REDUCE_MODE;				  
		}
	}
#endif
#endif

	/* adjust Seagate Barracuda III/IV HDD settings */
	if (StringCmp((PUCHAR)&pIdentifyData->ModelNumber, "TS132051 A", 10)==0 ||
		StringCmp((PUCHAR)&pIdentifyData->ModelNumber, "TS133501 A", 10)==0 ||
		StringCmp((PUCHAR)&pIdentifyData->ModelNumber, "TS230011 A", 10)==0 ||
		StringCmp((PUCHAR)&pIdentifyData->ModelNumber, "TS234041 A", 10)==0 ||
		StringCmp((PUCHAR)&pIdentifyData->ModelNumber, "TS336002 A", 10)==0 ||
		StringCmp((PUCHAR)&pIdentifyData->ModelNumber, "TS430061 A", 10)==0 ||
		StringCmp((PUCHAR)&pIdentifyData->ModelNumber, "TS630012 A", 10)==0 ||
		StringCmp((PUCHAR)&pIdentifyData->ModelNumber, "TS830012 A", 10)==0 ||
		StringCmp((PUCHAR)&pIdentifyData->ModelNumber, "TS438042 A", 10)==0) 
	{
		void seagate_hdd_fix(PDevice pDev, PIDE_REGISTERS_1 IoPort, PIDE_REGISTERS_2 ControlPort);
		seagate_hdd_fix(pDev, pChan->BaseIoAddress1, pChan->BaseIoAddress2);
	}
	
    if((pDev->DeviceFlags & (DFLAGS_ATAPI | DFLAGS_LS120)) == 0)
        pDev->DeviceFlags |= DFLAGS_HARDDISK;
       
/*===================================================================
 * Copy Basic Info
 *===================================================================*/   

	SetMaxCmdQueue(pDev, pIdentifyData->MaxQueueDepth & 0x1F);

    pDev->DeviceFlags |= (UCHAR)((pIdentifyData->Capabilities  >> 9) & 1);
	/* gmm 2001-4-3 merge BMA fix
	 * BUGFIX: by HS Zhang
	 * the size should shift left 8 instead of 7
	 * wordLeft = Sectors * 512 / 2
	 * 512/2 = 256 = 1 << 8
	 */
    pDev->MultiBlockSize = pIdentifyData->MaximumBlockTransfer << 8;

#ifdef SUPPORT_48BIT_LBA
    if(pIdentifyData->CommandSupport & 0x400) {
        pDev->DeviceFlags |= DFLAGS_48BIT_LBA;
        pDev->capacity = pIdentifyData->Lba48BitLow - 1;
		pDev->RealHeader     = 255;
		pDev->RealSector     = 63;
    }
    else
#endif
    if(pIdentifyData->TranslationFieldsValid & 1) {
       pDev->RealHeader     = (UCHAR)pIdentifyData->NumberOfCurrentHeads;
       pDev->RealSector     = (UCHAR)pIdentifyData->CurrentSectorsPerTrack;
       pDev->capacity = ((pIdentifyData->CurrentSectorCapacity <
            pIdentifyData->UserAddressableSectors)? pIdentifyData->UserAddressableSectors :
            pIdentifyData->CurrentSectorCapacity) - 1;
    } else {
       pDev->RealHeader     = (UCHAR)pIdentifyData->NumberOfHeads;
       pDev->RealSector     = (UCHAR)pIdentifyData->SectorsPerTrack;
       pDev->capacity = pIdentifyData->UserAddressableSectors - 1;
    }

    pDev->RealHeadXsect = pDev->RealSector * pDev->RealHeader;

/*===================================================================
 * Select Best PIO mode
 *===================================================================*/   

    if((mod = pIdentifyData->PioCycleTimingMode) > 4)
        mod = 0;
    if((pIdentifyData->TranslationFieldsValid & 2) &&
       (pIdentifyData->Capabilities & 0x800) && (pIdentifyData->AdvancedPIOModes)) {
       if(pIdentifyData->MinimumPIOCycleTime > 0)
             for (mod = 5; mod > 0 &&
                 pIdentifyData->MinimumPIOCycleTime > pioTiming[mod]; mod-- );
        else
             mod = (UCHAR)(
             (pIdentifyData->AdvancedPIOModes & 0x1) ? 3 :
             (pIdentifyData->AdvancedPIOModes & 0x2) ? 4 :
             (pIdentifyData->AdvancedPIOModes & 0x4) ? 5 : mod);
    }

    pDev->bestPIO = (UCHAR)mod;

/*===================================================================
 * Select Best Multiword DMA
 *===================================================================*/   

#ifdef USE_DMA
    if((pIdentifyData->Capabilities & 0x100) &&   // check mw dma
       (pIdentifyData->MultiWordDMASupport & 6)) {
       pDev->bestDMA = (UCHAR)((pIdentifyData->MultiWordDMASupport & 4)? 2 : 1);
    } else 
#endif //USE_DMA
        pDev->bestDMA = 0xFF;

/*===================================================================
 * Select Best Ultra DMA
 *===================================================================*/   
	/* 2001-4-3 gmm merge BMA fix
	 * Added by HS.Zhang
	 * To detect whether is 80pin cable, we should enable MA15
	 * MA16 as input pins.
	 */
	if(pChan->ChannelFlags & IS_80PIN_CABLE){
		UCHAR	ucOldSetting;
		ucOldSetting = InPort(pChan->BaseBMI + 0x7B);
		OutPort((pChan->BaseBMI + 0x7B), (UCHAR)(ucOldSetting&0xFE));
		/*
		 * Added by HS.Zhang
		 * After enable MA15, MA16 as input pins, we need wait awhile
		 * for debouncing.
		 */
		StallExec(10);
		if((InPort(pChan->BaseBMI + 0x7A) << 4) & pChan->ChannelFlags){
			pChan->ChannelFlags &= ~IS_80PIN_CABLE;
		}
		OutPort((pChan->BaseBMI + 0x7B), ucOldSetting);
	}

#ifdef USE_DMA
	if(pIdentifyData->TranslationFieldsValid & 0x4)  {
		mod = (UCHAR)(((pChan->ChannelFlags & IS_HPT_372) &&
					   (pIdentifyData->UtralDmaMode & 0x40))? 6 :    /* ultra DMA Mode 6 */
					  (pIdentifyData->UtralDmaMode & 0x20)? 5 :    /* ultra DMA Mode 5 */
					  (pIdentifyData->UtralDmaMode & 0x10)? 4 :    /* ultra DMA Mode 4 */
					  (pIdentifyData->UtralDmaMode & 0x8 )? 3 :    /* ultra DMA Mode 3 */
					  (pIdentifyData->UtralDmaMode & 0x4) ? 2 :    /* ultra DMA Mode 2 */
					  (pIdentifyData->UtralDmaMode & 0x2) ? 1 :    /* ultra DMA Mode 1 */
					  (pIdentifyData->UtralDmaMode & 0x1) ? 0 :0xFF); //If disk does not support UDMA,mod = 0xFF,added by Qyd,  2001/3/20.  

		if((pChan->ChannelFlags & IS_80PIN_CABLE) == 0 && mod > 2)
			mod = 2;

		pDev->bestUDMA = (UCHAR)mod;

	} else
#endif //USE_DMA
		pDev->bestUDMA = 0xFF;

/*===================================================================
 * select bset mode 
 *===================================================================*/   

    pbd = check_bad_disk((PUCHAR)&pIdentifyData->ModelNumber, pChan);

    if((pbd->UltraDMAMode | pDev->bestUDMA) != 0xFF) 
        pDev->Usable_Mode = (UCHAR)((MIN(pbd->UltraDMAMode, pDev->bestUDMA)) + 8);
    else if((pbd->DMAMode | pDev->bestDMA) != 0xFF) 
        pDev->Usable_Mode = (UCHAR)((MIN(pbd->DMAMode, pDev->bestDMA)) + 5);
    else 
        pDev->Usable_Mode = MIN(pbd->PIOMode, pDev->bestPIO);
        
#if defined(USE_PCI_CLK)
    /* When using PCI_CLK and PCI clock less than 33MHz, cannot run ATA133 */
    {
    	extern int f_cnt_initial;
		if (f_cnt_initial<0x85 && pDev->Usable_Mode>13) pDev->Usable_Mode = 13;
	}
#endif
#if !defined(FORCE_133)
	/* if not define FORCE_133, don't use ATA133 */
	if (pDev->Usable_Mode>13) pDev->Usable_Mode = 13;
#endif

	/* if chip is 370/370A, not use ATA133 */
    if (!(pChan->ChannelFlags & IS_HPT_372) && pDev->Usable_Mode>13) pDev->Usable_Mode = 13;
}

int FindDevice(PDevice pDev, ST_XFER_TYPE_SETTING osAllowedMaxXferMode)
{
    LOC_IDENTIFY
    PChannel          pChan = pDev->pChannel;
    PIDE_REGISTERS_1  IoPort = pChan->BaseIoAddress1;
    PIDE_REGISTERS_2  ControlPort = pChan->BaseIoAddress2;
    OLD_IRQL
    int               j, retry;
    UCHAR             stat;

    DISABLE

#ifndef _BIOS_
	// initialize the critical member of Device
	memset(&pDev->stErrorLog, 0, sizeof(pDev->stErrorLog));
	pDev->nLockedLbaStart = -1;	// when start LBA == -1, mean no block locked
	pDev->nLockedLbaEnd = 0;		// when end LBA == 0, mean no block locked also
#endif
	// gmm 2001-3-21
	pDev->IoCount = 0;
	pDev->ResetCount = 0;
	pDev->IoSuccess = 0;
	
	Check601(pDev);

    SelectUnit(IoPort,pDev->UnitId);
	// gmm 03/06/2001 
	// add this retry
	// some IBM disks often busy for a long time.
	retry=0;
wait_busy:
    for(j = 1; j < 5; j++) {
        stat = WaitOnBusy(ControlPort);
        SelectUnit(IoPort,pDev->UnitId);
        if((stat & IDE_STATUS_BUSY) == 0)
            goto check_port;
    }
	if (++retry>3) goto no_dev;
	 //  01/11 Maxtor disk on a single disk single cable
    //  can't accept this reset. It should be OK without this 
    //  reset if master disk is missing
    //IdeHardReset(ControlPort);
	goto wait_busy;

check_port:
    SetBlockNumber(IoPort, 0x55);
    SetBlockCount(IoPort, 0);
    if(GetBlockNumber(IoPort) != 0x55) {
no_dev:
        SelectUnit(IoPort,(UCHAR)(pDev->UnitId ^ 0x10));
        ENABLE
//		  OutPort(pChan->BaseBMI+0x7A, 0);
        return(FALSE);
    }
    SetBlockNumber(IoPort, 0xAA);
    if(GetBlockNumber(IoPort) != 0xAA)
        goto no_dev;
    ENABLE

/*===================================================================
 * check if the device is a ATAPI one
 *===================================================================*/

    if(GetByteLow(IoPort) == 0x14 && GetByteHigh(IoPort) == 0xEB)
          goto is_cdrom;

    for(j = 0; j != 0xFFFF; j++) {
        stat = GetBaseStatus(IoPort);
        if(stat & IDE_STATUS_DWF)
             break;
        if((stat & IDE_STATUS_BUSY) == 0) {
             if((stat & (IDE_STATUS_DSC|IDE_STATUS_DRDY)) == (IDE_STATUS_DSC|IDE_STATUS_DRDY))
                 goto chk_cd_again;
             break;
        }
        StallExec(5000);
    }

    if((GetBaseStatus(IoPort) & 0xAE) != 0)
        goto no_dev;

/*===================================================================
 * Read Identifytify data for a device
 *===================================================================*/

chk_cd_again:
    if(GetByteLow(IoPort) == 0x14 && GetByteHigh(IoPort) == 0xEB) {
is_cdrom:
#ifdef SUPPORT_ATAPI
        AtapiSoftReset(IoPort, ControlPort, pDev->UnitId);

        if(IssueIdentify(pDev, IDE_COMMAND_ATAPI_IDENTIFY ARG_IDENTIFY) == 0) 
             goto no_dev;

        pDev->DeviceFlags = DFLAGS_ATAPI;

#ifndef _BIOS_
		  if(osAllowedMaxXferMode.XferType== 0xE)
               pDev->DeviceFlags |= DFLAGS_FORCE_PIO;
#endif

        if(Identify.GeneralConfiguration & 0x20)
            pDev->DeviceFlags |= DFLAGS_INTR_DRQ;

        if((Identify.GeneralConfiguration & 0xF00) == 0x500)
                pDev->DeviceFlags |= DFLAGS_CDROM_DEVICE;

#ifndef _BIOS_
        if((Identify.GeneralConfiguration & 0xF00) == 0x100)
                 pDev->DeviceFlags |= DFLAGS_TAPE_DEVICE;
#endif

        stat = (UCHAR)GetMediaStatus(pDev);
        if((stat & 0x100) == 0 || (stat & 4) == 0)
            pDev->DeviceFlags |= DFLAGS_DEVICE_LOCKABLE;
#else
		goto no_dev;
#endif // SUPPORT_ATAPI

    } else if(IssueIdentify(pDev, IDE_COMMAND_IDENTIFY ARG_IDENTIFY) == FALSE) { 

        if((GetBaseStatus(IoPort) & ~1) == 0x50 ||
            (GetByteLow(IoPort) == 0x14 && GetByteHigh(IoPort) == 0xEB))
            goto is_cdrom;
        else
            goto no_dev;
	 }
	 
	SetDeviceProperties(pDev, &Identify);

	OS_Identify(pDev);

	if((pDev->DeviceFlags & DFLAGS_ATAPI) == 0) 
		SetDevice(pDev);

#ifdef DPLL_SWITCH
     if (!(pChan->ChannelFlags & IS_HPT_372) && pDev->Usable_Mode>=13) {
         if(pChan->ChannelFlags & IS_DPLL_MODE)
            pDev->DeviceFlags |= DFLAGS_NEED_SWITCH;
     }
#endif
 
     DeviceSelectMode(pDev, pDev->Usable_Mode);

     return(TRUE);
}

void seagate_hdd_fix( PDevice pDev,
					PIDE_REGISTERS_1  IoPort,
					PIDE_REGISTERS_2  ControlPort
					)
{
	int i;

	SetFeaturePort(IoPort, 0x00);		// W 1F1 00
	SetBlockCount(IoPort, 0x06);		// W 1F2 06
	SetBlockNumber(IoPort, 0x9A);		// W 1F3 9A
	SetCylinderLow(IoPort, 0x00);		// W 1F4 00
	SetCylinderHigh(IoPort, 0x00);		// W 1F5 00
	
	SelectUnit(IoPort, pDev->UnitId);	// Select device
	//SelectUnit(IoPort, 0x00);			// W 1F6 00

	IssueCommand(IoPort, 0x9A);			// W 1F7 9A

	WaitOnBaseBusy(IoPort);				// R 1F7

	GetErrorCode(IoPort);				// R 1F1
	GetInterruptReason(IoPort);			// R 1F2
	GetCurrentSelectedUnit(IoPort);		// R 1F6
	GetBlockNumber(IoPort);				// R 1F3
	GetByteLow(IoPort);					// R 1F4
	GetByteHigh(IoPort);				// R 1F5
	GetCurrentSelectedUnit(IoPort);		// R 1F6
	GetBaseStatus(IoPort);				// R 1F7
	GetStatus(ControlPort);				// R 3F6
	GetBaseStatus(IoPort);				// R 1F7

	//
	// Write 512 bytes
	//
	OutWord(&IoPort->Data, 0x5341);		// W 1F0 5341
	OutWord(&IoPort->Data, 0x4943);		// W 1F0 4943
	OutWord(&IoPort->Data, 0x3938);		// W 1F0 3938
	OutWord(&IoPort->Data, 0x3831);		// W 1F0 3831
	OutWord(&IoPort->Data, 0x3330);		// W 1F0 3330
	OutWord(&IoPort->Data, 0x4646);		// W 1F0 4646
	for(i = 0; i < 250; i++)
	{
		OutWord(&IoPort->Data, 0x0000);	// W 1F0 0000
	}

	//
	// Read 1F7 5 times
	//
	for(i = 0; i < 5; i++)
	{
		GetBaseStatus(IoPort);			// R 1F7
	}
	WaitOnBusy(ControlPort);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\port\scsi\miniport\hipoint\hpt3xx\winnt\hsutil.c ===
/***************************************************************************
 * File:          hsutil.c
 * Description:   This module include the system functions for NT device
 *				  drivers, These functions is OS dependent.
 * Author:        DaHai Huang    (DH)
 * Dependence:    none
 * Copyright (c)  2000 HighPoint Technologies, Inc. All rights reserved
 * History:
 *		11/08/2000	HS.Zhang	Added this header
 *		2/16/2001	gmm			modify PrepareForNotification() call
 *
 ***************************************************************************/
#ifndef	WIN95				  

#include <ntddk.h>

BOOLEAN g_bNotifyEvent = FALSE;

HANDLE PrepareForNotification(HANDLE hEvent)
{
	g_bNotifyEvent = FALSE;
	return (HANDLE)&g_bNotifyEvent;
}

void NotifyApplication(HANDLE hEvent)
{
	*(BOOLEAN *)hEvent = TRUE;
}

void CloseNotifyEventHandle(HANDLE hEvent)
{						
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\port\scsi\miniport\hipoint\hpt3xx\winnt\io.c ===
/***************************************************************************
 * File:          Global.h
 * Description:   Basic function for device I/O request.
 * Author:        DaHai Huang    (DH)
 * Dependence:    none
 * Copyright (c)  2000 HighPoint Technologies, Inc. All rights reserved
 * History:
 *	11/06/2000	HS.Zhang	Changed the IdeHardReset flow
 *	11/08/2000	HS.Zhang	Added this header
 *	11/28/2000  SC          add RAID 0+1 condition in "IdeHardReset"
 *                            during one of hard disk is removed
 *  4/2/2001    gmm         add retry in ReadWrite()   
 ***************************************************************************/
#include "global.h"

/******************************************************************
 * Wait Device Busy off
 *******************************************************************/

UCHAR WaitOnBusy(PIDE_REGISTERS_2 BaseIoAddress) 
{ 
	UCHAR Status;
	ULONG i; 

	for (i=0; i<20000; i++) { 
		Status = GetStatus(BaseIoAddress); 
		if ((Status & IDE_STATUS_BUSY) == 0 || Status == 0xFF) 
			break;
		StallExec(150); 
	} 
	return(Status);
}

/******************************************************************
 * Wait Device Busy off (Read status from base port)
 *******************************************************************/

UCHAR  WaitOnBaseBusy(PIDE_REGISTERS_1 BaseIoAddress) 
{ 
	UCHAR Status;
	ULONG i; 

	for (i=0; i<20000; i++) { 
		Status = GetBaseStatus(BaseIoAddress); 
		if ((Status & IDE_STATUS_BUSY)  == 0)
			break;
		StallExec(150); 
	}
	return(Status); 
}

/******************************************************************
 * Wait Device DRQ on
 *******************************************************************/

UCHAR WaitForDrq(PIDE_REGISTERS_2 BaseIoAddress) 
{ 
	UCHAR Status;
	int  i; 

	for (i=0; i<2000; i++) { 
		Status = GetStatus(BaseIoAddress); 
		if ((Status & (IDE_STATUS_BUSY | IDE_STATUS_DRQ)) == IDE_STATUS_DRQ)
			break; 
		StallExec(150); 
	} 
	return(Status);
}


/******************************************************************
 * Reset Atapi Device
 *******************************************************************/

void AtapiSoftReset(
					PIDE_REGISTERS_1 IoPort, 
					PIDE_REGISTERS_2 ControlPort, 
					UCHAR DeviceNumber) 
{
	SelectUnit(IoPort,DeviceNumber); 
	StallExec(500);
	IssueCommand(IoPort, IDE_COMMAND_ATAPI_RESET); 
	WaitOnBusy(ControlPort); 
	SelectUnit(IoPort,DeviceNumber); 
	WaitOnBusy(ControlPort); 
	StallExec(500);
}

/******************************************************************
 * Reset IDE Channel
 *******************************************************************/

int IdeHardReset(PIDE_REGISTERS_1 DataPort, PIDE_REGISTERS_2 ControlPort) 
{
    ULONG i;
    UCHAR dev;
	
	UnitControl(ControlPort,IDE_DC_RESET_CONTROLLER|IDE_DC_DISABLE_INTERRUPTS );
	StallExec(50000L);
	UnitControl(ControlPort,IDE_DC_REENABLE_CONTROLLER);
	StallExec(50000L);

	WaitOnBusy(ControlPort);
	
	for (dev = 0xA0; dev<=0xB0; dev+=0x10) {
		for (i = 0; i < 100; i++) {
			SelectUnit(DataPort, dev);
			if(GetCurrentSelectedUnit(DataPort) == dev) {
				GetBaseStatus(DataPort);
				break;
			}
			StallExec(1000);
		}
	}
	return TRUE;
}

/******************************************************************
 * IO ATA Command
 *******************************************************************/

int ReadWrite(PDevice pDev, ULONG Lba, UCHAR Cmd DECL_BUFFER)
{
	PChannel   pChan = pDev->pChannel;
	PIDE_REGISTERS_1  IoPort = pChan->BaseIoAddress1;
	PIDE_REGISTERS_2  ControlPort = pChan->BaseIoAddress2;
	UCHAR      statusByte;
    UINT       i, retry=0;
    UCHAR is_lba9 = (Lba==RECODR_LBA);
	//PULONG     SettingPort;
	//ULONG      OldSettings;

	// gmm: save old mode
	// if interrupt is enabled we will disable and then re-enable it
	//
	UCHAR old_mode = pDev->DeviceModeSetting;
	UCHAR intr_enabled = !(InPort(pChan->BaseBMI+0x7A) & 0x10);
	if (intr_enabled) DisableBoardInterrupt(pChan->BaseBMI);
	DeviceSelectMode(pDev, 0);
	/*
	SettingPort = (PULONG)(pChan->BMI+ ((pDev->UnitId & 0x10)>> 2) + 0x60);
	OldSettings = InDWord(SettingPort);
	OutDWord(SettingPort, pChan->Setting[pDev->bestPIO]);
	*/
	
	i=0;
_retry_:
	SelectUnit(IoPort, pDev->UnitId);
    if (GetCurrentSelectedUnit(IoPort) != pDev->UnitId && i++<100) {
        StallExec(200);
        goto _retry_;
    }
    if (i>=100) goto out;
	WaitOnBusy(ControlPort);

	if(pDev->DeviceFlags & DFLAGS_LBA) 
		Lba |= 0xE0000000;
	else 
		Lba = MapLbaToCHS(Lba, pDev->RealHeadXsect, pDev->RealSector);


	SetBlockCount(IoPort, 1);
	SetBlockNumber(IoPort, (UCHAR)(Lba & 0xFF));
	SetCylinderLow(IoPort, (UCHAR)((Lba >> 8) & 0xFF));
	SetCylinderHigh(IoPort,(UCHAR)((Lba >> 16) & 0xFF));
	SelectUnit(IoPort,(UCHAR)((Lba >> 24) | (pDev->UnitId)));

	WaitOnBusy(ControlPort);

	IssueCommand(IoPort, Cmd);

	for(i = 0; i < 5; i++)	{
		statusByte = WaitOnBusy(ControlPort);
		if((statusByte & (IDE_STATUS_BUSY | IDE_STATUS_ERROR)) == 0)
			goto check_drq;
	}
out:
	/* gmm:
	 *
	 */
    if (retry++<4) {
		statusByte= GetErrorCode(IoPort);
		IssueCommand(IoPort, IDE_COMMAND_RECALIBRATE);
		GetBaseStatus(IoPort);
		StallExec(10000);
        goto _retry_;
    }
    DeviceSelectMode(pDev, old_mode);
	if (intr_enabled) EnableBoardInterrupt(pChan->BaseBMI);
	//OutDWord(SettingPort, OldSettings);
	//-*/
	return(FALSE);

check_drq:
	if((statusByte & IDE_STATUS_DRQ) == 0) {
		statusByte = WaitForDrq(ControlPort);
		if((statusByte & IDE_STATUS_DRQ) == 0)	{
			GetBaseStatus(IoPort); //Clear interrupt
			goto out;
		}
	}
	GetBaseStatus(IoPort); //Clear interrupt

//	 if(pChan->ChannelFlags & IS_HPT_370)
//	     OutPort(pChan->BMI + (((UINT)pChan->BMI & 0xF)? 0x6C : 0x70), 0x25);

	if(Cmd == IDE_COMMAND_READ)
		RepINS(IoPort, (ADDRESS)tmpBuffer, 256);
	else {
		RepOUTS(IoPort, (ADDRESS)tmpBuffer, 256);
		/* gmm 2001-6-13
		 *  Save buffer to pDev->real_lba9
		 */
		if (is_lba9) _fmemcpy(pDev->real_lba9, tmpBuffer, 512);
	}

	/* gmm:
	 *
	 */
	DeviceSelectMode(pDev, old_mode);
	if (intr_enabled) EnableBoardInterrupt(pChan->BaseBMI);
	//OutDWord(SettingPort, OldSettings);
	//-*/
	return(TRUE);
}


/******************************************************************
 * Non IO ATA Command
 *******************************************************************/

UCHAR NonIoAtaCmd(PDevice pDev, UCHAR cmd)
{
	PChannel   pChan = pDev->pChannel;
	PIDE_REGISTERS_1  IoPort = pChan->BaseIoAddress1;
	UCHAR   state, cnt=0;
_retry_:
	SelectUnit(IoPort, pDev->UnitId);
#if 1 // gmm 2001-3-19
	if (GetCurrentSelectedUnit(IoPort) != pDev->UnitId && cnt++<100) {
		StallExec(200);
		goto _retry_;
	}
	// gmm 2001-3-19: NO: if (cnt>=100) return IDE_STATUS_ERROR;
#endif
	WaitOnBusy(pChan->BaseIoAddress2);
	IssueCommand(IoPort, cmd);
	StallExec(1000);
	WaitOnBusy(pChan->BaseIoAddress2);
	state = GetBaseStatus(IoPort);//clear interrupt
	OutPort(pChan->BMI + BMI_STS, BMI_STS_ERROR|BMI_STS_INTR);
	return state;
}


UCHAR SetAtaCmd(PDevice pDev, UCHAR cmd)
{
	PChannel   pChan = pDev->pChannel;
	PIDE_REGISTERS_1  IoPort = pChan->BaseIoAddress1;
	UCHAR   state;

	IssueCommand(IoPort, cmd);
	StallExec(1000);
	WaitOnBusy(pChan->BaseIoAddress2);
	state = GetBaseStatus(IoPort);//clear interrupt
	OutPort(pChan->BMI + BMI_STS, BMI_STS_ERROR|BMI_STS_INTR);
	return state;
}

/******************************************************************
 * Get Media Status
 *******************************************************************/

UINT GetMediaStatus(PDevice pDev)
{
	return ((NonIoAtaCmd(pDev, IDE_COMMAND_GET_MEDIA_STATUS) << 8) | 
			GetErrorCode(pDev->pChannel->BaseIoAddress1));
}

/******************************************************************
 * Strncmp
 *******************************************************************/

UCHAR StringCmp (PUCHAR FirstStr, PUCHAR SecondStr, UINT Count )
{
	while(Count-- > 0) {
		if (*FirstStr++ != *SecondStr++) 
			return 1;
	}
	return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\port\scsi\miniport\hipoint\hpt3xx\winnt\ioctrl.c ===
/*++
Copyright (c) 1999, HighPoint Technologies, Inc.

Module Name:
	IoCtrl.c: Miniport I/O ctrl code dispatch routine

Abstract:

Author:
    HongSheng Zhang (HS)

Environment:
	Windows NT Kernel mode
Notes:

Revision History:
    12-07-99    Created initially
    11/08/2000	HS.Zhang	Updated the header information
	11/20/2000	SLeng		Added code to Enable/Disable a device
	11/23/2000  SLeng		Added code to add/del a spare disk to/from a mirror
	11/29/2000  SLeng		Added code to add a mirror disk to a mirror array
--*/
#include "global.h"	
#include "DevMgr.h"

#include "HptIoctl.h"                       // MINIPORT IOCTL code
#include "HptVer.h"

extern PHW_DEVICE_EXTENSION hpt_adapters[];
extern int num_adapters;

#ifdef SUPPORT_HPT601
BOOLEAN Device_Get601Info(PDevice pDev, PSt_HPT601_INFO pInfo)
{
	PChannel   pChan = pDev->pChannel;
	PIDE_REGISTERS_1  IoPort = pChan->BaseIoAddress1;
	PIDE_REGISTERS_2  ControlPort = pChan->BaseIoAddress2;

	if ((pDev->DeviceFlags2 & DFLAGS_WITH_601)==0) return FALSE;

	SelectUnit(IoPort, pDev->UnitId);
	WaitOnBusy(ControlPort);
	
	BeginAccess601(IoPort);

	OutPort(&IoPort->BlockCount, 0);
	pInfo->DeviceId = InWord(&IoPort->Data);

	OutPort(&IoPort->BlockCount, 0x14);
	pInfo->Temperature = InWord(&IoPort->Data);

	OutPort(&IoPort->BlockCount, 0x16);
	pInfo->FanStatus = InWord(&IoPort->Data);

	OutPort(&IoPort->BlockCount, 7);
	pInfo->BeeperControl = InWord(&IoPort->Data);

	OutPort(&IoPort->BlockCount, 3);
	pInfo->LED1Control = InWord(&IoPort->Data);

	OutPort(&IoPort->BlockCount, 5);
	pInfo->LED2Control = InWord(&IoPort->Data);

	OutPort(&IoPort->BlockCount, 0x18);
	pInfo->PowerStatus = InWord(&IoPort->Data);
		
	EndAccess601(IoPort);
	pInfo->ValidFields= HPT601_INFO_DEVICEID|
						HPT601_INFO_TEMPERATURE|
						HPT601_INFO_FANSTATUS|
						HPT601_INFO_BEEPERCONTROL|
						HPT601_INFO_LED1CONTROL|
						HPT601_INFO_LED2CONTROL|
						HPT601_INFO_POWERSTATUS;
	return TRUE;
}

BOOLEAN Device_Set601Info(PDevice pDev, PSt_HPT601_INFO pInfo)
{
	PChannel   pChan = pDev->pChannel;
	PIDE_REGISTERS_1  IoPort = pChan->BaseIoAddress1;
	PIDE_REGISTERS_2  ControlPort = pChan->BaseIoAddress2;

	if ((pDev->DeviceFlags2 & DFLAGS_WITH_601)==0) return FALSE;

	SelectUnit(IoPort, pDev->UnitId);
	WaitOnBusy(ControlPort);
	
	BeginAccess601(IoPort);

	if (pInfo->ValidFields & HPT601_INFO_FANSTATUS) {
		OutPort(&IoPort->BlockCount, 0x16);
		OutWord(&IoPort->Data, pInfo->FanStatus);
	}

	if (pInfo->ValidFields & HPT601_INFO_BEEPERCONTROL) {
		OutPort(&IoPort->BlockCount, 7);
		OutWord(&IoPort->Data, pInfo->BeeperControl);
	}

	if (pInfo->ValidFields & HPT601_INFO_LED1CONTROL) {
		OutPort(&IoPort->BlockCount, 3);
		OutWord(&IoPort->Data, pInfo->LED1Control);
	}

	if (pInfo->ValidFields & HPT601_INFO_LED2CONTROL) {
		OutPort(&IoPort->BlockCount, 5);
		OutWord(&IoPort->Data, pInfo->LED2Control);
	}
		
	EndAccess601(IoPort);
	return TRUE;
}

#endif

/*++
 Function:
	 HptUtLockDeviceBlock
	 
 Description:
 	 Lock a block on harddisk to prevent the READ/WRITE operation on
 	 it, all READ/WRITE operation on this block will be hold in SRB
 	 queue.
 	 
 Argument:
	 pChannel - channel struct of the hard disk
	 nTarget - device id of the hard disk
	 nStartLbaAddress - the start LBA address want to be locked
	 nBlockSize - the block size

 Return:
	 ULONG SRB_STATUS
++*/  

ULONG
   HptUtLockDeviceBlock(
					  IN PChannel	pChannel,
					  IN ULONG		nTargetId,
					  IN ULONG		nStartLbaAddress,
					  IN ULONG		nBlockSize
					 )
{							  
	PDevice  pDevice;

	if(nTargetId > 1){
		return SRB_STATUS_INVALID_REQUEST;
	}									  

	pDevice = pChannel->pDevice[nTargetId];

	if(pDevice == NULL){
		return SRB_STATUS_SELECTION_TIMEOUT;
	}										
	
	if(pDevice->DeviceFlags & DFLAGS_HAS_LOCKED){
		// already present a locked block, return error
		return SRB_STATUS_INVALID_REQUEST;
	}									  

	pDevice->nLockedLbaStart = nStartLbaAddress;
	pDevice->nLockedLbaEnd = nStartLbaAddress + nBlockSize;

	pDevice->DeviceFlags |= DFLAGS_HAS_LOCKED;
	
	return SRB_STATUS_SUCCESS;
}	 

/*++
 Function:
	 HptUtUnlockDeviceBlock

 Description:
	 Unlock a block on hard disk which was locked previous to allow the
	 READ/WRITE operation on it again.

 Argument:
	 pChannel - channel struct of the hard disk
	 nTarget - device id of the hard disk
	 nStartLbaAddress - the start LBA address want to be unlocked
	 nBlockSize - the block size

 Return:
	 ULONG SRB_STATUS
++*/

ULONG
   HptUtUnlockDeviceBlock(
						  IN PChannel	pChannel,
						  IN ULONG		nTargetId,
						  IN ULONG		nStartLbaAddress,
						  IN ULONG		nBlockSize
						 )
{
	PDevice pDevice;

	if(nTargetId > 1){
		return SRB_STATUS_INVALID_REQUEST;
	}									  

	pDevice = pChannel->pDevice[nTargetId];

	if(pDevice == NULL){
		return SRB_STATUS_SELECTION_TIMEOUT;
	}										

	if((pDevice->nLockedLbaStart != nStartLbaAddress)&&
	   (pDevice->nLockedLbaEnd != nStartLbaAddress + nBlockSize)){

		// skip it to avoid GUI programming error
		// return SRB_STATUS_INVALID_REQUEST;
	}									  

	pDevice->DeviceFlags &= ~DFLAGS_HAS_LOCKED;
	pDevice->nLockedLbaStart = -1;
	pDevice->nLockedLbaEnd = 0;

	return SRB_STATUS_SUCCESS;
}
/*++
Function:
    HptUtGetIdentifyData

Description:
    Get identify data for specify device

Arguments:
    HwDeviceExtension - HBA miniport driver's adapter data storage
	nTargetId - id for target device
	pIdentifyData - data buffer for store indentify data

Returns:
	ULONG	SRB_STATUS
--*/

ULONG
   HptUtGetIdentifyData(
						IN PChannel pChannel,				// HW_DEVICE_EXTENSION
						IN ULONG nTargetId,					// Id for target device
						OUT PSt_IDENTIFY_DATA	pIdentifyData // data buffer for store indentify data
					   )
{
	int i;
	WORD Tmp;

	PDevice pDev;
	PIDENTIFY_DATA2 pIdentifyOfDevice;
	//
	// Target id should only between 0 and 1
	//
	if(nTargetId > 1){
		return SRB_STATUS_INVALID_REQUEST;
	}

	pDev = pChannel->pDevice[nTargetId];

	if(pDev == NULL){
		return SRB_STATUS_SELECTION_TIMEOUT;
	}

	pIdentifyOfDevice = &pDev->IdentifyData;

	pIdentifyData->nNumberOfCylinders = pIdentifyOfDevice->NumberOfCylinders;
	pIdentifyData->nNumberOfHeads = pIdentifyOfDevice->NumberOfHeads;
	pIdentifyData->nSectorsPerTrack = pIdentifyOfDevice->SectorsPerTrack;
	pIdentifyData->nBytesPerSector = 512; // physical sector size
	pIdentifyData->nUserAddressableSectors = pIdentifyOfDevice->UserAddressableSectors;

	for(i = 0; i < 10; i++){																
		Tmp = pIdentifyOfDevice->SerialNumber[i];
		pIdentifyData->st20_SerialNumber[i*2 + 1] = (UCHAR)(Tmp);
		pIdentifyData->st20_SerialNumber[i*2] = (UCHAR)(Tmp >> 8);
	}

	for(i = 0; i < 4; i++){																
		Tmp = pIdentifyOfDevice->FirmwareRevision[i];
		pIdentifyData->st8_FirmwareRevision[i*2 + 1] = (UCHAR)(Tmp);
		pIdentifyData->st8_FirmwareRevision[i*2] = (UCHAR)(Tmp >> 8);
	}
	memcpy(&pIdentifyData->st40_ModelNumber,
		   pIdentifyOfDevice->ModelNumber,
		   sizeof(pIdentifyData->st40_ModelNumber));

	return SRB_STATUS_SUCCESS;
}

/*++
Function:
    HptUtGetRaidInfo

Description:
    Get RAID info stored on disk

Arguments:
    pChannel - channel relate info
	nTargetId - id for target device
	pDiskArrayInfo - data buffer for store disk array info

Note:
	To call this function, be sure the device is connected.
Returns:
	ULONG	SRB_STATUS
--*/
ULONG
   HptUtGetRaidInfo(
					IN PChannel pChannel,				// pChannel
					IN ULONG nTargetId,					// Id for target device
					OUT PSt_DISK_ARRAY_INFO	pDiskArrayInfo // data buffer for store disk array info
				   )
{	   
	PDevice	pDevSource, pDevTarget;
	PVirtualDevice pArraySource, pArrayTarget;
	

	pDevSource = pChannel->pDevice[nTargetId];							  

	memset(pDiskArrayInfo, 0, sizeof(St_DISK_ARRAY_INFO));

	if(pDevSource == NULL){
		return SRB_STATUS_INVALID_REQUEST;
	}

	pArraySource = pDevSource->pArray;

	if(pArraySource != NULL){
		
		pDiskArrayInfo->uliGroupNumber.LowPart = pArraySource->Stamp;
		pDiskArrayInfo->uliGroupNumber.HighPart = (ULONG)pArraySource;
		pDiskArrayInfo->nMemberCount = pArraySource->nDisk;
		
		pDiskArrayInfo->nCylinders = 0;
		pDiskArrayInfo->nHeads = 0;
		pDiskArrayInfo->nSectorsPerTrack = 0;
		pDiskArrayInfo->nBytesPerSector = 512;
		pDiskArrayInfo->nCapacity = pArraySource->capacity;

		switch(pArraySource->arrayType){
			case VD_SPAN:
			{	  
				pDiskArrayInfo->nDiskSets = pDevSource->ArrayNum + 4;
			}
			break;
			case VD_RAID_0_STRIPE:
			{
				pDiskArrayInfo->nDiskSets = pDevSource->ArrayNum * 2;
			}
			break;
			case VD_RAID_01_2STRIPE:
			{													  
				pDevTarget = pArraySource->pDevice[MIRROR_DISK];
				if(pDevTarget != NULL){
					pArrayTarget = pDevTarget->pArray;
					pDiskArrayInfo->nMemberCount = pArraySource->nDisk + pArrayTarget->nDisk;
				}else{		 
					pDiskArrayInfo->nMemberCount = pArraySource->nDisk;
				}
				pDiskArrayInfo->nDiskSets = pDevSource->ArrayNum * 2;
			}
			break;

			case VD_RAID_1_MIRROR:						   
			{
				pDiskArrayInfo->nMemberCount = 2;
				if(pDevSource->ArrayNum == MIRROR_DISK){
					pDiskArrayInfo->nDiskSets = 1;
				}else if(pDevSource->ArrayNum == SPARE_DISK){
					pDiskArrayInfo->nDiskSets = 7;
				}else{
					pDiskArrayInfo->nDiskSets = 0;
				}
			}
			break;

			case VD_RAID01_MIRROR:
			{
				pDevTarget = pArraySource->pDevice[MIRROR_DISK];
				if(pDevTarget != NULL){
					pArrayTarget = pDevTarget->pArray;
					pDiskArrayInfo->nMemberCount = pArraySource->nDisk + pArrayTarget->nDisk;
					pDiskArrayInfo->uliGroupNumber.LowPart = pArrayTarget->Stamp;
					pDiskArrayInfo->uliGroupNumber.HighPart = (ULONG)pArrayTarget;
					pDiskArrayInfo->nDiskSets = (pDevSource->ArrayNum * 2) + 1;
				}else{		 
					pDiskArrayInfo->uliGroupNumber.LowPart = pArraySource->Stamp;
					pDiskArrayInfo->uliGroupNumber.HighPart = (ULONG)pArraySource;
					pDiskArrayInfo->nMemberCount = pArraySource->nDisk;
					pDiskArrayInfo->nDiskSets = pDevSource->ArrayNum * 2;
				}
			}
			break;

			case VD_RAID_01_1STRIPE:
			{
				pDevTarget = pArraySource->pDevice[MIRROR_DISK];
				if(pDevTarget != NULL){
					pArrayTarget = pDevTarget->pArray;
					pDiskArrayInfo->nMemberCount = pArraySource->nDisk + 1;
					pDiskArrayInfo->uliGroupNumber.LowPart = pArrayTarget->Stamp;
					pDiskArrayInfo->uliGroupNumber.HighPart = (ULONG)pArrayTarget;
					if(pDevSource == pDevTarget){
						pDiskArrayInfo->nDiskSets = 1;
					}else{
						pDiskArrayInfo->nDiskSets = pDevSource->ArrayNum * 2;
					}
				}else{		 
					pDiskArrayInfo->uliGroupNumber.LowPart = pArraySource->Stamp;
					pDiskArrayInfo->uliGroupNumber.HighPart = (ULONG)pArraySource;
					pDiskArrayInfo->nMemberCount = pArraySource->nDisk;
					pDiskArrayInfo->nDiskSets = pDevSource->ArrayNum * 2;
				}
			}
			break;

			default:
				memset(pDiskArrayInfo, 0, sizeof(St_DISK_ARRAY_INFO));
				break;
		}
	}

	return SRB_STATUS_SUCCESS;
}

/*++
Function:
    HptUtFillPhysicalInfo

Description:
    Fill the physical device specified by "nTargetId" to buffer "pPhysDevInfo"

Arguments:
	pChannel - channal related data
	nTargetId - id for target device
	pPhysDevInfo - data buffer for store disk physical info

Note:

Returns:
	ULONG	SRB_STATUS
--*/		  
ULONG
   HptUtFillPhysicalInfo(
						 IN PChannel	pChannel,				// pChannel data
						 IN ULONG	nTargetId,				// Id for target device
						 OUT PSt_PHYSICAL_DEVINFO	pPhysDevInfo // data buffer for store the array
						)
{ 

	pPhysDevInfo->nSize = sizeof(St_PHYSICAL_DEVINFO);

	//
	// Fill the identify info
	//
	HptUtGetIdentifyData(pChannel,
						 nTargetId,
						 &pPhysDevInfo->IdentifyData);

	//
	// Fill the capability data structure
	//
	pPhysDevInfo->CapabilityData.DeviceType = DEVTYPE_DIRECT_ACCESS_DEVICE;
	if(pChannel->pDevice[nTargetId]->DeviceFlags & DFLAGS_REMOVABLE_DRIVE){
		pPhysDevInfo->CapabilityData.RemovableMedia = 1;
	}

	//
	// Fill the RAID info
	//
	HptUtGetRaidInfo(pChannel,
					 nTargetId,
					 &pPhysDevInfo->DiskArrayInfo);

	return SRB_STATUS_SUCCESS;

}						  

ULONG
   HptUtGetLastError(
					 IN PChannel pChannel,
					 IN ULONG nTargetId,
					 OUT PSt_HPT_ERROR_RECORD pErrorRecord
					)
{
	PDevice	pDev;
	
	memset(pErrorRecord, 0, sizeof(St_HPT_ERROR_RECORD));
	
	pDev = pChannel->pDevice[nTargetId];

	pErrorRecord->nLastError = pDev->stErrorLog.nLastError;
	
	return SRB_STATUS_SUCCESS;
}
/*
 * HptUtGetLastErrorDevice
 * this function check and return the device which occurs error most
 * recently, and return the CDB code in pDeviceErrorRecord stucture.
 */																	
ULONG
   HptUtGetLastErrorDevice(
						   IN	PHW_DEVICE_EXTENSION	pHwDeviceExtension,
						   OUT	PSt_DiskFailure	pDeviceErrorRecord
						  )
{		
	memset(pDeviceErrorRecord, 0, sizeof(St_DiskFailure));
						 
	if(g_pErrorDevice == NULL){
		pDeviceErrorRecord->hDisk = INVALID_HANDLE_VALUE;
	}else{
		memcpy(&pDeviceErrorRecord->vecCDB, &g_pErrorDevice->stErrorLog.Cdb, sizeof(pDeviceErrorRecord->vecCDB));
		pDeviceErrorRecord->hDisk = Device_GetHandle(g_pErrorDevice);

/////////////// Added by SLeng
		if(g_pErrorDevice->stErrorLog.nLastError == DEVICE_PLUGGED)
		{
			pDeviceErrorRecord->HotPlug = 0x01;
		}
///////////////

		if(g_pErrorDevice->pArray != NULL){
			pDeviceErrorRecord->bNeedRebuild = ((g_pErrorDevice->pArray->RaidFlags & RAID_FLAGS_NEED_SYNCHRONIZE) != 0);
			//(*ppErrorDevice)->pArray->RaidFlags &= ~RAID_FLAGS_NEED_REBUILD;
		}

		g_pErrorDevice = g_pErrorDevice->stErrorLog.pNextErrorDevice;
	}
	
	return SRB_STATUS_SUCCESS;
}

/*
 * call this in case of ioctl R/W fail before WinStartCommand.
 */
void restore_path_target_lun( IN PHW_DEVICE_EXTENSION pHwDeviceExtension,
								  IN PSCSI_REQUEST_BLOCK pSrb)
{
	PSrbExtension pSrbExt = (PSrbExtension)pSrb->SrbExtension;
	pSrb->PathId = pSrbExt->OriginalPathId;
	pSrb->TargetId = pSrbExt->OriginalTargetId;
	pSrb->Lun = pSrbExt->OriginalLun;
}

/*++
Function:
    ULONG   HptIsValidDeviceSpecifiedIoControl

Description:
	Check the Srb is whether a device specified IO control, if so,
	update the SRB data field to correct value.

Arguments:
    Srb - IO request packet

Returns:
	TRUE:	is a vaild device specified IO control
	FALSE:	not a vaild device specified IO control
--*/
												   
BOOLEAN
   HptIsValidDeviceSpecifiedIoControl(IN PSCSI_REQUEST_BLOCK pSrb)
{
	PSt_HPT_LUN	pLun;
	PSrbExtension pSrbExt;

	PSRB_IO_CONTROL pSrbIoCtl = (PSRB_IO_CONTROL)(pSrb->DataBuffer);
	pLun = (PSt_HPT_LUN)(pSrbIoCtl + 1);

	if((pSrbIoCtl->ControlCode == IOCTL_HPT_MINIPORT_EXECUTE_CDB)||
	   (pSrbIoCtl->ControlCode == IOCTL_HPT_MINIPORT_SCSI_PASSTHROUGH)){

		pSrbExt = (PSrbExtension)pSrb->SrbExtension;

		pSrbExt->OriginalPathId = pSrb->PathId;
		pSrbExt->OriginalTargetId = pSrb->TargetId;
		pSrbExt->OriginalLun = pSrb->Lun;
		
		pSrb->PathId = (CHAR)(pLun->nPathId);
		pSrb->TargetId = (CHAR)(pLun->nTargetId);
		pSrb->Lun = (CHAR)(pLun->nLun);
		
		pSrbExt->WorkingFlags |= SRB_WFLAGS_HAS_CALL_BACK;
		pSrbExt->pfnCallBack = restore_path_target_lun;
		
		return TRUE;
	}
	return FALSE;
}

/*
 * HptDeviceExecuteCDBCallBack
 * 
 * This call back routine will be called before call
 * ScsiPortNotification with RequestComplete notification. these
 * protocol let device driver can restore the change of SRB it make
 * before the system refer it again
 */								   
void HptDeviceExecuteCDBCallBack( IN PHW_DEVICE_EXTENSION pHwDeviceExtension,
								  IN PSCSI_REQUEST_BLOCK pSrb)
{
	PSrbExtension pSrbExt = (PSrbExtension)pSrb->SrbExtension;
	ULONG	nLength = pSrb->DataTransferLength;
	PULONG pSource = (PULONG)pSrb->DataBuffer;
	PULONG pTarget = (PULONG)(((PCHAR)pSrb->DataBuffer)+
					   sizeof(SRB_IO_CONTROL)+
					   sizeof(St_HPT_LUN)+
					   sizeof(St_HPT_EXECUTE_CDB));

	KdPrint(("ExecuteCDBCallback(%d,%d,%s,%d)", pSrb->PathId, pSrb->TargetId, 
		(pSrb->SrbFlags & SRB_FLAGS_DATA_IN)? "R" : "W", pSrb->SrbStatus));

	if(pSrb->SrbFlags & SRB_FLAGS_DATA_IN){
		_asm{
			pushf;
			pusha;
			mov		esi, pSource;
			mov		edi, pTarget;
			mov		ecx, nLength;
			mov		ebx, ecx;

			add		esi, ecx;
			add		edi, ecx;
			sub		esi, 4;
			sub		edi, 4;
			shr		ecx, 2;
			std;
			rep		movsd;
			mov		ecx, ebx;
			and		ecx, 3;
			std;
			rep		movsb;

			popa;
			popf;
		}									   
	}

	pSrb->DataTransferLength += sizeof(SRB_IO_CONTROL) + sizeof(St_HPT_LUN) + sizeof(St_HPT_EXECUTE_CDB);
	pSrb->PathId = pSrbExt->OriginalPathId;
	pSrb->TargetId = pSrbExt->OriginalTargetId;
	pSrb->Lun = pSrbExt->OriginalLun;
}
/*++
Function:
    VOID   HptDeviceSpecifiedIoControl

Description:
    Process private device specified IO controls sent down directly
    from an application, the device specified IO controls mean the IO
    control need a device to work, just like CDB_EXECUTE

Arguments:
    HwDeviceExtension - HBA miniport driver's adapter data storage
    Srb - IO request packet

Returns:
    SRB_STATUS_SUCCESS if the IO control supported
    SRB_STATUS_INVALID_REQUEST if the IO control not supported
--*/
VOID
   HptDeviceSpecifiedIoControl(
							   IN PDevice pDevice,
							   IN PSCSI_REQUEST_BLOCK pSrb
							  )
{
	PSt_HPT_LUN	pLun;
	PSrbExtension pSrbExtension;
	
	PSRB_IO_CONTROL pSrbIoCtl = (PSRB_IO_CONTROL)(pSrb->DataBuffer);
	pLun = (PSt_HPT_LUN)(pSrbIoCtl + 1);


	pSrbExtension = (PSrbExtension)pSrb->SrbExtension;

	switch(pSrbIoCtl->ControlCode){
		case IOCTL_HPT_MINIPORT_EXECUTE_CDB:
		{					  
			PSt_HPT_EXECUTE_CDB	pExecuteCdb;
			pExecuteCdb = (PSt_HPT_EXECUTE_CDB)(pLun + 1);
			
			pSrbExtension->WorkingFlags |= SRB_WFLAGS_IGNORE_ARRAY|SRB_WFLAGS_HAS_CALL_BACK|SRB_WFLAGS_MUST_DONE;

			pSrb->CdbLength = pExecuteCdb->CdbLength;
			
			memcpy(&pSrb->Cdb, &pExecuteCdb->Cdb, pExecuteCdb->CdbLength);

			pSrb->DataTransferLength -= sizeof(SRB_IO_CONTROL) + sizeof(St_HPT_LUN) + sizeof(St_HPT_EXECUTE_CDB);

			if(pExecuteCdb->OperationFlags & OPERATION_FLAGS_DATA_IN){
				pSrb->SrbFlags = (pSrb->SrbFlags & ~SRB_FLAGS_DATA_OUT) | SRB_FLAGS_DATA_IN;
			}else{
				pSrb->SrbFlags = (pSrb->SrbFlags & ~SRB_FLAGS_DATA_IN) | SRB_FLAGS_DATA_OUT;
				memcpy(pSrb->DataBuffer, (pExecuteCdb + 1), pSrb->DataTransferLength);
			}															  
			
			pSrbExtension->pfnCallBack = HptDeviceExecuteCDBCallBack;
		}
		break;

		case IOCTL_HPT_MINIPORT_SCSI_PASSTHROUGH:
		{	  
			PSt_HPT_EXECUTE_CDB pExecuteCdb;
			pExecuteCdb = (PSt_HPT_EXECUTE_CDB)(pLun + 1);
			pSrbExtension->WorkingFlags |= SRB_WFLAGS_HAS_CALL_BACK|SRB_WFLAGS_MUST_DONE;

			pSrb->CdbLength = pExecuteCdb->CdbLength;
			
			if(pExecuteCdb->OperationFlags & OPERATION_FLAGS_ON_MIRROR_DISK){
				pSrbExtension->WorkingFlags |= SRB_WFLAGS_ON_MIRROR_DISK;
			}
			if(pExecuteCdb->OperationFlags & OPERATION_FLAGS_ON_SOURCE_DISK){
				pSrbExtension->WorkingFlags |= SRB_WFLAGS_ON_SOURCE_DISK;
			}

			memcpy(&pSrb->Cdb, &pExecuteCdb->Cdb, pExecuteCdb->CdbLength);

			pSrb->DataTransferLength -= sizeof(SRB_IO_CONTROL) + sizeof(St_HPT_LUN) + sizeof(St_HPT_EXECUTE_CDB);
			
			if(pExecuteCdb->OperationFlags & OPERATION_FLAGS_DATA_IN){
				pSrb->SrbFlags = (pSrb->SrbFlags & ~SRB_FLAGS_DATA_OUT) | SRB_FLAGS_DATA_IN;
			}else{
				pSrb->SrbFlags = (pSrb->SrbFlags & ~SRB_FLAGS_DATA_IN) | SRB_FLAGS_DATA_OUT;
				memcpy(pSrb->DataBuffer, (pExecuteCdb + 1), pSrb->DataTransferLength);
			}

			pSrbExtension->pfnCallBack = HptDeviceExecuteCDBCallBack;
		}
		break;

		default:
		{	  
		}	  
		break;
	}
}
/*++
Function:
    ULONG   HptIoControl

Description:
    Process private IO controls sent down directly from an application

Arguments:
    HwDeviceExtension - HBA miniport driver's adapter data storage
    Srb - IO request packet

Returns:
    SRB_STATUS_SUCCESS if the IO control supported
    SRB_STATUS_INVALID_REQUEST if the IO control not supported
--*/
ULONG
HptIoControl(
	IN PHW_DEVICE_EXTENSION HwDeviceExtension,
	IN PSCSI_REQUEST_BLOCK	pSrb
	)
{
	ULONG status;
	PSt_HPT_LUN pLun;
	PSRB_IO_CONTROL pSrbIoCtl = (PSRB_IO_CONTROL)(pSrb->DataBuffer);
	pLun = (PSt_HPT_LUN)(pSrbIoCtl + 1);

	switch(pSrbIoCtl->ControlCode){
		case IOCTL_HPT_MINIPORT_GET_VERSION:
		{
			PSt_HPT_VERSION_INFO pHptVerInfo;
			if(pSrbIoCtl->Length < (sizeof(St_HPT_VERSION_INFO) + sizeof(St_HPT_LUN))){
				status = SRB_STATUS_INVALID_REQUEST;
				break;
			}

			pHptVerInfo = (PSt_HPT_VERSION_INFO)(pLun+1);
			memset(pHptVerInfo, 0, sizeof(St_HPT_VERSION_INFO));
			pHptVerInfo->dwVersionInfoSize = sizeof(St_HPT_VERSION_INFO);
			pHptVerInfo->dwDriverVersion = VERSION_NUMBER;
			pHptVerInfo->dwPlatformId = PLATFORM_ID_WIN32_NT;
			pHptVerInfo->dwSupportFunction |= HPT_FUNCTION_RAID;
			while (pHptVerInfo->ControllerId<num_adapters &&
					hpt_adapters[pHptVerInfo->ControllerId]!=HwDeviceExtension)
				pHptVerInfo->ControllerId++;

			status = SRB_STATUS_SUCCESS;
		}
		break;
									 
		case IOCTL_HPT_MINIPORT_GET_IDENTIFY_INFO:
		{
			PSt_IDENTIFY_DATA	pIdentifyData;
			if(pSrbIoCtl->Length < (sizeof(St_HPT_LUN)+sizeof(St_IDENTIFY_DATA))){
				status = SRB_STATUS_INVALID_REQUEST;
				break;
			}				 
									
			if((pLun->nPathId > 1)||(pLun->nTargetId > 1)){
				status = SRB_STATUS_INVALID_REQUEST;
				break;
			}
			
			pIdentifyData = (PSt_IDENTIFY_DATA)(pLun+1);
			
			status = HptUtGetIdentifyData(
										  &(HwDeviceExtension->IDEChannel[pLun->nPathId]),
										  pLun->nTargetId,
										  pIdentifyData
										 );
			
		}
		break;								

		case IOCTL_HPT_MINIPORT_GET_RAID_INFO:
		{									   
			PSt_DISK_ARRAY_INFO	pDiskArrayInfo;
			
			if(pSrbIoCtl->Length < (sizeof(St_HPT_LUN)+sizeof(St_DISK_ARRAY_INFO))){
				status = SRB_STATUS_INVALID_REQUEST;
				break;
			}
			
			if((pLun->nPathId > 1)||(pLun->nTargetId > 1)){
				status = SRB_STATUS_INVALID_REQUEST;
				break;
			}
			pDiskArrayInfo = (PSt_DISK_ARRAY_INFO)(pLun + 1);
			status = HptUtGetRaidInfo(
									  &(HwDeviceExtension->IDEChannel[pLun->nPathId]),
									  pLun->nTargetId,
									  pDiskArrayInfo
									 );
			
		}
		break;

		case IOCTL_HPT_MINIPORT_GET_LAST_ERROR:
		{	 
			PSt_HPT_ERROR_RECORD pErrorRecord;

			if(pSrbIoCtl->Length < (sizeof(St_HPT_LUN) + sizeof(St_HPT_ERROR_RECORD))){
				status = SRB_STATUS_INVALID_REQUEST;
				break;
			}		  


			if((pLun->nPathId > 1)||(pLun->nTargetId > 1)){
				status = SRB_STATUS_INVALID_REQUEST;
				break;
			}		  

			pErrorRecord = (PSt_HPT_ERROR_RECORD)(pLun+1);

			status = HptUtGetLastError(
									   &(HwDeviceExtension->IDEChannel[pLun->nPathId]),
									   pLun->nTargetId,
									   pErrorRecord
									  );

		}
		break;

		case IOCTL_HPT_MINIPORT_GET_LAST_ERROR_DEVICE:
		{	  
			PSt_DiskFailure pDeviceErrorRecord;

			if(pSrbIoCtl->Length < (sizeof(St_HPT_LUN) + sizeof(St_DiskFailure))){
				status = SRB_STATUS_INVALID_REQUEST;
				break;
			}		  

			pDeviceErrorRecord = (PSt_DiskFailure)(pLun+1);

			status = HptUtGetLastErrorDevice(
									   HwDeviceExtension,
									   pDeviceErrorRecord
									  );
		}
		break;

		case IOCTL_HPT_MINIPORT_SET_NOTIFY_EVENT:
		{							  
			PSt_HPT_NOTIFY_EVENT	pNotifyEvent;

			if(pSrbIoCtl->Length < (sizeof(St_HPT_LUN) + sizeof(St_HPT_NOTIFY_EVENT))){
				status = SRB_STATUS_INVALID_REQUEST;
				break;
			}		  
						  
			pNotifyEvent = (PSt_HPT_NOTIFY_EVENT)(pLun + 1);
			
			g_hAppNotificationEvent = PrepareForNotification(pNotifyEvent->hEvent);
			status = SRB_STATUS_SUCCESS;
		}
		break;

		case IOCTL_HPT_MINIPORT_REMOVE_NOTIFY_EVENT:
		{					 
			CloseNotifyEventHandle(g_hAppNotificationEvent);
			g_hAppNotificationEvent = NULL;
			status = SRB_STATUS_SUCCESS;
		}
		break;

		case IOCTL_HPT_MINIPORT_ENUM_GET_DEVICE_INFO:
		{
			PSt_HPT_ENUM_GET_DEVICE_INFO pEnumDeviceInfo;
			if(pSrbIoCtl->Length < (sizeof(St_HPT_ENUM_GET_DEVICE_INFO) + sizeof(St_HPT_LUN))){
				status = SRB_STATUS_INVALID_REQUEST;
				break;
			}		  

			pEnumDeviceInfo = (PSt_HPT_ENUM_GET_DEVICE_INFO)(pLun + 1);

			status = SRB_STATUS_SUCCESS;

			if(!Device_GetInfo(
							   pEnumDeviceInfo->hDeviceNode,
							   &pEnumDeviceInfo->DiskStatus
							  )){
				status = SRB_STATUS_INVALID_REQUEST;
			}
		}
		break;

		case IOCTL_HPT_MINIPORT_ENUM_GET_DEVICE_CHILD:
		{	 
			PSt_HPT_ENUM_DEVICE_RELATION pEnumDeviceRelation;
			if(pSrbIoCtl->Length < (sizeof(St_HPT_ENUM_DEVICE_RELATION) + sizeof(St_HPT_LUN))){
				status = SRB_STATUS_INVALID_REQUEST;
				break;
			}		  

			pEnumDeviceRelation = (PSt_HPT_ENUM_DEVICE_RELATION)(pLun + 1);

			status = SRB_STATUS_SUCCESS;

			if(!Device_GetChild(
								pEnumDeviceRelation->hNode,
								&pEnumDeviceRelation->hRelationNode
							   )){
				status = SRB_STATUS_INVALID_REQUEST;
			}
		}
		break;

		case IOCTL_HPT_MINIPORT_ENUM_GET_DEVICE_SIBLING:
		{
			PSt_HPT_ENUM_DEVICE_RELATION pEnumDeviceRelation;

			if(pSrbIoCtl->Length < (sizeof(St_HPT_ENUM_DEVICE_RELATION) + sizeof(St_HPT_LUN))){
				status = SRB_STATUS_INVALID_REQUEST;
				break;
			}		  

			pEnumDeviceRelation = (PSt_HPT_ENUM_DEVICE_RELATION)(pLun + 1);

			status = SRB_STATUS_SUCCESS;

			if(!Device_GetSibling(
								  pEnumDeviceRelation->hNode,
								  &pEnumDeviceRelation->hRelationNode
								 )){
				status = SRB_STATUS_INVALID_REQUEST;
			}
		}
		break;								   

		case IOCTL_HPT_MINIPORT_ENUM_GET_CONTROLLER_NUMBER:
		{													 
			PSt_HPT_ENUM_GET_CONTROLLER_NUMBER pControllerNumber;

			if(pSrbIoCtl->Length < (sizeof(St_HPT_ENUM_GET_CONTROLLER_NUMBER) + sizeof(St_HPT_LUN))){
				status = SRB_STATUS_INVALID_REQUEST;
				break;
			}		  

			pControllerNumber = (PSt_HPT_ENUM_GET_CONTROLLER_NUMBER)(pLun + 1);

			pControllerNumber->nControllerNumber = RAIDController_GetNum();
			
			status = SRB_STATUS_SUCCESS;
			
		}												  
		break;

		case IOCTL_HPT_MINIPORT_ENUM_GET_CONTROLLER_INFO:
		{
			PSt_HPT_ENUM_GET_CONTROLLER_INFO pControllerInfo;

			if(pSrbIoCtl->Length < (sizeof(St_HPT_ENUM_GET_CONTROLLER_INFO) + sizeof(St_HPT_LUN))){
				status = SRB_STATUS_INVALID_REQUEST;
				break;
			}		  

			pControllerInfo = (PSt_HPT_ENUM_GET_CONTROLLER_INFO)(pLun + 1);
			
			status = SRB_STATUS_SUCCESS;

			if( !RAIDController_GetInfo(
									   pControllerInfo->iController,
									   &pControllerInfo->stControllerInfo
									 ) ){
				status = SRB_STATUS_INVALID_REQUEST;
			}
		}
		break;

		case IOCTL_HPT_MINIPORT_LOCK_BLOCK:
		{
			PSt_HPT_BLOCK pLockBlock;  

			if(pSrbIoCtl->Length < (sizeof(St_HPT_BLOCK) + sizeof(St_HPT_LUN))){
				status = SRB_STATUS_INVALID_REQUEST;
				break;
			}		  

			pLockBlock = (PSt_HPT_BLOCK)(pLun + 1);

			status = HptUtLockDeviceBlock(
										  &(HwDeviceExtension->IDEChannel[pLun->nPathId]),
										  pLun->nTargetId,
										  pLockBlock->nStartLbaAddress,
										  pLockBlock->nBlockSize
										 );
		}
		break;

		case IOCTL_HPT_MINIPORT_UNLOCK_BLOCK:
		{							 
			PSt_HPT_BLOCK pLockBlock;  

			if(pSrbIoCtl->Length < (sizeof(St_HPT_BLOCK) + sizeof(St_HPT_LUN))){
				status = SRB_STATUS_INVALID_REQUEST;
				break;
			}		  

			pLockBlock = (PSt_HPT_BLOCK)(pLun + 1);

			status = HptUtUnlockDeviceBlock(
											&(HwDeviceExtension->IDEChannel[pLun->nPathId]),
											pLun->nTargetId,
											pLockBlock->nStartLbaAddress,
											pLockBlock->nBlockSize
										   );
			{
				/* checking waiting list */
				PSCSI_REQUEST_BLOCK WaitingSrb;
				PSrbExtension pSrbExt;
				PDevice WaitingDev = 
					HwDeviceExtension->IDEChannel[pLun->nPathId].pDevice[pLun->nTargetId];
				if (WaitingDev && (WaitingDev->DeviceFlags & DFLAGS_HAS_LOCKED)==0) {
					while (WaitingSrb = WaitingDev->pWaitingSrbList) {
						pSrbExt = WaitingSrb->SrbExtension;
						WaitingDev->pWaitingSrbList = 
							(PSCSI_REQUEST_BLOCK)pSrbExt->ArraySg[0].SgAddress;
						IdeSendCommand(WaitingDev, WaitingSrb);
						if (WaitingSrb->SrbStatus != SRB_STATUS_PENDING &&
							!(pSrbExt->WorkingFlags & SRB_WFLAGS_ARRAY_IO_STARTED)){
							/* DeviceInterrupt() expects pSrbExt->member_status set */
							pSrbExt->member_status = WaitingSrb->SrbStatus;
							DeviceInterrupt(WaitingDev, WaitingSrb);
						}
					}
				}
			}
		}
		break;

		case IOCTL_HPT_MINIPORT_CREATE_MIRROR:
		{
			PSt_HPT_CREATE_RAID	pstCreateRaid;

			pstCreateRaid = (PSt_HPT_CREATE_RAID)(pLun + 1);

			if(pSrbIoCtl->Length < (sizeof(St_HPT_CREATE_RAID)+
									sizeof(St_HPT_LUN)+
									pstCreateRaid->nDisks*sizeof(HDISK))){
				status = SRB_STATUS_INVALID_REQUEST;
				break;
			}

			pstCreateRaid->hRaidDisk = Device_CreateMirror(
				&pstCreateRaid->aryhDisks[0],
				pstCreateRaid->nDisks
				);
			
			status = SRB_STATUS_SUCCESS;
		}
		break;

		case IOCTL_HPT_MINIPORT_CREATE_STRIPE:
		{
			PSt_HPT_CREATE_RAID	pstCreateRaid;

			pstCreateRaid = (PSt_HPT_CREATE_RAID)(pLun + 1);

			if(pSrbIoCtl->Length < (sizeof(St_HPT_CREATE_RAID)+
									sizeof(St_HPT_LUN)+
									pstCreateRaid->nDisks*sizeof(HDISK))){
				status = SRB_STATUS_INVALID_REQUEST;
				break;
			}

			pstCreateRaid->hRaidDisk = Device_CreateStriping(
				&pstCreateRaid->aryhDisks[0],
				pstCreateRaid->nDisks,
				pstCreateRaid->nStripeBlockSizeShift
				);
			
			status = SRB_STATUS_SUCCESS;
		}
		break;

		case IOCTL_HPT_MINIPORT_CREATE_SPAN:
		{
			PSt_HPT_CREATE_RAID	pstCreateRaid;

			pstCreateRaid = (PSt_HPT_CREATE_RAID)(pLun + 1);

			if(pSrbIoCtl->Length < (sizeof(St_HPT_CREATE_RAID)+
									sizeof(St_HPT_LUN)+
									pstCreateRaid->nDisks*sizeof(HDISK))){
				status = SRB_STATUS_INVALID_REQUEST;
				break;
			}

			pstCreateRaid->hRaidDisk = Device_CreateSpan(
				&pstCreateRaid->aryhDisks[0],
				pstCreateRaid->nDisks);	
			
			status = SRB_STATUS_SUCCESS;
		}
		break;

		case IOCTL_HPT_MINIPORT_REMOVE_RAID:
		{
			PSt_HPT_REMOVE_RAID	pstRemoveRaid;
															
			if(pSrbIoCtl->Length < (sizeof(St_HPT_REMOVE_RAID)+sizeof(St_HPT_LUN))){
				status = SRB_STATUS_INVALID_REQUEST;
				break;
			}
			pstRemoveRaid = (PSt_HPT_REMOVE_RAID)(pLun + 1);

			if(!Device_Remove(pstRemoveRaid->hDisk)){
				status = SRB_STATUS_INVALID_REQUEST;
			}else{
				status = SRB_STATUS_SUCCESS;
			}
		}
		break;
		
		case IOCTL_HPT_MINIPORT_ABORT_MIRROR_REBUILDING:
		{
			HDISK *	phMirror;
															
			if(pSrbIoCtl->Length < (sizeof(HDISK)+sizeof(St_HPT_LUN)))
			{
				status = SRB_STATUS_INVALID_REQUEST;
				break;
			}
			
			phMirror = (HDISK *)(pLun + 1);

			if( !Device_AbortMirrorBuilding( *phMirror ) )
			{
				status = SRB_STATUS_INVALID_REQUEST;
			}else
			{
				status = SRB_STATUS_SUCCESS;
			}
		}
		break;
		
		case IOCTL_HPT_MINIPORT_BEGIN_REBUILDING_MIRROR:
		{
			HDISK *	phMirror;
															
			if(pSrbIoCtl->Length < (sizeof(HDISK)+sizeof(St_HPT_LUN)))
			{
				status = SRB_STATUS_INVALID_REQUEST;
				break;
			}
			
			phMirror = (HDISK *)(pLun + 1);

			if( !Device_BeginRebuildingMirror( *phMirror ) )
			{
				status = SRB_STATUS_INVALID_REQUEST;
			}else
			{
				status = SRB_STATUS_SUCCESS;
			}
		}
		break;
		
		case IOCTL_HPT_MINIPORT_VALIDATE_MIRROR:
		{
			HDISK *	phMirror;
															
			if(pSrbIoCtl->Length < (sizeof(HDISK)+sizeof(St_HPT_LUN)))
			{
				status = SRB_STATUS_INVALID_REQUEST;
				break;
			}
			
			phMirror = (HDISK *)(pLun + 1);

			if( !Device_ValidateMirror( *phMirror ) )
			{
				status = SRB_STATUS_INVALID_REQUEST;
			}else
			{
				status = SRB_STATUS_SUCCESS;
			}
		}
		break;
		
#ifdef SUPPORT_XPRO
////////////////////
		case IOCTL_HPT_MINIPORT_SET_XPRO:
		{
			extern DWORD	dwEnable;
			extern DWORD	Api_mem_Sz;
			extern DWORD	Masks;
			DWORD	*pdwXpro;
			
			if(pSrbIoCtl->Length < (8 + sizeof(St_HPT_LUN)))
			{
				status = SRB_STATUS_INVALID_REQUEST;
				break;
			}
			
			pdwXpro    = (DWORD *)(pLun + 1);
			dwEnable   = *pdwXpro;
			Api_mem_Sz = *(pdwXpro + 1);
			Masks      = ~(Api_mem_Sz - 1);

			status = SRB_STATUS_SUCCESS;
		}
		break;
////////////////////
#endif									// SUPPORT_XPRO

////////////////////
				  // Added by SLeng, 11/20/2000
				  //
		case IOCTL_HPT_MINIPORT_ENABLE_DEVICE:
		{
			PDevice  pDev;
			PChannel pChan;
			if(pSrbIoCtl->Length < sizeof(St_HPT_LUN))
			{
				status = SRB_STATUS_INVALID_REQUEST;
				break;
			}
			
			if((pLun->nPathId > 1)||(pLun->nTargetId > 1))
			{
				status = SRB_STATUS_INVALID_REQUEST;
				break;
			}

			pChan = &(HwDeviceExtension->IDEChannel[pLun->nPathId]);
			pDev  = &(pChan->Devices[pLun->nTargetId]);
			pDev->DeviceFlags2 &= ~DFLAGS_DEVICE_DISABLED;

		}
		break;

		case IOCTL_HPT_MINIPORT_DISABLE_DEVICE:
		{
			PDevice  pDev;
			PChannel pChan;
			if(pSrbIoCtl->Length < sizeof(St_HPT_LUN))
			{
				status = SRB_STATUS_INVALID_REQUEST;
				break;
			}

			if((pLun->nPathId > 1)||(pLun->nTargetId > 1))
			{
				status = SRB_STATUS_INVALID_REQUEST;
				break;
			}
			
			pChan = &(HwDeviceExtension->IDEChannel[pLun->nPathId]);
			pDev  = &(pChan->Devices[pLun->nTargetId]);
			pDev->DeviceFlags2 |= DFLAGS_DEVICE_DISABLED;

		}
		break;

		case IOCTL_HPT_MINIPORT_ADD_SPARE_DISK:
		{	
			// Add spare disk to a mirror array
			PSt_HPT_ADD_DISK	pstAddDisk;
															
			if(pSrbIoCtl->Length < (sizeof(St_HPT_ADD_DISK)+sizeof(St_HPT_LUN)))
			{
				status = SRB_STATUS_INVALID_REQUEST;
				break;
			}
			pstAddDisk = (PSt_HPT_ADD_DISK)(pLun + 1);

			if(!Device_AddSpare(pstAddDisk->hArray, pstAddDisk->hDisk))
			{
				status = SRB_STATUS_INVALID_REQUEST;
			}
			else
			{
				status = SRB_STATUS_SUCCESS;
			}
		}
		break;

		case IOCTL_HPT_MINIPORT_DEL_SPARE_DISK:
		{	
			// Del spare disk from a mirror array
			PSt_HPT_REMOVE_RAID	pstDelDisk;
															
			if(pSrbIoCtl->Length < (sizeof(St_HPT_REMOVE_RAID)+sizeof(St_HPT_LUN)))
			{
				status = SRB_STATUS_INVALID_REQUEST;
				break;
			}
			pstDelDisk = (PSt_HPT_REMOVE_RAID)(pLun + 1);

			if(!Device_DelSpare(pstDelDisk->hDisk))
			{
				status = SRB_STATUS_INVALID_REQUEST;
			}
			else
			{
				status = SRB_STATUS_SUCCESS;
			}
		}
		break;

		case IOCTL_HPT_MINIPORT_ADD_MIRROR_DISK:
		{	
			// Add mirror disk to a mirror array
			PSt_HPT_ADD_DISK	pstAddDisk;

			if(pSrbIoCtl->Length < (sizeof(St_HPT_ADD_DISK)+sizeof(St_HPT_LUN)))
			{
				status = SRB_STATUS_INVALID_REQUEST;
				break;
			}

			pstAddDisk = (PSt_HPT_ADD_DISK)(pLun + 1);			
			
			if(!Device_AddMirrorDisk( pstAddDisk->hArray, pstAddDisk->hDisk ))
			{
				status = SRB_STATUS_INVALID_REQUEST;
			}
			else
			{
				status = SRB_STATUS_SUCCESS;
			}
		}
		break;

		case IOCTL_HPT_MINIPORT_SET_ARRAY_NAME:	//added by wx 12/26/00
		{
			BYTE* pInfo = (BYTE*)(pLun +1);
		
			if(pSrbIoCtl->Length != (20 + sizeof(St_HPT_LUN))){
				status = SRB_STATUS_INVALID_REQUEST;
				break;
			}
			
			Device_SetArrayName(*((HDISK*)pInfo), (char*)((HDISK*)(pInfo+4)));
			
			status = SRB_STATUS_SUCCESS;
		}
		break;

		case IOCTL_HPT_MINIPORT_RESCAN_ALL:	//ldx added 
		{
			if (Device_RescanAll())
				status = SRB_STATUS_SUCCESS;
			else
				status = SRB_STATUS_INVALID_REQUEST;
		}
		break;
#ifndef WIN95
		case IOCTL_HPT_CHECK_NOTIFY_EVENT:
		{
			extern BOOLEAN g_bNotifyEvent;
			if (g_bNotifyEvent) {
				g_bNotifyEvent = FALSE;
				status = SRB_STATUS_SUCCESS;
			}
			else
				status = SRB_STATUS_ERROR;
			break;
		}
#endif
		case IOCTL_HPT_GET_DRIVER_CAPABILITIES:
		{
			PSt_DRIVER_CAPABILITIES pCap;

			if(pSrbIoCtl->Length < (sizeof(St_DRIVER_CAPABILITIES) + sizeof(St_HPT_LUN))){
				status = SRB_STATUS_INVALID_REQUEST;
				break;
			}		  

			pCap = (PSt_DRIVER_CAPABILITIES)(pLun + 1);
			if (pCap->dwSize==sizeof(St_DRIVER_CAPABILITIES)) {
				ZeroMemory(&pCap->dwSize+1, sizeof(St_DRIVER_CAPABILITIES)-4);
				pCap->MaximumControllers = MAX_HPT_BOARD;
				pCap->SupportCrossControllerRAID = 0;
				pCap->MinimumBlockSizeShift = 5;
				pCap->MaximumBlockSizeShift = 12;
				pCap->MaximumArrayNameLength = 8;
				pCap->SupportDiskModeSetting = 0;
				pCap->SupportSparePool = 0;
#define AT_RAID0	1
#define AT_RAID1	2
#define AT_RAID5	3
#define AT_JBOD		7
				pCap->SupportedRAIDTypes[0] = AT_RAID0;
				pCap->MaximumArrayMembers[0] = 4;
				pCap->SupportedRAIDTypes[1] = AT_RAID1;
				pCap->MaximumArrayMembers[1] = 3;
				pCap->SupportedRAIDTypes[2] = (AT_RAID1<<4)|AT_RAID0;
				pCap->MaximumArrayMembers[2] = 4;
				pCap->SupportedRAIDTypes[3] = AT_JBOD;
				pCap->MaximumArrayMembers[3] = 4;
			
				status = SRB_STATUS_SUCCESS;
			} 
			else
				status = SRB_STATUS_INVALID_REQUEST;
		}
		break;
		
#ifdef SUPPORT_HPT601			
		case IOCTL_HPT_GET_601_INFO:
		{
			PDevice pDev=HwDeviceExtension->IDEChannel[pLun->nPathId].pDevice[pLun->nTargetId];
			PSt_HPT601_INFO pInfo = (PSt_HPT601_INFO)(pLun + 1);
			if (pDev==0 ||
				pSrbIoCtl->Length < (sizeof(St_HPT601_INFO) + sizeof(St_HPT_LUN))){
				status = SRB_STATUS_INVALID_REQUEST;
				break;
			}		  
			if (Device_Get601Info(pDev, pInfo))
				status = SRB_STATUS_SUCCESS;
			else
				status = SRB_STATUS_ERROR;
		}
		break;

		case IOCTL_HPT_SET_601_INFO:
		{
			PDevice pDev=HwDeviceExtension->IDEChannel[pLun->nPathId].pDevice[pLun->nTargetId];
			PSt_HPT601_INFO pInfo = (PSt_HPT601_INFO)(pLun + 1);
			if (pDev==0 ||
				pSrbIoCtl->Length < (sizeof(St_HPT601_INFO) + sizeof(St_HPT_LUN))){
				status = SRB_STATUS_INVALID_REQUEST;
				break;
			}		  
			if (Device_Set601Info(pDev, pInfo))
				status = SRB_STATUS_SUCCESS;
			else
				status = SRB_STATUS_ERROR;
		}
		break;
#endif

		default:
		{
			status = SRB_STATUS_INVALID_REQUEST;
		}
		break;
	}
	return status;
}

void ioctl_dpc(PSCSI_REQUEST_BLOCK Srb)
{
	PSrbExtension pSrbExt = (PSrbExtension)(Srb->SrbExtension);
	PHW_DEVICE_EXTENSION HwDeviceExtension = pSrbExt->StartChannel->HwDeviceExtension;

	Srb->SrbStatus = (UCHAR)HptIoControl(HwDeviceExtension, Srb);
	
	if (pSrbExt->WorkingFlags & SRB_WFLAGS_HAS_CALL_BACK){
		pSrbExt->pfnCallBack(HwDeviceExtension, Srb);
	}
	
	ScsiPortNotification(RequestComplete, HwDeviceExtension, Srb);
	if (!HwDeviceExtension->dpc_pending)
		ScsiPortNotification(NextRequest, HwDeviceExtension);
}

BOOLEAN IsReadOnlyIoctl(PSCSI_REQUEST_BLOCK Srb)
{
	PSRB_IO_CONTROL pSrbIoCtl = (PSRB_IO_CONTROL)(Srb->DataBuffer);
	switch(pSrbIoCtl->ControlCode){
	case IOCTL_HPT_MINIPORT_GET_VERSION:
	case IOCTL_HPT_MINIPORT_GET_IDENTIFY_INFO:
	case IOCTL_HPT_MINIPORT_GET_RAID_INFO:
	case IOCTL_HPT_MINIPORT_GET_LAST_ERROR:
	case IOCTL_HPT_MINIPORT_GET_LAST_ERROR_DEVICE:
	case IOCTL_HPT_MINIPORT_ENUM_GET_DEVICE_INFO:
	case IOCTL_HPT_MINIPORT_ENUM_GET_DEVICE_CHILD:
	case IOCTL_HPT_MINIPORT_ENUM_GET_DEVICE_SIBLING:
	case IOCTL_HPT_MINIPORT_ENUM_GET_CONTROLLER_NUMBER:
	case IOCTL_HPT_MINIPORT_ENUM_GET_CONTROLLER_INFO:
	case IOCTL_HPT_CHECK_NOTIFY_EVENT:
	case IOCTL_HPT_GET_DRIVER_CAPABILITIES:
	case IOCTL_HPT_MINIPORT_LOCK_BLOCK: /* can safely lock */
	case IOCTL_HPT_MINIPORT_UNLOCK_BLOCK: /* can safely unlock */
	case IOCTL_HPT_MINIPORT_BEGIN_REBUILDING_MIRROR:
	case IOCTL_HPT_MINIPORT_ABORT_MIRROR_REBUILDING:
	case IOCTL_HPT_MINIPORT_VALIDATE_MIRROR:
		return TRUE;
	}
	return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\port\scsi\miniport\hipoint\hpt3xx\winnt\span.c ===
#include "global.h"


/******************************************************************
 * Build the member's SG table
 *******************************************************************/

void Span_SG_Table(
    PDevice     pDevice,
    PSCAT_GATH  ArraySg
    DECL_SRBEXT_PTR)
{
    register PSCAT_GATH pArraySg = ArraySg;
    register PSCAT_GATH  pDevSg = pDevice->pChannel->pSgTable;
    ULONG    i;
    UINT     numSg = MAX_SG_DESCRIPTORS;

    if(pSrbExt->LastMember != 0xFF){
		
		i = (ULONG)pSrbExt->FirstSectors << 9;
		
		while(pArraySg->SgSize && i > (ULONG)pArraySg->SgSize) {
			if(pDevice->ArrayNum == pSrbExt->FirstMember){
				*pDevSg = *pArraySg;						  
				pDevSg++;
			}
			i -= (ULONG)pArraySg->SgSize;
			pArraySg++;
			numSg--;
		}

		if(pDevice->ArrayNum == pSrbExt->FirstMember) {
			pDevSg->SgAddress = pArraySg->SgAddress;
			pDevSg->SgSize = (USHORT)i;
			pDevSg->SgFlag = SG_FLAG_EOT;
			return;
		}
	  
		if((ULONG)pArraySg->SgSize > i) {
			pDevSg->SgAddress = pArraySg->SgAddress + i;
			pDevSg->SgSize = (USHORT)(pArraySg->SgSize - i);
			pDevSg->SgFlag = 0;
		}

		if(pArraySg->SgFlag == SG_FLAG_EOT){
			pDevSg->SgFlag = SG_FLAG_EOT;
			return;
		}
		
		pDevSg++;
		pArraySg++;
		numSg--;
	}
	
	MemoryCopy(pDevSg, pArraySg, numSg << 3);
}

/******************************************************************
 * Get Stripe disk LBA and sectors
 *******************************************************************/

void Span_Lba_Sectors(
    PDevice  pDevice
    DECL_SRBEXT_PTR)
{
    PVirtualDevice pArray = pDevice->pArray;
    PChannel  pChan = pDevice->pChannel;
    ULONG    Lba = pSrbExt->StartLBA;

    if(pDevice->ArrayNum == pSrbExt->FirstMember) {
        pChan->nSector = pSrbExt->FirstSectors ;
        pChan->Lba = pSrbExt->StartLBA;
    } else {
        pChan->nSector = pSrbExt->LastSectors;
        pChan->Lba = 0;
    }
}

/******************************************************************
 * Start Stripe Command
 *******************************************************************/

void Span_Prepare(PVirtualDevice pArray DECL_SRBEXT_PTR)
{
     register PSrbExtension pSrbx = pSrbExt;
     PDevice  pDev;
     ULONG    Lba = pSrbx->Lba, i;


     for (i = 0; i < pArray->nDisk; i++) {
         pDev = pArray->pDevice[i];
         if(Lba >= pDev->capacity) {
             Lba -= pDev->capacity;
             continue;
         }

         pSrbx->StartLBA = Lba;
         pSrbx->FirstMember = (UCHAR)i;

         pSrbx->JoinMembers |= (1 << i);
         if(Lba + pSrbx->nSector > pDev->capacity) {
				  pSrbx->LastMember = (UCHAR)(i + 1);
              pSrbx->JoinMembers |= (1 << (i + 1));
              pSrbx->FirstSectors = (UCHAR)(pDev->capacity - Lba);
              pSrbx->LastSectors = pSrbx->nSector - pSrbx->FirstSectors;
         } else {
              pSrbx->LastMember = 0xFF;
              pSrbx->FirstSectors =	pSrbx->nSector;
         }

         break;
     }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\port\scsi\miniport\hipoint\hpt3xx\winnt\stypes.h ===
#ifndef __S_TYPES_H__
#define __S_TYPES_H__

/************************************************************************
**                  Type definition                                     *
*************************************************************************/

#ifdef _FORDOS_H_

	typedef unsigned char  UCHAR;
	typedef unsigned short USHORT;
	typedef unsigned long  ULONG;
	typedef unsigned long  LONG;
	typedef unsigned char  *PUCHAR;
	typedef unsigned short *PUSHORT;
	typedef unsigned long  *PULONG;
	typedef void           VOID;
	typedef UCHAR          BOOLEAN;
	
#else
	
	typedef unsigned long  DWORD;
	
#endif

typedef int            BOOL;
typedef unsigned short WORD;
typedef unsigned int   UINT;
typedef unsigned char  BYTE;
typedef unsigned char FAR *ADDRESS ;

#ifndef INVALID_HANDLE_VALUE
	#define INVALID_HANDLE_VALUE (HANDLE)-1
#endif		// INVALID_HANDLE_VALUE

#ifndef NULL
	#define NULL	(void*)0
#endif

#endif									// __S_TYPES_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\port\scsi\miniport\hipoint\hpt3xx\winnt\stripe.c ===
#include "global.h"


/******************************************************************
 * Build the member's SG table
 *******************************************************************/

void Stripe_SG_Table(
    PDevice     pDevice,
    PSCAT_GATH  pArraySg
    DECL_SRBEXT_PTR)
{
    PVirtualDevice pArray = pDevice->pArray;
    UCHAR       Member = pDevice->ArrayNum;
    PSCAT_GATH  pDevSg = pDevice->pChannel->pSgTable;
    ULONG       sgSize, min, i, sgAddress;
    UCHAR       who;


    i = (ULONG)pSrbExt->FirstSectors << 9;
    who = pSrbExt->FirstMember;

    for ( ; ; ) {
        if(pArraySg->SgSize)
             sgSize = (ULONG)pArraySg->SgSize;
        else
             sgSize = 0x10000L;

        sgAddress = pArraySg->SgAddress;
        do {
            min = MIN(sgSize, i);
            if(who == Member) {
                 *(ULONG *)&pDevSg->SgSize = (ULONG)min;
                 pDevSg->SgAddress = sgAddress;
                 pDevSg++;
            }
            i -= min;
            sgSize -= min;
            sgAddress += min;
            if(i == 0) {
                 if((++who) == pArray->nDisk)
                      who = 0;
                 i = (ULONG)pArray->ArrayNumBlock << 9;
            }
        } while(sgSize);

        if(pArraySg->SgFlag == SG_FLAG_EOT)
            break;
        pArraySg++;
    } 

    pDevSg[-1].SgFlag = SG_FLAG_EOT;
}

/******************************************************************
 * Get Stripe disk LBA and sectors
 *******************************************************************/

void Stripe_Lba_Sectors(
    PDevice  pDevice
    DECL_SRBEXT_PTR)
{
    PVirtualDevice pArray = pDevice->pArray;
    PChannel  pChan = pDevice->pChannel;
    ULONG    Lba = pSrbExt->StartLBA;
    UCHAR    Member;
    USHORT   Sectors = pSrbExt->AllMemberBlocks;

    Member = pDevice->ArrayNum;
    if(Member == pSrbExt->FirstMember)
         Lba += pSrbExt->FirstOffset;
    else if(Member < pSrbExt->FirstMember)
         Lba += pArray->ArrayNumBlock;

    if(Member == pSrbExt->FirstMember)
        Sectors += pSrbExt->FirstSectors;
    if(Member == pSrbExt->LastMember)
        Sectors += pSrbExt->LastSectors;

    if(pSrbExt->InSameLine) {
        if(Member > pSrbExt->FirstMember && 
            Member < pSrbExt->LastMember)
            goto add_blksz;
    } else {
        if(Member > pSrbExt->FirstMember)
            Sectors += pArray->ArrayNumBlock;
        if(Member < pSrbExt->LastMember)
add_blksz:
            Sectors += pArray->ArrayNumBlock;
    }
    pChan->nSector = Sectors;
    pChan->Lba = Lba;
}

/******************************************************************
 * Start Stripe Command
 *******************************************************************/

void Stripe_Prepare(PVirtualDevice pArray DECL_SRBEXT_PTR)
{
	 register PSrbExtension pSrbx = pSrbExt;
     ULONG  Lba = pSrbx->Lba;
     ULONG  BlksNum = LongRShift(Lba, pArray->BlockSizeShift);
     USHORT Sectors = pSrbx->nSector;
     UCHAR  i;

     pSrbx->AllMemberBlocks = 0;
     pSrbx->InSameLine = TRUE;
     pSrbx->StartLBA = LongDivLShift(BlksNum, pArray->nDisk, pArray->BlockSizeShift);
     i = pSrbx->FirstMember = (UCHAR)LongRem(BlksNum, pArray->nDisk);
     pSrbx->FirstOffset = (USHORT)(Lba & (pArray->ArrayNumBlock - 1));
     pSrbx->FirstSectors = pArray->ArrayNumBlock - pSrbx->FirstOffset;

     if(pSrbx->FirstSectors >= Sectors) {
         pSrbx->FirstSectors = Sectors;
         Sectors = 0;
         goto last_one;
     }
     Sectors -= pSrbx->FirstSectors;

     for ( ; ; ) {
         pSrbx->JoinMembers |= (1 << i);

         i++;
         if(i == pArray->nDisk) {
             i = 0;
             if(pSrbx->InSameLine)
                 pSrbx->InSameLine = FALSE;
             else
                 pSrbx->AllMemberBlocks += pArray->ArrayNumBlock;
         }

         if(Sectors <= pArray->ArrayNumBlock) {
last_one:
             pSrbx->JoinMembers |= (1 << i);
             pSrbx->LastMember = i;
             pSrbx->LastSectors = Sectors;
             break;
          }

          Sectors -= pArray->ArrayNumBlock;
     }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\port\scsi\miniport\hipoint\hpt3xx\winnt\win.c ===
/***************************************************************************
 * File:          Win.c
 * Description:   The OS depended interface routine for win9x & winNT
 * Author:        DaHai Huang    (DH)
 *                Steve Chang		(SC)
 *                HS  Zhang      (HZ)
 *   					SLeng          (SL)
 *
 * Dependence:    none
 * Copyright (c)  2000 HighPoint Technologies, Inc. All rights reserved
 * History:
 *		11/03/2000	HS.Zhang	Remove some unuse local variables.
 *		11/06/2000	HS.Zhang	Added this header
 *		11/14/2000	HS.Zhang	Added ParseArgumentString functions
 *		11/16/2000	SLeng		Added MointerDisk function
 *		11/20/2000	SLeng		Forbid user's operation before array become usable
 *		11/28/2000  SC			modify to fix removing any hard disk on a RAID 0+1 case 
 *		12/04/2000	SLeng		Added code to check excluded_flags in MointerDisk
 *		2/16/2001	gmm			Add PrepareForNotification() call in DriverEntry()
 *		2/21/2001	gmm			call SrbExt->pfnCallback in AtapiResetController()
 *      12/20/2001  gmm         multi controller support
 *      12/30/2001  gmm         enable command queuing
 ***************************************************************************/
#include "global.h"
#include "devmgr.h"
#include "hptioctl.h"
#include "limits.h"

#ifndef _BIOS_

/******************************************************************
 * global data
 *******************************************************************/

ULONG setting370_50_133[] = {
   0xd029d5e,  0xd029d26,  0xc829ca6,  0xc829c84,  0xc829c62,
   0x2c829d2c, 0x2c829c66, 0x2c829c62,
   0x1c829c62, 0x1c9a9c62, 0x1c929c62, 0x1c8e9c62, 0x1c8a9c62,
   /* use UDMA4 timing for UDMA5 (ATA66 write) */
   0x1c8a9c62, /* 0x1cae9c62,*/ 0x1c869c62
};

ULONG setting370_50_100[] = {
	CLK50_370PIO0, CLK50_370PIO1, CLK50_370PIO2, CLK50_370PIO3, CLK50_370PIO4,
	CLK50_370DMA0, CLK50_370DMA1, CLK50_370DMA2, 
	CLK50_370UDMA0, CLK50_370UDMA1, CLK50_370UDMA2, CLK50_370UDMA3,
	CLK50_370UDMA4, CLK50_370UDMA5, 0xad9f50bL
};    

ULONG setting370_33[] = {
	CLK33_370PIO0, CLK33_370PIO1, CLK33_370PIO2, CLK33_370PIO3, CLK33_370PIO4,
	CLK33_370DMA0, CLK33_370DMA1, CLK33_370DMA2, 
	CLK33_370UDMA0, CLK33_370UDMA1, CLK33_370UDMA2, CLK33_370UDMA3,
	CLK33_370UDMA4, CLK33_370UDMA5, 0xad9f50bL
};

UCHAR           Hpt_Slot = 0;
UCHAR           Hpt_Bus = 0;
ULONG           excluded_flags = 0xFFFFFFFF;

HANDLE	g_hAppNotificationEvent=0;
PDevice	g_pErrorDevice=0;

static void SetLogicalDevices(PHW_DEVICE_EXTENSION HwDeviceExtension);
static __inline PDevice 
	GetCommandTarget(PHW_DEVICE_EXTENSION HwDeviceExtension, PSCSI_REQUEST_BLOCK Srb);

#ifdef WIN95
int Win95AdapterControl(
					   IN PHW_DEVICE_EXTENSION deviceExtension,
					   IN int ControlType
					  );
void S3_reinit(IN PHW_DEVICE_EXTENSION deviceExtension);
#endif

BOOLEAN HptIsValidDeviceSpecifiedIoControl(IN PSCSI_REQUEST_BLOCK pSrb);
ULONG HptIoControl(IN PHW_DEVICE_EXTENSION HwDeviceExtension, IN PSCSI_REQUEST_BLOCK pSrb);
void ioctl_dpc(PSCSI_REQUEST_BLOCK Srb);
BOOLEAN IsReadOnlyIoctl(PSCSI_REQUEST_BLOCK Srb);

#if DBG
int call_AtapiStartIo=0;
#define ENTER_FUNC(fn) call_##fn++
#define LEAVE_FUNC(fn) call_##fn--
#define ASSERT_NON_REENTRANT(fn) do { if (call_##fn) \
			_asm int 3 \
		} while (0)
#else
#define ENTER_FUNC(fn)
#define LEAVE_FUNC(fn)
#define ASSERT_NON_REENTRANT(fn)
#endif

/******************************************************************
 * Driver Entry
 *******************************************************************/
ULONG
   DriverEntry(IN PVOID DriverObject, IN PVOID Argument2)
{
	HW_INITIALIZATION_DATA hwInitializationData;
	HPT_FIND_CONTEXT	hptContext;
	ULONG   status;
	ULONG   status2;
	ULONG   VendorStr = '3011';
	ULONG   DeviceStr = '5000';

#ifndef WIN95
	PrepareForNotification(NULL);
#endif

	start_ifs_hook((PCHAR)Argument2);

	//
	// Zero out structure.
	//
	ZeroMemory((PUCHAR)&hwInitializationData, sizeof(HW_INITIALIZATION_DATA));

	ZeroMemory((PUCHAR)&hptContext, sizeof(hptContext));

	//
	// Set size of hwInitializationData.
	//
	hwInitializationData.HwInitializationDataSize =	sizeof(HW_INITIALIZATION_DATA);

	//
	// Set entry points.
	//
	hwInitializationData.HwResetBus  = AtapiResetController;
	hwInitializationData.HwStartIo   = AtapiStartIo;
	hwInitializationData.HwAdapterState = AtapiAdapterState;
	hwInitializationData.SrbExtensionSize = sizeof(SrbExtension);

///#ifdef WIN95
	// Indicate need physical addresses.
	// NOTE: In NT, if set NeedPhysicalAddresses to TRUE, PIO will not work.
	// Win95 requires these
	// (We can and must set NeedPhysicalAddresses to TRUE in Win 95)
	//
	hwInitializationData.NeedPhysicalAddresses = TRUE;
///#endif //WIN95

#ifdef WIN2000
	hwInitializationData.HwAdapterControl = AtapiAdapterControl;
#endif //WIN2000


	//
	// Specify size of extensions.
	//
	hwInitializationData.SpecificLuExtensionSize = 0;

	//
	// Indicate PIO device (It is possible to use PIO operation)
	//
	hwInitializationData.MapBuffers = TRUE;

	//
	// Indicate bustype.
	//
	hwInitializationData.AdapterInterfaceType = PCIBus;

	hwInitializationData.VendorIdLength = 4;
	hwInitializationData.VendorId = &VendorStr;
	hwInitializationData.DeviceIdLength = 4;
	hwInitializationData.DeviceId = &DeviceStr;

	//
	// Call initialization for the bustype.
	//
	hwInitializationData.HwInitialize = AtapiHwInitialize370;
	hwInitializationData.HwInterrupt = AtapiHwInterrupt370;
	hwInitializationData.HwFindAdapter = AtapiFindController;
	hwInitializationData.NumberOfAccessRanges = 5;
	hwInitializationData.DeviceExtensionSize = sizeof(HW_DEVICE_EXTENSION);
	
	// To support multi request we must also set CommandQueue bit in InquiryData.
	hwInitializationData.AutoRequestSense = TRUE;
	hwInitializationData.MultipleRequestPerLu = TRUE;
	hwInitializationData.TaggedQueuing = TRUE;

	status = ScsiPortInitialize(DriverObject, Argument2, &hwInitializationData, &hptContext);

	/* try HPT372/HPT370 */
	DeviceStr = '4000';
	status2 = ScsiPortInitialize(DriverObject, Argument2, &hwInitializationData, &hptContext);
	if (status>status2) status = status2;

	return status;

} // end DriverEntry()


/*++
Function:
    BOOLEAN FindPnpAdapter

Description:
	Check the device passed by scsiport whether is our adapter

Arguments:
    deviceExtension - HBA miniport driver's adapter data storage
	ConfigInfo - Port config info passed form scsiport

Returns:
	SP_RETURN_FOUND :	The adapter is our adapter
	SP_RETURN_BAD_CONFIG: The config info passed form scsiport is invalid
	SP_RETURN_NOT_FOUND: The adapter is not out adapter
--*/
ULONG
   FindPnpAdapter(
				  IN PHW_DEVICE_EXTENSION	deviceExtension,
				  IN OUT PPORT_CONFIGURATION_INFORMATION	ConfigInfo
				 )
{
	PCI_COMMON_CONFIG	pciConfig;
	ULONG	nStatus = SP_RETURN_NOT_FOUND;

	if(ScsiPortGetBusData(deviceExtension,
						  PCIConfiguration,
						  ConfigInfo->SystemIoBusNumber,
						  ConfigInfo->SlotNumber,
						  &pciConfig,
						  PCI_COMMON_HDR_LENGTH) == PCI_COMMON_HDR_LENGTH){

		if (*(PULONG)(&pciConfig.VendorID) == SIGNATURE_370 ||
			*(PULONG)(&pciConfig.VendorID) == SIGNATURE_372A){
			if(((*ConfigInfo->AccessRanges)[0].RangeInMemory == TRUE)||
			   ((*ConfigInfo->AccessRanges)[1].RangeInMemory == TRUE)||
			   ((*ConfigInfo->AccessRanges)[2].RangeInMemory == TRUE)||
			   ((*ConfigInfo->AccessRanges)[3].RangeInMemory == TRUE)||
			   ((*ConfigInfo->AccessRanges)[4].RangeInMemory == TRUE)||
			   ((*ConfigInfo->AccessRanges)[0].RangeLength < 8)||
			   ((*ConfigInfo->AccessRanges)[1].RangeLength < 4)||
			   ((*ConfigInfo->AccessRanges)[2].RangeLength < 8)||
			   ((*ConfigInfo->AccessRanges)[3].RangeLength < 4)||
			   ((*ConfigInfo->AccessRanges)[4].RangeLength < 0x100)
			  ){
				nStatus = SP_RETURN_BAD_CONFIG;
			}else{
				nStatus = SP_RETURN_FOUND;
			}
		}
	}

	return nStatus;
}
/*++
Function:
    BOOLEAN FindLegacyAdapter

Description:
	Searching the bus for looking for our adapter

Arguments:
    deviceExtension - HBA miniport driver's adapter data storage
	ConfigInfo - Port config info passed form scsiport
	pHptContext - Our searching structure

Returns:
	SP_RETURN_FOUND :	The adapter is our adapter
	SP_RETURN_NOT_FOUND: The adapter is not out adapter
--*/
ULONG
   FindLegacyAdapter(
					 IN PHW_DEVICE_EXTENSION	deviceExtension,
					 IN OUT PPORT_CONFIGURATION_INFORMATION	ConfigInfo,
					 IN OUT PHPT_FIND_CONTEXT	pHptContext
					)
{
	PCI_COMMON_CONFIG   pciConfig;
	//
	// check every slot & every function
	// because our adapter only have two functions, so we just need check two functions
	//
	while(TRUE){
		while(pHptContext->nSlot.u.bits.FunctionNumber < 1){
			if(ScsiPortGetBusData(deviceExtension,
								  PCIConfiguration,
								  ConfigInfo->SystemIoBusNumber,
								  pHptContext->nSlot.u.AsULONG,
								  &pciConfig,
								  PCI_COMMON_HDR_LENGTH) == PCI_COMMON_HDR_LENGTH){
				//
				// Now check for the VendorID & Revision of PCI config,
				// to ensure it is whether our adapter.
				//
				if (*(PULONG)&pciConfig.VendorID == SIGNATURE_370 ||
					*(PULONG)&pciConfig.VendorID == SIGNATURE_372A) {
					int i;
					i = ConfigInfo->NumberOfAccessRanges - 1;
					//
					// setup config I/O info's range BMI
					//
					(*ConfigInfo->AccessRanges)[i].RangeStart =
						ScsiPortConvertUlongToPhysicalAddress(pciConfig.u.type0.BaseAddresses[i] & ~1);
					(*ConfigInfo->AccessRanges)[i].RangeInMemory = FALSE;
					(*ConfigInfo->AccessRanges)[i].RangeLength = 0x100;

					i--;

					while( i > 0 ){
						//
						// setup config I/O info's range ATAPI io space
						// 
						(*ConfigInfo->AccessRanges)[i-1].RangeStart =
							ScsiPortConvertUlongToPhysicalAddress(pciConfig.u.type0.BaseAddresses[i-1] & ~1);
						(*ConfigInfo->AccessRanges)[i-1].RangeInMemory = FALSE;
						(*ConfigInfo->AccessRanges)[i-1].RangeLength = 8;
						//
						// setup config I/O info's range ATAPI io space
						//
						(*ConfigInfo->AccessRanges)[i].RangeStart =
							ScsiPortConvertUlongToPhysicalAddress(pciConfig.u.type0.BaseAddresses[i] & ~1);
						(*ConfigInfo->AccessRanges)[i].RangeInMemory = FALSE;
						(*ConfigInfo->AccessRanges)[i].RangeLength = 4;

						i = i - 2;
					}

					ConfigInfo->BusInterruptLevel = pciConfig.u.type0.InterruptLine;

					ConfigInfo->InterruptMode = LevelSensitive;

					ConfigInfo->SlotNumber = pHptContext->nSlot.u.AsULONG;

					pHptContext->nSlot.u.bits.FunctionNumber ++;
					return SP_RETURN_FOUND;
				}
			}	  
			//
			// if the adapter not present in first function,
			// it should not present in next function too.
			// so just break out this loop, continue search next slot.
			//
			break;									  
		} 
		// next slot
		pHptContext->nSlot.u.bits.FunctionNumber = 0;
		if(pHptContext->nSlot.u.bits.DeviceNumber < 0x1F){
			pHptContext->nSlot.u.bits.DeviceNumber ++;
		}else{
			break;
		}
	}				
	return SP_RETURN_NOT_FOUND;
}
				
ULONG
   AtapiFindController(
						  IN PHW_DEVICE_EXTENSION HwDeviceExtension,
						  IN PVOID Context,
						  IN PVOID BusInformation,
						  IN PCHAR ArgumentString,
						  IN OUT PPORT_CONFIGURATION_INFORMATION ConfigInfo,
						  OUT PBOOLEAN Again
						 )
/*++

Function:
    ULONG AtapiFindController

Routine Description:

    This function is called by the OS-specific port driver after
    the necessary storage has been allocated, to gather information
    about the adapter's configuration.

Arguments:

    HwDeviceExtension - HBA miniport driver's adapter data storage
    Context - Address of adapter count
    BusInformation - Indicates whether or not driver is client of crash dump utility.
    ArgumentString - Used to determine whether driver is client of ntldr.
    ConfigInfo - Configuration information structure describing HBA
    Again - Indicates search for adapters to continue

Return Value:

    ULONG

--*/

{
	PChannel pChan = HwDeviceExtension->IDEChannel;
	PUCHAR  BMI;
	int     i;
	ULONG	nStatus = SP_RETURN_NOT_FOUND;

	*Again = FALSE;

	if((*ConfigInfo->AccessRanges)[0].RangeLength != 0){
		nStatus = FindPnpAdapter(HwDeviceExtension, ConfigInfo);
	}else{
		if(Context != NULL){
			nStatus = FindLegacyAdapter(HwDeviceExtension, ConfigInfo, (PHPT_FIND_CONTEXT)Context);
		}
	}

	if(nStatus == SP_RETURN_FOUND){
		*Again = TRUE;
		ZeroMemory(pChan, sizeof(HW_DEVICE_EXTENSION));
		
		(BMI = (PUCHAR)ScsiPortConvertPhysicalAddressToUlong(
			(*ConfigInfo->AccessRanges)[ConfigInfo->NumberOfAccessRanges - 1].RangeStart));

		pci_write_config_byte((UCHAR)ConfigInfo->SystemIoBusNumber, 
			(UCHAR)(*(PCI_SLOT_NUMBER *)&ConfigInfo->SlotNumber).u.bits.DeviceNumber,
			0, 0x70, 0);
			
		SetHptChip(pChan, BMI);

		Create_Internal_Buffer(HwDeviceExtension);

		//
		// Indicate maximum transfer length is 64k.
		//
		ConfigInfo->MaximumTransferLength = 0x10000;
		ConfigInfo->AlignmentMask = 0x00000003;

		//
		//  Enable system flush data (9/18/00)
		//
		ConfigInfo->CachesData = TRUE;

		//
		// Indicate it is a bus master
		//
		ConfigInfo->Master = TRUE;
		ConfigInfo->Dma32BitAddresses = TRUE;
		ConfigInfo->NumberOfPhysicalBreaks = MAX_SG_DESCRIPTORS - 1;
		ConfigInfo->ScatterGather = TRUE;
		
		//
		// Indicate 2 buses.
		//
		ConfigInfo->NumberOfBuses = 3;

		//
		// Indicate only two devices can be attached to the adapter.
		//
		ConfigInfo->MaximumNumberOfTargets = 2;
			
		pChan->HwDeviceExtension = (PHW_DEVICE_EXTENSION)pChan;
		pChan->CallBack = AtapiCallBack;
		pChan[1].HwDeviceExtension = (PHW_DEVICE_EXTENSION)pChan;
		pChan[1].CallBack = AtapiCallBack370;

		pLastVD = VirtualDevices;

		HwDeviceExtension->pci_bus = (UCHAR)ConfigInfo->SystemIoBusNumber;
		HwDeviceExtension->pci_dev = (UCHAR)(*(PCI_SLOT_NUMBER *)&ConfigInfo->SlotNumber).u.bits.DeviceNumber;
		for (i=0; i<5; i++)
			HwDeviceExtension->io_space[i] = 
				pci_read_config_dword(HwDeviceExtension->pci_bus, 
					HwDeviceExtension->pci_dev, 0, (UCHAR)(0x10+i*4));
		HwDeviceExtension->pci_reg_0c = 
			pci_read_config_byte(HwDeviceExtension->pci_bus, HwDeviceExtension->pci_dev, 0, 0xC);
		HwDeviceExtension->pci_reg_0d = 
			pci_read_config_byte(HwDeviceExtension->pci_bus, HwDeviceExtension->pci_dev, 0, 0xD);
		//
		// Allocate a Noncached Extension to use for scatter/gather list
		//
		if((pChan->pSgTable = (PSCAT_GATH)ScsiPortGetUncachedExtension(
			HwDeviceExtension,
			ConfigInfo,
			sizeof(SCAT_GATH) * MAX_SG_DESCRIPTORS * 2)) != 0) {

			//
			// Convert virtual address to physical address.
			//
			i = sizeof(SCAT_GATH) * MAX_SG_DESCRIPTORS * 2;
			pChan->SgPhysicalAddr = ScsiPortConvertPhysicalAddressToUlong(
				ScsiPortGetPhysicalAddress(HwDeviceExtension,
										   NULL,
										   pChan->pSgTable,
										   &i)
				);


			pChan[1].pSgTable = (PSCAT_GATH)
					((ULONG)pChan->pSgTable + sizeof(SCAT_GATH) * MAX_SG_DESCRIPTORS);
			pChan[1].SgPhysicalAddr = pChan->SgPhysicalAddr
									 + sizeof(SCAT_GATH) * MAX_SG_DESCRIPTORS;
		}
	}
	
	return nStatus;
} // end AtapiFindController()


/******************************************************************
 * Initial Channel
 *******************************************************************/

BOOLEAN
   AtapiHwInitialize(IN PChannel pChan)
{
	int i;
	PDevice pDevice;
	ST_XFER_TYPE_SETTING	osAllowedDeviceXferMode;

	OutPort(pChan->BaseBMI+0x7A, 0x10);
	for(i=0; i<2; i++) {
		pDevice = &pChan->Devices[i];
		pDevice->UnitId = (i)? 0xB0 : 0xA0;
		pDevice->pChannel = pChan;

		osAllowedDeviceXferMode.Mode = 0xFF;

		if(FindDevice(pDevice,osAllowedDeviceXferMode)) {
			pChan->pDevice[i] = pDevice;

			if (pChan->pSgTable == NULL) 
				pDevice->DeviceFlags &= ~(DFLAGS_DMA | DFLAGS_ULTRA);

			if(pDevice->DeviceFlags & DFLAGS_HARDDISK) {
				//StallExec(1000000);
				CheckArray(pDevice, pChan->HwDeviceExtension);
         	}

			/* gmm 2001-6-7
			 *  If device is faulted just after we found it, we will remove it.
			 *  See also CheckArray()
			 */
			if (pDevice->DeviceFlags2 & DFLAGS_DEVICE_DISABLED) {
				ZeroMemory(pDevice, sizeof(struct _Device));
				pChan->pDevice[i] = 0;
			}
			else {
				if((pDevice->DeviceFlags & DFLAGS_ATAPI) == 0 && 
				   (pDevice->DeviceFlags & DFLAGS_SUPPORT_MSN))
					IdeMediaStatus(TRUE, pDevice);
	
				Nt2kHwInitialize(pDevice);
			}
		} 
	}

	OutPort(pChan->BaseBMI+0x7A, 0);
	return TRUE;

} // end AtapiHwInitialize()

int num_adapters=0;
PHW_DEVICE_EXTENSION hpt_adapters[MAX_HPT_BOARD];

BOOLEAN
   AtapiHwInitialize370(IN PHW_DEVICE_EXTENSION HwDeviceExtension)
{
	BOOLEAN	bResult;
	int bus, id;
	PChannel pChan = &HwDeviceExtension->IDEChannel[0];
	PDevice pDev;

#ifdef WIN95
	HwDeviceExtension->g_fnAdapterControl = Win95AdapterControl;
#else
	g_hAppNotificationEvent = PrepareForNotification(NULL);
#endif

	bResult = (AtapiHwInitialize(pChan) && AtapiHwInitialize(pChan+1));

	hpt_adapters[num_adapters++] = HwDeviceExtension;
	
	if (pChan->ChannelFlags & IS_HPT_372)
		HwDeviceExtension->MultipleRequestPerLu = TRUE;
	HwDeviceExtension->EmptyRequestSlots = 0xFFFFFFFF;

	for (bus=0; bus<2; bus++) {
		pChan = &HwDeviceExtension->IDEChannel[bus];
		for (id=0; id<2; id++) {
			pDev = pChan->pDevice[id];
			if (pDev && pDev->Usable_Mode>13) {
				/* set twice */
				HwDeviceExtension->dpll66 = 1;
				goto check_done;
			}
		}
	}
check_done:
	if (HwDeviceExtension->dpll66) {
		exlude_num = HwDeviceExtension->IDEChannel[0].exclude_index-1;
		SetHptChip(HwDeviceExtension->IDEChannel, HwDeviceExtension->IDEChannel[0].BaseBMI);
		for (bus=0; bus<2; bus++) {
			pChan = &HwDeviceExtension->IDEChannel[bus];
			for (id=0; id<2; id++) {
				pDev = pChan->pDevice[id];
				if (pDev) DeviceSelectMode(pDev, pDev->Usable_Mode);
			}
		}
	}

	Final_Array_Check(0, HwDeviceExtension);
	SetLogicalDevices(HwDeviceExtension);

	return bResult;
}


/******************************************************************
 * Reset Controller
 *******************************************************************/

BOOLEAN AtapiResetController(
						IN PHW_DEVICE_EXTENSION HwDeviceExtension, 
						IN ULONG PathId)
{
	int i, j;
	PSCSI_REQUEST_BLOCK Srb;
	PChannel pChan;
	PDevice pDev;

	if (PathId==2) return TRUE;

	for (i=0; i<MAX_PENDING_REQUESTS; i++) {
		if (HwDeviceExtension->EmptyRequestSlots & (1<<i)) continue;
		Srb = HwDeviceExtension->PendingRequests[i];
		if (Srb) {
			PSrbExtension pSrbExt = (PSrbExtension)Srb->SrbExtension;
			if (pSrbExt->WorkingFlags & SRB_WFLAGS_USE_INTERNAL_BUFFER){
				bts(EXCLUDE_BUFFER);
				pSrbExt->WorkingFlags &= ~SRB_WFLAGS_USE_INTERNAL_BUFFER;
			}
			/* restore Srb members in case of SRB_FUNCTION_IOCONTROL */
			if (pSrbExt->WorkingFlags & SRB_WFLAGS_HAS_CALL_BACK){
				pSrbExt->pfnCallBack(HwDeviceExtension, Srb);
			}
			Srb->SrbStatus = SRB_STATUS_BUS_RESET;
			ScsiPortNotification(RequestComplete, HwDeviceExtension, Srb);
		}
	}
	HwDeviceExtension->EmptyRequestSlots = 0xFFFFFFFF;

	for (i=0; i<2; i++) {
		pChan = &HwDeviceExtension->IDEChannel[i];
		if (pChan->pWorkDev) ScsiPortWritePortUchar(pChan->BMI, BMI_CMD_STOP);
		bts(pChan->exclude_index);
		pChan->pWorkDev = 0;
		pChan->CurrentSrb = 0;
		IdeResetController(pChan);
		for (j=0; j<2; j++) {
			pDev = pChan->pDevice[j];
			if (!pDev) continue;
			pDev->pWaitingSrbList = 0;
			pDev->queue_first = pDev->queue_last = 0;
			pDev->DeviceFlags &= ~(DFLAGS_DMAING | DFLAGS_REQUEST_DMA | DFLAGS_HAS_LOCKED |
							   DFLAGS_TAPE_RDP | DFLAGS_SET_CALL_BACK);
		}
	}
	ScsiPortNotification(NextRequest, HwDeviceExtension);
	return TRUE;

} // end AtapiResetController()

/******************************************************************
 * Start Io
 *******************************************************************/

// gmm 2001-3-11
#ifdef ADAPTEC
const char HPT_DEVICE[] = "ADAPTEC RCM DEVICE";
#else
const char HPT_DEVICE[] = "HPT     RCM DEVICE";
#endif

char HPT_SIGNATURE[8] = {'H','P','T','-','C','T','R','L'};

BOOLEAN AtapiStartIo(
				IN PHW_DEVICE_EXTENSION HwDeviceExtension, 
				IN PSCSI_REQUEST_BLOCK Srb)
{
	PChannel pChan = HwDeviceExtension->IDEChannel;
	PDevice pDev;
	UCHAR PathId = Srb->PathId, TargetId = Srb->TargetId;
	LOC_SRBEXT_PTR

	ASSERT_NON_REENTRANT(AtapiStartIo);	
	ENTER_FUNC(AtapiStartIo);
	
#ifdef WIN95
	if (HwDeviceExtension->need_reinit) {
		S3_reinit(HwDeviceExtension);
		HwDeviceExtension->need_reinit = 0;
	}
#endif

	ZeroMemory(pSrbExt, sizeof(SrbExtension));
	pSrbExt->StartChannel = pChan;
	pSrbExt->DataBuffer = Srb->DataBuffer;
	pSrbExt->DataTransferLength = (USHORT)Srb->DataTransferLength;
	pSrbExt->SgFlags = SG_FLAG_EOT;
	pSrbExt->RequestSlot = 0xFF;

	if (HwDeviceExtension->EmptyRequestSlots==0xFFFFFFFF) {
		do_dpc_routines(HwDeviceExtension);
	}
	
	//
	// Determine which function.
	//
	switch (Srb->Function) {

		case SRB_FUNCTION_EXECUTE_SCSI:

			if (PathId==2 && 
				TargetId==0 && 
				Srb->Lun==0 &&
				Srb->Cdb[0]==SCSIOP_INQUIRY)
			{
				UINT i;
				PINQUIRYDATA pInquiryData;

				pInquiryData = Srb->DataBuffer;

				ZeroMemory(Srb->DataBuffer, Srb->DataTransferLength);

				pInquiryData->DeviceType = PROCESSOR_DEVICE;
				pInquiryData->Versions = 1;
				pInquiryData->AdditionalLength = 0x20;

				memcpy((PUCHAR)pInquiryData+offsetof(INQUIRYDATA, VendorId), &HPT_DEVICE, sizeof(HPT_DEVICE)-1);

				for(i = (offsetof(INQUIRYDATA, VendorId) + sizeof(HPT_DEVICE)-1); i < Srb->DataTransferLength; i++){
					((PCHAR)pInquiryData)[i] = 0x20;
				}

				Srb->SrbStatus = SRB_STATUS_SUCCESS;

			}else {

SubmitCommand:
				if (HwDeviceExtension->dpc_pending) {
					KdPrint(("dpc pending, reject Srb %x,%d", Srb, Srb->Function));
					Srb->SrbStatus = SRB_STATUS_BUSY;
					if (pSrbExt->WorkingFlags & SRB_WFLAGS_HAS_CALL_BACK){
						pSrbExt->pfnCallBack(HwDeviceExtension, Srb);
					}
					ScsiPortNotification(RequestComplete, HwDeviceExtension, Srb);
					LEAVE_FUNC(AtapiStartIo);
					return TRUE;
				}
				pDev = GetCommandTarget(HwDeviceExtension, Srb);
				if (pDev == 0) {
no_device:
					Srb->SrbStatus = SRB_STATUS_NO_DEVICE;
					break;
				}
				pChan = pDev->pChannel;
				pSrbExt->StartChannel = pChan;

				if (MarkPendingRequest(HwDeviceExtension, Srb)) {
					Srb->SrbStatus = SRB_STATUS_PENDING;
					WinStartCommand(pDev, Srb);
					if (HwDeviceExtension->MultipleRequestPerLu &&
						HwDeviceExtension->EmptyRequestSlots &&
						HwDeviceExtension->dpc_pending==0)
						ScsiPortNotification(NextLuRequest, HwDeviceExtension, PathId, TargetId, 0);
				}
				else {
					KdPrint(("No available slots for Srb"));
					Srb->SrbStatus = SRB_STATUS_BUSY;
					break;
				}
				LEAVE_FUNC(AtapiStartIo);
				return TRUE;
			}
			break;

		case SRB_FUNCTION_IO_CONTROL:			
			if(memcmp(((PSRB_IO_CONTROL)Srb->DataBuffer)->Signature, HPT_SIGNATURE, sizeof(HPT_SIGNATURE)) == 0){
				if(HptIsValidDeviceSpecifiedIoControl(Srb)){
#if DBG
					PSRB_IO_CONTROL pSrbIoCtl = (PSRB_IO_CONTROL)(Srb->DataBuffer);
					PSt_HPT_LUN	pLun = (PSt_HPT_LUN)(pSrbIoCtl + 1);
					PSt_HPT_EXECUTE_CDB	pExecuteCdb = (PSt_HPT_EXECUTE_CDB)(pLun + 1);
					PULONG p = (PULONG)&pExecuteCdb->Cdb;
					KdPrint(("ioctl(%x): %x-%x-%x(%d)", ((PSRB_IO_CONTROL)Srb->DataBuffer)->ControlCode,
						p[0], p[1], p[2], pExecuteCdb->CdbLength));
#endif
					goto SubmitCommand;
				}
				if (IsReadOnlyIoctl(Srb)) {
					KdPrint(("ioctl(%x): read-only", ((PSRB_IO_CONTROL)Srb->DataBuffer)->ControlCode));
					Srb->SrbStatus = (UCHAR)HptIoControl(HwDeviceExtension, Srb);
				}
				else {
					KdPrint(("ioctl(%x): queue_dpc", ((PSRB_IO_CONTROL)Srb->DataBuffer)->ControlCode));
					hpt_queue_dpc(HwDeviceExtension, ioctl_dpc, Srb);
					LEAVE_FUNC(AtapiStartIo);
					return TRUE;
				}
			}else{
				Srb->SrbStatus = SRB_STATUS_INVALID_REQUEST;
			}
			break;

		case SRB_FUNCTION_ABORT_COMMAND:

			/* we should abort the command Srb->NextSrb. But simply flow down now */

		case SRB_FUNCTION_RESET_BUS:

			if (!AtapiResetController(HwDeviceExtension, Srb->PathId)) {

				ScsiPortLogError(HwDeviceExtension, NULL, 0, 0, 0,
								 SP_INTERNAL_ADAPTER_ERROR, __LINE__);

				Srb->SrbStatus = SRB_STATUS_ERROR;
			}
			else
				Srb->SrbStatus = SRB_STATUS_SUCCESS;

			break;

		case SRB_FUNCTION_FLUSH:
			/* 
			 * Generally we should flush data in cache as required. But to improve
			 * performace, we don't handle it.
			 */
			Srb->SrbStatus = SRB_STATUS_SUCCESS;
			break;
			
		case SRB_FUNCTION_SHUTDOWN:

			pDev = GetCommandTarget(HwDeviceExtension, Srb);
			if (pDev == 0) goto no_device;

			/* there should be no pending I/O on the target device */
			if (pDev->pArray)
				FlushArray(pDev->pArray, DFLAGS_WIN_SHUTDOWN);
			else if ((pDev->DeviceFlags & DFLAGS_TAPE_DEVICE)==0)
				FlushDrive(pDev, DFLAGS_WIN_SHUTDOWN);

			Srb->SrbStatus = SRB_STATUS_SUCCESS;

			break;		   

		default:
			Srb->SrbStatus = SRB_STATUS_INVALID_REQUEST;
			break;

	} // end switch

	//
	// Check if command complete.
	//
	if (Srb->SrbStatus != SRB_STATUS_PENDING) {
		OS_EndCmd_Interrupt(pChan, Srb);
	}
	LEAVE_FUNC(AtapiStartIo);
	return TRUE;

} // end AtapiStartIo()

/******************************************************************
 * Interrupt
 *******************************************************************/

BOOLEAN
   AtapiHwInterrupt(
					IN PChannel pChan
				   )

{
	PATAPI_REGISTERS_1  baseIoAddress1;
	PUCHAR BMI = pChan->BMI;
	PDevice   pDev;

	if((ScsiPortReadPortUchar(BMI + BMI_STS) & BMI_STS_INTR) == 0) {
		return FALSE;
	}

	if((pDev = pChan->pWorkDev) != 0)
		return DeviceInterrupt(pDev, 0);

	baseIoAddress1 = (PATAPI_REGISTERS_1)pChan->BaseIoAddress1;
	do {
		if(pChan->pDevice[0]) 
			ScsiPortWritePortUchar(&baseIoAddress1->DriveSelect, 0xA0);
		if(pChan->pDevice[1]) {
			GetBaseStatus(baseIoAddress1);
			ScsiPortWritePortUchar(&baseIoAddress1->DriveSelect, 0xB0);
		}
		GetBaseStatus(baseIoAddress1);
		ScsiPortWritePortUchar(BMI + BMI_STS, BMI_STS_INTR);
	}
	while (InPort(BMI + BMI_STS) & BMI_STS_INTR);

	pChan->ChannelFlags &= ~PF_ACPI_INTR;

	return TRUE;
}


BOOLEAN
   AtapiHwInterrupt370(
					   IN PChannel pChan
					  )
{	
	BOOLEAN	bResult1, bResult2;
	
	ASSERT_NON_REENTRANT(AtapiStartIo);	

	bResult1 = AtapiHwInterrupt(pChan);
	bResult2 = AtapiHwInterrupt(pChan+1);

	return (bResult1||bResult2);
} 


/******************************************************************
 * Call Back
 *******************************************************************/

void AtapiCallBack(
				   IN PChannel pChan
				  )
{
	PDevice              pDev = pChan->pWorkDev;
	PSCSI_REQUEST_BLOCK  Srb;
	PATAPI_REGISTERS_2   ControlPort;
	UCHAR statusByte;

	if(pDev == 0 || (pDev->DeviceFlags & DFLAGS_SET_CALL_BACK) == 0)
		return;
	//
	// If the last command was DSC restrictive, see if it's set. If so, the device is
	// ready for a new request. Otherwise, reset the timer and come back to here later.
	//

	Srb = pChan->CurrentSrb;
	if (Srb) {
		ControlPort = (PATAPI_REGISTERS_2)pChan->BaseIoAddress2;
		if (pDev->DeviceFlags & DFLAGS_TAPE_RDP) {
			statusByte = GetStatus(ControlPort);
			if (statusByte & IDE_STATUS_DSC) 
				DeviceInterrupt(pDev, 0);
			else 
				OS_Busy_Handle(pChan, pDev);
			return;
		}
	}

	DeviceInterrupt(pDev, 0);
}

void AtapiCallBack370(IN PChannel pChan)
{
	AtapiCallBack(&pChan[1]);
}


/******************************************************************
 * Adapter Status
 *******************************************************************/
BOOLEAN
   AtapiAdapterState(IN PVOID HwDeviceExtension, IN PVOID Context, IN BOOLEAN SaveState)
{
	if(!SaveState) {
		end_ifs_hook();
	}
	return TRUE;
}

void set_dpll66(PChannel pChan)
{
	PUCHAR BMI=pChan->BaseBMI;
	int ha, i;
	
	for (ha=0; ha<num_adapters; ha++)
		if (hpt_adapters[ha]->IDEChannel==pChan) goto found;
	return;
found:
	if (hpt_adapters[ha]->dpll66) return;
	hpt_adapters[ha]->dpll66 = 1;
	
	OutPort(BMI+0x7A, 0x10);
	SetHptChip(pChan, BMI);
	for (ha=0; ha<2; ha++) for (i=0; i<2; i++) {
		PDevice pDev = pChan[ha].pDevice[i];
		if (pDev) DeviceSelectMode(pDev, pDev->Usable_Mode);
	}
	OutPort(BMI+0x7A, 0);
}

static void SetLogicalDevices(PHW_DEVICE_EXTENSION HwDeviceExtension)
{
	int i, bus, id;
	PDevice pDev;
	LOGICAL_DEVICE *pLDs = HwDeviceExtension->_LogicalDevices;

	for (i=0; i<MAX_DEVICES_PER_CHIP; i++) {
		pLDs[i].isValid = 0;
		pLDs[i].isInUse = 0;
	}
	for (bus=0; bus<2; bus++)
	for (id=0; id<2; id++) {
		i = (bus<<1)|id;
		pDev = HwDeviceExtension->IDEChannel[bus].pDevice[id];
		if (!pDev) continue;
		if (pDev->DeviceFlags & DFLAGS_HIDEN_DISK) continue;
		if (pDev->pArray) {
			pLDs[i].isArray = 1;
			pLDs[i].pLD = pDev->pArray;
		}
		else {
			pLDs[i].isArray = 0;
			pLDs[i].pLD = pDev;
		}
		pLDs[i].isValid = 1;
	}
}

BOOL UnregisterLogicalDevice(PVOID pld)
{
	int i, ha;
	for (ha=0; ha<num_adapters; ha++) {
		PHW_DEVICE_EXTENSION HwDeviceExtension = hpt_adapters[ha];
		for (i=0; i<MAX_DEVICES_PER_CHIP; i++)
			if (LogicalDevices[i].pLD==pld) {
				// alreay unregistered?
				if (!LogicalDevices[i].isValid) return TRUE;
				// in use?
				if (LogicalDevices[i].isInUse) return FALSE;
				// mark as invalid.
				LogicalDevices[i].isValid = 0;
				return TRUE;
		}
	}
	return TRUE;
}

static __inline PDevice 
	GetCommandTarget(PHW_DEVICE_EXTENSION HwDeviceExtension, PSCSI_REQUEST_BLOCK Srb)
{
	PDevice pDev;

	if (Srb->Function==SRB_FUNCTION_IO_CONTROL &&
		memcmp(((PSRB_IO_CONTROL)Srb->DataBuffer)->Signature, 
			HPT_SIGNATURE, sizeof(HPT_SIGNATURE))==0)
	{
		if (Srb->TargetId>1 || Srb->PathId >= 2) return NULL;
		if (Srb->Lun>=num_adapters) return NULL;
		/* Check for IO control call. Cannot StartIo on another controller */
		if (HwDeviceExtension != hpt_adapters[Srb->Lun]) return NULL;
		return HwDeviceExtension->IDEChannel[Srb->PathId].pDevice[Srb->TargetId];
	}
	else {
		int id;
		LOGICAL_DEVICE *pLDs = HwDeviceExtension->_LogicalDevices;
		if (Srb->Lun>0 || Srb->PathId>1 || Srb->TargetId>1) return NULL;
		id = (Srb->PathId<<1) | Srb->TargetId;
		if (!pLDs[id].isValid) return NULL;

		if (pLDs[id].isArray) {
			int i;
			PVirtualDevice pArray = (PVirtualDevice)pLDs[id].pLD;
			for (i=0; i<MAX_MEMBERS; i++) {
				pDev = pArray->pDevice[i];
				if (pDev) break;
			}
		}
		else {
			pDev = (PDevice)pLDs[id].pLD;
			// it may be add to an array after driver loaded, check it
			if (pDev->pArray) {
				// in this case, pDev can only be a RAID 1 source disk.
				if (pDev->pArray->arrayType!=VD_RAID_1_MIRROR ||
					pDev!=pDev->pArray->pDevice[0])
					return NULL;
				// adjust logical device data else if pDev failed, system will not work
				pLDs[id].isArray = 1;
				pLDs[id].pLD = pDev->pArray;
			}
		}
		return pDev;
	}
}

PVirtualDevice Array_alloc(PHW_DEVICE_EXTENSION HwDeviceExtension)
{
	PVirtualDevice pArray;
	for (pArray=VirtualDevices; pArray<pLastVD; pArray++) {
		if (pArray->arrayType==VD_INVALID_TYPE)
			goto found;
	}
	pArray = pLastVD++;
found:
	ZeroMemory(pArray, sizeof(VirtualDevice));
	return pArray;
}

void Array_free(PVirtualDevice pArray)
{
	int ha, i;
	for (ha=0; ha<num_adapters; ha++)
	for (i=0; i<MAX_DEVICES_PER_CHIP; i++) {
		if (pArray==&hpt_adapters[ha]->_VirtualDevices[i]) {
			pArray->arrayType = VD_INVALID_TYPE;
    		if(pArray+1 == hpt_adapters[ha]->_pLastVD) hpt_adapters[ha]->_pLastVD--;
    	}
    }
}

UCHAR pci_read_config_byte(UCHAR bus, UCHAR dev, UCHAR func, UCHAR reg)
{
	UCHAR v;
	OLD_IRQL
	DISABLE
	OutDWord(0xCF8, (0x80000000|(bus<<16)|(dev<<11)|(func<<8)|(reg&0xFC)));
	v = InPort(0xCFC+(reg&3));
	ENABLE
	return v;
}
void pci_write_config_byte(UCHAR bus, UCHAR dev, UCHAR func, UCHAR reg, UCHAR v)
{
	OLD_IRQL
	DISABLE
	OutDWord(0xCF8, (0x80000000|(bus<<16)|(dev<<11)|(func<<8)|(reg&0xFC)));
	OutPort(0xCFC+(reg&3), v);
	ENABLE
}
DWORD pci_read_config_dword(UCHAR bus, UCHAR dev, UCHAR func, UCHAR reg)
{
	DWORD v;
	OLD_IRQL
	DISABLE
	OutDWord(0xCF8, (0x80000000|(bus<<16)|(dev<<11)|(func<<8)|reg));
	v = InDWord(0xCFC);
	ENABLE
	return v;
}
void pci_write_config_dword(UCHAR bus, UCHAR dev, UCHAR func, UCHAR reg, DWORD v)
{
	OLD_IRQL
	DISABLE
	OutDWord(0xCF8, (0x80000000|(bus<<16)|(dev<<11)|(func<<8)|reg));
	OutDWord(0xCFC, v);
	ENABLE
}

#ifdef WIN95
int _stdcall Win95AdapterControl(
					   IN PHW_DEVICE_EXTENSION deviceExtension,
					   IN int ControlType
					  )
{
	KdPrint(("AtapiAdapterControl(ext=%x, type=%d)", deviceExtension, ControlType));
	
	switch (ControlType) {

	case ScsiStopAdapter:
		{
			int bus, id;
			DEBUG_POINT(0xD001);
			for (bus=0; bus<2; bus++) {
				for (id=0; id<2; id++) {
					PDevice pDev = deviceExtension->IDEChannel[bus].pDevice[id];
					if (pDev && !(pDev->DeviceFlags2 & DFLAGS_DEVICE_DISABLED)) {
						void FlushDrive(PDevice pDev, DWORD flags);
						FlushDrive(pDev, DFLAGS_WIN_FLUSH);
					}
				}
			}
			deviceExtension->need_reinit = 1;
		}
		return ScsiAdapterControlSuccess;

	case ScsiRestartAdapter:
		DEBUG_POINT(0xD002);
		S3_reinit(deviceExtension);
		deviceExtension->need_reinit = 0;
		return ScsiAdapterControlSuccess;

	case ScsiSetBootConfig:
		DEBUG_POINT(0xD003);
		return ScsiAdapterControlSuccess;

	case ScsiSetRunningConfig:
		DEBUG_POINT(0xD004);
		return ScsiAdapterControlSuccess;

	default:
		break;
	}

	return ScsiAdapterControlUnsuccessful;
}

void S3_reinit(IN PHW_DEVICE_EXTENSION deviceExtension)
{
	int i;
	UCHAR bus, dev;
	
	OLD_IRQL
	DISABLE

	bus = deviceExtension->pci_bus;
	dev = deviceExtension->pci_dev;
		
	pci_write_config_byte(bus, dev, 0, REG_PCICMD, 5);
	pci_write_config_byte(bus, dev, 0, 0xC, deviceExtension->pci_reg_0c);
	pci_write_config_byte(bus, dev, 0, 0xD, deviceExtension->pci_reg_0d);
	for (i=0; i<5; i++)
		pci_write_config_dword(bus, dev, 0, (UCHAR)(0x10+i*4), deviceExtension->io_space[i]);
	pci_write_config_byte(bus, dev, 0, 0x3C, deviceExtension->IDEChannel[0].InterruptLevel);
	pci_write_config_byte(bus, dev, 0, 0x70, 0);
	pci_write_config_byte(bus, dev, 0, 0x64, 0);
	StallExec(1000);

	exlude_num = deviceExtension->IDEChannel[0].exclude_index-1;
	SetHptChip(deviceExtension->IDEChannel, deviceExtension->IDEChannel[0].BaseBMI);
	OutPort(deviceExtension->IDEChannel[0].BaseBMI+0x7A, 0);

	for (bus=0; bus<2; bus++) {
		IdeResetController(&deviceExtension->IDEChannel[bus]);
	}

	ENABLE
	DEBUG_POINT(0xD005);
}
#endif

#endif // not _BIOS_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\port\scsi\miniport\hipoint\hpt3xx\winnt\win98.c ===
/***************************************************************************
 * File:          win98.c
 * Description:   Subroutines in the file are used to atapi device in
 *				  win98 platform
 * Author:        DaHai Huang    (DH)
 * Dependence:    none
 * Copyright (c)  2000 HighPoint Technologies, Inc. All rights reserved
 * History:     
 *		11/06/2000	HS.Zhang	Added this head
 *		11/10/2000	HS.Zhang	Added a micro define NO_DMA_ON_ATAPI in
 *								Start_Atapi routine
 *
 ***************************************************************************/
#include "global.h"

#if  defined(WIN95) && !defined(_BIOS_)

/******************************************************************
 *  Build Scatter/Gather List
 *******************************************************************/

int BuildSgl(IN PDevice pDev, IN PSCAT_GATH pSG,
			IN PSCSI_REQUEST_BLOCK Srb)
{
	PChannel pChan = pDev->pChannel;
	PSCAT_GATH psg = pSG;
	PVOID   dataPointer = Srb->DataBuffer;
	ULONG   bytesLeft   = Srb->DataTransferLength;
	ULONG   physicalAddress[MAX_SG_DESCRIPTORS];
	ULONG   addressLength[MAX_SG_DESCRIPTORS];
	ULONG   addressCount = 0;
	ULONG   sgEnteries = 0;

	ULONG   length;
	ULONG   i;

	if((int)dataPointer	& 0xF)
		goto use_internel;

	//
	// Create SDL segment descriptors.
	//
	do {
		//
		// Get physical address and length of contiguous physical buffer.
		//
		physicalAddress[addressCount] =
									   ScsiPortConvertPhysicalAddressToUlong(
			ScsiPortGetPhysicalAddress(pChan->HwDeviceExtension,
									   Srb,
									   dataPointer,
									   &length));

		//
		// If length of physical memory is more than bytes left
		// in transfer, use bytes left as final length.
		//
		if (length > bytesLeft)
			length = bytesLeft;

		addressLength[addressCount] = length;

		//
		// Adjust counts.
		//
		dataPointer = (PUCHAR)dataPointer + length;
		bytesLeft  -= length;
		addressCount++;

	} while (bytesLeft);

#ifdef BUFFER_CHECK									   
	if(psg == &(((PSrbExtension)(Srb->SrbExtension))->ArraySg[0])){
		if(((PSrbExtension)(Srb->SrbExtension))->WorkingFlags){
			__asm{
				int	3;
			}													   
		}
	}
#endif									// BUFFER_CHECK

	//
	// Create Scatter/Gather List
	//
	for (i = 0; i < addressCount; i++) {
		psg->SgAddress = physicalAddress[i];
		length = addressLength[i];

		// In Win95, ScsiPortGetPhysicalAddress() often returns small pieces
		// of memory blocks which are really contiguous physical memory.
		// Let's merge any contiguous addresses into one SG entry. This will
		// increase the performance a lot.
		//
		while ((i+1 < addressCount) &&
			   (psg->SgAddress+length == physicalAddress[i+1])) {
			i++;
			length += addressLength[i];
		}

		//
		// If contiguous physical memory skips 64K boundary, we split it.
		// Hpt366 don't support physical memory skipping 64K boundary in
		// one SG entry.
		//
		if ((psg->SgAddress & 0xFFFF0000) !=
			  ((psg->SgAddress+length-1) & 0xFFFF0000)) {
			ULONG firstPart;

			firstPart = 0x10000 - (psg->SgAddress & 0xFFFF);
			psg->SgSize = (USHORT)firstPart;
			psg->SgFlag = 0;

			sgEnteries++;
			psg++;

			psg->SgAddress = (psg-1)->SgAddress + firstPart;
			length -= firstPart;
		} // skip 64K boundary

		psg->SgSize = (USHORT)length;

		if((length & 3) || (length < 8))
use_internel:
			return Use_Internal_Buffer(pSG, Srb);

			psg->SgFlag = (i < addressCount-1) ? 0 : SG_FLAG_EOT;

			sgEnteries++;
			psg++;
	} // for each memory segment

	return(1);

} // BuildSgl()


/******************************************************************
 *  
 *******************************************************************/
#ifdef SUPPORT_ATAPI
void Start_Atapi(PDevice pDevice, PSCSI_REQUEST_BLOCK Srb)
{
	PChannel  pChan= pDevice->pChannel;
	PIDE_REGISTERS_1 IoPort = pChan->BaseIoAddress1;
	PIDE_REGISTERS_2 ControlPort = pChan->BaseIoAddress2;
	int    i;
	UCHAR   ScsiStatus, statusByte;

	//
	// Make sure command is to ATAPI device.
	//
	if (Srb->Lun || !(pDevice->DeviceFlags & DFLAGS_ATAPI)) {
		ScsiStatus = SRB_STATUS_SELECTION_TIMEOUT; //no device at this address
		goto out;
	}
	// Added by HS.Zhang
	// Added macro define check to let us change the DMA by set the
	// macro in forwin.h
#ifdef NO_DMA_ON_ATAPI	
	// no ultra DMA or DMA on ATAPI devices
	//				  
	if(pDevice->DeviceFlags & DFLAGS_ATAPI) {
		pDevice->DeviceFlags &= ~(DFLAGS_DMA | DFLAGS_ULTRA);
	}  
#endif									// NO_DMA_ON_ATAPI
	//
	// For some commands, we need to filter the CDB in Win95
	//
	for (i = Srb->CdbLength; i < MAXIMUM_CDB_SIZE; Srb->Cdb[i++] = 0);


	//
	// Deal with wrong DataTransferLength
	//
	if(Srb->Cdb[0] == 0x12) 
		Srb->DataTransferLength = (ULONG)Srb->Cdb[4];

	if (Srb->Cdb[0] == 0x5A && Srb->Cdb[2] != 5 &&
		  Srb->Cdb[8] > (UCHAR)Srb->DataTransferLength)
		Srb->DataTransferLength = (ULONG)Srb->Cdb[8];

	if (Srb->Cdb[0] == 0x28 && (Srb->DataTransferLength % 2352)==0) {
		Srb->Cdb[0] = 0xBE;
		Srb->Cdb[9] = 0xf8;
	}


	//
	// Select device 0 or 1.
	//
	SelectUnit(IoPort, pDevice->UnitId);

	//
	// When putting a MITSUBISHI LS120 with other device on a same channel,
	// the other device strangely is offten busy.
	//
	statusByte = WaitOnBusy(ControlPort);

	if (statusByte & IDE_STATUS_BUSY) {
		ScsiStatus = SRB_STATUS_BUSY;
		goto out;
	}

	if ((statusByte & IDE_STATUS_ERROR) &&
		  (Srb->Cdb[0] != SCSIOP_REQUEST_SENSE) && 
		  (Srb->Cdb[0] != SCSIOP_INQUIRY)) {
		ScsiStatus = MapAtapiErrorToOsError(GetErrorCode(IoPort), Srb);
		goto out;
	}

	//
	// If a tape drive doesn't have DSC set and the last command is
	// restrictive, don't send the next command. See discussion of
	// Restrictive Delayed Process commands in QIC-157.
	//
	if ((!(statusByte & IDE_STATUS_DSC)) &&
		  (pDevice->DeviceFlags & (DFLAGS_TAPE_RDP | DFLAGS_TAPE_RDP))) {
		ScsiPortStallExecution(1000);
		ScsiStatus =  SRB_STATUS_BUSY;
		goto out;
	}

	if (IS_RDP(Srb->Cdb[0])) 
		pDevice->DeviceFlags |= DFLAGS_TAPE_RDP;
	else
		pDevice->DeviceFlags &= ~DFLAGS_TAPE_RDP;


	if (statusByte & IDE_STATUS_DRQ) {
		//
		// Try to drain the data that one preliminary device thinks that it has
		// to transfer. Hopefully this random assertion of DRQ will not be present
		// in production devices.
		//
		for (i = 0; i < 0x10000; i++) {
			statusByte = GetStatus(ControlPort);

			if (statusByte & IDE_STATUS_DRQ)
				ScsiPortReadPortUshort(&IoPort->Data);
			else
				break;
		}

		if (i == 0x10000) {
			LOC_IDENTIFY

			AtapiSoftReset(IoPort,ControlPort,Srb->TargetId);

			//
			// Re-initialize Atapi device.
			//
			IssueIdentify(pDevice, IDE_COMMAND_ATAPI_IDENTIFY ARG_IDENTIFY );

			//
			// Inform the port driver that the bus has been reset.
			//
			ScsiPortNotification(ResetDetected, pChan->HwDeviceExtension, 0);

			//
			// Clean up device extension fields that AtapiStartIo won't.
			//
			ScsiStatus = SRB_STATUS_BUS_RESET;
out:
			//Srb->ScsiStatus = ScsiStatus;
			Srb->SrbStatus = ScsiStatus;
			return;
		}
	}


	//
	// Convert SCSI to ATAPI commands if needed
	//
	if (!(pDevice->DeviceFlags & DFLAGS_TAPE_DEVICE)) {

		Srb->CdbLength = 12;

		//
		// Save the original CDB
		//
		for (i = 0; i < MAXIMUM_CDB_SIZE; i++) 
			pChan->OrgCdb[i] = Srb->Cdb[i];

		switch (Srb->Cdb[0]) {
			case SCSIOP_MODE_SENSE: {
										PMODE_SENSE_10 modeSense10 = (PMODE_SENSE_10)Srb->Cdb;
										UCHAR PageCode = ((PCDB)Srb->Cdb)->MODE_SENSE.PageCode;
										UCHAR Length = ((PCDB)Srb->Cdb)->MODE_SENSE.AllocationLength;

										ZeroMemory(Srb->Cdb,MAXIMUM_CDB_SIZE);

										modeSense10->OperationCode = ATAPI_MODE_SENSE;
										modeSense10->PageCode = PageCode;
										modeSense10->ParameterListLengthMsb = 0;
										modeSense10->ParameterListLengthLsb = Length;

										pDevice->DeviceFlags |= DFLAGS_OPCODE_CONVERTED;
										break;
									}

			case SCSIOP_MODE_SELECT: {
										 PMODE_SELECT_10 modeSelect10 = (PMODE_SELECT_10)Srb->Cdb;
										 UCHAR Length = ((PCDB)Srb->Cdb)->MODE_SELECT.ParameterListLength;

			//
			// Zero the original cdb
			//
										 ZeroMemory(Srb->Cdb,MAXIMUM_CDB_SIZE);

										 modeSelect10->OperationCode = ATAPI_MODE_SELECT;
										 modeSelect10->PFBit = 1;
										 modeSelect10->ParameterListLengthMsb = 0;
										 modeSelect10->ParameterListLengthLsb = Length;

										 pDevice->DeviceFlags |= DFLAGS_OPCODE_CONVERTED;
										 break;
									 }

			case SCSIOP_FORMAT_UNIT:
			// DON'T DO THIS FOR LS-120!!!

			//Srb->Cdb[0] = ATAPI_FORMAT_UNIT;
			//pDevice->Flag |= DFLAGS_OPCODE_CONVERTED;
				break;
		}
	}


	if((pDevice->DeviceFlags & (DFLAGS_DMA|DFLAGS_ULTRA)) &&
	   (pDevice->DeviceFlags & DFLAGS_FORCE_PIO) == 0 &&
	   (Srb->Cdb[0] == 0x28 || Srb->Cdb[0] == 0x2A ||
		  Srb->Cdb[0] == 0x8 || Srb->Cdb[0] == 0xA) &&
	   BuildSgl(pDevice, pChan->pSgTable, Srb)) 
		pDevice->DeviceFlags |= DFLAGS_REQUEST_DMA;
	else
		pDevice->DeviceFlags &= ~DFLAGS_REQUEST_DMA;

	StartAtapiCommand(pDevice ARG_SRB);
}
#endif // SUPPORT_ATAPI

/******************************************************************
 *  
 *******************************************************************/
#ifdef SUPPORT_ATAPI
BOOLEAN Atapi_End_Interrupt(PDevice pDevice , PSCSI_REQUEST_BLOCK Srb)
{
	PChannel  pChan= pDevice->pChannel;
	PIDE_REGISTERS_1 IoPort = pChan->BaseIoAddress1;
	PIDE_REGISTERS_2 ControlPort = pChan->BaseIoAddress2;
	LONG    i;
	UCHAR  status = Srb->ScsiStatus, statusByte;
	pIOP    pIop;
	DCB*    pDcb;


	//
	// For some opcodes, we cannot report OVERRUN
	//
	if (status == SRB_STATUS_DATA_OVERRUN) {
		//
		// Don't report OVERRUN error for READ TOC to let CD AUDIO work.
		// (and also 0x5A)
		//
		if (Srb->Cdb[0] == 0x43 || Srb->Cdb[0] == 0x5A) {
			pChan->WordsLeft = 0;
			status = SRB_STATUS_SUCCESS;
		}
	}

	//
	// Translate ATAPI data back to SCSI data if needed
	//
	if (pDevice->DeviceFlags & DFLAGS_OPCODE_CONVERTED) {
		LONG    byteCount = Srb->DataTransferLength;
		char    *dataBuffer = Srb->DataBuffer;

		switch (Srb->Cdb[0]) {
			case ATAPI_MODE_SENSE:
			{
				PMODE_SENSE_10 modeSense10 = (PMODE_SENSE_10)Srb->Cdb;
				PMODE_PARAMETER_HEADER_10 header_10 = (PMODE_PARAMETER_HEADER_10)dataBuffer;
				PMODE_PARAMETER_HEADER header = (PMODE_PARAMETER_HEADER)dataBuffer;

				header->ModeDataLength = header_10->ModeDataLengthLsb;
				header->MediumType = header_10->MediumType;

			//
			// ATAPI Mode Parameter Header doesn't have these fields.
			//
				header->DeviceSpecificParameter = header_10->Reserved[0];
				header->BlockDescriptorLength = header_10->Reserved[1];

				byteCount -= sizeof(MODE_PARAMETER_HEADER_10);

				if (byteCount > 0)
					ScsiPortMoveMemory(
									   dataBuffer+sizeof(MODE_PARAMETER_HEADER),
									   dataBuffer+sizeof(MODE_PARAMETER_HEADER_10),
									   byteCount);

			//
			// Insert a block descriptor for Audio Control Mode Page
			// for AUDIO to work
			//
				if (modeSense10->PageCode == 0x0E) {
					for (i = byteCount-1; i >= 0; i--)
						dataBuffer[sizeof(MODE_PARAMETER_HEADER) + i + 8] =
							dataBuffer[sizeof(MODE_PARAMETER_HEADER) + i];

					for (i = 0; i < 8; i++)
						dataBuffer[4 + i]  = 0;

					header->BlockDescriptorLength = 8;
					dataBuffer[10] = 8;
				}

			//
			// Change ATAPI_MODE_SENSE opcode back to SCSIOP_MODE_SENSE
			//
				Srb->Cdb[0] = SCSIOP_MODE_SENSE;
				break;
			}

			case ATAPI_MODE_SELECT:
				Srb->Cdb[0] = SCSIOP_MODE_SELECT;
				break;

			case ATAPI_FORMAT_UNIT:
			//Srb->Cdb[0] = SCSIOP_FORMAT_UNIT;
				break;
		}
	}


	if (status != SRB_STATUS_ERROR) {
		if(pDevice->DeviceFlags & DFLAGS_CDROM_DEVICE) {
			//
			// Work around to make many atapi devices return correct 
			// sector size of 2048. Also certain devices will have 
			// sector count == 0x00, check for that also.
			//
			if (Srb->Cdb[0] == 0x25) {
				((PULONG)Srb->DataBuffer)[1] = 0x00080000;

				if (((PULONG)Srb->DataBuffer)[0] == 0x00)
					((PULONG)Srb->DataBuffer)[0] = 0xFFFFFF7F;
			}
		}

		//
		// Wait for busy to drop.
		//

		for (i = 0; i < 30; i++) {
			statusByte = GetStatus(ControlPort);
			if (!(statusByte & IDE_STATUS_BUSY)) 
				break;
			ScsiPortStallExecution(500);
		}

		if (i == 30) 
			goto reset;

		//
		// Check to see if DRQ is still up.
		//

		if (statusByte & IDE_STATUS_DRQ) {

			for (i = 0; i < 2048; i++) {
				statusByte = GetStatus(ControlPort);
				if (!(statusByte & IDE_STATUS_DRQ)) 
					break;

				ScsiPortReadPortUshort(&IoPort->Data);
				ScsiPortStallExecution(50);

			}

			if (i == 2048) {
reset:
				//
				// reset the controller.
				//
				AtapiResetController(pChan->HwDeviceExtension,Srb->PathId);
				return TRUE;
			}

		}
	}

	//
	// Sanity check that there is a current request.
	//
	if (Srb != NULL) {
		//
		// Check for underflow.
		//
		if (pChan->WordsLeft) {
			//
			// Subtract out residual words.
			//
			Srb->DataTransferLength -= pChan->WordsLeft;
		}

		//
		// Indicate command complete.
		//
		if (!(pDevice->DeviceFlags & DFLAGS_TAPE_RDP)) {
			DeviceInterrupt(pDevice, Srb);
		}
		else {
			OS_Busy_Handle(pChan, pDevice)
					return TRUE;
		}
	}


	pIop = *(pIOP *)((int)Srb+0x40);
	pDcb = (DCB*)pIop->IOP_physical_dcb;

	if(Srb->Cdb[0] == 0x12) {
		pDcb->DCB_cmn.DCB_device_flags2 |= DCB_DEV2_ATAPI_DEVICE;
		if(pDevice->DeviceFlags & DFLAGS_LS120) 
			pDcb->DCB_cmn.DCB_device_flags2 |= 0x40;
	}

	if(Srb->SrbStatus == SRB_STATUS_SUCCESS &&
	   Srb->ScsiStatus== SCSISTAT_GOOD &&
	   (Srb->Cdb[0] == 0x5A || Srb->Cdb[0] == 0x1A) &&
	   Srb->Cdb[2] == 0x2A) {
		PUCHAR pData = (Srb->DataBuffer)?
					   (PUCHAR)Srb->DataBuffer:
					   (PUCHAR)pIop->IOP_ior.IOR_buffer_ptr;
		if (!(pData[((Srb->Cdb[0] == 0x5A)? 8 : 4+pData[3]) + 2] & 8)) 
			pDcb->DCB_cmn.DCB_device_flags2 |= DCB_DEV2_ATAPI_DEVICE;
		else 
			pDcb->DCB_cmn.DCB_device_flags2 &= ~DCB_DEV2_ATAPI_DEVICE;

	}

	return TRUE;
}
#endif // SUPPORT_ATAPI

/******************************************************************
 * Get Stamps 
 *******************************************************************/
DWORD __stdcall LOCK_VTD_Get_Date_And_Time (DWORD* pDate);

ULONG GetStamp(void)
{
	ULONG Date, Time;
	Time = LOCK_VTD_Get_Date_And_Time(&Date);
	return((Time >> 4) | (Date << 28));
}

#ifdef SUPPORT_HOTSWAP

void CheckDeviceReentry(PChannel pChan, PSCSI_REQUEST_BLOCK Srb)
{

	if(Srb->Cdb[0]==0x12 && Srb->Lun == 0 && 
	   pChan->pDevice[0] == 0 && pChan->pDevice[1] == 0) {
		PDevice pDevice = &pChan->Devices[Srb->TargetId];
		HKEY    hKey;
		DWORD   ret, len;
		UCHAR   chnlstr[10]= {0,};
		DWORD   dwType;
		DWORD   szbuf;

		ret = RegOpenKey(
						 HKEY_LOCAL_MACHINE,     // Key handle at root level.
						 "SOFTWARE\\HighPoint\\Swap-n-Go",
						 &hKey);                 // Address of key to be returned.

		if(ret == ERROR_SUCCESS ) 
		{
			strcat(chnlstr, "Unplug");

			len= 4;
			dwType= REG_BINARY;

		  // Get key value
		  //
			RegQueryValueEx(
							hKey,       // Key handle.
							chnlstr,    // Buffer for class name.
							NULL,       // Length of class string.
							&dwType,    // address of buffer for value type
							(CHAR *)&szbuf,     // address of data buffer
							&len);      // address of data buffer size

			RegCloseKey(hKey);
			if(szbuf != 0)
				return;

		}

		for(i = 0; i < 10; i++) {
			ScsiPortStallExecution(1000*1000);
			AtapiHwInitialize(pChan);
			if(pChan->pDevice[0] != 0 || pChan->pDevice[1] != 0)
				break;
		}
	}
#endif //SUPPORT_HOTSWAP

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\port\scsi\miniport\hipoint\hpt3xx\winnt\ver.h ===
/* select one company !! */
#define HPT3XX
//#define IWILL_
//#define ABIT_
//#define ASHTON_
//#define JAPAN_
//#define ADAPTEC

#ifdef  ADAPTEC
#define COMPANY      "Adaptec"
#define PRODUCT_NAME "ATA RAID 1200A"
//#define COPYRIGHT    "(c) 1999-2001. HighPoint Technologies, Inc."
#define UTILITY      "BIOS Array Configuration Utility"
#define WWW_ADDRESS  "www.adaptec.com"
#endif


#ifdef  IWILL
#define COMPANY      "Iwill"
#define PRODUCT_NAME "SIDE RAID100 "
#define UTILITY      "ROMBSelect(TM) Utility"
#define WWW_ADDRESS  "www.iwill.net"
#define SHOW_LOGO
#endif

#ifdef HPT3XX
#define COMPANY      "HighPoint Technologies, Inc."

#ifdef _BIOS_
	#ifdef FOR_372
		#define PRODUCT_NAME "HPT370/372"
	#else
		#define PRODUCT_NAME "HPT372A"
	#endif
#else /* driver */
	#define PRODUCT_NAME "HPT370/370A/372/372A"
#endif

#define COPYRIGHT    "(c) 1999-2002. HighPoint Technologies, Inc." 
#define UTILITY      "BIOS Setting Utility"
#define WWW_ADDRESS  "www.highpoint-tech.com"
#define SHOW_LOGO
#endif

#ifdef JAPAN
#define COMPANY      "System TALKS Inc."
#define PRODUCT_NAME "UA-HD100C "
#define UTILITY      "UA-HD100C BIOS Settings Menu"
#define WWW_ADDRESS  "www.system-talks.co.jp"
#define SHOW_LOGO
#endif

#ifdef CENTOS
#define COMPANY      "         "
#define PRODUCT_NAME "CI-1520U10 "
#define UTILITY      "CI-1520U10 BIOS Settings Menu"
#define WWW_ADDRESS  "www.centos.com.tw"
#endif


#ifdef ASHTON
#define COMPANY      "Ashton Periperal Computer"
#define PRODUCT_NAME "In & Out "
#define UTILITY      "In & Out ATA-100 BIOS Settings Menu"
#define WWW_ADDRESS  "www.ashtondigital.com"
#endif


#ifndef VERSION_STR						// this version str macro can be defined in makefile
#define VERSION_STR ""
#endif									// VERSION_STR

#define VERSION    "v2.32"		// VERSION

#define BUILT_DATE __DATE__

/***************************************************************************
 * Description:  Version history
 ***************************************************************************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\port\scsi\miniport\hipoint\hpt3xx\winnt\winlog.c ===
/***************************************************************************
 * File:          Winlog.c
 * Description:   The ReportError routine for win9x & winNT
 * Author:        DaHai Huang    (DH)
 * Dependence:    none
 * Copyright (c)  2000 HighPoint Technologies, Inc. All rights reserved
 * History:
 *		11/16/2000	SLeng	Added code to handle removed disk added by hotplug
 *		2/16/2001	gmm		Move NotifyApplication() to a scsi callback
 *		2/26/2001	gmm		Remove Notify_Callback().
 ***************************************************************************/
#include "global.h"
#include "devmgr.h"

extern void check_bootable(PDevice pDevice);
extern PHW_DEVICE_EXTENSION hpt_adapters[];
void hpt_set_remained_member(PDevice pDev);

void do_dpc_routines(PHW_DEVICE_EXTENSION HwDeviceExtension)
{
	while (HwDeviceExtension->DpcQueue_First!=HwDeviceExtension->DpcQueue_Last) {
		ST_HPT_DPC p;
		p = HwDeviceExtension->DpcQueue[HwDeviceExtension->DpcQueue_First];
		HwDeviceExtension->DpcQueue_First++;
		HwDeviceExtension->DpcQueue_First %= MAX_DPC;
		p.dpc(p.arg);
	}
	HwDeviceExtension->dpc_pending = 0;
}

int hpt_queue_dpc(PHW_DEVICE_EXTENSION HwDeviceExtension, HPT_DPC dpc, void *arg)
{
	int p;
	if (HwDeviceExtension->EmptyRequestSlots==0xFFFFFFFF) {
		dpc(arg);
		return 0;
	}
	p = (HwDeviceExtension->DpcQueue_Last + 1) % MAX_DPC;
	if (p==HwDeviceExtension->DpcQueue_First) {
		return -1;
	}
	HwDeviceExtension->DpcQueue[HwDeviceExtension->DpcQueue_Last].dpc = dpc;
	HwDeviceExtension->DpcQueue[HwDeviceExtension->DpcQueue_Last].arg = arg;
	HwDeviceExtension->DpcQueue_Last = p;
	HwDeviceExtension->dpc_pending = 1;
	return 0;
}

void hpt_set_remained_member(PDevice pDev)
{
	PChannel pChan = pDev->pChannel;
	ArrayBlock ArrayBlk;
	if (ReadWrite(pDev, RECODR_LBA, IDE_COMMAND_READ, (PUSHORT)&ArrayBlk)) {
		ArrayBlk.Old.Flag |= OLDFLAG_REMAINED_MEMBER;
		ArrayBlk.RebuiltSector = 0;
		ReadWrite(pDev, RECODR_LBA, IDE_COMMAND_WRITE, (PUSHORT)&ArrayBlk);
		pDev->DeviceFlags2 |= DFLAGS_REMAINED_MEMBER;
	}
}

static void Set_RAID01_Remained(PVirtualDevice pArray)
{
	int iArray, i;
	PVirtualDevice pVD = pArray;
	PDevice pDev;

	for (iArray=0; iArray<2; iArray++) {
		if (iArray) {
			if ((pDev=pArray->pDevice[MIRROR_DISK]))
				pVD = pDev->pArray;
			else
				pVD = 0;
			if (!pVD) break;
		}
		for (i=0; i<SPARE_DISK; i++) {
			pDev=pVD->pDevice[i];
			if (pDev && !(pDev->DeviceFlags2 & DFLAGS_DEVICE_DISABLED)
				&& !(pDev->DeviceFlags2 & DFLAGS_REMAINED_MEMBER)) {
				hpt_set_remained_member(pDev);
			}
		}
	}
}

/* must be called from a DPC */
void hpt_assoc_mirror(PVirtualDevice pArray)
{
	ArrayBlock ArrayBlk;
	PDevice pDev1 = pArray->pDevice[0];
	PDevice pDev2 = pArray->pDevice[MIRROR_DISK];
	if (!pDev1 || !pDev2) return;
	
	/*
	 * assume source disk is always ok
	 */
	if (ReadWrite(pDev1, RECODR_LBA, IDE_COMMAND_READ, (PUSHORT)&ArrayBlk)) {
		ArrayBlk.StripeStamp++;
		ArrayBlk.RebuiltSector = 0;
		ArrayBlk.DeviceNum = 0;
		ReadWrite(pDev1, RECODR_LBA, IDE_COMMAND_WRITE, (PUSHORT)&ArrayBlk);
		ArrayBlk.DeviceNum = MIRROR_DISK;
		ReadWrite(pDev2, RECODR_LBA, IDE_COMMAND_WRITE, (PUSHORT)&ArrayBlk);
	}
}

void R01_member_fail(PDevice pDev)
{
	PVirtualDevice pArray = pDev->pArray;
	PVirtualDevice pSource=0, pMirror=0;
	
	pArray->BrokenFlag = TRUE;

	if (pArray->arrayType==VD_RAID_01_2STRIPE) {
		pSource = pArray;
		if (pArray->pDevice[MIRROR_DISK]) pMirror = pArray->pDevice[MIRROR_DISK]->pArray;
	}
	else {
		pMirror = pArray;
		if (pArray->pDevice[MIRROR_DISK]) pSource = pArray->pDevice[MIRROR_DISK]->pArray;
	}
	
	if (!pSource || !pMirror) {
		pArray->nDisk = 0;
		pArray->RaidFlags |= RAID_FLAGS_DISABLED;
		return;
	}
	
	if (pSource->BrokenFlag) {
		// swap source/mirror if possible
		if (!pMirror->BrokenFlag && !(pSource->RaidFlags & RAID_FLAGS_NEED_SYNCHRONIZE)) {
			DWORD f;
			pSource->arrayType = VD_RAID01_MIRROR;
			pMirror->arrayType = VD_RAID_01_2STRIPE;
			pMirror->capacity = pSource->capacity;
			pArray = pSource;
			pSource = pMirror;
			pMirror = pArray;
			pArray = pDev->pArray;
			/* swap RaidFlags too. */
			f = pMirror->RaidFlags & (RAID_FLAGS_NEED_SYNCHRONIZE |
											RAID_FLAGS_BEING_BUILT |
											RAID_FLAGS_BOOTDISK |
											RAID_FLAGS_NEWLY_CREATED);
			pMirror->RaidFlags &= ~f;
			pSource->RaidFlags |= f;
		}
		if (pSource->BrokenFlag) {
			/*
			 * The array should be unaccessible now.
			 */
			pSource->nDisk = 0;
			pSource->RaidFlags |= RAID_FLAGS_DISABLED;
			if (pMirror->BrokenFlag) {
				pMirror->nDisk = 0;
				pMirror->RaidFlags |= RAID_FLAGS_DISABLED;
			}
			return;
		}
	}

	// mark existing members 
	Set_RAID01_Remained(pSource);
	
	/// ASSERT(pArray==pMirror);
	pMirror->nDisk = 0;
	pMirror->RaidFlags |= RAID_FLAGS_DISABLED;
	return;
}

void report_event(PDevice pDev, BYTE error)
{
	PDevice pErr = g_pErrorDevice;
	pDev->stErrorLog.nLastError = error;
	if (!pErr) {
		g_pErrorDevice = pDev;
	}
	else {
		while (pErr!=pDev && pErr->stErrorLog.pNextErrorDevice!=NULL)
			pErr = pErr->stErrorLog.pNextErrorDevice;
		if (pErr!=pDev) {
			pErr->stErrorLog.pNextErrorDevice = pDev;
			pDev->stErrorLog.pNextErrorDevice = NULL;
		}
	}
	NotifyApplication(g_hAppNotificationEvent);
}

void disk_plugged_dpc(PDevice pDev)
{
	PHW_DEVICE_EXTENSION HwDeviceExtension = pDev->pChannel->HwDeviceExtension;
	int checkboot;
	ArrayBlock ArrayBlk;
	PVirtualDevice pArray;
	
	pDev->DeviceFlags2 &= ~DFLAGS_DEVICE_DISABLED;
	
	/* if pDev is an original member of an array, never mark it as bootable
	 * otherwise GUI will not allow to add it back
	 */
	pDev->DeviceFlags2 &= ~DFLAGS_BOOTABLE_DEVICE;
	ReadWrite(pDev, RECODR_LBA, IDE_COMMAND_READ, (PUSHORT)&ArrayBlk);
	if (ArrayBlk.Signature==HPT_ARRAY_NEW && ArrayBlk.StripeStamp)
		checkboot = 0;
	else
		checkboot = 1;
	
	pArray = pDev->pArray;
	if (!pArray) goto check_boot;
	
	switch (pArray->arrayType) {
	case VD_RAID_1_MIRROR:
		/* pDev has been removed from array */
		pDev->pArray = 0;
		pDev->DeviceFlags &= ~(DFLAGS_HIDEN_DISK|DFLAGS_ARRAY_DISK);
		break;
	case VD_RAID_0_STRIPE:
	case VD_SPAN:
		/* remove pDev from array */
		pArray->pDevice[pDev->ArrayNum] = 0;
		pDev->pArray = 0;
		pDev->DeviceFlags &= ~(DFLAGS_HIDEN_DISK|DFLAGS_ARRAY_DISK);
		if (pDev->HidenLBA) {
			pDev->capacity += pDev->HidenLBA;
			pDev->HidenLBA = 0;
		}
		break;
	case VD_RAID_01_2STRIPE:
	case VD_RAID01_MIRROR:
		{
			PVirtualDevice pOther = 0;
			if (pArray->pDevice[MIRROR_DISK]) pOther=pArray->pDevice[MIRROR_DISK]->pArray;

			/* remove it from pArray first */
			pArray->pDevice[pDev->ArrayNum] = 0;
			pDev->pArray = 0;
			pDev->DeviceFlags &= ~(DFLAGS_HIDEN_DISK|DFLAGS_ARRAY_DISK);
			if (pDev->HidenLBA) {
				pDev->capacity += pDev->HidenLBA;
				pDev->HidenLBA = 0;
			}
			
			if (pOther) {
				int i;
				/* re-link two arrays */
				if (pOther->pDevice[MIRROR_DISK]==pDev) {
					for (i=0; i<MIRROR_DISK; i++) {
						if (pArray->pDevice[i]) {
							pOther->pDevice[MIRROR_DISK]=pArray->pDevice[i];
							break;
						}
					}
				}
				/* cannot link? */
				if (pOther->pDevice[MIRROR_DISK]==pDev) {
					pOther->pDevice[MIRROR_DISK]=0;
					if (pOther->arrayType!=VD_RAID_01_2STRIPE) {
						pOther->arrayType = VD_RAID_01_2STRIPE;
						pOther->capacity = pArray->capacity;
					}
					/* this array is totally lost */
					pArray->arrayType = VD_INVALID_TYPE;
					/* pArray cannot be used, adjust logical device table */
					for (i=0; i<MAX_DEVICES_PER_CHIP; i++) {
						if (LogicalDevices[i].pLD==pArray) {
							LogicalDevices[i].pLD = pOther;
							break;
						}
					}
				}
			}
		}
		break;
	}
check_boot:
	if (checkboot && pDev->pArray==0) check_bootable(pDev);
	
	report_event(pDev, DEVICE_PLUGGED);
}

void disk_failed_dpc(PDevice pDev)
{
	PVirtualDevice pArray = pDev->pArray;

	pDev->DeviceFlags2 |= DFLAGS_DEVICE_DISABLED;

	if(pArray) {
		switch(pArray->arrayType) {
		case VD_RAID_01_2STRIPE:
		case VD_RAID01_MIRROR:
			R01_member_fail(pDev);
			break;
			
		case VD_RAID_1_MIRROR:
		{
			PDevice pSpareDevice, pMirrorDevice;

			// the disk has already removed from RAID group,
			// just report the error.
			if((pDev != pArray->pDevice[0])&&
			   (pDev != pArray->pDevice[MIRROR_DISK])&&
			   (pDev != pArray->pDevice[SPARE_DISK])){
				break;
			}

			pSpareDevice = pArray->pDevice[SPARE_DISK];
			pArray->pDevice[SPARE_DISK] = NULL;
			pMirrorDevice = pArray->pDevice[MIRROR_DISK];

			if (pDev==pSpareDevice) {
				// spare disk fails. just remove it.
				pSpareDevice->pArray = NULL;
			}
			else if(pDev == pArray->pDevice[MIRROR_DISK]){
				// mirror disk fails
				if(pSpareDevice != NULL){
					pSpareDevice->ArrayMask = 1<<MIRROR_DISK;
					pSpareDevice->ArrayNum = MIRROR_DISK;
					pArray->RaidFlags |= RAID_FLAGS_NEED_SYNCHRONIZE|RAID_FLAGS_NEED_AUTOREBUILD;
					pArray->pDevice[MIRROR_DISK] = pSpareDevice;
					hpt_assoc_mirror(pArray);
				}
				else
				{
					pArray->pDevice[MIRROR_DISK] = 0;
					pArray->BrokenFlag = TRUE;
					hpt_set_remained_member(pArray->pDevice[0]);
				}
			}else{
				// source disk fails
				if (pMirrorDevice) {
					pArray->pDevice[0] = pMirrorDevice;
					pMirrorDevice->ArrayMask = 1;
					pMirrorDevice->ArrayNum = 0;
					if (pSpareDevice) {
						pSpareDevice->ArrayMask = 1<<MIRROR_DISK;
						pSpareDevice->ArrayNum = MIRROR_DISK;
						pArray->pDevice[MIRROR_DISK] = pSpareDevice;
						pArray->RaidFlags |= RAID_FLAGS_NEED_SYNCHRONIZE|RAID_FLAGS_NEED_AUTOREBUILD;
						hpt_assoc_mirror(pArray);
					}
					else {
						pArray->pDevice[MIRROR_DISK] = 0;
						pArray->BrokenFlag = TRUE;
						hpt_set_remained_member(pMirrorDevice);
					}
				}
				else {
					pArray->nDisk = 0;
					pArray->pDevice[0] = 0;
					pArray->RaidFlags |= RAID_FLAGS_DISABLED;
				}
			}
		}
		break;

		default:
			pArray->nDisk = 0;
			pArray->BrokenFlag = TRUE;
			pArray->RaidFlags |= RAID_FLAGS_DISABLED;
			break;
		}
	}
	
	report_event(pDev, DEVICE_REMOVED);
}

int GetUserResponse(PDevice pDevice)
{
	return(TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\port\scsi\miniport\hp\fcmngr\fcinc\tach.h ===
#define uchar   unsigned char
#define ulong   unsigned long

#include "ports.h"
#include "tachlite.h"
//
//      Misc Defines
//
#define FCMNGR_VERSION          "0.35"
#define MAX_FC_CHIPS            0x02
#define MAX_INCOMING_DATA       (ulong)((MAX_SDB * SEST_BUFFER_LENGTH) - SEST_BUFFER_LENGTH)

//
// The maximum length an individual SG Write length can be.
//
#define MAX_TACHYON_SG_LENGTH           0xFFFC

//
// For each xid, there is a cmd/data IOP and a status IOP.
//
#ifdef PEGASUS
#define LS_IOPS                 QUEUE_DEPTH
#else
#define LS_IOPS                 32
#endif
#define FCMNGR_MAX_IOPS         (ulong)((QUEUE_DEPTH * 2) + LS_IOPS)
#define MAX_FCPS                (unsigned long)FCMNGR_MAX_IOPS

//
// For Initiators, the Outbound SEST FC Header will come from the FC Header
// in the Status IOP for that XID.
//
#define MAX_TACH_HEADERS        (ulong)(FCMNGR_MAX_IOPS)

#define MAX_DELAYED_LS_CMDS     QUEUE_DEPTH
//
// IOP FCMNGR_STATUS Values. Additional Values are in the Outbound Completion
// Message #defines.
//
#define IOP_STATUS              0x0001
#define IOP_FRAME_UNDERRUN      0x0002
#define IOP_FRAME_OVERRUN       0x0004
#define IOP_TARGET_ALPA_CHANGED 0x0008
#define IOP_TARGET_GONE         0x0020
#define IOP_NEW_ALPA            0x0040

//
//      Outbound Completion Message (Status Field)
//
#define CLASS_CONNECT_OPEN      0x0080
#define PROGRAMMING_ERROR       0x0100
#define RETRIES_EXCEEDED        0x0200
#define FRAME_REJECTED          0x0400
#define FRAME_TIME_OUT          0x0800
#define ACK_TIME_OUT            0x1000
#define ABORT_REQUESTED         0x2000
#define LINK_DOWN               0x4000
#define CLASS_1_ERROR           0x8000

#define IOP_ABORTED             0x00010000
#define IOP_ABORT_FAILED        0x00020000
#define TARGET_STATUS           0x00040000
#define TARGET_IS_RESET         0x00080000
#define IOP_STATUS_MASK         0xFFFFFFF0

//
// IOP FLAGS Values.
//
#define IOP_FREE                0x00000000
#define IOP_COMPLETE            0x00000001
#define IOP_IN_USE              0x00000002
#define IOP_NOT_COMPLETE        0x00000004
#define IOP_CHECK_DATA          0x00000008
#define IOP_ON_QUEUE            0x00000010
#define IOP_WAITING             0x00000020
#define IOP_INTR                0x00000040
#define IOP_ABORT               0x00000080
#define IOP_GONE                0x00000100
#define IOP_ABORT_PROCESSED     0x00000200
#define IOP_RESPONSE            0x00040000
#define IOP_LS_CMD              0x00080000
#define IOP_ANY_COMPLETE        0x000F0000

#define IOP_QUEUED_SAVED        0x00100000
#define IOP_QUEUED_SEND         0x00200000
#define IOP_QUEUED_WAIT         0x00400000

#define IOP_TASK_MANAGEMENT     0x01000000
#define IOP_TARGET_RESET        0x02000000


typedef enum {
    FCMNGR_SCSI = 0x00010000,
    FCMNGR_GENERIC = 0x00020000
} FRAME_TYPE, *PFRAME_TYPE;

//
// FCMNGR Error Codes
//
#define FCMNGR_SUCCESS          0x00
#define FCMNGR_INVALID_ADDR     0x01
#define FCMNGR_INVALID_ROOT     0x02
#define FCMNGR_INVALID_IOP      0x03
#define FCMNGR_INIT_NOT_COMPL   0x04
#define FCMNGR_NO_LOG           0x05
#define FCMNGR_IOP_BUSY         0x06
#define FCMNGR_FAILURE          0x0F
#define FCMNGR_NO_MEMORY        0x10
#define FCMNGR_MEMORY_ALIGNMENT 0x11
#define FCMNGR_HW_NOT_SUPPORTED 0x12
#define FCMNGR_INVALID_XFER     0x13
#define FCMNGR_INVALID_SG_SIZE  0x14
#define FCMNGR_NO_RESOURCES     0x15
#define FCMNGR_NOT_LOGGED_IN    0x16

//
// root phase defines
//
#define FCMNGR_NO_INIT          0x000020
#define FCMNGR_INIT_ROOT        0x000021
#define FCMNGR_GET_MEM_REQ      0x000022
#define FCMNGR_DEFINE_MEMORY    0x000023
#define FCMNGR_INIT_INTR        0x000024
#define FCMNGR_INIT_COMPLETE    0x000040

#define FCMNGR_FIRST_RESET      0x000080
#define FCMNGR_ID_CHANGE        0x010000
#define REESTABLISHING_LOGINS   0x020000
#define FCMNGR_OFFLINE          0x040000
#define FCMNGR_RESET            0x100000
#define INITIALIZATION          0x200000
#define ON_A_LOOP               0x400000
#define FINDING_OTHERS          0x800000
#define STATE_MASK              0xF00000

//
// Log Codes
//
#define FCMNGR_LOG_UNKNOWN_INTR         0x01
#define FCMNGR_LOG_BAD_SCSI_FRAME       0x04
#define FCMNGR_FATAL_ERROR              0x06
#define FCMNGR_HW_ERROR                 0x07
#define FCMNGR_WARNING                  0x09
#define FCMNGR_WARNING_LIP              0x109
#define FCMNGR_WARNING_E_STORE          0x209
#define FCMNGR_WARNING_OUT_SYNC         0x309
#define FCMNGR_WARNING_LASER_FAULT      0x409
#define FCMNGR_WARNING_LOOP_TIMEOUT     0x509
#define FCMNGR_WARNING_LOOP_FAILURE     0x609
#define FCMNGR_WARNING_OFFLINE          0x709
#define FCMNGR_LOGGED_IN                0x0A
#define FCMNGR_UNKNOWN_SFS_FRAME        0x0B
#define FCMNGR_SCSI_CMD                 0x0C
#define FCMNGR_SCSI_DATA                0x0D
#define FCMNGR_UNKNOWN_MFS_FRAME        0x0E
#define FCMNGR_ABORT_REQUEST            0x0F
#define FCMNGR_FREE_BUFFERS             0x10
#define FCMNGR_MY_ALPA                  0x20
#define FCMNGR_RESET_LOGINS             0x21
#define FCMNGR_TARGET_RESET_COMPLETE    0x22
#define FCMNGR_TARGET_RESET_FAILED      0x23
#define FCMNGR_LOGGED_OUT               0x24

//
// Reset Flags
//
#define FCMNGR_SOFT_RESET       0x01
#define FCMNGR_HARD_RESET       0x02
#define FCMNGR_TARGET_RESET     0x04

//
// Defines for returning the current Fibre Channel Loop Status
//
#define FULL_SPEED      0x30000000
#define LINK_UP         0x00
#define LOS             0x00
#define LOOP_PORT_STATE 0x00
#define LOOP_BYPASS     0x00
#define LOOP_ACCESS     0x00
#define DUPLEX          0x00
#define REPLICATE       0x00
//
// FCMNGR Interface Flags (For Target Code)
//
#define NEW_CDB                 0x01
#define FCMNGR_SEND_DATA        0x02
#define FCMNGR_GET_DATA         0x04
#define FCMNGR_SEND_STATUS      0x08

#define INITIATOR       0x00
#define TARGET          0x01

//
// Product ID's
//
#define JAGUAR          0xA0EC
#define JAGULAR         0xA0FB

#define SOFC1           0x030
#define SOFI1           0x050
#define SOFI2           0x060
#define SOFI3           0x070
#define SOFN1           0x090
#define SOFN2           0x0A0
#define SOFN3           0x0B0

#define EOFDT           0x01
#define EOFA            0x04
#define EOFN            0x05
#define EOFT            0x06

#define MAX_ALPA_VALUE  0xF0
//
//      Incoming Buffer Defines
//
#define FRAME_SIZE              0x3A0   // Maximum Frame Size. Per Bill
#define SFBQ_BUFFER_LENGTH      (ulong)0x200
#define MFSBQ_BUFFER_LENGTH     (ulong)0x200

//
//      Logical Drive defines
//
#define PERIPHERAL_DEVICE_ADDRESSING    0x00
#define VOLUME_SET_ADDRESSING           0x40
#define LOGICAL_UNIT_ADDRESSING         0x80

//
//      IMQ Interrupt Types
//
#define OUTBOUND_COMPLETE               0x000
#define OUTBOUND_COMPLETE_I             0x100
#define OUTBOUND_HI_PRI_COMPLETE        0x001
#define OUTBOUND_HI_PRI_COMPLETE_I      0x101

#define INBOUND_MFS_COMPLETE            0x002
#define INBOUND_OOO_COMPLETE            0x003
#define INBOUND_COMPLETION              0x004
#define INBOUND_C1_TIMEOUT              0x005
#define INBOUND_UNKNOWN_FRAME           0x006
#define INBOUND_BUSIED_FRAME            0x006

#define SFS_BUF_WARN                    0x007
#define MFS_BUF_WARN                    0x008
#define IMQ_BUF_WARN                    0x009

#define FRAME_MANAGER_INTR              0x00A
#define READ_STATUS                     0x00B
#define INBOUND_SCSI_DATA_COMPLETE      0x00C
#define INBOUND_SCSI_COMMAND            0x00D
#define BAD_SCSI_FRAME                  0x00E
#define INBOUND_SCSI_STAT_COMPLETE      0x00F

//
//      Queue Depths
//
#define HPCQ_DEPTH              (ulong)0x08
#define MFSBQ_DEPTH             (ulong)0x04
#define SEST_DEPTH              (ulong)QUEUE_DEPTH

//
// Tachyon Register Offsets
//
#define OCQ_BASE                0x00
#define OCQ_LENGTH              0x04
#define OCQ_PRODUCER_INDEX      0x08
#define OCQ_CONSUMER_INDEX      0x0C

#define HPCQ_BASE               0x40
#define HPCQ_LENGTH             0x44
#define HPCQ_PRODUCER_INDEX     0x48
#define HPCQ_CONSUMER_INDEX     0x4C

#define IMQ_BASE                0x80
#define IMQ_LENGTH              0x84
#define IMQ_CONSUMER_INDEX      0x88
#define IMQ_PRODUCER_INDEX      0x8C

#define MFSBQ_BASE              0xC0
#define MFSBQ_LENGTH            0xC4
#define MFSBQ_PRODUCER_INDEX    0xC8
#define MFSBQ_CONSUMER_INDEX    0xCC
#define MFSBQ_BUFFER_LENGTH_REG 0xD0

#define SFBQ_BASE               0x000
#define SFBQ_LENGTH             0x004
#define SFBQ_PRODUCER_INDEX     0x008
#define SFBQ_CONSUMER_INDEX     0x00C
#define SFBQ_BUFFER_LENGTH_REG  0x010

#define SEST_BASE               0x040
#define SEST_LENGTH             0x044
#define SEST_BUFFER_LENGTH_REG  0x048

#define TYCNTL_CONFIG           0x084
#define TYCNTL_CONTROL          0x088
#define TYCNTL_STATUS           0x08C
#define FLUSH_OXID              0x090
#define EE_CR0_TMR              0x094
#define BB_CR0_TMR              0x098
#define RX_FRAME_ERR            0x09C

#define FMCNTL_CONFIG           0x0C0
#define FMCNTL_CONTROL          0x0C4
#define FMCNTL_STATUS           0x0C8
#define FMCNTL_TOV              0x0CC
#define FMCNTL_LINK_STATUS1     0x0D0
#define FMCNTL_LINK_STATUS2     0x0D4
#define WWNAME_HI               0x0E0
#define WWNAME_LO               0x0E4
#define FMCNTL_AL_PA            0x0E8
#define FMCNTL_PRIMITIVE        0x0EC

//
//      ODB CONTROL Defines
//
#define ODB_CLASS_1             0x40000000
#define ODB_CLASS_2             0x80000000
#define ODB_CLASS_3             0xC0000000
#define XID_INTERLOCK           0x20000000
#define ODB_SOFC1               0x10000000
#define ODB_END_CONNECTION      0x8000000
#define ODB_NO_COMP             0x4000000
#define ODB_NO_INT              0x2000000
#define ODB_ACK0                0x1000000
#define FILL_BYTES_USED         0xC00000
#define ODB_CONT_SEQ            0x100000
#define ODB_EE_CREDIT           0x0F0000

//
//      SEST Defines
//

#define SCSI_VALID              0x80000000
#define SDB_ERROR               0x40000000
#define INBOUND_SCSI            0x20000000
#define X_ID_MASK               0xDFFF
#define INBOUND_SCSI_XID        0x4000
#define NOT_SCSI_XFER           0x8000

//
//      EDB Defines
//
#define EDB_END_BIT             0x80000000
#define EDB_HEADER_BIT          0x40000000
#define EDB_FRAME_BOUNDARY_BIT  0x20000000

//
//      Tachyon Header Defines
//
#define TACHYON_TS_VALID                0x100
#define TACHYON_LOOP_CREDIT_MASK        0x07
#define TACHYON_LOOP_CREDIT_SHIFT       0x0A
#define TACHYON_LOOP_CLOSE              0x2000
#define TACHYON_UNFAIR_ACCESS           0x4000
#define TACHYON_DISABLE_CRC             0x8000
//
//      Control Register Defines (TYCNTL)
//
//      TYCNTL Config Register Defines
//
#define SCSI_ASSIST             0x40000000
#define DISABLE_P_BSY           0x01000000

#define SCSI_AUTO_ACK           0x1000
#define OOO_DISABLE             0x40
#define ACK_DISABLE             0x20
#define RETRY_DISABLE           0x10
#define POINT_TO_POINT          0x08
#define PARITY_ENABLE           0x04
#define STACKED_CONNECTS        0x01

//
//      TYCNTL Control Register Defines
//
#define STATUS_REQUEST          0x01
#define ERROR_RELEASE           0x02
#define OCQ_RESET               0x04
#define SCSI_FREEZE             0x08
#define SOFTWARE_RESET          0x80000000

//
//      TYCNTL Status Register Defines
//
#define OSM_FROZEN              0x01
#define CHIP_REVISION_MASK      0x0E
#define RECEIVE_FIFO_EMPTY      0x10
#define OCQ_RESET_STATUS        0x20
#define SCSI_FREEZE_STATUS      0x40
#define TY_FATAL_ERROR          0xF80
#define SEND_FIFO_EMPTY         0x1000

//
//      TYCNTL Flush OX_ID Cache Entry Register Defines
//
#define FLUSH_IN_PROGRESS       0x80000000

//
//      TYCNTL EE Credit Zero Timer Register Defines
//
#define EE_CR0_TMR_MASK         0xFFFFFF

//
//      TYCNTL BB Credit Zero Timer Register Defines
//
#define BB_CR0_TMR_MASK         0xFFFFFF

//
//      TYCNTL Receive Frame Error Count Register Defines
//
#define RX_FRAME_ERR_MASK       0xFFFF0000

//
//      Frame Manager Register Defines (FMCNTL)
//
//      Frame Manager Configuration Register
//
#define FMCNTL_ALPA_MASK                0xFF000000
#define FMCNTL_BB_CREDIT_MASK           0x00FF0000
#define FMCNTL_N_PORT                   0x000   // x8000 to be an N-Port
#define FMCNTL_INTERNAL_LB              0x4000
#define FMCNTL_EXTERNAL_LB              0x2000
#define TIMER_DISABLE                   0x800
#define FMCNTL_FABRIC_ACQ_ADDR          0x400
#define PREV_ACQ_ADDR                   0x200
#define PREFERRED_ADDR                  0x100
#define SOFT_ADDR                       0x80
#define RESP_FABRIC_ADDR                0x20
#define INIT_AS_FABRIC                  0x10
#define FMCNTL_LOGIN_REQ                0x08
#define NON_PARTICIPATING               0xFFFFF87F

//
//      Frame Manager Control Register
//
#define FMCNTL_PRIM_SEQ                 0x40
#define FMCNTL_SEND_PRIM_REG            0x20
#define FMCNTL_NO_CLOSE_LOOP            0x10
#define FMCNTL_CLOSE_LOOP               0x08
#define FMCNTL_NOP                      0x00
#define FMCNTL_HOST_CNTRL               0x02
#define FMCNTL_EXIT_HOST_CNTRL          0x03
#define FMCNTL_LINK_RESET               0x04
#define FMCNTL_OFFLINE                  0x05
#define FMCNTL_INIT                     0x06
#define FMCNTL_CLEAR_LF                 0x07

//
//      Frame Manager Status Register
//

#define FMCNTL_STATUS_LOOP              0x80000000
#define FMCNTL_TX_PAR_ERR               0x40000000
#define FMCNTL_NON_PARTICIPATE          0x20000000
#define FMCNTL_PARALLEL_ID              0x18000000

#define FMCNTL_STATUS_MASK              0x07FFFF00
#define LINK_FAULT                      0x04000000
#define OUT_OF_SYNC                     0x02000000
#define LOSS_SIGNAL                     0x01000000
#define NOS_OLS                         0x00080000
#define LOOP_TIMEOUT                    0x00040000
#define FMCNTL_LIPf                     0x00020000
#define BAD_ALPA                        0x00010000
#define FMCNTL_PRIM_REC                 0x00008000
#define FMCNTL_PRIM_SENT                0x00004000
#define FMCNTL_FABRIC_LOGIN_REQ         0x00002000
#define LINK_FAILURE                    0x00001000
#define FMCNTL_CREDIT_ERROR             0x00000800
#define ELASTIC_STORE_ERR               0x00000400
#define FMCNTL_LINK_UP                  0x00000200
#define FMCNTL_LINK_DOWN                0x00000100
#define FMCNTL_HOST_CONTROL             0x000000C0

#define LOOP_STATE_MASK                 0xF0
#define PORT_STATE_MASK                 0x0F

//
// Loop State Defines
//
#define MONITORING                      0x00000000
#define ARBITRATING                     0x00000010
#define ARBITRATION_WON                 0x00000020
#define LOOP_OPEN                       0x00000030
#define LOOP_OPENED                     0x00000040
#define XMITTED_CLOSE                   0x00000050
#define CLOSE_RECEIVED                  0x00000060
#define LOOP_TRANSFER                   0x00000070
#define INITIALIZING                    0x00000080
#define O_I_INIT_FINISH                 0x00000090
#define O_I_INIT_PROTOCOL               0x000000A0
#define O_I_LIP_RECEIVED                0x000000B0
#define HOST_CONTROL                    0x000000C0
#define LOOP_FAIL                       0x000000D0
#define OLD_PORT                        0x000000F0
//
//      Frame Manager Round Trip & Error Detect Time Out Register
//
#define FMCNTL_RT_TOV_MASK              0x1FF0000
#define FMCNTL_ED_TOV_MASK              0xFFFF

//
//      Frame Manager Link Error Status 1 Register
//
#define FMCNTL_STATUS1_LFC_MASK         0x0F            // Link Fail Count
#define FMCNTL_STATUS1_LSC_MASK         0xFF0           // Loss of Sync Count
#define FMCNTL_STATUS1_BCC_MASK         0xFF000         // Bad Tx Character Cnt
#define FMCNTL_STATUS1_LSS_MASK         0xFF00000       // Loss of Signal Count

//
//      Frame Manager Link Error Status 2 Register
//
#define FMCNTL_STATUS2_PEC_MASK         0x0F            // Protocol Error Count
#define FMCNTL_STATUS2_BAD_CRC          0xFF0           // Bad CRC Count
#define FMCNTL_STATUS2_GEN_EOFA         0xFF000         // Generated EOFa Count
#define FMCNTL_STATUS2_REC_EOFA         0xFF00000       // Received EOFa Count

//
//      Frame Manager Received AL_PA Register
//
#define FMCNTL_LIPf_ALPA                0xFF            // AL PA of last LIPf
#define BAD_AL_PA_MASK                  0xFF00          // AL PA Not Accepted

#define DOING_RESET     1

#include "taki.h"

//
// If MAX_ENTRIES exceeds 24, the "buffer" variable in init.c will need to be
// made larger.
//
#define MAX_ENTRIES     20              // Number of FC related structures
#define SDBS            0
#define SFBQ_BUFFERS    1
#define OCQ             2
#define IMQ             3
#define HPQ_CONS        4
#define SEST            5
#define MFSBQ_BUFFERS   6
#define OCQ_CONS        7
#define SFBQ            8
#define IMQ_PROD        9
#define MFSBQ           10
#define HPQ             11
#define LOGIN           12
#define PRLI            13
#define LOGOUT          14
#define IOP             15
#define HPFS_INDEX      16
#define PRLO            17
#define ADISC           18
#define STATUS_BUFFER   19
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\port\scsi\miniport\ibm\cbidf\atapi.c ===
/*++

Copyright (c) 1993-4  Microsoft Corporation

Module Name:

    atapi.c

Abstract:

    This is the miniport driver for ATAPI IDE controllers.

Author:

    Mike Glass (MGlass)
    Chuck Park (ChuckP)

Environment:

    kernel mode only

Notes:

Revision History:

--*/

#include "ntddk.h"
// #include "miniport.h"
#include "atapi.h"               // includes scsi.h
#include "ntdddisk.h"
#include "ntddscsi.h"

//
// Device extension
//

typedef struct _HW_DEVICE_EXTENSION {

    //
    // Current request on controller.
    //

    PSCSI_REQUEST_BLOCK CurrentSrb;

    //
    // Base register locations
    //

    PIDE_REGISTERS_1 BaseIoAddress1[2];
    PIDE_REGISTERS_2 BaseIoAddress2[2];

    //
    // Interrupt level
    //

    ULONG InterruptLevel;

    //
    // Interrupt Mode (Level or Edge)
    //

    ULONG InterruptMode;

    //
    // Data buffer pointer.
    //

    PUSHORT DataBuffer;

    //
    // Data words left.
    //

    ULONG WordsLeft;

    //
    // Number of channels being supported by one instantiation
    // of the device extension. Normally (and correctly) one, but
    // with so many broken PCI IDE controllers being sold, we have
    // to support them.
    //

    ULONG NumberChannels;

    //
    // Count of errors. Used to turn off features.
    //

    ULONG ErrorCount;

    //
    // Indicates number of platters on changer-ish devices.
    //

    ULONG DiscsPresent[4];

    //
    // Flags word for each possible device.
    //

    USHORT DeviceFlags[4];

    //
    // Indicates the number of blocks transferred per int. according to the
    // identify data.
    //

    UCHAR MaximumBlockXfer[4];

    //
    // Indicates expecting an interrupt
    //

    BOOLEAN ExpectingInterrupt;

    //
    // Indicate last tape command was DSC Restrictive.
    //

    BOOLEAN RDP;

    //
    // Driver is being used by the crash dump utility or ntldr.
    //

    BOOLEAN DriverMustPoll;

    //
    // Indicates use of 32-bit PIO
    //

    BOOLEAN DWordIO;

    //
    // Indicates whether '0x1f0' is the base address. Used
    // in SMART Ioctl calls.
    //

    BOOLEAN PrimaryAddress;

    //
    // Placeholder for the sub-command value of the last
    // SMART command.
    //

    UCHAR SmartCommand;

    //
    // Placeholder for status register after a GET_MEDIA_STATUS command
    //

    UCHAR ReturningMediaStatus;

    //
    // Indicate support irq sharing
    //

    BOOLEAN IrqSharing;

    //
    // Identify data for device
    //

    IDENTIFY_DATA FullIdentifyData;
    IDENTIFY_DATA2 IdentifyData[4];

    //
    // Mechanism Status Srb Data
    //
    PSCSI_REQUEST_BLOCK OriginalSrb;
    SCSI_REQUEST_BLOCK InternalSrb;
    MECHANICAL_STATUS_INFORMATION_HEADER MechStatusData;
    SENSE_DATA MechStatusSense;
    ULONG MechStatusRetryCount;

} HW_DEVICE_EXTENSION, *PHW_DEVICE_EXTENSION;

//
// Logical unit extension
//

typedef struct _HW_LU_EXTENSION {
   ULONG Reserved;
} HW_LU_EXTENSION, *PHW_LU_EXTENSION;

PSCSI_REQUEST_BLOCK
BuildMechanismStatusSrb (
    IN PVOID HwDeviceExtension,
    IN ULONG PathId,
    IN ULONG TargetId
    );

PSCSI_REQUEST_BLOCK
BuildRequestSenseSrb (
    IN PVOID HwDeviceExtension,
    IN ULONG PathId,
    IN ULONG TargetId
    );

VOID
AtapiHwInitializeChanger (
    IN PVOID HwDeviceExtension,
    IN ULONG TargetId,
    IN PMECHANICAL_STATUS_INFORMATION_HEADER MechanismStatus
    );

ULONG
AtapiSendCommand(
    IN PVOID HwDeviceExtension,
    IN PSCSI_REQUEST_BLOCK Srb
    );

VOID
AtapiZeroMemory(
    IN PCHAR Buffer,
    IN ULONG Count
    );

VOID
AtapiHexToString (
    ULONG Value,
    PCHAR *Buffer
    );

LONG
AtapiStringCmp (
    PCHAR FirstStr,
    PCHAR SecondStr,
    ULONG Count
    );

BOOLEAN
AtapiInterrupt(
    IN PVOID HwDeviceExtension
    );

BOOLEAN
AtapiHwInitialize(
    IN PVOID HwDeviceExtension
        );

ULONG
IdeBuildSenseBuffer(
    IN PVOID HwDeviceExtension,
    IN PSCSI_REQUEST_BLOCK Srb
    );

VOID
IdeMediaStatus(
    IN BOOLEAN EnableMSN,
    IN PVOID HwDeviceExtension,
    IN ULONG Channel
    );

ULONG
AtapiParseArgumentString(
    IN PCHAR String,
    IN PCHAR KeyWord
    );



BOOLEAN
IssueIdentify(
    IN PVOID HwDeviceExtension,
    IN ULONG DeviceNumber,
    IN ULONG Channel,
    IN UCHAR Command
    )

/*++

Routine Description:

    Issue IDENTIFY command to a device.

Arguments:

    HwDeviceExtension - HBA miniport driver's adapter data storage
    DeviceNumber - Indicates which device.
    Command - Either the standard (EC) or the ATAPI packet (A1) IDENTIFY.

Return Value:

    TRUE if all goes well.

--*/

{
    PHW_DEVICE_EXTENSION deviceExtension = HwDeviceExtension;
    PIDE_REGISTERS_1     baseIoAddress1 = deviceExtension->BaseIoAddress1[Channel] ;
    PIDE_REGISTERS_2     baseIoAddress2 = deviceExtension->BaseIoAddress2[Channel];
    ULONG                waitCount = 20000;
    ULONG                i,j;
    UCHAR                statusByte;
    UCHAR                signatureLow,
                         signatureHigh;

    //
    // Select device 0 or 1.
    //

    ScsiPortWritePortUchar(&baseIoAddress1->DriveSelect,
                           (UCHAR)((DeviceNumber << 4) | 0xA0));

    //
    // Check that the status register makes sense.
    //

    GetBaseStatus(baseIoAddress1, statusByte);

    if (Command == IDE_COMMAND_IDENTIFY) {

        //
        // Mask status byte ERROR bits.
        //

        statusByte &= ~(IDE_STATUS_ERROR | IDE_STATUS_INDEX);

        DebugPrint((1,
                    "IssueIdentify: Checking for IDE. Status (%x)\n",
                    statusByte));

        //
        // Check if register value is reasonable.
        //

        if (statusByte != IDE_STATUS_IDLE) {

            //
            // Reset the controller.
            //

            AtapiSoftReset(baseIoAddress1,baseIoAddress2,DeviceNumber);

            ScsiPortWritePortUchar(&baseIoAddress1->DriveSelect,
                                   (UCHAR)((DeviceNumber << 4) | 0xA0));

            WaitOnBusy(baseIoAddress2,statusByte);

            signatureLow = ScsiPortReadPortUchar(&baseIoAddress1->CylinderLow);
            signatureHigh = ScsiPortReadPortUchar(&baseIoAddress1->CylinderHigh);

            if (signatureLow == 0x14 && signatureHigh == 0xEB) {

                //
                // Device is Atapi.
                //

                return FALSE;
            }

            DebugPrint((1,
                        "IssueIdentify: Resetting controller.\n"));

            ScsiPortWritePortUchar(&baseIoAddress2->AlternateStatus,IDE_DC_RESET_CONTROLLER );
            ScsiPortStallExecution(500 * 1000);
            ScsiPortWritePortUchar(&baseIoAddress2->AlternateStatus,IDE_DC_REENABLE_CONTROLLER);


            // We really should wait up to 31 seconds
            // The ATA spec. allows device 0 to come back from BUSY in 31 seconds!
            // (30 seconds for device 1)
            do {

                //
                // Wait for Busy to drop.
                //

                ScsiPortStallExecution(100);
                GetStatus(baseIoAddress2, statusByte);

            } while ((statusByte & IDE_STATUS_BUSY) && waitCount--);

            ScsiPortWritePortUchar(&baseIoAddress1->DriveSelect,
                                   (UCHAR)((DeviceNumber << 4) | 0xA0));

            //
            // Another check for signature, to deal with one model Atapi that doesn't assert signature after
            // a soft reset.
            //

            signatureLow = ScsiPortReadPortUchar(&baseIoAddress1->CylinderLow);
            signatureHigh = ScsiPortReadPortUchar(&baseIoAddress1->CylinderHigh);

            if (signatureLow == 0x14 && signatureHigh == 0xEB) {

                //
                // Device is Atapi.
                //

                return FALSE;
            }

            statusByte &= ~IDE_STATUS_INDEX;

            if (statusByte != IDE_STATUS_IDLE) {

                //
                // Give up on this.
                //

                return FALSE;
            }

        }

    } else {

        DebugPrint((1,
                    "IssueIdentify: Checking for ATAPI. Status (%x)\n",
                    statusByte));

    }

    //
    // Load CylinderHigh and CylinderLow with number bytes to transfer.
    //

    ScsiPortWritePortUchar(&baseIoAddress1->CylinderHigh, (0x200 >> 8));
    ScsiPortWritePortUchar(&baseIoAddress1->CylinderLow,  (0x200 & 0xFF));

    for (j = 0; j < 2; j++) {

        //
        // Send IDENTIFY command.
        //

        WaitOnBusy(baseIoAddress2,statusByte);

        ScsiPortWritePortUchar(&baseIoAddress1->Command, Command);

        //
        // Wait for DRQ.
        //

        for (i = 0; i < 4; i++) {

            WaitForDrq(baseIoAddress2, statusByte);

            if (statusByte & IDE_STATUS_DRQ) {

                //
                // Read status to acknowledge any interrupts generated.
                //

                GetBaseStatus(baseIoAddress1, statusByte);

                //
                // One last check for Atapi.
                //


                signatureLow = ScsiPortReadPortUchar(&baseIoAddress1->CylinderLow);
                signatureHigh = ScsiPortReadPortUchar(&baseIoAddress1->CylinderHigh);

                if (signatureLow == 0x14 && signatureHigh == 0xEB) {

                    //
                    // Device is Atapi.
                    //

                    return FALSE;
                }

                break;
            }

            if (Command == IDE_COMMAND_IDENTIFY) {

                //
                // Check the signature. If DRQ didn't come up it's likely Atapi.
                //

                signatureLow = ScsiPortReadPortUchar(&baseIoAddress1->CylinderLow);
                signatureHigh = ScsiPortReadPortUchar(&baseIoAddress1->CylinderHigh);

                if (signatureLow == 0x14 && signatureHigh == 0xEB) {

                    //
                    // Device is Atapi.
                    //

                    return FALSE;
                }
            }

            WaitOnBusy(baseIoAddress2,statusByte);
        }

        if (i == 4 && j == 0) {

            //
            // Device didn't respond correctly. It will be given one more chances.
            //

            DebugPrint((1,
                        "IssueIdentify: DRQ never asserted (%x). Error reg (%x)\n",
                        statusByte,
                         ScsiPortReadPortUchar((PUCHAR)baseIoAddress1 + 1)));

            AtapiSoftReset(baseIoAddress1,baseIoAddress2,DeviceNumber);

            GetStatus(baseIoAddress2,statusByte);

            DebugPrint((1,
                       "IssueIdentify: Status after soft reset (%x)\n",
                       statusByte));

        } else {

            break;

        }
    }

    //
    // Check for error on really stupid master devices that assert random
    // patterns of bits in the status register at the slave address.
    //

    if ((Command == IDE_COMMAND_IDENTIFY) && (statusByte & IDE_STATUS_ERROR)) {
        return FALSE;
    }

    DebugPrint((1,
               "IssueIdentify: Status before read words %x\n",
               statusByte));

    //
    // Suck out 256 words. After waiting for one model that asserts busy
    // after receiving the Packet Identify command.
    //

    WaitOnBusy(baseIoAddress2,statusByte);

    if (!(statusByte & IDE_STATUS_DRQ)) {
        return FALSE;
    }

    ReadBuffer(baseIoAddress1,
               (PUSHORT)&deviceExtension->FullIdentifyData,
               256);

    //
    // Check out a few capabilities / limitations of the device.
    //

    if (Command == IDE_COMMAND_IDENTIFY ||
        (deviceExtension->FullIdentifyData.GeneralConfiguration & 0x1F00) != 0x0500)
    {
        //
        // Determine this drive is removable
        //

        DebugPrint((1,
                    "IssueIdentify: Device is a ATA or ATAPI disk drive (type %x).\n",
                    (UCHAR)(deviceExtension->FullIdentifyData.GeneralConfiguration >> 8)));

        if (Command == IDE_COMMAND_IDENTIFY
            && deviceExtension->FullIdentifyData.GeneralConfiguration & 0x0080)
        {
            deviceExtension->DeviceFlags[(Channel * 2) + DeviceNumber] |= DFLAGS_REMOVABLE_DRIVE;

            DebugPrint((1,
                        "IssueIdentify: Marking ATA drive as removable. (%x)\n",
                        (UCHAR)(deviceExtension->FullIdentifyData.GeneralConfiguration & 0xff)));
        }
        /*
        else if (Command != IDE_COMMAND_IDENTIFY)
        {
            deviceExtension->DeviceFlags[(Channel * 2) + DeviceNumber] |= DFLAGS_REMOVABLE_DRIVE;

            DebugPrint((1,
                        "IssueIdentify: Marking ATAPI drive as removable. (%x)\n",
                        (UCHAR)(deviceExtension->FullIdentifyData.GeneralConfiguration & 0xff)));
        }
        */
    }

    if (deviceExtension->FullIdentifyData.MaximumBlockTransfer) {

        //
        // Determine max. block transfer for this device.
        //

        deviceExtension->MaximumBlockXfer[(Channel * 2) + DeviceNumber] =
            (UCHAR)(deviceExtension->FullIdentifyData.MaximumBlockTransfer & 0xFF);
    }

    ScsiPortMoveMemory(&deviceExtension->IdentifyData[(Channel * 2) + DeviceNumber],&deviceExtension->FullIdentifyData,sizeof(IDENTIFY_DATA2));

    if (deviceExtension->IdentifyData[(Channel * 2) + DeviceNumber].GeneralConfiguration & 0x20 &&
        Command != IDE_COMMAND_IDENTIFY) {

        //
        // This device interrupts with the assertion of DRQ after receiving
        // Atapi Packet Command
        //

        deviceExtension->DeviceFlags[(Channel * 2) + DeviceNumber] |= DFLAGS_INT_DRQ;

        DebugPrint((1,
                    "IssueIdentify: Device interrupts on assertion of DRQ.\n"));

    } else {

        DebugPrint((1,
                    "IssueIdentify: Device does not interrupt on assertion of DRQ.\n"));
    }

    if (((deviceExtension->IdentifyData[(Channel * 2) + DeviceNumber].GeneralConfiguration & 0xF00) == 0x100) &&
        Command != IDE_COMMAND_IDENTIFY) {

        //
        // This is a tape.
        //

        deviceExtension->DeviceFlags[(Channel * 2) + DeviceNumber] |= DFLAGS_TAPE_DEVICE;

        DebugPrint((2,
                    "IssueIdentify: Device is a tape drive.\n"));

    } else {

        DebugPrint((2,
                    "IssueIdentify: Device is not a tape drive.\n"));
    }

    //
    // Work around for some IDE and one model Atapi that will present more than
    // 256 bytes for the Identify data.
    //

    WaitOnBusy(baseIoAddress2,statusByte);

    for (i = 0; i < 0x10000; i++) {

        GetStatus(baseIoAddress2,statusByte);

        if (statusByte & IDE_STATUS_DRQ) {

            //
            // Suck out any remaining bytes and throw away.
            //

            ScsiPortReadPortUshort(&baseIoAddress1->Data);

        } else {

            break;

        }
    }

    DebugPrint((1,
               "IssueIdentify: Status after read words (%x)\n",
               statusByte));

    return TRUE;

} // end IssueIdentify()


BOOLEAN
AtapiResetController(
    IN PVOID HwDeviceExtension,
    IN ULONG PathId
    )

/*++

Routine Description:

    Reset IDE controller and/or Atapi device.

Arguments:

    HwDeviceExtension - HBA miniport driver's adapter data storage

Return Value:

    Nothing.


--*/

{
    PHW_DEVICE_EXTENSION deviceExtension = HwDeviceExtension;
    ULONG                numberChannels  = deviceExtension->NumberChannels;
    PIDE_REGISTERS_1 baseIoAddress1;
    PIDE_REGISTERS_2 baseIoAddress2;
    BOOLEAN result = FALSE;
    ULONG i,j;
    UCHAR statusByte;

    DebugPrint((2,"AtapiResetController: Reset IDE\n"));

    //
    // Check and see if we are processing an internal srb
    //
    if (deviceExtension->OriginalSrb) {
        deviceExtension->CurrentSrb = deviceExtension->OriginalSrb;
        deviceExtension->OriginalSrb = NULL;
    }

    //
    // Check if request is in progress.
    //

    if (deviceExtension->CurrentSrb) {

        //
        // Complete outstanding request with SRB_STATUS_BUS_RESET.
        //

        ScsiPortCompleteRequest(deviceExtension,
                                deviceExtension->CurrentSrb->PathId,
                                deviceExtension->CurrentSrb->TargetId,
                                deviceExtension->CurrentSrb->Lun,
                                (ULONG)SRB_STATUS_BUS_RESET);

        //
        // Clear request tracking fields.
        //

        deviceExtension->CurrentSrb = NULL;
        deviceExtension->WordsLeft = 0;
        deviceExtension->DataBuffer = NULL;

        //
        // Indicate ready for next request.
        //

        ScsiPortNotification(NextRequest,
                             deviceExtension,
                             NULL);
    }

    // suppress the interrupt unitl AtapiStartIo()
    if (deviceExtension->IrqSharing)
        ScsiPortWritePortUchar(&deviceExtension->BaseIoAddress1[0]->DmaReg, 0x20);

    //
    // Clear expecting interrupt flag.
    //

    deviceExtension->ExpectingInterrupt = FALSE;
    deviceExtension->RDP = FALSE;

    for (j = 0; j < numberChannels; j++) {

        baseIoAddress1 = deviceExtension->BaseIoAddress1[j];
        baseIoAddress2 = deviceExtension->BaseIoAddress2[j];

        //
        // Do special processing for ATAPI and IDE disk devices.
        //

        for (i = 0; i < 2; i++) {

            //
            // Check if device present.
            //

            if (deviceExtension->DeviceFlags[i + (j * 2)] & DFLAGS_DEVICE_PRESENT) {

                //
                // Check for ATAPI disk.
                //

                if (deviceExtension->DeviceFlags[i + (j * 2)] & DFLAGS_ATAPI_DEVICE) {

                    //
                    // Issue soft reset and issue identify.
                    //

                    GetStatus(baseIoAddress2,statusByte);
                    DebugPrint((1,
                                "AtapiResetController: Status before Atapi reset (%x).\n",
                                statusByte));

                    AtapiSoftReset(baseIoAddress1,baseIoAddress2,i);

                    GetStatus(baseIoAddress2,statusByte);

                    if (statusByte == 0x0) {

                        IssueIdentify(HwDeviceExtension,
                                      i,
                                      j,
                                      IDE_COMMAND_ATAPI_IDENTIFY);
                    } else {

                        DebugPrint((1,
                                   "AtapiResetController: Status after soft reset %x\n",
                                   statusByte));
                    }

                } else {

                    //
                    // Write IDE reset controller bits.
                    //

                    IdeHardReset(baseIoAddress2,result);

                    if (!result) {
                        return FALSE;
                    }
                }
            }
        }
    }

    //
    // Call the HwInitialize routine to setup multi-block.
    //

    AtapiHwInitialize(HwDeviceExtension);

    return TRUE;

} // end AtapiResetController()



ULONG
MapError(
    IN PVOID HwDeviceExtension,
    IN PSCSI_REQUEST_BLOCK Srb
    )

/*++

Routine Description:

    This routine maps ATAPI and IDE errors to specific SRB statuses.

Arguments:

    HwDeviceExtension - HBA miniport driver's adapter data storage
    Srb - IO request packet

Return Value:

    SRB status

--*/

{
    PHW_DEVICE_EXTENSION deviceExtension = HwDeviceExtension;
    PIDE_REGISTERS_1     baseIoAddress1  = deviceExtension->BaseIoAddress1[Srb->TargetId >> 1];
    PIDE_REGISTERS_2     baseIoAddress2  = deviceExtension->BaseIoAddress2[Srb->TargetId >> 1];
    ULONG i;
    UCHAR errorByte;
    UCHAR srbStatus;
    UCHAR scsiStatus;

    //
    // Read the error register.
    //

    errorByte = ScsiPortReadPortUchar((PUCHAR)baseIoAddress1 + 1);
    DebugPrint((1,
               "MapError: Error register is %x\n",
               errorByte));

    if (deviceExtension->DeviceFlags[Srb->TargetId] & DFLAGS_ATAPI_DEVICE) {

        switch (errorByte >> 4) {
        case SCSI_SENSE_NO_SENSE:

            DebugPrint((1,
                       "ATAPI: No sense information\n"));
            scsiStatus = SCSISTAT_CHECK_CONDITION;
            srbStatus = SRB_STATUS_ERROR;
            break;

        case SCSI_SENSE_RECOVERED_ERROR:

            DebugPrint((1,
                       "ATAPI: Recovered error\n"));

            // fix MATSUSHITA SR-8175 bug
            scsiStatus = SCSISTAT_CHECK_CONDITION;
            srbStatus = SRB_STATUS_ERROR;
            break;

        case SCSI_SENSE_NOT_READY:

            DebugPrint((1,
                       "ATAPI: Device not ready\n"));
            scsiStatus = SCSISTAT_CHECK_CONDITION;
            srbStatus = SRB_STATUS_ERROR;
            break;

        case SCSI_SENSE_MEDIUM_ERROR:

            DebugPrint((1,
                       "ATAPI: Media error\n"));
            scsiStatus = SCSISTAT_CHECK_CONDITION;
            srbStatus = SRB_STATUS_ERROR;
            break;

        case SCSI_SENSE_HARDWARE_ERROR:

            DebugPrint((1,
                       "ATAPI: Hardware error\n"));
            scsiStatus = SCSISTAT_CHECK_CONDITION;
            srbStatus = SRB_STATUS_ERROR;
            break;

        case SCSI_SENSE_ILLEGAL_REQUEST:

            DebugPrint((1,
                       "ATAPI: Illegal request\n"));
            scsiStatus = SCSISTAT_CHECK_CONDITION;
            srbStatus = SRB_STATUS_ERROR;
            break;

        case SCSI_SENSE_UNIT_ATTENTION:

            DebugPrint((1,
                       "ATAPI: Unit attention\n"));
            scsiStatus = SCSISTAT_CHECK_CONDITION;
            srbStatus = SRB_STATUS_ERROR;
            break;

        case SCSI_SENSE_DATA_PROTECT:

            DebugPrint((1,
                       "ATAPI: Data protect\n"));
            scsiStatus = SCSISTAT_CHECK_CONDITION;
            srbStatus = SRB_STATUS_ERROR;
            break;

        case SCSI_SENSE_BLANK_CHECK:

            DebugPrint((1,
                       "ATAPI: Blank check\n"));
            scsiStatus = SCSISTAT_CHECK_CONDITION;
            srbStatus = SRB_STATUS_ERROR;
            break;

        case SCSI_SENSE_ABORTED_COMMAND:
            DebugPrint((1,
                        "Atapi: Command Aborted\n"));
            scsiStatus = SCSISTAT_CHECK_CONDITION;
            srbStatus = SRB_STATUS_ERROR;
            break;

        default:

            DebugPrint((1,
                       "ATAPI: Invalid sense information\n"));
            scsiStatus = 0;
            srbStatus = SRB_STATUS_ERROR;
            break;
        }

    } else {

        scsiStatus = 0;

        //
        // Save errorByte,to be used by SCSIOP_REQUEST_SENSE.
        //

        deviceExtension->ReturningMediaStatus = errorByte;

        if (errorByte & IDE_ERROR_MEDIA_CHANGE_REQ) {
            DebugPrint((1,
                       "IDE: Media change\n"));
            scsiStatus = SCSISTAT_CHECK_CONDITION;
            srbStatus = SRB_STATUS_ERROR;

        } else if (errorByte & IDE_ERROR_COMMAND_ABORTED) {
            DebugPrint((1,
                       "IDE: Command abort\n"));
            srbStatus = SRB_STATUS_ABORTED;
            scsiStatus = SCSISTAT_CHECK_CONDITION;

            if (Srb->SenseInfoBuffer) {

                PSENSE_DATA  senseBuffer = (PSENSE_DATA)Srb->SenseInfoBuffer;

                senseBuffer->ErrorCode = 0x70;
                senseBuffer->Valid     = 1;
                senseBuffer->AdditionalSenseLength = 0xb;
                senseBuffer->SenseKey =  SCSI_SENSE_ABORTED_COMMAND;
                senseBuffer->AdditionalSenseCode = 0;
                senseBuffer->AdditionalSenseCodeQualifier = 0;

                srbStatus |= SRB_STATUS_AUTOSENSE_VALID;
            }

            deviceExtension->ErrorCount++;

        } else if (errorByte & IDE_ERROR_END_OF_MEDIA) {

            DebugPrint((1,
                       "IDE: End of media\n"));
            scsiStatus = SCSISTAT_CHECK_CONDITION;
            srbStatus = SRB_STATUS_ERROR;
            if (!(deviceExtension->DeviceFlags[Srb->TargetId] & DFLAGS_MEDIA_STATUS_ENABLED)){
                deviceExtension->ErrorCount++;
            }

        } else if (errorByte & IDE_ERROR_ILLEGAL_LENGTH) {

            DebugPrint((1,
                       "IDE: Illegal length\n"));
            srbStatus = SRB_STATUS_INVALID_REQUEST;

        } else if (errorByte & IDE_ERROR_BAD_BLOCK) {

            DebugPrint((1,
                       "IDE: Bad block\n"));
            srbStatus = SRB_STATUS_ERROR;
            scsiStatus = SCSISTAT_CHECK_CONDITION;
            if (Srb->SenseInfoBuffer) {

                PSENSE_DATA  senseBuffer = (PSENSE_DATA)Srb->SenseInfoBuffer;

                senseBuffer->ErrorCode = 0x70;
                senseBuffer->Valid     = 1;
                senseBuffer->AdditionalSenseLength = 0xb;
                senseBuffer->SenseKey =  SCSI_SENSE_MEDIUM_ERROR;
                senseBuffer->AdditionalSenseCode = 0;
                senseBuffer->AdditionalSenseCodeQualifier = 0;

                srbStatus |= SRB_STATUS_AUTOSENSE_VALID;
            }

        } else if (errorByte & IDE_ERROR_ID_NOT_FOUND) {

            DebugPrint((1,
                       "IDE: Id not found\n"));
            srbStatus = SRB_STATUS_ERROR;
            scsiStatus = SCSISTAT_CHECK_CONDITION;

            if (Srb->SenseInfoBuffer) {

                PSENSE_DATA  senseBuffer = (PSENSE_DATA)Srb->SenseInfoBuffer;

                senseBuffer->ErrorCode = 0x70;
                senseBuffer->Valid     = 1;
                senseBuffer->AdditionalSenseLength = 0xb;
                senseBuffer->SenseKey =  SCSI_SENSE_MEDIUM_ERROR;
                senseBuffer->AdditionalSenseCode = 0;
                senseBuffer->AdditionalSenseCodeQualifier = 0;

                srbStatus |= SRB_STATUS_AUTOSENSE_VALID;
            }

            deviceExtension->ErrorCount++;

        } else if (errorByte & IDE_ERROR_MEDIA_CHANGE) {

            DebugPrint((1,
                       "IDE: Media change\n"));
            scsiStatus = SCSISTAT_CHECK_CONDITION;
            srbStatus = SRB_STATUS_ERROR;

            if (Srb->SenseInfoBuffer) {

                PSENSE_DATA  senseBuffer = (PSENSE_DATA)Srb->SenseInfoBuffer;

                senseBuffer->ErrorCode = 0x70;
                senseBuffer->Valid     = 1;
                senseBuffer->AdditionalSenseLength = 0xb;
                senseBuffer->SenseKey =  SCSI_SENSE_UNIT_ATTENTION;
                senseBuffer->AdditionalSenseCode = SCSI_ADSENSE_MEDIUM_CHANGED;
                senseBuffer->AdditionalSenseCodeQualifier = 0;

                srbStatus |= SRB_STATUS_AUTOSENSE_VALID;
            }

        } else if (errorByte & IDE_ERROR_DATA_ERROR) {

            DebugPrint((1,
                   "IDE: Data error\n"));
            scsiStatus = SCSISTAT_CHECK_CONDITION;
            srbStatus = SRB_STATUS_ERROR;

            if (!(deviceExtension->DeviceFlags[Srb->TargetId] & DFLAGS_MEDIA_STATUS_ENABLED)){
                deviceExtension->ErrorCount++;
            }

            //
            // Build sense buffer
            //

            if (Srb->SenseInfoBuffer) {

                PSENSE_DATA  senseBuffer = (PSENSE_DATA)Srb->SenseInfoBuffer;

                senseBuffer->ErrorCode = 0x70;
                senseBuffer->Valid     = 1;
                senseBuffer->AdditionalSenseLength = 0xb;
                senseBuffer->SenseKey =  SCSI_SENSE_MEDIUM_ERROR;
                senseBuffer->AdditionalSenseCode = 0;
                senseBuffer->AdditionalSenseCodeQualifier = 0;

                srbStatus |= SRB_STATUS_AUTOSENSE_VALID;
            }
        }

        if (deviceExtension->ErrorCount >= MAX_ERRORS) {
            deviceExtension->MaximumBlockXfer[Srb->TargetId] = 0;

            DebugPrint((1,
                        "MapError: Disabling Multi-sector\n"));

            //
            // Log the error.
            //

            ScsiPortLogError( HwDeviceExtension,
                              Srb,
                              Srb->PathId,
                              Srb->TargetId,
                              Srb->Lun,
                              SP_BAD_FW_WARNING,
                              4);
            //
            // Reprogram to not use Multi-sector.
            //

            for (i = 0; i < 4; i++) {
                UCHAR statusByte;

                if (deviceExtension->DeviceFlags[i] & DFLAGS_DEVICE_PRESENT &&
                     !(deviceExtension->DeviceFlags[i] & DFLAGS_ATAPI_DEVICE)) {

                    // disable the interrupt
                    if (deviceExtension->IrqSharing)
                        ScsiPortWritePortUchar(&baseIoAddress1->DmaReg, 0x20);

                    //
                    // Select the device.
                    //

                    ScsiPortWritePortUchar(&baseIoAddress1->DriveSelect,
                                           (UCHAR)(((i & 0x1) << 4) | 0xA0));

                    //
                    // Setup sector count to reflect the # of blocks.
                    //

                    ScsiPortWritePortUchar(&baseIoAddress1->BlockCount,
                                           0);

                    //
                    // Issue the command.
                    //

                    ScsiPortWritePortUchar(&baseIoAddress1->Command,
                                           IDE_COMMAND_SET_MULTIPLE);

                    //
                    // Wait for busy to drop.
                    //

                    WaitOnBaseBusy(baseIoAddress1,statusByte);

                    // enable the interrupt
                    if (deviceExtension->IrqSharing)
                        ScsiPortWritePortUchar(&baseIoAddress1->DmaReg, 0x00);

                    //
                    // Check for errors. Reset the value to 0 (disable MultiBlock) if the
                    // command was aborted.
                    //

                    if (statusByte & IDE_STATUS_ERROR) {

                        //
                        // Read the error register.
                        //

                        errorByte = ScsiPortReadPortUchar((PUCHAR)baseIoAddress1 + 1);

                        DebugPrint((1,
                                    "AtapiHwInitialize: Error setting multiple mode. Status %x, error byte %x\n",
                                    statusByte,
                                    errorByte));
                        //
                        // Adjust the devExt. value, if necessary.
                        //

                        deviceExtension->MaximumBlockXfer[i] = 0;

                    }
                }
            }
        }
    }


    //
    // Set SCSI status to indicate a check condition.
    //

    Srb->ScsiStatus = scsiStatus;

    return srbStatus;

} // end MapError()


BOOLEAN
AtapiHwInitialize(
    IN PVOID HwDeviceExtension
    )

/*++

Routine Description:

Arguments:

    HwDeviceExtension - HBA miniport driver's adapter data storage

Return Value:

    TRUE - if initialization successful.
    FALSE - if initialization unsuccessful.

--*/

{
    PHW_DEVICE_EXTENSION deviceExtension = HwDeviceExtension;
    PIDE_REGISTERS_1     baseIoAddress;
    ULONG i;
    UCHAR statusByte, errorByte;


    for (i = 0; i < 4; i++) {
        if (deviceExtension->DeviceFlags[i] & DFLAGS_DEVICE_PRESENT) {

            if (!(deviceExtension->DeviceFlags[i] & DFLAGS_ATAPI_DEVICE)) {

                //
                // Enable media status notification
                //

                baseIoAddress = deviceExtension->BaseIoAddress1[i >> 1];

                // ATA drive, assume no media status
                IdeMediaStatus(FALSE,HwDeviceExtension,i);

                //
                // If supported, setup Multi-block transfers.
                //
                if (deviceExtension->MaximumBlockXfer[i]) {

                    //
                    // Select the device.
                    //

                    ScsiPortWritePortUchar(&baseIoAddress->DriveSelect,
                                           (UCHAR)(((i & 0x1) << 4) | 0xA0));

                    //
                    // Setup sector count to reflect the # of blocks.
                    //

                    ScsiPortWritePortUchar(&baseIoAddress->BlockCount,
                                           deviceExtension->MaximumBlockXfer[i]);

                    //
                    // Issue the command.
                    //

                    ScsiPortWritePortUchar(&baseIoAddress->Command,
                                           IDE_COMMAND_SET_MULTIPLE);

                    //
                    // Wait for busy to drop.
                    //

                    WaitOnBaseBusy(baseIoAddress,statusByte);

                    //
                    // Check for errors. Reset the value to 0 (disable MultiBlock) if the
                    // command was aborted.
                    //

                    if (statusByte & IDE_STATUS_ERROR) {

                        //
                        // Read the error register.
                        //

                        errorByte = ScsiPortReadPortUchar((PUCHAR)baseIoAddress + 1);

                        DebugPrint((1,
                                    "AtapiHwInitialize: Error setting multiple mode. Status %x, error byte %x\n",
                                    statusByte,
                                    errorByte));
                        //
                        // Adjust the devExt. value, if necessary.
                        //

                        deviceExtension->MaximumBlockXfer[i] = 0;

                    } else {
                        DebugPrint((1,
                                    "AtapiHwInitialize: Using Multiblock on Device %d. Blocks / int - %d\n",
                                    i,
                                    deviceExtension->MaximumBlockXfer[i]));
                    }
                }
            } else if (!(deviceExtension->DeviceFlags[i] & DFLAGS_CHANGER_INITED)){

                ULONG j;
                BOOLEAN isSanyo = FALSE;
                UCHAR vendorId[26];

                //
                // Attempt to identify any special-case devices - psuedo-atapi changers, atapi changers, etc.
                //

                for (j = 0; j < 13; j += 2) {

                    //
                    // Build a buffer based on the identify data.
                    //

                    vendorId[j] = ((PUCHAR)deviceExtension->IdentifyData[i].ModelNumber)[j + 1];
                    vendorId[j+1] = ((PUCHAR)deviceExtension->IdentifyData[i].ModelNumber)[j];
                }

                if (!AtapiStringCmp (vendorId, "CD-ROM  CDR", 11)) {

                    //
                    // Inquiry string for older model had a '-', newer is '_'
                    //

                    if (vendorId[12] == 'C') {

                        //
                        // Torisan changer. Set the bit. This will be used in several places
                        // acting like 1) a multi-lun device and 2) building the 'special' TUR's.
                        //

                        deviceExtension->DeviceFlags[i] |= (DFLAGS_CHANGER_INITED | DFLAGS_SANYO_ATAPI_CHANGER);
                        deviceExtension->DiscsPresent[i] = 3;
                        isSanyo = TRUE;
                    }
                }
            }

            //
            // We need to get our device ready for action before
            // returning from this function
            //
            // According to the atapi spec 2.5 or 2.6, an atapi device
            // clears its status BSY bit when it is ready for atapi commands.
            // However, some devices (Panasonic SQ-TC500N) are still
            // not ready even when the status BSY is clear.  They don't react
            // to atapi commands.
            //
            // Since there is really no other indication that tells us
            // the drive is really ready for action.  We are going to check BSY
            // is clear and then just wait for an arbitrary amount of time!
            //
            if (deviceExtension->DeviceFlags[i] & DFLAGS_ATAPI_DEVICE) {
                PIDE_REGISTERS_1     baseIoAddress1 = deviceExtension->BaseIoAddress1[i >> 1];
                PIDE_REGISTERS_2     baseIoAddress2 = deviceExtension->BaseIoAddress2[i >> 1];
                ULONG waitCount;

                // have to get out of the loop sometime!
                // 10000 * 100us = 1000,000us = 1000ms = 1s
                waitCount = 10000;
                GetStatus(baseIoAddress2, statusByte);
                while ((statusByte & IDE_STATUS_BUSY) && waitCount) {
                    //
                    // Wait for Busy to drop.
                    //
                    ScsiPortStallExecution(100);
                    GetStatus(baseIoAddress2, statusByte);
                    waitCount--;
                }

                // 5000 * 100us = 500,000us = 500ms = 0.5s
                waitCount = 5000;
                do {
                    ScsiPortStallExecution(100);
                } while (waitCount--);
            }
        }
    }

    return TRUE;

} // end AtapiHwInitialize()


VOID
AtapiHwInitializeChanger (
    IN PVOID HwDeviceExtension,
    IN ULONG TargetId,
    IN PMECHANICAL_STATUS_INFORMATION_HEADER MechanismStatus)
{
    PHW_DEVICE_EXTENSION deviceExtension = HwDeviceExtension;

    if (MechanismStatus) {
        deviceExtension->DiscsPresent[TargetId] = MechanismStatus->NumberAvailableSlots;
        if (deviceExtension->DiscsPresent[TargetId] > 1) {
            deviceExtension->DeviceFlags[TargetId] |= DFLAGS_ATAPI_CHANGER;
        }
    }
    return;
}



BOOLEAN
FindDevices(
    IN PVOID HwDeviceExtension,
    IN BOOLEAN AtapiOnly,
    IN ULONG   Channel
    )

/*++

Routine Description:

    This routine is called from AtapiFindController to identify
    devices attached to an IDE controller.

Arguments:

    HwDeviceExtension - HBA miniport driver's adapter data storage
    AtapiOnly - Indicates that routine should return TRUE only if
        an ATAPI device is attached to the controller.

Return Value:

    TRUE - True if devices found.

--*/

{
    PHW_DEVICE_EXTENSION deviceExtension = HwDeviceExtension;
    PIDE_REGISTERS_1     baseIoAddress1 = deviceExtension->BaseIoAddress1[Channel];
    PIDE_REGISTERS_2     baseIoAddress2 = deviceExtension->BaseIoAddress2[Channel];
    BOOLEAN              deviceResponded = FALSE,
                         skipSetParameters = FALSE;
    ULONG                waitCount = 10000;
    ULONG                deviceNumber;
    ULONG                i;
    UCHAR                signatureLow,
                         signatureHigh;
    UCHAR                statusByte;
    UCHAR                NumDrive = 0; // default

    //
    // Clear expecting interrupt flag and current SRB field.
    //

    deviceExtension->ExpectingInterrupt = FALSE;
    deviceExtension->CurrentSrb = NULL;

    //
    // Search for devices.
    //

    for (deviceNumber = 0; deviceNumber < 2; deviceNumber++) {

        //
        // Select the device.
        //

        ScsiPortWritePortUchar(&baseIoAddress1->DriveSelect,
                               (UCHAR)((deviceNumber << 4) | 0xA0));

        //
        // Check here for some SCSI adapters that incorporate IDE emulation.
        //

        GetStatus(baseIoAddress2, statusByte);
        if (statusByte == 0xFF) {
            continue;
        }

        // wait device become ready (not busy)

        DebugPrint((1,
                    "FindDevices: Status %x first read on device %d\n",
                    statusByte, deviceNumber));

        if ((deviceNumber == 0) && (statusByte == 0x80)) {

            WaitOnBusy(baseIoAddress2,statusByte);
        }

#if 1   // not neccessary to do soft reset before read signature
        AtapiSoftReset(baseIoAddress1,baseIoAddress2,deviceNumber);
        WaitOnBusy(baseIoAddress2,statusByte);
#endif

        signatureLow = ScsiPortReadPortUchar(&baseIoAddress1->CylinderLow);
        signatureHigh = ScsiPortReadPortUchar(&baseIoAddress1->CylinderHigh);

        DebugPrint((1,
                    "FindDevices: Signature read on device %d is %x, %x\n",
                    deviceNumber,
                    signatureLow,
                    signatureHigh));

        // check slave drive signature in beginning
        if ((deviceNumber == 0) && (NumDrive == 0)) {

            ScsiPortWritePortUchar(&baseIoAddress1->DriveSelect, 0xB0);

            GetStatus(baseIoAddress2, statusByte);

            if (statusByte != 0xFF) {

#ifdef  DBG
             // _asm int 3;
#endif
                if (ScsiPortReadPortUchar(&baseIoAddress1->CylinderLow) == 0x14 &&
                    ScsiPortReadPortUchar(&baseIoAddress1->CylinderHigh) == 0xEB) {

                    DebugPrint((1,
                                "FindDevices: Signature read from slave is 0x14EB\n"));

                    NumDrive = 2;
                }
            }

            ScsiPortWritePortUchar(&baseIoAddress1->DriveSelect, 0xA0);
        }

        if (signatureLow == 0x14 && signatureHigh == 0xEB) {

            //
            // ATAPI signature found.
            // Issue the ATAPI identify command if this
            // is not for the crash dump utility.
            //

atapiIssueId:

            if (!deviceExtension->DriverMustPoll) {

                //
                // Issue ATAPI packet identify command.
                //

                if (IssueIdentify(HwDeviceExtension,
                                  deviceNumber,
                                  Channel,
                                  IDE_COMMAND_ATAPI_IDENTIFY)) {

                    //
                    // Indicate ATAPI device.
                    //

                    DebugPrint((1,
                               "FindDevices: Device %x is ATAPI\n",
                               deviceNumber));

                    deviceExtension->DeviceFlags[deviceNumber + (Channel * 2)] |= DFLAGS_ATAPI_DEVICE;
                    deviceExtension->DeviceFlags[deviceNumber + (Channel * 2)] |= DFLAGS_DEVICE_PRESENT;

                    deviceResponded = TRUE;

                    GetStatus(baseIoAddress2, statusByte);
                    if (statusByte & IDE_STATUS_ERROR) {
                        AtapiSoftReset(baseIoAddress1, baseIoAddress2, deviceNumber);
                    }


                } else {

                    //
                    // Indicate no working device.
                    //

                    DebugPrint((1,
                               "FindDevices: Device %x not responding\n",
                               deviceNumber));

                    deviceExtension->DeviceFlags[deviceNumber + (Channel * 2)] &= ~DFLAGS_DEVICE_PRESENT;
                }

            }

        } else if ((deviceNumber == 0) || (NumDrive == 2)) {

            // if master drive signature is not ATAPI, issue IDE identify first,
            //    if not IDE, reset then it, then check signature again
            // if make sure there is a slave drive (NumDrive = 2),
            //    reset it, then check signature again

            //
            // Issue IDE Identify. If an Atapi device is actually present, the signature
            // will be asserted, and the drive will be recognized as such.
            //

            if ((deviceNumber == 0) // only master drive can be IDE

                && IssueIdentify(HwDeviceExtension,
                                 deviceNumber,
                                 Channel,
                                 IDE_COMMAND_IDENTIFY)) {

                //
                // IDE drive found.
                //

                DebugPrint((1,
                           "FindDevices: Device %x is IDE\n",
                           deviceNumber));

                deviceExtension->DeviceFlags[deviceNumber + (Channel * 2)] |= DFLAGS_DEVICE_PRESENT;

                if (!AtapiOnly) {
                    deviceResponded = TRUE;
                }

                //
                // Indicate IDE - not ATAPI device.
                //

                deviceExtension->DeviceFlags[deviceNumber + (Channel * 2)] &= ~DFLAGS_ATAPI_DEVICE;

            } else {

                //
                // Look to see if an Atapi device is present.
                //

                AtapiSoftReset(baseIoAddress1,baseIoAddress2,deviceNumber);

                WaitOnBusy(baseIoAddress2,statusByte);

                signatureLow = ScsiPortReadPortUchar(&baseIoAddress1->CylinderLow);
                signatureHigh = ScsiPortReadPortUchar(&baseIoAddress1->CylinderHigh);

                if (signatureLow == 0x14 && signatureHigh == 0xEB) {

                    DebugPrint((1,
                                "FindDevices: Signature read 0x14EB after soft reset.\n"));

                    goto atapiIssueId;
                }
            }
        }

        if (NumDrive == 1)
            break;
    }

    for (i = 0; i < 2; i++) {
        if ((deviceExtension->DeviceFlags[i + (Channel * 2)] & DFLAGS_DEVICE_PRESENT) &&
            (!(deviceExtension->DeviceFlags[i + (Channel * 2)] & DFLAGS_ATAPI_DEVICE)) && deviceResponded) {

            if (deviceExtension->DeviceFlags[deviceNumber + (Channel * 2)] & DFLAGS_REMOVABLE_DRIVE) {

                //
                // Pick up ALL IDE removable drives that conform to Yosemite V0.2...
                //

                AtapiOnly = FALSE;
            }


            //
            // Indicate that a device was found.
            //

            if (!AtapiOnly) {
                deviceResponded = TRUE;
            }
        }
    }

    //
    // Make sure master device is selected on exit.
    //

    ScsiPortWritePortUchar(&baseIoAddress1->DriveSelect, 0xA0);

    //
    // Reset the controller. This is a feeble attempt to leave the ESDI
    // controllers in a state that ATDISK driver will recognize them.
    // The problem in ATDISK has to do with timings as it is not reproducible
    // in debug. The reset should restore the controller to its poweron state
    // and give the system enough time to settle.
    //

    if (!deviceResponded) {

        ScsiPortWritePortUchar(&baseIoAddress2->AlternateStatus,IDE_DC_RESET_CONTROLLER );
        ScsiPortStallExecution(50 * 1000);
        ScsiPortWritePortUchar(&baseIoAddress2->AlternateStatus,IDE_DC_REENABLE_CONTROLLER);
    }

    return deviceResponded;

} // end FindDevices()



ULONG
AtapiFindController(
    IN PVOID HwDeviceExtension,
    IN PVOID Context,
    IN PVOID BusInformation,
    IN PCHAR ArgumentString,
    IN OUT PPORT_CONFIGURATION_INFORMATION ConfigInfo,
    OUT PBOOLEAN Again
    )
/*++

Routine Description:

    This function is called by the OS-specific port driver after
    the necessary storage has been allocated, to gather information
    about the adapter's configuration.

Arguments:

    HwDeviceExtension - HBA miniport driver's adapter data storage
    Context - Address of adapter count
    ArgumentString - Used to determine whether driver is client of ntldr or crash dump utility.
    ConfigInfo - Configuration information structure describing HBA
    Again - Indicates search for adapters to continue

Return Value:

    ULONG

--*/

{
    PHW_DEVICE_EXTENSION deviceExtension = HwDeviceExtension;
    PUCHAR               ioSpace, ioSpace2;
    ULONG                i,j;
    ULONG                irq;
    ULONG                portBase;
    ULONG                retryCount;
    UCHAR                statusByte;
    BOOLEAN              pwr_feature;

    if (!deviceExtension) {
        return SP_RETURN_ERROR;
    }

    *Again = FALSE;

    //
    // Check to see if this is a special configuration environment.
    //

    portBase = ScsiPortConvertPhysicalAddressToUlong((*ConfigInfo->AccessRanges)[0].RangeStart);

    if (!portBase) {
        return(SP_RETURN_NOT_FOUND);
    }

    //
    // Get the system physical address for this IO range.
    //

    ioSpace =  ScsiPortGetDeviceBase(HwDeviceExtension,
                                     ConfigInfo->AdapterInterfaceType,
                                     ConfigInfo->SystemIoBusNumber,
                                     (*ConfigInfo->AccessRanges)[0].RangeStart,
                                     ((*ConfigInfo->AccessRanges)[0].RangeLength <= 8 ? 8 : 16),
                                     (BOOLEAN) !((*ConfigInfo->AccessRanges)[0].RangeInMemory));

    //
    // Check if ioSpace accessible.
    //

    if (!ioSpace) {
        return(SP_RETURN_NOT_FOUND);
    }

    // set power feature if CHARGE parameter is set to 1

    pwr_feature = FALSE;

    if (ArgumentString != NULL) {

        pwr_feature = (AtapiParseArgumentString(ArgumentString, "charge") == 1);
    }

    if (pwr_feature) {

        for (i=0; i<50000; i++) {

            if ((ScsiPortReadPortUchar(&((PIDE_REGISTERS_1)ioSpace)->DmaReg) & 0x08)) {

                break;

            } else {

                ScsiPortStallExecution(1000);
            }
        }
        ScsiPortStallExecution(3000*1000);

        DebugPrint((1, "Container charged completed.\n"));

#ifdef  DBG
     // _asm int 3;
#endif
    }

    retryCount = 4;

    for (i = 0; i < 4; i++) {

        //
        // Zero device fields to ensure that if earlier devices were found,
        // but not claimed, the fields are cleared.
        //

        deviceExtension->DeviceFlags[i] &= ~(DFLAGS_ATAPI_DEVICE | DFLAGS_DEVICE_PRESENT | DFLAGS_TAPE_DEVICE);
    }

//retryIdentifier:

    //
    // Select master.
    //

    ScsiPortWritePortUchar(&((PIDE_REGISTERS_1)ioSpace)->DriveSelect, 0xA0);

    //
    // Check if card at this address.
    //

    ScsiPortWritePortUchar(&((PIDE_REGISTERS_1)ioSpace)->BlockCount, 0xAA);

    //
    // Check if indentifier can be read back.
    //

    if ((statusByte = ScsiPortReadPortUchar(&((PIDE_REGISTERS_1)ioSpace)->BlockCount)) != 0xAA) {

        DebugPrint((1,
                    "AtapiFindController: Identifier read back from Master (%x)\n",
                    statusByte));

        // if master drive not detected, check slave
        // ATA drive may report statusByte 0x80 when spin up

        if (statusByte != 0x01 && statusByte != 0x80) {

            //
            // Select slave.
            //

            ScsiPortWritePortUchar(&((PIDE_REGISTERS_1)ioSpace)->DriveSelect, 0xB0);

            //
            // See if slave is present.
            //

            ScsiPortWritePortUchar(&((PIDE_REGISTERS_1)ioSpace)->BlockCount, 0xAA);

            if ((statusByte = ScsiPortReadPortUchar(&((PIDE_REGISTERS_1)ioSpace)->BlockCount)) != 0xAA) {

                DebugPrint((1,
                            "AtapiFindController: Identifier read back from Slave (%x)\n",
                            statusByte));

                // if slave drive not detected, abort

                if (statusByte != 0x01 && statusByte != 0x80) {

                    //
                    //
                    // No controller at this base address.
                    //

                    ScsiPortFreeDeviceBase(HwDeviceExtension,
                                           ioSpace);

                    return(SP_RETURN_NOT_FOUND);
                }
            }
        }
    }

    //
    // Enable DWordIO by default.  Then check for an PIO parameter.
    // if PIO set to 16, disable DWordIO
    //

    deviceExtension->DWordIO = TRUE;

    if (ArgumentString != NULL) {

        ULONG pio = AtapiParseArgumentString(ArgumentString, "pio");

        if (pio == 16) {

            deviceExtension->DWordIO = FALSE;
        }
    }

    //
    // Record base IO address.
    //

    deviceExtension->BaseIoAddress1[0] = (PIDE_REGISTERS_1)(ioSpace);

    //
    // Get the system physical address for the second IO range.
    //

    // if not power feature and not 32-bit PIO, then check if standard IDE

    if (!pwr_feature && !deviceExtension->DWordIO &&
        ((*ConfigInfo->AccessRanges)[0].RangeLength <= 8)) {

        // stardard IDE has two I/O port ranges

        ioSpace2 = ScsiPortGetDeviceBase(HwDeviceExtension,
                                         ConfigInfo->AdapterInterfaceType,
                                         ConfigInfo->SystemIoBusNumber,
                                         ScsiPortConvertUlongToPhysicalAddress(portBase + 0x206),
                                         1,
                                         TRUE);

        if (!ioSpace2) {

            ScsiPortFreeDeviceBase(HwDeviceExtension,
                                   ioSpace);

            return(SP_RETURN_NOT_FOUND);
        }

        deviceExtension->BaseIoAddress2[0] = (PIDE_REGISTERS_2)(ioSpace2);

        (*ConfigInfo->AccessRanges)[0].RangeLength = 8;
        (*ConfigInfo->AccessRanges)[1].RangeLength = 2;

        // standard IDE dose not support irq sharing
        deviceExtension->IrqSharing = FALSE;

    } else {

        (*ConfigInfo->AccessRanges)[0].RangeLength = 16;

        deviceExtension->BaseIoAddress2[0] = (PIDE_REGISTERS_2)((PUCHAR)ioSpace + 0x00e);

        deviceExtension->IrqSharing = TRUE; // support irq sharing
    }

    deviceExtension->NumberChannels = 1;

    ConfigInfo->NumberOfBuses = 1;
    ConfigInfo->MaximumNumberOfTargets = 2;

    //
    // Indicate maximum transfer length is 64k.
    //

    ConfigInfo->MaximumTransferLength = 0x10000;

    DebugPrint((1,
               "AtapiFindController: Found IDE at %x\n",
               deviceExtension->BaseIoAddress1[0]));


    deviceExtension->DriverMustPoll = FALSE;

    //
    // Save the Interrupe Mode for later use
    //
    deviceExtension->InterruptMode = ConfigInfo->InterruptMode;

    // suppress the interrupt unitl AtapiStartIo()
    if (deviceExtension->IrqSharing)
        ScsiPortWritePortUchar(&deviceExtension->BaseIoAddress1[0]->DmaReg, 0x20);

    //
    // Search for devices on this controller.
    //

    if (FindDevices(HwDeviceExtension,
                    FALSE,
                    0)) {

        // if standard secondary IDE, claim it

        if (portBase == 0x170) {
            ConfigInfo->AtdiskSecondaryClaimed = TRUE;
            deviceExtension->PrimaryAddress = FALSE;
        }

        return(SP_RETURN_FOUND);
    }

    return(SP_RETURN_NOT_FOUND);

} // end AtapiFindController()





ULONG
Atapi2Scsi(
    IN PSCSI_REQUEST_BLOCK Srb,
    IN char *DataBuffer,
    IN ULONG ByteCount
    )
{
    ULONG bytesAdjust = 0;
    if (Srb->Cdb[0] == ATAPI_MODE_SENSE) {

        PMODE_PARAMETER_HEADER_10 header_10 = (PMODE_PARAMETER_HEADER_10)DataBuffer;
        PMODE_PARAMETER_HEADER header = (PMODE_PARAMETER_HEADER)DataBuffer;

        header->ModeDataLength = header_10->ModeDataLengthLsb;
        header->MediumType = header_10->MediumType;

        //
        // ATAPI Mode Parameter Header doesn't have these fields.
        //

        header->DeviceSpecificParameter = header_10->Reserved[0];
        header->BlockDescriptorLength = header_10->Reserved[1];

        ByteCount -= sizeof(MODE_PARAMETER_HEADER_10);
        if (ByteCount > 0)
            ScsiPortMoveMemory(DataBuffer+sizeof(MODE_PARAMETER_HEADER),
                               DataBuffer+sizeof(MODE_PARAMETER_HEADER_10),
                               ByteCount);

        //
        // Change ATAPI_MODE_SENSE opcode back to SCSIOP_MODE_SENSE
        // so that we don't convert again.
        //

        Srb->Cdb[0] = SCSIOP_MODE_SENSE;

        bytesAdjust = sizeof(MODE_PARAMETER_HEADER_10) -
                      sizeof(MODE_PARAMETER_HEADER);


    }

    //
    // Convert to words.
    //

    return bytesAdjust >> 1;
}


VOID
AtapiCallBack(
    IN PVOID HwDeviceExtension
    )
{
    PHW_DEVICE_EXTENSION deviceExtension = HwDeviceExtension;
    PSCSI_REQUEST_BLOCK  srb = deviceExtension->CurrentSrb;
    PATAPI_REGISTERS_2   baseIoAddress2;
    UCHAR statusByte;

    //
    // If the last command was DSC restrictive, see if it's set. If so, the device is
    // ready for a new request. Otherwise, reset the timer and come back to here later.
    //

    if (srb && (!(deviceExtension->ExpectingInterrupt))) {
#if DBG
        if (!IS_RDP((srb->Cdb[0]))) {
            DebugPrint((1,
                        "AtapiCallBack: Invalid CDB marked as RDP - %x\n",
                        srb->Cdb[0]));
        }
#endif

        baseIoAddress2 = (PATAPI_REGISTERS_2)deviceExtension->BaseIoAddress2[srb->TargetId >> 1];
        if (deviceExtension->RDP) {
            GetStatus(baseIoAddress2, statusByte);
            if (statusByte & IDE_STATUS_DSC) {

                ScsiPortNotification(RequestComplete,
                                     deviceExtension,
                                     srb);

                //
                // Clear current SRB.
                //

                deviceExtension->CurrentSrb = NULL;
                deviceExtension->RDP = FALSE;

                //
                // Ask for next request.
                //

                ScsiPortNotification(NextRequest,
                                     deviceExtension,
                                     NULL);


                return;

            } else {

                DebugPrint((3,
                            "AtapiCallBack: Requesting another timer for Op %x\n",
                            deviceExtension->CurrentSrb->Cdb[0]));

                ScsiPortNotification(RequestTimerCall,
                                     HwDeviceExtension,
                                     AtapiCallBack,
                                     1000);
                return;
            }
        }
    }

    DebugPrint((2,
                "AtapiCallBack: Calling ISR directly due to BUSY\n"));
    AtapiInterrupt(HwDeviceExtension);
}


BOOLEAN
AtapiInterrupt(
    IN PVOID HwDeviceExtension
    )

/*++

Routine Description:

    This is the interrupt service routine for ATAPI IDE miniport driver.

Arguments:

    HwDeviceExtension - HBA miniport driver's adapter data storage

Return Value:

    TRUE if expecting an interrupt.

--*/

{
    PHW_DEVICE_EXTENSION deviceExtension = HwDeviceExtension;
    PSCSI_REQUEST_BLOCK srb              = deviceExtension->CurrentSrb;
    PATAPI_REGISTERS_1 baseIoAddress1;
    PATAPI_REGISTERS_2 baseIoAddress2;
    ULONG wordCount = 0, wordsThisInterrupt = 256;
    ULONG status;
    ULONG i;
    UCHAR statusByte,interruptReason;
    BOOLEAN commandComplete = FALSE;
    BOOLEAN atapiDev = FALSE;

    // check if interrupt is ours
    if (deviceExtension->IrqSharing) {

        if (!(ScsiPortReadPortUchar(&deviceExtension->BaseIoAddress1[0]->DmaReg) & 0x20)) {

            DebugPrint((2,
                        "AtapiInterrupt: Unexpected interrupt (irq sharing).\n"));

            return FALSE;
        }
    }

    if (srb) {
        baseIoAddress1 =    (PATAPI_REGISTERS_1)deviceExtension->BaseIoAddress1[srb->TargetId >> 1];
        baseIoAddress2 =    (PATAPI_REGISTERS_2)deviceExtension->BaseIoAddress2[srb->TargetId >> 1];
    } else {
        DebugPrint((2,
                    "AtapiInterrupt: CurrentSrb is NULL\n"));
        //
        // We can only support one ATAPI IDE master on Carolina, so find
        // the base address that is non NULL and clear its interrupt before
        // returning.
        //

#ifdef _PPC_

        if ((PATAPI_REGISTERS_1)deviceExtension->BaseIoAddress1[0] != NULL) {
           baseIoAddress1 = (PATAPI_REGISTERS_1)deviceExtension->BaseIoAddress1[0];
        } else {
           baseIoAddress1 = (PATAPI_REGISTERS_1)deviceExtension->BaseIoAddress1[1];
        }

        GetBaseStatus(baseIoAddress1, statusByte);
#else

        if (deviceExtension->InterruptMode == LevelSensitive) {
            if (deviceExtension->BaseIoAddress1[0] != NULL) {
               baseIoAddress1 = (PATAPI_REGISTERS_1)deviceExtension->BaseIoAddress1[0];
               GetBaseStatus(baseIoAddress1, statusByte);
            }
            if (deviceExtension->BaseIoAddress1[1] != NULL) {
               baseIoAddress1 = (PATAPI_REGISTERS_1)deviceExtension->BaseIoAddress1[1];
               GetBaseStatus(baseIoAddress1, statusByte);
            }
        }
#endif
        return FALSE;
    }

    if (!(deviceExtension->ExpectingInterrupt)) {

        DebugPrint((3,
                    "AtapiInterrupt: Unexpected interrupt.\n"));
        return FALSE;
    }

    //
    // Clear interrupt by reading status.
    //

    GetBaseStatus(baseIoAddress1, statusByte);

    DebugPrint((3,
                "AtapiInterrupt: Entered with status (%x)\n",
                statusByte));


    if (statusByte & IDE_STATUS_BUSY) {
        if (deviceExtension->DriverMustPoll) {

            //
            // Crashdump is polling and we got caught with busy asserted.
            // Just go away, and we will be polled again shortly.
            //

            DebugPrint((3,
                        "AtapiInterrupt: Hit BUSY while polling during crashdump.\n"));

            return TRUE;
        }

        //
        // Ensure BUSY is non-asserted.
        //

        for (i = 0; i < 10; i++) {

            GetBaseStatus(baseIoAddress1, statusByte);
            if (!(statusByte & IDE_STATUS_BUSY)) {
                break;
            }
            ScsiPortStallExecution(5000);
        }

        if (i == 10) {

            DebugPrint((2,
                        "AtapiInterrupt: BUSY on entry. Status %x, Base IO %x\n",
                        statusByte,
                        baseIoAddress1));

            ScsiPortNotification(RequestTimerCall,
                                 HwDeviceExtension,
                                 AtapiCallBack,
                                 500);
            return TRUE;
        }
    }


    //
    // Check for error conditions.
    //

    if (statusByte & IDE_STATUS_ERROR) {

        if (srb->Cdb[0] != SCSIOP_REQUEST_SENSE) {

            //
            // Fail this request.
            //

            status = SRB_STATUS_ERROR;
            goto CompleteRequest;
        }
    }

    //
    // check reason for this interrupt.
    //

    if (deviceExtension->DeviceFlags[srb->TargetId] & DFLAGS_ATAPI_DEVICE) {

        interruptReason = (ScsiPortReadPortUchar(&baseIoAddress1->InterruptReason) & 0x3);
        atapiDev = TRUE;
        wordsThisInterrupt = 256;

    } else {

        if (statusByte & IDE_STATUS_DRQ) {

            if (deviceExtension->MaximumBlockXfer[srb->TargetId]) {
                wordsThisInterrupt = 256 * deviceExtension->MaximumBlockXfer[srb->TargetId];

            }

            if (srb->SrbFlags & SRB_FLAGS_DATA_IN) {

                interruptReason =  0x2;

            } else if (srb->SrbFlags & SRB_FLAGS_DATA_OUT) {
                interruptReason = 0x0;

            } else {
                status = SRB_STATUS_ERROR;
                goto CompleteRequest;
            }

        } else if (statusByte & IDE_STATUS_BUSY) {

            return FALSE;

        } else {

            if (deviceExtension->WordsLeft) {

                ULONG k;

                //
                // Funky behaviour seen with PCI IDE (not all, just one).
                // The ISR hits with DRQ low, but comes up later.
                //

                for (k = 0; k < 5000; k++) {
                    GetStatus(baseIoAddress2,statusByte);
                    if (!(statusByte & IDE_STATUS_DRQ)) {
                        ScsiPortStallExecution(100);
                    } else {
                        break;
                    }
                }

                if (k == 5000) {

                    //
                    // reset the controller.
                    //

                    DebugPrint((1,
                                "AtapiInterrupt: Resetting due to DRQ not up. Status %x, Base IO %x\n",
                                statusByte,
                                baseIoAddress1));

                    AtapiResetController(HwDeviceExtension,srb->PathId);
                    return TRUE;
                } else {

                    interruptReason = (srb->SrbFlags & SRB_FLAGS_DATA_IN) ? 0x2 : 0x0;
                }

            } else {

                //
                // Command complete - verify, write, or the SMART enable/disable.
                //
                // Also get_media_status

                interruptReason = 0x3;
            }
        }
    }

    if (interruptReason == 0x1 && (statusByte & IDE_STATUS_DRQ)) {

        //
        // Write the packet.
        //

        DebugPrint((2,
                    "AtapiInterrupt: Writing Atapi packet.\n"));

        //
        // Send CDB to device.
        //

        WriteBuffer(baseIoAddress1,
                    (PUSHORT)srb->Cdb,
                    6);

        return TRUE;

    } else if (interruptReason == 0x0 && (statusByte & IDE_STATUS_DRQ)) {

        //
        // Write the data.
        //

        if (deviceExtension->DeviceFlags[srb->TargetId] & DFLAGS_ATAPI_DEVICE) {

            //
            // Pick up bytes to transfer and convert to words.
            //

            wordCount =
                ScsiPortReadPortUchar(&baseIoAddress1->ByteCountLow);

            wordCount |=
                ScsiPortReadPortUchar(&baseIoAddress1->ByteCountHigh) << 8;

            //
            // Covert bytes to words.
            //

            wordCount >>= 1;

            if (wordCount != deviceExtension->WordsLeft) {
                DebugPrint((3,
                           "AtapiInterrupt: %d words requested; %d words xferred\n",
                           deviceExtension->WordsLeft,
                           wordCount));
            }

            //
            // Verify this makes sense.
            //

            if (wordCount > deviceExtension->WordsLeft) {
                wordCount = deviceExtension->WordsLeft;
            }

        } else {

            //
            // IDE path. Check if words left is at least 256.
            //

            if (deviceExtension->WordsLeft < wordsThisInterrupt) {

               //
               // Transfer only words requested.
               //

               wordCount = deviceExtension->WordsLeft;

            } else {

               //
               // Transfer next block.
               //

               wordCount = wordsThisInterrupt;
            }
        }

        //
        // Ensure that this is a write command.
        //

        if (srb->SrbFlags & SRB_FLAGS_DATA_OUT) {

           DebugPrint((3,
                      "AtapiInterrupt: Write interrupt\n"));

           WaitOnBusy(baseIoAddress2,statusByte);

           if (deviceExtension->DWordIO && wordCount >= 256 && (wordCount & 1) == 0) {

               WriteBuffer32(baseIoAddress1,
                             (PULONG)deviceExtension->DataBuffer,
                             wordCount >> 1);
           } else {

               WriteBuffer(baseIoAddress1,
                           deviceExtension->DataBuffer,
                           wordCount);
           }

        } else {

            DebugPrint((1,
                        "AtapiInterrupt: Int reason %x, but srb is for a write %x.\n",
                        interruptReason,
                        srb));

            //
            // Fail this request.
            //

            status = SRB_STATUS_ERROR;
            goto CompleteRequest;
        }


        //
        // Advance data buffer pointer and bytes left.
        //

        deviceExtension->DataBuffer += wordCount;
        deviceExtension->WordsLeft -= wordCount;

        return TRUE;

    } else if (interruptReason == 0x2 && (statusByte & IDE_STATUS_DRQ)) {


        if (deviceExtension->DeviceFlags[srb->TargetId] & DFLAGS_ATAPI_DEVICE) {

            //
            // Pick up bytes to transfer and convert to words.
            //

            wordCount =
                ScsiPortReadPortUchar(&baseIoAddress1->ByteCountLow);

            wordCount |=
                ScsiPortReadPortUchar(&baseIoAddress1->ByteCountHigh) << 8;

            //
            // Covert bytes to words.
            //

            wordCount >>= 1;

            if (wordCount != deviceExtension->WordsLeft) {
                DebugPrint((3,
                           "AtapiInterrupt: %d words requested; %d words xferred\n",
                           deviceExtension->WordsLeft,
                           wordCount));
            }

            //
            // Verify this makes sense.
            //

            if (wordCount > deviceExtension->WordsLeft) {
                wordCount = deviceExtension->WordsLeft;
            }

        } else {

            //
            // Check if words left is at least 256.
            //

            if (deviceExtension->WordsLeft < wordsThisInterrupt) {

               //
               // Transfer only words requested.
               //

               wordCount = deviceExtension->WordsLeft;

            } else {

               //
               // Transfer next block.
               //

               wordCount = wordsThisInterrupt;
            }
        }

        //
        // Ensure that this is a read command.
        //

        if (srb->SrbFlags & SRB_FLAGS_DATA_IN) {

           DebugPrint((3,
                      "AtapiInterrupt: Read interrupt\n"));

           WaitOnBusy(baseIoAddress2,statusByte);

           if (deviceExtension->DWordIO && wordCount >= 256 && (wordCount & 1) == 0) {

               ReadBuffer32(baseIoAddress1,
                            (PULONG)deviceExtension->DataBuffer,
                            wordCount >> 1);
           } else {

               ReadBuffer(baseIoAddress1,
                         deviceExtension->DataBuffer,
                         wordCount);
           }

        } else {

            DebugPrint((1,
                        "AtapiInterrupt: Int reason %x, but srb is for a read %x.\n",
                        interruptReason,
                        srb));

            //
            // Fail this request.
            //

            status = SRB_STATUS_ERROR;
            goto CompleteRequest;
        }

        //
        // Translate ATAPI data back to SCSI data if needed
        //

        if (srb->Cdb[0] == ATAPI_MODE_SENSE &&
            deviceExtension->DeviceFlags[srb->TargetId] & DFLAGS_ATAPI_DEVICE) {

            //
            //convert and adjust the wordCount
            //

            wordCount -= Atapi2Scsi(srb, (char *)deviceExtension->DataBuffer,
                                     wordCount << 1);
        }
        //
        // Advance data buffer pointer and bytes left.
        //

        deviceExtension->DataBuffer += wordCount;
        deviceExtension->WordsLeft -= wordCount;

        //
        // Check for read command complete.
        //

        if (deviceExtension->WordsLeft == 0) {

            if (deviceExtension->DeviceFlags[srb->TargetId] & DFLAGS_ATAPI_DEVICE) {

                //
                // Work around to make many atapi devices return correct sector size
                // of 2048. Also certain devices will have sector count == 0x00, check
                // for that also.
                //

                if ((srb->Cdb[0] == 0x25) &&
                    ((deviceExtension->IdentifyData[srb->TargetId].GeneralConfiguration >> 8) & 0x1f) == 0x05) {

                    deviceExtension->DataBuffer -= wordCount;
                    if (deviceExtension->DataBuffer[0] == 0x00) {

                        *((ULONG *) &(deviceExtension->DataBuffer[0])) = 0xFFFFFF7F;

                    }

                    // default sector size set to 2048 (0x800) for non-removable drive
                    if (!(deviceExtension->DeviceFlags[srb->TargetId] & DFLAGS_REMOVABLE_DRIVE))

                        *((ULONG *) &(deviceExtension->DataBuffer[2])) = 0x00080000;

                    deviceExtension->DataBuffer += wordCount;
                }
            } else {

                //
                // Completion for IDE drives.
                //


                if (deviceExtension->WordsLeft) {

                    status = SRB_STATUS_DATA_OVERRUN;

                } else {

                    status = SRB_STATUS_SUCCESS;

                }

                goto CompleteRequest;

            }
        }

        return TRUE;

    } else if (interruptReason == 0x3  && !(statusByte & IDE_STATUS_DRQ)) {

        //
        // Command complete.
        //

        if (deviceExtension->WordsLeft) {

            status = SRB_STATUS_DATA_OVERRUN;

        } else {

            status = SRB_STATUS_SUCCESS;

        }

CompleteRequest:

        //
        // Check and see if we are processing our secret (mechanism status/request sense) srb
        //
        if (deviceExtension->OriginalSrb) {

            ULONG srbStatus;

            if (srb->Cdb[0] == SCSIOP_MECHANISM_STATUS) {

                if (status == SRB_STATUS_SUCCESS) {
                    // Bingo!!
                    AtapiHwInitializeChanger (HwDeviceExtension,
                                              srb->TargetId,
                                              (PMECHANICAL_STATUS_INFORMATION_HEADER) srb->DataBuffer);

                    // Get ready to issue the original srb
                    srb = deviceExtension->CurrentSrb = deviceExtension->OriginalSrb;
                    deviceExtension->OriginalSrb = NULL;

                } else {
                    // failed!  Get the sense key and maybe try again
                    srb = deviceExtension->CurrentSrb = BuildRequestSenseSrb (
                                                          HwDeviceExtension,
                                                          deviceExtension->OriginalSrb->PathId,
                                                          deviceExtension->OriginalSrb->TargetId);
                }

                srbStatus = AtapiSendCommand(HwDeviceExtension, deviceExtension->CurrentSrb);
                if (srbStatus == SRB_STATUS_PENDING) {
                    return TRUE;
                }

            } else { // srb->Cdb[0] == SCSIOP_REQUEST_SENSE)

                PSENSE_DATA senseData = (PSENSE_DATA) srb->DataBuffer;

                if (status == SRB_STATUS_DATA_OVERRUN) {
                    // Check to see if we at least get mininum number of bytes
                    if ((srb->DataTransferLength - deviceExtension->WordsLeft) >
                        (offsetof (SENSE_DATA, AdditionalSenseLength) + sizeof(senseData->AdditionalSenseLength))) {
                        status = SRB_STATUS_SUCCESS;
                    }
                }

                if (status == SRB_STATUS_SUCCESS) {
                    if ((senseData->SenseKey != SCSI_SENSE_ILLEGAL_REQUEST) &&
                        deviceExtension->MechStatusRetryCount) {

                        // The sense key doesn't say the last request is illegal, so try again
                        deviceExtension->MechStatusRetryCount--;
                        srb = deviceExtension->CurrentSrb = BuildMechanismStatusSrb (
                                                              HwDeviceExtension,
                                                              deviceExtension->OriginalSrb->PathId,
                                                              deviceExtension->OriginalSrb->TargetId);
                    } else {

                        // last request was illegal.  No point trying again

                        AtapiHwInitializeChanger (HwDeviceExtension,
                                                  srb->TargetId,
                                                  (PMECHANICAL_STATUS_INFORMATION_HEADER) NULL);

                        // Get ready to issue the original srb
                        srb = deviceExtension->CurrentSrb = deviceExtension->OriginalSrb;
                        deviceExtension->OriginalSrb = NULL;
                    }

                    srbStatus = AtapiSendCommand(HwDeviceExtension, deviceExtension->CurrentSrb);
                    if (srbStatus == SRB_STATUS_PENDING) {
                        return TRUE;
                    }
                }
            }

            // If we get here, it means AtapiSendCommand() has failed
            // Can't recover.  Pretend the original srb has failed and complete it.

            if (deviceExtension->OriginalSrb) {
                AtapiHwInitializeChanger (HwDeviceExtension,
                                          srb->TargetId,
                                          (PMECHANICAL_STATUS_INFORMATION_HEADER) NULL);
                srb = deviceExtension->CurrentSrb = deviceExtension->OriginalSrb;
                deviceExtension->OriginalSrb = NULL;
            }

            // fake an error and read no data
            status = SRB_STATUS_ERROR;
            srb->ScsiStatus = 0;
            deviceExtension->DataBuffer = srb->DataBuffer;
            deviceExtension->WordsLeft = srb->DataTransferLength;
            deviceExtension->RDP = FALSE;

        } else if (status == SRB_STATUS_ERROR) {

            //
            // Map error to specific SRB status and handle request sense.
            //

            status = MapError(deviceExtension,
                              srb);

            deviceExtension->RDP = FALSE;

        } else {

            //
            // Wait for busy to drop.
            //

            for (i = 0; i < 30; i++) {
                GetStatus(baseIoAddress2,statusByte);
                if (!(statusByte & IDE_STATUS_BUSY)) {
                    break;
                }
                ScsiPortStallExecution(500);
            }

            if (i == 30) {

                //
                // reset the controller.
                //

                DebugPrint((1,
                            "AtapiInterrupt: Resetting due to BSY still up - %x. Base Io %x\n",
                            statusByte,
                            baseIoAddress1));
                AtapiResetController(HwDeviceExtension,srb->PathId);
                return TRUE;
            }

            //
            // Check to see if DRQ is still up.
            //

            if (statusByte & IDE_STATUS_DRQ) {

                for (i = 0; i < 500; i++) {
                    GetStatus(baseIoAddress2,statusByte);
                    if (!(statusByte & IDE_STATUS_DRQ)) {
                        break;
                    }
                    ScsiPortStallExecution(100);

                }

                if (i == 500) {

                    //
                    // reset the controller.
                    //

                    DebugPrint((1,
                                "AtapiInterrupt: Resetting due to DRQ still up - %x\n",
                                statusByte));
                    AtapiResetController(HwDeviceExtension,srb->PathId);
                    return TRUE;
                }

            }
        }


        //
        // Clear interrupt expecting flag.
        //

        deviceExtension->ExpectingInterrupt = FALSE;

        //
        // Sanity check that there is a current request.
        //

        if (srb != NULL) {

            //
            // Set status in SRB.
            //

            srb->SrbStatus = (UCHAR)status;

            //
            // Check for underflow.
            //

            if (deviceExtension->WordsLeft) {

                //
                // Subtract out residual words and update if filemark hit,
                // setmark hit , end of data, end of media...
                //

                if (!(deviceExtension->DeviceFlags[srb->TargetId] & DFLAGS_TAPE_DEVICE)) {
                if (status == SRB_STATUS_DATA_OVERRUN) {
                    srb->DataTransferLength -= deviceExtension->WordsLeft;
                } else {
                    srb->DataTransferLength = 0;
                }
                } else {
                    srb->DataTransferLength -= deviceExtension->WordsLeft;
                }
            }

            if (srb->Function != SRB_FUNCTION_IO_CONTROL) {

                //
                // Indicate command complete.
                //

                if (!(deviceExtension->RDP)) {
                    ScsiPortNotification(RequestComplete,
                                         deviceExtension,
                                         srb);

                }
            } else {

                PSENDCMDOUTPARAMS cmdOutParameters = (PSENDCMDOUTPARAMS)(((PUCHAR)srb->DataBuffer) + sizeof(SRB_IO_CONTROL));
                UCHAR             error = 0;

                if (status != SRB_STATUS_SUCCESS) {
                    error = ScsiPortReadPortUchar((PUCHAR)baseIoAddress1 + 1);
                }

                //
                // Build the SMART status block depending upon the completion status.
                //

                cmdOutParameters->cBufferSize = wordCount;
                cmdOutParameters->DriverStatus.bDriverError = (error) ? SMART_IDE_ERROR : 0;
                cmdOutParameters->DriverStatus.bIDEError = error;

                //
                // If the sub-command is return smart status, jam the value from cylinder low and high, into the
                // data buffer.
                //

                if (deviceExtension->SmartCommand == RETURN_SMART_STATUS) {
                    cmdOutParameters->bBuffer[0] = RETURN_SMART_STATUS;
                    cmdOutParameters->bBuffer[1] = ScsiPortReadPortUchar(&baseIoAddress1->InterruptReason);
                    cmdOutParameters->bBuffer[2] = ScsiPortReadPortUchar(&baseIoAddress1->Unused1);
                    cmdOutParameters->bBuffer[3] = ScsiPortReadPortUchar(&baseIoAddress1->ByteCountLow);
                    cmdOutParameters->bBuffer[4] = ScsiPortReadPortUchar(&baseIoAddress1->ByteCountHigh);
                    cmdOutParameters->bBuffer[5] = ScsiPortReadPortUchar(&baseIoAddress1->DriveSelect);
                    cmdOutParameters->bBuffer[6] = SMART_CMD;
                    cmdOutParameters->cBufferSize = 8;
                }

                //
                // Indicate command complete.
                //

                ScsiPortNotification(RequestComplete,
                                     deviceExtension,
                                     srb);

            }

        } else {

            DebugPrint((1,
                       "AtapiInterrupt: No SRB!\n"));
        }

        //
        // Indicate ready for next request.
        //

        if (!(deviceExtension->RDP)) {

            //
            // Clear current SRB.
            //

            deviceExtension->CurrentSrb = NULL;

            ScsiPortNotification(NextRequest,
                                 deviceExtension,
                                 NULL);
        } else {

            ScsiPortNotification(RequestTimerCall,
                                 HwDeviceExtension,
                                 AtapiCallBack,
                                 2000);
        }

        return TRUE;

    } else {

        //
        // Unexpected int.
        //

        DebugPrint((3,
                    "AtapiInterrupt: Unexpected interrupt. InterruptReason %x. Status %x.\n",
                    interruptReason,
                    statusByte));
        return FALSE;
    }

    return TRUE;

} // end AtapiInterrupt()


ULONG
IdeSendSmartCommand(
    IN PVOID HwDeviceExtension,
    IN PSCSI_REQUEST_BLOCK Srb
    )

/*++

Routine Description:

    This routine handles SMART enable, disable, read attributes and threshold commands.

Arguments:

    HwDeviceExtension - HBA miniport driver's adapter data storage
    Srb - IO request packet

Return Value:

    SRB status

--*/

{
    PHW_DEVICE_EXTENSION deviceExtension = HwDeviceExtension;
    PIDE_REGISTERS_1     baseIoAddress1  = deviceExtension->BaseIoAddress1[Srb->TargetId >> 1];
    PIDE_REGISTERS_2     baseIoAddress2  = deviceExtension->BaseIoAddress2[Srb->TargetId >> 1];
    PSENDCMDOUTPARAMS    cmdOutParameters = (PSENDCMDOUTPARAMS)(((PUCHAR)Srb->DataBuffer) + sizeof(SRB_IO_CONTROL));
    SENDCMDINPARAMS      cmdInParameters = *(PSENDCMDINPARAMS)(((PUCHAR)Srb->DataBuffer) + sizeof(SRB_IO_CONTROL));
    PIDEREGS             regs = &cmdInParameters.irDriveRegs;
    ULONG                i;
    UCHAR                statusByte,targetId;


    if (cmdInParameters.irDriveRegs.bCommandReg == SMART_CMD) {

        targetId = cmdInParameters.bDriveNumber;

        //TODO optimize this check

        if ((!(deviceExtension->DeviceFlags[targetId] & DFLAGS_DEVICE_PRESENT)) ||
             (deviceExtension->DeviceFlags[targetId] & DFLAGS_ATAPI_DEVICE)) {

            return SRB_STATUS_SELECTION_TIMEOUT;
        }

        deviceExtension->SmartCommand = cmdInParameters.irDriveRegs.bFeaturesReg;

        //
        // Determine which of the commands to carry out.
        //

        if ((cmdInParameters.irDriveRegs.bFeaturesReg == READ_ATTRIBUTES) ||
            (cmdInParameters.irDriveRegs.bFeaturesReg == READ_THRESHOLDS)) {

            WaitOnBusy(baseIoAddress2,statusByte);

            if (statusByte & IDE_STATUS_BUSY) {
                DebugPrint((1,
                            "IdeSendSmartCommand: Returning BUSY status\n"));
                return SRB_STATUS_BUSY;
            }

            //
            // Zero the ouput buffer as the input buffer info. has been saved off locally (the buffers are the same).
            //

            for (i = 0; i < (sizeof(SENDCMDOUTPARAMS) + READ_ATTRIBUTE_BUFFER_SIZE - 1); i++) {
                ((PUCHAR)cmdOutParameters)[i] = 0;
            }

            //
            // Set data buffer pointer and words left.
            //

            deviceExtension->DataBuffer = (PUSHORT)cmdOutParameters->bBuffer;
            deviceExtension->WordsLeft = READ_ATTRIBUTE_BUFFER_SIZE / 2;

            //
            // Indicate expecting an interrupt.
            //

            deviceExtension->ExpectingInterrupt = TRUE;

            ScsiPortWritePortUchar(&baseIoAddress1->DriveSelect,(UCHAR)(((targetId & 0x1) << 4) | 0xA0));
            ScsiPortWritePortUchar((PUCHAR)baseIoAddress1 + 1,regs->bFeaturesReg);
            ScsiPortWritePortUchar(&baseIoAddress1->BlockCount,regs->bSectorCountReg);
            ScsiPortWritePortUchar(&baseIoAddress1->BlockNumber,regs->bSectorNumberReg);
            ScsiPortWritePortUchar(&baseIoAddress1->CylinderLow,regs->bCylLowReg);
            ScsiPortWritePortUchar(&baseIoAddress1->CylinderHigh,regs->bCylHighReg);
            ScsiPortWritePortUchar(&baseIoAddress1->Command,regs->bCommandReg);

            //
            // Wait for interrupt.
            //

            return SRB_STATUS_PENDING;

        } else if ((cmdInParameters.irDriveRegs.bFeaturesReg == ENABLE_SMART) ||
                   (cmdInParameters.irDriveRegs.bFeaturesReg == DISABLE_SMART) ||
                   (cmdInParameters.irDriveRegs.bFeaturesReg == RETURN_SMART_STATUS) ||
                   (cmdInParameters.irDriveRegs.bFeaturesReg == ENABLE_DISABLE_AUTOSAVE) ||
                   (cmdInParameters.irDriveRegs.bFeaturesReg == EXECUTE_OFFLINE_DIAGS) ||
                   (cmdInParameters.irDriveRegs.bFeaturesReg == SAVE_ATTRIBUTE_VALUES)) {

            WaitOnBusy(baseIoAddress2,statusByte);

            if (statusByte & IDE_STATUS_BUSY) {
                DebugPrint((1,
                            "IdeSendSmartCommand: Returning BUSY status\n"));
                return SRB_STATUS_BUSY;
            }

            //
            // Zero the ouput buffer as the input buffer info. has been saved off locally (the buffers are the same).
            //

            for (i = 0; i < (sizeof(SENDCMDOUTPARAMS) - 1); i++) {
                ((PUCHAR)cmdOutParameters)[i] = 0;
            }

            //
            // Set data buffer pointer and indicate no data transfer.
            //

            deviceExtension->DataBuffer = (PUSHORT)cmdOutParameters->bBuffer;
            deviceExtension->WordsLeft = 0;

            //
            // Indicate expecting an interrupt.
            //

            deviceExtension->ExpectingInterrupt = TRUE;

            ScsiPortWritePortUchar(&baseIoAddress1->DriveSelect,(UCHAR)(((targetId & 0x1) << 4) | 0xA0));
            ScsiPortWritePortUchar((PUCHAR)baseIoAddress1 + 1,regs->bFeaturesReg);
            ScsiPortWritePortUchar(&baseIoAddress1->BlockCount,regs->bSectorCountReg);
            ScsiPortWritePortUchar(&baseIoAddress1->BlockNumber,regs->bSectorNumberReg);
            ScsiPortWritePortUchar(&baseIoAddress1->CylinderLow,regs->bCylLowReg);
            ScsiPortWritePortUchar(&baseIoAddress1->CylinderHigh,regs->bCylHighReg);
            ScsiPortWritePortUchar(&baseIoAddress1->Command,regs->bCommandReg);

            //
            // Wait for interrupt.
            //

            return SRB_STATUS_PENDING;
        }
    }

    return SRB_STATUS_INVALID_REQUEST;

} // end IdeSendSmartCommand()


ULONG
IdeReadWrite(
    IN PVOID HwDeviceExtension,
    IN PSCSI_REQUEST_BLOCK Srb
    )

/*++

Routine Description:

    This routine handles IDE read and writes.

Arguments:

    HwDeviceExtension - HBA miniport driver's adapter data storage
    Srb - IO request packet

Return Value:

    SRB status

--*/

{
    PHW_DEVICE_EXTENSION deviceExtension = HwDeviceExtension;
    PIDE_REGISTERS_1     baseIoAddress1  = deviceExtension->BaseIoAddress1[Srb->TargetId >> 1];
    PIDE_REGISTERS_2     baseIoAddress2  = deviceExtension->BaseIoAddress2[Srb->TargetId >> 1];
    ULONG                startingSector,i;
    ULONG                wordCount;
    UCHAR                statusByte,statusByte2;
    UCHAR                cylinderHigh,cylinderLow,drvSelect,sectorNumber;

    //
    // Select device 0 or 1.
    //

    ScsiPortWritePortUchar(&baseIoAddress1->DriveSelect,
                            (UCHAR)(((Srb->TargetId & 0x1) << 4) | 0xA0));

    WaitOnBusy(baseIoAddress2,statusByte2);

    if (statusByte2 & IDE_STATUS_BUSY) {
        DebugPrint((1,
                    "IdeReadWrite: Returning BUSY status\n"));
        return SRB_STATUS_BUSY;
    }

    //
    // Set data buffer pointer and words left.
    //

    deviceExtension->DataBuffer = (PUSHORT)Srb->DataBuffer;
    deviceExtension->WordsLeft = Srb->DataTransferLength / 2;

    //
    // Indicate expecting an interrupt.
    //

    deviceExtension->ExpectingInterrupt = TRUE;

    //
    // Set up sector count register. Round up to next block.
    //

    ScsiPortWritePortUchar(&baseIoAddress1->BlockCount,
                           (UCHAR)((Srb->DataTransferLength + 0x1FF) / 0x200));

    //
    // Get starting sector number from CDB.
    //

    startingSector = ((PCDB)Srb->Cdb)->CDB10.LogicalBlockByte3 |
                     ((PCDB)Srb->Cdb)->CDB10.LogicalBlockByte2 << 8 |
                     ((PCDB)Srb->Cdb)->CDB10.LogicalBlockByte1 << 16 |
                     ((PCDB)Srb->Cdb)->CDB10.LogicalBlockByte0 << 24;

    DebugPrint((1,
               "IdeReadWrite: Starting sector is %x, Number of bytes %x\n",
               startingSector,
               Srb->DataTransferLength));

    //
    // Set up sector number register.
    //

    sectorNumber = ((PCDB)Srb->Cdb)->CDB10.LogicalBlockByte3;      // LBA mode
                 // (UCHAR)((startingSector % deviceExtension->IdentifyData[Srb->TargetId].SectorsPerTrack) + 1);
    ScsiPortWritePortUchar(&baseIoAddress1->BlockNumber,sectorNumber);

    //
    // Set up cylinder low register.
    //

    cylinderLow = ((PCDB)Srb->Cdb)->CDB10.LogicalBlockByte2;      // LBA mode
                // (UCHAR)(startingSector / (deviceExtension->IdentifyData[Srb->TargetId].SectorsPerTrack *
                //         deviceExtension->IdentifyData[Srb->TargetId].NumberOfHeads));
    ScsiPortWritePortUchar(&baseIoAddress1->CylinderLow,cylinderLow);

    //
    // Set up cylinder high register.
    //

    cylinderHigh = ((PCDB)Srb->Cdb)->CDB10.LogicalBlockByte1;      // LBA mode
                // (UCHAR)((startingSector / (deviceExtension->IdentifyData[Srb->TargetId].SectorsPerTrack *
                //         deviceExtension->IdentifyData[Srb->TargetId].NumberOfHeads)) >> 8);
    ScsiPortWritePortUchar(&baseIoAddress1->CylinderHigh,cylinderHigh);

    //
    // Set up head and drive select register.
    //

    drvSelect = (UCHAR)(((PCDB)Srb->Cdb)->CDB10.LogicalBlockByte0 |      // LBA mode
                ((Srb->TargetId & 0x1) << 4) | 0xE0);
             // (UCHAR)(((startingSector / deviceExtension->IdentifyData[Srb->TargetId].SectorsPerTrack) %
             //       deviceExtension->IdentifyData[Srb->TargetId].NumberOfHeads) |((Srb->TargetId & 0x1) << 4) | 0xA0);
    ScsiPortWritePortUchar(&baseIoAddress1->DriveSelect,drvSelect);

 // DebugPrint((2,
 //            "IdeReadWrite: Cylinder %x Head %x Sector %x\n",
 //            startingSector /
 //            (deviceExtension->IdentifyData[Srb->TargetId].SectorsPerTrack *
 //            deviceExtension->IdentifyData[Srb->TargetId].NumberOfHeads),
 //            (startingSector /
 //            deviceExtension->IdentifyData[Srb->TargetId].SectorsPerTrack) %
 //            deviceExtension->IdentifyData[Srb->TargetId].NumberOfHeads,
 //            startingSector %
 //            deviceExtension->IdentifyData[Srb->TargetId].SectorsPerTrack + 1));

    //
    // Check if write request.
    //

    if (Srb->SrbFlags & SRB_FLAGS_DATA_IN) {

        //
        // Send read command.
        //

        if (deviceExtension->MaximumBlockXfer[Srb->TargetId]) {
            ScsiPortWritePortUchar(&baseIoAddress1->Command,
                                   IDE_COMMAND_READ_MULTIPLE);

        } else {
            ScsiPortWritePortUchar(&baseIoAddress1->Command,
                                   IDE_COMMAND_READ);
        }
    } else {


        //
        // Send write command.
        //

        if (deviceExtension->MaximumBlockXfer[Srb->TargetId]) {
            wordCount = 256 * deviceExtension->MaximumBlockXfer[Srb->TargetId];

            if (deviceExtension->WordsLeft < wordCount) {

               //
               // Transfer only words requested.
               //

               wordCount = deviceExtension->WordsLeft;

            }
            ScsiPortWritePortUchar(&baseIoAddress1->Command,
                                   IDE_COMMAND_WRITE_MULTIPLE);

        } else {
            wordCount = 256;
            ScsiPortWritePortUchar(&baseIoAddress1->Command,
                                   IDE_COMMAND_WRITE);
        }

        //
        // Wait for BSY and DRQ.
        //

        WaitOnBaseBusy(baseIoAddress1,statusByte);

        if (statusByte & IDE_STATUS_BUSY) {

            DebugPrint((1,
                        "IdeReadWrite 2: Returning BUSY status %x\n",
                        statusByte));
            return SRB_STATUS_BUSY;
        }

        for (i = 0; i < 1000; i++) {
            GetBaseStatus(baseIoAddress1, statusByte);
            if (statusByte & IDE_STATUS_DRQ) {
                break;
            }
            ScsiPortStallExecution(200);

        }

        if (!(statusByte & IDE_STATUS_DRQ)) {

            DebugPrint((1,
                       "IdeReadWrite: DRQ never asserted (%x) original status (%x)\n",
                       statusByte,
                       statusByte2));

            deviceExtension->WordsLeft = 0;

            //
            // Clear interrupt expecting flag.
            //

            deviceExtension->ExpectingInterrupt = FALSE;

            //
            // Clear current SRB.
            //

            deviceExtension->CurrentSrb = NULL;

            return SRB_STATUS_TIMEOUT;
        }

        //
        // Write next 256 words.
        //

        if (deviceExtension->DWordIO) {

            WriteBuffer32(baseIoAddress1,
                          (PULONG)deviceExtension->DataBuffer,
                          wordCount >> 1);
        } else {

            WriteBuffer(baseIoAddress1,
                        deviceExtension->DataBuffer,
                        wordCount);
        }

        //
        // Adjust buffer address and words left count.
        //

        deviceExtension->WordsLeft -= wordCount;
        deviceExtension->DataBuffer += wordCount;

    }

    //
    // Wait for interrupt.
    //

    return SRB_STATUS_PENDING;

} // end IdeReadWrite()



ULONG
IdeVerify(
    IN PVOID HwDeviceExtension,
    IN PSCSI_REQUEST_BLOCK Srb
    )

/*++

Routine Description:

    This routine handles IDE Verify.

Arguments:

    HwDeviceExtension - HBA miniport driver's adapter data storage
    Srb - IO request packet

Return Value:

    SRB status

--*/

{
    PHW_DEVICE_EXTENSION deviceExtension = HwDeviceExtension;
    PIDE_REGISTERS_1     baseIoAddress1  = deviceExtension->BaseIoAddress1[Srb->TargetId >> 1];
    PIDE_REGISTERS_2     baseIoAddress2  = deviceExtension->BaseIoAddress2[Srb->TargetId >> 1];
    ULONG                startingSector;
    ULONG                sectors;
    ULONG                endSector;
    USHORT               sectorCount;

    //
    // Drive has these number sectors.
    //

    sectors = deviceExtension->IdentifyData[Srb->TargetId].SectorsPerTrack *
              deviceExtension->IdentifyData[Srb->TargetId].NumberOfHeads *
              deviceExtension->IdentifyData[Srb->TargetId].NumberOfCylinders;

    DebugPrint((3,
                "IdeVerify: Total sectors %x\n",
                sectors));

    //
    // Get starting sector number from CDB.
    //

    startingSector = ((PCDB)Srb->Cdb)->CDB10.LogicalBlockByte3 |
                     ((PCDB)Srb->Cdb)->CDB10.LogicalBlockByte2 << 8 |
                     ((PCDB)Srb->Cdb)->CDB10.LogicalBlockByte1 << 16 |
                     ((PCDB)Srb->Cdb)->CDB10.LogicalBlockByte0 << 24;

    DebugPrint((3,
                "IdeVerify: Starting sector %x. Number of blocks %x\n",
                startingSector,
                ((PCDB)Srb->Cdb)->CDB10.TransferBlocksLsb));

    sectorCount = (USHORT)(((PCDB)Srb->Cdb)->CDB10.TransferBlocksMsb << 8 |
                           ((PCDB)Srb->Cdb)->CDB10.TransferBlocksLsb );
    endSector = startingSector + sectorCount;

    DebugPrint((3,
                "IdeVerify: Ending sector %x\n",
                endSector));

    if (endSector > sectors) {

        //
        // Too big, round down.
        //

        DebugPrint((1,
                    "IdeVerify: Truncating request to %x blocks\n",
                    sectors - startingSector - 1));

        ScsiPortWritePortUchar(&baseIoAddress1->BlockCount,
                               (UCHAR)(sectors - startingSector - 1));

    } else {

        //
        // Set up sector count register. Round up to next block.
        //

        if (sectorCount > 0xFF) {
            sectorCount = (USHORT)0xFF;
        }

        ScsiPortWritePortUchar(&baseIoAddress1->BlockCount,(UCHAR)sectorCount);
    }

    //
    // Set data buffer pointer and words left.
    //

    deviceExtension->DataBuffer = (PUSHORT)Srb->DataBuffer;
    deviceExtension->WordsLeft = Srb->DataTransferLength / 2;

    //
    // Indicate expecting an interrupt.
    //

    deviceExtension->ExpectingInterrupt = TRUE;

    //
    // Set up sector number register.
    //

    ScsiPortWritePortUchar(&baseIoAddress1->BlockNumber,
                ((PCDB)Srb->Cdb)->CDB10.LogicalBlockByte3);      // LBA mode
                //         (UCHAR)((startingSector %
                //         deviceExtension->IdentifyData[Srb->TargetId].SectorsPerTrack) + 1));

    //
    // Set up cylinder low register.
    //

    ScsiPortWritePortUchar(&baseIoAddress1->CylinderLow,
                ((PCDB)Srb->Cdb)->CDB10.LogicalBlockByte2);      // LBA mode
                //         (UCHAR)(startingSector /
                //         (deviceExtension->IdentifyData[Srb->TargetId].SectorsPerTrack *
                //         deviceExtension->IdentifyData[Srb->TargetId].NumberOfHeads)));

    //
    // Set up cylinder high register.
    //

    ScsiPortWritePortUchar(&baseIoAddress1->CylinderHigh,
                ((PCDB)Srb->Cdb)->CDB10.LogicalBlockByte1);      // LBA mode
                //         (UCHAR)((startingSector /
                //         (deviceExtension->IdentifyData[Srb->TargetId].SectorsPerTrack *
                //         deviceExtension->IdentifyData[Srb->TargetId].NumberOfHeads)) >> 8));

    //
    // Set up head and drive select register.
    //

    ScsiPortWritePortUchar(&baseIoAddress1->DriveSelect,
                (UCHAR)(((PCDB)Srb->Cdb)->CDB10.LogicalBlockByte0 |      // LBA mode
                ((Srb->TargetId & 0x1) << 4) | 0xE0));
                //         (UCHAR)(((startingSector /
                //         deviceExtension->IdentifyData[Srb->TargetId].SectorsPerTrack) %
                //         deviceExtension->IdentifyData[Srb->TargetId].NumberOfHeads) |
                //         ((Srb->TargetId & 0x1) << 4) | 0xA0));

    DebugPrint((2,
               "IdeVerify: Cylinder %x Head %x Sector %x\n",
               startingSector /
               (deviceExtension->IdentifyData[Srb->TargetId].SectorsPerTrack *
               deviceExtension->IdentifyData[Srb->TargetId].NumberOfHeads),
               (startingSector /
               deviceExtension->IdentifyData[Srb->TargetId].SectorsPerTrack) %
               deviceExtension->IdentifyData[Srb->TargetId].NumberOfHeads,
               startingSector %
               deviceExtension->IdentifyData[Srb->TargetId].SectorsPerTrack + 1));


    //
    // Send verify command.
    //

    ScsiPortWritePortUchar(&baseIoAddress1->Command,
                           IDE_COMMAND_VERIFY);

    //
    // Wait for interrupt.
    //

    return SRB_STATUS_PENDING;

} // end IdeVerify()


VOID
Scsi2Atapi(
    IN PSCSI_REQUEST_BLOCK Srb
    )

/*++

Routine Description:

    Convert SCSI packet command to Atapi packet command.

Arguments:

    Srb - IO request packet

Return Value:

    None

--*/
{
    //
    // Change the cdb length
    //

    Srb->CdbLength = 12;

    switch (Srb->Cdb[0]) {
        case SCSIOP_MODE_SENSE: {
            PMODE_SENSE_10 modeSense10 = (PMODE_SENSE_10)Srb->Cdb;
            UCHAR PageCode = ((PCDB)Srb->Cdb)->MODE_SENSE.PageCode;
            UCHAR Length = ((PCDB)Srb->Cdb)->MODE_SENSE.AllocationLength;

            AtapiZeroMemory(Srb->Cdb,MAXIMUM_CDB_SIZE);

            modeSense10->OperationCode = ATAPI_MODE_SENSE;
            modeSense10->PageCode = PageCode;
            modeSense10->ParameterListLengthMsb = 0;
            modeSense10->ParameterListLengthLsb = Length;
            break;
        }

        case SCSIOP_MODE_SELECT: {
            PMODE_SELECT_10 modeSelect10 = (PMODE_SELECT_10)Srb->Cdb;
            UCHAR Length = ((PCDB)Srb->Cdb)->MODE_SELECT.ParameterListLength;

            //
            // Zero the original cdb
            //

            AtapiZeroMemory(Srb->Cdb,MAXIMUM_CDB_SIZE);

            modeSelect10->OperationCode = ATAPI_MODE_SELECT;
            modeSelect10->PFBit = 1;
            modeSelect10->ParameterListLengthMsb = 0;
            modeSelect10->ParameterListLengthLsb = Length;
            break;
        }

        /*
        case SCSIOP_FORMAT_UNIT:
        Srb->Cdb[0] = ATAPI_FORMAT_UNIT;
        break;
        */
    }
}



ULONG
AtapiSendCommand(
    IN PVOID HwDeviceExtension,
    IN PSCSI_REQUEST_BLOCK Srb
    )

/*++

Routine Description:

    Send ATAPI packet command to device.

Arguments:

    HwDeviceExtension - HBA miniport driver's adapter data storage
    Srb - IO request packet

Return Value:


--*/

{
    PHW_DEVICE_EXTENSION deviceExtension = HwDeviceExtension;
    PATAPI_REGISTERS_1   baseIoAddress1  = (PATAPI_REGISTERS_1)deviceExtension->BaseIoAddress1[Srb->TargetId >> 1];
    PATAPI_REGISTERS_2   baseIoAddress2 =  (PATAPI_REGISTERS_2)deviceExtension->BaseIoAddress2[Srb->TargetId >> 1];
    ULONG i;
    ULONG flags;
    UCHAR statusByte,byteCountLow,byteCountHigh;

    //
    // We need to know how many platters our atapi cd-rom device might have.
    // Before anyone tries to send a srb to our target for the first time,
    // we must "secretly" send down a separate mechanism status srb in order to
    // initialize our device extension changer data.  That's how we know how
    // many platters our target has.
    //
    if (!(deviceExtension->DeviceFlags[Srb->TargetId] & DFLAGS_CHANGER_INITED) &&
        !deviceExtension->OriginalSrb) {

        ULONG srbStatus;

        //
        // Set this flag now. If the device hangs on the mech. status
        // command, we will not have the change to set it.
        //
        deviceExtension->DeviceFlags[Srb->TargetId] |= DFLAGS_CHANGER_INITED;

        deviceExtension->MechStatusRetryCount = 3;
        deviceExtension->CurrentSrb = BuildMechanismStatusSrb (
                                        HwDeviceExtension,
                                        Srb->PathId,
                                        Srb->TargetId);
        deviceExtension->OriginalSrb = Srb;

        srbStatus = AtapiSendCommand(HwDeviceExtension, deviceExtension->CurrentSrb);
        if (srbStatus == SRB_STATUS_PENDING) {
            return srbStatus;
        } else {
            deviceExtension->CurrentSrb = deviceExtension->OriginalSrb;
            deviceExtension->OriginalSrb = NULL;
            AtapiHwInitializeChanger (HwDeviceExtension,
                                      Srb->TargetId,
                                      (PMECHANICAL_STATUS_INFORMATION_HEADER) NULL);
            // fall out
        }
    }

    DebugPrint((2,
               "AtapiSendCommand: Command %x to TargetId %d lun %d\n",
               Srb->Cdb[0],
               Srb->TargetId,
               Srb->Lun));

    if (Srb->Cdb[0] == SCSIOP_READ || Srb->Cdb[0] == SCSIOP_READ_CD || Srb->Cdb[0] == SCSIOP_WRITE) {

        DebugPrint((1,
                   "AtapiSendCommand: Command is %x, Number of bytes %x\n",
                   Srb->Cdb[0],
                   Srb->DataTransferLength));
    }

    //
    // Make sure command is to ATAPI device.
    //

    flags = deviceExtension->DeviceFlags[Srb->TargetId];
    if (flags & (DFLAGS_SANYO_ATAPI_CHANGER | DFLAGS_ATAPI_CHANGER)) {
        if ((Srb->Lun) > (deviceExtension->DiscsPresent[Srb->TargetId] - 1)) {

            //
            // Indicate no device found at this address.
            //

            return SRB_STATUS_SELECTION_TIMEOUT;
        }
    } else if (Srb->Lun > 0) {
        return SRB_STATUS_SELECTION_TIMEOUT;
    }

    if (!(flags & DFLAGS_ATAPI_DEVICE)) {
        return SRB_STATUS_SELECTION_TIMEOUT;
    }

    //
    // Select device 0 or 1.
    //

    ScsiPortWritePortUchar(&baseIoAddress1->DriveSelect,
                           (UCHAR)(((Srb->TargetId & 0x1) << 4) | 0xA0));

    //
    // Verify that controller is ready for next command.
    //

    GetStatus(baseIoAddress2,statusByte);

    DebugPrint((2,
                "AtapiSendCommand: Entered with status %x\n",
                statusByte));

    if (statusByte & IDE_STATUS_BUSY) {
        DebugPrint((1,
                    "AtapiSendCommand: Device busy (%x)\n",
                    statusByte));
        return SRB_STATUS_BUSY;

    }

    if (statusByte & IDE_STATUS_ERROR) {
        if (Srb->Cdb[0] != SCSIOP_REQUEST_SENSE) {

            DebugPrint((1,
                        "AtapiSendCommand: Error on entry: (%x)\n",
                        statusByte));
            //
            // Read the error reg. to clear it and fail this request.
            //

            return MapError(deviceExtension,
                            Srb);
        }
    }

    //
    // If a tape drive has doesn't have DSC set and the last command is restrictive, don't send
    // the next command. See discussion of Restrictive Delayed Process commands in QIC-157.
    //

    if ((!(statusByte & IDE_STATUS_DSC)) &&
          (flags & DFLAGS_TAPE_DEVICE) && deviceExtension->RDP) {
        ScsiPortStallExecution(1000);
        DebugPrint((2,"AtapiSendCommand: DSC not set. %x\n",statusByte));
        return SRB_STATUS_BUSY;
    }

    if (IS_RDP(Srb->Cdb[0])) {

        deviceExtension->RDP = TRUE;

        DebugPrint((3,
                    "AtapiSendCommand: %x mapped as DSC restrictive\n",
                    Srb->Cdb[0]));

    } else {

        deviceExtension->RDP = FALSE;
    }

    if (statusByte & IDE_STATUS_DRQ) {

        DebugPrint((1,
                    "AtapiSendCommand: Entered with status (%x). Attempting to recover.\n",
                    statusByte));
        //
        // Try to drain the data that one preliminary device thinks that it has
        // to transfer. Hopefully this random assertion of DRQ will not be present
        // in production devices.
        //

        for (i = 0; i < 0x10000; i++) {

           GetStatus(baseIoAddress2, statusByte);

           if (statusByte & IDE_STATUS_DRQ) {

              ScsiPortReadPortUshort(&baseIoAddress1->Data);

           } else {

              break;
           }
        }

        if (i == 0x10000) {

            DebugPrint((1,
                        "AtapiSendCommand: DRQ still asserted.Status (%x)\n",
                        statusByte));

            // disable the interrupt
            if (deviceExtension->IrqSharing)
                ScsiPortWritePortUchar(&baseIoAddress1->DmaReg, 0x20);

            AtapiSoftReset(baseIoAddress1,baseIoAddress2,Srb->TargetId);

            DebugPrint((1,
                         "AtapiSendCommand: Issued soft reset to Atapi device. \n"));

            //
            // Re-initialize Atapi device.
            //

            IssueIdentify(HwDeviceExtension,
                          (Srb->TargetId & 0x1),
                          (Srb->TargetId >> 1),
                          IDE_COMMAND_ATAPI_IDENTIFY);

            // enable the interrupt
            if (deviceExtension->IrqSharing)
                ScsiPortWritePortUchar(&baseIoAddress1->DmaReg, 0x00);

            //
            // Inform the port driver that the bus has been reset.
            //

            ScsiPortNotification(ResetDetected, HwDeviceExtension, 0);

            //
            // Clean up device extension fields that AtapiStartIo won't.
            //

            deviceExtension->ExpectingInterrupt = FALSE;
            deviceExtension->RDP = FALSE;

            return SRB_STATUS_BUS_RESET;

        }
    }

    if (flags & (DFLAGS_SANYO_ATAPI_CHANGER | DFLAGS_ATAPI_CHANGER)) {

        //
        // As the cdrom driver sets the LUN field in the cdb, it must be removed.
        //

        Srb->Cdb[1] &= ~0xE0;

        if ((Srb->Cdb[0] == SCSIOP_TEST_UNIT_READY) && (flags & DFLAGS_SANYO_ATAPI_CHANGER)) {

            //
            // Torisan changer. TUR's are overloaded to be platter switches.
            //

            Srb->Cdb[7] = Srb->Lun;

        }
    }

    //
    // Convert SCSI to ATAPI commands if needed
    //

    switch (Srb->Cdb[0]) {
        case SCSIOP_MODE_SENSE:
        case SCSIOP_MODE_SELECT:
        /* case SCSIOP_FORMAT_UNIT: */
            if (!(flags & DFLAGS_TAPE_DEVICE)) {
                Scsi2Atapi(Srb);
            }

            break;
    }

    //
    // Set data buffer pointer and words left.
    //

    deviceExtension->DataBuffer = (PUSHORT)Srb->DataBuffer;
    deviceExtension->WordsLeft = Srb->DataTransferLength / 2;

    WaitOnBusy(baseIoAddress2,statusByte);

    //
    // Write transfer byte count to registers.
    //

    byteCountLow = (UCHAR)(Srb->DataTransferLength & 0xFF);
    byteCountHigh = (UCHAR)(Srb->DataTransferLength >> 8);

    if (Srb->DataTransferLength >= 0x10000) {
        byteCountLow = byteCountHigh = 0xFF;
    }

    ScsiPortWritePortUchar(&baseIoAddress1->ByteCountLow,byteCountLow);
    ScsiPortWritePortUchar(&baseIoAddress1->ByteCountHigh, byteCountHigh);

    ScsiPortWritePortUchar((PUCHAR)baseIoAddress1 + 1,0);


    if (flags & DFLAGS_INT_DRQ) {

        //
        // This device interrupts when ready to receive the packet.
        //
        // Write ATAPI packet command.
        //

        ScsiPortWritePortUchar(&baseIoAddress1->Command,
                               IDE_COMMAND_ATAPI_PACKET);

        DebugPrint((3,
                   "AtapiSendCommand: Wait for int. to send packet. Status (%x)\n",
                   statusByte));

        deviceExtension->ExpectingInterrupt = TRUE;

        return SRB_STATUS_PENDING;

    } else {

        //
        // Write ATAPI packet command.
        //

        ScsiPortWritePortUchar(&baseIoAddress1->Command,
                               IDE_COMMAND_ATAPI_PACKET);

        //
        // Wait for DRQ.
        //

        WaitOnBusy(baseIoAddress2, statusByte);
        WaitForDrq(baseIoAddress2, statusByte);

        if (!(statusByte & IDE_STATUS_DRQ)) {

            DebugPrint((1,
                       "AtapiSendCommand: DRQ never asserted (%x)\n",
                       statusByte));
            return SRB_STATUS_ERROR;
        }
    }

    //
    // Need to read status register.
    //

    GetBaseStatus(baseIoAddress1, statusByte);

    //
    // Send CDB to device.
    //

    WaitOnBusy(baseIoAddress2,statusByte);

    WriteBuffer(baseIoAddress1,
                (PUSHORT)Srb->Cdb,
                6);

    //
    // Indicate expecting an interrupt and wait for it.
    //

    deviceExtension->ExpectingInterrupt = TRUE;

    return SRB_STATUS_PENDING;

} // end AtapiSendCommand()

ULONG
IdeSendCommand(
    IN PVOID HwDeviceExtension,
    IN PSCSI_REQUEST_BLOCK Srb
    )

/*++

Routine Description:

    Program ATA registers for IDE disk transfer.

Arguments:

    HwDeviceExtension - ATAPI driver storage.
    Srb - System request block.

Return Value:

    SRB status (pending if all goes well).

--*/

{
    PHW_DEVICE_EXTENSION deviceExtension = HwDeviceExtension;
    PIDE_REGISTERS_1     baseIoAddress1  = deviceExtension->BaseIoAddress1[Srb->TargetId >> 1];
    PIDE_REGISTERS_2     baseIoAddress2  = deviceExtension->BaseIoAddress2[Srb->TargetId >> 1];
    PCDB cdb;

    UCHAR statusByte,errorByte;
    ULONG status;
    ULONG i;
    PMODE_PARAMETER_HEADER   modeData;

    DebugPrint((2,
               "IdeSendCommand: Command %x to device %d\n",
               Srb->Cdb[0],
               Srb->TargetId));



    switch (Srb->Cdb[0]) {
    case SCSIOP_INQUIRY:

        //
        // Filter out all TIDs but 0 and 1 since this is an IDE interface
        // which support up to two devices.
        //

        if ((Srb->Lun != 0) ||
            ((deviceExtension->DeviceFlags[Srb->TargetId] & DFLAGS_DEVICE_PRESENT) == 0)) {

            //
            // Indicate no device found at this address.
            //

            status = SRB_STATUS_SELECTION_TIMEOUT;
            break;

        } else {

            PINQUIRYDATA    inquiryData  = Srb->DataBuffer;
            PIDENTIFY_DATA2 identifyData = &deviceExtension->IdentifyData[Srb->TargetId];

            //
            // Zero INQUIRY data structure.
            //

            for (i = 0; i < Srb->DataTransferLength; i++) {
               ((PUCHAR)Srb->DataBuffer)[i] = 0;
            }

            //
            // Standard IDE interface only supports disks.
            //

            inquiryData->DeviceType = DIRECT_ACCESS_DEVICE;

            //
            // Set the removable bit, if applicable.
            //

            if (deviceExtension->DeviceFlags[Srb->TargetId] & DFLAGS_REMOVABLE_DRIVE) {
                inquiryData->RemovableMedia = 1;
            }

            //
            // Fill in vendor identification fields.
            //

            //for (i = 0; i < 20; i += 2) {
             //  inquiryData->VendorId[i] =
              //     ((PUCHAR)identifyData->ModelNumber)[i + 1];
               //inquiryData->VendorId[i+1] =
                //   ((PUCHAR)identifyData->ModelNumber)[i];
            //}

            //
            // break it into two loops such that it 
            // explicitly indicates the fields to 
            // which the id is copied
            //

            //
            // copy the first 8 bytes to VendorId
            //
            for (i = 0; i < 8; i += 2) {
                inquiryData->VendorId[i] =
                ((PUCHAR)identifyData->ModelNumber)[i + 1];
                inquiryData->VendorId[i+1] =
                ((PUCHAR)identifyData->ModelNumber)[i];
            }

            //
            // copy the next 12 bytes to ProductId
            //
            for (i = 0; i < 12; i += 2) {
                inquiryData->ProductId[i] =
                ((PUCHAR)identifyData->ModelNumber)[i + 9];
                inquiryData->ProductId[i+1] =
                ((PUCHAR)identifyData->ModelNumber)[i + 8];
            }

            //
            // Initialize unused portion of product id.
            //

            for (i = 0; i < 4; i++) {
               inquiryData->ProductId[12+i] = ' ';
            }

            //
            // Move firmware revision from IDENTIFY data to
            // product revision in INQUIRY data.
            //

            for (i = 0; i < 4; i += 2) {
               inquiryData->ProductRevisionLevel[i] =
                   ((PUCHAR)identifyData->FirmwareRevision)[i+1];
               inquiryData->ProductRevisionLevel[i+1] =
                   ((PUCHAR)identifyData->FirmwareRevision)[i];
            }

            status = SRB_STATUS_SUCCESS;
        }

        break;

    case SCSIOP_MODE_SENSE:

        //
        // This is used to determine of the media is write-protected.
        // Since IDE does not support mode sense then we will modify just the portion we need
        // so the higher level driver can determine if media is protected.
        //

        if (deviceExtension->DeviceFlags[Srb->TargetId] & DFLAGS_MEDIA_STATUS_ENABLED) {

            ScsiPortWritePortUchar(&baseIoAddress1->DriveSelect,
                             (UCHAR)(((Srb->TargetId & 0x1) << 4) | 0xA0));
            ScsiPortWritePortUchar(&baseIoAddress1->Command,IDE_COMMAND_GET_MEDIA_STATUS);
            WaitOnBusy(baseIoAddress2,statusByte);

            if (!(statusByte & IDE_STATUS_ERROR)){

                //
                // no error occured return success, media is not protected
                //

                deviceExtension->ExpectingInterrupt = FALSE;
                status = SRB_STATUS_SUCCESS;

            } else {

                //
                // error occured, handle it locally, clear interrupt
                //

                errorByte = ScsiPortReadPortUchar((PUCHAR)baseIoAddress1 + 1);

                GetBaseStatus(baseIoAddress1, statusByte);
                deviceExtension->ExpectingInterrupt = FALSE;
                status = SRB_STATUS_SUCCESS;

                if (errorByte & IDE_ERROR_DATA_ERROR) {

                   //
                   //media is write-protected, set bit in mode sense buffer
                   //

                   modeData = (PMODE_PARAMETER_HEADER)Srb->DataBuffer;

                   Srb->DataTransferLength = sizeof(MODE_PARAMETER_HEADER);
                   modeData->DeviceSpecificParameter |= MODE_DSP_WRITE_PROTECT;
                }
            }
            status = SRB_STATUS_SUCCESS;
        } else {
            status = SRB_STATUS_INVALID_REQUEST;
        }
        break;

    case SCSIOP_TEST_UNIT_READY:

        if (deviceExtension->DeviceFlags[Srb->TargetId] & DFLAGS_REMOVABLE_DRIVE) {

            //
            // Select device 0 or 1.
            //

            ScsiPortWritePortUchar(&baseIoAddress1->DriveSelect,
                            (UCHAR)(((Srb->TargetId & 0x1) << 4) | 0xA0));
            ScsiPortWritePortUchar(&baseIoAddress1->Command,IDE_COMMAND_GET_MEDIA_STATUS);

            //
            // Wait for busy. If media has not changed, return success
            //

            WaitOnBusy(baseIoAddress2,statusByte);

            if (!(statusByte & IDE_STATUS_ERROR)){
                deviceExtension->ExpectingInterrupt = FALSE;
                status = SRB_STATUS_SUCCESS;
            } else {
                errorByte = ScsiPortReadPortUchar((PUCHAR)baseIoAddress1 + 1);
                if (errorByte == IDE_ERROR_DATA_ERROR){

                    //
                    // Special case: If current media is write-protected,
                    // the 0xDA command will always fail since the write-protect bit
                    // is sticky,so we can ignore this error
                    //

                   GetBaseStatus(baseIoAddress1, statusByte);
                   deviceExtension->ExpectingInterrupt = FALSE;
                   status = SRB_STATUS_SUCCESS;

                } else {

                    //
                    // Request sense buffer to be build
                    //
                    deviceExtension->ExpectingInterrupt = TRUE;
                    status = SRB_STATUS_PENDING;
               }
            }
        } else {
            status = SRB_STATUS_SUCCESS;
        }

        break;

    case SCSIOP_READ_CAPACITY:

        //
        // Claim 512 byte blocks (big-endian).
        //

        ((PREAD_CAPACITY_DATA)Srb->DataBuffer)->BytesPerBlock = 0x20000;

       //
       // Calculate last sector.
       //


       i = (deviceExtension->IdentifyData[Srb->TargetId].NumberOfHeads *
            deviceExtension->IdentifyData[Srb->TargetId].NumberOfCylinders *
            deviceExtension->IdentifyData[Srb->TargetId].SectorsPerTrack) - 1;

       if ((deviceExtension->IdentifyData[Srb->TargetId].NumberOfHeads == 16
            || deviceExtension->IdentifyData[Srb->TargetId].NumberOfHeads == 15)
           && deviceExtension->IdentifyData[Srb->TargetId].NumberOfCylinders == 16383
           && deviceExtension->IdentifyData[Srb->TargetId].UserAddressableSectors
           && deviceExtension->IdentifyData[Srb->TargetId].UserAddressableSectors > (i + 1))
       {
           i = deviceExtension->IdentifyData[Srb->TargetId].UserAddressableSectors - 1;

           DebugPrint((1,
                      "IDE disk %x - using user addressable sectors (%x) instead of CHS. (sizeof IdentifyData = %d)\n",
                      Srb->TargetId,
                      deviceExtension->IdentifyData[Srb->TargetId].UserAddressableSectors,
                      sizeof(IDENTIFY_DATA2)));
       }

       ((PREAD_CAPACITY_DATA)Srb->DataBuffer)->LogicalBlockAddress =
           (((PUCHAR)&i)[0] << 24) |  (((PUCHAR)&i)[1] << 16) |
           (((PUCHAR)&i)[2] << 8) | ((PUCHAR)&i)[3];

       DebugPrint((1,
                  "IDE disk %x - #sectors %x, #heads %x, #cylinders %x\n",
                  Srb->TargetId,
                  deviceExtension->IdentifyData[Srb->TargetId].SectorsPerTrack,
                  deviceExtension->IdentifyData[Srb->TargetId].NumberOfHeads,
                  deviceExtension->IdentifyData[Srb->TargetId].NumberOfCylinders));


       status = SRB_STATUS_SUCCESS;
       break;

    case SCSIOP_VERIFY:
       status = IdeVerify(HwDeviceExtension,Srb);

       break;

    case SCSIOP_READ:
    case SCSIOP_WRITE:

       status = IdeReadWrite(HwDeviceExtension,
                                  Srb);
       break;

    case SCSIOP_START_STOP_UNIT:

       //
       //Determine what type of operation we should perform
       //
       cdb = (PCDB)Srb->Cdb;

       if (cdb->START_STOP.LoadEject == 1){

           //
           // Eject media,
           // first select device 0 or 1.
           //
           ScsiPortWritePortUchar(&baseIoAddress1->DriveSelect,
                            (UCHAR)(((Srb->TargetId & 0x1) << 4) | 0xA0));
           ScsiPortWritePortUchar(&baseIoAddress1->Command,IDE_COMMAND_MEDIA_EJECT);
       }
       status = SRB_STATUS_SUCCESS;
       break;

    case SCSIOP_REQUEST_SENSE:
       // this function makes sense buffers to report the results
       // of the original GET_MEDIA_STATUS command

       if (deviceExtension->DeviceFlags[Srb->TargetId] & DFLAGS_REMOVABLE_DRIVE) {

           status = IdeBuildSenseBuffer(HwDeviceExtension,Srb);
           break;
       }

    default:

       DebugPrint((1,
                  "IdeSendCommand: Unsupported command %x\n",
                  Srb->Cdb[0]));

       status = SRB_STATUS_INVALID_REQUEST;

    } // end switch

    return status;

} // end IdeSendCommand()

VOID
IdeMediaStatus(
    BOOLEAN EnableMSN,
    IN PVOID HwDeviceExtension,
    ULONG Channel
    )
/*++

Routine Description:

    Enables disables media status notification

Arguments:

HwDeviceExtension - ATAPI driver storage.

--*/

{
    PHW_DEVICE_EXTENSION deviceExtension = HwDeviceExtension;
    PIDE_REGISTERS_1     baseIoAddress = deviceExtension->BaseIoAddress1[Channel >> 1];
    UCHAR statusByte,errorByte;


    if (EnableMSN == TRUE){

        //
        // If supported enable Media Status Notification support
        //

        if ((deviceExtension->DeviceFlags[Channel] & DFLAGS_REMOVABLE_DRIVE)) {

            //
            // enable
            //
            ScsiPortWritePortUchar((PUCHAR)baseIoAddress + 1,(UCHAR) (0x95));
            ScsiPortWritePortUchar(&baseIoAddress->Command,
                                   IDE_COMMAND_ENABLE_MEDIA_STATUS);

            WaitOnBaseBusy(baseIoAddress,statusByte);

            if (statusByte & IDE_STATUS_ERROR) {
                //
                // Read the error register.
                //
                errorByte = ScsiPortReadPortUchar((PUCHAR)baseIoAddress + 1);

                DebugPrint((1,
                            "IdeMediaStatus: Error enabling media status. Status %x, error byte %x\n",
                             statusByte,
                             errorByte));
            } else {
                deviceExtension->DeviceFlags[Channel] |= DFLAGS_MEDIA_STATUS_ENABLED;
                DebugPrint((1,"IdeMediaStatus: Media Status Notification Supported\n"));
                deviceExtension->ReturningMediaStatus = 0;

            }

        }
    } else { // end if EnableMSN == TRUE

        //
        // disable if previously enabled
        //
        if ((deviceExtension->DeviceFlags[Channel] & DFLAGS_MEDIA_STATUS_ENABLED)) {

            ScsiPortWritePortUchar((PUCHAR)baseIoAddress + 1,(UCHAR) (0x31));
            ScsiPortWritePortUchar(&baseIoAddress->Command,
                                   IDE_COMMAND_ENABLE_MEDIA_STATUS);

            WaitOnBaseBusy(baseIoAddress,statusByte);
            deviceExtension->DeviceFlags[Channel] &= ~DFLAGS_MEDIA_STATUS_ENABLED;
        }


    }



}

ULONG
IdeBuildSenseBuffer(
    IN PVOID HwDeviceExtension,
    IN PSCSI_REQUEST_BLOCK Srb
    )

/*++

Routine Description:

    Builts an artificial sense buffer to report the results of a GET_MEDIA_STATUS
    command. This function is invoked to satisfy the SCSIOP_REQUEST_SENSE.
Arguments:

    HwDeviceExtension - ATAPI driver storage.
    Srb - System request block.

Return Value:

    SRB status (ALWAYS SUCCESS).

--*/

{
    PHW_DEVICE_EXTENSION deviceExtension = HwDeviceExtension;
    ULONG status;
    PSENSE_DATA  senseBuffer = (PSENSE_DATA)Srb->DataBuffer;


    if (senseBuffer){


        if(deviceExtension->ReturningMediaStatus & IDE_ERROR_MEDIA_CHANGE) {

            senseBuffer->ErrorCode = 0x70;
            senseBuffer->Valid     = 1;
            senseBuffer->AdditionalSenseLength = 0xb;
            senseBuffer->SenseKey =  SCSI_SENSE_UNIT_ATTENTION;
            senseBuffer->AdditionalSenseCode = SCSI_ADSENSE_MEDIUM_CHANGED;
            senseBuffer->AdditionalSenseCodeQualifier = 0;
        } else if(deviceExtension->ReturningMediaStatus & IDE_ERROR_MEDIA_CHANGE_REQ) {

            senseBuffer->ErrorCode = 0x70;
            senseBuffer->Valid     = 1;
            senseBuffer->AdditionalSenseLength = 0xb;
            senseBuffer->SenseKey =  SCSI_SENSE_UNIT_ATTENTION;
            senseBuffer->AdditionalSenseCode = SCSI_ADSENSE_MEDIUM_CHANGED;
            senseBuffer->AdditionalSenseCodeQualifier = 0;
        } else if(deviceExtension->ReturningMediaStatus & IDE_ERROR_END_OF_MEDIA) {

            senseBuffer->ErrorCode = 0x70;
            senseBuffer->Valid     = 1;
            senseBuffer->AdditionalSenseLength = 0xb;
            senseBuffer->SenseKey =  SCSI_SENSE_NOT_READY;
            senseBuffer->AdditionalSenseCode = SCSI_ADSENSE_NO_MEDIA_IN_DEVICE;
            senseBuffer->AdditionalSenseCodeQualifier = 0;
        } else if(deviceExtension->ReturningMediaStatus & IDE_ERROR_DATA_ERROR) {

            senseBuffer->ErrorCode = 0x70;
            senseBuffer->Valid     = 1;
            senseBuffer->AdditionalSenseLength = 0xb;
            senseBuffer->SenseKey =  SCSI_SENSE_DATA_PROTECT;
            senseBuffer->AdditionalSenseCode = 0;
            senseBuffer->AdditionalSenseCodeQualifier = 0;
        }
        return SRB_STATUS_SUCCESS;
    }
    return SRB_STATUS_ERROR;

}// End of IdeBuildSenseBuffer




BOOLEAN
AtapiStartIo(
    IN PVOID HwDeviceExtension,
    IN PSCSI_REQUEST_BLOCK Srb
    )

/*++

Routine Description:

    This routine is called from the SCSI port driver synchronized
    with the kernel to start an IO request.

Arguments:

    HwDeviceExtension - HBA miniport driver's adapter data storage
    Srb - IO request packet

Return Value:

    TRUE

--*/

{
    PHW_DEVICE_EXTENSION deviceExtension = HwDeviceExtension;
    ULONG status;

    // enable interrupt
    if (deviceExtension->IrqSharing)
        ScsiPortWritePortUchar(&deviceExtension->BaseIoAddress1[0]->DmaReg, 0x00);

    //
    // Determine which function.
    //

    switch (Srb->Function) {

    case SRB_FUNCTION_EXECUTE_SCSI:

        //
        // Sanity check. Only one request can be outstanding on a
        // controller.
        //

        if (deviceExtension->CurrentSrb) {

            DebugPrint((1,
                       "AtapiStartIo: Already have a request!\n"));
            Srb->SrbStatus = SRB_STATUS_BUSY;
            ScsiPortNotification(RequestComplete,
                                 deviceExtension,
                                 Srb);
            return FALSE;
        }

        //
        // Indicate that a request is active on the controller.
        //

        deviceExtension->CurrentSrb = Srb;

        //
        // Send command to device.
        //

        if (deviceExtension->DeviceFlags[Srb->TargetId] & DFLAGS_ATAPI_DEVICE) {

           status = AtapiSendCommand(HwDeviceExtension,
                                     Srb);

        } else if (deviceExtension->DeviceFlags[Srb->TargetId] & DFLAGS_DEVICE_PRESENT) {

           status = IdeSendCommand(HwDeviceExtension,
                                   Srb);
        } else {

            status = SRB_STATUS_SELECTION_TIMEOUT;
        }

        break;

    case SRB_FUNCTION_ABORT_COMMAND:

        //
        // Verify that SRB to abort is still outstanding.
        //

        if (!deviceExtension->CurrentSrb) {

            DebugPrint((1, "AtapiStartIo: SRB to abort already completed\n"));

            //
            // Complete abort SRB.
            //

            status = SRB_STATUS_ABORT_FAILED;

            break;
        }

        //
        // Abort function indicates that a request timed out.
        // Call reset routine. Card will only be reset if
        // status indicates something is wrong.
        // Fall through to reset code.
        //

    case SRB_FUNCTION_RESET_BUS:

        //
        // Reset Atapi and SCSI bus.
        //

        DebugPrint((1, "AtapiStartIo: Reset bus request received\n"));

        if (!AtapiResetController(deviceExtension,
                             Srb->PathId)) {

              DebugPrint((1,"AtapiStartIo: Reset bus failed\n"));

            //
            // Log reset failure.
            //

            ScsiPortLogError(
                HwDeviceExtension,
                NULL,
                0,
                0,
                0,
                SP_INTERNAL_ADAPTER_ERROR,
                5 << 8
                );

              status = SRB_STATUS_ERROR;

        } else {

              status = SRB_STATUS_SUCCESS;
        }

        break;

    case SRB_FUNCTION_IO_CONTROL:

        if (deviceExtension->CurrentSrb) {

            DebugPrint((1,
                       "AtapiStartIo: Already have a request!\n"));
            Srb->SrbStatus = SRB_STATUS_BUSY;
            ScsiPortNotification(RequestComplete,
                                 deviceExtension,
                                 Srb);
            return FALSE;
        }

        //
        // Indicate that a request is active on the controller.
        //

        deviceExtension->CurrentSrb = Srb;

        if (AtapiStringCmp( ((PSRB_IO_CONTROL)(Srb->DataBuffer))->Signature,"SCSIDISK",strlen("SCSIDISK"))) {

            DebugPrint((1,
                        "AtapiStartIo: IoControl signature incorrect. Send %s, expected %s\n",
                        ((PSRB_IO_CONTROL)(Srb->DataBuffer))->Signature,
                        "SCSIDISK"));

            status = SRB_STATUS_INVALID_REQUEST;
            break;
        }

        switch (((PSRB_IO_CONTROL)(Srb->DataBuffer))->ControlCode) {

            case IOCTL_SCSI_MINIPORT_SMART_VERSION: {

                PGETVERSIONINPARAMS versionParameters = (PGETVERSIONINPARAMS)(((PUCHAR)Srb->DataBuffer) + sizeof(SRB_IO_CONTROL));
                UCHAR deviceNumber;

                //
                // Version and revision per SMART 1.03
                //

                versionParameters->bVersion = 1;
                versionParameters->bRevision = 1;
                versionParameters->bReserved = 0;

                //
                // Indicate that support for IDE IDENTIFY, ATAPI IDENTIFY and SMART commands.
                //

                versionParameters->fCapabilities = (CAP_ATA_ID_CMD | CAP_ATAPI_ID_CMD | CAP_SMART_CMD);

                //
                // This is done because of how the IOCTL_SCSI_MINIPORT
                // determines 'targetid's'. Disk.sys places the real target id value
                // in the DeviceMap field. Once we do some parameter checking, the value passed
                // back to the application will be determined.
                //

                deviceNumber = versionParameters->bIDEDeviceMap;

                if (!(deviceExtension->DeviceFlags[Srb->TargetId] & DFLAGS_DEVICE_PRESENT) ||
                    (deviceExtension->DeviceFlags[Srb->TargetId] & DFLAGS_ATAPI_DEVICE)) {

                    status = SRB_STATUS_SELECTION_TIMEOUT;
                    break;
                }

                //
                // NOTE: This will only set the bit
                // corresponding to this drive's target id.
                // The bit mask is as follows:
                //
                //     Sec Pri
                //     S M S M
                //     3 2 1 0
                //

                if (deviceExtension->NumberChannels == 1) {
                    if (deviceExtension->PrimaryAddress) {
                        deviceNumber = 1 << Srb->TargetId;
                    } else {
                        deviceNumber = 4 << Srb->TargetId;
                    }
                } else {
                    deviceNumber = 1 << Srb->TargetId;
                }

                versionParameters->bIDEDeviceMap = deviceNumber;

                status = SRB_STATUS_SUCCESS;
                break;
            }

            case IOCTL_SCSI_MINIPORT_IDENTIFY: {

                PSENDCMDOUTPARAMS cmdOutParameters = (PSENDCMDOUTPARAMS)(((PUCHAR)Srb->DataBuffer) + sizeof(SRB_IO_CONTROL));
                SENDCMDINPARAMS   cmdInParameters = *(PSENDCMDINPARAMS)(((PUCHAR)Srb->DataBuffer) + sizeof(SRB_IO_CONTROL));
                ULONG             i;
                UCHAR             targetId;


                if (cmdInParameters.irDriveRegs.bCommandReg == ID_CMD) {

                    //
                    // Extract the target.
                    //

                    targetId = cmdInParameters.bDriveNumber;

                if (!(deviceExtension->DeviceFlags[Srb->TargetId] & DFLAGS_DEVICE_PRESENT) ||
                     (deviceExtension->DeviceFlags[Srb->TargetId] & DFLAGS_ATAPI_DEVICE)) {

                        status = SRB_STATUS_SELECTION_TIMEOUT;
                        break;
                    }

                    //
                    // Zero the output buffer
                    //

                    for (i = 0; i < (sizeof(SENDCMDOUTPARAMS) + IDENTIFY_BUFFER_SIZE - 1); i++) {
                        ((PUCHAR)cmdOutParameters)[i] = 0;
                    }

                    //
                    // Build status block.
                    //

                    cmdOutParameters->cBufferSize = IDENTIFY_BUFFER_SIZE;
                    cmdOutParameters->DriverStatus.bDriverError = 0;
                    cmdOutParameters->DriverStatus.bIDEError = 0;

                    //
                    // Extract the identify data from the device extension.
                    //

                    ScsiPortMoveMemory (cmdOutParameters->bBuffer, &deviceExtension->IdentifyData[targetId], IDENTIFY_DATA_SIZE);

                    status = SRB_STATUS_SUCCESS;


                } else {
                    status = SRB_STATUS_INVALID_REQUEST;
                }
                break;
            }

            case  IOCTL_SCSI_MINIPORT_READ_SMART_ATTRIBS:
            case  IOCTL_SCSI_MINIPORT_READ_SMART_THRESHOLDS:
            case  IOCTL_SCSI_MINIPORT_ENABLE_SMART:
            case  IOCTL_SCSI_MINIPORT_DISABLE_SMART:
            case  IOCTL_SCSI_MINIPORT_RETURN_STATUS:
            case  IOCTL_SCSI_MINIPORT_ENABLE_DISABLE_AUTOSAVE:
            case  IOCTL_SCSI_MINIPORT_SAVE_ATTRIBUTE_VALUES:
            case  IOCTL_SCSI_MINIPORT_EXECUTE_OFFLINE_DIAGS:

                status = IdeSendSmartCommand(HwDeviceExtension,Srb);
                break;

            default :

                status = SRB_STATUS_INVALID_REQUEST;
                break;

        }

        break;

    default:

        //
        // Indicate unsupported command.
        //

        status = SRB_STATUS_INVALID_REQUEST;

        break;

    } // end switch

    //
    // Check if command complete.
    //

    if (status != SRB_STATUS_PENDING) {

        DebugPrint((2,
                   "AtapiStartIo: Srb %x complete with status %x\n",
                   Srb,
                   status));

        //
        // Clear current SRB.
        //

        deviceExtension->CurrentSrb = NULL;

        //
        // Set status in SRB.
        //

        Srb->SrbStatus = (UCHAR)status;

        //
        // Indicate command complete.
        //

        ScsiPortNotification(RequestComplete,
                             deviceExtension,
                             Srb);

        //
        // Indicate ready for next request.
        //

        ScsiPortNotification(NextRequest,
                             deviceExtension,
                             NULL);
    }

    return TRUE;

} // end AtapiStartIo()


SCSI_ADAPTER_CONTROL_STATUS
AtapiAdapterControl(
    IN PVOID HwDeviceExtension,
    IN SCSI_ADAPTER_CONTROL_TYPE ControlType,
    IN PVOID Parameters
    )

/*++

Routine Description:

    This routine is called at various time's by SCSIPort and is used
        to provide a control function over the adapter. Most commonly, NT
        uses this entry point to control the power state of the HBA during
        a hibernation operation.

Arguments:

    HwDeviceExtension - HBA miniport driver's per adapter storage
    Parameters  - This varies by control type, see below.
    ControlType - Indicates which adapter control function should be
                  executed. Conrol Types are detailed below.

Return Value:

     ScsiAdapterControlSuccess - requested ControlType completed successfully
     ScsiAdapterControlUnsuccessful - requested ControlType failed

--*/


{
    PHW_DEVICE_EXTENSION deviceExtension = HwDeviceExtension;
    PSCSI_SUPPORTED_CONTROL_TYPE_LIST ControlTypeList;
    ULONG AdjustedMaxControlType;

    ULONG Index;

    //
    // Default Status
    //
    SCSI_ADAPTER_CONTROL_STATUS Status = ScsiAdapterControlSuccess;

    //
    // Structure defining which functions this miniport supports
    //

#define Atapi_TYPE_MAX  5

    BOOLEAN SupportedConrolTypes[Atapi_TYPE_MAX] = {
        TRUE,   // ScsiQuerySupportedControlTypes
        TRUE,   // ScsiStopAdapter
        TRUE,   // ScsiRestartAdapter
        FALSE,  // ScsiSetBootConfig
        FALSE   // ScsiSetRunningConfig
        };

    //
    // Execute the correct code path based on ControlType
    //
    switch (ControlType) {

        case ScsiQuerySupportedControlTypes:

            DebugPrint((1,"AtapiAdapterControl: Query supported control types\n"));

            //
            // This entry point provides the method by which SCSIPort determines the
            // supported ControlTypes. Parameters is a pointer to a
            // SCSI_SUPPORTED_CONTROL_TYPE_LIST structure. Fill in this structure
            // honoring the size limits.
            //
            ControlTypeList = Parameters;
            AdjustedMaxControlType =
                (ControlTypeList->MaxControlType < Atapi_TYPE_MAX) ?
                ControlTypeList->MaxControlType :
                Atapi_TYPE_MAX;
            for (Index = 0; Index < AdjustedMaxControlType; Index++) {
                ControlTypeList->SupportedTypeList[Index] =
                    SupportedConrolTypes[Index];
            }
            break;

        case ScsiStopAdapter:

            DebugPrint((1,"AtapiAdapterControl: Stop adapter\n"));

            //
            // This entry point  is called by SCSIPort when it needs to stop/disable
            // the HBA. Parameters is a pointer to the HBA's HwDeviceExtension. The adapter
            // has already been quiesced by SCSIPort (i.e. no outstanding SRBs). Hence the adapter
            // should abort/complete any internally generated commands, disable adapter interrupts
            // and optionally power down the adapter.
            //

            //
            // It is not possible to disable interrupts. The alternative is to
            // reset the adapter, clear any remaining interrupts and return success.
            //

            if (deviceExtension->CurrentSrb) {

#ifdef  DBG
             // _asm int 3;
#endif
                AtapiResetController(deviceExtension,deviceExtension->CurrentSrb->PathId);
            }

            break;


        case ScsiRestartAdapter:

            DebugPrint((1,"AtapiAdapterControl: Restart adapter\n"));

            //
            // This entry point is called by SCSIPort when it needs to re-enable
            // a previously stopped adapter. In the generic case, previously
            // suspended IO operations should be restarted and the adapter's
            // previous configuration should be reinstated. Our hardware device
            // extension and uncached extensions have been preserved so no
            // actual driver software reinitialization is necesarry.
            //

            AtapiResetController(deviceExtension,0);
            break;

        case ScsiSetBootConfig:

            DebugPrint((1,"AtapiAdapterControl: Set boot config\n"));

            Status = ScsiAdapterControlUnsuccessful;
            break;

        case ScsiSetRunningConfig:

            DebugPrint((1,"AtapiAdapterControl: Set running config\n"));

            Status = ScsiAdapterControlUnsuccessful;
            break;

        case ScsiAdapterControlMax:

            DebugPrint((1,"AtapiAdapterControl: Adapter control max\n"));

            Status = ScsiAdapterControlUnsuccessful;
            break;

        default:
            Status = ScsiAdapterControlUnsuccessful;
            break;
    }

    return Status;
}


ULONG
DriverEntry(
    IN PVOID DriverObject,
    IN PVOID Argument2
    )

/*++

Routine Description:

    Installable driver initialization entry point for system.

Arguments:

    Driver Object

Return Value:

    Status from ScsiPortInitialize()

--*/

{
    HW_INITIALIZATION_DATA hwInitializationData;
    ULONG                  adapterCount;
    ULONG                  isaStatus;
    ULONG                  pciStatus;


    DebugPrint((1,"\n\nCardBus/PCMCIA IDE Miniport Driver\n"));

    //
    // Zero out structure.
    //

    AtapiZeroMemory(((PUCHAR)&hwInitializationData), sizeof(HW_INITIALIZATION_DATA));

    //
    // Set size of hwInitializationData.
    //

    hwInitializationData.HwInitializationDataSize =
      sizeof(HW_INITIALIZATION_DATA);

    //
    // Set entry points.
    //

    hwInitializationData.HwInitialize = AtapiHwInitialize;
    hwInitializationData.HwResetBus = AtapiResetController;
    hwInitializationData.HwStartIo = AtapiStartIo;
    hwInitializationData.HwInterrupt = AtapiInterrupt;
    hwInitializationData.HwAdapterControl = AtapiAdapterControl;

    //
    // Specify size of extensions.
    //

    hwInitializationData.DeviceExtensionSize = sizeof(HW_DEVICE_EXTENSION);
    hwInitializationData.SpecificLuExtensionSize = sizeof(HW_LU_EXTENSION);

    //
    // Indicate PIO device.
    //

    hwInitializationData.MapBuffers = TRUE;

    hwInitializationData.HwFindAdapter = AtapiFindController;
    hwInitializationData.NumberOfAccessRanges = 2;

    hwInitializationData.AdapterInterfaceType = Isa;
    adapterCount = 0;

    isaStatus = ScsiPortInitialize(DriverObject,
                                   Argument2,
                                   &hwInitializationData,
                                   &adapterCount);

    hwInitializationData.AdapterInterfaceType = PCIBus;
    adapterCount = 0;

    pciStatus = ScsiPortInitialize(DriverObject,
                                   Argument2,
                                   &hwInitializationData,
                                   &adapterCount);

    //
    // Return the smaller status.
    //

    return(pciStatus < isaStatus ? pciStatus : isaStatus);

} // end DriverEntry()



LONG
AtapiStringCmp (
    PCHAR FirstStr,
    PCHAR SecondStr,
    ULONG Count
    )
{
    UCHAR  first ,last;

    if (Count) {
        do {

            //
            // Get next char.
            //

            first = *FirstStr++;
            last = *SecondStr++;

            if (first != last) {

                //
                // If no match, try lower-casing.
                //

                if (first>='A' && first<='Z') {
                    first = first - 'A' + 'a';
                }
                if (last>='A' && last<='Z') {
                    last = last - 'A' + 'a';
                }
                if (first != last) {

                    //
                    // No match
                    //

                    return first - last;
                }
            }
        }while (--Count && first);
    }

    return 0;
}


VOID
AtapiZeroMemory(
    IN PCHAR Buffer,
    IN ULONG Count
    )
{
    ULONG i;

    for (i = 0; i < Count; i++) {
        Buffer[i] = 0;
    }
}


VOID
AtapiHexToString (
    IN ULONG Value,
    IN OUT PCHAR *Buffer
    )
{
    PCHAR  string;
    PCHAR  firstdig;
    CHAR   temp;
    ULONG i;
    USHORT digval;

    string = *Buffer;

    firstdig = string;

    for (i = 0; i < 4; i++) {
        digval = (USHORT)(Value % 16);
        Value /= 16;

        //
        // convert to ascii and store. Note this will create
        // the buffer with the digits reversed.
        //

        if (digval > 9) {
            *string++ = (char) (digval - 10 + 'a');
        } else {
            *string++ = (char) (digval + '0');
        }

    }

    //
    // Reverse the digits.
    //

    *string-- = '\0';

    do {
        temp = *string;
        *string = *firstdig;
        *firstdig = temp;
        --string;
        ++firstdig;
    } while (firstdig < string);
}



PSCSI_REQUEST_BLOCK
BuildMechanismStatusSrb (
    IN PVOID HwDeviceExtension,
    IN ULONG PathId,
    IN ULONG TargetId
    )
{
    PHW_DEVICE_EXTENSION deviceExtension = HwDeviceExtension;
    PSCSI_REQUEST_BLOCK srb;
    PCDB cdb;

    srb = &deviceExtension->InternalSrb;

    AtapiZeroMemory((PUCHAR) srb, sizeof(SCSI_REQUEST_BLOCK));

    srb->PathId     = (UCHAR) PathId;
    srb->TargetId   = (UCHAR) TargetId;
    srb->Function   = SRB_FUNCTION_EXECUTE_SCSI;
    srb->Length     = sizeof(SCSI_REQUEST_BLOCK);

    //
    // Set flags to disable synchronous negociation.
    //
    srb->SrbFlags = SRB_FLAGS_DATA_IN | SRB_FLAGS_DISABLE_SYNCH_TRANSFER;

    //
    // Set timeout to 2 seconds.
    //
    srb->TimeOutValue = 4;

    srb->CdbLength          = 6;
    srb->DataBuffer         = &deviceExtension->MechStatusData;
    srb->DataTransferLength = sizeof(MECHANICAL_STATUS_INFORMATION_HEADER);

    //
    // Set CDB operation code.
    //
    cdb = (PCDB)srb->Cdb;
    cdb->MECH_STATUS.OperationCode       = SCSIOP_MECHANISM_STATUS;
    cdb->MECH_STATUS.AllocationLength[1] = sizeof(MECHANICAL_STATUS_INFORMATION_HEADER);

    return srb;
}


PSCSI_REQUEST_BLOCK
BuildRequestSenseSrb (
    IN PVOID HwDeviceExtension,
    IN ULONG PathId,
    IN ULONG TargetId
    )
{
    PHW_DEVICE_EXTENSION deviceExtension = HwDeviceExtension;
    PSCSI_REQUEST_BLOCK srb;
    PCDB cdb;

    srb = &deviceExtension->InternalSrb;

    AtapiZeroMemory((PUCHAR) srb, sizeof(SCSI_REQUEST_BLOCK));

    srb->PathId     = (UCHAR) PathId;
    srb->TargetId   = (UCHAR) TargetId;
    srb->Function   = SRB_FUNCTION_EXECUTE_SCSI;
    srb->Length     = sizeof(SCSI_REQUEST_BLOCK);

    //
    // Set flags to disable synchronous negociation.
    //
    srb->SrbFlags = SRB_FLAGS_DATA_IN | SRB_FLAGS_DISABLE_SYNCH_TRANSFER;

    //
    // Set timeout to 2 seconds.
    //
    srb->TimeOutValue = 4;

    srb->CdbLength          = 6;
    srb->DataBuffer         = &deviceExtension->MechStatusSense;
    srb->DataTransferLength = sizeof(SENSE_DATA);

    //
    // Set CDB operation code.
    //
    cdb = (PCDB)srb->Cdb;
    cdb->CDB6INQUIRY.OperationCode    = SCSIOP_REQUEST_SENSE;
    cdb->CDB6INQUIRY.AllocationLength = sizeof(SENSE_DATA);

    return srb;
}


ULONG
AtapiParseArgumentString(
    IN PCHAR String,
    IN PCHAR KeyWord
    )

/*++

Routine Description:

    This routine will parse the string for a match on the keyword, then
    calculate the value for the keyword and return it to the caller.

Arguments:

    String - The ASCII string to parse.
    KeyWord - The keyword for the value desired.

Return Values:

    Zero if value not found
    Value converted from ASCII to binary.

--*/

{
    PCHAR cptr;
    PCHAR kptr;
    ULONG value;
    ULONG stringLength = 0;
    ULONG keyWordLength = 0;
    ULONG index;

    //
    // Calculate the string length and lower case all characters.
    //
    cptr = String;
    while (*cptr) {

        if (*cptr >= 'A' && *cptr <= 'Z') {
            *cptr = *cptr + ('a' - 'A');
        }
        cptr++;
        stringLength++;
    }

    //
    // Calculate the keyword length and lower case all characters.
    //
    cptr = KeyWord;
    while (*cptr) {

        if (*cptr >= 'A' && *cptr <= 'Z') {
            *cptr = *cptr + ('a' - 'A');
        }
        cptr++;
        keyWordLength++;
    }

    if (keyWordLength > stringLength) {

        //
        // Can't possibly have a match.
        //
        return 0;
    }

    //
    // Now setup and start the compare.
    //
    cptr = String;

ContinueSearch:
    //
    // The input string may start with white space.  Skip it.
    //
    while (*cptr == ' ' || *cptr == '\t') {
        cptr++;
    }

    if (*cptr == '\0') {

        //
        // end of string.
        //
        return 0;
    }

    kptr = KeyWord;
    while (*cptr++ == *kptr++) {

        if (*(cptr - 1) == '\0') {

            //
            // end of string
            //
            return 0;
        }
    }

    if (*(kptr - 1) == '\0') {

        //
        // May have a match backup and check for blank or equals.
        //

        cptr--;
        while (*cptr == ' ' || *cptr == '\t') {
            cptr++;
        }

        //
        // Found a match.  Make sure there is an equals.
        //
        if (*cptr != '=') {

            //
            // Not a match so move to the next semicolon.
            //
            while (*cptr) {
                if (*cptr++ == ';') {
                    goto ContinueSearch;
                }
            }
            return 0;
        }

        //
        // Skip the equals sign.
        //
        cptr++;

        //
        // Skip white space.
        //
        while ((*cptr == ' ') || (*cptr == '\t')) {
            cptr++;
        }

        if (*cptr == '\0') {

            //
            // Early end of string, return not found
            //
            return 0;
        }

        if (*cptr == ';') {

            //
            // This isn't it either.
            //
            cptr++;
            goto ContinueSearch;
        }

        value = 0;
        if ((*cptr == '0') && (*(cptr + 1) == 'x')) {

            //
            // Value is in Hex.  Skip the "0x"
            //
            cptr += 2;
            for (index = 0; *(cptr + index); index++) {

                if (*(cptr + index) == ' ' ||
                    *(cptr + index) == '\t' ||
                    *(cptr + index) == ';') {
                     break;
                }

                if ((*(cptr + index) >= '0') && (*(cptr + index) <= '9')) {
                    value = (16 * value) + (*(cptr + index) - '0');
                } else {
                    if ((*(cptr + index) >= 'a') && (*(cptr + index) <= 'f')) {
                        value = (16 * value) + (*(cptr + index) - 'a' + 10);
                    } else {

                        //
                        // Syntax error, return not found.
                        //
                        return 0;
                    }
                }
            }
        } else {

            //
            // Value is in Decimal.
            //
            for (index = 0; *(cptr + index); index++) {

                if (*(cptr + index) == ' ' ||
                    *(cptr + index) == '\t' ||
                    *(cptr + index) == ';') {
                    break;
                }

                if ((*(cptr + index) >= '0') && (*(cptr + index) <= '9')) {
                    value = (10 * value) + (*(cptr + index) - '0');
                } else {

                    //
                    // Syntax error return not found.
                    //
                    return 0;
                }
            }
        }

        return value;
    } else {

        //
        // Not a match check for ';' to continue search.
        //
        while (*cptr) {
            if (*cptr++ == ';') {
                goto ContinueSearch;
            }
        }

        return 0;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\port\scsi\miniport\hipoint\hpt3xx\winnt\winio.c ===
/***************************************************************************
 * File:          winio.c
 * Description:   include routine for windows platform
 * Author:        DaHai Huang    (DH)
 * Dependence:    none
 * Copyright (c)  2000 HighPoint Technologies, Inc. All rights reserved
 * History:
 *		11/08/2000	HS.Zhang	Added this header
 *		3/02/2001	gmm			Return array info instead of disk on INQUIRY cmd
 *
 ***************************************************************************/
#include "global.h"

void HptDeviceSpecifiedIoControl(IN PDevice pDevice, IN PSCSI_REQUEST_BLOCK pSrb);

/******************************************************************
 * Start Windows Command
 *******************************************************************/
void WinStartCommand( IN PDevice pDev, IN PSCSI_REQUEST_BLOCK Srb)
{
	PSrbExtension pSrbExt = (PSrbExtension)Srb->SrbExtension;
	
	if(Srb->Function == SRB_FUNCTION_IO_CONTROL){
		HptDeviceSpecifiedIoControl(pDev, Srb);
	}
#ifdef WIN95
	else{
		pIOP  pIop;
		DCB*  pDcb;

		pIop = *(pIOP *)((int)Srb+0x40);
		pDcb = (DCB*)pIop->IOP_physical_dcb;

		if(pDev->DeviceFlags & DFLAGS_LS120)  
			pIop->IOP_timer_orig = pIop->IOP_timer = 31;

		Srb->ScsiStatus = SCSISTAT_GOOD;
		pIop->IOP_ior.IOR_status = IORS_SUCCESS;
	}											 
#endif												 
#ifdef SUPPORT_ATAPI
	if(pDev->DeviceFlags & DFLAGS_ATAPI){ 
		Start_Atapi(pDev, Srb);
	}else
#endif // SUPPORT_ATAPI		
	IdeSendCommand(pDev, Srb);

	/*
	 * if SRB_WFLAGS_ARRAY_IO_STARTED set, it will be handled by DeviceInterrupt 
	 * in StartArrayIo(), we shall not handle it here again
	 */
	if (Srb->SrbStatus != SRB_STATUS_PENDING &&
		!(pSrbExt->WorkingFlags & SRB_WFLAGS_ARRAY_IO_STARTED)){
		/* DeviceInterrupt() expects pSrbExt->member_status set */
		pSrbExt->member_status = Srb->SrbStatus;
		DeviceInterrupt(pDev, Srb);
	}
}

void FlushDrive(PDevice pDev, DWORD flag)
{
	if (!(pDev->DeviceFlags2 & DFLAGS_DEVICE_DISABLED)) {
		NonIoAtaCmd(pDev, IDE_COMMAND_FLUSH_CACHE);
	/*
	 * SRB_FUNCTION_SHUTDOWN will only be called at system shutdown.
	 * It's not much useful to power down the drive
	 */
#if 0
		if(flag & DFLAGS_WIN_SHUTDOWN)
			NonIoAtaCmd(pDev, IDE_COMMAND_STANDBY_IMMEDIATE);
#endif
	}
}

void FlushArray(PVirtualDevice pArray, DWORD flag)
{
	int i;
	PDevice pDev;
loop:
	for(i = 0; i < MAX_MEMBERS; i++) {
		if((pDev = pArray->pDevice[i]) == 0)
			continue;
		if(i == MIRROR_DISK) {
			if(pArray->arrayType == VD_RAID01_MIRROR)
				return;
			if(pArray->arrayType == VD_RAID_01_2STRIPE) {
				pArray = pDev->pArray;
				goto loop;
			}
		}
		FlushDrive(pDev, flag);
	}
}

/******************************************************************
 * Check Next Request
 *******************************************************************/

void CheckNextRequest(PChannel pChan, PDevice pWorkDev)
{
	PDevice pDev;
	PSCSI_REQUEST_BLOCK Srb;
	PSrbExtension pSrbExt;

	if (btr(pChan->exclude_index) == 0) {
		//KdPrint(("! call CheckNextRequest when Channel busy!"));
		return;
	}

	pDev = (pWorkDev==pChan->pDevice[0])? pChan->pDevice[1] : pChan->pDevice[0];
	if (pDev) {
check_queue:
		while (Srb=GetCommandFromQueue(pDev)) {

			//KdPrint(("StartCommandFromQueue(%d)", pDev->ArrayNum));
			
			pSrbExt = Srb->SrbExtension;

			if (pDev->DeviceFlags2 & DFLAGS_DEVICE_DISABLED) {
				pSrbExt->member_status = SRB_STATUS_NO_DEVICE;
				DeviceInterrupt(pDev, Srb);
				continue;
			}

			if (pSrbExt->WorkingFlags & SRB_WFLAGS_ARRAY_IO_STARTED) {
				
				if (pDev->DeviceFlags & DFLAGS_ARRAY_DISK) {
					if(pDev->pArray->arrayType == VD_SPAN){ 
						Span_Lba_Sectors(pDev, pSrbExt);
					}else{
						Stripe_Lba_Sectors(pDev, pSrbExt);
					}
				} else {
					pChan->Lba = pSrbExt->Lba;
					pChan->nSector = pSrbExt->nSector;
				}
			}
			else {
				pChan->Lba = pSrbExt->Lba;
				pChan->nSector = pSrbExt->nSector;
			}
	
			StartIdeCommand(pDev ARG_SRB);
			if(pSrbExt->member_status != SRB_STATUS_PENDING) {
				btr(pChan->exclude_index); /* reacquire the channel! */
				DeviceInterrupt(pDev, Srb);
			}
			else {
				/* waiting for INTRQ */
				return;
			}
		}
	}
	if (pDev!=pWorkDev) {
		pDev = pWorkDev;
		goto check_queue;
	}

	bts(pChan->exclude_index);
	//KdPrint(("CheckNextRequest(%d): nothing", pDev->ArrayNum));
}

/******************************************************************
 * exclude
 *******************************************************************/

int __declspec(naked) __fastcall btr (ULONG locate)
{
   _asm {
       xor  eax,  eax
       btr  excluded_flags, ecx
       adc  eax, eax
       ret
   }
}     

void __declspec(naked) __fastcall bts (ULONG locate)
{
   _asm {
       bts  excluded_flags, ecx
       ret
   }
}     

/******************************************************************
 * Map Lba to CHS
 *******************************************************************/

ULONG __declspec(naked) __fastcall MapLbaToCHS(ULONG Lba, WORD sectorXhead, BYTE head)
{
	 _asm	{
		  xchg    ecx, edx
        mov     eax, edx
        shr     edx, 16
        div     cx
        xchg    eax, edx
        div     byte ptr [esp+4]
        and     ax, 3F0Fh
        inc     ah
        xchg    al, ah
        xchg    dl, dh
        xchg    dh, ah
        ret
    } 
}

/******************************************************************
 * Ide Send command
 *******************************************************************/

void
IdeSendCommand(IN PDevice pDev, IN PSCSI_REQUEST_BLOCK Srb)
{
	PChannel             pChan = pDev->pChannel;
	PIDE_REGISTERS_1     IoPort = pChan->BaseIoAddress1;
	PIDE_REGISTERS_2     ControlPort = pChan->BaseIoAddress2;
	LONG                 MediaStatus;
	ULONG   i;
	PCDB    cdb = (PCDB)Srb->Cdb;
	PMODE_PARAMETER_HEADER   modeData;
	LOC_SRBEXT_PTR

	if (pDev->DeviceFlags & DFLAGS_REMOVABLE_DRIVE) {

		if(pDev->ReturningMediaStatus & IDE_ERROR_END_OF_MEDIA) {
			Srb->ScsiStatus = SCSISTAT_CHECK_CONDITION;
			Srb->SrbStatus = SRB_STATUS_ERROR;
			return;
		}

		if(Srb->Cdb[0] == SCSIOP_START_STOP_UNIT) {
			if (cdb->START_STOP.LoadEject == 1){
				if (btr(pChan->exclude_index)) {
					OutPort(pChan->BaseBMI+0x7A, 0x10);
					NonIoAtaCmd(pDev, IDE_COMMAND_MEDIA_EJECT);
					OutPort(pChan->BaseBMI+0x7A, 0);
					bts(pChan->exclude_index);
					Srb->SrbStatus = SRB_STATUS_SUCCESS;
				} else
					Srb->SrbStatus = SRB_STATUS_BUSY;
				return;
			}
		}

		if((pDev->DeviceFlags & DFLAGS_MEDIA_STATUS_ENABLED) != 0) {
	
			if(Srb->Cdb[0] == SCSIOP_REQUEST_SENSE) {
				Srb->SrbStatus = IdeBuildSenseBuffer(pDev, Srb);
				return;
			}
	
			if(Srb->Cdb[0] == SCSIOP_MODE_SENSE || 
			   Srb->Cdb[0] == SCSIOP_TEST_UNIT_READY) {
			   	
			   	if (btr(pChan->exclude_index)==0) {
			   		Srb->SrbStatus = SRB_STATUS_BUSY;
			   		return;
			   	}
	
				OutPort(pChan->BaseBMI+0x7A, 0x10);
				MediaStatus = GetMediaStatus(pDev);
				OutPort(pChan->BaseBMI+0x7A, 0);
				bts(pChan->exclude_index);
	
				if ((MediaStatus & (IDE_STATUS_ERROR << 8)) == 0){ 
					pDev->ReturningMediaStatus = 0;				  
				}else{
					if(Srb->Cdb[0] == SCSIOP_MODE_SENSE) {
						if (MediaStatus & IDE_ERROR_DATA_ERROR) {
							//
							// media is write-protected, set bit in mode sense buffer
							//
							modeData = (PMODE_PARAMETER_HEADER)Srb->DataBuffer;
	
							Srb->DataTransferLength = sizeof(MODE_PARAMETER_HEADER);
							modeData->DeviceSpecificParameter |= MODE_DSP_WRITE_PROTECT;
						}
					} else{
						if ((UCHAR)MediaStatus != IDE_ERROR_DATA_ERROR) {
							//
							// Request sense buffer to be build
							//
							Srb->SrbStatus = MapAtaErrorToOsError((UCHAR)MediaStatus, Srb);
							return;
						}  
					}
				}
			}
			Srb->SrbStatus = SRB_STATUS_SUCCESS;
			return;
		} else if(Srb->Cdb[0] == 0x1A) {
			struct _Mode_6 *pMode6;
			pMode6 = (struct _Mode_6 *)Srb->DataBuffer;
			ZeroMemory(Srb->DataBuffer, Srb->DataTransferLength);
			i = (pDev->pArray)? pDev->pArray->capacity : pDev->capacity;
			pMode6->DataLength = 11;
			pMode6->BlockSize = 8;
			pMode6->LBA[0] = (UCHAR)(i >> 24);
			pMode6->LBA[1]	= (UCHAR)(i >> 16);
			pMode6->LBA[2]	= (UCHAR)(i >> 8);
			pMode6->LBA[3]	= (UCHAR)i;
			pMode6->Length[1]	= 2;
			Srb->SrbStatus = SRB_STATUS_SUCCESS;
			return;
		}
	}
	
	switch (Srb->Cdb[0]) {
		case SCSIOP_INQUIRY:
		{
			PINQUIRYDATA inquiryData = Srb->DataBuffer;
#ifdef WIN95
			DCB_COMMON* pDcb=(*(IOP**)((int)Srb+0x40))->IOP_physical_dcb;
			pDcb->DCB_device_flags |= DCB_DEV_SPINDOWN_SUPPORTED;
			if(pDev->DeviceFlags & DFLAGS_LS120) 
				pDcb->DCB_device_flags2 |= 0x40;
#endif
			ZeroMemory(Srb->DataBuffer, Srb->DataTransferLength);
			inquiryData->AdditionalLength = (UCHAR)Srb->DataTransferLength-5;
			inquiryData->CommandQueue = 1;
			inquiryData->DeviceType = DIRECT_ACCESS_DEVICE;
			if ((pDev->DeviceFlags & DFLAGS_REMOVABLE_DRIVE) || 
				  (pDev->IdentifyData.GeneralConfiguration & 0x80))
				inquiryData->RemovableMedia = 1;
			if (pDev->pArray) {
#ifdef ADAPTEC
				memcpy(&inquiryData->VendorId, "Adaptec ", 8);
#else
				memcpy(&inquiryData->VendorId, "HPT37x  ", 8);
#endif
				switch(pDev->pArray->arrayType){
				case VD_RAID_0_STRIPE:
					memcpy(&inquiryData->ProductId, "RAID 0 Array    ", 16);
					break;
				case VD_RAID_1_MIRROR:
					memcpy(&inquiryData->ProductId, "RAID 1 Array    ", 16);
					break;
				case VD_RAID_01_2STRIPE:
				case VD_RAID_01_1STRIPE:
				case VD_RAID01_MIRROR:
					memcpy(&inquiryData->ProductId, "RAID 0/1 Array  ", 16);
					break;
				case VD_SPAN:
					memcpy(&inquiryData->ProductId, "JBOD Array      ", 16);
					break;
				}
				memcpy(&inquiryData->ProductRevisionLevel, "2.00", 4);
			}
			else {
				PUCHAR p = inquiryData->VendorId;
				for (i = 0; i < 20; i += 2) {
					*p++ = ((PUCHAR)pDev->IdentifyData.ModelNumber)[i + 1];
					*p++ = ((PUCHAR)pDev->IdentifyData.ModelNumber)[i];
				}
				for (i = 0; i < 4; i++) *p++ = ' ';
				for (i = 0; i < 4; i += 2) {
					inquiryData->ProductRevisionLevel[i] =
						((PUCHAR)pDev->IdentifyData.FirmwareRevision)[i+1];
					inquiryData->ProductRevisionLevel[i+1] =
						((PUCHAR)pDev->IdentifyData.FirmwareRevision)[i];
				}
			}
			Srb->SrbStatus = SRB_STATUS_SUCCESS;
			return;
		}
		case SCSIOP_READ_CAPACITY:
			//
			// Claim 512 byte blocks (big-endian).
			//
			((PREAD_CAPACITY_DATA)Srb->DataBuffer)->BytesPerBlock = 0x20000;
			i = (pDev->pArray)? pDev->pArray->capacity : pDev->capacity;

			((PREAD_CAPACITY_DATA)Srb->DataBuffer)->LogicalBlockAddress =
				(((PUCHAR)&i)[0] << 24) |  (((PUCHAR)&i)[1] << 16) |
				(((PUCHAR)&i)[2] << 8) | ((PUCHAR)&i)[3];

		case SCSIOP_START_STOP_UNIT:
		case SCSIOP_TEST_UNIT_READY:
			Srb->SrbStatus = SRB_STATUS_SUCCESS;
			return;

		case SCSIOP_READ:
#ifdef SUPPORT_XPRO
			if(Srb->Function != SRB_FUNCTION_IO_CONTROL){
				need_read_ahead = 1;
			}
#endif
		case SCSIOP_WRITE:
		case SCSIOP_VERIFY:
			pSrbExt->Lba = ((PCDB)Srb->Cdb)->CDB10.LogicalBlockByte3 |
						 ((PCDB)Srb->Cdb)->CDB10.LogicalBlockByte2 << 8 |
						 ((PCDB)Srb->Cdb)->CDB10.LogicalBlockByte1 << 16 |
						 ((PCDB)Srb->Cdb)->CDB10.LogicalBlockByte0 << 24;			 
			
			pSrbExt->nSector = ((PCDB)Srb->Cdb)->CDB10.TransferBlocksLsb
						| ((USHORT)((PCDB)Srb->Cdb)->CDB10.TransferBlocksMsb << 8);
			
  			if((pDev->DeviceFlags & DFLAGS_HAS_LOCKED)&&
			   ((pSrbExt->WorkingFlags & SRB_WFLAGS_MUST_DONE) == 0)){

			   	if (pSrbExt->Lba<pDev->nLockedLbaEnd &&
			   		pSrbExt->Lba+pSrbExt->nSector>pDev->nLockedLbaStart) {
					/* 
					 * cannot return busy here, or OS will try before the block get
					 * unlocked and eventualy fail the request.
					 * Move it to a waiting list.
					 */
					pSrbExt->ArraySg[0].SgAddress = (ULONG)pDev->pWaitingSrbList;
					pDev->pWaitingSrbList = Srb;
					ScsiPortNotification(NextLuRequest, 
						pChan->HwDeviceExtension, 
						Srb->PathId, Srb->TargetId, 0);
					return;
				}
			}
			
			NewIdeIoCommand(pDev, Srb);
			return;

		default:
			Srb->SrbStatus = SRB_STATUS_INVALID_REQUEST;

	} // end switch

} // end IdeSendCommand()


/******************************************************************
 * global data
 *******************************************************************/

VOID
IdeMediaStatus(BOOLEAN EnableMSN, IN PDevice pDev)
{
    PChannel             pChan = pDev->pChannel;
    PIDE_REGISTERS_1     IoPort = pChan->BaseIoAddress1;
    PIDE_REGISTERS_2     ControlPort = pChan->BaseIoAddress2;

    if (EnableMSN == TRUE){
        //
        // If supported enable Media Status Notification support
        //
		SelectUnit(IoPort, pDev->UnitId);
        ScsiPortWritePortUchar((PUCHAR)IoPort + 1, (UCHAR)0x95);

        if ((NonIoAtaCmd(pDev, IDE_COMMAND_ENABLE_MEDIA_STATUS) 
             & (IDE_STATUS_ERROR << 8)) == 0) {
            pDev->DeviceFlags |= DFLAGS_MEDIA_STATUS_ENABLED;
            pDev->ReturningMediaStatus = 0;
        }
    }
    else 

    if (pDev->DeviceFlags & DFLAGS_MEDIA_STATUS_ENABLED) {
        //
        // disable if previously enabled
        //
		SelectUnit(IoPort, pDev->UnitId);
        ScsiPortWritePortUchar((PUCHAR)IoPort + 1, (UCHAR)0x31);
        NonIoAtaCmd(pDev, IDE_COMMAND_ENABLE_MEDIA_STATUS);

       pDev->DeviceFlags &= ~DFLAGS_MEDIA_STATUS_ENABLED;
    }
}


/******************************************************************
 * 
 *******************************************************************/

UCHAR
IdeBuildSenseBuffer(IN PDevice pDev, IN PSCSI_REQUEST_BLOCK Srb)

/*++
    Builts an artificial sense buffer to report the results of a
    GET_MEDIA_STATUS command. This function is invoked to satisfy
    the SCSIOP_REQUEST_SENSE.
++*/
{
    PSENSE_DATA senseBuffer = (PSENSE_DATA)Srb->DataBuffer;

    if (senseBuffer) {
        if (pDev->ReturningMediaStatus & IDE_ERROR_MEDIA_CHANGE) {
            senseBuffer->ErrorCode = 0x70;
            senseBuffer->Valid     = 1;
            senseBuffer->AdditionalSenseLength = 0xb;
            senseBuffer->SenseKey  = SCSI_SENSE_UNIT_ATTENTION;
            senseBuffer->AdditionalSenseCode = SCSI_ADSENSE_MEDIUM_CHANGED;
            senseBuffer->AdditionalSenseCodeQualifier = 0;
        }
        else if (pDev->ReturningMediaStatus & IDE_ERROR_MEDIA_CHANGE_REQ) {
            senseBuffer->ErrorCode = 0x70;
            senseBuffer->Valid     = 1;
            senseBuffer->AdditionalSenseLength = 0xb;
            senseBuffer->SenseKey  = SCSI_SENSE_UNIT_ATTENTION;
            senseBuffer->AdditionalSenseCode = SCSI_ADSENSE_MEDIUM_CHANGED;
            senseBuffer->AdditionalSenseCodeQualifier = 0;
        }
        else if (pDev->ReturningMediaStatus & IDE_ERROR_END_OF_MEDIA) {
            senseBuffer->ErrorCode = 0x70;
            senseBuffer->Valid     = 1;
            senseBuffer->AdditionalSenseLength = 0xb;
            senseBuffer->SenseKey  = SCSI_SENSE_NOT_READY;
            senseBuffer->AdditionalSenseCode = SCSI_ADSENSE_NO_MEDIA_IN_DEVICE;
            senseBuffer->AdditionalSenseCodeQualifier = 0;
        }
        else if (pDev->ReturningMediaStatus & IDE_ERROR_DATA_ERROR) {
            senseBuffer->ErrorCode = 0x70;
            senseBuffer->Valid     = 1;
            senseBuffer->AdditionalSenseLength = 0xb;
            senseBuffer->SenseKey  = SCSI_SENSE_DATA_PROTECT;
            senseBuffer->AdditionalSenseCode = 0;
            senseBuffer->AdditionalSenseCodeQualifier = 0;
        }

        return SRB_STATUS_SUCCESS;
    }

    return SRB_STATUS_ERROR;

}// End of IdeBuildSenseBuffer

/******************************************************************
 * Map Ata Error To Windows Error
 *******************************************************************/

UCHAR
MapAtapiErrorToOsError(IN UCHAR errorByte, IN PSCSI_REQUEST_BLOCK Srb)
{
    UCHAR srbStatus;
    UCHAR scsiStatus;

    switch (errorByte >> 4) {
    case SCSI_SENSE_NO_SENSE:

        scsiStatus = 0;

        // OTHERWISE, THE TAPE WOULDN'T WORK
        scsiStatus = SCSISTAT_CHECK_CONDITION;

        srbStatus = SRB_STATUS_ERROR;
        break;

    case SCSI_SENSE_RECOVERED_ERROR:

        scsiStatus = 0;
        srbStatus = SRB_STATUS_SUCCESS;
        break;

    case SCSI_SENSE_NOT_READY:

        scsiStatus = SCSISTAT_CHECK_CONDITION;
        srbStatus = SRB_STATUS_ERROR;
        break;

    case SCSI_SENSE_MEDIUM_ERROR:

        scsiStatus = SCSISTAT_CHECK_CONDITION;
        srbStatus = SRB_STATUS_ERROR;
        break;

    case SCSI_SENSE_HARDWARE_ERROR:

        scsiStatus = SCSISTAT_CHECK_CONDITION;
        srbStatus = SRB_STATUS_ERROR;
        break;

    case SCSI_SENSE_ILLEGAL_REQUEST:

        scsiStatus = SCSISTAT_CHECK_CONDITION;
        srbStatus = SRB_STATUS_ERROR;
        break;

    case SCSI_SENSE_UNIT_ATTENTION:

        scsiStatus = SCSISTAT_CHECK_CONDITION;
        srbStatus = SRB_STATUS_ERROR;
        break;

    default:
        scsiStatus = 0;

        // OTHERWISE, THE TAPE WOULDN'T WORK
        scsiStatus = SCSISTAT_CHECK_CONDITION;
        srbStatus = SRB_STATUS_ERROR;
        break;
    }

    Srb->ScsiStatus = scsiStatus;

    return srbStatus;
}


UCHAR
MapAtaErrorToOsError(IN UCHAR errorByte, IN PSCSI_REQUEST_BLOCK Srb)
{
    UCHAR srbStatus;
    UCHAR scsiStatus;

    scsiStatus = 0;

    if (errorByte & IDE_ERROR_MEDIA_CHANGE_REQ) {

        scsiStatus = SCSISTAT_CHECK_CONDITION;
        srbStatus = SRB_STATUS_ERROR;
    }

    else if (errorByte & IDE_ERROR_COMMAND_ABORTED) {

        srbStatus = SRB_STATUS_ABORTED;
        scsiStatus = SCSISTAT_CHECK_CONDITION;

        if (Srb->SenseInfoBuffer) {
            PSENSE_DATA  senseBuffer = (PSENSE_DATA)Srb->SenseInfoBuffer;

            senseBuffer->ErrorCode = 0x70;
            senseBuffer->Valid = 1;
            senseBuffer->AdditionalSenseLength = 0xb;
            senseBuffer->SenseKey = SCSI_SENSE_ABORTED_COMMAND;
            senseBuffer->AdditionalSenseCode = 0;
            senseBuffer->AdditionalSenseCodeQualifier = 0;

            srbStatus |= SRB_STATUS_AUTOSENSE_VALID;
        }
    }

    else if (errorByte & IDE_ERROR_END_OF_MEDIA) {

        scsiStatus = SCSISTAT_CHECK_CONDITION;
        srbStatus = SRB_STATUS_ERROR;
    }

    else if (errorByte & IDE_ERROR_ILLEGAL_LENGTH) {

        srbStatus = SRB_STATUS_INVALID_REQUEST;
    }

    else if (errorByte & IDE_ERROR_BAD_BLOCK) {

        srbStatus = SRB_STATUS_ERROR;
        scsiStatus = SCSISTAT_CHECK_CONDITION;

        if (Srb->SenseInfoBuffer) {
            PSENSE_DATA  senseBuffer = (PSENSE_DATA)Srb->SenseInfoBuffer;

            senseBuffer->ErrorCode = 0x70;
            senseBuffer->Valid = 1;
            senseBuffer->AdditionalSenseLength = 0xb;
            senseBuffer->SenseKey = SCSI_SENSE_MEDIUM_ERROR;
            senseBuffer->AdditionalSenseCode = 0;
            senseBuffer->AdditionalSenseCodeQualifier = 0;

            srbStatus |= SRB_STATUS_AUTOSENSE_VALID;
        }
    }

    else if (errorByte & IDE_ERROR_ID_NOT_FOUND) {

        srbStatus = SRB_STATUS_ERROR;
        scsiStatus = SCSISTAT_CHECK_CONDITION;

        if (Srb->SenseInfoBuffer) {
            PSENSE_DATA  senseBuffer = (PSENSE_DATA)Srb->SenseInfoBuffer;

            senseBuffer->ErrorCode = 0x70;
            senseBuffer->Valid = 1;
            senseBuffer->AdditionalSenseLength = 0xb;
            senseBuffer->SenseKey = SCSI_SENSE_MEDIUM_ERROR;
            senseBuffer->AdditionalSenseCode = 0;
            senseBuffer->AdditionalSenseCodeQualifier = 0;

            srbStatus |= SRB_STATUS_AUTOSENSE_VALID;
        }
    }

    else if (errorByte & IDE_ERROR_MEDIA_CHANGE) {

        scsiStatus = SCSISTAT_CHECK_CONDITION;
        srbStatus = SRB_STATUS_ERROR;

        if (Srb->SenseInfoBuffer) {
            PSENSE_DATA  senseBuffer = (PSENSE_DATA)Srb->SenseInfoBuffer;

            senseBuffer->ErrorCode = 0x70;
            senseBuffer->Valid = 1;
            senseBuffer->AdditionalSenseLength = 0xb;
            senseBuffer->SenseKey = SCSI_SENSE_UNIT_ATTENTION;
            senseBuffer->AdditionalSenseCode = SCSI_ADSENSE_MEDIUM_CHANGED;
            senseBuffer->AdditionalSenseCodeQualifier = 0;

            srbStatus |= SRB_STATUS_AUTOSENSE_VALID;
        }
    }

    else if (errorByte & IDE_ERROR_DATA_ERROR) {

        scsiStatus = SCSISTAT_CHECK_CONDITION;
        srbStatus = SRB_STATUS_ERROR;

        //
        // Build sense buffer
        //
        if (Srb->SenseInfoBuffer) {
            PSENSE_DATA  senseBuffer = (PSENSE_DATA)Srb->SenseInfoBuffer;

            senseBuffer->ErrorCode = 0x70;
            senseBuffer->Valid = 1;
            senseBuffer->AdditionalSenseLength = 0xb;
            senseBuffer->SenseKey = SCSI_SENSE_MEDIUM_ERROR;
            senseBuffer->AdditionalSenseCode = 0;
            senseBuffer->AdditionalSenseCodeQualifier = 0;

            srbStatus |= SRB_STATUS_AUTOSENSE_VALID;
        }
    }
    

    //
    // Set SCSI status to indicate a check condition.
    //
    Srb->ScsiStatus = scsiStatus;

    return srbStatus;

} // end MapError()

/***************************************************************************
 * Function:     BOOLEAN ArrayInterrupt(PDevice pDev) 
 * Description:  
 *   An array member has finished it's task.
 *               
 * Dependence:   array.h srb.h io.c
 * Source file:  array.c
 * Argument:     
 *               PDevice pDev - The device that is waiting for a interrupt
 *               
 * Retures:      BOOLEAN - TRUE  This interrupt is for the device
 *                         FALSE This interrupt is not for the device
 *               
 ***************************************************************************/
void ArrayInterrupt(PDevice pDev DECL_SRB)
{
    PVirtualDevice    pArray = pDev->pArray;  
    PChannel          pChan = pDev->pChannel;
    LOC_SRBEXT_PTR
    
    //KdPrint(("ArrayInterrupt(%d)", pDev->ArrayNum));

	if (pArray->arrayType==VD_RAID01_MIRROR) {
		pSrbExt->MirrorWaitInterrupt &= ~pDev->ArrayMask;
		if (pSrbExt->MirrorStatus==SRB_STATUS_PENDING)
			pSrbExt->MirrorStatus = pSrbExt->member_status;
	}
	else {
		pSrbExt->WaitInterrupt &= ~pDev->ArrayMask;
		if (pDev->ArrayNum==MIRROR_DISK) {
			if (pSrbExt->MirrorStatus==SRB_STATUS_PENDING)
				pSrbExt->MirrorStatus = pSrbExt->member_status;
		}
		else {
			if (pSrbExt->SourceStatus==SRB_STATUS_PENDING)
				pSrbExt->SourceStatus = pSrbExt->member_status;
		}
	}

	if (pSrbExt->WaitInterrupt || pSrbExt->MirrorWaitInterrupt)
		return;
	if (pSrbExt->SourceStatus==SRB_STATUS_PENDING) pSrbExt->SourceStatus = SRB_STATUS_SUCCESS;
	if (pSrbExt->MirrorStatus==SRB_STATUS_PENDING) pSrbExt->MirrorStatus = SRB_STATUS_SUCCESS;

	if (pSrbExt->WorkingFlags & SRB_WFLAGS_ON_SOURCE_DISK) {
		Srb->SrbStatus = pSrbExt->SourceStatus;
		goto finish;
	}
	else if (pSrbExt->WorkingFlags & SRB_WFLAGS_ON_MIRROR_DISK) {
		Srb->SrbStatus = pSrbExt->MirrorStatus;
		goto finish;
	}
    /*
     * retry read errors.
     */
	if (Srb->Cdb[0]==SCSIOP_READ) {
		if (pSrbExt->JoinMembers) {
			if (pDev->ArrayNum==MIRROR_DISK) {
				if (pSrbExt->MirrorStatus==SRB_STATUS_SUCCESS) {
					Srb->SrbStatus = SRB_STATUS_SUCCESS;
					goto finish;
				}
				if (pSrbExt->WorkingFlags & SRB_WFLAGS_RETRY) {
					Srb->SrbStatus = pSrbExt->MirrorStatus;
					goto finish;
				}
			}
			else {
				if (pSrbExt->SourceStatus==SRB_STATUS_SUCCESS) {
					Srb->SrbStatus = SRB_STATUS_SUCCESS;
					goto finish;
				}
				if (pSrbExt->WorkingFlags & SRB_WFLAGS_RETRY) {
					Srb->SrbStatus = pSrbExt->SourceStatus;
					goto finish;
				}
			}
			pSrbExt->WorkingFlags |= SRB_WFLAGS_RETRY;
			switch(pArray->arrayType) {
			case VD_RAID_1_MIRROR:
				if (pSrbExt->JoinMembers & (1<<MIRROR_DISK)) {
					if (pArray->pDevice[0]) {
						pSrbExt->JoinMembers = pSrbExt->WaitInterrupt = 1;
						pSrbExt->SourceStatus = pSrbExt->MirrorStatus = SRB_STATUS_PENDING;
						StartArrayIo(pArray, Srb);
						return;
					}
				}
				else if (pArray->pDevice[MIRROR_DISK]) {
					pSrbExt->JoinMembers = pSrbExt->WaitInterrupt = 1<<MIRROR_DISK;
					pSrbExt->SourceStatus = pSrbExt->MirrorStatus = SRB_STATUS_PENDING;
					StartArrayIo(pArray, Srb);
					return;
				}
				break;
			case VD_RAID_01_2STRIPE:
				if (pArray->pDevice[MIRROR_DISK]) {
					pArray = pArray->pDevice[MIRROR_DISK]->pArray;
					pSrbExt->MirrorJoinMembers = 
						pSrbExt->MirrorWaitInterrupt = pSrbExt->JoinMembers;
					pSrbExt->JoinMembers = 0;
					pSrbExt->SourceStatus = pSrbExt->MirrorStatus = SRB_STATUS_PENDING;
					StartArrayIo(pArray, Srb);
					return;
				}
				break;
			}
			/* cannot recover */
			Srb->SrbStatus = pSrbExt->SourceStatus;
		}
		else {
			if (pSrbExt->MirrorStatus==SRB_STATUS_SUCCESS) {
				Srb->SrbStatus = SRB_STATUS_SUCCESS;
				goto finish;
			}
			if (pSrbExt->WorkingFlags & SRB_WFLAGS_RETRY) {
				Srb->SrbStatus = pSrbExt->MirrorStatus;
				goto finish;
			}
			pSrbExt->WorkingFlags |= SRB_WFLAGS_RETRY;
			/* recover from source */
			if (pArray->arrayType==VD_RAID01_MIRROR) {
				if (pArray->pDevice[MIRROR_DISK]) {
					pArray = pArray->pDevice[MIRROR_DISK]->pArray;
					pSrbExt->JoinMembers = 
						pSrbExt->WaitInterrupt = pSrbExt->MirrorJoinMembers;
					pSrbExt->MirrorJoinMembers = 0;
					pSrbExt->SourceStatus = pSrbExt->MirrorStatus = SRB_STATUS_PENDING;
					StartArrayIo(pArray, Srb);
					return;
				}
			}
			/* cannot recover */
			Srb->SrbStatus = pSrbExt->SourceStatus;
		}
	}
	else {
		/* write: if one is busy, then return busy (since device_removed() is not called).
		 * else if one success, we think success. 
		 */
		if (pSrbExt->SourceStatus==SRB_STATUS_BUSY || 
			pSrbExt->MirrorStatus==SRB_STATUS_BUSY) {
			Srb->SrbStatus = SRB_STATUS_BUSY;
		}
		else if (pSrbExt->SourceStatus==SRB_STATUS_SUCCESS || 
			pSrbExt->MirrorStatus==SRB_STATUS_SUCCESS) {
			Srb->SrbStatus = SRB_STATUS_SUCCESS;
		}
		else
			Srb->SrbStatus = SRB_STATUS_ERROR;
	}

finish:
	/*
     * copy data from internal buffer to user buffer if the SRB
     * is using the internal buffer. Win98 only
     */
    CopyInternalBuffer(Srb);
    
    if(pArray->arrayType == VD_RAID01_MIRROR) {
        pArray = pArray->pDevice[MIRROR_DISK]->pArray;
    }

	/* gmm 2001-6-13
	 *  Handle our secret LBA 9 now.
	 */
	if (pSrbExt->Lba <= RECODR_LBA && 
		pSrbExt->Lba + pSrbExt->nSector > RECODR_LBA) {
		// copy saved buffer to OS buffer
		_fmemcpy((PUCHAR)Srb->DataBuffer+(RECODR_LBA-pSrbExt->Lba)*512, 
			pArray->os_lba9, 512);
	}

	//KdPrint(("Command %x Finished", Srb));
    OS_EndCmd_Interrupt(pSrbExt->StartChannel, Srb); /* use the channel which StartIo called */
}

/******************************************************************
 * 
 *******************************************************************/

void StartArrayIo(PVirtualDevice pArray DECL_SRB)
{
    int i;
    LOC_SRBEXT_PTR
    PDevice pDevice;
    PChannel pChan;
    USHORT joinmembers = (pArray->arrayType==VD_RAID01_MIRROR)? 
    	pSrbExt->MirrorJoinMembers : pSrbExt->JoinMembers;
    int num_failed = 0;
    PDevice failed_disks[MAX_MEMBERS*2];
    UCHAR failed_status[MAX_MEMBERS*2];
    
    //KdPrint(("StartArrayIo(%x, JoinMember=%x)", Srb, joinmembers));

	pSrbExt->WorkingFlags |= SRB_WFLAGS_ARRAY_IO_STARTED;

check_members:
	for(i = 0; i<=MIRROR_DISK; i++) {
        if (joinmembers & (1 << i)) {
            pDevice = pArray->pDevice[i];
			//ASSERT(pDevice!=NULL);
            pChan = pDevice->pChannel;
            if(btr(pChan->exclude_index) == 0) {
            	//KdPrint(("   queue disk %d", i));
            	PutCommandToQueue(pDevice, Srb);
                continue;
            }
            if(pDevice->DeviceFlags & DFLAGS_ARRAY_DISK) {
                if(pArray->arrayType == VD_SPAN) 
                    Span_Lba_Sectors(pDevice ARG_SRBEXT_PTR);
                else
                    Stripe_Lba_Sectors(pDevice ARG_SRBEXT_PTR);
            } else {
                pChan->Lba = pSrbExt->Lba;
                pChan->nSector = pSrbExt->nSector;
            }
            StartIdeCommand(pDevice ARG_SRB);
            if (pSrbExt->member_status!=SRB_STATUS_PENDING) {
            	failed_disks[num_failed] = pDevice;
            	failed_status[num_failed] = pSrbExt->member_status;
            	num_failed++;
            }
        }
	}

	if (pArray->arrayType==VD_RAID_01_2STRIPE) {
		pDevice = pArray->pDevice[MIRROR_DISK];
    	if (pDevice && pDevice->pArray) {
        	pArray = pDevice->pArray;
        	joinmembers = pSrbExt->MirrorJoinMembers;
        	goto check_members;
        }
    }
    
    /* check failed members */
    for (i=0; i<num_failed; i++) {
    	pSrbExt->member_status = failed_status[i];
    	DeviceInterrupt(failed_disks[i], Srb);
    }
}

/******************************************************************
 * Check if this disk is a bootable disk
 *******************************************************************/
void check_bootable(PDevice pDevice)
{
	struct master_boot_record mbr;
	pDevice->DeviceFlags2 &= ~DFLAGS_BOOTABLE_DEVICE;
	ReadWrite(pDevice, 0, IDE_COMMAND_READ, (PUSHORT)&mbr);
	if (mbr.signature==0xAA55) {
		int i;
		// Some linux version will not set bootid to 0x80. Check "LILO"
		if (mbr.parts[0].numsect && *(DWORD*)&mbr.bootinst[6]==0x4F4C494C)
			pDevice->DeviceFlags2 |= DFLAGS_BOOTABLE_DEVICE;
		else
		for (i=0; i<4; i++) {
			if (mbr.parts[i].bootid==0x80 && mbr.parts[i].numsect) {
				pDevice->DeviceFlags2 |= DFLAGS_BOOTABLE_DEVICE;
				break;
			}
		}
	}
}

/******************************************************************
 *  StartIdeCommand
 *   2002-1-1 gmm: If it fails, set excluded_flags bit for the channel
 *                 otherwise the channel is occupied until INTRQ
 *******************************************************************/
#if !defined(USE_PCI_CLK)
UINT switch_to_dpll = 0xFFFFFFFF;
#endif
void StartIdeCommand(PDevice pDevice DECL_SRB)
{
	LOC_SRBEXT_PTR
	PChannel         pChan = pDevice->pChannel;
	PIDE_REGISTERS_1 IoPort;
	PIDE_REGISTERS_2 ControlPort;
	ULONG            Lba = pChan->Lba;
	USHORT           nSector = pChan->nSector;
	PUCHAR           BMI;
	UCHAR            statusByte, cnt=0;
	UINT             is_48bit = 0;

	IoPort = pChan->BaseIoAddress1;
	ControlPort = pChan->BaseIoAddress2;
	BMI = pChan->BMI;
	pChan->pWorkDev = pDevice;
	pChan->CurrentSrb = Srb;
	pSrbExt->member_status = SRB_STATUS_PENDING;
	
#if !defined(USE_PCI_CLK) && defined(DPLL_SWITCH)
	if (pDevice->DeviceFlags & DFLAGS_NEED_SWITCH) {
		if (((UINT)pChan->BMI & 8) != 0 && Srb->Cdb[0] == SCSIOP_WRITE) {
			Switching370Clock(pChan, 0x21);
			switch_to_dpll |= 3<<(pChan->exclude_index-1);
		} else if (switch_to_dpll & (1<<pChan->exclude_index)) {
			switch_to_dpll &= ~( 3<< ( pChan->exclude_index-(((UINT)pChan->BMI&8)?1:0) ));
			Switching370Clock(pChan, 0x23);
		}
	}
#endif
	
	/*
     * Set IDE Command Register
     */
_retry_:
	SelectUnit(IoPort, pDevice->UnitId);
	statusByte=WaitOnBusy(ControlPort);
#if 1
	/*
	 * when a device is removed. statusByte will be 0xxxxxxxb, write 7F to any register
	 * will cause it to be 0x7F.
	 */
	if ((GetCurrentSelectedUnit(IoPort) != pDevice->UnitId)) {
		SelectUnit(IoPort, pDevice->UnitId);
		WaitOnBusy(ControlPort);
		SetBlockCount(IoPort, 0x7F);
		statusByte=WaitOnBusy(ControlPort);
	}
#endif
	if(statusByte & IDE_STATUS_BUSY) {
busy:
		pSrbExt->member_status = SRB_STATUS_BUSY;
		bts(pChan->exclude_index);
		return;
	}
	else if ((statusByte & 0x7E)==0x7E) {
		goto device_removed;
	}
	else if (statusByte & IDE_STATUS_DWF) {
		/*
		 * gmm 2001-3-18
		 * Some disks will set IDE_STATUS_DWF for a while
		 * when the other disk on same channel get removed 
		 */
		statusByte= GetErrorCode(IoPort);
		DisableBoardInterrupt(pChan->BaseBMI);
		IssueCommand(IoPort, IDE_COMMAND_RECALIBRATE);
		EnableBoardInterrupt(pChan->BaseBMI);
		GetBaseStatus(IoPort);
		StallExec(10000);
		if(cnt++< 10) goto _retry_;
		if (pDevice->ResetCount>3) goto device_removed; /* gmm 2001-11-9 */
	}
	else if(statusByte & (IDE_STATUS_ERROR|IDE_STATUS_DRQ)) {
		/* gmm 2002-1-17 add IDE_STATUS_DRQ above, it's a strange problem */
		statusByte= GetErrorCode(IoPort);
		DisableBoardInterrupt(pChan->BaseBMI);
		IssueCommand(IoPort, IDE_COMMAND_RECALIBRATE);
		EnableBoardInterrupt(pChan->BaseBMI);
		GetBaseStatus(IoPort);
		if(cnt++< 10) goto _retry_;
		if (pDevice->ResetCount>3) goto device_removed; /* gmm 2001-11-9 */
	}

	if ((statusByte & IDE_STATUS_DRDY)==0) {
device_removed:
		if ((pDevice->DeviceFlags2 & DFLAGS_DEVICE_DISABLED)==0) {
			pDevice->DeviceFlags2 |= DFLAGS_DEVICE_DISABLED;
			hpt_queue_dpc(pChan->HwDeviceExtension, disk_failed_dpc, pDevice);
		}
		pSrbExt->member_status = SRB_STATUS_SELECTION_TIMEOUT;
		bts(pChan->exclude_index);
		return;
	}

	/* gmm 2001-3-22
	 * Check here rather than let drive report 'invalid parameter' error
	 * OS will rarely write to the last block, but win2k use it to save
	 * dynamic disk information.
	 *
	 * gmm 2001-7-4
	 *   highest accessible Lba == pDevice->capacity
	 *  We return pDev->capacity in READ_CAPACITY command. The capacity is
	 *  SectorCount-1. See also FindDev.c.
	 */
	if(Lba + (ULONG)nSector -1 > pDevice->capacity){ 
		pSrbExt->member_status = SRB_STATUS_ERROR;
		bts(pChan->exclude_index);
		return;
	}

	if((pSrbExt->WorkingFlags & SRB_WFLAGS_IGNORE_ARRAY) == 0){
		Lba += pDevice->HidenLBA;								   
		/* gmm 2001-6-13
		 *  Handle our secret LBA 9 now.
		 */
		if (pDevice->pArray && Srb->Cdb[0]==SCSIOP_WRITE &&
			Lba <= RECODR_LBA && Lba + nSector > RECODR_LBA) {
			// copy pDev's real_lba9 to OS buffer.
			_fmemcpy((PUCHAR)Srb->DataBuffer+(RECODR_LBA-Lba)*512, 
				pDevice->real_lba9, 512);
		}
		//-*/
	}

#ifdef SUPPORT_48BIT_LBA
	if((Lba & 0xF0000000) && (pDevice->DeviceFlags & DFLAGS_48BIT_LBA)) {
		SetBlockCount(IoPort, (UCHAR)(nSector>>8));
		SetBlockNumber(IoPort, (UCHAR)(Lba >> 24));
		SetCylinderLow(IoPort, 0);
		SetCylinderHigh(IoPort,0);
		Lba &= 0xFFFFFF;
		Lba |= 0xE0000000;
		is_48bit = 1;
		goto write_command;
	}
#endif //SUPPORT_48BIT_LBA

	if (pDevice->DeviceFlags & DFLAGS_LBA){ 
		Lba |= 0xE0000000;											 
	}else{
		Lba = MapLbaToCHS(Lba, pDevice->RealHeadXsect, pDevice->RealSector);
	}

write_command:
	SetBlockCount(IoPort, (UCHAR)nSector);
	SetBlockNumber(IoPort, (UCHAR)(Lba & 0xFF));
	SetCylinderLow(IoPort, (UCHAR)((Lba >> 8) & 0xFF));
	SetCylinderHigh(IoPort,(UCHAR)((Lba >> 16) & 0xFF));
	SelectUnit(IoPort,(UCHAR)((Lba >> 24) | (pDevice->UnitId)));

	if (WaitOnBusy(ControlPort) & (IDE_STATUS_BUSY | IDE_STATUS_DRQ)){
		goto busy;													  
	}

	if((Srb->SrbFlags & (SRB_FLAGS_DATA_OUT | SRB_FLAGS_DATA_IN)) == 0){
		goto pio;														
	}

#ifdef USE_DMA
	/*
     * Check if the drive & buffer support DMA
     */
	if(pDevice->DeviceFlags & (DFLAGS_DMA | DFLAGS_ULTRA)) {
		if((pDevice->pArray == 0)||
		   (pSrbExt->WorkingFlags & SRB_WFLAGS_IGNORE_ARRAY)){
			if(BuildSgl(pDevice, pChan->pSgTable ARG_SRB)){
				goto start_dma;
			}
		}else{
			if((pSrbExt->WorkingFlags & ARRAY_FORCE_PIO) == 0){
				goto start_dma;							   
			}
		}
	}
#endif //USE_DMA

	if((pDevice->DeviceFlags & DFLAGS_ARRAY_DISK)&&
	   ((pSrbExt->WorkingFlags & SRB_WFLAGS_IGNORE_ARRAY) == 0)){
		if(pDevice->pArray->arrayType == VD_SPAN){ 
			Span_SG_Table(pDevice, (PSCAT_GATH)&pSrbExt->DataBuffer
						  ARG_SRBEXT_PTR);		  
		}else{
			Stripe_SG_Table(pDevice, (PSCAT_GATH)&pSrbExt->DataBuffer
							ARG_SRBEXT_PTR);						 
		}

		pChan->BufferPtr = (ADDRESS)pChan->pSgTable;
		pChan->WordsLeft = ((UINT)pChan->nSector) << 8;

	}else{
		pChan->BufferPtr = (ADDRESS)Srb->DataBuffer;
		pChan->WordsLeft = Srb->DataTransferLength / 2;
	}
	 /*
     * Send PIO I/O Command
     */
pio:

	pDevice->DeviceFlags &= ~DFLAGS_DMAING;
	Srb->SrbFlags &= ~(SRB_FLAGS_DATA_IN | SRB_FLAGS_DATA_OUT);

	switch(Srb->Cdb[0]) {
		case SCSIOP_SEEK:
			IssueCommand(IoPort, IDE_COMMAND_SEEK);
			break;

		case SCSIOP_VERIFY:
#ifdef SUPPORT_48BIT_LBA
			IssueCommand(IoPort, (is_48bit? IDE_COMMAND_VERIFY_EXT : IDE_COMMAND_VERIFY));
#else
			IssueCommand(IoPort, IDE_COMMAND_VERIFY);
#endif
			break;

		case SCSIOP_READ:
			OutDWord((PULONG)(pChan->BMI + ((pDevice->UnitId & 0x10)>>2) + 0x60),
					 pChan->Setting[pDevice->bestPIO]);
			Srb->SrbFlags |= SRB_FLAGS_DATA_IN;
#ifdef SUPPORT_48BIT_LBA
			IssueCommand(IoPort, (is_48bit)? ((pDevice->ReadCmd == 
				IDE_COMMAND_READ)? IDE_COMMAND_READ_EXT : IDE_COMMAND_READ_MULTIPLE_EXT)
				: pDevice->ReadCmd);
#else
			IssueCommand(IoPort, pDevice->ReadCmd);
#endif
			break;

		default:
			OutDWord((PULONG)(pChan->BMI + ((pDevice->UnitId & 0x10)>>2) + 0x60),
					 pChan->Setting[pDevice->bestPIO]);
			Srb->SrbFlags |= SRB_FLAGS_DATA_OUT;
#ifdef SUPPORT_48BIT_LBA
			IssueCommand(IoPort,  (is_48bit)? ((pDevice->WriteCmd ==
				IDE_COMMAND_WRITE)? IDE_COMMAND_WRITE_EXT : IDE_COMMAND_WRITE_MULTIPLE_EXT)
				: pDevice->WriteCmd);
#else
			IssueCommand(IoPort,  pDevice->WriteCmd);
#endif
			if (!(WaitForDrq(ControlPort) & IDE_STATUS_DRQ)) {
				Srb->SrbStatus = SRB_STATUS_ERROR;
				bts(pChan->exclude_index);
				return;
			}

			AtaPioInterrupt(pDevice);
	}
	return;

#ifdef USE_DMA
start_dma:

#ifdef SUPPORT_TCQ

	 /*
     * Send Commamd Queue DMA I/O Command
     */

	if(pDevice->MaxQueue) {


		pDevice->pTagTable[pSrbExt->Tag] = (ULONG)Srb;

		IssueCommand(IoPort, (UCHAR)((Srb->Cdb[0] == SCSIOP_READ)?
									  IDE_COMMAND_READ_DMA_QUEUE : IDE_COMMAND_WRITE_DMA_QUEUE));

		for ( ; ; ) {
			status = GetStatus(ControlPort);
			if((status & IDE_STATUS_BUSY) == 0){
				break;							
			}
		}

		if(status & IDE_STATUS_ERROR) {
			AbortAllCommand(pChan, pDevice);
			Srb->SrbStatus = MapATAError(pChan, Srb); 
			return;
		}

		// read sector count register
		//
		if((GetInterruptReason(IoPort) & 4) == 0){
			goto start_dma_now;					  
		}

		// wait for service
		//
		status = GetBaseStatus(IoPort);

		if(status & IDE_STATUS_SRV) {
			IssueCommand(IoPort, IDE_COMMAND_SERVICE);

			for( ; ; ) {
				status = GetStatus(ControlPort);
				if((status & IDE_STATUS_BUSY) == 0){
					break;							
				}
			}

			if((Srb = pDevice->pTagTable[GetInterruptReason(IoPort >> 3]) != 0) {
				pSrbExt = Srb->SrbExtension;
				if((pDevice->pArray == 0)||
				   (pSrbExt->WorkingFlags & SRB_WFLAGS_IGNORE_ARRAY)){
					BuildSgl(pDevice, pChan->pSgTable ARG_SRB);
				}
				goto start_dma_now;
			}
		}

		pChan->pWorkDev = 0;
		return;
	}

#endif //SUPPORT_TCQ

	OutPort(BMI, BMI_CMD_STOP);
	OutPort(BMI + BMI_STS, BMI_STS_INTR);

	/* gmm 2001-4-3 merge BMA fix
	 * Removed by HS.Zhang, 12/19/2000
	 * We don't need switch the clock again because we have switched the
	 * clock at the beginning of this function also.
	 * Beware, the switch clock function also reset the 370 chips, so after
	 * calling Switching370Clock, the FIFO in 370 chip are removed. This
	 * may let the previous operation on HDD registers became useless, so
	 * we should call this function before we do any operations on HDD
	 * registers.
	 */
	if(Srb->Cdb[0] == SCSIOP_READ) {
#ifdef SUPPORT_48BIT_LBA
		IssueCommand(IoPort, (is_48bit)? IDE_COMMAND_READ_DMA_EXT : IDE_COMMAND_DMA_READ);
#else
		IssueCommand(IoPort, IDE_COMMAND_DMA_READ);
#endif
	}else{
#ifdef SUPPORT_48BIT_LBA
		IssueCommand(IoPort, (is_48bit)? IDE_COMMAND_WRITE_DMA_EXT : IDE_COMMAND_DMA_WRITE);
#else
		IssueCommand(IoPort, IDE_COMMAND_DMA_WRITE);
#endif
	}

#ifdef SUPPORT_TCQ
start_dma_now:
#endif //SUPPORT_TCQ
	
	pDevice->DeviceFlags |= DFLAGS_DMAING;
					   
	if((pSrbExt->WorkingFlags & SRB_WFLAGS_IGNORE_ARRAY) == 0){
		if(pDevice->DeviceFlags & DFLAGS_ARRAY_DISK){
			if(pDevice->pArray->arrayType == VD_SPAN){
				Span_SG_Table(pDevice, pSrbExt->ArraySg ARG_SRBEXT_PTR);
			}else{
				Stripe_SG_Table(pDevice, pSrbExt->ArraySg ARG_SRBEXT_PTR);
			}
		} else if(pDevice->pArray){
			MemoryCopy(pChan->pSgTable, pSrbExt->ArraySg, sizeof(SCAT_GATH)
					   * MAX_SG_DESCRIPTORS);
		}
	}
#if 0
	/* gmm 2001-3-21
	 * Some disks may not support DMA well. Check it.
	 */
	if (pDevice->IoCount < 10) {
		int i=0;
		pDevice->IoCount++;
		DisableBoardInterrupt(pChan->BaseBMI);
		SetSgPhysicalAddr(pChan);
		OutPort(BMI, (UCHAR)((Srb->Cdb[0] == SCSIOP_READ)? 
			BMI_CMD_STARTREAD : BMI_CMD_STARTWRITE));
		do {
			if (++i>5000) {
				// command failed, use PIO mode
				OutPort(BMI, BMI_CMD_STOP);
				pDevice->DeviceModeSetting = 4;
				IdeResetController(pChan);
				EnableBoardInterrupt(pChan->BaseBMI);
				StartIdeCommand(pDevice ARG_SRB);
				return;
			}
			StallExec(1000);
		}
		while ((InPort(BMI + BMI_STS) & BMI_STS_INTR)==0);
		EnableBoardInterrupt(pChan->BaseBMI);
		return;
	}
#endif	
	SetSgPhysicalAddr(pChan);
	OutPort(BMI, (UCHAR)((Srb->Cdb[0] == SCSIOP_READ)? BMI_CMD_STARTREAD : BMI_CMD_STARTWRITE));

#endif //USE_DMA
}

/* gmm: 2001-3-7
 * Fix bug "Fault a un-first disk of JBOD without I/O on this disk
 *  GUI can't find it has less"
 */
extern BOOL Device_IsRemoved(PDevice pDev);
BOOLEAN CheckSpanMembers(PVirtualDevice pArray, ULONG JoinMembers)
{
	PDevice			 pDevice;
	BOOLEAN			 noError = TRUE;
	int i;

	for(i = 0; i < (int)pArray->nDisk; i++) {
		// only check members that have no I/O
	    if (JoinMembers & (1 << i)) continue;
		/*
		 * Check if device is still working.
		 */
		pDevice = pArray->pDevice[i];
		if (!pDevice) continue;

		if (Device_IsRemoved(pDevice)) {
			if ((pDevice->DeviceFlags2 & DFLAGS_DEVICE_DISABLED)==0) {
				pDevice->DeviceFlags2 |= DFLAGS_DEVICE_DISABLED;
				hpt_queue_dpc(pDevice->pChannel->HwDeviceExtension, disk_failed_dpc, pDevice);
			}
			/*
			 * now the JBOD is disabled. Shall we allow user to access it?
			 */
			noError = FALSE;
		}
	}
	return noError;
}

/******************************************************************
 *  
 *******************************************************************/
void NewIdeIoCommand(PDevice pDevice DECL_SRB)
{
    LOC_SRBEXT_PTR  
    PVirtualDevice pArray = pDevice->pArray;
    PChannel pChan = pDevice->pChannel;
	// gmm: added
	BOOL source_only = ((pSrbExt->WorkingFlags & SRB_WFLAGS_ON_SOURCE_DISK) !=0);
	BOOL mirror_only = ((pSrbExt->WorkingFlags & SRB_WFLAGS_ON_MIRROR_DISK) !=0);

    /*
     * single disk
     */
    if((pArray == 0)||(pSrbExt->WorkingFlags & SRB_WFLAGS_IGNORE_ARRAY)) {
		if (pDevice->DeviceFlags2 & DFLAGS_DEVICE_DISABLED)
			goto no_device;
		/* gmm 2001-6-13
		 *  Handle our secret LBA 9 now.
		 */
		if (pArray && Srb->Cdb[0]==SCSIOP_WRITE &&
			pSrbExt->Lba <= RECODR_LBA && 
			pSrbExt->Lba + pSrbExt->nSector > RECODR_LBA) {
			// copy buffer (possiblly GUI) to pDev's real_lba9
			_fmemcpy(pDevice->real_lba9, 
				(PUCHAR)Srb->DataBuffer+(RECODR_LBA-pSrbExt->Lba)*512, 512);
		}
		//-*/
        if(btr(pChan->exclude_index) == 0) {
        	if (!PutCommandToQueue(pDevice, Srb))
        		Srb->SrbStatus = SRB_STATUS_BUSY;
        }
        else {
        	pChan->Lba = pSrbExt->Lba;
        	pChan->nSector = pSrbExt->nSector;
        	StartIdeCommand(pDevice ARG_SRB);
        	Srb->SrbStatus = pSrbExt->member_status;
        }
        return;
    }

    /*
     * gmm: Don't start io on disabled array
     * we should use only RAID_FLAGS_DISABLED, but there may be some missing
     * places we forgot to set the flag, and RAID 0/1 case is not correct
     * 
     */
    if (pArray->BrokenFlag &&
		(pArray->arrayType==VD_RAID_0_STRIPE || pArray->arrayType==VD_SPAN))
	{
    	Srb->SrbStatus = SRB_STATUS_SELECTION_TIMEOUT;
    	return;
    }
    //-*/

	/* gmm 2001-6-13
	 *  Handle our secret LBA 9 now.
	 */
	if (Srb->Cdb[0]==SCSIOP_WRITE &&
		pSrbExt->Lba <= RECODR_LBA && 
		pSrbExt->Lba + pSrbExt->nSector > RECODR_LBA) {
		// copy OS buffer to saved buffer
		_fmemcpy(pArray->os_lba9, 
			(PUCHAR)Srb->DataBuffer+(RECODR_LBA-pSrbExt->Lba)*512, 512);
	}
	//-*/

    if((Srb->SrbFlags & (SRB_FLAGS_DATA_IN | SRB_FLAGS_DATA_OUT)) &&
        BuildSgl(pDevice, pSrbExt->ArraySg ARG_SRB))
        pSrbExt->WorkingFlags &= ~ARRAY_FORCE_PIO;
    else
        pSrbExt->WorkingFlags |= ARRAY_FORCE_PIO;
 
    switch (pArray->arrayType) {
    case VD_SPAN:
        if (pArray->nDisk)
			 Span_Prepare(pArray ARG_SRBEXT_PTR);
		/* gmm: 2001-3-7
		 * Fix bug "Fault a un-first disk of JBOD without I/O on this disk
		 *  GUI can't find it has less"
		 */
		if (!CheckSpanMembers(pArray, pSrbExt->JoinMembers)) {
			pSrbExt->JoinMembers = 0;
			goto no_device;
		}
		//*/ end gmm 2001-3-7
		break;

    case VD_RAID_1_MIRROR:
	{
		PDevice pSource = pArray->pDevice[0];
		PDevice pMirror = pArray->pDevice[MIRROR_DISK];
		
		if (pArray->RaidFlags & RAID_FLAGS_DISABLED) {
	    	Srb->SrbStatus = SRB_STATUS_SELECTION_TIMEOUT;
	    	return;
		}
		if (pArray->nDisk == 0 || 
			(pDevice->DeviceFlags2 & DFLAGS_DEVICE_DISABLED)){
			// is the source disk broken?
			// in this case mirror disk will move to pDevice[0] and become source disk
			if (source_only)
				pSrbExt->JoinMembers = pSource? 1 : 0;
			else if (mirror_only)
				pSrbExt->JoinMembers = pMirror? (1 << MIRROR_DISK) : 0;
			else {
				pSrbExt->JoinMembers =(USHORT)(pSource? 1 : (1<<MIRROR_DISK));
				if (Srb->Cdb[0] == SCSIOP_WRITE && pMirror)
					pSrbExt->JoinMembers |= (1 << MIRROR_DISK);
			}
		}else if (pMirror){
			 // does the mirror disk present?

			if(Srb->Cdb[0] == SCSIOP_WRITE){
				if(!source_only && pMirror)
					pSrbExt->JoinMembers = 1 << MIRROR_DISK;
				
				if(!mirror_only){
					// if the SRB_WFLAGS_MIRRO_SINGLE flags not set, we
					// need write both source and target disk.
					pSrbExt->JoinMembers |= 1;
				}
			}else{
				if (mirror_only){
					if (pMirror)
						pSrbExt->JoinMembers = (1 << MIRROR_DISK);
				}
				else {
					/* do load banlance on two disks */
					if (pArray->RaidFlags & RAID_FLAGS_NEED_SYNCHRONIZE)
						pSrbExt->JoinMembers = 1;
					else {
						pSrbExt->JoinMembers = (pArray->last_read)? (1<<MIRROR_DISK) : 1;
						pArray->last_read = !pArray->last_read;
					}
				}
			}

		}else{	
			// is the mirror disk broken?
			if(!mirror_only)
				pSrbExt->JoinMembers = 1;
		}
	}
	break;

	case VD_RAID01_MIRROR:
		// in case of hot-plug pDevice->pArray may be changed to this.
		pDevice = pArray->pDevice[MIRROR_DISK];
		pArray = pDevice->pArray;
		// flow down
    case VD_RAID_01_2STRIPE:
    {
    	PVirtualDevice pSrcArray=0, pMirArray=0;
		if(pArray->BrokenFlag) {
			/*
			 * gmm 2001-3-15
			 *      Report to GUI if second drive of mirror RAID0 is removed
			 */
			int i;
			for (i=0; i<SPARE_DISK; i++) {
				PDevice pd = pArray->pDevice[i];
				if (pd && pd->pArray==pArray && 
					!(pd->DeviceFlags2 & DFLAGS_DEVICE_DISABLED)) {
					if (Device_IsRemoved(pd)) {
						if ((pDevice->DeviceFlags2 & DFLAGS_DEVICE_DISABLED)==0) {
							pd->DeviceFlags2 |= DFLAGS_DEVICE_DISABLED;
							hpt_queue_dpc(pd->pChannel->HwDeviceExtension, disk_failed_dpc, pd);
						}
					}
				}
			}
		}else{
			pSrcArray = pArray;
		}
		pDevice = pArray->pDevice[MIRROR_DISK];
		if (pDevice) {
			pMirArray = pDevice->pArray;
			if (pMirArray && pMirArray->BrokenFlag) pMirArray=0;
		}
		
		if (source_only && !pSrcArray) break;
		if (mirror_only && !pMirArray) break;
		
		if (pSrcArray)
			Stripe_Prepare(pSrcArray ARG_SRBEXT_PTR);
		else if (pMirArray)
			Stripe_Prepare(pMirArray ARG_SRBEXT_PTR);

		if (source_only) {
			// (already zero) pSrbExt->MirrorJoinMembers = 0;
			pArray = pSrcArray;
		}
		else if (mirror_only) {
			pSrbExt->MirrorJoinMembers = pSrbExt->JoinMembers;
			pSrbExt->JoinMembers = 0;
			pArray = pMirArray;
		}
		else if (Srb->Cdb[0]==SCSIOP_WRITE) {
			if (pMirArray)
				pSrbExt->MirrorJoinMembers = pSrbExt->JoinMembers;
			if (!pSrcArray)
				pSrbExt->JoinMembers = 0;
		}
	}
	break;
	
    case VD_RAID_0_STRIPE:
        if (!pArray->BrokenFlag)
			Stripe_Prepare(pArray ARG_SRBEXT_PTR);
		break;
    }
    
    /*
     * gmm: added
     * in case of broken mirror there is a chance that JoinMembers==0
     */
    if (pSrbExt->JoinMembers==0 && pSrbExt->MirrorJoinMembers==0) {
no_device:
    	Srb->SrbStatus = 0x8; /* 0x8==SRB_STATUS_NO_DEVICE */;
    	return;
    }
    //-*/

    pSrbExt->WaitInterrupt = pSrbExt->JoinMembers;
    pSrbExt->MirrorWaitInterrupt = pSrbExt->MirrorJoinMembers;

    StartArrayIo(pArray ARG_SRB);
}

/******************************************************************
 * Device Interrupt
 *******************************************************************/

UCHAR DeviceInterrupt(PDevice pDev, PSCSI_REQUEST_BLOCK Srb)
{
	PVirtualDevice    pArray = pDev->pArray;
	PChannel          pChan = pDev->pChannel;
	PIDE_REGISTERS_1  IoPort = pChan->BaseIoAddress1;
	PUCHAR            BMI = pChan->BMI;
	UINT              i;
	UCHAR             state;
	PSrbExtension  pSrbExt;
	
	//KdPrint(("DeviceInterrupt(%d, %x)", pDev->ArrayNum, Srb));

	if (Srb) {
		pSrbExt = (PSrbExtension)Srb->SrbExtension;
		goto end_process;
	}

	Srb = pChan->CurrentSrb;
	if(Srb == 0) {
		OutPort(BMI, BMI_CMD_STOP);					   
		
#ifndef NOT_ISSUE_37
		Reset370IdeEngine(pChan, pDev->UnitId);
#endif
		while(InPort(BMI + BMI_STS) & BMI_STS_INTR){
			SelectUnit(IoPort, pDev->UnitId);
			state = GetBaseStatus(IoPort);
			OutPort(BMI + BMI_STS, BMI_STS_INTR);		
		}
		return(TRUE);
	}
	pSrbExt = (PSrbExtension)Srb->SrbExtension;

	i = 0;
	if(pDev->DeviceFlags & DFLAGS_DMAING) {
		/*
		 * BugFix: by HS.Zhang
		 * 
		 * if the device failed the request before DMA transfer.We
		 * cann't detect whether the INTR is corrent depended on
		 * BMI_STS_ACTIVE. We should check whether the FIFO count is
		 * zero.
		 */
//		if((InPort(BMI + BMI_STS) & BMI_STS_ACTIVE)!=0){
		if((InWord(pChan->MiscControlAddr+2) & 0x1FF)){ // if FIFO count in misc 3 register NOT equ 0, it's a fake interrupt.
			return FALSE;
		}

		OutPort(BMI, BMI_CMD_STOP);
#ifndef NOT_ISSUE_37
		Reset370IdeEngine(pChan, pDev->UnitId);
#endif
	}

	do {
		SelectUnit(IoPort, pDev->UnitId);
		state = GetBaseStatus(IoPort);
		OutPort(BMI + BMI_STS, BMI_STS_INTR);		
	}
	while(InPort(BMI + BMI_STS) & BMI_STS_INTR);

	if (state & IDE_STATUS_BUSY) {
		for (i = 0; i < 10; i++) {
			state = GetBaseStatus(IoPort);
			if (!(state & IDE_STATUS_BUSY))
				break;
			StallExec(5000);
		}
		if(i == 10) {
			OS_Busy_Handle(pChan, pDev);
			return TRUE;
		}
	}

	if((state & IDE_STATUS_DRQ) == 0 || (pDev->DeviceFlags & DFLAGS_DMAING))
		goto  complete;

#ifdef SUPPORT_ATAPI

	if(pDev->DeviceFlags & DFLAGS_ATAPI) {
		AtapiInterrupt(pDev);
		return TRUE;
	}

#endif //SUPPORT_ATAPI

	if((Srb->SrbFlags & (SRB_FLAGS_DATA_OUT | SRB_FLAGS_DATA_IN)) == 0) {
		OS_Reset_Channel(pChan);
		return TRUE;
	}

	if(AtaPioInterrupt(pDev))    
		return TRUE;

complete:

#ifdef SUPPORT_ATAPI

	if(pDev->DeviceFlags & DFLAGS_ATAPI) {
		OutDWord((PULONG)(pChan->BMI + ((pDev->UnitId & 0x10)>>2) + 
						  0x60), pChan->Setting[pDev->bestPIO]);

		if(state & IDE_STATUS_ERROR) 
			Srb->SrbStatus = MapAtapiErrorToOsError(GetErrorCode(IoPort) ARG_SRB);
					
		/*
		 * BugFix: by HS.Zhang
		 * The Atapi_End_Interrupt will call DeviceInterrupt with Abort
		 * flag set as TRUE, so if we don't return here. the
		 * CheckNextRequest should be called twice.
		 */
		return Atapi_End_Interrupt(pDev ARG_SRB);
	} else
#endif	// SUPPORT_ATAPI

	if (state & IDE_STATUS_ERROR) {
		UCHAR   statusByte, cnt=0;
		PIDE_REGISTERS_2 ControlPort;
		UCHAR err = MapAtaErrorToOsError(GetErrorCode(IoPort) ARG_SRB);

		// clear IDE bus status
		DisableBoardInterrupt(pChan->BaseBMI);
		ControlPort = pChan->BaseIoAddress2;
		for(cnt=0;cnt<10;cnt++) {
			SelectUnit(IoPort, pDev->UnitId);
			statusByte = WaitOnBusy(ControlPort);
			if(statusByte & IDE_STATUS_ERROR) {
				IssueCommand(IoPort, IDE_COMMAND_RECALIBRATE);
				statusByte = WaitOnBusy(ControlPort);
				GetBaseStatus(IoPort);
			}
			else break;
		}
		/* gmm 2001-10-6
		 *  Timing mode will be reduced in IdeResetController
		 * gmm 2001-4-9
		 *  If disk still fail after retry we will reduce the timing mode.
		 */
		if (pChan->RetryTimes > 2) {
			IdeResetController(pChan);
		}
		//-*/
		EnableBoardInterrupt(pChan->BaseBMI);
	
		/* gmm 2001-1-20
		 *
		 * Retry R/W operation.
		 * 2001-3-12: should call StartIdeCommand only when Srb->Status is
		 * SRB_STATUS_PENDING. and also check result of StartIdeCommand.
		 */
		if (pChan->RetryTimes++ < 10) {
			StartIdeCommand(pDev ARG_SRB);
			if(pSrbExt->member_status != SRB_STATUS_PENDING) {
				// this recursive call should be safe, because we set abort=1
				DeviceInterrupt(pDev, Srb);
			}
			return TRUE;
		}
		else {
			pDev->DeviceFlags2 |= DFLAGS_DEVICE_DISABLED;
			hpt_queue_dpc(pChan->HwDeviceExtension, disk_failed_dpc, pDev);
			pSrbExt->member_status = err;
		}
	}
	else {
		pSrbExt->member_status = SRB_STATUS_PENDING;
		if (pDev->IoSuccess++>1000)
			pDev->ResetCount = 0;
	}

	/* only hardware interrupt handler should change these fields */
	pChan->RetryTimes = 0;
	pChan->pWorkDev = 0;
	pChan->CurrentSrb = 0;
	bts(pChan->exclude_index);
	pDev->DeviceFlags &= ~(DFLAGS_DMAING | DFLAGS_REQUEST_DMA WIN_DFLAGS);

end_process:

	if((pArray == 0)||
	   (pSrbExt->WorkingFlags & SRB_WFLAGS_IGNORE_ARRAY) ||
		!(pSrbExt->WorkingFlags & SRB_WFLAGS_ARRAY_IO_STARTED)) {
		Srb->SrbStatus = pSrbExt->member_status;
		if(Srb->SrbStatus == SRB_STATUS_PENDING)
			Srb->SrbStatus = SRB_STATUS_SUCCESS;
		CopyInternalBuffer(Srb);
		OS_EndCmd_Interrupt(pChan ARG_SRB);
	}
	else
		ArrayInterrupt(pDev, Srb);
		
	CheckNextRequest(pChan, pDev);
	return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\port\scsi\miniport\hipoint\hpt3xx\winnt\winnt2k.c ===
/***************************************************************************
 * File:          winnt2k.c
 * Description:   Subroutines in the file are used to NT/2K platform
 * Author:        DaHai Huang    (DH)
 * Dependence:    none
 * Copyright (c)  2000 HighPoint Technologies, Inc. All rights reserved
 * History:     
 *		11/06/2000	HS.Zhang	Added this head
 *		11/10/2000	HS.Zhang	Added a micro define NO_DMA_ON_ATAPI in
 *								Start_Atapi routine
 *		2/28/2000	gmm			Use ScsiportGetPhysicalAddress under win2k
 *
 ***************************************************************************/
#include "global.h"

#if  !defined(WIN95) && !defined(_BIOS_)

#define MAX_CONTROL_TYPE	5

#ifndef WIN2000
DECLSPEC_IMPORT PHYSICAL_ADDRESS MmGetPhysicalAddress(IN PVOID BaseAddress);
#endif

/*++
Function:
    VOID H366BuildSgl

Description:
    This routine builds a scatter/gather descriptor list.
    The user's buffer is already locked down before AtapiStartIo was called.
    So we don't do anything to lock the buffer.

    Suppose that we should have not written a routine like this, but we
    have no way to go if there is a device connected which only supports
    PIO. PIO needs the data buffer pointer is an address in system address
    space.

Arguments:
    HwDeviceExtension - HBA miniport driver's adapter data storage
    Srb - IO request packet

Returns:
    Number of SG entries
--*/
int
   BuildSgl(IN PDevice pDev, IN PSCAT_GATH pSG,
			IN PSCSI_REQUEST_BLOCK Srb)
{
	PChannel pChan = pDev->pChannel;
	PSCAT_GATH psg = pSG;
	PVOID   dataPointer = Srb->DataBuffer;
	ULONG   bytesLeft   = Srb->DataTransferLength;
	ULONG   physicalAddress[MAX_SG_DESCRIPTORS];
	ULONG   addressLength[MAX_SG_DESCRIPTORS];
	ULONG   addressCount = 0;
	ULONG   sgEnteries = 0;
	ULONG   length, delta, pageSize;
	ULONG   i = 0;

	if((int)dataPointer	& 1)
		return FALSE;

	//
	// The start address maybe is not at the boundary of a page.
	// So the first page maybe is not a full page.
	//
	pageSize = 0x1000 - (((ULONG)dataPointer) & 0xFFF);

	//
	// Get physical address of each page
	//
	while (bytesLeft) {
		physicalAddress[addressCount] =
#ifndef WIN2000
					MmGetPhysicalAddress(dataPointer).u.LowPart;
#else
					ScsiPortConvertPhysicalAddressToUlong(
						ScsiPortGetPhysicalAddress(pChan->HwDeviceExtension,
									   Srb,
									   dataPointer,
									   &length));
#endif

		addressLength[addressCount] = (bytesLeft > pageSize) ? pageSize : bytesLeft;

		bytesLeft -= addressLength[addressCount];
		dataPointer = (PUCHAR)dataPointer + pageSize;
		addressCount++;

		//
		// Set pageSize to a full page size
		//
		pageSize = 0x1000;
	}

	//
	// Create Scatter/Gather List
	//
	i = 0;
	do {
		psg->SgAddress = physicalAddress[i];
		length = addressLength[i];

		//
		// Get the length of contiguous physical memory
		// NOTE:
		//  If contiguous physical memory skips 64K boundary, we split it.
		//
		i++;

		while (i < addressCount) {
			delta = physicalAddress[i] - physicalAddress[i-1];

			if (delta > 0 && delta <= pageSize &&
				  (physicalAddress[i] & 0xFFFF) ) {
				length += addressLength[i];
				i++;
			}
			else
				break;
		}

		psg->SgSize = (USHORT)length;
		if((length & 3) || (length < 8))
			return FALSE;
		psg->SgFlag = (i < addressCount) ? 0 : SG_FLAG_EOT;

		sgEnteries++;
		psg++;

	} while (i < addressCount);

	return (TRUE);
} // BuildSgl()

/******************************************************************
 *  
 *******************************************************************/

void Nt2kHwInitialize(
					  IN PDevice pDevice
					 )
{
	PChannel             pChan = pDevice->pChannel;
	PIDE_REGISTERS_1     IoPort = pChan->BaseIoAddress1;
	PIDE_REGISTERS_2     ControlPort = pChan->BaseIoAddress2;
	ULONG waitCount;
	ULONG i, j;
	UCHAR statusByte, errorByte;
	UCHAR vendorId[26];

#ifdef SUPPORT_ATAPI
	if (pDevice->DeviceFlags & DFLAGS_ATAPI) {
		//
		// We need to get our device ready for action before
		// returning from this function
		//
		// According to the atapi spec 2.5 or 2.6, an atapi device
		// clears its status BSY bit when it is ready for atapi commands.
		// However, some devices (Panasonic SQ-TC500N) are still
		// not ready even when the status BSY is clear.  They don't react
		// to atapi commands.
		//
		// Since there is really no other indication that tells us
		// the drive is really ready for action.  We are going to check BSY
		// is clear and then just wait for an arbitrary amount of time!
		//

		// have to get out of the loop sometime!
		// 10000 * 100us = 1000,000us = 1000ms = 1s
		for(waitCount = 10000; waitCount != 0; waitCount--) {
			if((GetStatus(ControlPort) & IDE_STATUS_BUSY) == 0)
				break;
			//
			// Wait for Busy to drop.
			//
			ScsiPortStallExecution(100);
		}

		// 5000 * 100us = 500,000us = 500ms = 0.5s
		for(waitCount = 5000; waitCount != 0; waitCount--){
			ScsiPortStallExecution(100);					 
		}

		// Added by HS.Zhang
		// Added macro define check to let us change the DMA by set the
		// macro in forwin.h
#ifdef NO_DMA_ON_ATAPI	
		pDevice->DeviceFlags &= ~(DFLAGS_DMA | DFLAGS_ULTRA);
#endif									// NO_DMA_ON_ATAPI
	}

	if(!(pDevice->DeviceFlags & DFLAGS_CHANGER_INITED)) {
		  //
		// Attempt to identify any special-case devices - psuedo-atapi changers, atapi changers, etc.
		//

		for (j = 0; j < 13; j += 2) {

			//
			// Build a buffer based on the identify data.
			//

			vendorId[j] = ((PUCHAR)pDevice->IdentifyData.ModelNumber)[j + 1];
			vendorId[j+1] = ((PUCHAR)pDevice->IdentifyData.ModelNumber)[j];
		}

		if (!StringCmp (vendorId, "CD-ROM  CDR", 11)) {

			//
			// Inquiry string for older model had a '-', newer is '_'
			//

			if (vendorId[12] == 'C') {

				//
				// Torisan changer. Set the bit. This will be used in several places
				// acting like 1) a multi-lun device and 2) building the 'special' TUR's.
				//

				pDevice->DeviceFlags |= (DFLAGS_CHANGER_INITED | DFLAGS_SANYO_ATAPI_CHANGER);
				pDevice->DiscsPresent = 3;
			}
		}
	}
#endif // SUPPORT_ATAPI

} // end Nt2kHwInitialize()

/******************************************************************
 *  
 *******************************************************************/
#ifdef SUPPORT_ATAPI
VOID
   AtapiHwInitializeChanger (
							 IN PDevice pDevice,
							 IN PMECHANICAL_STATUS_INFORMATION_HEADER MechanismStatus)
{
	if (MechanismStatus) {
		pDevice->DiscsPresent = MechanismStatus->NumberAvailableSlots;
		if (pDevice->DiscsPresent > 1) {
			pDevice->DeviceFlags |= DFLAGS_ATAPI_CHANGER;
		}
	}
	return;
}
#endif // SUPPOR_ATAPI

/******************************************************************
 *  
 *******************************************************************/
#ifdef SUPPORT_ATAPI

void Start_Atapi(PDevice pDev, PSCSI_REQUEST_BLOCK Srb)
{
	LOC_IDENTIFY
			PChannel  pChan = pDev->pChannel;
	PIDE_REGISTERS_1 IoPort = pChan->BaseIoAddress1;
	PIDE_REGISTERS_2 ControlPort = pChan->BaseIoAddress2;
	PSCSI_REQUEST_BLOCK NewSrb;
	int    i, flags;
	BYTE   statusByte;

	//
	// We need to know how many platters our atapi cd-rom device might have.
	// Before anyone tries to send a srb to our target for the first time,
	// we must "secretly" send down a separate mechanism status srb in order to
	// initialize our device extension changer data.  That's how we know how
	// many platters our target has.
	//
	if (!(pDev->DeviceFlags & DFLAGS_CHANGER_INITED) &&
		  !pChan->OriginalSrb) {

		ULONG srbStatus;

		//
		// Set this flag now. If the device hangs on the mech. status
		// command, we will not have the change to set it.
		//
		pDev->DeviceFlags |= DFLAGS_CHANGER_INITED;

		pChan->MechStatusRetryCount = 3;
		NewSrb = BuildMechanismStatusSrb (
										  pChan,
										  Srb->PathId,
										  Srb->TargetId);
		pChan->OriginalSrb = Srb;

		StartAtapiCommand(pDev, NewSrb);
		if (NewSrb->SrbStatus == SRB_STATUS_PENDING) {
			return;
		} else {
			pChan->CurrentSrb = pChan->OriginalSrb;
			pChan->OriginalSrb = NULL;
			AtapiHwInitializeChanger (pDev,
									  (PMECHANICAL_STATUS_INFORMATION_HEADER) NULL);
			// fall out
		}
	}

	//
	// Make sure command is to ATAPI device.
	//

	flags = (int)pDev->DeviceFlags;
	if (flags & (DFLAGS_SANYO_ATAPI_CHANGER | DFLAGS_ATAPI_CHANGER)) {
		if ((Srb->Lun) > (pDev->DiscsPresent - 1)) {

			//
			// Indicate no device found at this address.
			//
no_device:
			Srb->SrbStatus = SRB_STATUS_SELECTION_TIMEOUT;
			return;
		}
	} else if (Srb->Lun > 0) 
		goto no_device;

	if (!(flags & DFLAGS_ATAPI)) 
		goto no_device;

	//
	// Select device 0 or 1.
	//

	ScsiPortWritePortUchar(&IoPort->DriveSelect,
						   (UCHAR)(((Srb->TargetId) << 4) | 0xA0));

	//
	// Verify that controller is ready for next command.
	//

	statusByte = GetStatus(ControlPort);

	if (statusByte & IDE_STATUS_BUSY) {
busy:
		Srb->SrbStatus = SRB_STATUS_BUSY;
		return;

	}

	if (statusByte & IDE_STATUS_ERROR) {
		if (Srb->Cdb[0] != SCSIOP_REQUEST_SENSE) {

			//
			// Read the error reg. to clear it and fail this request.
			//

			Srb->SrbStatus = MapAtapiErrorToOsError(GetErrorCode(IoPort), Srb);
			return;
		}
	}

	//
	// If a tape drive has doesn't have DSC set and the last command is restrictive, don't send
	// the next command. See discussion of Restrictive Delayed Process commands in QIC-157.
	//

	if ((!(statusByte & IDE_STATUS_DSC)) &&
		  (flags & DFLAGS_TAPE_DEVICE) && (flags & DFLAGS_TAPE_RDP)) {

		ScsiPortStallExecution(1000);
		goto busy;
	}

	if(IS_RDP(Srb->Cdb[0]))
		pDev->DeviceFlags |= DFLAGS_TAPE_RDP;
	else
		pDev->DeviceFlags &= ~DFLAGS_TAPE_RDP;

	if (statusByte & IDE_STATUS_DRQ) {

		// Try to drain the data that one preliminary device thinks that it has
		// to transfer. Hopefully this random assertion of DRQ will not be present
		// in production devices.
		//

		for (i = 0; i < 0x10000; i++) {

			statusByte = GetStatus(ControlPort);

			if (statusByte & IDE_STATUS_DRQ) {

				ScsiPortReadPortUshort(&IoPort->Data);

			} else {

				break;
			}
		}

		if (i == 0x10000) {

			AtapiSoftReset(IoPort,ControlPort,pDev->UnitId);

			//
			// Re-initialize Atapi device.
			//

			IssueIdentify(pDev,
						  IDE_COMMAND_ATAPI_IDENTIFY,
						  (PUSHORT)&Identify);
			//
			// Inform the port driver that the bus has been reset.
			//

			ScsiPortNotification(ResetDetected, pChan->HwDeviceExtension, 0);

			//
			// Clean up device extension fields that AtapiStartIo won't.
			//
			Srb->SrbStatus = SRB_STATUS_BUS_RESET;
			return;
		}
	}

	if (flags & (DFLAGS_SANYO_ATAPI_CHANGER | DFLAGS_ATAPI_CHANGER)) {

		//
		// As the cdrom driver sets the LUN field in the cdb, it must be removed.
		//

		Srb->Cdb[1] &= ~0xE0;

		if ((Srb->Cdb[0] == SCSIOP_TEST_UNIT_READY) && (flags & DFLAGS_SANYO_ATAPI_CHANGER)) {

			//
			// Torisan changer. TUR's are overloaded to be platter switches.
			//

			Srb->Cdb[7] = Srb->Lun;

		}
	}

	//
	// Convert SCSI to ATAPI commands if needed
	//
	if (flags & DFLAGS_TAPE_DEVICE)
		goto no_convert;

	switch (Srb->Cdb[0]) {
		case SCSIOP_MODE_SENSE: {
									PMODE_SENSE_10 modeSense10 = (PMODE_SENSE_10)Srb->Cdb;
									UCHAR PageCode = ((PCDB)Srb->Cdb)->MODE_SENSE.PageCode;
									UCHAR Length = ((PCDB)Srb->Cdb)->MODE_SENSE.AllocationLength;

									ZeroMemory(Srb->Cdb,MAXIMUM_CDB_SIZE);

									modeSense10->OperationCode = ATAPI_MODE_SENSE;
									modeSense10->PageCode = PageCode;
									modeSense10->ParameterListLengthMsb = 0;
									modeSense10->ParameterListLengthLsb = Length;
									break;
								}

		case SCSIOP_MODE_SELECT: {
									 PMODE_SELECT_10 modeSelect10 = (PMODE_SELECT_10)Srb->Cdb;
									 UCHAR Length = ((PCDB)Srb->Cdb)->MODE_SELECT.ParameterListLength;

			//
			// Zero the original cdb
			//

									 ZeroMemory(Srb->Cdb,MAXIMUM_CDB_SIZE);

									 modeSelect10->OperationCode = ATAPI_MODE_SELECT;
									 modeSelect10->PFBit = 1;
									 modeSelect10->ParameterListLengthMsb = 0;
									 modeSelect10->ParameterListLengthLsb = Length;
									 break;
								 }

		case SCSIOP_FORMAT_UNIT:
			Srb->Cdb[0] = ATAPI_FORMAT_UNIT;
			break;
	}

no_convert:

	if((pDev->DeviceFlags & (DFLAGS_DMA|DFLAGS_ULTRA)) &&
	   (pDev->DeviceFlags & DFLAGS_FORCE_PIO) == 0 &&
	   (Srb->Cdb[0] == 0x28 || Srb->Cdb[0] == 0x2A ||
		  Srb->Cdb[0] == 0x8 || Srb->Cdb[0] == 0xA) &&
	   BuildSgl(pDev, pChan->pSgTable, Srb)) 
		pDev->DeviceFlags |= DFLAGS_REQUEST_DMA;
	else
		pDev->DeviceFlags &= ~DFLAGS_REQUEST_DMA;

	StartAtapiCommand(pDev ARG_SRB);
}

BOOLEAN Atapi_End_Interrupt(PDevice pDev , PSCSI_REQUEST_BLOCK Srb)
{
	PChannel  pChan = pDev->pChannel;	 
	PIDE_REGISTERS_1     IoPort = pChan->BaseIoAddress1;
	PIDE_REGISTERS_2 ControlPort = pChan->BaseIoAddress2;
	UCHAR  status = Srb->SrbStatus, statusByte;
	ULONG  i;

	if((pDev->DeviceFlags & DFLAGS_DMAING) == 0 && pChan->WordsLeft)
		status = SRB_STATUS_DATA_OVERRUN;
	else if(Srb->SrbStatus == SRB_STATUS_PENDING)
		status = SRB_STATUS_SUCCESS;


	// Check and see if we are processing our secret (mechanism status/request sense) Srb
	//
	if (pChan->OriginalSrb) {

		if (Srb->Cdb[0] == SCSIOP_MECHANISM_STATUS) {

			if (status == SRB_STATUS_SUCCESS) {
				// Bingo!!
				AtapiHwInitializeChanger (pDev,
										  (PMECHANICAL_STATUS_INFORMATION_HEADER) Srb->DataBuffer);

				// Get ready to issue the original Srb
				Srb = pChan->CurrentSrb = pChan->OriginalSrb;
				pChan->OriginalSrb = NULL;

			} else {
				// failed!  Get the sense key and maybe try again
				Srb = pChan->CurrentSrb = BuildRequestSenseSrb (
					pChan,
					pChan->OriginalSrb->PathId,
					pChan->OriginalSrb->TargetId);
			}

			Start_Atapi(pDev, pChan->CurrentSrb);
			if (Srb->SrbStatus == SRB_STATUS_PENDING) {
				return TRUE;
			}

		} else { // Srb->Cdb[0] == SCSIOP_REQUEST_SENSE)

			PSENSE_DATA senseData = (PSENSE_DATA) Srb->DataBuffer;

			if (status == SRB_STATUS_DATA_OVERRUN) {
				// Check to see if we at least get mininum number of bytes
				if ((Srb->DataTransferLength - pChan->WordsLeft) >
					  (offsetof (SENSE_DATA, AdditionalSenseLength) + sizeof(senseData->AdditionalSenseLength))) {
					status = SRB_STATUS_SUCCESS;
				}
			}

			if (status == SRB_STATUS_SUCCESS) {
				if ((senseData->SenseKey != SCSI_SENSE_ILLEGAL_REQUEST) &&
					  pChan->MechStatusRetryCount) {

					// The sense key doesn't say the last request is illegal, so try again
					pChan->MechStatusRetryCount--;
					Srb = pChan->CurrentSrb = BuildMechanismStatusSrb (
						pChan,
						pChan->OriginalSrb->PathId,
						pChan->OriginalSrb->TargetId);
				} else {

					// last request was illegal.  No point trying again

					AtapiHwInitializeChanger (pDev,
											  (PMECHANICAL_STATUS_INFORMATION_HEADER) NULL);

					// Get ready to issue the original Srb
					Srb = pChan->CurrentSrb = pChan->OriginalSrb;
					pChan->OriginalSrb = NULL;
				}

				Start_Atapi(pDev, pChan->CurrentSrb);
				if (Srb->SrbStatus == SRB_STATUS_PENDING) {
					return TRUE;
				}
			}
		}

		// If we get here, it means AtapiSendCommand() has failed
		// Can't recover.  Pretend the original Srb has failed and complete it.

		if (pChan->OriginalSrb) {
			AtapiHwInitializeChanger (pDev,
									  (PMECHANICAL_STATUS_INFORMATION_HEADER) NULL);
			Srb = pChan->CurrentSrb = pChan->OriginalSrb;
			pChan->OriginalSrb = NULL;
		}

		// fake an error and read no data
		status = SRB_STATUS_ERROR;
		Srb->ScsiStatus = 0;
		pChan->BufferPtr = Srb->DataBuffer;
		pChan->WordsLeft = Srb->DataTransferLength;
		pDev->DeviceFlags &= ~DFLAGS_TAPE_RDP;

	} else if (status != SRB_STATUS_SUCCESS) {

		pDev->DeviceFlags &= ~DFLAGS_TAPE_RDP;

	} else {

		//
		// Wait for busy to drop.
		//

		for (i = 0; i < 30; i++) {
			statusByte = GetStatus(ControlPort);
			if (!(statusByte & IDE_STATUS_BUSY)) {
				break;
			}
			ScsiPortStallExecution(500);
		}

		if (i == 30) {

			//
			// reset the controller.
			AtapiResetController(
								 pChan->HwDeviceExtension,Srb->PathId);
			return TRUE;
		}

		//
		// Check to see if DRQ is still up.
		//

		if (statusByte & IDE_STATUS_DRQ) {

			for (i = 0; i < 500; i++) {
				statusByte = GetStatus(ControlPort);
				if (!(statusByte & IDE_STATUS_DRQ)) {
					break;
				}
				ScsiPortStallExecution(100);

			}

			if (i == 500) {

				//
				// reset the controller.
				//
				AtapiResetController(pChan->HwDeviceExtension,Srb->PathId);
				return TRUE;
			}

		}
	}

	//
	// Sanity check that there is a current request.
	//

	if (Srb != NULL) {

		//
		// Set status in SRB.
		//

		Srb->SrbStatus = (UCHAR)status;

		//
		// Check for underflow.
		//

		if (pChan->WordsLeft) {

			//
			// Subtract out residual words and update if filemark hit,
			// setmark hit , end of data, end of media...
			//

			if (!(pDev->DeviceFlags & DFLAGS_TAPE_DEVICE)) {
				if (status == SRB_STATUS_DATA_OVERRUN) {
					Srb->DataTransferLength -= pChan->WordsLeft;
				} else {
					Srb->DataTransferLength = 0;
				}
			} else {
				Srb->DataTransferLength -= pChan->WordsLeft;
			}
		}

	} 

	//
	// Indicate ready for next request.
	//
	if (!(pDev->DeviceFlags & DFLAGS_TAPE_RDP)) 
		DeviceInterrupt(pDev, Srb);
	else 
		OS_Busy_Handle(pChan, pDev);
	return TRUE;

} // end AtapiInterrupt()
#endif // SUPPORT_ATAPI

void
   IdeSendSmartCommand(
					   IN PDevice pDev,
					   IN PSCSI_REQUEST_BLOCK Srb
					  )

/*++

Routine Description:

    This routine handles SMART enable, disable, read attributes and threshold commands.

Arguments:

    HwDeviceExtension - HBA miniport driver's adapter data storage
    Srb - IO request packet

Return Value:

    SRB status

--*/

{
	PChannel             pChan = pDev->pChannel;
	PIDE_REGISTERS_1     IoPort  = pChan->BaseIoAddress1;
	PIDE_REGISTERS_2     ControlPort  = pChan->BaseIoAddress2;
	PSENDCMDOUTPARAMS    cmdOutParameters = (PSENDCMDOUTPARAMS)(((PUCHAR)Srb->DataBuffer) + sizeof(SRB_IO_CONTROL));
	SENDCMDINPARAMS      cmdInParameters = *(PSENDCMDINPARAMS)(((PUCHAR)Srb->DataBuffer) + sizeof(SRB_IO_CONTROL));
	PIDEREGS             regs = &cmdInParameters.irDriveRegs;
	ULONG                i;
	UCHAR                statusByte,targetId, status;


	switch (((PSRB_IO_CONTROL)(Srb->DataBuffer))->ControlCode) {

		case IOCTL_SCSI_MINIPORT_SMART_VERSION: {

			PGETVERSIONINPARAMS versionParameters = (PGETVERSIONINPARAMS)(((PUCHAR)Srb->DataBuffer) + sizeof(SRB_IO_CONTROL));
			UCHAR deviceNumber;

			//
			// Version and revision per SMART 1.03
			//
			versionParameters->bVersion = 1;
			versionParameters->bRevision = 1;
			versionParameters->bReserved = 0;

			//
			// Indicate that support for IDE IDENTIFY, ATAPI IDENTIFY and SMART commands.
			//

			versionParameters->fCapabilities = (CAP_ATA_ID_CMD | CAP_ATAPI_ID_CMD | CAP_SMART_CMD);

			//
			// This is done because of how the IOCTL_SCSI_MINIPORT
			// determines 'targetid's'. Disk.sys places the real target id value
			// in the DeviceMap field. Once we do some parameter checking, the value passed
			// back to the application will be determined.
			//

			deviceNumber = versionParameters->bIDEDeviceMap;

			if (pDev->DeviceFlags & DFLAGS_ATAPI) {

				status = SRB_STATUS_SELECTION_TIMEOUT;
				goto out;
			}


			versionParameters->bIDEDeviceMap = (1 << Srb->TargetId);

			status = SRB_STATUS_SUCCESS;
			goto out;
		}

		case IOCTL_SCSI_MINIPORT_IDENTIFY: {

		   if (cmdInParameters.irDriveRegs.bCommandReg == ID_CMD) {

				//
				// Extract the target.
				//
	
			   targetId = cmdInParameters.bDriveNumber;
	
			   if (pDev->DeviceFlags & DFLAGS_ATAPI) {
timeout:
				   status = SRB_STATUS_SELECTION_TIMEOUT;
				   goto out;
			   }
	
				//
				// Zero the output buffer
				//
	
			   for (i = 0; i < (sizeof(SENDCMDOUTPARAMS) + IDENTIFY_BUFFER_SIZE - 1); i++) {
				   ((PUCHAR)cmdOutParameters)[i] = 0;
			   }
	
				//
				// Build status block.
				//
	
			   cmdOutParameters->cBufferSize = IDENTIFY_BUFFER_SIZE;
			   cmdOutParameters->DriverStatus.bDriverError = 0;
			   cmdOutParameters->DriverStatus.bIDEError = 0;
	
				//
				// Extract the identify data from the device extension.
				//
	
			   ZeroMemory(cmdOutParameters->bBuffer, 512);
			   ScsiPortMoveMemory (cmdOutParameters->bBuffer, &pDev->IdentifyData, IDENTIFY_DATA_SIZE);
	
			   status = SRB_STATUS_SUCCESS;
	
	
		   } else {
			   status = SRB_STATUS_INVALID_REQUEST;
		   }
		   goto out;
		   }

		case  IOCTL_SCSI_MINIPORT_READ_SMART_ATTRIBS:
		case  IOCTL_SCSI_MINIPORT_READ_SMART_THRESHOLDS:
		case  IOCTL_SCSI_MINIPORT_ENABLE_SMART:
		case  IOCTL_SCSI_MINIPORT_DISABLE_SMART:
		case  IOCTL_SCSI_MINIPORT_RETURN_STATUS:
		case  IOCTL_SCSI_MINIPORT_ENABLE_DISABLE_AUTOSAVE:
		case  IOCTL_SCSI_MINIPORT_SAVE_ATTRIBUTE_VALUES:
		case  IOCTL_SCSI_MINIPORT_EXECUTE_OFFLINE_DIAGS:
			break;

		default :

			status = SRB_STATUS_INVALID_REQUEST;
			goto out;
	}


	Srb->SrbStatus = SRB_STATUS_PENDING;

	if (cmdInParameters.irDriveRegs.bCommandReg == SMART_CMD) {

		targetId = cmdInParameters.bDriveNumber;

		//TODO optimize this check

		if (pDev->DeviceFlags & DFLAGS_ATAPI) {

			goto timeout;
		}

		pDev->SmartCommand = cmdInParameters.irDriveRegs.bFeaturesReg;

		//
		// Determine which of the commands to carry out.
		//

		if ((cmdInParameters.irDriveRegs.bFeaturesReg == READ_ATTRIBUTES) ||
			  (cmdInParameters.irDriveRegs.bFeaturesReg == READ_THRESHOLDS)) {

			statusByte = WaitOnBusy(ControlPort);

			if (statusByte & IDE_STATUS_BUSY) {
busy:
				status = SRB_STATUS_BUSY;
				goto out;
			}

			//
			// Zero the ouput buffer as the input buffer info. has been saved off locally (the buffers are the same).
			//

			for (i = 0; i < (sizeof(SENDCMDOUTPARAMS) + READ_ATTRIBUTE_BUFFER_SIZE - 1); i++) {
				((PUCHAR)cmdOutParameters)[i] = 0;
			}

			//
			// Set data buffer pointer and words left.
			//

			pChan->BufferPtr = (ADDRESS)cmdOutParameters->bBuffer;
			pChan->WordsLeft = READ_ATTRIBUTE_BUFFER_SIZE / 2;

			ScsiPortWritePortUchar(&IoPort->DriveSelect,(UCHAR)((targetId << 4) | 0xA0));
			ScsiPortWritePortUchar((PUCHAR)IoPort + 1,regs->bFeaturesReg);
			ScsiPortWritePortUchar(&IoPort->BlockCount,regs->bSectorCountReg);
			ScsiPortWritePortUchar(&IoPort->BlockNumber,regs->bSectorNumberReg);
			ScsiPortWritePortUchar(&IoPort->CylinderLow,regs->bCylLowReg);
			ScsiPortWritePortUchar(&IoPort->CylinderHigh,regs->bCylHighReg);
			ScsiPortWritePortUchar(&IoPort->Command,regs->bCommandReg);

			//
			// Wait for interrupt.
			//

			return;

		} else if ((cmdInParameters.irDriveRegs.bFeaturesReg == ENABLE_SMART) ||
				   (cmdInParameters.irDriveRegs.bFeaturesReg == DISABLE_SMART) ||
				   (cmdInParameters.irDriveRegs.bFeaturesReg == RETURN_SMART_STATUS) ||
				   (cmdInParameters.irDriveRegs.bFeaturesReg == ENABLE_DISABLE_AUTOSAVE) ||
				   (cmdInParameters.irDriveRegs.bFeaturesReg == EXECUTE_OFFLINE_DIAGS) ||
				   (cmdInParameters.irDriveRegs.bFeaturesReg == SAVE_ATTRIBUTE_VALUES)) {

			statusByte = WaitOnBusy(ControlPort);

			if (statusByte & IDE_STATUS_BUSY) {
				goto busy;
			}

			//
			// Zero the ouput buffer as the input buffer info. has been saved off locally (the buffers are the same).
			//

			for (i = 0; i < (sizeof(SENDCMDOUTPARAMS) - 1); i++) {
				((PUCHAR)cmdOutParameters)[i] = 0;
			}

			//
			// Set data buffer pointer and indicate no data transfer.
			//

			pChan->BufferPtr = (ADDRESS)cmdOutParameters->bBuffer;
			pChan->WordsLeft = 0;

			//
			// Indicate expecting an interrupt.
			//

			ScsiPortWritePortUchar(&IoPort->DriveSelect,(UCHAR)((targetId << 4) | 0xA0));
			ScsiPortWritePortUchar((PUCHAR)IoPort + 1,regs->bFeaturesReg);
			ScsiPortWritePortUchar(&IoPort->BlockCount,regs->bSectorCountReg);
			ScsiPortWritePortUchar(&IoPort->BlockNumber,regs->bSectorNumberReg);
			ScsiPortWritePortUchar(&IoPort->CylinderLow,regs->bCylLowReg);
			ScsiPortWritePortUchar(&IoPort->CylinderHigh,regs->bCylHighReg);
			ScsiPortWritePortUchar(&IoPort->Command,regs->bCommandReg);

			//
			// Wait for interrupt.
			//

			return ;
		}
	}

	status = SRB_STATUS_INVALID_REQUEST;
out:
	Srb->SrbStatus = status;


} // end IdeSendSmartCommand()

PSCSI_REQUEST_BLOCK
   BuildMechanismStatusSrb (
							IN PChannel pChan,
							IN ULONG PathId,
							IN ULONG TargetId
						   )
{
	PSCSI_REQUEST_BLOCK Srb;
	PCDB cdb;

	Srb = &pChan->InternalSrb;

	ZeroMemory((PUCHAR) Srb, sizeof(SCSI_REQUEST_BLOCK));

	Srb->PathId     = (UCHAR) PathId;
	Srb->TargetId   = (UCHAR) TargetId;
	Srb->Function   = SRB_FUNCTION_EXECUTE_SCSI;
	Srb->Length     = sizeof(SCSI_REQUEST_BLOCK);

	//
	// Set flags to disable synchronous negociation.
	//
	Srb->SrbFlags = SRB_FLAGS_DATA_IN | SRB_FLAGS_DISABLE_SYNCH_TRANSFER;

	//
	// Set timeout to 2 seconds.
	//
	Srb->TimeOutValue = 4;

	Srb->CdbLength          = 6;
	Srb->DataBuffer         = &pChan->MechStatusData;
	Srb->DataTransferLength = sizeof(MECHANICAL_STATUS_INFORMATION_HEADER);

	//
	// Set CDB operation code.
	//
	cdb = (PCDB)Srb->Cdb;
	cdb->MECH_STATUS.OperationCode       = SCSIOP_MECHANISM_STATUS;
	cdb->MECH_STATUS.AllocationLength[1] = sizeof(MECHANICAL_STATUS_INFORMATION_HEADER);

	return Srb;
}

PSCSI_REQUEST_BLOCK
   BuildRequestSenseSrb (
						 IN PChannel pChan,
						 IN ULONG PathId,
						 IN ULONG TargetId
						)
{
	PSCSI_REQUEST_BLOCK Srb;
	PCDB cdb;

	Srb = &pChan->InternalSrb;

	ZeroMemory((PUCHAR) Srb, sizeof(SCSI_REQUEST_BLOCK));

	Srb->PathId     = (UCHAR) PathId;
	Srb->TargetId   = (UCHAR) TargetId;
	Srb->Function   = SRB_FUNCTION_EXECUTE_SCSI;
	Srb->Length     = sizeof(SCSI_REQUEST_BLOCK);

	//
	// Set flags to disable synchronous negociation.
	//
	Srb->SrbFlags = SRB_FLAGS_DATA_IN | SRB_FLAGS_DISABLE_SYNCH_TRANSFER;

	//
	// Set timeout to 2 seconds.
	//
	Srb->TimeOutValue = 4;

	Srb->CdbLength          = 6;
	Srb->DataBuffer         = &pChan->MechStatusSense;
	Srb->DataTransferLength = sizeof(SENSE_DATA);

	//
	// Set CDB operation code.
	//
	cdb = (PCDB)Srb->Cdb;
	cdb->CDB6INQUIRY.OperationCode    = SCSIOP_REQUEST_SENSE;
	cdb->CDB6INQUIRY.AllocationLength = sizeof(SENSE_DATA);

	return Srb;
}


#ifdef WIN2000

SCSI_ADAPTER_CONTROL_STATUS
   AtapiAdapterControl(
					   IN PHW_DEVICE_EXTENSION deviceExtension,
					   IN SCSI_ADAPTER_CONTROL_TYPE ControlType,
					   IN PVOID Parameters
					  )

/*++

Routine Description:

    This routine is called at various time's by SCSIPort and is used
    to provide a control function over the adapter. Most commonly, NT
    uses this entry point to control the power state of the HBA during
    a hibernation operation.

Arguments:

    HwDeviceExtension - HBA miniport driver's per adapter storage
    Parameters  - This varies by control type, see below.
    ControlType - Indicates which adapter control function should be 
                  executed. Conrol Types are detailed below.

Return Value:

    ScsiAdapterControlSuccess - requested ControlType completed successfully
    ScsiAdapterControlUnsuccessful - requested ControlType failed

--*/


{
	int i;
	
	KdPrint(("AtapiAdapterControl(ext=%x, type=%d)", deviceExtension, ControlType));
	
	//
	// Execute the correct code path based on ControlType
	//
	switch (ControlType) {

	case ScsiQuerySupportedControlTypes:
		//
		// This entry point provides the method by which SCSIPort determines the
		// supported ControlTypes. Parameters is a pointer to a
		// SCSI_SUPPORTED_CONTROL_TYPE_LIST structure. Fill in this structure
		// honoring the size limits.
		//
		{
			BOOLEAN SupportedConrolTypes[MAX_CONTROL_TYPE] = {
				TRUE,   // ScsiQuerySupportedControlTypes
				TRUE,   // ScsiStopAdapter
				TRUE,   // ScsiRestartAdapter
				TRUE,   // ScsiSetBootConfig
				TRUE    // ScsiSetRunningConfig
			};
			PSCSI_SUPPORTED_CONTROL_TYPE_LIST ControlTypeList;
			ULONG AdjustedMaxControlType, Index;

			ControlTypeList = Parameters;
			AdjustedMaxControlType = 
									(ControlTypeList->MaxControlType < MAX_CONTROL_TYPE) ? 
									ControlTypeList->MaxControlType : MAX_CONTROL_TYPE;
	
			for (Index = 0; Index < AdjustedMaxControlType; Index++) {
				ControlTypeList->SupportedTypeList[Index] = 
					SupportedConrolTypes[Index];
			};
		}
		return ScsiAdapterControlSuccess;

	case ScsiStopAdapter:
		//
		// This entry point is called by SCSIPort when it needs to stop/disable
		// the HBA. Parameters is a pointer to the HBA's HwDeviceExtension. The adapter
		// has already been quiesced by SCSIPort (i.e. no outstanding SRBs). Hence the adapter
		// should abort/complete any internally generated commands, disable adapter interrupts
		// and optionally power down the adapter.
		//
		return ScsiAdapterControlSuccess;

	case ScsiRestartAdapter:
		/* 
		 * Reinitializes an HBA. The port driver calls HwScsiAdapterControl with this 
		 * control type to power up an HBA that was shut down for power management. 
		 * All resources previously assigned to the miniport are still available, and 
		 * its device extension and logical unit extensions, if any, are intact. 
		 * The miniport performs the same operations as in its HwScsiInitialize routine, 
		 * such as setting up the HBA's registers and its initial state, if any. 
		 */
		{
			PUCHAR BMI;
			int bus, id;
			PChannel pChan;
			PDevice pDev;
			BMI = deviceExtension->IDEChannel[0].BaseBMI;
			OutPort(BMI+0x7A, 0x10);
			exlude_num = deviceExtension->IDEChannel[0].exclude_index-1;
			SetHptChip(deviceExtension->IDEChannel, BMI);
			for (bus=0; bus<2; bus++) {
				pChan = &deviceExtension->IDEChannel[bus];
				for (id=0; id<2; id++) {
					pDev = pChan->pDevice[id];
					if (pDev && !(pDev->DeviceFlags2 & DFLAGS_DEVICE_DISABLED)) {
						pDev->IoCount = 0;
						pDev->IoSuccess = 0;
						pDev->ResetCount = 0;
						SetDevice(pDev);
						DeviceSelectMode(pDev, pDev->Usable_Mode);
					}
				}
			}
			OutPort(BMI+0x7A, 0);
		}

		return ScsiAdapterControlSuccess;

	case ScsiSetBootConfig:
		/*
		 * save IO space registers
		 */
		for (i=0; i<5; i++)
			deviceExtension->io_space[i] = 
				pci_read_config_dword(deviceExtension->pci_bus, 
					deviceExtension->pci_dev, 0, (UCHAR)(0x10+i*4));

		return ScsiAdapterControlSuccess;

	case ScsiSetRunningConfig:
	
		/* PCI Command */
		pci_write_config_byte(deviceExtension->pci_bus, 
			deviceExtension->pci_dev, 0, REG_PCICMD, 5);
		/* I/O space */
		for (i=0; i<5; i++)
			pci_write_config_dword(deviceExtension->pci_bus, 
				deviceExtension->pci_dev, 0, (UCHAR)(0x10+i*4), deviceExtension->io_space[i]);
		/* Cache line size */
		pci_write_config_byte(deviceExtension->pci_bus, deviceExtension->pci_dev, 0, 
			0xC, deviceExtension->pci_reg_0c);
		/* Latency timer */
		pci_write_config_byte(deviceExtension->pci_bus, deviceExtension->pci_dev, 0, 
			0xD, deviceExtension->pci_reg_0d);
		/* Interrupt line */
		pci_write_config_byte(deviceExtension->pci_bus, deviceExtension->pci_dev, 0, 
			0x3C, deviceExtension->IDEChannel[0].InterruptLevel);
		/* Power state */
		pci_write_config_byte(deviceExtension->pci_bus, deviceExtension->pci_dev, 0, 0x64, 0);
		/* EPROM mapping */
		pci_write_config_byte(deviceExtension->pci_bus, deviceExtension->pci_dev, 0, 0x70, 0);

		return ScsiAdapterControlSuccess;
	}

	return ScsiAdapterControlUnsuccessful;
}
#endif //WIN2000

/******************************************************************
 * Get Stamps 
 *******************************************************************/

ULONG GetStamp(void)
{
	static ULONG last_stamp = 0x1ABCDEF2;
	return ++last_stamp;
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\port\scsi\miniport\ibm\cbidf\atapi.h ===
/*++

Copyright (c) 1993  Microsoft Corporation

Module Name:

    atapi.h

Abstract:

    This module contains the structures and definitions for the ATAPI
    IDE miniport driver.

Author:

    Mike Glass


Revision History:

--*/

#include "scsi.h"
#include "stddef.h"
#include "stdio.h"
#include "string.h"
//
// IDE register definition
//

typedef struct _IDE_REGISTERS_1 {
    USHORT Data;
    UCHAR BlockCount;
    UCHAR BlockNumber;
    UCHAR CylinderLow;
    UCHAR CylinderHigh;
    UCHAR DriveSelect;
    UCHAR Command;
    ULONG Data32;
    UCHAR DmaReg;
} IDE_REGISTERS_1, *PIDE_REGISTERS_1;

typedef struct _IDE_REGISTERS_2 {
    UCHAR AlternateStatus;
    UCHAR DriveAddress;
} IDE_REGISTERS_2, *PIDE_REGISTERS_2;

typedef struct _IDE_REGISTERS_3 {
    ULONG Data;
    UCHAR Others[4];
} IDE_REGISTERS_3, *PIDE_REGISTERS_3;

//
// Device Extension Device Flags
//

#define DFLAGS_DEVICE_PRESENT        0x0001    // Indicates that some device is present.
#define DFLAGS_ATAPI_DEVICE          0x0002    // Indicates whether Atapi commands can be used.
#define DFLAGS_TAPE_DEVICE           0x0004    // Indicates whether this is a tape device.
#define DFLAGS_INT_DRQ               0x0008    // Indicates whether device interrupts as DRQ is set after
                                               // receiving Atapi Packet Command
#define DFLAGS_REMOVABLE_DRIVE       0x0010    // Indicates that the drive has the 'removable' bit set in
                                               // identify data (offset 128)
#define DFLAGS_MEDIA_STATUS_ENABLED  0x0020    // Media status notification enabled
#define DFLAGS_ATAPI_CHANGER         0x0040    // Indicates atapi 2.5 changer present.
#define DFLAGS_SANYO_ATAPI_CHANGER   0x0080    // Indicates multi-platter device, not conforming to the 2.5 spec.
#define DFLAGS_CHANGER_INITED        0x0100    // Indicates that the init path for changers has already been done.
//
// Used to disable 'advanced' features.
//

#define MAX_ERRORS                     4

//
// ATAPI command definitions
//

#define ATAPI_MODE_SENSE   0x5A
#define ATAPI_MODE_SELECT  0x55
#define ATAPI_FORMAT_UNIT  0x24

//
// ATAPI Command Descriptor Block
//

typedef struct _MODE_SENSE_10 {
        UCHAR OperationCode;
        UCHAR Reserved1;
        UCHAR PageCode : 6;
        UCHAR Pc : 2;
        UCHAR Reserved2[4];
        UCHAR ParameterListLengthMsb;
        UCHAR ParameterListLengthLsb;
        UCHAR Reserved3[3];
} MODE_SENSE_10, *PMODE_SENSE_10;

typedef struct _MODE_SELECT_10 {
        UCHAR OperationCode;
        UCHAR Reserved1 : 4;
        UCHAR PFBit : 1;
        UCHAR Reserved2 : 3;
        UCHAR Reserved3[5];
        UCHAR ParameterListLengthMsb;
        UCHAR ParameterListLengthLsb;
        UCHAR Reserved4[3];
} MODE_SELECT_10, *PMODE_SELECT_10;

typedef struct _MODE_PARAMETER_HEADER_10 {
    UCHAR ModeDataLengthMsb;
    UCHAR ModeDataLengthLsb;
    UCHAR MediumType;
    UCHAR Reserved[5];
}MODE_PARAMETER_HEADER_10, *PMODE_PARAMETER_HEADER_10;

//
// IDE command definitions
//

#define IDE_COMMAND_ATAPI_RESET      0x08
#define IDE_COMMAND_RECALIBRATE      0x10
#define IDE_COMMAND_READ             0x20
#define IDE_COMMAND_WRITE            0x30
#define IDE_COMMAND_VERIFY           0x40
#define IDE_COMMAND_SEEK             0x70
#define IDE_COMMAND_SET_DRIVE_PARAMETERS 0x91
#define IDE_COMMAND_ATAPI_PACKET     0xA0
#define IDE_COMMAND_ATAPI_IDENTIFY   0xA1
#define IDE_COMMAND_READ_MULTIPLE    0xC4
#define IDE_COMMAND_WRITE_MULTIPLE   0xC5
#define IDE_COMMAND_SET_MULTIPLE     0xC6
#define IDE_COMMAND_READ_DMA         0xC8
#define IDE_COMMAND_WRITE_DMA             0xCA
#define IDE_COMMAND_GET_MEDIA_STATUS      0xDA
#define IDE_COMMAND_ENABLE_MEDIA_STATUS   0xEF
#define IDE_COMMAND_IDENTIFY              0xEC
#define IDE_COMMAND_MEDIA_EJECT           0xED

//
// IDE status definitions
//

#define IDE_STATUS_ERROR             0x01
#define IDE_STATUS_INDEX             0x02
#define IDE_STATUS_CORRECTED_ERROR   0x04
#define IDE_STATUS_DRQ               0x08
#define IDE_STATUS_DSC               0x10
#define IDE_STATUS_DRDY              0x40
#define IDE_STATUS_IDLE              0x50
#define IDE_STATUS_BUSY              0x80

//
// IDE drive select/head definitions
//

#define IDE_DRIVE_SELECT_1           0xA0
#define IDE_DRIVE_SELECT_2           0x10

//
// IDE drive control definitions
//

#define IDE_DC_DISABLE_INTERRUPTS    0x02
#define IDE_DC_RESET_CONTROLLER      0x04
#define IDE_DC_REENABLE_CONTROLLER   0x00

//
// IDE error definitions
//

#define IDE_ERROR_BAD_BLOCK          0x80
#define IDE_ERROR_DATA_ERROR         0x40
#define IDE_ERROR_MEDIA_CHANGE       0x20
#define IDE_ERROR_ID_NOT_FOUND       0x10
#define IDE_ERROR_MEDIA_CHANGE_REQ   0x08
#define IDE_ERROR_COMMAND_ABORTED    0x04
#define IDE_ERROR_END_OF_MEDIA       0x02
#define IDE_ERROR_ILLEGAL_LENGTH     0x01

//
// ATAPI register definition
//

typedef struct _ATAPI_REGISTERS_1 {
    USHORT Data;
    UCHAR InterruptReason;
    UCHAR Unused1;
    UCHAR ByteCountLow;
    UCHAR ByteCountHigh;
    UCHAR DriveSelect;
    UCHAR Command;
    ULONG Data32;
    UCHAR DmaReg;
} ATAPI_REGISTERS_1, *PATAPI_REGISTERS_1;

typedef struct _ATAPI_REGISTERS_2 {
    UCHAR AlternateStatus;
    UCHAR DriveAddress;
} ATAPI_REGISTERS_2, *PATAPI_REGISTERS_2;

//
// ATAPI interrupt reasons
//

#define ATAPI_IR_COD 0x01
#define ATAPI_IR_IO  0x02

//
// IDENTIFY data
//

typedef struct _IDENTIFY_DATA {
    USHORT GeneralConfiguration;            // 00 00
    USHORT NumberOfCylinders;               // 02  1
    USHORT Reserved1;                       // 04  2
    USHORT NumberOfHeads;                   // 06  3
    USHORT UnformattedBytesPerTrack;        // 08  4
    USHORT UnformattedBytesPerSector;       // 0A  5
    USHORT SectorsPerTrack;                 // 0C  6
    USHORT VendorUnique1[3];                // 0E  7-9
    USHORT SerialNumber[10];                // 14  10-19
    USHORT BufferType;                      // 28  20
    USHORT BufferSectorSize;                // 2A  21
    USHORT NumberOfEccBytes;                // 2C  22
    USHORT FirmwareRevision[4];             // 2E  23-26
    USHORT ModelNumber[20];                 // 36  27-46
    UCHAR  MaximumBlockTransfer;            // 5E  47
    UCHAR  VendorUnique2;                   // 5F
    USHORT DoubleWordIo;                    // 60  48
    USHORT Capabilities;                    // 62  49
    USHORT Reserved2;                       // 64  50
    UCHAR  VendorUnique3;                   // 66  51
    UCHAR  PioCycleTimingMode;              // 67
    UCHAR  VendorUnique4;                   // 68  52
    UCHAR  DmaCycleTimingMode;              // 69
    USHORT TranslationFieldsValid:1;        // 6A  53
    USHORT Reserved3:15;
    USHORT NumberOfCurrentCylinders;        // 6C  54
    USHORT NumberOfCurrentHeads;            // 6E  55
    USHORT CurrentSectorsPerTrack;          // 70  56
    ULONG  CurrentSectorCapacity;           // 72  57-58
    USHORT CurrentMultiSectorSetting;       //     59
    ULONG  UserAddressableSectors;          //     60-61
    USHORT SingleWordDMASupport : 8;        //     62
    USHORT SingleWordDMAActive : 8;
    USHORT MultiWordDMASupport : 8;         //     63
    USHORT MultiWordDMAActive : 8;
    USHORT AdvancedPIOModes : 8;            //     64
    USHORT Reserved4 : 8;
    USHORT MinimumMWXferCycleTime;          //     65
    USHORT RecommendedMWXferCycleTime;      //     66
    USHORT MinimumPIOCycleTime;             //     67
    USHORT MinimumPIOCycleTimeIORDY;        //     68
    USHORT Reserved5[2];                    //     69-70
    USHORT ReleaseTimeOverlapped;           //     71
    USHORT ReleaseTimeServiceCommand;       //     72
    USHORT MajorRevision;                   //     73
    USHORT MinorRevision;                   //     74
    USHORT Reserved6[50];                   //     75-126
    USHORT SpecialFunctionsEnabled;         //     127
    USHORT Reserved7[128];                  //     128-255
} IDENTIFY_DATA, *PIDENTIFY_DATA;

//
// Identify data without the Reserved4.
//

typedef struct _IDENTIFY_DATA2 {
    USHORT GeneralConfiguration;            // 00
    USHORT NumberOfCylinders;               // 02
    USHORT Reserved1;                       // 04
    USHORT NumberOfHeads;                   // 06
    USHORT UnformattedBytesPerTrack;        // 08
    USHORT UnformattedBytesPerSector;       // 0A
    USHORT SectorsPerTrack;                 // 0C
    USHORT VendorUnique1[3];                // 0E
    USHORT SerialNumber[10];                // 14
    USHORT BufferType;                      // 28
    USHORT BufferSectorSize;                // 2A
    USHORT NumberOfEccBytes;                // 2C
    USHORT FirmwareRevision[4];             // 2E
    USHORT ModelNumber[20];                 // 36
    UCHAR  MaximumBlockTransfer;            // 5E
    UCHAR  VendorUnique2;                   // 5F
    USHORT DoubleWordIo;                    // 60
    USHORT Capabilities;                    // 62
    USHORT Reserved2;                       // 64
    UCHAR  VendorUnique3;                   // 66
    UCHAR  PioCycleTimingMode;              // 67
    UCHAR  VendorUnique4;                   // 68
    UCHAR  DmaCycleTimingMode;              // 69
    USHORT TranslationFieldsValid:1;        // 6A
    USHORT Reserved3:15;
    USHORT NumberOfCurrentCylinders;        // 6C
    USHORT NumberOfCurrentHeads;            // 6E
    USHORT CurrentSectorsPerTrack;          // 70
    USHORT CurrentSectorCapacityLo;         // 72
    USHORT CurrentSectorCapacityHi;
    USHORT CurrentMultiSectorSetting;       // 76
    ULONG  UserAddressableSectors;          // 78
} IDENTIFY_DATA2, *PIDENTIFY_DATA2;

#define IDENTIFY_DATA_SIZE sizeof(IDENTIFY_DATA)

//
// IDENTIFY capability bit definitions.
//

#define IDENTIFY_CAPABILITIES_DMA_SUPPORTED 0x0100
#define IDENTIFY_CAPABILITIES_LBA_SUPPORTED 0x0200

//
// IDENTIFY DMA timing cycle modes.
//

#define IDENTIFY_DMA_CYCLES_MODE_0 0x00
#define IDENTIFY_DMA_CYCLES_MODE_1 0x01
#define IDENTIFY_DMA_CYCLES_MODE_2 0x02


typedef struct _BROKEN_CONTROLLER_INFORMATION {
    PCHAR   VendorId;
    ULONG   VendorIdLength;
    PCHAR   DeviceId;
    ULONG   DeviceIdLength;
}BROKEN_CONTROLLER_INFORMATION, *PBROKEN_CONTROLLER_INFORMATION;

BROKEN_CONTROLLER_INFORMATION const BrokenAdapters[] = {
    { "1095", 4, "0640", 4},
    { "1039", 4, "0601", 4}
};

#define BROKEN_ADAPTERS (sizeof(BrokenAdapters) / sizeof(BROKEN_CONTROLLER_INFORMATION))

typedef struct _NATIVE_MODE_CONTROLLER_INFORMATION {
    PCHAR   VendorId;
    ULONG   VendorIdLength;
    PCHAR   DeviceId;
    ULONG   DeviceIdLength;
}NATIVE_MODE_CONTROLLER_INFORMATION, *PNATIVE_MODE_CONTROLLER_INFORMATION;

NATIVE_MODE_CONTROLLER_INFORMATION const NativeModeAdapters[] = {
    { "10ad", 4, "0105", 4}
};
#define NUM_NATIVE_MODE_ADAPTERS (sizeof(NativeModeAdapters) / sizeof(NATIVE_MODE_CONTROLLER_INFORMATION))

//
// Beautification macros
//

#define GetStatus(BaseIoAddress, Status) \
    Status = ScsiPortReadPortUchar(&BaseIoAddress->AlternateStatus);

#define GetBaseStatus(BaseIoAddress, Status) \
    Status = ScsiPortReadPortUchar(&BaseIoAddress->Command);

#define WriteCommand(BaseIoAddress, Command) \
    ScsiPortWritePortUchar(&BaseIoAddress->Command, Command);



#define ReadBuffer(BaseIoAddress, Buffer, Count) \
    ScsiPortReadPortBufferUshort(&BaseIoAddress->Data, \
                                 Buffer, \
                                 Count);

#define WriteBuffer(BaseIoAddress, Buffer, Count) \
    ScsiPortWritePortBufferUshort(&BaseIoAddress->Data, \
                                  Buffer, \
                                  Count);

#define ReadBuffer32(BaseIoAddress, Buffer, Count) \
    ScsiPortReadPortBufferUlong((PULONG)&BaseIoAddress->Data32, \
                                Buffer, \
                                Count);

#define WriteBuffer32(BaseIoAddress, Buffer, Count) \
    ScsiPortWritePortBufferUlong((PULONG)&BaseIoAddress->Data32, \
                                 Buffer, \
                                 Count);

#define WaitOnBusy(BaseIoAddress, Status) \
{ \
    ULONG i; \
    for (i=0; i<20000; i++) { \
        GetStatus(BaseIoAddress, Status); \
        if (Status & IDE_STATUS_BUSY) { \
            ScsiPortStallExecution(150); \
            continue; \
        } else { \
            break; \
        } \
    } \
}

#define WaitOnBaseBusy(BaseIoAddress, Status) \
{ \
    ULONG i; \
    for (i=0; i<20000; i++) { \
        GetBaseStatus(BaseIoAddress, Status); \
        if (Status & IDE_STATUS_BUSY) { \
            ScsiPortStallExecution(150); \
            continue; \
        } else { \
            break; \
        } \
    } \
}

#define WaitForDrq(BaseIoAddress, Status) \
{ \
    ULONG i; \
    for (i=0; i<1000; i++) { \
        GetStatus(BaseIoAddress, Status); \
        if (Status & IDE_STATUS_BUSY) { \
            ScsiPortStallExecution(100); \
        } else if (Status & IDE_STATUS_DRQ) { \
            break; \
        } else { \
            ScsiPortStallExecution(200); \
        } \
    } \
}


#define WaitShortForDrq(BaseIoAddress, Status) \
{ \
    ULONG i; \
    for (i=0; i<2; i++) { \
        GetStatus(BaseIoAddress, Status); \
        if (Status & IDE_STATUS_BUSY) { \
            ScsiPortStallExecution(100); \
        } else if (Status & IDE_STATUS_DRQ) { \
            break; \
        } else { \
            ScsiPortStallExecution(100); \
        } \
    } \
}

#define AtapiSoftReset(BaseIoAddress,BaseIoAddress2,DeviceNumber) \
{\
    UCHAR statusByte; \
    ScsiPortWritePortUchar(&BaseIoAddress->DriveSelect,(UCHAR)(((DeviceNumber & 0x1) << 4) | 0xA0)); \
    ScsiPortStallExecution(500);\
    ScsiPortWritePortUchar(&BaseIoAddress->Command, IDE_COMMAND_ATAPI_RESET); \
    ScsiPortStallExecution(1000*1000);\
    ScsiPortWritePortUchar(&BaseIoAddress->DriveSelect,(UCHAR)((DeviceNumber << 4) | 0xA0)); \
    WaitOnBusy(BaseIoAddress2,statusByte); \
    ScsiPortStallExecution(500);\
}

#define IdeHardReset(BaseIoAddress,result) \
{\
    UCHAR statusByte;\
    ULONG i;\
    ScsiPortWritePortUchar(&BaseIoAddress->AlternateStatus,IDE_DC_RESET_CONTROLLER );\
    ScsiPortStallExecution(50 * 1000);\
    ScsiPortWritePortUchar(&BaseIoAddress->AlternateStatus,IDE_DC_REENABLE_CONTROLLER);\
    for (i = 0; i < 1000 * 1000; i++) {\
        statusByte = ScsiPortReadPortUchar(&BaseIoAddress->AlternateStatus);\
        if (statusByte != IDE_STATUS_IDLE && statusByte != 0x0) {\
            ScsiPortStallExecution(5);\
        } else {\
            break;\
        }\
    }\
    if (i == 1000*1000) {\
        result = FALSE;\
    }\
    result = TRUE;\
}

#define IS_RDP(OperationCode)\
    ((OperationCode == SCSIOP_ERASE)||\
    (OperationCode == SCSIOP_LOAD_UNLOAD)||\
    (OperationCode == SCSIOP_LOCATE)||\
    (OperationCode == SCSIOP_REWIND) ||\
    (OperationCode == SCSIOP_SPACE)||\
    (OperationCode == SCSIOP_SEEK)||\
    (OperationCode == SCSIOP_WRITE_FILEMARKS))


=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\port\scsi\miniport\megaide\hddefs.h ===
#ifndef _HDDEFS_H_
#define _HDDEFS_H_


/**************************

  Change this Definition to build Win2k or WinNT and Win9x drivers

***************************/

#define HYPERDISK_WIN2K
//#define HYPERDISK_WINNT
//#define HYPERDISK_WIN98

//#define KEEP_LOG    // to keep note of log activity

// Use this for supplying a dummy IRCD to the Driver.
// See the definition of gucDummyIRCD variable for more information
// #define DUMMY_RAID10_IRCD

//
// System log error codes for some miniport error events.
//
#define HYPERDISK_RESET_DETECTED                0
#define HYPERDISK_DRIVE_LOST_POWER              HYPERDISK_RESET_DETECTED + 1
#define HYPERDISK_DRIVE_BUSY                    HYPERDISK_DRIVE_LOST_POWER + 1
#define HYPERDISK_ERROR_PENDING_SRBS_COUNT      HYPERDISK_DRIVE_BUSY + 1
#define HYPERDISK_ERROR_EXCEEDED_PDDS_PER_SRB	HYPERDISK_ERROR_PENDING_SRBS_COUNT + 1
#define HYPERDISK_RESET_BUS_FAILED              HYPERDISK_ERROR_EXCEEDED_PDDS_PER_SRB + 1
#define HYPERDISK_TOO_MANY_ERRORS               HYPERDISK_RESET_BUS_FAILED + 1


// #define FORCE_PIO

#define DRIVER_COMPILATION
#define INTERRUPT_LOOP          1

#ifdef HYPERDISK_WIN98

#define HD_ALLOCATE_SRBEXT_SEPERATELY

#endif // HYPERDISK_WIN98


#ifdef HYPERDISK_WIN2K

#define PNP_AND_POWER_MANAGEMENT

#endif // HYPERDISK_WIN2K


#endif // _HDDEFS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\port\scsi\miniport\megaide\hyperdisk.c ===
/************************************************************************

Copyright (c) 1997-99  American Megatrends Inc.,

Module Name:

	HyperDisk.c

Abstract:

    Source for HyperDisk PCI IDERAID Controller.

Author:

	Neela Syam Kolli
    Eric Moore
    Vasudevan Srinivasan

Revision History:

    29 March 2000 - Vasudevan
    - Rewritten for Clarity
    - Removed ATAPI Stuff

    October 11 2000 - Syam
    - The problem of giving the Raid10 stripe size as zero to the utility is fixed.
    - The Maximum number of outstanding commands for Raid10 are made equal to the Raid0 (it was equal to Raid1)

**************************************************************************/

#include "HDDefs.h"

#include "devioctl.h"
#include "miniport.h"

#if defined(HYPERDISK_WINNT) || defined(HYPERDISK_WIN2K)

#include "ntdddisk.h"
#include "ntddscsi.h"

#endif // defined(HYPERDISK_WINNT) || defined(HYPERDISK_WIN2K)

#ifdef HYPERDISK_WIN98

#include "9xdddisk.h"
#include "9xddscsi.h"

#endif // HYPERDISK_WIN98

#include "RIIOCtl.h"
#include "ErrorLog.h"

#include "HyperDisk.h"
#include "raid.h"

#include "LocalFunctions.h"

UCHAR                   gucControllerCount = 0;
BOOLEAN                 gbFinishedScanning = FALSE;
CARD_INFO               gaCardInfo[MAX_CONTROLLERS];
UCHAR                   gaucIRCDData[IDE_SECTOR_SIZE];
BOOLEAN                 bFoundIRCD = FALSE;
LARGE_INTEGER           gIRCDLockTime;
UCHAR                   gcIRCDLocked;
ULONG                   gulIRCDUnlockKey;
UCHAR                   gucStatusChangeFlag;
BOOLEAN                 gbDoNotUnlockIRCD = FALSE;
IDE_VERSION	            gFwVersion = {0}; // version of hyperdsk card

#define                 DEFAULT_DISPLAY_VALUE       3

// Begin Vasu
// gucDummyIRCD variable to hold dummy IRCD Information.

#ifdef DUMMY_RAID10_IRCD

UCHAR gucDummyIRCD[512] = {

/*
    IRCD Structure

    Logical Drive:  RAID 10, with 2 Stripes and 4 Drives with Online Status.
                    
                    1st Mirror : Primary Master and Secondary Master.
                    2nd Mirror : Primary Slave and Secondary Slave.
*/

    0x24, 0x58, 0x49, 0x44, 0x45, 0x24, 0x10, 0x0F, 0x32, 0x30, 0x06, 0x01, 0x04, 0x00, 0x00, 0x00,
    0x03, 0x10, 0x80, 0x00, 0x02, 0x04, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x10, 0xC0, 0xFB, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,     // PM
    0x10, 0x10, 0xC0, 0xFB, 0x00, 0x01, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,     // SM
    0x01, 0x10, 0x30, 0x20, 0x30, 0x01, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,     // PS
    0x11, 0x10, 0x30, 0x20, 0x30, 0x01, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00      // SS

};

#endif // DUMMY_RAID10_IRCD

// End Vasu

#ifdef HYPERDISK_WINNT

UCHAR                   gucNextControllerInd = 0;
BOOLEAN                 gbManualScan = FALSE;
BOOLEAN                 gbFindRoutineVisited = FALSE;

#endif

ULONG                   gulChangeIRCDPending;
ULONG                   gulLockVal;
ULONG                   gulPowerFailedTargetBitMap;

#ifdef DBG

ULONG SrbCount = 0;

#endif // DBG

VOID
AtapiHexToString (
	IN ULONG Value,
	IN OUT PCHAR *Buffer
)

{
	PCHAR  string;
	PCHAR  firstdig;
	CHAR   temp;
	ULONG i;
	USHORT digval;

	string = *Buffer;

	firstdig = string;

	for (i = 0; i < 4; i++) 
    {
		digval = (USHORT)(Value % 16);
		Value /= 16;

		//
		// convert to ascii and store. Note this will create
		// the buffer with the digits reversed.
		//

		if (digval > 9) 
        {
			*string++ = (char) (digval - 10 + 'a');
		} 
        else 
        {
			*string++ = (char) (digval + '0');
		}
	}

	//
	// Reverse the digits.
	//

	*string-- = '\0';

	do 
    {
		temp = *string;
		*string = *firstdig;
		*firstdig = temp;
		--string;
		++firstdig;
	} while (firstdig < string);

} // end AtapiHexToString ()

BOOLEAN
AtapiHwInitialize(
	IN PHW_DEVICE_EXTENSION DeviceExtension
)

/*++

Routine Description:

Arguments:

	HwDeviceExtension - HBA miniport driver's adapter data storage

Return Value:

	TRUE - if initialization successful.
	FALSE - if initialization unsuccessful.

--*/

{
	UCHAR maxDrives;
	UCHAR targetId;
	UCHAR channel;
	UCHAR statusByte, errorByte;
	UCHAR uchMRDMODE = 0;
	PBM_REGISTERS BMRegister = NULL;

#ifdef HYPERDISK_WIN2K

    if ( !DeviceExtension->bIsThruResetController )
    {
        //SetPCISpace(DeviceExtension);
        InitIdeRaidControllers(DeviceExtension);
    }

#endif // HYPERDISK_WIN2K

    //
    // Adjust SGL's buffer pointer for the physical drive
    //
    AssignSglPtrsForPhysicalCommands(DeviceExtension);

    EnableInterrupts (DeviceExtension);

    // Begin Vasu - 05 March 2001
    // Copied from the SetPCISpace function to here as SetPCISpace is not
    // called during initialization.
    BMRegister = DeviceExtension->BaseBmAddress[0];
    uchMRDMODE = ScsiPortReadPortUchar(((PUCHAR)BMRegister + 1));
    uchMRDMODE &= 0xF0; // Dont Clear Interrupt Pending Flags.
    uchMRDMODE |= 0x01; // Make it Read Multiple
    ScsiPortWritePortUchar(((PUCHAR)BMRegister + 1), uchMRDMODE);
    // End Vasu

    if ( !DeviceExtension->bIsThruResetController )
    {
        // Through the port driver directly... BIOS took care of everything... let us not worry anything about it
        return TRUE;
    }

	DebugPrint((3, "\nAtapiHwInitialize: Entering routine.\n"));

	for (targetId = 0; targetId < MAX_DRIVES_PER_CONTROLLER; targetId++) 
    {

        if ( DeviceExtension->PhysicalDrive[targetId].TimeOutErrorCount >= MAX_TIME_OUT_ERROR_COUNT )
        {
            continue;   // This drive has lost the power.... let us not do anything to this drive
        }

        DebugPrint((0,"AHI"));

		if (DeviceExtension->DeviceFlags[targetId] & DFLAGS_DEVICE_PRESENT) 
        {
			channel = targetId >> 1;

			if (!(DeviceExtension->DeviceFlags[targetId] & DFLAGS_ATAPI_DEVICE)) 
            {
				//
				// Enable media status notification
				//
				IdeMediaStatus(TRUE, DeviceExtension, targetId);

				//
				// If supported, setup Multi-block transfers.
				//

                SetMultiBlockXfers(DeviceExtension, targetId);
			} 
		}
	}

    DebugPrint((0,"AHI-D"));

	return TRUE;

} // end AtapiHwInitialize()


BOOLEAN
SetMultiBlockXfers( 
	IN PHW_DEVICE_EXTENSION DeviceExtension,
    UCHAR ucTargetId
        )
{
	PIDE_REGISTERS_1	    baseIoAddress;
    UCHAR                   statusByte, errorByte;

	baseIoAddress = DeviceExtension->BaseIoAddress1[ucTargetId>>1];
    //
    // If supported, setup Multi-block transfers.
    //

    if (DeviceExtension->MaximumBlockXfer[ucTargetId] != 0) 
    {
		//
		// Select the device.
		//

        SELECT_DEVICE(baseIoAddress, ucTargetId);

		//
		// Setup sector count to reflect the # of blocks.
		//

		ScsiPortWritePortUchar(&baseIoAddress->SectorCount,
				   DeviceExtension->MaximumBlockXfer[ucTargetId]);

		//
		// Issue the command.
		//

		ScsiPortWritePortUchar(&baseIoAddress->Command,
							   IDE_COMMAND_SET_MULTIPLE);

		//
		// Wait for busy to drop.
		//

		WAIT_ON_BASE_BUSY(baseIoAddress,statusByte);

		//
		// Check for errors. Reset the value to 0 (disable MultiBlock) if the
		// command was aborted.
		//

		if (statusByte & IDE_STATUS_ERROR) 
        {

            //
            // Read the error register.
            //

            errorByte = ScsiPortReadPortUchar((PUCHAR)baseIoAddress + 1);

            DebugPrint((0,
			            "AtapiHwInitialize: Error setting multiple mode. Status %x, error byte %x\n",
			            statusByte,
			            errorByte));
            //
            // Adjust the devExt. value, if necessary.
            //

            DeviceExtension->MaximumBlockXfer[ucTargetId] = 0;

		} 
        else 
        {
			DebugPrint((2,
						"AtapiHwInitialize: Using Multiblock on TID %d. Blocks / int - %d\n",
			ucTargetId,
			DeviceExtension->MaximumBlockXfer[ucTargetId]));
	    }
    }

    return TRUE;
}

VOID
changePCIConfiguration(
	IN PHW_DEVICE_EXTENSION DeviceExtension,
    ULONG ulUpdationLength,
    ULONG ulOffset,
    ULONG ulAndVal,
    ULONG ulOrVal,
    BOOLEAN bSetThisVal
)
{
    ULONG length;
    IDE_PCI_REGISTERS pciRegisters;
    PUCHAR  pucPCIVal = (PUCHAR)&pciRegisters;

	//
	// Get the PIIX4 IDE PCI registers.
	//

	length = ScsiPortGetBusData(
				DeviceExtension,
				PCIConfiguration,
				DeviceExtension->BusNumber,
				DeviceExtension->PciSlot.u.AsULONG,
				&pciRegisters,
				sizeof(IDE_PCI_REGISTERS)
				);

	if (length != sizeof(IDE_PCI_REGISTERS)) 
    {
		return;//(FALSE);
	}

    if ( bSetThisVal )
    {
        switch ( ulUpdationLength )
        {
            case 1:
                pucPCIVal[ulOffset] &= (UCHAR)ulAndVal;
                pucPCIVal[ulOffset] |= (UCHAR)ulOrVal;
                break;
            case 2:
                *((PUSHORT)(pucPCIVal+ulOffset)) &= (USHORT)ulAndVal;
                *((PUSHORT)(pucPCIVal+ulOffset)) |= (USHORT)ulOrVal;
                break;
            case 4:
                *((PULONG)(pucPCIVal+ulOffset)) = (ULONG)ulAndVal;
                *((PULONG)(pucPCIVal+ulOffset)) = (ULONG)ulOrVal;
                break;
        }
    }

	length = ScsiPortSetBusDataByOffset(
				DeviceExtension,
				PCIConfiguration,
				DeviceExtension->BusNumber,
				DeviceExtension->PciSlot.u.AsULONG,
                (PVOID)&(pucPCIVal[ulOffset]),
				ulOffset,
				ulUpdationLength
				);
    return;
}

ULONG
AtapiParseArgumentString(
	IN PCHAR String,
	IN PCHAR KeyWord
)

/*++

Routine Description:

	This routine will parse the string for a match on the keyword, then
	calculate the value for the keyword and return it to the caller.

Arguments:

	String - The ASCII string to parse.
	KeyWord - The keyword for the value desired.

Return Values:

	Zero if value not found
	Value converted from ASCII to binary.

--*/

{
	PCHAR cptr;
	PCHAR kptr;
	ULONG value;
	ULONG stringLength = 0;
	ULONG keyWordLength = 0;
	ULONG index;

	if (!String) 
    {
		return 0;
	}
	if (!KeyWord) 
    {
		return 0;
	}

	//
	// Calculate the string length and lower case all characters.
	//

	cptr = String;
	while (*cptr) 
    {
		if (*cptr >= 'A' && *cptr <= 'Z') 
        {
			*cptr = *cptr + ('a' - 'A');
		}
		cptr++;
		stringLength++;
	}

	//
	// Calculate the keyword length and lower case all characters.
	//

	cptr = KeyWord;
	while (*cptr) 
    {
		if (*cptr >= 'A' && *cptr <= 'Z') 
        {
			*cptr = *cptr + ('a' - 'A');
		}
		cptr++;
		keyWordLength++;
	}

	if (keyWordLength > stringLength) 
    {
		//
		// Can't possibly have a match.
		//

		return 0;
	}

	//
	// Now setup and start the compare.
	//

	cptr = String;

ContinueSearch:

	//
	// The input string may start with white space.	 Skip it.
	//

	while (*cptr == ' ' || *cptr == '\t') 
    {
		cptr++;
	}

	if (*cptr == '\0') 
    {
		//
		// end of string.
		//

		return 0;
	}

	kptr = KeyWord;
	while (*cptr++ == *kptr++) 
    {
		if (*(cptr - 1) == '\0') 
        {
			//
			// end of string
			//

			return 0;
		}
	}

	if (*(kptr - 1) == '\0') 
    {
		//
		// May have a match backup and check for blank or equals.
		//

		cptr--;
		while (*cptr == ' ' || *cptr == '\t') 
        {
			cptr++;
		}

		//
		// Found a match.  Make sure there is an equals.
		//

		if (*cptr != '=') 
        {
			//
			// Not a match so move to the next semicolon.
			//

			while (*cptr) 
            {
				if (*cptr++ == ';') 
                {
					goto ContinueSearch;
				}
			}
			return 0;
		}

		//
		// Skip the equals sign.
		//

		cptr++;

		//
		// Skip white space.
		//

		while ((*cptr == ' ') || (*cptr == '\t')) 
        {
			cptr++;
		}

		if (*cptr == '\0') 
        {

			//
			// Early end of string, return not found
			//

			return 0;
		}

		if (*cptr == ';') 
        {

			//
			// This isn't it either.
			//

			cptr++;
			goto ContinueSearch;
		}

		value = 0;
		if ((*cptr == '0') && (*(cptr + 1) == 'x')) 
        {

			//
			// Value is in Hex.	 Skip the "0x"
			//

			cptr += 2;
			for (index = 0; *(cptr + index); index++) 
            {

				if (*(cptr + index) == ' ' ||
					*(cptr + index) == '\t' ||
					*(cptr + index) == ';') 
                {
					 break;
				}

				if ((*(cptr + index) >= '0') && (*(cptr + index) <= '9')) 
                {
					value = (16 * value) + (*(cptr + index) - '0');
				} 
                else 
                {
					if ((*(cptr + index) >= 'a') && (*(cptr + index) <= 'f')) 
                    {
						value = (16 * value) + (*(cptr + index) - 'a' + 10);
					} 
                    else 
                    {
						//
						// Syntax error, return not found.
						//
						return 0;
					}
				}
			}
		} 
        else 
        {
			//
			// Value is in Decimal.
			//

			for (index = 0; *(cptr + index); index++) 
            {
				if (*(cptr + index) == ' ' ||
					*(cptr + index) == '\t' ||
					*(cptr + index) == ';') 
                {
					 break;
				}

				if ((*(cptr + index) >= '0') && (*(cptr + index) <= '9')) 
                {
					value = (10 * value) + (*(cptr + index) - '0');
				} 
                else 
                {
					//
					// Syntax error return not found.
					//
					return 0;
				}
			}
		}

		return value;
	} 
    else 
    {
		//
		// Not a match check for ';' to continue search.
		//

		while (*cptr) 
        {
			if (*cptr++ == ';') 
            {
				goto ContinueSearch;
			}
		}

		return 0;
	}

} // end AtapiParseArgumentString()

BOOLEAN
AtapiResetController(
	IN PHW_DEVICE_EXTENSION DeviceExtension,
	IN ULONG PathId
)

/*++

Routine Description:


	Reset IDE controller and/or Atapi device.

Arguments:

	DeviceExtension - HBA miniport driver's adapter data storage

Return Value:

	Nothing.


--*/

{
	PIDE_REGISTERS_1 baseIoAddress1;
	PIDE_REGISTERS_2 baseIoAddress2;
	UCHAR statusByte, k;
	ULONG ulDeviceNum ;
	PCHANNEL channel;
	UCHAR drive;
    UCHAR ucTargetId;
    PPHYSICAL_DRIVE pPhysicalDrive;

    ScsiPortLogError(DeviceExtension,0,0,0,0,SP_BAD_FW_WARNING,HYPERDISK_RESET_DETECTED);

	DebugPrint((0,"RC"));

    StopBusMasterTransfers(DeviceExtension);    // Issues Stop Transfers to all the controllers

    for(ucTargetId=0;ucTargetId<MAX_DRIVES_PER_CONTROLLER;ucTargetId++) // let us flush cache before resetting the controller so that we will not get the 
    {                                           // data corruption in mirror (has seen when SRB Test going on and power has been taken out
        if ( !( IS_IDE_DRIVE(ucTargetId) ) )       
            continue;

        FlushCache(DeviceExtension, ucTargetId);
    }

    IssuePowerOnResetToDrives(DeviceExtension); // Issues a Power on Reset for each controller

	//
	// Complete all remaining SRBs.
	//

	CompleteOutstandingRequests(DeviceExtension);
    DebugPrint((0,"\nRC 1"));

	//
	// Cleanup internal queues and states.
	//

	for (k = 0; k < MAX_CHANNELS_PER_CONTROLLER; k++) 
    {

		channel = &(DeviceExtension->Channel[k]);

		DeviceExtension->ExpectingInterrupt[k] = 0;

		//
		// Reset ActivePdd.
		//
		channel->ActiveCommand = NULL;

		//
		// Clear request tracking fields.
		//

		DeviceExtension->TransferDescriptor[k].WordsLeft = 0;
		DeviceExtension->TransferDescriptor[k].DataBuffer = NULL;
		DeviceExtension->TransferDescriptor[k].StartSector = 0;
		DeviceExtension->TransferDescriptor[k].Sectors = 0;
		DeviceExtension->TransferDescriptor[k].SglPhysicalAddress = 0;

        for(ulDeviceNum=0;ulDeviceNum<MAX_DRIVES_PER_CHANNEL;ulDeviceNum++)
        {
            ucTargetId = (UCHAR)((k<<1) + ulDeviceNum);
            pPhysicalDrive = &(DeviceExtension->PhysicalDrive[ucTargetId]);
            pPhysicalDrive->ucHead = 0;
            pPhysicalDrive->ucTail = 0;

            if ( !IS_IDE_DRIVE(ucTargetId) )
                continue;

		    if (!DeviceExtension->bSkipSetParameters[ucTargetId]) 
            {
				if (!SetDriveParameters(DeviceExtension, k, (UCHAR)ulDeviceNum))
				{
					DebugPrint((1, "SetDriveParameters Command failed\n"));
                    continue;
				}
            }

			if (!SetDriveFeatures(DeviceExtension, ucTargetId))  
			{
				DebugPrint((1, "SetDriveFeatures Command failed\n"));
                continue;
			}
        }

	} // for (k = 0; k < MAX_CHANNELS_PER_CONTROLLER; k++)

    CheckDrivesResponse(DeviceExtension);

	//
	// Call the HwInitialize routine to setup multi-block.
	//

    DeviceExtension->bIsThruResetController = TRUE; 
    // Informing AtapiHwInitialize that we reset the drive and so it is our responsibility to reprogram the drive.
	AtapiHwInitialize(DeviceExtension);
    DeviceExtension->bIsThruResetController = FALSE;

	//
	// Indicate ready for next request.
	//
	
	ScsiPortNotification(NextRequest, DeviceExtension, NULL);

    DebugPrint((0,"\nRC-D"));

    return TRUE;

} // end AtapiResetController()

BOOLEAN StopBusMasterTransfers(PHW_DEVICE_EXTENSION DeviceExtension)    // Issues Stop Bus Master Transfers to all the controllers
{
	PIDE_REGISTERS_1 baseIoAddress1;
	PIDE_REGISTERS_2 baseIoAddress2;
    PBM_REGISTERS baseBm;
    ULONG ulChannel;
    UCHAR statusByte;

    for(ulChannel=0;ulChannel<MAX_CHANNELS_PER_CONTROLLER;ulChannel++)
    {
		baseIoAddress1 = (PIDE_REGISTERS_1) DeviceExtension->BaseIoAddress1[ulChannel];
		baseIoAddress2 = (PIDE_REGISTERS_2) DeviceExtension->BaseIoAddress2[ulChannel];
        baseBm = DeviceExtension->BaseBmAddress[ulChannel];

        if ( !baseBm )  // There is no Channel at this place
            continue;

		ScsiPortWritePortUchar(&(baseBm->Command.AsUchar), STOP_TRANSFER);

        CLEAR_BM_INT(baseBm, statusByte);

        ScsiPortWritePortUchar(&(baseBm->Status.AsUchar), 0);

        ScsiPortStallExecution(100);

        ScsiPortWritePortUchar(&(baseBm->Status.AsUchar), statusByte);

    }

    return TRUE;
}

BOOLEAN IssuePowerOnResetToDrives(PHW_DEVICE_EXTENSION DeviceExtension) // Issues a Power on Reset for each controller
{

	PIDE_REGISTERS_1 baseIoAddress1;
	PIDE_REGISTERS_2 baseIoAddress2;
    PBM_REGISTERS baseBm;
    ULONG ulController, ulTime, ulDrive, ulChannel;
    UCHAR statusByte;

    for(ulChannel=0;ulChannel<MAX_CHANNELS_PER_CONTROLLER;ulChannel++)
    {
        ULONG ulTargetId, ulWaitLoop;

		baseIoAddress1 = (PIDE_REGISTERS_1) DeviceExtension->BaseIoAddress1[ulChannel];
		baseIoAddress2 = (PIDE_REGISTERS_2) DeviceExtension->BaseIoAddress2[ulChannel];
        baseBm = DeviceExtension->BaseBmAddress[ulChannel];

        // Begin Vasu - 18 Aug 2000
        // Have modified in such a way that a soft reset is issued to the drive only
        // if a drive is identified in that channel.
        for (ulDrive = 0; ulDrive < MAX_DRIVES_PER_CHANNEL; ulDrive++)
        {
            ulTargetId = (ulChannel << 1) + ulDrive;

            if (!(DeviceExtension->DeviceFlags[ulTargetId] & DFLAGS_DEVICE_PRESENT))
                continue;   // Check Next Drive
            else
                break;      // Found atleast one drive, so now break out and reset the drive.
        }
        
        // No Drives are found in this channel if ulDrive equals MAX_DRIVES_PER_CHANNEL. 
        // So continue to the next channel.
        if (ulDrive == MAX_DRIVES_PER_CHANNEL)
            continue;

        // End Vasu.

        IDE_HARD_RESET(baseIoAddress1, baseIoAddress2, ulTargetId, statusByte); // issue soft reset to the drive

	    GET_STATUS(baseIoAddress1, statusByte);
        if ( !statusByte )
        {
	        GET_STATUS(baseIoAddress1, statusByte);
	        DebugPrint((0, "Hard Reset Failed. The Status %X on %ld\n\n\n",
		        (ULONG)statusByte, ulTargetId));
        }

        for(ulDrive=0;ulDrive<MAX_DRIVES_PER_CHANNEL;ulDrive++)
        {
            ulTargetId = (ulChannel << 1) + ulDrive;

            if ( !IS_IDE_DRIVE(ulTargetId) )
                continue;

            SELECT_DEVICE(baseIoAddress1, ulDrive);
            for(ulWaitLoop=0;ulWaitLoop<5;ulWaitLoop++) // total wait time is 5 seconds or till the Busy Bit Gets Cleared
            {
                WAIT_ON_BUSY(baseIoAddress1, statusByte);
                if ( statusByte & 0x80 )
                {
                    DebugPrint((0, "Busy : %X on drive %ld\n", statusByte, ulTargetId));
                }
                else
                {
                    break;
                }
            }
        }
    }

    return TRUE;
}

BOOLEAN CheckDrivesResponse(PHW_DEVICE_EXTENSION DeviceExtension)
{
	PIDE_REGISTERS_1 baseIoAddress1;
	PIDE_REGISTERS_2 baseIoAddress2;
    ULONG ulDriveNum;
    UCHAR statusByte;
    UCHAR aucIdentifyBuf[512];
    ULONG i;

    for(ulDriveNum=0;ulDriveNum<MAX_DRIVES_PER_CONTROLLER;ulDriveNum++)
    {
        if ( !IS_IDE_DRIVE(ulDriveNum) )
            continue;

		baseIoAddress1 = (PIDE_REGISTERS_1) DeviceExtension->BaseIoAddress1[(ulDriveNum>>1)];
		baseIoAddress2 = (PIDE_REGISTERS_2) DeviceExtension->BaseIoAddress2[(ulDriveNum>>1)];

	    //
	    // Select device 0 or 1.
	    //

	    SELECT_DEVICE(baseIoAddress1, ulDriveNum);

	    //
	    // Check that the status register makes sense.
	    //

        // The call came here since there is a drive ... so let us not worry about whether there is any drive at this place
	    GET_BASE_STATUS(baseIoAddress1, statusByte);    

	    //
	    // Load CylinderHigh and CylinderLow with number bytes to transfer.
	    //

	    ScsiPortWritePortUchar(&baseIoAddress1->CylinderHigh, (0x200 >> 8));
	    ScsiPortWritePortUchar(&baseIoAddress1->CylinderLow,  (0x200 & 0xFF));

        WAIT_ON_BUSY(baseIoAddress1, statusByte);

	    //
	    // Send IDENTIFY command.
	    //
	    WAIT_ON_BUSY(baseIoAddress1,statusByte);

	    ScsiPortWritePortUchar(&baseIoAddress1->Command, IDE_COMMAND_IDENTIFY);

	    WAIT_ON_BUSY(baseIoAddress1,statusByte);

        if ( ( !( statusByte & IDE_STATUS_BUSY ) ) && ( !( statusByte & IDE_STATUS_DRQ ) ) )
        {
            // this is an error... so let us not try any more.
            FailDrive(DeviceExtension, (UCHAR)ulDriveNum);
            continue;
        }

        WAIT_ON_BUSY(baseIoAddress1,statusByte);

	    //
	    // Wait for DRQ.
	    //

	    for (i = 0; i < 4; i++) 
        {
		    WAIT_FOR_DRQ(baseIoAddress1, statusByte);

		    if (statusByte & IDE_STATUS_DRQ)
            {
                break;
            }
        }

	    //
	    // Read status to acknowledge any interrupts generated.
	    //

	    GET_BASE_STATUS(baseIoAddress1, statusByte);

	    //
	    // Check for error on really stupid master devices that assert random
	    // patterns of bits in the status register at the slave address.
	    //

	    if ((statusByte & IDE_STATUS_ERROR)) 
        {
            FailDrive(DeviceExtension, (UCHAR)ulDriveNum);
            continue;
	    }

	    DebugPrint((1, "CheckDrivesResponse: Status before read words %x\n", statusByte));

	    //
	    // Suck out 256 words. After waiting for one model that asserts busy
	    // after receiving the Packet Identify command.
	    //

	    WAIT_ON_BUSY(baseIoAddress1,statusByte);

	    if ( (!(statusByte & IDE_STATUS_DRQ)) || (statusByte & IDE_STATUS_BUSY) ) 
        {
            FailDrive(DeviceExtension, (UCHAR)ulDriveNum);
            continue;
	    }

	    READ_BUFFER(baseIoAddress1, (PUSHORT)aucIdentifyBuf, 256);

	    //
	    // Work around for some IDE and one model Atapi that will present more than
	    // 256 bytes for the Identify data.
	    //

	    WAIT_ON_BUSY(baseIoAddress1,statusByte);

	    for (i = 0; i < 0x10000; i++) 
        {
		    GET_STATUS(baseIoAddress1,statusByte);

		    if (statusByte & IDE_STATUS_DRQ) 
            {
			    //
			    // Suck out any remaining bytes and throw away.
			    //

			    ScsiPortReadPortUshort(&baseIoAddress1->Data);

		    } 
            else 
            {
			    break;
		    }
        }
    }

    return TRUE;
}

VOID
AtapiStrCpy(
	IN PUCHAR Destination,
	IN PUCHAR Source
)

{
	// Begin Vasu - 03 January 2001
	// Sanity Check
	if ((Source == NULL) || (Destination == NULL))
		return;
	// End Vasu

	*Destination = *Source;

	while (*Source != '\0') 
    {
		*Destination++ = *Source++;
	}

	return;

} // end AtapiStrCpy()

LONG
AtapiStringCmp (
	PCHAR FirstStr,
	PCHAR SecondStr,
	ULONG Count
)

{
	UCHAR  first ,last;

	if (Count) 
    {
		do 
        {

			//
			// Get next char.
			//

			first = *FirstStr++;
			last = *SecondStr++;

			if (first != last) 
            {

				//
				// If no match, try lower-casing.
				//

				if (first>='A' && first<='Z') 
                {
					first = first - 'A' + 'a';
				}
				if (last>='A' && last<='Z') 
                {
					last = last - 'A' + 'a';
				}
				if (first != last) 
                {
					//
					// No match
					//

					return first - last;
				}
			}
		}while (--Count && first);
	}

	return 0;

} // end AtapiStringCmp()
PUCHAR
AtapiMemCpy(
            PUCHAR pDst,
            PUCHAR pSrc,
            ULONG ulCount
            )
{
    ULONG ulTemp = ulCount & 0x03;
    _asm
    {

        push esi
        push edi
        push ecx
        pushf
        cld

        mov ecx, ulCount
        mov esi, pSrc
        mov edi, pDst
        shr ecx, 2      ; Copy a DWORD At a Time
        rep movsd

        mov ecx, ulTemp
        rep movsb

        mov eax, pDst

        popf
        pop ecx
        pop edi
        pop esi
    }


//    for(ulTemp=0;ulTemp<ulCount;ulTemp++)
//        pDst[ulTemp] = pSrc[ulTemp];

}
        
VOID
AtapiFillMemory(
            PUCHAR pDst,
            ULONG ulCount,
            UCHAR ucFillChar
            )
{
    ULONG ulTemp = ulCount & 0x03;

    _asm
    {
        push edi
        push ecx
        push eax
        pushf
        cld

        mov   al, ucFillChar
        shl eax, 8
        mov   al, ucFillChar
        shl eax, 8
        mov   al, ucFillChar
        shl eax, 8
        mov   al, ucFillChar

        mov ecx, ulCount
        mov edi, pDst
        shr ecx, 2      ; Copy a DWORD At a Time
        rep stosd

        movzx ecx, ulTemp
        rep stosb

        popf
        pop eax
        pop ecx
        pop edi
    }

//    for(ulTemp=0;ulTemp<ulCount;ulTemp++)
//        pDst[ulTemp] = ucFillChar;



}


VOID
AtapiCopyString(
    IN PCHAR Destination,
    IN PCHAR Source,
    IN ULONG Count
)
{
    ULONG i = 0;

	// Begin Vasu - 03 January 2001
	// Sanity Check
	if ((Source == NULL) || (Destination == NULL))
		return;
	// End Vasu

    for (i = 0; i < Count; i++)
    {
        if (Source[i] == '\0')
            break;
        Destination[i] = Source[i];
    }
} // end AtapiCopyString()

BOOLEAN
GetTransferMode(
	IN PHW_DEVICE_EXTENSION DeviceExtension,
	IN UCHAR TargetId
)
{
	PIDENTIFY_DATA capabilities;
	CHAR message[16];
    capabilities = &(DeviceExtension->FullIdentifyData[TargetId]);

    DeviceExtension->TransferMode[TargetId] = PioMode0;    // By default assume this drive is PioMode 0

	if (capabilities->AdvancedPioModes != 0) 
    {

		if (capabilities->AdvancedPioModes & IDENTIFY_PIO_MODE4) 
        {
            DeviceExtension->TransferMode[TargetId] = PioMode4;
		} 
        else 
        {
            if (capabilities->AdvancedPioModes & IDENTIFY_PIO_MODE3) 
            {
                DeviceExtension->TransferMode[TargetId] = PioMode3;
		    } 
            else 
            {
                DeviceExtension->TransferMode[TargetId] = PioMode0;
            }
        }
    }

    if ( capabilities->MultiWordDmaActive )
    {
        switch ( capabilities->MultiWordDmaActive )
        {
            case 1:
                DeviceExtension->TransferMode[TargetId] = DmaMode0;
                DeviceExtension->DeviceFlags[TargetId] |= DFLAGS_USE_DMA;
                break;

            case 2:
                DeviceExtension->TransferMode[TargetId] = DmaMode1;
                DeviceExtension->DeviceFlags[TargetId] |= DFLAGS_USE_DMA;
                break;

            case 4:
                DeviceExtension->TransferMode[TargetId] = DmaMode2;
                DeviceExtension->DeviceFlags[TargetId] |= DFLAGS_USE_DMA;
                break;
        }
    }

    if ( capabilities->UltraDmaActive )
    {
        switch ( capabilities->UltraDmaActive )
        {
            case 1:
                DeviceExtension->TransferMode[TargetId] = UdmaMode0;
                DeviceExtension->DeviceFlags[TargetId] |= DFLAGS_USE_UDMA;
                break;

            case 2:
                DeviceExtension->TransferMode[TargetId] = UdmaMode1;
                DeviceExtension->DeviceFlags[TargetId] |= DFLAGS_USE_UDMA;
                break;

            case 4:
                DeviceExtension->TransferMode[TargetId] = UdmaMode2;
                DeviceExtension->DeviceFlags[TargetId] |= DFLAGS_USE_UDMA;
                break;
            case 8:
                DeviceExtension->TransferMode[TargetId] = UdmaMode3;
                DeviceExtension->DeviceFlags[TargetId] |= DFLAGS_USE_UDMA;
                break;

            case 0x10:
                DeviceExtension->TransferMode[TargetId] = UdmaMode4;
                DeviceExtension->DeviceFlags[TargetId] |= DFLAGS_USE_UDMA;
                break;
            case 0x20:
                DeviceExtension->DeviceFlags[TargetId] |= DFLAGS_USE_UDMA;
                if ( Udma100 == DeviceExtension->ControllerSpeed )
                    DeviceExtension->TransferMode[TargetId] = UdmaMode5;
                else
                    DeviceExtension->TransferMode[TargetId] = UdmaMode4;
                break;
        }
    }

    return  TRUE;
}

VOID
CompleteOutstandingRequests(
	PHW_DEVICE_EXTENSION DeviceExtension
)

{
	ULONG i;
	PSCSI_REQUEST_BLOCK srb;
	PSRB_EXTENSION SrbExtension;

	for (i = 0; (i < DeviceExtension->ucMaxPendingSrbs) && (DeviceExtension->PendingSrbs != 0); i++) 
    {
		if (DeviceExtension->PendingSrb[i] != NULL) 
        {
			srb = DeviceExtension->PendingSrb[i];

			srb->SrbStatus = SRB_STATUS_BUS_RESET;

			SrbExtension = srb->SrbExtension;

            if ( SCSIOP_INTERNAL_COMMAND == srb->Cdb[0] )
            {
               srb->TargetId = SrbExtension->ucOriginalId;
            }
            // It is an Internal Srb, so let us not post the completion status
			ScsiPortNotification(RequestComplete, DeviceExtension, srb);
		
			DeviceExtension->PendingSrb[i] = NULL;

			DeviceExtension->PendingSrbs--;
		}
	}

	return;

} // end CompleteOutstandingRequests()

ULONG
DriverEntry(
	IN PVOID DriverObject,
	IN PVOID Argument2
)

/*++

Routine Description:

	Installable driver initialization entry point for system.

Arguments:

	Driver Object

Return Value:

	Status from ScsiPortInitialize()

--*/

{
	HW_INITIALIZATION_DATA hwInitializationData;
	ULONG				   adapterCount;
	ULONG				   i;
	ULONG				   statusToReturn, newStatus, ulControllerType;

	DebugPrint((1,"\n\nATAPI IDE MiniPort Driver\n"));

	statusToReturn = 0xffffffff;

	//
	// Zero out structure.
	//

	AtapiFillMemory(((PUCHAR)&hwInitializationData), sizeof(HW_INITIALIZATION_DATA), 0);

	//
	// Set size of hwInitializationData.
	//

	hwInitializationData.HwInitializationDataSize = sizeof(HW_INITIALIZATION_DATA);

	//
	// Set entry points.
	//

	hwInitializationData.HwInitialize = AtapiHwInitialize;
	hwInitializationData.HwResetBus = AtapiResetController;
	hwInitializationData.HwStartIo = AtapiStartIo;
    hwInitializationData.HwInterrupt = AtapiInterrupt;
	hwInitializationData.HwFindAdapter = FindIdeRaidControllers;

#ifdef HYPERDISK_WIN2K
	hwInitializationData.HwAdapterControl = HyperDiskPnPControl;
#endif // HYPERDISK_WIN2K


    //
    // Specify size of extensions.
    //

    hwInitializationData.DeviceExtensionSize = sizeof(HW_DEVICE_EXTENSION);
    hwInitializationData.SpecificLuExtensionSize =0;
    
#ifdef HD_ALLOCATE_SRBEXT_SEPERATELY
    hwInitializationData.SrbExtensionSize = 0;
#else // HD_ALLOCATE_SRBEXT_SEPERATELY
    hwInitializationData.SrbExtensionSize = sizeof(SRB_EXTENSION);
#endif // HD_ALLOCATE_SRBEXT_SEPERATELY

	//
	// Indicate PIO device.
	//
	hwInitializationData.MapBuffers = TRUE;

    // Begin Vasu - 27 March 2001
    // Set NeedPhysicalAddresses to TRUE always as we use ScsiPort routines
    // now for memory related stuff.
    //
	// Indicate we'll call SCSI Port address conversion functions.
	//
	hwInitializationData.NeedPhysicalAddresses = TRUE;
    // End Vasu

    //
	// Enable multiple requests per LUN, since we do queuing.
	//
	hwInitializationData.MultipleRequestPerLu = TRUE;
	hwInitializationData.TaggedQueuing = TRUE;

	//
	// Pick just one adapter for this release.
	//
#ifdef HYPERDISK_WIN98
	hwInitializationData.NumberOfAccessRanges = 6;
#else
	hwInitializationData.NumberOfAccessRanges = 5;
#endif

	hwInitializationData.AdapterInterfaceType = PCIBus;

#ifdef HYPERDISK_WINNT
    gbFindRoutineVisited = FALSE;
#endif

    // let us try for different controllers
    for(ulControllerType=0;ulControllerType<NUM_NATIVE_MODE_ADAPTERS;ulControllerType++)
    {
        hwInitializationData.VendorId             = CMDAdapters[ulControllerType].VendorId;
        hwInitializationData.VendorIdLength       = (USHORT) CMDAdapters[ulControllerType].VendorIdLength;
        hwInitializationData.DeviceId             = CMDAdapters[ulControllerType].DeviceId;
        hwInitializationData.DeviceIdLength       = (USHORT) CMDAdapters[ulControllerType].DeviceIdLength;

        newStatus = ScsiPortInitialize(DriverObject,
                                           Argument2,
                                           &hwInitializationData,
                                           NULL);
	    if (newStatus < statusToReturn) 
        {
		    statusToReturn = newStatus;
	    }
    }

#ifdef HYPERDISK_WINNT
    if ( !gbFindRoutineVisited )
    {   // let us give it a last try ... for the machines like MegaPlex and FlexTel machines
        // for these type of machines the Port Driver somehow doesn't call our Find Routine if we
        // specify the Vendor Id and Device Id... so we will tell him zero for all the Ids and this 
        // will certainly cause the Port Driver to call our Find Routine whether card is present or not

        gbManualScan = TRUE;

        hwInitializationData.VendorId             = 0;
        hwInitializationData.VendorIdLength       = 0;
        hwInitializationData.DeviceId             = 0;
        hwInitializationData.DeviceIdLength       = 0;

        newStatus = ScsiPortInitialize(DriverObject,
                                           Argument2,
                                           &hwInitializationData,
                                           NULL);
	    if (newStatus < statusToReturn) 
        {
		    statusToReturn = newStatus;
	    }

        gbManualScan = FALSE;
    }
#endif

	return statusToReturn;

} // end DriverEntry() 

VOID
ExposeSingleDrives(
	IN PHW_DEVICE_EXTENSION DeviceExtension
)

{
	UCHAR targetId;
#ifdef HD_ALLOCATE_SRBEXT_SEPERATELY
    DeviceExtension->ucMaxPendingSrbs   = MAX_PENDING_SRBS;
    DeviceExtension->ucOptMaxQueueSize  = OPT_QUEUE_MAX_SIZE;
    DeviceExtension->ucOptMinQueueSize  = OPT_QUEUE_MIN_SIZE;
#else
    DeviceExtension->ucMaxPendingSrbs   = STRIPING_MAX_PENDING_SRBS;
    DeviceExtension->ucOptMaxQueueSize  = STRIPING_OPT_QUEUE_MAX_SIZE;
    DeviceExtension->ucOptMinQueueSize  = STRIPING_OPT_QUEUE_MIN_SIZE;
#endif

	for (targetId = 0; targetId < MAX_DRIVES_PER_CONTROLLER; targetId++) 
    {
		if ((DeviceExtension->DeviceFlags[targetId] & DFLAGS_DEVICE_PRESENT) &&
			!DeviceExtension->PhysicalDrive[targetId].Hidden) 
        {
			DeviceExtension->IsSingleDrive[targetId] = TRUE;
		}

#ifndef HD_ALLOCATE_SRBEXT_SEPERATELY
        if ( ( Raid1  == DeviceExtension->LogicalDrive[targetId].RaidLevel ) || 
             ( Raid10 == DeviceExtension->LogicalDrive[targetId].RaidLevel ) 
           )
        {
            DeviceExtension->ucMaxPendingSrbs   = MIRROR_MAX_PENDING_SRBS;
            DeviceExtension->ucOptMaxQueueSize  = MIRROR_OPT_QUEUE_MAX_SIZE;
            DeviceExtension->ucOptMinQueueSize  = MIRROR_OPT_QUEUE_MIN_SIZE;
        }
#endif
	}

    // Begin Vasu - 16 December 2000
    // If there is a single drive in the system, then the MaxTransferLength 
    // must be made to 1, irrespective of whether there are any RAID arrays in
    // the system
    DeviceExtension->ulMaxStripesPerRow = (ULONG) 1;
    // End Vasu

	return;

} // end ExposeSingleDrives()

BOOLEAN
IsDrivePresent(
	IN PHW_DEVICE_EXTENSION DeviceExtension,
	IN UCHAR ucTargetId
)
{
	PIDE_REGISTERS_1	 baseIoAddress1 = DeviceExtension->BaseIoAddress1[ucTargetId>>1];
	PIDE_REGISTERS_2	 baseIoAddress2 = DeviceExtension->BaseIoAddress2[ucTargetId>>1];
    UCHAR ucStatus, ucStatus2;
    ULONG ulCounter;
    UCHAR ucDrvSelVal, ucReadDrvNum;

    SELECT_DEVICE(baseIoAddress1, ucTargetId);

    GET_STATUS(baseIoAddress1, ucStatus);

    if ( 0xff == ucStatus )
        return FALSE;

    for(ulCounter=0;ulCounter<350;ulCounter++)  // 350 * 60us = 21000us = 21ms time out
    {
        ScsiPortStallExecution(60);

        GET_STATUS(baseIoAddress1, ucStatus2);

        ucStatus2 |= ucStatus;

        ucStatus2 &= 0xc9;

        if ( !( ucStatus2  & 0xc9 ) )
            return TRUE;
    }

    SELECT_DEVICE(baseIoAddress1, ucTargetId);

	ScsiPortWritePortUchar(&baseIoAddress1->SectorCount, 0xff);

    ScsiPortStallExecution(60);

    ucReadDrvNum = ScsiPortReadPortUchar(&baseIoAddress1->DriveSelect);

    ucDrvSelVal = IDE_CHS_MODE | ((ucTargetId & 0x01) << 4);

    if ( ucReadDrvNum == ucDrvSelVal )
        return TRUE;
    else
        return FALSE;
}

BOOLEAN
FindDevices(
	IN PHW_DEVICE_EXTENSION DeviceExtension,
	IN UCHAR Channel
)

/*++

Routine Description:

	This routine is called from FindIDERAIDController to identify
	devices attached to an IDE controller.

Arguments:

	DeviceExtension - HBA miniport driver's adapter data storage
	Channel	- The number of the channel to scan.

Return Value:

	TRUE - True if devices found.

--*/

{
	PIDE_REGISTERS_1	 baseIoAddress1 = DeviceExtension->BaseIoAddress1[Channel];
	PIDE_REGISTERS_2	 baseIoAddress2 = DeviceExtension->BaseIoAddress2[Channel];
	BOOLEAN				 deviceResponded = FALSE,
						 skipSetParameters = FALSE;
	ULONG				 waitCount = 10000;
	UCHAR				 deviceNumber;
	UCHAR				 i;
	UCHAR				 signatureLow,
						 signatureHigh;
	UCHAR				 statusByte;
	UCHAR				 targetId;

	//
	// Clear expecting interrupt flags.
	//

	DeviceExtension->ExpectingInterrupt[Channel] = 0;

	//
	// Search for devices.
	//

	for (deviceNumber = 0; deviceNumber < 2; deviceNumber++) 
    {
		targetId = (Channel << 1) + deviceNumber;

        if ( !IsDrivePresent(DeviceExtension, targetId) )
            continue;

		//
		// Issue IDE Identify. If an Atapi device is actually present, the signature
		// will be asserted, and the drive will be recognized as such.
		//

		if (IssueIdentify(DeviceExtension, deviceNumber, Channel, IDE_COMMAND_IDENTIFY)) 
        {
			//
			// IDE drive found.
			//

			DebugPrint((1, "FindDevices: TID %d is IDE\n", targetId));

			DeviceExtension->DeviceFlags[targetId] |= DFLAGS_DEVICE_PRESENT;

			deviceResponded = TRUE;

			//
			// Indicate IDE - not ATAPI device.
			//

			DeviceExtension->DeviceFlags[targetId] &= ~DFLAGS_ATAPI_DEVICE;

			DeviceExtension->PhysicalDrive[targetId].SectorSize = IDE_SECTOR_SIZE;

			DeviceExtension->PhysicalDrive[targetId].MaxTransferLength =
												MAX_BYTES_PER_IDE_TRANSFER;
		}
        else
        {
            // No device
            continue;
        }
	}

	for (i = 0; i < 2; i++) 
    {
		targetId = (Channel << 1) + i;

		if (DeviceExtension->DeviceFlags[targetId] & DFLAGS_DEVICE_PRESENT) 
        {
			//
			// Initialize LastDriveFed.
			//

			DeviceExtension->Channel[Channel].LastDriveFed = i;

			if (!(DeviceExtension->DeviceFlags[targetId] & DFLAGS_ATAPI_DEVICE) &&
				deviceResponded) 
            {

				//
				// This hideous hack is to deal with ESDI devices that return
				// garbage geometry in the IDENTIFY data.
				// This is ONLY for the crashdump environment as
				// these are ESDI devices.
				//
	
				if (DeviceExtension->IdentifyData[targetId].SectorsPerTrack == 0x35 &&
					DeviceExtension->IdentifyData[targetId].NumberOfHeads == 0x07) 
                {
	
					DebugPrint((1, "FindDevices: Found nasty Compaq ESDI!\n"));
	
					//
					// Change these values to something reasonable.
					//
	
					DeviceExtension->IdentifyData[targetId].SectorsPerTrack = 0x34;
					DeviceExtension->IdentifyData[targetId].NumberOfHeads = 0x0E;
				}
	
				if (DeviceExtension->IdentifyData[targetId].SectorsPerTrack == 0x35 &&
					DeviceExtension->IdentifyData[targetId].NumberOfHeads == 0x0F) 
                {
	
					DebugPrint((1, "FindDevices: Found nasty Compaq ESDI!\n"));
	
					//
					// Change these values to something reasonable.
					//
	
					DeviceExtension->IdentifyData[targetId].SectorsPerTrack = 0x34;
					DeviceExtension->IdentifyData[targetId].NumberOfHeads = 0x0F;
				}
	
	
				if (DeviceExtension->IdentifyData[targetId].SectorsPerTrack == 0x36 &&
					DeviceExtension->IdentifyData[targetId].NumberOfHeads == 0x07) 
                {
	
					DebugPrint((1, "FindDevices: Found nasty UltraStor ESDI!\n"));
	
					//
					// Change these values to something reasonable.
					//
	
					DeviceExtension->IdentifyData[targetId].SectorsPerTrack = 0x3F;
					DeviceExtension->IdentifyData[targetId].NumberOfHeads = 0x10;
					DeviceExtension->bSkipSetParameters[targetId] = TRUE;
				}

#ifdef HYPERDISK_WIN2K
                if (!( DeviceExtension->FullIdentifyData[targetId].CmdSupported1 & POWER_MANAGEMENT_SUPPORTED ))
                    continue;

                DeviceExtension->PhysicalDrive[targetId].bPwrMgmtSupported = TRUE;

                if (( DeviceExtension->FullIdentifyData[targetId].CmdSupported2 & POWER_UP_IN_STANDBY_FEATURE_SUPPORTED ))
                    DeviceExtension->PhysicalDrive[targetId].bPwrUpInStdBySupported = TRUE;
                else
                    DeviceExtension->bIsResetRequiredToGetActiveMode = TRUE;


                if (( DeviceExtension->FullIdentifyData[targetId].CmdSupported2 & SET_FEATURES_REQUIRED_FOR_SPIN_UP ))
                    DeviceExtension->PhysicalDrive[targetId].bSetFeatureReqForSpinUp = TRUE;
#endif // HYPERDISK_WIN2K
			}
        }
	}


	for (i = 0; i < 2; i++) 
    {
        targetId = (Channel << 1) + i;

        if (DeviceExtension->DeviceFlags[targetId] & DFLAGS_DEVICE_PRESENT) 
        {
        	SELECT_DEVICE(baseIoAddress1, targetId);    // select first available drive
            break;
        }
    }

	return deviceResponded;

} // end FindDevices()

VOID
GetDriveCapacity(
	IN PHW_DEVICE_EXTENSION DeviceExtension,
	IN PSCSI_REQUEST_BLOCK Srb
)

{
	ULONG sectors;
	ULONG sectorSize;

	//
	// Claim 512 byte blocks (big-endian).
	//

	sectorSize = DeviceExtension->PhysicalDrive[Srb->TargetId].SectorSize;

	((PREAD_CAPACITY_DATA)Srb->DataBuffer)->BytesPerBlock = BIG_ENDIAN_ULONG(sectorSize);

	if (DeviceExtension->IsLogicalDrive[Srb->TargetId]) 
    {

		sectors = DeviceExtension->LogicalDrive[Srb->TargetId].Sectors;

	} 
    else 
    {

		sectors = DeviceExtension->PhysicalDrive[Srb->TargetId].Sectors;
	}

     sectors--;// Zero based Index

	((PREAD_CAPACITY_DATA)Srb->DataBuffer)->LogicalBlockAddress = BIG_ENDIAN_ULONG(sectors);

	DebugPrint((0,
	  "Atapi GetDriveCapacity: TID %d - capacity %ld MB (%lxh), sector size %ld (%lx BE)\n",
	  Srb->TargetId,
	  sectors / 2048,
	  sectors / 2048,
	  sectorSize,
	  BIG_ENDIAN_ULONG(sectorSize)
	  ));

	return;

} // end GetDriveCapacity()

SRBSTATUS
GetInquiryData(
	IN PHW_DEVICE_EXTENSION DeviceExtension,
	IN PSCSI_REQUEST_BLOCK Srb
)

{
	PMODE_PARAMETER_HEADER modeData;
	ULONG i;
	PINQUIRYDATA inquiryData;
	PIDENTIFY_DATA2 identifyData;
	
	inquiryData = Srb->DataBuffer;
	identifyData = &DeviceExtension->IdentifyData[Srb->TargetId];

	//
	// Zero INQUIRY data structure.
	//
    AtapiFillMemory((PUCHAR)Srb->DataBuffer, Srb->DataTransferLength, 0);

	//
	// Standard IDE interface only supports disks.
	//

	inquiryData->DeviceType = DIRECT_ACCESS_DEVICE;
    inquiryData->DeviceTypeQualifier = DEVICE_CONNECTED;

	//
	// Set the removable bit, if applicable.
	//

	if (DeviceExtension->DeviceFlags[Srb->TargetId] & DFLAGS_REMOVABLE_DRIVE) 
    {
		inquiryData->RemovableMedia = 1;
	}

	//
	// Fill in vendor identification fields.
	//

	for (i = 0; i < 20; i += 2) 
    {
	   inquiryData->VendorId[i] =
		   ((PUCHAR)identifyData->ModelNumber)[i + 1];
	   inquiryData->VendorId[i+1] =
		   ((PUCHAR)identifyData->ModelNumber)[i];
	}

	//
	// Initialize unused portion of product id.
	//

	for (i = 0; i < 4; i++) 
    {
	   inquiryData->ProductId[12+i] = ' ';
	}

	//
	// Move firmware revision from IDENTIFY data to
	// product revision in INQUIRY data.
	//

	for (i = 0; i < 4; i += 2) 
    {
	   inquiryData->ProductRevisionLevel[i] =
		   ((PUCHAR)identifyData->FirmwareRevision)[i+1];
	   inquiryData->ProductRevisionLevel[i+1] =
		   ((PUCHAR)identifyData->FirmwareRevision)[i];
	}

    if ( DeviceExtension->IsLogicalDrive[Srb->TargetId] )
    {
        // Zero up the information.... so that it doesn't show any junk.. Bug reported by Hitachi
        // Vendor Id 8 Chars, Product Id 16 Product Rivision Level 4 = 28 Chars....
        AtapiFillMemory(inquiryData->VendorId, 8, ' ');
        AtapiFillMemory(inquiryData->ProductId, 16, ' ');
        AtapiFillMemory(inquiryData->ProductRevisionLevel, 4, ' ');

        AtapiCopyString(inquiryData->VendorId, "AMI", 3);
        AtapiCopyString(inquiryData->ProductRevisionLevel, "1.0", 3);
		// Begin Vasu - 26 Dec 2000
		// Name Change
        AtapiCopyString(inquiryData->ProductId, "MegaIDE #", 11);
        inquiryData->ProductId[9] = (UCHAR) ( ((DeviceExtension->aulLogDrvId[Srb->TargetId] + (DeviceExtension->ucControllerId * MAX_DRIVES_PER_CONTROLLER)) / 10 )+ '0');
        inquiryData->ProductId[10] = (UCHAR) ( ((DeviceExtension->aulLogDrvId[Srb->TargetId] + (DeviceExtension->ucControllerId * MAX_DRIVES_PER_CONTROLLER)) % 10 )+ '0');
		// End Vasu
    }

	return(SRB_STATUS_SUCCESS);

} // end GetInquiryData()

BOOLEAN
GetConfigInfoAndErrorLogSectorInfo(
	PHW_DEVICE_EXTENSION DeviceExtension
)
{
	ULONG ulDevice = 0, ulCurLogDrv, ulLogDrvInd, ulInd;
    BOOLEAN bFoundRaid = FALSE;

    for (ulDevice = 0; ulDevice < MAX_DRIVES_PER_CONTROLLER; ulDevice++) 
    {

        if ( !IS_IDE_DRIVE(ulDevice) )
            continue;

        if ( !bFoundIRCD )
        {
            if ( GetRaidInfoSector(DeviceExtension, ulDevice, gaucIRCDData, &ulInd) )
                bFoundIRCD = TRUE;
        }

        InitErrorLogAndIRCDIndices(DeviceExtension, ulDevice);

	}

	return TRUE;

} // end GetRaidConfiguration()

BOOLEAN 
GetRaidInfoSector(
		PHW_DEVICE_EXTENSION pDE, 
		LONG lTargetId, 
		PUCHAR pRaidConfigSector,
        PULONG pulInd)
{
	ULONG		ulInd = 0;
    ULONG       ulSecInd;
    BOOLEAN     bFound = FALSE;

#ifdef DUMMY_RAID10_IRCD

    AtapiMemCpy( pRaidConfigSector,
                 gucDummyIRCD,
                 512
                );

    return TRUE;

#else // DUMMY_RAID10_IRCD

    for(ulInd=0;ulInd<MAX_IRCD_SECTOR;ulInd++)
    {
        if ( !pDE->PhysicalDrive[lTargetId].OriginalSectors )
            return FALSE;       // No drive there. So, nothing to read from.

        ulSecInd =     pDE->PhysicalDrive[lTargetId].OriginalSectors;
        ulSecInd--;        // It is a Zero Based Index so make it n-1 (becomes last sector)
        ulSecInd -= ulInd;

        PIOReadWriteSector(
				IDE_COMMAND_READ,
				pDE, 
				lTargetId, 
				ulSecInd,
				pRaidConfigSector);

        if ( IsRaidMember(pRaidConfigSector) )
        {
            *pulInd = ulInd;
            bFound = TRUE;
            break;
        }
    }

#endif // DUMMY_RAID10_IRCD

	return bFound;
}

BOOLEAN
InitErrorLogAndIRCDIndices(
	PHW_DEVICE_EXTENSION DeviceExtension,
    ULONG ulTargetId
)
{
    UCHAR aucInfoSector[IDE_SECTOR_SIZE];
    ULONG ulInd = 0;
    ULONG ulIrcdSecInd, ulErrLogSecInd, ulOriginalSectors;
	PERROR_LOG_HEADER pErrorLogHeader = (PERROR_LOG_HEADER)aucInfoSector;
    USHORT usMaxErrors;

    GetRaidInfoSector(DeviceExtension, ulTargetId, aucInfoSector,&ulInd);

    ulOriginalSectors = DeviceExtension->PhysicalDrive[ulTargetId].OriginalSectors;
    DeviceExtension->PhysicalDrive[ulTargetId].IrcdSectorIndex = ulOriginalSectors - ulInd - 1;
    ulIrcdSecInd = DeviceExtension->PhysicalDrive[ulTargetId].IrcdSectorIndex;

    // Error Log Sector will always be behind the last but one sector (minimum) ... just to allocate the room for
    //  IRCD (for future Use
    ulErrLogSecInd = ulIrcdSecInd - 1;

    PIOReadWriteSector(
			IDE_COMMAND_READ,
			DeviceExtension, 
			ulTargetId, 
			ulErrLogSecInd,  // Error Log will be the very next sector of the IRCD
			aucInfoSector);


	// if BIOS has not init yet
	if ( AtapiStringCmp( 
				pErrorLogHeader->Signature, 
                IDERAID_ERROR_LOG_SIGNATURE,
                IDERAID_ERROR_LOG_SIGNATURE_LENGTH) )
    {
		InitErrorLogSector (DeviceExtension, ulTargetId, ulErrLogSecInd, aucInfoSector);
    } 
    else 
    {
        usMaxErrors = (USHORT)( ( (ULONG)(pErrorLogHeader->ErrorLogSectors << 9) - 
                                (ULONG)sizeof(ERROR_LOG_HEADER) ) / (ULONG)sizeof(ERROR_LOG) );
        // assume the structure size is greater than the previous one
        if (pErrorLogHeader->MaxErrorCount > usMaxErrors)
    		InitErrorLogSector (DeviceExtension, ulTargetId, ulErrLogSecInd, aucInfoSector);
    }

	// init Error Reported count
	DeviceExtension->PhysicalDrive[ulTargetId].ErrorReported = 0;

	// init Error Found count
	DeviceExtension->PhysicalDrive[ulTargetId].ErrorFound = pErrorLogHeader->TotalErrorCount;

	// save error sector index
	DeviceExtension->PhysicalDrive[ulTargetId].ErrorLogSectorIndex = ulErrLogSecInd;

    // fill out the total number of visible sectors
    DeviceExtension->PhysicalDrive[ulTargetId].Sectors = ulErrLogSecInd - 1;

    return TRUE;
}

VOID
InitErrorLogSector (
		PHW_DEVICE_EXTENSION	pDE, 
		LONG					lTargetId, 
		ULONG					ulStartIndex,
		PUCHAR					pErrorLogSector)
{
	PERROR_LOG_HEADER pErrorLogHeader = (PERROR_LOG_HEADER)pErrorLogSector;

	// signature string
    AtapiCopyString(pErrorLogHeader->Signature, 
                    IDERAID_ERROR_LOG_SIGNATURE, 
                    IDERAID_ERROR_LOG_SIGNATURE_LENGTH);

	// size of this structure
	pErrorLogHeader->Size = (UCHAR)sizeof(ERROR_LOG_HEADER);

	// size of error log structure
	pErrorLogHeader->SizeErrorLogStruct = (UCHAR)sizeof(ERROR_LOG);

	// error log sector
	pErrorLogHeader->ErrorLogSectors = 1;

	// max error log count
	pErrorLogHeader->MaxErrorCount = (USHORT)( ( (ULONG)(pErrorLogHeader->ErrorLogSectors << 9) - 
											  (ULONG)sizeof(ERROR_LOG_HEADER) ) / (ULONG)sizeof(ERROR_LOG) );

	// total error log count
	pErrorLogHeader->TotalErrorCount = 0;

	// head pos
	pErrorLogHeader->Head = 0;

	// tail pos
	pErrorLogHeader->Tail = 0;

	// write to drive
	PIOReadWriteSector(
				IDE_COMMAND_WRITE,
				pDE, 
				lTargetId, 
				ulStartIndex,
				pErrorLogSector);

}

BOOLEAN ReadWriteSector(
				UCHAR					theCmd,	// IDE_COMMAND_READ or write
				PHW_DEVICE_EXTENSION	DeviceExtension, 
				LONG					lTargetId, 
				PULONG					pStartSector,
				PUCHAR					pSectorBuffer)
{
    ULONG ulSectors;
    ULONG ulChannel = lTargetId>>1;
	PIDE_REGISTERS_1 pBaseIoAddress1 = DeviceExtension->BaseIoAddress1[ulChannel];
    PIDE_REGISTERS_2 pBaseIoAddress2 = DeviceExtension->BaseIoAddress2[ulChannel];
    ULONG ulCount, ulSecCounter, ulValue;
    UCHAR ucStatus, ucTemp;
    ULONG ulSectorNumber, ulCylinderLow, ulCylinderHigh, ulHead;

	if ((*pStartSector) >= MAX_IRCD_SECTOR)
        return FALSE;	// goes beyond the margin

    if (!IS_IDE_DRIVE(lTargetId))
        return FALSE;

    if ( !DeviceExtension->PhysicalDrive[lTargetId].OriginalSectors )
        return FALSE;       // No drive there. So, nothing to read from.


    ulSectors =     DeviceExtension->PhysicalDrive[lTargetId].OriginalSectors;
    ulSectors--;        // It is a Zero Based Index so make it n-1 (becomes last sector)

	ulSectors -= (*pStartSector);
    ulSecCounter = 0;

    while ( ulSecCounter < MAX_IRCD_SECTOR )
    {
        ulValue = (ulSectors - ulSecCounter);

	    SELECT_LBA_DEVICE(pBaseIoAddress1, lTargetId, ulValue);

        ScsiPortStallExecution(1);  // we have to wait atleast 400 ns ( 1000 ns = 1 Micro Second ) to get the Busy Bit to set

        WAIT_ON_BUSY(pBaseIoAddress1, ucStatus);

        if ( ((ucStatus & IDE_STATUS_BUSY)) || (!(ucStatus & IDE_STATUS_DRDY)) )
        {
            DebugPrint((0,"\n\n\n\n\nAre Very B A D \n\n\n\n\n"));
        }

        ulSectorNumber = ulValue & 0x000000ff;
        ulCylinderLow = (ulValue & 0x0000ff00) >> 8;
        ulCylinderHigh = (ulValue & 0xff0000) >> 16;

	    ScsiPortWritePortUchar(&pBaseIoAddress1->SectorCount, 1);
	    ScsiPortWritePortUchar(&pBaseIoAddress1->SectorNumber, (UCHAR)ulSectorNumber);
	    ScsiPortWritePortUchar(&pBaseIoAddress1->CylinderLow,(UCHAR)ulCylinderLow);
	    ScsiPortWritePortUchar(&pBaseIoAddress1->CylinderHigh,(UCHAR)ulCylinderHigh);
        ScsiPortWritePortUchar(&pBaseIoAddress1->Command, theCmd);
        
        WAIT_ON_BUSY(pBaseIoAddress1, ucStatus);

        WAIT_FOR_DRQ(pBaseIoAddress1, ucStatus);

	    if (!(ucStatus & IDE_STATUS_DRQ)) 
        {
		    DebugPrint((0,"\nHaaa.... I couldn't read/write the sector..............1\n"));
		    return(FALSE);
	    }

        //
        // Read status to acknowledge any interrupts generated.
        //

        GET_BASE_STATUS(pBaseIoAddress1, ucStatus);

        //
        // Check for error on really stupid master devices that assert random
        // patterns of bits in the status register at the slave address.
        //
        if (ucStatus & IDE_STATUS_ERROR) 
        {
            DebugPrint((0,"\nHaaa.... I couldn't read/write the sector..............2\n"));
            return(FALSE);
        }

        WAIT_ON_BUSY(pBaseIoAddress1,ucStatus);

        WAIT_ON_BUSY(pBaseIoAddress1,ucStatus);

        WAIT_ON_BUSY(pBaseIoAddress1,ucStatus);

    	if ( (ucStatus & IDE_STATUS_DRQ) && (!(ucStatus & IDE_STATUS_BUSY)) )
        {
			if (theCmd == IDE_COMMAND_READ) 
            {
				READ_BUFFER(pBaseIoAddress1, (unsigned short *)pSectorBuffer, 256);
			}
			else
            {
			    if (theCmd == IDE_COMMAND_WRITE)
                {
                    ULONG ulCounter;
				    WRITE_BUFFER(pBaseIoAddress1, (unsigned short *)pSectorBuffer, 256);
                    WAIT_FOR_DRQ(pBaseIoAddress1, ucStatus);
	                if (ucStatus & IDE_STATUS_DRQ) 
                    {
		                DebugPrint((0,"\nHaaa.... I couldn't read/write the sector..............3\n"));
                        for(ulCounter=0;ulCounter<4;ulCounter++)
                        {
                            ScsiPortWritePortUchar((PUCHAR)&pBaseIoAddress1->Data, pSectorBuffer[ulCounter]);
                            ScsiPortStallExecution(1);  // we have to wait atleast 400 ns ( 1000 ns = 1 Micro Second ) to get the Busy Bit to set
                        }
	                }
                }
            }
            break;
        }

	    //
	    // Read status. This will clear the interrupt.
	    //
    	GET_BASE_STATUS(pBaseIoAddress1, ucStatus);

        ulSecCounter++; // This error has to be handled
    }

    DeviceExtension->bIntFlag = TRUE;

	(*pStartSector) += ulSecCounter;

	//
	// Read status. This will clear the interrupt.
	//

	GET_BASE_STATUS(pBaseIoAddress1, ucTemp);


	if ( ucStatus & IDE_STATUS_ERROR )
        return FALSE;
    else 
        return TRUE;
}

//
// ErrorLogErase
//
//  move tail
//  dec error reported
//  dec error found and total error count
//
BOOLEAN
ErrorLogErase (
		IN PHW_DEVICE_EXTENSION	pDE, 
		IN LONG					lTargetId, 
		IN PUCHAR				pErrorLogSector,
		IN USHORT				NumErrorLogs)
{
	PERROR_LOG_HEADER pErrorLogHeader = (PERROR_LOG_HEADER)pErrorLogSector;
	PERROR_LOG pErrorLog = (PERROR_LOG)(pErrorLogSector + sizeof(ERROR_LOG_HEADER));
	USHORT	index = pErrorLogHeader->Tail;
	USHORT	numToErase = NumErrorLogs;

	if (numToErase > pDE->PhysicalDrive[lTargetId].ErrorReported)
		numToErase = pDE->PhysicalDrive[lTargetId].ErrorReported;

	if (numToErase == 0)
		return FALSE;

	// find the new tail pos
	index = index + numToErase;
	if (index >= pErrorLogHeader->MaxErrorCount) // circled buffer
		index -= pErrorLogHeader->MaxErrorCount;
	pErrorLogHeader->Tail = index;

	// dec reported
	pDE->PhysicalDrive[lTargetId].ErrorReported -= numToErase;

	// dec error found and total count
	pDE->PhysicalDrive[lTargetId].ErrorFound -= numToErase;
	pErrorLogHeader->TotalErrorCount -= numToErase;

	return TRUE;
}

UCHAR
IdeBuildSenseBuffer(
	IN PHW_DEVICE_EXTENSION DeviceExtension,
	IN PSCSI_REQUEST_BLOCK Srb
)

/*++
Routine Description:

	Builts an artificial sense buffer to report the results of a GET_MEDIA_STATUS
	command. This function is invoked to satisfy the SCSIOP_REQUEST_SENSE.
Arguments:

	DeviceExtension - ATAPI driver storage.
	Srb - System request block.

Return Value:

	SRB status (ALWAYS SUCCESS).

--*/

{
	PSENSE_DATA	 senseBuffer = (PSENSE_DATA)Srb->DataBuffer;


	if (senseBuffer)
    {
		if (DeviceExtension->ReturningMediaStatus[Srb->TargetId] & IDE_ERROR_MEDIA_CHANGE) {

			senseBuffer->ErrorCode = 0x70;
			senseBuffer->Valid	   = 1;
			senseBuffer->AdditionalSenseLength = 0xb;
			senseBuffer->SenseKey =	 SCSI_SENSE_UNIT_ATTENTION;
			senseBuffer->AdditionalSenseCode = SCSI_ADSENSE_MEDIUM_CHANGED;
			senseBuffer->AdditionalSenseCodeQualifier = 0;

		} else if (DeviceExtension->ReturningMediaStatus[Srb->TargetId] &
					IDE_ERROR_MEDIA_CHANGE_REQ) {

			senseBuffer->ErrorCode = 0x70;
			senseBuffer->Valid	   = 1;
			senseBuffer->AdditionalSenseLength = 0xb;
			senseBuffer->SenseKey =	 SCSI_SENSE_UNIT_ATTENTION;
			senseBuffer->AdditionalSenseCode = SCSI_ADSENSE_MEDIUM_CHANGED;
			senseBuffer->AdditionalSenseCodeQualifier = 0;

		} else if (DeviceExtension->ReturningMediaStatus[Srb->TargetId] & IDE_ERROR_END_OF_MEDIA) {

			senseBuffer->ErrorCode = 0x70;
			senseBuffer->Valid	   = 1;
			senseBuffer->AdditionalSenseLength = 0xb;
			senseBuffer->SenseKey =	 SCSI_SENSE_NOT_READY;
			senseBuffer->AdditionalSenseCode = SCSI_ADSENSE_NO_MEDIA_IN_DEVICE;
			senseBuffer->AdditionalSenseCodeQualifier = 0;

		} else if (DeviceExtension->ReturningMediaStatus[Srb->TargetId] & IDE_ERROR_DATA_ERROR) {

			senseBuffer->ErrorCode = 0x70;
			senseBuffer->Valid	   = 1;
			senseBuffer->AdditionalSenseLength = 0xb;
			senseBuffer->SenseKey =	 SCSI_SENSE_DATA_PROTECT;
			senseBuffer->AdditionalSenseCode = 0;
			senseBuffer->AdditionalSenseCodeQualifier = 0;
		}

		return SRB_STATUS_SUCCESS;
	}
	return SRB_STATUS_ERROR;

}// End of IdeBuildSenseBuffer

VOID
IdeMediaStatus(
	BOOLEAN EnableMSN,
	IN PHW_DEVICE_EXTENSION DeviceExtension,
	ULONG TargetId
)
/*++

Routine Description:

	Enables disables media status notification

Arguments:

DeviceExtension - ATAPI driver storage.

--*/

{
	UCHAR channel;
	PIDE_REGISTERS_1 baseIoAddress;
	UCHAR statusByte,errorByte;


	channel = (UCHAR) (TargetId >> 1);

	baseIoAddress = DeviceExtension->BaseIoAddress1[channel];

    SELECT_DEVICE(baseIoAddress, TargetId);

	if (EnableMSN == TRUE)
    {

		//
		// If supported enable Media Status Notification support
		//

		if ((DeviceExtension->DeviceFlags[TargetId] & DFLAGS_REMOVABLE_DRIVE)) 
        {

			//
			// enable
			//
			ScsiPortWritePortUchar((PUCHAR)baseIoAddress + 1,(UCHAR) (0x95));
			ScsiPortWritePortUchar(&baseIoAddress->Command,
								   IDE_COMMAND_ENABLE_MEDIA_STATUS);

			WAIT_ON_BASE_BUSY(baseIoAddress,statusByte);

			if (statusByte & IDE_STATUS_ERROR) 
            {
				//
				// Read the error register.
				//
				errorByte = ScsiPortReadPortUchar((PUCHAR)baseIoAddress + 1);

				DebugPrint((1,
							"IdeMediaStatus: Error enabling media status. Status %x, error byte %x\n",
							 statusByte,
							 errorByte));
			} 
            else 
            {
				DeviceExtension->DeviceFlags[TargetId] |= DFLAGS_MEDIA_STATUS_ENABLED;
				DebugPrint((1,"IdeMediaStatus: Media Status Notification Supported\n"));
				DeviceExtension->ReturningMediaStatus[TargetId] = 0;

			}

		}
	} 
    else 
    { // end if EnableMSN == TRUE

		//
		// disable if previously enabled
		//
		if ((DeviceExtension->DeviceFlags[TargetId] & DFLAGS_MEDIA_STATUS_ENABLED)) 
        {
			ScsiPortWritePortUchar((PUCHAR)baseIoAddress + 1,(UCHAR) (0x31));
			ScsiPortWritePortUchar(&baseIoAddress->Command,
								   IDE_COMMAND_ENABLE_MEDIA_STATUS);

			WAIT_ON_BASE_BUSY(baseIoAddress,statusByte);
			DeviceExtension->DeviceFlags[TargetId] &= ~DFLAGS_MEDIA_STATUS_ENABLED;
		}


	}

} // end IdeMediaStatus()

BOOLEAN
IsRaidMember(
	IN PUCHAR pucIRCDSector
)

{
	PIRCD_HEADER pRaidHeader;

	pRaidHeader = (PIRCD_HEADER) pucIRCDSector;

	if (AtapiStringCmp(pRaidHeader->Signature, IDE_RAID_SIGNATURE, IDE_RAID_SIGNATURE_LENGTH - 1) == 0) 
    {
		//
		// Found RAID member signature.
		//

		return(TRUE);
	}

	return(FALSE);

} // end IsRaidMember()

BOOLEAN
IssueIdentify(
	IN PHW_DEVICE_EXTENSION DeviceExtension,
	IN UCHAR DeviceNumber,
	IN UCHAR Channel,
	IN UCHAR Command
)
/*++

Routine Description:

	Issue IDENTIFY command to a device.

Arguments:

	DeviceExtension - HBA miniport driver's adapter data storage
	DeviceNumber - Indicates which device.
	Command - Either the standard (EC) or the ATAPI packet (A1) IDENTIFY.

Return Value:

	TRUE if all goes well.

--*/
{
	PIDE_REGISTERS_1	 baseIoAddress1 = DeviceExtension->BaseIoAddress1[Channel] ;
	PIDE_REGISTERS_2	 baseIoAddress2 = DeviceExtension->BaseIoAddress2[Channel];
	ULONG				 waitCount = 20000;
	ULONG				 i,j;
	UCHAR				 statusByte;
	UCHAR				 signatureLow,
						 signatureHigh;
	UCHAR k;	// Channel number.
	UCHAR targetId;
    PUSHORT         puIdentifyData;

	//
	// Select device 0 or 1.
	//

	SELECT_DEVICE(baseIoAddress1, DeviceNumber);

	//
	// Check that the status register makes sense.
	//

    // The call came here since there is a drive ... so let us not worry about whether there is any drive at this place
	GET_BASE_STATUS(baseIoAddress1, statusByte);    

	//
	// Load CylinderHigh and CylinderLow with number bytes to transfer.
	//

	ScsiPortWritePortUchar(&baseIoAddress1->CylinderHigh, (0x200 >> 8));
	ScsiPortWritePortUchar(&baseIoAddress1->CylinderLow,  (0x200 & 0xFF));

    WAIT_ON_BUSY(baseIoAddress1, statusByte);

	//
	// Send IDENTIFY command.
	//
	WAIT_ON_BUSY(baseIoAddress1,statusByte);

	ScsiPortWritePortUchar(&baseIoAddress1->Command, Command);

	WAIT_ON_BUSY(baseIoAddress1,statusByte);

    if ( ( !( statusByte & IDE_STATUS_BUSY ) ) && ( !( statusByte & IDE_STATUS_DRQ ) ) )
        // this is an error... so let us not try any more.
        return FALSE;

    WAIT_ON_BUSY(baseIoAddress1,statusByte);

	//
	// Wait for DRQ.
	//

	for (i = 0; i < 4; i++) 
    {
		WAIT_FOR_DRQ(baseIoAddress1, statusByte);

		if (statusByte & IDE_STATUS_DRQ)
        {
            break;
        }
    }

	//
	// Read status to acknowledge any interrupts generated.
	//

	GET_BASE_STATUS(baseIoAddress1, statusByte);

	//
	// Check for error on really stupid master devices that assert random
	// patterns of bits in the status register at the slave address.
	//

	if ((Command == IDE_COMMAND_IDENTIFY) && (statusByte & IDE_STATUS_ERROR)) 
    {
		return FALSE;
	}

	DebugPrint((1, "IssueIdentify: Status before read words %x\n", statusByte));

	//
	// Suck out 256 words. After waiting for one model that asserts busy
	// after receiving the Packet Identify command.
	//

	WAIT_ON_BUSY(baseIoAddress1,statusByte);

	if (!(statusByte & IDE_STATUS_DRQ)) 
    {
		return FALSE;
	}

	targetId = (Channel << 1) + DeviceNumber;

	READ_BUFFER(baseIoAddress1, (PUSHORT)&DeviceExtension->FullIdentifyData[targetId], 256);

	//
	// Check out a few capabilities / limitations of the device.
	//

	if (DeviceExtension->FullIdentifyData[targetId].MediaStatusNotification & 1) 
    {
		//
		// Determine if this drive supports the MSN functions.
		//

		DebugPrint((2,"IssueIdentify: Marking drive %d as removable. MSN = %d\n",
					Channel * 2 + DeviceNumber,
					DeviceExtension->FullIdentifyData[targetId].MediaStatusNotification));


		DeviceExtension->DeviceFlags[(Channel * 2) + DeviceNumber] |= DFLAGS_REMOVABLE_DRIVE;
	}

	if (DeviceExtension->FullIdentifyData[targetId].MaximumBlockTransfer) 
    {
		//
		// Determine max. block transfer for this device.
		//

		DeviceExtension->MaximumBlockXfer[targetId] =
			(UCHAR)(DeviceExtension->FullIdentifyData[targetId].MaximumBlockTransfer & 0xFF);
	}

	AtapiMemCpy(
		(PUCHAR)&DeviceExtension->IdentifyData[targetId],
		(PUCHAR)&DeviceExtension->FullIdentifyData[targetId],
		sizeof(IDENTIFY_DATA2)
		);

    puIdentifyData = (PUSHORT) &(DeviceExtension->FullIdentifyData[targetId]);

	if (DeviceExtension->IdentifyData[targetId].GeneralConfiguration & 0x20 &&
		Command != IDE_COMMAND_IDENTIFY) 
    {
		//
		// This device interrupts with the assertion of DRQ after receiving
		// Atapi Packet Command
		//

		DeviceExtension->DeviceFlags[targetId] |= DFLAGS_INT_DRQ;

		DebugPrint((2, "IssueIdentify: Device interrupts on assertion of DRQ.\n"));

	} 
    else 
    {
		DebugPrint((2, "IssueIdentify: Device does not interrupt on assertion of DRQ.\n"));
	}

	if (((DeviceExtension->IdentifyData[targetId].GeneralConfiguration & 0xF00) == 0x100) &&
		Command != IDE_COMMAND_IDENTIFY) 
    {
		//
		// This is a tape.
		//

		DeviceExtension->DeviceFlags[targetId] |= DFLAGS_TAPE_DEVICE;

		DebugPrint((2, "IssueIdentify: Device is a tape drive.\n"));

	} 
    else 
    {
		DebugPrint((2, "IssueIdentify: Device is not a tape drive.\n"));
	}

	//
	// Work around for some IDE and one model Atapi that will present more than
	// 256 bytes for the Identify data.
	//

	WAIT_ON_BUSY(baseIoAddress1,statusByte);

	for (i = 0; i < 0x10000; i++) 
    {
		GET_STATUS(baseIoAddress1,statusByte);

		if (statusByte & IDE_STATUS_DRQ) 
        {
			//
			// Suck out any remaining bytes and throw away.
			//

			ScsiPortReadPortUshort(&baseIoAddress1->Data);

		} 
        else 
        {
			break;
		}
	}

	DebugPrint((3, "IssueIdentify: Status after read words (%x)\n", statusByte));

	return TRUE;

} // end IssueIdentify()


SRBSTATUS
PostPassThruCommand(
	IN PHW_DEVICE_EXTENSION DeviceExtension,
	IN PPHYSICAL_COMMAND pPhysicalCommand
)
{
	PIDE_REGISTERS_1 baseIoAddress1;
    UCHAR statusByte = 0;
    PPHYSICAL_REQUEST_BLOCK pPrb = DeviceExtension->PhysicalDrive[pPhysicalCommand->TargetId].pPrbList[pPhysicalCommand->ucStartInd];
    PSCSI_REQUEST_BLOCK Srb = pPrb->pPdd->OriginalSrb;
    PPASS_THRU_DATA pPassThruData = (PPASS_THRU_DATA)
    (((PSRB_BUFFER)Srb->DataBuffer)->caDataBuffer);
    PUCHAR pucTaskFile = pPassThruData->aucTaskFile;
    UCHAR ucBitMapValue = pPassThruData->ucTaskFileBitMap;
    UCHAR ucChannel;

	DebugPrint((3, "\nSetDriveRegisters: Entering routine.\n"));

	ucChannel = GET_CHANNEL(pPhysicalCommand);

	baseIoAddress1 = DeviceExtension->BaseIoAddress1[ucChannel];

	WAIT_ON_BUSY(baseIoAddress1, statusByte);

	//
	// Check for erroneous IDE status.
	//
	if (statusByte & IDE_STATUS_BUSY)
    {
        DebugPrint((3, "S%x", (ULONG)statusByte));

        // Controller is not free for Accepting the command.
		return FALSE;
	}

    SELECT_LBA_DEVICE(baseIoAddress1, pPhysicalCommand->TargetId, 0);

	WAIT_ON_BUSY(baseIoAddress1, statusByte);

	//
	// Check for erroneous IDE status.
	//
	if (((statusByte & IDE_STATUS_BUSY)) || 
        (!(statusByte & IDE_STATUS_DRDY)))
    {
        // Drive is not Ready.
		return FALSE;
	}

    if ( 1  & ucBitMapValue )   // zero th byte in Task File
        ScsiPortWritePortUchar(&baseIoAddress1->SectorCount, pucTaskFile[0]);

    if ( (1 << 1) & ucBitMapValue )   // First byte in Task File
	    ScsiPortWritePortUchar(&baseIoAddress1->SectorNumber, pucTaskFile[1]);

    if ( ( (1 << (offsetof(IDE_REGISTERS_1, SectorCount) )) & ucBitMapValue ) )
        ScsiPortWritePortUchar(&baseIoAddress1->SectorCount, pucTaskFile[offsetof(IDE_REGISTERS_1, SectorCount)]);

    if ( ( (1 << (offsetof(IDE_REGISTERS_1, SectorNumber) )) & ucBitMapValue ) )
	    ScsiPortWritePortUchar(&baseIoAddress1->SectorNumber, pucTaskFile[offsetof(IDE_REGISTERS_1, SectorNumber)]);

    if ( ( (1 << (offsetof(IDE_REGISTERS_1, CylinderLow) )) & ucBitMapValue ) )
	    ScsiPortWritePortUchar(&baseIoAddress1->CylinderLow, pucTaskFile[offsetof(IDE_REGISTERS_1, CylinderLow)]);

    if ( ( (1 << (offsetof(IDE_REGISTERS_1, CylinderHigh) )) & ucBitMapValue ) )
	    ScsiPortWritePortUchar(&baseIoAddress1->CylinderHigh, pucTaskFile[offsetof(IDE_REGISTERS_1, CylinderHigh)]);

    if ( ( (1 << (offsetof(IDE_REGISTERS_1, Command) )) & ucBitMapValue ) )
        ScsiPortWritePortUchar(&baseIoAddress1->Command, pucTaskFile[offsetof(IDE_REGISTERS_1, Command)]);

	return TRUE;
}

SRBSTATUS
PostIdeCmd(
	IN PHW_DEVICE_EXTENSION DeviceExtension,
	IN PPHYSICAL_COMMAND pPhysicalCommand
)

/*++

Routine Description:

	This routine starts IDE read, write, and verify operations.

	It supports single and RAID devices.

	It can be called multiple times for the same Pdd, in case
	the total transfer length exceeds that supported by the target
	device.

	The current transfer description and state are saved in the
	device extension, while the global transfer state is saved in
	the Pdd itself.

Arguments:

	DeviceExtension - HBA miniport driver's adapter data storage.
	Pdd - Physical request packet.

Return Value:

	SRB status:

	SRB_STATUS_BUSY
	SRB_STATUS_TIMEOUT
	SRB_STATUS_PENDING

--*/
{
	PIDE_REGISTERS_1 baseIoAddress1;
	PIDE_REGISTERS_2 baseIoAddress2;
	PBM_REGISTERS bmBase;
	UCHAR bmCommand;
	UCHAR bmStatus;
	UCHAR channel;
	ULONG i;
	ULONG k;
	BOOLEAN read;
	UCHAR scsiCommand;
	UCHAR statusByte;
	PTRANSFER_DESCRIPTOR transferDescriptor;
	ULONG wordCount, ulStartSector;
    UCHAR ucCmd, ucTargetId;

	//
	// Check for possible failure of the SRB this Pdd is part of.
	//

    ucTargetId = pPhysicalCommand->TargetId;

    if (    DRIVE_IS_UNUSABLE_STATE(ucTargetId) || 
            (!DRIVE_PRESENT(ucTargetId)) )
    {
        // This drive may be a drive that responding even when power is not there
		DebugPrint((1, "PostIdeCmd: found BUSY status\n"));
        HandleError(DeviceExtension, pPhysicalCommand);
		return SRB_STATUS_ERROR;
    }

    channel = GET_CHANNEL(pPhysicalCommand);
	baseIoAddress1 = DeviceExtension->BaseIoAddress1[channel];
	baseIoAddress2 = DeviceExtension->BaseIoAddress2[channel];
    bmBase = DeviceExtension->BaseBmAddress[channel];
	transferDescriptor = &(DeviceExtension->TransferDescriptor[channel]);

	//
	// Get the SCSI command code.
	//

	scsiCommand = pPhysicalCommand->ucCmd;

    if ( pPhysicalCommand->ucCmd == SCSIOP_INTERNAL_COMMAND )
    {
        PSGL_ENTRY pSglEntry;
		//
		// PIO transfer or VERIFY.
		// Set transfer parameters taken from the current element of the
		// logical S/G list.
		//

        // No merging concept for PIO Transfers... so we will issue command by command
		// Set buffer address..... The SglBasePhysicalAddress will have Logical Buffer Address
		transferDescriptor->DataBuffer = (PUSHORT)pPhysicalCommand->SglBaseVirtualAddress;
        pSglEntry = (PSGL_ENTRY)transferDescriptor->DataBuffer;
        // only for this command the ulCount will be stored as bytes rather than sectors
		transferDescriptor->WordsLeft = pPhysicalCommand->ulCount / 2;  // word count
        transferDescriptor->pusCurBufPtr = pSglEntry[0].Logical.Address;
        transferDescriptor->ulCurBufLen = pSglEntry[0].Logical.Length;
        transferDescriptor->ulCurSglInd = 0;
		DeviceExtension->ExpectingInterrupt[channel] = IDE_PIO_INTERRUPT;
        PostPassThruCommand(DeviceExtension, pPhysicalCommand);
        return SRB_STATUS_PENDING;
    }

	//
	// Set up transfer parameters.
	//

	if (!USES_DMA(ucTargetId) || 
		scsiCommand == SCSIOP_VERIFY || 
		scsiCommand == SCSIOP_EXECUTE_SMART_COMMAND) 
    {
        if ( SCSIOP_VERIFY == scsiCommand )
        {
            // No Buffer for Verify Command
		    transferDescriptor->DataBuffer = NULL;

	        //
	        // Initialize the transfer info common to PIO and DMA modes.
	        // 1. Sart sector
	        // 2. Number of sectors.
	        //

	        transferDescriptor->StartSector = pPhysicalCommand->ulStartSector;

		    // Sectors for this transfer.
            if ( pPhysicalCommand->ulCount > MAX_SECTORS_PER_IDE_TRANSFER )
            {
                transferDescriptor->Sectors = MAX_SECTORS_PER_IDE_TRANSFER;
            }
            else
            {
                transferDescriptor->Sectors = pPhysicalCommand->ulCount;
            }

            pPhysicalCommand->ulStartSector += transferDescriptor->Sectors;
            pPhysicalCommand->ulCount -= transferDescriptor->Sectors;
        }
        else
        {
            PSGL_ENTRY pSglEntry;
		    //
		    // PIO transfer or VERIFY.
		    // Set transfer parameters taken from the current element of the
		    // logical S/G list.
		    //

            // No merging concept for PIO Transfers... so we will issue command by command
		    // Set buffer address..... The SglBasePhysicalAddress will have Logical Buffer Address
		    transferDescriptor->DataBuffer = (PUSHORT)pPhysicalCommand->SglBaseVirtualAddress;
	    
	        //
	        // Initialize the transfer info common to PIO and DMA modes.
	        // 1. Sart sector
	        // 2. Number of sectors.
	        //

	        transferDescriptor->StartSector = pPhysicalCommand->ulStartSector;
            transferDescriptor->Sectors = pPhysicalCommand->ulCount;

		    // Set transfer length.
		    transferDescriptor->WordsLeft = (transferDescriptor->Sectors * IDE_SECTOR_SIZE) / 2;


            pSglEntry = (PSGL_ENTRY)transferDescriptor->DataBuffer;
            transferDescriptor->pusCurBufPtr = pSglEntry[0].Logical.Address;
            transferDescriptor->ulCurBufLen = pSglEntry[0].Logical.Length;
            transferDescriptor->ulCurSglInd = 0;
        }

		DeviceExtension->ExpectingInterrupt[channel] = IDE_PIO_INTERRUPT;
	} 
    else 
    {
		//
		// DMA transfer. Retrieve transfer parameters from the SGL partition list.
		//

		// Set the physical address of the SGL partition to use for this transfer.
		transferDescriptor->SglPhysicalAddress = pPhysicalCommand->SglBasePhysicalAddress;

	    //
	    // Initialize the transfer info common to PIO and DMA modes.
	    // 1. Sart sector
	    // 2. Number of sectors.
	    //

	    transferDescriptor->StartSector = pPhysicalCommand->ulStartSector;
        transferDescriptor->Sectors = pPhysicalCommand->ulCount;

		DeviceExtension->ExpectingInterrupt[channel] = IDE_DMA_INTERRUPT;
	}

#ifdef DBG
    DebugPrint((3, "Drive : %ld\tAddress : %X\tStart : %X\tSectors : %X\n", 
                    ucTargetId,
                    transferDescriptor->SglPhysicalAddress,
                    transferDescriptor->StartSector,
                    transferDescriptor->Sectors
                    ));
#endif



    

	// added by Zhang 11/22/99
	// the header pos after this transfer
	DeviceExtension->PhysicalDrive[ucTargetId].CurrentHeaderPos = transferDescriptor->StartSector + transferDescriptor->Sectors;

    //
	// Program all I/O registers except for command.
	//
	if (! SetDriveRegisters(DeviceExtension, pPhysicalCommand))
    {
        // Drive Time Out 
        DeviceExtension->PhysicalDrive[ucTargetId].TimeOutErrorCount++;

        if ( DeviceExtension->PhysicalDrive[ucTargetId].TimeOutErrorCount >= MAX_TIME_OUT_ERROR_COUNT )
        {

            FailDrive(DeviceExtension, ucTargetId);
        }

		DebugPrint((1, "PostIdeCmd: found BUSY / ERROR status\n"));
        HandleError(DeviceExtension, pPhysicalCommand);
		return SRB_STATUS_BUSY;
	}

    //
	// Check if verify, read or write request.
	//
    switch (scsiCommand)
    {
        case SCSIOP_VERIFY:
        {
		    // Set transfer length.
		    DeviceExtension->ExpectingInterrupt[channel] = IDE_PIO_INTERRUPT;
		    transferDescriptor->WordsLeft = 0;
		    ScsiPortWritePortUchar(&baseIoAddress1->Command, IDE_COMMAND_VERIFY);
            goto PostIdeCmdDone;    // for Verify Command nothing else to be done.  Just Wait for Interrupt
            break;
        }
        case SCSIOP_EXECUTE_SMART_COMMAND:
        {
		    DeviceExtension->ExpectingInterrupt[channel] = IDE_PIO_INTERRUPT;
            switch(DeviceExtension->uchSMARTCommand)
            {
            case HD_SMART_ENABLE:
            case HD_SMART_DISABLE:
            case HD_SMART_RETURN_STATUS:
		        transferDescriptor->WordsLeft = 0;
                break;
            case HD_SMART_READ_DATA:
                transferDescriptor->WordsLeft = 256;
                break;
            }
		    
            ScsiPortWritePortUchar(&baseIoAddress1->Command, IDE_COMMAND_EXECUTE_SMART);
            goto PostIdeCmdDone;
            break;
        }
        default:
        {
		    read = (SCSIOP_READ == pPhysicalCommand->ucCmd);
            break;
        }
    }

    if (USES_DMA(ucTargetId)) 
    {
		if (read) 
        {
			ScsiPortWritePortUchar(&baseIoAddress1->Command, IDE_COMMAND_READ_DMA);
			bmCommand = READ_TRANSFER;

		} 
        else 
        {
			ScsiPortWritePortUchar(&baseIoAddress1->Command, IDE_COMMAND_WRITE_DMA);
			bmCommand = WRITE_TRANSFER;
		}

        bmStatus = ScsiPortReadPortUchar(&(bmBase->Status.AsUchar));

		if (bmStatus & 1) 
        {
			DebugPrint((1, "PostIdeCmd: found Bus Master BUSY\n"));

			STOP;

            HandleError(DeviceExtension, pPhysicalCommand);
		    return SRB_STATUS_ERROR;
		}
			
        // Clear interrupt and error bits (if set).
		CLEAR_BM_INT(bmBase, statusByte);

		ScsiPortWritePortUlong(&(bmBase->SglAddress), transferDescriptor->SglPhysicalAddress);

		// Start transfer.
		ScsiPortWritePortUchar(&(bmBase->Command.AsUchar), (UCHAR)(bmCommand | START_TRANSFER));

        DebugPrint((3, "S1:%x", (ULONG)ScsiPortReadPortUchar(&(baseIoAddress2->AlternateStatus)) ));
	} 
    else 
    {
        if (read) 
        {

		    //
		    // Send read command in PIO mode.
		    //

		    if (DeviceExtension->MaximumBlockXfer[ucTargetId]) 
            {
			    ScsiPortWritePortUchar(&baseIoAddress1->Command, IDE_COMMAND_READ_MULTIPLE);

		    } 
            else 
            {
			    ScsiPortWritePortUchar(&baseIoAddress1->Command, IDE_COMMAND_READ);
		    }

	    } 
        else 
        {

		    //
		    // Send write command in PIO mode.
		    //

		    if (DeviceExtension->MaximumBlockXfer[ucTargetId] != 0) 
            {
			    //
			    // The device supports multi-sector transfers.
			    //

			    wordCount = (DeviceExtension->MaximumBlockXfer[ucTargetId] * IDE_SECTOR_SIZE) / 2;

				    //
				    // Transfer only words requested.
				    //

                wordCount = min(wordCount, transferDescriptor->WordsLeft);

                ScsiPortWritePortUchar(&baseIoAddress1->Command, IDE_COMMAND_WRITE_MULTIPLE);
		    } 
            else 
            {
			    //
			    // The device supports single-sector transfers.
			    //

			    wordCount = 256;
			    ScsiPortWritePortUchar(&baseIoAddress1->Command, IDE_COMMAND_WRITE);
		    }

		    //
		    // Wait for BSY and DRQ.
		    //

		    WAIT_ON_ALTERNATE_STATUS_BUSY(baseIoAddress2, statusByte);

		    if ((statusByte & IDE_STATUS_BUSY) || (statusByte & IDE_STATUS_ERROR)) 
            {
			    DebugPrint((1, "PostIdeCmd 2: Pdd failed due to BUSY status %x\n", statusByte));

			    STOP;

                HandleError(DeviceExtension, pPhysicalCommand);
		        return SRB_STATUS_BUSY;
		    }

            WAIT_FOR_ALTERNATE_DRQ(baseIoAddress2, statusByte);

		    if (!(statusByte & IDE_STATUS_DRQ)) 
            {
			    DebugPrint((1,
				       "PostIdeCmd: [PIO write] Failure: DRQ never asserted (%x); original status (%x)\n",
				       statusByte,
				       statusByte));

                HandleError(DeviceExtension, pPhysicalCommand);
		        return SRB_STATUS_BUSY;
		    }

		    //
		    // Write next 256 words.
		    //
            RWBufferToTransferDescriptor( DeviceExtension, 
                                            transferDescriptor, 
                                            wordCount, 
                                            SCSIOP_WRITE, 
                                            ucTargetId, 
                                            DeviceExtension->DWordIO);

		    //
		    // Adjust words left count do not adjust buffer address 
            // since it is the starting point for the SGLs for that Command.
		    // Buffer adjustments are taken care of in RWBufferToTransferDescriptor()
            //

		    transferDescriptor->WordsLeft -= wordCount;
	    }
    }
PostIdeCmdDone:

    DebugPrint((DEFAULT_DISPLAY_VALUE," E%ld ", (channel | (DeviceExtension->ucControllerId << 1)) ));


	//
	// Wait for interrupt.
	//
	return SRB_STATUS_PENDING;

} // end PostIdeCmd()

VOID
PrintCapabilities(
	IN PIDENTIFY_DATA Capabilities,
	IN UCHAR TargetId
)

{
#ifndef HYPERDISK_WIN98

	DebugPrint((
				3,
				"Atapi: TID %d capabilities (transfer mode as programmed by the BIOS):\n"
				"\tAdvanced PIO modes supported (bit mask): %xh\n"
				"\tMinimum PIO cycle time w/ IORDY: %xh\n"
				"\tMultiword DMA modes supported (bit mask): %xh\n"
				"\tMultiword DMA mode active (bit mask): %xh\n"
				"\tUltra DMA modes supported (bit mask): %xh\n"
				"\tUltra DMA mode active (bit mask): %xh\n",
				TargetId,
				Capabilities->AdvancedPioModes,
				Capabilities->MinimumPioCycleTimeIordy,
				Capabilities->MultiWordDmaSupport,
				Capabilities->MultiWordDmaActive,
				Capabilities->UltraDmaSupport,
				Capabilities->UltraDmaActive
				));
#else

	//
	// Win98 dirties the stack when the above DebugPrint gets executed.
	// One format string per statement is safe.
	//

	DebugPrint((
				3,
				"Atapi: TID %d capabilities (transfer mode as programmed by the BIOS):\n",
				TargetId
				));

	DebugPrint((
				3,
				"\tAdvanced PIO modes supported (bit mask): %xh\n",
				Capabilities->AdvancedPioModes
				));

	DebugPrint((
				3,
				"\tMinimum PIO cycle time w/ IORDY: %xh\n",
				Capabilities->MinimumPioCycleTimeIordy
				));

	DebugPrint((
				3,
				"\tMultiword DMA modes supported (bit mask): %xh\n",
				Capabilities->MultiWordDmaSupport
				));

	DebugPrint((
				3,
				"\tMultiword DMA mode active (bit mask): %xh\n",
				Capabilities->MultiWordDmaActive
				));

	DebugPrint((
				3,
				"\tUltra DMA modes supported (bit mask): %xh\n",
				Capabilities->UltraDmaSupport
				));

	DebugPrint((
				3,
				"\tUltra DMA mode active (bit mask): %xh\n",
				Capabilities->UltraDmaActive
				));

#endif

	return;

} // end PrintCapabilities()

void FailDrive(PHW_DEVICE_EXTENSION DeviceExtension, UCHAR ucTargetId)
{
    UCHAR ucLogDrvId, ucPriDrvId, ucMirrorDrvId;
    ULONG ulTempInd;
    UCHAR ucIRCDLogDrvInd, ucPhyDrvInd, ucSpareDrvPoolInd, ucConnectionId;
    PIRCD_LOGICAL_DRIVE pLogDrive = NULL;
    PIRCD_PHYSICAL_DRIVE pPhyDrive = NULL;
    PIRCD_HEADER pHeader = NULL;
    UCHAR caConfigSector[512];
    ULONG ulDrvInd, ulSecInd;
    BOOLEAN bFoundIRCD;

    if ( DeviceExtension->PhysicalDrive[ucTargetId].TimeOutErrorCount >= ( MAX_TIME_OUT_ERROR_COUNT + 0x10 ) )
        // Failing of this drive is already done.... so don't do it again... it will be equal only if it is accumulated in PostIdeCmd
        return;

    ScsiPortLogError(DeviceExtension,0,0,0,0,SP_BAD_FW_WARNING,HYPERDISK_DRIVE_LOST_POWER);

    DebugPrint((0,"\nF%d", ucTargetId));

    // Begin Vasu - 18 Aug 2000
    // Code updated from Syam's Fix on 18 Aug
    // Moved out from the immediate if loop below.
    SetStatusChangeFlag(DeviceExtension, IDERAID_STATUS_FLAG_UPDATE_DRIVE_STATUS);
    // End Vasu

    ucLogDrvId = (UCHAR)DeviceExtension->PhysicalDrive[ucTargetId].ucLogDrvId;

    // Drive Time Out 
    DeviceExtension->PhysicalDrive[ucTargetId].TimeOutErrorCount = MAX_TIME_OUT_ERROR_COUNT + 0x10;

    // Begin Vasu - 18 Aug 2000
    // Code updated from Syam's Fix on 18 Aug
    // Doubt: This should be done to RAID10 drives as RAID10 primarily has two RAID1 arrays.

    // We should not do this failing of the drive if the Logical Drive type is Raid0 or Raid 10
    // We should decide only after initializing above variable since this will decide whether the commands
    // should go the drive or not (which will avoid the freezing of the system).
    // Begin Vasu - 28 Aug 2000
    // For RAID 10 also, the physical drive status should be changed to failed.
//    if (( Raid0 == DeviceExtension->LogicalDrive[ucLogDrvId].RaidLevel ) || 
//        ( Raid10 == DeviceExtension->LogicalDrive[ucLogDrvId].RaidLevel ) )
    if ( Raid0 == DeviceExtension->LogicalDrive[ucLogDrvId].RaidLevel )
    // End Vasu
    {
        return;
    }
    // End Vasu

    // Let us go ahead and fail this drive
    ChangeMirrorDriveStatus(
        DeviceExtension, 
        0,/*It doesn't matter ... 
          just for sake... inside the function we will find out the logical drive again
          */
        ucTargetId,
        PDS_Failed
        );

    for(ulTempInd=0;ulTempInd<DeviceExtension->LogicalDrive[ucLogDrvId].StripesPerRow;ulTempInd++)
    {
		// get the primary phy drive id and its mirror drive id
		ucPriDrvId = DeviceExtension->LogicalDrive[ucLogDrvId].PhysicalDriveTid[ulTempInd];
        ucMirrorDrvId = DeviceExtension->PhysicalDrive[ucPriDrvId].ucMirrorDriveId & (~DRIVE_OFFLINE);

        if ( ( ucPriDrvId != ucTargetId )  && ( ucMirrorDrvId != ucTargetId ) ) // If this is not the drive... we just changed the status continue
            continue;

        // Begin Vasu - 09 Aug 2000
        // Added from Syam's Fix in the ATA100 Release 1.
        if (DeviceExtension->bInvalidConnectionIdImplementation)
        {
            DeviceExtension->PhysicalDrive[ucPriDrvId].ucMirrorDriveId = INVALID_DRIVE_ID;
        }
        // End Vasu.

        // If any one drive has failed then Logical Drive should go to Degraded status
        if ( ( DeviceExtension->PhysicalDrive[ucPriDrvId].Status == PDS_Failed ) ||
            ( DeviceExtension->PhysicalDrive[ucMirrorDrvId].Status == PDS_Failed ) )
        {
            DeviceExtension->LogicalDrive[ucLogDrvId].Status = LDS_Degraded; 
        }

        // If any both drives has failed then Logical Drive should go to Failed status
        if ( ( DeviceExtension->PhysicalDrive[ucPriDrvId].Status == PDS_Failed ) &&
            ( DeviceExtension->PhysicalDrive[ucMirrorDrvId].Status == PDS_Failed ) )
        {
            DeviceExtension->LogicalDrive[ucLogDrvId].Status = LDS_OffLine;
        }
    }

    TryToUpdateIRCDOnAllControllers(DeviceExtension, (ULONG)ucTargetId);
	SetStatusChangeFlag(DeviceExtension, IDERAID_STATUS_FLAG_UPDATE_DRIVE_STATUS);

}

BOOLEAN
TryToUpdateIRCDOnAllControllers(
	IN OUT PHW_DEVICE_EXTENSION DeviceExtension,
    ULONG ulTargetId
    )
{
    ULONG ulBadDrvId;
    
    ulBadDrvId = (ULONG)(( ulTargetId ) | ( DeviceExtension->ucControllerId << 2));
    SetBadDriveInGlobalParameter(ulBadDrvId);
    gulLockVal = TryToLockIRCD(DeviceExtension);
    if ( !gulLockVal )
    {
        gulChangeIRCDPending = LOCK_IRCD_PENDING;
        return FALSE;
    }

    InformAllControllers();
    gulChangeIRCDPending = SET_IRCD_PENDING;


    return TRUE;
}


ULONG
TryToLockIRCD(
	IN OUT PHW_DEVICE_EXTENSION DeviceExtension
    )
{
    ULONG ulTempLockVal = gulLockVal;

    if ( !ulTempLockVal )  // let us try to lock the IRCD (only if we didn't already lock it)
    {
        ulTempLockVal = LockIRCD(DeviceExtension, TRUE, 0);
    }

    return ulTempLockVal;
}

BOOLEAN
UpdateFinished()
{
    ULONG ulControllerInd;

    for(ulControllerInd=0;ulControllerInd<gucControllerCount;ulControllerInd++)
    {
        if (    ( gaCardInfo[ulControllerInd].pDE->Channel[0].bUpdateInfoPending ) || 
                ( gaCardInfo[ulControllerInd].pDE->Channel[1].bUpdateInfoPending ) )
                return FALSE;
    }

    return TRUE;
}

void
InformAllControllers()
{
    ULONG ulControllerInd;
    // We locked the IRCD... so let us go and inform all the controllers about this
    for(ulControllerInd=0;ulControllerInd<gucControllerCount;ulControllerInd++)
    {
        gaCardInfo[ulControllerInd].pDE->Channel[0].bUpdateInfoPending = TRUE;
        gaCardInfo[ulControllerInd].pDE->Channel[1].bUpdateInfoPending = TRUE;
    }

}

void
SetBadDriveInGlobalParameter(ULONG ulBadDrvId)
{
    ULONG ulBadDrvIdBitMap;
    ULONG ulTempPowerFailedTargetId;

    ulBadDrvIdBitMap = gulPowerFailedTargetBitMap | (1 << ulBadDrvId);

    do  // let us repeat the process of trying to set this bad drive Id
    {
        ulTempPowerFailedTargetId = gulPowerFailedTargetBitMap;
        ulBadDrvIdBitMap = gulPowerFailedTargetBitMap | (1 << ulBadDrvId);
        gulPowerFailedTargetBitMap = ulBadDrvIdBitMap;
    } while ( gulPowerFailedTargetBitMap != ulBadDrvIdBitMap );

    return;
}

void SetIRCDBufStatus(
    IN  PUCHAR pucIRCDBuf
    )
{
    UCHAR ucIRCDLogDrvInd, ucPhyDrvInd, ucSpareDrvPoolInd, ucConnectionId, ucLogDrvId;
    PIRCD_LOGICAL_DRIVE pLogDrive = NULL;
    PIRCD_PHYSICAL_DRIVE pPhyDrive = NULL;
    PIRCD_HEADER pHeader = NULL;
    ULONG ulDrvId, ulPowerFailedBitMap = gulPowerFailedTargetBitMap, ulTempPhyDrvId;
	PHW_DEVICE_EXTENSION pDE;

    DebugPrint((DEFAULT_DISPLAY_VALUE,"\nSIBS"));

    for(ulDrvId=0;ulPowerFailedBitMap;ulDrvId++, (ulPowerFailedBitMap>>=1))
    {
        if ( !( ulPowerFailedBitMap & 0x1 ) )
            continue;

        pDE = gaCardInfo[(ulDrvId>>2)].pDE;

        ucConnectionId = (UCHAR)TARGET_ID_2_CONNECTION_ID(ulDrvId);

        // Begin Vasu - 09 Aug 2000
        // Update from Syam's fix for ATA100 Release 1
        // Moved from inside the GetLogicalDriveId if loop.
        pHeader = (PIRCD_HEADER) pucIRCDBuf;
        pLogDrive = (PIRCD_LOGICAL_DRIVE) &pucIRCDBuf[sizeof(IRCD_HEADER)];
        // End Vasu.

        // Let us find out the PhysicalDrive location and change the physical and logical drive status
        if ( !GetIRCDLogicalDriveInd(pucIRCDBuf, ucConnectionId, &ucIRCDLogDrvInd, &ucPhyDrvInd, &ucSpareDrvPoolInd) )
        {
            DebugPrint((DEFAULT_DISPLAY_VALUE,"\nNF"));
            return;       // It is not a proper PhysicalDrive Id.. Something Terribly wrong
        }

        ucLogDrvId = (UCHAR)pDE->PhysicalDrive[TARGET_ID_WITHOUT_CONTROLLER_ID(ulDrvId)].ucLogDrvId;
        if ( ucLogDrvId < MAX_DRIVES_PER_CONTROLLER )
            pLogDrive[ucIRCDLogDrvInd].LogDrvStatus = (UCHAR)pDE->LogicalDrive[ucLogDrvId].Status;

        pPhyDrive = (PIRCD_PHYSICAL_DRIVE) &pucIRCDBuf[(sizeof(IRCD_HEADER) + 
                                                   (sizeof(IRCD_LOGICAL_DRIVE) * pHeader->NumberOfLogicalDrives))];
        for (ulTempPhyDrvId = 0; ulTempPhyDrvId < pHeader->NumberOfPhysicalDrives; ulTempPhyDrvId++)
        {
            if (pPhyDrive[ulTempPhyDrvId].ConnectionId == ucConnectionId)
            {
                DebugPrint((0,"\nFO1"));
                pPhyDrive[ulTempPhyDrvId].PhyDrvStatus = (UCHAR)pDE->PhysicalDrive[TARGET_ID_WITHOUT_CONTROLLER_ID(ulDrvId)].Status;
                    // Don't break as we need to take care of the drives in the spare drive pool also
                if ( pDE->bInvalidConnectionIdImplementation)
                    pPhyDrive[ulTempPhyDrvId].ConnectionId = INVALID_CONNECTION_ID;

                pDE->DeviceFlags[TARGET_ID_WITHOUT_CONTROLLER_ID(ulDrvId)] &= ~(DFLAGS_DEVICE_PRESENT);
            }
        }
    }
}

void SetOneDriveIRCD(
	IN OUT PHW_DEVICE_EXTENSION DeviceExtension,
	IN UCHAR ucTargetId
    )
{
    ULONG ulSecInd;
    UCHAR caConfigSector[512];

    if ( !IS_IDE_DRIVE(ucTargetId) )
        return;

    if ( DRIVE_IS_UNUSABLE_STATE(ucTargetId) )// This drive is bad... so let us not touch this....
        return;

    DebugPrint((DEFAULT_DISPLAY_VALUE,"\nSODI"));

    ulSecInd = DeviceExtension->PhysicalDrive[ucTargetId].IrcdSectorIndex;

#ifdef DUMMY_RAID10_IRCD

    AtapiMemCpy(caConfigSector, gucDummyIRCD, 512);

#else // DUMMY_RAID10_IRCD

	if ( PIOReadWriteSector(
				IDE_COMMAND_READ,
				DeviceExtension, 
				(ULONG)ucTargetId, 
				ulSecInd,
				caConfigSector))
    {

#endif // DUMMY_RAID10_IRCD

        SetIRCDBufStatus(caConfigSector);

#ifdef DUMMY_RAID10_IRCD

    AtapiMemCpy(gucDummyIRCD, caConfigSector, 512);

#else // DUMMY_RAID10_IRCD
	    if (PIOReadWriteSector(
				    IDE_COMMAND_WRITE,
				    DeviceExtension, 
                    (ULONG)ucTargetId, 
				    ulSecInd,
				    caConfigSector))
        {
		        // continue for the other drive
        }
    }

#endif // DUMMY_RAID10_IRCD

    DeviceExtension->PhysicalDrive[ucTargetId].bSetIRCDPending = FALSE;
}

BOOLEAN 
InSpareDrivePool(
                 IN PUCHAR RaidInfoSector,
                 IN UCHAR ucConnectionId)
{

    PIRCD_HEADER pRaidHeader = (PIRCD_HEADER)RaidInfoSector;
    PIRCD_LOGICAL_DRIVE pRaidLogDrive = (PIRCD_LOGICAL_DRIVE)GET_FIRST_LOGICAL_DRIVE(pRaidHeader);
    PIRCD_PHYSICAL_DRIVE pPhyDrive;
    ULONG ulLogDrvInd, ulDrvInd;

    for(ulLogDrvInd=0;ulLogDrvInd<pRaidHeader->NumberOfLogicalDrives;ulLogDrvInd++)
    {
        if ( SpareDrivePool == pRaidLogDrive[ulLogDrvInd].LogicalDriveType )
        {
	        pPhyDrive = (PIRCD_PHYSICAL_DRIVE)((char *)pRaidHeader + pRaidLogDrive[ulLogDrvInd].FirstStripeOffset);
			for(ulDrvInd=0;ulDrvInd<pRaidLogDrive[ulLogDrvInd].NumberOfDrives;ulDrvInd++)
            {
                if ( ucConnectionId == pPhyDrive[ulDrvInd].ConnectionId )
                    return TRUE;
            }
        }
    }

    return FALSE;
}

BOOLEAN
SetDriveFeatures(
	IN PHW_DEVICE_EXTENSION DeviceExtension,
	IN UCHAR TargetId
)

/*++

Routine Description:

	This function sets the features of 'TargetId'.

Arguments:

	DeviceExtension		Pointer to miniport instance.
	TargetId			Target ID of the device whose features are to be set up.

Return Value:

	TRUE	Success.
	FALSE	Failure.

--*/

{
	PIDE_REGISTERS_1 baseIoAddress;
	UCHAR statusByte;
	UCHAR transferMode;


	baseIoAddress = DeviceExtension->BaseIoAddress1[TargetId >> 1];

    if ( DeviceExtension->bEnableRwCache ) 
    {
    	SELECT_DEVICE(baseIoAddress, TargetId);

		ScsiPortWritePortUchar((PUCHAR)baseIoAddress + 1, FEATURE_ENABLE_WRITE_CACHE);

		ScsiPortWritePortUchar(&(baseIoAddress->Command), IDE_COMMAND_SET_FEATURES);

		WAIT_ON_BASE_BUSY(baseIoAddress, statusByte);
	}
    else
    {
    	SELECT_DEVICE(baseIoAddress, TargetId);

		ScsiPortWritePortUchar((PUCHAR)baseIoAddress + 1, FEATURE_DISABLE_WRITE_CACHE);

		ScsiPortWritePortUchar(&(baseIoAddress->Command), IDE_COMMAND_SET_FEATURES);

		WAIT_ON_BASE_BUSY(baseIoAddress, statusByte);
    }

	SELECT_DEVICE(baseIoAddress, TargetId);

	ScsiPortWritePortUchar((PUCHAR)baseIoAddress + 1, FEATURE_ENABLE_READ_CACHE);

	ScsiPortWritePortUchar(&(baseIoAddress->Command), IDE_COMMAND_SET_FEATURES);

	WAIT_ON_BASE_BUSY(baseIoAddress, statusByte);

    return ProgramTransferMode(DeviceExtension, TargetId);
}

BOOLEAN
ProgramTransferMode(
	IN PHW_DEVICE_EXTENSION DeviceExtension,
	IN UCHAR TargetId
)

/*++

Routine Description:

	This function program the drive to work in the maximum possible transfer mode.

Arguments:

	DeviceExtension		Pointer to miniport instance.
	TargetId			Target ID of the device whose features are to be set up.

Return Value:

	TRUE	Success.
	FALSE	Failure.

--*/
{
	PIDE_REGISTERS_1 baseIoAddress;
	UCHAR statusByte;
	UCHAR transferMode;

	baseIoAddress = DeviceExtension->BaseIoAddress1[TargetId >> 1];

	switch(DeviceExtension->TransferMode[TargetId]) 
    {
		case PioMode0:
			transferMode = STM_PIO(0);
			break;

		case PioMode3:
			transferMode = STM_PIO(3);
			break;

		case PioMode4:
			transferMode = STM_PIO(4);
			break;

		case DmaMode0:
			transferMode = STM_MULTIWORD_DMA(0);
			break;

		case DmaMode1:
			transferMode = STM_MULTIWORD_DMA(1);
			break;

		case DmaMode2:
			transferMode = STM_MULTIWORD_DMA(2);
			break;

		case UdmaMode0:
			transferMode = STM_UDMA(0);
			break;

		case UdmaMode1:
			transferMode = STM_UDMA(1);
			break;

		case UdmaMode2:
			transferMode = STM_UDMA(2);
			break;

		case UdmaMode3:
            switch ( DeviceExtension->ControllerSpeed )
            {
                case Udma66:
                case Udma100:
    			    transferMode = STM_UDMA(3);
                    break;
                default:

    			    transferMode = STM_UDMA(2);
                    break;
            }
			break;

		case UdmaMode4:
            switch ( DeviceExtension->ControllerSpeed )
            {
                case Udma66:
                case Udma100:
			        transferMode = STM_UDMA(4);
                    break;
                default:
			        transferMode = STM_UDMA(2);
                    break;
            }
            break;
		case UdmaMode5:
            switch ( DeviceExtension->ControllerSpeed )
            {
                case Udma100:
			        transferMode = STM_UDMA(5);
                    break;
                case Udma66:
			        transferMode = STM_UDMA(4);
                    break;
                default:
			        transferMode = STM_UDMA(2);
                    break;
            }
            break;
		default:
			return(FALSE);
	}

	SELECT_DEVICE(baseIoAddress, TargetId);

	ScsiPortWritePortUchar((PUCHAR)baseIoAddress + 1, FEATURE_SET_TRANSFER_MODE);

	ScsiPortWritePortUchar(&(baseIoAddress->SectorCount), transferMode);

	ScsiPortWritePortUchar(&(baseIoAddress->Command), IDE_COMMAND_SET_FEATURES);
	
	WAIT_ON_BASE_BUSY(baseIoAddress, statusByte);

	if ((statusByte & IDE_STATUS_ERROR) || (statusByte & IDE_STATUS_BUSY)) 
    {
		DebugPrint((1, "SetDriveFeatures on TID %d failed.\n", TargetId));

		return(FALSE);
	}

	return(TRUE);

} // end ProgramTransferMode()


BOOLEAN
SetDriveParameters(
	IN PHW_DEVICE_EXTENSION DeviceExtension,
	IN UCHAR Channel,
	IN UCHAR DeviceNumber
)

/*++

Routine Description:

	Set drive parameters using the IDENTIFY data.

Arguments:

	DeviceExtension - HBA miniport driver's adapter data storage
	DeviceNumber - Indicates which device.
	Channel - Indicates which channel.

Return Value:

	TRUE if all goes well.



--*/

{
	PIDE_REGISTERS_1	 baseIoAddress1 = DeviceExtension->BaseIoAddress1[Channel];
	PIDE_REGISTERS_2	 baseIoAddress2 = DeviceExtension->BaseIoAddress2[Channel];
	PIDENTIFY_DATA2		 identifyData	= &DeviceExtension->IdentifyData[(Channel * 2) + DeviceNumber];
	ULONG i;
	UCHAR statusByte;

	DebugPrint((3, "\nSetDriveParameters: Entering routine.\n"));

	DebugPrint((0, "SetDriveParameters: Drive : %ld Number of heads %x\n", DeviceNumber, identifyData->NumberOfHeads));

	DebugPrint((0, "SetDriveParameters: Sectors per track %x\n", identifyData->SectorsPerTrack));

    DebugPrint(( 0, "The value entering into the ports : %X\n", (ULONG)(((DeviceNumber << 4) | 0xA0) | (identifyData->NumberOfHeads - 1))) );

	//
	// Set up registers for SET PARAMETER command.
	//

	ScsiPortWritePortUchar(&baseIoAddress1->DriveSelect,
						   (UCHAR)(((DeviceNumber << 4) | 0xA0) | (identifyData->NumberOfHeads - 1)));

    ScsiPortWritePortUchar(&baseIoAddress1->SectorCount, (UCHAR)identifyData->SectorsPerTrack);

	//
	// Send SET PARAMETER command.
	//

	ScsiPortWritePortUchar(&baseIoAddress1->Command,
						   IDE_COMMAND_SET_DRIVE_PARAMETERS);

    
	ScsiPortStallExecution(1000);

	//
	// Wait for up to 30 milliseconds for ERROR or command complete.
	//

	for (i = 0; i < 30 * 1000; i++) 
    {
		UCHAR errorByte;

//		GET_STATUS(baseIoAddress1, statusByte);
        statusByte = ScsiPortReadPortUchar(&baseIoAddress2->AlternateStatus);

		if (statusByte & IDE_STATUS_ERROR) 
        {
			errorByte = ScsiPortReadPortUchar((PUCHAR)baseIoAddress1 + 1);

			DebugPrint((0,
						"SetDriveParameters: Error bit set. Status %x, error %x\n",
						errorByte,
						statusByte));

			return FALSE;

		} else if ((statusByte & ~IDE_STATUS_INDEX ) == IDE_STATUS_IDLE) {

			break;

		} else {

			ScsiPortStallExecution(100);
		}
	}


    DebugPrint((0, "Status after setting Drive Parameters : %X\n", statusByte));

	//
	// Check for timeout.
	//

	GET_STATUS(baseIoAddress1, statusByte);

    if ((statusByte & ~IDE_STATUS_INDEX ) == IDE_STATUS_IDLE)
        return TRUE;
    else
        return FALSE;

} // end SetDriveParameters()

BOOLEAN
SetDriveRegisters(
	IN PHW_DEVICE_EXTENSION DeviceExtension,
	IN PPHYSICAL_COMMAND pPhysicalCommand
)
{
	PIDE_REGISTERS_1 baseIoAddress1;
	UCHAR cylinderHigh;
	UCHAR cylinderLow;
	UCHAR headNumber;
	UCHAR sectors;
	UCHAR sectorNumber;
    USHORT heads;
	UCHAR k;
	USHORT sectorsPerTrack;
	ULONG startSector;
	UCHAR targetId;
    UCHAR statusByte = 0;

	DebugPrint((3, "\nSetDriveRegisters: Entering routine.\n"));

	k = GET_CHANNEL(pPhysicalCommand);
	targetId = pPhysicalCommand->TargetId;

	sectors = (UCHAR)DeviceExtension->TransferDescriptor[k].Sectors;
	startSector = DeviceExtension->TransferDescriptor[k].StartSector;

	baseIoAddress1 = DeviceExtension->BaseIoAddress1[k];

	WAIT_ON_BUSY(baseIoAddress1, statusByte);

	//
	// Check for erroneous IDE status.
	//
	if (statusByte & IDE_STATUS_BUSY)
    {
        DebugPrint((3, "S%x", (ULONG)statusByte));

        // Controller is not free for Accepting the command.
		return FALSE;
	}

    // Begin Vasu - 13 Feb 2001
    // Code to take care of Drive Removals
    if (statusByte & IDE_STATUS_ERROR)
    {
        DebugPrint((3, "S%x", (ULONG)statusByte));

        // Controller is not free for Accepting the command.
		return FALSE;
    }
    // End Vasu

	if (DeviceExtension->DeviceFlags[targetId] & DFLAGS_LBA) 
    {
        sectorNumber = (UCHAR) (startSector & 0x000000ff);
        cylinderLow = (UCHAR) ((startSector & 0x0000ff00) >> 8);
        cylinderHigh = (UCHAR) ((startSector & 0x00ff0000) >> 16);

        SELECT_LBA_DEVICE(baseIoAddress1, targetId, startSector);
	} 
    else 
    {
		sectorsPerTrack = DeviceExtension->IdentifyData[targetId].SectorsPerTrack;
		heads = DeviceExtension->IdentifyData[targetId].NumberOfHeads;

		// Calculate the start sector.
		sectorNumber = (UCHAR)((startSector % sectorsPerTrack) + 1);

		// Calculate the head number.
		headNumber = (UCHAR) ((startSector / sectorsPerTrack) % heads);

		// Calculate the low part of the cylinder number.
		cylinderLow =  (UCHAR)(startSector / (sectorsPerTrack * heads));

		// Calculate the high part of the cylinder number.
		cylinderHigh = (UCHAR)((startSector / (sectorsPerTrack * heads)) >> 8);

		// Program the device/head register.
		SELECT_CHS_DEVICE(baseIoAddress1, targetId, headNumber);
	}

	WAIT_ON_BUSY(baseIoAddress1, statusByte);

	//
	// Check for erroneous IDE status.
	//
	if (((statusByte & IDE_STATUS_BUSY)) || 
        (!(statusByte & IDE_STATUS_DRDY)))
    {
        // Drive is not Ready.
		return FALSE;
	}
   
    if (pPhysicalCommand->ucCmd == SCSIOP_EXECUTE_SMART_COMMAND)
    {
        ScsiPortWritePortUchar(((PUCHAR)baseIoAddress1 + 1), DeviceExtension->uchSMARTCommand);
	    ScsiPortWritePortUchar(&baseIoAddress1->CylinderLow, 0x4F);
	    ScsiPortWritePortUchar(&baseIoAddress1->CylinderHigh, 0xC2);
    }
    else
    {
    ScsiPortWritePortUchar(&baseIoAddress1->SectorCount, sectors);
	ScsiPortWritePortUchar(&baseIoAddress1->SectorNumber, sectorNumber);
	ScsiPortWritePortUchar(&baseIoAddress1->CylinderLow, cylinderLow);
	ScsiPortWritePortUchar(&baseIoAddress1->CylinderHigh, cylinderHigh);
    }

#ifdef DBG

	if (DeviceExtension->DeviceFlags[targetId] & DFLAGS_LBA) 
    {

		DebugPrint((
				1,
				"SetDriveRegisters: TID %d, Start sector %lxh, Sectors %xh\n",
				targetId,
				startSector,
				sectors
				));

	} 
    else 
    {

		DebugPrint((
				1,
				"SetDriveRegisters: TID %d, Cylinder %xh, Head %xh, Sector %xh\n",
				targetId,
				cylinderLow + (cylinderHigh << 8),
				headNumber,
				sectorNumber
				));
	}

#endif // ifdef DBG

	return TRUE;

} // end SetDriveRegisters()


BOOLEAN
GetIoMode(
	IN PHW_DEVICE_EXTENSION DeviceExtension,
	IN UCHAR TargetId
)

{
	PIDENTIFY_DATA capabilities;
	ULONG sectors, length;
	BOOLEAN success = TRUE;
    IDE_PCI_REGISTERS pciRegisters;
    char *pcPciRegisters = (PUCHAR)&pciRegisters;

	capabilities = &(DeviceExtension->FullIdentifyData[TargetId]);
	
	// Calculate the total number of addressable sectors using CHS convention.
	sectors = capabilities->NumberOfCylinders * capabilities->NumberOfHeads *
			  capabilities->SectorsPerTrack;

	if (capabilities->TranslationFieldsValid & IDENTIFY_FAST_TRANSFERS_SUPPORTED) 
    {

#ifdef DBG
		PrintCapabilities(capabilities, TargetId);
#endif
		

		if ((capabilities->Capabilities & IDENTIFY_CAPABILITIES_LBA_SUPPORTED)) 
        {
			DeviceExtension->DeviceFlags[TargetId] |= DFLAGS_LBA;

			// Get the total number of LBA-mode addressable sectors.
			sectors = capabilities->UserAddressableSectors;

        	DebugPrint((2, "GetIoMode:  TID %d supports LBA\n", TargetId));
		}
    }

	DeviceExtension->PhysicalDrive[TargetId].Sectors = sectors;


	DeviceExtension->PhysicalDrive[TargetId].OriginalSectors = sectors;

    GetTransferMode(DeviceExtension,TargetId);

	return(success);
}
BOOLEAN
TargetAccessible(
	IN PHW_DEVICE_EXTENSION DeviceExtension,
	IN PSCSI_REQUEST_BLOCK Srb

)

{
	if (
		Srb->PathId == 0 &&
		Srb->Lun == 0 &&
		(DeviceExtension->IsLogicalDrive[Srb->TargetId] ||
		DeviceExtension->IsSingleDrive[Srb->TargetId])
		)
    {
        return TRUE;
    }

    return FALSE;
} // end TargetAccessible()

void SynchronizeIRCD(
	IN PSCSI_REQUEST_BLOCK Srb
    )
{

    PIRCD_DATA pIrcdData = (PIRCD_DATA) (((PSRB_BUFFER)(Srb->DataBuffer))->caDataBuffer);
    PIRCD_HEADER pRaidHeader = (PIRCD_HEADER)(pIrcdData->caIRCDDataBuff);
    PIRCD_LOGICAL_DRIVE pRaidLogDrive = (PIRCD_LOGICAL_DRIVE)(GET_FIRST_LOGICAL_DRIVE(pRaidHeader));
    BOOLEAN bFound = FALSE;
    ULONG ulLogDrvInd, ulDrvInd;
    PIRCD_PHYSICAL_DRIVE pPhyDrive;
    UCHAR ucLocalLogDrvId;
    UCHAR ucLocalPhyDrvId;
    PHW_DEVICE_EXTENSION pDE;

    for(ulLogDrvInd=0;ulLogDrvInd<pRaidHeader->NumberOfLogicalDrives;ulLogDrvInd++)
    {
        pPhyDrive = (PIRCD_PHYSICAL_DRIVE)((char *)pRaidHeader + pRaidLogDrive[ulLogDrvInd].FirstStripeOffset);

        if ( !FoundValidDrive(pPhyDrive, pRaidLogDrive[ulLogDrvInd].NumberOfDrives) )
        {   // No valid Drive in this logical drive.. so let us not worry about this drive
            continue;
        }

        for(ulDrvInd=0;ulDrvInd<pRaidLogDrive[ulLogDrvInd].NumberOfDrives;ulDrvInd++)
        {
            if ( INVALID_CONNECTION_ID == pPhyDrive[ulDrvInd].ConnectionId )
                continue;
            ucLocalPhyDrvId = GET_TARGET_ID(pPhyDrive[ulDrvInd].ConnectionId);
        }

        pDE = gaCardInfo[(ucLocalPhyDrvId>>2)].pDE;

        if ( SpareDrivePool != pRaidLogDrive[ulLogDrvInd].LogicalDriveType )    // There is nothing like status for a Spare Drive Pool
        {
            ucLocalLogDrvId = pDE->PhysicalDrive[TARGET_ID_WITHOUT_CONTROLLER_ID(ucLocalPhyDrvId)].ucLogDrvId;
            if ( ucLocalLogDrvId < MAX_DRIVES_PER_CONTROLLER )   // Just a sanity check ... In case something goes wrong
                pRaidLogDrive[ulLogDrvInd].LogDrvStatus = (UCHAR)pDE->LogicalDrive[ucLocalLogDrvId].Status;
        }

        for(ulDrvInd=0;ulDrvInd<pRaidLogDrive[ulLogDrvInd].NumberOfDrives;ulDrvInd++)
        {   // let us change status of all the Physical Drives IN THIS LOGICAL DRIVE
            if ( INVALID_CONNECTION_ID == pPhyDrive[ulDrvInd].ConnectionId )    // no drive present at this place
                continue;
            ucLocalPhyDrvId = TARGET_ID_WITHOUT_CONTROLLER_ID((GET_TARGET_ID(pPhyDrive[ulDrvInd].ConnectionId)));
            pPhyDrive[ulDrvInd].PhyDrvStatus = (UCHAR)pDE->PhysicalDrive[ucLocalPhyDrvId].Status;
        }
    }
}

SRBSTATUS
DummySendRoutine(
	IN PHW_DEVICE_EXTENSION DeviceExtension,
	IN PSCSI_REQUEST_BLOCK Srb
)
{
    return SRB_STATUS_SELECTION_TIMEOUT;
}

SRBSTATUS
DummyPostRoutine(
	IN PHW_DEVICE_EXTENSION DeviceExtension,
	IN PPHYSICAL_COMMAND pPhysicalCommand
)
{
    return SRB_STATUS_SELECTION_TIMEOUT;
}


BOOLEAN PIOReadWriteSector(
				UCHAR					theCmd,	// IDE_COMMAND_READ or write
				PHW_DEVICE_EXTENSION	DeviceExtension, 
				LONG					lTargetId, 
				ULONG					ulSectorInd,
				PUCHAR					pSectorBuffer)
{
    ULONG ulSectors;
    ULONG ulChannel = lTargetId>>1;
	PIDE_REGISTERS_1 pBaseIoAddress1 = DeviceExtension->BaseIoAddress1[ulChannel];
    PIDE_REGISTERS_2 pBaseIoAddress2 = DeviceExtension->BaseIoAddress2[ulChannel];
    ULONG ulCount, ulSecCounter, ulValue;
    UCHAR ucStatus, ucTemp;
    ULONG ulSectorNumber, ulCylinderLow, ulCylinderHigh, ulHead;

    if (!IS_IDE_DRIVE(lTargetId))
        return FALSE;

    // End Vasudevan

    if ( !DeviceExtension->PhysicalDrive[lTargetId].OriginalSectors )
    {
        DebugPrint((0," IF 1 "));
        return FALSE;       // No drive there. So, nothing to read from.
    }


	SELECT_LBA_DEVICE(pBaseIoAddress1, lTargetId, ulSectorInd);

	ScsiPortStallExecution(1);  // we have to wait atleast 400 ns ( 1000 ns = 1 Micro Second ) to get the Busy Bit to set

    WAIT_ON_BUSY(pBaseIoAddress1, ucStatus);

    if ( ((ucStatus & IDE_STATUS_BUSY)) || (!(ucStatus & IDE_STATUS_DRDY)) )
    {
        DebugPrint((0,"\n\n\n\n\nAre Very B A D \n\n\n\n\n"));
    }

    ulSectorNumber = ulSectorInd & 0x000000ff;
    ulCylinderLow = (ulSectorInd & 0x0000ff00) >> 8;
    ulCylinderHigh = (ulSectorInd & 0xff0000) >> 16;

	ScsiPortWritePortUchar(&pBaseIoAddress1->SectorCount, 1);
	ScsiPortWritePortUchar(&pBaseIoAddress1->SectorNumber, (UCHAR)ulSectorNumber);
	ScsiPortWritePortUchar(&pBaseIoAddress1->CylinderLow,(UCHAR)ulCylinderLow);
	ScsiPortWritePortUchar(&pBaseIoAddress1->CylinderHigh,(UCHAR)ulCylinderHigh);
    ScsiPortWritePortUchar(&pBaseIoAddress1->Command, theCmd);

    WAIT_ON_BUSY(pBaseIoAddress1, ucStatus);

    WAIT_FOR_DRQ(pBaseIoAddress1, ucStatus);

	if (!(ucStatus & IDE_STATUS_DRQ)) 
    {
		DebugPrint((0,"\nHaaa.... I couldn't read/write the sector..............1\n"));
		return(FALSE);
	}

	//
	// Read status to acknowledge any interrupts generated.
	//

	GET_BASE_STATUS(pBaseIoAddress1, ucStatus);

	//
	// Check for error on really stupid master devices that assert random
	// patterns of bits in the status register at the slave address.
	//

	if (ucStatus & IDE_STATUS_ERROR) 
    {
		DebugPrint((0,"\nHaaa.... I couldn't read/write the sector..............2\n"));
		return(FALSE);
	}

	WAIT_ON_BUSY(pBaseIoAddress1,ucStatus);

	WAIT_ON_BUSY(pBaseIoAddress1,ucStatus);

	WAIT_ON_BUSY(pBaseIoAddress1,ucStatus);

	if ( (ucStatus & IDE_STATUS_DRQ) && (!(ucStatus & IDE_STATUS_BUSY)) )
    {
		if (theCmd == IDE_COMMAND_READ) 
        {
			READ_BUFFER(pBaseIoAddress1, (unsigned short *)pSectorBuffer, 256);
		}
		else 
        {
			if (theCmd == IDE_COMMAND_WRITE)
            {
                ULONG ulCounter;
				WRITE_BUFFER(pBaseIoAddress1, (unsigned short *)pSectorBuffer, 256);
                WAIT_FOR_DRQ(pBaseIoAddress1, ucStatus);
	            if (ucStatus & IDE_STATUS_DRQ) 
                {
		            DebugPrint((0,"\nHaaa.... I couldn't read/write the sector..............3\n"));
                    for(ulCounter=0;ulCounter<4;ulCounter++)
                    {
                        ScsiPortWritePortUchar((PUCHAR)&pBaseIoAddress1->Data, pSectorBuffer[ulCounter]);
                        ScsiPortStallExecution(1);  // we have to wait atleast 400 ns ( 1000 ns = 1 Micro Second ) to get the Busy Bit to set
                    }
	            }
            }
		}

	    //
	    // Read status. This will clear the interrupt.
	    //
    	GET_BASE_STATUS(pBaseIoAddress1, ucStatus);
        return TRUE;
    }
    else
    {
	    //
	    // Read status. This will clear the interrupt.
	    //

        GET_BASE_STATUS(pBaseIoAddress1, ucStatus);
        DebugPrint((0," IF 2 "));
        return FALSE;
    }
}

ULONG LockIRCD(
    IN PHW_DEVICE_EXTENSION DeviceExtension,
    IN BOOLEAN Lock,   
    IN ULONG UnlockKey)
/*
    Locks or Unlocks the Access to IRCD with the help of a variable.

    if Lock is aquired, then the return value will be a ULONG number which must be 
    returned again in the UnlockKey parameter for unlocking. If the given ULONG number
    does not match with what was returned before, then Unlock will fail.
*/
{
    LARGE_INTEGER liSysTime;
    PUCHAR puchCurrentTime = NULL;
    PUCHAR puchOldTime = NULL;

    AtapiFillMemory((PUCHAR)&liSysTime, sizeof(LARGE_INTEGER), 0);

    FillTimeStamp(&liSysTime);

    if (Lock)   // Lock Request
    {
        if (gcIRCDLocked)
        {

            puchCurrentTime = (UCHAR *) &(liSysTime.LowPart);
            puchOldTime = (UCHAR *) &((gIRCDLockTime).LowPart);

            if (puchCurrentTime[1] > puchOldTime[1])  // if the hours are changed
            {
                puchCurrentTime[2] += 60;
            }

            if (puchCurrentTime[2] == puchOldTime[2]) // if the two minutes are the same
            {
                // Locked by some other call and the TimeOut has not reached yet.!
                return 0;
            }

            if ( gbDoNotUnlockIRCD ) // No more changes to IRCD allowed... so donot try to unlock/unlock
                return 0;
        }

        gcIRCDLocked = TRUE;

        gIRCDLockTime.LowPart = liSysTime.LowPart;
        gIRCDLockTime.HighPart = liSysTime.HighPart;

        gulIRCDUnlockKey++;

        if ((LONG) gulIRCDUnlockKey <= 0)
            gulIRCDUnlockKey = 1;
    }
    else        // Unlock Request
    {
        if ( gbDoNotUnlockIRCD ) // No more changes to IRCD allowed... so donot try to unlock/unlock
            return 0;

        if (gulIRCDUnlockKey == UnlockKey)
        {
            gcIRCDLocked = FALSE;
            gIRCDLockTime.LowPart = 0;
            gIRCDLockTime.HighPart = 0;
            return 1;
        }
        else
            return 0;
    }
    
    return gulIRCDUnlockKey;
}

VOID
FillTimeStamp(
    IN OUT PLARGE_INTEGER pTimeStamp
)
{
    //
    // StampLowPart :  aa bb cc dd
    // StampHighPart : ee ff gg hh
    //
    // dd : Seconds
    // cc : Minutes
    // bb : Hours
    // aa : Day Of Week (Sunday = 0; Saturday = 6)
    //
    // hh : Date (0 to 31)
    // gg : Month (1 to 12)
    // ff : Year 
    // ee : Century
    //

    PUCHAR pTime = (PUCHAR) &(pTimeStamp->LowPart);
    PUCHAR pDate = (PUCHAR) &(pTimeStamp->HighPart);
    UCHAR uchData = 0;

    ScsiPortWritePortUchar((PUCHAR)0x70, 0x0A);
    uchData = ScsiPortReadPortUchar((PUCHAR)0x71);

    if (uchData & 0x80)
        return;

    ScsiPortWritePortUchar((PUCHAR)0x70, 0x00);
    pTime[3] = ScsiPortReadPortUchar((PUCHAR)0x71); // Seconds
    
    ScsiPortWritePortUchar((PUCHAR)0x70, 0x02);
    pTime[2] = ScsiPortReadPortUchar((PUCHAR)0x71); // Minutes

    ScsiPortWritePortUchar((PUCHAR)0x70, 0x04);
    pTime[1] = ScsiPortReadPortUchar((PUCHAR)0x71); // Hours

    ScsiPortWritePortUchar((PUCHAR)0x70, 0x06);
    pTime[0] = ScsiPortReadPortUchar((PUCHAR)0x71); // Day Of Week

    ScsiPortWritePortUchar((PUCHAR)0x70, 0x07);
    pDate[3] = ScsiPortReadPortUchar((PUCHAR)0x71); // Date

    ScsiPortWritePortUchar((PUCHAR)0x70, 0x08);
    pDate[2] = ScsiPortReadPortUchar((PUCHAR)0x71); // Month

    ScsiPortWritePortUchar((PUCHAR)0x70, 0x09);
    pDate[1] = ScsiPortReadPortUchar((PUCHAR)0x71); // Year

    ScsiPortWritePortUchar((PUCHAR)0x70, 0x32);
    pDate[0] = ScsiPortReadPortUchar((PUCHAR)0x71); // Century

    return;
} // end FillTimeStamp

BOOLEAN
AssignSglPtrsForPhysicalCommands
    (
        IN PHW_DEVICE_EXTENSION DeviceExtension
    )
{

    PPHYSICAL_DRIVE pPhysicalDrive;
    ULONG ulDrvInd;
    PSGL_ENTRY sgl;
    LONG lengthInNextBoundary;
    LONG lengthLeftInBoundary;
	ULONG maxSglEntries;
    ULONG sglBasePhysicalAddress, length;
    ULONG ulStartAddress, ulEndAddress, ulStartPage, ulEndPage;
    ULONG ulLengthReduced = 0;
    
    pPhysicalDrive = &(DeviceExtension->PhysicalDrive[0]);

    for(ulDrvInd=0;ulDrvInd<MAX_DRIVES_PER_CONTROLLER;ulDrvInd++)
    {
		sgl = &(pPhysicalDrive[ulDrvInd].PhysicalCommand.sglEntry[0]);

    	//
    	// Get physical SGL address.
    	//
        sglBasePhysicalAddress = ScsiPortConvertPhysicalAddressToUlong(
        				ScsiPortGetPhysicalAddress(DeviceExtension, NULL, sgl, &length));


		ASSERT(sglBasePhysicalAddress != NULL);

		if (sglBasePhysicalAddress == 0) 
        {
			return(FALSE);
		}

        if (length >= (MAX_SGL_ENTRIES_PER_PHYSICAL_DRIVE * sizeof(SGL_ENTRY)))
        {
            length = MAX_SGL_ENTRIES_PER_PHYSICAL_DRIVE * sizeof(SGL_ENTRY);
        }

        ulStartAddress = (ULONG)sglBasePhysicalAddress;
        ulEndAddress = ulStartAddress + length;


		//
    	// Check to see if SGL Pointer is DWORD Aligned and make it so.
    	// Remember we allocated an extra SGL entry for this purpose.
		//

    	if ((ULONG)sglBasePhysicalAddress & 3) 
        {
        	sglBasePhysicalAddress = (((ULONG)sglBasePhysicalAddress & 0xfffffffcL) + 4L); 
            ulLengthReduced = sglBasePhysicalAddress - ulStartAddress;
            ulStartAddress = (ULONG)sglBasePhysicalAddress;
            length -= ulLengthReduced;
            sgl += ulLengthReduced;
		}

        ASSERT(length < (MAX_SGL_ENTRIES_PER_PHYSICAL_DRIVE / 2));

#ifdef DBG
        if (length < (MAX_SGL_ENTRIES_PER_PHYSICAL_DRIVE / 2))
        {
            STOP;
        }
#endif // DBG

        ulStartPage = (ULONG)( ulStartAddress / SGL_HW_BOUNDARY );
        ulEndPage = (ULONG)( ulEndAddress / SGL_HW_BOUNDARY );

        if ( ulStartPage == ulEndPage )
        {   // all entries are in the same page
			maxSglEntries =   (length / sizeof(SGL_ENTRY));
        }
        else
        {
		    //
    	    // Make sure the SGL does NOT cross a 4K boundary.
		    //
    	    lengthLeftInBoundary = SGL_HW_BOUNDARY - ((ULONG)sglBasePhysicalAddress & (SGL_HW_BOUNDARY - 1));

    	    lengthInNextBoundary = length - lengthLeftInBoundary;

    	    if (lengthInNextBoundary > lengthLeftInBoundary) 
            {
			    //
			    // SGL crosses 4KB boundary and top portion is larger than bottom.
			    // Use top portion.
			    //
                sglBasePhysicalAddress = sglBasePhysicalAddress + lengthLeftInBoundary;
        	    sgl = (PSGL_ENTRY) ((ULONG)sgl + lengthLeftInBoundary); 
			    maxSglEntries =  lengthInNextBoundary / sizeof(SGL_ENTRY);

		    } 
            else 
            {
			    maxSglEntries =  lengthLeftInBoundary / sizeof(SGL_ENTRY);
		    }
        }

        DebugPrint((0, "        SGL physical address = %lxh for %ld\n", sglBasePhysicalAddress, ulDrvInd));
		DebugPrint((0, "             Max SGL entries = %lxh for %ld\n", maxSglEntries, ulDrvInd));

		//
		// Save SGL info for next call.
		//
		pPhysicalDrive[ulDrvInd].PhysicalCommand.SglBaseVirtualAddress = (PSGL_ENTRY) sgl;
		pPhysicalDrive[ulDrvInd].PhysicalCommand.SglBasePhysicalAddress = sglBasePhysicalAddress;
		pPhysicalDrive[ulDrvInd].PhysicalCommand.MaxSglEntries = maxSglEntries;
    }
    return TRUE;
}

BOOLEAN
DisableInterrupts(
    IN PHW_DEVICE_EXTENSION DeviceExtension
    )
{
    ULONG ulController;
    PBM_REGISTERS         BMRegister = NULL;
    UCHAR opcimcr;

    BMRegister = DeviceExtension->BaseBmAddress[0];
    //
    // Enable the Interrupt notification so that further interrupts are got.
    // This is done because, there is no interrupt handler at the time
    // before the actual registration of the Int. handler..
    //
    opcimcr = ScsiPortReadPortUchar(((PUCHAR)BMRegister + 1));
    opcimcr |= 0x30;
    // Begin Vasu - 7 Feb 2001
    // Enable Read Multiple here as this is the place where we write this register back.
    opcimcr &= 0xF0; // Dont Clear Interrupt Pending Flags.
    opcimcr |= 0x01;
    // End Vasu
    ScsiPortWritePortUchar(((PUCHAR)BMRegister + 1), opcimcr);

    return TRUE;
}

BOOLEAN
EnableInterrupts(
    IN PHW_DEVICE_EXTENSION DeviceExtension
    )
{
    ULONG ulController;
    PBM_REGISTERS         BMRegister = NULL;
    UCHAR opcimcr;

    BMRegister = DeviceExtension->BaseBmAddress[0];
    //
    // Enable the Interrupt notification so that further interrupts are got.
    // This is done because, there is no interrupt handler at the time
    // before the actual registration of the Int. handler..
    //
    opcimcr = ScsiPortReadPortUchar(((PUCHAR)BMRegister + 1));
    opcimcr &= 0xCF;
    // Begin Vasu - 7 Feb 2001
    // Enable Read Multiple here as this is the place where we write this register back.
    opcimcr &= 0xF0; // Dont Clear Interrupt Pending Flags.
    opcimcr |= 0x01;
    // End Vasu
    ScsiPortWritePortUchar(((PUCHAR)BMRegister + 1), opcimcr);

    return TRUE;
}

BOOLEAN
InitDriveFeatures(
    IN OUT PHW_DEVICE_EXTENSION DeviceExtension
    )
/*++

Routine Description:

    Initialize some features on drive (which are required at the initialization time)
    Right now we are enabling Cache implementation features... (this is to resolve the bug of 
    bad performance on some IBM Drives)

Arguments:

    DeviceExtension - HBA miniport driver's adapter data storage
Return Value:

    BOOLEAN
--*/
{
    PIDE_REGISTERS_1  baseIoAddress;
    UCHAR ucDrvInd;
    UCHAR statusByte;

    for(ucDrvInd=0;ucDrvInd<MAX_DRIVES_PER_CONTROLLER;ucDrvInd++)
    {
        if ( !IS_IDE_DRIVE(ucDrvInd) )
            continue;

        baseIoAddress = DeviceExtension->BaseIoAddress1[ucDrvInd >> 1];

        if ( DeviceExtension->bEnableRwCache ) 
        {

            SELECT_DEVICE(baseIoAddress, ucDrvInd);

            ScsiPortWritePortUchar((PUCHAR)baseIoAddress + 1, FEATURE_ENABLE_WRITE_CACHE);

            ScsiPortWritePortUchar(&(baseIoAddress->Command), IDE_COMMAND_SET_FEATURES);

            WAIT_ON_BASE_BUSY(baseIoAddress, statusByte);
        }
        else
        {
    	    SELECT_DEVICE(baseIoAddress, ucDrvInd);

		    ScsiPortWritePortUchar((PUCHAR)baseIoAddress + 1, FEATURE_DISABLE_WRITE_CACHE);

		    ScsiPortWritePortUchar(&(baseIoAddress->Command), IDE_COMMAND_SET_FEATURES);

		    WAIT_ON_BASE_BUSY(baseIoAddress, statusByte);
        }

        SELECT_DEVICE(baseIoAddress, ucDrvInd);

        ScsiPortWritePortUchar((PUCHAR)baseIoAddress + 1, FEATURE_ENABLE_READ_CACHE);

        ScsiPortWritePortUchar(&(baseIoAddress->Command), IDE_COMMAND_SET_FEATURES);

        WAIT_ON_BASE_BUSY(baseIoAddress, statusByte);

        SetMultiBlockXfers( DeviceExtension, ucDrvInd);
    }

    return TRUE;
}

BOOLEAN
SupportedController(
    IN PHW_DEVICE_EXTENSION DeviceExtension,
    USHORT VendorId,
    USHORT DeviceId
)

{
    BOOLEAN found;

    if (VendorId == 0x1095) 
    {
        switch (DeviceId)
        {
            case 0x648:
			    found = TRUE;
                break;
            case 0x649:
			    found = TRUE;
                break;
            default:
                found = FALSE;
                break;
        }
    }
    else
    {
	    // Assume failure.
	    found = FALSE;
    }

    return(found);

} // end SupportedController()

#define PCI_MAX_BUS	0xFF

BOOLEAN ScanPCIBusForHyperDiskControllers(
    IN PHW_DEVICE_EXTENSION DeviceExtension
    )
{
	PCI_SLOT_NUMBER slot;
    UCHAR   pciBus, pciDevice, pciFunction;
    ULONG ulLength, ulPCICode;

    if ( gbFinishedScanning )
        return TRUE;

	slot.u.AsULONG = 0;

    gbFinishedScanning = TRUE;

    for(pciBus = 0;pciBus < PCI_MAX_BUS;pciBus++)
    {
	    //
	    // Look at each device.
	    //
	    for (pciDevice = 0; pciDevice < PCI_MAX_DEVICES; pciDevice++) 
        {
            slot.u.bits.DeviceNumber = pciDevice;

            //
            // Look at each function.
            //
            for (pciFunction = 0; pciFunction < PCI_MAX_FUNCTION; pciFunction++) 
            {
	            slot.u.bits.FunctionNumber = pciFunction;

                ulPCICode = 0x80000000 | (pciFunction<<0x8) | (pciDevice<<0xb) | (pciBus<<0x10);

                _asm 
                {
                    push eax
                    push edx
                    push ebx

                    mov edx, 0cf8h
                    mov eax, ulPCICode
                    out dx, eax

                    add dx, 4
                    in eax, dx

                    mov ulPCICode, eax

                    pop ebx
                    pop edx
                    pop eax
                }

	            if ( PCI_INVALID_VENDORID == (ulPCICode & 0xffff) ) 
                {
		            //
		            // No PCI device, or no more functions on device.
		            // Move to next PCI device.
		            //
		            continue;
	            }

			    //
			    // Find out if the controller is supported.
			    //

			    if (!SupportedController(
                                        DeviceExtension,
                                        (USHORT)(ulPCICode & 0xffff),
                                        (USHORT)(ulPCICode >> 0x10)
                                        )
				    ) 
                {

				    //
				    // Not our PCI device. Try next device/function
				    //

				    continue;
			    }

                if ( !ShouldThisCardBeHandledByUs(pciBus, pciDevice, pciFunction) )
                {
                    continue;       // looks like it is should not be handled by us
                }

                // Let us store the info in the array
                gaCardInfo[gucControllerCount].ucPCIBus = pciBus;
                gaCardInfo[gucControllerCount].ucPCIDev = pciDevice;
                gaCardInfo[gucControllerCount].ucPCIFun = pciFunction;
                gaCardInfo[gucControllerCount].ulDeviceId = ulPCICode >> 0x10;
                gaCardInfo[gucControllerCount].ulVendorId = ulPCICode & 0xffff;
                gaCardInfo[gucControllerCount++].pDE = NULL;

                DebugPrint((0, "Found Card at %x:%x:%x\n", pciBus, pciDevice, pciFunction));

		    }	// next PCI function

        }	// next PCI device

    } // next PCI Bus

    return TRUE;
}


#define COMPAQ_VENDOR_ID        0x0e11
#define COMPAQ_DEVICE_ID        0x005d
    

BOOLEAN ShouldThisCardBeHandledByUs(UCHAR pciBus, UCHAR pciDevice, UCHAR pciFunction)
{
    ULONG ulSubSysId, ulPCICode;
    USHORT usSubVenId, usSubDevId;

    ulPCICode = 0x80000000 | (pciFunction<<0x8) | (pciDevice<<0xb) | (pciBus<<0x10) | 0x8c; // SubSysId Offset

    _asm 
    {
        push eax
        push edx
        push ebx

        mov edx, 0cf8h
        mov eax, ulPCICode
        out dx, eax

        add dx, 4
        in eax, dx

        mov ulSubSysId, eax

        pop ebx
        pop edx
        pop eax
    }


    usSubVenId = (USHORT)(ulSubSysId & 0xffff);
    usSubDevId = (USHORT)(ulSubSysId >> 16);

    if ( COMPAQ_VENDOR_ID  == usSubVenId  )
    {
        if ( COMPAQ_DEVICE_ID == usSubDevId  )
        {
            return TRUE;
        }
        else
        {
            return FALSE;
        }
    }
    else
    {   // if it is a NON COMPAQ card we will boot by default
        return TRUE;
    }
}

#ifdef HYPERDISK_WINNT
BOOLEAN 
AssignDeviceInfo(
	IN OUT PPORT_CONFIGURATION_INFORMATION ConfigInfo
    )
{
	PCI_SLOT_NUMBER PCISlot;

    if ( gucNextControllerInd >= gucControllerCount )
        return FALSE;


    PCISlot.u.AsULONG = 0;

    ConfigInfo->SystemIoBusNumber = gaCardInfo[gucNextControllerInd].ucPCIBus;
    PCISlot.u.bits.DeviceNumber = gaCardInfo[gucNextControllerInd].ucPCIDev;
    PCISlot.u.bits.FunctionNumber = gaCardInfo[gucNextControllerInd].ucPCIFun;

    ConfigInfo->SlotNumber = PCISlot.u.AsULONG;

    gucNextControllerInd++;
    return TRUE;
}

#endif

#include "Init.c"
#include "IOCTL.C"
#include "StartIO.C"
#include "ISR.C"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\port\scsi\miniport\megaide\hyperdisk.h ===
/*********************************************************

  HyperDisk.h

  Main Header File for HyperDisk

*********************************************************/

#ifndef _HYPERDISK_H_
#define _HYPERDISK_H_

#ifndef HYPERDISK_WIN98
#include "scsi.h"
#else   // HYPERDISK_WIN98
#include "Scsi9x.h"
#endif  // HYPERDISK_WIN98

#include "stdio.h"
#include "string.h"

#include "raid.h"

//
// Quick way to break into the debugger while keeping
// the local context active.
//
#ifdef DBG
#define STOP	_asm {int 3}
#else
#define STOP
#endif

// Interrupt Status Bits to be read from either 71h of PCI Config Space 
// or In (BM Base Register + 1) for Primary Channel 
#define PRIMARY_CHANNEL_INTERRUPT       0x04
#define SECONDARY_CHANNEL_INTERRUPT     0x08

#define ANY_CHANNEL_INTERRUPT           (PRIMARY_CHANNEL_INTERRUPT | SECONDARY_CHANNEL_INTERRUPT)


// Power on Reset Bits to be read from either 71h of PCI Config Space 
// or In (BM Base Register + 1) for Primary Channel
#define POWER_ON_RESET_FOR_PRIMARY_CHANNEL            0x40
#define POWER_ON_RESET_FOR_SECONDARY_CHANNEL          0x80

#define POWER_ON_RESET_FOR_BOTH_CHANNEL           (POWER_ON_RESET_FOR_PRIMARY_CHANNEL | POWER_ON_RESET_FOR_SECONDARY_CHANNEL)

#pragma pack(1)

typedef struct _PACKED_ACCESS_RANGE {

	SCSI_PHYSICAL_ADDRESS RangeStart;
	ULONG RangeLength;
	BOOLEAN RangeInMemory;

} PACKED_ACCESS_RANGE, *PPACKED_ACCESS_RANGE;

#pragma pack()

//
// IDE register definition
//
typedef struct _IDE_REGISTERS_1 {
    USHORT Data;
    UCHAR SectorCount;
    UCHAR SectorNumber;
    UCHAR CylinderLow;
    UCHAR CylinderHigh;
    UCHAR DriveSelect;
    UCHAR Command;
} IDE_REGISTERS_1, *PIDE_REGISTERS_1;

typedef struct _IDE_REGISTERS_2 {
    UCHAR ucReserved1;
    UCHAR ucReserved2;
    UCHAR AlternateStatus;  // This will itself behave as "DriveAddress" when it is used as out port
    UCHAR ucReserved3;
} IDE_REGISTERS_2, *PIDE_REGISTERS_2;

typedef struct _IDE_REGISTERS_3 {
    ULONG Data;
    UCHAR Others[4];
} IDE_REGISTERS_3, *PIDE_REGISTERS_3;

//
// ATAPI register definition
//

typedef struct _ATAPI_REGISTERS_1 {
    USHORT Data;
    UCHAR InterruptReason;
    UCHAR Unused1;
    UCHAR ByteCountLow;
    UCHAR ByteCountHigh;
    UCHAR DriveSelect;
    UCHAR Command;
} ATAPI_REGISTERS_1, *PATAPI_REGISTERS_1;

typedef struct _ATAPI_REGISTERS_2 {
    UCHAR AlternateStatus;
    UCHAR DriveAddress;
} ATAPI_REGISTERS_2, *PATAPI_REGISTERS_2;

//
// Device selection constants used for programming the device/head register.
//
#define IDE_LBA_MODE		0xE0
#define IDE_CHS_MODE		0xA0

//
// Device Extension Device Flags
//
#define DFLAGS_DEVICE_PRESENT        (1 << 0)    // Indicates that some device is present.
#define DFLAGS_ATAPI_DEVICE          (1 << 1)    // Indicates whether Atapi commands can be used.
#define DFLAGS_TAPE_DEVICE           (1 << 2)    // Indicates whether this is a tape device.
#define DFLAGS_INT_DRQ               (1 << 3)    // Indicates whether device interrupts as DRQ
												 // is set after receiving Atapi Packet Command.
#define DFLAGS_REMOVABLE_DRIVE       (1 << 4)    // Indicates that the drive has the 'removable'
												 // bit set in identify data (offset 128).
#define DFLAGS_MEDIA_STATUS_ENABLED  (1 << 5)    // Media status notification enabled

#define DFLAGS_USE_DMA               (1 << 9)    // Indicates whether device can use DMA
#define DFLAGS_LBA                   (1 << 10)   // support LBA addressing
#define DFLAGS_MULTI_LUN_INITED      (1 << 11)   // Indicates that the init path for multi-lun
												 // has already been done.
#define DFLAGS_MSN_SUPPORT           (1 << 12)   // Device support media status notification
#define DFLAGS_AUTO_EJECT_ZIP        (1 << 13)   // bootup default enables auto eject
#define DFLAGS_WD_MODE               (1 << 14)   // Indicates that unit is WD-Mode(not SFF-Mode).
#define DFLAGS_LS120_FORMAT          (1 << 15)   // Indicates that unit uses
												 // ATAPI_LS120_FORMAT_UNIT to format.
#define DFLAGS_USE_UDMA              (1 << 16)   // Indicates whether device can use UDMA

#define DFLAGS_ATAPI_CHANGER         (1 << 29)	 // Indicates atapi 2.5 changer present.
#define DFLAGS_SANYO_ATAPI_CHANGER   (1 << 30)   // Indicates multi-platter device, not
												 // conforming to the 2.5 spec.
#define DFLAGS_CHANGER_INITED        (1 << 31)   // Indicates that the init path for changers has
												 // already been done.

#define DFLAGS_USES_EITHER_DMA      0x10200

//
// Types of interrupts expected.
//
#define IDE_SEEK_INTERRUPT	(1 << 0)
#define IDE_PIO_INTERRUPT	(1 << 1)
#define IDE_DMA_INTERRUPT	(1 << 2)
#define ANY_DMA_INTERRUPT   (IDE_DMA_INTERRUPT)

//
// Used to disable 'advanced' features.
//
#define MAX_ERRORS                     4


//
// Types of DMA operation.
//
#define READ_OPERATION	0
#define WRITE_OPERATION	1

//
// DMA transfer control.
//
#define READ_TRANSFER		    0x08
#define WRITE_TRANSFER	        0x00
#define STOP_TRANSFER			0x00
#define START_TRANSFER          0x01

//
// ATAPI command definitions
//
#define ATAPI_MODE_SENSE   0x5A
#define ATAPI_MODE_SELECT  0x55
#define ATAPI_FORMAT_UNIT  0x24

//
// IDE controller speed definition.
//

typedef enum {

	Udma33,
	Udma66,
    Udma100

} CONTROLLER_SPEED, *PCONTROLLER_SPEED;


//
// IDE command definitions
//
#define IDE_COMMAND_ATAPI_RESET             0x08
#define IDE_COMMAND_RECALIBRATE             0x10
#define IDE_COMMAND_READ                    0x20
#define IDE_COMMAND_WRITE                   0x30
#define IDE_COMMAND_VERIFY                  0x40
#define IDE_COMMAND_SEEK                    0x70
#define IDE_COMMAND_SET_DRIVE_PARAMETERS    0x91
#define IDE_COMMAND_ATAPI_PACKET            0xA0
#define IDE_COMMAND_ATAPI_IDENTIFY          0xA1
// Begin Vasu - SMART Command
#define IDE_COMMAND_EXECUTE_SMART           0xB0
// End Vasu
#define IDE_COMMAND_READ_MULTIPLE           0xC4
#define IDE_COMMAND_WRITE_MULTIPLE          0xC5
#define IDE_COMMAND_SET_MULTIPLE            0xC6
#define IDE_COMMAND_READ_DMA                0xC8
#define IDE_COMMAND_WRITE_DMA               0xCA
#define IDE_COMMAND_GET_MEDIA_STATUS        0xDA
#define IDE_COMMAND_ENABLE_MEDIA_STATUS     0xEF
#define IDE_COMMAND_IDENTIFY                0xEC
#define IDE_COMMAND_MEDIA_EJECT             0xED
#define IDE_COMMAND_SET_FEATURES	        0xEF
#define IDE_COMMAND_FLUSH_CACHE             0xE7

#ifdef HYPERDISK_WIN2K
#define IDE_COMMAND_STANDBY_IMMEDIATE       0xE0
#endif // HYPERDISK_WIN2K

//
// Set Features register definitions.
//
#define FEATURE_ENABLE_WRITE_CACHE			0x02
#define FEATURE_SET_TRANSFER_MODE			0x03
#define FEATURE_KEEP_CONFIGURATION_ON_RESET	0x66
#define FEATURE_ENABLE_READ_CACHE			0xAA
#define FEATURE_DISABLE_WRITE_CACHE			0x82
#define FEATURE_DISABLE_READ_CACHE			0x55

// Power Management Stuff
#ifdef HYPERDISK_WIN2K
#define FEATURE_ENABLE_POWER_UP_IN_STANDBY      0x06
#define FEATURE_SPIN_AFTER_POWER_UP             0x07
#define POWER_MANAGEMENT_SUPPORTED              0x08    // Bit 3 of 82nd Word of Identify Data
#define POWER_UP_IN_STANDBY_FEATURE_SUPPORTED   0x20    // Bit 5 of 83rd Word of Identify Dataa
#define SET_FEATURES_REQUIRED_FOR_SPIN_UP       0x40    // Bit 6 of 83rd Word of Identify Dataa
#endif // HYPERDISK_WIN2K

//
// Set Features/Set Transfer Mode subcommand definitions.
//
#define STM_PIO(mode)				((UCHAR) ((1 << 3) | (mode)))
#define STM_MULTIWORD_DMA(mode)		((UCHAR) ((1 << 5) | (mode)))
#define STM_UDMA(mode)				((UCHAR) ((1 << 6) | (mode)))

//
// IDE status definitions
//
#define IDE_STATUS_ERROR             0x01
#define IDE_STATUS_INDEX             0x02
#define IDE_STATUS_CORRECTED_ERROR   0x04
#define IDE_STATUS_DRQ               0x08
#define IDE_STATUS_DSC               0x10
#define IDE_STATUS_DRDY              0x40
#define IDE_STATUS_IDLE              0x50
#define IDE_STATUS_BUSY              0x80

//
// IDE drive select/head definitions
//
#define IDE_DRIVE_SELECT_1           0xA0
#define IDE_DRIVE_SELECT_2           0x10

//
// IDE drive control definitions
//
#define IDE_DC_DISABLE_INTERRUPTS    0x02
#define IDE_DC_RESET_CONTROLLER      0x04
#define IDE_DC_REENABLE_CONTROLLER   0x00

//
// IDE error definitions
//
#define IDE_ERROR_BAD_BLOCK          0x80
#define IDE_ERROR_DATA_ERROR         0x40
#define IDE_ERROR_MEDIA_CHANGE       0x20
#define IDE_ERROR_ID_NOT_FOUND       0x10
#define IDE_ERROR_MEDIA_CHANGE_REQ   0x08
#define IDE_ERROR_COMMAND_ABORTED    0x04
#define IDE_ERROR_END_OF_MEDIA       0x02
#define IDE_ERROR_ILLEGAL_LENGTH     0x01

//
// IDENTIFY data.
//

#pragma pack (1)
typedef struct _IDENTIFY_DATA {
    USHORT GeneralConfiguration;            // 00 00
    USHORT NumberOfCylinders;               // 02  1
    USHORT Reserved1;                       // 04  2
    USHORT NumberOfHeads;                   // 06  3
    USHORT UnformattedBytesPerTrack;        // 08  4
    USHORT UnformattedBytesPerSector;       // 0A  5
    USHORT SectorsPerTrack;                 // 0C  6
    USHORT VendorUnique1[3];                // 0E  7-9
    UCHAR  SerialNumber[20];                // 14  10-19
    USHORT BufferType;                      // 28  20
    USHORT BufferSectorSize;                // 2A  21
    USHORT NumberOfEccBytes;                // 2C  22
    UCHAR  FirmwareRevision[8];             // 2E  23-26
    UCHAR  ModelNumber[40];                 // 36  27-46
    UCHAR  MaximumBlockTransfer;            // 5E  47
    UCHAR  VendorUnique2;                   // 5F
    USHORT DoubleWordIo;                    // 60  48
    USHORT Capabilities;                    // 62  49
    USHORT Reserved2;                       // 64  50
    UCHAR  VendorUnique3;                   // 66  51
    UCHAR  PioCycleTimingMode;              // 67
    UCHAR  VendorUnique4;                   // 68  52
    UCHAR  DmaCycleTimingMode;              // 69
    USHORT TranslationFieldsValid:3;        // 6A  53
    USHORT Reserved3:13;
    USHORT NumberOfCurrentCylinders;        // 6C  54
    USHORT NumberOfCurrentHeads;            // 6E  55
    USHORT CurrentSectorsPerTrack;          // 70  56
    ULONG  CurrentSectorCapacity;           // 72  57-58
    USHORT CurrentMultiSectorSetting;       //     59
    ULONG  UserAddressableSectors;          //     60-61
    USHORT SingleWordDmaSupport : 8;        //     62
    USHORT SingleWordDmaActive : 8;
    USHORT MultiWordDmaSupport : 8;         //     63
    USHORT MultiWordDmaActive : 8;
    USHORT AdvancedPioModes : 8;            //     64
    USHORT Reserved4 : 8;
    USHORT MinimumMwXferCycleTime;          //     65
    USHORT RecommendedMwXferCycleTime;      //     66
    USHORT MinimumPioCycleTime;             //     67
    USHORT MinimumPioCycleTimeIordy;        //     68
    USHORT Reserved5[11];                   //     69-79
    USHORT MajorRevision;                   //     80
    USHORT MinorRevision;                   //     81

    USHORT CmdSupported1;                   //     82
    USHORT CmdSupported2;                   //     83
    USHORT FtrSupported;                    //     84

    USHORT CmdEnabled1;                     //     85
    USHORT CmdEnabled2;                     //     86
    USHORT FtrEnabled;                      //     87


    USHORT UltraDmaSupport : 8;             //     88
    USHORT UltraDmaActive  : 8;             //
    USHORT Reserved7[37];                   //     89-125
    USHORT LastLun:3;                       //     126
    USHORT Reserved8:13;
    USHORT MediaStatusNotification:2;       //     127
    USHORT Reserved9:6;
    USHORT DeviceWriteProtect:1;
    USHORT Reserved10:7;
    USHORT Reserved11[128];                  //     128-255
} IDENTIFY_DATA, *PIDENTIFY_DATA;


//
// Identify data without the Reserved4.
//

typedef struct _IDENTIFY_DATA2 {
    USHORT GeneralConfiguration;            // 00
    USHORT NumberOfCylinders;               // 02
    USHORT Reserved1;                       // 04
    USHORT NumberOfHeads;                   // 06
    USHORT UnformattedBytesPerTrack;        // 08
    USHORT UnformattedBytesPerSector;       // 0A
    USHORT SectorsPerTrack;                 // 0C
    USHORT VendorUnique1[3];                // 0E
    USHORT SerialNumber[10];                // 14
    USHORT BufferType;                      // 28
    USHORT BufferSectorSize;                // 2A
    USHORT NumberOfEccBytes;                // 2C
    USHORT FirmwareRevision[4];             // 2E
    USHORT ModelNumber[20];                 // 36
    UCHAR  MaximumBlockTransfer;            // 5E
    UCHAR  VendorUnique2;                   // 5F
    USHORT DoubleWordIo;                    // 60
    USHORT Capabilities;                    // 62
    USHORT Reserved2;                       // 64
    UCHAR  VendorUnique3;                   // 66
    UCHAR  PioCycleTimingMode;              // 67
    UCHAR  VendorUnique4;                   // 68
    UCHAR  DmaCycleTimingMode;              // 69
    USHORT TranslationFieldsValid:1;        // 6A
    USHORT Reserved3:15;
    USHORT NumberOfCurrentCylinders;        // 6C
    USHORT NumberOfCurrentHeads;            // 6E
    USHORT CurrentSectorsPerTrack;          // 70
    ULONG  CurrentSectorCapacity;           // 72
} IDENTIFY_DATA2, *PIDENTIFY_DATA2;

#pragma pack()

#define IDENTIFY_DATA_SIZE sizeof(IDENTIFY_DATA)

//
// Value of bit 1 of TranslationFieldsValid in the IDENTIFY_DATA structure.
//

#define IDENTIFY_FAST_TRANSFERS_SUPPORTED	2	// PIO mode 3+ or DMA modes supported.

//
// IDENTIFY capability bit definitions.
//

#define IDENTIFY_CAPABILITIES_DMA_SUPPORTED 0x0100
#define IDENTIFY_CAPABILITIES_LBA_SUPPORTED 0x0200

//
// I/O Timing table values for Intel PIIX4.
//
// Legend:
//	ISP: IORDY Sample Point
//	RCT: Recovery Time
//	IDETIM: Master IDE Timing
//	SIDETIM: Slave IDE Timing
//

#define IO_TIMING_TABLE_VALUES  {\
\
	/* Cycle								Cycle					*/ \
	/* Time		PIO MODE	DMA MODE		Time	ISP		RCT		*/ \
\
	/* 900ns	PIO_MODE0,	N/A       */	{900,	0,		0},\
	/* ********************************/	{900,	0,		0},\
	/* 240ns	PIO_MODE2,	DMA_MODE0 */	{240,	1,		0},\
	/* 180ns	PIO_MODE3,	DMA_MODE1 */	{180,	2,		1},\
	/* 120ns	PIO_MODE4,	DMA_MODE2 */	{120,	2,		3}\
}

//
// UDMA Timing values for Intel PIIX4.
// To be programmed in the UDMA Timing Register.
//
#define UDMA_MODE0_TIMING	0
#define UDMA_MODE1_TIMING	1
#define UDMA_MODE2_TIMING	2
#define UDMA_MODE3_TIMING	3
#define UDMA_MODE4_TIMING	4

//
// DMA modes to be used as index into the IO_TIMING_TABLE.
//
#define DMA_MODE0	2
#define DMA_MODE1	3
#define DMA_MODE2	4
#define DMA_MODE3	4       // Not sure what to fill with
#define DMA_MODE4	4       // Not sure what to fill with

//
// Advanced PIO modes to be used as index into the IO_TIMING_TABLE.
//
#define PIO_MODE0	0
#define PIO_MODE2	2
#define PIO_MODE3	3
#define PIO_MODE4	4

//
// PIO_MODE0 timing.
//
#define PIO_MODE0_TIMING	900

//
// IDENTIFY Advanced PIO Modes.
//
#define IDENTIFY_PIO_MODE3		(1 << 0)
#define IDENTIFY_PIO_MODE4		(1 << 1)

//
// IDENTIFY Multi-word DMA modes.
//
#define IDENTIFY_DMA_MODE0		(1 << 0)
#define IDENTIFY_DMA_MODE1		(1 << 1)
#define IDENTIFY_DMA_MODE2		(1 << 2)
#define IDENTIFY_DMA_MODE3		(1 << 3)
#define IDENTIFY_DMA_MODE4		(1 << 4)


//
// IDENTIFY UDMA modes.
//
#define IDENTIFY_UDMA_MODE0		(1 << 0)
#define IDENTIFY_UDMA_MODE1		(1 << 1)
#define IDENTIFY_UDMA_MODE2		(1 << 2)
#define IDENTIFY_UDMA_MODE3		(1 << 3)
#define IDENTIFY_UDMA_MODE4		(1 << 4)


//
// IDENTIFY DMA timing cycle modes.
//
#define IDENTIFY_DMA_MODE0_TIMING 0x00
#define IDENTIFY_DMA_MODE1_TIMING 0x01
#define IDENTIFY_DMA_MODE2_TIMING 0x02
#define IDENTIFY_DMA_MODE3_TIMING 0x03
#define IDENTIFY_DMA_MODE4_TIMING 0x04

//
// I/O Timing table entry for PIIX4. Works for PIO and DMA modes.
//
typedef struct _IO_TIMING_TABLE_ENTRY {

	USHORT CycleTime;
	UCHAR Isp;	// IORDY Sample Point.
	UCHAR Rct;	// Recovery Time.

} IO_TIMING_TABLE_ENTRY, *PIO_TIMING_TABLE_ENTRY;


//
// PIIX4 IDETIM - IDE Timing Register.
//
// PCI Configuration Space offset: 40-41h (Primary Channel), 42-42h (Secondar Channely)
// Default value: 0000h
// Attribute: R/W only
//
typedef union _IDE_PCI_TIMING_REGISTER {

	struct {

		USHORT FastTimingEnableDrive0:1;		// 0 = disabled (compatible timing-slowest).
												// 1 = enabled.
	
		USHORT IordySamplePointEnableDrive0:1;	// 0 = IORDY sampling disabled.
												// 1 = IORDY sampling enabled.
	
		USHORT PrefetchAndPostingEnableDrive0:1;	// 0 = disabled.
													// 1 = enabled.
	
		USHORT DmaOnlyTimingEnableDrive0:1;		// 0 = both DMA and PIO use fast timing mode.
												// 1 = DMA uses fast timing, PIO uses
												//		compatible timing.
	
		USHORT FastTimingEnableDrive1:1;		// 0 = disabled (compatible timing-slowest).
												// 1 = enabled.
	
		USHORT IordySamplePointEnableDrive1:1;	// 0 = IORDY sampling disabled.
												// 1 = IORDY sampling enabled.
	
		USHORT PrefetchAndPostingEnableDrive1:1;// 0 = disabled.
												// 1 = enabled.
	
		USHORT DmaOnlyTimingEnableDrive1:1;		// 0 = both DMA and PIO use fast timing mode.
												// 1 = DMA uses fast timing, PIO uses
												//		compatible timing.
	
		USHORT RecoveryTime:2;					// RTC - Selects the minimum number of PCI clocks
												// between the last IORDY# sample point and the
												// DIOx# strobe of the next cycle.
												//
												// Bits[1:0]	Number of Clocks
												// -----------------------------
												// 		00			4
												// 		01			3
												// 		10			2
												// 		11			1
	
		USHORT Reserved:2;
	
		USHORT IordySamplePoint:2;				// ISP - Selects the number of PCI clocks
												// between the last DIOx# assertion and the first
												// IORDY sample point.
												//
												// Bits[1:0]	Number of Clocks
												// -----------------------------
												// 		00			5
												// 		01			4
												// 		10			3
												// 		11			2
	
		USHORT SlaveIdeTimingRegisterEnable:1;	// (SITRE)
												// 0 = disable SIDETIM.
												// 1 = enable SIDETIM.
	
		USHORT IdeDecodeEnable:1;				// (IDE)
												// 0 = disable (IDE accesses are decoded on ISA).
												// 1 = enable (IDE accesses are decoded on PCI).
	};

	USHORT AsUshort;

} IDE_PCI_TIMING_REGISTER, *PIDE_PCI_TIMING_REGISTER;


//
// PIIX4 SIDETIM - Slave IDE Timing Register.
//
// PCI Configuration Space offset: 44h
// Default value: 00h
// Attribute: R/W only
//
typedef union _IDE_PCI_SLAVE_TIMING_REGISTER {

	struct {

		UCHAR PrimaryDrive1RecoveryTime:2;		// PRTC1 - Selects the minimum number of PCI clocks
												// between the last PIORDY# sample point and the
												// PDIOx# strobe of the next cycle of the slave
												// drive on the primary channel.
												//
												// Bits[1:0]	Number of Clocks
												// -----------------------------
												// 		00			4
												// 		01			3
												// 		10			2
												// 		11			1
	
		UCHAR PrimaryDrive1IordySamplePoint:2;	// PISP1 - Selects the number of PCI clocks
												// between the PDIOx# assertion and the first
												// PIORDY sample point of the slave drive on
												// the primary channel.
												//
												// Bits[1:0]	Number of Clocks
												// -----------------------------
												// 		00			5
												// 		01			4
												// 		10			3
												// 		11			2
	
		UCHAR SecondaryDrive1RecoveryTime:2;	// SRTC1 - Selects the minimum number of PCI clocks
												// between the last SIORDY# sample point and the
												// SDIOx# strobe of the next cycle of the slave
												// drive on the secondary channel.
												//
												// Bits[1:0]	Number of Clocks
												// -----------------------------
												// 		00			4
												// 		01			3
												// 		10			2
												// 		11			1
	
		UCHAR SecondaryDrive1IordySamplePoint:2;// SISP1 - Selects the number of PCI clocks
												// between the SDIOx# assertion and the first
												// SIORDY sample point of the slave drive on
												// the secondary channel.
												//
												// Bits[1:0]	Number of Clocks
												// -----------------------------
												// 		00			5
												// 		01			4
												// 		10			3
												// 		11			2
	};

	UCHAR AsUchar;

} IDE_PCI_SLAVE_TIMING_REGISTER, *PIDE_PCI_SLAVE_TIMING_REGISTER;


//
// PIIX4 PCI Configuration Space - Command Register.
//

typedef union _IDE_PCI_COMMAND_REGISTER {

	struct {

	    USHORT IoSpaceEnable:1; 			// (r/w)
		USHORT Ignore:1;
		USHORT BusMasterFunctionEnable:1;	// (r/w) 0 = disable, 1 = enable.
		USHORT Ignore2:13;
	};

	USHORT AsUshort;

} IDE_PCI_COMMAND_REGISTER, *PIDE_PCI_COMMAND_REGISTER;

	
//
// PIIX4 UDMACTL - IDE Ultra DMA/33 Control Register.
//
// PCI Configuration Space offset: 48h
// Default value: 00h
// Attribute: R/W
//

typedef union _IDE_PCI_UDMA_CONTROL_REGISTER {

	struct {

		UCHAR PrimaryDrive0UdmaEnable:1;		// 0 = disable.
												// 1 = enable.
	
		UCHAR PrimaryDrive1UdmaEnable:1;		// 0 = disable.
												// 1 = enable.
	
		UCHAR SecondaryDrive0UdmaEnable:1;		// 0 = disable.
												// 1 = enable.
	
		UCHAR SecondaryDrive1UdmaEnable:1;		// 0 = disable.
												// 1 = enable.
	
		UCHAR Reserved:4;
	};

	UCHAR AsUchar;

} IDE_PCI_UDMA_CONTROL_REGISTER, *PIDE_PCI_UDMA_CONTROL_REGISTER;

//
// PIIX4 UDMACTL - IDE Ultra DMA/33 Timing Register.
//
// PCI Configuration Space offset: 4A-4Bh
// Default value: 0000h
// Attribute: R/W only
//

typedef union _IDE_PCI_UDMA_TIMING_REGISTER {

	struct {

		USHORT PrimaryDrive0CycleTime:2;		// PCT0 - Selects the minimum data write strobe
												// cycle time (CT) and minimum ready to pause (RP)
												// time (in PCI clocks).
												//
												// Bits[1:0]	Time
												// ------------------------------------
												//		00		CT=4, RP=6
												//		01		CT=3, RP=5
												//		10		CT=2, RP=4
												//		11		Reserved
	
		USHORT Reserved:2;
	
		USHORT PrimaryDrive1CycleTime:2;		// PCT1 - Selects the minimum data write strobe
												// cycle time (CT) and minimum ready to pause (RP)
												// time (in PCI clocks).
												//
												// Bits[1:0]	Time
												// ------------------------------------
												//		00		CT=4, RP=6
												//		01		CT=3, RP=5
												//		10		CT=2, RP=4
												//		11		Reserved
	
		USHORT Reserved2:2;
	
	
		USHORT SecondaryDrive0CycleTime:2;		// SCT0 - Selects the minimum data write strobe
												// cycle time (CT) and minimum ready to pause (RP)
												// time (in PCI clocks).
												//
												// Bits[1:0]	Time
												// ------------------------------------
												//		00		CT=4, RP=6
												//		01		CT=3, RP=5
												//		10		CT=2, RP=4
												//		11		Reserved
	
		USHORT Reserved3:2;
	
		USHORT SecondaryDrive1CycleTime:2;		// SCT1 - Selects the minimum data write strobe
												// cycle time (CT) and minimum ready to pause (RP)
												// time (in PCI clocks).
												//
												// Bits[1:0]	Time
												// ------------------------------------
												//		00		CT=4, RP=6
												//		01		CT=3, RP=5
												//		10		CT=2, RP=4
												//		11		Reserved
	
		USHORT Reserved4:2;
	};

	USHORT AsUshort;

} IDE_PCI_UDMA_TIMING_REGISTER, *PIDE_PCI_UDMA_TIMING_REGISTER;





//
// CAMINO chipset UDMACTL - IDE Ultra DMA/33/66 IDE_CONFIG
//
// PCI Configuration Space offset: 54-55
// Default value: 0000h
// Attribute: R/W only
//
typedef union _IDE_PCI_UDMA_CONFIG_REGISTER {

	struct {
        USHORT BaseClkPriMaster:1;      // 0 1=66MHz 0=33MHz
        USHORT BaseClkPriSlave:1;       // 1 1=66MHz 0=33MHz
        USHORT BaseClkSecMaster:1;      // 2 1=66MHz 0=33MHz
        USHORT BaseClkSecSlave:1;       // 3 1=66MHz 0=33MHz

        USHORT CableRepPriMaster:1;     // 4 1=80 conductors 0=40 conductors
        USHORT CableRepPriSlave:1;      // 5 1=80 conductors 0=40 conductors
        USHORT CableRepSecMaster:1;     // 6 1=80 conductors 0=40 conductors
        USHORT CableRepSecSlave:1;      // 7 1=80 conductors 0=40 conductors
        
		USHORT Reserved2:2;             // 9:8 Reserved
	
		USHORT WRPingPongEnabled:1;     // 10 th Bit 1 = Enables the write buffer to be used in a split(ping/pong) manner
                                        // 0 = Disabled. The buffer will behave similar to PIIX 4

		USHORT Reserved1:5;             // Reserved 15:11
	};

	USHORT AsUshort;

} IDE_PCI_UDMA_CONFIG_REGISTER, *PIDE_PCI_UDMA_CONFIG_REGISTER;



//
// PIIX4 PCI Configuration Registers.
//
typedef struct _IDE_PCI_REGISTERS {

    USHORT  VendorID;                   // (ro)
    USHORT  DeviceID;                   // (ro)
	IDE_PCI_COMMAND_REGISTER Command;	// (r/w) device control
    USHORT  Status;
    UCHAR   RevisionID;                 // (ro)
    UCHAR   ProgIf;                     // (ro)
    UCHAR   SubClass;                   // (ro)
    UCHAR   BaseClass;                  // (ro)
    UCHAR   CacheLineSize;              // (ro+)
    UCHAR   LatencyTimer;               // (ro+)
    UCHAR   HeaderType;                 // (ro)
    UCHAR   BIST;                       // Built in self test

    ULONG   BaseAddress1;
    ULONG   BaseAddress2;
    ULONG   BaseAddress3;
    ULONG   BaseAddress4;
	ULONG	BaseBmAddress;	// PIIX4-specific. Offset 20-23h.
    ULONG   BaseAddress6;
    ULONG   CIS;
    USHORT  SubVendorID;
    USHORT  SubSystemID;
    ULONG   ROMBaseAddress;
    ULONG   Reserved2[2];

    UCHAR   InterruptLine;      //
    UCHAR   InterruptPin;       // (ro)
    UCHAR   MinimumGrant;       // (ro)
    UCHAR   MaximumLatency;     // (ro)

	//
	// Offset 40h - Vendor-specific registers.
	//

	IDE_PCI_TIMING_REGISTER	PrimaryIdeTiming;		// 40-41h
	IDE_PCI_TIMING_REGISTER	SecondaryIdeTiming;		// 42-43h
	IDE_PCI_SLAVE_TIMING_REGISTER SlaveIdeTiming;	// 44h
	UCHAR Reserved3[3];
	IDE_PCI_UDMA_CONTROL_REGISTER UdmaControl;		// 48h
	UCHAR Reserved4;
	IDE_PCI_UDMA_TIMING_REGISTER UdmaTiming;		// 4A-4Bh

    ULONG   unknown1;                               // 4c-4f
    ULONG   unknown2;                               // 50-53
    IDE_PCI_UDMA_CONFIG_REGISTER UDMAConfig;        // 54-55    
    UCHAR Unknown[170]; // Was 180

} IDE_PCI_REGISTERS, *PIDE_PCI_REGISTERS;

//
// PIIX4 BMICX - Bus Master IDE Command Register.
//
// IDE Controller I/O Space offset: Primary Channel Base + 00h, Secondary Channel Base + 08h
// Default value: 00h
// Attribute: R/W
//
typedef union _BM_COMMAND_REGISTER {

	struct {

		UCHAR StartStopBm:1;					// SSMB
												// 0 = stop
												// 1 = start
												// Intended to be set to 0 after data transfer is
												// complete, as indicated by either bit 0 or bit 2
												// being set in the IDE Channel's Bus Master IDE
												// Status Register.
	
		UCHAR Reserved:2;
	
		UCHAR BmReadWriteControl:1;				// RWCON - Indicates the direction of a DMA
												//			transfer.
												// 0 = reads
												// 1 = writes
	
		UCHAR Reserved2:4;
	};

	UCHAR AsUchar;

} BM_COMMAND_REGISTER, *PBM_COMMAND_REGISTER;

//
// PIIX4 BMISX - Bus Master IDE Status Register.
//
// IDE Controller I/O Space offset: Primary Channel Base + 02h, Secondary Channel Base + 0Ah
// Default value: 00h
// Attribute: R/W Clear
//
typedef union _BM_STATUS_REGISTER {

	struct {

		UCHAR BmActive:1;			// BMIDEA - Read-Only
									// PIIX4 sets this bit to 1 when a BM operation is started
									// (when SSBM in BMICx is set to 1). PIIX4 sets this bit to 0
									// when the last transfer of a region is performed or when SSBM
									// is set to 0.
	
		UCHAR DmaError:1;			// (Read/Write-Clear)
									// Indicates a target or master abort. Software sets this bit
									// to 0 by writing a 1 to it.
	
		UCHAR InterruptStatus:1;	// IDEINTS - Read/Write-Clear
									// When set to 1, it indicates that an IDE device has asserted
									// its interrupt line (i.e., all data have been transferred).
									// Software clears this bit by writing a 1 to it.
	
		UCHAR Reserved:2;
	
		UCHAR Drive0DmaCapable:1;	// DMA0CAP - R/W - Software controlled.
									// 1 = capable
	
		UCHAR Drive1DmaCapable:1;	// DMA1CAP - R/W - Software controlled.
									// 1 = capable
	
		UCHAR Reserved2:1;
	};

	UCHAR AsUchar;

} BM_STATUS_REGISTER, *PBM_STATUS_REGISTER;

//
// PIIX4 BMIDTPX - Bus Master IDE Descriptor Table Pointer Register.
//
// IDE Controller I/O Space offset: Primary Channel Base + 04h, Secondary Channel Base + 0Ch
// Default value: 00000000h
// Attribute: R/W
//
typedef union _BM_SGL_REGISTER {

	struct {

		ULONG Reserved:2;

		ULONG SglAddress:30;		// Address of the Scatter/Gather List. The list must
									// not cross a 4-KB boundary in memory.
	};

	ULONG AsUlong;

} BM_SGL_REGISTER, *PBM_SGL_REGISTER;

//
// Bus Master Registers.
//
typedef struct _BM_REGISTERS {

	BM_COMMAND_REGISTER Command;

	UCHAR Reserved;

	BM_STATUS_REGISTER Status;

	UCHAR Reserved2;

	ULONG SglAddress;

} BM_REGISTERS, *PBM_REGISTERS;

typedef struct _CMD__CONTROLLER_INFORMATION {

    PCHAR   VendorId;
    ULONG   VendorIdLength;
    PCHAR   DeviceId;
    ULONG   ulDeviceId;
    ULONG   DeviceIdLength;

} CMD_CONTROLLER_INFORMATION, *PCMD_CONTROLLER_INFORMATION;

CMD_CONTROLLER_INFORMATION const CMDAdapters[] = {
    {"1095", 4, "0648", 0x648, 4},
    {"1095", 4, "0649", 0x649, 4}
};

#define NUM_NATIVE_MODE_ADAPTERS (sizeof(CMDAdapters) / sizeof(CMD_CONTROLLER_INFORMATION))

//
// Beautification macros
//
#define USES_DMA(TargetId) \
	((DeviceExtension->DeviceFlags[TargetId] & DFLAGS_USES_EITHER_DMA) != 0)

#define SELECT_DEVICE(BaseIoAddress, TargetId) \
	ScsiPortWritePortUchar(\
		&(BaseIoAddress)->DriveSelect, \
		(UCHAR)((((TargetId) & 1) << 4) | IDE_CHS_MODE)\
		);\
    ScsiPortStallExecution(60)

#define SELECT_CHS_DEVICE(BaseIoAddress, TargetId, HeadNumber) \
	ScsiPortWritePortUchar(\
		&(BaseIoAddress)->DriveSelect, \
		(UCHAR)((((TargetId) & 1) << 4) | IDE_CHS_MODE | (HeadNumber & 15))\
		);\
    ScsiPortStallExecution(60)

#define SELECT_LBA_DEVICE(BaseIoAddress, TargetId, Lba) \
	ScsiPortWritePortUchar(\
		&(BaseIoAddress)->DriveSelect, \
		(UCHAR)((((TargetId) & 1) << 4) | IDE_LBA_MODE | (Lba & 0x0f000000) >> 24)\
		);\
    ScsiPortStallExecution(60)

#define GET_STATUS(BaseIoAddress1, Status) \
    Status = ScsiPortReadPortUchar(&BaseIoAddress1->Command);

#define GET_BASE_STATUS(BaseIoAddress, Status) \
    Status = ScsiPortReadPortUchar(&BaseIoAddress->Command);

#define WRITE_COMMAND(BaseIoAddress, Command) \
    ScsiPortWritePortUchar(&BaseIoAddress->Command, Command);



#define READ_BUFFER(BaseIoAddress, Buffer, Count) \
    ScsiPortReadPortBufferUshort(&BaseIoAddress->Data, \
                                 Buffer, \
                                 Count);

#define WRITE_BUFFER(BaseIoAddress, Buffer, Count) \
    ScsiPortWritePortBufferUshort(&BaseIoAddress->Data, \
                                  Buffer, \
                                  Count);

#define READ_BUFFER2(BaseIoAddress, Buffer, Count) \
    ScsiPortReadPortBufferUlong(&BaseIoAddress->Data, \
                             Buffer, \
                             Count);

#define WRITE_BUFFER2(BaseIoAddress, Buffer, Count) \
    ScsiPortWritePortBufferUlong(&BaseIoAddress->Data, \
                              Buffer, \
                              Count);

//
// WAIT_IN_BUSY waits for up to 1 s.
//

#define WAIT_ON_BUSY(BaseIoAddress, Status) \
{ \
    ULONG i; \
    for (i = 0; i < 200000; i++) { \
        GET_STATUS(BaseIoAddress, Status); \
        if (Status & IDE_STATUS_BUSY) { \
            ScsiPortStallExecution(5); \
            continue; \
        } else { \
            break; \
        } \
    } \
}

#define WAIT_ON_ALTERNATE_STATUS_BUSY(BaseIoAddress2, Status) \
{ \
    ULONG i; \
    for (i = 0; i < 200000; i++) { \
		Status = ScsiPortReadPortUchar(&(baseIoAddress2->AlternateStatus)); \
        if (Status & IDE_STATUS_BUSY) { \
            ScsiPortStallExecution(5); \
            continue; \
        } else { \
            break; \
        } \
    } \
}

#define WAIT_ON_BASE_BUSY(BaseIoAddress, Status) \
{ \
    ULONG i; \
    for (i = 0; i < 200000; i++) { \
        GET_BASE_STATUS(BaseIoAddress, Status); \
        if (Status & IDE_STATUS_BUSY) { \
            ScsiPortStallExecution(5); \
            continue; \
        } else { \
            break; \
        } \
    } \
}

#define WAIT_FOR_DRQ(BaseIoAddress, Status) \
{ \
    ULONG i; \
    for (i = 0; i < 200000; i++) { \
        GET_STATUS(BaseIoAddress, Status); \
        if (Status & IDE_STATUS_BUSY) { \
            ScsiPortStallExecution(100); \
        } else if (Status & IDE_STATUS_DRQ) { \
            break; \
        } else { \
            ScsiPortStallExecution(5); \
        } \
    } \
}

#define WAIT_FOR_ALTERNATE_DRQ(baseIoAddress2, Status) \
{ \
    ULONG i; \
    for (i = 0; i < 200000; i++) { \
		Status = ScsiPortReadPortUchar(&(baseIoAddress2->AlternateStatus)); \
        if (Status & IDE_STATUS_BUSY) { \
            ScsiPortStallExecution(100); \
        } else if (Status & IDE_STATUS_DRQ) { \
            break; \
        } else { \
            ScsiPortStallExecution(5); \
        } \
    } \
}


#define WAIT_SHORT_FOR_DRQ(BaseIoAddress, Status) \
{ \
    ULONG i; \
    for (i = 0; i < 40; i++) { \
        GET_STATUS(BaseIoAddress, Status); \
        if (Status & IDE_STATUS_BUSY) { \
            ScsiPortStallExecution(100); \
        } else if (Status & IDE_STATUS_DRQ) { \
            break; \
        } else { \
            ScsiPortStallExecution(5); \
        } \
    } \
}

#define IDE_HARD_RESET(BaseIoAddress1, BaseIoAddress2, ucTargetId, result) \
{\
    UCHAR statusByte;\
    ULONG i;\
    ScsiPortWritePortUchar(&BaseIoAddress2->AlternateStatus,IDE_DC_RESET_CONTROLLER );\
    ScsiPortStallExecution(1000);\
    ScsiPortStallExecution(1000);\
    ScsiPortStallExecution(1000);\
    ScsiPortWritePortUchar(&BaseIoAddress2->AlternateStatus,IDE_DC_REENABLE_CONTROLLER);\
    ScsiPortStallExecution(1000);\
    ScsiPortStallExecution(1000);\
    ScsiPortStallExecution(1000);\
    ScsiPortStallExecution(1000);\
    ScsiPortStallExecution(1000);\
    SELECT_DEVICE(BaseIoAddress1, ucTargetId);\
    for (i = 0; i < 1000; i++) {\
        statusByte = ScsiPortReadPortUchar(&BaseIoAddress1->Command);\
        if (statusByte != IDE_STATUS_IDLE && statusByte != 0x0) {\
            ScsiPortStallExecution(1000);\
        } else {\
            break;\
        }\
    }\
    if (i == 1000) {\
        result = FALSE;\
    }\
    result = TRUE;\
}

#define IS_RDP(OperationCode)\
    ((OperationCode == SCSIOP_ERASE)||\
    (OperationCode == SCSIOP_LOAD_UNLOAD)||\
    (OperationCode == SCSIOP_LOCATE)||\
    (OperationCode == SCSIOP_REWIND) ||\
    (OperationCode == SCSIOP_SPACE)||\
    (OperationCode == SCSIOP_SEEK)||\
    (OperationCode == SCSIOP_WRITE_FILEMARKS))

#define SET_BM_COMMAND_REGISTER(Base, Field, Value) \
	{\
		BM_COMMAND_REGISTER buffer;\
\
		buffer.AsUchar = ScsiPortReadPortUchar(&(Base->Command.AsUchar));\
\
		buffer.Field = Value;\
\
		ScsiPortWritePortUchar(&(Base->Command.AsUchar), buffer.AsUchar);\
	}

#define SET_BM_STATUS_REGISTER(Base, Field, Value) \
	{\
		BM_STATUS_REGISTER buffer;\
\
		buffer.AsUchar = ScsiPortReadPortUchar(&(Base->Status.AsUchar));\
\
		buffer.Field = Value;\
\
		ScsiPortWritePortUchar(&(Base->Status.AsUchar), buffer.AsUchar);\
	}

#define CLEAR_BM_INT(Base, StatusByte) \
	StatusByte = ScsiPortReadPortUchar(&(Base->Status.AsUchar));\
	StatusByte |= 0x06; \
	ScsiPortWritePortUchar(&(Base->Status.AsUchar), StatusByte)

#define DRIVE_PRESENT(TargetId)                                         \
    ( DeviceExtension->DeviceFlags[TargetId] & DFLAGS_DEVICE_PRESENT )

#define IS_IDE_DRIVE(TargetId) \
	((DeviceExtension->DeviceFlags[TargetId] & DFLAGS_DEVICE_PRESENT) && \
	!(DeviceExtension->DeviceFlags[TargetId] & DFLAGS_ATAPI_DEVICE))

#define IS_ATAPI_DRIVE(TargetId) \
	((DeviceExtension->DeviceFlags[TargetId] & DFLAGS_DEVICE_PRESENT) && \
	(DeviceExtension->DeviceFlags[TargetId] & DFLAGS_ATAPI_DEVICE))

//
// Generic I/O transfer descriptor for PIO and DMA operations to/from IDE and ATAPI
// devices.
//

typedef struct _TRANSFER_DESCRIPTOR {

	//
	// Common section.
	//
	ULONG StartSector;
	ULONG Sectors;

	//
	// PIO section.
	//
    PUSHORT DataBuffer;
	ULONG WordsLeft;

    PUSHORT pusCurBufPtr;
    ULONG   ulCurBufLen;
    ULONG   ulCurSglInd;

	//
	// DMA section.
	//
	ULONG SglPhysicalAddress;

} TRANSFER_DESCRIPTOR, *PTRANSFER_DESCRIPTOR;

//
// SRB Extension.
//
typedef struct _SRB_EXTENSION {

    UCHAR SrbStatus;

	UCHAR NumberOfPdds;

	//
	// Scatter/Gather list. In PIO mode, this list contains
	// virtual addresses, while in DMA mode it contains
	// physical addresses.
	// 
	SGL_ENTRY aSglEntry[MAX_SGL_ENTRIES_PER_SRB];

    ULONG ulSglInsertionIndex;

	//
	// List of descriptors of DMA transfers. Each entry describes
	// a portion of the SGL. The SGL is logically partitioned
	// to support SCSI Port request sizes that exceed the physical
	// limit of individual drives. For example, each partition in an SGL
	// for an IDE disk defines a transfer not to exceed 128KB (256 sectors).
	// Single IDE drives, when a stripe-set is present, may be targeted
	// with large transfers by the SCSI Port, because the miniport
	// set the max transfer length to that (at least double) for the stripe-set.
	// Large transfers are split in smaller portions whose lengths do not
	// exceed the maximum accepted by the specific device.
	// 
	PHYSICAL_REQUEST_BLOCK Prb[MAX_PHYSICAL_REQUEST_BLOCKS];

    ULONG ulPrbInsertionIndex;

	PHYSICAL_DRIVE_DATA PhysicalDriveData[MAX_PDDS_PER_SRB];

    UCHAR RebuildTargetId;

    UCHAR RebuildSourceId;

    BOOLEAN IsWritePending;

    BOOLEAN IsNewOnly;	

    USHORT usNumError;	
						
    UCHAR ucOpCode;

    UCHAR ucOriginalId;

    UCHAR SrbInd;

#ifdef DBG
	ULONG SrbId;
#endif

} SRB_EXTENSION, *PSRB_EXTENSION;

#define MAX_DRIVE_TYPES         2       // We support Logical, Physical
#define MAX_DEVICE_TYPES        2       // We support NO_DRIVE and ATA

typedef struct PHW_DEVICE_EXTENSION;
typedef SRBSTATUS (*SEND_COMMAND)(IN PHW_DEVICE_EXTENSION DeviceExtension, IN PSCSI_REQUEST_BLOCK Srb );
typedef SRBSTATUS (*SPLIT_SRB_ENQUEQUE_SRB)(IN PHW_DEVICE_EXTENSION DeviceExtension,IN PSCSI_REQUEST_BLOCK Srb);
typedef VOID (*COMPLETION_ROUTINES)(IN PHW_DEVICE_EXTENSION DeviceExtension,IN PPHYSICAL_DRIVE_DATA Prb);
typedef SRBSTATUS   (*POST_ROUTINES)(IN PHW_DEVICE_EXTENSION DeviceExtension,IN PPHYSICAL_COMMAND pPhysicalCommand);

#define NO_DRIVE                0
#define IDE_DRIVE               1

#define LOGICAL_DRIVE_TYPE      1
#define PHYSICAL_DRIVE_TYPE     0

#define SET_IRCD_PENDING        1
#define GET_IRCD_PENDING        2
#define LOCK_IRCD_PENDING       4

#define IRCD_MAX_LOCK_TIME      (10000000 * 60)

#ifdef HYPERDISK_WIN2K

#define PCI_DATA_TO_BE_UPDATED  5

typedef struct _PCI_BIT_MASK
{
    ULONG ulOffset;
    ULONG ulLength;
    ULONG ulAndMask;
} PCI_BIT_MASK;

PCI_BIT_MASK aPCIDataToBeStored[PCI_DATA_TO_BE_UPDATED] = 
{ // right now the WriteToPCISpace, ReadFromPCI functions are capable of handling only dwords at a time
    {0x50, 4, 0x0f3300bb},
    {0x54, 4, 0x41000f00}, 
    {0x58, 4, 0x00ffff00}, 
    {0x70, 4, 0x001800ff}, 
    {0x78, 4, 0x00180cff} 
};

#endif

//
// Device extension.
//

typedef struct _HW_DEVICE_EXTENSION {
    UCHAR ucControllerId;

	LOGICAL_DRIVE LogicalDrive[MAX_DRIVES_PER_CONTROLLER];	
	// PHYSICAL_DRIVE PhysicalDrive[MAX_DRIVES_PER_CONTROLLER];
    PPHYSICAL_DRIVE PhysicalDrive;
	BOOLEAN IsSingleDrive[MAX_DRIVES_PER_CONTROLLER];
	BOOLEAN IsLogicalDrive[MAX_DRIVES_PER_CONTROLLER];

	CHANNEL Channel[MAX_CHANNELS_PER_CONTROLLER];

	//
	// Transfer descriptor.
	//
	TRANSFER_DESCRIPTOR TransferDescriptor[MAX_CHANNELS_PER_CONTROLLER];

    //
    // List of pending SRBs.
    //
#ifdef HD_ALLOCATE_SRBEXT_SEPERATELY
	PSCSI_REQUEST_BLOCK PendingSrb[MAX_PENDING_SRBS];  // Striping will have the maximum pending srbs
#else
	PSCSI_REQUEST_BLOCK PendingSrb[STRIPING_MAX_PENDING_SRBS];  // Striping will have the maximum pending srbs
#endif

	//
	// Number of pending SRBs.
	//
	ULONG PendingSrbs;

    //
    // Base register locations.
    //
    PIDE_REGISTERS_1 BaseIoAddress1[MAX_CHANNELS_PER_CONTROLLER];
    PIDE_REGISTERS_2 BaseIoAddress2[MAX_CHANNELS_PER_CONTROLLER];
	PBM_REGISTERS BaseBmAddress[MAX_CHANNELS_PER_CONTROLLER];

	//
	// PCI Slot information for the IDE controller.
	//
	PCI_SLOT_NUMBER PciSlot;

	//
	// System I/O Bus Number for this controller.
    //
	ULONG BusNumber;

	//
	// Interface type.
	//
	INTERFACE_TYPE AdapterInterfaceType;

	//
	// Transfer Mode.
	//
	TRANSFER_MODE TransferMode[MAX_DRIVES_PER_CONTROLLER];

    //
    // Interrupt level.
    //
    ULONG ulIntLine;

    //
    // Interrupt Mode (Level or Edge)
    //
    ULONG InterruptMode;

	//
	// Controller speed (UDMA/33, UDMA/66, etc.)
	//
    CONTROLLER_SPEED ControllerSpeed;

	//
	// Copy of PCI timing registers.
	//
	IDE_PCI_TIMING_REGISTER IdeTimingRegister[MAX_CHANNELS_PER_CONTROLLER];

	//
	// Copy of UDMA Control register.
	//
	IDE_PCI_UDMA_CONTROL_REGISTER UdmaControlRegister;

	//
	// Copy of UDMA Timing register.
	//
	IDE_PCI_UDMA_TIMING_REGISTER UdmaTimingRegister;

    //
    // Count of errors. Used to turn off features.
    //
    ULONG ErrorCount[MAX_DRIVES_PER_CONTROLLER];

    //
    // Indicates number of platters on changer-ish devices.
    //
    ULONG DiscsPresent[MAX_DRIVES_PER_CONTROLLER];

    //
    // Flags dword for each possible device.
    //
    ULONG DeviceFlags[MAX_DRIVES_PER_CONTROLLER];

    //
    // Indicates the number of blocks transferred per int. according to the
    // identify data.
    //
    UCHAR MaximumBlockXfer[MAX_DRIVES_PER_CONTROLLER];

    //
    // Indicates expecting an interrupt.
    //
	UCHAR ExpectingInterrupt[MAX_CHANNELS_PER_CONTROLLER];

    //
    // Driver is being used by the crash dump utility or ntldr.
    //
    BOOLEAN DriverMustPoll;

    //
    // Indicates use of 32-bit PIO
    //
    BOOLEAN DWordIO;

    //
    // Placeholder for status register after a GET_MEDIA_STATUS command
    //

    UCHAR ReturningMediaStatus[MAX_DRIVES_PER_CONTROLLER];
    
    //
    // Identify data for device
    //
    IDENTIFY_DATA FullIdentifyData[MAX_DRIVES_PER_CONTROLLER];
    IDENTIFY_DATA2 IdentifyData[MAX_DRIVES_PER_CONTROLLER];

    ULONG aulDrvList[MAX_DRIVES_PER_CONTROLLER];
    UCHAR aucDevType[MAX_DRIVES_PER_CONTROLLER];
    SEND_COMMAND SendCommand[MAX_DEVICE_TYPES];

    SPLIT_SRB_ENQUEQUE_SRB SrbHandlers[MAX_DRIVE_TYPES];

    POST_ROUTINES PostRoutines[MAX_DEVICE_TYPES];

    UCHAR RebuildInProgress;
    ULONG RebuildWaterMarkSector;
    ULONG RebuildWaterMarkLength;
    ULONG RebuildTargetDrive;

    UCHAR   ulMaxStripesPerRow; 

    BOOLEAN bIntFlag;

    UCHAR IsSpareDrive[MAX_DRIVES_PER_CONTROLLER];

    BOOLEAN bEnableRwCache;

    BOOLEAN bSkipSetParameters[MAX_DRIVES_PER_CONTROLLER];

    BOOLEAN bIsThruResetController;

    ULONG   aulLogDrvId[MAX_DRIVES_PER_CONTROLLER];

    ULONG   ulFlushCacheCount;

#ifdef HYPERDISK_WIN2K
    BOOLEAN bIsResetRequiredToGetActiveMode;
    ULONG aulPCIData[PCI_DATA_TO_BE_UPDATED];
#endif // HYPERDISK_WIN2K

#ifdef HD_ALLOCATE_SRBEXT_SEPERATELY
    PSRB_EXTENSION  pSrbExtension;
#endif // HYPERDISK_WIN98

    BOOLEAN bInvalidConnectionIdImplementation;

    // plays the same role as MAX_PENDING_SRBS
    UCHAR   ucMaxPendingSrbs ;
    UCHAR   ucOptMaxQueueSize;
    UCHAR   ucOptMinQueueSize;

    // For SMART Implementation
    UCHAR uchSMARTCommand;
} HW_DEVICE_EXTENSION, *PHW_DEVICE_EXTENSION;


typedef struct _CARD_INFO
{
    PHW_DEVICE_EXTENSION pDE;
    UCHAR   ucPCIBus;
    UCHAR   ucPCIDev;
    UCHAR   ucPCIFun;
    ULONG   ulDeviceId;
    ULONG   ulVendorId;
}CARD_INFO, *PCARD_INFO;


#define GET_TARGET_ID(ConnectionId) ((ConnectionId & 0x0f ) + ((ConnectionId >> 4) * 2))
#define GET_TARGET_ID_WITHOUT_CONTROLLER_INFO(ConnectionId) ( ((ConnectionId & 0x0f ) + ((ConnectionId >> 4) * 2)) & 0x3)
#define GET_FIRST_LOGICAL_DRIVE(pRaidHeader) ((char *)pRaidHeader + pRaidHeader->HeaderSize)
#define TARGET_ID_2_CONNECTION_ID(ulDrvInd) ((ulDrvInd & 0x1) + ((ulDrvInd & 0xfe) << 3))
#define TARGET_ID_WITHOUT_CONTROLLER_ID(ulDrvInd)   (ulDrvInd & 0x03)

#define IS_CHANNEL_BUSY(DeviceExtension, ulChannel) ( DeviceExtension->Channel[ulChannel].ActiveCommand )

#define DRIVE_HAS_COMMANDS(PhysicalDrive)   \
        (PhysicalDrive->ucHead != PhysicalDrive->ucTail)

#define ACTIVE_COMMAND_PRESENT(Channel) (Channel->ActiveCommand)

#define FEED_ALL_CHANNELS(DeviceExtension)                              \
            {                                                           \
                ULONG ulChannel;                                        \
                for(ulChannel=0;ulChannel<MAX_CHANNELS_PER_CONTROLLER;ulChannel++)     \
                    StartChannelIo(DeviceExtension, ulChannel);         \
            }

#define CLEAR_AND_POST_COMMAND(DeviceExtension, ulChannel)              \
            {                                                           \
                MarkChannelFree(DeviceExtension, ulChannel);            \
                StartChannelIo(DeviceExtension, ulChannel);             \
            }

#define DRIVE_IS_UNUSABLE_STATE(TargetId)                               \
        ( DeviceExtension->PhysicalDrive[TargetId].TimeOutErrorCount >= MAX_TIME_OUT_ERROR_COUNT )

#define MAX_TIME_OUT_ERROR_COUNT    5


#endif // _HYPERDISK_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\port\scsi\miniport\megaraid\adapter.h ===
/*******************************************************************/
/*                                                                 */
/* NAME             = Adapter.H                                    */
/* FUNCTION         = Header file of Adapter Version Information;  */
/* NOTES            =                                              */
/* DATE             = 02-03-2000                                   */
/* HISTORY          = 001, 02-03-00, Parag Ranjan Maharana;        */
/* COPYRIGHT        = LSI Logic Corporation. All rights reserved;  */
/*                                                                 */
/*******************************************************************/

#ifndef _ADAPTER_H
#define _ADAPTER_H

/*
	Define Vendor here
*/
#define MEGARAID  1

#undef VER_PRODUCTNAME_STR
#undef VER_PRODUCTVERSION_STR
#undef VER_COMPANYNAME_STR


#if (_WIN32_WINNT == 0x0502)	 //.NET


#ifdef _WIN64   
#define VER_PRODUCTVERSION_STR  "6.21.8.64"    //IA64
#else
#define VER_PRODUCTVERSION_STR  "6.21.8.32"		 //x86
#endif


#elif (_WIN32_WINNT == 0x0501) //XP

#ifdef _WIN64
#define VER_PRODUCTVERSION_STR  "6.19.8.64"		 //IA64
#else
#define VER_PRODUCTVERSION_STR  "6.19.8.32"		 //x86
#endif

#elif (_WIN32_WINNT == 0x0500) //Win2k

#define VER_PRODUCTVERSION_STR  "5.2.58.8"		 //x86

#else	 //any other version

#ifdef _WIN64
#define VER_PRODUCTVERSION_STR  "7.21.8.64"		 //IA64
#else
#define VER_PRODUCTVERSION_STR  "7.21.8.32"		 //x86
#endif

#endif


/*
  MegaRAID Version Information
*/

#define VER_LEGALCOPYRIGHT_YEARS    "         "
#define VER_LEGALCOPYRIGHT_STR      "Copyright \251 LSI Logic Corporation" VER_LEGALCOPYRIGHT_YEARS
#define VER_COMPANYNAME_STR         "LSI Logic Corporation"      
#ifdef _WIN64
#define VER_PRODUCTNAME_STR         "MegaRAID Miniport Driver for IA64 Systems"
#define VER_FILEDESCRIPTION_STR     "MegaRAID RAID Controller Driver for IA64 Systems"
#else
#define VER_PRODUCTNAME_STR         "MegaRAID Miniport Driver for x86 Systems"
#define VER_FILEDESCRIPTION_STR     "MegaRAID RAID Controller Driver for x86 Systems"
#endif
#define VER_ORIGINALFILENAME_STR    "mraid35x.sys"
#define VER_INTERNALNAME_STR        "mraid35x.sys"




#define RELEASE_DATE "04-08-2002"

#ifdef _WIN64
#define OS_NAME      "Whistler 64"
#else
#define OS_NAME      "Whistler 32"
#endif
#define OS_VERSION   "5.01"


#endif //_ADAPTER_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\port\scsi\miniport\megaide\startio.c ===
#ifdef KEEP_LOG
ULONG ulStartLog = 0;   // boolean variable to decide whether to start log or not

typedef struct _COMMAND_LOG
{
    ULONG ulCmd;
    ULONG ulStartSector;
    ULONG ulSectorCount;
}COMMAND_LOG;

#define MAX_LOG_COUNT   5000
ULONG ulStartInd = 0;

COMMAND_LOG CommandLog[MAX_LOG_COUNT];

#endif

BOOLEAN
AtapiStartIo(
	IN PHW_DEVICE_EXTENSION DeviceExtension,
	IN PSCSI_REQUEST_BLOCK Srb
)

/*++

Routine Description:

	This routine is called from the SCSI port driver synchronized
	with the kernel to start an IO request.

Arguments:

	DeviceExtension - HBA miniport driver's adapter data storage
	Srb - IO request packet

Return Value:

	TRUE

--*/

{
	ULONG status, ulChannelId;
	UCHAR targetId;
	ULONG sectorsRequested = GET_SECTOR_COUNT(Srb);
	ULONG ulStartSector = GET_START_SECTOR(Srb);
    ULONG i = 0;

    PSRB_EXTENSION SrbExtension;

    i = AssignSrbExtension (DeviceExtension, Srb);

    if (i >= DeviceExtension->ucMaxPendingSrbs)
    {
        Srb->SrbStatus = SRB_STATUS_BUSY;
    	ScsiPortNotification(RequestComplete, DeviceExtension, Srb);
    }
	
	SrbExtension = Srb->SrbExtension;

    SrbExtension->SrbStatus = SRB_STATUS_SUCCESS;

    if ( SCSIOP_INTERNAL_COMMAND == Srb->Cdb[0] )   
    // this is done only as a precaution since we will be refering to the Original Id 
    // when we need to complete the command
    {
        ((PSRB_EXTENSION)(Srb->SrbExtension))->ucOriginalId = Srb->TargetId;
    }

#ifdef DBG
	SrbExtension->SrbId = SrbCount;
	++SrbCount;
#endif

    DebugPrint((1, "%ld\t%ld\t\n", sectorsRequested, ulStartSector));

	targetId = Srb->TargetId;

    Srb->SrbStatus = SRB_STATUS_SUCCESS;    // by default the command is success

    //
	// Determine which function.
	//

	switch (Srb->Function) {

		case SRB_FUNCTION_EXECUTE_SCSI:

            //
            // Perform sanity checks.
            //

            if (!TargetAccessible(DeviceExtension, Srb)) {

	            status = SRB_STATUS_SELECTION_TIMEOUT;
	            break;
            }

            //
            // Send command to device.
            //
            status = (DeviceExtension->SendCommand[DeviceExtension->aucDevType[targetId]])(DeviceExtension, Srb);
            break;
	
        case SRB_FUNCTION_ABORT_COMMAND:
			//
			// Verify that SRB to abort is still outstanding.
			//
	
			if (!PendingSrb(DeviceExtension, Srb)) {
	
				DebugPrint((1, "AtapiStartIo: SRB to abort already completed\n"));
	
				//
				// Complete abort SRB.
				//
	
				status = SRB_STATUS_ABORT_FAILED;
	
				break;

			}
	
			//
			// Abort function indicates that a request timed out.
			// Call reset routine. Card will only be reset if
			// status indicates something is wrong.
			// Fall through to reset code.
			//
	
        case SRB_FUNCTION_RESET_BUS:
	
			//
			// Reset Atapi and SCSI bus.
			//
	
			DebugPrint((1, "AtapiStartIo: Reset bus request received\n"));
	
			if (!AtapiResetController(DeviceExtension, Srb->PathId)) {
	
				DebugPrint((1,"AtapiStartIo: Reset bus failed\n"));
	
				//
				// Log reset failure.
				//
	
                ScsiPortLogError(DeviceExtension, NULL, 0, 0, 0, SP_INTERNAL_ADAPTER_ERROR, HYPERDISK_RESET_BUS_FAILED);

                status = SRB_STATUS_ERROR;

			} else {
	
				  status = SRB_STATUS_SUCCESS;
			}
	
			break;

        case SRB_FUNCTION_FLUSH:
            // We are avoiding all the Flush commands since it is a time consuming process and 
            // it is not useful???!!!!
            // We are hoping that it is enough if we handle this only when shutdown time
            // To be checked for Win2000 sometimes the suspend or 
            // hibernation is not working properly... is it due to not flushing properly????? verify
            // Check this out
            status = SRB_STATUS_SUCCESS;
            break;

        case SRB_FUNCTION_SHUTDOWN:
            {
                UCHAR ucDrvId, ucStatus;
                PIDE_REGISTERS_2 baseIoAddress2;
                PIDE_REGISTERS_1 baseIoAddress1;
                ULONG ulWaitSec;

                for(ucDrvId=0;ucDrvId<MAX_DRIVES_PER_CONTROLLER;ucDrvId++)
                {
                    if ( !( IS_IDE_DRIVE(ucDrvId) ) )
                        continue;

                    if ( IS_CHANNEL_BUSY(DeviceExtension, (ucDrvId>>1) ) )
                    {
                        DeviceExtension->PhysicalDrive[ucDrvId].bFlushCachePending = TRUE;
                        DeviceExtension->ulFlushCacheCount++;
                        continue;
                    }

                    FlushCache(DeviceExtension, ucDrvId);
                    DisableRWBCache(DeviceExtension, ucDrvId); 
                }

                status = SRB_STATUS_SUCCESS;
            }
            break;
		default:
	
			//
			// Indicate unsupported command.
			//
	
			status = SRB_STATUS_INVALID_REQUEST;
	
			break;

	} // end switch

    FEED_ALL_CHANNELS(DeviceExtension);

	//
	// Check if command complete.
	//

	if (status != SRB_STATUS_PENDING) 
    {
		//
		// Indicate command complete.
		//
		DebugPrint((2,
				   "AtapiStartIo: Srb %lx complete with status %x\n",
				   Srb,
				   status));

		//
		// Set status in SRB.
		//
		Srb->SrbStatus = (UCHAR)status;

        if ( SCSIOP_INTERNAL_COMMAND == Srb->Cdb[0] )
        {
            Srb->TargetId = ((PSRB_EXTENSION)(Srb->SrbExtension))->ucOriginalId;
        }

        // We already added this SRB in the Pending SRB Array... so we have to remove it
        RemoveSrbFromPendingList(DeviceExtension, Srb);

        // Complete the Command
    	ScsiPortNotification(RequestComplete, DeviceExtension, Srb);
	}

    if (DeviceExtension->PendingSrbs < DeviceExtension->ucMaxPendingSrbs) 
    {
        if ( ( !((ScsiPortReadPortUchar( &((DeviceExtension->BaseBmAddress[0])->Reserved) ) ) & ANY_CHANNEL_INTERRUPT) ) || 
                (DeviceExtension->PendingSrbs < 2) )
        
        { // Request for next command only if controller is not waiting on interrupt to be processed
		    //
		    // Indicate ready for next request.
		    //
		    ScsiPortNotification(NextLuRequest, DeviceExtension, 0, targetId, 0);
        }
	}

	return TRUE;

} // end AtapiStartIo()

VOID
StartChannelIo(
	IN PHW_DEVICE_EXTENSION DeviceExtension,
    IN ULONG ulChannelId
)

{
	UCHAR status;
    ULONG targetId;
    ULONG ulDrvCount;
    PPHYSICAL_COMMAND pPhysicalCommand;
    PPHYSICAL_DRIVE PhysicalDrive;

	// Init status to something impossible.
	status = SRB_STATUS_NO_DEVICE;

	//
	// If the channel is Busy, just return...
	//

    if ( IS_CHANNEL_BUSY(DeviceExtension,ulChannelId) )
        return;

    if ( gulChangeIRCDPending )
    {
        if ( LOCK_IRCD_PENDING == gulChangeIRCDPending  )
        {
            gulLockVal = LockIRCD(DeviceExtension, TRUE, 0);
            if ( gulLockVal )
            {
                gulChangeIRCDPending = SET_IRCD_PENDING;
                InformAllControllers();
            }
        }
        else
        {
            if ( DeviceExtension->Channel[ulChannelId].bUpdateInfoPending )
            {
                for(ulDrvCount=0;ulDrvCount<MAX_DRIVES_PER_CHANNEL;ulDrvCount++)
                {
                    targetId = (ulChannelId << 1) + ulDrvCount;
                    SetOneDriveIRCD(DeviceExtension, (UCHAR)targetId);
                }
                DeviceExtension->Channel[ulChannelId].bUpdateInfoPending = FALSE;
                if ( UpdateFinished() ) // if all the controllers finished the updation go ahead and unlock the ircd
                {
                    gulLockVal = LockIRCD(DeviceExtension, FALSE, gulLockVal);
                    gulPowerFailedTargetBitMap = 0; // reset the bit map so that we don't do this again and again
                    gulChangeIRCDPending = 0;
                }

            }
        }
    }

    if ( DeviceExtension->ulFlushCacheCount )
    {
        for(ulDrvCount=0;ulDrvCount<MAX_DRIVES_PER_CHANNEL;ulDrvCount++)
        {
            targetId = (ulChannelId << 1) + ulDrvCount;
            if ( DeviceExtension->PhysicalDrive[targetId].bFlushCachePending )
            {
                FlushCache(DeviceExtension, (UCHAR)targetId);
                DisableRWBCache(DeviceExtension, (UCHAR)targetId); 
                // We are handling only SHUTDOWN... so.. let us Disable the cache
                DeviceExtension->ulFlushCacheCount--;
                DeviceExtension->PhysicalDrive[targetId].bFlushCachePending = FALSE;
            }
        }
    }

	// Set TID of the next drive in the channel.
	targetId = (ulChannelId << 1) + (DeviceExtension->Channel[ulChannelId].LastDriveFed ^ DeviceExtension->Channel[ulChannelId].SwitchDrive);

    PhysicalDrive = &(DeviceExtension->PhysicalDrive[targetId]);
	// See if this drive's work queue is empty.
	if (!DRIVE_HAS_COMMANDS(PhysicalDrive)) {

		if (DeviceExtension->Channel[ulChannelId].SwitchDrive == 0) {
			return;
		}

		// Switch to other drive.
		targetId ^= DeviceExtension->Channel[ulChannelId].SwitchDrive;

        PhysicalDrive = &(DeviceExtension->PhysicalDrive[targetId]);
			// Check the other drive's work queue.
		if (!DRIVE_HAS_COMMANDS(PhysicalDrive)) {

			// No new work for this channel. Move to next channel.
			return;
		}
	}

	//
	// At least one drive on this channel has something to do.
	//

	// Next time, feed the other drive.
	DeviceExtension->Channel[ulChannelId].LastDriveFed = (UCHAR)targetId & 1;
    pPhysicalCommand = CreatePhysicalCommand(DeviceExtension, targetId);
    DeviceExtension->Channel[ulChannelId].ActiveCommand = pPhysicalCommand;

#ifdef DBG
    if ( pPhysicalCommand )
    {
        PrintPhysicalCommandDetails(pPhysicalCommand);
    }
#endif

    status = (DeviceExtension->PostRoutines[DeviceExtension->aucDevType[targetId]])(DeviceExtension, pPhysicalCommand);

	if (status != SRB_STATUS_PENDING) {
        MarkChannelFree(DeviceExtension, (targetId>>1));    // free the channel
	}

    pPhysicalCommand->SrbStatus = SRB_STATUS_SUCCESS;
    return;
}

BOOLEAN
MarkChannelFree(
	IN PHW_DEVICE_EXTENSION DeviceExtension,
	ULONG ulChannel
)
{

    DeviceExtension->Channel[ulChannel].ActiveCommand = NULL;
    DeviceExtension->ExpectingInterrupt[ulChannel] = 0;

    return TRUE;
}

PPHYSICAL_COMMAND 
CreatePhysicalCommand(
	IN PHW_DEVICE_EXTENSION DeviceExtension,
	ULONG ulTargetId
    )
/*++


 This function will be used by both PIO and UDMA Transfers

 This function tries to merge the commands.... Done for both PIO and UDMA


--*/
{
    PPHYSICAL_DRIVE     pPhysicalDrive = &(DeviceExtension->PhysicalDrive[ulTargetId]);
    PPHYSICAL_COMMAND   pPhysicalCommand = &(pPhysicalDrive->PhysicalCommand);
    PPHYSICAL_REQUEST_BLOCK      *ppPrbList = pPhysicalDrive->pPrbList;
    UCHAR               ucHead = pPhysicalDrive->ucHead;
    UCHAR               ucTail = pPhysicalDrive->ucTail;
    UCHAR               ucStartInd, ucEndInd, ucCurInd, ucNextCurInd, ucCmd, ucCmdCount, ucCounter;
    ULONG               ulCurXferLength = 0, ulGlobalSglCount, ulSglCount, ulSglInd;
    PVOID               pvGlobalSglBufPtr, pvCurPartSglBufPtr;
    PSGL_ENTRY          pSglPtr;

#ifdef DBG
    ULONG               ulTotSglCount = 0;
#endif

    if ( ucHead == ucTail ) // No commands in the queue ...
        return NULL;

    ucCurInd = ucHead;
    ucNextCurInd = ((ucCurInd + 1)%MAX_NUMBER_OF_PHYSICAL_REQUEST_BLOCKS_PER_DRIVE);
    ulCurXferLength = ppPrbList[ucCurInd]->ulSectors;
    ucCmd = ppPrbList[ucCurInd]->ucCmd;
    ucCmdCount=1;

    if ( SCSIOP_VERIFY == ucCmd )
    {   // No merging for Verify Command ... it is possible that we will get even 0x2000 sectors for one command
        // and we are going to reuse the same prb

        // form the PhysicalCommand
        pPhysicalCommand->ucCmd = ucCmd;
        pPhysicalCommand->TargetId = (UCHAR)ulTargetId;

        // Number of commands merged
        pPhysicalCommand->ucStartInd = ucHead;
        pPhysicalCommand->ucCmdCount = 1;
        DeviceExtension->PhysicalDrive[ulTargetId].ucCommandCount -= 1;

        // Total number of sectors..
        pPhysicalCommand->ulStartSector = ppPrbList[ucHead]->ulStartSector;
        pPhysicalCommand->ulCount = ppPrbList[ucHead]->ulSectors;

        DeviceExtension->PhysicalDrive[ulTargetId].ucHead = ucNextCurInd;
        return pPhysicalCommand;
    }

#ifdef DBG
    ulTotSglCount = ppPrbList[ucCurInd]->ulSglCount;
#endif

    for(;ucNextCurInd!=ucTail;ucCurInd=ucNextCurInd, (ucNextCurInd=(ucNextCurInd+1)%MAX_NUMBER_OF_PHYSICAL_REQUEST_BLOCKS_PER_DRIVE))
    {
        // Is Next Command is not same as the current Command?
        if ( ucCmd != ppPrbList[ucNextCurInd]->ucCmd )
            break;

        // Is the length is going beyond the limit of the IDE Xfer?
        if ( ( ulCurXferLength + ppPrbList[ucNextCurInd]->ulSectors ) > MAX_SECTORS_PER_IDE_TRANSFER )
            break;

        // Is Next Command is consecutive location of the current Command?
        if ( (ppPrbList[ucCurInd]->ulStartSector+ppPrbList[ucCurInd]->ulSectors) != 
                    ppPrbList[ucNextCurInd]->ulStartSector )
            break;

        ulCurXferLength += ppPrbList[ucNextCurInd]->ulSectors;
        ucCmdCount++;
#ifdef DBG
        ulTotSglCount += ppPrbList[ucNextCurInd]->ulSglCount;
#endif
    }


#ifdef DBG
    DebugPrint((DEFAULT_DISPLAY_VALUE," MS:%x ", ulTotSglCount));
    if ( ulTotSglCount > pPhysicalCommand->MaxSglEntries )
    {
        STOP;
    }
#endif

    ucStartInd = ucHead;
    ucEndInd = ucCurInd;
    pPhysicalDrive->ucHead = ucNextCurInd;

    // form the PhysicalCommand
    pPhysicalCommand->ucCmd = ucCmd;
    pPhysicalCommand->TargetId = (UCHAR)ulTargetId;

    // Number of commands merged
    pPhysicalCommand->ucStartInd = ucStartInd;
    pPhysicalCommand->ucCmdCount = ucCmdCount;

    DeviceExtension->PhysicalDrive[ulTargetId].ucCommandCount -= ucCmdCount;

    // Total number of sectors..
    pPhysicalCommand->ulStartSector = ppPrbList[ucHead]->ulStartSector;
    if ( SCSIOP_INTERNAL_COMMAND == ucCmd )
    {
        PPASS_THRU_DATA pPassThruData = (PPASS_THRU_DATA)(((PSRB_BUFFER)(ppPrbList[ucHead]->pPdd->OriginalSrb->DataBuffer))->caDataBuffer);
        pPhysicalCommand->ulCount = pPassThruData->ulSize;
    }
    else
    {
        pPhysicalCommand->ulCount = ulCurXferLength;
    }

    pvGlobalSglBufPtr = pPhysicalCommand->SglBaseVirtualAddress;
    ulGlobalSglCount = 0;

    for(ucCounter=0;ucCounter<ucCmdCount;ucCounter++)
    {
        ucCurInd = ( ucHead + ucCounter ) % MAX_NUMBER_OF_PHYSICAL_REQUEST_BLOCKS_PER_DRIVE;

        pvCurPartSglBufPtr = (PVOID)ppPrbList[ucCurInd]->ulVirtualAddress;
        ulSglCount = ppPrbList[ucCurInd]->ulSglCount;

        AtapiMemCpy(pvGlobalSglBufPtr, pvCurPartSglBufPtr, ulSglCount * sizeof(SGL_ENTRY));

        ulGlobalSglCount = ulGlobalSglCount + ulSglCount;

        pvGlobalSglBufPtr = (PUCHAR)pvGlobalSglBufPtr + (ulSglCount * sizeof(SGL_ENTRY));
    }

    pSglPtr = (PSGL_ENTRY)pPhysicalCommand->SglBaseVirtualAddress;

    pSglPtr[ulGlobalSglCount-1].Physical.EndOfListFlag = 1; // Considering Zero Index... we have to keep the EOL in ulGlobalSglCount

#ifdef DBG
    pPhysicalCommand->ulTotSglCount = ulGlobalSglCount;
#endif

    return pPhysicalCommand;
}

//
// ATAPI Command Descriptor Block
//

typedef struct _MODE_SENSE_10 {
        UCHAR OperationCode;
        UCHAR Reserved1;
        UCHAR PageCode : 6;
        UCHAR Pc : 2;
        UCHAR Reserved2[4];
        UCHAR ParameterListLengthMsb;
        UCHAR ParameterListLengthLsb;
        UCHAR Reserved3[3];
} MODE_SENSE_10, *PMODE_SENSE_10;

SRBSTATUS
IdeSendCommand(
	IN PHW_DEVICE_EXTENSION DeviceExtension,
	IN PSCSI_REQUEST_BLOCK Srb
)

/*++

Routine Description:

	Program ATA registers for IDE disk transfer.

Arguments:

	DeviceExtension - ATAPI driver storage.
	Srb - System request block.

Return Value:

	SRB status (pending if all goes well).

--*/

{
	UCHAR status = SRB_STATUS_SUCCESS;

    DebugPrint((DEFAULT_DISPLAY_VALUE,"ISC"));
    
    DebugPrint((3, "\nIdeSendCommand: Entering routine.\n"));

	DebugPrint((2,
			   "IdeSendCommand: Command %x to TID %d\n",
			   Srb->Cdb[0],
			   Srb->TargetId));

	switch(Srb->Cdb[0]) {

		case SCSIOP_READ:
		case SCSIOP_WRITE:
		case SCSIOP_VERIFY:
            status = DeviceExtension->SrbHandlers[DeviceExtension->IsLogicalDrive[Srb->TargetId]](DeviceExtension, Srb);
			break;

		case SCSIOP_INQUIRY:
			status = GetInquiryData(DeviceExtension, Srb);
			break;

		case SCSIOP_MODE_SELECT:
            status = SRB_STATUS_SUCCESS;
            break;

		case SCSIOP_SYNCHRONIZE_CACHE:
            {
                break;
            }
		case SCSIOP_MODE_SENSE:
            {
		        status = SRB_STATUS_INVALID_REQUEST;
		        break;
            }
		case SCSIOP_TEST_UNIT_READY:
            status = SRB_STATUS_SUCCESS;
			break;
		case SCSIOP_START_STOP_UNIT:
            status = SRB_STATUS_SUCCESS;
			break;
		case SCSIOP_READ_CAPACITY:
			GetDriveCapacity(DeviceExtension, Srb);
			status = SRB_STATUS_SUCCESS;
			break;
		case SCSIOP_REQUEST_SENSE:
			//
			// This function makes sense buffers to report the results
			// of the original GET_MEDIA_STATUS command.
			//
			if (DeviceExtension->DeviceFlags[Srb->TargetId] & DFLAGS_MEDIA_STATUS_ENABLED) {
				status = IdeBuildSenseBuffer(DeviceExtension, Srb);
				break;
			}
            status = SRB_STATUS_ERROR;
            break;
        case SCSIOP_INTERNAL_COMMAND:
            {
                // This is our internal Request... So let us call the function to Enqueue the request
                // The functions that are supported are GetErrorLog, EraseErrorLog, GetIRCD, SetIRCD
                // Probe HyperDisk, GetRaidInfo, GetStatus, LockUnlockIRCD, IOGetCapacity, ChangeMirrorDriveStatus,
                // ChangeMirrorDrive, ChangeDriveStatus, GetStatus
                PSRB_EXTENSION SrbExtension = Srb->SrbExtension;
                PSRB_IO_CONTROL pSrbIoc = (PSRB_IO_CONTROL) Srb->DataBuffer;
                UCHAR ucOpCode = (UCHAR) pSrbIoc->ControlCode;
                UCHAR ucOriginalId = Srb->TargetId;
                PCDB pCDB = NULL;
                pCDB = (PCDB)Srb->Cdb;

                switch ( ucOpCode )
                {
                    case IOC_PROBE_AMIRAID:
                    {
                        PPROBE_AMI_DRIVER pSrbProbe = (PPROBE_AMI_DRIVER) 
                                                      (((PSRB_BUFFER)Srb->DataBuffer)->caDataBuffer);
                        
                        AtapiMemCpy(pSrbProbe->aucAmiSig, "AMIRAID", sizeof("AMIRAID"));
                        status = SRB_STATUS_SUCCESS;
                        break;
                    }
                    case IOC_PASS_THRU_COMMAND:
                    {
                        ULONG ulStartSector;
                        PPASS_THRU_DATA pPassThruData = (PPASS_THRU_DATA)
                            (((PSRB_BUFFER)Srb->DataBuffer)->caDataBuffer);

                        SrbExtension->ucOriginalId = ucOriginalId;
                        SrbExtension->ucOpCode = ucOpCode;
                        if (DRIVE_IS_UNUSABLE_STATE((pPassThruData->uchTargetID)) || 
                            (!DRIVE_PRESENT((pPassThruData->uchTargetID))))
                        {
                            // This drive may be a drive that responding 
                            // even when power is not there
		                    DebugPrint((1, "Failed Drive.... so failing command \n"));
                            status = SRB_STATUS_ERROR;
		                    break;
                        }

                        Srb->TargetId = pPassThruData->uchTargetID;
                        //
                        // Set the Transfer Length and Starting Transfer Sector (Block).
                        //
                        pCDB->CDB10.LogicalBlockByte0 = (UCHAR) 0;
                        pCDB->CDB10.LogicalBlockByte1 = (UCHAR) 0;
                        pCDB->CDB10.LogicalBlockByte2 = (UCHAR) 0;
                        pCDB->CDB10.LogicalBlockByte3 = (UCHAR) 0;

                        pCDB->CDB10.TransferBlocksMsb = (UCHAR) 0;
                        pCDB->CDB10.TransferBlocksLsb = (UCHAR) 1;

                        SrbExtension->RebuildSourceId = Srb->TargetId;
                        status = EnqueueSrb(DeviceExtension,Srb);
                        break;
                    }
				    case IOC_GET_CONTROLLER_INFO:
                    {
						PCONTROLLER_DATA pContrInfo = (PCONTROLLER_DATA) 
									 (((PSRB_BUFFER)Srb->DataBuffer)->caDataBuffer);

						// get DeviceExtension for all controllers
						PHW_DEVICE_EXTENSION HwDeviceExtension = gaCardInfo[0].pDE;	

						// index - is being used for the controller index
						long index=0;

						while( HwDeviceExtension )
						{
							pContrInfo->Info[index].ControllerId = (USHORT)HwDeviceExtension->ucControllerId; 
							pContrInfo->Info[index].PrimaryBaseAddress = (ULONG)HwDeviceExtension->BaseIoAddress1[0];
							pContrInfo->Info[index].PrimaryControlAddress = (ULONG)HwDeviceExtension->BaseIoAddress2[0]; 
							pContrInfo->Info[index].SecondaryBaseAddress = (ULONG)HwDeviceExtension->BaseIoAddress1[1]; 
							pContrInfo->Info[index].SecondaryControllAddress = (ULONG)HwDeviceExtension->BaseIoAddress2[1]; 
							pContrInfo->Info[index].BusMasterBaseAddress = (ULONG)HwDeviceExtension->BaseBmAddress[0];
							pContrInfo->Info[index].IRQ = (USHORT)HwDeviceExtension->ulIntLine; 
							pContrInfo->Info[index].FwVersion.MajorVer=gFwVersion.MajorVer; // Info is filled in InitIdeRaidControllers
							pContrInfo->Info[index].FwVersion.MinorVer=gFwVersion.MinorVer; // Info is filled in InitIdeRaidControllers
							pContrInfo->Info[index].FwVersion.Build=gFwVersion.Build; // Info is filled in InitIdeRaidControllers......... Build doesn't know about this

							pContrInfo->Info[index].ChipsetInfo.VendorID=(USHORT)gaCardInfo[index].ulVendorId;
							pContrInfo->Info[index].ChipsetInfo.DeviceID=(USHORT)gaCardInfo[index].ulDeviceId;

                            pContrInfo->Info[index].ChipsetInfo.PciBus=(UCHAR)gaCardInfo[index].ucPCIBus;
                            pContrInfo->Info[index].ChipsetInfo.PciDevice=(UCHAR)gaCardInfo[index].ucPCIDev;
                            pContrInfo->Info[index].ChipsetInfo.PciFunction=(UCHAR)gaCardInfo[index].ucPCIFun;

							index++;

							HwDeviceExtension=gaCardInfo[index].pDE; // get next controller

							if( index >= MAX_CONTROLLERS )
								break;
						}
						pContrInfo->ControllerCount = index;
                        status = SRB_STATUS_SUCCESS;
                        break;
                    }
				    case IOC_GET_SPAREPOOL_INFO:
                    {

						PSPAREPOOL_DATA pSpareInfo = (PSPAREPOOL_DATA) 
									 (((PSRB_BUFFER)Srb->DataBuffer)->caDataBuffer);

						// get DeviceExtension for all controllers
						PHW_DEVICE_EXTENSION HwDeviceExtension = gaCardInfo[0].pDE;	

						// index - is being used for the controller index
						long drvIndex,ulTemp,index=0,spareInd;

						while( HwDeviceExtension ) {

							for(drvIndex=0;drvIndex< ( MAX_DRIVES_PER_CONTROLLER ) ;drvIndex++) {
						
								if( HwDeviceExtension->IsSpareDrive[drvIndex] ) {
						
                                    pSpareInfo->Info[index].ulMode = SpareDrivePool;

									spareInd = pSpareInfo->Info[index].ulTotDriveCnt;

									for(ulTemp=0;ulTemp<PHYSICAL_DRIVE_MODEL_LENGTH;ulTemp+=2) {

										pSpareInfo->Info[index].phyDrives[spareInd].sModelInfo[ulTemp] = 
													   ((UCHAR *)HwDeviceExtension->FullIdentifyData[drvIndex].ModelNumber)[ulTemp+1];

										pSpareInfo->Info[index].phyDrives[spareInd].sModelInfo[ulTemp+1] = 
													   ((UCHAR *)HwDeviceExtension->FullIdentifyData[drvIndex].ModelNumber)[ulTemp];
									}

									pSpareInfo->Info[index].phyDrives[spareInd].sModelInfo[PHYSICAL_DRIVE_MODEL_LENGTH - 1] = '\0';

									for(ulTemp=0;ulTemp<PHYSICAL_DRIVE_SERIAL_NO_LENGTH;ulTemp+=2) {

										pSpareInfo->Info[index].phyDrives[spareInd].caSerialNumber[ulTemp] = 
													   ((UCHAR *)HwDeviceExtension->FullIdentifyData[drvIndex].SerialNumber)[ulTemp+1];

										pSpareInfo->Info[index].phyDrives[spareInd].caSerialNumber[ulTemp+1] = 
													   ((UCHAR *)HwDeviceExtension->FullIdentifyData[drvIndex].SerialNumber)[ulTemp];
									}

									pSpareInfo->Info[index].phyDrives[spareInd].caSerialNumber[PHYSICAL_DRIVE_SERIAL_NO_LENGTH - 1] = '\0';

                                    // Begin Vasu - 7 March 2001
                                    // Connection ID must be System Wide. Not Controller Specific.
                                    // Reported by Audrius
									pSpareInfo->Info[index].phyDrives[spareInd].cChannelID = (UCHAR)TARGET_ID_2_CONNECTION_ID((drvIndex + (index * MAX_DRIVES_PER_CONTROLLER)));
                                    // End Vasu
									
                                    pSpareInfo->Info[index].phyDrives[spareInd].TransferMode = HwDeviceExtension->TransferMode[drvIndex];

									pSpareInfo->Info[index].phyDrives[spareInd].ulPhySize           = HwDeviceExtension->PhysicalDrive[drvIndex].OriginalSectors / 2; // In KB
									pSpareInfo->Info[index].phyDrives[spareInd].ucIsPhyDrvPresent   = TRUE;

									if ( DeviceExtension->PhysicalDrive[drvIndex].TimeOutErrorCount < MAX_TIME_OUT_ERROR_COUNT )
    									pSpareInfo->Info[index].phyDrives[spareInd].ucIsPowerConnected  = TRUE;

									if ( DeviceExtension->TransferMode[drvIndex] >= UdmaMode3 )
										pSpareInfo->Info[index].phyDrives[spareInd].ucIs80PinCable      = TRUE;

									pSpareInfo->Info[index].phyDrives[spareInd].ulBaseAddress1 = (ULONG)HwDeviceExtension->BaseIoAddress1[drvIndex>>1];
									pSpareInfo->Info[index].phyDrives[spareInd].ulAltAddress2 = (ULONG)HwDeviceExtension->BaseIoAddress2[drvIndex>>1];
									pSpareInfo->Info[index].phyDrives[spareInd].ulbmAddress = (ULONG)HwDeviceExtension->BaseBmAddress[drvIndex>>1];
									pSpareInfo->Info[index].phyDrives[spareInd].ulIrq = HwDeviceExtension->ulIntLine;

									pSpareInfo->Info[index].ulTotDriveCnt++;

								}


							}


							index++;
							HwDeviceExtension=gaCardInfo[index].pDE; // get next controller

							if( index >= MAX_CONTROLLERS )
								break;

						}

						pSpareInfo->ControllerCount=index;
                        status = SRB_STATUS_SUCCESS;
                        break;
                    }
				    case IOC_GET_VERSION:
					{

						PIDE_VERSION pVersion = (PIDE_VERSION) 
									 (((PSRB_BUFFER)Srb->DataBuffer)->caDataBuffer);

						// return's driver version
						
						pVersion->MajorVer = HYPERDSK_MAJOR_VERSION;
						pVersion->MinorVer = HYPERDSK_MINOR_VERSION;
						pVersion->Build = HYPERDSK_BUILD_VERSION;

                        status = SRB_STATUS_SUCCESS;
                        break;
                    }
				    case IOC_LOCK_UNLOCK_IRCD_EX:
                    {

                        PLOCK_UNLOCK_DATA_EX pLockUnlockData = 
                            (PLOCK_UNLOCK_DATA_EX) (((PSRB_BUFFER) Srb->DataBuffer)->caDataBuffer);

					    ULONG ulTimeOut;

						// don't know what to do with timeout value, 
						// still need to implement this??
                        pLockUnlockData->ulUnlockKey = LockIRCD(DeviceExtension,
                                                                pLockUnlockData->uchLock,
                                                                pLockUnlockData->ulUnlockKey);

						if ( MAX_UNLOCK_TIME == pLockUnlockData->ulTimeOut )
                        {
                            gbDoNotUnlockIRCD = TRUE;
                        }

                        status = SRB_STATUS_SUCCESS;

                        break;
                    }
                    case IOC_GET_RAID_INFO:
                    {
                        status = (UCHAR) FillRaidInfo(DeviceExtension, Srb);
                        break;
                    }
                    case IOC_GET_STATUS:
                    {
                        status = (UCHAR) GetStatusChangeFlag(DeviceExtension, Srb);
                        break;
                    }
                    case IOC_GET_ERROR_LOG:
                    {
                        ULONG ulStartSector;
                        PERROR_LOG_REPORT pInOutInfo = (PERROR_LOG_REPORT) 
                            (((PSRB_BUFFER)Srb->DataBuffer)->caDataBuffer + 2);
                        
                        BOOLEAN bIsNewOnly = (BOOLEAN)pInOutInfo->IsNewOnly;
                        USHORT  usNumError = pInOutInfo->Offset;

                        // Begin Vasu - 14 Aug 2000
                        // Code from Syam's Update - Added
                        if (DRIVE_IS_UNUSABLE_STATE((pInOutInfo->DriveId)) || 
                            (!DRIVE_PRESENT((pInOutInfo->DriveId))))
                        {
                            // This drive may be a drive that responding 
                            // even when power is not there
                            SrbExtension->ucOriginalId = Srb->TargetId;
		                    DebugPrint((1, "Failed Drive.... so failing command \n"));
                            status = SRB_STATUS_ERROR;
		                    break;
                        }
                        // End Vasu.

                        Srb->TargetId = pInOutInfo->DriveId;

                        // if no new error
                        if (bIsNewOnly && 
                            (DeviceExtension->PhysicalDrive[Srb->TargetId].ErrorReported == 
                                DeviceExtension->PhysicalDrive[Srb->TargetId].ErrorFound))
                        {
                            pInOutInfo->DriveId = Srb->TargetId;  // the id user filled
                            pInOutInfo->Count = 0;
                            pInOutInfo->IsMore = FALSE;
                            pInOutInfo->IsNewOnly = bIsNewOnly;
                            pInOutInfo->Offset = usNumError;

                            Srb->TargetId = ucOriginalId;   // the id OS filled

                            status = SRB_STATUS_SUCCESS;
                            break;
                        }

                        ulStartSector = DeviceExtension->PhysicalDrive[Srb->TargetId].ErrorLogSectorIndex;
                        //
                        // Set the Transfer Length and Starting Transfer Sector (Block).
                        //
                        pCDB->CDB10.LogicalBlockByte0 = (UCHAR) (ulStartSector >> 24);
                        pCDB->CDB10.LogicalBlockByte1 = (UCHAR) (ulStartSector >> 16);
                        pCDB->CDB10.LogicalBlockByte2 = (UCHAR) (ulStartSector >> 8);
                        pCDB->CDB10.LogicalBlockByte3 = (UCHAR) (ulStartSector);

                        pCDB->CDB10.TransferBlocksMsb = (UCHAR) 0;
                        pCDB->CDB10.TransferBlocksLsb = (UCHAR) 1;

                        SrbExtension->IsNewOnly = bIsNewOnly;
                        SrbExtension->usNumError = usNumError;

                        SrbExtension->ucOpCode = ucOpCode;
                        SrbExtension->RebuildSourceId = Srb->TargetId;
                        SrbExtension->ucOriginalId = ucOriginalId;
                        status = EnqueueSrb(DeviceExtension, Srb);

                        break;
                    }
                    case IOC_ERASE_ERROR_LOG:
                    {
                        ULONG ulStartSector;
                        PERASE_ERROR_LOG peel = (PERASE_ERROR_LOG)
                            (((PSRB_BUFFER)Srb->DataBuffer)->caDataBuffer);

                        if ( !IS_IDE_DRIVE((peel->DriveId)) ) 
                        {
                            Srb->TargetId = ucOriginalId;   // the ID OS Filled
                            status = SRB_STATUS_SUCCESS;
                            break;
                        }

                        // Begin Vasu - 14 Aug 2000
                        // Code from Syam's Update - Added
                        if (DRIVE_IS_UNUSABLE_STATE((peel->DriveId)) || 
                            (!DRIVE_PRESENT((peel->DriveId))))
                        {
                            // This drive may be a drive that responding 
                            // even when power is not there
                            SrbExtension->ucOriginalId = Srb->TargetId;
		                    DebugPrint((1, "Failed Drive.... so failing command \n"));
                            status = SRB_STATUS_ERROR;
		                    break;
                        }
                        // End Vasu.

                        Srb->TargetId = peel->DriveId;

                        ulStartSector = DeviceExtension->PhysicalDrive[Srb->TargetId].ErrorLogSectorIndex;

                        //
                        // Set the Transfer Length and Starting Transfer Sector (Block).
                        //
                        pCDB->CDB10.LogicalBlockByte0 = (UCHAR) (ulStartSector >> 24);
                        pCDB->CDB10.LogicalBlockByte1 = (UCHAR) (ulStartSector >> 16);
                        pCDB->CDB10.LogicalBlockByte2 = (UCHAR) (ulStartSector >> 8);
                        pCDB->CDB10.LogicalBlockByte3 = (UCHAR) (ulStartSector);

                        pCDB->CDB10.TransferBlocksMsb = (UCHAR) 0;
                        pCDB->CDB10.TransferBlocksLsb = (UCHAR) 1;

                        SrbExtension->RebuildSourceId = Srb->TargetId;
                        SrbExtension->IsWritePending = TRUE;
                        SrbExtension->ucOpCode = ucOpCode;
                        SrbExtension->usNumError = (USHORT) peel->Count;
                        SrbExtension->ucOriginalId = ucOriginalId;
                        status = EnqueueSrb(DeviceExtension, Srb);


                        break;
                    }
                    case IOC_LOCK_UNLOCK_IRCD:
                    {
                        PLOCK_UNLOCK_DATA pLockUnlockData = 
                            (PLOCK_UNLOCK_DATA) (((PSRB_BUFFER) Srb->DataBuffer)->caDataBuffer);

                        pLockUnlockData->ulUnlockKey = LockIRCD(DeviceExtension,
                                                                pLockUnlockData->uchLock,
                                                                pLockUnlockData->ulUnlockKey);

                        status = SRB_STATUS_SUCCESS;

                        break;
                    }
                    case IOC_GET_IRCD:
                    case IOC_SET_IRCD:
                    {
                        ULONG ulStartSector;
                        PIRCD_DATA pIrcdData = (PIRCD_DATA)
                            (((PSRB_BUFFER)Srb->DataBuffer)->caDataBuffer);

                        // Begin Vasu - 14 Aug 2000
                        // Code from Syam's Update - Added
                        if (DRIVE_IS_UNUSABLE_STATE((pIrcdData->uchTargetID)) || 
                            (!DRIVE_PRESENT((pIrcdData->uchTargetID))))
                        {
                            // This drive may be a drive that responding 
                            // even when power is not there
                            SrbExtension->ucOriginalId = Srb->TargetId;
		                    DebugPrint((1, "Failed Drive.... so failing command \n"));
                            status = SRB_STATUS_ERROR;
		                    break;
                        }
                        // End Vasu.

                        Srb->TargetId = pIrcdData->uchTargetID;

                        ulStartSector = DeviceExtension->PhysicalDrive[Srb->TargetId].IrcdSectorIndex;

                        if ( !ulStartSector )
                        {
                            // There is no IRCD for this drive.... so fail this request
                            Srb->TargetId = ucOriginalId;      // the ID OS Filled
                            status = SRB_STATUS_ERROR;
                            break;
                        }

                        //
                        // Set the Transfer Length and Starting Transfer Sector (Block).
                        //
                        pCDB->CDB10.LogicalBlockByte0 = (UCHAR) (ulStartSector >> 24);
                        pCDB->CDB10.LogicalBlockByte1 = (UCHAR) (ulStartSector >> 16);
                        pCDB->CDB10.LogicalBlockByte2 = (UCHAR) (ulStartSector >> 8);
                        pCDB->CDB10.LogicalBlockByte3 = (UCHAR) (ulStartSector);

                        pCDB->CDB10.TransferBlocksMsb = (UCHAR) 0;
                        pCDB->CDB10.TransferBlocksLsb = (UCHAR) 1;

                        SrbExtension->RebuildSourceId = Srb->TargetId;
                        SrbExtension->ucOpCode = ucOpCode;
                        SrbExtension->ucOriginalId = ucOriginalId;
                        status = EnqueueSrb(DeviceExtension, Srb);
                        break;
                    }
                    case IOC_GET_SECTOR_DATA:
                    {
                        ULONG ulStartSector;
                        PSECTOR_DATA pSectorData = (PSECTOR_DATA)(((PSRB_BUFFER)Srb->DataBuffer)->caDataBuffer);

                        // Begin Vasu - 22 Aug 2000
                        // Code from Syam's Update - Added to Get Sector Data also.
                        if (DRIVE_IS_UNUSABLE_STATE((pSectorData->uchTargetID)) || 
                            (!DRIVE_PRESENT((pSectorData->uchTargetID))))
                        {
                            SrbExtension->ucOriginalId = Srb->TargetId;
		                    DebugPrint((1, "Failed Drive.... so failing command \n"));
                            status = SRB_STATUS_ERROR;
		                    break;
                        }
                        // End Vasu.

                        Srb->TargetId = pSectorData->uchTargetID;

                        ulStartSector = (ULONG) (pSectorData->caDataBuffer[0]);

                        //
                        // Set the Transfer Length and Starting Transfer Sector (Block).
                        //
                        pCDB->CDB10.LogicalBlockByte0 = (UCHAR) (ulStartSector >> 24);
                        pCDB->CDB10.LogicalBlockByte1 = (UCHAR) (ulStartSector >> 16);
                        pCDB->CDB10.LogicalBlockByte2 = (UCHAR) (ulStartSector >> 8);
                        pCDB->CDB10.LogicalBlockByte3 = (UCHAR) (ulStartSector);

                        pCDB->CDB10.TransferBlocksMsb = (UCHAR) 0;
                        pCDB->CDB10.TransferBlocksLsb = (UCHAR) 1;

                        SrbExtension->ucOpCode = ucOpCode;
                        SrbExtension->ucOriginalId = ucOriginalId;
                        status = EnqueueSrb(DeviceExtension, Srb);
                        break;
                    }
                    case IOC_SET_DRIVE_STATUS:
                    {
                        PSET_LOGICAL_DRIVE_STATUS pLogDrvStatus = (PSET_LOGICAL_DRIVE_STATUS) 
                            (((PSRB_BUFFER)Srb->DataBuffer)->caDataBuffer);

                        SetLogicalDriveStatus (DeviceExtension,
                                               pLogDrvStatus->ucLogDrvId,
                                               pLogDrvStatus->ucPhyDrvId,
                                               pLogDrvStatus->ucLogDrvStatus,
                                               pLogDrvStatus->ucPhyDrvStatus,
                                               pLogDrvStatus->ucFlags);
                        status = SRB_STATUS_SUCCESS;
                        break;
                    }
                    case IOC_CHANGE_MIRROR_DRIVE_STATUS:
                    {
                        PCHANGE_MIRROR_DRIVE_STATUS pMirrorDrvStatus = (PCHANGE_MIRROR_DRIVE_STATUS)
                            (((PSRB_BUFFER)Srb->DataBuffer)->caDataBuffer);

                        ChangeMirrorDriveStatus (DeviceExtension,
                                                 pMirrorDrvStatus->ucLogDrvId,
                                                 pMirrorDrvStatus->ucPhyDrvId,
                                                 pMirrorDrvStatus->ucPhyDrvStatus);
                        status = SRB_STATUS_SUCCESS;
                        break;
                    }
                    case IOC_CHANGE_MIRROR_DRIVE_ID:
                    {
                        PCHANGE_MIRROR_DRIVE pMirrorDrv = (PCHANGE_MIRROR_DRIVE)
                            (((PSRB_BUFFER)Srb->DataBuffer)->caDataBuffer);

                            ChangeMirrorDrive (DeviceExtension,
                                               pMirrorDrv->ucLogDrvId,
                                               pMirrorDrv->ucBadPhyDrvId,
                                               pMirrorDrv->ucGoodPhyDrvId);
                            status = SRB_STATUS_SUCCESS;
                        break;
                    }
                    case IOC_GET_CAPACITY:
                    {
                        status = (UCHAR) GetRAIDDriveCapacity(DeviceExtension, Srb);
                        break;
                    }
                    case IOC_REBUILD:
                    {
                        // This is our internal Request... So let us call the function to Enqueue the request
                        // Let us store the information of the Rebuild Target Id
                        PREBUILD_CONSISTENCY_CHECK prcc = (PREBUILD_CONSISTENCY_CHECK)
                            (((PSRB_BUFFER)Srb->DataBuffer)->caDataBuffer);

                        UCHAR ucTargetId = prcc->uchTargetID;

                        Srb->TargetId = prcc->uchSourceID;

                        SrbExtension->RebuildSourceId = Srb->TargetId;
                        SrbExtension->IsWritePending = TRUE;
                        SrbExtension->ucOpCode = ucOpCode;
                        SrbExtension->RebuildTargetId = ucTargetId;
                        SrbExtension->ucOriginalId = ucOriginalId;      
                        status = EnqueueSrb(DeviceExtension, Srb);
                    }
                    break;
                    case IOC_SET_CONSISTENCY_STATUS:
                    {
                        PSRB_IO_CONTROL pSrb = (PSRB_IO_CONTROL)(Srb->DataBuffer);
                        PSET_CONSISTENCY_STATUS pConsistencyStatus = (PSET_CONSISTENCY_STATUS) 
                            (((PSRB_BUFFER) Srb->DataBuffer)->caDataBuffer);

                        if ( AtapiStringCmp( 
                                    pSrb->Signature, 
                                    IDE_RAID_SIGNATURE,
                                    strlen(IDE_RAID_SIGNATURE))) 
                        {
                            status = SRB_STATUS_ERROR;
                            break;
                        }

                        if ((pConsistencyStatus->uchPhysicalDriveOne >= MAX_DRIVES_PER_CONTROLLER) ||
                            (pConsistencyStatus->uchPhysicalDriveTwo >= MAX_DRIVES_PER_CONTROLLER))
                        {
                            status = SRB_STATUS_ERROR;
                            break;
                        }

                        DeviceExtension->PhysicalDrive[pConsistencyStatus->uchPhysicalDriveOne].ConsistencyOn = 
                            pConsistencyStatus->uchConsistencyCheckFlag;
                        DeviceExtension->PhysicalDrive[pConsistencyStatus->uchPhysicalDriveTwo].ConsistencyOn = 
                            pConsistencyStatus->uchConsistencyCheckFlag;

                        status = SRB_STATUS_SUCCESS;

                        break;
                    }
                    case IOC_CONSISTENCY_CHECK:
                    {
                        // This is our internal Request... So let us call the function to Enqueue the request
                        // Let us store the information
                        PREBUILD_CONSISTENCY_CHECK prcc = (PREBUILD_CONSISTENCY_CHECK)
                            (((PSRB_BUFFER)Srb->DataBuffer)->caDataBuffer);

                        UCHAR ucTargetId = prcc->uchTargetID;

                        Srb->TargetId = prcc->uchSourceID;

                        SrbExtension->RebuildSourceId = Srb->TargetId;
                        SrbExtension->ucOpCode = ucOpCode;
                        SrbExtension->RebuildTargetId = ucTargetId;
                        SrbExtension->ucOriginalId = ucOriginalId;      

                        EnqueueConsistancySrb(DeviceExtension, Srb);

                        status = SRB_STATUS_PENDING;
                        break;
                    }
                    case IOC_GET_DEVICE_FLAGS:
                    {
                        ULONG ulControllerInd;
                        PHW_DEVICE_EXTENSION pDE;
                        PUCHAR pucBuffer;

                        pucBuffer = (PUCHAR)((PSRB_BUFFER)(Srb->DataBuffer))->caDataBuffer;
                        for(ulControllerInd=0;ulControllerInd<gucControllerCount;ulControllerInd++)
                        {
                            pDE = gaCardInfo[ulControllerInd].pDE;
                            AtapiMemCpy(    pucBuffer,
                                            (PUCHAR)(pDE->DeviceFlags),
                                            (sizeof(ULONG) * MAX_DRIVES_PER_CONTROLLER)
                                        );
                            pucBuffer += (sizeof(ULONG) * MAX_DRIVES_PER_CONTROLLER);
                        }
                        status = SRB_STATUS_SUCCESS;
                        break;
                    }
                    case IOC_REMOVE_DRIVE_FROM_SPARE:
                    {
                        PREMOVE_DRIVE_FROM_SPARE prdfs = (PREMOVE_DRIVE_FROM_SPARE)
                            (((PSRB_BUFFER) Srb->DataBuffer)->caDataBuffer);

                        if (! IS_IDE_DRIVE(prdfs->uchPhysicalDriveTid))
                        {
                            status = SRB_STATUS_ERROR;
                            break;
                        }

                        DeviceExtension->IsSpareDrive[prdfs->uchPhysicalDriveTid] = FALSE;
                        status = SRB_STATUS_SUCCESS;
                        break;
                    }
                    case IOC_EXECUTE_SMART_COMMAND:
                    {
                        UCHAR uchPostSMARTCmd = 0;
                        PSRB_IO_CONTROL pSrb = (PSRB_IO_CONTROL)(Srb->DataBuffer);
                        PSMART_DATA pSD = (PSMART_DATA) 
                            (((PSRB_BUFFER) Srb->DataBuffer)->caDataBuffer);

                        if ( AtapiStringCmp( 
                                    pSrb->Signature, 
                                    IDE_RAID_SIGNATURE,
                                    strlen(IDE_RAID_SIGNATURE))) 
                        {
                            status = SRB_STATUS_ERROR;
                            break;
                        }

                        // Check for SMART Capability in the Specified Drive
                        if (!((DeviceExtension->FullIdentifyData[pSD->uchTargetID].CmdSupported1) & 0x01))
                        {
                            pSD->uchCommand = HD_SMART_ERROR_NOT_SUPPORTED;
                            // Begin Vasu - 23 Aug 2000
							// Changing Status from SRB_STATUS_INVALID_REQUEST to SRB_STATUS_ERROR
							// so that the call is getting completed.
							status = SRB_STATUS_ERROR;
							// End Vasu
                            break;
                        }

                        switch (pSD->uchCommand)
                        {
                        case HD_SMART_ENABLE:
                            if (((DeviceExtension->FullIdentifyData[pSD->uchTargetID].CmdEnabled1) & 0x01))
                            {
                                pSD->uchCommand = HD_SMART_ERROR_ENABLED;
                                status = SRB_STATUS_SUCCESS;
                                break;
                            }
                            uchPostSMARTCmd = 1;
                            break;
                        case HD_SMART_DISABLE:
                            if (!((DeviceExtension->FullIdentifyData[pSD->uchTargetID].CmdEnabled1) & 0x01))
                            {
                                pSD->uchCommand = HD_SMART_ERROR_DISABLED;
                                status = SRB_STATUS_SUCCESS;
                                break;
                            }
                            uchPostSMARTCmd = 1;
                            break;
                        case HD_SMART_RETURN_STATUS:
                        case HD_SMART_READ_DATA:
                            if (!((DeviceExtension->FullIdentifyData[pSD->uchTargetID].CmdEnabled1) & 0x01))
                            {
                                pSD->uchCommand = HD_SMART_ERROR_DISABLED;
                                status = SRB_STATUS_ERROR;
                                break;
                            }
                            uchPostSMARTCmd = 1;
                            break;
                        default:
                            status = SRB_STATUS_ERROR;
                            break;
                        }

                        // Post the Command to the drives only when SMART is 
                        // present and enabled.
                        if (uchPostSMARTCmd)
                        {
                        Srb->TargetId = pSD->uchTargetID;

                        SrbExtension->ucOpCode = ucOpCode;
                        SrbExtension->ucOriginalId = ucOriginalId;

                        status = EnqueueSMARTSrb(DeviceExtension, Srb);
                        }

                        break;
                    }
                // End Vasu
                    default:
                    {
                        Srb->TargetId = ucOriginalId;
                        status = SRB_STATUS_ERROR;
                        break;
                    }
                }
            }
            break;
		default:
		   DebugPrint((1,
			  "IdeSendCommand: Unsupported command %x\n",
			  Srb->Cdb[0]));

		   status = SRB_STATUS_INVALID_REQUEST;

	} // end switch
	return status;
} // end IdeSendCommand()

SRBSTATUS
EnqueueSMARTSrb(
	IN PHW_DEVICE_EXTENSION DeviceExtension,
	IN PSCSI_REQUEST_BLOCK Srb
)
{
	PSRB_EXTENSION SrbExtension;
	BOOLEAN success;
    PUCHAR  pucCurBufPtr;
    ULONG ulCurLength;
	PPHYSICAL_DRIVE_DATA Pdd;
    SRBSTATUS status = SRB_STATUS_PENDING;
    PSMART_DATA pSD = (PSMART_DATA) 
        (((PSRB_BUFFER) Srb->DataBuffer)->caDataBuffer);

	DebugPrint((3, "\nEnqueueSMARTSrb: Entering routine.\n"));

	if (DeviceExtension->PendingSrbs >= DeviceExtension->ucMaxPendingSrbs) 
    {
		return SRB_STATUS_BUSY;
	}

	//
	// Initializations.
	//

	success = TRUE;

	SrbExtension = Srb->SrbExtension;

	// Get pointer to the only Pdd we need.
	Pdd = &(SrbExtension->PhysicalDriveData[0]);

	// Save TID.
	Pdd->TargetId = Srb->TargetId;

	// Save pointer to SRB.
	Pdd->OriginalSrb = Srb;

	// Set number of Pdds.
	SrbExtension->NumberOfPdds = 1;

    Pdd->ulStartSglInd = SrbExtension->ulSglInsertionIndex;

    pucCurBufPtr = Srb->DataBuffer;
    
    // Hmmmm... the bug of forming improper SGLs when the transfer length > MAX_IDE_XFER_LENGTH 
    // has to be fixed here also... reproducable through IOMeter

    ulCurLength = 512;

	//
	// Use PIO.
	// Build S/G list using logical addresses.
	//
	success = BuildSgls(    DeviceExtension,
                            Srb,
                            SrbExtension->aSglEntry, &(SrbExtension->ulSglInsertionIndex), 
                            pucCurBufPtr, ulCurLength,
                            FALSE);

	if (!success) 
    {
		return SRB_STATUS_ERROR;
	}

    Pdd->ulSglCount = SrbExtension->ulSglInsertionIndex - Pdd->ulStartSglInd;

    // Store the SMART Command value here itself.
    DeviceExtension->uchSMARTCommand = pSD->uchCommand;

	EnqueuePdd(DeviceExtension, Srb, Pdd);

    return status;
}

SRBSTATUS
EnqueueSrb(
	IN PHW_DEVICE_EXTENSION DeviceExtension,
	IN PSCSI_REQUEST_BLOCK Srb
)

/*++

Routine Description:

	This function enqueues an SRB into the proper SINGLE device
	queue.

	Steps:

	1. Check if there's room for this request.
	2. Fill in Pdd.
	3. Build S/G list.
	4. Save SRB address in general list for use on abort request.
	5. Enqueue Pdd to device's work queue.

	DO NOT CALL THIS FUNCTION FOR LOGICAL DEVICES SRBs.

Arguments:

	DeviceExtension		Pointer to the device extension area for the HBA.
	Srb					Pointer to the SCSI request block.

Return Value:

	SRB_STATUS_INVALID_REQUEST	Could not build the S/G list.
	SRB_STATUS_PENDING			The Srb will cause an interrupt.
	SRB_STATUS_ERROR			Internal miniport error.
	SRB_STATUS_BUSY				Non more requests can be accepted
								(should not happen - internal error!)

--*/
{
	PPHYSICAL_DRIVE_DATA Pdd;
	USHORT sectorsRequested;
	PSRB_EXTENSION SrbExtension;
	ULONG startSector;
	SRBSTATUS status;
	BOOLEAN success, bISUdma;
    UCHAR uchRebuildTargetId;
    PUCHAR  pucCurBufPtr;
    ULONG ulBufLength, ulMaxIdeXferLength, ulCurLength;

	DebugPrint((3, "\nEnqueueSrb: Entering routine.\n"));

    if (DeviceExtension->PendingSrbs >= DeviceExtension->ucMaxPendingSrbs) 
    {
		return SRB_STATUS_BUSY;
	}

    if ( SCSIOP_VERIFY == Srb->Cdb[0] )
    {
        return EnqueueVerifySrb(DeviceExtension, Srb);
    }

    //
	// Initializations.
	//

	success = TRUE;

	SrbExtension = Srb->SrbExtension;

	sectorsRequested = GET_SECTOR_COUNT(Srb);

	startSector = GET_START_SECTOR(Srb);

	if ((sectorsRequested + startSector) > DeviceExtension->PhysicalDrive[Srb->TargetId].Sectors) {
        if ( ( ! (DeviceExtension->DeviceFlags[Srb->TargetId] & DFLAGS_ATAPI_DEVICE) ) && ( SCSIOP_INTERNAL_COMMAND != Srb->Cdb[0] ) )
            // Not sure about concept of Sectors in Atapi Device
            // so let me not checkup that for Atapi Devices.
            // Putting this checking outside of this if Condition will give an extra over head to the
            // IDE Drives
		    return SRB_STATUS_INVALID_REQUEST;
	}

	// Get pointer to the only Pdd we need.
	Pdd = &(SrbExtension->PhysicalDriveData[0]);

	// Save TID.
	Pdd->TargetId = Srb->TargetId;

	// Save start sector number.
	Pdd->ulStartSector = startSector;

	// Save pointer to SRB.
	Pdd->OriginalSrb = Srb;

	// Set number of Pdds.
	SrbExtension->NumberOfPdds = 1;

    Pdd->ulStartSglInd = SrbExtension->ulSglInsertionIndex;

    if ( ( SCSIOP_INTERNAL_COMMAND == Srb->Cdb[0] ) && ( IOC_PASS_THRU_COMMAND == SrbExtension->ucOpCode ) )
    {   // At this moment only the Pass Thru command will come like this...
        PPASS_THRU_DATA pPassThruData = (PPASS_THRU_DATA)(((PSRB_BUFFER)Srb->DataBuffer)->caDataBuffer);

        pucCurBufPtr = pPassThruData->aucBuffer;
        ulBufLength = pPassThruData->ulSize;
    }
    else
    {
        pucCurBufPtr = Srb->DataBuffer;
        ulBufLength = sectorsRequested * IDE_SECTOR_SIZE;
    }
    
    ulMaxIdeXferLength = MAX_SECTORS_PER_IDE_TRANSFER * IDE_SECTOR_SIZE;

	if ( (USES_DMA(Srb->TargetId)) && (Srb->Cdb[0] != SCSIOP_VERIFY) )
    {
        if ( SCSIOP_INTERNAL_COMMAND == Srb->Cdb[0] )
        {
            if ( IOC_PASS_THRU_COMMAND == SrbExtension->ucOpCode )
            {
                PPASS_THRU_DATA pPassThruData = (PPASS_THRU_DATA)(((PSRB_BUFFER)Srb->DataBuffer)->caDataBuffer);
                if ( !pPassThruData->bIsPIO )
                {
                    bISUdma = TRUE;
                }
                else
                {
                    bISUdma = FALSE;
                }

            }
            else
            {
                bISUdma = TRUE;
            }
        }
        else
        {
            bISUdma = TRUE;
        }
    }
    else
    {
        bISUdma = FALSE;
    }

    // Hmmmm... the bug of forming improper SGLs when the transfer length > MAX_IDE_XFER_LENGTH 
    // has to be fixed here also... reproducable through IOMeter

    while ( ulBufLength )
    {
        ulCurLength = (ulBufLength>ulMaxIdeXferLength)?ulMaxIdeXferLength:ulBufLength;

		//
		// Use DMA.
		// Build S/G list using physical addresses.
		//

		success = BuildSgls(    DeviceExtension,
                                Srb,
                                SrbExtension->aSglEntry, &(SrbExtension->ulSglInsertionIndex), 
                                pucCurBufPtr, ulCurLength,
                                bISUdma);

        pucCurBufPtr += ulCurLength;
        ulBufLength -= ulCurLength;

	    if (!success) 
        {

		    return SRB_STATUS_ERROR;
	    }
    }


    Pdd->ulSglCount = SrbExtension->ulSglInsertionIndex - Pdd->ulStartSglInd;

	EnqueuePdd(DeviceExtension, Srb, Pdd);

	status = SRB_STATUS_PENDING;

	return(status);

} // end EnqueueSrb();

SRBSTATUS
EnqueueConsistancySrb(
	IN PHW_DEVICE_EXTENSION DeviceExtension,
	IN PSCSI_REQUEST_BLOCK Srb
)
/*++

Routine Description:

	This function enqueues an SRB into the proper SINGLE device
	queue.

	Steps:

	1. Check if there's room for this request.
	2. Fill in Pdd.
	3. Build S/G list.
	4. Save SRB address in general list for use on abort request.
	5. Enqueue Pdd to device's work queue.

	DO NOT CALL THIS FUNCTION FOR LOGICAL DEVICES SRBs.

Arguments:

	DeviceExtension		Pointer to the device extension area for the HBA.
	Srb					Pointer to the SCSI request block.

Return Value:

	SRB_STATUS_INVALID_REQUEST	Could not build the S/G list.
	SRB_STATUS_PENDING			The Srb will cause an interrupt.
	SRB_STATUS_ERROR			Internal miniport error.
	SRB_STATUS_BUSY				Non more requests can be accepted
								(should not happen - internal error!)

--*/
{
	ULONG maxTransferLength, ulStartPrbInd;
	PPHYSICAL_DRIVE_DATA Pdd;
	USHORT sectorsRequested;
	PSRB_EXTENSION SrbExtension;
	ULONG startSector;
	SRBSTATUS status;
	BOOLEAN success;
    UCHAR uchRebuildTargetId, i;
    ULONG ulTargetId;

	DebugPrint((3, "\nEnqueueSrb: Entering routine.\n"));

    if (DeviceExtension->PendingSrbs >= DeviceExtension->ucMaxPendingSrbs) 
    {

		return SRB_STATUS_BUSY;
	}

	//
	// Initializations.
	//

	success = TRUE;

	SrbExtension = Srb->SrbExtension;

    sectorsRequested = GET_SECTOR_COUNT(Srb);

	startSector = GET_START_SECTOR(Srb);

	if ((sectorsRequested + startSector) > DeviceExtension->PhysicalDrive[Srb->TargetId].Sectors) {
        if ( ( ! (DeviceExtension->DeviceFlags[Srb->TargetId] & DFLAGS_ATAPI_DEVICE) ) && ( SCSIOP_INTERNAL_COMMAND != Srb->Cdb[0] ) )
            // Not sure about concept of Sectors in Atapi Device
            // so let me not checkup that for Atapi Devices.
            // Putting this checking outside of this if Condition will give an extra over head to the
            // IDE Drives
		    return SRB_STATUS_INVALID_REQUEST;
	}

	// Set number of Pdds.
	SrbExtension->NumberOfPdds = 2;

    for(i=0;i<2;i++)
    {
        PUCHAR DataBuffer;

	    // Get pointer to the only Pdd we need.
	    Pdd = &(SrbExtension->PhysicalDriveData[i]);

        if ( 0 == i )
        {
	        // Save TID.
	        Pdd->TargetId = SrbExtension->RebuildSourceId;
        }
        else
        {
	        // Save TID.
	        Pdd->TargetId = SrbExtension->RebuildTargetId;
        }

        ulTargetId = Pdd->TargetId;

	    // Save start sector number.
	    Pdd->ulStartSector = startSector;

	    // Save pointer to SRB.
	    Pdd->OriginalSrb = Srb;

	    maxTransferLength = DeviceExtension->PhysicalDrive[ulTargetId].MaxTransferLength;

        DataBuffer = 
            ((PUCHAR) Srb->DataBuffer) + (i * sectorsRequested * DeviceExtension->PhysicalDrive[ulTargetId].SectorSize);

        Pdd->ulStartSglInd = ((PSRB_EXTENSION)Pdd->OriginalSrb->SrbExtension)->ulSglInsertionIndex;

	    if (USES_DMA(ulTargetId) ) {
		    //
		    // Use DMA.
		    // Build S/G list using physical addresses.
		    //

		    success = BuildSgls(    DeviceExtension,
                                    Srb,
                                    SrbExtension->aSglEntry, &(SrbExtension->ulSglInsertionIndex), 
                                    Srb->DataBuffer, sectorsRequested * IDE_SECTOR_SIZE,
                                    TRUE);
	    } else {
		    //
		    // Use PIO.
		    // Build S/G list using logical addresses.
		    //
		    success = BuildSgls(    DeviceExtension,
                                    Srb,
                                    SrbExtension->aSglEntry, &(SrbExtension->ulSglInsertionIndex), 
                                    Srb->DataBuffer, sectorsRequested * IDE_SECTOR_SIZE,
                                    FALSE);
        }
	    if (!success) {

		    return SRB_STATUS_ERROR;
	    }

        Pdd->ulSglCount = SrbExtension->ulSglInsertionIndex - Pdd->ulStartSglInd;

    }

    ulStartPrbInd = SrbExtension->ulPrbInsertionIndex;
    ExportSglsToPrbs(DeviceExtension, &(SrbExtension->PhysicalDriveData[0]), (PSRB_EXTENSION)Pdd->OriginalSrb->SrbExtension);
    ExportSglsToPrbs(DeviceExtension, &(SrbExtension->PhysicalDriveData[1]), (PSRB_EXTENSION)Pdd->OriginalSrb->SrbExtension);
    Pdd->ulStartPrbInd = ulStartPrbInd;

	status = SRB_STATUS_PENDING;

	return(status);

} // end EnqueueConsistencySrb();

SRBSTATUS
SplitSrb(
	IN PHW_DEVICE_EXTENSION DeviceExtension,
	IN PSCSI_REQUEST_BLOCK Srb
)
{
    ULONG ulTargetId = Srb->TargetId;
    ULONG ulStripesPerRow, ulCurStripe, ulRaidMemberNumber;
    PSRB_EXTENSION pSrbExtension = (PSRB_EXTENSION)Srb->SrbExtension;
    ULONG ulLogDrvId;
    PPHYSICAL_DRIVE_DATA pMirrorPdd, Pdd;
    ULONG ulBufChunks, ulBufChunkInd;
    BOOLEAN success, bISUdma;
    UCHAR ucMirrorDriveId;

    if ( SCSIOP_VERIFY == Srb->Cdb[0] )
    {
        return EnqueueVerifySrb(DeviceExtension, Srb);
    }

    if ( SRB_STATUS_SUCCESS != SplitBuffers(DeviceExtension, Srb) )
    {   // may be the request is not a valid one
		return(SRB_STATUS_INVALID_REQUEST);
    }

	//
	// Initializations.
	//
    ulLogDrvId = Srb->TargetId;
    ulStripesPerRow = DeviceExtension->LogicalDrive[ulLogDrvId].StripesPerRow;
	pSrbExtension = Srb->SrbExtension;

	//
	// Enqueue the Pdds just filled in.
	//

	for (ulRaidMemberNumber = 0; ulRaidMemberNumber < ulStripesPerRow; ulRaidMemberNumber++) 
    {

		Pdd = &(pSrbExtension->PhysicalDriveData[ulRaidMemberNumber]);

		//
		// Check is this Pdd has been filled in.
		//

		if ( Pdd->ulBufChunkCount )
        {
            ulTargetId = Pdd->TargetId;
            ulBufChunks = Pdd->ulBufChunkCount;
            Pdd->ulStartSglInd = pSrbExtension->ulSglInsertionIndex;

	        if (USES_DMA(ulTargetId) && ((Srb->Cdb[0] == SCSIOP_READ) || (Srb->Cdb[0] == SCSIOP_WRITE) || (SCSIOP_INTERNAL_COMMAND == Srb->Cdb[0] ) )) 
            {
                bISUdma = TRUE;
            }
            else
            {
                bISUdma = FALSE;
            }

            for(ulBufChunkInd=0;ulBufChunkInd<ulBufChunks;ulBufChunkInd++)
            {
		        //
		        // Use DMA.
		        // Build S/G list using physical addresses.
		        //
		        success = BuildSgls(    DeviceExtension,
                                        Srb,
                                        pSrbExtension->aSglEntry, 
                                        &(pSrbExtension->ulSglInsertionIndex), 
                                        Pdd->aBufChunks[ulBufChunkInd].pucBufPtr, 
                                        Pdd->aBufChunks[ulBufChunkInd].ulBufLength,
                                        bISUdma);

	            if (!success) 
                {
		            return SRB_STATUS_ERROR;
	            }
            }

            Pdd->ulSglCount = pSrbExtension->ulSglInsertionIndex - Pdd->ulStartSglInd;

			ucMirrorDriveId = DeviceExtension->PhysicalDrive[ulTargetId].ucMirrorDriveId;

			if (!IS_DRIVE_OFFLINE(ucMirrorDriveId)) 
            {   // mirror drive exists
                // Have a duplicate copy if SCSIOP_VERIFY / (SCSIOP_WRITE and the drive is not in rebuilding)
                // if the drive is in rebuilding state then the SCSIOP_WRITE command will be queued in TryToCompleteSrb
                switch (Srb->Cdb[0])
                {
                    case SCSIOP_WRITE:
                    {
                        {
                            ULONG ulPrbCount, ulPrbInd;
                            PPHYSICAL_REQUEST_BLOCK pPrb, pOriginalPrb;

                            // Enqueue Original Pdd
                            EnqueuePdd(DeviceExtension, Srb, Pdd);

                            // Make a duplicate Pdd
                            pMirrorPdd = &(pSrbExtension->PhysicalDriveData[ulRaidMemberNumber + ulStripesPerRow]);
                            pSrbExtension->NumberOfPdds++;
                            AtapiMemCpy((PUCHAR)pMirrorPdd, (PUCHAR)Pdd, sizeof(PHYSICAL_DRIVE_DATA));

                            pMirrorPdd->ulStartPrbInd = pSrbExtension->ulPrbInsertionIndex;
                            pMirrorPdd->TargetId = ucMirrorDriveId;
                            ulPrbCount = pMirrorPdd->ulPrbCount;

                            pOriginalPrb = &(pSrbExtension->Prb[Pdd->ulStartPrbInd]);
                            pPrb = &(pSrbExtension->Prb[pMirrorPdd->ulStartPrbInd]);
                            // Copy Prbs created for this Pdd
                            AtapiMemCpy((PUCHAR)pPrb, (PUCHAR)pOriginalPrb, (sizeof(PHYSICAL_REQUEST_BLOCK) * ulPrbCount) );
                            // Increment SRBExtension Ptrs
                            pSrbExtension->ulPrbInsertionIndex += ulPrbCount;

                            // Export all Pdds of mirror Drive to the physical Drive
                            for(ulPrbInd=0;ulPrbInd<ulPrbCount;ulPrbInd++)
                            {
                                pPrb[ulPrbInd].pPdd = pMirrorPdd;
                                ExportPrbToPhysicalDrive(  DeviceExtension, 
                                                            &(pPrb[ulPrbInd]), 
                                                            ucMirrorDriveId
                                                            );
                            }
                            continue;   // Go for the Next PDD
                        }
                        case SCSIOP_READ:
                        {
                            if ( PDS_Rebuilding == DeviceExtension->PhysicalDrive[ucMirrorDriveId].Status )
                                break;

                            if (Raid10 == DeviceExtension->LogicalDrive[Srb->TargetId].RaidLevel)
                                // for Raid10 there will not be any concept of load balancing... we 
                                // did the optimal configuration of the drives that are to be taken for reading
                                break;

                            if (DeviceExtension->PhysicalDrive[ulTargetId].QueueingFlag == 0) 
                            {	// fill into queue0
                                // if queue 0 is full and queue 1 is about empty, switch queue flag to 1
                                if ((DeviceExtension->PhysicalDrive[ulTargetId].ucCommandCount  >= DeviceExtension->ucOptMaxQueueSize) &&
                                (DeviceExtension->PhysicalDrive[ucMirrorDriveId].ucCommandCount  <= DeviceExtension->ucOptMinQueueSize)) 
                                {
                                    DeviceExtension->PhysicalDrive[ulTargetId].QueueingFlag = 1;
                                    DeviceExtension->PhysicalDrive[ucMirrorDriveId].QueueingFlag = 0;
                                }
                            } 
                            else 
                            { // fill into queue 1
                                // if queue 1 is full and queue 0 is about empty, switch queue flag to 0
                                if ((DeviceExtension->PhysicalDrive[ucMirrorDriveId].ucCommandCount  >= DeviceExtension->ucOptMaxQueueSize) &&
                                (DeviceExtension->PhysicalDrive[ulTargetId].ucCommandCount  <= DeviceExtension->ucOptMinQueueSize)) 
                                {
                                    DeviceExtension->PhysicalDrive[ulTargetId].QueueingFlag = 0;
                                    DeviceExtension->PhysicalDrive[ucMirrorDriveId].QueueingFlag = 1;
                                }
                                Pdd->TargetId = ucMirrorDriveId;
                            }

                        }
                        break;
                    }
			    } // mirror drive exists
            }

			//
			// Add Pdd to the drive queue.
			//
			EnqueuePdd(DeviceExtension, Srb, Pdd);
        } // if ( Pdd->ulBufChunkCount )
    } // for all stripes per row

	return(SRB_STATUS_PENDING);
} // end of SplitSrb()


SRBSTATUS
EnqueuePdd(
	IN PHW_DEVICE_EXTENSION DeviceExtension,
	IN PSCSI_REQUEST_BLOCK Srb,
	IN PPHYSICAL_DRIVE_DATA Pdd
)

/*++

Routine Description:

	This function enqueues 'Pdd' on the appropriate
	device queue, sorted by ascending start sector number.

Arguments:

	DeviceExtension		Pointer to miniport instance.
	Srb					Pointer to the SRB that was split into Pdds.
	Pdd					Pointer to a Pdd that's part of 'Srb'

Return Value:

	SRB_STATUS_PENDING		Success.
	SRB_INVALID_REQUEST		Could not build S/G list.

--*/
{

    if ( ExportSglsToPrbs(DeviceExtension, Pdd, (PSRB_EXTENSION)Pdd->OriginalSrb->SrbExtension) )
        return(SRB_STATUS_PENDING);
    else
        return(SRB_STATUS_ERROR);

} // end EnqueuePdd()

SRBSTATUS
SplitBuffers(
	IN PHW_DEVICE_EXTENSION DeviceExtension,
	IN PSCSI_REQUEST_BLOCK Srb
)
{
    ULONG ulLogDrvId, ulStripesPerRow;
    PSRB_EXTENSION pSrbExtension;
    PPHYSICAL_DRIVE_DATA Pdd;
    ULONG ulSectorsRequested;
    ULONG ulSectorsPerStripe, ulStartSector;
    ULONG ulEndStripeNumber, ulCurrentStripeNumber;
    ULONG ulRaidMemberNumber, ulSectorsToProcess, ulLogicalSectorStartAddress;
    ULONG ulTempStartSector, ulEndAddressOfcurrentStripe;
    PUCHAR pucBuffer, pucCurBufPtr;
    ULONG ulMaxIdeXferLength, ulBufLength, ulCurLength;


	//
	// Initializations.
	//
    ulLogDrvId = Srb->TargetId;
    ulStripesPerRow = DeviceExtension->LogicalDrive[ulLogDrvId].StripesPerRow;
	pSrbExtension = Srb->SrbExtension;

	//
	// the drive failed 
	//      RAID0:    one or both drives failed
	//		RAID1/10: one or more pair of mirroring drives failed
	//
	if (LDS_OffLine == DeviceExtension->LogicalDrive[ulLogDrvId].Status) {
		return(SRB_STATUS_ERROR);
	}

	ulSectorsRequested = GET_SECTOR_COUNT(Srb);

	ulStartSector = GET_START_SECTOR(Srb);

#ifdef KEEP_LOG
    if ( ulStartLog )
    {
        CommandLog[ulStartInd].ulCmd = (ULONG)Srb->Cdb[0];
        CommandLog[ulStartInd].ulStartSector = ulStartSector;
        CommandLog[ulStartInd].ulSectorCount = ulSectorsRequested;
        ulStartInd = (ulStartInd + 1 ) % MAX_LOG_COUNT;;
    }
#endif

	if ((ulSectorsRequested + ulStartSector) > DeviceExtension->LogicalDrive[ulLogDrvId].Sectors) {

		return(SRB_STATUS_INVALID_REQUEST);
	}

	ulSectorsPerStripe = DeviceExtension->LogicalDrive[ulLogDrvId].StripeSize;
	ulStripesPerRow = DeviceExtension->LogicalDrive[ulLogDrvId].StripesPerRow;

	//
	// Get the logical stripe number for the end sector.
	//

	ulEndStripeNumber = (ulStartSector + ulSectorsRequested - 1) / ulSectorsPerStripe;
	
	//
	// Get the logical stripe number for the start sector.
	//

	ulCurrentStripeNumber = ulStartSector / ulSectorsPerStripe;
	
	//
	// Get the address of the first logical sector.
	//

	ulLogicalSectorStartAddress = ulStartSector;
	
	ulMaxIdeXferLength = MAX_SECTORS_PER_IDE_TRANSFER * IDE_SECTOR_SIZE;

	pucBuffer = Srb->DataBuffer;

	//
	// While there are still sectors to be processed...
	//

	while (ulSectorsRequested != 0) 
    {
		ulEndAddressOfcurrentStripe = ((ulCurrentStripeNumber+1) * ulSectorsPerStripe) - 1;

		if (ulCurrentStripeNumber != ulEndStripeNumber) {

			ulSectorsToProcess =
				(USHORT)(ulEndAddressOfcurrentStripe - ulLogicalSectorStartAddress + 1);

		} else {

			ulSectorsToProcess = ulSectorsRequested;
		}

		//
		// Calculate the number of the RAID member that will handle this stripe.
		//

		ulRaidMemberNumber = (UCHAR)(ulCurrentStripeNumber % (ULONG)ulStripesPerRow);

		//
		// Get pointer to Pdd.
		//

		Pdd = &pSrbExtension->PhysicalDriveData[ulRaidMemberNumber];

        //
		// Start sector to be read/written in the physical drive.
		//

		ulTempStartSector = ((ulCurrentStripeNumber / ulStripesPerRow) *  ulSectorsPerStripe ) + 
			(ulLogicalSectorStartAddress - (ulCurrentStripeNumber * ulSectorsPerStripe));


        if ( !Pdd->ulBufChunkCount )
        {
			//Save start sector address.
			Pdd->ulStartSector = ulTempStartSector;

			// Save TID.
            //
            // Get TID of physical drive that will handle this stripe.
            //
			Pdd->TargetId = (UCHAR)DeviceExtension->LogicalDrive[ulLogDrvId].PhysicalDriveTid[ulRaidMemberNumber];

			// Save pointer to SRB.
			Pdd->OriginalSrb = Srb;

			// Update number of Pdds into which the SRB has been split.
			pSrbExtension->NumberOfPdds++;
        }

        // Split the buf chunks so that we can send them in a single transfer
        // if we don't do this we will be in the trouble of giving incorrect buffer
        // length since sometimes the scatter gather list elements will be split 
        // in such a way that forces the ExportSglsToPrbs function 
        // to split the sgls to non multiples of IDE_SECTOR_SIZE
		//
		// pucBuffer offset in the Srb->DataBuffer.
		//
        pucCurBufPtr = &(pucBuffer[((ulLogicalSectorStartAddress - ulStartSector) * IDE_SECTOR_SIZE)]);
        ulBufLength = ulSectorsToProcess * IDE_SECTOR_SIZE;

        while ( ulBufLength )
        {
            ulCurLength = (ulBufLength>ulMaxIdeXferLength)?ulMaxIdeXferLength:ulBufLength;
            Pdd->aBufChunks[Pdd->ulBufChunkCount].pucBufPtr     = pucCurBufPtr;
            Pdd->aBufChunks[Pdd->ulBufChunkCount++].ulBufLength = ulCurLength;
            pucCurBufPtr += ulCurLength;
            ulBufLength -= ulCurLength;
        }


		//
		// Increment ulLogicalSectorStartAddress and ulCurrentStripeNumber.
		//

		ulLogicalSectorStartAddress = ulEndAddressOfcurrentStripe + 1;
		ulCurrentStripeNumber++;

		//
		// Decrement the number of sectors left.
		//

		ulSectorsRequested -= ulSectorsToProcess;	

	}

    return SRB_STATUS_SUCCESS;
}


BOOLEAN
BuildSgls
(
	IN PHW_DEVICE_EXTENSION DeviceExtension,
    IN PSCSI_REQUEST_BLOCK Srb,
    IN PSGL_ENTRY pSglEntry,
	IN PULONG pulCurSglInd,
    IN PUCHAR pucBuffer,
	IN ULONG ulLength,
    IN BOOLEAN bPhysical
)
{
    ULONG ulCurLength = ulLength;
    ULONG ulTempLength, ulLengthLeftInBoundary;
    ULONG ulContiguousMemoryLength;
    ULONG physicalAddress;
    ULONG ulSglInsertionIndex = *pulCurSglInd;
    PSRB_BUFFER pSrbBuffer = (PSRB_BUFFER)pucBuffer;
    UCHAR ucSrbTargetId = 0;
#ifdef DBG
    BOOLEAN bPrintDetails = FALSE;
#endif

    if (SCSIOP_INTERNAL_COMMAND == Srb->Cdb[0]) 
    {
        if ( IOC_PASS_THRU_COMMAND != ((PSRB_IO_CONTROL) Srb->DataBuffer)->ControlCode )    
            // for pass thru command it is not necessary to adjust the pointer ... caller will take care of this
            pucBuffer = ((PUCHAR) pSrbBuffer->caDataBuffer) + 2;
    }

    if ( !bPhysical )   // This is logical... so each contiguous virtual address will become one Sgl
    {
        pSglEntry[*pulCurSglInd].Logical.Address = pucBuffer;
        pSglEntry[*pulCurSglInd].Logical.Length = ulLength;
        *pulCurSglInd = *pulCurSglInd + 1;
        return TRUE;
    }

    // so this needs Physical Addresses
	do 
    {
        //
	    // Get physical address and length of contiguous
	    // physical buffer.
        //
        
        if (SCSIOP_INTERNAL_COMMAND == Srb->Cdb[0])
        {
            ucSrbTargetId = Srb->TargetId;
            Srb->TargetId = ((PSRB_EXTENSION) (Srb->SrbExtension))->ucOriginalId;
        }

        physicalAddress = ScsiPortConvertPhysicalAddressToUlong(
	                		ScsiPortGetPhysicalAddress(
							DeviceExtension,
	                        Srb,
	                        pucBuffer,
	                        &ulContiguousMemoryLength));

        if (SCSIOP_INTERNAL_COMMAND == Srb->Cdb[0])
        {
            Srb->TargetId = ucSrbTargetId;
        }

		if (physicalAddress == 0) {

			return(FALSE);
		}

#if DBG
	
		if (bPrintDetails) {

			DebugPrint((4, "-------------physicalAddress = %lxh\n", physicalAddress));
			DebugPrint((4, "------contiguousMemoryLength = %lxh\n", ulContiguousMemoryLength));
		}
#endif
	
		while (ulContiguousMemoryLength > 0 && ulCurLength > 0) {

			ulLength = ulContiguousMemoryLength;	  

#if DBG
			if (bPrintDetails) {

				DebugPrint((3, "---1------------------length = %lxh\n", ulLength));
			}
#endif
			//
			// Make sure that the physical region does not cross 64KB boundary.
			//

	    	ulLengthLeftInBoundary = REGION_HW_BOUNDARY -
									((ULONG)physicalAddress & (REGION_HW_BOUNDARY - 1));

			if (ulLength > (ULONG)ulLengthLeftInBoundary) {
				ulLength = ulLengthLeftInBoundary;
			}

#if DBG
			if (bPrintDetails) {

				DebugPrint((3, "---2------------------length = %lxh\n", ulLength));
			}
#endif

			//
		    // If length of physical memory is more
		    // than bytes left in transfer, use bytes
		    // left as final length.
		    //
	
		    if  (ulLength > ulCurLength) {
		        ulLength = ulCurLength;
		    }
#if DBG
	
			if (bPrintDetails) {

				DebugPrint((3, "---3------------------length = %lxh\n", ulLength));
			}
#endif
		
			// DWORD alignment check.
		    ASSERT(((ULONG)physicalAddress & 3) == 0);

#if DBG
	
			if (bPrintDetails) {

				DebugPrint((
						3,
						"--------------------&sgl[%ld] = %lxh\n",
						ulSglInsertionIndex,
						&(pSglEntry[ulSglInsertionIndex])
						));
			}

#endif

            if (physicalAddress & 0x01)
            {
                return FALSE;
            }

		    pSglEntry[ulSglInsertionIndex].Physical.Address = (PVOID)physicalAddress;
		    // Begin Parag, Vasu - 7 March 2001
			// Do not typecast this to USHORT as a 64K length will make it zero.
			// pSglEntry[ulSglInsertionIndex].Physical.Length = ulLength;
            // Vasu - This has been taken care now in ExportSglsToPrbs.
            // This assignment will make the left side 0 which is still taken care
            // at the ExportSglsToPrbs.
			pSglEntry[ulSglInsertionIndex].Physical.Length = (USHORT) ulLength;
			// End Parag, Vasu

		    //
		    // Adjust Counts and Pointers.
		    // 

		    pucBuffer = (PUCHAR)pucBuffer + ulLength;
		    ulContiguousMemoryLength -= ulLength;
		    ulCurLength -= ulLength;  
		    physicalAddress += ulLength;
		    ulSglInsertionIndex++;
		    
			//
		    // Check for SGL not too big.
			//

		    if (ulSglInsertionIndex >= MAX_SGL_ENTRIES_PER_SRB) {
		        return FALSE;
			}
		}
	
	} while (ulCurLength != 0);

    *pulCurSglInd = ulSglInsertionIndex;

    return TRUE;
}


VOID
DiscardResidualData(
	IN PATAPI_REGISTERS_1 BaseIoAddress
)

{
	LONG i;
	UCHAR statusByte;

	for (i = 0; i < 0x10000; i++) {
	
		GET_BASE_STATUS(BaseIoAddress, statusByte);
	
   		if (statusByte & IDE_STATUS_DRQ) {

      		WAIT_ON_BASE_BUSY(BaseIoAddress, statusByte);
	
			ScsiPortReadPortUshort(&BaseIoAddress->Data);
	
	    } else {
	
	    	break;
	    }
	}
	
	return;

} // end DiscardResidualData()

BOOLEAN
ExportSglsToPrbs(
            IN PHW_DEVICE_EXTENSION DeviceExtension,
            IN PPHYSICAL_DRIVE_DATA Pdd,
            IN PSRB_EXTENSION pSrbExtension
            )
{
	PSGL_ENTRY pSglEntry;
    ULONG ulMaxIdeXferLength, ulCurPrbInsInd, ulSglInd, ulCurXferLength, ulSglParts;
    ULONG ulSglCount, ulPrbInd;
    PPHYSICAL_REQUEST_BLOCK pPrb;
    UCHAR ucCmd;

	ulMaxIdeXferLength = MAX_SECTORS_PER_IDE_TRANSFER * IDE_SECTOR_SIZE;
	pSglEntry = &(pSrbExtension->aSglEntry[Pdd->ulStartSglInd]);
    pPrb = &(pSrbExtension->Prb[pSrbExtension->ulPrbInsertionIndex]);
    Pdd->ulStartPrbInd = pSrbExtension->ulPrbInsertionIndex;
    ulSglCount = Pdd->ulSglCount;
    ucCmd = Pdd->OriginalSrb->Cdb[0];

    if ( SCSIOP_INTERNAL_COMMAND == ucCmd )
    {
        switch ( pSrbExtension->ucOpCode )
        {
            case IOC_GET_ERROR_LOG:
                ucCmd = SCSIOP_READ;    // Just Read
                break;
            case IOC_ERASE_ERROR_LOG:   // Read and then write
                ucCmd = SCSIOP_READ;
                break;
            case IOC_GET_IRCD:          // Just Read
            case IOC_GET_SECTOR_DATA:
                ucCmd = SCSIOP_READ;
                break;
            case IOC_SET_IRCD:          // Just Write
                ucCmd = SCSIOP_WRITE;
                break;
            case IOC_REBUILD:           // Read and then Write
                ucCmd = SCSIOP_READ;
                break;
            case IOC_CONSISTENCY_CHECK:
                ucCmd = SCSIOP_READ;
                break;
            case IOC_EXECUTE_SMART_COMMAND:
                ucCmd = SCSIOP_EXECUTE_SMART_COMMAND;
                break;
            default:
                  // remaining Internal Commands will not come into this path
                  // nothing to be done
                break;
        }
    }


    // Begin Vasu - 21 January 2001
    // Code rewrite for Exporting SGLs to PRBs.
	ulCurPrbInsInd = 0;
    ulSglInd = 0;

    do
    {
        ulCurXferLength = 0;
        pPrb[ulCurPrbInsInd].ulVirtualAddress = (ULONG)(&pSglEntry[ulSglInd]);
        pPrb[ulCurPrbInsInd].ulSglCount = 0;

        while ( (ulCurXferLength < ulMaxIdeXferLength) &&
                (ulSglInd < ulSglCount) )
        {
            // Begin Vasu - 7 March 2001
            // Send 64K if SGL Entry has 0 in it.
            // SGL Entry should be 0 for 64K transfers. But for our calculation we
            // need 64K and not 0.
            // ulCurXferLength += pSglEntry[ulSglInd].Physical.Length;
            ulCurXferLength += 
                (pSglEntry[ulSglInd].Physical.Length ? 
                pSglEntry[ulSglInd].Physical.Length :
                REGION_HW_BOUNDARY);    // Return 64K
            // End Vasu
            pPrb[ulCurPrbInsInd].ulSglCount++;
            ulSglInd++;

        }

        if (ulCurXferLength > ulMaxIdeXferLength)
        {
            // Go back to prev. SGL Index to take that into account
            ulSglInd--;
            // if greater, then we must remove the last SGL Entry.
            // Vasu - 27 March 2001 - Missed this one on 7th.
            ulCurXferLength -= 
                (pSglEntry[ulSglInd].Physical.Length ? 
                pSglEntry[ulSglInd].Physical.Length :
                REGION_HW_BOUNDARY);    // Return 64K
            pPrb[ulCurPrbInsInd].ulSglCount--;
        }

        // Complete This PRB.
        pPrb[ulCurPrbInsInd].ucCmd = ucCmd;
        pPrb[ulCurPrbInsInd].pPdd = Pdd;
        pPrb[ulCurPrbInsInd].pSrbExtension = pSrbExtension;

        if ( (SCSIOP_INTERNAL_COMMAND == ucCmd) && (IOC_PASS_THRU_COMMAND == pSrbExtension->ucOpCode) )
        {
            pPrb[ulCurPrbInsInd].ulSectors = ulCurXferLength;
        }
        else
        {
            pPrb[ulCurPrbInsInd].ulSectors = ulCurXferLength / IDE_SECTOR_SIZE;
        }

        if ( ulCurPrbInsInd )
        {
            pPrb[ulCurPrbInsInd].ulStartSector = 
                pPrb[ulCurPrbInsInd - 1].ulStartSector + 
                pPrb[ulCurPrbInsInd - 1].ulSectors;
        }
        else
        {
            pPrb[ulCurPrbInsInd].ulStartSector = Pdd->ulStartSector;
        }
        
        // Goto Next PRB
        ulCurPrbInsInd ++;

    } while (ulSglInd < ulSglCount);
    // End Vasu

    for(ulPrbInd=0;ulPrbInd<ulCurPrbInsInd;ulPrbInd++)
    {
        ExportPrbToPhysicalDrive(  DeviceExtension, 
                                            &(pPrb[ulPrbInd]), 
                                            Pdd->TargetId
                                         );
    }

	pSrbExtension->ulPrbInsertionIndex += ulCurPrbInsInd;
    Pdd->ulPrbCount = ulCurPrbInsInd;
    Pdd->ulPrbsRemaining = ulCurPrbInsInd;
    DebugPrint((DEFAULT_DISPLAY_VALUE, "ESTP %X", ulCurPrbInsInd));

    return TRUE;
}

BOOLEAN ExportPrbToPhysicalDrive(
	IN PHW_DEVICE_EXTENSION DeviceExtension,
	IN PPHYSICAL_REQUEST_BLOCK pSglpartition,
    IN ULONG ulTargetId
    )
/*++

To be Done
Yet to handle the case of the queue becoming full 

--*/
{
    UCHAR ucSglPartInd, ucHead, ucTail;
    PPHYSICAL_DRIVE pPhysicalDrive = &(DeviceExtension->PhysicalDrive[ulTargetId]);

    // Let us put the Physical Request Block's pointer in Physical Drive Array
    ucHead = DeviceExtension->PhysicalDrive[ulTargetId].ucHead;
    ucTail = DeviceExtension->PhysicalDrive[ulTargetId].ucTail;

    pPhysicalDrive->pPrbList[ucTail] = pSglpartition;
    ucTail = (ucTail + 1) % MAX_NUMBER_OF_PHYSICAL_REQUEST_BLOCKS_PER_DRIVE;
    pPhysicalDrive->ucTail = ucTail;

    pPhysicalDrive->ucCommandCount++;

#ifdef DBG
    if ( pPhysicalDrive->ucCommandCount > MAX_NUMBER_OF_PHYSICAL_REQUEST_BLOCKS_PER_DRIVE )
        STOP;
#endif

    return TRUE;
}


#ifdef DBG
void
PrintPhysicalCommandDetails(PPHYSICAL_COMMAND pPhysicalCommand)
{
    ULONG ulLength = 0, ulSglInd;
    PSGL_ENTRY pSglEntry;

    DebugPrint((3, "TargetId : %ld\tStart : %x\tSecCount : %ld\tStartIndex : %ld\tNumberOfCommand : %ld\n", 
                        (ULONG)pPhysicalCommand->TargetId, 
                        (ULONG)pPhysicalCommand->ulStartSector,
                        (ULONG)pPhysicalCommand->ulCount,
                        (ULONG)pPhysicalCommand->ucStartInd,
                        (ULONG)pPhysicalCommand->ucCmdCount));

    pSglEntry = (PSGL_ENTRY)pPhysicalCommand->SglBaseVirtualAddress;

    for(ulSglInd=0;ulSglInd<pPhysicalCommand->ulTotSglCount;ulSglInd++)
    {
        DebugPrint((3,"%x:%ld:%ld\n", 
                                (ULONG)pSglEntry[ulSglInd].Physical.Address, 
                                (ULONG)pSglEntry[ulSglInd].Physical.Length,
                                (ULONG)pSglEntry[ulSglInd].Physical.EndOfListFlag));
        ulLength += pSglEntry[ulSglInd].Physical.Length;
        if ( pSglEntry[ulSglInd].Physical.EndOfListFlag )
        {
            break;
        }
    }

    DebugPrint((3, "Total Xfer Length : %ld\n", ulLength));

#ifdef DBG
    if ( ( (pPhysicalCommand->ulCount * 512) != ulLength ) && ((pPhysicalCommand->ucCmd != SCSIOP_VERIFY) ) )
    {
        STOP;
    }
#endif

}
#endif

BOOLEAN
RemoveSrbFromPendingList(
	IN PHW_DEVICE_EXTENSION DeviceExtension,
	IN PSCSI_REQUEST_BLOCK Srb
)
{

	LONG i;
	BOOLEAN success = FALSE;
    PSRB_EXTENSION SrbExtension = Srb->SrbExtension;

	DebugPrint((3, "\nRemoveSrbFromPendingList: Entering routine.\n"));

    i = SrbExtension->SrbInd;

    DebugPrint((DEFAULT_DISPLAY_VALUE, " RSFB%ld ", i));

    if ( DeviceExtension->PendingSrb[i] != Srb)
    {
		ScsiPortLogError(   DeviceExtension, Srb, Srb->PathId, Srb->TargetId, Srb->Lun, SP_INTERNAL_ADAPTER_ERROR, 
                            HYPERDISK_ERROR_PENDING_SRBS_COUNT);

        success = FALSE;
    }
    else
    {
		DeviceExtension->PendingSrb[i] = NULL;
		DeviceExtension->PendingSrbs--;

        success = TRUE;
    }

	ASSERT(i < DeviceExtension->ucMaxPendingSrbs);

    return(success);

} // end RemoveSrbFromPendingList()

ULONG 
AssignSrbExtension(
    IN PHW_DEVICE_EXTENSION DeviceExtension, 
    IN PSCSI_REQUEST_BLOCK Srb
)
{
    ULONG i = 0;
    PSRB_EXTENSION SrbExtension = NULL;


    for (i = 0; i < DeviceExtension->ucMaxPendingSrbs; i++) 
    {
        if (DeviceExtension->PendingSrb[i] == NULL) 
        {
            break;
        }
    }

    ASSERT( i < DeviceExtension->ucMaxPendingSrbs );

    if ( i < DeviceExtension->ucMaxPendingSrbs ) 
    {

        DebugPrint((3, "AssignSrbExtension: Adding SRB 0x%lx.\n", Srb));

#ifdef HD_ALLOCATE_SRBEXT_SEPERATELY
        
        Srb->SrbExtension = &(DeviceExtension->pSrbExtension[i]);

#endif // HD_ALLOCATE_SRBEXT_SEPERATELY

        SrbExtension = Srb->SrbExtension;

        AtapiFillMemory((PUCHAR)SrbExtension, sizeof(SRB_EXTENSION), 0);

        SrbExtension->SrbInd = (UCHAR)i;

        DeviceExtension->PendingSrb[i] = Srb;

        DeviceExtension->PendingSrbs++;

#ifdef DBG
        if ( DeviceExtension->PendingSrbs > 1 )
            DebugPrint((DEFAULT_DISPLAY_VALUE, " MPS%ld ", DeviceExtension->PendingSrbs));
#endif

        DebugPrint((DEFAULT_DISPLAY_VALUE, " ASE%ld ", i));
    }

    return i;
}


UCHAR FlushCache(PHW_DEVICE_EXTENSION DeviceExtension, UCHAR ucTargetId)
{
    PIDE_REGISTERS_1 baseIoAddress1;
    PIDE_REGISTERS_2 baseIoAddress2;
    UCHAR ucStatus;
    ULONG ulWaitSec;

    baseIoAddress1 = DeviceExtension->BaseIoAddress1[(ucTargetId>>1)];
    baseIoAddress2 = DeviceExtension->BaseIoAddress2[(ucTargetId>>1)];

    SELECT_DEVICE(baseIoAddress1, ucTargetId);
    WAIT_ON_ALTERNATE_STATUS_BUSY(baseIoAddress2, ucStatus);
    SELECT_DEVICE(baseIoAddress1, ucTargetId);
    ScsiPortWritePortUchar(&baseIoAddress1->Command, IDE_COMMAND_FLUSH_CACHE);

    // IDE Specs says this command can take more than most 30 Seconds
    // so we are awaiting one minute
    for(ulWaitSec=0;ulWaitSec<60;ulWaitSec++)
    {
        WAIT_ON_ALTERNATE_STATUS_BUSY(baseIoAddress2, ucStatus);    

        if ( !(ucStatus & IDE_STATUS_BUSY) )
            break;

        if ( ucStatus & IDE_STATUS_ERROR )  // there is no meaning waiting more time when error occured.
        {
            break;
        }
    }

    GET_STATUS(baseIoAddress1, ucStatus);  // Read the Base Status this will clear interrupt raised if any

    return ucStatus;
}

UCHAR DisableRWBCache(PHW_DEVICE_EXTENSION DeviceExtension, UCHAR ucTargetId)
{
    PIDE_REGISTERS_1 baseIoAddress1;
    PIDE_REGISTERS_2 baseIoAddress2;
    UCHAR ucStatus;
    ULONG ulWaitSec;

    baseIoAddress1 = DeviceExtension->BaseIoAddress1[(ucTargetId>>1)];
    baseIoAddress2 = DeviceExtension->BaseIoAddress2[(ucTargetId>>1)];

    SELECT_DEVICE(baseIoAddress1, ucTargetId);
    GET_STATUS(baseIoAddress1, ucStatus);
	ScsiPortWritePortUchar( (((PUCHAR)baseIoAddress1) + 1), FEATURE_DISABLE_WRITE_CACHE);
	ScsiPortWritePortUchar(&(baseIoAddress1->Command), IDE_COMMAND_SET_FEATURES);
	WAIT_ON_BASE_BUSY(baseIoAddress1, ucStatus);

    SELECT_DEVICE(baseIoAddress1, ucTargetId);
    GET_STATUS(baseIoAddress1, ucStatus);
	ScsiPortWritePortUchar( (((PUCHAR)baseIoAddress1) + 1), FEATURE_DISABLE_READ_CACHE);
	ScsiPortWritePortUchar(&(baseIoAddress1->Command), IDE_COMMAND_SET_FEATURES);
	WAIT_ON_BASE_BUSY(baseIoAddress1, ucStatus);

    return ucStatus;
}

SRBSTATUS
EnqueueVerifySrb
(
	IN PHW_DEVICE_EXTENSION DeviceExtension,
	IN PSCSI_REQUEST_BLOCK Srb
)
{
    ULONG ulStripesPerRow, ulRaidMemberNumber;
    PSRB_EXTENSION pSrbExtension = (PSRB_EXTENSION)Srb->SrbExtension;
    PPHYSICAL_DRIVE_DATA pMirrorPdd, Pdd;
    UCHAR ucMirrorDriveId;

    if ( SRB_STATUS_SUCCESS != SplitVerifyBuffers(DeviceExtension, Srb) )
    {   // may be the request is not a valid one
		return(SRB_STATUS_INVALID_REQUEST);
    }

    if ( DeviceExtension->IsSingleDrive[Srb->TargetId] )
    {
		Pdd = &(pSrbExtension->PhysicalDriveData[0]);
        Pdd->ulStartSglInd = 0;
        Pdd->ulSglCount = 0;
        ExportVerifySglsToPrbs(DeviceExtension, Pdd, pSrbExtension);
        return SRB_STATUS_PENDING;
    }

	//
	// Initializations.
	//
    ulStripesPerRow = DeviceExtension->LogicalDrive[Srb->TargetId].StripesPerRow;
	pSrbExtension = Srb->SrbExtension;

	//
	// Enqueue the Pdds just filled in.
	//
	for (ulRaidMemberNumber = 0; ulRaidMemberNumber < ulStripesPerRow; ulRaidMemberNumber++) 
    {

		Pdd = &(pSrbExtension->PhysicalDriveData[ulRaidMemberNumber]);

		//
		// Check is this Pdd has been filled in.
		//
		if ( Pdd->OriginalSrb == Srb )
        {
            Pdd->ulStartSglInd = 0;
            Pdd->ulSglCount = 0;

            ExportVerifySglsToPrbs(DeviceExtension, Pdd, pSrbExtension);

			ucMirrorDriveId = DeviceExtension->PhysicalDrive[Pdd->TargetId].ucMirrorDriveId;

			if (!IS_DRIVE_OFFLINE(ucMirrorDriveId)) 
            {   // mirror drive exists
                // Have a duplicate copy if SCSIOP_VERIFY / (SCSIOP_WRITE and the drive is not in rebuilding)
                // if the drive is in rebuilding state then the SCSIOP_WRITE command will be queued in TryToCompleteSrb
                pMirrorPdd = &(pSrbExtension->PhysicalDriveData[ulRaidMemberNumber + ulStripesPerRow]);
                pSrbExtension->NumberOfPdds++;
                AtapiMemCpy((PUCHAR)pMirrorPdd, (PUCHAR)Pdd, sizeof(PHYSICAL_DRIVE_DATA));
                pMirrorPdd->TargetId = ucMirrorDriveId;
                ExportVerifySglsToPrbs(DeviceExtension, pMirrorPdd, pSrbExtension);
            }

        } // if ( Pdd->OriginalSrb == Srb )

    } // for all stripes per row

	return(SRB_STATUS_PENDING);
} // end of EnqueueVerifySrb()


SRBSTATUS
SplitVerifyBuffers(
	IN PHW_DEVICE_EXTENSION DeviceExtension,
	IN PSCSI_REQUEST_BLOCK Srb
)
{
    ULONG ulLogDrvId, ulStripesPerRow;
    PSRB_EXTENSION pSrbExtension;
    PPHYSICAL_DRIVE_DATA Pdd;
    ULONG ulSectorsRequested;
    ULONG ulSectorsPerStripe, ulStartSector;
    ULONG ulEndStripeNumber, ulCurrentStripeNumber;
    ULONG ulRaidMemberNumber, ulSectorsToProcess, ulLogicalSectorStartAddress;
    ULONG ulTempStartSector, ulEndAddressOfcurrentStripe;


	//
	// Initializations.
	//
    ulLogDrvId = Srb->TargetId;
    ulStripesPerRow = DeviceExtension->LogicalDrive[ulLogDrvId].StripesPerRow;
	pSrbExtension = Srb->SrbExtension;

	ulSectorsRequested = GET_SECTOR_COUNT(Srb);

	ulStartSector = GET_START_SECTOR(Srb);

    if ( DeviceExtension->IsSingleDrive[ulLogDrvId] )
    {
	    if ((ulSectorsRequested + ulStartSector) > DeviceExtension->PhysicalDrive[ulLogDrvId].Sectors) 
        {
		    return(SRB_STATUS_INVALID_REQUEST);
	    }

		//
		// Get pointer to Pdd.
		//

		Pdd = &(pSrbExtension->PhysicalDriveData[0]);

		//Save start sector address.
		Pdd->ulStartSector = ulStartSector;

        //
        // Get TID of physical drive that will handle this stripe.
        //
		Pdd->TargetId = (UCHAR)ulLogDrvId;

		// Save pointer to SRB.
		Pdd->OriginalSrb = Srb;

		// Update number of Pdds into which the SRB has been split.
		pSrbExtension->NumberOfPdds++;

        // As this command is verify command we will 
        // use only ulsectorcount variable we will not use the BufChunk variables
        Pdd->ulSectorCount = ulSectorsRequested;

        return SRB_STATUS_SUCCESS;
    }

	//
	// the drive failed 
	//      RAID0:    one or both drives failed
	//		RAID1/10: one or more pair of mirroring drives failed
	//
	if (LDS_OffLine == DeviceExtension->LogicalDrive[ulLogDrvId].Status) 
    {
		return(SRB_STATUS_ERROR);
	}

	if ((ulSectorsRequested + ulStartSector) > DeviceExtension->LogicalDrive[ulLogDrvId].Sectors) 
    {
		return(SRB_STATUS_INVALID_REQUEST);
	}

#ifdef DBG
    if ( SCSIOP_VERIFY == Srb->Cdb[0] )
    {
        DebugPrint((0, "Start : %ld\tSecCnt : %ld\t", ulStartSector, ulSectorsRequested));

    }
#endif

	ulSectorsPerStripe = DeviceExtension->LogicalDrive[ulLogDrvId].StripeSize;
	ulStripesPerRow = DeviceExtension->LogicalDrive[ulLogDrvId].StripesPerRow;

	//
	// Get the logical stripe number for the end sector.
	//

	ulEndStripeNumber = (ulStartSector + ulSectorsRequested - 1) / ulSectorsPerStripe;
	
	//
	// Get the logical stripe number for the start sector.
	//

	ulCurrentStripeNumber = ulStartSector / ulSectorsPerStripe;
	
	//
	// Get the address of the first logical sector.
	//

	ulLogicalSectorStartAddress = ulStartSector;
	
	//
	// While there are still sectors to be processed...
	//

	while (ulSectorsRequested != 0) 
    {
		ulEndAddressOfcurrentStripe = ((ulCurrentStripeNumber+1) * ulSectorsPerStripe) - 1;

		if (ulCurrentStripeNumber != ulEndStripeNumber) 
        {
			ulSectorsToProcess =
				(USHORT)(ulEndAddressOfcurrentStripe - ulLogicalSectorStartAddress + 1);

		} 
        else 
        {
			ulSectorsToProcess = ulSectorsRequested;
		}

		//
		// Calculate the number of the RAID member that will handle this stripe.
		//

		ulRaidMemberNumber = (UCHAR)(ulCurrentStripeNumber % (ULONG)ulStripesPerRow);

		//
		// Get pointer to Pdd.
		//

		Pdd = &(pSrbExtension->PhysicalDriveData[ulRaidMemberNumber]);

        //
		// Start sector to be read/written in the physical drive.
		//

		ulTempStartSector = ( ( ulCurrentStripeNumber / ulStripesPerRow ) *  ulSectorsPerStripe ) + 
			( ulLogicalSectorStartAddress - ( ulCurrentStripeNumber * ulSectorsPerStripe ) );


        if ( Pdd->OriginalSrb != Srb )
        {
			//Save start sector address.
			Pdd->ulStartSector = ulTempStartSector;

            //
            // Get TID of physical drive that will handle this stripe.
            //
			Pdd->TargetId = (UCHAR)DeviceExtension->LogicalDrive[ulLogDrvId].PhysicalDriveTid[ulRaidMemberNumber];

			// Save pointer to SRB.
			Pdd->OriginalSrb = Srb;

			// Update number of Pdds into which the SRB has been split.
			pSrbExtension->NumberOfPdds++;

            Pdd->ulSectorCount = 0;
        }
        
        // As this command is verify command we will 
        // use only ulsectorcount variable we will not use the BufChunk variables
        Pdd->ulSectorCount += ulSectorsToProcess;

		//
		// Increment ulLogicalSectorStartAddress and ulCurrentStripeNumber.
		//

		ulLogicalSectorStartAddress = ulEndAddressOfcurrentStripe + 1;
		ulCurrentStripeNumber++;

		//
		// Decrement the number of sectors left.
		//

		ulSectorsRequested -= ulSectorsToProcess;	

	}

    return SRB_STATUS_SUCCESS;
}


BOOLEAN
ExportVerifySglsToPrbs(
            IN PHW_DEVICE_EXTENSION DeviceExtension,
            IN PPHYSICAL_DRIVE_DATA Pdd,
            IN PSRB_EXTENSION pSrbExtension
            )
{
    PPHYSICAL_REQUEST_BLOCK pPrb;

    pPrb = &(pSrbExtension->Prb[pSrbExtension->ulPrbInsertionIndex]);
    Pdd->ulStartPrbInd = pSrbExtension->ulPrbInsertionIndex;

    pPrb->ulVirtualAddress = 0;
    pPrb->ulSglCount = 0;
    pPrb->pPdd = Pdd;
    pPrb->pSrbExtension = pSrbExtension;
    pPrb->ucCmd = Pdd->OriginalSrb->Cdb[0];
    pPrb->ulStartSector = Pdd->ulStartSector;
    pPrb->ulSectors = Pdd->ulSectorCount;

    ExportPrbToPhysicalDrive( DeviceExtension, pPrb, Pdd->TargetId );

	pSrbExtension->ulPrbInsertionIndex += 1;
    Pdd->ulPrbCount = 1;
    Pdd->ulPrbsRemaining = 1;

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\port\scsi\miniport\megaraid\bios.h ===
/*
 ****************************************************************************
 *
 * BIOSPROT.H - Defines constants/structures used Megaraid BIOS to pass
 * PCI configuration information to the firmware
 *
 * Written by Adam Weiner
 *
 */

#ifndef  _INCL_BIOSPROT
#define  _INCL_BIOSPROT

/*
//
// type used to represent the 16-bit bit-packed value that
// represents a PCI device's location. This is the same
// format used by the x86 PCI BIOS specification:
//
//  bits 0..2  = Function Number
//  bits 3..7  = Device Number
//  bits 8..15 = Bus Number
//
*/
#ifndef _DEFINED_PCI_LOCATION
#define  _DEFINED_PCI_LOCATION

typedef USHORT t_pcilocation;

/*
//
// these are macros to extract the various PCI location
// fields from a t_pcilocation
//  
*/
#define  PCI_LOCATION_BUS_NUMBER(pciLocation) (pciLocation>>8)
#define  PCI_LOCATION_DEV_NUMBER(pciLocation) (pciLocation>>3 & 0x1F)
#define  PCI_LOCATION_FUNC_NUMBER(pciLocation) (pciLocation & 0x07)

#endif

/*
// These are the two PCI configuration addresses used in the
// BIOS <-> Firmware startup protocol
//
*/
#define  MEGARAID_PROTOCOL_PORT_0xA0    (0xa0)
#define  MEGARAID_PROTOCOL_PORT_0x64    (0x64)


/*
// These are the possible ID's stored by the firmware in 
// MEGARAID_PROTOCOL_PORT_0xA0 during startup. They are used
// by the BIOS to determine the general class of adapter
*/
#define  MEGARAID_BOOT_ID_TRANSPARENT_BRIDGE_ADAPTER    (0xbbbb)
#define  MEGARAID_BOOT_ID_NON_TRANSPARENT_BRIDGE_ADAPTER  (0x3344)

  

/*
// These are the values moved between the BIOS and the firmware to
// signal the various stages of the protocol
//
*/
#define  BIOS_STARTUP_PROTOCOL_NEXT_STRUCTURE_READY          (0x5555)
#define  BIOS_STARTUP_PROTOCOL_FIRMWARE_DONE_PROCESSING_STRUCTURE  (0xAAAA)
#define  BIOS_STARTUP_PROTOCOL_END_OF_BIOS_STRUCTURES        (0x1122)
#define  BIOS_STARTUP_PROTOCOL_FIRMWARE_DONE_SUCCESFUL        (0x4000)
#define  BIOS_STARTUP_PROTOCOL_FIRMWARE_DONE_PCI_CFG_ERROR      (0x4001)

/*
//
// MEGARAID_BIOS_STARTUP_INFO_HEADER.structureId values
//
*/
#define  MEGARAID_STARTUP_STRUCTYPE_PCI      (0x01)  /* MEGARAID_BIOS_STARTUP_INFO_PCI */

typedef  struct _MEGARAID_BIOS_STARTUP_INFO_HEADER {
  USHORT  structureId;            /* 0x00 - constant describing the type of structure that follows header */
  USHORT  structureRevision;          /* 0x02 - revision of the specific structure type */
  USHORT  structureLength;          /* 0x04 - length of the structure (including this header) */
  USHORT  reserved;              /* 0x06 - reserved */
} MEGARAID_BIOS_STARTUP_INFO_HEADER, *PMEGARAID_BIOS_STARTUP_INFO_HEADER;


/*
//
// structure built by the Megaraid BIOS, containing the
// PCI configuration of the i960 ATU and the SCSI chips
// on the board. The SCSI chips in 'scsiChipInfo[]'
// are guaranteed to be in ascending order of device
// ID
//
*/
#define  MEGARAID_STARTUP_PCI_INFO_STRUCTURE_REVISION  (0)  /* MEGARAID_BIOS_STARTUP_INFO_PCI.h.structureRevision */
#define  COUNT_PCI_BASE_ADDR_REGS      (6)  /* per PCI spec */

typedef struct _MEGARAID_BIOS_STARTUP_INFO_PCI {/* MEGARAID_STARTUP_STRUCTYPE_PCI */

  MEGARAID_BIOS_STARTUP_INFO_HEADER  h;    /* 0x00 - header */
  t_pcilocation  atuPciLocation;        /* 0x08 - PCI location of ATU */
  USHORT      atuSubSysDeviceId;      /* 0x0A - subsystem device ID of the ATU */
  USHORT      scsiChipCount;        /* 0x0C - number of SCSI chips located on this board */
  UCHAR      reserved2[34];        /* 0x0E - reserved for future use */
  struct _MEGARAID_PCI_SCSI_CHIP_INFO {    /* 0x30, 0x60, 0x90, etc... */
    USHORT    vendorId;        /* 0x30 - vendor ID of SCSI chip */
    USHORT    deviceId;        /* 0x32 - device ID of SCSI chip */
    t_pcilocation  pciLocation;      /* 0x34 - PCI location of SCSI CHIP (0..2 = Function #, 3..7 = Device #, 8..15 = Bus #) */
    USHORT    reserved3;      /* 0x36 - reserved/padding */
    ULONG    baseAddrRegs[COUNT_PCI_BASE_ADDR_REGS];  /* 0x38 - base address regsiters (PCI config locations 0x10-0x28) */
    UCHAR    reserved[16];      /* 0x50 - reserved */
  } scsiChipInfo[4];              /* 0x60 */
} MEGARAID_BIOS_STARTUP_INFO_PCI, *PMEGARAID_BIOS_STARTUP_INFO_PCI;


#endif /* #ifndef _INCL_BIOSPROT */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\port\scsi\miniport\megaide\ioctl.c ===
#ifndef _IOCTL_IMPLEMENTATION_
#define _IOCTL_IMPLEMENTATION_

#define     DRIVER_COMPILATION

extern LONG
AtapiStringCmp (
	PCHAR FirstStr,
	PCHAR SecondStr,
	ULONG Count
);

#include "RIIOCtl.h"
#include "ErrorLog.h"
#include "Raid.h"
#include "HyperDisk.h"

#define DRIVER_MAJOR_VERSION        1
#define DRIVER_MINOR_VERSION        1

#define HYPERDSK_MAJOR_VERSION        2
#define HYPERDSK_MINOR_VERSION        5
#define HYPERDSK_BUILD_VERSION        20010328


ULONG
FillRaidInfo(
    IN PHW_DEVICE_EXTENSION DeviceExtension,
    IN PSCSI_REQUEST_BLOCK Srb
)
{
    ULONG ulStatus, ulDriveNum, ulLInd, ulPInd, ulDrvInd, ulTemp, ulOutDrvInd, ulDrvCounter;
    BOOLEAN bFound;
    PSRB_IO_CONTROL pSrb = (PSRB_IO_CONTROL)(Srb->DataBuffer);
    PIDE_RAID_INFO pInOutInfo = (PIDE_RAID_INFO)((PSRB_BUFFER)(Srb->DataBuffer))->caDataBuffer;

    if ( AtapiStringCmp( 
                pSrb->Signature, 
                IDE_RAID_SIGNATURE,
                strlen(IDE_RAID_SIGNATURE))) 
    {
        ulStatus = SRB_STATUS_ERROR;
        goto FillRaidInfoDone;
    }

    ulDriveNum = pInOutInfo->ulTargetId;

    if ( ulDriveNum >= MAX_DRIVES_PER_CONTROLLER )
    {
        ulStatus = SRB_STATUS_ERROR;
        goto FillRaidInfoDone;
    }

    AtapiFillMemory((PCHAR)pInOutInfo, sizeof(IDE_RAID_INFO), 0);

    if ( !DeviceExtension->IsLogicalDrive[ulDriveNum] )
    {
        if ( DeviceExtension->IsSingleDrive[ulDriveNum] )
        {
            pInOutInfo->cMajorVersion       = DRIVER_MAJOR_VERSION;
            pInOutInfo->cMinorVersion       = DRIVER_MINOR_VERSION;
            pInOutInfo->ulDriveSize         = DeviceExtension->PhysicalDrive[ulDriveNum].Sectors / 2;
            pInOutInfo->ulMode              = None;
            pInOutInfo->ulTotalSize         = DeviceExtension->PhysicalDrive[ulDriveNum].Sectors / 2;
            pInOutInfo->ulStripeSize        = 0;
            pInOutInfo->ulStripesPerRow     = 1;
            pInOutInfo->ulTotDriveCnt       = 1;
		    pInOutInfo->ulStatus            = 0;
            pInOutInfo->ulArrayId           = INVALID_ARRAY_ID;
// edm June 8, 2000 start
			pInOutInfo->ulTargetId			= Srb->TargetId;
// edm June 8,, 2000 add
            ulStatus                        = SRB_STATUS_SUCCESS;

            ulDrvInd = ulDriveNum;
            ulOutDrvInd = 0;

            for(ulTemp=0;ulTemp<PHYSICAL_DRIVE_MODEL_LENGTH;ulTemp+=2)
            {
                pInOutInfo->phyDrives[ulOutDrvInd].sModelInfo[ulTemp] = 
				               ((UCHAR *)DeviceExtension->FullIdentifyData[ulDrvInd].ModelNumber)[ulTemp+1];

                pInOutInfo->phyDrives[ulOutDrvInd].sModelInfo[ulTemp+1] = 
				               ((UCHAR *)DeviceExtension->FullIdentifyData[ulDrvInd].ModelNumber)[ulTemp];
            }

            pInOutInfo->phyDrives[ulOutDrvInd].sModelInfo[PHYSICAL_DRIVE_MODEL_LENGTH - 1] = '\0';

            for(ulTemp=0;ulTemp<PHYSICAL_DRIVE_SERIAL_NO_LENGTH;ulTemp+=2)
            {
                pInOutInfo->phyDrives[ulOutDrvInd].caSerialNumber[ulTemp] = 
				               ((UCHAR *)DeviceExtension->FullIdentifyData[ulDrvInd].SerialNumber)[ulTemp+1];

                pInOutInfo->phyDrives[ulOutDrvInd].caSerialNumber[ulTemp+1] = 
				               ((UCHAR *)DeviceExtension->FullIdentifyData[ulDrvInd].SerialNumber)[ulTemp];
            }

            pInOutInfo->phyDrives[ulOutDrvInd].caSerialNumber[PHYSICAL_DRIVE_SERIAL_NO_LENGTH - 1] = '\0';

            pInOutInfo->phyDrives[ulOutDrvInd].cChannelID = (UCHAR)( (TARGET_ID_2_CONNECTION_ID(ulDrvInd)) | (DeviceExtension->ucControllerId << 5) );
            pInOutInfo->phyDrives[ulOutDrvInd].TransferMode = DeviceExtension->TransferMode[ulDrvInd];

		    pInOutInfo->phyDrives[ulOutDrvInd].ulPhySize           = DeviceExtension->PhysicalDrive[ulDriveNum].OriginalSectors / 2; // In KB
		    pInOutInfo->phyDrives[ulOutDrvInd].ucIsPhyDrvPresent   = TRUE;

            // Begin Vasu 09 Aug 2000
            // Updated Fix from Syam's Fix for ATA100 Release 1
            if ( DeviceExtension->PhysicalDrive[ulDriveNum].TimeOutErrorCount < MAX_TIME_OUT_ERROR_COUNT )
            {
    		    pInOutInfo->phyDrives[ulOutDrvInd].ucIsPowerConnected  = TRUE;
            }
            else
            {
                if (DeviceExtension->bInvalidConnectionIdImplementation)
                {
                    pInOutInfo->phyDrives[ulOutDrvInd].cChannelID = (UCHAR) INVALID_CHANNEL_ID;
                }
            }
            // End Vasu.

            if ( DeviceExtension->TransferMode[ulDriveNum] >= UdmaMode3 )
		        pInOutInfo->phyDrives[ulOutDrvInd].ucIs80PinCable      = TRUE;

		    pInOutInfo->phyDrives[ulOutDrvInd].ulBaseAddress1 = (ULONG)DeviceExtension->BaseIoAddress1[ulDriveNum>>1];
		    pInOutInfo->phyDrives[ulOutDrvInd].ulAltAddress2 = (ULONG)DeviceExtension->BaseIoAddress2[ulDriveNum>>1];
		    pInOutInfo->phyDrives[ulOutDrvInd].ulbmAddress = (ULONG)DeviceExtension->BaseBmAddress[ulDriveNum>>1];
		    pInOutInfo->phyDrives[ulOutDrvInd].ulIrq = DeviceExtension->ulIntLine;
            pInOutInfo->phyDrives[ulOutDrvInd].ucControllerId = DeviceExtension->ucControllerId;

        }
        else
            ulStatus = SRB_STATUS_ERROR; // Hey there is no drive with this Target Id
    }
    else
    {
        pInOutInfo->cMajorVersion       = DRIVER_MAJOR_VERSION;
        pInOutInfo->cMinorVersion       = DRIVER_MINOR_VERSION;
        pInOutInfo->ulDriveSize         = DeviceExtension->LogicalDrive[ulDriveNum].Sectors / 
                                    ( 2 * DeviceExtension->LogicalDrive[ulDriveNum].StripesPerRow );
        pInOutInfo->ulMode              = DeviceExtension->LogicalDrive[ulDriveNum].RaidLevel;
        pInOutInfo->ulTotalSize         = DeviceExtension->LogicalDrive[ulDriveNum].Sectors / 2;
        pInOutInfo->ulStripeSize        = DeviceExtension->LogicalDrive[ulDriveNum].StripeSize;
        pInOutInfo->ulStripesPerRow     = DeviceExtension->LogicalDrive[ulDriveNum].StripesPerRow;
        pInOutInfo->ulTotDriveCnt       = DeviceExtension->LogicalDrive[ulDriveNum].PhysicalDriveCount;
		pInOutInfo->ulStatus            = DeviceExtension->LogicalDrive[ulDriveNum].Status;
        pInOutInfo->ulArrayId           = DeviceExtension->LogicalDrive[ulDriveNum].ulArrayId;
// edm June 8, 2000 start
		pInOutInfo->ulTargetId			= Srb->TargetId;
// edm June 8, 2000 end
        ulStatus                        = SRB_STATUS_SUCCESS;
    }

    ulOutDrvInd = 0;

    for(ulDrvCounter=0;ulDrvCounter<DeviceExtension->LogicalDrive[ulDriveNum].StripesPerRow;ulDrvCounter++)
    {
        ULONG ulTempId;

        ulTempId = ulDrvInd = DeviceExtension->LogicalDrive[ulDriveNum].PhysicalDriveTid[ulDrvCounter];

        pInOutInfo->phyDrives[ulOutDrvInd].cChannelID = (UCHAR)( (TARGET_ID_2_CONNECTION_ID(ulDrvInd)) | (DeviceExtension->ucControllerId << 5) );

        for(ulTemp=0;ulTemp<PHYSICAL_DRIVE_MODEL_LENGTH;ulTemp+=2)
        {
            pInOutInfo->phyDrives[ulOutDrvInd].sModelInfo[ulTemp] = 
						   ((UCHAR *)DeviceExtension->FullIdentifyData[ulDrvInd].ModelNumber)[ulTemp+1];

            pInOutInfo->phyDrives[ulOutDrvInd].sModelInfo[ulTemp+1] = 
						   ((UCHAR *)DeviceExtension->FullIdentifyData[ulDrvInd].ModelNumber)[ulTemp];
        }

        pInOutInfo->phyDrives[ulOutDrvInd].sModelInfo[PHYSICAL_DRIVE_MODEL_LENGTH - 1] = '\0';

        for(ulTemp=0;ulTemp<PHYSICAL_DRIVE_SERIAL_NO_LENGTH;ulTemp+=2)
        {
            pInOutInfo->phyDrives[ulOutDrvInd].caSerialNumber[ulTemp] = 
						   ((UCHAR *)DeviceExtension->FullIdentifyData[ulDrvInd].SerialNumber)[ulTemp+1];

            pInOutInfo->phyDrives[ulOutDrvInd].caSerialNumber[ulTemp+1] = 
						   ((UCHAR *)DeviceExtension->FullIdentifyData[ulDrvInd].SerialNumber)[ulTemp];
        }

        pInOutInfo->phyDrives[ulOutDrvInd].caSerialNumber[PHYSICAL_DRIVE_SERIAL_NO_LENGTH - 1] = '\0';

        pInOutInfo->phyDrives[ulOutDrvInd].ulPhyStatus = DeviceExtension->PhysicalDrive[ulDrvInd].Status;

        pInOutInfo->phyDrives[ulOutDrvInd].TransferMode = DeviceExtension->TransferMode[ulDrvInd];

		pInOutInfo->phyDrives[ulOutDrvInd].ulPhySize           = DeviceExtension->PhysicalDrive[ulDrvInd].OriginalSectors / 2;  // In KB
		pInOutInfo->phyDrives[ulOutDrvInd].ucIsPhyDrvPresent   = TRUE;

        // Begin Vasu 09 Aug 2000
        // Updated Fix from Syam's Fix for ATA100 Release 1
        if ( DeviceExtension->PhysicalDrive[ulDrvInd].TimeOutErrorCount < MAX_TIME_OUT_ERROR_COUNT )
        {
    		pInOutInfo->phyDrives[ulOutDrvInd].ucIsPowerConnected  = TRUE;
        }
        else
        {
            if (DeviceExtension->bInvalidConnectionIdImplementation)
            {
                pInOutInfo->phyDrives[ulOutDrvInd].cChannelID = (UCHAR) INVALID_CHANNEL_ID;
            }
        }
        // End Vasu.

        if ( DeviceExtension->TransferMode[ulDrvInd] >= UdmaMode3 )
		    pInOutInfo->phyDrives[ulOutDrvInd].ucIs80PinCable      = TRUE;

        pInOutInfo->phyDrives[ulOutDrvInd].ulBaseAddress1 = (ULONG)DeviceExtension->BaseIoAddress1[ulDrvInd>>1];
		pInOutInfo->phyDrives[ulOutDrvInd].ulAltAddress2 = (ULONG)DeviceExtension->BaseIoAddress2[ulDrvInd>>1];
		pInOutInfo->phyDrives[ulOutDrvInd].ulbmAddress = (ULONG)DeviceExtension->BaseBmAddress[ulDrvInd>>1];
		pInOutInfo->phyDrives[ulOutDrvInd].ulIrq = DeviceExtension->ulIntLine;

        if  ((Raid1 == DeviceExtension->LogicalDrive[ulDriveNum].RaidLevel) ||
             (Raid10 == DeviceExtension->LogicalDrive[ulDriveNum].RaidLevel))
        {
            if  (   (DeviceExtension->PhysicalDrive[ulDrvInd].ucMirrorDriveId != INVALID_DRIVE_ID) && 
                    ( (DeviceExtension->PhysicalDrive[ulDrvInd].ucMirrorDriveId & (~DRIVE_OFFLINE)) < MAX_DRIVES_PER_CONTROLLER )
                )
            {
                if (Raid1 == DeviceExtension->LogicalDrive[ulDriveNum].RaidLevel)
                    pInOutInfo->ulStripeSize = 0;

                ulTempId = ulDrvInd = (DeviceExtension->PhysicalDrive[ulDrvInd].ucMirrorDriveId) & 0x7f;
                ulOutDrvInd++;

                pInOutInfo->phyDrives[ulOutDrvInd].cChannelID = (UCHAR)( (TARGET_ID_2_CONNECTION_ID(ulDrvInd)) | (DeviceExtension->ucControllerId << 5) );

                for(ulTemp=0;ulTemp<PHYSICAL_DRIVE_MODEL_LENGTH;ulTemp+=2)
                {
                    pInOutInfo->phyDrives[ulOutDrvInd].sModelInfo[ulTemp] = 
						           ((UCHAR *)DeviceExtension->FullIdentifyData[ulDrvInd].ModelNumber)[ulTemp+1];

                    pInOutInfo->phyDrives[ulOutDrvInd].sModelInfo[ulTemp+1] = 
						           ((UCHAR *)DeviceExtension->FullIdentifyData[ulDrvInd].ModelNumber)[ulTemp];
                }

                pInOutInfo->phyDrives[ulOutDrvInd].sModelInfo[PHYSICAL_DRIVE_MODEL_LENGTH - 1] = '\0';

                for(ulTemp=0;ulTemp<PHYSICAL_DRIVE_SERIAL_NO_LENGTH;ulTemp+=2)
                {
                    pInOutInfo->phyDrives[ulOutDrvInd].caSerialNumber[ulTemp] = 
						           ((UCHAR *)DeviceExtension->FullIdentifyData[ulDrvInd].SerialNumber)[ulTemp+1];

                    pInOutInfo->phyDrives[ulOutDrvInd].caSerialNumber[ulTemp+1] = 
						           ((UCHAR *)DeviceExtension->FullIdentifyData[ulDrvInd].SerialNumber)[ulTemp];
                }

                pInOutInfo->phyDrives[ulOutDrvInd].caSerialNumber[PHYSICAL_DRIVE_SERIAL_NO_LENGTH - 1] = '\0';

                pInOutInfo->phyDrives[ulOutDrvInd].ulPhyStatus = DeviceExtension->PhysicalDrive[ulDrvInd].Status;

                pInOutInfo->phyDrives[ulOutDrvInd].TransferMode = DeviceExtension->TransferMode[ulDrvInd];

		        pInOutInfo->phyDrives[ulOutDrvInd].ulPhySize           = DeviceExtension->PhysicalDrive[ulDrvInd].OriginalSectors / 2; // In KB
		        pInOutInfo->phyDrives[ulOutDrvInd].ucIsPhyDrvPresent   = TRUE;

                // Begin Vasu 09 Aug 2000
                // Updated Fix from Syam's Fix for ATA100 Release 1
                if ( DeviceExtension->PhysicalDrive[ulDrvInd].TimeOutErrorCount < MAX_TIME_OUT_ERROR_COUNT )
                {
    		        pInOutInfo->phyDrives[ulOutDrvInd].ucIsPowerConnected  = TRUE;
                }
                else
                {
                    if (DeviceExtension->bInvalidConnectionIdImplementation)
                    {
                        pInOutInfo->phyDrives[ulOutDrvInd].cChannelID = (UCHAR) INVALID_CHANNEL_ID;
                    }
                }
                // End Vasu.

                if ( DeviceExtension->TransferMode[ulDrvInd] >= UdmaMode3 )
		            pInOutInfo->phyDrives[ulOutDrvInd].ucIs80PinCable      = TRUE;

                pInOutInfo->phyDrives[ulOutDrvInd].ulBaseAddress1 = (ULONG)DeviceExtension->BaseIoAddress1[ulDrvInd>>1];
		        pInOutInfo->phyDrives[ulOutDrvInd].ulAltAddress2 = (ULONG)DeviceExtension->BaseIoAddress2[ulDrvInd>>1];
		        pInOutInfo->phyDrives[ulOutDrvInd].ulbmAddress = (ULONG)DeviceExtension->BaseBmAddress[ulDrvInd>>1];
		        pInOutInfo->phyDrives[ulOutDrvInd].ulIrq = DeviceExtension->ulIntLine;

            }
            else
            {
                if ((Raid1 == DeviceExtension->LogicalDrive[ulDriveNum].RaidLevel) ||
                    (Raid10 == DeviceExtension->LogicalDrive[ulDriveNum].RaidLevel))
                {
                    ++ulOutDrvInd;
                    pInOutInfo->phyDrives[ulOutDrvInd].cChannelID = (UCHAR)INVALID_CONNECTION_ID;
                    pInOutInfo->phyDrives[ulOutDrvInd].ulPhyStatus = PDS_Failed;
                }
            }
        }

        ulOutDrvInd++;
    }

    for (ulPInd = 0; ulPInd < pInOutInfo->ulTotDriveCnt; ulPInd++)
    {
        ulDrvInd = GET_TARGET_ID(pInOutInfo->phyDrives[ulPInd].cChannelID);

        if (DeviceExtension->IsSpareDrive[ulDrvInd])
        {
            UCHAR uchChannelID = pInOutInfo->phyDrives[ulPInd].cChannelID;
            ULONG ulStatus = pInOutInfo->phyDrives[ulPInd].ulPhyStatus;
            AtapiFillMemory((PUCHAR)&(pInOutInfo->phyDrives[ulPInd]), sizeof(PHY_DRIVE_INFO), 0);
            pInOutInfo->phyDrives[ulPInd].ulPhyStatus = ulStatus;
            pInOutInfo->phyDrives[ulPInd].cChannelID = uchChannelID;
        }
    }

FillRaidInfoDone:
    return ulStatus;
}   // FillRaidInfo


ULONG SetLogicalDriveStatus(IN PHW_DEVICE_EXTENSION DeviceExtension,
                            IN UCHAR LogDrvId,
                            IN UCHAR PhyDrvId,
                            IN UCHAR LogDrvStatus,
                            IN UCHAR PhyDrvStatus,
                            IN UCHAR Flags)
/*++


SetLogicalDriveStatus

Set logical and/or physical drive status based on flag as fellow:
 Flags: 
     0: logical drive
     1: physical drive
     2: both

--*/
{
	SET_DRIVE_STATUS_TYPE type = Flags;
	int i;

    LogDrvId = (UCHAR)DeviceExtension->PhysicalDrive[PhyDrvId].ucLogDrvId;
    // Logical Drive Id may get changed since the Application will not be 
    // active always and when parsing IRCD the LogicalDrive Id will be
    // decided based on the first GOOD physical Drive Id... So application 
    // and Driver will think in different way.

	// set logical drive status
    if ( LogDrvId < MAX_DRIVES_PER_CONTROLLER )
    {
	    // set logical drive status
	    if ((SDST_Both == type) || (SDST_Logical == type)) 
        {
            DeviceExtension->LogicalDrive[LogDrvId].Status = LogDrvStatus;
	    }
    }

	// set physical drive status
	if ((SDST_Both == type) || (SDST_Physical == type)) {
	    DeviceExtension->PhysicalDrive[PhyDrvId].Status = PhyDrvStatus;
	}

	if (LDS_Degraded == LogDrvStatus)
	{
        DeviceExtension->RebuildInProgress = 1;
	}

	if (LDS_Online == LogDrvStatus)
	{
        DeviceExtension->RebuildInProgress = 0;
        DeviceExtension->RebuildWaterMarkSector = 0;
        DeviceExtension->RebuildWaterMarkLength = 0;
	}

	//
	// set error flag
	//
	SetStatusChangeFlag(DeviceExtension, IDERAID_STATUS_FLAG_UPDATE_DRIVE_STATUS);

    return SRB_STATUS_SUCCESS;
}

/////////////////////////////////////////////////////////////////
//
// ChangeMirrorDrive
//
// Bad drive to failed
// Good drive to rebuilding
//
// Assumption: always replace the mirroring drive
//
/////////////////////////////////////////////////////////////////
ULONG ChangeMirrorDrive(
    IN PHW_DEVICE_EXTENSION DeviceExtension,
    IN UCHAR LogDrvId,
    IN UCHAR BadPhyDrvId,
    IN UCHAR GoodPhyDrvId
)
{
    ULONG ulTempInd;
    UCHAR ucPriDrvId, ucMirrorDrvId;

    LogDrvId = (UCHAR)DeviceExtension->PhysicalDrive[LogDrvId].ucLogDrvId;
    // anyway hyper rebuild application is sending physical drive id of good drive id
    // let us use this for finding out the logical drive information

    // Logical Drive Id may get changed since the Application will 
    // not be active always and when parsing IRCD the LogicalDrive Id will be
    // decided based on the first GOOD physical Drive Id... So application 
    // and Driver will think in different way.
    
    for(ulTempInd=0;ulTempInd<DeviceExtension->LogicalDrive[LogDrvId].StripesPerRow;ulTempInd++) 
    {
		// get the primary phy drive id and its mirror drive id
		ucPriDrvId = DeviceExtension->LogicalDrive[LogDrvId].PhysicalDriveTid[ulTempInd];
        ucMirrorDrvId = DeviceExtension->PhysicalDrive[ucPriDrvId].ucMirrorDriveId & (~DRIVE_OFFLINE);

		if ((ucMirrorDrvId >= MAX_DRIVES_PER_CONTROLLER) ||
			(BadPhyDrvId == ucMirrorDrvId)) 
        {
            // set the primary drive's mirror drive id to GoodDrv Id
            DeviceExtension->PhysicalDrive[ucPriDrvId].ucMirrorDriveId = GoodPhyDrvId;

            // set the good drvs's mirror drive as primary drive
            DeviceExtension->PhysicalDrive[GoodPhyDrvId].ucMirrorDriveId = ucPriDrvId;

            DeviceExtension->PhysicalDrive[GoodPhyDrvId].ucLogDrvId = DeviceExtension->PhysicalDrive[ucPriDrvId].ucLogDrvId;

            if ( BadPhyDrvId < MAX_DRIVES_PER_CONTROLLER)
                DeviceExtension->PhysicalDrive[BadPhyDrvId].ucLogDrvId = INVALID_CONNECTION_ID;

			if (ucMirrorDrvId < MAX_DRIVES_PER_CONTROLLER)
	            // set the bad drive's status to FAILED
	            DeviceExtension->PhysicalDrive[ucMirrorDrvId].Status = PDS_Failed;

            // set the good drvs's status to REBUILDING
            DeviceExtension->PhysicalDrive[GoodPhyDrvId].Status = PDS_Rebuilding;
            DeviceExtension->PhysicalDrive[ucPriDrvId].ucMirrorDriveId |= DRIVE_OFFLINE;

            break;
		}
    } // end for loop

    return SRB_STATUS_SUCCESS;
}

/////////////////////////////////////////////////////////////////
//
//  ChangeMirrorDriveStatus
//  
//  If setting the primary drive to non working condition
//      swaps the drives and set the mirror drive to offline
//  If setting the mirror drive
//      set its status and online flags respectively
//
//  Assumption: at least one drive must be in working condition
//
/////////////////////////////////////////////////////////////////
ULONG ChangeMirrorDriveStatus(  
    IN PHW_DEVICE_EXTENSION DeviceExtension,
    IN UCHAR LogDrvId,
    IN UCHAR PhyDrvId,
    IN UCHAR PhyDrvStatus
)
{
    ULONG ulTempInd;
    UCHAR ucPriDrvId, ucMirrorDrvId;

    if ( PhyDrvId >= MAX_DRIVES_PER_CONTROLLER )   // may be a drive id that is not present in the system (like INVALID_CONNECTION_ID)
        return SRB_STATUS_SUCCESS; 

    LogDrvId = (UCHAR)DeviceExtension->PhysicalDrive[PhyDrvId].ucLogDrvId;
    // Logical Drive Id may get changed since the Application will not be 
    // active always and when parsing IRCD the LogicalDrive Id will be
    // decided based on the first GOOD physical Drive Id... So application 
    // and Driver will think in different way.

    // Set status
    DeviceExtension->PhysicalDrive[PhyDrvId].Status = PhyDrvStatus;
    
    
    for(ulTempInd=0;ulTempInd<DeviceExtension->LogicalDrive[LogDrvId].StripesPerRow;ulTempInd++) 
    {
		// get the primary phy drive id and its mirror drive id
		ucPriDrvId = DeviceExtension->LogicalDrive[LogDrvId].PhysicalDriveTid[ulTempInd];
        ucMirrorDrvId = (DeviceExtension->PhysicalDrive[ucPriDrvId].ucMirrorDriveId) & (~DRIVE_OFFLINE);

        // if setting the primary drive to non working condition
        if ((PhyDrvId == ucPriDrvId) &&
            (PDS_Online != PhyDrvStatus) && (PDS_Critical != PhyDrvStatus)) 
        {
            if ( INVALID_DRIVE_ID != DeviceExtension->PhysicalDrive[ucPriDrvId].ucMirrorDriveId )
            {   // if the mirror drive exists
                // put the mirror drive to the primary position
                // set the new primary's mirror drive to offline flag
                //
                DeviceExtension->LogicalDrive[LogDrvId].PhysicalDriveTid[ulTempInd] = ucMirrorDrvId;
			    DeviceExtension->PhysicalDrive[ucMirrorDrvId].ucMirrorDriveId |= DRIVE_OFFLINE;
                break;
            }
        } 
        else
        {
            // if setting the mirror drive status
            if (PhyDrvId == ucMirrorDrvId) 
            {
                if ((PDS_Online == PhyDrvStatus) ||
				    (PDS_Critical == PhyDrvStatus))
				    // if setting the status to working condition
        		    DeviceExtension->PhysicalDrive[ucPriDrvId].ucMirrorDriveId &= ~DRIVE_OFFLINE;

                else
				    // setting the status to non-working condition
        		    DeviceExtension->PhysicalDrive[ucPriDrvId].ucMirrorDriveId |= DRIVE_OFFLINE;

                break;
             } 
        }
    }

	//
	// set error flag
	//
	SetStatusChangeFlag(DeviceExtension, IDERAID_STATUS_FLAG_UPDATE_DRIVE_STATUS);

    return SRB_STATUS_SUCCESS;
}

ULONG
GetRAIDDriveCapacity(
    IN PHW_DEVICE_EXTENSION DeviceExtension,
    IN PSCSI_REQUEST_BLOCK  Srb
)
/*++

Routine Description:

    This routine returns the drive capacity in the form of the Last accessible
    sector number.

Arguments:

	DeviceExtension - HBA miniport driver's adapter data storage
	Srb - IO request packet

Return Value:

    SRB Status as ULONG.

--*/
{
    ULONG ulStatus = SRB_STATUS_SUCCESS;

    PIDERAID_DISK_CAPACITY_INFO pDataBuffer = NULL;
    PSRB_IO_CONTROL pSrb = NULL;

    DebugPrint((1, "Entering GetRAIDDriveCapacity routine\n"));

    pSrb = (PSRB_IO_CONTROL)(Srb->DataBuffer);
    pDataBuffer = (PIDERAID_DISK_CAPACITY_INFO)(((PSRB_BUFFER)(Srb->DataBuffer))->caDataBuffer);

    if ( AtapiStringCmp( 
                pSrb->Signature, 
                IDE_RAID_SIGNATURE,
                strlen(IDE_RAID_SIGNATURE))) 
    {
        ulStatus = SRB_STATUS_ERROR;
    }
    else
    {
        if ((pDataBuffer->uchTargetID < 0) ||     // Cannot exceed max. drives
            (pDataBuffer->uchTargetID > MAX_DRIVES_PER_CONTROLLER)) // supported.
        {
            // Capacity for a drive that is not present is asked.
            ulStatus = SRB_STATUS_NO_DEVICE;
        }
        else
        {
            pDataBuffer->ulLastSector = 
                (DeviceExtension->PhysicalDrive[pDataBuffer->uchTargetID]).Sectors;
            ulStatus = SRB_STATUS_SUCCESS;
        }

        DebugPrint((1, "GetRAIDDriveCapacity : LastSector : %d\n", pDataBuffer->ulLastSector));
    }
       
    return ulStatus;
}

ULONG
GetStatusChangeFlag(
    IN PHW_DEVICE_EXTENSION DeviceExtension,
    IN PSCSI_REQUEST_BLOCK  Srb
)
/*++

Routine Description:

    This routine returns the driver status flag which includes error logs and drive status changes.
	After fetching the flag, this routine resets the flag.

Arguments:

	DeviceExtension - HBA miniport driver's adapter data storage
	Srb - IO request packet

Return Value:

    SRB Status as ULONG.

--*/
{
    PGET_STATUS_CHANGE_FLAG pData;

    DebugPrint((3, "Entering GetStatusChangeFlag routine\n"));

    pData = (PGET_STATUS_CHANGE_FLAG) (((PSRB_BUFFER)Srb->DataBuffer)->caDataBuffer);

    pData->ulUpdateFlag = (ULONG) gucStatusChangeFlag;

	// reset the update flag
	gucStatusChangeFlag = 0x0;

    return SRB_STATUS_SUCCESS;
}


VOID
SetStatusChangeFlag(
    IN PHW_DEVICE_EXTENSION DeviceExtension,
	IN UCHAR			    TheNewStatus
)
{
    DebugPrint((3, "Entering SetStatusChangeFlag routine\n"));
    gucStatusChangeFlag |= TheNewStatus;
}


BOOLEAN
GetIRCDLogicalDriveInd(
    PUCHAR RaidInfoSector,
    UCHAR ucPhyDrvId,
    PUCHAR pucLogDrvInd,
    PUCHAR pucPhyDrvInd,
    PUCHAR pucSpareDrvPoolInd
)
{
    PIRCD_HEADER pRaidHeader = (PIRCD_HEADER)RaidInfoSector;
    PIRCD_LOGICAL_DRIVE pRaidLogDrive = (PIRCD_LOGICAL_DRIVE)GET_FIRST_LOGICAL_DRIVE(pRaidHeader);
    BOOLEAN bFound = FALSE;
    ULONG ulLogDrvInd, ulDrvInd;
    PIRCD_PHYSICAL_DRIVE pPhyDrive;

    for(ulLogDrvInd=0;ulLogDrvInd<pRaidHeader->NumberOfLogicalDrives;ulLogDrvInd++)
    {
        if ( SpareDrivePool == pRaidLogDrive[ulLogDrvInd].LogicalDriveType )
        {
            *pucSpareDrvPoolInd = (UCHAR)ulLogDrvInd;
            continue;       // let us not worry about SpareDrivePool
        }

	    pPhyDrive = (PIRCD_PHYSICAL_DRIVE)((char *)pRaidHeader + pRaidLogDrive[ulLogDrvInd].FirstStripeOffset);

		for(ulDrvInd=0;ulDrvInd<pRaidLogDrive[ulLogDrvInd].NumberOfDrives;ulDrvInd++)
		{
            if (pPhyDrive[ulDrvInd].ConnectionId == (ULONG)ucPhyDrvId)
            {
                *pucPhyDrvInd = (UCHAR)ulDrvInd;
                *pucLogDrvInd = (UCHAR)ulLogDrvInd;
                bFound = TRUE;
                break;
            }
        }
    }

    return bFound;
}

#endif // _IOCTL_IMPLEMENTATION_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\port\scsi\miniport\megaide\init.c ===
ULONG
FindIdeRaidControllers(
	IN PHW_DEVICE_EXTENSION DeviceExtension,
	IN PVOID Context,
	IN PVOID BusInformation,
	IN PCHAR ArgumentString,
	IN OUT PPORT_CONFIGURATION_INFORMATION ConfigInfo,
	OUT PBOOLEAN Again
)

/*++

Routine Description:

	This function scans the PCI bus containing the main IDE controller
	to find the PIIX4 IDE function. Once found it, it maps the Base
	Address of the Bus Master Registers and saves it in the DeviceExtension.

	The Bus Master Address of both channels is mapped and saved.

Arguments:

	DeviceExtension		Pointer to miniport instance.
	ConfigInfo			Pointer to configuration data from the Port driver.

Return Value:

	TRUE	Found PIIX4 IDE controller and mapped base address of Bus Master
			Registers.

	FALSE	Failure.


--*/
{
    ScanPCIBusForHyperDiskControllers(DeviceExtension);

#ifdef HYPERDISK_WINNT
    gbFindRoutineVisited = TRUE;
    if (gbManualScan)
    {
        if ( !AssignDeviceInfo(ConfigInfo) )
        {// probably we already reported all the cards
            *Again = FALSE;
            return SP_RETURN_NOT_FOUND;
        }
    }
#endif

    // Assigns controller Id for this controller
    //  done by comparing the Global Array of PCI Cards' PCI info 
    //  with the current PCI Card's Info
    if ( !AssignControllerId(DeviceExtension, ConfigInfo) )
    {
        *Again = TRUE;  // let us see if we found it out
        return SP_RETURN_NOT_FOUND;
    }


    FindResourcesInfo(DeviceExtension, ConfigInfo);

    DeviceExtension->ulMaxStripesPerRow = ~0;

    // for Clearing parity error, FIFO Enable
    SetInitializationSettings(DeviceExtension);

    // Fill ConfigInfo Structure
	ConfigInfo->InterruptMode = LevelSensitive;

    ConfigInfo->CachesData = TRUE;

    //
    // Indicate one bus.
    //

    ConfigInfo->NumberOfBuses = 1;

	//
	// Indicate the total number of devices that can be attached to the adapter.
	//

	ConfigInfo->MaximumNumberOfTargets = (UCHAR) MAX_DRIVES_PER_CONTROLLER;

	//
	// Indicate that the miniport always calls ScsiPortxxx to access
	// data buffers.
	//

	ConfigInfo->BufferAccessScsiPortControlled = TRUE;

	//
	// Indicate use of S/G list for transfers.
	//
	
	ConfigInfo->ScatterGather = TRUE;

	//
	// Indicate maximum number of SGL entries supported.
	//
	
	ConfigInfo->NumberOfPhysicalBreaks = (MAX_SGL_ENTRIES_PER_SRB / 2) - 1;
	
    ConfigInfo->NeedPhysicalAddresses = TRUE;

    ConfigInfo->TaggedQueuing = TRUE;
	ConfigInfo->MultipleRequestPerLu = TRUE;

	//
	// Indicate DMA master capability.
	//
	
	ConfigInfo->Master = TRUE;
	
	//
	// Indicate 32-bit memory region addresses.
	//

	ConfigInfo->Dma32BitAddresses = TRUE;

    //
	// Indicate 32-bit (DWORD) alignment requirement for data buffers.
	//
	ConfigInfo->AlignmentMask = 3;

    
    DeviceExtension->PhysicalDrive = (PPHYSICAL_DRIVE) 
                                     ScsiPortGetUncachedExtension (
                                        DeviceExtension,
                                        ConfigInfo,
                                        (sizeof (PHYSICAL_DRIVE) * MAX_DRIVES_PER_CONTROLLER) 
                                        );
    
#ifndef HYPERDISK_W2K
    InitIdeRaidControllers(DeviceExtension);
#endif

#ifdef HD_ALLOCATE_SRBEXT_SEPERATELY

        if (! AllocateSRBExtMemory(DeviceExtension, ConfigInfo))
        {
            *Again = FALSE;
            return SP_RETURN_NOT_FOUND;
        }

#endif // HD_ALLOCATE_SRBEXT_SEPERATELY

	//
	// Indicate maximum transfer length.
	//
	ConfigInfo->MaximumTransferLength = DeviceExtension->ulMaxStripesPerRow * MAX_SECTORS_PER_IDE_TRANSFER * IDE_SECTOR_SIZE;

    //
	// Look for other adapters at the moment.
	//
	*Again = TRUE;
	return SP_RETURN_FOUND;
}

BOOLEAN
InitIdeRaidControllers(
	IN PHW_DEVICE_EXTENSION DeviceExtension
)
/*++

Routine Description:

	This function is called by the OS-specific port driver after
	the necessary storage has been allocated, to gather information
	about the adapter's configuration. In particular, it determines
	whether a RAID is present.

Arguments:

	DeviceExtension - HBA miniport driver's adapter data storage
	Context - Address of adapter count
	BusInformation -
	ArgumentString - Used to determine whether driver is client of ntldr or crash dump utility.
	ConfigInfo - Configuration information structure describing HBA
	Again - Indicates search for adapters to continue

Return Value:

	ULONG

--*/
{
	BOOLEAN foundDevices;
	PHW_DEVICE_EXTENSION  e = DeviceExtension;
	SCSI_PHYSICAL_ADDRESS ioBasePort3;
	UCHAR				  channel;
	PUCHAR				  ioSpace;
	UCHAR				  statusByte;
	SCSI_PHYSICAL_ADDRESS ioBasePort1;
	SCSI_PHYSICAL_ADDRESS ioBasePort2;
	UCHAR targetId;

	foundDevices = FALSE;

	// Begin Vasu - 03 January 2001
	// Disable Interrupts if Windows 98
	// Better we do it no matter what BIOS does.
#ifdef HYPERDISK_WIN98
	DisableInterrupts(DeviceExtension);
#endif
	// End Vasu

	for (channel = 0; channel < MAX_CHANNELS_PER_CONTROLLER; channel++) 
    {
		//
		// Search for devices on this controller.
		//

        if (FindDevices(DeviceExtension, channel)) 
        {
            //
            // Remember that some devices were found.
            //

            foundDevices = TRUE;

            if ((DeviceExtension->DeviceFlags[channel << 1] & DFLAGS_DEVICE_PRESENT) &&
		            (DeviceExtension->DeviceFlags[(channel << 1) + 1] & DFLAGS_DEVICE_PRESENT)) 
            {

                //
                // If 2 drives are present, set SwitchDrive to 1 (default is 0).
                // SwitchDrive is used to toggle bewteen the two drives' work queues,
                // to keep the drives fed in a fair fashion. See StartChannelIo().
                //

	            DeviceExtension->Channel[channel].SwitchDrive = 1;
            }
        }

	}

	if (foundDevices) 
    {

		//
		// Program I/O mode for each drive.
		//

		for (targetId = 0; targetId < MAX_DRIVES_PER_CONTROLLER; targetId++) 
        {

			if (IS_IDE_DRIVE(targetId)) 
            {

				BOOLEAN success;

				success = GetIoMode(DeviceExtension, targetId);

				if (!success) {

					//
					// Disable device.
					//

					DeviceExtension->DeviceFlags[targetId] &= ~DFLAGS_DEVICE_PRESENT;
				}
                else {
                    DeviceExtension->aucDevType[targetId] = IDE_DRIVE;
				}    

			}
        }

        DeviceExtension->SendCommand[NO_DRIVE]      = DummySendRoutine;
        DeviceExtension->SendCommand[IDE_DRIVE]     = IdeSendCommand;

        DeviceExtension->SrbHandlers[LOGICAL_DRIVE_TYPE] = SplitSrb;
        DeviceExtension->SrbHandlers[PHYSICAL_DRIVE_TYPE] = EnqueueSrb;

        DeviceExtension->PostRoutines[NO_DRIVE] = DummyPostRoutine;
        DeviceExtension->PostRoutines[IDE_DRIVE] = PostIdeCmd;
	}

    GetConfigInfoAndErrorLogSectorInfo(DeviceExtension);

	//
	// Get RAID configuration for both channels.
	//
    if (IsRaidMember(gaucIRCDData)) // Try to do this configuration only if the IRCD Data is valid
    {
	    PIRCD_HEADER pRaidHeader;

	    pRaidHeader = (PIRCD_HEADER) gaucIRCDData;

        if (    ( pRaidHeader->MajorVersionNumber == 1) &&
                ( pRaidHeader->MinorVersionNumber == 0)
        )
        {
            DeviceExtension->bInvalidConnectionIdImplementation = FALSE;
        }
        else
        {
            DeviceExtension->bInvalidConnectionIdImplementation = TRUE;
        }

        gFwVersion.Build = 0;   // how to find this????
        gFwVersion.MajorVer = pRaidHeader->MajorVersionNumber;
        gFwVersion.MinorVer = pRaidHeader->MinorVersionNumber;

	    ConfigureRaidDrives(DeviceExtension);
    }

	//
	// Expose single drives.
	//
	ExposeSingleDrives(DeviceExtension);

    AssignLogicalDriveIds(DeviceExtension);

    // Initialize some features on drive (which are required at the initialization time)
    // Right now we are enabling Cache implementation features... (this is to resolve the bug of 
    // bad performance on some IBM Drives)
    InitDriveFeatures(DeviceExtension);

    return TRUE;
} // end InitIdeRaidControllers()

BOOLEAN
AssignLogicalDriveIds(
	IN OUT PHW_DEVICE_EXTENSION DeviceExtension
)
{
    ULONG ulCurLogDrv, ulLogDrvInd;

    for(ulCurLogDrv=0, ulLogDrvInd=0;ulLogDrvInd<MAX_DRIVES_PER_CONTROLLER;ulLogDrvInd++)
    {
        if ( DeviceExtension->IsLogicalDrive[ulLogDrvInd] || DeviceExtension->IsSingleDrive[ulLogDrvInd] )
        {
            DeviceExtension->aulLogDrvId[ulLogDrvInd] = ulCurLogDrv;
            DeviceExtension->aulDrvList[ulCurLogDrv++] = ulLogDrvInd;
        }
    }
    // Begin Vasu - 16 January 2001
    // Fixed prob. with Inquiry Command returning MegaIDE #00 always.
    return TRUE;
    // End Vasu.
}

BOOLEAN
ConfigureRaidDrives(
	IN OUT PHW_DEVICE_EXTENSION DeviceExtension
)
// Find out the Logical Drive that is related to this controller
{
    UCHAR ucControllerId, ucMirrorDrvId;
    PIRCD_HEADER pRaidHeader = (PIRCD_HEADER)gaucIRCDData;
    PIRCD_LOGICAL_DRIVE pRaidLogDrive = (PIRCD_LOGICAL_DRIVE)GET_FIRST_LOGICAL_DRIVE(pRaidHeader);
    PIRCD_PHYSICAL_DRIVE pPhyDrive;
    ULONG ulLogDrvInd, ulDrvInd, ulArrayId, ulCurLogDrv, ulLastDrvInd, ulMinSize, ulDrvInd2, ulPhyDrvInd;
    ULONG ulTemp;

    DeviceExtension->bEnableRwCache = (BOOLEAN)(pRaidHeader->Features & 0x01); // First bit is for Write Cache Enable 

    //
	// hide all of phy drives in spare drive list
	//
    for(ulLogDrvInd=0;ulLogDrvInd<pRaidHeader->NumberOfLogicalDrives;ulLogDrvInd++)
    {
        if ( SpareDrivePool == pRaidLogDrive[ulLogDrvInd].LogicalDriveType )
        {
	        pPhyDrive = (PIRCD_PHYSICAL_DRIVE)((char *)pRaidHeader + pRaidLogDrive[ulLogDrvInd].FirstStripeOffset);

			for(ulDrvInd=0;ulDrvInd<pRaidLogDrive[ulLogDrvInd].NumberOfDrives;ulDrvInd++)
			{
                if ( INVALID_CONNECTION_ID == pPhyDrive[ulDrvInd].ConnectionId )
                    continue;

				ulPhyDrvInd = GET_TARGET_ID((pPhyDrive[ulDrvInd].ConnectionId));

                if ( DeviceExtension->ucControllerId != (ulPhyDrvInd>>2) )
                    continue;   // this does not belong to this controller

                ulPhyDrvInd &= 0x3; // We need only the info about the current controller ... so strip out the 
                // controller Info

				DeviceExtension->IsSingleDrive[ulPhyDrvInd] = FALSE;

				DeviceExtension->PhysicalDrive[ulPhyDrvInd].Hidden = TRUE;

                DeviceExtension->IsSpareDrive[ulPhyDrvInd] = (UCHAR) 1;

                DeviceExtension->PhysicalDrive[ulPhyDrvInd].ucLogDrvId = INVALID_DRIVE_ID;
			}
    		// since there are only one spare drive list, jump out of loop
            break;
        }
    }


    for(ulLogDrvInd=0, ulArrayId=0;ulLogDrvInd<pRaidHeader->NumberOfLogicalDrives;ulLogDrvInd++, ulArrayId++)
    {
        if ( SpareDrivePool == pRaidLogDrive[ulLogDrvInd].LogicalDriveType )
            continue;

        // Here for every Raid Drive the target ID will be equal to the first GOOD Physical Drive in the array
        pPhyDrive = (PIRCD_PHYSICAL_DRIVE)((char *)pRaidHeader + pRaidLogDrive[ulLogDrvInd].FirstStripeOffset);

        if ( !FoundValidDrive(pPhyDrive, pRaidLogDrive[ulLogDrvInd].NumberOfDrives) )
        {   // No valid Drive in this logical drive.. so let us not consider this drive at all
            continue;
        }

        ulCurLogDrv = CoinLogicalDriveId(&(pRaidLogDrive[ulLogDrvInd]), pPhyDrive);
        DeviceExtension->LogicalDrive[ulCurLogDrv].ulArrayId = ulArrayId;

        // Check if this logical drive belongs to this controller at all
        for(ulDrvInd=0;ulDrvInd<pRaidLogDrive->NumberOfDrives;ulDrvInd++)
        {
            if ( INVALID_CONNECTION_ID == pPhyDrive[ulDrvInd].ConnectionId )
                continue;

            ulTemp = GET_TARGET_ID(pPhyDrive[ulDrvInd].ConnectionId);
            break;
        }

        if ( DeviceExtension->ucControllerId != (ulTemp>>2) )
            continue;   // this drive does not belong to this controller

        FillLogicalDriveInfo(DeviceExtension, ulCurLogDrv, &(pRaidLogDrive[ulLogDrvInd]), gaucIRCDData );
    }

    return TRUE;
}


BOOLEAN
FoundValidDrive(
                PIRCD_PHYSICAL_DRIVE pPhyDrv,
                UCHAR ucDrvCount
                )
{
   UCHAR ucDrvInd;

   for(ucDrvInd=0;ucDrvInd<ucDrvCount;ucDrvInd++)
   {
       if ( INVALID_CONNECTION_ID != pPhyDrv[ucDrvInd].ConnectionId ) // this drive is not present
       {
           return TRUE;
       }
   }
   return FALSE;
}

#ifdef HD_ALLOCATE_SRBEXT_SEPERATELY

BOOLEAN AllocateSRBExtMemory(
    IN PHW_DEVICE_EXTENSION DeviceExtension,
    IN PPORT_CONFIGURATION_INFORMATION ConfigInfo
)
{
    DeviceExtension->pSrbExtension = 
        ScsiPortGetUncachedExtension (DeviceExtension,
                                      ConfigInfo,
                                      (sizeof(SRB_EXTENSION) * MAX_PENDING_SRBS));

    if (DeviceExtension->pSrbExtension == NULL)
    {
        return FALSE;
    }

    return TRUE;
}

#endif // HD_ALLOCATE_SRBEXT_SEPERATELY

BOOLEAN
FillLogicalDriveInfo(
	IN OUT PHW_DEVICE_EXTENSION DeviceExtension,
    ULONG ulLogDrvId,
    PIRCD_LOGICAL_DRIVE pRaidLogDrive,
    PUCHAR  pucIRCDData
    )
{
    PLOGICAL_DRIVE pCurLogDrv;
    PPHYSICAL_DRIVE pPhyDrv;
    PIRCD_PHYSICAL_DRIVE pIRCDPhyDrv;
    IRCD_PHYSICAL_DRIVE TempPhysicalDrive;
    ULONG ulTempInd, ulLastDrvInd, ulMinSize, ulDrvInd, ulDrvInd2, ulPhyDrvInd;
    UCHAR ucMirrorDrvId;
    PIRCD_HEADER pRaidHeader = (PIRCD_HEADER)pucIRCDData;

    pCurLogDrv = &(DeviceExtension->LogicalDrive[ulLogDrvId]);
    pPhyDrv = DeviceExtension->PhysicalDrive;

    // Store the Logical Drive Information
    pCurLogDrv->RaidLevel          = pRaidLogDrive->LogicalDriveType;
    DeviceExtension->IsLogicalDrive[ulLogDrvId]                  = TRUE;
    pCurLogDrv->StripeSize         = pRaidLogDrive->StripeSize;		// In 512-byte units.
    pCurLogDrv->StripesPerRow      = pRaidLogDrive->NumberOfStripes;
    pCurLogDrv->PhysicalDriveCount = pRaidLogDrive->NumberOfDrives;
    pCurLogDrv->TargetId           = (UCHAR)ulLogDrvId;
    pCurLogDrv->Status             = pRaidLogDrive->LogDrvStatus;
        // NextLogicalDrive fields of "DeviceExtension->LogicalDrive[pRaidLogDrive]" are TO BE FILLED YET

    if ( DeviceExtension->ulMaxStripesPerRow > pCurLogDrv->StripesPerRow ) 
    {
        DeviceExtension->ulMaxStripesPerRow = pCurLogDrv->StripesPerRow;
    }

    // Fill in the Physical Drive Information
    ulLastDrvInd = EOL;
    ulMinSize = ~0; // keep the maximum possible value in this

    pIRCDPhyDrv = (PIRCD_PHYSICAL_DRIVE)((char *)pRaidHeader + pRaidLogDrive->FirstStripeOffset);

    if ( ( Raid1 == pCurLogDrv->RaidLevel ) || ( Raid10 == pCurLogDrv->RaidLevel ) )
    {
        for(ulDrvInd=0;ulDrvInd<pRaidLogDrive->NumberOfStripes;ulDrvInd++)
        {   // atleast one drive will be a valid drive id other wise it would have been skipped in the above
            // for loop ... Yet to put some more thoughts on Raid10
            if ( INVALID_CONNECTION_ID == pIRCDPhyDrv[ulDrvInd*2].ConnectionId )
            {   // swap them so that the good drive is in the first place
                AtapiMemCpy((PUCHAR)&TempPhysicalDrive, (PUCHAR)(&(pIRCDPhyDrv[ulDrvInd*2])), sizeof(IRCD_PHYSICAL_DRIVE));
                AtapiMemCpy((PUCHAR)(&(pIRCDPhyDrv[ulDrvInd*2])), (PUCHAR)(&(pIRCDPhyDrv[(ulDrvInd*2) + 1])), sizeof(IRCD_PHYSICAL_DRIVE));
                AtapiMemCpy((PUCHAR)(&(pIRCDPhyDrv[(ulDrvInd*2) + 1])), (PUCHAR)&TempPhysicalDrive, sizeof(IRCD_PHYSICAL_DRIVE));
            }
        }
    }

    for(ulDrvInd=0, ulDrvInd2=0;ulDrvInd<pRaidLogDrive->NumberOfDrives;ulDrvInd++, ulDrvInd2++)
    {
        if ( INVALID_CONNECTION_ID == pIRCDPhyDrv[ulDrvInd].ConnectionId )
        {   // this should never happen as we will be making sure that the good drive is in the first place
            continue;
        }

        ulPhyDrvInd = GET_TARGET_ID_WITHOUT_CONTROLLER_INFO((pIRCDPhyDrv[ulDrvInd].ConnectionId));

        if ( ulMinSize > pIRCDPhyDrv[ulDrvInd].Capacity )
            ulMinSize = pIRCDPhyDrv[ulDrvInd].Capacity;

        if ( ! InSpareDrivePool(pucIRCDData, pIRCDPhyDrv[ulDrvInd].ConnectionId) )
        { // This drive is not spare drive pool... if it is in Spare Drive Pool also then it is a Drive Replacement Case
            // then we are in trouble of showing wrong Logical Drive Size.. if we look in DeviceExtension
			// take care of IRCD and Error Log sectors
			//
			
            if ( ulMinSize > pPhyDrv[ulPhyDrvInd].Sectors) 
                ulMinSize = pPhyDrv[ulPhyDrvInd].Sectors;
        }
        else
        {
            
        }

        // Store the status.
        pPhyDrv[ulPhyDrvInd].Status = pIRCDPhyDrv[ulDrvInd].PhyDrvStatus;

        DeviceExtension->IsSingleDrive[ulPhyDrvInd] = FALSE;

        // This is part of Raid so mark it as HIDDEN
        pPhyDrv[ulPhyDrvInd].Hidden = TRUE;

		pPhyDrv[ulPhyDrvInd].ucMirrorDriveId = INVALID_DRIVE_ID;	// init mirror drive id
		pPhyDrv[ulPhyDrvInd].ucLogDrvId = (UCHAR)ulLogDrvId;	// init mirror drive id

        pCurLogDrv->PhysicalDriveTid[ulDrvInd2] = (UCHAR)ulPhyDrvInd;

        pPhyDrv[ulPhyDrvInd].Next = EOL;
        if ( EOL != ulLastDrvInd )
            pPhyDrv[ulLastDrvInd].Next = (UCHAR)ulPhyDrvInd;

        ulLastDrvInd = ulPhyDrvInd;

        if ( ( Raid1 == pCurLogDrv->RaidLevel ) || ( Raid10 == pCurLogDrv->RaidLevel ) )
        {
			++ulDrvInd;
            if ( INVALID_CONNECTION_ID == pIRCDPhyDrv[ulDrvInd].ConnectionId )
            {
				DeviceExtension->PhysicalDrive[ulPhyDrvInd].ucMirrorDriveId = INVALID_DRIVE_ID;      // Let the mirror drives point to each other
            }
            else
            {
                // Begin Vasu - 18 Aug 2000
                // Removed one redundant if loop.
    		    if (ulDrvInd < pRaidLogDrive->NumberOfDrives) 
                {
				        ucMirrorDrvId = GET_TARGET_ID_WITHOUT_CONTROLLER_INFO((pIRCDPhyDrv[ulDrvInd].ConnectionId));

				        pPhyDrv[ulPhyDrvInd].ucMirrorDriveId = ucMirrorDrvId;      // Let the mirror drives point to each other
				        pPhyDrv[ucMirrorDrvId].ucMirrorDriveId = (UCHAR)ulPhyDrvInd;
                        pPhyDrv[ucMirrorDrvId].ucLogDrvId = (UCHAR)ulLogDrvId;	// init mirror drive id


				        if ( ulMinSize > pIRCDPhyDrv[ulDrvInd].Capacity )
					        ulMinSize = pIRCDPhyDrv[ulDrvInd].Capacity;

                        if ( ! InSpareDrivePool(gaucIRCDData, pIRCDPhyDrv[ulDrvInd].ConnectionId) )
                        { // This drive is not spare drive pool... if it is in Spare Drive Pool also then it is a Drive Replacement Case
                            // then we are in trouble of showing wrong Logical Drive Size.. if we look in DeviceExtension
					        // take care of IRCD and Error Log sectors
					        //
					        
					        if ( ulMinSize > pPhyDrv[ucMirrorDrvId].Sectors) 
						        ulMinSize = pPhyDrv[ucMirrorDrvId].Sectors;
                        }

				        // Store the status.
				        pPhyDrv[ucMirrorDrvId].Status = pIRCDPhyDrv[ulDrvInd].PhyDrvStatus;

				        // mark the drive type
				        DeviceExtension->IsSingleDrive[ucMirrorDrvId] = FALSE;

				        // This is part of Raid so mark it as HIDDEN
				        pPhyDrv[ucMirrorDrvId].Hidden = TRUE;
			        }
                // End Vasu.
            }
		}
    }   // END OF for(ulDrvInd=0, ulDrvInd2=0;ulDrvInd<pRaidLogDrive->.NumberOfDrives;ulDrvInd++, ulDrvInd2++)

	switch (pCurLogDrv->RaidLevel) 
    {
		case Raid0:				// striping
			break;

		case Raid10:            // Striping over Mirrorring
			break;

		case Raid1:				// mirroring
            // If it is a raid1 then at the mostwe can transfer on a drive is 256 Sectors (MAXimum transfer possible for Transfer)
		    pCurLogDrv->StripesPerRow  = 1;	// bios should set this value to 1 already
            pCurLogDrv->StripeSize = ulMinSize;    // For Mirroring case the stripe size is 
                                        // equal to the size of the drive
		    break;
	}

    // Each Drive size should be multiple of Stripe Size
    if ((pCurLogDrv->RaidLevel == Raid0) ||
		(pCurLogDrv->RaidLevel == Raid10)) 
    {
            ulMinSize = ulMinSize - (ulMinSize % pCurLogDrv->StripeSize);
    }

    pCurLogDrv->Sectors = pCurLogDrv->StripesPerRow * ulMinSize;

	// set all phy drives' useable size 
    for(ulTempInd=0;ulTempInd<pCurLogDrv->StripesPerRow;ulTempInd++)
    {
		ulPhyDrvInd = pCurLogDrv->PhysicalDriveTid[ulTempInd];
        pPhyDrv[ulPhyDrvInd].Sectors = ulMinSize;

		// check if mirror drive exists or not
        ucMirrorDrvId = pPhyDrv[ulPhyDrvInd].ucMirrorDriveId;
		if (!IS_DRIVE_OFFLINE(ucMirrorDrvId)) 
        {
			pPhyDrv[ucMirrorDrvId].Sectors = ulMinSize;
		}
    }


	// if Raid1 or Raid10, always put the good drive in the mirroring to the first position
    if ((pCurLogDrv->RaidLevel == Raid1) ||
		(pCurLogDrv->RaidLevel == Raid10)) 
    {
		
		for(ulTempInd=0;ulTempInd<pCurLogDrv->StripesPerRow;ulTempInd++)
        {
			// get the first phy drive id (from the mirror pair)
			ulPhyDrvInd = pCurLogDrv->PhysicalDriveTid[ulTempInd];
            ucMirrorDrvId = pPhyDrv[ulPhyDrvInd].ucMirrorDriveId;

			// if no mirror drv, try next
			if (IS_DRIVE_OFFLINE(ucMirrorDrvId))
				continue;

			//
			// check if any of them Failed or Rebuilding in both cases the we should mark drives as offline
            // so that in normal read or write path we will not use the mirror drive
			//
			if  (   (pPhyDrv[ulPhyDrvInd].Status == PDS_Failed) ||
                    (pPhyDrv[ulPhyDrvInd].Status == PDS_Rebuilding) 
                )
				pPhyDrv[ucMirrorDrvId].ucMirrorDriveId |= DRIVE_OFFLINE;

			if  (   (pPhyDrv[ucMirrorDrvId].Status == PDS_Failed) ||
                    (pPhyDrv[ucMirrorDrvId].Status == PDS_Rebuilding)
                )
				pPhyDrv[ulPhyDrvInd].ucMirrorDriveId |= DRIVE_OFFLINE;

			if (
                (pPhyDrv[ulPhyDrvInd].Status == PDS_Failed) ||
                (pPhyDrv[ulPhyDrvInd].Status == PDS_Rebuilding)
                )
            {   // let us make sure that the first physical drive is the good drive
    			pCurLogDrv->PhysicalDriveTid[ulTempInd] = ucMirrorDrvId;
            }

			//
			// if both drives offline, set this logical drive offline
			//
			if (IS_DRIVE_OFFLINE((pPhyDrv[ulPhyDrvInd].ucMirrorDriveId)) &&
				IS_DRIVE_OFFLINE((pPhyDrv[ucMirrorDrvId].ucMirrorDriveId))) 
            {
					pCurLogDrv->Status = LDS_OffLine;
			} else
            {
				// if the first drive failed, swap it
				if (IS_DRIVE_OFFLINE((pPhyDrv[ucMirrorDrvId].ucMirrorDriveId))) 
                {
					pCurLogDrv->PhysicalDriveTid[ulTempInd] = ucMirrorDrvId;
				} // end if
            }
		} // END OF for(ulTempInd=0;ulTempInd<pCurLogDrv->StripesPerRow;ulTempInd++)

	} // end if raid1 or raid10


    if ( Raid10 == pCurLogDrv->RaidLevel )
    {   // make sure that the Physical Drive list in this Logical Drive are in different channels 
        // (so that the Reads will be in optimum mode)
        UCHAR ucFirstStripe, ucSecondStripe, ucMirrorOfFirstStripe, ucMirrorOfSecondStripe;

        ucFirstStripe  = DeviceExtension->LogicalDrive[ulLogDrvId].PhysicalDriveTid[0];
        ucMirrorOfFirstStripe = DeviceExtension->PhysicalDrive[ucFirstStripe].ucMirrorDriveId;
        ucSecondStripe = DeviceExtension->LogicalDrive[ulLogDrvId].PhysicalDriveTid[1];
        ucMirrorOfSecondStripe = DeviceExtension->PhysicalDrive[ucSecondStripe].ucMirrorDriveId;

        if ( (ucFirstStripe>>1) == (ucSecondStripe>>1) )
        {
            if ( !IS_DRIVE_OFFLINE(ucMirrorOfSecondStripe) )
            {   // Mirror Drive is good and we can use this as a primary drive for the second stripe
                DeviceExtension->LogicalDrive[ulLogDrvId].PhysicalDriveTid[1] = ucMirrorOfSecondStripe;
            }
            else
            {
                if ( !IS_DRIVE_OFFLINE(ucMirrorOfFirstStripe) )
                {
                    DeviceExtension->LogicalDrive[ulLogDrvId].PhysicalDriveTid[0] = ucMirrorOfFirstStripe;
                }
                else
                {
                    // we cannot do anything... we have to survive with this... as the remaining drives are offline
                }
            }
        }
        else
        {
            // nothing to be done ... both the drives are in different channels....
        }
    }

    return TRUE;
}

ULONG
CoinLogicalDriveId(
    PIRCD_LOGICAL_DRIVE pRaidLogDrive,
    PIRCD_PHYSICAL_DRIVE pPhyDrive
    )
{
    ULONG ulDrvInd, ulCurLogDrv;
    BOOLEAN bFoundGoodDrive = FALSE;

    for(ulDrvInd=0;ulDrvInd<pRaidLogDrive->NumberOfDrives;ulDrvInd++)
    {
        if ( INVALID_CONNECTION_ID == pPhyDrive[ulDrvInd].ConnectionId )
            continue;

        if ( PDS_Online == pPhyDrive[ulDrvInd].PhyDrvStatus )
        {
            ulCurLogDrv = GET_TARGET_ID_WITHOUT_CONTROLLER_INFO((pPhyDrive[ulDrvInd].ConnectionId)); // The target Id is equal to the first GOOD PhysicalDrive
            bFoundGoodDrive = TRUE;
            break;
        }
    }

    if ( !bFoundGoodDrive )    
        // all the drives in this logical drives are failed... so, 
        // let's assign the logical drive number as the first valid physical drive...
    {
        // find out a valid drive number now it is possible that invalid drive id can be first one also
        // so ....
        for(ulDrvInd=0;ulDrvInd<pRaidLogDrive->NumberOfDrives;ulDrvInd++)
        {
            if ( INVALID_CONNECTION_ID == pPhyDrive[ulDrvInd].ConnectionId ) // this drive is not present
                continue;

            ulCurLogDrv = GET_TARGET_ID_WITHOUT_CONTROLLER_INFO((pPhyDrive[ulDrvInd].ConnectionId)); 
            break;
        }
    }

    return ulCurLogDrv;
}

BOOLEAN
SetInitializationSettings(
	IN OUT PHW_DEVICE_EXTENSION DeviceExtension
)
// for parity error, FIFO Enable
{
    changePCIConfiguration(DeviceExtension,4,0x04,0,0,FALSE);// Clear Master Abort/Parity Error etc... Just Read and Write the Value
    changePCIConfiguration(DeviceExtension,1,0x79,0xcf,0x20,TRUE);//Set the controller to 1/2 Full FIFO Threshold

    return TRUE;
}

BOOLEAN
AssignControllerId(
	IN OUT PHW_DEVICE_EXTENSION DeviceExtension,
	IN OUT PPORT_CONFIGURATION_INFORMATION ConfigInfo
)
{
    ULONG ulControllerId;
    PCI_SLOT_NUMBER PciSlot;

    PciSlot.u.AsULONG = ConfigInfo->SlotNumber;

    DebugPrint((0, "looking for %x:%x:%x\n", ConfigInfo->SystemIoBusNumber, PciSlot.u.bits.DeviceNumber, PciSlot.u.bits.FunctionNumber));
    for(ulControllerId=0;ulControllerId<gucControllerCount;ulControllerId++)
    {
        if  ( 
                ( ConfigInfo->SystemIoBusNumber == gaCardInfo[ulControllerId].ucPCIBus ) &&
                ( PciSlot.u.bits.DeviceNumber == gaCardInfo[ulControllerId].ucPCIDev ) &&
                ( PciSlot.u.bits.FunctionNumber == gaCardInfo[ulControllerId].ucPCIFun ) 
            )
        {   // Yes... this is the card we are looking for ... so let us fill the ControllerId
            DebugPrint((0, "Controller ID : %x\n", ulControllerId));
            DeviceExtension->ucControllerId = (UCHAR)ulControllerId;
            gaCardInfo[ulControllerId].pDE = DeviceExtension;   // Store the Device Extension for further usage (helps in looking at a global picture)
            switch (gaCardInfo[ulControllerId].ulDeviceId)
            {
            case 0x648:
			    DeviceExtension->ControllerSpeed = Udma66;
                break;
            case 0x649:
			    DeviceExtension->ControllerSpeed = Udma100;
                break;
            }
            return TRUE;
            break;
        }
    }

    return FALSE;   // we didn't find the controller that can be controlled by us at this slot 
}
#define MAX_PORTS       6
BOOLEAN
FindResourcesInfo(
	IN OUT PHW_DEVICE_EXTENSION DeviceExtension,
	IN OUT PPORT_CONFIGURATION_INFORMATION ConfigInfo
)
{
	ULONG length, ulTempRange;
	PCI_SLOT_NUMBER slot;
    ULONG ulRangeInd, ulStartInd;
    ULONG aulPorts[MAX_PORTS];
    ULONG aulPCIBuf[sizeof(IDE_PCI_REGISTERS)];
	PIDE_PCI_REGISTERS pciRegisters = (PIDE_PCI_REGISTERS)aulPCIBuf;

#ifdef HYPERDISK_WIN98
    PPACKED_ACCESS_RANGE pAccessRange;
#else
    PACCESS_RANGE pAccessRange;
#endif

#ifdef HYPERDISK_WIN2K
    ULONG ulPCIDataCount;
#endif

	length = ScsiPortGetBusData(
							DeviceExtension,
							PCIConfiguration,
							ConfigInfo->SystemIoBusNumber,
							ConfigInfo->SlotNumber,
                            pciRegisters,
							sizeof(IDE_PCI_REGISTERS)
							);

	if (length < sizeof(IDE_PCI_REGISTERS)) 
    {
        DebugPrint((1,"GBMA1\n"));

		//
		// Invalid bus number.
		//

		return FALSE;
	}

#ifdef HYPERDISK_WIN98
    pAccessRange = (PPACKED_ACCESS_RANGE)*ConfigInfo->AccessRanges;
    ulTempRange = sizeof(PPACKED_ACCESS_RANGE);
#else
    pAccessRange = *ConfigInfo->AccessRanges;
    ulTempRange = sizeof(PACCESS_RANGE);
#endif

#ifdef HYPERDISK_WINNT
    if (gbManualScan) // for the boards like MegaPlex and Flextel Boards
    {
        ulRangeInd = 0;
        pAccessRange[ulRangeInd].RangeStart.LowPart = pciRegisters->BaseAddress1 & 0xfffffffe;
        pAccessRange[ulRangeInd].RangeStart.HighPart = 0;
        pAccessRange[ulRangeInd].RangeLength = 8;
        pAccessRange[ulRangeInd++].RangeInMemory = FALSE;

        pAccessRange[ulRangeInd].RangeStart.LowPart = pciRegisters->BaseAddress2 & 0xfffffffe;
        pAccessRange[ulRangeInd].RangeStart.HighPart = 0;
        pAccessRange[ulRangeInd].RangeLength = 4;
        pAccessRange[ulRangeInd++].RangeInMemory = FALSE;

        pAccessRange[ulRangeInd].RangeStart.LowPart = pciRegisters->BaseAddress3 & 0xfffffffe;
        pAccessRange[ulRangeInd].RangeStart.HighPart = 0;
        pAccessRange[ulRangeInd].RangeLength = 8;
        pAccessRange[ulRangeInd++].RangeInMemory = FALSE;

        pAccessRange[ulRangeInd].RangeStart.LowPart = pciRegisters->BaseAddress4 & 0xfffffffe;
        pAccessRange[ulRangeInd].RangeStart.HighPart = 0;
        pAccessRange[ulRangeInd].RangeLength = 4;
        pAccessRange[ulRangeInd++].RangeInMemory = FALSE;

        pAccessRange[ulRangeInd].RangeStart.LowPart = pciRegisters->BaseBmAddress & 0xfffffffe;
        pAccessRange[ulRangeInd].RangeStart.HighPart = 0;
        pAccessRange[ulRangeInd].RangeLength = 0x10;
        pAccessRange[ulRangeInd++].RangeInMemory = FALSE;

	    ConfigInfo->BusInterruptLevel = pciRegisters->InterruptLine;
	    ConfigInfo->InterruptMode = LevelSensitive;
    }
#endif


    for(ulRangeInd=0;
        ((ulRangeInd<ConfigInfo->NumberOfAccessRanges) && (pAccessRange[ulRangeInd].RangeStart.LowPart));
        ulRangeInd++)
    {
        aulPorts[ulRangeInd] = (ULONG)ScsiPortGetDeviceBase(
										DeviceExtension,
										ConfigInfo->AdapterInterfaceType,
										ConfigInfo->SystemIoBusNumber,
                                        pAccessRange[ulRangeInd].RangeStart,
                                        pAccessRange[ulRangeInd].RangeLength,
										TRUE	// I/O space.
										);
        if (!aulPorts[ulRangeInd])
        {
            DebugPrint((0,"\nUnable to Convert Ports\n\n"));
            return FALSE;
        }
	}

    ulStartInd = 0;

    ulRangeInd = 0;
	DeviceExtension->BaseIoAddress1[ulStartInd]     = (PIDE_REGISTERS_1)aulPorts[ulRangeInd++];
	DeviceExtension->BaseIoAddress2[ulStartInd]     = (PIDE_REGISTERS_2)aulPorts[ulRangeInd++];
	DeviceExtension->BaseIoAddress1[ulStartInd+1]   = (PIDE_REGISTERS_1)aulPorts[ulRangeInd++];
	DeviceExtension->BaseIoAddress2[ulStartInd+1]   = (PIDE_REGISTERS_2)aulPorts[ulRangeInd++];
	DeviceExtension->BaseBmAddress[ulStartInd]      = (PBM_REGISTERS)aulPorts[ulRangeInd];
	DeviceExtension->BaseBmAddress[ulStartInd + 1]  = (PBM_REGISTERS)(aulPorts[ulRangeInd] + sizeof(BM_REGISTERS));

    DeviceExtension->BusNumber = ConfigInfo->SystemIoBusNumber;
    DeviceExtension->PciSlot.u.AsULONG = ConfigInfo->SlotNumber;
    DebugPrint((0, 
        "Bus:%x:Device:%x:Function:%x\t", 
        DeviceExtension->BusNumber, 
        DeviceExtension->PciSlot.u.bits.DeviceNumber, 
        DeviceExtension->PciSlot.u.bits.FunctionNumber
        ));

	// Begin Vasu - 25 Aug 2000
	// ConfigInfo->BusInterruptVector is valid only in WinNT and not in Win98
	// ConfigInfo->BusInterruptLevel is valid in both WinNT and Win98.
	// Anyway, use ConfigInfo->BusInterruptLevel in 98 and
	// ConfigInfo->BusInterruptVector in NT/2K
#ifndef HYPERDISK_WIN98
	DeviceExtension->ulIntLine = ConfigInfo->BusInterruptVector;	// For WinNT and Win2K
#else // HYPERDISK_WIN98
	DeviceExtension->ulIntLine = ConfigInfo->BusInterruptLevel;		// For Win98
#endif // HYPERDISK_WIN98
	// End Vasu

#ifdef HYPERDISK_WIN2K
    for(ulPCIDataCount=0;ulPCIDataCount<PCI_DATA_TO_BE_UPDATED;ulPCIDataCount++)
    {   // take a copy of the data space that is required to restore when we come back from Standby
        length = ReadFromPCISpace(
						DeviceExtension,
                        &(DeviceExtension->aulPCIData[ulPCIDataCount]),
                        aPCIDataToBeStored[ulPCIDataCount].ulOffset,
						aPCIDataToBeStored[ulPCIDataCount].ulLength
						);
    }
#endif

	return TRUE;
}

#ifdef HYPERDISK_WIN2K
SCSI_ADAPTER_CONTROL_STATUS HyperDiskPnPControl(IN PVOID HwDeviceExtension,
			IN SCSI_ADAPTER_CONTROL_TYPE ControlType,
			IN PVOID Parameters)
{
	PHW_DEVICE_EXTENSION DeviceExtension = (PHW_DEVICE_EXTENSION)HwDeviceExtension;
	ULONG ulDrvInd, ulIndex;
    SCSI_ADAPTER_CONTROL_STATUS ucSCSIStatus;
    UCHAR ucTargetId;

    BOOLEAN baSupportList[ScsiAdapterControlMax] = 
    {
            TRUE,        // ScsiQuerySupportedControlTypes
#ifdef PNP_AND_POWER_MANAGEMENT
            TRUE,        // ScsiStopAdapter
            TRUE,       // ScsiRestartAdapter
            TRUE,       // ScsiSetBootConfig
            TRUE        // ScsiSetRunningConfig
#else
            FALSE,        // ScsiStopAdapter
            FALSE,       // ScsiRestartAdapter
            FALSE,       // ScsiSetBootConfig
            FALSE        // ScsiSetRunningConfig
#endif
    };

    ucSCSIStatus = ScsiAdapterControlUnsuccessful;

	DebugPrint((0, "\nIn AdapterControl\t: %X\n", ControlType));

	switch (ControlType)
	{
		case ScsiQuerySupportedControlTypes:
			{
                PSCSI_SUPPORTED_CONTROL_TYPE_LIST controlTypeList =
	                (PSCSI_SUPPORTED_CONTROL_TYPE_LIST)Parameters;
                for(ulIndex = 0; ulIndex < controlTypeList->MaxControlType; ulIndex++)
                    controlTypeList->SupportedTypeList[ulIndex] = baSupportList[ulIndex];
			}
            ucSCSIStatus = ScsiAdapterControlSuccess;
			break;
#ifdef PNP_AND_POWER_MANAGEMENT
        case ScsiStopAdapter:
            StopDrives(DeviceExtension);
            DisableInterrupts(DeviceExtension);// Win2000 should call for each controller check it out
            ucSCSIStatus = ScsiAdapterControlSuccess;
            break;

        case ScsiRestartAdapter:
            for(ucTargetId=0;ucTargetId<MAX_DRIVES_PER_CONTROLLER;ucTargetId++)
            {
                if ( !IS_IDE_DRIVE(ucTargetId) )
                    continue;
                SetDriveFeatures(DeviceExtension, ucTargetId);
            }
            SetPCISpace(DeviceExtension);   // The PCI Space that we stored will have the interrupts disabled as part of PCI Space
            EnableInterrupts(DeviceExtension);
            ucSCSIStatus = ScsiAdapterControlSuccess;
            break;

		case ScsiSetBootConfig:
            ucSCSIStatus = ScsiAdapterControlSuccess;
            break;
		case ScsiSetRunningConfig:
            ucSCSIStatus = ScsiAdapterControlSuccess;
            break;
#endif
		default:
			break;
	}

	return ucSCSIStatus;
}

BOOLEAN SetPCISpace(PHW_DEVICE_EXTENSION DeviceExtension)
{
    ULONG ulPCIDataCount;
    UCHAR uchMRDMODE = 0;
    PBM_REGISTERS BMRegister = NULL;

    for(ulPCIDataCount=0;ulPCIDataCount<PCI_DATA_TO_BE_UPDATED;ulPCIDataCount++)
    {   // Restore the PCI Space (only the bytes that were changed
        WriteToPCISpace(DeviceExtension, 
                        DeviceExtension->aulPCIData[ulPCIDataCount],
                        aPCIDataToBeStored[ulPCIDataCount].ulAndMask,
                        aPCIDataToBeStored[ulPCIDataCount].ulOffset,
                        aPCIDataToBeStored[ulPCIDataCount].ulLength
                        );
    }

    // Begin Vasu - 02 March 2001
    BMRegister = DeviceExtension->BaseBmAddress[0];
    uchMRDMODE = ScsiPortReadPortUchar(((PUCHAR)BMRegister + 1));
    uchMRDMODE &= 0xF0; // Dont Clear Interrupt Pending Flags.
    uchMRDMODE |= 0x01; // Make it Read Multiple
    ScsiPortWritePortUchar(((PUCHAR)BMRegister + 1), uchMRDMODE);
    // End Vasu

#ifdef DBG
    {
        ULONG length;
        for(ulPCIDataCount=0;ulPCIDataCount<PCI_DATA_TO_BE_UPDATED;ulPCIDataCount++)
        {   // take a copy of the data space that is required to restore when we come back from Standby
            length = ReadFromPCISpace(
						    DeviceExtension,
                            &(DeviceExtension->aulPCIData[ulPCIDataCount]),
                            aPCIDataToBeStored[ulPCIDataCount].ulOffset,
						    aPCIDataToBeStored[ulPCIDataCount].ulLength
						    );
        }
    }




    {
        PIDE_REGISTERS_1 baseIoAddress1;
        PIDE_REGISTERS_2 baseIoAddress2;
        ULONG ulDriveNum;
        UCHAR statusByte;
        UCHAR aucIdentifyBuf[512];
        ULONG i;
    	PIDENTIFY_DATA capabilities = (PIDENTIFY_DATA)aucIdentifyBuf;

        for(ulDriveNum=0;ulDriveNum<MAX_DRIVES_PER_CONTROLLER;ulDriveNum++)
        {
            if ( !IS_IDE_DRIVE(ulDriveNum) )
                continue;

		    baseIoAddress1 = (PIDE_REGISTERS_1) DeviceExtension->BaseIoAddress1[(ulDriveNum>>1)];
		    baseIoAddress2 = (PIDE_REGISTERS_2) DeviceExtension->BaseIoAddress2[(ulDriveNum>>1)];

	        //
	        // Select device 0 or 1.
	        //

	        SELECT_DEVICE(baseIoAddress1, ulDriveNum);

	        //
	        // Check that the status register makes sense.
	        //

            // The call came here since there is a drive ... so let us not worry about whether there is any drive at this place
	        GET_BASE_STATUS(baseIoAddress1, statusByte);    

	        //
	        // Load CylinderHigh and CylinderLow with number bytes to transfer.
	        //

	        ScsiPortWritePortUchar(&baseIoAddress1->CylinderHigh, (0x200 >> 8));
	        ScsiPortWritePortUchar(&baseIoAddress1->CylinderLow,  (0x200 & 0xFF));

            WAIT_ON_BUSY(baseIoAddress1, statusByte);

	        //
	        // Send IDENTIFY command.
	        //
	        WAIT_ON_BUSY(baseIoAddress1,statusByte);

	        ScsiPortWritePortUchar(&baseIoAddress1->Command, IDE_COMMAND_IDENTIFY);

	        WAIT_ON_BUSY(baseIoAddress1,statusByte);

            if ( ( !( statusByte & IDE_STATUS_BUSY ) ) && ( !( statusByte & IDE_STATUS_DRQ ) ) )
            {
                // this is an error... so let us not try any more.
                FailDrive(DeviceExtension, (UCHAR)ulDriveNum);
                continue;
            }

            WAIT_ON_BUSY(baseIoAddress1,statusByte);

	        //
	        // Wait for DRQ.
	        //

	        for (i = 0; i < 4; i++) 
            {
		        WAIT_FOR_DRQ(baseIoAddress1, statusByte);

		        if (statusByte & IDE_STATUS_DRQ)
                {
                    break;
                }
            }

	        //
	        // Read status to acknowledge any interrupts generated.
	        //

	        GET_BASE_STATUS(baseIoAddress1, statusByte);

	        //
	        // Check for error on really stupid master devices that assert random
	        // patterns of bits in the status register at the slave address.
	        //

	        if ((statusByte & IDE_STATUS_ERROR)) 
            {
                FailDrive(DeviceExtension, (UCHAR)ulDriveNum);
                continue;
	        }

	        DebugPrint((1, "CheckDrivesResponse: Status before read words %x\n", statusByte));

	        //
	        // Suck out 256 words. After waiting for one model that asserts busy
	        // after receiving the Packet Identify command.
	        //

	        WAIT_ON_BUSY(baseIoAddress1,statusByte);

	        if ( (!(statusByte & IDE_STATUS_DRQ)) || (statusByte & IDE_STATUS_BUSY) ) 
            {
                FailDrive(DeviceExtension, (UCHAR)ulDriveNum);
                continue;
	        }

	        READ_BUFFER(baseIoAddress1, (PUSHORT)aucIdentifyBuf, 256);

            DebugPrint((0, "capabilities->AdvancedPioModes : %x on ulDriveNum : %ld\n", (ULONG)capabilities->AdvancedPioModes, ulDriveNum ));
            DebugPrint((0, "capabilities->MultiWordDmaSupport : %x\n", (ULONG)capabilities->MultiWordDmaSupport ));
            DebugPrint((0, "capabilities->MultiWordDmaActive : %x\n", (ULONG)capabilities->MultiWordDmaActive ));
            DebugPrint((0, "capabilities->UltraDmaSupport : %x\n", (ULONG)capabilities->UltraDmaSupport ));
            DebugPrint((0, "capabilities->UltraDmaActive : %x\n", (ULONG)capabilities->UltraDmaActive ));

	        //
	        // Work around for some IDE and one model Atapi that will present more than
	        // 256 bytes for the Identify data.
	        //

	        WAIT_ON_BUSY(baseIoAddress1,statusByte);

	        for (i = 0; i < 0x10000; i++) 
            {
		        GET_STATUS(baseIoAddress1,statusByte);

		        if (statusByte & IDE_STATUS_DRQ) 
                {
			        //
			        // Suck out any remaining bytes and throw away.
			        //

			        ScsiPortReadPortUshort(&baseIoAddress1->Data);

		        } 
                else 
                {
			        break;
		        }
            }
    }

    return TRUE;

    }

#endif

    return TRUE;
}


BOOLEAN StopDrives(PHW_DEVICE_EXTENSION DeviceExtension)
{
	PIDE_REGISTERS_1 baseIoAddress1;
    ULONG ulDrvInd;
    UCHAR ucStatus;

	for(ulDrvInd=0;ulDrvInd<MAX_DRIVES_PER_CONTROLLER;ulDrvInd++)
	{
        if ( IS_IDE_DRIVE(ulDrvInd) )
        {
            FlushCache(DeviceExtension, (UCHAR)ulDrvInd);

            if (DeviceExtension->PhysicalDrive[ulDrvInd].bPwrMgmtSupported)
            {
        	    baseIoAddress1 = DeviceExtension->BaseIoAddress1[ulDrvInd>>1];

                // Issue Stand By Immediate
                SELECT_DEVICE(baseIoAddress1, ulDrvInd);
                WAIT_ON_BASE_BUSY(baseIoAddress1, ucStatus);
    		    ScsiPortWritePortUchar(&baseIoAddress1->Command, IDE_COMMAND_STANDBY_IMMEDIATE);
                WAIT_ON_BASE_BUSY(baseIoAddress1, ucStatus);
                WAIT_ON_BASE_BUSY(baseIoAddress1, ucStatus);
            }
        }
	}
    return TRUE;
}

BOOLEAN
EnableInterruptsOnAllChannels(
    IN PHW_DEVICE_EXTENSION DeviceExtension
    )
{
    ULONG ulController;
    PBM_REGISTERS         BMRegister = NULL;
    UCHAR opcimcr;

    for(ulController=0;ulController<gucControllerCount;ulController++)
    {
         // always take first channels base bm address register
        BMRegister = (gaCardInfo[ulController].pDE)->BaseBmAddress[0];

        //
        // Enable the Interrupt notification so that further interrupts are got.
        // This is done because, there is no interrupt handler at the time
        // before the actual registration of the Int. handler..
        //
        opcimcr = ScsiPortReadPortUchar(((PUCHAR)BMRegister + 1));
        opcimcr &= 0xCF;
        // Begin Vasu - 7 Feb 2001
        // Enable Read Multiple here as this is the place where we write this register back.
        opcimcr &= 0xF0; // Dont Clear Interrupt Pending Flags.
        opcimcr |= 0x01;
        // End Vasu
        ScsiPortWritePortUchar(((PUCHAR)BMRegister + 1), opcimcr);
    }

    return TRUE;
}

BOOLEAN
DisableInterruptsOnAllChannels(
    IN PHW_DEVICE_EXTENSION DeviceExtension
    )
{
    ULONG ulController;
    PBM_REGISTERS         BMRegister = NULL;
    UCHAR opcimcr;

    for(ulController=0;ulController<gucControllerCount;ulController++)
    {
         // always take first channels base bm address register
        BMRegister = (gaCardInfo[ulController].pDE)->BaseBmAddress[0];
        //
        // Enable the Interrupt notification so that further interrupts are got.
        // This is done because, there is no interrupt handler at the time
        // before the actual registration of the Int. handler..
        //
        opcimcr = ScsiPortReadPortUchar(((PUCHAR)BMRegister + 1));
        opcimcr |= 0x30;
        // Begin Vasu - 7 Feb 2001
        // Enable Read Multiple here as this is the place where we write this register back.
        opcimcr &= 0xF0; // Dont Clear Interrupt Pending Flags.
        opcimcr |= 0x01;
        // End Vasu
        ScsiPortWritePortUchar(((PUCHAR)BMRegister + 1), opcimcr);
    }

    return TRUE;
}

ULONG ReadFromPCISpace
            (
                PHW_DEVICE_EXTENSION DeviceExtension,
                PULONG pulData,
                ULONG ulPCIConfigIndex,
                ULONG ulLength
            )
// Right now this function can read only DWORDS from PCI Space
{
    ULONG ulPCICode, ulPCIValue;
    ULONG  ulpciBus, ulpciDevice, ulpciFunction;

    ulpciBus = DeviceExtension->BusNumber;
    ulpciDevice = DeviceExtension->PciSlot.u.bits.DeviceNumber;
    ulpciFunction = DeviceExtension->PciSlot.u.bits.FunctionNumber;

    ulPCICode = 0x80000000 | (ulpciFunction<<0x8) | (ulpciDevice<<0xb) | (ulpciBus<<0x10) | (ulPCIConfigIndex);
    _asm 
    {
        push eax
        push edx
        push ebx

        mov edx, 0cf8h
        mov eax, ulPCICode
        out dx, eax

        add dx, 4
        in eax, dx
        mov ulPCIValue, eax

        pop ebx
        pop edx
        pop eax
    }

    DebugPrint((0, "\tRead %x:%x:", ulPCICode, ulPCIValue));

    *pulData = ulPCIValue;

    return ulLength;
}

ULONG WriteToPCISpace
            (
                PHW_DEVICE_EXTENSION DeviceExtension,
                ULONG ulPCIValue,
                ULONG ulAndMask,
                ULONG ulPCIConfigIndex,
                ULONG ulLength
            )
// Right now this function can read only DWORDS from PCI Space
{
    ULONG ulPCICode;
    ULONG ulpciBus, ulpciDevice, ulpciFunction;

    ulpciBus = DeviceExtension->BusNumber;
    ulpciDevice = DeviceExtension->PciSlot.u.bits.DeviceNumber;
    ulpciFunction = DeviceExtension->PciSlot.u.bits.FunctionNumber;

    ulPCICode = 0x80000000 | (ulpciFunction<<0x8) | (ulpciDevice<<0xb) | (ulpciBus<<0x10) | (ulPCIConfigIndex);

    switch (ulPCIConfigIndex)
    {
    case 0x70:
    case 0x78:
        ulAndMask = ulAndMask & (~0xff);
        break;
    }

    DebugPrint((0, "\tWritting %x:%x:", ulPCICode, ulPCIValue));

    _asm 
    {
        push eax
        push edx
        push ebx

        mov edx, 0cf8h
        mov eax, ulPCICode
        out dx, eax

        mov eax, ulPCIValue
        add dx, 4
        in eax, dx

        and eax, ulAndMask
        or eax, ulPCIValue      // read the current value and restore the reserve values
        mov ebx, eax            // take a back up

        sub dx, 4   
        mov eax, ulPCICode      // Select the register again
        out dx, eax

        add dx, 4
        mov eax, ebx
        out dx, eax             // Write the desired value

        pop ebx
        pop edx
        pop eax
    }

    return ulLength;
}

#endif  // #ifdef HYPERDISK_WIN2K
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\port\scsi\miniport\megaraid\const.h ===
/*******************************************************************/
/*                                                                 */
/* NAME             = Const.h                                      */
/* FUNCTION         = Header file all const value and flags;       */
/* NOTES            =                                              */
/* DATE             = 02-03-2000                                   */
/* HISTORY          = 001, 02-03-00, Parag Ranjan Maharana;        */
/* COPYRIGHT        = LSI Logic Corporation. All rights reserved;  */
/*                                                                 */
/*******************************************************************/
#ifndef _CONST_H
#define _CONST_H


#define MAX_RETRY    3
//
//define other options
//
#define CHEYENNE_BUG_CORRECTION	1

#define TOSHIBA						1
//#define MRAID_762					1
#define MRAID_SYNC				1

#define MRAID_TIMEOUT					1
// #define TOSHIBA_SFR				1 
// #define MRAID_SFR_DEBUG		1 

#define COALESE_COMMANDS				1

//#define AMILOGIC        				1


#define ONE_MEGA_BYTE							(1024L * 1024L)
#define FOUR_KILO_BYTE						(1024L * 4L)
#define FOUR_KB										(4 * 1024)

#define MAXIMUM_TRANSFER_LENGTH		(2L * ONE_MEGA_BYTE)
#define MAXIMUM_SGL_DESCRIPTORS   63

#ifdef  CHEYENNE_BUG_CORRECTION		
		#define DEFAULT_SGL_DESCRIPTORS					17
		#define DEFAULT_TRANSFER_LENGTH					(64L * 1024) //64k 
#else		
		#define DEFAULT_SGL_DESCRIPTORS					16
		#define DEFAULT_TRANSFER_LENGTH					0x0f000
#endif

#define MINIMUM_TRANSFER_LENGTH	(DEFAULT_SGL_DESCRIPTORS * FOUR_KILO_BYTE)

#define	FW_8SPAN_DEPTH				8
#define	FW_4SPAN_DEPTH				4
#define FW_UNKNOWNSPAN_DEPTH	0xff

#define MAX_DEVICE_DEPTH		8		/* Maximum device depth allowed */
//#define MAX_ROW_SIZE				8		/* Maximum number of stripes in a row */
#define MAX_STRIPES					8

#define STRIPE_SIZE_8K			16 //16 512byte blocks
#define STRIPE_SIZE_16K			32
#define STRIPE_SIZE_32K			64
#define STRIPE_SIZE_64K			128
#define STRIPE_SIZE_128K		0 //256 blocks 

#define STRIPE_SIZE_UNKNOWN 255


//
//structure update states
//
#define UPDATE_STATE_ADAPTER_INQUIRY		1
#define UPDATE_STATE_DISK_ARRAY					2
#define UPDATE_STATE_NONE								0


#define MAX_LOGICAL_DRIVES       40
#define MAX_SPAN_DEPTH           8
#define MAX_ROW_SIZE             32

#define MAX_ISP                  2
#define MAX_CHANNELS             16
#define MAX_TARGETS_PER_CHANNEL  16
#define MAX_PHYSICAL_DEVICES     256
#define MAX_LUN_PER_TARGET       8

#define MAX_ROW_SIZE_40LD              32

//currently = 256 . Defined in fw_struc.h
#define MAX_PHYSICAL_DEVICES_40LD     MAX_PHYSICAL_DEVICES 


#define MAX_LOGICAL_DRIVES_40	40
#define MAX_LOGICAL_DRIVES_8  8

#define MAX_ROW_SIZE_8LD             8

#define MAX_CHANNELS_8LD             5
#define MAX_TARGETS_PER_CHANNEL_8LD  16

//currently = 75
#define MAX_PHYSICAL_DEVICES_8LD     \
        ((MAX_CHANNELS_8LD * MAX_TARGETS_PER_CHANNEL_8LD)-(MAX_CHANNELS_8LD))

//READ64 and WRITE64
#define MRAID_READ_LARGE_MEMORY     (0xA7)
#define MRAID_WRITE_LARGE_MEMORY    (0xA8)

#define UNKNOWN_DEVICE              (0x1F)
#define UNKNOWN_DEVICE_TARGET_ID    (0x0F)
#define UNKNOWN_DEVICE_LUN          (0x00)

#define OEM_VENDOR_AMI    "MEGARAID"
#define OEM_VENDOR_HP     "HPNetRD "
#define OEM_VENDOR_SDI    "RAIDCard"
#define OEM_VENDOR_ADAC   "ADAC    "
#define OEM_VENDOR_TRAC   "TRAC    "
#define OEM_VENDOR_DELL   "PERC    "

#define OEM_PRODUCT_AMI    " LD XY MEGARAID "
#define OEM_PRODUCT_HP     " LD XY NetRAID  "
#define OEM_PRODUCT_DELL   " LD XY PERCRAID "
#define OEM_PRODUCT_ID     " LD XY RAID     "

#define SUBSYSTEM_VENDOR_AMI      (0x101E)
#define SUBSYSTEM_VENDOR_HP       (0x103C)
#define SUBSYSTEM_VENDOR_DELL     (0x1111)
#define SUBSYSTEM_VENDOR_EP_DELL  (0x1028)
#define OLD_DELL_DEVICE_ID        (0x09A0)


#define DEFAULT_INITIATOR_ID       (0x7)

#define MEGARAID_SUCCESS            (0x0)
#define MEGARAID_FAILURE            (0x1)

#define MRAID_SECTOR_SIZE           (512)

#define MRAID_INVALID_HOST_ADDRESS  (0xFFFFFFFF)

#define DEC_BRIDGE_DEVICE_ID  (0x0026)
#define DEC_BRIDGE_VENDOR_ID  (0x1011)

#define AMILOGIC_CHIP_DEVICE_ID  (0x1216)
#define AMILOGIC_CHIP_VENDOR_ID  (0x1077)
//New vendorID and deviceID of DEC Bridge 21154.
#define DEC_BRIDGE_VENDOR_ID2  (0x8086)
#define DEC_BRIDGE_DEVICE_ID2  (0xB154)

#define MAX_AMILOGIC_CHIP_COUNT   (2)

#define TWO                        2

#ifdef _WIN64
#define MEGARAID_PAGE_SIZE  0x2000
#else
#define MEGARAID_PAGE_SIZE  0x1000
#endif

#define SUBSYTEM_DEVICE_ID_ELITE1600       0x0493
#define SUBSYTEM_DEVICE_ID_ENTERPRISE1600  0x0471
#define SUBSYTEM_DEVICE_ID_EXPRESS500      0x0475

#define SUBSYTEM_DEVICE_ID_1_M             0x60E7
#define SUBSYTEM_DEVICE_ID_2_M             0x60E8






#endif //_CONST_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\port\scsi\miniport\megaraid\extendedsgl.h ===
/*******************************************************************/
/*                                                                 */
/* NAME             = ExtendedSGL.H                                */
/* FUNCTION         = Header file of Extended SGL data stucture;   */
/* NOTES            =                                              */
/* DATE             = 02-03-2000                                   */
/* HISTORY          = 001, 02-03-00, Parag Ranjan Maharana;        */
/* COPYRIGHT        = LSI Logic Corporation. All rights reserved;  */
/*                                                                 */
/*******************************************************************/

#ifndef _EXTENDED_SGL_H
#define _EXTENDED_SGL_H

#define MAIN_MISC_OPCODE		0xA4
#define GET_MAX_SG_SUPPORT	0x1

typedef struct _MBOX_SG_SUPPORT{

		UCHAR   Opcode;
		UCHAR   Id;
		UCHAR		SubOpcode;
}MBOX_SG_SUPPORT, *PMBOX_SG_SUPPORT;


typedef struct _SG_ELEMENT_COUNT{

	ULONG32	AllowedBreaks;

}SG_ELEMENT_COUNT, *PSG_ELEMENT_COUNT;

//
//Functions prototype
//
void
GetAndSetSupportedScatterGatherElementCount(
    PHW_DEVICE_EXTENSION	DeviceExtension,
    PUCHAR								PciPortStart,
    UCHAR									RPFlag);


#endif //of _EXTENDED_SGL_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\port\scsi\miniport\megaraid\fwdatastructure40.h ===
/*******************************************************************/
/*                                                                 */
/* NAME             = FwDataStructure40.h                          */
/* FUNCTION         = Structure Declarations for the Firmware      */
/*                    supporting 40 Logical Drives and 256         */
/*                    Physical Drives;                             */
/* NOTES            =                                              */
/* DATE             = 02-03-2000                                   */
/* HISTORY          = 001, 02-03-00, Parag Ranjan Maharana;        */
/* COPYRIGHT        = LSI Logic Corporation. All rights reserved;  */
/*                                                                 */
/*******************************************************************/

#ifndef _FW_DATA_STRUCTURE_40_H
#define _FW_DATA_STRUCTURE_40_H



/********************************************
 * PRODUCT_INFO Strucure
 ********************************************/
/* 
 * Utilities declare this strcture size as 1024 bytes. So more fields can
 * be added in future.
 */

struct MRaidProductInfo
{
    ULONG32   DataSize; /* current size in bytes (not including resvd) */
    ULONG32   ConfigSignature;
                         /* Current value is 0x00282008
                          * 0x28=MAX_LOGICAL_DRIVES, 
                          * 0x20=Number of stripes and 
                          * 0x08=Number of spans */
    UCHAR   FwVer[16];         /* printable ASCI string */
    UCHAR   BiosVer[16];       /* printable ASCI string */
    UCHAR   ProductName[80];   /* printable ASCI string */

    UCHAR   MaxConcCmds;       /* Max. concurrent commands supported */
    UCHAR   SCSIChanPresent;   /* Number of SCSI Channels detected */
    UCHAR   FCLoopPresent;     /* Number of Fibre Loops detected */
    UCHAR   memType;           /* EDO, FPM, SDRAM etc */

    ULONG32   signature;
    USHORT  DramSize;          /* In terms of MB */
    USHORT  subSystemID;

    USHORT  subSystemVendorID;
    UCHAR   numNotifyCounters;  /* Total counters in notify struc */
    /* 
    * Add reserved field so that total size is 1K 
    */
};

/********************************************
 * NOTIFICATION Strucure
 ********************************************/

#define MAX_NOTIFY_SIZE     0x80
#define CUR_NOTIFY_SIZE     sizeof(struct MegaRAID_Notify)

//#pragma noalign(MegaRAID_Notify)
/* 
 * Utilities declare this strcture size as ?? bytes. So more fields can
 * be added in future.
 */
struct MegaRAID_Notify
{
    ULONG32   globalCounter;  /* Any change increments this counter */

    UCHAR   paramCounter;   /* Indicates any params changed  */
    UCHAR   paramId;        /* Param modified - defined below */
    USHORT  paramVal;       /* New val of last param modified */

    UCHAR   writeConfigCounter; /* write config occurred */
    UCHAR   writeConfigRsvd[3];

    UCHAR   ldrvOpCounter;  /* Indicates ldrv op started/completed */
    UCHAR   ldrvOpId;       /* ldrv num */
    UCHAR   ldrvOpCmd;      /* ldrv operation - defined below */
    UCHAR   ldrvOpStatus;   /* status of the operation */

    UCHAR   ldrvStateCounter;   /* Indicates change of ldrv state */
    UCHAR   ldrvStateId;    /* ldrv num */
    UCHAR   ldrvStateNew;   /* New state */
    UCHAR   ldrvStateOld;   /* old state */

    UCHAR   pdrvStateCounter;   /* Indicates change of ldrv state */
    UCHAR   pdrvStateId;    /* pdrv id */
    UCHAR   pdrvStateNew;   /* New state */
    UCHAR   pdrvStateOld;   /* old state */

    UCHAR   pdrvFmtCounter; /* Indicates pdrv format started/over */
    UCHAR   pdrvFmtId;      /* pdrv id */
    UCHAR   pdrvFmtVal;     /* format started/over */
    UCHAR   pdrvFmtRsvd;

    UCHAR   targXferCounter;    /* Indicates SCSI-2 Xfer rate change */
    UCHAR   targXferId;     /* pdrv Id  */
    UCHAR   targXferVal;    /* new Xfer params of last pdrv */
    UCHAR   targXferRsvd;

    UCHAR   fcLoopIdChgCounter; /* Indicates loopid changed */
    UCHAR   fcLoopIdPdrvId; /* pdrv id */
    UCHAR   fcLoopId0;      /* loopid on fc loop 0 */
    UCHAR   fcLoopId1;      /* loopid on fc loop 1 */

    UCHAR   fcLoopStateCounter; /* Indicates loop state changed */
    UCHAR   fcLoopState0;   /* state of fc loop 0 */
    UCHAR   fcLoopState1;   /* state of fc loop 1 */
    UCHAR   fcLoopStateRsvd;
};

/********************************************
 * PARAM IDs in Notify struct
 ********************************************/
#define PARAM_RBLD_RATE                 0x01
    /*--------------------------------------
     * Param val = 
     *      byte 0: new rbld rate 
     *--------------------------------------*/
#define PARAM_CACHE_FLUSH_INTERVAL      0x02
    /*--------------------------------------
     * Param val = 
     *      byte 0: new cache flush interval
     *--------------------------------------*/
#define PARAM_SENSE_ALERT               0x03
    /*--------------------------------------
     * Param val = 
     *      byte 0: last pdrv id causing chkcond
     *--------------------------------------*/
#define PARAM_DRIVE_INSERTED            0x04
    /*--------------------------------------
     * Param val = 
     *      byte 0: last pdrv id inserted
     *--------------------------------------*/
#define PARAM_BATTERY_STATUS            0x05
    /*--------------------------------------
     * Param val = 
     *      byte 0: battery status
     *--------------------------------------*/

/********************************************
 * Ldrv operation cmd in Notify struct
 ********************************************/
#define LDRV_CMD_CHKCONSISTANCY         0x01
#define LDRV_CMD_INITIALIZE             0x02
#define LDRV_CMD_RECONSTRUCTION         0x03

/********************************************
 * Ldrv operation status in Notify struct
 ********************************************/
#define  LDRV_OP_SUCCESS                 0x00
#define  LDRV_OP_FAILED                  0x01
#define  LDRV_OP_ABORTED                 0x02
#define  LDRV_OP_CORRECTED               0x03
#define  LDRV_OP_STARTED                 0x04


/********************************************
 * Raid Logical drive states.
 ********************************************/
#define     RDRV_OFFLINE                0
#define     RDRV_DEGRADED               1
#define     RDRV_OPTIMAL                2
#define     RDRV_DELETED                3

/*******************************************
 * Physical drive states.
 *******************************************/
#define     PDRV_UNCNF                  0
#define     PDRV_ONLINE                 3
#define     PDRV_FAILED                 4
#define     PDRV_RBLD                   5
#define     PDRV_HOTSPARE               6

/*******************************************
 * Formal val in Notify struct
 *******************************************/
#define PDRV_FMT_START                  0x01
#define PDRV_FMT_OVER                   0x02

/********************************************
 * FC Loop State in Notify Struct
 ********************************************/
#define ENQ_FCLOOP_FAILED               0
#define ENQ_FCLOOP_ACTIVE               1
#define ENQ_FCLOOP_TRANSIENT            2



/********************************************
 * ENQUIRY3 Strucure
 ********************************************/
/* 
 * Utilities declare this strcture size as 1024 bytes. So more fields can
 * be added in future.
 */
struct MegaRAID_Enquiry3
{
   ULONG32   dataSize; /* current size in bytes (not including resvd) */

   struct MegaRAID_Notify   notify;

   UCHAR   notifyRsvd[MAX_NOTIFY_SIZE - CUR_NOTIFY_SIZE];

   UCHAR   rbldRate;     /* Rebuild rate (0% - 100%) */
   UCHAR   cacheFlushInterval; /* In terms of Seconds */
   UCHAR   senseAlert;
   UCHAR   driveInsertedCount; /* drive insertion count */

   UCHAR   batteryStatus;
   UCHAR   numLDrv;              /* No. of Log Drives configured */
   UCHAR   reconState[MAX_LOGICAL_DRIVES/8]; /* State of reconstruct */
   USHORT  lDrvOpStatus[MAX_LOGICAL_DRIVES/8]; /* log. Drv Status */

   ULONG32   lDrvSize[MAX_LOGICAL_DRIVES];  /* Size of each log. Drv */
   UCHAR   lDrvProp[MAX_LOGICAL_DRIVES];
   UCHAR   lDrvState[MAX_LOGICAL_DRIVES]; /* State of Logical Drives */
   UCHAR   pDrvState[MAX_PHYSICAL_DEVICES];  /* State of Phys. Drvs. */
   USHORT  physDrvFormat[MAX_PHYSICAL_DEVICES/16];

   UCHAR   targXfer[80];               /* phys device transfer rate */
   /* 
    * Add reserved field so that total size is 1K 
    */
};

/********************************************
 * Standard ENQUIRY Strucure
 ********************************************/
struct ADP_INFO
{
    UCHAR  MaxConcCmds;         /* Max. concurrent commands supported. */
    UCHAR  RbldRate;            /* Rebuild Rate. Varies from 0%-100% */
    UCHAR  MaxTargPerChan;      /* Max. Targets supported per chan. */
    UCHAR  ChanPresent;         /* No. of Chans present on this adapter. */
    UCHAR  FwVer[4];            /* Firmware version. */
    USHORT AgeOfFlash;          /* No. of times FW has been downloaded. */
    UCHAR  ChipSetValue;        /* Contents of 0xC0000832 */
    UCHAR  DramSize;            /* In terms of MB */
    UCHAR  CacheFlushInterval;  /* In terms of Seconds */
    UCHAR  BiosVersion[4];
    UCHAR  BoardType;
    UCHAR  sense_alert;
    UCHAR  write_config_count;   /* Increase with evry configuration change */
    UCHAR  drive_inserted_count; /* Increase with every drive inserted */
    UCHAR  inserted_drive;       /* Channel: Id of inserted drive */
    UCHAR  battery_status;
                           /*
                              BIT 0 : battery module missing
                              BIT 1 : VBAD
                              BIT 2 : temp high
                              BIT 3 : battery pack missing
                              BIT 4,5 : 00 - charge complete
                                        01 - fast charge in prog
                                        10 - fast charge fail
                                        11 - undefined
                              BIt 6 : counter > 1000
                              Bit 7 : undefined
                           */
    UCHAR  dec_fault_bus_info;   /* was resvd */
};

struct LDRV_INFO
{
    UCHAR  NumLDrv;      /* No. of Log. Drvs configured. */
    UCHAR  recon_state[MAX_LOGICAL_DRIVES/8];    
                                /* bit field for State of reconstruct */
    USHORT LDrvOpStatus[MAX_LOGICAL_DRIVES/8];   
                                /* bit field Status of Long Operations. */

    ULONG32  LDrvSize[MAX_LOGICAL_DRIVES];   /* Size of each log. Drv. */
    UCHAR  LDrvProp[MAX_LOGICAL_DRIVES];
    UCHAR  LDrvState[MAX_LOGICAL_DRIVES];  /* State of Logical Drives. */
};

#define PREVSTAT_MASK   0xf0
#define CURRSTAT_MASK   0x0f

struct PDRV_INFO
{
    UCHAR PDrvState[MAX_PHYSICAL_DEVICES]; /* State of Phys Drvs. */
};

typedef struct _MEGARaid_INQUIRY
{
    struct ADP_INFO    AdpInfo;
    struct LDRV_INFO   LogdrvInfo;
    struct PDRV_INFO   PhysdrvInfo;
}MEGARaid_INQUIRY, *PMEGARaid_INQUIRY;

/********************************************
 * Extended ENQUIRY Strucure
 ********************************************/
struct MRaid_Ext_Inquiry
{
    struct ADP_INFO  AdpInfo;
    struct LDRV_INFO LogdrvInfo;
    struct PDRV_INFO PhysdrvInfo;
    USHORT   PhysDrvFormat[MAX_CHANNELS];
    UCHAR    StackAttention;  /* customized for Core */
    UCHAR    ModemStatus;
    UCHAR    Reserved[2];
};

/********************************************
 * ENQUIRY2 Strucure
 ********************************************/
struct MRaid_Ext_Inquiry_2
{
    struct ADP_INFO   AdpInfo;
    struct LDRV_INFO  LogdrvInfo;
    struct PDRV_INFO  PhysdrvInfo;
    USHORT    PhysDrvFormat[MAX_CHANNELS];
    UCHAR     StackAttention;  /* customized for Core */
    UCHAR     ModemStatus;
    UCHAR     Reserved[4];
    ULONG32     extendedDataSize;
    USHORT    subSystemID;
    USHORT    subSystemVendorID;
    ULONG32     signature;
    UCHAR     targInfo[80];
    ULONG32     fcLoopIDChangeCount;
    UCHAR     fcLoopState[MAX_ISP];
    /* 
    * Add reserved field so that total size is 1K 
    */
};

/********************************************
 * DISK_ARRAY Strucure
 ********************************************/
struct APP_PHYS_DRV
{
    UCHAR  type;           /* Used for dedicated hotspare */
    UCHAR  curr_status;    /* Current configuration status */
    UCHAR  loopID[2];
    ULONG32  size;           /* Reserved Field. */
};

struct APP_DEVICE
{
    UCHAR channel;       /* This field is reserved */
    UCHAR target;        /* This is an index in the PHYS_DRV array */
};

struct APP_SPAN
{
    ULONG32     start_blk;              /* Starting Block */
    ULONG32     num_blks;               /* Number of blocks */
    struct APP_DEVICE device[MAX_ROW_SIZE];
};

struct APP_LOG_DRV
{
    UCHAR span_depth;        /* Total Number of Spans */
    UCHAR level;             /* RAID level */
    UCHAR read_ahead;        /* No READ_AHEAD or user opted for READ_AHEAD
                                     * or adaptive READ_AHEAD */
    UCHAR StripeSize;        /* Encoded Stripe Size */
    UCHAR status;            /* Status of the logical drive */
    UCHAR write_mode;        /* WRITE_THROUGH or WRITE_BACK */
    UCHAR direct_io;         /* DIRECT IO or through CACHE */
    UCHAR row_size;          /* Number of stripes in a row */
    struct APP_SPAN span[MAX_SPAN_DEPTH];
};

struct APP_DISK_ARRAY
{
    UCHAR  num_log_drives;        /* Number of logical drives */
    UCHAR  pad[3];
    struct APP_LOG_DRV log_drv[MAX_LOGICAL_DRIVES];
    struct APP_PHYS_DRV phys_drv[MAX_PHYSICAL_DEVICES];
};

/********************************************
 * NEW_DRVGROUP_INFO Strucure
 ********************************************/
struct NewDeviceInformation
{
    UCHAR newDevType;
    UCHAR newDevLoopID[2];
    UCHAR resvd;
};

struct NewDrvGroupInfo
{
    UCHAR numNewDevs;
    UCHAR numFailedDevs;
    struct NewDeviceInformation newDevInfo[MAX_SPAN_DEPTH * MAX_ROW_SIZE];
};

/********************************************
 * FAILED_DEV_LOOPID Strucure
 ********************************************/
struct FailedDevLoopID
{
    UCHAR numFailedDevs;
    UCHAR failedDevLoopID[MAX_SPAN_DEPTH][2];
};

/*****************************************************************************
    New Structure
*****************************************************************************/
struct FW_DEVICE_40LD
{
    UCHAR channel;
    UCHAR target;        /* LUN is always 0 for disk devices */
};

typedef struct _FW_SPAN_40LD
{
    ULONG32  start_blk;      /* Starting Block */
    ULONG32  total_blks;      /* Number of blocks */
  
    struct FW_DEVICE_40LD device[MAX_ROW_SIZE_40LD];//32

}FW_SPAN_40LD, *PFW_SPAN_40LD;

typedef struct _FW_LOG_DRV_4SPAN_40LD
{
    UCHAR  span_depth;
    UCHAR  raid;
    UCHAR  read_ahead;

    UCHAR  stripe_sz;
    UCHAR  status;
    UCHAR  write_policy;

    UCHAR  direct_io;
    UCHAR  no_stripes;
    FW_SPAN_40LD  span[FW_4SPAN_DEPTH];   /* 4 */

}FW_LOG_DRV_4SPAN_40LD, *PFW_LOG_DRV_4SPAN_40LD;

typedef struct _FW_LOG_DRV_8SPAN_40LD
{
    UCHAR  span_depth;
    UCHAR  raid;
    UCHAR  read_ahead  ;

    UCHAR  stripe_sz;
    UCHAR  status;
    UCHAR  write_policy;

    UCHAR  direct_io;
    UCHAR  no_stripes;
    FW_SPAN_40LD  span[FW_8SPAN_DEPTH];   /* 8 */

}FW_LOG_DRV_8SPAN_40LD, *PFW_LOG_DRV_8SPAN_40LD;

typedef struct _FW_PHYS_DRV_40LD
{
    UCHAR type;      /* type of device */
    UCHAR curr_status;  /* Current status of the drive */
    UCHAR tag_depth;  /* Level of tagging 0=>DEflt, 1=Disabled, 2,3,4=>Tag_depth*/
    UCHAR sync;      /*Sync 0=>default, 1=>Enabled, 2=>disabled */
    ULONG32  size;      /* Configuration size in terms of 512 byte blocks */

}FW_PHYS_DRV_40LD, *PFW_PHYS_DRV_40LD;

typedef struct _FW_ARRAY_4SPAN_40LD
{
    UCHAR num_log_drives;      /* Number of logical drives */
    UCHAR pad[3];

    FW_LOG_DRV_4SPAN_40LD  log_drv[MAX_LOGICAL_DRIVES_40];
    FW_PHYS_DRV_40LD      phys_drv[MAX_PHYSICAL_DEVICES_40LD];

}FW_ARRAY_4SPAN_40LD, *PFW_ARRAY_4SPAN_40LD;

typedef struct _FW_ARRAY_8SPAN_40LD
{
    UCHAR num_log_drives;      /* Number of logical drives */
    UCHAR pad[3];

    FW_LOG_DRV_8SPAN_40LD  log_drv[MAX_LOGICAL_DRIVES_40];
    FW_PHYS_DRV_40LD      phys_drv[MAX_PHYSICAL_DEVICES_40LD];

}FW_ARRAY_8SPAN_40LD, *PFW_ARRAY_8SPAN_40LD;


#endif //_FW_DATA_STRUCTURE_40_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\port\scsi\miniport\megaraid\fwdatastructure8.h ===
/*******************************************************************/
/*                                                                 */
/* NAME             = FwDataStructure8.h                           */
/* FUNCTION         = Structure Declarations for the Firmware      */
/*                    supporting 8  Logical Drives and 256         */
/*                    Physical Drives;                             */
/* NOTES            =                                              */
/* DATE             = 02-03-2000                                   */
/* HISTORY          = 001, 02-03-00, Parag Ranjan Maharana;        */
/* COPYRIGHT        = LSI Logic Corporation. All rights reserved;  */
/*                                                                 */
/*******************************************************************/
#ifndef _FW_DATA_STRUCTURE_8_H
#define _FW_DATA_STRUCTURE_8_H

/********************************************
 * Standard ENQUIRY Strucure
 ********************************************/
#pragma pack(1)
struct ADP_INFO_8
{
   UCHAR  MaxConcCmds;         /* Max. concurrent commands supported. */
   UCHAR  RbldRate;            /* Rebuild Rate. Varies from 0%-100% */
   UCHAR  MaxTargPerChan;      /* Max. Targets supported per chan. */
   UCHAR  ChanPresent;         /* No. of Chans present on this adapter. */
   UCHAR  FwVer[4];            /* Firmware version. */
   USHORT AgeOfFlash;          /* No. of times FW has been downloaded. */
   UCHAR  ChipSetValue;        /* Contents of 0xC0000832 */
   UCHAR  DramSize;            /* In terms of MB */
   UCHAR  CacheFlushInterval;  /* In terms of Seconds */
   UCHAR  BiosVersion[4];
   UCHAR  BoardType;
   UCHAR  sense_alert;
   UCHAR  write_config_count;   /* Increase with evry configuration change */
   UCHAR  drive_inserted_count; /* Increase with every drive inserted */
   UCHAR  inserted_drive;       /* Channel: Id of inserted drive */
   UCHAR  battery_status;
                           /*
                              BIT 0 : battery module missing
                              BIT 1 : VBAD
                              BIT 2 : temp high
                              BIT 3 : battery pack missing
                              BIT 4,5 : 00 - charge complete
                                        01 - fast charge in prog
                                        10 - fast charge fail
                                        11 - undefined
                              BIt 6 : counter > 1000
                              Bit 7 : undefined
                           */
   UCHAR  dec_fault_bus_info;   /* was resvd */
};

#pragma pack(1)
struct LDRV_INFO_8
{
   UCHAR  NumLDrv;      /* No. of Log. Drvs configured. */
   UCHAR  recon_state[MAX_LOGICAL_DRIVES_8/8];    
                             /* bit field for State of reconstruct */
   USHORT LDrvOpStatus[MAX_LOGICAL_DRIVES_8/8];   
                             /* bit field Status of Long Operations. */
   ULONG32  LDrvSize[MAX_LOGICAL_DRIVES_8];
                             /* Size of each log. Drv. */
   UCHAR  LDrvProp[MAX_LOGICAL_DRIVES_8];
   UCHAR  LDrvState[MAX_LOGICAL_DRIVES_8];  
                            /* State of Logical Drives. */
};

#pragma pack(1)
struct PDRV_INFO_8
{
   UCHAR PDrvState[MAX_PHYSICAL_DEVICES]; 
                              /* State of Phys Drvs. */
};

#pragma pack(1)
typedef struct _MEGARaid_INQUIRY_8
{
   struct ADP_INFO_8    AdpInfo;
   struct LDRV_INFO_8   LogdrvInfo;
   struct PDRV_INFO_8   PhysdrvInfo;
}MEGARaid_INQUIRY_8, *PMEGARaid_INQUIRY_8;


struct FW_DEVICE_8LD
{
    UCHAR channel;
    UCHAR target;       /* LUN is always 0 for disk devices */
};

typedef struct _FW_SPAN_8LD
{
    ULONG32  start_blk;       /* Starting Block */
    ULONG32  total_blks;      /* Number of blocks */

    struct FW_DEVICE_8LD device[MAX_ROW_SIZE_8LD];//8

}FW_SPAN_8LD, *PFW_SPAN_8LD;

typedef struct _FW_LOG_DRV_4SPAN_8LD
{
    UCHAR  span_depth;
    UCHAR	raid;
    UCHAR  read_ahead;

    UCHAR	stripe_sz;
    UCHAR	status;
    UCHAR	write_policy;

    UCHAR	direct_io;
    UCHAR	no_stripes;
    FW_SPAN_8LD	span[FW_4SPAN_DEPTH];   /* 4 */

}FW_LOG_DRV_4SPAN_8LD, *PFW_LOG_DRV_4SPAN_8LD;

typedef struct _FW_LOG_DRV_8SPAN_8LD
{
    UCHAR  span_depth;
    UCHAR  raid;
    UCHAR  read_ahead	;

    UCHAR  stripe_sz;
    UCHAR  status;
    UCHAR  write_policy;

    UCHAR  direct_io;
    UCHAR  no_stripes;
    FW_SPAN_8LD    span[FW_8SPAN_DEPTH];   /* 8 */

}FW_LOG_DRV_8SPAN_8LD, *PFW_LOG_DRV_8SPAN_8LD;

typedef struct _FW_PHYS_DRV_8LD
{
    UCHAR type;         /* type of device */
    UCHAR curr_status;  /* Current status of the drive */
    UCHAR tag_depth;    /* Level of tagging 0=>DEflt, 1=Disabled, 2,3,4=>Tag_depth*/
    UCHAR sync;         /*Sync 0=>default, 1=>Enabled, 2=>disabled */
    ULONG32  size;        /* Configuration size in terms of 512 byte blocks */

}FW_PHYS_DRV_8LD, *PFW_PHYS_DRV_8LD;

typedef struct _FW_ARRAY_4SPAN_8LD
{
    UCHAR num_log_drives; /* Number of logical drives */
    UCHAR pad[3];

    FW_LOG_DRV_4SPAN_8LD log_drv[MAX_LOGICAL_DRIVES_8];
    FW_PHYS_DRV_8LD      phys_drv[MAX_PHYSICAL_DEVICES_8LD];

}FW_ARRAY_4SPAN_8LD, *PFW_ARRAY_4SPAN_8LD;

typedef struct _FW_ARRAY_8SPAN_8LD
{
    UCHAR num_log_drives;   /* Number of logical drives */
    UCHAR pad[3];

    FW_LOG_DRV_8SPAN_8LD  log_drv[MAX_LOGICAL_DRIVES_8];
    FW_PHYS_DRV_8LD       phys_drv[MAX_PHYSICAL_DEVICES_8LD];

}FW_ARRAY_8SPAN_8LD, *PFW_ARRAY_8SPAN_8LD;


#endif //_FW_DATA_STRUCTURE_8_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\port\scsi\miniport\megaraid\includes.h ===
/*******************************************************************/
/*                                                                 */
/* NAME             = INCLUDES.h                                   */
/* FUNCTION         = Header file for all include files;           */
/* NOTES            =                                              */
/* DATE             = 02-03-2000                                   */
/* HISTORY          = 001, 02-03-00, Parag Ranjan Maharana;        */
/* COPYRIGHT        = LSI Logic Corporation. All rights reserved;  */
/*                                                                 */
/*******************************************************************/
//
//include files
//

#include <miniport.h>
#include <scsi.h>



#include "Const.h"
#include "Adapter.h"
#include "Bios.h"

#define MegaPrintf

//
//force the byte alignment for the structure
//
#pragma pack(push,fwstruct_pack, 1)
#include "FwDataStructure8.h"
#include "FwDataStructure40.h"
#pragma pack(pop,fwstruct_pack, 1)

#include "MegaRAID.h"
#include "Miscellaneous.h"

#include "NewConfiguration.h"
#include "ReadConfiguration.h"


#include "MegaEnquiry.h"
#include "ExtendedSGL.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\port\scsi\miniport\megaraid\initialize.c ===
/*******************************************************************/
/*                                                                 */
/* NAME             = Initialize.C                                 */
/* FUNCTION         = Implementation of MegaRAIDInitialize routine;*/
/* NOTES            =                                              */
/* DATE             = 02-03-2000                                   */
/* HISTORY          = 001, 02-03-00, Parag Ranjan Maharana;        */
/* COPYRIGHT        = LSI Logic Corporation. All rights reserved;  */
/*                                                                 */
/*******************************************************************/


#include "includes.h"


//
//Logical Drive Info struct (global)
//
extern LOGICAL_DRIVE_INFO  gLDIArray;
extern UCHAR               globalHostAdapterOrdinalNumber;


/*********************************************************************
Routine Description:
	Inititialize adapter.

Arguments:
	HwDeviceExtension - HBA miniport driver's adapter data storage

Return Value:
	TRUE - if initialization successful.
	FALSE - if initialization unsuccessful.
**********************************************************************/
BOOLEAN
MegaRAIDInitialize(
	IN PVOID HwDeviceExtension
	)
{
	PHW_DEVICE_EXTENSION deviceExtension = HwDeviceExtension;
	PNONCACHED_EXTENSION noncachedExtension;	

	PMEGARaid_INQUIRY_8  raidParamEnquiry_8ldrv;
	PMEGARaid_INQUIRY_40 raidParamEnquiry_40ldrv;
	PUCHAR							raidParamFlatStruct;

	PUCHAR pciPortStart;
	
	ULONG32  length;
	UCHAR  status;

	ULONG32	 raidParamStructLength =0;

	FW_MBOX mbox;

	DebugPrint((0, "\nEntering MegaRAIDInitialize\n"));

  noncachedExtension = deviceExtension->NoncachedExtension;
	pciPortStart = deviceExtension->PciPortStart;

	//Initialize the MailBox
  MegaRAIDZeroMemory(&mbox, sizeof(FW_MBOX));
  
  //
	// We work in polled mode for Init, so disable Interrupts.
	//
	if (noncachedExtension->RPBoard == 0)
		ScsiPortWritePortUchar(pciPortStart+INT_ENABLE, MRAID_DISABLE_INTERRUPTS);

  if(!deviceExtension->IsFirmwareHanging)
  {
	  //
	  //check for the supported logical drive count. The disk array
	  //structures for the 8Log Drive & 40Log Drive firmware are different.
	  //Also, a 8/40Log Drive firmware may support 4SPAN or a 8SPAN device
	  //structure.
	  //A firmware will have ONLY ONE of the following combination:
	  //
	  //			LogicalDrive Support		SPAN
	  //						8										8
	  //						8										4
	  //						40									8
	  //						40									4
	  //Since only one of them is valid for a firmware there are four
	  //structures defined in a {union} in the NonCachedExtension structure.
	  //
	  if(deviceExtension->SupportedLogicalDriveCount == MAX_LOGICAL_DRIVES_8)
	  {
		  //
		  //get the span information along with the disk array structure.
		  //The span information is returned in 
		  //			DeviceExtension->NoncachedExtension->ArraySpanDepth 
		  //Possible values for ArraySpanDepth:FW_8SPAN_DEPTH (or) FW_4SPAN_DEPTH

		  Find8LDDiskArrayConfiguration(deviceExtension);						
	  }
	  else
	  {
		  //
		  //get the span information along with the disk array structure.
		  //The span information is returned in 
		  //			DeviceExtension->NoncachedExtension->ArraySpanDepth 
		  //Possible values for ArraySpanDepth:FW_8SPAN_DEPTH (or) FW_4SPAN_DEPTH
		  if( Find40LDDiskArrayConfiguration(deviceExtension) != 0)
		  {
			  //error in reading disk array config for 40logical drive.
			  //
			  return(FALSE);
		  }
    }


	  //
	  // Issue Adapter Enquiry command.
	  //
	  //mParam =(PMRAID_ENQ)&NoncachedExtension->MRAIDParams;
	  
	  //MRAIDParams is a UNION.It does not matter whether we set
	  //raidParamFlatStruct to MRAIDParams8 or MRAIDParams40.
	  //
	  raidParamFlatStruct =
		  (PUCHAR)&noncachedExtension->MRAIDParams.MRAIDParams8;

	  if(deviceExtension->SupportedLogicalDriveCount == MAX_LOGICAL_DRIVES_8)
	  {
			  raidParamStructLength = sizeof(MEGARaid_INQUIRY_8);
	  }
	  else
	  {
			  raidParamStructLength = sizeof(MEGARaid_INQUIRY_40);
	  }

	  mbox.u.Flat2.DataTransferAddress = MegaRAIDGetPhysicalAddressAsUlong(deviceExtension, 
														                          NULL, 
														                          raidParamFlatStruct, 
														                          &length);

	  //
	  // Check the contiguity of the physical region. Return Failure if the
	  // region is not contiguous.
	  //
	  if(length < raidParamStructLength)
    { 
      DebugPrint((0, "\n **** ERROR Buffer Length is less than required size, ERROR ****"));
		  //return(FALSE);
	  }

	  //
	  //CAST to MegaRAID_Enquiry_8 & MegaRAID_Enquiry3 structures
	  //
	  raidParamEnquiry_8ldrv  = (PMEGARaid_INQUIRY_8)raidParamFlatStruct;
	  raidParamEnquiry_40ldrv = (PMEGARaid_INQUIRY_40)raidParamFlatStruct;

	  //
	  // Initialize the number of logical drives found.
	  //
	  if(deviceExtension->SupportedLogicalDriveCount == MAX_LOGICAL_DRIVES_8)
	  {
		  //
		  // Fill the Mailbox for the normal Enquiry command. 40 logical
		  // drive firmwares do not support his opcode anymore.
		  //
		  //
		  mbox.Command   = MRAID_DEVICE_PARAMS;
		  mbox.CommandId = 0xFE;

		  raidParamEnquiry_8ldrv->LogdrvInfo.NumLDrv = 0;
	  }
	  else
    {

		  //
		  //send enquiry3 command to the firmware to get the logical
		  //drive information.The older enquiry command is no longer
		  //supported by the 40 logical drive firmware
		  //

		  mbox.Command   = NEW_CONFIG_COMMAND; //inquiry 3 [BYTE 0]
		  mbox.CommandId = 0xFE;//command id [BYTE 1]

		  mbox.u.Flat2.Parameter[0] = NC_SUBOP_ENQUIRY3;	//[BYTE 2]
		  mbox.u.Flat2.Parameter[1] = ENQ3_GET_SOLICITED_FULL;//[BYTE 3]

		  raidParamEnquiry_40ldrv->numLDrv = 0;
	  }

	  
	  deviceExtension->NoncachedExtension->fw_mbox.Status.CommandStatus = 0;
    deviceExtension->NoncachedExtension->fw_mbox.Status.NumberOfCompletedCommands = 0;
	  SendMBoxToFirmware(deviceExtension, pciPortStart, &mbox);

	  //
	  // Poll for completion for 60 seconds.
	  //
    if(WaitAndPoll(noncachedExtension, pciPortStart, SIXITY_SECONDS_TIMEOUT, TRUE) == FALSE)
    {
      DebugPrint((0, "\n **** ERROR timeout, ERROR ****"));

      return FALSE;
    }

    status  = deviceExtension->NoncachedExtension->fw_mbox.Status.CommandStatus;
    if(status)
    {
      DebugPrint((0, "\n **** status ERROR ERROR ****"));
      return FALSE;
    }
  }
	//
	// Enable interrupts on the Adapter. 
	//
	if (noncachedExtension->RPBoard == MRAID_NONRP_BOARD)
		ScsiPortWritePortUchar(pciPortStart+INT_ENABLE, MRAID_ENABLE_INTERRUPTS);

   //
   //store the hostadapter number in the device extension.
   //THis is a zero base number indicating the ordinal number of the
   //recognized host adapters.
   //
   if(!deviceExtension->OrdinalNumberAssigned)
   {
         deviceExtension->HostAdapterOrdinalNumber = 
                     globalHostAdapterOrdinalNumber++;

         deviceExtension->OrdinalNumberAssigned = TRUE;
   }

   DebugPrint((0, "\nExiting MegaRAIDInitialize\n"));

	return(TRUE);
} // end MegaRAIDInitialize()
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\port\scsi\miniport\megaraid\extendedsgl.c ===
/*******************************************************************/
/*                                                                 */
/* NAME             = ExtendedSGL.C                                */
/* FUNCTION         = Implementation of Extended SGL;              */
/* NOTES            =                                              */
/* DATE             = 02-03-2000                                   */
/* HISTORY          = 001, 02-03-00, Parag Ranjan Maharana;        */
/* COPYRIGHT        = LSI Logic Corporation. All rights reserved;  */
/*                                                                 */
/*******************************************************************/
#include "includes.h"

/*
Function : GetAndSetSupportedScatterGatherElementCount
Description:
		Queries the controller for the maximum supported scatter gather 
		element count.The command is failed by the old firmwares.For them
		the driver sets the default values for the MaximumTransferLength
		and NumberOfPhysicalBreaks in the deviceExtension.If the call succeeds,
		the driver sets the values based on the allowed maximum.
Input Arguments:
		Pointer to the controller DeviceExtension
		Pointer to the mapped register space of the controller
		Boolean Flag (TRUE = RP Series Controller; FALSE= Non RP (428) )
Return Values:
			None
Output
		DeviceExtension->MaximumTransferLength
		DeviceExtension->NumberOfPhysicalBreaks
		set appropriate values.
*/
void
GetAndSetSupportedScatterGatherElementCount(
				PHW_DEVICE_EXTENSION	DeviceExtension,
				PUCHAR								PciPortStart,
				UCHAR									RPFlag
				)
{
	PUCHAR						dataBuffer;
	PSG_ELEMENT_COUNT	sgElementCount;

	ULONG32		count;
	ULONG32		maximumTransferLength;
	ULONG32		numberOfPhysicalBreaks;
	ULONG32		length;
	
	ULONG32		rpInterruptStatus;

	UCHAR		nonrpInterruptStatus;
	UCHAR		commandStatus;

	SCSI_PHYSICAL_ADDRESS	physicalAddress;
	FW_MBOX	mailBox;

	//
	//initialize the mailBox
	//
	MegaRAIDZeroMemory(&mailBox, sizeof(FW_MBOX));

	//
	//construct the command 
	//
  mailBox.Command = MAIN_MISC_OPCODE;
	//set the command id. 
  mailBox.CommandId = 0xFE;
  //Set the subcommand id
  mailBox.u.Flat2.Parameter[0] = GET_MAX_SG_SUPPORT;



	//
	//get the physical address of the data buffer
	//
	dataBuffer = DeviceExtension->NoncachedExtension->Buffer;

	physicalAddress = ScsiPortGetPhysicalAddress(DeviceExtension,
												                        NULL,
												                        dataBuffer,
												                        &length);
	
  //convert the physical address to ULONG32
	mailBox.u.Flat2.DataTransferAddress = ScsiPortConvertPhysicalAddressToUlong(physicalAddress);

	DebugPrint((0, "\nPAD[DataBuffer]=0x%0x PADLength=%d",
								mailBox.u.Flat2.DataTransferAddress,length));
	DebugPrint((0, "\n SizeofTransfer = %d", sizeof(SG_ELEMENT_COUNT)));
	
	//
	//reset the status byte in the mail box
	//
	DeviceExtension->NoncachedExtension->fw_mbox.Status.CommandStatus= 0;
  DeviceExtension->NoncachedExtension->fw_mbox.Status.NumberOfCompletedCommands = 0;
	
	//
	//fire the command to the firmware
	//	
	SendMBoxToFirmware(DeviceExtension, PciPortStart, &mailBox);
 
  //
  //wait for the completion of the command
	//

	if(WaitAndPoll(DeviceExtension->NoncachedExtension, PciPortStart, DEFAULT_TIMEOUT, TRUE)==FALSE)
  {
	 		commandStatus = 1; //COMMAND FAILED
			
			goto SET_VALUES;
  }
  
	//
	//check for the command status
	//
	commandStatus = DeviceExtension->NoncachedExtension->fw_mbox.Status.CommandStatus;

SET_VALUES:

	//Set Data Transfer Lenth to 64K because firmware cannot handle more than 64k transferlength
	//if stripe is 2K.
	maximumTransferLength = DEFAULT_TRANSFER_LENGTH;
	
	//TAKE ACTION based on success or failure of the command
	if(commandStatus != 0)
  {
			//command Failed by the firmware.
			//set default values.
			numberOfPhysicalBreaks = DEFAULT_SGL_DESCRIPTORS;		
	}
	else
  {
		//command successfull.Cast the data buffer to SG_ELEMENT_COUNT structure.
		sgElementCount = (PSG_ELEMENT_COUNT)(dataBuffer);
	
		//check for the returned value with the allowed maximum by driver
		numberOfPhysicalBreaks = sgElementCount->AllowedBreaks-1;		

		if(numberOfPhysicalBreaks > MAXIMUM_SGL_DESCRIPTORS)
		{
			numberOfPhysicalBreaks = MAXIMUM_SGL_DESCRIPTORS;		
		}
	
	}

	//
	//set the values in the DeviceExtension
	//
	DeviceExtension->MaximumTransferLength = maximumTransferLength;
	DeviceExtension->NumberOfPhysicalBreaks = numberOfPhysicalBreaks;

}//GetAndSetSupportedScatterGatherElementCount ends
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\port\scsi\miniport\megaraid\interrupt.c ===
/*******************************************************************/
/*                                                                 */
/* NAME             = Interrupt.C                                  */
/* FUNCTION         = Implementation of MegaRAIDInterrupt routine; */
/* NOTES            =                                              */
/* DATE             = 02-03-2000                                   */
/* HISTORY          = 001, 02-03-00, Parag Ranjan Maharana;        */
/* COPYRIGHT        = LSI Logic Corporation. All rights reserved;  */
/*                                                                 */
/*******************************************************************/

#include "includes.h"

extern LOGICAL_DRIVE_INFO  gLDIArray;

/*********************************************************************
Routine Description:
	Interrupt Handler

Arguments:
	HwDeviceExtension - HBA miniport driver's adapter data storage

Return Value:
	TRUE if we handled the interrupt
**********************************************************************/
BOOLEAN
MegaRAIDInterrupt(
	IN PVOID HwDeviceExtension
	)
{
	PHW_DEVICE_EXTENSION   deviceExtension = HwDeviceExtension;
	PSCSI_REQUEST_BLOCK    srb;
	UCHAR                  commandID;
	PUCHAR                 pciPortStart;
	UCHAR                  status, command;
	UCHAR                  nonrpInterruptStatus;
	ULONG32                index, rpInterruptStatus;
	UCHAR                  commandsCompleted;
	USHORT                 rxInterruptStatus;
	
	PSRB_EXTENSION				 srbExtension = NULL;


	pciPortStart       = deviceExtension->PciPortStart;

  if(deviceExtension->NoncachedExtension->RPBoard == MRAID_RP_BOARD)
	{
		rpInterruptStatus = 
			ScsiPortReadRegisterUlong(
			(PULONG)(pciPortStart+OUTBOUND_DOORBELL_REG));
		
		if (rpInterruptStatus != MRAID_RP_INTERRUPT_SIGNATURE)      
			return FALSE;

		
		ScsiPortWriteRegisterUlong(
			(PULONG)(pciPortStart+OUTBOUND_DOORBELL_REG), rpInterruptStatus);
		
	}
	else
	{
		nonrpInterruptStatus = ScsiPortReadPortUchar(pciPortStart+PCI_INT);
		//
		// Check if our interrupt. Return False otherwise.
		//
		if ((nonrpInterruptStatus & MRAID_NONRP_INTERRUPT_MASK) != MRAID_NONRP_INTERRUPT_MASK) 
			return FALSE;
		//
		// Acknowledge the interrupt on the adapter.
		//
		ScsiPortWritePortUchar(pciPortStart+PCI_INT, nonrpInterruptStatus);
	}

  //DebugPrint((0, "\nMegaRAIDInterrupt::DEV EXT %x Interrupt received", deviceExtension));

#ifdef MRAID_TIMEOUT
	//
	// If the Controller Is Dead Complete Handshake 
	// and Return
	//
	if (deviceExtension->DeadAdapter)
	{
		//
		// Acknowledge the interrupt to the adapter.
		//
		DebugPrint((0, "\nDead Adapter Code In Intr"));

    if (deviceExtension->NoncachedExtension->RPBoard == MRAID_RP_BOARD)
		{
			ScsiPortWriteRegisterUlong((PULONG)(pciPortStart+INBOUND_DOORBELL_REG), MRAID_RP_INTERRUPT_ACK);
		}
		else
    {
			ScsiPortWritePortUchar(pciPortStart, MRAID_NONRP_INTERRUPT_ACK);
    }
		return TRUE;
	} 
#endif // MRAID_TIMEOUT



	//
	// Pick up the completed id's from the mailBox.
	//
	for (index=0; index<0xFFFFFF; index++)
  {
    //Microsoft fixed for Security reason
		if((deviceExtension->NoncachedExtension->fw_mbox.Status.NumberOfCompletedCommands) != 0)
			break;	
  }
	if (index == 0xFFFFFF)
  {
		DebugPrint((0, "MegaRAIDInterrupt: Commands Completed Zero\n"));
  }

	commandsCompleted = deviceExtension->NoncachedExtension->fw_mbox.Status.NumberOfCompletedCommands; 
	deviceExtension->NoncachedExtension->fw_mbox.Status.NumberOfCompletedCommands = 0;

	for(command=0; command < commandsCompleted; command++)
	{
		//
		// Pick the status from the mailbox.
		//

		status = deviceExtension->NoncachedExtension->fw_mbox.Status.CommandStatus;
		//
		// Pick the command id from the mailbox.
		//
	  for (index=0; index<0xFFFFFF; index++)
    {
			if ((commandID = (deviceExtension->NoncachedExtension->fw_mbox.Status.CompletedCommandIdList[command])) != 0xFF)
				break;	
    }
		if (index == 0xFFFFFF)
    {
			DebugPrint((0, "MegaRAIDInterrupt: Invalid Command Id Completed\n"));
    }

		deviceExtension->NoncachedExtension->fw_mbox.Status.CompletedCommandIdList[command] = MRAID_INVALID_COMMAND_ID;

		//
		// If Command Id is the one used for Resetting, Release the ID
		//
		if ( commandID == RESERVE_RELEASE_DRIVER_ID ) 
		{
			deviceExtension->ResetIssued = 0;       
			continue;
		}
		//
		// Release The Poll Flag when Adapter Inquiry Completes
		// and let the Write Config Command Completion happen
		// in the continuedisk routine
		//
		if (commandID == DEDICATED_ID) 
		{
			//deviceExtension->AdpInquiryFlag = 0;    
			UCHAR commandCode;

			if(deviceExtension->NoncachedExtension->UpdateState == UPDATE_STATE_NONE)
			{
				//
				//something wrong !!
				continue;
			}

			if(deviceExtension->NoncachedExtension->UpdateState == UPDATE_STATE_DISK_ARRAY)
			{
				deviceExtension->NoncachedExtension->UpdateState = UPDATE_STATE_NONE;
			
				//
				//clear the flag. This flag when set, holds the subsequent
				//write config calls.
				//
				deviceExtension->AdpInquiryFlag = 0;

				// both the updates (AdapterInquiry structure & disk array 
				// structure) completed
				//
				continue;
			}

			//
			//check for adapter inquiry update. Adapter Inquiry Update
			//must be followed by DiskArrayUpdate
			//
			if(deviceExtension->NoncachedExtension->UpdateState == UPDATE_STATE_ADAPTER_INQUIRY)
			{				

				//
				//REF : MS VDS RESCAN PROBLEM : -
				//BusChangeDetected ADDED TO SUPPORT VDS RESCAN PROBLEM WHEN LOGICAL DRIVES 
				//ARE CREATED FROM ONLINE UTILITY
				//

				//
				//Write config done. Driver issued a private read config after that 
				//to update the internal data structures.
				//
				if(deviceExtension->SupportedLogicalDriveCount == MAX_LOGICAL_DRIVES_8)
				{					
					if(deviceExtension->NoncachedExtension->MRAIDParams.MRAIDParams8.LogdrvInfo.NumLDrv != 
						deviceExtension->NoncachedExtension->MRAIDTempParams.MRAIDTempParams8.LogdrvInfo.NumLDrv)
					{
						ScsiPortNotification(BusChangeDetected, deviceExtension, deviceExtension->NumberOfPhysicalChannels);  
						ScsiPortNotification(BusChangeDetected, deviceExtension, (deviceExtension->NumberOfPhysicalChannels+1));  
					}
					deviceExtension->NoncachedExtension->MRAIDParams.MRAIDParams8 = 
						deviceExtension->NoncachedExtension->MRAIDTempParams.MRAIDTempParams8;
				}
				else
				{
					if(deviceExtension->NoncachedExtension->MRAIDParams.MRAIDParams40.numLDrv != 
						deviceExtension->NoncachedExtension->MRAIDTempParams.MRAIDTempParams40.numLDrv)
					{
						ScsiPortNotification(BusChangeDetected, deviceExtension, deviceExtension->NumberOfPhysicalChannels);  
						ScsiPortNotification(BusChangeDetected, deviceExtension, (deviceExtension->NumberOfPhysicalChannels+1));  
					}
					deviceExtension->NoncachedExtension->MRAIDParams.MRAIDParams40 = 
						deviceExtension->NoncachedExtension->MRAIDTempParams.MRAIDTempParams40;
				}
			}

      if(!deviceExtension->ReadDiskArray)
      {
				deviceExtension->NoncachedExtension->UpdateState = UPDATE_STATE_NONE;
			
				//
				//clear the flag. This flag when set, holds the subsequent
				//write config calls.
				//
				deviceExtension->AdpInquiryFlag = 0;

				//  updates AdapterInquiry structure not need to update disk array 
				// structure
        continue;
      }
      
      deviceExtension->ReadDiskArray = 0;

			//
			//UPDATE_STATE_ADAPTER_INQUIRY should be followed by
			//UPDATE_STATE_DISK_ARRAY
			//That is, we got to update two different structures using
			//two different commands whenever the WRITE_CONFIG is operation
			//is made.

			//
			//check for the supported logical drive count.
			//For 8 logical drive firmware & 40 logical drive firmware
			//the command codes and mode in which the commands are sent
			//differ to a much greater extent.
			//
			if(deviceExtension->SupportedLogicalDriveCount == MAX_LOGICAL_DRIVES_40)
			{
			
				//
				//set the flag
				//
				deviceExtension->NoncachedExtension->UpdateState= 
																				UPDATE_STATE_DISK_ARRAY;

				Read40LDDiskArrayConfiguration(
					deviceExtension, //PFW_DEVICE_EXTENSION	DeviceExtension,
					(UCHAR)commandID,//UCHAR		CommandId,
					FALSE); //BOOLEAN	IsPolledMode 		

				//
				//continue here
				continue;
			}

			//
			//This is 8 logical drive firmware. For the 8 logical drive
			//firmware we may have two configurations : 4 SPAN & 8 SPAN.
			//So based on that, give appropriate command to the firmware
			//

			//
			// do the read configuration for a 4 span array
			//
			commandCode = MRAID_READ_CONFIG;
			
			if(deviceExtension->NoncachedExtension->ArraySpanDepth == FW_8SPAN_DEPTH)
			{
				//
				// do the read configuration for a 8 span array
				//
				commandCode = MRAID_EXT_READ_CONFIG;
			}

			//
			//set the flag
			//
			deviceExtension->NoncachedExtension->UpdateState= UPDATE_STATE_DISK_ARRAY;

			Read8LDDiskArrayConfiguration(
					deviceExtension, //PFW_DEVICE_EXTENSION	DeviceExtension,
					commandCode, //UCHAR		CommandCode,
					(UCHAR)commandID,//UCHAR		CommandId,
					FALSE); //BOOLEAN	IsPolledMode 		
			
			continue;	
		}
		//
		// if dummy interrupt from the adapter return FALSE.
		//
		if(deviceExtension->PendCmds<=0)  return(TRUE);
		//
		// Check whether this SRB is actually running
		//

  //Now Get the SRB from Queue
	srb  = deviceExtension->PendSrb[commandID];

	
	//Check Valid SRB
	if(srb == NULL)
	{
		//IF NULL SRB FOUND IN QUEUE, IT MUST BE INTERNAL COMMAND WHICH MOST HAVE COMPLETED
		//BEFORE IT REACH THIS POINT, OR FIRMWARE POSTED A COMMAND ID WHICH IS NOT GENERATED
		//BY DRIVER. DRIVER NEED TO IGNORE THIS COMMAND AND CONTINUE TO PROCCESS OTHER COMMANDS
    DebugPrint((0,"\nERROR FOUND NULL SRB @ CMD ID 0x%x", commandID));
		continue;
	}

  if((deviceExtension->AdapterFlushIssued) && (srb->Cdb[0] == SCSIOP_WRITE))
  {																			 
    FW_MBOX                 mbox;
    
		srbExtension = srb->SrbExtension;
    
		if(srbExtension->IsFlushIssued == FALSE)
    {
		  MegaRAIDZeroMemory(&mbox, sizeof(FW_MBOX));

		  mbox.Command = MRAID_ADAPTER_FLUSH;
		  mbox.CommandId = commandID;
			  
		  deviceExtension->AdapterFlushIssued++;
		  srbExtension->IsFlushIssued = TRUE;
		  SendMBoxToFirmware(deviceExtension, pciPortStart, &mbox);
		  continue;	      
    }
    else if(srbExtension->IsFlushIssued == TRUE)
    {
		  MegaRAIDZeroMemory(&mbox, sizeof(FW_MBOX));

		  mbox.Command = 0xFE;
		  mbox.CommandId = commandID;
			  
		  srbExtension->IsFlushIssued = TWO;
		  SendMBoxToFirmware(deviceExtension, pciPortStart, &mbox);
		  continue;	      
    }
    else
    {
		  srbExtension->IsFlushIssued = FALSE;
		  DebugPrint((0, "\nAdapterFlush completed after write"));
    }
   }
  
  
  //Request for NON DISK
  if(srb->PathId < deviceExtension->NumberOfPhysicalChannels)
  {
    if((srb->Cdb[0] == SCSIOP_INQUIRY)
      && (srb->Function == SRB_FUNCTION_EXECUTE_SCSI))
    {
      if(status == 0)
      {
 				PINQUIRYDATA  inquiry;

        inquiry = (PINQUIRYDATA)srb->DataBuffer;

        DebugPrint((0, "\n<P %d T %d L %d> -> DEV TYPE %d", srb->PathId, srb->TargetId, srb->Lun, inquiry->DeviceType));
        if(inquiry->DeviceType == DIRECT_ACCESS_DEVICE)
        {
          status = 100;  //Knowingly failed the cmd
				  srb->SrbStatus = SRB_STATUS_NO_DEVICE;
          MegaRAIDZeroMemory(srb->DataBuffer, srb->DataTransferLength);
          deviceExtension->Failed.PathId = srb->PathId;
          deviceExtension->Failed.TargetId = srb->TargetId;
        }
        else
        {
          deviceExtension->NonDiskDeviceCount++; 
     
          SET_NONDISK_INFO(deviceExtension->NonDiskInfo, srb->PathId, srb->TargetId, srb->Lun);
      
          if((srb->PathId == (deviceExtension->NumberOfPhysicalChannels-1))
            && (srb->TargetId == (MAX_TARGETS_PER_CHANNEL-1)))
          {
              deviceExtension->NonDiskInfo.NonDiskInfoPresent = TRUE;
          }
        }
      } //Of NonDisk scan done
      else
      {
        deviceExtension->Failed.PathId = srb->PathId;
        deviceExtension->Failed.TargetId = srb->TargetId;
      }

      
     
      //Issue a Read Config to update the logical disk size for Virtual sizing rather
      //dynamic disk properites
      if((deviceExtension->ReadConfigCount == 1)
         && (srb->PathId == 0)
         && (srb->TargetId == 0)
         && (srb->Lun == 0))
      {
				FW_MBOX mbox;
      	PUCHAR	raidTempParamFlatStruct;
        ULONG32   length;

        MegaRAIDZeroMemory(&mbox, sizeof(FW_MBOX));
        
	      raidTempParamFlatStruct = 
		      (PUCHAR)&deviceExtension->NoncachedExtension->MRAIDTempParams.MRAIDTempParams8;
        
        
        //
				// Issue Adapter Enquiry command.
				//
				//
				//get the latest configuration in the TempParams structure
				//
				mbox.u.Flat2.DataTransferAddress = MegaRAIDGetPhysicalAddressAsUlong(deviceExtension, 
																		                      NULL, 
																		                      raidTempParamFlatStruct, 
																		                      &length);
				
				if(deviceExtension->SupportedLogicalDriveCount == MAX_LOGICAL_DRIVES_8)
				{
						//
						// Fill the Mailbox.
						//
						mbox.Command  = MRAID_DEVICE_PARAMS;
						mbox.CommandId = DEDICATED_ID;

				}
				else
				{

					//
					//send enquiry3 command to the firmware to get the logical
					//drive information.The older enquiry command is no longer
					//supported by the 40 logical drive firmware
					//

					mbox.Command   = NEW_CONFIG_COMMAND; //inquiry 3 [BYTE 0]
					mbox.CommandId       = DEDICATED_ID;//command id [BYTE 1]

					mbox.u.Flat2.Parameter[0] = NC_SUBOP_ENQUIRY3;	//[BYTE 2]
					mbox.u.Flat2.Parameter[1] = ENQ3_GET_SOLICITED_FULL;//[BYTE 3]

				}

		
				deviceExtension->AdpInquiryFlag = 1;

				//
				//set the update state
				//
				deviceExtension->NoncachedExtension->UpdateState =
																		UPDATE_STATE_ADAPTER_INQUIRY;

				SendMBoxToFirmware(deviceExtension, pciPortStart, &mbox);
      }
    }//Of INQUIRY & SCSI_EXECUTE
  }//Of Number of Physical Channels

  
#ifdef COALESE_COMMANDS
		//
		// check for chained or single Srb
		//
		srbExtension = srb->SrbExtension;
		if(srbExtension->IsChained)
		{
				//
				//chain of Srb's found. Post them one by one
				//
				deviceExtension->PendSrb[commandID] = NULL;
				deviceExtension->FreeSlot = commandID;
				deviceExtension->PendCmds--;

				PostChainedSrbs(deviceExtension, srb, status);

				continue;
		}
#endif

		deviceExtension->ActiveIO[commandID].CommandStatus = status;

		if (srb->SrbStatus == MRAID_RESERVATION_CHECK )
    {
			switch (srb->Cdb[0])
      {
				case SCSIOP_READ_CAPACITY:
				case SCSIOP_TEST_UNIT_READY:
						
					if((status ==  LOGDRV_RESERVATION_FAILED)
					    || (status ==  LOGDRV_RESERVATION_FAILED_NEW))
          {
						srb->ScsiStatus = SCSI_STATUS_RESERVATION_FAILED;
						srb->SrbStatus  = SRB_STATUS_ERROR;
					}
					else
          {
						srb->ScsiStatus = SCSISTAT_GOOD;
						srb->SrbStatus = SRB_STATUS_SUCCESS;
					}
					break;
				case SCSIOP_MODE_SENSE:
					if((status ==  LOGDRV_RESERVATION_FAILED )
					    || (status ==  LOGDRV_RESERVATION_FAILED_NEW))
          {
						srb->ScsiStatus = SCSI_STATUS_RESERVATION_FAILED;
						srb->SrbStatus  = SRB_STATUS_ERROR;
					}
					else
          {
							srb->SrbStatus = SRB_STATUS_INVALID_REQUEST;
          }
					break;

			}
			FireRequestDone(deviceExtension, commandID, srb->SrbStatus);
			continue;
		}


#ifdef  DELL
		if (srb->SrbStatus == MRAID_WRITE_BLOCK0_COMMAND)
		{
			deviceExtension->PendSrb[commandID] = NULL;
			deviceExtension->FreeSlot = commandID;
			deviceExtension->PendCmds--;

      //If return failure that means SRB already posted
      if(DellChkWriteBlockZero(srb, deviceExtension, status))
      {
    			MegaRAIDStartIo(deviceExtension, srb); 
      }
		}
		else 
    {
			deviceExtension->ActiveIO[commandID].CommandStatus = status;
			//
			// Complete the interrupting request.
			//
			ContinueDiskRequest(deviceExtension, commandID, FALSE);
		}

#else
		//
		// Complete the interrupting request.
		//
		ContinueDiskRequest(deviceExtension, commandID, FALSE);

#endif
   }

	//
	// Issue the queued request.
	//
	if(deviceExtension->PendCmds < CONC_CMDS) {
		
		#ifdef COALESE_COMMANDS
		//
		//check for the pending command count. if pendCmd  is less than
		//the minimum threshold, then fire the queued srbs in all the
		//logical drives.
		//
		if(deviceExtension->PendCmds == 0) //<  MINIMUM_THRESHOLD)
		{
				UCHAR	logDrvIndex;
				UCHAR configuredLogicalDrives;

				//
				//get the configured logical drives on the controller (if any)
				//
				if(deviceExtension->SupportedLogicalDriveCount == MAX_LOGICAL_DRIVES_8)
				{
					configuredLogicalDrives = 
							deviceExtension->NoncachedExtension->MRAIDParams.MRAIDParams8.LogdrvInfo.NumLDrv;
				}
				else
				{
					configuredLogicalDrives = 
							deviceExtension->NoncachedExtension->MRAIDParams.MRAIDParams40.numLDrv;
				}

				for(logDrvIndex=0; logDrvIndex < configuredLogicalDrives;
						logDrvIndex++)
				{
					//DebugPrint((0, "\n IN MegaraidInterrupt: Calling FCR()"));

					FireChainedRequest(
							deviceExtension,
							&deviceExtension->LogDrvCommandArray[logDrvIndex]);

					//DebugPrint((0, "\n IN MegaraidInterrupt: Callover FCR()"));
				}
		}
		else
		{
				UCHAR			logDrvIndex;
				UCHAR			configuredLogicalDrives;
				BOOLEAN		fireCommand;
				PLOGDRV_COMMAND_ARRAY	logDrive;

								//
				//get the configured logical drives on the controller (if any)
				//
				if(deviceExtension->SupportedLogicalDriveCount == MAX_LOGICAL_DRIVES_8)
				{
					configuredLogicalDrives = 
							deviceExtension->NoncachedExtension->MRAIDParams.MRAIDParams8.LogdrvInfo.NumLDrv;
				}
				else
				{
					configuredLogicalDrives = 
							deviceExtension->NoncachedExtension->MRAIDParams.MRAIDParams40.numLDrv;
				}

				for(logDrvIndex=0; logDrvIndex < configuredLogicalDrives;
						logDrvIndex++)
				{
					//DebugPrint((0, "\n IN MegaraidInterrupt: Calling FCR()"));
					
					//
					//compare the previous & the current queue length
					logDrive = &deviceExtension->LogDrvCommandArray[logDrvIndex];
					fireCommand = FALSE;

					if(logDrive->PreviousQueueLength == logDrive->CurrentQueueLength)
					{
						//
						//No additions to the queue.Increment QueueLengthConstancyPeriod
						//
						logDrive->QueueLengthConstancyPeriod++;

						//
						//check for the queue length constancy period
						if( logDrive->QueueLengthConstancyPeriod >= MAX_QLCP)
						{
								fireCommand = TRUE;
						}
					}
					else
					{
						// queue length has changed.Increment CheckPeriod
						//
						logDrive->CheckPeriod++;

						//
						//set the queue length
						logDrive->PreviousQueueLength = logDrive->CurrentQueueLength;

						//
						//check for check period time out
						if(logDrive->CheckPeriod >= MAX_CP)
						{
							fireCommand= TRUE;
						}
					}

					if(fireCommand)
          {

						FireChainedRequest(deviceExtension, 
                               &deviceExtension->LogDrvCommandArray[logDrvIndex]);
					}

					//DebugPrint((0, "\n IN MegaraidInterrupt: Callover FCR()"));
				}//of for()
		}
		#endif

		if(deviceExtension->PendingSrb != NULL) 
    {
      DebugPrint((0, "\n Firing Queued Cmd (Interrupt)"));
      srb = deviceExtension->PendingSrb;
			deviceExtension->PendingSrb = NULL;
			MegaRAIDStartIo(deviceExtension, srb);
      DebugPrint((0, "\n Exiting Fire Queued Cmd(Interrupt)"));
		}
	}
	//
	// Acknowledge the interrupt to the adapter.
	//
	if(deviceExtension->NoncachedExtension->RPBoard == MRAID_RP_BOARD)
	{
		ScsiPortWriteRegisterUlong((PULONG)(pciPortStart+INBOUND_DOORBELL_REG), MRAID_RP_INTERRUPT_ACK);
	}
	else
  {
		ScsiPortWritePortUchar(pciPortStart, MRAID_NONRP_INTERRUPT_ACK);
  }
	return TRUE;
} // end MegaRAIDInterrupt()
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\port\scsi\miniport\megaraid\ioctl.c ===
/*******************************************************************/
/*                                                                 */
/* NAME             = IOCTL.C                                      */
/* FUNCTION         = Implementation of PowerConsole IOCTLs;       */
/* NOTES            =                                              */
/* DATE             = 02-03-2000                                   */
/* HISTORY          = 001, 02-03-00, Parag Ranjan Maharana;        */
/* COPYRIGHT        = LSI Logic Corporation. All rights reserved;  */
/*                                                                 */
/*******************************************************************/

#include "includes.h"

//defines

//
// Driver Data
//
DriverInquiry   DriverData = {"megaraid$",
											        OS_NAME,
											        OS_VERSION,
											        VER_ORIGINALFILENAME_STR,
											        VER_PRODUCTVERSION_STR,
											        RELEASE_DATE};

/*********************************************************************
Routine Description:
	This routines returns the statistics of the adapter.

Arguments:
		deviceExtension			-	Pointer to Device Extension.
		Srb							-  Pointer to request packet.

Return Value:
		REQUEST_DONE	
**********************************************************************/
ULONG32
MRaidStatistics(PHW_DEVICE_EXTENSION DeviceExtension,
						    PSCSI_REQUEST_BLOCK  Srb)
{
	PUCHAR    driverStatistics, 
						applicationStatistics;
	
	PIOCONTROL_MAIL_BOX ioctlMailBox =	(PIOCONTROL_MAIL_BOX)((PUCHAR)Srb->DataBuffer +	sizeof(SRB_IO_CONTROL));
	
	ULONG32		count;
	ULONG32		statisticsStructLength;

	//
	//get the statistics structure. Statistics8 & Statistics40 are in {union}
	//It doesn't matter, which we CAST to
	//
	driverStatistics  = (PUCHAR)&DeviceExtension->Statistics.Statistics8;

	if(DeviceExtension->SupportedLogicalDriveCount == MAX_LOGICAL_DRIVES_8)
	{
			statisticsStructLength = sizeof(MegaRaidStatistics_8);
	}
	else
	{
			statisticsStructLength = sizeof(MegaRaidStatistics_40);
	}
	
	//
	//get the output buffer pointer
	//
	applicationStatistics   = (PUCHAR)(
															(PUCHAR)Srb->DataBuffer + 
															sizeof(SRB_IO_CONTROL) +
															APPLICATION_MAILBOX_SIZE
														);

	for ( count = 0 ; count < statisticsStructLength ; count++)
	{
		*((PUCHAR)applicationStatistics + count) = 
												*((PUCHAR)driverStatistics + count);
	}

	ioctlMailBox->IoctlSignatureOrStatus      = MEGARAID_SUCCESS;
  
	Srb->SrbStatus  = SRB_STATUS_SUCCESS;
	Srb->ScsiStatus = SCSISTAT_GOOD;

	return REQUEST_DONE;
}


/*********************************************************************
Routine Description:
	This routines returns the statistics of the Driver.

Arguments:
		deviceExtension			-	Pointer to Device Extension.
		Srb							-  Pointer to request packet.

Return Value:
		REQUEST_DONE	
**********************************************************************/
ULONG32
MRaidDriverData(
						PHW_DEVICE_EXTENSION    DeviceExtension,
						PSCSI_REQUEST_BLOCK     Srb)
{
	PUCHAR     dataPtr;
	PIOCONTROL_MAIL_BOX ioctlMailBox =	(PIOCONTROL_MAIL_BOX)((PUCHAR)Srb->DataBuffer +sizeof(SRB_IO_CONTROL));
	USHORT     count;

	dataPtr= ((PUCHAR)Srb->DataBuffer + sizeof(SRB_IO_CONTROL) +
					  APPLICATION_MAILBOX_SIZE);

	for ( count = 0 ; count < sizeof(DriverInquiry) ; count++)
		*((PUCHAR)dataPtr + count) = *((PUCHAR)&DriverData+count);

	ioctlMailBox->IoctlSignatureOrStatus = MEGARAID_SUCCESS;
	Srb->SrbStatus  = SRB_STATUS_SUCCESS;
	Srb->ScsiStatus = SCSISTAT_GOOD;
	
	return REQUEST_DONE;
}

/*********************************************************************
Routine Description:
	This routines returns the Baseport of the Controller.

Arguments:
		deviceExtension                 -       Pointer to Device Extension.
		Srb                                                     -  Pointer to request packet.

Return Value:
		REQUEST_DONE    
**********************************************************************/
ULONG32 MRaidBaseport(PHW_DEVICE_EXTENSION DeviceExtension,
							 PSCSI_REQUEST_BLOCK    Srb)
{
	PULONG  dataPtr;
	PIOCONTROL_MAIL_BOX ioctlMailBox =	(PIOCONTROL_MAIL_BOX)((PUCHAR)Srb->DataBuffer +sizeof(SRB_IO_CONTROL));

  if(DeviceExtension->BaseAddressRegister.QuadPart & 0x10) //64bit address
  {
    Srb->SrbStatus = SRB_STATUS_ERROR;
	  return REQUEST_DONE;
  }
  
  dataPtr = (PULONG) ((PUCHAR)Srb->DataBuffer + sizeof(SRB_IO_CONTROL) +
		APPLICATION_MAILBOX_SIZE);

	*dataPtr  = (ULONG32)DeviceExtension->BaseAddressRegister.LowPart;

  ioctlMailBox->IoctlSignatureOrStatus = MEGARAID_SUCCESS;
	
  Srb->SrbStatus = SRB_STATUS_SUCCESS;
	Srb->ScsiStatus = SCSISTAT_GOOD;

	return REQUEST_DONE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\port\scsi\miniport\megaraid\logicaldrive.c ===
/*******************************************************************/
/*                                                                 */
/* NAME             = LogicalDrive.C                               */
/* FUNCTION         = Logical Drive support Implementation;        */
/* NOTES            =                                              */
/* DATE             = 02-03-2000                                   */
/* HISTORY          = 001, 02-03-00, Parag Ranjan Maharana;        */
/* COPYRIGHT        = LSI Logic Corporation. All rights reserved;  */
/*                                                                 */
/*******************************************************************/

#include "includes.h"


//
//Function Name: GetSupportedLogicalDriveCount
//Routine Description:
//	The supported logical drive count from the firmware is 
//	determined. This is done in a roundabout way. That is, there
//	is no direct firmware command support to inform the driver
//	about the supported logical drive count.This is got by firing
//	the Inquiry_3 command to the firmware. If this command 
//	succeeds then, it is a 40 logical drive firmware. This command
//	is supported only by the 40 logical drive firmware. On failure
//	of this Inquiry_3 command, it can be safely defaulted to be the
//	8 logical drive firmware.
//
//Return Value:
//	None
//
//Output:
//	The supported logical drive count is returned in the
//	controller device extension.
//
//++
BOOLEAN
GetSupportedLogicalDriveCount(
				PHW_DEVICE_EXTENSION DeviceExtension
				)
{
	PMEGARaid_INQUIRY_40	enquiry3;

	PUCHAR pciPortStart = DeviceExtension->PciPortStart;

	FW_MBOX	mailBox;

	ULONG32		count;
	ULONG32		length;
	UCHAR		commandStatus;

	//
	//get the enquiry structure from the NONCACHED extension of the
	//controller extension
	//
	enquiry3 = &DeviceExtension->NoncachedExtension->MRAIDParams.MRAIDParams40;

	//
	//initialize the mailBox structure
	//
	MegaRAIDZeroMemory(&mailBox, sizeof(FW_MBOX));

	//
	// Fill the Mailbox.
	//
	mailBox.Command   = NEW_CONFIG_COMMAND; //inquiry 3 [BYTE 0]
	mailBox.CommandId = 0xFE;//command id [BYTE 1]

	//
	//due to the intricate nature of the Mailbox structure,
	//I have nothing but to confuse the reader a bit.This command
	//requires the subcodes to be set in the bytes 2 & 3 of the mailbox.
	//As we have a RIGID mailBox structure for all the commands, I am
	//forced to cast the mail box to a CHAR pointer. Sorry for the
	//trouble. Please have the FibreChannel documentation for this 
	//command.
	//
  mailBox.u.Flat2.Parameter[0] = NC_SUBOP_ENQUIRY3;	//[BYTE 2]
  mailBox.u.Flat2.Parameter[1] = ENQ3_GET_SOLICITED_FULL;//[BYTE 3]

	//
	//get the physical address of the enquiry3 data structure
	//
	mailBox.u.Flat2.DataTransferAddress = MegaRAIDGetPhysicalAddressAsUlong(DeviceExtension, 
														                           NULL, 
														                           enquiry3, 
														                           &length);

	//
	// Check the contiguity of the physical region. Return Failure if the
	// region is not contiguous.
	//
	if(length < sizeof(struct MegaRAID_Enquiry3) )
	{ 
    DebugPrint((0, "\n **** ERROR Buffer Length is less than required size, ERROR ****"));
		//return(FALSE);
	}

	DeviceExtension->NoncachedExtension->fw_mbox.Status.CommandStatus= 0;
  DeviceExtension->NoncachedExtension->fw_mbox.Status.NumberOfCompletedCommands = 0;


	SendMBoxToFirmware(DeviceExtension,pciPortStart,&mailBox);

  if(WaitAndPoll(DeviceExtension->NoncachedExtension, pciPortStart, DEFAULT_TIMEOUT, TRUE) == TRUE)
  {
    commandStatus = DeviceExtension->NoncachedExtension->fw_mbox.Status.CommandStatus;
    DebugPrint((0, "\n Found Logical Drive %d", enquiry3->numLDrv));
  }
  else
  {
    return FALSE;
  }

  //
	//check for the status. If SUCCESS, then supported logical drive
	//count is 40, else it's 8
	//

	if(commandStatus != 0)
	{
		//Command not supported by the firmware.
		//set the supported logical drive count to 8
		//
		DeviceExtension->SupportedLogicalDriveCount = MAX_LOGICAL_DRIVES_8;
	}
	else
	{
		//Command not supported by the firmware.
		//set the supported logical drive count to 8
		//
		DeviceExtension->SupportedLogicalDriveCount = MAX_LOGICAL_DRIVES_40;
	}

	return(TRUE);
}//of GetSupportedLogicalDriveCount
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\port\scsi\miniport\megaraid\megaenquiry.h ===
/*******************************************************************/
/*                                                                 */
/* NAME             = MegaEnquiry.h                                */
/* FUNCTION         = Header file for MegaEnquiry;                 */
/* NOTES            =                                              */
/* DATE             = 02-03-2000                                   */
/* HISTORY          = 001, 02-03-00, Parag Ranjan Maharana;        */
/* COPYRIGHT        = LSI Logic Corporation. All rights reserved;  */
/*                                                                 */
/*******************************************************************/
#ifndef _MEGA_ENQUIRY_H
#define _MEGA_ENQUIRY_H


#define MINIMUM_THRESHOLD			2
#define MAX_QUEUE_THRESHOLD	  16
#define MAX_BLOCKS						128


#define MAX_CP			8
#define MAX_QLCP		4

//
//functions prototypes
//
BOOLEAN
BuildSglForChainedSrbs(
					PLOGDRV_COMMAND_ARRAY	LogDrv,
					PHW_DEVICE_EXTENSION		DeviceExtension,
					PFW_MBOX		MailBox,
					UCHAR  CommandId,
					UCHAR	 Opcode);



void
PostChainedSrbs(
				PHW_DEVICE_EXTENSION DeviceExtension,
				PSCSI_REQUEST_BLOCK		Srb, 
				UCHAR		Status);

BOOLEAN
FireChainedRequest(
				PHW_DEVICE_EXTENSION	DeviceExtension,
				PLOGDRV_COMMAND_ARRAY LogDrv 
				);

ULONG32
ProcessPartialTransfer(
					PHW_DEVICE_EXTENSION	DeviceExtension, 
					UCHAR									CommandId, 
					PSCSI_REQUEST_BLOCK		Srb,
					PFW_MBOX							MailBox
					);
void
ClearControlBlock(PREQ_PARAMS ControlBlock);

#endif //of _MEGA_ENQUIRY_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\port\scsi\miniport\megaraid\io.c ===
/*******************************************************************/
/*                                                                 */
/* NAME             = IO.C                                         */
/* FUNCTION         = Implementation of input/Output routines;     */
/* NOTES            =                                              */
/* DATE             = 02-03-2000                                   */
/* HISTORY          = 001, 02-03-00, Parag Ranjan Maharana;        */
/* COPYRIGHT        = LSI Logic Corporation. All rights reserved;  */
/*                                                                 */
/*******************************************************************/

#include "includes.h"

//
// Defines 
//

//
//Logical Drive Info struct (global)
//
extern LOGICAL_DRIVE_INFO  gLDIArray;
extern UCHAR               globalHostAdapterOrdinalNumber;

char    LogicalDriveSerialNumber[] = "LOGICAL   XY";
char    DummyProductId[]           = " DummyDevice    ";
char    DummyVendor[]              = "  RAID  ";

extern DriverInquiry   DriverData;

/*********************************************************************
Routine Description:
	This routine is called from the SCSI port driver synchronized
	with the kernel to start a request

Arguments:
	HwDeviceExtension - HBA miniport driver's adapter data storage
	Srb - IO request packet

Return Value:
	TRUE
**********************************************************************/
BOOLEAN
MegaRAIDStartIo(
	IN PVOID HwDeviceExtension,
	IN PSCSI_REQUEST_BLOCK Srb
	)
{
	PHW_DEVICE_EXTENSION deviceExtension = HwDeviceExtension;
	ULONG32                status;
	UCHAR								 configuredLogicalDrives;


#ifdef MRAID_TIMEOUT
	//
	// Check For The Dead Adapter
	//
	if (deviceExtension->DeadAdapter)
	{
		DebugPrint((0, "\nRequest Coming For DeadAdapter"));
		Srb->SrbStatus  = SRB_STATUS_ERROR;
    
    ScsiPortNotification(NextRequest, deviceExtension, NULL);

    ScsiPortNotification(RequestComplete,deviceExtension,Srb);
		return TRUE;
	}
#endif // MRAID_TIMEOUT


	//
	// Check the Request type.
	//
	if ( Srb->CdbLength <= 10 )
  {
		switch(Srb->Function) 
    {
			//
			// Clustering has to Handle ResetBus
			//
			case SRB_FUNCTION_RESET_BUS:
				//
				// If no Logical Drives Configured don't handle RESET
				//
				//if ( !deviceExtension->NoncachedExtension->MRAIDParams.LogdrvInfo.NumLDrv)
				if(deviceExtension->SupportedLogicalDriveCount == MAX_LOGICAL_DRIVES_8)
				{
					configuredLogicalDrives = 
							deviceExtension->NoncachedExtension->MRAIDParams.MRAIDParams8.LogdrvInfo.NumLDrv;
				}
				else
				{
					configuredLogicalDrives = 
							deviceExtension->NoncachedExtension->MRAIDParams.MRAIDParams40.numLDrv;
				}

				if(configuredLogicalDrives == 0)
				{
					Srb->SrbStatus  = SRB_STATUS_SUCCESS;  
					Srb->ScsiStatus = SCSISTAT_GOOD;
					status          = REQUEST_DONE;
					break;
				}
				status = FireRequest(deviceExtension, Srb);
				break;
			case SRB_FUNCTION_FLUSH:
				{
					Srb->SrbStatus = SRB_STATUS_SUCCESS;  
					Srb->ScsiStatus = SCSISTAT_GOOD;
					status = REQUEST_DONE;
					break;
				}
			case SRB_FUNCTION_SHUTDOWN:
        DebugPrint((0,"\nDEVEXT %#p RECEIVED ->SRB_FUNCTION_SHUTDOWN for <%02d %02d %02d>", deviceExtension, Srb->PathId, Srb->TargetId, Srb->Lun));
			case SRB_FUNCTION_IO_CONTROL:
			case SRB_FUNCTION_EXECUTE_SCSI:
			//
			// Requests for the adapter. The FireRequest routine returns the
			// the status of command firing. it sets the SRB status for the
			// invalid requests and returns REQUEST_DONE.
			//

				status = FireRequest(deviceExtension, Srb);

				break;
			case SRB_FUNCTION_ABORT_COMMAND:
			//
			// Fail the Abort command. We can't abort the requests.
			//
				Srb->SrbStatus          = SRB_STATUS_ABORT_FAILED;
				status                  = REQUEST_DONE; 
				break;
			default:
			//
			// Return SUCCESS for all other calls.
			//
				Srb->SrbStatus  = SRB_STATUS_SUCCESS;  
				Srb->ScsiStatus = SCSISTAT_GOOD;
				status          = REQUEST_DONE;
				break;
			} // end switch
		}
		else{
			Srb->SrbStatus    = SRB_STATUS_INVALID_REQUEST;
			status            = REQUEST_DONE;
		}       
		
    //
		// Check the request status.
		//

		switch( status) {
			case TRUE:
				//
				// The request got issued. Ask the next request.
				//
        if(Srb->SrbFlags & SRB_FLAGS_QUEUE_ACTION_ENABLE)
        {
			    ScsiPortNotification(NextLuRequest, deviceExtension, Srb->PathId, Srb->TargetId, Srb->Lun);
        }
				break;
			case QUEUE_REQUEST:
				//
				// Adapter is BUSY. Queue the request. We queue only one request. 
				//
				if(deviceExtension->PendingSrb)
				{
					//Already command is queued return to PortDriver to process it later.
					Srb->SrbStatus = SRB_STATUS_BUSY;
					ScsiPortNotification(RequestComplete, deviceExtension, Srb);
				}
				else //Now command is queued then queue this command
				{
					deviceExtension->PendingSrb = Srb;
				}

        DebugPrint((0, "\n MegaRAIDStartIo -> Queued Request SRB %#p : P%xT%xL%x -> Srb->Function %X Cdb[0] %X", Srb, Srb->PathId, Srb->TargetId, Srb->Lun, Srb->Function, Srb->Cdb[0]));
				break;
			case REQUEST_DONE:
				//
				// The request is complete. Ask the next request from the OS and
				// complete the current request.
				//
        if(Srb->SrbFlags & SRB_FLAGS_QUEUE_ACTION_ENABLE)
        {
          ScsiPortNotification(NextLuRequest, deviceExtension, Srb->PathId, Srb->TargetId, Srb->Lun);
        }
        else
        {
          ScsiPortNotification(NextRequest, deviceExtension, NULL);
        }
				ScsiPortNotification(RequestComplete, deviceExtension, Srb);
			break;
			default:
				//      
				// We never reach this condition.
				//
					break;
		}
		return TRUE;
} // end MegaRAIDStartIo()



/*********************************************************************
Routine Description:
	This routine issues or completes the request depending on the point of
	call.

Arguments:
		DeviceExtension-	Pointer to Device Extension.
		CommandID			-  Command index.
		Origin			-  Origin of the call.

Return Value:
		REQUEST_DONE if invalid request
		TRUE otherwise
**********************************************************************/
ULONG32
ContinueDiskRequest(
	IN PHW_DEVICE_EXTENSION DeviceExtension,
	IN UCHAR CommandID,
	IN BOOLEAN Origin
	)
{
	PVOID                   dataPointer;
	PDIRECT_CDB             megasrb;
	PSGL32                  sgPtr ;
	PSCSI_REQUEST_BLOCK     srb;
	PREQ_PARAMS             controlBlock;
	PUCHAR                  pciPortStart;
	FW_MBOX                 mbox;
	ULONG32                   bytesLeft;
	ULONG32										bytesTobeTransferred;
	ULONG32                   descriptorCount = 0;
	ULONG32                   physAddr, tmp;
	ULONG32                   length, blocks, bytes;
	
	UCHAR			              configuredLogicalDrives;

	PMEGARaid_INQUIRY_8     raidParamEnquiry_8ldrv;
	PMEGARaid_INQUIRY_40    raidParamEnquiry_40ldrv;
	
	PMEGARaid_INQUIRY_8     raidTempParamEnquiry_8ldrv;
	PMEGARaid_INQUIRY_40    raidTempParamEnquiry_40ldrv;
	
	PUCHAR							    raidParamFlatStruct;
	PUCHAR							    raidTempParamFlatStruct;
	
  PSGL64                  sgl64;

  PMegaSrbExtension       srbExtension;
  PIOCONTROL_MAIL_BOX     ioctlMailBox;

  //
	//get the controller inquiry data
	//
	raidParamEnquiry_8ldrv = 
		(PMEGARaid_INQUIRY_8)&DeviceExtension->NoncachedExtension->MRAIDParams.MRAIDParams8;
	raidParamEnquiry_40ldrv = 
		(PMEGARaid_INQUIRY_40)&DeviceExtension->NoncachedExtension->MRAIDParams.MRAIDParams40;
	
	//
	//since, MRAIDParams8 & MRAIDParams40 are in {Union}, casting to anything
	//is one and the same.
	//
	raidParamFlatStruct = 
		(PUCHAR)&DeviceExtension->NoncachedExtension->MRAIDParams.MRAIDParams8;

	raidTempParamEnquiry_8ldrv = 
		(PMEGARaid_INQUIRY_8)&DeviceExtension->NoncachedExtension->MRAIDTempParams.MRAIDTempParams8;
	raidTempParamEnquiry_40ldrv = 
		(PMEGARaid_INQUIRY_40)&DeviceExtension->NoncachedExtension->MRAIDTempParams.MRAIDTempParams40;
	
	//
	//since, MRAIDTempParams8 & MRAIDTempParams40 are in {Union}, 
	//casting to anything is one and the same.
	//
	raidTempParamFlatStruct = 
		(PUCHAR)&DeviceExtension->NoncachedExtension->MRAIDTempParams.MRAIDTempParams8;

	//
	//get the configured logical drive count
	//
	if(DeviceExtension->SupportedLogicalDriveCount == MAX_LOGICAL_DRIVES_8)
	{
		configuredLogicalDrives = 
					raidParamEnquiry_8ldrv->LogdrvInfo.NumLDrv;
	}
	else
	{
		configuredLogicalDrives = 
					raidParamEnquiry_40ldrv->numLDrv;
	}

	//
	//get the port map of the controller
	//
	pciPortStart = DeviceExtension->PciPortStart;
	
	//
	// Extract the Request Control Block.
	//
	controlBlock = &DeviceExtension->ActiveIO[CommandID];
	srb = DeviceExtension->PendSrb[CommandID];

	//
	// MegaSrb structure is taken in the Srb Extension.
	//
  srbExtension = srb->SrbExtension;
  megasrb = (PDIRECT_CDB)&srbExtension->MegaPassThru;
  sgPtr =   &srbExtension->SglType.SG32List;
  sgl64 =   &srbExtension->SglType.SG64List;

  //Initialize MAILBOX
  MegaRAIDZeroMemory(&mbox, sizeof(FW_MBOX));

	if (Origin == FALSE) 
	{
		//
		// Interrupt time call.
		//
		
    //Updating the actual data transfer length from fw to OS
    if(controlBlock->Opcode == MEGA_SRB)
		{		
				srb->DataTransferLength = megasrb->data_xfer_length;
		}

    if (srb->Function == SRB_FUNCTION_SHUTDOWN)
		{
			DebugPrint((0, "\nMegaRAID: Shutdown....."));
     
			DebugPrint((0, "\nCommands Pending = 0x%x....",DeviceExtension->PendCmds));
      /////////////////////////////////////////////////////////
     	if(srbExtension->IsShutDownSyncIssued == 0)
			{
				DebugPrint((0, "\nMegaRAID: Issuing Sync Command with CommandID=%x\n", CommandID));
				srbExtension->IsShutDownSyncIssued = 1;
				mbox.Command = 0xFE;
				mbox.CommandId = CommandID;
				SendMBoxToFirmware(DeviceExtension, pciPortStart, &mbox);
				return (ULONG32)TRUE;
			}
			else
			{
				DebugPrint((0, "\n0xFE command completing with CommandId=%x\n",CommandID));

				srbExtension->IsShutDownSyncIssued = 0;
				FireRequestDone(DeviceExtension, CommandID, SRB_STATUS_SUCCESS);
			
				DebugPrint((0, "\nShutdown completed to OS"));
				return (ULONG32)TRUE;
			}
      /////////////////////////////////////////////////////////

		}

		if(srb->Function == SRB_FUNCTION_IO_CONTROL)
		{
			
			ioctlMailBox = (PIOCONTROL_MAIL_BOX)((PUCHAR)srb->DataBuffer + sizeof(SRB_IO_CONTROL));

			//
			// MegaIo completion.
			//
			//pDest=(PUCHAR )srb->DataBuffer;
		  
      ioctlMailBox->IoctlSignatureOrStatus = controlBlock->CommandStatus;
			srb->ScsiStatus = SCSISTAT_GOOD;

			if ((ioctlMailBox->IoctlCommand == MRAID_WRITE_CONFIG)
           || (ioctlMailBox->IoctlCommand == MRAID_EXT_WRITE_CONFIG) 
           ||((ioctlMailBox->IoctlCommand == DCMD_FC_CMD) 
           && (ioctlMailBox->CommandSpecific[0] == DCMD_WRITE_CONFIG))
         )
			{
				//
				// Issue Adapter Enquiry command.
				//
				//
				//get the latest configuration in the TempParams structure
				//
				mbox.u.Flat2.DataTransferAddress = MegaRAIDGetPhysicalAddressAsUlong(DeviceExtension, 
																		                      NULL, 
																		                      raidTempParamFlatStruct, 
																		                      &length);
				
				if(DeviceExtension->SupportedLogicalDriveCount == MAX_LOGICAL_DRIVES_8)
				{
						//
						// Fill the Mailbox.
						//
						mbox.Command  = MRAID_DEVICE_PARAMS;
						mbox.CommandId = DEDICATED_ID;

						raidTempParamEnquiry_8ldrv->LogdrvInfo.NumLDrv = 0;
				}
				else
				{

					//
					//send enquiry3 command to the firmware to get the logical
					//drive information.The older enquiry command is no longer
					//supported by the 40 logical drive firmware
					//

					mbox.Command   = NEW_CONFIG_COMMAND; //inquiry 3 [BYTE 0]
					mbox.CommandId       = DEDICATED_ID;//command id [BYTE 1]

					mbox.u.Flat2.Parameter[0] = NC_SUBOP_ENQUIRY3;	//[BYTE 2]
					mbox.u.Flat2.Parameter[1] = ENQ3_GET_SOLICITED_FULL;//[BYTE 3]

					raidTempParamEnquiry_40ldrv->numLDrv = 0;
				}

		
				DeviceExtension->AdpInquiryFlag = 1;
        DeviceExtension->ReadDiskArray = 1;

				//
				//set the update state
				//
				DeviceExtension->NoncachedExtension->UpdateState =
																		UPDATE_STATE_ADAPTER_INQUIRY;

				//DeviceExtension->BootFlag = 1;
				SendMBoxToFirmware(DeviceExtension, pciPortStart,&mbox);
			}
			FireRequestDone(DeviceExtension, CommandID, SRB_STATUS_SUCCESS);
			return (ULONG32)TRUE;
		}


		//
		// If No Logical Drive is configured on this adapter then
		// Complete the Request here only 
		//
		if ((configuredLogicalDrives == 0)
			&& (srb->PathId >= DeviceExtension->NumberOfPhysicalChannels))
		{
			//
			// Check Status 
			//
			if (megasrb->status)
			{
				//
				// Check the BAD Status
				//
				if((megasrb->status == 0x02) &&
#ifndef CHEYENNE_BUG_CORRECTION
					!(srb->SrbFlags & SRB_FLAGS_DISABLE_AUTOSENSE) &&
#endif
					 (srb->SenseInfoBuffer != 0)) 
				{
					//
					// Copy the Request Sense
					//
					PUCHAR  senseptr;

					srb->SrbStatus  = SRB_STATUS_ERROR | SRB_STATUS_AUTOSENSE_VALID;
					srb->ScsiStatus = megasrb->status;
					senseptr = (PUCHAR)srb->SenseInfoBuffer;
					//
					// Copy the request sense data to the SRB.
					//
					ScsiPortMoveMemory(senseptr, megasrb->RequestSenseArea, megasrb->RequestSenseLength);
          
          srb->SenseInfoBufferLength      = megasrb->RequestSenseLength;
					//
					// Call the OS Request completion and free the command id.
					//
					FireRequestDone(DeviceExtension, CommandID, srb->SrbStatus);
				}
				else 
				{
					//
					// Fail the Command
					//
					srb->SrbStatus = SRB_STATUS_ERROR;
					srb->ScsiStatus = megasrb->status;
					srb->SenseInfoBufferLength = 0;
					//
					// Call the OS Request completion and free the command id.
					//
					FireRequestDone(DeviceExtension, CommandID, srb->SrbStatus);
				}
			}
			else
			{
				srb->ScsiStatus = SCSISTAT_GOOD;
				FireRequestDone(DeviceExtension, CommandID, SRB_STATUS_SUCCESS);
			}
			return (ULONG32)TRUE;
		}
		else 
		{
			if(srb->PathId < DeviceExtension->NumberOfPhysicalChannels)
			{
			//
			// Non disk request completion.
			//
				if(megasrb->status == 0x02)
					controlBlock->CommandStatus = 0x02;
			}

			if(controlBlock->CommandStatus)
			{
				//
				// Request Failed.
				//
				if (srb->PathId >= DeviceExtension->NumberOfPhysicalChannels)
				{
					UCHAR logicalDriveNumber = 
							GetLogicalDriveNumber(DeviceExtension, 
                                    srb->PathId,
                                    srb->TargetId,
                                    srb->Lun);

					//      
					// If Reserve/Release Fails tell SCSI Status 0x18
					//
					if ( srb->Cdb[0] == SCSIOP_RESERVE_UNIT ||
						  srb->Cdb[0] == SCSIOP_RELEASE_UNIT )
					{
						srb->ScsiStatus = SCSI_STATUS_RESERVATION_CONFLICT;
						FireRequestDone(DeviceExtension, CommandID, SRB_STATUS_ERROR);
						return(TRUE);
					}
					//
					//******************** STATISTICS ***************************//
					//

					if ((srb->Cdb[0] == SCSIOP_READ) ||
					    (srb->Cdb[0] == SCSIOP_READ6))  
					{
						//      
						// Incerement the read failure statistics.
						//
						if(DeviceExtension->SupportedLogicalDriveCount == MAX_LOGICAL_DRIVES_8)
						{
							DeviceExtension->Statistics.Statistics8.NumberOfIoReads[logicalDriveNumber]++;
							DeviceExtension->Statistics.Statistics8.NumberOfReadFailures[logicalDriveNumber]++;
						}
						else
						{
							DeviceExtension->Statistics.Statistics40.NumberOfIoReads[logicalDriveNumber]++;
							DeviceExtension->Statistics.Statistics40.NumberOfReadFailures[logicalDriveNumber]++;
						}
					}
					else 
					{
						//
						// Increment the write failure statistics.
						//
						if(DeviceExtension->SupportedLogicalDriveCount == MAX_LOGICAL_DRIVES_8)
						{
							DeviceExtension->Statistics.Statistics8.NumberOfIoWrites[logicalDriveNumber]++;
							DeviceExtension->Statistics.Statistics8.NumberOfWriteFailures[logicalDriveNumber]++;
						}
						else
						{
							DeviceExtension->Statistics.Statistics40.NumberOfIoWrites[logicalDriveNumber]++;
							DeviceExtension->Statistics.Statistics40.NumberOfWriteFailures[logicalDriveNumber]++;
						}
					}
					//
					//************************* STATISTICS ********************* //
					//
					if((controlBlock->CommandStatus == LOGDRV_RESERVATION_FAILED)
            || (controlBlock->CommandStatus == LOGDRV_RESERVATION_FAILED_NEW))
					{
						srb->ScsiStatus = SCSI_STATUS_RESERVATION_CONFLICT; 
						FireRequestDone(DeviceExtension, CommandID, SRB_STATUS_ERROR);
					}       
					else 
          {
						FireRequestDone(DeviceExtension, CommandID, SRB_STATUS_TIMEOUT);
          }
					return(TRUE);
				}
				else
				{
					//
					// Physical disk request.
					//
					if((controlBlock->CommandStatus == 0x02) &&
#ifndef CHEYENNE_BUG_CORRECTION
						!(srb->SrbFlags & SRB_FLAGS_DISABLE_AUTOSENSE) &&
#endif
						(srb->SenseInfoBuffer != 0)) 
					{
						int i;
						PUCHAR senseptr;

						srb->SrbStatus = SRB_STATUS_ERROR | 
											  SRB_STATUS_AUTOSENSE_VALID;          
						srb->ScsiStatus = controlBlock->CommandStatus;
						senseptr = (PUCHAR)srb->SenseInfoBuffer;
						//
						// Copy the request sense data to the SRB.
						//
            ScsiPortMoveMemory(senseptr, megasrb->RequestSenseArea, megasrb->RequestSenseLength);

						srb->SenseInfoBufferLength = megasrb->RequestSenseLength;
						//
						// Call the OS Request completion and free the command id.
						//
						FireRequestDone(DeviceExtension, CommandID, srb->SrbStatus);
					}
					else 
					{
						srb->SrbStatus = SRB_STATUS_ERROR;
						srb->ScsiStatus = controlBlock->CommandStatus;
						srb->SenseInfoBufferLength      = 0;
						//
						// Call the OS Request completion and free the command id.
						//
						FireRequestDone(DeviceExtension, CommandID, srb->SrbStatus);
					}
					return (ULONG32)(TRUE);
				}
			}
				
			//
			// ************************** STATISTICS ************************* //
			//
			// Modify the statistics in the device extension.
			//
			if(srb->PathId >= DeviceExtension->NumberOfPhysicalChannels) 
			{
				UCHAR logicalDriveNumber = 
							GetLogicalDriveNumber(DeviceExtension, 
                                    srb->PathId,
                                    srb->TargetId,
                                    srb->Lun);

				if ((srb->Cdb[0] == SCSIOP_READ) ||
				    (srb->Cdb[0] == SCSIOP_READ6))  
				{
					
					if(DeviceExtension->SupportedLogicalDriveCount == MAX_LOGICAL_DRIVES_8)
					{
							DeviceExtension->Statistics.Statistics8.NumberOfIoReads[logicalDriveNumber]++;
							DeviceExtension->Statistics.Statistics8.NumberOfBlocksRead[logicalDriveNumber] += controlBlock->TotalBlocks;
					}
					else
					{
							DeviceExtension->Statistics.Statistics40.NumberOfIoReads[logicalDriveNumber]++;
							DeviceExtension->Statistics.Statistics40.NumberOfBlocksRead[logicalDriveNumber] += controlBlock->TotalBlocks;
					}
						
				}
				else 
				{
					
					if(DeviceExtension->SupportedLogicalDriveCount == MAX_LOGICAL_DRIVES_8)
					{
							DeviceExtension->Statistics.Statistics8.NumberOfIoWrites[logicalDriveNumber]++;
							DeviceExtension->Statistics.Statistics8.NumberOfBlocksWritten[logicalDriveNumber] += controlBlock->TotalBlocks;;
					}
					else
					{
							DeviceExtension->Statistics.Statistics40.NumberOfIoWrites[logicalDriveNumber]++;
							DeviceExtension->Statistics.Statistics40.NumberOfBlocksWritten[logicalDriveNumber] += controlBlock->TotalBlocks;;
					}
				}
			}
			//
			//************************ STATISTICS ***************************
			//			
		
			//
			//check for the command completion. Partial transfers will have
			//some data left to be transferred.
			if(!controlBlock->IsSplitRequest)			
			{
				
				// All data transferred.Nothing more to be transferred.

				// Return good status for the request.
				//
				srb->ScsiStatus = SCSISTAT_GOOD;
				FireRequestDone(DeviceExtension, CommandID, SRB_STATUS_SUCCESS);
				
				return (ULONG32)TRUE;
			}
	
			//
			//initialize the mail box
			//
      MegaRAIDZeroMemory(&mbox, sizeof(FW_MBOX));

			//
			//Process the request for the remaining transfer
			//
			if(
				ProcessPartialTransfer(DeviceExtension, CommandID, srb, &mbox) !=0)
			{
					//
					//error in processing. Post the srb with the error code
					srb->SrbStatus = SRB_STATUS_ERROR;
					srb->ScsiStatus = controlBlock->CommandStatus;
					srb->SenseInfoBufferLength      = 0;
					
					//
					// Call the OS Request completion and free the command id.
					//
					FireRequestDone(DeviceExtension, CommandID, srb->SrbStatus);

					return (ULONG32)(TRUE);
			}
			
			//send the command to the firmware.
			//
			SendMBoxToFirmware(DeviceExtension, pciPortStart,&mbox);

			return (ULONG32)(TRUE);
		}//of (Logical drive presence)
	}//of ORIGIN == FALSE
	else 
	{
		//
		// Issue request.
		//
		if((controlBlock->BytesLeft) && 
			((controlBlock->Opcode == MRAID_LOGICAL_READ) || 
			(controlBlock->Opcode == MRAID_LOGICAL_WRITE) || 
			(controlBlock->Opcode == MEGA_SRB))) 
		{
      BOOLEAN buildSgl32Type;
			//
			// Get the physical addresses for the Buffer. 
			//
			dataPointer=controlBlock->VirtualTransferAddress;
			bytesLeft = controlBlock->BytesLeft;//actually bytestobeTransferred
			bytesTobeTransferred = controlBlock->BytesLeft;

			//
			//check for the split request.This flag is SET in the FireRequest()
			//routine.
			//
			if(controlBlock->IsSplitRequest){
					//
					//Request needs to be split because of SCSI limitation.
					//Any request > 100k needs to be broken for logical drives
					//with stripe size > 64K.This is because our SCSI scripts
					//can transfer only 100k maximum in a single command to the
					//drive.
					bytesLeft = DEFAULT_SGL_DESCRIPTORS * FOUR_KB;
					
					if(controlBlock->TotalBytes > bytesLeft){
						//
						//update the bytes to be transferred in the next cycle
						//
						controlBlock->BytesLeft = controlBlock->TotalBytes- bytesLeft;
					}
					else{
						//
						//set the old value from the control block as the transfer
						//is within the allowed bounds.
						//
						bytesLeft = controlBlock->BytesLeft;
						
						//
						//nothing remaining to be transferred
						//
						controlBlock->IsSplitRequest = FALSE;
						controlBlock->BytesLeft = 0;
					}						
			}

			//
			//update bytesto be transferred
			bytesTobeTransferred = bytesLeft;

      buildSgl32Type = (BOOLEAN)(DeviceExtension->LargeMemoryAccess == FALSE) ? TRUE : FALSE;


      if(BuildScatterGatherListEx(DeviceExtension,
			                   srb,
			                   dataPointer,
			                   bytesTobeTransferred,
                         buildSgl32Type,
                    		 (PVOID)sgPtr,
			                   &descriptorCount)!= MEGARAID_SUCCESS)
			{
				DeviceExtension->PendSrb[CommandID] = NULL;
				DeviceExtension->FreeSlot = CommandID;
				DeviceExtension->PendCmds--;

				srb->SrbStatus = SRB_STATUS_INVALID_REQUEST;
				return REQUEST_DONE;
			}
      

		  //
			// Get physical address of SGL.
			//
      //SG32List and SG64List are union, their physical location are same
      //SGList Physical address and SG64List Physical Address are same
      //But their length are different.

			physAddr = MegaRAIDGetPhysicalAddressAsUlong(DeviceExtension, 
															                     NULL,
															                     sgPtr, 
															                     &length);
			//
			// Assume minimum physical memory contiguous for sizeof(SGL32) bytes.
			//

      //
			// Create SGL segment descriptors.
			//
			//bytes = controlBlock->BytesLeft;
			bytes = bytesTobeTransferred;
			blocks = bytes / 512;
			bytes = blocks * 512;

			//update the number of blocks left to be transferred
			controlBlock->BlocksLeft = controlBlock->TotalBlocks - blocks;
		}
		else 
		{
			//
			// We don't have data to transfer.
			//
			bytes = 0;
			blocks = 0;
		}
    //
		// Check the command.
		//
		switch(controlBlock->Opcode) 
		{
				case MRAID_RESERVE_RELEASE_RESET:
				mbox.Command = controlBlock->Opcode;
				mbox.CommandId = CommandID;

				if (srb->Function == SRB_FUNCTION_RESET_BUS)
				{
					//
					// For Reset I don't need any Logical Drive Number 
					//
					mbox.u.Flat1.Parameter[0] = RESET_BUS;
				}
				else 
				{
					if ( srb->Cdb[0] == SCSIOP_RESERVE_UNIT)
						mbox.u.Flat2.Parameter[0] = RESERVE_UNIT;
					else
						mbox.u.Flat2.Parameter[0] = RELEASE_UNIT;

					//
					// Fill the Logical Drive No.
					//
					 mbox.u.Flat2.Parameter[1]= 
							GetLogicalDriveNumber(DeviceExtension, srb->PathId, srb->TargetId, srb->Lun);
				}
				break;
			case MRAID_LOGICAL_READ:
			case MRAID_LOGICAL_WRITE:
				{
					UCHAR logicalDriveNumber;
					ULONG32 lastLogicalBlock;

					logicalDriveNumber = GetLogicalDriveNumber(DeviceExtension, srb->PathId, srb->TargetId, srb->Lun);

					if(DeviceExtension->SupportedLogicalDriveCount == MAX_LOGICAL_DRIVES_8)
					{
						lastLogicalBlock = DeviceExtension->NoncachedExtension->MRAIDParams.MRAIDParams8.LogdrvInfo.LDrvSize[logicalDriveNumber];
					}
					else
					{
						lastLogicalBlock = DeviceExtension->NoncachedExtension->MRAIDParams.MRAIDParams40.lDrvSize[logicalDriveNumber];
					}

					//
					// Check if blocks is zero, fail the request for this case.
					//
					//
					//NORTON ANTIVIRUS SENDs command with start block as 0xFFFFFFFF, firmware fails to check 
					//its size validity because if number of blocks added to start block it truncated value
					//
					if ((blocks == 0) || (controlBlock->BlockAddress > lastLogicalBlock) || ((controlBlock->BlockAddress + blocks) > lastLogicalBlock))
					{
						DeviceExtension->PendSrb[CommandID] = NULL;
						DeviceExtension->FreeSlot = CommandID;
						DeviceExtension->PendCmds--;

						srb->SrbStatus = SRB_STATUS_INVALID_REQUEST;
						return (REQUEST_DONE);

						return (ULONG32)(REQUEST_DONE);
					}

				if(DeviceExtension->LargeMemoryAccess)
        {
 					  if(controlBlock->Opcode == MRAID_LOGICAL_READ)
              mbox.Command = MRAID_READ_LARGE_MEMORY;
            else
              mbox.Command = MRAID_WRITE_LARGE_MEMORY;

					  mbox.u.ReadWrite.NumberOfSgElements= (UCHAR)descriptorCount;
					  mbox.u.ReadWrite.DataTransferAddress  = physAddr;

        }
        else
        {
          if (descriptorCount > 1)
				  {
					  mbox.Command = controlBlock->Opcode;
					  mbox.u.ReadWrite.NumberOfSgElements = (UCHAR)descriptorCount;
					  mbox.u.ReadWrite.DataTransferAddress = physAddr;
				  }
				  else
				  {
					  //
					  // Scatter gather list has only one element. Give the address
					  // of the first element and issue the command as non Scatter
					  // Gather.
					  //
					  mbox.Command = controlBlock->Opcode;
					  mbox.u.ReadWrite.NumberOfSgElements = 0;  
		        mbox.u.ReadWrite.DataTransferAddress = sgPtr->Descriptor[0].Address;
				  }
        }
				//
				// Fill the local mailbox.
				//
				mbox.CommandId = CommandID;
				mbox.u.ReadWrite.NumberOfBlocks = (USHORT)blocks;
				mbox.u.ReadWrite.StartBlockAddress = controlBlock->BlockAddress;
				
				mbox.u.ReadWrite.LogicalDriveNumber = logicalDriveNumber; 
				}
				break;

			case MEGA_SRB:
        {
          SCSI_PHYSICAL_ADDRESS scsiPhyAddress;


				  //
				  // MegaSrb command. Fill the MegaSrb structure. 
				  //
          MegaRAIDZeroMemory(megasrb, sizeof(DIRECT_CDB));

          megasrb->Channel = srb->PathId;
				  megasrb->Lun = srb->Lun;
				  megasrb->ScsiId = srb->TargetId;

				  megasrb->TimeOut = TIMEOUT_60_SEC;
				  megasrb->Ars = 1;
				  megasrb->RequestSenseLength= MIN(srb->SenseInfoBufferLength, MAX_SENSE);
				  megasrb->data_xfer_length = srb->DataTransferLength;
				  megasrb->CdbLength = srb->CdbLength;
				  
          ScsiPortMoveMemory(megasrb->Cdb, srb->Cdb, srb->CdbLength);
				  

          if((descriptorCount == 1) && (DeviceExtension->LargeMemoryAccess == FALSE))
				  {
					  //
					  // Scatter gather list has only one element. Give the address
					  // of the first element and issue the command as non Scatter
					  // Gather.
					  //
					  megasrb->pointer = sgPtr->Descriptor[0].Address;
					  megasrb->NOSGElements = 0;
				  }
				  else
				  {
					  megasrb->pointer = physAddr;
					  megasrb->NOSGElements = (UCHAR)descriptorCount;
				  }
		  
				  //
				  // Fill the Mailbox
				  //
				  mbox.CommandId = CommandID;
				  mbox.u.PassThrough.CommandSpecific = 0;
				  

					scsiPhyAddress = ScsiPortGetPhysicalAddress(DeviceExtension, 
														                           NULL,
														                           megasrb, 
														                           &length);

					//
					//EXTENDED MAILBOX IS NOW PART OF MAILBOX ITSELF TO PROCTECT IT FROM CORRUPTION
					//REF : MS BUG 591773
					//
          
          if(DeviceExtension->LargeMemoryAccess == TRUE)
          {
            mbox.Command = NEW_MEGASRB;

					  if(scsiPhyAddress.HighPart)
						{
							mbox.u.PassThrough.DataTransferAddress =  MRAID_INVALID_HOST_ADDRESS;

							mbox.ExtendedMBox.HighAddress = scsiPhyAddress.HighPart;
							mbox.ExtendedMBox.LowAddress = scsiPhyAddress.LowPart;
						}
						else
						{
	            mbox.u.PassThrough.DataTransferAddress =  scsiPhyAddress.LowPart;

							mbox.ExtendedMBox.HighAddress = 0;
							mbox.ExtendedMBox.LowAddress = 0;
						}
          }
          else
          {
            mbox.Command = controlBlock->Opcode;

            mbox.u.PassThrough.DataTransferAddress =  scsiPhyAddress.LowPart;
          }

        }
				break;
			case MEGA_IO_CONTROL:
        {
        
				PUCHAR ioctlBuffer;
				PUCHAR mboxPtr;
        SCSI_PHYSICAL_ADDRESS scsiPhyAddress;
          //
				// Adapter Ioctl command.
				//
				ioctlMailBox = (PIOCONTROL_MAIL_BOX)
          ((PUCHAR)srb->DataBuffer+ sizeof(SRB_IO_CONTROL));
				
			  ioctlBuffer = (PUCHAR)(ioctlMailBox + 1);

        scsiPhyAddress.QuadPart = 0;
				
				if(ioctlMailBox->IoctlCommand != MEGA_SRB) 
				{
          //
					//       MegaIo command.
					//
					switch(ioctlMailBox->IoctlCommand) 
					{
						case MRAID_READ_FIRST_SECTOR:
							//
							// Application request to read the first sector.
							//
							mbox.Command                        = MRAID_LOGICAL_READ;
							mbox.CommandId                      = CommandID;
							mbox.u.ReadWrite.NumberOfBlocks     = 1;
							mbox.u.ReadWrite.StartBlockAddress  = 0;
							mbox.u.ReadWrite.LogicalDriveNumber = ioctlMailBox->CommandSpecific[0];      
							mbox.u.ReadWrite.NumberOfSgElements = 0;
							//
							// Get the physical address of the Data area.
							//
							scsiPhyAddress = ScsiPortGetPhysicalAddress(DeviceExtension, 
														                               srb ,
														                               ioctlBuffer, 
														                               &length);
							
              //
							// Fill the physical address in the mailbox
							//	
							if(scsiPhyAddress.HighPart > 0)
              {
                
                
                //Inorder to send 64 bit address to FW. Driver have to set phy address
                //as FFFFFFFF. Then Fw takes 64bit address from above 8 bytes
                //of MAILBOX, which is called as Extended MailBox.
                mbox.u.ReadWrite.DataTransferAddress = MRAID_INVALID_HOST_ADDRESS;

								//
								//EXTENDED MAILBOX IS NOW PART OF MAILBOX ITSELF TO PROCTECT IT FROM CORRUPTION
								//REF : MS BUG 591773
								//
                mbox.ExtendedMBox.HighAddress = scsiPhyAddress.HighPart;
                mbox.ExtendedMBox.LowAddress = scsiPhyAddress.LowPart;
                
                
                mbox.Command = MRAID_READ_LARGE_MEMORY;


                descriptorCount = 0;

                if(BuildScatterGatherListEx(DeviceExtension,
			                         srb,
			                         ioctlBuffer,
			                         512,
                               FALSE, //SGL64
                    	         (PVOID)sgPtr,
			                         &descriptorCount) != MEGARAID_SUCCESS)
								{
									DeviceExtension->PendSrb[CommandID] = NULL;
									DeviceExtension->FreeSlot = CommandID;
									DeviceExtension->PendCmds--;

									srb->SrbStatus = SRB_STATUS_INVALID_REQUEST;
									return REQUEST_DONE;
								}
		            //
			          // Get physical address of SGL.
			          //
                //SG32List and SG64List are union, their physical location are same
                //SGList Physical address and SG64List Physical Address are same
                //But their length are different.

			           physAddr = MegaRAIDGetPhysicalAddressAsUlong(DeviceExtension, 
															                                 NULL,
															                                 sgPtr, 
															                                 &length);

                
					        mbox.u.ReadWrite.NumberOfSgElements= (UCHAR)descriptorCount;
					        mbox.u.ReadWrite.DataTransferAddress  = physAddr;                             
              }
              else
              {
							  mbox.u.ReadWrite.DataTransferAddress = scsiPhyAddress.LowPart;
              }
						break;

						case DCMD_FC_CMD://0xA1
						{
              BOOLEAN skipDefault = TRUE; 
							switch(ioctlMailBox->CommandSpecific[0])
							{
								case DCMD_FC_READ_NVRAM_CONFIG: //0x04
									//
									//new private F/w Call introduced on 12/31/98.
									//The Scatter/Gather list for the user buffer
									//must be built to be sent to the firmware.
									//
									ConstructReadConfiguration(DeviceExtension, srb,CommandID, &mbox);
								break;

								case DCMD_WRITE_CONFIG://0x0D
									//
									//new private F/w Call introduced on 12/31/98.
									//The Scatter/Gather list for the user buffer
									//must be built to be sent to the firmware.
									//
									ConstructWriteConfiguration(DeviceExtension, srb, CommandID, &mbox);
								break;
                default:
                  skipDefault = FALSE;
							}

              if(skipDefault == TRUE)
                break;

						}
						//INTENTIONAL FALL THROUGH. THERE ARE LOTS of commands
						//with DCMD_FC_CMD as the first byte. We need to filter
						//only the READ AND WRITE CONFIG commands.

						default:
							//
							// Extract the mailbox from the application.
							//
							mbox.Command              = ioctlMailBox->IoctlCommand;
							mbox.CommandId            = CommandID;

							mbox.u.Flat2.Parameter[0] = ioctlMailBox->CommandSpecific[0];
							mbox.u.Flat2.Parameter[1] = ioctlMailBox->CommandSpecific[1];
							mbox.u.Flat2.Parameter[2] = ioctlMailBox->CommandSpecific[2];
							mbox.u.Flat2.Parameter[3] = ioctlMailBox->CommandSpecific[3];
							mbox.u.Flat2.Parameter[4] = ioctlMailBox->CommandSpecific[4];
							mbox.u.Flat2.Parameter[5] = ioctlMailBox->CommandSpecific[5];
							
							if ( ioctlMailBox->IoctlCommand == MRAID_CONFIGURE_DEVICE && 
									 ioctlMailBox->CommandSpecific[2] == MRAID_CONFIGURE_HOT_SPARE ) 
							{
                ScsiPortMoveMemory((PUCHAR)&mbox.u.Flat2.DataTransferAddress, ioctlBuffer, 4);
							}
							else 
							{
                if(srb->DataTransferLength > (sizeof(SRB_IO_CONTROL) + 8))
                {
								
                
                  //
								  // Get the physical address of the data transfer area.
								  //
							    scsiPhyAddress = ScsiPortGetPhysicalAddress(DeviceExtension, 
														                                   srb ,
														                                   ioctlBuffer, 
														                                   &length);
                }
                else
                {
                  scsiPhyAddress.QuadPart = 0;
                }


								//
								// Fill the physical address of data transfer area in
								// the mailbox.
								//
							  if(scsiPhyAddress.HighPart > 0)
                {
                  //Inorder to send 64 bit address to FW. Driver have to set phy address
                  //as FFFFFFFF. Then Fw takes 64bit address from above 8 bytes
                  //of MAILBOX, which is called as Extended MailBox.
                  mbox.u.Flat2.DataTransferAddress = MRAID_INVALID_HOST_ADDRESS;

								//
								//EXTENDED MAILBOX IS NOW PART OF MAILBOX ITSELF TO PROCTECT IT FROM CORRUPTION
								//REF : MS BUG 591773
								//
                  mbox.ExtendedMBox.HighAddress = scsiPhyAddress.HighPart;
                  mbox.ExtendedMBox.LowAddress = scsiPhyAddress.LowPart;
                }
                else
                {
							    mbox.u.Flat2.DataTransferAddress = scsiPhyAddress.LowPart;
                }


							}
							break;
						}
				} //of if(pSrc[0] != MEGA_SRB)                                                
				else
				{
					BOOLEAN buildSgl32Type;
          //
					// MegaSrb request. 
					//
					
          if(DeviceExtension->LargeMemoryAccess == TRUE)
            mbox.Command    = NEW_MEGASRB;
          else
            mbox.Command    = ioctlMailBox->IoctlCommand;
					
          mbox.CommandId  = CommandID;

					megasrb = (PDIRECT_CDB)ioctlBuffer;
          
          //
					// Get the physical address of the megasrb.
					//
					scsiPhyAddress = ScsiPortGetPhysicalAddress(DeviceExtension, 
														                           srb ,
														                           megasrb, 
														                           &length);

					//
					// Fill the physical address in the mailbox.
					//
          if(DeviceExtension->LargeMemoryAccess == TRUE)
          {
					  mbox.u.PassThrough.DataTransferAddress =  MRAID_INVALID_HOST_ADDRESS;

					//
					//EXTENDED MAILBOX IS NOW PART OF MAILBOX ITSELF TO PROCTECT IT FROM CORRUPTION
					//REF : MS BUG 591773
					//
            mbox.ExtendedMBox.HighAddress = scsiPhyAddress.HighPart;
            mbox.ExtendedMBox.LowAddress = scsiPhyAddress.LowPart;
          }
          else
          {
					  mbox.u.PassThrough.DataTransferAddress =  scsiPhyAddress.LowPart;
          }

          //Get dataBuffer address of MegaSRB
          ioctlBuffer      += sizeof(DIRECT_CDB);
	
					
					dataPointer = ioctlBuffer;
					bytesLeft = megasrb->data_xfer_length;
					descriptorCount = 0;
    
          buildSgl32Type = (BOOLEAN)(DeviceExtension->LargeMemoryAccess == FALSE) ? TRUE : FALSE;

          if(BuildScatterGatherListEx(DeviceExtension,
			                             srb,
			                             dataPointer,
			                             bytesLeft,
                                   buildSgl32Type, //SGL32
                    	             (PVOID)sgPtr,
			                             &descriptorCount) != MEGARAID_SUCCESS)
					{
						DeviceExtension->PendSrb[CommandID] = NULL;
						DeviceExtension->FreeSlot = CommandID;
						DeviceExtension->PendCmds--;

						srb->SrbStatus = SRB_STATUS_INVALID_REQUEST;
						return REQUEST_DONE;
					}

          

					if((descriptorCount == 1) && (DeviceExtension->LargeMemoryAccess == FALSE))
					{
						megasrb->pointer = sgPtr->Descriptor[descriptorCount-1].Address;
						megasrb->NOSGElements = 0;
					}
					else
					{
						//
						// Get physical address of SGL.
						//	
						physAddr = MegaRAIDGetPhysicalAddressAsUlong(DeviceExtension, 
																	                       NULL,
																	                       sgPtr, 
																	                       &length);
						//
						// Assume physical memory contiguous for sizeof(SGL) bytes.
						//
						megasrb->pointer = physAddr;
						megasrb->NOSGElements = (UCHAR)descriptorCount;
					}
					
				}
				break;
        }
			case MRAID_ADAPTER_FLUSH:
				//
				// Adapter flush cache command.
				//
        DebugPrint((0, "\n ContinueDiskRequest issuing MRAID_ADAPTER_FLUSH"));
        DeviceExtension->AdapterFlushIssued++;
        mbox.Command            = MRAID_ADAPTER_FLUSH;
				mbox.CommandId          = CommandID;
				controlBlock->BytesLeft = 0;
				bytes                   = 0;
				blocks                  = 0;
				break;
			default:
				//
				// Fail any other command with parity error.
				//
				srb->SrbStatus = SRB_STATUS_PARITY_ERROR;
			  DebugPrint((0, "\n ERROR *** (CDR)- case default hit"));
				return (ULONG32)(REQUEST_DONE);
		}
		//
		//      Issue command to the Adapter.
		//
		srb->SrbStatus = 0;
#ifdef  TOSHIBA
    //Implemented to remove event id for timeout
    DeviceExtension->AssociatedSrbStatus = SHORT_TIMEOUT;

		if (SendMBoxToFirmware(DeviceExtension, pciPortStart, &mbox) == FALSE) 
		{
			DebugPrint((0, "\n SendMBox Timed out -> Queueing the request (ContinueDiskRequest)"));
      DeviceExtension->PendSrb[CommandID] = NULL;
			DeviceExtension->FreeSlot = CommandID;
			DeviceExtension->PendCmds--;
      //If mailbox is busy queue this request by notifing ScsiPort Driver
      if(DeviceExtension->AssociatedSrbStatus == ERROR_MAILBOX_BUSY)
      {
        DeviceExtension->AssociatedSrbStatus = NORMAL_TIMEOUT;
        return (ULONG32)QUEUE_REQUEST;
      }
#ifdef MRAID_TIMEOUT
			DeviceExtension->DeadAdapter = 1;
			srb->SrbStatus = SRB_STATUS_ERROR;
			
      return (ULONG32)(REQUEST_DONE);
#else
			return (ULONG32)QUEUE_REQUEST;
#endif // MRAID_TIMEOUT
		}
#else
		SendMBoxToFirmware(DeviceExtension, pciPortStart, &mbox);
#endif
		return (ULONG32)(TRUE);
	}
}

/*********************************************************************
Routine Description:
	Build disk request from SRB and send it to the Adapter

Arguments:
	DeviceExtension
	SRB

Return Value:
	TRUE if command was started
	FALSE if host adapter is busy
**********************************************************************/
ULONG32
FireRequest(
	IN PHW_DEVICE_EXTENSION DeviceExtension,
	IN PSCSI_REQUEST_BLOCK Srb
	)
{
	PREQ_PARAMS       controlBlock;
	ULONG32             tmp, lsize;
  UCHAR             commandID;
	ULONG32             blocks=0, blockAddr=0;
	
	UCHAR             logicalDriveNumber = 0xff;
	UCHAR             opcode; 

	UCHAR			configuredLogicalDrives;

	PLOGDRV_COMMAND_ARRAY	logDrv;
	BOOLEAN	doubleFire;
	BOOLEAN isSplitRequest = FALSE;

  //
	//get the configured logical drives on the controller (if any)
	//
	if(DeviceExtension->SupportedLogicalDriveCount == MAX_LOGICAL_DRIVES_8)
	{
		configuredLogicalDrives = 
				DeviceExtension->NoncachedExtension->MRAIDParams.MRAIDParams8.LogdrvInfo.NumLDrv;
	}
	else
	{
		configuredLogicalDrives = 
				DeviceExtension->NoncachedExtension->MRAIDParams.MRAIDParams40.numLDrv;
	}

	//
	// Check for the Request Type.
	//
	if(Srb->Function == SRB_FUNCTION_IO_CONTROL)
	{
		PIOCONTROL_MAIL_BOX ioctlMailBox;

    if(Srb->DataTransferLength < (sizeof(SRB_IO_CONTROL)+sizeof(IOCONTROL_MAIL_BOX)))
		{
      Srb->SrbStatus = SRB_STATUS_INVALID_REQUEST;
			return ( REQUEST_DONE);
		}

		ioctlMailBox = (PIOCONTROL_MAIL_BOX)((PUCHAR )Srb->DataBuffer + sizeof(SRB_IO_CONTROL));
		//
		// Check for the Validity of the Request. Fail the invalid request.
		//
		if ( ioctlMailBox->IoctlSignatureOrStatus != 0xAA )
    {
			Srb->SrbStatus = SRB_STATUS_INVALID_REQUEST;
			return ( REQUEST_DONE);
		}
                                     
    if(ioctlMailBox->IoctlCommand == MRAID_ADAPTER_FLUSH) 
    {
      DeviceExtension->AdapterFlushIssued++;
      DebugPrint((0, "\n MEGARAID issuing MRAID_ADAPTER_FLUSH"));

    }
		//
		// If the request is statistics request return the statistics.
		//
		if ( ioctlMailBox->IoctlCommand == MRAID_STATISTICS) 
			return  MRaidStatistics(DeviceExtension, Srb);

		//
		// Driver and OS Data
		//
		if ( ioctlMailBox->IoctlCommand == MRAID_DRIVER_DATA)
			return  MRaidDriverData(DeviceExtension, Srb);

		//
		// Controller BasePort Data
		//
		if ( ioctlMailBox->IoctlCommand == MRAID_BASEPORT)
			return  MRaidBaseport(DeviceExtension, Srb);

#ifdef TOSHIBA_SFR
		if ( ioctlMailBox->IoctlCommand == MRAID_SFR_IOCTL)
		{
			PMRAID_SFR_DATA_BUFFER  buffer;

			buffer = (PMRAID_SFR_DATA_BUFFER)((PUCHAR)Srb->DataBuffer + 
															sizeof(SRB_IO_CONTROL) +
															APPLICATION_MAILBOX_SIZE);

			buffer->FunctionA = (PHW_SFR_IF_VOID)MegaRAIDFunctionA;
			buffer->FunctionB = (PHW_SFR_IF)MegaRAIDFunctionB;
			buffer->HwDeviceExtension = DeviceExtension;
      
      ioctlMailBox->IoctlSignatureOrStatus = MEGARAID_SUCCESS;
			
      Srb->SrbStatus  = SRB_STATUS_SUCCESS;
			Srb->ScsiStatus = SCSISTAT_GOOD;
			
      return REQUEST_DONE;
		}
#endif

	if ((ioctlMailBox->IoctlCommand == MRAID_WRITE_CONFIG)
    || (ioctlMailBox->IoctlCommand == MRAID_EXT_WRITE_CONFIG) 
    || ((ioctlMailBox->IoctlCommand == DCMD_FC_CMD) && (ioctlMailBox->CommandSpecific[0] == DCMD_WRITE_CONFIG))
    )
    {
	    if (DeviceExtension->AdpInquiryFlag)
				    return QUEUE_REQUEST;
    }
	
      //
      //NEW IOCTL added on 12/14/98
      //
      if(ioctlMailBox->IoctlCommand == MRAID_GET_LDRIVE_INFO)
      {         

	      PLOGICAL_DRIVE_INFO  lDriveInfo;
         //
         //check for invalid data in the global array
         //
         if(gLDIArray.HostAdapterNumber == 0xFF)
         {
            //
            //Read command not given before LDInfo
            //
            Srb->SrbStatus  = SRB_STATUS_INVALID_REQUEST;           
            return REQUEST_DONE;
         }


         lDriveInfo = (PLOGICAL_DRIVE_INFO)(
                            (PUCHAR)Srb->DataBuffer + 
														sizeof(SRB_IO_CONTROL) +
														APPLICATION_MAILBOX_SIZE);

         //
         //fill in the logical drive information from the global
         //array. This must be issued only after issuing READ_SECTOR
         //for the logical drive.On call to this, whatever info
         //present in the global array is copied to the output buffer.
         //The caller has to enforce the sequentiality 
         //
         lDriveInfo->HostAdapterNumber =  gLDIArray.HostAdapterNumber;
         lDriveInfo->LogicalDriveNumber = gLDIArray.LogicalDriveNumber;

         //
         //invalidate the global array data
         //
         gLDIArray.HostAdapterNumber = 0xFF;
         gLDIArray.LogicalDriveNumber = 0xFF;

         //
         //reset the 0xAA signature
         //
         ioctlMailBox->IoctlSignatureOrStatus = MEGARAID_SUCCESS;

         Srb->SrbStatus  = SRB_STATUS_SUCCESS;
				 Srb->ScsiStatus = SCSISTAT_GOOD;
			
         return REQUEST_DONE;
      }
		
		//
		// MegaIo call for the adapter. 
		//
		opcode = MEGA_IO_CONTROL;
		//
		// Fill the actual length later.
		//
		blocks = 0;  
		goto give_command;
	}


	//
	// Clustering is Supported for Logical Drive only. I make sure the RESET
	// Bus Comes  only when Logical Drives are Configured.
	//
	if ( Srb->Function == SRB_FUNCTION_RESET_BUS )
	{
		opcode = MRAID_RESERVE_RELEASE_RESET;
		//
		// Fill the actual length later.
		//
		blocks = 0;  
		goto give_command;
	}
  
  //Initialize the actual exposed devices
  if((Srb->Cdb[0] == SCSIOP_INQUIRY)
      && (Srb->Function == SRB_FUNCTION_EXECUTE_SCSI)
      && (Srb->PathId == 0)
      &&(Srb->TargetId == 0) 
      && (Srb->Lun == 0))
  {
    DeviceExtension->ExposedDeviceCount = configuredLogicalDrives + DeviceExtension->NonDiskDeviceCount;

 
    if(DeviceExtension->ReadConfigCount >= MAX_RETRY)
      DeviceExtension->ReadConfigCount = 0;

    DeviceExtension->ReadConfigCount++;

    if(DeviceExtension->ReadConfigCount == 1)
    {
      opcode = MEGA_SRB;

		  //
		  // Actual length is filled in later.
		  //
		  blocks = 0;  
		  goto give_command;
    }

  }
  
  //
  //Any request for physical channel send it directly to drive
  //
	if (Srb->PathId < DeviceExtension->NumberOfPhysicalChannels
    && Srb->Function == SRB_FUNCTION_EXECUTE_SCSI) 
	{
			//
			// Non Disk Request.
			//
			//If Lun != 0 then MEGARAID SCSI will not process any command
      if(Srb->Lun != 0)
      {
				Srb->SrbStatus = SRB_STATUS_NO_DEVICE;
				return ( REQUEST_DONE);
      }

      ////ALLOW SCANNING TO PHYSICAL CHANNELS
      /*
      if(DeviceExtension->NonDiskInfo.NonDiskInfoPresent == TRUE)
      {
        if(!IS_NONDISK_PRESENT(DeviceExtension->NonDiskInfo, Srb->PathId, Srb->TargetId, Srb->Lun))
        {
				  Srb->SrbStatus = SRB_STATUS_NO_DEVICE;
				  return ( REQUEST_DONE);
        }
      }*/

      if(Srb->PathId == DeviceExtension->Failed.PathId && Srb->TargetId == DeviceExtension->Failed.TargetId)
      {
        Srb->SrbStatus = SRB_STATUS_NO_DEVICE;
				return ( REQUEST_DONE);
      }

      opcode = MEGA_SRB;

			//
			// Actual length is filled in later.
			//
			blocks = 0;  
			goto give_command;
  }


	//
  //Process for LOGICAL DRIVE
  //
  //
	//Extract Logical drive number
  //Extract the target from the request.
	logicalDriveNumber = GetLogicalDriveNumber(DeviceExtension, Srb->PathId, Srb->TargetId, Srb->Lun);

  //
  //Under condtion of no Logical drive configured and no NON DISK device
  //present we have to expose one unknown device to enable power console
  //to access the driver
  //
  if( (Srb->PathId == DeviceExtension->NumberOfPhysicalChannels)
    && (Srb->TargetId == UNKNOWN_DEVICE_TARGET_ID)
    && (Srb->Lun == UNKNOWN_DEVICE_LUN))
  {
    ; //Do nothing
  }
  else
  {
    //
		// Check Logical drive is present. Fail the request otherwise.
		//
		if (logicalDriveNumber >= configuredLogicalDrives)
		{
				Srb->SrbStatus = SRB_STATUS_NO_DEVICE;
				return ( REQUEST_DONE);
		}
  }

  //
  //CONFIGURED LOGICAL DRIVE  ONLY
  //

	if(Srb->Function == SRB_FUNCTION_EXECUTE_SCSI) 
	{
		//
		// Check the request opcode.
		//
		switch(Srb->Cdb[0]) 
		{
			case SCSIOP_READ:
				//
				// Ten Byte Read command.
				//
				opcode = MRAID_LOGICAL_READ;
				blocks = (ULONG32)GetM16(&Srb->Cdb[7]);
				blockAddr = GetM32(&Srb->Cdb[2]);


					//
          //For new IOCTL,  MRAID_GET_LDRIVE_INFO, a call to 
          //read sector1 is given by the application first.
          //Note down the Path, Target & Lun info in a global
          //structure.Every call to MRAID_GET_LDRIVE_INFO must be
          //preceded by a call to the ReadSector(1) for the 
          //logical drive.
          //
          if( (blockAddr == 1) && (blocks == 1) )
          {
             //
             //sector0 read. store the path, target,lun info
             //in the global array.
             //
             gLDIArray.HostAdapterNumber = 
                      DeviceExtension->HostAdapterOrdinalNumber;
             gLDIArray.LogicalDriveNumber = logicalDriveNumber; //logical drive number
          }


				break;
			case SCSIOP_WRITE:
			case SCSIOP_WRITE_VERIFY:
				//
				// Ten Byte write command.
				//
				opcode = MRAID_LOGICAL_WRITE;
				blocks = (ULONG32)GetM16(&Srb->Cdb[7]);
				blockAddr = GetM32(&Srb->Cdb[2]);
				break;

			case SCSIOP_READ6:
				//
				// Six Byte read command. 
				//
				opcode = MRAID_LOGICAL_READ;
				blocks = (ULONG32)Srb->Cdb[4];
				blockAddr = GetM24(&Srb->Cdb[1]) & 0x1fffff;
				break;
			
      case SCSIOP_WRITE6:
				//
				// Six byte write command.
				//
				opcode = MRAID_LOGICAL_WRITE;
				blocks = (ULONG32)Srb->Cdb[4];
				blockAddr = GetM24(&Srb->Cdb[1]) & 0x1fffff;
				break;

      case SCSIOP_READ_CAPACITY:
        {
          ULONG32 BytesPerBlock = 0x200;
          PREAD_CAPACITY_DATA ReadCapacity;
				  //
				  // Read capacity command.
				  //
				  //Initialize the buffer before using
          MegaRAIDZeroMemory(Srb->DataBuffer, Srb->DataTransferLength);
          
          ReadCapacity = (PREAD_CAPACITY_DATA)Srb->DataBuffer;
        
				  if(DeviceExtension->SupportedLogicalDriveCount == MAX_LOGICAL_DRIVES_8)
				  {
						  lsize = 
							  DeviceExtension->NoncachedExtension->MRAIDParams.MRAIDParams8.LogdrvInfo.LDrvSize[logicalDriveNumber];
				  }
				  else
				  {
						  lsize = 
							  DeviceExtension->NoncachedExtension->MRAIDParams.MRAIDParams40.lDrvSize[logicalDriveNumber];
				  }
				  lsize--;

          //
          //Unknown device has no capacity
          //
          if(Srb->TargetId == UNKNOWN_DEVICE_TARGET_ID)
          {
            lsize = 0;
            BytesPerBlock = 0;
          }

			  
          PutM32((PUCHAR)&ReadCapacity->LogicalBlockAddress, lsize);
          PutM32((PUCHAR)&ReadCapacity->BytesPerBlock, BytesPerBlock);

					DebugPrint((0, "\n0x%X -> LD%d -> Capacity %d MB", DeviceExtension, logicalDriveNumber, (lsize/2048)));

          Srb->ScsiStatus = SCSISTAT_GOOD;
				  Srb->SrbStatus = SRB_STATUS_SUCCESS;
				  break;     
        }

      case SCSIOP_TEST_UNIT_READY:
				Srb->ScsiStatus = SCSISTAT_GOOD;
				Srb->SrbStatus = SRB_STATUS_SUCCESS;
				break;     

    	case SCSIOP_MODE_SENSE:				
				DebugPrint((0, "\nMode Sense : Page=0x%0x",Srb->Cdb[2]));
				Srb->SrbStatus = SRB_STATUS_INVALID_REQUEST;				
				return(REQUEST_DONE);

			case SCSIOP_RESERVE_UNIT:
			case SCSIOP_RELEASE_UNIT:
				opcode = MRAID_RESERVE_RELEASE_RESET;
				blocks = 0;
				break;

			case SCSIOP_INQUIRY:
			{
				UCHAR                Index;
				INQUIRYDATA          inquiry;
				PMEGARaid_INQUIRY_8  raidParamEnquiry_8ldrv;
				PMEGARaid_INQUIRY_40 raidParamEnquiry_40ldrv;


        //RAID CONTROLLERS CANNOT SUPPORT VENDOR SPECIFIC INQUIRY e.g. Code 0, Code 80 and code 83
        if(Srb->Cdb[1])
        {
      		Srb->SrbStatus = SRB_STATUS_INVALID_REQUEST;
    			return REQUEST_DONE;
        }
				
				//
				//get the Controller inquiry information.Cast to both the 8 & 40
				//logical drive structures.
				//
				raidParamEnquiry_8ldrv = 
							(PMEGARaid_INQUIRY_8)&DeviceExtension->NoncachedExtension->MRAIDParams.MRAIDParams8;

				raidParamEnquiry_40ldrv = 
							(PMEGARaid_INQUIRY_40)&DeviceExtension->NoncachedExtension->MRAIDParams.MRAIDParams40;


				//Initialize the Data buffer
        MegaRAIDZeroMemory(Srb->DataBuffer, Srb->DataTransferLength);

				//Initialize local INQUIRY BUFFER
				MegaRAIDZeroMemory(&inquiry, sizeof(INQUIRYDATA));

        DebugPrint((0, "\n SCSI INQUIRY LENGTH %x -> Page Code %X Page %X", Srb->DataTransferLength, Srb->Cdb[1], Srb->Cdb[2]));
        
				//////////////////////////////////////////
				//Now Fill the INQUIRY into Local Buffer//
				//////////////////////////////////////////

        if(Srb->TargetId == UNKNOWN_DEVICE_TARGET_ID)
        {
          inquiry.DeviceType = UNKNOWN_DEVICE;

          ScsiPortMoveMemory((void*)&inquiry.VendorId, (void*)DummyVendor, 8);

          for (Index = 0 ; Index < 16 ; Index++)
					  inquiry.ProductId[Index] = DummyProductId[Index];

          ScsiPortMoveMemory (&inquiry.ProductRevisionLevel, "0000", 4);

        }
				else
				{
					inquiry.DeviceType = DIRECT_ACCESS_DEVICE;
					inquiry.Versions = 2;
					inquiry.ResponseDataFormat = 2;

					//((PUCHAR)pInq)[7] = 0x32;     //HCT Fix
          //HCT Fix Start
          inquiry.CommandQueue = 1; 
          inquiry.Synchronous = 1;  
          inquiry.Wide16Bit = 1;    
          //HCT Fix Ends


					inquiry.AdditionalLength = 0xFA;
					
					//Fill Actual Vendor ID depending on  SubsystemVendorID
					FillOemVendorID(inquiry.VendorId, DeviceExtension->SubSystemDeviceID, DeviceExtension->SubSystenVendorID);
					
					//Fill Actual Product ID depending on  SubsystemVendorID
					FillOemProductID(&inquiry, DeviceExtension->SubSystemDeviceID, DeviceExtension->SubSystenVendorID);

					
					if(logicalDriveNumber <= 9)
					{
						inquiry.ProductId[4] = ' ';//higher digit
						inquiry.ProductId[5] = logicalDriveNumber + '0';//lower digit
					}
					else
					{
						inquiry.ProductId[4] = (logicalDriveNumber / 10) + '0';//higher digit
						inquiry.ProductId[5] = (logicalDriveNumber % 10) + '0';//lower digit
					}

					for (Index=0;Index<4;Index++)
					{
						/*
						if(DeviceExtension->SupportedLogicalDriveCount == MAX_LOGICAL_DRIVES_8)
						{
							inquiry.ProductRevisionLevel[Index] = 
													raidParamEnquiry_8ldrv->AdpInfo.FwVer[Index];
						}
						else*/
						{
							inquiry.ProductRevisionLevel[Index] = ' ';

						}
					}
				}
				
				//TRANSFER INQUIRY BUFFER according to output buffer length
				if(sizeof(INQUIRYDATA) > Srb->DataTransferLength)
					ScsiPortMoveMemory(Srb->DataBuffer, &inquiry, Srb->DataTransferLength);
				else
					ScsiPortMoveMemory(Srb->DataBuffer, &inquiry, sizeof(INQUIRYDATA));

				Srb->ScsiStatus = SCSISTAT_GOOD;
				Srb->SrbStatus = SRB_STATUS_SUCCESS;
				
				return(REQUEST_DONE);
				break;
			}
			case SCSIOP_REZERO_UNIT:
			case SCSIOP_SEEK6:
			case SCSIOP_VERIFY6:
			case SCSIOP_SEEK:
			case SCSIOP_VERIFY:
				Srb->ScsiStatus         = SCSISTAT_GOOD;
				Srb->SrbStatus          = SRB_STATUS_SUCCESS;
				return(REQUEST_DONE);

			case SCSIOP_REQUEST_SENSE:
				
    		MegaRAIDZeroMemory(Srb->DataBuffer, Srb->DataTransferLength);

				((PUCHAR)Srb->DataBuffer)[0] = 0x70;
				

				((PUCHAR)Srb->DataBuffer)[7] = 0x18;

				((PUCHAR)Srb->DataBuffer)[8] = 0xFF;
				((PUCHAR)Srb->DataBuffer)[9] = 0xFF;
				((PUCHAR)Srb->DataBuffer)[10] = 0xFF;
				((PUCHAR)Srb->DataBuffer)[11] = 0xFF;

				((PUCHAR)Srb->DataBuffer)[19] = 0xFF;
				((PUCHAR)Srb->DataBuffer)[20] = 0xFF;
				((PUCHAR)Srb->DataBuffer)[21] = 0xFF;
				((PUCHAR)Srb->DataBuffer)[22] = 0xFF;
				((PUCHAR)Srb->DataBuffer)[23] = 0xFF;


				Srb->ScsiStatus = SCSISTAT_GOOD;
				Srb->SrbStatus = SRB_STATUS_SUCCESS;
				return(REQUEST_DONE);

			case SCSIOP_FORMAT_UNIT:
			default:
				Srb->SrbStatus = SRB_STATUS_INVALID_REQUEST;
				return(REQUEST_DONE);
		}
	}
	else 
	{
		//
		// MegaIo command.
		//
		UCHAR	logDrvIndex;
		BOOLEAN chainFired;
		PSRB_EXTENSION	srbExtension;

    DebugPrint((0, "\nCDR -> Issuing Flush"));
	  if(DeviceExtension->IsFirmwareHanging)
    {
		  Srb->SrbStatus = SRB_STATUS_SUCCESS;
		  return (REQUEST_DONE);
    }

		//
		// MegaIo command.
		//
		opcode = MRAID_ADAPTER_FLUSH;
		blocks = 0;

		#ifdef COALESE_COMMANDS
		{

			//
			//get the SRB extension & initialize the fields
			//
			srbExtension = Srb->SrbExtension;

			srbExtension->NextSrb = NULL;
			srbExtension->StartPhysicalBlock =0;
			srbExtension->NumberOfBlocks =0;
			srbExtension->IsChained = FALSE;

			//
			//get the configured logical drives on the controller (if any)
			//
			if(DeviceExtension->SupportedLogicalDriveCount == MAX_LOGICAL_DRIVES_8)
			{
				configuredLogicalDrives = 
					DeviceExtension->NoncachedExtension->MRAIDParams.MRAIDParams8.LogdrvInfo.NumLDrv;
			}
			else
			{
				configuredLogicalDrives = 
					DeviceExtension->NoncachedExtension->MRAIDParams.MRAIDParams40.numLDrv;
			}

			//initialize
			chainFired =FALSE;

			for(logDrvIndex=0; logDrvIndex <  DeviceExtension->SupportedLogicalDriveCount;
						logDrvIndex++)
			{

				if(FireChainedRequest(DeviceExtension,
					                    &DeviceExtension->LogDrvCommandArray[logDrvIndex])
					)
				{
					//atleast one chain got fired
					chainFired = TRUE;
				}
			}//of for()

			//check for atleast one chain getting fired
			if(chainFired)
			{
				//hold the flush request. queue it in pending
				//srb
				return(QUEUE_REQUEST);
			}

			//else fire the current request.
			goto fire_command;
		}
		#endif// COALESE_COMMANDS
	}

give_command:

	if(DeviceExtension->IsFirmwareHanging)
  {
		Srb->SrbStatus = SRB_STATUS_SELECTION_TIMEOUT;
		return (REQUEST_DONE);
  }

	//
	// Check if the adapter can accept request. Queue the request otherwise.
	//
	if(DeviceExtension->PendCmds >= CONC_CMDS) 
	{
		return(QUEUE_REQUEST);
	}

	doubleFire = FALSE;

	// check if commands are pending in the adapter.
  //			IF( pending )
	//			{
	//					IF( command can be queued,,i.e possible to merge )
	//					{
	//							return TRUE ;
	//					}
	//					ELSE
	//					{
	//							Fire the commands in the queue;
	//							Fire the current command;
	//					}
	//			}
	//			ELSE
	//			IF not pending,
	//					fire the command
	//

#ifdef COALESE_COMMANDS
{
	PSRB_EXTENSION				srbExtension;


	//
	//Introduced for 2.23.Coalese.B
	//
	//get the SRB extension & initialize the fields
	//
	srbExtension = Srb->SrbExtension;

	srbExtension->NextSrb = NULL;
	srbExtension->StartPhysicalBlock =0;
	srbExtension->NumberOfBlocks =0;
	srbExtension->IsChained = FALSE;
	

	//
	//check for IOCTL commands. These commands don't have
	//a specific logical drive address.
	//
	if( (Srb->Function == SRB_FUNCTION_IO_CONTROL) )		
	{
			//bypass the read/write merge queue.
			//
			goto fire_command;
	}

	//check for the presence of logical drive in the system.
	//
	if(configuredLogicalDrives == 0)
	{
		//
		//no logical drives present in the system.
		//bypass the read/write merge queue.
		//
		goto fire_command;
	}

	//
	//check for the physical channels path. 
	//
	if(Srb->PathId < DeviceExtension->NumberOfPhysicalChannels)
	{
			//
			//Request is for non-disk. 
			//bypass the read/write merge queue.
			//
		goto fire_command;
	}
  //Don't Queue this command
  if(!(Srb->SrbFlags & SRB_FLAGS_QUEUE_ACTION_ENABLE))
  {
    //Fire All the commands it queued for this logcial drive
		FireChainedRequest(DeviceExtension, &DeviceExtension->LogDrvCommandArray[logicalDriveNumber]);
		goto fire_command;
  }

	//End Change for 2.23.Coalese.C

	//Change introduced for 2.23.Coalese.I
	//
	//change added on May/18/99 to solve the Cluster related issue.
	//Please, do refer to the Readme.txt for details.
	//
	if((Srb->Function==SRB_FUNCTION_EXECUTE_SCSI) &&
		 ((Srb->Cdb[0]== SCSIOP_READ_CAPACITY)	||
			(Srb->Cdb[0]== SCSIOP_MODE_SENSE)			||
			(Srb->Cdb[0]== SCSIOP_TEST_UNIT_READY)||
			(Srb->Cdb[0]== SCSIOP_RESERVE_UNIT)	  ||
			(Srb->Cdb[0]== SCSIOP_RELEASE_UNIT)))
	{
		goto fire_command;
	}

	//
	// This additional check is introduced for logical drives with
	// stripe size > 64K under larger SGL support by the driver/firmware.
	// This is explained in the <Megaq.h> header file for the function 
	// prototype ProcessPartialTransfer().
	//
	//
	// get the supported SGL count by the driver
	if(DeviceExtension->NumberOfPhysicalBreaks > DEFAULT_SGL_DESCRIPTORS)
	{
		//
		//	driver supports more sgl than the default. This might cause
		//	problems for the logical drives that are configured with the
		//	stripe size > 64K.
		//
		//	get the stripe size of the logical drive
		//
		UCHAR stripeSize;

    if(DeviceExtension->CrashDumpRunning == TRUE)
    {
				//
				//we don't know stripe size is > 64k or not. So split the 
        //command depending on the data transfer length. This flows 
        //through a different path in the callback.
				//
				isSplitRequest = TRUE;
				
				goto fire_command;
    }

		stripeSize = GetLogicalDriveStripeSize(
												DeviceExtension,
												logicalDriveNumber //logicalDriveNumber
												);

		//note : stripeSize == STRIPE_SIZE_UNKNOWN not accounted
		if(stripeSize == STRIPE_SIZE_128K){
				//
				//stripe size > 64k. The request might have to be split
				//depending on the data transfer length. This flows through
				//a different path in the callback.
				//
				isSplitRequest = TRUE;
				
				goto fire_command;
		}
	}
	//
	
	//
	// NT40's ScsiPortGetUncachedExtension() problem:
	// This particular function call allocates the shareable memory for
	// the controller and the cpu. This is where the firmware mail box
	// is maintained. NT40 uses the ConfigInformation structure values
	// for the memory allocation and sets them as is. This causes a 
	// problem for us, if we have to change the MaximumTransferLength &
	// NumberOfPhysicalBreaks values later on. Currently we are setting
	// the values to MAXIMUM_TRANSFER_LENGTH & MAXIMUM_SGL_DESCRIPTORS
	// before the memory allocation call. Irrespective of whatever value
	// we set later on, NT40 retains the values set before the memory
	// allocation. This would cause system crash with the firmware supporting
	// less than the MAXIMUM_SGL_DESCRIPTORS.
	// To avoid this, a check is done for I/O transfer size >
	// MINIMUM_TRANSFER_LENGTH & NumberOfPhysicalBreaks < MAXIMUM_SGL_DESCRIPTORS
	//
	if((DeviceExtension->NumberOfPhysicalBreaks < MAXIMUM_SGL_DESCRIPTORS) &&
		 (Srb->DataTransferLength > 	MINIMUM_TRANSFER_LENGTH)) 
	{
				isSplitRequest = TRUE;
				
				goto fire_command;
	}

	//
	//NOTE : 
	//	Other than SRB_FUNCTION_EXECUTE_SCSI all the 
	//	other commands are not addressed to a specific 
	//	path/target/lun. Either it is for PATH alone 
	//	(SRB_FUNCTION_RESET_BUS) or for nothing at all
	//	(SRB_FUNCTION_IO_CONTROL , SRB_FUNCTION_SHUTDOWN).
	//
	//	In those cases it is assumed that the Srb->TargetId=0
	//	and the request is tried to be queued up for logical
	//	drive 0. Any abnormalities might lead to system crash.
	//	
  if(DeviceExtension->AdapterFlushIssued)
  {
      UCHAR ld;
      for(ld=0; ld <  DeviceExtension->SupportedLogicalDriveCount; ld++)
      {
					FireChainedRequest(
													DeviceExtension,
                          &DeviceExtension->LogDrvCommandArray[ld]);
      }
          goto fire_command;
   }


	if(DeviceExtension->PendCmds)
	{
      ULONG32 lastLogicalBlock;

			logDrv = &DeviceExtension->LogDrvCommandArray[logicalDriveNumber];

			srbExtension = Srb->SrbExtension;
			srbExtension->StartPhysicalBlock = blockAddr;
			srbExtension->NumberOfBlocks = blocks;
			
			//
			//NORTON ANTIVIRUS SENDs command with start block as 0xFFFFFFFF, firmware fails to check 
			//its size validity because if number of blocks added to start block it truncate value
			//

			if((Srb->Function==SRB_FUNCTION_EXECUTE_SCSI) && 
				 ((Srb->Cdb[0] == SCSIOP_READ)|| (Srb->Cdb[0] == SCSIOP_WRITE)))
			{

				if(DeviceExtension->SupportedLogicalDriveCount == MAX_LOGICAL_DRIVES_8)
				{
					lastLogicalBlock = DeviceExtension->NoncachedExtension->MRAIDParams.MRAIDParams8.LogdrvInfo.LDrvSize[logicalDriveNumber];
				}
				else
				{
					lastLogicalBlock = DeviceExtension->NoncachedExtension->MRAIDParams.MRAIDParams40.lDrvSize[logicalDriveNumber];
				}
        
				if((blockAddr > lastLogicalBlock) || ((blockAddr+blocks) > lastLogicalBlock))
        {
					FireChainedRequest(DeviceExtension, logDrv);
					goto fire_command;
				}

			}

			if(!logDrv->NumSrbsQueued)
			{

				if((Srb->Function==SRB_FUNCTION_EXECUTE_SCSI) &&
					 ((Srb->Cdb[0] == SCSIOP_READ)||
					  (Srb->Cdb[0] == SCSIOP_WRITE)))
				{

chain_first_srb:
						
						if(blocks > MAX_BLOCKS){
							
							DebugPrint((0, "\n Sequentiality Break: MAX_BLOCKS > 128"));

							goto fire_command;
						}

            //
            //Estimate number of SGList will generate from this request for Merging
            //
            logDrv->ExpectedPhysicalBreaks = (UCHAR)((Srb->DataTransferLength / MEGARAID_PAGE_SIZE) + 2);
            
            if(logDrv->ExpectedPhysicalBreaks >= DeviceExtension->NumberOfPhysicalBreaks)
							goto fire_command;


						logDrv->LastFunction = Srb->Function;
						logDrv->LastCommand = Srb->Cdb[0];
						logDrv->Opcode = opcode;
						logDrv->StartBlock = 	blockAddr;
						logDrv->LastBlock = blockAddr+blocks;
						logDrv->NumSrbsQueued++;

						logDrv->PreviousQueueLength =1;
						logDrv->CurrentQueueLength  =1;

						//update the head and tail of the srb queue
						logDrv->SrbQueue = Srb;
						logDrv->SrbTail = Srb;

						//
						//set the chain flag
						//
						srbExtension->IsChained = TRUE;
						srbExtension->NextSrb = NULL;

						return TRUE;
				}
				else
				{
						//no srbs in the queue. Current srb cannot be
						//queued. Fire the current srb.
						goto fire_command;
				}
			}
			else
			{
				//
				//queue not empty. Try linking the current srb with
				//the queued srb.
				//
				PSCSI_REQUEST_BLOCK tailSrb = logDrv->SrbTail;
				PSRB_EXTENSION	tailExtension;
        UCHAR expectedBreaks;

				if( (Srb->Function != logDrv->LastFunction) ||
						(Srb->Cdb[0] != logDrv->LastCommand) )
				{

						//doubleFire = TRUE;				
						//goto fire_command;

					//Sequentiality broken..
					//Fire if possible or leave in the chain itself
					//

					FireChainedRequest(
													DeviceExtension,
													logDrv);

					//attempt the current Srb
					goto fire_command;
					
					//return(QUEUE_REQUEST);						
				}

				if( (logDrv->NumSrbsQueued >= MAX_QUEUE_THRESHOLD) ||
					  ((logDrv->LastBlock) != blockAddr) )
				{

							//doubleFire = TRUE;
							//goto fire_command;


					//Sequentiality broken..
					//Fire if possible or leave in the chain itself
					//	
					if(FireChainedRequest(
													DeviceExtension,
													logDrv))
					{
						//
						//previously chained srbs are fired to the F/w.
						//Queue the current Srb for the logical drive.
						//This has the same (Function ,command) as the previously
						//chained ones.The reason it could not get queued is because 
						//of the bound crossing.This can be held for the next
						//sequence of Srbs.
						//On Firing the Chained Srbs, the logDrv is completely 
						//initialized by the called function.
						//
						goto chain_first_srb;
					}

					//
					//The chain of srbs could not get fired.Try the current Srb.
					//
					//attempt the current Srb
					goto fire_command;
						
					//return(QUEUE_REQUEST);						
				}

				if( (logDrv->LastBlock+blocks - logDrv->StartBlock) > MAX_BLOCKS)
				{
							//doubleFire = TRUE;
							//goto fire_command;
					
						
						//Sequentiality broken..
						//Fire if possible or leave in the chain itself
						//	
						if(FireChainedRequest(
													DeviceExtension,
													logDrv))
						{
							//
							//previously chained srbs are fired to the F/w.
							//Queue the current Srb for the logical drive.
							//This has the same (Function ,command) as the previously
							//chained ones.The reason it could not get queued is because 
							//of the bound crossing.This can be held for the next
							//sequence of Srbs.
							//On Firing the Chained Srbs, the logDrv is completely 
							//initialized by the called function.
							//
							goto chain_first_srb;
						}

						//
						//The chain of srbs could not get fired.Try the current Srb.
						//							
						//attempt the current Srb
						goto fire_command;
						
						//return(QUEUE_REQUEST);						
				}

        //
        //Estimate number of SGList will generate from this request for Merging
        //
        expectedBreaks = (UCHAR)((Srb->DataTransferLength / MEGARAID_PAGE_SIZE) + 2);
        
        if((ULONG32)(logDrv->ExpectedPhysicalBreaks +  expectedBreaks) >= DeviceExtension->NumberOfPhysicalBreaks)
        {
						if(FireChainedRequest(
													DeviceExtension,
													logDrv))
						{
							//
							//previously chained srbs are fired to the F/w.
							//Queue the current Srb for the logical drive.
							//This has the same (Function ,command) as the previously
							//chained ones.The reason it could not get queued is because 
							//of the bound crossing.This can be held for the next
							//sequence of Srbs.
							//On Firing the Chained Srbs, the logDrv is completely 
							//initialized by the called function.
							//
							goto chain_first_srb;
						}
        }
        else
        {
          logDrv->ExpectedPhysicalBreaks += expectedBreaks; 
        }

        
        //
				//all validations done. Queue the current SRB with
				//the chained srbs.
				//

				tailExtension = tailSrb->SrbExtension;
				tailExtension->NextSrb = Srb;

				logDrv->SrbTail = Srb;

				//
				//update the last block & number of srbs queued
				//
				logDrv->LastBlock += blocks;
				logDrv->NumSrbsQueued++;

				//update the currentQueueLength
				//
				logDrv->CurrentQueueLength++;

				//
				//set the chain flag
				//
				srbExtension->IsChained = TRUE;
				srbExtension->NextSrb = NULL;

				return(TRUE);
			}
	}//of if (pendCmds)
}
fire_command:

#endif //of COALESE_COMMANDS


	//
	// NEWLY INTRODUCED CHECK
	// If Double firing sequence occurred, PendCmds would have got incremented
	// by 1.
	// Check if the adapter can accept request. Queue the request otherwise.
	//

	//
	// Get the free commandid.
	//

  if(GetFreeCommandID(&commandID, DeviceExtension) == MEGARAID_FAILURE)
  {
			//
			//Queue the current request (SRB)
			//
			return(QUEUE_REQUEST);
  }
	//
	// Save the next free slot in device extension.
	//
	DeviceExtension->FreeSlot = commandID;
	//
	// Increment the number of commands fired.
	//
	DeviceExtension->PendCmds++;
	//
	// Save the request pointer in device extension.
	//
	DeviceExtension->PendSrb[commandID] = Srb;

	//get the control block & clear it
	//
	ClearControlBlock(&DeviceExtension->ActiveIO[commandID]);

	//
	// Check The Call
	//
	if ((Srb->Function == SRB_FUNCTION_EXECUTE_SCSI) && 
		 (Srb->PathId >= DeviceExtension->NumberOfPhysicalChannels) && 
		 (configuredLogicalDrives != 0))
		 //(DeviceExtension->NoncachedExtension->MRAIDParams.LogdrvInfo.NumLDrv))
	{
		switch ( Srb->Cdb[0] )
		{
			case SCSIOP_READ_CAPACITY:
			case SCSIOP_TEST_UNIT_READY:
			case SCSIOP_MODE_SENSE:
					return QueryReservationStatus(DeviceExtension, Srb, commandID);
				break;
		
			default:
				break;
		}       
	}

#ifdef  DELL
	if ((Srb->Cdb[0] == SCSIOP_WRITE          ||
		  Srb->Cdb[0] == SCSIOP_WRITE6          ||
		  Srb->Cdb[0] == SCSIOP_WRITE_VERIFY)   &&
		 (Srb->PathId >= DeviceExtension->NumberOfPhysicalChannels))
	{
			if ( !blockAddr && !DeviceExtension->LogDrvChecked[logicalDriveNumber])
			{
					DeviceExtension->LogDrvChecked[logicalDriveNumber] = 1;
					return IssueReadConfig(DeviceExtension, Srb, commandID);
			}
			else
				DeviceExtension->LogDrvChecked[logicalDriveNumber] = 0;
	}
#endif

	//
	// Fill the request control block.
	//
	controlBlock = &DeviceExtension->ActiveIO[commandID];
	controlBlock->Opcode = opcode;
	controlBlock->VirtualTransferAddress = (PUCHAR)(Srb->DataBuffer);
	controlBlock->BlockAddress = blockAddr;

	if(blocks!=0)
		controlBlock->BytesLeft = blocks*512;
	else
		controlBlock->BytesLeft = Srb->DataTransferLength;

	controlBlock->TotalBlocks = blocks;
	controlBlock->BlocksLeft = blocks;
	controlBlock->TotalBytes = controlBlock->BytesLeft;
	controlBlock->CommandStatus =0;
	controlBlock->IsSplitRequest = isSplitRequest;

	//this is useful only for the split R/W requests.else, just a junk
	controlBlock->LogicalDriveNumber = logicalDriveNumber;

	return ContinueDiskRequest(DeviceExtension, commandID, TRUE);
}


/*********************************************************************
Routine Description:
	Command Completed Successfully with Status

Arguments:
	HwDeviceExtension - HBA miniport driver's adapter data storage
	CommandID				- command id
	Status				- command status

Return Value:
	Disk Request Done
	Dequeue, set status, notify Miniport layer
	Always returns TRUE (slot freed)
**********************************************************************/
BOOLEAN
FireRequestDone(
	IN PHW_DEVICE_EXTENSION DeviceExtension,
	IN UCHAR CommandID,
	IN UCHAR Status
	)
{
	PSCSI_REQUEST_BLOCK   srb = DeviceExtension->PendSrb[CommandID];
	
  srb->SrbStatus = Status;
	DeviceExtension->PendSrb[CommandID] = NULL;
	DeviceExtension->FreeSlot = CommandID;
	DeviceExtension->PendCmds--;

  if(srb->SrbFlags & SRB_FLAGS_QUEUE_ACTION_ENABLE)
  {
	  ScsiPortNotification(RequestComplete, (PVOID)DeviceExtension, srb);
  }
  else
  {
    ScsiPortNotification(NextRequest, DeviceExtension, NULL);
    ScsiPortNotification(RequestComplete, (PVOID)DeviceExtension, srb);
  }
  return(TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\port\scsi\miniport\megaraid\mailbox.h ===
/*******************************************************************/
/*                                                                 */
/* NAME             = MAILBOX.h                                    */
/* FUNCTION         = Header file for Mailbox structure;           */
/* NOTES            =                                              */
/* DATE             = 02-03-2000                                   */
/* HISTORY          = 001, 02-03-00, Parag Ranjan Maharana;        */
/* COPYRIGHT        = LSI Logic Corporation. All rights reserved;  */
/*                                                                 */
/*******************************************************************/
#ifndef _INCLUDE_MAIL_BOX
#define _INCLUDE_MAIL_BOX
//
//set the packing level to 1
#pragma pack( push,mailbox_pack,1 )

//The firmware can report status for upto 46 command ids.
#define MAX_STATUS_ACKNOWLEDGE	46 
	
typedef struct _MAILBOX_STATUS{

	UCHAR		NumberOfCompletedCommands;
	UCHAR		CommandStatus;
	UCHAR		CompletedCommandIdList[MAX_STATUS_ACKNOWLEDGE];

}MAILBOX_STATUS, *PMAILBOX_STATUS;

typedef struct _MAILBOX_READ_WRITE{
	
	USHORT	NumberOfBlocks;	 	
	ULONG32		StartBlockAddress;
	ULONG32		DataTransferAddress;//10	
	UCHAR		LogicalDriveNumber;
	UCHAR		NumberOfSgElements;
	UCHAR		Reserved; //13	
}MAILBOX_READ_WRITE, *PMAILBOX_READ_WRITE;

//
//MegaIO Command: The MegaIO commands are adapter specific commands
//which are used for handshake of the Host and firmware. The Mailbox
//definition for the MegaIo commands is command group specific.
//They are of 3 categories:
// (1)Adapter Specific cmds (2) Logical Drive cmds (3) Physical Drive cmds
//

//
//COmmands using the below given mailbox structure
/*		
			Megaraid Inquiry			0x05
			Read Config						0x07
			FlushAdapter					0x0A
			Write Config					0x20
			Get Rebuild Rate			0x23
			Set Rebuild Rate			0x24
			Set Flush Interval		0x2E
			Set Spinup Parameters	0x33
			Get Spinup Parameters	0x32			
*/
typedef struct _MAILBOX_MEGAIO_ADAPTER{

	UCHAR		Channel;
	UCHAR		Reserved1[5];//6
	ULONG32		DataTransferAddress;
	UCHAR		Reserved2[3];//13	
}MAILBOX_MEGAIO_ADAPTER, *PMAILBOX_MEGAIO_ADAPTER;

//
//COmmands using the below given mailbox structure
/*
			Check Consistency						0x09
			Initialize Logical Drive		0x0B
			Get Initialize Progress			0x1B
			Check Consistency Progress	0x19
			Update Write Policy					0x26
			Abort Initialize						0x2B
			Abort Check Consistency			0x29
*/
typedef struct _MAILBOX_MEGAIO_LDRV{

	UCHAR		LogicalDriveNumber;
	UCHAR		SubCommand;
	UCHAR		Reserved1[4];//6
	ULONG32		DataTransferAddress;
	UCHAR		Reserved2[3];//13	
}MAILBOX_MEGAIO_LDRV, *PMAILBOX_MEGAIO_LDRV;

//
//COmmands using the below given mailbox structure
/*
			Change State						0x06
			Rebuild Physical Drive	0x08
			Get Rebuild Progress		0x18
			Abort Rebuild						0x28

			Start Unit									0x75
			Stop Unit										0x76
			Get Error Counters					0x77
			Get Boot time drive status	0x78
*/
typedef struct _MAILBOX_MEGAIO_PDRV{
	
	UCHAR		Channel;
	UCHAR		Parameter;
	UCHAR		CommandSpecific;
	UCHAR		Reserved1[3];//6
	ULONG32		DataTransferAddress;
	UCHAR		Reserved2[3];//13	
}MAILBOX_MEGAIO_PDRV, *PMAILBOX_MEGAIO_PDRV;

typedef struct _MAILBOX_PASS_THROUGH{
	
	UCHAR		Reserved1[6];//6
	ULONG32		DataTransferAddress; //address of the direct CDB
	UCHAR		CommandSpecific;
	UCHAR		Reserved2[2];//13	
}MAILBOX_PASS_THROUGH, *PMAILBOX_PASS_THROUGH;

typedef struct _MAILBOX_FLAT_1{

	UCHAR		Parameter[13];
}MAILBOX_FLAT_1, *PMAILBOX_FLAT_1;

typedef struct _MAILBOX_FLAT_2{

	UCHAR		Parameter[6];
	ULONG32		DataTransferAddress;
	UCHAR		Reserved1[3];
}MAILBOX_FLAT_2, *PMAILBOX_FLAT_2;

typedef struct _MAILBOX_NEW_CONFIG
{
	UCHAR SubCommand; 
	UCHAR NumberOfSgElements;
	UCHAR Reserved0[4];
	ULONG32 DataTransferAddress;
	UCHAR Reserved1[3];

}MAILBOX_NEW_CONFIG, *PMAILBOX_NEW_CONFIG;

//
//EXTENDED MAILBOX IS NOW PART OF MAILBOX ITSELF TO PROCTECT IT FROM CORRUPTION
//REF : MS BUG 591773
//

//Extended MAILBOX for 64 bit addressing
typedef struct _EXTENDED_MBOX
{
  unsigned __int32  LowAddress;  /*Changed according to FW+ members request*/
  unsigned __int32  HighAddress;
}EXTENDED_MBOX, *PEXTENDED_MBOX;


typedef struct _FW_MBOX
{
  EXTENDED_MBOX           ExtendedMBox;

	UCHAR		Command;
	UCHAR		CommandId;

	union{
		MAILBOX_READ_WRITE			ReadWrite;
		MAILBOX_MEGAIO_ADAPTER	MegaIoAdapter;
		MAILBOX_MEGAIO_LDRV			MegaIoLdrv;
		MAILBOX_MEGAIO_PDRV			MegaIoPdrv;
		MAILBOX_PASS_THROUGH		PassThrough;
		MAILBOX_FLAT_1					Flat1;
		MAILBOX_FLAT_2					Flat2;
    MAILBOX_NEW_CONFIG      NewConfig;
	}u; //13 bytes
	
	UCHAR		MailBoxBusyFlag; //16

	MAILBOX_STATUS Status;	//48 bytes 
}FW_MBOX, *PFW_MBOX;//64 bytes

typedef struct _IOCONTROL_MAIL_BOX
{
	UCHAR	IoctlCommand;
	UCHAR IoctlSignatureOrStatus;
	UCHAR CommandSpecific[6];

}IOCONTROL_MAIL_BOX, *PIOCONTROL_MAIL_BOX;

//
//reset the packing level to whatever it was before
#pragma pack( pop,mailbox_pack,1 )

#endif // end of _INCLUDE_MAIL_BOX
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\port\scsi\miniport\megaraid\megaenquiry.c ===
/*******************************************************************/
/*                                                                 */
/* NAME             = MegaEnquiry.C                                */
/* FUNCTION         = Enquiry and Ext Enquiry Implementation;      */
/* NOTES            =                                              */
/* DATE             = 02-03-2000                                   */
/* HISTORY          = 001, 02-03-00, Parag Ranjan Maharana;        */
/*                    002, 03-09-01, Parag Ranjan Maharana         */
/*                         Command Merging was failing due to over */
/*                         computation of scatter gather list;     */
/* COPYRIGHT        = LSI Logic Corporation. All rights reserved;  */
/*                                                                 */
/*******************************************************************/

#include "includes.h"

BOOLEAN
FireChainedRequest(
				PHW_DEVICE_EXTENSION	DeviceExtension,
				PLOGDRV_COMMAND_ARRAY LogDrv 
				)
{
	UCHAR       commandID;
	FW_MBOX	    mailBox;
	PREQ_PARAMS controlBlock;	
  UCHAR       opcode;


	
  do
  {
    if(!LogDrv)
    {
			  return(FALSE);
	  }
    //
    //Fixed for Whistler DataCenter Server
    //This condition will hit if coalese commands exceds number of scatter & gather count
    //
    if(DeviceExtension->SplitAccessed)
    {
      DeviceExtension->SplitAccessed = FALSE;
  
      ScsiPortMoveMemory(LogDrv, &DeviceExtension->SplitCommandArray, sizeof(LOGDRV_COMMAND_ARRAY));

    }

    if(LogDrv->SrbQueue == NULL)
    {
			  return (FALSE);
	  }

	  //
	  // Get the free commandid for the Chained SRB (SECOND FIRE)
	  //
	  commandID = DeviceExtension->FreeSlot;
	  
	  if(GetFreeCommandID(&commandID, DeviceExtension) == MEGARAID_FAILURE)
    {
		  return (FALSE);
	  }
    
	  //
	  // Increment the number of commands fired.
	  //
	  DeviceExtension->PendCmds++;	

	  //
	  // Save the queue head in device extension.
	  //
	  DeviceExtension->PendSrb[commandID] = LogDrv->SrbQueue;
		  
	  //
	  // Fill the request control block.
	  //
	  controlBlock = &DeviceExtension->ActiveIO[commandID];


    opcode = LogDrv->Opcode;

    //If 64 bit access is ON send READ64 for READ cmd and WRITE64 for write cmd
    if(DeviceExtension->LargeMemoryAccess)
    {
      if(LogDrv->Opcode == MRAID_LOGICAL_READ)
        opcode = MRAID_READ_LARGE_MEMORY;
      else if(LogDrv->Opcode == MRAID_LOGICAL_WRITE)
        opcode = MRAID_WRITE_LARGE_MEMORY;
    }
  
    //Initialize MAILBOX
    MegaRAIDZeroMemory(&mailBox, sizeof(FW_MBOX));
  
    //
	  //Build Sgl for the chained srbs
	  //

	  BuildSglForChainedSrbs(LogDrv, DeviceExtension, &mailBox, commandID, opcode);


	  //
	  //send the command to the firmware
	  if(SendMBoxToFirmware(DeviceExtension, DeviceExtension->PciPortStart, &mailBox) == TRUE)
    {
	    //
	    //initialize everything to NULL
	    //
	    ClearControlBlock(controlBlock);
      //
	    //Reset the LogDrv structure
	    //
	    LogDrv->LastFunction = 0;
	    LogDrv->LastCommand = 0;
	    LogDrv->StartBlock = 	0;
	    LogDrv->LastBlock = 0;
	    LogDrv->Opcode =0;
	    LogDrv->NumSrbsQueued=0;							
	    LogDrv->SrbQueue = NULL;
	    LogDrv->SrbTail = NULL;
	    
	    LogDrv->PreviousQueueLength =0;
	    LogDrv->CurrentQueueLength =0;
	    LogDrv->QueueLengthConstancyPeriod =0;
	    LogDrv->CheckPeriod =0;
    }
    else //On Error Condition
    {
		  PSCSI_REQUEST_BLOCK		queueHead;

		  PSRB_EXTENSION				srbExtension = NULL;

      //
	    // Decrement the number of commands fired.
	    //
	    DeviceExtension->PendCmds--;	

	    //
	    // Save the queue head in device extension.
	    //
      queueHead = DeviceExtension->PendSrb[commandID];

	    DeviceExtension->PendSrb[commandID] = NULL;

      if(DeviceExtension->SplitAccessed)
      {
        DeviceExtension->SplitAccessed = FALSE;
        LogDrv->NumSrbsQueued = 0;

        LogDrv->PreviousQueueLength = 1;
			  LogDrv->CurrentQueueLength  = 0;

        LogDrv->StartBlock = 	GetM32(&queueHead->Cdb[2]);
			  LogDrv->LastBlock = GetM32(&queueHead->Cdb[2]);
	      LogDrv->SrbQueue = queueHead;
	      LogDrv->SrbTail = queueHead;

        while(queueHead)
        {
          LogDrv->LastBlock += (ULONG32)GetM16(&queueHead->Cdb[7]);
          LogDrv->NumSrbsQueued++;
          LogDrv->CurrentQueueLength++;
        
          LogDrv->SrbTail = queueHead;

          srbExtension = queueHead->SrbExtension;

          queueHead = srbExtension->NextSrb;
        }

        queueHead = DeviceExtension->SplitCommandArray.SrbQueue;
        if(queueHead && srbExtension)
        {
          //
					//Last Srb in SRB queue
					//
					srbExtension->NextSrb = queueHead;

          while(queueHead)
          {
            LogDrv->LastBlock += (ULONG32)GetM16(&queueHead->Cdb[7]);
            LogDrv->NumSrbsQueued++;
            LogDrv->CurrentQueueLength++;
        
            LogDrv->SrbTail = queueHead;
    
            srbExtension = queueHead->SrbExtension;
            queueHead = srbExtension->NextSrb;
          }
        }
      }
      return FALSE;
    }
  }while(DeviceExtension->SplitAccessed);

	
	return(TRUE);
}//of FireDoubleRequest()

BOOLEAN
BuildSglForChainedSrbs(
					PLOGDRV_COMMAND_ARRAY	LogDrv,
					PHW_DEVICE_EXTENSION		DeviceExtension,
					PFW_MBOX		MailBox,
					UCHAR  CommandId,
					UCHAR	 Opcode)
{
		PSCSI_REQUEST_BLOCK		workingNode;
		PSCSI_REQUEST_BLOCK		queueHead;

		PSRB_EXTENSION				srbExtension;
		PSGL32		            sgPtr;

		ULONG32	scatterGatherDescriptorCount = 0;
		ULONG32	physicalBufferAddress;

		ULONG32	physicalBlockAddress=0;
		ULONG32 numberOfBlocks=0;
		ULONG32	totalBlocks = 0;
		ULONG32	length=0;
		ULONG32 totalPackets=0;
    BOOLEAN sgl32Type = TRUE;
		PSCSI_REQUEST_BLOCK		splitQueueHead = NULL;
    LOGDRV_COMMAND_ARRAY	localLogDrv;

		
RecomputeScatterGatherAgain:
    //
		//get the head of the queue
		//
		queueHead = LogDrv->SrbQueue;
		workingNode = LogDrv->SrbQueue;
		
		if(!workingNode)
		{
			return (FALSE);
		}

		srbExtension = workingNode->SrbExtension;
		sgPtr = (PSGL32)&srbExtension->SglType.SG32List;

    sgl32Type = (BOOLEAN)(DeviceExtension->LargeMemoryAccess == TRUE) ? FALSE : TRUE;


		while(workingNode)
		{
			srbExtension   = workingNode->SrbExtension;

			physicalBlockAddress = srbExtension->StartPhysicalBlock;
			numberOfBlocks       = srbExtension->NumberOfBlocks;


	    if(BuildScatterGatherListEx(DeviceExtension,
                                  workingNode,
			                            workingNode->DataBuffer,
                                  numberOfBlocks * MRAID_SECTOR_SIZE, //bytesTobeTransferred,
                                  sgl32Type, //It may be 32 sgl or 64 sgl depending on Physical Memory
                                  (PVOID)sgPtr,
			                            &scatterGatherDescriptorCount) != MEGARAID_SUCCESS) 
      
      
			{
				break;
			}

			totalBlocks	+= numberOfBlocks;
			totalPackets++;

			workingNode = srbExtension->NextSrb;
		}//of while

    //
    //Fixed for Whistler Data Center Server
    //Data Corruption HCT10  9th March 2001
    //This condition will hit if coalese commands exceeds number of scatter & gather count
    //Scatter Gather Count need recomputation
    //
    if(LogDrv->NumSrbsQueued != totalPackets)
    {

      DebugPrint((0, "\nMRAID35x Recomputing ScatterGather due to break Srbs<%d %d>", LogDrv->NumSrbsQueued, totalPackets));
     
      //
      //When number of SGList is more than supported.
      //Current SRB in chain of SRBs will be split to form a another chain
      //where current SRB is the Head SRB for new chain
      //
      splitQueueHead = workingNode;
      
      workingNode = queueHead;
      
      //
      //Compute again how many SRB will be present in Old Chain 
      //as new chained SRB will be exclude from this list
      //
      LogDrv->NumSrbsQueued = 0;
      
      //
      //Compute all again all parameters for Old Chain
      //
      while(workingNode)
      {
        LogDrv->NumSrbsQueued++;
        srbExtension = workingNode->SrbExtension;
        workingNode = srbExtension->NextSrb;
        if(srbExtension->NextSrb == splitQueueHead)
        {
          srbExtension->NextSrb = NULL;
          totalBlocks = 0;
          scatterGatherDescriptorCount = 0;
          totalPackets = 0;
          break;
        }
      }

      MegaRAIDZeroMemory(&localLogDrv, sizeof(LOGDRV_COMMAND_ARRAY));

      //
      //Compute all the parameters for new chain of SRBs
      //
      workingNode = splitQueueHead;

      localLogDrv.SrbQueue = splitQueueHead;
      localLogDrv.SrbTail = splitQueueHead;


      localLogDrv.LastFunction = splitQueueHead->Function;
			localLogDrv.LastCommand = splitQueueHead->Cdb[0];
			localLogDrv.Opcode = LogDrv->Opcode;

			localLogDrv.StartBlock = 	GetM32(&splitQueueHead->Cdb[2]);
			localLogDrv.LastBlock = GetM32(&splitQueueHead->Cdb[2]);
			localLogDrv.NumSrbsQueued = 0;


			localLogDrv.PreviousQueueLength =1;
			localLogDrv.CurrentQueueLength  =0;


      while(workingNode)
      {
        localLogDrv.SrbTail = workingNode;
        localLogDrv.LastBlock += (ULONG32)GetM16(&workingNode->Cdb[7]);
        localLogDrv.CurrentQueueLength++;
        localLogDrv.NumSrbsQueued++;
        srbExtension = workingNode->SrbExtension;
        workingNode = srbExtension->NextSrb;
      }
      DebugPrint((3, "\nMRAID35x Number of commands Split1 %d Split2 %d", LogDrv->NumSrbsQueued, localLogDrv.NumSrbsQueued));

      DeviceExtension->SplitAccessed = TRUE;
  
      ScsiPortMoveMemory(&DeviceExtension->SplitCommandArray, &localLogDrv, sizeof(LOGDRV_COMMAND_ARRAY));

      goto RecomputeScatterGatherAgain;
    }


		//DebugPrint((0, "\nTotalQueuedPackets=%d",LogDrv->NumSrbsQueued);
		//DebugPrint((0, "\n Command ID %02X TotalPackets(Sent)=%d TotalBlocks(Sent)=%d SGCount(Sent)=%d ", CommandId,
		//						totalPackets,totalBlocks,scatterGatherDescriptorCount);

    
		if((scatterGatherDescriptorCount == 1) && 
      (DeviceExtension->LargeMemoryAccess == FALSE))
		{
			//buffer is not scattered.
			//
			physicalBufferAddress = sgPtr->Descriptor[0].Address;

			//if descriptorCount =1, effectively there is no scatter gather.
			//so return the count as 0,because the physical address used
			//is the exact address of the data buffer itself.
			//
			scatterGatherDescriptorCount--;

		}
		else
		{
		
      //As SGL32 and SGL64 are union, they have same memory so we can 
      //send any one address.
			//buffer is scattered. return the physcial address of the
			//scatter/gather list
			//
			physicalBufferAddress = MegaRAIDGetPhysicalAddressAsUlong(DeviceExtension, 
																	                              NULL,
																	                              sgPtr, 
																	                              &length);
		}

		//
		//sgl built. construct mail box
		//
    MailBox->Command = Opcode;
		MailBox->CommandId = CommandId;

		MailBox->u.ReadWrite.NumberOfSgElements = (UCHAR)scatterGatherDescriptorCount;
		MailBox->u.ReadWrite.DataTransferAddress = physicalBufferAddress;
		
		MailBox->u.ReadWrite.NumberOfBlocks = (USHORT)totalBlocks;
		MailBox->u.ReadWrite.StartBlockAddress = LogDrv->StartBlock;
		MailBox->u.ReadWrite.LogicalDriveNumber = 
				GetLogicalDriveNumber(DeviceExtension, queueHead->PathId, queueHead->TargetId, queueHead->Lun);

		//DebugPrint((0, "\r\n OUT BuildSglForChain()");

		return (TRUE);
}//of BuildSglForChainedSrbs()

void
PostChainedSrbs(
				PHW_DEVICE_EXTENSION DeviceExtension,
				PSCSI_REQUEST_BLOCK		Srb, 
				UCHAR		Status)
{
	PSCSI_REQUEST_BLOCK	currentSrb = Srb;
	PSCSI_REQUEST_BLOCK	prevSrb = Srb;
	PSRB_EXTENSION currentExt, prevExt;
	
	ULONG32 blocks;
	ULONG32 blockAddr;
  UCHAR srbCount = 0;

	while(currentSrb)
	{
		prevSrb = currentSrb;
    ++srbCount;

		blocks = (ULONG32)GetM16(&prevSrb->Cdb[7]);
		blockAddr = GetM32(&prevSrb->Cdb[2]);

		/*
		DebugPrint((0, "\r\n(POST CHAIN)LD:%d Command:%02x  Start:%0x  Num:%0x",
									prevSrb->TargetId, prevSrb->Cdb[0],
									blockAddr, blocks);
		*/

		if(!Status)
		{
				prevSrb->ScsiStatus = SCSISTAT_GOOD;
				prevSrb->SrbStatus = SRB_STATUS_SUCCESS;
		}
		else
		{
				prevSrb->ScsiStatus = Status;
				prevSrb->SrbStatus  = SRB_STATUS_ERROR;
		}		

		currentExt = currentSrb->SrbExtension;
		currentSrb = currentExt->NextSrb;
	
		prevExt = prevSrb->SrbExtension;
		prevExt->NextSrb = NULL;

		ScsiPortNotification(
				RequestComplete,
				(PVOID)DeviceExtension, prevSrb);
	}
  //DebugPrint((0, "\nNumber of Chained SRB posted = %d", srbCount);
}//of PostChainedSrbs()


//++
//
//Function Name : ProcessPartialTransfer
//Routine Description:
//		The ControlBlock structure indexed by CommandId is refferred and
//		the partial transfer details are taken. The control block holds 
//		the details of the next starting block, bytes left to be transferred
//		etc.
//		The input Srb is the original Srb from NTOS.For this only, the 
//		request is sent to f/w multiple times.
//		For the next possible data segment the Scatter / gather list is
//		built and the command is given to the f/w.
//
//Input Arguments:
//		Pointer To controller Device Extension
//		Firmware used CommandId
//		Scsi request block
//Returns
//	0 - for success
//	1 - on error conditions				
//
//--
ULONG32
ProcessPartialTransfer(
					PHW_DEVICE_EXTENSION	DeviceExtension, 
					UCHAR									CommandId, 
					PSCSI_REQUEST_BLOCK		Srb,
					PFW_MBOX							MailBox
					)
{
	PSGL32		sgPtr;

	PSRB_EXTENSION		srbExtension;

	ULONG32		bytesTobeTransferred;
	ULONG32		blocksTobeTransferred;
	ULONG32		scatterGatherDescriptorCount;
	ULONG32		srbDataBufferByteOffset;
	ULONG32		physicalBufferAddress;
	ULONG32		length;
	ULONG32		startBlock;
  BOOLEAN sgl32Type = TRUE;

	//
	//get the control block
	PREQ_PARAMS controlBlock = &DeviceExtension->ActiveIO[CommandId];

	//
	// Get the address offset of the Buffer for the next transfer.
	//
	srbDataBufferByteOffset = 
								(controlBlock->TotalBytes - controlBlock->BytesLeft);

	//
	//Request needs to be split because of SCSI limitation.
	//Any request > 100k needs to be broken for logical drives
  //with stripe size > 64K.This is because our SCSI scripts
	//can transfer only 100k maximum in a single command to the
	//drive.
	bytesTobeTransferred = DEFAULT_SGL_DESCRIPTORS * FOUR_KB;
					
	if(controlBlock->BytesLeft > bytesTobeTransferred){
						
			//
			//update the bytes to be transferred in the next cycle
			//
			controlBlock->BytesLeft = 
						controlBlock->BytesLeft- bytesTobeTransferred;
	}
	else{
		
		//
		//set the  value from the control block as the transfer
		//is within the allowed bounds.
		//
		bytesTobeTransferred = controlBlock->BytesLeft;
						
		//
		//nothing remaining to be transferred
		//
		controlBlock->IsSplitRequest = FALSE;
		controlBlock->BytesLeft = 0;
  }						

	//
	//do house keeping operations
	blocksTobeTransferred = bytesTobeTransferred / 512;
	startBlock = controlBlock->BlockAddress +
									(controlBlock->TotalBlocks - controlBlock->BlocksLeft);

	controlBlock->BlocksLeft -= blocksTobeTransferred;


	//
	//build the scatter gather list
	//
	srbExtension = Srb->SrbExtension;
	sgPtr = (PSGL32)&srbExtension->SglType.SG32List;
	scatterGatherDescriptorCount =0;
  sgl32Type = (BOOLEAN)(DeviceExtension->LargeMemoryAccess == TRUE) ? FALSE : TRUE;

	if(BuildScatterGatherListEx(DeviceExtension,
                              Srb,
			                        (PUCHAR)Srb->DataBuffer+srbDataBufferByteOffset,
                              bytesTobeTransferred,
                              sgl32Type, //It may be 32 sgl or 64 sgl depending on Physical Memory
                              (PVOID)sgPtr,
			                        &scatterGatherDescriptorCount) != MEGARAID_SUCCESS) 
	{
		return(1L); // in the future some error code !=0
	}

	if((scatterGatherDescriptorCount == 1)
     && (DeviceExtension->LargeMemoryAccess == FALSE))
	{
			//buffer is not scattered.
			//
			physicalBufferAddress = sgPtr->Descriptor[0].Address;

			//if descriptorCount =1, effectively there is no scatter gather.
			//so return the count as 0,because the physical address used
			//is the exact address of the data buffer itself.
			//
			scatterGatherDescriptorCount--;

	}
	else
	{
			//
			//buffer is scattered. return the physcial address of the
			//scatter/gather list
			//
			physicalBufferAddress = MegaRAIDGetPhysicalAddressAsUlong(DeviceExtension, 
																	                              NULL,
																	                              sgPtr, 
																	                              &length);
	}

	//
	//sgl built. construct mail box
	//
	MailBox->Command = controlBlock->Opcode;
	MailBox->CommandId = CommandId;

  MailBox->u.ReadWrite.NumberOfSgElements = (UCHAR)scatterGatherDescriptorCount;
	MailBox->u.ReadWrite.DataTransferAddress = physicalBufferAddress;
		
	MailBox->u.ReadWrite.NumberOfBlocks= (USHORT)blocksTobeTransferred;
	MailBox->u.ReadWrite.StartBlockAddress = startBlock;
	MailBox->u.ReadWrite.LogicalDriveNumber = controlBlock->LogicalDriveNumber;

	return(0L); // in the future some code which means success
}//of ProcessPartialTransfer()

void
ClearControlBlock(PREQ_PARAMS ControlBlock)
{
			ControlBlock->TotalBytes =0;
	    ControlBlock->BytesLeft	 =0;
			ControlBlock->TotalBlocks=0;
			ControlBlock->BlocksLeft=0;

	    ControlBlock->BlockAddress=0;
	    ControlBlock->VirtualTransferAddress=NULL;	
	    ControlBlock->Opcode=0;
	    ControlBlock->CommandStatus=0;

			ControlBlock->LogicalDriveNumber=0;
			ControlBlock->IsSplitRequest=0;
}//of ClearControlBlock
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\port\scsi\miniport\megaraid\megaraid.h ===
/*******************************************************************/
/*                                                                 */
/* NAME             = MegaRAID.h                                   */
/* FUNCTION         = Main Header file for MegaRAID;               */
/* NOTES            =                                              */
/* DATE             = 02-03-2000                                   */
/* HISTORY          = 001, 02-03-00, Parag Ranjan Maharana;        */
/* COPYRIGHT        = LSI Logic Corporation. All rights reserved;  */
/*                                                                 */
/*******************************************************************/
#ifndef _INCLUDE_MEGARAID
#define _INCLUDE_MEGARAID

#include "MailBox.h"

#define DEFAULT_TIMEOUT                          (60) //seconds
#define SIXITY_SECONDS_TIMEOUT                  DEFAULT_TIMEOUT 
#define THIRTY_SECONDS_TIMEOUT                  (30) //seconds
#define FIFTEEN_SECONDS_TIMEOUT                 (15) //seconds


#define RESERVE_UNIT                            0x1
#define RELEASE_UNIT                            0x2
#define RESET_BUS                               0x3
#define QUESTION_RESERVATION                    0x4
#define MRAID_RESERVATION_CHECK                 0x12
#define LOGDRV_RESERVATION_FAILED               0x03
#define LOGDRV_RESERVATION_FAILED_NEW           0x05
#define SCSI_STATUS_RESERVATION_CONFLICT        0x18


#define DEDICATED_LOGICAL_DRIVES                0x14

#ifdef  DELL

#define MRAID_WRITE_BLOCK0_COMMAND         0x11

#endif

#define CONC_CMDS               0x7e
#define DEDICATED_ID            0x7F

//
//428 controller register addresses
//
#define INT_ENABLE              0x01
#define PCI_INT                 0x0a

//
//RP & NONRP CONTROLLER REGISTER ADDRESSES
//
#define INBOUND_DOORBELL_REG         0x20
#define OUTBOUND_DOORBELL_REG        0x2C



//#define MRAID_EXTENSION_SIZE    226     
#define MRAID_VENDOR_ID         0x101e
#define MRAID_VENDOR_ID_RP      0x8086
#define MRAID_DEVICE_9010       0x9010
#define MRAID_DEVICE_9060       0x9060
#define MRAID_DEVICE_ID_RP      0x1960


//
// The MRAID Opcode codes
//
#define MRAID_WRITE_CONFIG          0x20
#define MRAID_EXT_WRITE_CONFIG      0x68

#define MRAID_READ_CONFIG            0x07
#define MRAID_EXT_READ_CONFIG        0x67

#define MRAID_LOGICAL_READ          0x01
#define MRAID_LOGICAL_WRITE          0x02
#define MRAID_DEVICE_PARAMS          0x05
#define MRAID_ADAPTER_FLUSH          0x0a
#define MEGA_SRB                    0x03
#define MEGA_IO_CONTROL             0x99
#define MRAID_FIND_INITIATORID      0x7D
#define DRIVER_IDENTIFICATION   

#define MRAID_RESERVE_RELEASE_RESET 0x6E
#define RESERVE_RELEASE_DRIVER_ID   0x81

#define REQUEST_DONE                        3
#define QUEUE_REQUEST                       4
#define MRAID_CONFIGURE_HOT_SPARE           6
#define MRAID_CONFIGURE_DEVICE              6
#define MRAID_STATISTICS                    0xc3
#define MRAID_BASEPORT                      0xc5
#define MRAID_READ_FIRST_SECTOR             0xce
#define MRAID_DRIVER_DATA                   0x81
#define APPLICATION_MAILBOX_SIZE            0x08

#define  MRAID_GET_LDRIVE_INFO     0x82
//#define MRAID_READ_CONFIG_NEW      0x83  
//#define MRAID_WRITE_CONFIG_NEW    0x84  

#define MRAID_DISABLE_INTERRUPTS  0
#define MRAID_ENABLE_INTERRUPTS   0xC0

#define MRAID_DGR_BITMAP          0x56
#define SCSI_INQUIRY              0x12

//#define MAXCHANNEL          5
#define DATA_OFFSET          100

#define TIMEOUT_6_SEC           0
#define TIMEOUT_60_SEC          1
#define  TIMEOUT_10M             2
#define TIMEOUT_3_HOURS         3

#define MAX_SENSE                  0x20
#define MEGA_PASSTHRU_MAX_CDB     0x0a    
#define MEGA_PASSTHRU_MAX_SENSE   0x20

#define MRAID_RP_INTERRUPT_SIGNATURE  0x10001234
#define MRAID_NONRP_INTERRUPT_MASK    0x40
#define MRAID_RX_INTERRUPT_SIGNATURE  0x0001

#define MRAID_RP_INTERRUPT_ACK        0x2
#define MRAID_NONRP_INTERRUPT_ACK     0x8
#define MRAID_RX_INTERRUPT_ACK        0x100

//Type of Board
#define MRAID_NONRP_BOARD       0x0
#define MRAID_RP_BOARD          0x1



#define MRAID_INVALID_COMMAND_ID      0xFF


#define SCSI_STATUS_RESERVATION_FAILED 0x18

#define MRAID_DEFAULT_MAX_PHYSICAL_CHANNEL 4


#define MRAID_RP_BOARD_SIGNATURE_OFFSET     0xA0
#define MRAID_RP_BOARD_SIGNATURE            0x3344
#define MRAID_RP_BOARD_SIGNATURE2           0xCCCC
#define MRAID_PAE_SUPPORT_SIGNATURE_OFFSET  0xA4
#define MRAID_PAE_SUPPORT_SIGNATURE_LHC     0x00000299   //64 bit addressing with SGL Low-High-Count format
#define MRAID_PAE_SUPPORT_SIGNATURE_HLC     0x00000199   //64 bit addressing with SGL High-Low-Count format
 
#define PCI_CONFIG_LENGTH_TO_READ           (168)

#define MIN(a,b)        (a) < (b) ? (a):(b)

//
//structure definitions
//
typedef  struct _SRB_IO_CONTROL{

  ULONG32 HeaderLength;
  UCHAR Signature[8];
  ULONG32 Timeout;
  ULONG32 ControlCode;
  ULONG32 ReturnCode;
  ULONG32 Length;
} SRB_IO_CONTROL, * PSRB_IO_CONTROL;

typedef struct{
  
  SRB_IO_CONTROL srbioctl;
  UCHAR DataBuf[512];
}PASS_THROUGH_STRUCT,  *PPT;


#ifdef TOSHIBA_SFR
  //
  // SFR Function Export Structure
  //
  typedef VOID (*PHW_SFR_IF)(IN PVOID HwDeviceExtension);
  typedef VOID (*PHW_SFR_IF_VOID)(IN ULONG32 timeOut);
  
  typedef struct _MRAID_SFR_DATA_BUFFER
  {
    PHW_SFR_IF_VOID FunctionA;
    PHW_SFR_IF      FunctionB;
    PVOID                   HwDeviceExtension;
  } MRAID_SFR_DATA_BUFFER, *PMRAID_SFR_DATA_BUFFER;

  #define MRAID_SFR_IOCTL   0xc4
#endif

//
// Context structure for board scanning
//
typedef struct {

  ULONG32   DeviceNumber;
  ULONG32   AdapterCount;
  ULONG32   BusNumber;
} SCANCONTEXT, *PSCANCONTEXT;




#pragma pack(1)
typedef struct {

  UCHAR   TimeOut:3;    /*  LUN + ARS + TO */  
  UCHAR   Ars:1;
  UCHAR   Dummy:3;

  UCHAR   IsLogical:1;
  UCHAR   Lun;
  UCHAR   Channel;
  UCHAR   ScsiId;
  UCHAR   QueueTag;
  UCHAR   QueueAction; // simple/ordered/head. SCSI-II Specs

  UCHAR   Cdb[10];
  UCHAR   CdbLength;    /* length of cdb */
  UCHAR   RequestSenseLength;  
  UCHAR   RequestSenseArea[32];
  UCHAR   NOSGElements;  /* Number of SG elements */
  UCHAR   status;

  ULONG32   pointer; 
  ULONG32    data_xfer_length ;
} DIRECT_CDB, *PDIRECT_CDB;


//
// Request Control Block (SRB Extension)
// All information required to break down and execute
// a disk request is stored here
//
/*
typedef struct _REQ_PARAMS {

    PUCHAR          VirtualTransferAddress;
    ULONG32           BlockAddress;
    ULONG32           BytesLeft;
    UCHAR           Opcode;
    UCHAR           CommandStatus;
} REQ_PARAMS, *PREQ_PARAMS;
*/

typedef struct _REQ_PARAMS {

  ULONG32      TotalBytes;
  ULONG32     BytesLeft;
  ULONG32      TotalBlocks;
  ULONG32      BlocksLeft;
  ULONG32     BlockAddress;
  PUCHAR      VirtualTransferAddress;  
  UCHAR       Opcode;
  UCHAR       CommandStatus;
  UCHAR        LogicalDriveNumber;
  BOOLEAN      IsSplitRequest;

} REQ_PARAMS, *PREQ_PARAMS;



//
// SCSI Opcode Control Block
// We use this block to break down a non-disk scsi request
//
typedef struct _SCCB {

  PUCHAR          VirtualTransferAddress;
  ULONG32           DeviceAddress;
  ULONG32           BytesPerBlock;
  ULONG32           BlocksLeft;
  ULONG32           BlocksThisReq;
  ULONG32           BytesThisReq;
  UCHAR           Started;
  UCHAR           Opcode;
  UCHAR           DevType;
} SCCB, *PSCCB;

#pragma pack(1)
typedef struct {
  UCHAR   Timeout:3;
  UCHAR   Ars:1;
  UCHAR   Dummy:3;
  UCHAR   IsLogical:1;
  UCHAR   Lun;
  UCHAR   Channel;
  UCHAR   ScsiId;
  UCHAR   QueueTag;
  UCHAR   QueueAction; // simple/ordered/head. SCSI-II Specs
  UCHAR   Cdb[MEGA_PASSTHRU_MAX_CDB];
  UCHAR   CdbLength;
  UCHAR   RequestSenseLength;
  UCHAR   RequestSenseArea[MEGA_PASSTHRU_MAX_SENSE];
  UCHAR   NoSGElements;
  UCHAR   ScsiStatus;
  ULONG32   DataTransferAddress;
  ULONG32   DataTransferLength;
}MegaPassThru, *PMegaPassThru;

//
// Scatter Gather List *
//

typedef struct _SG_DESCRIPTOR {
    ULONG32 Address;
    ULONG32 Length;
} SG_DESCRIPTOR, *PSG_DESCRIPTOR;


typedef struct _SGL {

  SG_DESCRIPTOR Descriptor[MAXIMUM_SGL_DESCRIPTORS];
} SGL32, *PSGL32;

//
//64 bit addressing SGL Descriptor
//

typedef struct _SG64_DESCRIPTOR 
{
  unsigned __int32  AddressLow;          /*Changed according to FW+ members request*/
  unsigned __int32  AddressHigh;
  unsigned __int32  Length;

} SG64_DESCRIPTOR, *PSG64_DESCRIPTOR;

//
//64 bit addressing SGList
//

typedef struct _SGL64
{
  SG64_DESCRIPTOR Descriptor[MAXIMUM_SGL_DESCRIPTORS];

}SGL64, *PSGL64;


typedef struct {
  
  MegaPassThru    MegaPassThru;
  union
  {
    SGL32             SG32List;
    SGL64             SG64List;
  }SglType;

  PSCSI_REQUEST_BLOCK NextSrb;
  ULONG32             StartPhysicalBlock;
  ULONG32             NumberOfBlocks;
  BOOLEAN             IsChained;
  UCHAR               IsFlushIssued;
 	BOOLEAN             IsShutDownSyncIssued;

} MegaSrbExtension, *PMegaSrbExtension,
  SRB_EXTENSION, *PSRB_EXTENSION;


typedef struct {
  
  UCHAR    DriverSignature[10]; 
  UCHAR    OSName[15];
  UCHAR    OSVersion[10];
  UCHAR    DriverName[20];
  UCHAR    DriverVersion[30];
  UCHAR    DriverReleaseDate[20];
} DriverInquiry, *PDriverInquiry;

typedef struct {
     
  UCHAR HostAdapterNumber;
  UCHAR LogicalDriveNumber;
}LOGICAL_DRIVE_INFO, *PLOGICAL_DRIVE_INFO;



typedef struct MegaRAID_Enquiry3 MEGARaid_INQUIRY_40, *PMEGARaid_INQUIRY_40;

typedef struct {

  ULONG32   NumberOfIoReads[MAX_LOGICAL_DRIVES_40];
  ULONG32   NumberOfIoWrites[MAX_LOGICAL_DRIVES_40];
  ULONG32   NumberOfBlocksRead[MAX_LOGICAL_DRIVES_40];
  ULONG32   NumberOfBlocksWritten[MAX_LOGICAL_DRIVES_40];
  ULONG32   NumberOfReadFailures[MAX_LOGICAL_DRIVES_40];
  ULONG32   NumberOfWriteFailures[MAX_LOGICAL_DRIVES_40];
} MegaRaidStatistics_40, *PMegaRaidStatistics_40; 

typedef struct {
  
  ULONG32   NumberOfIoReads[MAX_LOGICAL_DRIVES_8];
  ULONG32   NumberOfIoWrites[MAX_LOGICAL_DRIVES_8];
  ULONG32   NumberOfBlocksRead[MAX_LOGICAL_DRIVES_8];
  ULONG32   NumberOfBlocksWritten[MAX_LOGICAL_DRIVES_8];
  ULONG32   NumberOfReadFailures[MAX_LOGICAL_DRIVES_8];
  ULONG32   NumberOfWriteFailures[MAX_LOGICAL_DRIVES_8];
} MegaRaidStatistics_8, *PMegaRaidStatistics_8; 



//
// The following structure is allocated
// from noncached memory as data will be DMA'd to
// and from it.
//
typedef struct _NONCACHED_EXTENSION
{

  volatile FW_MBOX        fw_mbox;
  ULONG32                 PhysicalBufferAddress;
  UCHAR                   Buffer[0x100];
  ULONG32                 PhysicalScsiReqAddress;
  
  //structure split
  union{
    MEGARaid_INQUIRY_8  MRAIDParams8;
    MEGARaid_INQUIRY_40  MRAIDParams40;
  }MRAIDParams;

  //structure split
  union{
    MEGARaid_INQUIRY_8  MRAIDTempParams8;
    MEGARaid_INQUIRY_40 MRAIDTempParams40;
  }MRAIDTempParams;

  //
  //scatter gather list used for 40logdrive disk array read
  //
  SGL32    DiskArraySgl;


  UCHAR    ArraySpanDepth;
  UCHAR    UpdateState;

  UCHAR   RPBoard;

#ifdef AMILOGIC
  PCI_COMMON_CONFIG AmiLogicConfig[MAX_AMILOGIC_CHIP_COUNT];

  MEGARAID_BIOS_STARTUP_INFO_PCI  BiosStartupInfo;
#endif

  union{
    union{
      FW_ARRAY_8SPAN_8LD      Span8;
      FW_ARRAY_4SPAN_8LD      Span4;
    }LD8;
    union{
      FW_ARRAY_8SPAN_40LD      Span8;
      FW_ARRAY_4SPAN_40LD      Span4;
    }LD40;
  }DiskArray;


} NONCACHED_EXTENSION, *PNONCACHED_EXTENSION;

typedef struct _CRASHDUMP_NONCACHED_EXTENSION
{

  volatile FW_MBOX        fw_mbox;
  ULONG32                 PhysicalBufferAddress;
  UCHAR                   Buffer[0x100];
  ULONG32                 PhysicalScsiReqAddress;
  
  //structure split
  union{
    MEGARaid_INQUIRY_8  MRAIDParams8;
    MEGARaid_INQUIRY_40  MRAIDParams40;
  }MRAIDParams;

  //structure split
  union{
    MEGARaid_INQUIRY_8  MRAIDTempParams8;
    MEGARaid_INQUIRY_40 MRAIDTempParams40;
  }MRAIDTempParams;

  //
  //scatter gather list used for 40logdrive disk array read
  //
  SGL32    DiskArraySgl;


  UCHAR    ArraySpanDepth;
  UCHAR    UpdateState;

  UCHAR   RPBoard;

#ifdef AMILOGIC
  PCI_COMMON_CONFIG AmiLogicConfig[MAX_AMILOGIC_CHIP_COUNT];

  MEGARAID_BIOS_STARTUP_INFO_PCI  BiosStartupInfo;
#endif

  union{
    union{
      FW_ARRAY_8SPAN_8LD      Span8;
      FW_ARRAY_4SPAN_8LD      Span4;
    }LD8;
    union{
      UCHAR Span8;
      UCHAR Span4;
    }LD40;
  }DiskArray;

} CRASHDUMP_NONCACHED_EXTENSION, *PCRASHDUMP_NONCACHED_EXTENSION;


typedef struct _LOGDRV_COMMAND_ARRAY{
  
  UCHAR LastFunction;
  UCHAR  LastCommand;
  UCHAR Opcode;

  ULONG32 StartBlock;
  ULONG32 LastBlock;
  UCHAR NumSrbsQueued;

  UCHAR PreviousQueueLength;
  UCHAR CurrentQueueLength;
  UCHAR QueueLengthConstancyPeriod;
  UCHAR CheckPeriod;

  PSCSI_REQUEST_BLOCK SrbQueue;
  PSCSI_REQUEST_BLOCK SrbTail;
  UCHAR       ExpectedPhysicalBreaks;

} LOGDRV_COMMAND_ARRAY, *PLOGDRV_COMMAND_ARRAY; 

//Non Disk Information Structure

typedef struct _NONDISK_INFO
{
  BOOLEAN   NonDiskInfoPresent;
  UCHAR     Reserved[3];
  USHORT    NonDiskInfo[MRAID_DEFAULT_MAX_PHYSICAL_CHANNEL];
}NONDISK_INFO, *PNONDISK_INFO;

typedef struct _FAILED_ID
{
  UCHAR PathId;
  UCHAR TargetId;
}FAILED_ID;

#define NORMAL_TIMEOUT      (0x00)
#define SHORT_TIMEOUT       (0x01)
#define ERROR_MAILBOX_BUSY  (0xC2)

//
// Device extension
//
typedef struct _HW_DEVICE_EXTENSION {

  //
  // Pending request.
  // This request has not been sent to the adapter yet
  // because the adapter was busy
  //
  PSCSI_REQUEST_BLOCK PendingSrb;

  //
  // Pointers to disk IO requests sent to adapter
  // and their statuses
  //
  ULONG32 PendCmds;
  PSCSI_REQUEST_BLOCK PendSrb[CONC_CMDS];
  
  PNONCACHED_EXTENSION NoncachedExtension;
  
  PVOID PciPortStart;
  ULONG32 AdapterIndex;           
  UCHAR FreeSlot;
  UCHAR HostTargetId;

  UCHAR SplitAccessed;  //Flag to check split is done for Merged Commands due SGList is more than NumberOfPhysicalBreaks
  LOGDRV_COMMAND_ARRAY LogDrvCommandArray[MAX_LOGICAL_DRIVES_40];

  #ifdef PDEBUG
    PVOID dbgport;                  
  #endif
  REQ_PARAMS ActiveIO[CONC_CMDS];

  //Structure split
  union{
    MegaRaidStatistics_8  Statistics8;
    MegaRaidStatistics_40 Statistics40;
  }Statistics;

  #ifdef  DELL
    //Increased to the maximum 
    UCHAR LogDrvChecked[MAX_LOGICAL_DRIVES_40];
  #endif

    UCHAR ResetIssued;

  #ifdef MRAID_TIMEOUT
    UCHAR DeadAdapter;
    ULONG32  SlotNumber;
    ULONG32  SystemIoBusNumber;  
  #endif

  volatile UCHAR  AdpInquiryFlag;
  volatile UCHAR  BootFlag;

  UCHAR   HostAdapterOrdinalNumber;
  BOOLEAN OrdinalNumberAssigned;

  ULONG32    SupportedLogicalDriveCount;  
  
  ULONG32    MaximumTransferLength;
  ULONG32    NumberOfPhysicalBreaks;
  BOOLEAN LargeMemoryAccess;              /*TRUE indicate 64 bit addressing supported*/
                                          /*otherwise 32 bit addressing*/
  UCHAR   NumberOfPhysicalChannels;


  USHORT SubSystemDeviceID;
  USHORT SubSystenVendorID;

  UCHAR  ExposedDeviceCount;
    
  UCHAR  NonDiskDeviceCount;
  NONDISK_INFO NonDiskInfo;
  UCHAR  ReadConfigCount;
  BOOLEAN  ReadDiskArray;
  UCHAR   CrashDumpRunning;
  FAILED_ID Failed;
  UCHAR  AssociatedSrbStatus;
  UCHAR  NumberOfDedicatedLogicalDrives;
  UCHAR  AdapterFlushIssued;
#ifdef AMILOGIC
  ULONG32  AmiSlotNumber[MAX_AMILOGIC_CHIP_COUNT];
  ULONG32  AmiSystemIoBusNumber;
  UCHAR    ChipCount;
  ULONG32  Dec2SlotNumber;
  ULONG32  Dec2SystemIoBusNumber;  
#endif
  SCSI_PHYSICAL_ADDRESS  BaseAddressRegister; 
  ULONG32  PhysicalAddressOfMailBox;    /*DEBUGING INFORMATION*/
  BOOLEAN  IsFirmwareHanging;
  
  LOGDRV_COMMAND_ARRAY SplitCommandArray; //Split SRBs Command Array.

} HW_DEVICE_EXTENSION, *PHW_DEVICE_EXTENSION;

//
//Functions prototypes
//

ULONG32
DriverEntry(
  IN PVOID DriverObject,
  IN PVOID Argument2);


ULONG32
MegaRAIDFindAdapter(
  IN PVOID DeviceExtension,
  IN PVOID Context,
  IN PVOID BusInformation,
  IN PCHAR ArgumentString,
  IN OUT PPORT_CONFIGURATION_INFORMATION ConfigInfo,
  OUT PBOOLEAN Again);

BOOLEAN
MegaRAIDInitialize(
  IN PVOID DeviceExtension);

BOOLEAN
MegaRAIDStartIo(
  IN PVOID DeviceExtension,
  IN PSCSI_REQUEST_BLOCK Srb);

BOOLEAN
MegaRAIDInterrupt(
  IN PVOID DeviceExtension);

BOOLEAN
MegaRAIDResetBus(
  IN PVOID HwDeviceExtension,
  IN ULONG PathId);


ULONG32
FireRequest(
  IN PHW_DEVICE_EXTENSION DeviceExtension,
  IN PSCSI_REQUEST_BLOCK Srb);

BOOLEAN
SendMBoxToFirmware(
  IN PHW_DEVICE_EXTENSION DeviceExtension,
  IN PUCHAR PciPortStart,
  IN PFW_MBOX Mbox);


ULONG32
ContinueDiskRequest(
  IN PHW_DEVICE_EXTENSION DeviceExtension,
  IN UCHAR CommandID,
  IN BOOLEAN Origin);

BOOLEAN
FireRequestDone(
  IN PHW_DEVICE_EXTENSION DeviceExtension,
  IN UCHAR CommandID,
  IN UCHAR Status);


ULONG32
MRaidStatistics(
  PHW_DEVICE_EXTENSION    DeviceExtension,
  PSCSI_REQUEST_BLOCK     Srb);   

#ifdef  DELL
BOOLEAN
DellChkWriteBlockZero(PSCSI_REQUEST_BLOCK Srb, PHW_DEVICE_EXTENSION DeviceExtension, UCHAR Status);

ULONG32
FindTotalSize( PSCSI_REQUEST_BLOCK Srb );

ULONG32
IssueReadConfig(
  PHW_DEVICE_EXTENSION    DeviceExtension,
  PSCSI_REQUEST_BLOCK     Srb,
  UCHAR                   CommandID);

#endif

ULONG32
QueryReservationStatus (
  PHW_DEVICE_EXTENSION    DeviceExtension,
  PSCSI_REQUEST_BLOCK     Srb,
  UCHAR                   CommandID);


ULONG32
MRaidBaseport(
  PHW_DEVICE_EXTENSION DeviceExtension,
  PSCSI_REQUEST_BLOCK  Srb  );

ULONG32
MRaidDriverData(        
  PHW_DEVICE_EXTENSION    DeviceExtension,
  PSCSI_REQUEST_BLOCK     Srb);

#ifdef TOSHIBA_SFR
  VOID MegaRAIDFunctionA(IN ULONG32 TimeOut);
  VOID MegaRAIDFunctionB(IN PVOID HwDeviceExtension);
#endif

#define IS_NONDISK_PRESENT(NdInfo, path, targ, lun) ((NdInfo.NonDiskInfo[path] & ( 1 << targ)) ? 1 : 0)
#define SET_NONDISK_INFO(NdInfo, path, targ, lun) (NdInfo.NonDiskInfo[path] |= ( 1 << targ))  
#define RESET_NONDISK_INFO(NdInfo, path, targ, lun) (IS_NONDISK_PRESENT(NdInfo, path, targ, lun) ? (NdInfo.NonDiskInfo[path] ^= ( 1 << targ)) : (NdInfo.NonDiskInfo[path] ^=  0))  

#endif //end of _INCLUDE_MEGARAID
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\port\scsi\miniport\megaraid\miscellaneous.c ===
/*******************************************************************/
/*                                                                 */
/* NAME             = Miscellanous.c                               */
/* FUNCTION         = Implementation of special functions;         */
/* NOTES            =                                              */
/* DATE             = 02-03-2000                                   */
/* HISTORY          = 001, 02-03-00, Parag Ranjan Maharana;        */
/* COPYRIGHT        = LSI Logic Corporation. All rights reserved;  */
/*                                                                 */
/*******************************************************************/

#include "includes.h"





ULONG32 
MegaRAIDGetPhysicalAddressAsUlong(
  IN PHW_DEVICE_EXTENSION HwDeviceExtension,
  IN PSCSI_REQUEST_BLOCK Srb,
  IN PVOID VirtualAddress,
  OUT ULONG32 *Length)
{
  SCSI_PHYSICAL_ADDRESS phyAddress;

  phyAddress = ScsiPortGetPhysicalAddress(HwDeviceExtension,
												                  Srb,
												                  VirtualAddress,
												                  Length);

  return ScsiPortConvertPhysicalAddressToUlong(phyAddress);
}

BOOLEAN
MegaRAIDZeroMemory(PVOID Buffer, ULONG32 Length)
{
  ULONG32   index;
  PUCHAR  bytes = (PUCHAR)Buffer;

  if(bytes == NULL)
    return FALSE;

  for(index = 0; index < Length; ++index)
  {
    bytes[index] = 0;
  }
  return TRUE;
}

UCHAR 
GetNumberOfChannel(IN PHW_DEVICE_EXTENSION DeviceExtension)
{
  FW_MBOX fwMailBox;
  UCHAR   numChannel = 1;
  ULONG32   count;
  ULONG32   length = 1;


	//
	//initialize the mailbox struct
	//
	MegaRAIDZeroMemory(&fwMailBox, sizeof(FW_MBOX));

  if(DeviceExtension->SupportedLogicalDriveCount == MAX_LOGICAL_DRIVES_40)
  {
    fwMailBox.Command              = NEW_CONFIG_COMMAND;
    fwMailBox.CommandId            = 0xFE;
	  fwMailBox.u.Flat2.Parameter[0] = GET_NUM_SCSI_CHAN;	//[BYTE 2]

	  //
	  //get the physical address of the enquiry3 data structure
	  //
	  fwMailBox.u.Flat2.DataTransferAddress = MegaRAIDGetPhysicalAddressAsUlong(DeviceExtension, 
														                             NULL, 
														                             DeviceExtension->NoncachedExtension->Buffer, 
														                             (PULONG)&length);



	  DeviceExtension->NoncachedExtension->fw_mbox.Status.CommandStatus = 0;
    DeviceExtension->NoncachedExtension->fw_mbox.Status.NumberOfCompletedCommands = 0;

    SendMBoxToFirmware(DeviceExtension, DeviceExtension->PciPortStart, &fwMailBox);

    if(WaitAndPoll(DeviceExtension->NoncachedExtension, DeviceExtension->PciPortStart, DEFAULT_TIMEOUT, TRUE))
    {
      numChannel = DeviceExtension->NoncachedExtension->Buffer[0];
      
      return numChannel;
    }
  }
  else   //8LD FIRE Normal Enquiry 
  {
    fwMailBox.Command       = MRAID_DEVICE_PARAMS;
    fwMailBox.CommandId     = 0xFE;

	  //
	  //get the physical address of the enquiry3 data structure
	  //
	  fwMailBox.u.Flat2.DataTransferAddress = MegaRAIDGetPhysicalAddressAsUlong(DeviceExtension, 
														                             NULL, 
														                             DeviceExtension->NoncachedExtension->Buffer, 
														                             (PULONG)&length);



	  DeviceExtension->NoncachedExtension->fw_mbox.Status.CommandStatus = 0;
    DeviceExtension->NoncachedExtension->fw_mbox.Status.NumberOfCompletedCommands = 0;

    SendMBoxToFirmware(DeviceExtension, DeviceExtension->PciPortStart, &fwMailBox);

    if(WaitAndPoll(DeviceExtension->NoncachedExtension, DeviceExtension->PciPortStart, DEFAULT_TIMEOUT, TRUE))
    {
      PMEGARaid_INQUIRY_8 megaInquiry8;

      megaInquiry8 = (PMEGARaid_INQUIRY_8)DeviceExtension->NoncachedExtension->Buffer;
      numChannel = megaInquiry8->AdpInfo.ChanPresent;
    
      return numChannel; 
    }

  }
  //
  //In an Controller there can be max. channels can be 4.
  //If enquiry fails at this stage it will not fail.
  //
  return MRAID_DEFAULT_MAX_PHYSICAL_CHANNEL; 
}

BOOLEAN
WaitAndPoll(PNONCACHED_EXTENSION NoncachedExtension, PUCHAR PciPortStart, ULONG32 TimeOut, BOOLEAN Polled)
{
  ULONG32 count = 0;
	ULONG32	rpInterruptStatus;
  UCHAR nonrpInterruptStatus;
	USHORT	rxInterruptStatus;

  //Convert the seconds to 100s of micro seconds
  TimeOut *= 10000;  
	
  if(Polled == FALSE)
  {
    //
    // Check for 60 seconds
    //
    for(count=0;count< TimeOut; count++) 
    {
      if(NoncachedExtension->RPBoard == MRAID_RP_BOARD)
		  {
			  rpInterruptStatus = 
				  ScsiPortReadRegisterUlong((PULONG)(PciPortStart+OUTBOUND_DOORBELL_REG));
			  if (rpInterruptStatus == MRAID_RP_INTERRUPT_SIGNATURE)
				  break;
		  }
		  else
		  {
			  nonrpInterruptStatus = ScsiPortReadPortUchar(PciPortStart+PCI_INT);
			  if( nonrpInterruptStatus & MRAID_NONRP_INTERRUPT_MASK) 
				  break;
      }
		    ScsiPortStallExecution(100);
    }

	  //
	  //  Check for timeout. Fail the adapter for timeout.
	  //
	  if(count == TimeOut) 
		  return FALSE;

	  //
	  // Clear the interrupts on the Adapter. Acknowlege the interrupt to the
	  // Firmware.
	  //
    if(NoncachedExtension->RPBoard == MRAID_RP_BOARD)
	  {
		  ScsiPortWriteRegisterUlong((PULONG)(PciPortStart+INBOUND_DOORBELL_REG), MRAID_RP_INTERRUPT_ACK);
		  while (ScsiPortReadRegisterUlong(
				  (PULONG)(PciPortStart+INBOUND_DOORBELL_REG)))
			  ;
		  rpInterruptStatus = 
			  ScsiPortReadRegisterUlong(
			  (PULONG)(PciPortStart+OUTBOUND_DOORBELL_REG));
		  ScsiPortWriteRegisterUlong(
			  (PULONG)(PciPortStart+OUTBOUND_DOORBELL_REG), rpInterruptStatus);
	  }
	  else
	  {
		  ScsiPortWritePortUchar(PciPortStart+PCI_INT, nonrpInterruptStatus);
		  ScsiPortWritePortUchar(PciPortStart, MRAID_NONRP_INTERRUPT_ACK);
    }

  }
  else
  {
    ////////////////POLLED MODE////////////////////
    //If in polled mode any command is timed out -> this means that fw is not in GOOD Condition
    //In Polled mode all the commands are internal command to driver. If any internal commands
    //failed then driver will not able to take any right decsion, So rather haging ask OS to BOOT
	  if (NoncachedExtension->RPBoard == MRAID_NONRP_BOARD)
	  {
		  //
		  // Check for time out value
		  //
		  for(count=0; count < TimeOut; count++) 
		  {
			  nonrpInterruptStatus = ScsiPortReadPortUchar(PciPortStart+PCI_INT);
			  if( nonrpInterruptStatus & 0x40) 
				  break;
			  ScsiPortStallExecution(100);
		  }

		  //
		  //  Check for timeout. Fail the adapter for timeout.
		  //
		  if (count == TimeOut) 
      {
        DebugPrint((0, "\n COMMAND is timed OUT"));
  	    //deviceExtension->IsFirmwareHanging = TRUE;
			  return FALSE;
      }

		  //
		  // Clear the interrupts on the Adapter. Acknowlege the interrupt to the
		  // Firmware.
		  //
		  ScsiPortWritePortUchar(PciPortStart+PCI_INT, nonrpInterruptStatus);
	  }
	  else
	  {                          
		  while (!NoncachedExtension->fw_mbox.Status.NumberOfCompletedCommands)
      {
		    ScsiPortStallExecution(100);
        count++;
		    if (count == TimeOut) 
        {
          DebugPrint((0, "\n COMMAND is timed OUT"));
			    //deviceExtension->IsFirmwareHanging = TRUE;
          return FALSE;
        }
      }
	  }

	  //
	  //Status ACK
	  //
	  if (NoncachedExtension->RPBoard == MRAID_RP_BOARD)
	  {
		  ScsiPortWriteRegisterUlong(
			  (PULONG)(PciPortStart+INBOUND_DOORBELL_REG),2);
		  while (ScsiPortReadRegisterUlong((PULONG)(PciPortStart+INBOUND_DOORBELL_REG)))
			  ;
	  }
	  else
	  {
		  ScsiPortWritePortUchar(PciPortStart, 8);
	  }
  }
  return TRUE;
}



USHORT  
GetM16(PUCHAR p)
{
	USHORT  s;
	PUCHAR  sp=(PUCHAR)&s;

	sp[0] = p[1];
	sp[1] = p[0];
	return(s);
}

ULONG32   
GetM24(PUCHAR p)
{
	ULONG32   l;
	PUCHAR  lp=(PUCHAR)&l;

	lp[0] = p[2];
	lp[1] = p[1];
	lp[2] = p[0];
	lp[3] = 0;
	return(l);
}

ULONG32   
GetM32(PUCHAR p)
{
	ULONG32   l;
	PUCHAR  lp=(PUCHAR)&l;

	lp[0] = p[3];
	lp[1] = p[2];
	lp[2] = p[1];
	lp[3] = p[0];
	return(l);
}

VOID    
PutM16(PUCHAR p, USHORT s)
{
	PUCHAR  sp=(PUCHAR)&s;

	p[0] = sp[1];
	p[1] = sp[0];
}

VOID    
PutM24(PUCHAR p, ULONG32 l)
{
	PUCHAR  lp=(PUCHAR)&l;

	p[0] = lp[2];
	p[1] = lp[1];
	p[2] = lp[0];
}

void    
PutM32(PUCHAR p, ULONG32 l)
{
	PUCHAR  lp=(PUCHAR)&l;

	p[0] = lp[3];
	p[1] = lp[2];
	p[2] = lp[1];
	p[3] = lp[0];
}

VOID    
PutI16(PUCHAR p, USHORT s)
{
	PUCHAR  sp=(PUCHAR)&s;

	p[0] = sp[0];
	p[1] = sp[1];
}

VOID    
PutI32(PUCHAR p, ULONG32 l)
{
	PUCHAR  lp=(PUCHAR)&l;

	p[0] = lp[0];
	p[1] = lp[1];
	p[2] = lp[2];
	p[3] = lp[3];
}

ULONG32           
SwapM32(ULONG32 l)
{
	ULONG32   lres;
	PUCHAR  lp=(PUCHAR)&l;
	PUCHAR  lpres=(PUCHAR)&lres;

	lpres[0] = lp[3];
	lpres[1] = lp[2];
	lpres[2] = lp[1];
	lpres[3] = lp[0];

	return(lres);
}



ULONG32
QueryReservationStatus (
					PHW_DEVICE_EXTENSION    DeviceExtension,
					PSCSI_REQUEST_BLOCK     Srb,
					UCHAR                   CommandID)
{
	FW_MBOX                 mbox;
	ULONG32                   length;
	UCHAR                   logicalDriveNumber;

  MegaRAIDZeroMemory(&mbox, sizeof(FW_MBOX));
  
  logicalDriveNumber = GetLogicalDriveNumber(DeviceExtension, Srb->PathId,Srb->TargetId,Srb->Lun);

	mbox.Command              =  MRAID_RESERVE_RELEASE_RESET; 
	mbox.CommandId            = CommandID;
	mbox.u.Flat2.Parameter[0] = QUESTION_RESERVATION;
	mbox.u.Flat2.Parameter[1] = logicalDriveNumber;

	Srb->SrbStatus     = MRAID_RESERVATION_CHECK;      
	
	SendMBoxToFirmware(DeviceExtension, DeviceExtension->PciPortStart, &mbox);
	return TRUE;
}


BOOLEAN 
SendSyncCommand(PHW_DEVICE_EXTENSION deviceExtension)
{    
  FW_MBOX mbox;
  PNONCACHED_EXTENSION NoncachedExtension = deviceExtension->NoncachedExtension;
  PUCHAR PciPortStart = deviceExtension->PciPortStart;
  ULONG32 interruptStatus;
  UCHAR istat;
  ULONG32 count;
  USHORT rxInterruptStatus;

  deviceExtension->IsFirmwareHanging = FALSE;
  

  MegaRAIDZeroMemory(&mbox, sizeof(FW_MBOX));

  mbox.Command = 0xFF;
	mbox.CommandId = 0xFE;

	//
	//The next two initializations are introduced on Feb/3/1999.
	//This is kinda cautious step to make sure that these fields
	//does not contain any junk data. In the while loop below,
	//one of the fields is checked for the value of 0.
	//The SendMBoxToFirmware() uses the deviceExtension's fw_mbox
	//mail box to send commands to the firmware. Only the First 16 bytes
	//are copied from the local Mbox structure, so fw_mbox.[mstat]
	//fields need to be zeroed.
	//
	NoncachedExtension->fw_mbox.Status.NumberOfCompletedCommands= 0;
	NoncachedExtension->fw_mbox.Status.CommandStatus = 0;
	
	SendMBoxToFirmware(deviceExtension, PciPortStart, &mbox);
		
	// COMMENTED ON Feb/3/1999. 
	// Reason : Most of the old firmwares does not support this command.
	// They won't change the Opcode value in the command. So the 
	// driver was continuosly executing the while loop, causing the 
	// system to hang. As a fix to that, instead of waiting for the
	// Opcode to change( as an indication of command completion)
	// the driver also checks for the status of the command and proceeds 
	// the normal way.

	// Ok, the Firmware logic for this command goes this way.
	// If the Firmware SUPPORTS the ABOVE COMMAND,
	//		deviceExtension->NoncachedExtension->fw_mbox.Opcode 
	//		will be set to 0
	// else 
	//		the firmware will reject the command with 
	//		deviceExtension->NoncachedExtension->fw_mbox.mstat.cmds_completed 
	//		=1 
	// end
	//
	// Previously, the check was done only for the first case. This was
	// causing the drivers to hang if the FW does not support the command.
	// This was because, the FW in that case would have set 
	//   deviceExtension->NoncachedExtension->fw_mbox.mstat.cmds_completed
	// to 1 but the driver was waiting on Opcode  change to 0.
	// 
	// As a fix, the second check is also introduced. This will ensure
	// the proper flow of the driver.
	//
    count = 0;
		while (
		 (NoncachedExtension->fw_mbox.Command == 0xFF)
		  &&
		 (!NoncachedExtension->fw_mbox.Status.NumberOfCompletedCommands)
		 )
		{
			count++;
			ScsiPortStallExecution(100);
      if(count == 0x927C0)
      {
        DebugPrint((0,"\n FIRMWARE IS HANGING -> NEED Reboot of system or Power to QlogicChips"));
        deviceExtension->IsFirmwareHanging = TRUE;
        break;
      }
		}

    //
		// Check For Interrupt Line 
		//
		if (NoncachedExtension->RPBoard == MRAID_RP_BOARD)
		{
			interruptStatus = 
				ScsiPortReadRegisterUlong(
				(PULONG)(PciPortStart+OUTBOUND_DOORBELL_REG));
			if (interruptStatus == 0x10001234)
				DebugPrint((0, "1st Delayed Interrupt\n"));
			//
			// Pull down the Interrupt
			//
			ScsiPortWriteRegisterUlong((PULONG)(
				PciPortStart+OUTBOUND_DOORBELL_REG),interruptStatus);
			ScsiPortWriteRegisterUlong((PULONG)(PciPortStart +
				INBOUND_DOORBELL_REG),2);
		}
		else
		{
			istat = ScsiPortReadPortUchar(PciPortStart+PCI_INT);
			ScsiPortWritePortUchar(PciPortStart+PCI_INT, istat);
			ScsiPortWritePortUchar(PciPortStart, 8);
		}

    return (deviceExtension->IsFirmwareHanging ? FALSE : TRUE);

}


//++
//
//Function Name : GetLogicalDriveNumber
//Routine Description:		
//		All the logical drives reported by the firmware must be
//		mapped to NT OS as a Scsi Path/Target/Lun.NT OS sees the
//		drives in this way, but the firmware processes them through
//		logical drive numbers.
//
//		This routine, returns the corresponding	logical drive number
//		for the Scsi Path/Target/Lun given by NTOS.
//
//Return Value:
//		Logical Drive Number
//
//
// NOTE : THE CURRENT IMPLEMENTATION IS ONLY FOR 
//				PathId == 0 & Lun == 0
//
//--
UCHAR
GetLogicalDriveNumber(
					PHW_DEVICE_EXTENSION DeviceExtension,
					UCHAR	PathId,
					UCHAR TargetId,
					UCHAR Lun)
{
	UCHAR	logicalDriveNumber;

	//
	//For the 8 logical drive we maintain a linear mapping for the
	//logical drives.
	//That is, for Srb->PathId =0, Various Targets are mapped in 
	//linear fashion for the corresponding logical drives, @ LUN =0.
	//Let us take an example.
	//			Number of Logical Drives Configured = 8
	//			Host Target id (Initiator Id ) = 7
	//
	//PathId | TargetId | Lun							LogicalDriveNumber
	//-----------------------							------------------
	//0 0 0	-------------------------->			0
	//0 1 0																	1
	//0 2 0 -------------------------->			2
	//0 3 0																	3
	//0 4 0	-------------------------->			4
	//0 5 0																	5
	//0 6 0	-------------------------->			6
	//REPORED AS INITIATOR ID. NT RESERVES THIS					
	//0 8 0																	7
	//

  //Request came for Physical Device
  if(PathId < DeviceExtension->NumberOfPhysicalChannels)
  {
    DebugPrint((0, "\nERROR in Getting Logical drive from Physical Channel"));
    return TargetId;
  }

  //
	//NOTE : This function never gets called for the condition:
	//			 TargetId == DeviceExtension->HostTargetId.
	//			 This is ensured by the NT ScsiPort driver.
	//
	if(TargetId < DeviceExtension->HostTargetId)
  {
			//
			//Target Id falls below the HostInitiator Id. Linear mapping
			//can be used as is.
			//
			logicalDriveNumber = (TargetId*MAX_LUN_PER_TARGET)+Lun;
	}
	else
  {
			//
			//Target Id falls above the HostInitiator Id. Linear mapping
			//CANNOT be used as is. The logical drive number would be
			//one less than the Target Id.
			//
			logicalDriveNumber = ((TargetId-1)*MAX_LUN_PER_TARGET)+Lun;
	}
  //It is dedicated bus
  if(PathId == DeviceExtension->NumberOfPhysicalChannels)
  {
    if(logicalDriveNumber >= DeviceExtension->NumberOfDedicatedLogicalDrives)
      logicalDriveNumber = 0xFF; //Make it as invalid logical drive number
  }
  else //Shared BUS
  {
    logicalDriveNumber += DeviceExtension->NumberOfDedicatedLogicalDrives;
  }


	//return the mapped logical drive number
	//
	return(logicalDriveNumber);
}//end of GetLogicalDriveNumber()

void
FillOemVendorID(PUCHAR Inquiry, USHORT SubSystemDeviceID, USHORT SubSystemVendorID)
{
  PUCHAR Vendor;
  switch(SubSystemVendorID)
  {
  case SUBSYSTEM_VENDOR_HP:
    Vendor = (PUCHAR)OEM_VENDOR_HP;
    break;
  case SUBSYSTEM_VENDOR_DELL:
  case SUBSYSTEM_VENDOR_EP_DELL:
    Vendor = (PUCHAR)OEM_VENDOR_DELL;
    break;
  case SUBSYSTEM_VENDOR_AMI:     
  default:
      if(SubSystemDeviceID == OLD_DELL_DEVICE_ID)
        Vendor = (PUCHAR)OEM_VENDOR_DELL;
      else
        Vendor = (PUCHAR)OEM_VENDOR_AMI;
  }


  ScsiPortMoveMemory((void*)Inquiry, (void*)Vendor, 8);
}

BOOLEAN 
GetFreeCommandID(PUCHAR CmdID, PHW_DEVICE_EXTENSION DeviceExtension) 
{
  BOOLEAN Ret = MEGARAID_FAILURE;
  UCHAR Index;
  UCHAR Cmd;
	Cmd = DeviceExtension->FreeSlot;                 
  
  if(DeviceExtension->PendCmds >= CONC_CMDS) 
    return Ret;

  for (Index=0;Index<CONC_CMDS;Index++)             
  {                                                 
		if (DeviceExtension->PendSrb[Cmd] == NULL)      
    {
      Ret = MEGARAID_SUCCESS;
			break;                                        
    }
		Cmd = (Cmd + 1) % CONC_CMDS;                    
  }                                                 
  if(Ret == MEGARAID_SUCCESS)
  {
    DeviceExtension->FreeSlot = Cmd;                
    *CmdID = Cmd;
  }
  return Ret;
} 
BOOLEAN
BuildScatterGatherListEx(IN PHW_DEVICE_EXTENSION DeviceExtension,
			                   IN PSCSI_REQUEST_BLOCK	 Srb,
			                   IN PUCHAR	             DataBufferPointer,
			                   IN ULONG32                TransferLength,
                         IN BOOLEAN              Sgl32,
                    		 IN PVOID                SglPointer,
			                   OUT PULONG							 ScatterGatherCount)
{
	
	PUCHAR	dataPointer = DataBufferPointer;
	ULONG32		bytesLeft = TransferLength;
	ULONG32		length = 0;
  PSGL64  sgl64 = (PSGL64)SglPointer;
  PSGL32  sgl32 = (PSGL32)SglPointer;
	
  SCSI_PHYSICAL_ADDRESS scsiPhyAddress;


	//Build S/G list for the DataBufferPointer
	//
	if (*ScatterGatherCount >= DeviceExtension->NumberOfPhysicalBreaks)
		return MEGARAID_FAILURE;

	do 
	{
		if (*ScatterGatherCount == DeviceExtension->NumberOfPhysicalBreaks)
		{
			return MEGARAID_FAILURE;
		}
		// Get physical address and length of contiguous
		// physical buffer.
		//
    scsiPhyAddress = ScsiPortGetPhysicalAddress(DeviceExtension,
										                            Srb,
                                                dataPointer, 
                                                &length);
    
    if(length > bytesLeft)
    {
					length = bytesLeft;
		}


    if(Sgl32 == TRUE)
    {
		  (sgl32->Descriptor[*ScatterGatherCount]).Address = scsiPhyAddress.LowPart;
		  (sgl32->Descriptor[*ScatterGatherCount]).Length  = length;
    }
    else
    {
      (sgl64->Descriptor[*ScatterGatherCount]).AddressHigh = scsiPhyAddress.HighPart;
      (sgl64->Descriptor[*ScatterGatherCount]).AddressLow  = scsiPhyAddress.LowPart;
		  (sgl64->Descriptor[*ScatterGatherCount]).Length      = length;
    }
		// Adjust counts.
		//
		dataPointer = (PUCHAR)dataPointer + length;
		bytesLeft -= length;
		(*ScatterGatherCount)++;

	} while (bytesLeft);


	return MEGARAID_SUCCESS;  // success

}

UCHAR 
GetNumberOfDedicatedLogicalDrives(IN PHW_DEVICE_EXTENSION DeviceExtension)
{
  FW_MBOX fwMailBox;
  UCHAR   numDedicatedLD = DeviceExtension->NumberOfDedicatedLogicalDrives;
  ULONG   count;
  ULONG   length = 1;


	//
	//initialize the mailbox struct
	//
	MegaRAIDZeroMemory(&fwMailBox, sizeof(FW_MBOX));

  //fwMailBox.Command              = MISCELLANEOUS_OPCODE;
  fwMailBox.Command              = DEDICATED_LOGICAL_DRIVES;
  fwMailBox.CommandId            = 0xFE;
	//fwMailBox.u.Flat2.Parameter[0] = DEDICATED_LOGICAL_DRIVES;	//[BYTE 2]

	//
	//get the physical address of the enquiry3 data structure
	//
	fwMailBox.u.Flat2.DataTransferAddress = MegaRAIDGetPhysicalAddressAsUlong(DeviceExtension, 
														                           NULL, 
														                           DeviceExtension->NoncachedExtension->Buffer, 
														                           (PULONG)&length);



	DeviceExtension->NoncachedExtension->fw_mbox.Status.CommandStatus= 0;
  DeviceExtension->NoncachedExtension->fw_mbox.Status.NumberOfCompletedCommands = 0;

  SendMBoxToFirmware(DeviceExtension, DeviceExtension->PciPortStart, &fwMailBox);

  if(WaitAndPoll(DeviceExtension->NoncachedExtension, DeviceExtension->PciPortStart, DEFAULT_TIMEOUT, TRUE) == TRUE)
  {
    if(DeviceExtension->NoncachedExtension->fw_mbox.Status.CommandStatus == 0)
      numDedicatedLD = DeviceExtension->NoncachedExtension->Buffer[1];
  }
  return numDedicatedLD;
}

#ifdef AMILOGIC

void
ScanDECBridge(PHW_DEVICE_EXTENSION DeviceExtension, 
              ULONG SystemIoBusNumber, 
              PSCANCONTEXT ScanContext)
{
  UCHAR                functionNumber;
  ULONG                retcount;
	PCI_COMMON_CONFIG    pciConfig;
  BOOLEAN              flag = TRUE;
  BOOLEAN              busflag;
  ULONG                busNumber;
  UCHAR                chipBusNumber = (UCHAR)(-1);
  UCHAR                numOfChips;
  MEGARAID_BIOS_STARTUP_INFO_PCI* MegaRAIDPciInfo = &DeviceExtension->NoncachedExtension->BiosStartupInfo;

  MegaRAIDPciInfo->h.structureId = MEGARAID_STARTUP_STRUCTYPE_PCI;
  MegaRAIDPciInfo->h.structureRevision = MEGARAID_STARTUP_PCI_INFO_STRUCTURE_REVISION;
  MegaRAIDPciInfo->h.structureLength = sizeof(MEGARAID_BIOS_STARTUP_INFO_PCI);

  
  for(busNumber = 0; flag; ++busNumber)
  {
		ScanContext->BusNumber = busNumber;
		ScanContext->DeviceNumber = 0;
    busflag = TRUE;
 
 	  for(ScanContext->DeviceNumber; ScanContext->DeviceNumber < PCI_MAX_DEVICES; ScanContext->DeviceNumber++)
	  {
		  for (functionNumber=0;functionNumber<2;functionNumber++)
		  {
			  PCI_SLOT_NUMBER pciSlotNumber;

        pciSlotNumber.u.AsULONG = 0;
        pciSlotNumber.u.bits.DeviceNumber = ScanContext->DeviceNumber;
        pciSlotNumber.u.bits.FunctionNumber = functionNumber;

 
			  pciConfig.VendorID = 0;                /* Initialize this field */
			  //
			  // Get the PCI Bus Data for the Adapter.
			  //
			  //
        MegaRAIDZeroMemory((PUCHAR)&pciConfig, sizeof(PCI_COMMON_CONFIG));

        retcount = HalGetBusData(PCIConfiguration, 
													  busNumber,
													  pciSlotNumber.u.AsULONG,
												    (PVOID)&pciConfig,
													  PCI_COMMON_HDR_LENGTH);

        if(retcount == 0)
        {
          flag = FALSE;
          break;
        }
        else
        {
          flag = TRUE;
        }

			  if(pciConfig.VendorID == PCI_INVALID_VENDORID) 
				  continue;

		  
		    if((pciConfig.VendorID != 0) || (pciConfig.DeviceID != 0))  
        {
          if(busflag == TRUE)
          {
            //DebugPrint((0, "\nSystemIoBusNumber = %d", busNumber);
            busflag = FALSE;
          }
          //DebugPrint((0, "\nDevice Number %d Function Number %d, Slot # 0x%X", ScanContext->DeviceNumber, functionNumber, pciSlotNumber.u.AsULONG);
          //DebugPrint((0, "\nVendor ID [%x] Device ID [%x]", pciConfig.VendorID, pciConfig.DeviceID);
          //DebugPrint((0, "\nSubSystemDeviceID = %X SubSystemVendorID = %X\n", pciConfig.u.type0.SubSystemID, pciConfig.u.type0.SubVendorID);

          //
          // look for the DEC 21154 bridge that is connected to *this* 960. This
          // will be the second of two DEC bridges on the megaraid board. We can 
          // determine the DEC bridge that is connected by matching up the
          // secondary bus # of a DEC bridge to the primary bus # of the 960
          //
          // example:
          //
          //          Primary   Secondary  Primary   Secondary  Primary    Secondary
          //      Bus #0          Bus #0 -> Bus #1     Bus #1 -> Bus #2     Bus #2 (-> Bus #3, not used)
          //  [PCI Host Bus] ---> [DEC Bridge #1] ---> [DEC Bridge #2] ---> i960RN
          //                              |
          //                              |
          //                          (Bus #1)
          //                              |
          //                              |
          //                          Qlogic Chip #1
          //                              |
          //                              |       
          //                          Qlogic Chip #2
          //
          // In the above example, we know that "DEC Bridge #2" is the bridge
          // connected to the i960 because the DEC's secondary bus number (Bus #2) is
          // equal to the i960's primary bus number (Bus #2).
          // 
          if(((pciConfig.VendorID == DEC_BRIDGE_VENDOR_ID) && (pciConfig.DeviceID == DEC_BRIDGE_DEVICE_ID))
 						||((pciConfig.VendorID == DEC_BRIDGE_VENDOR_ID2) && (pciConfig.DeviceID == DEC_BRIDGE_DEVICE_ID2)))
          {
            DebugPrint((0, "\nDevice Number %d Function Number %d, Slot # 0x%X", ScanContext->DeviceNumber, functionNumber, pciSlotNumber.u.AsULONG));
            DebugPrint((0, "\nVendor ID [%x] Device ID [%x]", pciConfig.VendorID, pciConfig.DeviceID));
            DebugPrint((0, "\nSubSystemDeviceID = %X SubSystemVendorID = %X\n", pciConfig.u.type0.SubSystemID, pciConfig.u.type0.SubVendorID));

            DebugPrint((0, "\nPrimaryBus %d SecondaryBus %d\n", pciConfig.u.type1.PrimaryBus, pciConfig.u.type1.SecondaryBus));
            
            if(pciConfig.u.type1.SecondaryBus == SystemIoBusNumber)
            {
              chipBusNumber = pciConfig.u.type1.PrimaryBus;
              numOfChips = 0;

              //We need this DEC Bridge #2 to Set PCI_SPACE+0x40 -> as 0x10
              //Which is near to RN Processor
              DeviceExtension->Dec2SlotNumber = pciSlotNumber.u.AsULONG;
              DeviceExtension->Dec2SystemIoBusNumber = busNumber;


              
            }
          }
          if((pciConfig.VendorID == AMILOGIC_CHIP_VENDOR_ID) && (pciConfig.DeviceID == AMILOGIC_CHIP_DEVICE_ID))
          {
            if(chipBusNumber == busNumber)
            {
              DebugPrint((0, "\nBaseAddresses[0] 0x%X BaseAddresses[1] 0x%X", pciConfig.u.type1.BaseAddresses[0], pciConfig.u.type1.BaseAddresses[1]));
              MegaRAIDPciInfo->scsiChipInfo[numOfChips].pciLocation = chipBusNumber;
              MegaRAIDPciInfo->scsiChipInfo[numOfChips].vendorId = AMILOGIC_CHIP_VENDOR_ID;
              MegaRAIDPciInfo->scsiChipInfo[numOfChips].deviceId = AMILOGIC_CHIP_DEVICE_ID;
              MegaRAIDPciInfo->scsiChipInfo[numOfChips].baseAddrRegs[0] = (pciConfig.u.type1.BaseAddresses[0] & 0xFFFFFFF0);
              MegaRAIDPciInfo->scsiChipInfo[numOfChips].baseAddrRegs[1] = (pciConfig.u.type1.BaseAddresses[1] & 0xFFFFFFF0);
            
              DebugPrint((0, "\nPrimaryBus %d SecondaryBus %d Qlogic Chip %d\n", pciConfig.u.type1.PrimaryBus, pciConfig.u.type1.SecondaryBus, numOfChips));

              ScsiPortMoveMemory(&DeviceExtension->NoncachedExtension->AmiLogicConfig[numOfChips], &pciConfig, PCI_COMMON_HDR_LENGTH);
              DeviceExtension->AmiSystemIoBusNumber = busNumber;
              DeviceExtension->AmiSlotNumber[numOfChips] = pciSlotNumber.u.AsULONG;
              
              DebugPrint((0, "\nAmiLogic -> PCIConfig Saved"));
              DumpPCIConfigSpace(&DeviceExtension->NoncachedExtension->AmiLogicConfig[numOfChips]);
              ++numOfChips;
              MegaRAIDPciInfo->scsiChipCount = numOfChips;
              DeviceExtension->ChipCount = numOfChips;

            
            }
          }
        }
      }
    }
  }
  //////////////////SORT QLOGIC 
  //
  // some PCI BIOS's return the devices in reverse device number (and/or function number)
  // order, so sort the SCSI chip table in ascending device number and function number
  //
  /* first sort by ascending device number */

  if (MegaRAIDPciInfo->scsiChipCount != 0) 
  {
    USHORT   x, y;
    struct  _MEGARAID_PCI_SCSI_CHIP_INFO tempScsiChipInfo;
  
    for (x=0; x < MegaRAIDPciInfo->scsiChipCount-1; x++) 
    {
      for (y=x+1; y < MegaRAIDPciInfo->scsiChipCount; y++) 
      {
        if (PCI_LOCATION_DEV_NUMBER(MegaRAIDPciInfo->scsiChipInfo[x].pciLocation) >
            PCI_LOCATION_DEV_NUMBER(MegaRAIDPciInfo->scsiChipInfo[y].pciLocation)) 
        {
           
          MegaPrintf("\nSORTING Qlc Chips  by ascending device number %x => %x", PCI_LOCATION_DEV_NUMBER(MegaRAIDPciInfo->scsiChipInfo[x].pciLocation), PCI_LOCATION_DEV_NUMBER(MegaRAIDPciInfo->scsiChipInfo[y].pciLocation));
          tempScsiChipInfo = MegaRAIDPciInfo->scsiChipInfo[x];
          MegaRAIDPciInfo->scsiChipInfo[x] = MegaRAIDPciInfo->scsiChipInfo[y];
          MegaRAIDPciInfo->scsiChipInfo[y] = tempScsiChipInfo;

          ScsiPortMoveMemory(&pciConfig, &DeviceExtension->NoncachedExtension->AmiLogicConfig[x], sizeof(PCI_COMMON_CONFIG));
          ScsiPortMoveMemory(&DeviceExtension->NoncachedExtension->AmiLogicConfig[x], &DeviceExtension->NoncachedExtension->AmiLogicConfig[y], sizeof(PCI_COMMON_CONFIG));
          ScsiPortMoveMemory(&DeviceExtension->NoncachedExtension->AmiLogicConfig[y], &pciConfig, sizeof(PCI_COMMON_CONFIG));
        }
      }           
     }
    /* now sort by ascending function number within each device number */
    for (x=0; x < MegaRAIDPciInfo->scsiChipCount-1; x++) 
    {
      for (y=x+1; y < MegaRAIDPciInfo->scsiChipCount; y++) 
      {
        if (PCI_LOCATION_DEV_NUMBER(MegaRAIDPciInfo->scsiChipInfo[x].pciLocation) != PCI_LOCATION_DEV_NUMBER(MegaRAIDPciInfo->scsiChipInfo[y].pciLocation))
            break;
        if (PCI_LOCATION_FUNC_NUMBER(MegaRAIDPciInfo->scsiChipInfo[x].pciLocation) > PCI_LOCATION_FUNC_NUMBER(MegaRAIDPciInfo->scsiChipInfo[y].pciLocation)) 
        {
          MegaPrintf("\nSORTING Qlc Chips  by ascending function number %x => %x", PCI_LOCATION_FUNC_NUMBER(MegaRAIDPciInfo->scsiChipInfo[x].pciLocation), PCI_LOCATION_FUNC_NUMBER(MegaRAIDPciInfo->scsiChipInfo[y].pciLocation));
          tempScsiChipInfo = MegaRAIDPciInfo->scsiChipInfo[x];
          MegaRAIDPciInfo->scsiChipInfo[x] = MegaRAIDPciInfo->scsiChipInfo[y];
          MegaRAIDPciInfo->scsiChipInfo[y] = tempScsiChipInfo;

          ScsiPortMoveMemory(&pciConfig, &DeviceExtension->NoncachedExtension->AmiLogicConfig[x], sizeof(PCI_COMMON_CONFIG));
          ScsiPortMoveMemory(&DeviceExtension->NoncachedExtension->AmiLogicConfig[x], &DeviceExtension->NoncachedExtension->AmiLogicConfig[y], sizeof(PCI_COMMON_CONFIG));
          ScsiPortMoveMemory(&DeviceExtension->NoncachedExtension->AmiLogicConfig[y], &pciConfig, sizeof(PCI_COMMON_CONFIG));

        }
      }
    }
  }
}

BOOLEAN 
WritePciInformationToScsiChip(PHW_DEVICE_EXTENSION DeviceExtension)

{
  ULONG length;
  ULONG status;
	PCI_COMMON_CONFIG    pciConfig;
  UCHAR chip;

  for(chip = 0; chip < DeviceExtension->ChipCount; ++chip)
  {
    USHORT pciValue;
    ULONG  phyAddress =  MegaRAIDGetPhysicalAddressAsUlong(DeviceExtension, 
														                       NULL, 
														                       &DeviceExtension->NoncachedExtension->AmiLogicConfig[chip], 
														                       (PULONG)&length);

    MegaRAIDZeroMemory((PUCHAR)&pciConfig, sizeof(PCI_COMMON_CONFIG));

    status = HalGetBusData(PCIConfiguration, 
										     DeviceExtension->AmiSystemIoBusNumber,
										     DeviceExtension->AmiSlotNumber[chip],
												(PVOID)&pciConfig,
												PCI_COMMON_HDR_LENGTH);

    DebugPrint((0, "\nSTATUS OF HalGetBusData -> %x", status));
    DebugPrint((0, "\nAmiLogic -> PCIConfig Read"));
    DumpPCIConfigSpace(&pciConfig);
    
    DebugPrint((0, "\nAmiLogic -> PCIConfig Writing.."));
    DumpPCIConfigSpace(&DeviceExtension->NoncachedExtension->AmiLogicConfig[chip]);

    status = HalSetBusData(PCIConfiguration, 
										           DeviceExtension->AmiSystemIoBusNumber,
										           DeviceExtension->AmiSlotNumber[chip],
                               &DeviceExtension->NoncachedExtension->AmiLogicConfig[chip],
                               PCI_COMMON_HDR_LENGTH);

    DebugPrint((0, "\nSTATUS OF HalSetBusData -> %x", status));

    MegaRAIDZeroMemory((PUCHAR)&pciConfig, sizeof(PCI_COMMON_CONFIG));

    status = HalGetBusData(PCIConfiguration, 
										     DeviceExtension->AmiSystemIoBusNumber,
										     DeviceExtension->AmiSlotNumber[chip],
												(PVOID)&pciConfig,
												PCI_COMMON_HDR_LENGTH);

    DebugPrint((0, "\nSTATUS OF HalGetBusData -> %x", status));
    DebugPrint((0, "\nAmiLogic -> PCIConfig Read after Write"));
    DumpPCIConfigSpace(&pciConfig);
  }

  return TRUE;
}

BOOLEAN 
WritePciDecBridgeInformation(PHW_DEVICE_EXTENSION DeviceExtension)

{
  
	PCI_COMMON_CONFIG    pciConfig;
  PUCHAR               pointer;
  ULONG status;
  UCHAR fourtyHex = 0x10;
  UCHAR fourtyHexGet;
  ULONG length;
  
  MegaRAIDZeroMemory((PUCHAR)&pciConfig, sizeof(PCI_COMMON_CONFIG));


  
  status = HalGetBusData(PCIConfiguration, 
										     DeviceExtension->Dec2SystemIoBusNumber,
										     DeviceExtension->Dec2SlotNumber,
                         &pciConfig,
                         PCI_COMMON_HDR_LENGTH);

  DebugPrint((0, "\nSTATUS OF HalGetBusData -> %x", status));
  DebugPrint((0, "\nDEC Bridge  -> GET PCIConfig"));
  DumpPCIConfigSpace(&pciConfig);

  pointer = (PUCHAR)&pciConfig;

  DebugPrint((0, "\nDEC BRIDGE 0x40 -> %0X", *(pointer + 0x40)));

  status = HalSetBusDataByOffset(PCIConfiguration, 
										     DeviceExtension->Dec2SystemIoBusNumber,
										     DeviceExtension->Dec2SlotNumber,
												 &fourtyHex,
												 0x40,
                         sizeof(UCHAR));

  DebugPrint((0, "\nSTATUS OF HalSetBusDataByOffset -> %x", status));

  status = HalGetBusDataByOffset(PCIConfiguration, 
										     DeviceExtension->Dec2SystemIoBusNumber,
										     DeviceExtension->Dec2SlotNumber,
												 &fourtyHexGet,
												 0x40,
                         sizeof(UCHAR));

  DebugPrint((0, "\nSTATUS OF HalGetBusDataByOffset -> %x Value -> %0X", status, fourtyHexGet));


  {
    USHORT pciValue;
    ULONG  phyAddress =  MegaRAIDGetPhysicalAddressAsUlong(DeviceExtension, 
														                       NULL, 
														                       &DeviceExtension->NoncachedExtension->BiosStartupInfo, 
														                       (PULONG)&length);

    status = HalSetBusDataByOffset(PCIConfiguration, 
										           DeviceExtension->SystemIoBusNumber,
										           DeviceExtension->SlotNumber,
                               &phyAddress,
                               MEGARAID_PROTOCOL_PORT_0xA0,
                               sizeof(ULONG));

    pciValue = BIOS_STARTUP_PROTOCOL_NEXT_STRUCTURE_READY;

    status = HalSetBusDataByOffset(PCIConfiguration, 
										           DeviceExtension->SystemIoBusNumber,
										           DeviceExtension->SlotNumber,
                               &pciValue,
                               MEGARAID_PROTOCOL_PORT_0x64,
                               sizeof(USHORT));

    do{
    
      pciValue = 0;
      status = HalGetBusDataByOffset(PCIConfiguration, 
										           DeviceExtension->SystemIoBusNumber,
										           DeviceExtension->SlotNumber,
                               &pciValue,
                               MEGARAID_PROTOCOL_PORT_0x64,
                               sizeof(USHORT));
    }while(pciValue == BIOS_STARTUP_PROTOCOL_NEXT_STRUCTURE_READY);
  

    pciValue = BIOS_STARTUP_PROTOCOL_END_OF_BIOS_STRUCTURES;

    status = HalSetBusDataByOffset(PCIConfiguration, 
										           DeviceExtension->SystemIoBusNumber,
										           DeviceExtension->SlotNumber,
                               &pciValue,
                               MEGARAID_PROTOCOL_PORT_0x64,
                               sizeof(USHORT));

    do{
      pciValue = 0;
      status = HalGetBusDataByOffset(PCIConfiguration, 
										           DeviceExtension->SystemIoBusNumber,
										           DeviceExtension->SlotNumber,
                               &pciValue,
                               MEGARAID_PROTOCOL_PORT_0x64,
                               sizeof(USHORT));
    }while(pciValue == BIOS_STARTUP_PROTOCOL_END_OF_BIOS_STRUCTURES);


    if(pciValue != BIOS_STARTUP_PROTOCOL_FIRMWARE_DONE_SUCCESFUL)
    {
      DebugPrint((0, "\n Firmware is not able to initialize properly for HOTPLUG"));
		  return FALSE;
    }
    else
    {
      DebugPrint((0, "\n Firmware is initialized properly for HOTPLUG"));
    }
    {
      #define BIOS_STARTUP_HANDSHAKE 0x9C
      UCHAR  handShake;
      
      DebugPrint((0, "\nWaiting for Firmware... "));
      do{
        handShake = 0;
        status = HalGetBusDataByOffset(PCIConfiguration, 
										             DeviceExtension->SystemIoBusNumber,
										             DeviceExtension->SlotNumber,
                                 &handShake,
                                 BIOS_STARTUP_HANDSHAKE,
                                 sizeof(UCHAR));
      }while(handShake != BIOS_STARTUP_HANDSHAKE);

      DebugPrint((0, "\nFirmware Active Now... "));
    }

  }


  return TRUE;

}

void 
DumpPCIConfigSpace(PPCI_COMMON_CONFIG PciConfig)
{
  int i,j;
  PULONG pci = (PULONG)PciConfig;

  for(j=0; j < sizeof(PCI_COMMON_CONFIG)/16; ++j)
  {
    DebugPrint((0, "\n"));
    for(i=0; i < 4; ++i)
      DebugPrint((0, " %08X", *(pci+i+j*16)));
  }
}
#endif


void
FillOemProductID(PINQUIRYDATA Inquiry, USHORT SubSystemDeviceID, USHORT SubSystemVendorID)
{
  PUCHAR product;
  switch(SubSystemVendorID)
  {
  case SUBSYSTEM_VENDOR_HP:
    product = (PUCHAR)OEM_PRODUCT_HP;
    break;
  case SUBSYSTEM_VENDOR_DELL:
  case SUBSYSTEM_VENDOR_EP_DELL:
    product = (PUCHAR)OEM_PRODUCT_DELL;
    break;
  case SUBSYSTEM_VENDOR_AMI:     
        product = (PUCHAR)OEM_PRODUCT_AMI;
  default:
        product = (PUCHAR)OEM_PRODUCT_AMI;
  }
  if(SubSystemDeviceID == OLD_DELL_DEVICE_ID)
    product = (PUCHAR)OEM_PRODUCT_DELL;



  ScsiPortMoveMemory((void*)Inquiry->ProductId, (void*)product, 16);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\port\scsi\miniport\megaraid\megaraid6.c ===
/*******************************************************************/
/*                                                                 */
/* NAME             = MegaRaid6.C                                  */
/* FUNCTION         = Main Miniport Source file for Windows 2000;  */
/* NOTES            =                                              */
/* DATE             = 02-03-2000                                   */
/* HISTORY          = 001, 02-03-00, Parag Ranjan Maharana;        */
/* COPYRIGHT        = LSI Logic Corporation. All rights reserved;  */
/*                                                                 */
/*******************************************************************/


#include "includes.h"




//
// Toshiba SFR related global data 
//
#define MAX_CONTROLLERS 24

PHW_DEVICE_EXTENSION    GlobalHwDeviceExtension[MAX_CONTROLLERS];

UCHAR		GlobalAdapterCount = 0;

//
//Logical Drive Info struct (global)
//
LOGICAL_DRIVE_INFO  gLDIArray;
UCHAR               globalHostAdapterOrdinalNumber =0;

#ifdef AMILOGIC
SCANCONTEXT GlobalScanContext;
#endif

typedef struct _MEGARAID_CONTROLLER_INFORMATION {
    UCHAR   VendorId[4];
    UCHAR   DeviceId[4];
} MEGARAID_CONTROLLER_INFORMATION, *PMEGARAID_CONTROLLER_INFORMATION;

MEGARAID_CONTROLLER_INFORMATION MegaRaidAdapters[] = {
    {"8086", "9060"},
    {"8086", "9010"},
    {"8086", "1960"},
    {"101E", "1960"},
    {"1028", "000E"},
		{"1000", "1960"}
};


//
// Function prototypes
//
	
SCSI_ADAPTER_CONTROL_STATUS 
MegaRAIDPnPControl(
  IN PVOID HwDeviceExtension,
  IN SCSI_ADAPTER_CONTROL_TYPE ControlType,
  IN PVOID Parameters);

#ifdef PDEBUG
	PUCHAR                dbgport;
	UCHAR                 debugport_init = 0;
	
	#define OUT_80(a)     ScsiPortWritePortUchar(dbgport,a)
#endif


  /*********************************************************************
Routine Description:
	Calls Scsiport Initialize For All Supported MegaRAIDs
  Installable driver initialization entry point for system
Arguments:
	Driver Object Argument2

Return Value:
	Status from ScsiPortInitialize()
**********************************************************************/
ULONG32
DriverEntry(
  IN PVOID DriverObject,
	IN PVOID Argument2)
{
	HW_INITIALIZATION_DATA  hwInitializationData;
	ULONG32   type, val=0;
	ULONG32   retVal=-1;

	//
  //initialize the global array
  //
  gLDIArray.HostAdapterNumber = 0xFF;
  gLDIArray.LogicalDriveNumber = 0xFF;

  //
  // Zero out structure.
  //
  MegaRAIDZeroMemory((PUCHAR)&hwInitializationData, sizeof(HW_INITIALIZATION_DATA));

  //
  // Set size of hwInitializationData.
  //
  hwInitializationData.HwInitializationDataSize=sizeof(HW_INITIALIZATION_DATA);

  //
  // Set entry points.
  //
  hwInitializationData.HwInitialize          = MegaRAIDInitialize;
  hwInitializationData.HwFindAdapter         = MegaRAIDFindAdapter;
  hwInitializationData.HwStartIo             = MegaRAIDStartIo;
  hwInitializationData.HwInterrupt           = MegaRAIDInterrupt;
  hwInitializationData.HwResetBus            = MegaRAIDResetBus;
  hwInitializationData.HwAdapterControl      = MegaRAIDPnPControl;

  //
  // Set Access ranges and bus type.
  //
  hwInitializationData.NumberOfAccessRanges  = 1;
  hwInitializationData.AdapterInterfaceType  = PCIBus;

  //
  // Indicate buffer mapping is required.
  // Indicate need physical addresses is required.
  //
  hwInitializationData.MapBuffers            = TRUE;
  hwInitializationData.NeedPhysicalAddresses = TRUE;
  hwInitializationData.TaggedQueuing         = TRUE;

  //
  // Indicate we support auto request sense and multiple requests per device.
  //
  hwInitializationData.MultipleRequestPerLu  = TRUE;
  hwInitializationData.AutoRequestSense      = TRUE;

  //
  // Specify size of extensions.
  //
  hwInitializationData.DeviceExtensionSize   = sizeof(HW_DEVICE_EXTENSION);
  hwInitializationData.SrbExtensionSize      = sizeof(MegaSrbExtension);

  //////////////////////////////////////////////////////////
	DebugPrint((0, "NONCACHED_EXTENSION Size = %d\n", sizeof(NONCACHED_EXTENSION)));
  DebugPrint((0, "HW_DEVICE_EXTENSION Size = %d\n", sizeof(HW_DEVICE_EXTENSION)));
  //////////////////////////////////////////////////////////

  DebugPrint((0, "\nLoading %s Version %s ", (char*)VER_INTERNALNAME_STR, (char*)VER_PRODUCTVERSION_STR));

  //
  // Set the PCI Vendor ,Device Id and related parameters.
  //
  hwInitializationData.DeviceIdLength        = 4;
  hwInitializationData.VendorIdLength        = 4;

  for(type = 0; type < sizeof(MegaRaidAdapters)/sizeof(MEGARAID_CONTROLLER_INFORMATION); ++type)
  {
    hwInitializationData.VendorId = MegaRaidAdapters[type].VendorId;
    hwInitializationData.DeviceId = MegaRaidAdapters[type].DeviceId;
    
    val = ScsiPortInitialize(DriverObject,Argument2, &hwInitializationData, NULL);

    DebugPrint((0, "\n Vendor ID =%s, Device ID = %s, return value1 %d\n", hwInitializationData.VendorId, hwInitializationData.DeviceId, val));

    if(retVal > val)
    {
      retVal = val;
    }
  }

  return retVal;

} // end DriverEntry()



/*********************************************************************
Routine Description:
	This function is called by the OS-specific port driver after
	the necessary storage has been allocated, to gather information
	about the adapter's configuration.

Arguments:
	HwDeviceExtension - HBA miniport driver's adapter data storage
	BusInformation		- NULL
	Context           - NULL 
	ConfigInfo        - Configuration information structure describing HBA

Return Value:
	SP_RETURN_FOUND 		- Adapter Found
	SP_RETURN_NOT_FOUND 	- Adapter Not Present
	SP_RETURN_ERROR		- Error Occurred
**********************************************************************/
ULONG32
MegaRAIDFindAdapter(
	IN PVOID HwDeviceExtension,
	IN PVOID Context,
	IN PVOID BusInformation,
	IN PCHAR ArgumentString,
	IN OUT PPORT_CONFIGURATION_INFORMATION ConfigInfo,
	OUT PBOOLEAN Again)
{
	PHW_DEVICE_EXTENSION deviceExtension = HwDeviceExtension;
	PCI_COMMON_CONFIG    pciConfig;
	PUCHAR               pciPortStart;
	ULONG32              baseport;
	ULONG32              length;
	UCHAR                megastatus;
	ULONG32              status;
	UCHAR                rpFlag=0;
	FW_MBOX              mbox;
	PUSHORT              rpBoardSignature;
	PNONCACHED_EXTENSION noncachedExtension;
  UCHAR                busNumber;
  ULONG32              noncachedExtensionLength;
  BOOLEAN              addressing64Bit = FALSE; //By Default 64bit is disable

  DebugPrint((0, "\nMegaRAIDFindAdapter : Entering ..."));
	*Again = FALSE;

  
	status = ScsiPortGetBusData(deviceExtension,
                              PCIConfiguration, 
			                        ConfigInfo->SystemIoBusNumber,
                              ConfigInfo->SlotNumber,
			                        (PVOID)&pciConfig,
                              PCI_CONFIG_LENGTH_TO_READ);

  rpBoardSignature = (PUSHORT)((PUCHAR)&pciConfig + MRAID_RP_BOARD_SIGNATURE_OFFSET);
	if((*rpBoardSignature == MRAID_RP_BOARD_SIGNATURE)
    || (*rpBoardSignature == MRAID_RP_BOARD_SIGNATURE2)) 
	{
		PULONG rpBoard64bitSupport;
    // 
		// 438 Series
		//
    rpFlag = MRAID_RP_BOARD;
    DebugPrint((0, "\n Found RP Processor Vendor ID [%x] Device ID [%x]\n", pciConfig.VendorID, pciConfig.DeviceID));
    DebugPrint((0, "\n Memory Mapped Address High 0x%X Low 0x%X Length 0x%X",
                (*ConfigInfo->AccessRanges)[0].RangeStart.HighPart,
                (*ConfigInfo->AccessRanges)[0].RangeStart.LowPart,
                (*ConfigInfo->AccessRanges)[0].RangeLength));
		baseport = (*ConfigInfo->AccessRanges)[0].RangeStart.LowPart;
    //baseport = (ULONG32)pciConfig.u.type0.BaseAddresses[0];
		baseport = baseport & 0xfffff000;

    //
    //Check Controller supports 64 bit SGL
    //
		rpBoard64bitSupport = (PULONG)((PUCHAR)&pciConfig + MRAID_PAE_SUPPORT_SIGNATURE_OFFSET);
  	if (*rpBoard64bitSupport == MRAID_PAE_SUPPORT_SIGNATURE_LHC) 
    {
      DebugPrint((0, "\nPAE Supported by Fw with LowHighCount format"));
      addressing64Bit = TRUE;
    }
  	else if (*rpBoard64bitSupport == MRAID_PAE_SUPPORT_SIGNATURE_HLC) 
    {
      DebugPrint((0, "\nPAE Supported by Fw with HighLowCount format"));
      //addressing64Bit = TRUE;
    }
    //Default Setting depending on Controller type (which almost correct expect 40LD for 467)
    if(*rpBoardSignature == MRAID_RP_BOARD_SIGNATURE2)    
      deviceExtension->SupportedLogicalDriveCount = MAX_LOGICAL_DRIVES_40;
    else
      deviceExtension->SupportedLogicalDriveCount = MAX_LOGICAL_DRIVES_8;

	}
  else if(((pciConfig.VendorID == MRAID_VENDOR_ID) && (pciConfig.DeviceID == MRAID_DEVICE_9010)) ||
           ((pciConfig.VendorID == MRAID_VENDOR_ID) && (pciConfig.DeviceID == MRAID_DEVICE_9060)))
	{
		baseport = (*ConfigInfo->AccessRanges)[0].RangeStart.LowPart;
    rpFlag = MRAID_NONRP_BOARD;
    DebugPrint((0, "\n Found None RP Processor Vendor ID [%x] Device ID [%x]\n", pciConfig.VendorID, pciConfig.DeviceID));
    deviceExtension->SupportedLogicalDriveCount = MAX_LOGICAL_DRIVES_8;
	}
  else //All PCI-X (Verdi) Controller (does not have controller check)
  {
    rpFlag = MRAID_RP_BOARD;
    DebugPrint((0, "\n Found PCI\\VEN_%x&DEV_%xSUBSYS%04X%04X\n", pciConfig.VendorID, pciConfig.DeviceID, pciConfig.u.type0.SubSystemID, pciConfig.u.type0.SubVendorID));
    baseport = (*ConfigInfo->AccessRanges)[0].RangeStart.LowPart;
	  baseport = baseport & 0xfffff000;

    //
    //Check Controller supports 64 bit SGL
    //
    addressing64Bit = TRUE;
    deviceExtension->SupportedLogicalDriveCount = MAX_LOGICAL_DRIVES_40;
  }

  //Saving BAR Register
  deviceExtension->BaseAddressRegister.QuadPart = (*ConfigInfo->AccessRanges)[0].RangeStart.QuadPart;
  //
  //Saving the System IDs. SubSystemVendorID is needed for filling
  //INQUIRY string for SCSIOP_INQUIRY calls
  //
	deviceExtension->SubSystemDeviceID = pciConfig.u.type0.SubSystemID;
	deviceExtension->SubSystenVendorID = pciConfig.u.type0.SubVendorID;
  deviceExtension->SlotNumber = ConfigInfo->SlotNumber;
  deviceExtension->SystemIoBusNumber = ConfigInfo->SystemIoBusNumber;

  DebugPrint((0, "\nSubSystemDeviceID = %X SubSystemVendorID = %X", pciConfig.u.type0.SubSystemID, pciConfig.u.type0.SubVendorID));



  //Check If the controller is already claimed by any other driver or
  //another instance of our driver
  if(ScsiPortValidateRange(deviceExtension,
                           PCIBus,
                           ConfigInfo->SystemIoBusNumber,
                           (*ConfigInfo->AccessRanges)[0].RangeStart,
                           (*ConfigInfo->AccessRanges)[0].RangeLength,
                           (BOOLEAN)((rpFlag == MRAID_NONRP_BOARD) ? TRUE : FALSE)  
                            ) == FALSE)
  {
    DebugPrint((0, "\nDevice is already claimed by another driver, return SP_RETURN_NOT_FOUND"));
    return SP_RETURN_NOT_FOUND;
  }



  //
	// Get the system address for this card.
	// The card uses I/O space.
	//
	if (rpFlag)
	{
		if (baseport)
		{
			pciPortStart = ScsiPortGetDeviceBase(deviceExtension,
				ConfigInfo->AdapterInterfaceType,
				ConfigInfo->SystemIoBusNumber,
				ScsiPortConvertUlongToPhysicalAddress((ULONG32)baseport),
        /*(*ConfigInfo->AccessRanges)[0].RangeLength*/ 0x2000, FALSE); 

        //When Memory on Controller is 128MB Scsiport not able to map 128 MB so we 
        //change back to small memory we need to map
		}               
	}
	else
	{
		if (baseport)
		{
			pciPortStart = ScsiPortGetDeviceBase(deviceExtension,
				ConfigInfo->AdapterInterfaceType,
				ConfigInfo->SystemIoBusNumber,
				ScsiPortConvertUlongToPhysicalAddress((ULONG32)baseport),
        /*(*ConfigInfo->AccessRanges)[0].RangeLength*/0x80,TRUE);

        //When Memory on Controller is 128MB Scsiport not able to map 128 MB so we 
        //change back to small memory we need to map
		  if(pciPortStart)
        pciPortStart = pciPortStart + 0x10;
		}
	}
	
	DebugPrint((0, "\nbaseport = %X, PciPortStart = %X", baseport, pciPortStart));

  if(pciPortStart == NULL)
  {
  	DebugPrint((0, "\n****FAILED TO MAP DEVICE BASE***** FATAL ERROR"));
    return SP_RETURN_ERROR;
  }
	
  deviceExtension->AdapterIndex = GlobalAdapterCount;

  //Initialize the failed id
  deviceExtension->Failed.PathId = 0xFF;
  deviceExtension->Failed.TargetId = 0xFF;

	
  //
	// Update The Global Device Extension Information
	//
	GlobalHwDeviceExtension[GlobalAdapterCount] = deviceExtension;
	GlobalAdapterCount++;
	
/////////////////////////DOING FOR TESTING////////////////////////////
  deviceExtension->MaximumTransferLength = DEFAULT_TRANSFER_LENGTH;
  //
  // We support upto 26 elements but 16 seems to work optimal. This parameter
  // is also subject to change.
  //
  deviceExtension->NumberOfPhysicalBreaks = DEFAULT_SGL_DESCRIPTORS;

  deviceExtension->NumberOfPhysicalChannels = 2;
	
  ConfigInfo->MaximumTransferLength  = deviceExtension->MaximumTransferLength;
  ConfigInfo->NumberOfPhysicalBreaks = deviceExtension->NumberOfPhysicalBreaks;


  /////////////////////////DOING FOR TESTING////////////////////////////
	if(rpFlag == MRAID_RP_BOARD)
	{
		status = ScsiPortReadRegisterUlong((PULONG)(pciPortStart+OUTBOUND_DOORBELL_REG));
		ScsiPortWriteRegisterUlong((PULONG)(pciPortStart+OUTBOUND_DOORBELL_REG), status);
	}

  //
	// SGather Supported.
	//
	ConfigInfo->ScatterGather = TRUE;

  //
	// Bus Mastering Controller
	//
	ConfigInfo->Master = TRUE;
	
  //
	// CACHING Controller.
	//
	ConfigInfo->CachesData = TRUE;

  if((ConfigInfo->Dma64BitAddresses & SCSI_DMA64_SYSTEM_SUPPORTED)
    && (addressing64Bit == TRUE))
  {
    //Set the flag for 64 bit access
    deviceExtension->LargeMemoryAccess = TRUE;

    //
	  // Enable 64bit DMA Capable Controller
	  //
    ConfigInfo->Dma64BitAddresses = SCSI_DMA64_MINIPORT_SUPPORTED;

    //
	  // Disable 32bit DMA Capable Controller
	  //
    ConfigInfo->Dma32BitAddresses = FALSE; 
    DebugPrint((0, "\nMegaRAIDFindAdapter::Dma64BitAddresses Enabled"));
  }
  else
  {
    deviceExtension->LargeMemoryAccess = FALSE;
	  
    //
	  //Enable 32bit DMA Capable Controller
	  //
    ConfigInfo->Dma32BitAddresses = TRUE; 
    DebugPrint((0, "\nMegaRAIDFindAdapter::Dma64BitAddresses Disabled"));
  }

  
  //
	// We support upto 100 cache lines per command so we can support 
	// stripe size * 100. For ex. on a 64k stripe size we will support 6.4 MB
	// per command. But we have seen that with 0xf000 bytes per request NT gives
	// the peak performance. This parameter is subject to change in future 
	// release.
	//
	//ConfigInfo->MaximumTransferLength = MAXIMUM_TRANSFER_LENGTH; 

	//
	// We support upto 26 elements but 16 seems to work optimal. This parameter 
	// is also subject to change.
	//
   //ConfigInfo->NumberOfPhysicalBreaks = MAXIMUM_SGL_DESCRIPTORS;
  ConfigInfo->NumberOfBuses = 3;
  ConfigInfo->InitiatorBusId[0] = 0xB;
  ConfigInfo->InitiatorBusId[1] = 0xB;
  ConfigInfo->InitiatorBusId[2] = 0xB;

  ////////////////////////////////////////////////////////////////////////
	// Allocate a Noncached Extension to use for mail boxes.
	////////////////////////////////////////////////////////////////////////
	noncachedExtension = NULL;
  deviceExtension->CrashDumpRunning = FALSE;

	noncachedExtension = ScsiPortGetUncachedExtension(deviceExtension, ConfigInfo, sizeof(NONCACHED_EXTENSION) + 4);
  
	//
	// Check if memory allocation is successful.
	//
  if(noncachedExtension == NULL)
  {
  	DebugPrint((0, "\n NONCACHED MEMORY ALLOCATION IS FAILED for size = %d", sizeof(NONCACHED_EXTENSION) + 4));
    noncachedExtension = ScsiPortGetUncachedExtension(deviceExtension, ConfigInfo, sizeof(CRASHDUMP_NONCACHED_EXTENSION) + 4);
    if(noncachedExtension)
      deviceExtension->CrashDumpRunning = TRUE;

  }

	//
	// Check if memory allocation is successful.
	//
  if(noncachedExtension == NULL)
  {
  	DebugPrint((0, "\n CRASHDUMP NONCACHED MEMORY ALLOCATION IS FAILED for size = %d", sizeof(CRASHDUMP_NONCACHED_EXTENSION) + 4));
    return SP_RETURN_ERROR;
  }

	noncachedExtensionLength = MegaRAIDGetPhysicalAddressAsUlong(deviceExtension, NULL, (PVOID)noncachedExtension, &length);
	
  noncachedExtensionLength = noncachedExtensionLength % 4;
	
  deviceExtension->NoncachedExtension = 
    (PNONCACHED_EXTENSION)((PUCHAR)noncachedExtension + 4 - noncachedExtensionLength); //align on 4 byte boundary

	//
	// Check if memory allocation is successful.
	//
	if(deviceExtension->NoncachedExtension == NULL) 
  {
    DebugPrint((0, "\n****ERROR - NOT ABLE TO ALLCOATE NONCACHED EXTENSION - ERROR****"));
		return(SP_RETURN_ERROR);
  }

  //
  //initialize the NONCACHED_EXTENSION
  //
  if(deviceExtension->CrashDumpRunning == TRUE)
		MegaRAIDZeroMemory(deviceExtension->NoncachedExtension, sizeof(CRASHDUMP_NONCACHED_EXTENSION));
	else
		MegaRAIDZeroMemory(deviceExtension->NoncachedExtension, sizeof(NONCACHED_EXTENSION));

  DebugPrint((0, "\n SIZE OF NONCACHED EXTENSION %d", sizeof(NONCACHED_EXTENSION)+4));

 	noncachedExtension = deviceExtension->NoncachedExtension;
  //////////////////////////////////////////////////////////////////
  //END OF ALLOCATION of NonCachedExtension
  //////////////////////////////////////////////////////////////////



  //
  //Save the BOARD TYPE info in NoncachedExtension
  //
	noncachedExtension->RPBoard = rpFlag;
	//
	// save  Baseport in the device extension.
	//
	deviceExtension->PciPortStart = pciPortStart;

  deviceExtension->NoncachedExtension->PhysicalBufferAddress =
     ScsiPortConvertPhysicalAddressToUlong(ScsiPortGetPhysicalAddress(deviceExtension,
                                                NULL,
                                                deviceExtension->NoncachedExtension->Buffer,
                                                &length));

  //Store the MAILBOX's Physical Address
	deviceExtension->PhysicalAddressOfMailBox = MegaRAIDGetPhysicalAddressAsUlong(deviceExtension, 
												                                                        NULL, 
												                                                        (PVOID)&(noncachedExtension->fw_mbox.Command), 
												                                                        &length);



  //
	// We work in polled mode for Init, so disable Interrupts.
	//
	if (noncachedExtension->RPBoard == 0)
		ScsiPortWritePortUchar(pciPortStart+INT_ENABLE, 
										MRAID_DISABLE_INTERRUPTS);


  
#ifdef AMILOGIC
  DebugPrint((0, "\nScanning DEC BRIDGE ..."));
  ScanDECBridge(deviceExtension, deviceExtension->SystemIoBusNumber, &GlobalScanContext);
  DebugPrint((0, "\nScanning DEC BRIDGE Completed"));
#endif
  
 
	DebugPrint((0, "\nFiring Sync\n"));

  if(SendSyncCommand(deviceExtension))
  {
	  ///////////////////////////////////////////////////////////////////////
	  //Get the Supported Scatter Gather Element count from the firmware and
	  //Appropriately set the MaximumTransferLength & PhysicalNumberOfBreaks
	  //in the deviceExtension data structure
    ///////////////////////////////////////////////////////////////////////
    DebugPrint((0, "\nDefault Max Transfer Length %d KBytes, Default Max Physical Breaks %d", deviceExtension->MaximumTransferLength/1024, deviceExtension->NumberOfPhysicalBreaks));
	  
    DebugPrint((0, "\nCALLING : GetAndSetSupportedScatterGatherElementCount"));

	  GetAndSetSupportedScatterGatherElementCount(deviceExtension, pciPortStart, rpFlag);

	  ConfigInfo->MaximumTransferLength  = deviceExtension->MaximumTransferLength;

    ConfigInfo->NumberOfPhysicalBreaks = deviceExtension->NumberOfPhysicalBreaks;
  
    DebugPrint((0, "\nMax Transfer Length %d KBytes, Max Physical Breaks %d", deviceExtension->MaximumTransferLength/1024, deviceExtension->NumberOfPhysicalBreaks));  //////////////////////////////////////////////////////////////////
  
	  //get the supported logical drive count from the firmware
	  //The value is set in the field
	  //		SupportedLogicalDriveCount of deviceExtension
    //////////////////////////////////////////////////////////////////
	  
    DebugPrint((0, "\nCALLING : GetSupportedLogicalDriveCount"));
	  if( !GetSupportedLogicalDriveCount(deviceExtension) )
	  {
		  //
		  //command failed for some reason or the other.we couldnot
		  //determine whether the firmware supports 8 or 40 logical
		  //drives. Under this condition, there is no way of proceeding
		  //further.
		  //
		  return(SP_RETURN_ERROR);
	  }

    DebugPrint((0, "\nSupportedLogicalDriveCount %d LD", deviceExtension->SupportedLogicalDriveCount == MAX_LOGICAL_DRIVES_8 ? 8 : 40));
    ///////////////////////////////////////////////////////////////////////////
    //For New Mapping make number of buses equal to number of physical channel 
    //plus one. This addition bus is used for Logical configurated drives.
    ///////////////////////////////////////////////////////////////////////////
 	  deviceExtension->NumberOfPhysicalChannels = GetNumberOfChannel(deviceExtension);
  
    ConfigInfo->NumberOfBuses = deviceExtension->NumberOfPhysicalChannels + 2;
  
    DebugPrint((0, "\nQuery And Set Number of Buses = %d", ConfigInfo->NumberOfBuses));

    deviceExtension->NumberOfDedicatedLogicalDrives = 0;  //Default value
    deviceExtension->NumberOfDedicatedLogicalDrives = GetNumberOfDedicatedLogicalDrives(deviceExtension);
  
    DebugPrint((0, "\nNumber Of Dedicated LogicalDrives %d ", deviceExtension->NumberOfDedicatedLogicalDrives));

    ///////////////////////////////////////////////////////////////////////////
	  // Get The Initiator Id  
    ///////////////////////////////////////////////////////////////////////////
	  // Fill the Mailbox.
	  //
    //Initialize MAILBOX
	  MegaRAIDZeroMemory(&mbox, sizeof(FW_MBOX));

    mbox.Command   = MRAID_FIND_INITIATORID;
	  mbox.CommandId = 0xFE;
	  //
	  //get the physical address of the enquiry3 data structure
	  //
	  mbox.u.Flat2.DataTransferAddress = MegaRAIDGetPhysicalAddressAsUlong(deviceExtension, 
														                         NULL, 
														                         noncachedExtension->Buffer, 
														                         (PULONG)&length);
    if(length < sizeof(UCHAR)) 
    {
      DebugPrint((0, "\n **** ERROR Buffer Length is less than 1 byte, ERROR ****"));
		  //return(SP_RETURN_ERROR);
    }
	  
  
    deviceExtension->NoncachedExtension->fw_mbox.Status.CommandStatus = 0;
    deviceExtension->NoncachedExtension->fw_mbox.Status.NumberOfCompletedCommands = 0;
	  SendMBoxToFirmware(deviceExtension, pciPortStart, &mbox);
	  //
	  // Poll for completion for 60 seconds.
	  //
	  if(WaitAndPoll(noncachedExtension, pciPortStart, SIXITY_SECONDS_TIMEOUT, TRUE) == FALSE)
    {
		  //
		  // Check for timeout. Return Failure for timeout.
		  //
		  DebugPrint((0, "MegaRAIDFindAdapter: Get InitiatorId Failed\n"));
		  return(SP_RETURN_ERROR);
	  }
  
	  megastatus = deviceExtension->NoncachedExtension->fw_mbox.Status.CommandStatus;
  }
  else
  {
    megastatus = 1; //ERROR 

  }
  

	if (!megastatus)
		deviceExtension->HostTargetId = noncachedExtension->Buffer[0];
	else
		deviceExtension->HostTargetId = DEFAULT_INITIATOR_ID;

  //
	//Report proper initiator id to OS
  //
  for(busNumber = 0; busNumber < ConfigInfo->NumberOfBuses; ++busNumber)
	  ConfigInfo->InitiatorBusId[busNumber] = deviceExtension->HostTargetId;

  DebugPrint((0, "\nMegaRAIDFindAdapter::Initiator ID = 0x%x\n",deviceExtension->HostTargetId));

  //
	// Supports Wide Devices
	//
	ConfigInfo->MaximumNumberOfTargets = MAX_TARGETS_PER_CHANNEL;

  //
  //Supports Max. LUNs
  //
  ConfigInfo->MaximumNumberOfLogicalUnits = MAX_LUN_PER_TARGET;
  DebugPrint((0, "\nMegaRAIDFindAdapter : Exiting ..."));

	*Again = TRUE;
	return SP_RETURN_FOUND;
} // end MegaRAIDFindAdapter()





/*********************************************************************
Routine Description:
	Start up conventional MRAID command

Return Value:
	none
**********************************************************************/
BOOLEAN
SendMBoxToFirmware(
	IN PHW_DEVICE_EXTENSION DeviceExtension,
	IN PUCHAR PciPortStart,
	IN PFW_MBOX Mbox
	)
{
	PUCHAR  pSrcMbox, pDestMbox;
	ULONG32   count;
  ULONG32   length;
  ULONG32   mboxAddress;
  ULONG32   delay = (DeviceExtension->AssociatedSrbStatus == NORMAL_TIMEOUT) ? 0x927C0 : 0x03;


	pSrcMbox = (PUCHAR)Mbox;
	pDestMbox = (PUCHAR)&DeviceExtension->NoncachedExtension->fw_mbox;

#ifdef MRAID_TIMEOUT 
//	Delay Of 1 min
	for (count=0; count<delay; count++)
	{
    //Microsoft fixed for Security reason
		if(!(DeviceExtension->NoncachedExtension->fw_mbox.MailBoxBusyFlag))
			break;
		ScsiPortStallExecution(100);
	}
	if (count == delay)
	{
		DebugPrint((0, "\nbusy Byte Not Free"));
    DeviceExtension->AssociatedSrbStatus = ERROR_MAILBOX_BUSY;
		return FALSE;
	}
  DeviceExtension->AssociatedSrbStatus = NORMAL_TIMEOUT;
#else
	while(DeviceExtension->NoncachedExtension->fw_mbox.MailBoxBusyFlag)
  {
			ScsiPortStallExecution(1);
  }
#endif

	//
	// Now the mail box is free 
	//

	//
	//EXTENDED MAILBOX IS NOW PART OF MAILBOX ITSELF TO PROCTECT IT FROM CORRUPTION
	//REF : MS BUG 591773
	//

  if(Mbox->ExtendedMBox.LowAddress || Mbox->ExtendedMBox.HighAddress)
	  ScsiPortMoveMemory(pDestMbox, pSrcMbox, sizeof(ULONG)*6);
  else
	  ScsiPortMoveMemory((pDestMbox+sizeof(EXTENDED_MBOX)), (pSrcMbox+sizeof(EXTENDED_MBOX)), sizeof(ULONG)*4);

	DeviceExtension->NoncachedExtension->fw_mbox.MailBoxBusyFlag = 1;

	mboxAddress = DeviceExtension->PhysicalAddressOfMailBox;

	if(DeviceExtension->NoncachedExtension->RPBoard == MRAID_RP_BOARD)
	{
		mboxAddress = mboxAddress | 0x1;
		ScsiPortWriteRegisterUlong((PULONG)(PciPortStart+INBOUND_DOORBELL_REG), mboxAddress);
	}
	else
	{
		ScsiPortWritePortUchar(PciPortStart+4, (UCHAR)(mboxAddress & 0xff));
		ScsiPortWritePortUchar(PciPortStart+5, (UCHAR)((mboxAddress >> 8) & 0xff));
		ScsiPortWritePortUchar(PciPortStart+6, (UCHAR)((mboxAddress >> 16) & 0xff));
		ScsiPortWritePortUchar(PciPortStart+7, (UCHAR)((mboxAddress >> 24) & 0xff));
		ScsiPortWritePortUchar(PciPortStart, 0x10);
	}
	return TRUE;
}


/*********************************************************************
Routine Description:
	Provides the PnP Support

Arguments:
	HwDeviceExtension - HBA miniport driver's adapter data storage
	ControlType - Action Code
	Parameters      - Parameters associated with Control Code

Return Value:
	alwaya ScsiAdapterControlSuccess
**********************************************************************/
SCSI_ADAPTER_CONTROL_STATUS MegaRAIDPnPControl(IN PVOID HwDeviceExtension,
			IN SCSI_ADAPTER_CONTROL_TYPE ControlType,
			IN PVOID Parameters)
{
	PHW_DEVICE_EXTENSION deviceExtension = HwDeviceExtension;
	PUCHAR pciPortStart = deviceExtension->PciPortStart;
	PNONCACHED_EXTENSION noncachedExtension = deviceExtension->NoncachedExtension;
  PSCSI_SUPPORTED_CONTROL_TYPE_LIST controlTypeList = NULL;
	SCSI_ADAPTER_CONTROL_STATUS status = ScsiAdapterControlSuccess;

	switch (ControlType)
	{
		case ScsiQuerySupportedControlTypes:
			{
        controlTypeList = Parameters;
				if(controlTypeList)
				{
  				ULONG32 index = 0;
          BOOLEAN supported[ScsiAdapterControlMax] = 
          {
                    TRUE,       // ScsiQuerySupportedControlTypes
                    TRUE,       // ScsiStopAdapter
                    TRUE,       // ScsiRestartAdapter
                    FALSE,      // ScsiSetBootConfig
                    FALSE       // ScsiSetRunningConfig
          };
          DebugPrint((0, "\n ScsiQuerySupportedControlTypes -> HW_Ext = 0x%X, PCI_START = 0x%X, NonCahced = 0x%X\n", deviceExtension, pciPortStart, noncachedExtension));
          for(index = 0; index < controlTypeList->MaxControlType; ++index)
            controlTypeList->SupportedTypeList[index] = supported[index];
				}
			}
			break;
		case ScsiStopAdapter:
			{
				FW_MBOX mbox;
				UCHAR megastatus;
        UCHAR cmdID = 0;

        DebugPrint((0, "\n ScsiStopAdapter -> HW_Ext = 0x%X, PCI_START = 0x%X, NonCahced = 0x%X\n", deviceExtension, pciPortStart, noncachedExtension));
				//
				// We work in polled mode , so disable Interrupts.
				//
				if (noncachedExtension->RPBoard == 0)
					ScsiPortWritePortUchar(pciPortStart+INT_ENABLE, MRAID_DISABLE_INTERRUPTS);

        if(deviceExtension->IsFirmwareHanging)
          break;
        
	      cmdID = deviceExtension->FreeSlot;
        if(GetFreeCommandID(&cmdID, deviceExtension) == MEGARAID_FAILURE)
				{
					DebugPrint((0, "\nScsiStopAdapter::No Command ID to flush"));
					return (ScsiAdapterControlUnsuccessful);
				}

	      //
	      // Save the next free slot in device extension.
	      //
	      deviceExtension->FreeSlot = cmdID;
        
        MegaRAIDZeroMemory(&mbox, sizeof(FW_MBOX));

				mbox.Command = MRAID_ADAPTER_FLUSH;
				mbox.CommandId = cmdID;
				
        deviceExtension->NoncachedExtension->fw_mbox.Status.CommandStatus = 0;
				
        SendMBoxToFirmware(deviceExtension, pciPortStart, &mbox);
		
				if(WaitAndPoll(deviceExtension->NoncachedExtension, pciPortStart, DEFAULT_TIMEOUT, FALSE) == FALSE)
				{
					DebugPrint((0, "\n ScsiStopAdapter:: failed - TimeOut"));
					return (ScsiAdapterControlUnsuccessful);
				}
				megastatus = deviceExtension->NoncachedExtension->fw_mbox.Status.CommandStatus;

        if(megastatus) //Failure
        {
          DebugPrint((0, "StopAdapter returns Unsuccessful"));
        	return (ScsiAdapterControlUnsuccessful);
        }

        
        ////////////////////NEW CMD ISSUED TO SHUTDOWN i960 Processor
        //
        //This command is supported by the new Firmware only
        //Don't send this command to any legacy controllers
        //
        if((deviceExtension->SubSystemDeviceID == SUBSYTEM_DEVICE_ID_ENTERPRISE1600) || 
          (deviceExtension->SubSystemDeviceID == SUBSYTEM_DEVICE_ID_ELITE1600) || 
          (deviceExtension->SubSystemDeviceID == SUBSYTEM_DEVICE_ID_EXPRESS500) ||
          (deviceExtension->SubSystemDeviceID == SUBSYTEM_DEVICE_ID_1_M) || 
          (deviceExtension->SubSystemDeviceID == SUBSYTEM_DEVICE_ID_2_M))
        {

	        cmdID = deviceExtension->FreeSlot;
          if(GetFreeCommandID(&cmdID, deviceExtension) == MEGARAID_FAILURE)
				  {
					  DebugPrint((0, "\nScsiStopAdapter::No Command ID to flush"));
					  return (ScsiAdapterControlUnsuccessful);
				  }

	        //
	        // Save the next free slot in device extension.
	        //

	        deviceExtension->FreeSlot = cmdID;

          MegaRAIDZeroMemory(&mbox, sizeof(FW_MBOX));

				  mbox.Command = 0xA4;
				  mbox.CommandId = cmdID;
          mbox.u.Flat2.Parameter[0] = 0xCC;
				  
          deviceExtension->NoncachedExtension->fw_mbox.Status.CommandStatus = 0;
				  
          SendMBoxToFirmware(deviceExtension, pciPortStart, &mbox);
		  
				  if(WaitAndPoll(deviceExtension->NoncachedExtension, pciPortStart, DEFAULT_TIMEOUT, FALSE) == FALSE)
				  {
					  DebugPrint((0, "\n ScsiStopAdapter:: failed - TimeOut"));
					  return (ScsiAdapterControlUnsuccessful);
				  }
				  megastatus = deviceExtension->NoncachedExtension->fw_mbox.Status.CommandStatus;
          if(megastatus)
            DebugPrint((0, "\nProcessor Shutdown Returned Status = Unsuccessful"));
          else
            DebugPrint((0, "\nProcessor Shutdown Returned Status = Success"));

          //**************************************************************************
          //Don't consider status of this command as this is a internal command only//
          //If this commands fails, don't send failure to OS
          //if(megastatus) //Failure
					//  return (ScsiAdapterControlUnsuccessful);
          //**************************************************************************
        }

			}
			break;
		case ScsiRestartAdapter:
			{
        ULONG mailboxValue = 0;
        ULONG pcistatus;
        DebugPrint((0, "\n ScsiRestartAdapter -> HW_Ext = 0x%X, PCI_START = 0x%X, NonCahced = 0x%X\n", deviceExtension, pciPortStart, noncachedExtension));

#ifdef AMILOGIC
        if((deviceExtension->SubSystemDeviceID == SUBSYTEM_DEVICE_ID_ENTERPRISE1600) || 
          (deviceExtension->SubSystemDeviceID == SUBSYTEM_DEVICE_ID_ELITE1600) || 
          (deviceExtension->SubSystemDeviceID == SUBSYTEM_DEVICE_ID_EXPRESS500) ||
          (deviceExtension->SubSystemDeviceID == SUBSYTEM_DEVICE_ID_1_M) || 
          (deviceExtension->SubSystemDeviceID == SUBSYTEM_DEVICE_ID_2_M))
        {
          pcistatus = HalGetBusDataByOffset(PCIConfiguration, 
										       deviceExtension->SystemIoBusNumber,
										       deviceExtension->SlotNumber,
												   &mailboxValue,
												   0x64,
                           sizeof(ULONG));
          if(mailboxValue == 0)
          {
            DebugPrint((0, "\nInitialization of Firmware started..."));
        
            if(WritePciInformationToScsiChip(deviceExtension) == FALSE)
            {
              DebugPrint((0, "\nInitialization of Firmware for SCSI Chip finished with Unsuccessful"));
  		        return(SP_RETURN_ERROR);
            }
            DebugPrint((0, "\nInitialization of Firmware for SCSI Chip finished with Successful"));
            if(WritePciDecBridgeInformation(deviceExtension) == FALSE)
            {
              DebugPrint((0, "\nInitialization of Firmware for Dec Bridge finished with Unsuccessful"));
  		        return(SP_RETURN_ERROR);
            }
            DebugPrint((0, "\nInitialization of Firmware for Dec Bridge finished with Successful"));
            ///////////////////////////////////////////////
            DebugPrint((0, "\nInitialization of Firmware finished with successful"));
          }
        }
#endif
        
        //
				// Enable Interrupts.
				//
				if (noncachedExtension->RPBoard == 0)
					ScsiPortWritePortUchar(pciPortStart+INT_ENABLE, MRAID_ENABLE_INTERRUPTS);
				DebugPrint((0, "\n ScsiRestartAdapter:: Enable interrupt"));

        if(deviceExtension->AdapterFlushIssued)
          deviceExtension->AdapterFlushIssued = 0;
      }
			break;
		case ScsiSetBootConfig:
		case ScsiSetRunningConfig:
		default:
      DebugPrint((0, "\n default (error) -> HW_Ext = 0x%X, PCI_START = 0x%X, NonCahced = 0x%X\n", deviceExtension, pciPortStart, noncachedExtension));
			status = ScsiAdapterControlUnsuccessful;
			break;
	}
	return (status);
} // end MegaRAIDPnPControl()
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\port\scsi\miniport\megaraid\miscellaneous.h ===
/*******************************************************************/
/*                                                                 */
/* NAME             = Miscellaneous.h                              */
/* FUNCTION         = Header file of special functions;            */
/* NOTES            =                                              */
/* DATE             = 02-03-2000                                   */
/* HISTORY          = 001, 02-03-00, Parag Ranjan Maharana;        */
/* COPYRIGHT        = LSI Logic Corporation. All rights reserved;  */
/*                                                                 */
/*******************************************************************/
#ifndef _UTIL_H
#define _UTIL_H

/*

  NOTE : 64 bit addressing (System having memory > 4GB)
  READ_LARGE_MEMORY, WRITE_LARGE_MEMORY will supported by 40LD fw with
  limitation. 
  1) MailBox must be allocated below 4 GB Address Space
  2) SGL it self must be below 4 GB AS but SGL contain may be in > 4GB

*/
//
//Function Prototype
//

BOOLEAN 
IsPhysicalMemeoryInUpper4GB(PSCSI_PHYSICAL_ADDRESS PhyAddress);

BOOLEAN 
IsMemeoryInUpper4GB(PHW_DEVICE_EXTENSION DeviceExtension, PVOID Memory, ULONG32 Length);

ULONG32 
MegaRAIDGetPhysicalAddressAsUlong(
  IN PHW_DEVICE_EXTENSION HwDeviceExtension,
  IN PSCSI_REQUEST_BLOCK Srb,
  IN PVOID VirtualAddress,
  OUT ULONG32 *Length);

BOOLEAN
MegaRAIDZeroMemory(PVOID Buffer, ULONG32 Length);

BOOLEAN
WaitAndPoll(PNONCACHED_EXTENSION NoncachedExtension, PUCHAR PciPortStart, ULONG32 TimeOut, BOOLEAN Polled);

UCHAR 
GetNumberOfChannel(IN PHW_DEVICE_EXTENSION DeviceExtension);

USHORT          
GetM16(PUCHAR Ptr);

ULONG32           
GetM24(PUCHAR Ptr);

ULONG32           
GetM32(PUCHAR Ptr);

VOID            
PutM16(PUCHAR Ptr, USHORT Number);


VOID
PutM24(PUCHAR Ptr, ULONG32 Number);

VOID            
PutM32(PUCHAR Ptr, ULONG32 Number);

VOID            
PutI16(PUCHAR Ptr, USHORT Number);

VOID            
PutI32(PUCHAR Ptr, ULONG32 Number);

ULONG32           
SwapM32(ULONG32 Number);

BOOLEAN 
SendSyncCommand(PHW_DEVICE_EXTENSION deviceExtension);

UCHAR
GetLogicalDriveNumber(
					PHW_DEVICE_EXTENSION DeviceExtension,
					UCHAR	PathId,
					UCHAR TargetId,
					UCHAR Lun);

void
FillOemVendorID(PUCHAR Inquiry, 
                USHORT SubSystemDeviceID, 
                USHORT SubSystemVendorID);


BOOLEAN 
GetFreeCommandID(PUCHAR CmdID, PHW_DEVICE_EXTENSION DeviceExtension);

BOOLEAN
BuildScatterGatherListEx(IN PHW_DEVICE_EXTENSION DeviceExtension,
			                   IN PSCSI_REQUEST_BLOCK	 Srb,
			                   IN PUCHAR	             DataBufferPointer,
			                   IN ULONG32                TransferLength,
                         IN BOOLEAN              Sgl32,
                    		 IN PVOID                SglPointer,
			                   OUT PULONG							 ScatterGatherCount);

UCHAR 
GetNumberOfDedicatedLogicalDrives(IN PHW_DEVICE_EXTENSION DeviceExtension);

#ifdef AMILOGIC
void 
DumpPCIConfigSpace(PPCI_COMMON_CONFIG PciConfig);

BOOLEAN 
WritePciDecBridgeInformation(PHW_DEVICE_EXTENSION DeviceExtension);

void
ScanDECBridge(PHW_DEVICE_EXTENSION DeviceExtension, 
              ULONG SystemIoBusNumber, 
              PSCANCONTEXT ScanContext);
BOOLEAN 
WritePciInformationToScsiChip(PHW_DEVICE_EXTENSION DeviceExtension);
#endif

void
FillOemProductID(PINQUIRYDATA Inquiry, USHORT SubSystemDeviceID, USHORT SubSystemVendorID);


#endif //_UTIL_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\port\scsi\miniport\megaraid\newconfiguration.h ===
/*******************************************************************/
/*                                                                 */
/* NAME             = NewConfiguration.h                           */
/* FUNCTION         = Header file for structure & macro defines for*/
/*                    the new config (Read & Write) & ENQUIRY3;    */
/* NOTES            =                                              */
/* DATE             = 02-03-2000                                   */
/* HISTORY          = 001, 02-03-00, Parag Ranjan Maharana;        */
/* COPYRIGHT        = LSI Logic Corporation. All rights reserved;  */
/*                                                                 */
/*******************************************************************/
#ifndef _INCLUDE_NEWCONFIG
#define _INCLUDE_NEWCONFIG


#define NEW_DCMD_FC_CMD									0xA1
#define NEW_MEGASRB                     0xC3


//
//ENQUIRY 3 RELATED COMMANDS (TAKEN FROM THE Fiber Channel Documentation)
//
#define	NEW_CONFIG_COMMAND	0xA1			
#define NC_SUBOP_ENQUIRY3		0x0F

#define ENQ3_GET_SOLICITED_NOTIFY_ONLY	0x01
#define ENQ3_GET_SOLICITED_FULL					0x02
#define ENQ3_GET_UNSOLICITED						0x03

#define GET_NUM_SCSI_CHAN               0x0C

#define NC_SUBOP_PRODUCT_INFO						0x0E


#define DCMD_FC_CMD									0xA1
#define DCMD_FC_READ_NVRAM_CONFIG		0x04

#define DCMD_WRITE_CONFIG						0x0D

#define NEW_DCMD_FC_READ_NVRAM_CONFIG		0xC0

#define NEW_DCMD_WRITE_CONFIG						0xC1

#define NEW_CONFIG_INFO	0x99
#define SUB_READ			0x01
#define SUB_WRITE			0x02 


//
//Mail box structure to F/W for WRITE_CONFIG_NEW & READ_CONFIG_NEW
//commands. The structure size is one and the same as FW_MBOX but
//the fields are renamed and resized for the command convience.
//
/*
#pragma pack(1)
typedef struct _NEW_CONFIG
{

	UCHAR Command; 
	UCHAR CommandId;
	UCHAR SubCommand; 
	UCHAR NumberOfSgElements;
	UCHAR Reserved[4];
	ULONG DataBufferAddress;//12
   
	UCHAR Reserved0;
	UCHAR Reserved1;
	UCHAR Reserved2;
	UCHAR Reserved3;  //16

	MRAID_STATUS    mstat;

	UCHAR        mraid_poll;
	UCHAR        mraid_ack;

}NEW_CONFIG, *PNEW_CONFIG;
*/

//
//Functional Prototypes
//
BOOLEAN
ConstructReadConfiguration(
				IN PHW_DEVICE_EXTENSION DeviceExtension,
				IN PSCSI_REQUEST_BLOCK	Srb,
				IN UCHAR		CommandId,
				IN PFW_MBOX InMailBox);

BOOLEAN
ConstructWriteConfiguration(
				IN PHW_DEVICE_EXTENSION DeviceExtension,
				IN PSCSI_REQUEST_BLOCK	Srb,
				IN UCHAR		CommandId,
				IN OUT PFW_MBOX  InMailBox);


//
//Function defined in logdrv.c
//
BOOLEAN
GetSupportedLogicalDriveCount(
			PHW_DEVICE_EXTENSION		DeviceExtension
			);


#endif //end of _INCLUDE_NEWCONFIG
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\port\scsi\miniport\megaraid\reset.c ===
/*******************************************************************/
/*                                                                 */
/* NAME             = Reset.c                                      */
/* FUNCTION         = Implementation of MegaRAIDResetBus routine;  */
/* NOTES            =                                              */
/* DATE             = 02-03-2000                                   */
/* HISTORY          = 001, 02-03-00, Parag Ranjan Maharana;        */
/* COPYRIGHT        = LSI Logic Corporation. All rights reserved;  */
/*                                                                 */
/*******************************************************************/

#include "includes.h"

BOOLEAN CompleteOutstandingRequest(IN PHW_DEVICE_EXTENSION DeviceExtension, IN UCHAR PathId);
ULONG32 GetNumberPendingCmdsInPath(IN PHW_DEVICE_EXTENSION DeviceExtension,IN UCHAR PathId);

/*********************************************************************
Routine Description:
	Reset MegaRAID SCSI adapter and SCSI bus.

Arguments:
	HwDeviceExtension - HBA miniport driver's adapter data storage

Return Value:
	Nothing.
**********************************************************************/
BOOLEAN
MegaRAIDResetBus(
	IN PVOID HwDeviceExtension,
	IN ULONG PathId
)
{
	PHW_DEVICE_EXTENSION deviceExtension = HwDeviceExtension;
	FW_MBOX              mbox;
	ULONG32              length;
	UCHAR	               configuredLogicalDrives;

  if(deviceExtension->IsFirmwareHanging)
  {
    //Don't send any command to Firmware
    return TRUE;
  }


#ifdef MRAID_TIMEOUT
	if(deviceExtension->DeadAdapter)
  {
		ScsiPortCompleteRequest(deviceExtension,
                            SP_UNTAGGED,
                            SP_UNTAGGED,
				                    SP_UNTAGGED,
                            (ULONG32) SRB_STATUS_BUS_RESET);

		deviceExtension->DeadAdapter = 1;
	  
		//
		// mraid35x fails to ask for next request in reset scenario
		// FIX FOR MIRCOSOFT REPORTED BUG NTBUG9 521941 
		//
		ScsiPortNotification(NextRequest, deviceExtension, NULL);
		
		return TRUE;
  }
#endif // MRAID_TIMEOUT

  if(!CompleteOutstandingRequest(deviceExtension, (UCHAR)PathId))
	{	//FAIL to recover commands

		ScsiPortCompleteRequest(deviceExtension,
                            SP_UNTAGGED,
                            SP_UNTAGGED,
				                    SP_UNTAGGED,
                            (ULONG32) SRB_STATUS_BUS_RESET);

		deviceExtension->DeadAdapter = 1;
	  
		//
		// mraid35x fails to ask for next request in reset scenario
		// FIX FOR MIRCOSOFT REPORTED BUG NTBUG9 521941 
		//
		ScsiPortNotification(NextRequest, deviceExtension, NULL);
		
		return TRUE;

	}


  //This is only for cluster
  //Shared Drives only present in (deviceExtension->NumberOfPhysicalChannels+1) path.
  if(PathId == (ULONG)(deviceExtension->NumberOfPhysicalChannels+1))
  {
    if(deviceExtension->ResetIssued) 
		{
			//
			// mraid35x fails to ask for next request in reset scenario
			// FIX FOR MIRCOSOFT REPORTED BUG NTBUG9 521941 
			//
			ScsiPortNotification(NextRequest, deviceExtension, NULL);
		  return FALSE;
		}

	  if(deviceExtension->SupportedLogicalDriveCount == MAX_LOGICAL_DRIVES_8)
	  {
		  configuredLogicalDrives = deviceExtension->NoncachedExtension->MRAIDParams.MRAIDParams8.LogdrvInfo.NumLDrv;
	  }
	  else
	  {
		  configuredLogicalDrives = deviceExtension->NoncachedExtension->MRAIDParams.MRAIDParams40.numLDrv;
	  }

    if(configuredLogicalDrives == 0)
		{
			//
			// mraid35x fails to ask for next request in reset scenario
			// FIX FOR MIRCOSOFT REPORTED BUG NTBUG9 521941 
			//
			ScsiPortNotification(NextRequest, deviceExtension, NULL);
		  return FALSE;
		}

	  deviceExtension->ResetIssued     = 1;

    MegaRAIDZeroMemory(&mbox, sizeof(FW_MBOX));
	  
    mbox.Command                     = MRAID_RESERVE_RELEASE_RESET;
	  mbox.CommandId                   = (UCHAR)RESERVE_RELEASE_DRIVER_ID;
	  mbox.u.Flat1.Parameter[0]        = RESET_BUS;
	  mbox.u.Flat1.Parameter[1]        = 0;  //We don't know

#ifdef MRAID_TIMEOUT
	  if(SendMBoxToFirmware(deviceExtension,	deviceExtension->PciPortStart, &mbox) == FALSE)
	  {
    	
		  DebugPrint((0, "\nReset Bus Command Firing Failed"));
		  //
		  // Complete all outstanding requests with SRB_STATUS_BUS_RESET.
		  //
		  ScsiPortCompleteRequest(deviceExtension,
                              SP_UNTAGGED,
                              SP_UNTAGGED,
				                      SP_UNTAGGED,
                              (ULONG32) SRB_STATUS_BUS_RESET);

			deviceExtension->DeadAdapter = 1;
		
    }
#else // MRAID_TIMEOUT
	  SendMBoxToFirmware(deviceExtension,deviceExtension->PciPortStart, &mbox);
#endif // MRAID_TIMEOUT
  }
 
  //
  // mraid35x fails to ask for next request in reset scenario
  // FIX FOR MIRCOSOFT REPORTED BUG NTBUG9 521941 
  //
  ScsiPortNotification(NextRequest, deviceExtension, NULL);

	return TRUE;
} // end MegaRAIDResetBus()


BOOLEAN CompleteOutstandingRequest(IN PHW_DEVICE_EXTENSION DeviceExtension, IN UCHAR PathId)
{
	PSCSI_REQUEST_BLOCK srb;
	PSCSI_REQUEST_BLOCK nextSrb;
  PSRB_EXTENSION srbExt;

	UCHAR command, commandId, logDrive, commandsCompleted, status;
  ULONG rpInterruptStatus;
  UCHAR nonrpInterruptStatus;
  PUCHAR pciPortStart = (PUCHAR)DeviceExtension->PciPortStart;
  ULONG index, PendCmds;
	ULONG timeoutValue;

  if(DeviceExtension->PendingSrb)
	{
    srb = DeviceExtension->PendingSrb;
    if(srb->PathId == PathId)
    {
      DeviceExtension->PendingSrb = NULL;
		  srb->SrbStatus  = SRB_STATUS_BUS_RESET;		          
      ScsiPortNotification(RequestComplete, (PVOID)DeviceExtension, srb);
    }
	}

#ifdef COALESE_COMMANDS
  for(logDrive = 0; logDrive < DeviceExtension->SupportedLogicalDriveCount; ++logDrive)
  {
    if(DeviceExtension->LogDrvCommandArray[logDrive].SrbQueue)
    {
      srb = DeviceExtension->LogDrvCommandArray[logDrive].SrbQueue;
      if(srb->PathId == PathId)
      {
        while(srb)
        {
		      srbExt = srb->SrbExtension;
		      nextSrb = srbExt->NextSrb;
	        srb->SrbStatus  = SRB_STATUS_BUS_RESET;		          
          ScsiPortNotification(RequestComplete, (PVOID)DeviceExtension, srb);
          srb = nextSrb;
        }
        MegaRAIDZeroMemory(&DeviceExtension->LogDrvCommandArray[logDrive], sizeof(LOGDRV_COMMAND_ARRAY));
      }
    }
  }
#endif

	//
	//TO AVOID INFINITY LOOP WE HAVE ADDED TIMEOUT CHECK
	//

	timeoutValue = 0;

  while(GetNumberPendingCmdsInPath(DeviceExtension, PathId))
  {
		timeoutValue++;
		//
		//If request does not recover within 3 minutes, then fail the recovery process and declare it as a DEAD ADAPTER
		//
		if(timeoutValue >= 1800000)
		{
			return FALSE;
		}

		MegaRAIDInterrupt(DeviceExtension);
		ScsiPortStallExecution(100);
		
  }


  return TRUE;
}

ULONG32 GetNumberPendingCmdsInPath(IN PHW_DEVICE_EXTENSION DeviceExtension, IN UCHAR PathId)
{
	PSCSI_REQUEST_BLOCK srb;
	ULONG32 command, numberOfCommands = 0;

	for(command=0; command < CONC_CMDS; command++)
	{
		if(DeviceExtension->PendSrb[command])
		{
			srb = DeviceExtension->PendSrb[command];
			if(srb->PathId == PathId)
				numberOfCommands++;
		}
	}
	return numberOfCommands;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\port\scsi\miniport\megaraid\readconfiguration.h ===
/*******************************************************************/
/*                                                                 */
/* NAME             = ReadConfiguration.h                          */
/* FUNCTION         = Header file for structure & macro defines for*/
/*                    the new config (Read & Write) calls;         */
/* NOTES            =                                              */
/* DATE             = 02-03-2000                                   */
/* HISTORY          = 001, 02-03-00, Parag Ranjan Maharana;        */
/* COPYRIGHT        = LSI Logic Corporation. All rights reserved;  */
/*                                                                 */
/*******************************************************************/

#ifndef _INCLUDE_READCFG
#define _INCLUDE_READCFG

ULONG32
Find8LDDiskArrayConfiguration(
					PHW_DEVICE_EXTENSION	DeviceExtension
					);

ULONG32
Find40LDDiskArrayConfiguration(
					PHW_DEVICE_EXTENSION	DeviceExtension
					);

ULONG32
Read40LDDiskArrayConfiguration(
				PHW_DEVICE_EXTENSION	DeviceExtension,
				UCHAR		CommandId,
				BOOLEAN	IsPolledMode
				);

BOOLEAN
Construct40LDDiskArrayConfiguration(
				IN PHW_DEVICE_EXTENSION DeviceExtension,
				IN UCHAR		CommandId,
				IN PFW_MBOX InMailBox
				);


ULONG32
Read8LDDiskArrayConfiguration(
				PHW_DEVICE_EXTENSION	DeviceExtension,
				UCHAR		CommandCode,
				UCHAR		CommandId,
				BOOLEAN	IsPolledMode
				);


UCHAR
GetLogicalDriveStripeSize(
						PHW_DEVICE_EXTENSION	DeviceExtension,
						UCHAR		LogicalDriveNumber
					);


#endif // end of _INCLUDE_READCFG
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\port\scsi\miniport\megaraid\newconfiguration.c ===
/*******************************************************************/
/*                                                                 */
/* NAME             = NewConfiguration.C                           */
/* FUNCTION         = New Configuration Implementation;            */
/* NOTES            =                                              */
/* DATE             = 02-03-2000                                   */
/* HISTORY          = 001, 02-03-00, Parag Ranjan Maharana;        */
/* COPYRIGHT        = LSI Logic Corporation. All rights reserved;  */
/*                                                                 */
/*******************************************************************/

//
//include files
//
#include "includes.h"

/*------------------------------------------------------------
File : NewConfiguration.c

This file holds the functions for the implementation of
new READ_CONFIG & WRITE_CONFIG commands.The new FW supports
40 (previously 8) logical drives. This requires a higher 
capacity contiguous buffer to be allocated and used by the driver.
The buffer is allocated during HWScsiInitialize() routine and the
pointer is kept in deviceExtension of the associated host adapter.
f
------------------------------------------------------------*/


BOOLEAN
ConstructReadConfiguration(
				IN PHW_DEVICE_EXTENSION DeviceExtension,
				IN PSCSI_REQUEST_BLOCK	Srb,
				IN UCHAR		CommandId,
				IN PFW_MBOX InMailBox)
/*------------------------------------------------------------
Function : SendReadConfigurationToFirmware
Routine Description:
	Constructs the read configuration (new version) and dispatches
	the command to the firmware. The buffer used for the 
	read config is taken from the deviceExtension.
Return Value:
	TRUE on success
	FALSE otherwise
------------------------------------------------------------*/
{
  UCHAR     bufferOffset =  (sizeof(SRB_IO_CONTROL) + APPLICATION_MAILBOX_SIZE);
	ULONG32		physicalBufferAddress;
	ULONG32		scatterGatherDescriptorCount = 0;
  PUCHAR    dataBuffer = (PUCHAR)((PUCHAR)Srb->DataBuffer + bufferOffset);

	BOOLEAN		retValue = TRUE;

  ULONG32   bytesTobeTransferred = Srb->DataTransferLength - bufferOffset;
  PMegaSrbExtension srbExtension = (PMegaSrbExtension)Srb->SrbExtension;
  BOOLEAN   buildSgl32Type = (BOOLEAN)(DeviceExtension->LargeMemoryAccess) ? FALSE : TRUE;
									
	//
	//Initialize the mail box
	//
	MegaRAIDZeroMemory(InMailBox, sizeof(FW_MBOX) );

	BuildScatterGatherListEx(DeviceExtension,
                           Srb,
			                     dataBuffer,
                           bytesTobeTransferred,
                           buildSgl32Type,   //Depending on LME build SGL
                           (PVOID)&srbExtension->SglType.SG32List,
			                      &scatterGatherDescriptorCount);
	
  if((scatterGatherDescriptorCount == 1) && (DeviceExtension->LargeMemoryAccess == FALSE))
  {
	  scatterGatherDescriptorCount = 0; 
    physicalBufferAddress = srbExtension->SglType.SG32List.Descriptor[0].Address;
  }
  else
  {
    SCSI_PHYSICAL_ADDRESS scsiPhyAddress;
    ULONG32 length;
    scsiPhyAddress = ScsiPortGetPhysicalAddress(DeviceExtension,
										                            NULL,
                                                (PVOID)&srbExtension->SglType.SG32List, 
                                                &length);

	  physicalBufferAddress = ScsiPortConvertPhysicalAddressToUlong(scsiPhyAddress);
  }

  //
	//construct the read config command
	//
	if(DeviceExtension->LargeMemoryAccess == TRUE)
    InMailBox->Command = NEW_DCMD_FC_CMD; // xA1
  else
    InMailBox->Command = DCMD_FC_CMD; // xA1

	InMailBox->CommandId = CommandId;
	if(DeviceExtension->LargeMemoryAccess == TRUE)
	  InMailBox->u.NewConfig.SubCommand = NEW_DCMD_FC_READ_NVRAM_CONFIG; //= 0xC0 
  else
	  InMailBox->u.NewConfig.SubCommand = DCMD_FC_READ_NVRAM_CONFIG; //= 0x04 
	InMailBox->u.NewConfig.NumberOfSgElements= (UCHAR)scatterGatherDescriptorCount; 
	InMailBox->u.NewConfig.DataTransferAddress = physicalBufferAddress;

	//
	//return status
	//
	return(retValue);

}//ConstructReadConfiguration ends



BOOLEAN
ConstructWriteConfiguration(
				IN PHW_DEVICE_EXTENSION DeviceExtension,
				IN PSCSI_REQUEST_BLOCK	Srb,
				IN UCHAR		CommandId,
				IN OUT PFW_MBOX  InMailBox
				)
/*----------------------------------------------------------------
Function: SendWriteConfigurationToFirmware
Routine Description:
	Writes the logical drive configuration information to the 
	firmware
Return value
	TRUE on success
	FALSE otherwise
----------------------------------------------------------------*/
{
	ULONG32			physicalBufferAddress;
	ULONG32			scatterGatherDescriptorCount = 0;
	BOOLEAN		retValue = TRUE;

  UCHAR     bufferOffset =  (sizeof(SRB_IO_CONTROL) + APPLICATION_MAILBOX_SIZE);
  PUCHAR    dataBuffer = (PUCHAR)((PUCHAR)Srb->DataBuffer + bufferOffset);
  ULONG32     bytesTobeTransferred = Srb->DataTransferLength - bufferOffset;
  PMegaSrbExtension srbExtension = (PMegaSrbExtension)Srb->SrbExtension;
  BOOLEAN   buildSgl32Type = (BOOLEAN)(DeviceExtension->LargeMemoryAccess) ? FALSE : TRUE;
		
	//
	//Initialize the mail box
	//
	MegaRAIDZeroMemory(InMailBox, sizeof(FW_MBOX));

	BuildScatterGatherListEx(DeviceExtension,
                           Srb,
			                     dataBuffer,
                           bytesTobeTransferred,
                           buildSgl32Type,   //Build SGL Depending on LME
                           (PVOID)&srbExtension->SglType.SG32List,
			                      &scatterGatherDescriptorCount);

  if((scatterGatherDescriptorCount == 1) && (DeviceExtension->LargeMemoryAccess == FALSE))
  {
	  scatterGatherDescriptorCount = 0; 
    physicalBufferAddress = srbExtension->SglType.SG32List.Descriptor[0].Address;
  }
  else
  {
    SCSI_PHYSICAL_ADDRESS scsiPhyAddress;
    ULONG32 length;
    scsiPhyAddress = ScsiPortGetPhysicalAddress(DeviceExtension,
										                            NULL,
                                                (PVOID)&srbExtension->SglType.SG32List, 
                                                &length);

	  physicalBufferAddress = ScsiPortConvertPhysicalAddressToUlong(scsiPhyAddress);
  }

  //
	//construct the read config command
	//
  if(DeviceExtension->LargeMemoryAccess)
	  InMailBox->Command = NEW_DCMD_FC_CMD; 
  else
	  InMailBox->Command = DCMD_FC_CMD; 

	InMailBox->CommandId = CommandId;
  if(DeviceExtension->LargeMemoryAccess)
  	InMailBox->u.NewConfig.SubCommand = NEW_DCMD_WRITE_CONFIG; //= 0xC1
  else
	  InMailBox->u.NewConfig.SubCommand = DCMD_WRITE_CONFIG; //=0x0D

	InMailBox->u.NewConfig.NumberOfSgElements= (UCHAR)scatterGatherDescriptorCount;
	InMailBox->u.NewConfig.DataTransferAddress = physicalBufferAddress;

	//
	//return status
	//
	return(retValue);
}//ConstructWriteConfiguration ends
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\port\scsi\miniport\megaraid\readconfiguration.c ===
/*******************************************************************/
/*                                                                 */
/* NAME             = ReadConfiguration.C                          */
/* FUNCTION         = Read Configuration Implementation;           */
/* NOTES            =                                              */
/* DATE             = 02-03-2000                                   */
/* HISTORY          = 001, 02-03-00, Parag Ranjan Maharana;        */
/* COPYRIGHT        = LSI Logic Corporation. All rights reserved;  */
/*                                                                 */
/*******************************************************************/

#include "includes.h"

//++
//
//Function :	Find8LDDiskArrayConfiguration
//Routine Description:
//					For the firmware with 8 logical drive support, this
//					routine queries the firmware for the 8SPAN or 4SPAN 
//					support. The disk array structure used for data interpretation
//					varies for a 8SPAN and 4SPAN firmware.
//					The disk array structure is used by the driver for getting
//					the logical drive stripe size information.
//Input Argument(s):
//					Controller Device Extension
//
//Return Value:
//					0L
//
//--
ULONG32
Find8LDDiskArrayConfiguration(
					PHW_DEVICE_EXTENSION	DeviceExtension
					)
{
	//
	//get the logical drive to physical drive information.
	//Check for the span depth by calling the 8_SPAN command first.
	//If that fails, call the 4_SPAN command next.
	// On success, this function reads the disk array information
	// to the deviceExtension->NoncachedExtension->DiskArray structure.
	//
	// The disk array structure could be [Span8] 0r [Span4]. This is
	// found out by giving the Read configuration commands
	//		MRAID_EXT_READ_CONFIG or MRAID_READ_CONFIG
	//
	// If the first one passes, then the firmware is an 8 span one
	// and the information is filled in [DiskArray.Span8] structure.
	// Else, the second command is given to the firmware and the
	// the information is filled in  [DiskArray.Span4] structure.
	//
	DeviceExtension->NoncachedExtension->ArraySpanDepth = 
																						FW_UNKNOWNSPAN_DEPTH;
	if(
		Read8LDDiskArrayConfiguration(
				DeviceExtension, //PFW_DEVICE_EXTENSION	DeviceExtension,
				MRAID_EXT_READ_CONFIG, //UCHAR		CommandCode,
				0xFE,//UCHAR		CommandId,
				TRUE)//BOOLEAN	IsPolledMode 
		== 0)
	{
			//command passed successfully. The firmware supports 8span
			//drive structure.
			DeviceExtension->NoncachedExtension->ArraySpanDepth = 
								FW_8SPAN_DEPTH;
	}
	else
	{
		//
		// do the read configuration for a 4 span array
		//
		Read8LDDiskArrayConfiguration(
				DeviceExtension, //PFW_DEVICE_EXTENSION	DeviceExtension,
				MRAID_READ_CONFIG, //UCHAR		CommandCode,
				0xFE,//UCHAR		CommandId,
				TRUE); //BOOLEAN	IsPolledMode 
		
		DeviceExtension->NoncachedExtension->ArraySpanDepth = 
								FW_4SPAN_DEPTH;
	}

	return(0L);
}//of Find8LDReadDiskArrayConfiguration()

//--
//
//Function Name: Read8LDDiskArrayConfiguration
//Routine Description:
//			This function queries the firmware for the logical/physical
//	drive configuration. The purpose is to get the logical drive
//	stripe size. This function gets called at two different places:
//
//			(1)At the init time, the call is given from 
//			MegaRAIDFindAdapter() routine to get the information about
//			the logical drives.
//
//			(2)Whenever the Win32 utility (PowerConsole) updates the
//			logical drive configuration(WRITE_CONFIG call).
//
//	The disk array structure has a hidden complexity. Some of
//	the firmwares support a maximum of 8 spans for the logical
//	drives whereas some support only a maximum of 4 spans.To
//	find out what kind of firmware is that, initially a call is
//	given to find out whether the firmware supports 8 span. If 
//	that fails it means that the firmware supports only 4 span.
//	This check is done only once at the start time. After that subsequent
//	calls are given based on the span information.
//
//	READ_CONFIG command code for 8Span is MRAID_EXT_READ_CONFIG
//	READ_CONFIG command code for 4span is MRAID_READ_CONFIG
//
//	The routine can be called in polled mode or interrupt mode. If called
//	in polled mode, then after sending the command to the firware, the
//	routine polls for the completion of the command.

//Input Arguments:
//	Pointer to the controller DeviceExtension
//	Command Code (MRAID_EXT_READ_CONFIG or MRAID_READ_CONFIG)
//	CommandId
//	IsPolled (TRUE or FALSE)
//
//Return Values:
//	0 if success
//	any other Positive value (currently == 1) on error conditions
//++
ULONG32
Read8LDDiskArrayConfiguration(
				PHW_DEVICE_EXTENSION	DeviceExtension,
				UCHAR		CommandCode,
				UCHAR		CommandId,
				BOOLEAN	IsPolledMode
				)
{
	PUCHAR		dataBuffer;
	PUCHAR		pciPortStart;
	
	ULONG32		count;
	ULONG32		length;	
	ULONG32		rpInterruptStatus;
	
	UCHAR		nonrpInterruptStatus;
	UCHAR		commandStatus;
	UCHAR		rpFlag;

	SCSI_PHYSICAL_ADDRESS	physicalAddress;
	
	FW_MBOX		mailBox;

	//
	//get the register space
	//
	pciPortStart = DeviceExtension->PciPortStart;
	rpFlag = DeviceExtension->NoncachedExtension->RPBoard;

	//
	//initialize the mailbox struct
	//
	MegaRAIDZeroMemory(&mailBox, sizeof(FW_MBOX));

	//
	//construct the command
	//
	mailBox.Command   = CommandCode;
	mailBox.CommandId = CommandId;

	//
	//get the physical address of the data buffer
	//
	dataBuffer = (PUCHAR)&DeviceExtension->NoncachedExtension->DiskArray;
	physicalAddress = ScsiPortGetPhysicalAddress(DeviceExtension,
												                        NULL,
												                        dataBuffer,
												                        &length);

	//convert the physical address to ULONG32
	mailBox.u.Flat2.DataTransferAddress = ScsiPortConvertPhysicalAddressToUlong(physicalAddress);
	
	if(physicalAddress.HighPart > 0)
  {
     DebugPrint((0, "\n Phy Add of Read8LDDiskArrayConfiguration has higher address 0x%X %X", physicalAddress.HighPart, physicalAddress.LowPart));
  }
	//
	//reset the status byte in the mail box
	//
	DeviceExtension->NoncachedExtension->fw_mbox.Status.CommandStatus = 0;
  DeviceExtension->NoncachedExtension->fw_mbox.Status.NumberOfCompletedCommands = 0;
	
	//
	//fire the command to the firmware
	//		
	SendMBoxToFirmware(DeviceExtension, pciPortStart, &mailBox);
 
	//
	//check for the polling mode
	//
	if(!IsPolledMode)
  {
		
		return(MEGARAID_SUCCESS);
	}

  //
  //wait for the completion of the command
	//

	
  if(WaitAndPoll(DeviceExtension->NoncachedExtension, pciPortStart, DEFAULT_TIMEOUT, IsPolledMode) == FALSE)
  {
		return(MEGARAID_FAILURE);
	}

  //
	//check for the command status
	//
	commandStatus = DeviceExtension->NoncachedExtension->fw_mbox.Status.CommandStatus;

	//
	//return the Command status to the caller
	//
	return((ULONG32) commandStatus);

}//end of Read8LDDiskArrayConfiguration()


//--
//
//Function : GetLogicalDriveStripeSize
//Routine Description:
//			For the specified logical drive, this function returns the
//			corresponding stripe size.
//			The stripe size is got from the DiskArray which could be an
//			eight span or a 4 span one. This is found out at the init time
//			itself. If the disk array is not properly updated then the
//			value of (0) is returned as the logical drive stripe size.
//
//			The calling functions have to check for the special (0) return
//			value.
//
//Input Arguments:
//			Pointer to controller device extension
//			Logical drive number
//
//Returns
//			stripe size of the logical drive number
//			STRIPE_SIZE_UNKNOWN -- other wise
//
//++
UCHAR
GetLogicalDriveStripeSize(
						PHW_DEVICE_EXTENSION	DeviceExtension,
						UCHAR		LogicalDriveNumber
					)
{
	PFW_ARRAY_8SPAN_40LD	span8Array_40ldrv;
	PFW_ARRAY_4SPAN_40LD  span4Array_40ldrv;

	PFW_ARRAY_8SPAN_8LD	span8Array_8ldrv;
	PFW_ARRAY_4SPAN_8LD span4Array_8ldrv;

	PNONCACHED_EXTENSION noncachedExtension = 
													DeviceExtension->NoncachedExtension;

	UCHAR	stripeSize;


	//
	//check for the authenticity of the disk array info
	//
	//if the NoncachedExtension->DiskArray is not properly updated
	//then the field NoncachedExtension->ArraySpanDepth  value would
	//be FW_UNKNOWNSPAN_DEPTH. Return 0 for stripe size in that case.
	//
	if(noncachedExtension->ArraySpanDepth == FW_UNKNOWNSPAN_DEPTH){

			//this is an error condition. The caller has to take action
			//accordingly
			return(STRIPE_SIZE_UNKNOWN);
	}

	//
	//check for the supported logical drive count by the firmware
	//
	if(DeviceExtension->SupportedLogicalDriveCount == MAX_LOGICAL_DRIVES_8)
	{
		//
		//firmware supports 8 logical drives. The disk array structure
		//is different for 8LD/ (4SPAN & 8SPAN) 
		//
		//locate the logical drive information from the disk array
		//based on the span depth of the disk array.
		//
		if(noncachedExtension->ArraySpanDepth == FW_8SPAN_DEPTH){

			span8Array_8ldrv = &noncachedExtension->DiskArray.LD8.Span8;

			stripeSize = span8Array_8ldrv->log_drv[LogicalDriveNumber].stripe_sz;
		}
		else{
			span4Array_8ldrv = &noncachedExtension->DiskArray.LD8.Span4;

			stripeSize = span4Array_8ldrv->log_drv[LogicalDriveNumber].stripe_sz;
		}
	}
	else
	{
		//
		//firmware supports 40 logical drives. The disk array structure
		//is different for 40LD/ (4SPAN & 8SPAN) 
		//
		//locate the logical drive information from the disk array
		//based on the span depth of the disk array.
		//
		if(noncachedExtension->ArraySpanDepth == FW_8SPAN_DEPTH){

			span8Array_40ldrv = &noncachedExtension->DiskArray.LD40.Span8;

			stripeSize = span8Array_40ldrv->log_drv[LogicalDriveNumber].stripe_sz;
		}
		else{
			span4Array_40ldrv = &noncachedExtension->DiskArray.LD40.Span4;

			stripeSize = span4Array_40ldrv->log_drv[LogicalDriveNumber].stripe_sz;
		}
	}
	//return the stripe size
	return(stripeSize);

}//end of GetLogicalDriveStripeSize()


ULONG32
Find40LDDiskArrayConfiguration(
					PHW_DEVICE_EXTENSION	DeviceExtension
					)
{
	DeviceExtension->NoncachedExtension->ArraySpanDepth = 
																						FW_UNKNOWNSPAN_DEPTH;
	
	//DebugPrint((0, "\r\nFind40LD: Calling Read40LD"));

	if(
		Read40LDDiskArrayConfiguration(
				DeviceExtension, //PFW_DEVICE_EXTENSION	DeviceExtension,
				0xFE,//UCHAR		CommandId,
				TRUE)//BOOLEAN	IsPolledMode 
		== 0)
	{
			//command passed successfully. The firmware supports 8span
			//drive structure.
			DeviceExtension->NoncachedExtension->ArraySpanDepth = 
								FW_8SPAN_DEPTH;
	}
	else
	{
			//
			//at this point, there is no 4span equivalent for the 40logical
			//drive firmware.
			//
			DebugPrint((0, "\r\nFind40LD: Outfrom Read40LD(FAILED)"));
			return(1L); //error code
	}

	DebugPrint((0, "\r\nFind40LD: Outfrom Read40LD(SUCCESS)"));

	return(0L);
}//of Find40LDDiskArrayConfiguration()

//--
//
//Function Name: Read40LDDiskArrayConfiguration
//Routine Description:
//			This function queries the firmware for the logical/physical
//	drive configuration. The purpose is to get the logical drive
//	stripe size. This function gets called at two different places:
//
//			(1)At the init time, the call is given from 
//			MegaRAIDFindAdapter() routine to get the information about
//			the logical drives.
//
//			(2)Whenever the Win32 utility (PowerConsole) updates the
//			logical drive configuration(WRITE_CONFIG call).
//
//	The disk array structure has a hidden complexity. Some of
//	the firmwares support a maximum of 8 spans for the logical
//	drives whereas some support only a maximum of 4 spans.To
//	find out what kind of firmware is that, initially a call is
//	given to find out whether the firmware supports 8 span. If 
//	that fails it means that the firmware supports only 4 span.
//	This check is done only once at the start time. After that subsequent
//	calls are given based on the span information.
//
//	READ_CONFIG command code for 8Span is MRAID_EXT_READ_CONFIG
//	READ_CONFIG command code for 4span is MRAID_READ_CONFIG
//
//	The routine can be called in polled mode or interrupt mode. If called
//	in polled mode, then after sending the command to the firware, the
//	routine polls for the completion of the command.

//Input Arguments:
//	Pointer to the controller DeviceExtension
//	Command Code (MRAID_EXT_READ_CONFIG or MRAID_READ_CONFIG)
//	CommandId
//	IsPolled (TRUE or FALSE)
//
//Return Values:
//	0 if success
//	any other Positive value (currently == 1) on error conditions
//++
ULONG32
Read40LDDiskArrayConfiguration(
				PHW_DEVICE_EXTENSION	DeviceExtension,
				UCHAR		CommandId,
				BOOLEAN	IsPolledMode
				)
{
	PUCHAR		dataBuffer;
	PUCHAR		pciPortStart;
	
	ULONG32		count;
	ULONG32		length;	
	ULONG32		rpInterruptStatus;
	
	UCHAR		nonrpInterruptStatus;
	UCHAR		commandStatus;
	UCHAR		rpFlag;

	SCSI_PHYSICAL_ADDRESS	physicalAddress;
	
	FW_MBOX		mailBox;

	//
	//get the register space
	//
	pciPortStart = DeviceExtension->PciPortStart;	
	rpFlag = DeviceExtension->NoncachedExtension->RPBoard;

	DebugPrint((0, "\r\nRead40LD:Initializing Mbox[Size=%d]",sizeof(FW_MBOX)));

	//
	//initialize the mailbox struct
	//
	MegaRAIDZeroMemory(&mailBox, sizeof(FW_MBOX));

	
  if(DeviceExtension->CrashDumpRunning == TRUE)
  {
    //Use Enquiry3 to Update Size of Disk//
    ///////////////////////////////////////

    GetSupportedLogicalDriveCount(DeviceExtension);
	  commandStatus = DeviceExtension->NoncachedExtension->fw_mbox.Status.CommandStatus;

	  DebugPrint((0, "\nReading Enquiry3 : Command Completed [Status=%d]", commandStatus));

	  //
	  //return the Command status to the caller
	  //
	  return((ULONG32) commandStatus);


  }
  //
	//construct the command
	//
	DebugPrint((0, "\nRead40LD: Calling Construct40LD"));

	Construct40LDDiskArrayConfiguration(DeviceExtension, CommandId, &mailBox);
	
	DebugPrint((0, "\nRead40LD: Outfrom Construct40LD"));
	
	DebugPrint((0, "\nRead40LD: Dumping Constructed Mailbox[in hex]"));
	for(count=0; count < 16; count++)
  {
			DebugPrint((0, "%02x ", ((PUCHAR)&mailBox)[count]));
	}

	//
	//reset the status byte in the mail box
	//
	DeviceExtension->NoncachedExtension->fw_mbox.Status.CommandStatus = 0;
  DeviceExtension->NoncachedExtension->fw_mbox.Status.NumberOfCompletedCommands = 0;
	
	//
	//fire the command to the firmware
	//		
	DebugPrint((0, "\nRead40LD: Firing Command to FW"));

	SendMBoxToFirmware(DeviceExtension, pciPortStart, &mailBox);
 
	DebugPrint((0, "\nRead40LD: Command Fired to FW"));

	//
	//check for the polling mode
	//
	if(!IsPolledMode)
  {
		
		return(MEGARAID_SUCCESS);
	}
	
	DebugPrint((0, "\nRead40LD: Waiting for FW Completion"));

  //
  //wait for the completion of the command
	//

  if(WaitAndPoll(DeviceExtension->NoncachedExtension, pciPortStart, DEFAULT_TIMEOUT, IsPolledMode) == FALSE)
  {
		DebugPrint((0, "\r\nRead40LD: Command Timed out"));
		return(MEGARAID_FAILURE);
	}
	 		
			 

	//
	//check for the command status
	//
	commandStatus = DeviceExtension->NoncachedExtension->fw_mbox.Status.CommandStatus;

	DebugPrint((0, "\nRead40LD: Command Completed [Status=%d]",commandStatus));

	//
	//return the Command status to the caller
	//
	return((ULONG32) commandStatus);

}//end of Read40LDDiskArrayConfiguration()


BOOLEAN
Construct40LDDiskArrayConfiguration(
				IN PHW_DEVICE_EXTENSION DeviceExtension,
				IN UCHAR		CommandId,
				IN PFW_MBOX InMailBox)
{

	ULONG32			physicalBufferAddress;
	ULONG32			scatterGatherDescriptorCount = 0;
	ULONG32			bytesTobeTransferred;
	
	BOOLEAN		retValue = TRUE;
  PNONCACHED_EXTENSION  noncachedExtension = DeviceExtension->NoncachedExtension;
									
	//
	//Initialize the mail box
	//
	MegaRAIDZeroMemory(InMailBox, sizeof(FW_MBOX));

	//calculate the disk array structure size
	//
	bytesTobeTransferred = sizeof(FW_ARRAY_8SPAN_40LD);

	DebugPrint((0, "\nConstruct40LD:size(NEWCON)=%d BytesTrd=%d",sizeof(FW_MBOX), bytesTobeTransferred));

	BuildScatterGatherListEx(DeviceExtension,
                           NULL,
			                     (PUCHAR)&noncachedExtension->DiskArray,
                           bytesTobeTransferred,
                           TRUE,  //32 bit SGL
                           (PVOID)&noncachedExtension->DiskArraySgl,
			                      &scatterGatherDescriptorCount);
	



  if(scatterGatherDescriptorCount == 1)
  {
	  scatterGatherDescriptorCount = 0; 
    physicalBufferAddress = noncachedExtension->DiskArraySgl.Descriptor[0].Address;
  }
  else
  {
    SCSI_PHYSICAL_ADDRESS scsiPhyAddress;
    ULONG32 length;
    scsiPhyAddress = ScsiPortGetPhysicalAddress(DeviceExtension,
										                            NULL,
                                                (PVOID)&noncachedExtension->DiskArraySgl, 
                                                &length);

	  physicalBufferAddress = ScsiPortConvertPhysicalAddressToUlong(scsiPhyAddress);
  }

	DebugPrint((0, "\nConstruct40LD: SGCount=%d PBA=0x%0x", scatterGatherDescriptorCount,physicalBufferAddress));

  //
	//construct the read config command
	//
	InMailBox->Command =DCMD_FC_CMD; // xA1
	InMailBox->CommandId = CommandId;
	InMailBox->u.NewConfig.SubCommand = DCMD_FC_READ_NVRAM_CONFIG; //= 0x04 
	InMailBox->u.NewConfig.NumberOfSgElements= (UCHAR)scatterGatherDescriptorCount; 
	InMailBox->u.NewConfig.DataTransferAddress = physicalBufferAddress;
	
	//
	//return status
	//
	return(retValue);

}//Construct40LDDiskArrayConfiguration ends
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\port\scsi\miniport\mylex\dac2w2k\io\mdacnt.c ===
/**************************************************************************
 *                COPYRIGHT (C) Mylex Corporation 1992-2000               *
 *                                                                        *
 * This software is furnished under a license and may be used and copied  * 
 * only in accordance with the terms and conditions of such license and   * 
 * with inclusion of the above copyright notice. This software or any     * 
 * other copies thereof may not be provided or otherwise made available   * 
 * to any other person. No title to, nor ownership of the software is     * 
 * hereby transferred.                                                    *
 *                                                                        *
 * The information in this software is subject to change without notices  *
 * and should not be construed as a commitment by Mylex Corporation       *
 *                                                                        *
 **************************************************************************/
extern void MdacInt3(void);
extern u32bits MLXFAR mdac_zero(u08bits MLXFAR *dp,u32bits sz);
extern u32bits MLXFAR mdac_oneintr(mdac_ctldev_t MLXFAR *ctp);

u32bits NotFound(u32bits num);
u32bits WasFound(u32bits num);
u32bits mdacParseArgumentString(IN PCHAR String,IN PCHAR KeyWord );
u32bits mdacParseArgumentStringComplex(IN PCHAR String,IN PCHAR KeyWord );
u32bits ntmdac_alloc_req_ret(mdac_ctldev_t MLXFAR *ctp,
							 mdac_req_t MLXFAR **rqpp,
							 PSCSI_REQUEST_BLOCK Srb,
							 u32bits rc);
u32bits MLXFAR rqp_completion_intr(mdac_req_t MLXFAR *rqp);

u32bits GamDbgAlpha = 1;
#define MDAC_SRB_EXTENSION_SIZE  4 * 1024
#if defined MLX_NT_ALPHA
#undef mlx_kvtophys
#define mlx_kvtophys(ctp, dp)           MdacKvToPhys(ctp, dp)
#define u08bits_read(addr)              ScsiPortReadRegisterUchar((u08bits *)(addr))       /* input  08 bits data*/
#define u16bits_read(addr)              ScsiPortReadRegisterUshort((u16bits *)(addr))       /* input  16 bits data*/
#define u32bits_read(addr)              ScsiPortReadRegisterUlong((u32bits *)(addr))       /* input  32 bits data*/
#define u08bits_write(addr,data)        ScsiPortWriteRegisterUchar((u08bits *)(addr),(u08bits)(data)) /* output 08 bits data*/
#define u16bits_write(addr,data)        ScsiPortWriteRegisterUshort((u16bits *)(addr),(u16bits)(data)) /* output 16 bits data*/
#define u32bits_write(addr,data)        ScsiPortWriteRegisterUlong((u32bits *)(addr),(u32bits)(data)) /* output 32 bits data*/

#define u08bits_read_mmb(addr)          (*((u08bits MLXFAR *)(addr)))
#define u16bits_read_mmb(addr)          (*((u16bits MLXFAR *)(addr)))
#define u32bits_read_mmb(addr)          (*((u32bits MLXFAR *)(addr)))
#define u08bits_write_mmb(addr,data)    *((u08bits MLXFAR *)(addr)) = data
#define u16bits_write_mmb(addr,data)    *((u16bits MLXFAR *)(addr)) = data
#define u32bits_write_mmb(addr,data)    *((u32bits MLXFAR *)(addr)) = data
#include "mdacasm.c"
#endif  /*MLX_NT_ALPHA*/
#define GetBlockNum(x)                  \
		((((PCDB)(x)->Cdb)->CDB10.LogicalBlockByte0 << 24) |    \
		(((PCDB)(x)->Cdb)->CDB10.LogicalBlockByte1 << 16)  |    \
		(((PCDB)(x)->Cdb)->CDB10.LogicalBlockByte2 <<  8)  |    \
		((PCDB)(x)->Cdb)->CDB10.LogicalBlockByte3)

#define BYTES_IN_THIS_PAGE(datap)  (4096- ((u32bits)(datap) & 0x0FFF))
#define GAM_1SEC_TICKS -10000000        // For 1 sec interval
#define MDAC_FORCE_INTR 0x04

ULONGLONG       MdacTimeTillJan1970;
ULONGLONG       Mdac10msPerTick;

BOOLEAN         Dac1164PDetected        = FALSE;
BOOLEAN         EXR2000Detected         = FALSE;
BOOLEAN         EXR3000Detected         = FALSE;
BOOLEAN         Dac960PGDetected        = FALSE;
BOOLEAN         LEOPDetected            = FALSE;
BOOLEAN         LYNXDetected            = FALSE;
BOOLEAN         BOBCATDetected          = FALSE;

BOOLEAN         forceScanDac1164P       = FALSE;
BOOLEAN         forceScanEXR2000        = FALSE;
BOOLEAN         forceScanEXR3000        = FALSE;
BOOLEAN         forceScanLEOP           = FALSE;
BOOLEAN         forceScanLYNX           = FALSE;
BOOLEAN         forceScanBOBCAT         = FALSE;

u32bits		mdacActiveControllers	= 0;
u32bits		MaxMemToAskFor		= MAXMEMSIZE;
u32bits         mdacnt_dbg              = 1;
u32bits         mdacnt_dbg1             = 1;
u32bits         mdacnt_dbg2             = 0;
s32bits         MdacSleepCount          = 0, MdacActiveCount = 0;
u32bits         TotalReqs 		= 0;
PVOID           lastSrb 		= 0;
PSCSI_REQUEST_BLOCK plastErrorSrb 	= 0;
SCSI_REQUEST_BLOCK lastErrorSrb;
u32bits		FirstCallToMdacEntry  	= 0;
CHAR 		ReadWriteArgument[256]	= {0};
CHAR 		ReadWriteKeyWord[256]	= {0};

#if defined MLX_NT_ALPHA
u32bits dummy_vaddr = 0, dummy_paddr = 0;
SCSI_PHYSICAL_ADDRESS dummy_physaddr;
u32bits dummy_length;

/* Device Specific Memory related */
#define MDAC_MAX_4K_DSM 128
#define MDAC_MAX_8K_DSM 128

typedef struct mdac_dsm_addr_struct {
    ULONG VAddr;
    ULONG PAddr;
    struct mdac_dsm_addr_struct *Next;
    ULONG Reserved;
    PHYSICAL_ADDRESS PhysAddrNT;
} MDAC_DSM_ADDR, *PMDAC_DSM_ADDR;

typedef struct {
    PADAPTER_OBJECT AdapterObject;
    ULONG MaxMapReg;
    PMDAC_DSM_ADDR DsmHeap4k;
    PMDAC_DSM_ADDR DsmStack4k;
    PMDAC_DSM_ADDR DsmHeap8k;
    PMDAC_DSM_ADDR DsmStack8k;
    MDAC_DSM_ADDR  DsmPool4k[MDAC_MAX_4K_DSM];
    MDAC_DSM_ADDR  DsmPool8k[MDAC_MAX_8K_DSM];
} MDAC_CTRL_INFO, *PMDAC_CTRL_INFO;

PMDAC_CTRL_INFO MdacCtrlInfoPtr[MDAC_MAXCONTROLLERS+1];
#endif

//
// function prototypes
//
u32bits ntmdac_flushcache(mdac_ctldev_t MLXFAR *ctp,
			  OSReq_t     MLXFAR *osrqp,
			  u32bits timeout,
			  u32bits flag);
u32bits MLXFAR  mdac_flushcmdintr(mdac_req_t MLXFAR *);

BOOLEAN Dac960Interrupt(PVOID HwDeviceExtension);
BOOLEAN mdacnt_initialize(VOID);
BOOLEAN mdacnt_allocmemory(mdac_ctldev_t MLXFAR *ctp);
#if !defined(MLX_NT_ALPHA) && !defined(MLX_WIN9X)
VOID    HotPlugTimer(PDEVICE_EXTENSION pExtension);
ULONG   HotPlugStartStopController(
    PDEVICE_EXTENSION pExtension,
    PSCSI_REQUEST_BLOCK osrqp,
    PPSEUDO_DEVICE_EXTENSION pPseudoExtension,
    ULONG startFlag,
    ULONG retryCount
);
#endif
#ifdef MLX_FIXEDPOOL
u32bits MLXFAR kmem_allocinit(IN mdac_ctldev_t MLXFAR *ctp,IN PPORT_CONFIGURATION_INFORMATION ConfigInfo);
VOID PartialConfigInfo(IN mdac_ctldev_t MLXFAR *ctp,IN PPORT_CONFIGURATION_INFORMATION ConfigInfo);
u32bits MLXFAR kmem_free(mdac_ctldev_t MLXFAR *ctp,u08bits      MLXFAR *smp,u32bits sz);
u08bits MLXFAR *kmem_alloc(mdac_ctldev_t MLXFAR *ctp, u32bits sz);
#endif
#ifdef MLX_NT
u32bits mdacnt_kvtophys(mdac_ctldev_t MLXFAR *ctp, VOID MLXFAR *dp);               
#define nt_copyin(sp,dp,sz)  GamCopyInOut(sp, dp, sz, MLXIOC_IN)
#define nt_copyout(sp,dp,sz) GamCopyInOut(sp, dp, sz, MLXIOC_OUT)

#elif MLX_WIN9X

#define mdacw95_copyin(sp,dp,sz) GamCopyInOut(sp, dp, sz, MLXIOC_IN)
#define mdacw95_copyout(sp,dp,sz) GamCopyInOut(sp, dp, sz, MLXIOC_OUT)

MDAC_MEM_BLOCK  mdac_mem_list[MDAC_MEM_LIST_SIZE] = {0};
BOOLEAN driverInitDone = FALSE;

#endif // MLX_NT

#if defined(MLX_NT_ALPHA)

PMDAC_CTRL_INFO
MdacGetAdpObj(ULONG BusNumber)
{
    DEVICE_DESCRIPTION  devDesc;
    ULONG numMapReg = 17;
    PMDAC_CTRL_INFO mdacCtrlInfoPtr;

    if ((mdacCtrlInfoPtr = (PMDAC_CTRL_INFO)mdac_allocmem(mdac_ctldevtbl, sizeof(MDAC_CTRL_INFO))) == NULL)
	return(NULL);
    devDesc.Version = DEVICE_DESCRIPTION_VERSION;
    devDesc.Master = TRUE;
    devDesc.ScatterGather = TRUE;
    devDesc.DemandMode = FALSE;
    devDesc.AutoInitialize = FALSE;
    devDesc.Dma32BitAddresses = TRUE;
    devDesc.IgnoreCount = FALSE;
    devDesc.Reserved1 = FALSE;          // must be false
    devDesc.Reserved2 = FALSE;          // must be false
    devDesc.BusNumber = (UCHAR)BusNumber;
    devDesc.DmaChannel = 0;
    devDesc.InterfaceType = PCIBus;
    devDesc.DmaWidth = Width32Bits;
    devDesc.DmaSpeed = Compatible;
    devDesc.MaximumLength = 128 * 1024;
    devDesc.DmaPort = 0;
    if ((mdacCtrlInfoPtr->AdapterObject = HalGetAdapter(&devDesc, &numMapReg)) == NULL) {
	mlx_freemem(mdac_ctldevtbl, mdacCtrlInfoPtr, sizeof(MDAC_CTRL_INFO));
	return(NULL);
    }
    mdacCtrlInfoPtr->MaxMapReg = numMapReg;
    mdacCtrlInfoPtr->DsmHeap4k = mdacCtrlInfoPtr->DsmPool4k;
    mdacCtrlInfoPtr->DsmStack4k = NULL;
    for (numMapReg=0; numMapReg < MDAC_MAX_4K_DSM-1; numMapReg++) {
	mdacCtrlInfoPtr->DsmPool4k[numMapReg].Next =
	    &(mdacCtrlInfoPtr->DsmPool4k[numMapReg+1]);
    }
    mdacCtrlInfoPtr->DsmPool4k[numMapReg].Next = NULL;
    mdacCtrlInfoPtr->DsmHeap8k = mdacCtrlInfoPtr->DsmPool8k;
    mdacCtrlInfoPtr->DsmStack8k = NULL;
    for (numMapReg=0; numMapReg < MDAC_MAX_8K_DSM-1; numMapReg++) {
	mdacCtrlInfoPtr->DsmPool8k[numMapReg].Next =
	    &(mdacCtrlInfoPtr->DsmPool8k[numMapReg+1]);
    }
    mdacCtrlInfoPtr->DsmPool8k[numMapReg].Next = NULL;
    return(mdacCtrlInfoPtr);
}
#endif /*MLX_NT_ALPHA*/


VOID
mdacScsiPortNotification(PVOID DeviceExtension,PSCSI_REQUEST_BLOCK Srb)
{
	if (Srb->SrbStatus != SRB_STATUS_SUCCESS)
	{
		((PDEVICE_EXTENSION)DeviceExtension)->lastErrorSrb = (PVOID) Srb;
		plastErrorSrb = Srb;
	//      lastErrorSrb = *Srb;
	}
	ScsiPortNotification(RequestComplete,DeviceExtension,Srb);

}


VOID
RequestCompleted(
	PVOID DeviceExtension,
	PSCSI_REQUEST_BLOCK Srb
)
{
	mdac_ctldev_t MLXFAR *ctp = ((PDEVICE_EXTENSION)DeviceExtension)->ctp;
	ULONG pathId = Srb->PathId;
	ULONG targetId = Srb->TargetId;
	ULONG lun = Srb->Lun;
    u08bits irql;

	mdacScsiPortNotification(DeviceExtension,Srb);

	if (ctp->cd_Status & MDACD_SLAVEINTRCTLR) {
        mdac_prelock(&irql);
	    mdac_ctlr_lock(ctp);
	    u08bits_write(ctp->cd_LocalDoorBellReg, MDAC_FORCE_INTR);
	    mdac_ctlr_unlock(ctp);
        mdac_postlock(irql);
	}
}

VOID
Gam_Mdac_MisMatch(
	mdac_req_t MLXFAR *rqp
)
{
	PVOID deviceExtension = (PVOID) rqp->rq_ctp->cd_deviceExtension;
	ScsiPortLogError(deviceExtension,NULL,0,0,0,SP_BAD_FW_ERROR,'MAG');
}

#ifdef MLX_FIXEDPOOL

#ifdef MLX_NT

u32bits
mdacnt_kvtophys(mdac_ctldev_t MLXFAR *ctp, VOID MLXFAR *dp)               
{
	u32bits Len;

	return (ScsiPortConvertPhysicalAddressToUlong(ScsiPortGetPhysicalAddress( 
				(PVOID)(ctp->cd_deviceExtension),NULL,(PVOID)dp,&Len)));
}

SCSI_PHYSICAL_ADDRESS
mdacnt_kvtophys3(mdac_ctldev_t MLXFAR *ctp, VOID MLXFAR *dp) 
{
	u32bits Len;
	return (ScsiPortGetPhysicalAddress((PVOID)(ctp->cd_deviceExtension),
			NULL,(PVOID)dp,&Len));
}

#endif /* ifdef MLX_NT */

 
/* allocates 256 KB memory and adds to our pool */
u32bits MLXFAR
kmem_allocinit(
	IN mdac_ctldev_t MLXFAR *ctp,
	IN PPORT_CONFIGURATION_INFORMATION ConfigInfo
)
{
	u08bits MLXFAR *va;     /* virtual address */
	PDEVICE_EXTENSION pCard;
	MdacInt3();
	// prepare for the call to ScsiPortGetUncachedExtension
	PartialConfigInfo(ctp,ConfigInfo);
	if (!(va = (u08bits MLXFAR *)ScsiPortGetUncachedExtension(ctp->cd_deviceExtension,
								ConfigInfo,MaxMemToAskFor)))
	{
	    DebugPrint((0, "kmem_allocinit: could not allocate 64K\n"));
	    return MLXERR_NOMEM;
	}
	mdaczero(va, MaxMemToAskFor);
	pCard = (PDEVICE_EXTENSION )ctp->cd_deviceExtension;
	pCard->lastmfp = pCard->freemem;
	return kmem_free(ctp,va,MaxMemToAskFor);    /* add the memory in free pool */
}

VOID
PartialConfigInfo(
IN mdac_ctldev_t MLXFAR *ctp,
PPORT_CONFIGURATION_INFORMATION ConfigInfo
)
{

	// Set the fields that need to be initialized before ScsiPortGetUncachedExtension
	// can be called.  Some will be adjusted before returning from the FindAdapter
	// routine (by values set in mdac_ctlinit() ).

	ConfigInfo->ScatterGather     = TRUE;
	ConfigInfo->Master            = TRUE;
	ConfigInfo->CachesData        = TRUE;
	ConfigInfo->Dma32BitAddresses = TRUE;
	ConfigInfo->BufferAccessScsiPortControlled = TRUE;
	ConfigInfo->MaximumTransferLength = 0xffffff;
    ConfigInfo->NumberOfPhysicalBreaks = 0x40; //jhr - This should be computed, not hard-coded.
	ctp->cd_MaxSGLen = 0x40;					//jhr - Just to keep things sane for the moment.
	ConfigInfo->DmaWidth			= Width32Bits;
#ifdef NEW_API 
#ifdef WINNT_50
	ConfigInfo->Dma64BitAddresses = SCSI_DMA64_MINIPORT_SUPPORTED;
	ConfigInfo->Dma32BitAddresses = FALSE;
#endif
#endif
	ConfigInfo->SrbExtensionSize = MDAC_SRB_EXTENSION_SIZE;

} // end PartialConfigInfo()


u32bits MLXFAR
kmem_free(
mdac_ctldev_t MLXFAR *ctp,
u08bits MLXFAR *smp,
u32bits sz
)
{
	u08bits         MLXFAR  *emp;   /* ending memory address */
	memfrag_t       MLXFAR  *mfp;
	memfrag_t       MLXFAR  *smfp;
	PDEVICE_EXTENSION pCard = (PDEVICE_EXTENSION)ctp->cd_deviceExtension;

/*  @Kawase, lastmfp should not be set in this function.  
	pCard->lastmfp = pCard->freemem;
*/
	sz = (sz+MEMOFFSET) & MEMPAGE;
	emp = smp + sz;                 /* ending memory address */
	mdac_link_lock();
/*  @Kawase, lastmfp is the last valid segment.
	for (mfp=pCard->freemem; mfp<pCard->lastmfp; mfp++)
*/
	for (mfp=pCard->freemem; mfp<=pCard->lastmfp; mfp++)
	{       /* first try to merge with exiting memory fragments */
		if (mfp->mf_Addr == emp)
		{
			mfp->mf_Addr = smp;
			goto merge_mfp;
		}
		if ((mfp->mf_Addr+mfp->mf_Size) == smp) goto merge_mfp;
	}
  
	/* let us find free spot and merge it */ 
/*  @Kawase, lastmfp is the last valid segment.
	for (mfp=pCard->freemem; mfp<pCard->lastmfp; mfp++)
*/
	for (mfp=pCard->freemem; mfp<=pCard->lastmfp; mfp++)
		if (!mfp->mf_Size) goto outadd;
	if (pCard->lastmfp >= &pCard->freemem[MAXMEMFRAG])
	{
		mdac_link_unlock();
		return MLXERR_BIGDATA;  /* too many fragments */
	}
/*  @Kawase
	mfp = pCard->lastmfp++;
*/
    //Here comes when a new segment is added at the end of the freemem.
    pCard->lastmfp++;

outadd: mfp->mf_Addr = smp;
	mfp->mf_Size = sz;
	mdac_link_unlock();
	return 0;

merge_smfp:
	smfp->mf_Addr = 0; 
	smfp->mf_Size = 0;

merge_mfp:                      /* see if any more segment can be merged */
	mfp->mf_Size += sz;
	sz = mfp->mf_Size;
	smp = mfp->mf_Addr;
	emp = smp + sz;
/*  @Kawase, lastmfp is the last valid segment.
	for (smfp=mfp, mfp=pCard->freemem; mfp<pCard->lastmfp; mfp++)
*/
	for (smfp=mfp, mfp=pCard->freemem; mfp<=pCard->lastmfp; mfp++)
	{
		if (mfp->mf_Addr == emp)
		{
			mfp->mf_Addr = smp;
			goto merge_smfp;
		}
		if ((mfp->mf_Addr+mfp->mf_Size) == smp) goto merge_smfp;
	}
	mdac_link_unlock();
	return 0;       /* no more merge is possible */
}

u08bits MLXFAR *
kmem_alloc(
mdac_ctldev_t MLXFAR *ctp,
u32bits sz
)
{
	u08bits         MLXFAR  *mp;
	memfrag_t       MLXFAR  *smfp;
	memfrag_t       MLXFAR  *mfp;
	PDEVICE_EXTENSION pCard = (PDEVICE_EXTENSION )ctp->cd_deviceExtension;

	sz = (sz+MEMOFFSET) & MEMPAGE;
	mdac_link_lock();
/*  @Kawase, lastmfp is the last valid segment.
	for (smfp=0, mfp=pCard->freemem; mfp<pCard->lastmfp; mfp++)
*/
	for (smfp=0, mfp=pCard->freemem; mfp<=pCard->lastmfp; mfp++)
	{
		if (sz > mfp->mf_Size) continue;
		if (!smfp) smfp = mfp;
		if (mfp->mf_Size < smfp->mf_Size) smfp = mfp;
	}
	if (!(mfp=smfp))
	{
		mdac_link_unlock();
		return 0;
	}
	mp = mfp->mf_Addr;
	mfp->mf_Addr += sz;
	if (!(mfp->mf_Size -= sz)) mfp->mf_Addr = 0;    /* free */
	mdac_link_unlock();
	return mp;
}

#endif //#ifdef MLX_FIXEDPOOL


VOID
UpdateConfigInfo(
	IN mdac_ctldev_t MLXFAR *ctp,
	IN PPORT_CONFIGURATION_INFORMATION ConfigInfo
)

/*++

Routine Description:

	
Arguments:

	ctp         - Controller state information.
	ConfigInfo  - Port configuration information structure.

Return Value:

	TRUE if commands complete successfully.

--*/

{
	ULONG inx;

	// Indicate that this adapter is a busmaster, supports scatter/gather,
	// caches data and can do DMA to/from physical addresses above 16MB.

	ConfigInfo->ScatterGather     = TRUE;
	ConfigInfo->Master            = TRUE;
	ConfigInfo->CachesData        = TRUE;
	ConfigInfo->Dma32BitAddresses = TRUE;
	ConfigInfo->BufferAccessScsiPortControlled = TRUE;

	ConfigInfo->MaximumTransferLength = ctp->cd_MaxSCDBTxSize;

	if (ctp->cd_Status & MDACD_NEWCMDINTERFACE)
	{

#ifdef  WINNT_50
		ConfigInfo->Dma64BitAddresses = SCSI_DMA64_MINIPORT_SUPPORTED;
		ConfigInfo->Dma32BitAddresses = FALSE;
#endif
	    // Set Maximum number of physical segments.

#ifdef MLX_NT
	    ConfigInfo->NumberOfPhysicalBreaks = ctp->cd_MaxSGLen;
#elif MLX_WIN9X
	    ConfigInfo->NumberOfPhysicalBreaks = mlx_min(32, ctp->cd_MaxSGLen);
#endif
	    //
	    // Ask system to scan target ids 16. Logical drives will appear
	    // on virtual channels.
	    //
	    // Firmware uses 2 virtual channels to map 32 logical drives.
	    //

	    ConfigInfo->MaximumNumberOfTargets = mlx_min(MDAC_MAXTARGETS, 16);

	    // Set number of channels.
#ifdef GAM_SUPPORT
	    ConfigInfo->NumberOfBuses = ctp->cd_MaxChannels + 1;
#else
	    ConfigInfo->NumberOfBuses = ctp->cd_MaxChannels;
#endif

	    DebugPrint((0, "MaxTxLength 0x%x bytes, #buses %d MaxCmds %d, MaxSGLen %d\n",
			ConfigInfo->MaximumTransferLength,
			ConfigInfo->NumberOfBuses,
			ctp->cd_MaxCmds,
			ConfigInfo->NumberOfPhysicalBreaks));
	}
	else
	{
	    //
	    // Set Maximum number of physical segments.
	    //

#ifdef MLX_NT

	    ConfigInfo->NumberOfPhysicalBreaks = ctp->cd_MaxSGLen;
#elif MLX_WIN9X
	    ConfigInfo->NumberOfPhysicalBreaks = mlx_min(32, ctp->cd_MaxSGLen);
#endif
	    //
	    // Ask system to scan target ids 32. System drives will appear
	    // at PathID DAC960_SYSTEM_DRIVE_CHANNEL, target ids 0-31.
	    //

	    ConfigInfo->MaximumNumberOfTargets = 32;

	    // Set number of channels.
    
	    ConfigInfo->NumberOfBuses = MAXIMUM_CHANNELS;

	    DebugPrint((0, "MaxTxLength 0x%x bytes, #buses %d MaxCmds %d, MaxSGLen %d\n",
			ConfigInfo->MaximumTransferLength,
			ConfigInfo->NumberOfBuses,
			ctp->cd_MaxCmds,
			ConfigInfo->NumberOfPhysicalBreaks));
	}

	// Indicate that each initiator is at id 254 for each bus.

	for (inx = 0; inx < ConfigInfo->NumberOfBuses; inx++)
	{
		ConfigInfo->InitiatorBusId[inx] = (UCHAR) 254;
	}

} // end UpdateConfigInfo()


ULONG
Dac960PciFindAdapterOld(
	IN PVOID HwDeviceExtension,
	IN PVOID Context,
	IN PVOID BusInformation,
	IN PCHAR ArgumentString,
	IN OUT PPORT_CONFIGURATION_INFORMATION ConfigInfo,
	OUT PBOOLEAN Again
)

/*++

Routine Description:
						   
	This function is called by the OS-specific port driver after
	the necessary storage has been allocated, to gather information
	about the adapter's configuration.

Arguments:

	HwDeviceExtension - HBA miniport driver's adapter data storage
	Context - Not used.
	BusInformation - Bus Specific Information.
	ArgumentString - Not used.
	ConfigInfo - Data shared between system and driver describing an adapter.
	Again - Indicates that driver wishes to be called again to continue
	search for adapters.

Return Value:

	TRUE if adapter present in system

--*/

{
	mdac_ctldev_t MLXFAR    *ctp = &mdac_ctldevtbl[mda_Controllers];
	ULONG                   inx, j;
	BOOLEAN                 memoryRangeFound = FALSE;
	PCI_COMMON_CONFIG       pciConfig;
	ULONG                   rc, ArgValue;
	USHORT                  vendorID;
	USHORT                  deviceID;
	USHORT                  subVendorID;
	USHORT                  subSystemID;
	BOOLEAN                 comingOffHybernation = FALSE;

	ULONG                   length;

    
	MdacInt3();
	DebugPrint((0, "Cfg->IntLevel 0x%lx, Cfg->IntVector 0x%lx\n",
		    ConfigInfo->BusInterruptLevel,
		    ConfigInfo->BusInterruptVector));
	DebugPrint((0, "Cfg->BusNo 0x%lx, Cfg->SlotNo 0x%lx\n",
		    ConfigInfo->SystemIoBusNumber,
		    ConfigInfo->SlotNumber));

#ifdef WINNT_50

	//
	// Is this a new controller ?
	//

	if (((PDEVICE_EXTENSION)HwDeviceExtension)->ctp)
	{
	    ctp = ((PDEVICE_EXTENSION)HwDeviceExtension)->ctp;
	    comingOffHybernation = TRUE;

	    DebugPrint((0, "PciFindAdapter: devExt 0x%I, ctp 0x%I already Initialized.\n",
			HwDeviceExtension, ctp));
	    mdacActiveControllers++;
	    goto controllerAlreadyInitialized;
	}
#endif

	//                                 
	// Check for configuration information passed in from system.
	//

	if ((*ConfigInfo->AccessRanges)[0].RangeLength == 0) 
	{
	    DebugPrint((0,
		       "Dac960PciFindAdapter: No configuration information\n"));

	    *Again = FALSE;
		NotFound(1);
	    return SP_RETURN_NOT_FOUND;
	}

	//
	// Look at PCI Config Information to determine board type
	//

	if (BusInformation != (PVOID) NULL)
	{
	    //
	    // Get VendorID and DeviceID from PCI Config Space
	    //

	    vendorID = ((PPCI_COMMON_CONFIG) BusInformation)->VendorID;
	    deviceID = ((PPCI_COMMON_CONFIG) BusInformation)->DeviceID;

	    //
	    // Get SubVendorID and SubSystemID from PCI Config Space
	    //

	    subVendorID = ((PPCI_COMMON_CONFIG) BusInformation)->u.type0.SubVendorID;
	    subSystemID = ((PPCI_COMMON_CONFIG) BusInformation)->u.type0.SubSystemID;
	}
	else {

	    //
	    // Get PCI Config Space information for Mylex Disk Array Controller
	    //

	    rc = ScsiPortGetBusData(HwDeviceExtension,
				    PCIConfiguration,
				    ConfigInfo->SystemIoBusNumber,
				     ConfigInfo->SlotNumber,
				    (PVOID) &pciConfig,
				    sizeof(PCI_COMMON_CONFIG));

	    if (rc == 0 || rc == 2) {
		DebugPrint((0, "PciFindAdapterOld: ScsiPortGetBusData Error: 0x%x\n", rc));

		*Again = TRUE;
		NotFound(2);
		return SP_RETURN_NOT_FOUND;
	    }
	    else {
		//
		// Get VendorID and DeviceID from PCI Config Space
		//
    
		vendorID = pciConfig.VendorID;
		deviceID = pciConfig.DeviceID;

		//
		// Get SubVendorID and SubSystemID from PCI Config Space
		//
    
		subVendorID = pciConfig.u.type0.SubVendorID;
		subSystemID = pciConfig.u.type0.SubSystemID;
	    }
	}

	DebugPrint((0, "PciFindAdapterOld: vendorID 0x%x, deviceID 0x%x, subVendorID 0x%x, subSystemID 0x%x\n",
			vendorID, deviceID, subVendorID, subSystemID));

	if (vendorID == MLXPCI_VID_DIGITAL)
	{ 
	    if ((deviceID != MLXPCI_DEVID_DEC_FOOT_BRIDGE) ||
		(subVendorID != MLXPCI_VID_MYLEX) ||
		(subSystemID != MLXPCI_DEVID_PVX))
	    {
		DebugPrint((0, "PciFindAdapterOld: Not our device.\n"));
    
		*Again = TRUE;
		NotFound(3);
		return SP_RETURN_NOT_FOUND;
	    }
	}
	else if (vendorID == MLXPCI_VID_MYLEX)
	{
	    if ((deviceID != MLXPCI_DEVID_PDFW2x) &&
		(deviceID != MLXPCI_DEVID_PDFW3x) &&
		(deviceID != MLXPCI_DEVID_PG) &&
		(deviceID != 0xBA56) &&
		(deviceID != MLXPCI_DEVID_LP))

		{
		DebugPrint((0, "PciFindAdapterOld: Not our device.\n"));
    
		*Again = TRUE;
		NotFound(4);
		return SP_RETURN_NOT_FOUND;
	    }

	//      if (deviceID == MLXPCI_DEVID_LP)
	//              mdac_advancefeaturedisable = 1;
	}
	else
	{
	    DebugPrint((0, "PciFindAdapterOld: Not our device.\n"));

	    *Again = TRUE;
		NotFound(5);
	    return SP_RETURN_NOT_FOUND;
	}

	DebugPrint((0, "#AccessRanges %d\n", ConfigInfo->NumberOfAccessRanges));

	for (j = 0, inx = 0; j < ConfigInfo->NumberOfAccessRanges; j++)
	{
	    if ((*ConfigInfo->AccessRanges)[j].RangeInMemory &&
		    (*ConfigInfo->AccessRanges)[j].RangeLength != 0)
	    {

		if ((vendorID == MLXPCI_VID_MYLEX) &&
		    (deviceID == 0xBA56))
		{
			(*ConfigInfo->AccessRanges)[j].RangeLength = 0x1000;
		}

		ctp->cd_MemBasePAddr = ScsiPortConvertPhysicalAddressToUlong(
					(*ConfigInfo->AccessRanges)[j].RangeStart);
		ctp->cd_MemBaseSize = (*ConfigInfo->AccessRanges)[j].RangeLength;

		DebugPrint((0, "paddr 0x%lx, len 0x%lx\n", ctp->cd_MemBasePAddr,ctp->cd_MemBaseSize));

		if (ctp->cd_MemBasePAddr >= 0xFFFC0000)
		{
		    DebugPrint((0, "Dac960PciFindAdapter: addr >= 0xFFFC0000\n"));
		    ctp->cd_MemBasePAddr = 0;
		    ctp->cd_MemBaseVAddr = 0;
		}
		if (! memoryRangeFound)
		{
		    memoryRangeFound = TRUE;
		    inx = j;
		}
	    }

	    if (!((*ConfigInfo->AccessRanges)[j].RangeInMemory) &&
		    (*ConfigInfo->AccessRanges)[j].RangeLength != 0)
	    {
		((PDEVICE_EXTENSION)HwDeviceExtension)->ioBaseAddress =
		    ScsiPortConvertPhysicalAddressToUlong(
			(*ConfigInfo->AccessRanges)[j].RangeStart);
	    }
	}

	//
	// setup information for Hot Plug Support
	//

	((PDEVICE_EXTENSION)HwDeviceExtension)->busInterruptLevel = ConfigInfo->BusInterruptLevel;
	((PDEVICE_EXTENSION)HwDeviceExtension)->numAccessRanges = ConfigInfo->NumberOfAccessRanges;

	DebugPrint((0, "busInterruptLevel 0x%x\n",
			ConfigInfo->BusInterruptLevel));

	DebugPrint((0, "numAccessRanges 0x%x\n",
			ConfigInfo->NumberOfAccessRanges));


	for (j = 0; j < ConfigInfo->NumberOfAccessRanges; j++)
	{
	    ((PDEVICE_EXTENSION)HwDeviceExtension)->accessRangeLength[j] = (*ConfigInfo->AccessRanges)[j].RangeLength;
	    length = ((PDEVICE_EXTENSION)HwDeviceExtension)->accessRangeLength[j];
	    DebugPrint((0, "index %d, length 0x%x\n", j, length));
	    if (length == 0)
		((PDEVICE_EXTENSION)HwDeviceExtension)->accessRangeLength[j] = 0x80;
	}

	ctp->cd_BusNo = (u08bits )ConfigInfo->SystemIoBusNumber;
	ctp->cd_FuncNo = (u08bits )((PPCI_SLOT_NUMBER)&ConfigInfo->SlotNumber)->u.bits.FunctionNumber;
	ctp->cd_SlotNo = (u08bits )((PPCI_SLOT_NUMBER)&ConfigInfo->SlotNumber)->u.bits.DeviceNumber;

	//
	// Setup ctp with this controller identification information
	//

	ctp->cd_InterruptVector = (u08bits) ConfigInfo->BusInterruptVector;
	ctp->cd_vidpid = (deviceID << 16) | vendorID;

	if (ctp->cd_MemBasePAddr)
	{
	    if (inx)
	    {
		// Fill in the access array information

		(*ConfigInfo->AccessRanges)[0].RangeStart = 
		    ScsiPortConvertUlongToPhysicalAddress(ctp->cd_MemBasePAddr);

		(*ConfigInfo->AccessRanges)[0].RangeLength = ctp->cd_MemBaseSize;
		(*ConfigInfo->AccessRanges)[0].RangeInMemory = TRUE;
	    }

#ifdef MLX_NT
	    ctp->cd_MemBaseVAddr = (UINT_PTR)
		    ScsiPortGetDeviceBase(HwDeviceExtension,
					  ConfigInfo->AdapterInterfaceType,
					  ConfigInfo->SystemIoBusNumber,
					  (*ConfigInfo->AccessRanges)[0].RangeStart,
					  (*ConfigInfo->AccessRanges)[0].RangeLength,
					  FALSE);
 

#elif MLX_WIN9X
	    //
	    // ScsiPortGetDeviceBase does not return linear address
	    // if the physical address is above 1MB.
	    // Refer Bug# Q169584, June4, 1997
	    //
	    ctp->cd_MemBaseVAddr = mlx_maphystokv(ctp->cd_MemBasePAddr,
						    ctp->cd_MemBaseSize);
#endif

	    DebugPrint((0, "vidpid %lx mapped memory addr %lx\n",
			ctp->cd_vidpid, ctp->cd_MemBaseVAddr));
	}
	else
	{
	    ctp->cd_IOBaseAddr = (UINT_PTR)
			ScsiPortGetDeviceBase(HwDeviceExtension,
					    ConfigInfo->AdapterInterfaceType,
					    ConfigInfo->SystemIoBusNumber,
					    (*ConfigInfo->AccessRanges)[0].RangeStart,
					    MDAC_IOSPACESIZE,
					    TRUE);

	    DebugPrint((0, "Dac960PciFindAdapterOld: vidpid %lx, ioaddress %lx\n",
			 ctp->cd_vidpid,
			 ctp->cd_IOBaseAddr));
	}

	if ((!ctp->cd_MemBaseVAddr) && (!ctp->cd_IOBaseAddr)) {
	    *Again = FALSE;
		NotFound(6);
	    return SP_RETURN_NOT_FOUND;
	}

#if defined(MLX_NT_ALPHA)

	DebugPrint((0, "Bus Number:0x%x\n", ConfigInfo->SystemIoBusNumber));
	if ((MdacCtrlInfoPtr[ctp->cd_ControllerNo] = MdacGetAdpObj(ConfigInfo->SystemIoBusNumber)) == NULL) {
	    DebugPrint((0, "could not get AdpObj\n"));
	    *Again = FALSE;
		NotFound(7);
	    return SP_RETURN_NOT_FOUND;
	}
	else {
	    DebugPrint((0, "AdpObj=0x%x\n", MdacCtrlInfoPtr[ctp->cd_ControllerNo]->AdapterObject));
	    DbgBreakPoint();
	}
#endif  /*MLX_NT_ALPHA*/


	if (ctp->cd_vidpid == MDAC_DEVPIDPV)
	    Dac1164PDetected = TRUE;
	else if ((ctp->cd_vidpid == MDAC_DEVPIDBA) || (ctp->cd_vidpid == MDAC_DEVPIDLP))
	{
	    if (subSystemID == MLXPCI_DEVID_BA)
		EXR2000Detected = TRUE;
	    else if (subSystemID == MLXPCI_DEVID_FA)
		EXR3000Detected = TRUE;
	    else if (subSystemID == MLXPCI_DEVID_LP) 
		LEOPDetected = TRUE;
	    else if (subSystemID == MLXPCI_DEVID_LX) 
		LYNXDetected = TRUE;
	    else if (subSystemID == MLXPCI_DEVID_BC) 
		BOBCATDetected = TRUE;

	    ctp->cd_Status |= MDACD_NEWCMDINTERFACE;
	}

controllerAlreadyInitialized:

	// Initialize mail box register addresses etc.

	ctp->cd_BusType = DAC_BUS_PCI;
	mdac_init_addrs_PCI(ctp);

	// Mark controllers that are sharing interrupts.

	mdac_isintr_shared(ctp);

	//
	// store device extension as cd_irq in controller structure.
	//

	ctp->cd_deviceExtension = (OSctldev_t MLXFAR *) HwDeviceExtension;
	ctp->cd_irq = (UINT_PTR) HwDeviceExtension;
	((PDEVICE_EXTENSION)HwDeviceExtension)->ctp = ctp;

	ctp->cd_ServiceIntr =  mdac_oneintr;

	// Allocate/Initialize buffers for request ids, request buffers, 
	// physical device table etc.
#ifdef MLX_FIXEDPOOL
	if (! comingOffHybernation)
	{
		if (ArgumentString != NULL) 
		{
			ArgValue = (mdacParseArgumentStringComplex(ArgumentString, "dump"));
			if (ArgValue == 1)
			{
				MaxMemToAskFor = REDUCEDMEMSIZE;
				mdac_advancefeaturedisable=1;
			}
		}
		if (kmem_allocinit(ctp, ConfigInfo))
		{
			DebugPrint((0, "Could not allocate busmaster memory for ctp %I\n", ctp));
			*Again = FALSE;
			NotFound(8);
			return SP_RETURN_NOT_FOUND;
		}
	}
#endif

	if (ArgumentString != NULL)
	{
		if (mdacParseArgumentString(ArgumentString, "EnableSIR"))
		{
			mdac_advanceintrdisable		= 0;
			mda_TotalCmdsToWaitForZeroIntr	= 0;
		}

		ArgValue = (mdacParseArgumentStringComplex(ArgumentString, "ConfigureSIR"));
		if ((ArgValue != 0xffffffff) && (((LONG)ArgValue >= 0) && (ArgValue < 65)))
		{
			mda_TotalCmdsToWaitForZeroIntr = (u08bits) ArgValue;
			mdac_advanceintrdisable	       = 0;
		}
	}
	MdacInt3();
	inx = mdac_ctlinit(ctp);

	DebugPrint((0, "cd_Status %x\n",  ctp->cd_Status));
	DebugPrint((0, "cd_ReadCmdIDStatus %I\n",  ctp->cd_ReadCmdIDStatus));
	DebugPrint((0, "cd_CheckMailBox %I\n",  ctp->cd_CheckMailBox));
	DebugPrint((0, "cd_HwPendingIntr %I\n",  ctp->cd_HwPendingIntr));
	DebugPrint((0, "cd_PendingIntr %I\n",  ctp->cd_PendingIntr));
	DebugPrint((0, "cd_SendCmd %I\n",  ctp->cd_SendCmd));
	DebugPrint((0, "cd_ServiceIntr %I\n",  ctp->cd_ServiceIntr));
	DebugPrint((0, "cd_irq %I\n", ctp->cd_irq));
	DebugPrint((0, "cd_InterruptVector %I\n",  ctp->cd_InterruptVector));
	DebugPrint((0, "cd_HostCmdQue %I\n",  ctp->cd_HostCmdQue));
	DebugPrint((0, "cd_HostCmdQueIndex %x\n",  ctp->cd_HostCmdQueIndex));
	DebugPrint((0, "cd_HostStatusQue %I\n",  ctp->cd_HostStatusQue));
	DebugPrint((0, "cd_HostStatusQueIndex %x\n",  ctp->cd_HostStatusQueIndex));

	//
	// Fill ConfigInfo structure.
	//

	UpdateConfigInfo(ctp, ConfigInfo);
	ConfigInfo->InterruptMode = LevelSensitive;

	DebugPrint((0, "Dac960PciFindAdapterOld: a new 0x%lx controller found\n", ctp->cd_vidpid));
	mdac_irqlevel = 26;

	if ((ctp->cd_vidpid == MDAC_DEVPIDPG) ||
	    (ctp->cd_vidpid == MDAC_DEVPIDLP))
	{

	    if (ctp->cd_vidpid == MDAC_DEVPIDPG)
		Dac960PGDetected = TRUE;

#if !defined(MLX_NT_ALPHA) && !defined(MLX_WIN9X)

	    //
	    // Fill in information for PG/LP Bridge device
	    //

	    ((PDEVICE_EXTENSION)HwDeviceExtension)->pciDeviceInfo[0].busNumber = ctp->cd_BusNo;
	    ((PDEVICE_EXTENSION)HwDeviceExtension)->pciDeviceInfo[0].deviceNumber = ctp->cd_SlotNo;
	    ((PDEVICE_EXTENSION)HwDeviceExtension)->pciDeviceInfo[0].functionNumber = 0;

	    //
	    // Fill in information for PG/LP local device
	    //

	    ((PDEVICE_EXTENSION)HwDeviceExtension)->pciDeviceInfo[1].busNumber = ctp->cd_BusNo;
	    ((PDEVICE_EXTENSION)HwDeviceExtension)->pciDeviceInfo[1].deviceNumber = ctp->cd_SlotNo;
	    ((PDEVICE_EXTENSION)HwDeviceExtension)->pciDeviceInfo[1].functionNumber = ctp->cd_FuncNo;
#endif
	}

	if (! comingOffHybernation)
	{
#if !defined(MLX_WIN9X)

	    if (mdacnt_allocmemory(ctp) == FALSE)
	    {
		DebugPrint((0, "Could not allocate Adapter Specific memory for ctp 0x%lx\n", ctp));
		*Again = FALSE;
		NotFound(9);
		return SP_RETURN_NOT_FOUND;
	    }
#endif

	    mdac_newctlfound();
	}

	//
	// Tell system to keep on searching.
	//

	*Again = TRUE;
	WasFound(1);
	return SP_RETURN_FOUND;
	
} // end Dac960PciFindAdapterOld()


u32bits
mdacParseArgumentString(
	IN PCHAR String,
	IN PCHAR KeyWord )

/*++

Routine Description:

This routine will parse the string for a match on the keyword, then
calculate the value for the keyword and return it to the caller.

Arguments:

String - The ASCII string to parse.
KeyWord - The keyword for the value desired.

Return Values:

0x0 if value not found

--*/
{
	PCHAR cptr = String;
	PCHAR kptr = KeyWord;
	PCHAR rwptr = ReadWriteArgument;
	PCHAR rwkptr = ReadWriteKeyWord;
	u32bits StringLength = 0;
	u32bits KeyWordLength = 0;
	u32bits MatchedLen = 0;
	//
	// Calculate the string length and lower case all characters.
	//
	while (*rwptr=*cptr) 
	{

		if (*cptr >= 'A' && *cptr <= 'Z') 
		{
			*rwptr = *cptr + ('a' - 'A');
		}
		cptr++;
		rwptr++;
		StringLength++;
	}

	*rwptr = (char )NULL;	

	//
	// Calculate the keyword length and lower case all characters.
	//
	while (*rwkptr=*kptr) 
	{

		if (*kptr >= 'A' && *kptr <= 'Z') 
		{
			*rwkptr = *kptr + ('a' - 'A');
		}
		kptr++;
		rwkptr++;
		KeyWordLength++;
	}
	*rwkptr = (char )NULL;	
	if (KeyWordLength == StringLength)
	{
		cptr = ReadWriteArgument;
		kptr = ReadWriteKeyWord;
		MatchedLen = 0;
		while (*cptr++ == *kptr++) 
		{
			if ((++MatchedLen) == StringLength)
				return 1;
		}
	}
	
	return 0;
	
} // end mdacParseArgumentString()

u32bits
mdacParseArgumentStringComplex(
	IN PCHAR String,
	IN PCHAR KeyWord )

/*++

Routine Description:

This routine will parse the string for a match on the keyword, then
calculate the value for the keyword and return it to the caller.

Arguments:

String - The ASCII string to parse.
KeyWord - The keyword for the value desired.

Return Values:

0xffffffff if value not found
Value converted from ASCII to binary.

--*/
{
	PCHAR cptr;
	PCHAR kptr;
	PCHAR rwptr = ReadWriteArgument;
	PCHAR rwkptr = ReadWriteKeyWord;
	u32bits value;
	u32bits stringLength = 0;
	u32bits keyWordLength = 0;
	u32bits index;

	//
	// Calculate the string length and lower case all characters.
	//
	cptr = String;
	while (*rwptr=*cptr) {

		if (*cptr >= 'A' && *cptr <= 'Z') {
			*rwptr = *cptr + ('a' - 'A');
			}
		cptr++;
		rwptr++;
		stringLength++;
		}
	*rwptr = (char )NULL;	
	//
	// Calculate the keyword length and lower case all characters.
	//
	cptr = KeyWord;
	while (*rwkptr=*cptr) {

		if (*cptr >= 'A' && *cptr <= 'Z') {
			*rwkptr = *cptr + ('a' - 'A');
			}
		cptr++;
		rwkptr++;
		keyWordLength++;
		}

	*rwkptr = (char )NULL;

	if (keyWordLength > stringLength) {

		//
		// Can't possibly have a match.
		//
		return 0xffffffff;
		}

	//
	// Now setup and start the compare.
	//
	cptr = ReadWriteArgument;

	ContinueSearch:
	//
	// The input string may start with white space. Skip it.
	//
	while (*cptr == ' ' || *cptr == '\t') {
		cptr++;
		}

	if (*cptr == '\0') {

		//
		// end of string.
		//
		return 0xffffffff;
		}

	kptr = ReadWriteKeyWord;
	while (*cptr++ == *kptr++) {

		if (*(cptr - 1) == '\0') {

			//
			// end of string
			//
			return 0xffffffff;
			}
		}

	if (*(kptr - 1) == '\0') {

		//
		// May have a match backup and check for blank or equals.
		//

		cptr--;
		while (*cptr == ' ' || *cptr == '\t') {
			cptr++;
			}

		//
		// Found a match. Make sure there is an equals.
		//
		if (*cptr != '=') {

			//
			// Not a match so move to the next semicolon.
			//
			while (*cptr) {
				if (*cptr++ == ';') {
					goto ContinueSearch;
					}
				}
			return 0xffffffff;
			}

		//
		// Skip the equals sign.
		//
		cptr++;

		//
		// Skip white space.
		//
		while ((*cptr == ' ') || (*cptr == '\t')) {
			cptr++;
			}

		if (*cptr == '\0') {

			//
			// Early end of string, return not found
			//
			return 0xffffffff;
			}

		if (*cptr == ';') {

			//
			// This isn't it either.
			//
			cptr++;
			goto ContinueSearch;
			}

		value = 0;
		if ((*cptr == '0') && (*(cptr + 1) == 'x')) {

			//
			// Value is in Hex. Skip the "0x"
			//
			cptr += 2;
			for (index = 0; *(cptr + index); index++) {

				if (*(cptr + index) == ' ' ||
				*(cptr + index) == '\t' ||
				*(cptr + index) == ';') {
					break;
					}

				if ((*(cptr + index) >= '0') && (*(cptr + index) <= '9')) {
					value = (16 * value) + (*(cptr + index) - '0');
					} else {
					if ((*(cptr + index) >= 'a') && (*(cptr + index) <= 'f')) {
						value = (16 * value) + (*(cptr + index) - 'a' + 10);
						} else {

						//
						// Syntax error, return not found.
						//
						return 0xffffffff;
						}
					}
				}
			} else {

			//
			// Value is in Decimal.
			//
			for (index = 0; *(cptr + index); index++) {

				if (*(cptr + index) == ' ' ||
				*(cptr + index) == '\t' ||
				*(cptr + index) == ';') {
					break;
					}

				if ((*(cptr + index) >= '0') && (*(cptr + index) <= '9')) {
					value = (10 * value) + (*(cptr + index) - '0');
					} else {

					//
					// Syntax error return not found.
					//
					return 0xffffffff;
					}
				}
			}

		return value;
		} else {

		//
		// Not a match check for ';' to continue search.
		//
		while (*cptr) {
			if (*cptr++ == ';') {
				goto ContinueSearch;
				}
			}

		return 0xffffffff;
		}
	} // end mdacParseArgumentStringComplex()


u32bits
NotFound(u32bits num)
{
	MdacInt3();
	return 0;  //jhr - Keeps the compiler happy.
}


u32bits
WasFound(u32bits num)
{
	MdacInt3();
	return 0;  //jhr - Keeps the compiler happy.
}


BOOLEAN
FindPciControllerScanMethod(
    IN PVOID  DeviceExtension,
    IN USHORT VendorID,
    IN USHORT DeviceID,
    IN USHORT SubVendorID,
    IN USHORT SubSystemID,
    IN OUT PULONG FunctionNumber,
    IN OUT PULONG DeviceNumber,
    IN ULONG  BusNumber,
    OUT PBOOLEAN LastSlot,
    OUT UINT_PTR *MemoryAddress,
    OUT u08bits *IrqNumber
    )

/*++

Routine Description:

    Walk PCI slot information looking for Vendor and Product ID matches.

Arguments:

Return Value:

    TRUE if card found. and following parameters are set with appropriate
    values.
    MemoryAddress - Memory Address configured on the controller
    IrqNumber     - Interrupt value configured on the controller

--*/
{
    PDEVICE_EXTENSION   deviceExtension = DeviceExtension;
    ULONG               rangeNumber = 0;
    UCHAR               pciBuffer[64];
    ULONG               deviceNumber;
    ULONG               functionNumber;
    PCI_SLOT_NUMBER     slotData;
    PPCI_COMMON_CONFIG  pciData = (PPCI_COMMON_CONFIG)&pciBuffer;
    ULONG rc;


    DebugPrint((mdacnt_dbg,"FindPciControllerScanMethod Entered\n"));

    slotData.u.AsULONG = 0;

    //
    // Look at each device.
    //

    for (deviceNumber = *DeviceNumber;
	 deviceNumber < PCI_MAX_DEVICES;
	 deviceNumber++) {

	slotData.u.bits.DeviceNumber = deviceNumber;

	//
	// Look at each function.
	//

	for (functionNumber= *FunctionNumber;
	     functionNumber < PCI_MAX_FUNCTION;
	     functionNumber++) {

	    DebugPrint((mdacnt_dbg, "FindPciControllerScanMethod: Trying FUNCTION Number %d devnumber %d\n",
			functionNumber,deviceNumber));

	    slotData.u.bits.FunctionNumber = functionNumber;

	    rc = ScsiPortGetBusData(DeviceExtension,
				    PCIConfiguration,
				    BusNumber,
				    slotData.u.AsULONG,
				    pciData,
				    sizeof(pciBuffer)); 
	    
	     
	     if (!rc) {

		DebugPrint((mdacnt_dbg, "FindPGController: Out OF PCI DATA\n"));

		//
		// Out of PCI data.
		//

		*LastSlot = TRUE;
		return FALSE;
	    }


	    if (pciData->VendorID == PCI_INVALID_VENDORID) {

		//
		// No PCI device, or no more functions on device
		// move to next PCI device.
		//
	       continue;
	    }

	    //
	    // Compare strings.
	    //

	    DebugPrint((mdacnt_dbg,
		       "FindPciControllerScanMethod: Bus %x Slot %x Function %x VendorID %x DeviceID %x SubVendorID %x SubSystemID %x\n",
		       BusNumber,
		       deviceNumber,
		       functionNumber,
		       pciData->VendorID,
		       pciData->DeviceID,
		       pciData->u.type0.SubVendorID,
		       pciData->u.type0.SubSystemID));

	    if ((VendorID != pciData->VendorID) || (DeviceID != pciData->DeviceID))
		continue;

#ifndef MLX_WIN9X
	    if ((pciData->u.type0.SubVendorID != SubVendorID) ||
		(pciData->u.type0.SubSystemID != SubSystemID))
	    {
		continue;
	    }
#endif
	    
	    DebugPrint((mdacnt_dbg,
		       "FindPciControllerScanMethod: Bus %x Slot %x Function %x VendorID %x DeviceID %x SubVendorID %x SubSystemID %x\n",
		       BusNumber,
		       deviceNumber,
		       functionNumber,
		       pciData->VendorID,
		       pciData->DeviceID,
		       pciData->u.type0.SubVendorID,
		       pciData->u.type0.SubSystemID));

	    DebugPrint((mdacnt_dbg, "FindPciControllerScanMethod: IRQ %d BA0 %x BA1 %x BA2 %x Header Type %x\n",
			pciData->u.type0.InterruptLine,
			pciData->u.type0.BaseAddresses[0],
			pciData->u.type0.BaseAddresses[1],
			pciData->u.type0.BaseAddresses[2],
			pciData->HeaderType));

	    *MemoryAddress = pciData->u.type0.BaseAddresses[0];
	 (UCHAR)(*IrqNumber) = pciData->u.type0.InterruptLine;

	    *FunctionNumber = functionNumber;
	    *DeviceNumber   = deviceNumber;

	    return TRUE;

	}   // next PCI function

	*FunctionNumber = 0;

    }   // next PCI slot

    return FALSE;

} // end FindPciControllerScanMethod()

ULONG
Dac960PciFindAdapterNew(
	IN PVOID HwDeviceExtension,
	IN PVOID Context,
	IN PVOID BusInformation,
	IN PCHAR ArgumentString,
	IN OUT PPORT_CONFIGURATION_INFORMATION ConfigInfo,
	OUT PBOOLEAN Again
)

/*++

Routine Description:
						   
	This function is called by the OS-specific port driver after
	the necessary storage has been allocated, to gather information
	about the adapter's configuration.

Arguments:

	HwDeviceExtension - HBA miniport driver's adapter data storage
	Context - Not used.
	BusInformation - Bus Specific Information.
	ArgumentString - Not used.
	ConfigInfo - Data shared between system and driver describing an adapter.
	Again - Indicates that driver wishes to be called again to continue
	search for adapters.

Return Value:

	TRUE if adapter present in system

--*/
{
	mdac_ctldev_t MLXFAR *ctp = &mdac_ctldevtbl[mda_Controllers];
	ULONG           inx;
	static ULONG    functionNumber,
			deviceNumber=0,
			lastBusNumber=0;
	BOOLEAN         lastSlot;
	USHORT          vendorId;
	USHORT          deviceId;
	USHORT          subVendorId;
	USHORT          subSystemId;
	ULONG           ArgValue;
	BOOLEAN      comingOffHybernation = FALSE;

	MdacInt3();
	DebugPrint((0, "Cfg->BusNo 0x%lx, Cfg->SlotNo 0x%lx\n",
		    ConfigInfo->SystemIoBusNumber,
		    ConfigInfo->SlotNumber));
#ifdef WINNT_50

	//
	// Is this a new controller ?
	//

	if (((PDEVICE_EXTENSION)HwDeviceExtension)->ctp)
	{
	    ctp = ((PDEVICE_EXTENSION)HwDeviceExtension)->ctp;
            comingOffHybernation = TRUE;
	}
#endif
	if (forceScanDac1164P)
	{
	    vendorId 	= MLXPCI_VID_DIGITAL;
	    deviceId 	= MLXPCI_DEVID_DEC_FOOT_BRIDGE;
	    subVendorId = MLXPCI_VID_MYLEX;
	    subSystemId = MLXPCI_DEVID_PVX;
	}
	else if (forceScanEXR2000)
	{
	    vendorId 	= MLXPCI_VID_MYLEX;
	    deviceId 	= 0xBA56;
	    subVendorId = MLXPCI_VID_MYLEX;
	    subSystemId = MLXPCI_DEVID_BA;
	}
	else if (forceScanEXR3000)
	{
	    vendorId 	= MLXPCI_VID_MYLEX;
	    deviceId 	= 0xBA56;
	    subVendorId = MLXPCI_VID_MYLEX;
	    subSystemId = MLXPCI_DEVID_FA;
	}
	else if (forceScanLEOP)
	{
	    vendorId 	= MLXPCI_VID_MYLEX;
	    deviceId 	= 0x50;
	    subVendorId = MLXPCI_VID_MYLEX;
	    subSystemId = MLXPCI_DEVID_LP;
	}
	else if (forceScanLYNX)
	{
	    vendorId 	= MLXPCI_VID_MYLEX;
	    deviceId 	= 0x50;
	    subVendorId = MLXPCI_VID_MYLEX;
	    subSystemId = MLXPCI_DEVID_LX;
	}
	else if (forceScanBOBCAT)
	{
	    vendorId 	= MLXPCI_VID_MYLEX;
	    deviceId 	= 0x50;
	    subVendorId = MLXPCI_VID_MYLEX;
	    subSystemId = MLXPCI_DEVID_BC;
	}

	else
	{
	    *Again = FALSE;
	    return SP_RETURN_NOT_FOUND;
	}

	//
	// If we got a different Bus Number than the earlier,
	// we need to start scanning from Device 0 and function 0 on that
	// bus.
	//

	if (lastBusNumber != ConfigInfo->SystemIoBusNumber)
	{
	    lastBusNumber 	= ConfigInfo->SystemIoBusNumber;
	    deviceNumber 	= 0;
	    functionNumber 	= 0;
	}
    

		//
	// Read PCI config space looking for DAC1164P Controllers.
	//

	// Not all the Devices are seen
	lastSlot = FALSE;

	if (FindPciControllerScanMethod(HwDeviceExtension,
				     vendorId,
				     deviceId,
#ifdef MLX_NT
				     subVendorId,
				     subSystemId,
#else
				     0,
				     0,
#endif
				     &functionNumber,
				     &deviceNumber,
				     ConfigInfo->SystemIoBusNumber,
				     &lastSlot,
				     &ctp->cd_MemBasePAddr,
				     &ctp->cd_InterruptVector))
	{
	    if (forceScanDac1164P)
	    {
		ctp->cd_vidpid = MDAC_DEVPIDPV;
		ctp->cd_MemBaseSize = MDAC_HWIOSPACESIZE;
		ctp->cd_BusNo = (u08bits )ConfigInfo->SystemIoBusNumber;
		ctp->cd_SlotNo = (u08bits )deviceNumber;
		ctp->cd_FuncNo = (u08bits )functionNumber;
		ctp->cd_MemBasePAddr &= MDAC_PCIPDMEMBASE_MASK;
		ctp->cd_IOBaseAddr = 0;
		ctp->cd_IOBaseSize = 0;
	    }
	    else if (forceScanEXR2000)
	    {
		ctp->cd_vidpid = MDAC_DEVPIDBA;
		ctp->cd_MemBaseSize = 4*ONEKB;
		ctp->cd_BusNo = (u08bits )ConfigInfo->SystemIoBusNumber;
		ctp->cd_SlotNo = (u08bits )deviceNumber;
		ctp->cd_FuncNo = (u08bits )functionNumber;
		ctp->cd_MemBasePAddr &= MDAC_PCIPDMEMBASE_MASK;
		ctp->cd_IOBaseAddr = 0;
		ctp->cd_IOBaseSize = 0;
	    }
	    else if (forceScanEXR3000)
	    {
		ctp->cd_vidpid = MDAC_DEVPIDBA;
		ctp->cd_MemBaseSize = 4*ONEKB;
		ctp->cd_BusNo = (u08bits )ConfigInfo->SystemIoBusNumber;
		ctp->cd_SlotNo = (u08bits )deviceNumber;
		ctp->cd_FuncNo = (u08bits )functionNumber;
		ctp->cd_MemBasePAddr &= MDAC_PCIPDMEMBASE_MASK;
		ctp->cd_IOBaseAddr = 0;
		ctp->cd_IOBaseSize = 0;
	    }
	    else if ((forceScanLEOP) || (forceScanLYNX) || (forceScanBOBCAT))
	    {
		ctp->cd_vidpid = MDAC_DEVPIDLP;
		ctp->cd_MemBaseSize = 4*ONEKB;
		ctp->cd_BusNo = (u08bits )ConfigInfo->SystemIoBusNumber;
		ctp->cd_SlotNo = (u08bits )deviceNumber;
		ctp->cd_FuncNo = (u08bits )functionNumber;
		ctp->cd_MemBasePAddr &= MDAC_PCIPDMEMBASE_MASK;
		ctp->cd_IOBaseAddr = 0;
		ctp->cd_IOBaseSize = 0;
	    }

	    DebugPrint((0, "Found Mylex Controller. ctp 0x%lx, ctlno 0x%x\n",
			ctp, ctp->cd_ControllerNo));
	    DebugPrint((0, "vidpid 0x%lx, bus 0x%lx slot 0x%lx, int 0x%lx\n",
			ctp->cd_vidpid, ctp->cd_BusNo, ctp->cd_SlotNo,
			ctp->cd_InterruptVector));
	    DebugPrint((0, "MemBasePaddr 0x%lx, MemBaseSize 0x%lx\n",
			ctp->cd_MemBasePAddr, ctp->cd_MemBaseSize));
	    DebugPrint((0, "IoBaseAddr 0x%lx, IoBaseSize 0x%lx\n",
			ctp->cd_IOBaseAddr, ctp->cd_IOBaseSize));
    
	    deviceNumber++;
	    functionNumber = 0;
    
	    //
	    // Update the CONFIGURATION_INFO structure.
	    //
    
	    ((PPCI_SLOT_NUMBER)&ConfigInfo->SlotNumber)->u.bits.FunctionNumber = ctp->cd_FuncNo;
	    ((PPCI_SLOT_NUMBER)&ConfigInfo->SlotNumber)->u.bits.DeviceNumber = ctp->cd_SlotNo;

	    DebugPrint((0, "Cfg->SlotNo set to 0x%lx\n", ConfigInfo->SlotNumber));

	    if ( !ConfigInfo->BusInterruptLevel )
	    {
		ConfigInfo->BusInterruptLevel = ctp->cd_InterruptVector;
		ConfigInfo->BusInterruptVector = ctp->cd_InterruptVector;
	    }
	
	    if (!ConfigInfo->BusInterruptVector)
	    {
		ConfigInfo->BusInterruptVector = ctp->cd_InterruptVector;
		ConfigInfo->BusInterruptLevel = ctp->cd_InterruptVector;
		DebugPrint((0, "Cfg->BusInterruptVector 0, set to 0x%x\n",
			    ConfigInfo->BusInterruptVector));
	    }
	    else
	    {
		DebugPrint((0, "Cfg->BusInterruptVector 0x%x, set to 0x%x\n",
			    ConfigInfo->BusInterruptVector,
			    ctp->cd_InterruptVector));
    
		ConfigInfo->BusInterruptVector = ctp->cd_InterruptVector;
		ConfigInfo->BusInterruptLevel = ctp->cd_InterruptVector;
	    }
    

	    if (ctp->cd_MemBasePAddr)
	    {
		// Fill in the access array information

		(*ConfigInfo->AccessRanges)[0].RangeStart = 
		    ScsiPortConvertUlongToPhysicalAddress(ctp->cd_MemBasePAddr);
		(*ConfigInfo->AccessRanges)[0].RangeLength = ctp->cd_MemBaseSize;
		(*ConfigInfo->AccessRanges)[0].RangeInMemory = TRUE;
		ConfigInfo->NumberOfAccessRanges = 1;

		DebugPrint((mdacnt_dbg, "busType %d, sysIoBus# %d\n",
			    ConfigInfo->AdapterInterfaceType,
			    ConfigInfo->SystemIoBusNumber));

#ifdef MLX_NT
		ctp->cd_MemBaseVAddr = (UINT_PTR)
			ScsiPortGetDeviceBase(HwDeviceExtension,
					      ConfigInfo->AdapterInterfaceType,
					      ConfigInfo->SystemIoBusNumber,
					      (*ConfigInfo->AccessRanges)[0].RangeStart,
					      (*ConfigInfo->AccessRanges)[0].RangeLength,
					      FALSE);

#elif MLX_WIN9X
		//
		// ScsiPortGetDeviceBase does not return linear address
		// if the physical address is above 1MB.
		// Refer Bug# Q169584, June4, 1997
		//
		ctp->cd_MemBaseVAddr = mlx_maphystokv(ctp->cd_MemBasePAddr,
						      ctp->cd_MemBaseSize);
#endif
		DebugPrint((0, "mapped memory addr %lx\n", ctp->cd_MemBaseVAddr));
	    }
	    else if (ctp->cd_IOBaseAddr)
	    {
		(*ConfigInfo->AccessRanges)[0].RangeStart = 
		    ScsiPortConvertUlongToPhysicalAddress(ctp->cd_IOBaseAddr);
		(*ConfigInfo->AccessRanges)[0].RangeLength = ctp->cd_IOBaseSize;
		(*ConfigInfo->AccessRanges)[0].RangeInMemory = FALSE;
		ConfigInfo->NumberOfAccessRanges = 1;

		ctp->cd_IOBaseAddr = (UINT_PTR)
					ScsiPortGetDeviceBase(HwDeviceExtension,
						ConfigInfo->AdapterInterfaceType,
						ConfigInfo->SystemIoBusNumber,
						(*ConfigInfo->AccessRanges)[0].RangeStart,
						(*ConfigInfo->AccessRanges)[0].RangeLength,
						TRUE);

		DebugPrint((0, "mapped ioaddr 0x%lx\n", ctp->cd_IOBaseAddr));
	    }

	    if ((!ctp->cd_MemBaseVAddr) && (!ctp->cd_IOBaseAddr))
	    {
		DebugPrint((0, "MemBaseVAddr and IOBaseAddr NULL\n"));
		*Again = FALSE;
		return SP_RETURN_NOT_FOUND;
	    }

	    if (forceScanDac1164P)
	    {
		//
		// setup information for Hot Plug Support
		//
    
		((PDEVICE_EXTENSION)HwDeviceExtension)->busInterruptLevel = ConfigInfo->BusInterruptLevel;
    
		//
		// Hardcoded values for DAC1164P controller.
		//
		// Uses 3 ranges
		//
		// 1.  Memory Space     - Length 0x80 bytes
		// 2.  IO Space         - Length 0x80 bytes
		// 3.  Memory Space     - Length 0x2000000 bytes
		//
    
		((PDEVICE_EXTENSION)HwDeviceExtension)->numAccessRanges = 3;
		((PDEVICE_EXTENSION)HwDeviceExtension)->accessRangeLength[0] = 0x80;
		((PDEVICE_EXTENSION)HwDeviceExtension)->accessRangeLength[1] = 0x80;
		((PDEVICE_EXTENSION)HwDeviceExtension)->accessRangeLength[2] = 0x2000000;
	    }
	    else if ((forceScanEXR2000) || (forceScanEXR3000) || (forceScanLEOP) 
 		     || (forceScanLYNX) || (forceScanBOBCAT))
			ctp->cd_Status |= MDACD_NEWCMDINTERFACE;
	    //
	    // Initialize mail box register addresses etc.
	    //
    
	    ctp->cd_BusType = DAC_BUS_PCI;
	    mdac_init_addrs_PCI(ctp);

	    //
	    // Mark controllers that are sharing interrupts.
	    //

	    mdac_isintr_shared(ctp);
	
	    //
	    // Store device extension in controller structure pointer.
	    // store device extension as cd_irq in controller structure.
	    //

	    ctp->cd_deviceExtension = (OSctldev_t MLXFAR *) HwDeviceExtension;
	    ctp->cd_irq = (UINT_PTR) HwDeviceExtension;
	    ((PDEVICE_EXTENSION)HwDeviceExtension)->ctp = ctp;

	    ctp->cd_ServiceIntr = mdac_oneintr;
		//
	    // Allocate/Initialize buffers for request ids, request buffers, 
	    // physical device table etc.
	    //
#ifdef MLX_FIXEDPOOL

	     if (! comingOffHybernation)
	     {
		if (ArgumentString != NULL) 
		{
			ArgValue = (mdacParseArgumentStringComplex(ArgumentString, "dump"));
			if (ArgValue == 1)
			{
				MaxMemToAskFor = REDUCEDMEMSIZE;
				mdac_advancefeaturedisable=1;
			}
		}
		if (kmem_allocinit(ctp, ConfigInfo))
		{
			DebugPrint((0, "Could not allocate busmaster memory for ctp 0x%lx\n", ctp));
			*Again = FALSE;
			NotFound(8);
			return SP_RETURN_NOT_FOUND;
		}
	     }
#endif

	if (ArgumentString != NULL)
	{
		if (mdacParseArgumentString(ArgumentString, "EnableSIR"))
		{
			mdac_advanceintrdisable 	= 0;
			mda_TotalCmdsToWaitForZeroIntr  = 0;
		}

		ArgValue = (mdacParseArgumentStringComplex(ArgumentString, "SIRCnt"));
		if ((ArgValue != 0xffffffff) && (((LONG)ArgValue >= 0) && (ArgValue < 65)))
		{
			mda_TotalCmdsToWaitForZeroIntr = (u08bits) ArgValue;
			mdac_advanceintrdisable	       = 0;
		}
	}
	MdacInt3();
	inx = mdac_ctlinit(ctp);

	    DebugPrint((0, "cd_Status %lx\n",  ctp->cd_Status));
	    DebugPrint((0, "cd_ReadCmdIDStatus %lx\n",  ctp->cd_ReadCmdIDStatus));
	    DebugPrint((0, "cd_CheckMailBox %lx\n",  ctp->cd_CheckMailBox));
	    DebugPrint((0, "cd_HwPendingIntr %lx\n",  ctp->cd_HwPendingIntr));
	    DebugPrint((0, "cd_PendingIntr %lx\n",  ctp->cd_PendingIntr));
	    DebugPrint((0, "cd_SendCmd %lx\n",  ctp->cd_SendCmd));
	    DebugPrint((0, "cd_ServiceIntr %lx\n",  ctp->cd_ServiceIntr));
	    DebugPrint((0, "cd_irq %I\n", ctp->cd_irq));
	    DebugPrint((0, "cd_InterruptVector %lx\n",  ctp->cd_InterruptVector));
	    DebugPrint((0, "cd_HostCmdQue %lx\n",  ctp->cd_HostCmdQue));
	    DebugPrint((0, "cd_HostCmdQueIndex %lx\n",  ctp->cd_HostCmdQueIndex));
	    DebugPrint((0, "cd_HostStatusQue %lx\n",  ctp->cd_HostStatusQue));
	    DebugPrint((0, "cd_HostStatusQueIndex %lx\n",  ctp->cd_HostStatusQueIndex));
    
	    //
	    // Fill ConfigInfo structure.
	    //
    
	    UpdateConfigInfo(ctp, ConfigInfo);
	    ConfigInfo->InterruptMode = LevelSensitive;

	    DebugPrint((0, "Dac960PciFindAdapterNew: a new controller found\n"));
	    mdac_irqlevel = 26;

#if !defined(MLX_WIN9X)

	    if (mdacnt_allocmemory(ctp) == FALSE)
	    {
		DebugPrint((0, "Could not allocate Adapter Specific memory for ctp 0x%lx\n", ctp));
		*Again = FALSE;
		return SP_RETURN_NOT_FOUND;
	    }
#endif

	    mdac_newctlfound();
	    Dac1164PDetected = TRUE;

	    *Again = TRUE;
	    return SP_RETURN_FOUND;
	}
    
	//
	// If all the Bus is scanned , don't ask to reenter again
	//
    
	if (lastSlot == TRUE) {
	    functionNumber = 0;
	    deviceNumber = 0;
	    lastSlot = FALSE;
	    lastBusNumber = 0;
    
	    *Again = FALSE;
	    return SP_RETURN_NOT_FOUND;
	}
    
	*Again = TRUE;

	return SP_RETURN_NOT_FOUND;

} // end Dac960PciFindAdapterNew()
BOOLEAN
Dac960Initialize(
	IN PVOID HwDeviceExtension
	)

/*++

Routine Description:

	Inititialize adapter.

Arguments:

	HwDeviceExtension - HBA miniport driver's adapter data storage

Return Value:

	TRUE - if initialization successful.
	FALSE - if initialization unsuccessful.

--*/

{
	MdacInt3();
	return (TRUE);

} // end Dac960Initialize()


BOOLEAN
Dac960ResetBus(
	IN PVOID HwDeviceExtension,
	IN ULONG PathId
)

/*++

Routine Description:

	Reset Dac960 SCSI adapter and SCSI bus.
	NOTE: Command ID is ignored as this command will be completed
	before reset interrupt occurs and all active slots are zeroed.

Arguments:

	HwDeviceExtension - HBA miniport driver's adapter data storage
	PathId - not used.

Return Value:

	TRUE if resets issued to all channels.

--*/

{
	mdac_ctldev_t MLXFAR *ctp = ((PDEVICE_EXTENSION)HwDeviceExtension)->ctp;
	ULONG inx;
	ULONG path;
//	MLXSPLVAR;

	MdacInt3();
	DebugPrint((0, "Dac960ResetBus: ctp %I c %x p %x\n",
		    ctp,
		    ctp->cd_ControllerNo,
		    PathId));

	if (ctp->cd_Status & MDACD_CLUSTER_NODE) {
//	    MLXSPL();

	    mdac_fake_scdb(ctp, 
			    NULL,
			    0xFF,
			    DACMD_RESET_SYSTEM_DRIVE,
			    NULL,
			    0);
//	    MLXSPLX();

	}

	for (path = 0; path < MAXIMUM_CHANNELS; path++) {
	    for (inx = 0 ; inx < 32; inx++) {
    		ScsiPortNotification(NextRequest,
                                 HwDeviceExtension,
                                 NULL);
        }
    }    

	return TRUE;

} // end Dac960ResetBus()

u32bits MLXFAR
mdac_send_scdb_nt(
	mdac_ctldev_t MLXFAR *ctp,
	PSCSI_REQUEST_BLOCK Srb
)
{
	u32bits rc;
	u32bits dirbits = mdac_timeout2dactimeout(Srb->TimeOutValue);


	if ((Srb->PathId == 0) && (Srb->TargetId == 5))
	    DebugPrint((1, "mdac_send_scdb_nt: c %x t %x l %x cmd %x\n",
			Srb->PathId,
			Srb->TargetId,
			Srb->Lun,
			Srb->Cdb[0]));

	if (!(Srb->SrbFlags & SRB_FLAGS_DISABLE_DISCONNECT))
	    dirbits |= DAC_DCDB_DISCONNECT;

	if (Srb->SrbFlags & SRB_FLAGS_DATA_IN)
		dirbits |= DAC_DCDB_XFER_READ;
	else if (Srb->SrbFlags & SRB_FLAGS_DATA_OUT)
		dirbits |= DAC_DCDB_XFER_WRITE;

	if (Srb->SrbFlags & SRB_FLAGS_DISABLE_AUTOSENSE)
		dirbits |= DAC_DCDB_NOAUTOSENSE;

	rc = mdac_send_scdb(ctp, 
			    Srb,
			    dev2pdp(ctp, Srb->PathId, Srb->TargetId, Srb->Lun),
			    Srb->DataTransferLength,
			    (u08bits MLXFAR *) Srb->Cdb,
			    Srb->CdbLength,
			    dirbits,
			    Srb->TimeOutValue);
	return (rc);
}

u32bits MLXFAR
mdac_zero_dbg(dp2,dp,sz)
u08bits MLXFAR *dp2;
u08bits MLXFAR *dp;
u32bits sz;
{
	for (; sz; dp++, sz--) *dp = 0;
	return 0;
}


BOOLEAN
mdac_entry(
	IN PVOID HwDeviceExtension,
	IN PSCSI_REQUEST_BLOCK Srb
)

/*++

Routine Description:

	This routine is called from the SCSI port driver synchronized
	with the kernel to start a request.

Arguments:

	HwDeviceExtension - HBA miniport driver's adapter data storage
	Srb - IO request packet

Return Value:

	TRUE

--*/

{
	u32bits controlbits;
	UCHAR             status;
	mdac_ctldev_t MLXFAR *ctp = ((PDEVICE_EXTENSION)HwDeviceExtension)->ctp;
	PDEVICE_EXTENSION deviceExtension = (PDEVICE_EXTENSION)HwDeviceExtension;
	PMIOC_REQ_HEADER  ioctlReqHeader = NULL;
	UINT_PTR          ItsAnIoctl = 0;
	u08bits MLXFAR * cdbptr  = (u08bits MLXFAR *) Srb->Cdb;	

	if (!(FirstCallToMdacEntry))
		FirstCallToMdacEntry = 1;

#if !defined(MLX_NT_ALPHA) && !defined(MLX_WIN9X)

	//
	// Support for Hot Plug PCI
	//

	if (PCS_HBA_NOT_READY(deviceExtension->stateFlags))
	{
	    DebugPrint((0, "mdac_entry: PCS_HBA_NOT_READY, ext %I, sFlags %x, cFlags %x\n",
			deviceExtension,
			deviceExtension->stateFlags,
			deviceExtension->controlFlags));

	    if (deviceExtension->controlFlags & ~LCS_HBA_TIMER_ACTIVE)
	    {
		DebugPrint((1, "mdac_entry:1 ret SRB_STATUS_BUSY\n"));

		Srb->SrbStatus = SRB_STATUS_BUSY;
	    }
	    else if (deviceExtension->stateFlags & PCS_HBA_FAILED)
	    {
		DebugPrint((1, "mdac_entry:1 ret SRB_STATUS_ERROR\n"));
		deviceExtension->stateFlags |= PCS_HBA_UNFAIL_PENDING;
		Srb->SrbStatus = SRB_STATUS_ERROR;
	    }
	    else
	    {
		if (deviceExtension->stateFlags & PCS_HPP_POWER_DOWN)
		{
		    DebugPrint((1, "mdac_entry:2 ret SRB_STATUS_ERROR\n"));
		    Srb->SrbStatus = SRB_STATUS_ERROR;
		}
		else
		{
		    if ((deviceExtension->stateFlags & PCS_HBA_UNFAIL_PENDING) &&
			(deviceExtension->stateFlags & PCS_HBA_OFFLINE))
		    {
			DebugPrint((1, "mdac_entry:3 ret SRB_STATUS_ERROR\n"));
			Srb->SrbStatus = SRB_STATUS_ERROR;
		    }
		    else
		    {
			DebugPrint((1, "mdac_entry:2 ret SRB_STATUS_ERROR\n"));
			deviceExtension->stateFlags &= ~PCS_HBA_UNFAIL_PENDING;
			Srb->SrbStatus = SRB_STATUS_BUSY;
		    }
		}
	    }

	    mdacScsiPortNotification(deviceExtension,Srb);
	    return (TRUE);
	}
	else
	{
	    deviceExtension->stateFlags &= ~PCS_HBA_UNFAIL_PENDING;
	}

#endif

	deviceExtension->lastSrb = (PVOID) Srb;
	lastSrb = (PVOID) Srb;
	TotalReqs++;
	if (TotalReqs == 0x1234)
		MdacInt3();     

	if (Srb->Function == SRB_FUNCTION_EXECUTE_SCSI)
	{
		switch (Srb->Cdb[0])  
		{
	         	case MDAC_NEWFSI_FWBOUND: 
			if (!(mdac_cmp(&Srb->Cdb[1],MDAC_BOUND_SIGNATURE,sizeof(MDAC_BOUND_SIGNATURE)))) 
			{
				mdac_req_t MLXFAR *rqp 	= (mdac_req_t MLXFAR *) Srb->DataBuffer;
				rqp->rq_OSReqp 		= Srb;
				rqp->rq_CompIntr = (u32bits (*)(mdac_req_t MLXFAR*))rqp_completion_intr;
				rqp->rq_Next 		= NULL;
				rqp->rq_MaxSGLen = MDAC_MAXSGLISTSIZENEW;
				rqp->rq_MaxDMASize = (rqp->rq_MaxSGLen & ~1) * MDAC_PAGESIZE;
				rqp->rq_OpFlags = MDAC_RQOP_FROM_SRB;
				rqp->rq_ctp = ctp; 
	        		mdac_zero_dbg(rqp,rqp->rq_SGList,rq_sglist_s); 

DebugPrint((0, "Calling mdac_os_gam_new_cmd: rqp = %x, Cmd = %x , offset 21(decimal) = %x\n",
			rqp, *(((u08bits MLXFAR *)(rqp)) + 0xc2),*(((u08bits MLXFAR *)(rqp)) + 0xc0 + 21)));

				if (mdac_os_gam_new_cmd(rqp))
				{
					status = SRB_STATUS_BUSY;
				}
				else
					status = SRB_STATUS_PENDING;

			} /* end if */
			ItsAnIoctl = 1;
		   break;
		default:
		   break;
		} /* end switch */
		if (ItsAnIoctl)
			goto AfterIoctlCall;
	} /* end if */

	switch (Srb->Function) {

	case SRB_FUNCTION_EXECUTE_SCSI:

	if (ctp->cd_Status & MDACD_NEWCMDINTERFACE)
	{
	    DebugPrint((mdacnt_dbg, "mdac_entry: ctp 0x%I Srb 0x%I p %d t %d l %d cdb 0x%x cl %d dl 0x%x cmd 0x%x\n",
			ctp,
			Srb,
			Srb->PathId,
			Srb->TargetId,
			Srb->Lun,
			 Srb->Cdb,
			Srb->CdbLength,
			Srb->DataTransferLength,
			Srb->Cdb[0]));

#ifdef GAM_SUPPORT
	    if (Srb->PathId == ctp->cd_MaxChannels)
	    {
		if ((Srb->TargetId != GAM_DEVICE_TARGET_ID) || (Srb->Lun != 0))
		{
		    status = SRB_STATUS_SELECTION_TIMEOUT;
		    break;
		}

		switch (Srb->Cdb[0]) {

		case SCSIOP_INQUIRY:
		{
			int i;
			//
			// Fill in inquiry buffer for the GAM device.
			//

			DebugPrint((0, "Inquiry For GAM device\n"));

			((PUCHAR)Srb->DataBuffer)[0]  = 0x03; // Processor device
			((PUCHAR)Srb->DataBuffer)[1]  = 0;
			((PUCHAR)Srb->DataBuffer)[2]  = 1;
			((PUCHAR)Srb->DataBuffer)[3]  = 0;
			((PUCHAR)Srb->DataBuffer)[4]  = 0x20;
			((PUCHAR)Srb->DataBuffer)[5]  = 0;
			((PUCHAR)Srb->DataBuffer)[6]  = 0;
			((PUCHAR)Srb->DataBuffer)[7]  = 0;
			((PUCHAR)Srb->DataBuffer)[8]  = 'M';
			((PUCHAR)Srb->DataBuffer)[9]  = 'Y';
			((PUCHAR)Srb->DataBuffer)[10] = 'L';
			((PUCHAR)Srb->DataBuffer)[11] = 'E';
			((PUCHAR)Srb->DataBuffer)[12] = 'X';
			((PUCHAR)Srb->DataBuffer)[13] = ' ';
			((PUCHAR)Srb->DataBuffer)[14] = ' ';
			((PUCHAR)Srb->DataBuffer)[15] = ' ';
			((PUCHAR)Srb->DataBuffer)[16] = 'G';
			((PUCHAR)Srb->DataBuffer)[17] = 'A';
			((PUCHAR)Srb->DataBuffer)[18] = 'M';
			((PUCHAR)Srb->DataBuffer)[19] = ' ';
			((PUCHAR)Srb->DataBuffer)[20] = 'D';
			((PUCHAR)Srb->DataBuffer)[21] = 'E';
			((PUCHAR)Srb->DataBuffer)[22] = 'V';
			((PUCHAR)Srb->DataBuffer)[23] = 'I';
			((PUCHAR)Srb->DataBuffer)[24] = 'C';
			((PUCHAR)Srb->DataBuffer)[25] = 'E';
		
			for (i = 26; i < (int)Srb->DataTransferLength; i++) {
				((PUCHAR)Srb->DataBuffer)[i] = ' ';
			}
	
			status = SRB_STATUS_SUCCESS;

			break;
		}

		default:
			DebugPrint((0, "GAM req not handled, Oc %x\n", Srb->Cdb[0]));
			status = SRB_STATUS_SELECTION_TIMEOUT;
			break;
		}

		break;
	    }
#endif
	 controlbits = (Srb->SrbFlags & SRB_FLAGS_DATA_IN) ? MDACMDCCB_READ : MDACMDCCB_WRITE;

	if (Srb->SrbFlags & SRB_FLAGS_DISABLE_AUTOSENSE)	
		controlbits |= MDACMDCCB_NOAUTOSENSE;

	if ( Srb->CdbLength > 10)
	{
		mdac_req_t MLXFAR *rqp = (mdac_req_t MLXFAR *)(Srb->SrbExtension);	
		mdaccopy((u08bits MLXFAR *) Srb->Cdb, (u08bits MLXFAR *) &rqp->rq_Cdb_Long,Srb->CdbLength);
		cdbptr  = (u08bits MLXFAR *) &rqp->rq_Cdb_Long;
	}
	 if (mdac_send_newcmd(ctp,
				Srb,
				Srb->PathId,
				Srb->TargetId,
				Srb->Lun,
				cdbptr,
				Srb->CdbLength,
				Srb->DataTransferLength,
				controlbits,
				Srb->TimeOutValue))
	    {
		status = SRB_STATUS_BUSY;
	    } 
	    else 
	    {
		status = SRB_STATUS_PENDING;
	    }
	    break;
	}

	if (Srb->PathId == DAC960_SYSTEM_DRIVE_CHANNEL)
	{
	    //
	    // Logical Drives mapped to 
	    // SCSI PathId DAC960_SYSTEM_DRIVE_CHANNEL TargetId 0-32, Lun 0
	    //

	    //
	    // Determine command from CDB operation code.
	    //

	    switch (Srb->Cdb[0]) {

	    case SCSIOP_READ:

		    //
		    // Send request to controller.
		    //

		    MLXSTATS(ctp->cd_Reads++;ctp->cd_ReadBlks+=Srb->DataTransferLength>>9;)
		    if ((*ctp->cd_SendRWCmd)(ctp,
					     Srb, 
					     Srb->TargetId,
#if defined(MLX_NT)
					     (ctp->cd_ReadCmd | 
						(((PCDB)Srb->Cdb)->CDB10.ForceUnitAccess << 9) |
						(((PCDB)Srb->Cdb)->CDB10.DisablePageOut << 10)),
#else
					     ctp->cd_ReadCmd,
#endif
					     GetBlockNum(Srb),
					     Srb->DataTransferLength,
					     Srb->TimeOutValue))
		    {
			    status = SRB_STATUS_BUSY;
		    } 
		    else 
		    {
			    status = SRB_STATUS_PENDING;
		    }
		    break;

	    case SCSIOP_WRITE:

		    //
		    // Send request to controller.
		    //

		    MLXSTATS(ctp->cd_Writes++;ctp->cd_WriteBlks+=Srb->DataTransferLength>>9;)
		    if ((*ctp->cd_SendRWCmd)(ctp,
					     Srb, 
					     Srb->TargetId,
#if defined(MLX_NT)
					     (ctp->cd_WriteCmd |
						(((PCDB)Srb->Cdb)->CDB10.ForceUnitAccess << 9) |
						(((PCDB)Srb->Cdb)->CDB10.DisablePageOut << 10)),
#else
					     ctp->cd_WriteCmd,
#endif
					     GetBlockNum(Srb),
					     Srb->DataTransferLength,
					     Srb->TimeOutValue))
		    {
			    status = SRB_STATUS_BUSY;
		    } 
		    else 
		    {
			    status = SRB_STATUS_PENDING;
		    }

		    break;

	    case SCSIOP_TEST_UNIT_READY:
	    case SCSIOP_INQUIRY:
	    case SCSIOP_READ_CAPACITY:
	    case SCSIOP_RESERVE_UNIT:
	    case SCSIOP_RELEASE_UNIT:

		    if (Srb->Lun != 0)
		    {
			    status = SRB_STATUS_SELECTION_TIMEOUT;
			    break;
		    }

		    //
		    // Send request to controller.
		    //

		    if (mdac_fake_scdb(ctp, 
				       Srb,
				       Srb->TargetId,
				       Srb->Cdb[0],
					(u08bits MLXFAR *) Srb->Cdb,
					(u32bits)Srb->DataTransferLength))
		    {                                   
			    status = SRB_STATUS_BUSY;
		    }
		    else {

			    status = SRB_STATUS_PENDING;
		    }

		    break;

	    case SCSIOP_VERIFY:

		    //
		    // Complete this request.
		    //

		    status = SRB_STATUS_SUCCESS;
		    break;

	    default:

		    //
		    // Fail this request.
		    //

		DebugPrint((1, "SCSI cdb %I not handled. srb %I for ctp %I c %x p %x t %x\n",
			    Srb->Cdb[0],
			    Srb,
			    ctp,
			    ctp->cd_ControllerNo,
			    Srb->PathId,
			    Srb->TargetId));

		    status = SRB_STATUS_INVALID_REQUEST;
		    break;

	    } // end switch (Srb->Cdb[0])

	    break;

	} else {

	    //
	    // These are passthrough requests.  Only accept request to LUN 0.
	    // This is because the DAC960 direct CDB interface does not include
	    // a field for LUN.
	    //

	    if (Srb->Lun != 0 || Srb->TargetId >= MDAC_MAXTARGETS)
	    {
		    status = SRB_STATUS_SELECTION_TIMEOUT;
		    break;
	    }

#ifdef GAM_SUPPORT

	    if (Srb->PathId == GAM_DEVICE_PATH_ID) 
	    {
		    if (Srb->TargetId != GAM_DEVICE_TARGET_ID) 
		    {
			    DebugPrint((1, "sel timeout for GAM c %x t %x l %x, oc %x\n",
						    Srb->PathId,
						    Srb->TargetId,
						    Srb->Lun,
						    Srb->Cdb[0]));

			    status = SRB_STATUS_SELECTION_TIMEOUT;
			    break;
		    }
    
		    switch (Srb->Cdb[0]) {

		    case SCSIOP_INQUIRY:
		    {
			    int i;
			    //
			    // Fill in inquiry buffer for the GAM device.
			    //

			    DebugPrint((1, "Inquiry For GAM device\n"));

			    ((PUCHAR)Srb->DataBuffer)[0]  = 0x03; // Processor device
			    ((PUCHAR)Srb->DataBuffer)[1]  = 0;
			    ((PUCHAR)Srb->DataBuffer)[2]  = 1;
			    ((PUCHAR)Srb->DataBuffer)[3]  = 0;
			    ((PUCHAR)Srb->DataBuffer)[4]  = 0x20;
			    ((PUCHAR)Srb->DataBuffer)[5]  = 0;
			    ((PUCHAR)Srb->DataBuffer)[6]  = 0;
			    ((PUCHAR)Srb->DataBuffer)[7]  = 0;
			    ((PUCHAR)Srb->DataBuffer)[8]  = 'M';
			    ((PUCHAR)Srb->DataBuffer)[9]  = 'Y';
			    ((PUCHAR)Srb->DataBuffer)[10] = 'L';
			    ((PUCHAR)Srb->DataBuffer)[11] = 'E';
			    ((PUCHAR)Srb->DataBuffer)[12] = 'X';
			    ((PUCHAR)Srb->DataBuffer)[13] = ' ';
			    ((PUCHAR)Srb->DataBuffer)[14] = ' ';
			    ((PUCHAR)Srb->DataBuffer)[15] = ' ';
			    ((PUCHAR)Srb->DataBuffer)[16] = 'G';
			    ((PUCHAR)Srb->DataBuffer)[17] = 'A';
			    ((PUCHAR)Srb->DataBuffer)[18] = 'M';
			    ((PUCHAR)Srb->DataBuffer)[19] = ' ';
			    ((PUCHAR)Srb->DataBuffer)[20] = 'D';
			    ((PUCHAR)Srb->DataBuffer)[21] = 'E';
			    ((PUCHAR)Srb->DataBuffer)[22] = 'V';
			    ((PUCHAR)Srb->DataBuffer)[23] = 'I';
			    ((PUCHAR)Srb->DataBuffer)[24] = 'C';
			    ((PUCHAR)Srb->DataBuffer)[25] = 'E';
		    
			    for (i = 26; i < (int)Srb->DataTransferLength; i++) {
				    ((PUCHAR)Srb->DataBuffer)[i] = ' ';
			    }
	    
			    status = SRB_STATUS_SUCCESS;

			    break;
		    }

		    default:
			    DebugPrint((1, "GAM req not handled, Oc %x\n", Srb->Cdb[0]));
			    status = SRB_STATUS_SELECTION_TIMEOUT;
			    break;
		    }

	    break;
    }       
#endif
	    //
	    // Send request to controller.
	    //

	    if (mdac_send_scdb_nt(ctp, Srb))
	    {
		    status = SRB_STATUS_BUSY;
	    }
	    else {
		    status = SRB_STATUS_PENDING;
	    }

	    break;
	}

	case SRB_FUNCTION_FLUSH:

		status = SRB_STATUS_SUCCESS;
		break;

		DebugPrint((0, "Flush ctp %I Srb %I\n", ctp, Srb));

		//
		// Issue flush command to controller.
		//

		if (ntmdac_flushcache(ctp, Srb, (2*60), 0))
		{
			status = SRB_STATUS_BUSY;
		} else 
		{
			status = SRB_STATUS_PENDING;
		}

		break;

	case SRB_FUNCTION_SHUTDOWN:

		//
		// Issue flush command to controller.
		//

		DebugPrint((0, "Shutdown ctp %I Srb %I\n", ctp, Srb));

		if (ntmdac_flushcache(ctp, Srb, (2*60), 1))
		{
			status = SRB_STATUS_BUSY;
		} else 
		{
			status = SRB_STATUS_PENDING;
		}

		break;

	case SRB_FUNCTION_ABORT_COMMAND:

		//
		// Indicate that the abort failed.
		//

		DebugPrint((0, "abort srb %I, nextsrb %I for ctp %I c %x p %x t %x\n",
			     Srb,
			     Srb->NextSrb,
			     ctp,
			     ctp->cd_ControllerNo,
			     Srb->PathId,
			     Srb->TargetId));

		status = SRB_STATUS_ABORT_FAILED;

		break;

	case SRB_FUNCTION_RESET_DEVICE:

		//
		// There is nothing the miniport can do by issuing Hard Resets on
		// Dac960 SCSI channels.
		//
		DebugPrint((0, "RD %x srb %I for ctp %I c %x p %x t %x\n",
			    Srb->Function,
			    Srb,
			    ctp,
			    ctp->cd_ControllerNo,
			    Srb->PathId,
			    Srb->TargetId));

		if (!(ctp->cd_Status & MDACD_CLUSTER_NODE))
		{
		    status = SRB_STATUS_SUCCESS;
		    break;
		}

		if (mdac_fake_scdb(ctp,
				Srb,
				Srb->TargetId,
				DACMD_RESET_SYSTEM_DRIVE,
				NULL,
				0))
		{                                   
			status = SRB_STATUS_BUSY;
		}
		else {
			status = SRB_STATUS_PENDING;
		}

		break;

	case SRB_FUNCTION_RESET_BUS:
		//
		// There is nothing the miniport can do by issuing Hard Resets on
		// Dac960 SCSI channels.
		//
		DebugPrint((0, "RB %x srb %I for ctp %I c %x p %x t %x\n",
			    Srb->Function,
			    Srb,
			    ctp,
			    ctp->cd_ControllerNo,
			    Srb->PathId,
			    Srb->TargetId));

		if (!(ctp->cd_Status & MDACD_CLUSTER_NODE))
		{
		    status = SRB_STATUS_SUCCESS;
		    break;
		}

		if (mdac_fake_scdb(ctp,
				Srb,
				0xFF,
				DACMD_RESET_SYSTEM_DRIVE,
				NULL,
				0))
		{                                   
			status = SRB_STATUS_BUSY;
		}
		else {
			status = SRB_STATUS_PENDING;
		}

		break;

	case SRB_FUNCTION_IO_CONTROL:

		ioctlReqHeader = (PMIOC_REQ_HEADER) Srb->DataBuffer;

		DebugPrint((1, "mdac_entry: ioctl cmd %x ", ioctlReqHeader->Command));

		if(Srb->DataTransferLength >  (sizeof(MIOC_REQ_HEADER)))
        {

			if ((mdac_ioctl((u32bits)ctp->cd_ControllerNo, ioctlReqHeader->Command,
			   ((PUCHAR)Srb->DataBuffer + sizeof(MIOC_REQ_HEADER)))) == 0xB0 /*ERR_PENDING*/)
			{
				DebugPrint((0, "ctp %I Srb = %I cmd %x, ret ERR_PENDING\n",
						ctp,
						 Srb,
						ioctlReqHeader->Command));

				status = SRB_STATUS_PENDING;
			}
			else
			{
				status = SRB_STATUS_SUCCESS;
			}
		}
		else
		{
			status=SRB_STATUS_INVALID_REQUEST;
		}

		break;

	default:

		//
		// Fail this request.
		//

		DebugPrint((0,
			    "mdac_entry: SRB fucntion %x not handled\n",
			    Srb->Function));

		status = SRB_STATUS_INVALID_REQUEST;
		break;

	} // end switch

AfterIoctlCall:
	//
	// Check if this request is complete.
	//

	if (status == SRB_STATUS_BUSY) {
		//
		// queue the operating system request in the queue.
		//

		qosreq(ctp, Srb, NextSrb);

		status = SRB_STATUS_PENDING;
	}
	else if (status != SRB_STATUS_PENDING)
	{
		//
		// Notify system of request completion.
		//

		Srb->SrbStatus = status;


		if(Srb->PathId >= ctp->cd_PhysChannels) 
			ScsiPortNotification(NextLuRequest,HwDeviceExtension,Srb->PathId, 
								 Srb->TargetId,Srb->Lun);   
		else        
			ScsiPortNotification(NextRequest,HwDeviceExtension,Srb->PathId, 
								 Srb->TargetId,Srb->Lun);   


		mdacScsiPortNotification(HwDeviceExtension,Srb);
	}

	//
	// Check if this is a request to a system drive. Indicating
	// ready for next logical unit request causes the system to
	// send overlapped requests to this device (tag queuing).
	//
	// The DAC960 only supports a single outstanding direct CDB
	// request per device, so indicate ready for next adapter request.
	//

	if (ctp->cd_ActiveCmds <= ctp->cd_MaxCmds)
	{
	    if (Srb->PathId >= ctp->cd_PhysChannels) 
	    {
		    //
		    // Indicate ready for next logical unit request.
		    //

            if (Srb->SrbFlags & SRB_FLAGS_QUEUE_ACTION_ENABLE) {

                ScsiPortNotification(NextLuRequest,
                         HwDeviceExtension,
                         Srb->PathId,
                         Srb->TargetId,
                         Srb->Lun);
            } else {

                //
                // If the current request is UNTAGGED, don't ask for NextLuRequest.
                //
                ScsiPortNotification(NextRequest,
                                     HwDeviceExtension,
                                     NULL);
            }    
	    }
	    else
	    {
		    //
		    // Indicate ready for next adapter request.
		    //

		    ScsiPortNotification(NextRequest,
		            			 HwDeviceExtension,
                                 NULL);
	    }
	}


	return TRUE;

} // end mdac_entry()


#if !defined(MLX_NT_ALPHA) && !defined(MLX_WIN9X)

//
// PCI Hot Plug Support routines
//

VOID
HotPlugRequestCompletionTimer(
    PPSEUDO_DEVICE_EXTENSION pPseudoExtension
)
{
    PSCSI_REQUEST_BLOCK srb, completionQueue;
//    MLXSPLVAR;

    if (! pPseudoExtension->completionQueueHead)
	goto php_timer_reschedule;

//    MLXSPL();

    mdac_link_lock();
    completionQueue = pPseudoExtension->completionQueueHead;
    pPseudoExtension->completionQueueHead = NULL;
    pPseudoExtension->numberOfPendingRequests -= pPseudoExtension->numberOfCompletedRequests;
    pPseudoExtension->numberOfCompletedRequests = 0;
    mdac_link_unlock();

//    MLXSPLX();

    DebugPrint((1, "HPRCT: #pr %d completionQueue %I\n", pPseudoExtension->numberOfPendingRequests,
		completionQueue));

    while (completionQueue)
    {
	srb = completionQueue;
	completionQueue = srb->NextSrb;
	srb->NextSrb = NULL;

	mdacScsiPortNotification(pPseudoExtension,srb);
    }

    //
    // Indicate to system that the controller can take another request for this device.
    //

    ScsiPortNotification(NextLuRequest, pPseudoExtension, 0, 0, 0);

php_timer_reschedule:

    //
    // Request next timer call from ScsiPort.
    //

    if (pPseudoExtension->numberOfPendingRequests)
    {
	DebugPrint((1, "HPRCT: reschedule\n"));
	ScsiPortNotification(RequestTimerCall,
			    pPseudoExtension,
			    HotPlugRequestCompletionTimer,
			    TIMER_TICKS_PER_SEC);
    }

    DebugPrint((1, "HPRCT: return. %d still outstanding.\n",
		pPseudoExtension->numberOfPendingRequests));

    return;
}

VOID
HotPlugSendEvent(
    IN PDEVICE_EXTENSION pExtension,
    IN OUT PHR_EVENT pEvent,
    IN ULONG eventType
)
{
	MdacInt3();
    if (! (pExtension->stateFlags & PCS_HPP_SERVICE_READY))
    {
	DebugPrint((0, "HotPlugSendEvent: ext %I, Service Not ready\n", pExtension));
	return;
    }

    if (! pExtension->rcmcData.healthCallback)
    {
	DebugPrint((0, "HotPlugSendEvent: ext %I, Callback address is null.\n", pExtension));
	return;
    }

    if (eventType == EVT_TYPE_SYSLOG)
	goto php_post_event;

    if (! pEvent->ulEventId)
    {
	DebugPrint((1, "HotPlugSendEvent: ext %I, !EventId, assume HR_DD_STATUS_CHANGE_EVENT.\n", pExtension));

	pEvent->ulEventId = HR_DD_STATUS_CHANGE_EVENT;
    }

    if (! pEvent->ulData1)
    {
	DebugPrint((1, "HotPlugSendEvent: ext %I, !Data1, assume CBS_HBA_STATUS_NORMAL.\n", pExtension));

	pEvent->ulData1 = CBS_HBA_STATUS_NORMAL;
    }

    pEvent->ulSenderId = pExtension->rcmcData.driverId;

    pEvent->ulData2 = pExtension->ioBaseAddress;

php_post_event:

    DebugPrint((1, "Event Id: %x\tSenderId: %x\tData1: %x\tData2: %x\n",
		pEvent->ulEventId,
		pEvent->ulSenderId,
		pEvent->ulData1,
		pEvent->ulData2));

    pExtension->rcmcData.healthCallback(pEvent);
}


VOID
HotPlugStartStopController_Intr(
    mdac_req_t MLXFAR *rqp
)
{

    mdac_ctldev_t MLXFAR *ctp = rqp->rq_ctp;
    PDEVICE_EXTENSION pExtension = (PDEVICE_EXTENSION)ctp->cd_deviceExtension;
    PPSEUDO_DEVICE_EXTENSION pPseudoExtension = (PPSEUDO_DEVICE_EXTENSION) rqp->rq_Poll;
    PSCSI_REQUEST_BLOCK Srb = rqp->rq_OSReqp;
    PMDAC_HPP_IOCTL_BUFFER pHppIoctl = (PMDAC_HPP_IOCTL_BUFFER) Srb->DataBuffer;
    PHPP_SLOT_EVENT pSlotEvent = (PHPP_SLOT_EVENT) pHppIoctl->ReturnData;
    mdac_req_t MLXFAR *tmprqp;
    u08bits MLXFAR *mem_addr;
    u08bits irql;
	MdacInt3();
    if (!dcmdp->mb_Status)
    {
	DebugPrint((0, "StartStop cmd successful for ext %x\n", pExtension));

	if ((rqp->rq_DacCmd.mb_MailBox5 & START_CONTROLLER) == START_CONTROLLER)
	{
	    // Let timer make the controller ready and report results to rcmc.

	    DebugPrint((0, "Set Unfail flags and Ready active controller\n"));

	    PCS_SET_UNFAIL(pExtension->stateFlags);

	    pExtension->controlFlags |= LCS_HBA_READY_ACTIVE;
	}
	else
	{
	    // set flags according to slot type.
    
	    switch (pSlotEvent->eSlotStatus)
	    {
		case HPPSS_SIMULATED_FAILURE:
		    PCS_SET_USER_FAIL(pExtension->stateFlags);
		    break;
    
		case HPPSS_POWER_OFF_WARNING:
		    (*ctp->cd_DisableIntr)(ctp); /* Disable interrupts */
	    
		    // Free Physical Device Table

            mdac_prelock(&irql);
		    mdac_ctlr_lock(ctp);

		    mem_addr = (void *)ctp->cd_PhysDevTbl;
		    ctp->cd_PhysDevTbl = NULL;
		    ctp->cd_Lastpdp = NULL;

		    mdac_ctlr_unlock(ctp);
            mdac_postlock(irql);

		    mlx_freemem(ctp, mem_addr, ctp->cd_PhysDevTblMemSize);

		    PCS_SET_PWR_OFF(pExtension->stateFlags);

		    break;
	    }
    
	    DebugPrint((0, "sintr: #oscmds %x #cmds %x\n",
			ctp->cd_OSCmdsWaiting,
			ctp->cd_CmdsWaiting));

        mdac_prelock(&irql);
	    mdac_ctlr_lock(ctp);
    
	    // deque all requests from OS request queue.
	    while (ctp->cd_OSCmdsWaiting)
	    {
		dqosreq(ctp, Srb, NextSrb);
	    }
    
	    // deque all requests queued in driver queue.
	    // free rqp memory.
    
	    while (ctp->cd_CmdsWaiting)
	    {
		dqreq(ctp, tmprqp);
		mdac_free_req(ctp, tmprqp); // we should not free macdisk requests.
	    }

	    mdac_ctlr_unlock(ctp);
        mdac_postlock(irql);
	
	    // complete outstanding SP requests with reset status.
	
	    ScsiPortCompleteRequest(pExtension,
				    SP_UNTAGGED,
				    SP_UNTAGGED,
				    SP_UNTAGGED,
				    SRB_STATUS_BUS_RESET);
    
	    switch (pSlotEvent->eSlotStatus)
	    {
		case HPPSS_SIMULATED_FAILURE:
		    pExtension->controlFlags |= LCS_HBA_FAIL_ACTIVE;
		    break;
    
		case HPPSS_POWER_OFF_WARNING:
		    pExtension->controlFlags |= LCS_HPP_POWER_DOWN;
		    break;
	    }
    
	    pExtension->stateFlags &= ~PCS_HBA_CACHE_IN_USE;
	}
    }
    else
    {
	DebugPrint((0, "StartStop command sts %x, ext %x\n",
		    dcmdp->mb_Status,
		    pExtension));

	if (! (rqp->rq_DacCmd.mb_MailBox5 & START_CONTROLLER))          // stop command
	{
	    if ((dcmdp->mb_Status == DACMDERR_TOUT_CMDS_PENDING) ||
		(dcmdp->mb_Status == DACMDERR_TOUT_CACHE_NOT_FLUSHED))
	    {

		if (rqp->rq_PollWaitChan)
		{
		    DebugPrint((0, "retrying stop command. iteration %I\n", rqp->rq_PollWaitChan));
		    if (! HotPlugStartStopController(pExtension, Srb, pPseudoExtension, 0, --(ULONG)(rqp->rq_PollWaitChan)))
		    {
			// free rqp.
	    
			mdac_free_req(ctp, rqp);
			return;
		    }
		}
	    }

	    pHppIoctl->Header.ReturnCode = IOS_HPP_HBA_CACHE_IN_USE;

	    ctp->cd_Status &= ~MDACD_CTRL_SHUTDOWN;
	    MDACD_FREE_IO(pExtension);
	}
	else
	    pHppIoctl->Header.ReturnCode = IOS_HPP_HBA_BUSY;
    }

    //
    // Complete this IOCTL
    //

    Srb = rqp->rq_OSReqp;

    Srb->SrbStatus = SRB_STATUS_SUCCESS;

    //
    // queue the request. HotPlugRequestCompletionTimer will complete
    // the requests.
    //

    mdac_link_lock();

    Srb->NextSrb = NULL;

    if (!pPseudoExtension->completionQueueHead)
    {
	DebugPrint((1, "sintr: completionQueue NULL\n"));

	pPseudoExtension->completionQueueHead = Srb;
	pPseudoExtension->completionQueueTail = Srb;
    }
    else
    {
	DebugPrint((1, "sintr: completionQueue %I\n",
		    pPseudoExtension->completionQueueHead));

	pPseudoExtension->completionQueueTail->NextSrb = Srb;
	pPseudoExtension->completionQueueTail = Srb;
    }

    pPseudoExtension->numberOfCompletedRequests++;

    mdac_link_unlock();

    //
    // free the request.
    //

    mdac_free_req(ctp, rqp);
}


ULONG
HotPlugStartStopController(
    PDEVICE_EXTENSION pExtension,
    PSCSI_REQUEST_BLOCK osrqp,
    PPSEUDO_DEVICE_EXTENSION pPseudoExtension,
    ULONG startFlag,
    ULONG retryCount
)
{
    mdac_ctldev_t MLXFAR *ctp = pExtension->ctp;
    mdac_req_t MLXFAR *rqp;

    MdacInt3();
    ntmdac_alloc_req_ret(ctp,&rqp,osrqp,ERR_NOMEM);

    DebugPrint((0, "issue StartStop for ext %I. #acmds %d #oscmds %d #dcmds %d\n",
		pExtension,
		ctp->cd_ActiveCmds,
		ctp->cd_OSCmdsWaiting,
		ctp->cd_CmdsWaiting));

    rqp->rq_OSReqp = osrqp;

	if (ctp->cd_Status & MDACD_NEWCMDINTERFACE)
	{

#if 0
//
// Commented by Mouli. 9/17/99. This is not the time to initialize the controller
// Timer would come in later and initialize the controller.
//
//
		if (startFlag == START_CONTROLLER)
			/* start the controller i.e. do BIOS initialization */
			mdac_start_controller(ctp);
#endif

	    rqp->rq_FinishTime = mda_CurTime + 50;      // 50 seconds
	    mdaczero(ncmdp,mdac_commandnew_s);
	    ncmdp->nc_TimeOut = 40;                                             // 40 seconds
	    ncmdp->nc_Command = MDACMD_IOCTL;
	    ncmdp->nc_SubIOCTLCmd = ((startFlag == START_CONTROLLER)?
				    MDACIOCTL_UNPAUSEDEV:MDACIOCTL_PAUSEDEV);
	    ncmdp->nc_Cdb[0] = MDACDEVOP_RAIDCONTROLLER;
	    dcmdp->mb_MailBox5 = (u08bits )startFlag;     // may as well use this location
	}
	else
	{
	    rqp->rq_FinishTime = mda_CurTime + 50;      // 50 seconds
	    dcmd4p->mb_MailBox0_3 = 0; dcmd4p->mb_MailBox4_7 = 0;
	    dcmd4p->mb_MailBox8_B = 0; dcmd4p->mb_MailBoxC_F = 0;
	    dcmdp->mb_Command = DACMD_IOCTL;
	    dcmdp->mb_ChannelNo = DACMDIOCTL_STARTSTOP_CONTROLLER;
	    dcmdp->mb_MailBox5 = (u08bits )startFlag;
	    dcmdp->mb_MailBox6 = 40;                    // 40 seconds.
	}

	MLXSTATS(ctp->cd_CmdsDone++;)
	rqp->rq_CompIntr = (u32bits (*)(struct mdac_req *))HotPlugStartStopController_Intr;
	rqp->rq_Poll = (UINT_PTR) pPseudoExtension;  // store Pseudo extenson
	rqp->rq_PollWaitChan = retryCount;          // store Retry Count
	if (mdac_send_cmd(rqp))
	    return (IOS_HPP_HBA_CACHE_IN_USE);
	if (! startFlag)
	    ctp->cd_Status |= MDACD_CTRL_SHUTDOWN;

	DebugPrint((0, "Issued StartStop command\n"));

    return (0);
}

VOID
HotPlugSendControllerFailedEvent(
    PDEVICE_EXTENSION pExtension
)
{
    HR_EVENT event = {0, 0, 0, 0};
	MdacInt3();
    event.ulEventId = HR_DD_STATUS_CHANGE_EVENT;

    RCMC_SET_STATUS(pExtension->stateFlags, event.ulData1);

    if (event.ulData1 != CBS_HBA_STATUS_NORMAL)
    {
	// send event to RCMC service.

	HotPlugSendEvent(pExtension, &event, EVT_TYPE_RCMC);

	// Setup system event log data.

	EVT_HBA_FAIL(event,
		    pExtension->rcmcData.driverId,
		    (UCHAR)pExtension->rcmcData.controllerChassis,
		    (u08bits )pExtension->rcmcData.physicalSlot);

	// send event to system log.

	HotPlugSendEvent(pExtension, &event, EVT_TYPE_SYSLOG);
    }

    //
    // clear fail control flags
    //

    DebugPrint((1, "Clear FAIL_ACTIVE_CTRL flags for ext %I\n", pExtension));

    pExtension->controlFlags &= ~LCS_HBA_FAIL_ACTIVE;
}

VOID
HotPlugInitializeController(
    PDEVICE_EXTENSION pExtension
)
{
    mdac_ctldev_t MLXFAR *ctp = pExtension->ctp;
    ULONG status;
MdacInt3();
    mdac_init_addrs_PCI(ctp);
    ctp->cd_irq = (UINT_PTR)pExtension;
    ctp->cd_ServiceIntr = mdac_oneintr;

    if (!(status = mdac_ctlinit(ctp)))
    {
	pExtension->controlFlags &= ~ LCS_HBA_INIT;             // success
	DebugPrint((0, "HotPlugInitializeController: ext %I success. cFlags %x\n",
		     pExtension,
		     pExtension->controlFlags));

	DebugPrint((0, "cd_Status %x\n",  ctp->cd_Status));
	DebugPrint((0, "cd_ReadCmdIDStatus %I\n",  ctp->cd_ReadCmdIDStatus));
	DebugPrint((0, "cd_CheckMailBox %I\n",  ctp->cd_CheckMailBox));
	DebugPrint((0, "cd_HwPendingIntr %I\n",  ctp->cd_HwPendingIntr));
	DebugPrint((0, "cd_PendingIntr %I\n",  ctp->cd_PendingIntr));
	DebugPrint((0, "cd_SendCmd %I\n",  ctp->cd_SendCmd));
	DebugPrint((0, "cd_ServiceIntr %I\n",  ctp->cd_ServiceIntr));
	DebugPrint((0, "cd_irq %I\n", ctp->cd_irq));
	DebugPrint((0, "cd_InterruptVector %I\n",  ctp->cd_InterruptVector));
	DebugPrint((0, "cd_HostCmdQue %I\n",  ctp->cd_HostCmdQue));
	DebugPrint((0, "cd_HostCmdQueIndex %x\n",  ctp->cd_HostCmdQueIndex));
	DebugPrint((0, "cd_HostStatusQue %I\n",  ctp->cd_HostStatusQue));
	DebugPrint((0, "cd_HostStatusQueIndex %x\n",  ctp->cd_HostStatusQueIndex));

	return;
    }

    DebugPrint((0, "HotPlugInitializeController: mdac_ctlinit ret status %x\n", status));
    
    PCS_SET_ADAPTER_CHECK(pExtension->stateFlags);
    pExtension->controlFlags |= LCS_HBA_FAIL_ACTIVE;
}

VOID
HotPlugReadyController(
    PDEVICE_EXTENSION pExtension
)
{
    mdac_ctldev_t MLXFAR *ctp = pExtension->ctp;
    HR_EVENT event = {0, 0, 0, 0};
    UCHAR path;
    UCHAR targetId;
MdacInt3();
    DebugPrint((0, "HotPlugReadyController: ext %I\n", pExtension));

    // complete any outstanding requests with BUS_RESET status.

    ScsiPortCompleteRequest(pExtension,
			    SP_UNTAGGED,
			    SP_UNTAGGED,
			    SP_UNTAGGED,
			    SRB_STATUS_BUS_RESET);

    pExtension->controlFlags &= ~LCS_HBA_READY_ACTIVE;  // Clear Ready Active control bits

    pExtension->stateFlags |= PCS_HBA_CACHE_IN_USE;     // Controllers are assumed to have write cache enabled.

    pExtension->stateFlags &= ~PCS_HBA_FAILED;
    ctp->cd_Status &= ~MDACD_CTRL_SHUTDOWN;

    MDACD_FREE_IO(pExtension);

    // Notify ready to ScsiPort driver.

    for (path = 0; path < MAXIMUM_CHANNELS; path++)
	for (targetId = 0; targetId < 32; targetId++)
	    ScsiPortNotification(NextRequest, pExtension);

    // send rcmc event.

    event.ulEventId = HR_DD_STATUS_CHANGE_EVENT;
    RCMC_SET_STATUS(pExtension->stateFlags, event.ulData1);

    HotPlugSendEvent(pExtension, &event, EVT_TYPE_RCMC);

    // Send SysLog event

    EVT_HBA_REPAIRED(event,
		    pExtension->rcmcData.driverId,
		    (UCHAR)pExtension->rcmcData.controllerChassis,
		    (u08bits )pExtension->rcmcData.physicalSlot);

    HotPlugSendEvent(pExtension, &event, EVT_TYPE_SYSLOG);
}

VOID
HotPlugTimer(
    PDEVICE_EXTENSION pExtension
)
{
    ULONG controlFlags = pExtension->controlFlags;
    ULONG stateFlags = pExtension->stateFlags;
MdacInt3();
    DebugPrint((1, "HotPlugTimer: ext %I\n", pExtension));

    if ((pExtension->stateFlags & PCS_HPP_POWER_DOWN) &&
	!(pExtension->stateFlags & PCS_HBA_FAILED))
    {
//      DebugPrint((0, "HotPlugTimer: IoHeldRetTimer %d\n", pExtension->IoHeldTimer));

//      pExtension->IoHeldRetTimer++;
    }

    //
    // if logical control flags are clear OR
    // timer is on hold, do nothing.
    //

    if (!(controlFlags & ~LCS_HBA_TIMER_ACTIVE) ||
	(controlFlags & LCS_HBA_HOLD_TIMER))
    {
	DebugPrint((1, "HotPlugTimer: IoHeldRetTimer skipping %s\n",
			(!(controlFlags & LCS_HBA_HOLD_TIMER) ? "nothing to do" : "timer held")));
    }
    else
    {
	DebugPrint((1, "HotPlugTimer: ext %I, cFlags %x sFlags %x\n", pExtension,
		    controlFlags, stateFlags));
    
	ScsiPortNotification(ResetDetected, pExtension, NULL);

	if (controlFlags & LCS_HBA_FAIL_ACTIVE)
	{
	    HotPlugSendControllerFailedEvent(pExtension);
	}
	else if (controlFlags & LCS_HBA_INIT)
	{
	    HotPlugInitializeController(pExtension);
	}
	else if (controlFlags & LCS_HBA_READY_ACTIVE)
	{
	    HotPlugReadyController(pExtension);
	}
    }

    //
    // Request next timer call from ScsiPort.
    //

    ScsiPortNotification(RequestTimerCall,
			pExtension,
			HotPlugTimer,
			TIMER_TICKS_PER_SEC);


    return;
}

PDEVICE_EXTENSION
HotPlugFindExtension(
    PHPP_CTRL_ID  controllerID
)
{
    mdac_ctldev_t MLXFAR *ctp = mdac_ctldevtbl;
MdacInt3();
    if (controllerID->eController == HPCID_IO_BASE_ADDR)
    {
	DebugPrint((1, "IOBaseAddress method. IOBaseAddress %I\n",
		    controllerID->ulIOBaseAddress));

	for ( ; ctp < mdac_lastctp; ctp++)
	{
	    if (!(((PDEVICE_EXTENSION)ctp->cd_deviceExtension)->status & MDAC_CTRL_HOTPLUG_SUPPORTED)) continue;
	    if (((PDEVICE_EXTENSION)ctp->cd_deviceExtension)->ioBaseAddress != controllerID->ulIOBaseAddress) continue;
    
	    return ((PDEVICE_EXTENSION)ctp->cd_deviceExtension);
	}
    }
    else if (controllerID->eController == HPCID_PCI_DEV_FUNC)
    {
	DebugPrint((1, "PciDesc method. bus %d dev %d func %d\n",
		    controllerID->sPciDescriptor.ucBusNumber,
		    controllerID->sPciDescriptor.fcDeviceNumber,
		    controllerID->sPciDescriptor.fcFunctionNumber));

	for ( ; ctp < mdac_lastctp; ctp++)
	{
	    if (!(((PDEVICE_EXTENSION)ctp->cd_deviceExtension)->status & MDAC_CTRL_HOTPLUG_SUPPORTED)) continue;

	    if (controllerID->sPciDescriptor.ucBusNumber != ctp->cd_BusNo) continue;
	    if (controllerID->sPciDescriptor.fcDeviceNumber != ctp->cd_SlotNo) continue;
	    if (controllerID->sPciDescriptor.fcFunctionNumber != ctp->cd_FuncNo) continue;
    
	    return ((PDEVICE_EXTENSION)ctp->cd_deviceExtension);
	}
    }

    DebugPrint((0, "Extension not found. HPP_CTRL_ID: eController 0x%x, ulIOBaseAddress 0x%I\n",
		controllerID->eController,
		controllerID->ulIOBaseAddress));

    return (NULL);
}


#if 0

VOID
HotPlugFind1164PPciDevices(
    PPSEUDO_DEVICE_EXTENSION pPseudoExtension
)

/*++

Routine Description:

    Walk PCI slot information looking for PCI devices on all DAC1164P controllers.

Arguments:

Return Value:

	Nothing.
--*/
{
    mdac_ctldev_t MLXFAR *ctp = mdac_ctldevtbl;
    PDEVICE_EXTENSION   pExtension;
    UCHAR               pciBuffer[64];
    ULONG               busNumber, secondaryBusNumber;
    ULONG               deviceNumber;
    ULONG               status;
    PCI_SLOT_NUMBER     slotData;
    PPCI_COMMON_CONFIG  pciData = (PPCI_COMMON_CONFIG)&pciBuffer;
    ULONG               rc;


    slotData.u.AsULONG = 0;
MdacInt3();
    //
    // Look at each device.
    //

    for (busNumber = 0;
	 busNumber < MDAC_MAXBUS;
	 busNumber++)
    {

	for (deviceNumber = 0;
	     deviceNumber < PCI_MAX_DEVICES;
	     deviceNumber++)
	{

	    slotData.u.bits.DeviceNumber = deviceNumber;
	    slotData.u.bits.FunctionNumber = 0;

	    rc = ScsiPortGetBusData((PVOID)pPseudoExtension,
				    PCIConfiguration,
				    busNumber,
				    slotData.u.AsULONG,
				    pciData,
				    sizeof(pciBuffer)); 
	     
	     if (!rc) {

		DebugPrint((1, "FindPGController: Out OF PCI DATA\n"));

		//
		// Out of PCI data.
		//

		return;
	    }

	    if (pciData->VendorID == PCI_INVALID_VENDORID) {

		//
		// No PCI device, or no more functions on device
		// move to next PCI device.
		//
	       continue;
	    }

	    DebugPrint((0, "HotPlugFind1164PCPciDevices: bus# %x dev# %x vid %x devid %x\n",
			busNumber, deviceNumber,
			pciData->VendorID, pciData->DeviceID));

	    //
	    // Compare strings.
	    //

	    if ((pciData->VendorID != MLXPCI_VID_DIGITAL) &&
		(pciData->VendorID != MLXPCI_VID_MYLEX))
		continue;

	    if ((pciData->VendorID == MLXPCI_VID_DIGITAL) &&
		((pciData->DeviceID != MLXPCI_DEVID_DEC_BRIDGE) || (pciData->BaseClass != MLXPCI_BASECC_BRIDGE)))
	    {
		continue;
	    }
	    else if ((pciData->VendorID == MLXPCI_VID_MYLEX) &&
		    (pciData->DeviceID != MLXPCI_DEVID_BASS))
	    {
		continue;
	    }

	    if (pciData->VendorID == MLXPCI_VID_MYLEX)
	    {
		for (ctp = mdac_ctldevtbl; ctp < mdac_lastctp; ctp++)
		{
		    DebugPrint((0, "ctp->BusNo 0x%lx, slot# 0x%lx, func# 0x%lx vidpid 0x%lx\n",
				ctp->cd_BusNo,  ctp->cd_SlotNo,
				ctp->cd_FuncNo, ctp->cd_vidpid));

		    if ((ctp->cd_vidpid != MDAC_DEVPIDPV) ||
			(ctp->cd_BusNo != busNumber)) continue;

		    pExtension = (PDEVICE_EXTENSION)ctp->cd_deviceExtension;

		    //
		    // Fill in information for Digital Foot Bridge device
		    //

		    pExtension->pciDeviceInfo[1].busNumber = ctp->cd_BusNo;
		    pExtension->pciDeviceInfo[1].deviceNumber = ctp->cd_SlotNo;
		    pExtension->pciDeviceInfo[1].functionNumber = ctp->cd_FuncNo;

		    //
		    // Fill in information for Mylex BASS device
		    //

		    pExtension->pciDeviceInfo[2].busNumber = busNumber;
		    pExtension->pciDeviceInfo[2].deviceNumber = deviceNumber;
		    pExtension->pciDeviceInfo[2].functionNumber = 0;

		    DebugPrint((0, "ctp %I, Foot Bridge Device found at %d:%d:%d(b:d:f)\n",
				ctp,
				pExtension->pciDeviceInfo[1].busNumber,
				pExtension->pciDeviceInfo[1].deviceNumber,
				pExtension->pciDeviceInfo[1].functionNumber));

		    DebugPrint((0, "ctp %I, Mylex BASS Device found at %d:%d:%d(b:d:f)\n",
				ctp,
				pExtension->pciDeviceInfo[2].busNumber,
				pExtension->pciDeviceInfo[2].deviceNumber,
				pExtension->pciDeviceInfo[2].functionNumber));

		    break;
		}
	    }
	    else if (pciData->VendorID == MLXPCI_VID_DIGITAL)
	    {
		secondaryBusNumber = pciBuffer[25];
		DebugPrint((1, "bridge secondaryBusNumber %x\n", secondaryBusNumber));

		for (ctp = mdac_ctldevtbl; ctp < mdac_lastctp; ctp++)
		{
		    DebugPrint((1, "ctp %I, ctp->BusNo 0x%lx, slot# 0x%lx, func# 0x%lx vidpid 0x%lx\n",
				ctp, ctp->cd_BusNo,  ctp->cd_SlotNo,
				ctp->cd_FuncNo, ctp->cd_vidpid));

		    if (ctp->cd_vidpid != MDAC_DEVPIDPV) continue;
		    if (ctp->cd_BusNo != secondaryBusNumber) continue;

		    pExtension = (PDEVICE_EXTENSION)ctp->cd_deviceExtension;

		    //
		    // Fill in information for Digital Bridge device

		    pExtension->pciDeviceInfo[0].busNumber = busNumber;
		    pExtension->pciDeviceInfo[0].deviceNumber = deviceNumber;
		    pExtension->pciDeviceInfo[0].functionNumber = 0;

		    DebugPrint((0, "ctp %I, Bridge Device found at %d:%d:%d(b:d:f)\n",
				ctp,
				pExtension->pciDeviceInfo[0].busNumber,
				pExtension->pciDeviceInfo[0].deviceNumber,
				pExtension->pciDeviceInfo[0].functionNumber));

		    break;
		}
	    }
	}
    }

} // end HotPlugFind1164PPciDevices()

#else

VOID
HotPlugFindPciDevices(
    PPSEUDO_DEVICE_EXTENSION pPseudoExtension,
    ULONG vendorDeviceId
)

/*++

Routine Description:

    Walk PCI slot information looking for PCI devices on all DAC1164P controllers.

Arguments:

Return Value:

	Nothing.
--*/
{
    mdac_ctldev_t MLXFAR *ctp = mdac_ctldevtbl;
    PDEVICE_EXTENSION   pExtension;
    UCHAR               pciBuffer[64];
    ULONG               busNumber, secondaryBusNumber;
    ULONG               deviceNumber;
    PCI_SLOT_NUMBER     slotData;
    PPCI_COMMON_CONFIG  pciData = (PPCI_COMMON_CONFIG)&pciBuffer;
    ULONG               rc;


    slotData.u.AsULONG = 0;
MdacInt3();
    //
    // Look at each device.
    //

    for (busNumber = 0;
	 busNumber < MDAC_MAXBUS;
	 busNumber++)
    {

	for (deviceNumber = 0;
	     deviceNumber < PCI_MAX_DEVICES;
	     deviceNumber++)
	{

	    slotData.u.bits.DeviceNumber = deviceNumber;
	    slotData.u.bits.FunctionNumber = 0;

	    rc = ScsiPortGetBusData((PVOID)pPseudoExtension,
				    PCIConfiguration,
				    busNumber,
				    slotData.u.AsULONG,
				    pciData,
				    sizeof(pciBuffer)); 
	     
	     if (!rc) {

		DebugPrint((1, "FindPGController: Out OF PCI DATA\n"));

		//
		// Out of PCI data.
		//

		return;
	    }

	    if (pciData->VendorID == PCI_INVALID_VENDORID) {

		//
		// No PCI device, or no more functions on device
		// move to next PCI device.
		//
	       continue;
	    }

	    DebugPrint((0, "HotPlugFindPciDevices: bus# %x dev# %x vid %x devid %x\n",
			busNumber, deviceNumber,
			pciData->VendorID, pciData->DeviceID));

	    //
	    // Compare strings.
	    //

	    if ((pciData->VendorID != MLXPCI_VID_DIGITAL) &&
		(pciData->VendorID != MLXPCI_VID_MYLEX))
		continue;

	    if ((pciData->VendorID == MLXPCI_VID_DIGITAL) &&
		((pciData->DeviceID != MLXPCI_DEVID_DEC_BRIDGE) || (pciData->BaseClass != MLXPCI_BASECC_BRIDGE)))
	    {
		continue;
	    }
	    else if ((pciData->VendorID == MLXPCI_VID_MYLEX) &&
		    (pciData->DeviceID != MLXPCI_DEVID_BASS) &&
		    (pciData->DeviceID != MLXPCI_DEVID_BASS_2))
	    {
		continue;
	    }

	    if (pciData->VendorID == MLXPCI_VID_MYLEX)
	    {
		for (ctp = mdac_ctldevtbl; ctp < mdac_lastctp; ctp++)
		{
		    DebugPrint((0, "ctp->BusNo 0x%lx, slot# 0x%lx, func# 0x%lx vidpid 0x%lx\n",
				ctp->cd_BusNo,  ctp->cd_SlotNo,
				ctp->cd_FuncNo, ctp->cd_vidpid));

#if 0
		    if ((ctp->cd_vidpid != MDAC_DEVPIDPV) ||
#else
		    if ((ctp->cd_vidpid != vendorDeviceId) ||
#endif
			(ctp->cd_BusNo != busNumber)) continue;

		    pExtension = (PDEVICE_EXTENSION)ctp->cd_deviceExtension;

		    //
		    // DAC1164P - Fill in information for Digital Foot Bridge device
		    // EXR2000/3000 - Fill in information for local device
		    //

		    pExtension->pciDeviceInfo[1].busNumber = ctp->cd_BusNo;
		    pExtension->pciDeviceInfo[1].deviceNumber = ctp->cd_SlotNo;
		    pExtension->pciDeviceInfo[1].functionNumber = ctp->cd_FuncNo;

		    DebugPrint((0, "ctp %I, Foot Bridge Device found at %d:%d:%d(b:d:f)\n",
				ctp,
				pExtension->pciDeviceInfo[1].busNumber,
				pExtension->pciDeviceInfo[1].deviceNumber,
				pExtension->pciDeviceInfo[1].functionNumber));

		    if (vendorDeviceId == MDAC_DEVPIDPV)
		    {
			//
			// Fill in information for Mylex BASS device
			//
    
			pExtension->pciDeviceInfo[2].busNumber = (u08bits )busNumber;
			pExtension->pciDeviceInfo[2].deviceNumber = (u08bits )deviceNumber;
			pExtension->pciDeviceInfo[2].functionNumber = 0;
    
			DebugPrint((0, "ctp %I, Mylex BASS Device found at %d:%d:%d(b:d:f)\n",
				    ctp,
				    pExtension->pciDeviceInfo[2].busNumber,
				    pExtension->pciDeviceInfo[2].deviceNumber,
				    pExtension->pciDeviceInfo[2].functionNumber));
		    }

		    break;
		}
	    }
	    else if (pciData->VendorID == MLXPCI_VID_DIGITAL)
	    {
		secondaryBusNumber = pciBuffer[25];
		DebugPrint((0, "bridge secondaryBusNumber %x\n", secondaryBusNumber));

		for (ctp = mdac_ctldevtbl; ctp < mdac_lastctp; ctp++)
		{
		    DebugPrint((1, "ctp %I, ctp->BusNo 0x%lx, slot# 0x%lx, func# 0x%lx vidpid 0x%lx\n",
				ctp, ctp->cd_BusNo,  ctp->cd_SlotNo,
				ctp->cd_FuncNo, ctp->cd_vidpid));

#if 0
		    if (ctp->cd_vidpid != MDAC_DEVPIDPV) continue;
#else
		    if (ctp->cd_vidpid != vendorDeviceId) continue;
#endif
		    if (ctp->cd_BusNo != secondaryBusNumber) continue;

		    pExtension = (PDEVICE_EXTENSION)ctp->cd_deviceExtension;

		    //
		    // Fill in information for Digital P2P Bridge device

		    pExtension->pciDeviceInfo[0].busNumber = (u08bits )busNumber;
		    pExtension->pciDeviceInfo[0].deviceNumber = (u08bits )deviceNumber;
		    pExtension->pciDeviceInfo[0].functionNumber = 0;

		    DebugPrint((0, "ctp %I, Digital P2P Bridge Device found at %d:%d:%d(b:d:f)\n",
				ctp,
				pExtension->pciDeviceInfo[0].busNumber,
				pExtension->pciDeviceInfo[0].deviceNumber,
				pExtension->pciDeviceInfo[0].functionNumber));

		    break;
		}
	    }
	}
    }

} // end HotPlugFindPciDevices()
#endif

ULONG
HotPlugPseudoFindAdapter(
	IN OUT PVOID HwDeviceExtension,
	IN OUT PVOID Context,
	IN PVOID BusInformation,
	IN PCHAR Argumentstring,
	IN OUT PPORT_CONFIGURATION_INFORMATION ConfigInfo,
	OUT PBOOLEAN Again
)
{

	// MdacInt3();
	MdacInt3();
    DebugPrint((1, "HotPlugPseudoFindAdapter Entry\n"));

    *Again = FALSE;

    //
    // We will be called once for every PCI bus found in the system.
    // We want to return controller found only once.
    //

    if (*(PULONG)Context)
    {
	DebugPrint((1, "HotPlugPseudoFindAdapter: One Pseudo Controller already exported.\n"));
	return (SP_RETURN_NOT_FOUND);
    }
    else
	(*(PULONG)Context)++;

    //
    // supply required information
    //

    ConfigInfo->MaximumTransferLength = 0x1000;  // 4K
    ConfigInfo->NumberOfPhysicalBreaks = 0;
    ConfigInfo->NumberOfBuses = 1;
    ConfigInfo->ScatterGather = FALSE;
    ConfigInfo->Master = FALSE;
    ConfigInfo->Dma32BitAddresses = FALSE;
    ConfigInfo->MaximumNumberOfTargets = 1;
    ConfigInfo->CachesData = FALSE;
    ConfigInfo->InitiatorBusId[0] = (UCHAR) 254;

#if 0

    if (Dac1164PDetected)
    {
	//
	// Find PCI devices information for PV controllers.
	//
    
	DebugPrint((0, "scanning for PCI devices on all DAC1164P controllers\n"));
    
	HotPlugFind1164PPciDevices((PPSEUDO_DEVICE_EXTENSION)HwDeviceExtension);
    }
#else

    if (Dac1164PDetected)
    {
	//
	// Find PCI devices information for PV controllers.
	//
    
	DebugPrint((0, "scanning for PCI devices on all DAC1164P controllers\n"));
    
	HotPlugFindPciDevices((PPSEUDO_DEVICE_EXTENSION)HwDeviceExtension, MDAC_DEVPIDPV);
    }

    if (EXR2000Detected || EXR3000Detected)
    {
	//
	// Find PCI devices information for PV controllers.
	//
    
	DebugPrint((0, "scanning for PCI devices on all EXR2000/3000 controllers\n"));
    
	HotPlugFindPciDevices((PPSEUDO_DEVICE_EXTENSION)HwDeviceExtension, MDAC_DEVPIDBA);
    }
#endif

    return (SP_RETURN_FOUND);
}

BOOLEAN
HotPlugPseudoInitialize(
    IN PVOID pPseudoExtension
)
{
    mdac_ctldev_t MLXFAR *ctp = mdac_ctldevtbl;
MdacInt3();
    ((PPSEUDO_DEVICE_EXTENSION)pPseudoExtension)->hotplugVersion = SUPPORT_VERSION_10;

    //
    //  Mark PG/PJ/PV/BA/LP controllers as Hot-Plug Controllers.
    //

    for ( ; ctp < mdac_lastctp; ctp++)
    {
	if ((ctp->cd_vidpid != MDAC_DEVPIDPV) && (ctp->cd_vidpid != MDAC_DEVPIDPG) &&
		(ctp->cd_vidpid != MDAC_DEVPIDBA) && (ctp->cd_vidpid != MDAC_DEVPIDLP))
		    continue;

	((PDEVICE_EXTENSION)ctp->cd_deviceExtension)->status |= MDAC_CTRL_HOTPLUG_SUPPORTED;
	ctp->cd_Status |= MDACD_PHP_ENABLED;

	//
	// Schedule Hot Plug Timer for this controller
	//

	HotPlugTimer((PDEVICE_EXTENSION)ctp->cd_deviceExtension);


	DebugPrint((0, "PCI device found at %d:%d:%d(b:d:f) VenDevID %x supports PCI Hot Plug.\n",
		    ctp->cd_BusNo, ctp->cd_SlotNo,
		    ctp->cd_FuncNo, ctp->cd_vidpid));
    }

    return (TRUE);
}

ULONG
HotPlugProcessIoctl(
    IN PPSEUDO_DEVICE_EXTENSION pPseudoExtension,
    IN PSCSI_REQUEST_BLOCK Srb
)
{
    ULONG status;
    PMDAC_HPP_IOCTL_BUFFER pHppIoctl = (PMDAC_HPP_IOCTL_BUFFER) Srb->DataBuffer;
    PDEVICE_EXTENSION pExtension;
    UCHAR j;
MdacInt3();
    pHppIoctl->Header.ReturnCode = IOS_HPP_SUCCESS;
    status = IOP_HPP_COMPLETED;

    DebugPrint((1, "HotPlugProcessIoctl: CODE %d PID %d TID %d LUN %d\n",
		pHppIoctl->Header.ControlCode,
		Srb->PathId,
		Srb->TargetId,
		Srb->Lun));

    switch (pHppIoctl->Header.ControlCode)
    {
	case IOC_HPP_RCMC_INFO:
	{
	    PHPP_RCMC_INFO pRcmcInfo;

	    DebugPrint((0, "IOC_HPP_RCMC_INFO\n"));

	    // verify that buffer is sufficient

	    if (pHppIoctl->Header.Length < sizeof(HPP_RCMC_INFO))
	    {
		DebugPrint((0, "Buffer Len %x Required Len %x\n",
				pHppIoctl->Header.Length, sizeof(HPP_RCMC_INFO)));

		pHppIoctl->Header.ReturnCode = IOS_HPP_BUFFER_TOO_SMALL;
		break;
	    }

	    pRcmcInfo = (PHPP_RCMC_INFO) pHppIoctl->ReturnData;

	    //
	    // Locate pointer to associated device extension from pool
	    //

	    pExtension = HotPlugFindExtension(&pRcmcInfo->sControllerID);

	    if (! pExtension)
	    {
		pHppIoctl->Header.ReturnCode = IOS_HPP_INVALID_CONTROLLER;
		break;
	    }

	    switch (pRcmcInfo->eServiceStatus)
	    {
		case HPRS_SERVICE_STARTING:
		    DebugPrint((1, "HPRS_SERVICE_STARTING for ext %I\n", pExtension));

		    //
		    // Verify that unique driver id is supplied.
		    //

		    if (pRcmcInfo->ulDriverID)
		    {
			//
			// Verify that Health driver call back address is supplied.
			//

			if (pRcmcInfo->vpCallbackAddress)
			{
			    //
			    // Record service data in the device extension.
			    //

			    pExtension->stateFlags |= PCS_HPP_SERVICE_READY;
			    pExtension->rcmcData.driverId = pRcmcInfo->ulDriverID;
			    pExtension->rcmcData.healthCallback = pRcmcInfo->vpCallbackAddress;
			    pExtension->rcmcData.controllerChassis = pRcmcInfo->ulCntrlChassis;
			    pExtension->rcmcData.physicalSlot = pRcmcInfo->ulPhysicalSlot;


			    DebugPrint((1, "ext %I drvId %x hcb %x chassis %x pslot %x sFlags %x\n",
					pExtension,
					pExtension->rcmcData.driverId,
					pExtension->rcmcData.healthCallback,
					pExtension->rcmcData.controllerChassis,
					pExtension->rcmcData.physicalSlot,
					pExtension->stateFlags));
			}
			else
			    pHppIoctl->Header.ReturnCode = IOS_HPP_INVALID_CALLBACK;
		    }
		    else
			pHppIoctl->Header.ReturnCode = IOS_HPP_INVALID_CONTROLLER;

		    break;

		case HPRS_SERVICE_STOPPING:
		    DebugPrint((1, "HPRS_SERVICE_STOPPING for ext %I\n", pExtension));

		    if (pExtension->stateFlags & PCS_HPP_SERVICE_READY)
		    {
			pExtension->stateFlags &= ~(PCS_HPP_SERVICE_READY | PCS_HPP_HOT_PLUG_SLOT);
			pExtension->rcmcData.driverId = 0;
		    }
		    else
		    {
			DebugPrint((1, "IOS_HPP_NO_SERVICE for ext %I\n", pExtension));
			pHppIoctl->Header.ReturnCode = IOS_HPP_INVALID_SERVICE_STATUS;
		    }

		    break;

		default:                        
		    DebugPrint((0, "unknown Hot Plug service status %x\n", pRcmcInfo->eServiceStatus));
		    pHppIoctl->Header.ReturnCode = IOS_HPP_INVALID_SERVICE_STATUS;
		    break;
	    }

	    break;
	}

	case IOC_HPP_HBA_INFO:
	{
	    PHPP_CTRL_INFO pHbaInfo;
	    mdac_ctldev_t MLXFAR *ctp;
	    ULONG inx = 0;

	    DebugPrint((1, "IOC_HPP_HBA_INFO\n"));

	    // verify that buffer is sufficient

	    if (pHppIoctl->Header.Length < sizeof(HPP_CTRL_INFO))
	    {
		DebugPrint((0, "Buffer Len %x, Required Len %x\n",
				pHppIoctl->Header.Length, sizeof(HPP_CTRL_INFO)));

		pHppIoctl->Header.ReturnCode = IOS_HPP_BUFFER_TOO_SMALL;
		break;
	    }


	    pHbaInfo = (PHPP_CTRL_INFO) pHppIoctl->ReturnData;

	    //
	    // Locate Pointer to associated device extension from pool
	    //

	    pExtension = HotPlugFindExtension(&pHbaInfo->sControllerID);

	    if (! pExtension)
	    {
		pHppIoctl->Header.ReturnCode = IOS_HPP_INVALID_CONTROLLER;
		break;
	    }

	    ctp = pExtension->ctp;

	    pHbaInfo->eSupportClass = HPSC_MINIPORT_STORAGE;
	    pHbaInfo->ulSupportVersion = SUPPORT_VERSION_10;
	    pHbaInfo->sController.eBusType = HPPBT_PCI_BUS_TYPE;


	    // fill in the bus related information

	    pHbaInfo->sController.sPciDescriptor.ucBusNumber = ctp->cd_BusNo;
	    pHbaInfo->sController.sPciDescriptor.fcDeviceNumber = ctp->cd_SlotNo;
	    pHbaInfo->sController.sPciDescriptor.fcFunctionNumber = ctp->cd_FuncNo;
	    pHbaInfo->sController.ulSlotNumber = 0;

	    pHbaInfo->sController.ulProductID = ctp->cd_vidpid;
	    pHbaInfo->sController.ulIRQ = pExtension->busInterruptLevel;

	    //
	    // setup Controller Descriptor string
	    //

	    mdaccopy(ctp->cd_ControllerName, pHbaInfo->sController.szControllerDesc, USCSI_PIDSIZE);

	    //
	    // setup Address range information
	    // Fill virtual addresses.
	    //

	    if (ctp->cd_MemBaseVAddr)
	    {
		pHbaInfo->sController.asCtrlAddress[inx].fValid = TRUE;
		pHbaInfo->sController.asCtrlAddress[inx].eAddrType = HPPAT_MEM_ADDR;
#ifndef _WIN64
		pHbaInfo->sController.asCtrlAddress[inx].ulStart = ctp->cd_MemBaseVAddr;
#endif
		pHbaInfo->sController.asCtrlAddress[inx++].ulLength = ctp->cd_MemBaseSize;
	    }

	    if (ctp->cd_IOBaseAddr)
	    {
		pHbaInfo->sController.asCtrlAddress[inx].fValid = TRUE;
		pHbaInfo->sController.asCtrlAddress[inx].eAddrType = HPPAT_IO_ADDR;
#ifndef _WIN64
		pHbaInfo->sController.asCtrlAddress[inx].ulStart = ctp->cd_IOBaseAddr;
#endif
		pHbaInfo->sController.asCtrlAddress[inx++].ulLength = MDAC_IOSPACESIZE;
	    }

	    for (; inx < 16; inx++)
		pHbaInfo->sController.asCtrlAddress[inx].fValid = FALSE;

	    break;
	}

	case IOC_HPP_HBA_STATUS:
	{
	    PHPP_CTRL_STATUS pHbaStatus;

	    DebugPrint((1, "IOC_HPP_HBA_STATUS\n"));

	    // verify that buffer is sufficient.


	    if (pHppIoctl->Header.Length < sizeof(HPP_CTRL_STATUS))
	    {
		DebugPrint((0, "Buffer Len %x, Required Len %x\n",
				pHppIoctl->Header.Length, sizeof(HPP_CTRL_STATUS)));

		pHppIoctl->Header.ReturnCode = IOS_HPP_BUFFER_TOO_SMALL;
		break;
	    }

	    pHbaStatus = (PHPP_CTRL_STATUS) pHppIoctl->ReturnData;

	    pExtension = HotPlugFindExtension(&pHbaStatus->sControllerID);

	    if (pExtension)
		pHbaStatus->ulStatus = pExtension->stateFlags;
	    else
	    {
		pHppIoctl->Header.ReturnCode = IOS_HPP_INVALID_CONTROLLER;
	    }

	    break;
	}

	case IOC_HPP_SLOT_TYPE:
	{
	    PHPP_CTRL_SLOT_TYPE pSlotType;

	    DebugPrint((0, "IOC_HPP_SLOT_TYPE\n"));

	    // verify that buffer is sufficient

	    if (pHppIoctl->Header.Length < sizeof(HPP_CTRL_SLOT_TYPE))
	    {
		DebugPrint((0, "Buffer Len %x, Required Len %x\n",
				pHppIoctl->Header.Length, sizeof(HPP_CTRL_SLOT_TYPE)));

		pHppIoctl->Header.ReturnCode = IOS_HPP_BUFFER_TOO_SMALL;
		break;
	    }

	    pSlotType = (PHPP_CTRL_SLOT_TYPE) pHppIoctl->ReturnData;

	    // find device extension by port address;

	    pExtension = HotPlugFindExtension(&pSlotType->sControllerID);

	    if (! pExtension)
	    {
		pHppIoctl->Header.ReturnCode = IOS_HPP_INVALID_CONTROLLER;
		break;
	    }

	    DebugPrint((1, "ext %I, SlotType = %x\n", pExtension, pSlotType->eSlotType));

	    if (pSlotType->eSlotType == HPPST_HOTPLUG_PCI_SLOT)
		pExtension->stateFlags |= PCS_HPP_HOT_PLUG_SLOT;
	    else
		pExtension->stateFlags &= ~PCS_HPP_HOT_PLUG_SLOT;

	    break;
	}

	case IOC_HPP_SLOT_EVENT:
	{
	    PHPP_SLOT_EVENT pSlotEvent;

	    HR_EVENT rcmcEvent = {0, 0, 0, 0};
	    BOOLEAN rcmcEventFlag = FALSE;

	    DebugPrint((0, "IOC_HPP_SLOT_EVENT\n"));

	    // verify buffer is sufficient

	    if (pHppIoctl->Header.Length < sizeof(HPP_SLOT_EVENT))
	    {
		DebugPrint((0, "Buffer Len %x, Required Len %x\n",
				pHppIoctl->Header.Length, sizeof(HPP_SLOT_EVENT)));

		pHppIoctl->Header.ReturnCode = IOS_HPP_BUFFER_TOO_SMALL;
		break;
	    }

	    pSlotEvent = (PHPP_SLOT_EVENT) pHppIoctl->ReturnData;

	    pExtension = HotPlugFindExtension(&pSlotEvent->sControllerID);

	    if (!pExtension)
	    {
		pHppIoctl->Header.ReturnCode = IOS_HPP_INVALID_CONTROLLER;
		goto send_event;
	    }

	    if ((pExtension->stateFlags & PCS_HPP_SERVICE_READY) != PCS_HPP_SERVICE_READY)
	    {
		DebugPrint((0, "IOC_HPP_SLOT_EVENT. service not started. PortAddress %I\n",
				pSlotEvent->sControllerID.ulIOBaseAddress));

		pHppIoctl->Header.ReturnCode = IOS_HPP_NO_SERVICE;
		goto send_event;
	    }

	    DebugPrint((1, "HPP Service Ready\n"));

	    if ((pExtension->stateFlags & PCS_HPP_HOT_PLUG_SLOT) != PCS_HPP_HOT_PLUG_SLOT)
	    {
		DebugPrint((0, "IOC_HPP_SLOT_EVENT. not a hotplug slot. Port Address %I\n",
				pSlotEvent->sControllerID.ulIOBaseAddress));

		pHppIoctl->Header.ReturnCode = IOS_HPP_NOT_HOTPLUGABLE;
		goto send_event;
	    }

	    DebugPrint((1, "Hot plug slot\n"));

	    switch (pSlotEvent->eSlotStatus)
	    {
		case HPPSS_NORMAL_OPERATION:

		    DebugPrint((0, "HPSS_NORMAL_OPERATION\n"));

		    if ((pExtension->controlFlags & ~LCS_HBA_TIMER_ACTIVE) ||
			    (pExtension->stateFlags & PCS_HPP_POWER_DOWN))
		    {
			DebugPrint((0, "Ret IOS_HPP_HBA_BUSY, sFlags %x cFlags %x\n",
				    pExtension->stateFlags,
				    pExtension->controlFlags));

			pHppIoctl->Header.ReturnCode = IOS_HPP_HBA_BUSY;
		    }
		    else
		    {
			if (HotPlugStartStopController(pExtension, Srb, pPseudoExtension, 1, 0))
			{
			    DebugPrint((0, "\tRet IOS_HPP_HBA_BUSY\n"));
			    pHppIoctl->Header.ReturnCode = IOS_HPP_HBA_BUSY;
			}
			else
			    status = IOP_HPP_ISSUED;
		    }

		    break;

		case HPPSS_SIMULATED_FAILURE:

		    DebugPrint((0, "HPPSS_SIMULATED_FAILURE\n"));

		    if (pExtension->stateFlags & PCS_HBA_FAILED)
		    {
			DebugPrint((0, "Slot already failed\n"));
			break;
		    }

		    if (pExtension->controlFlags & ~LCS_HBA_TIMER_ACTIVE)
			    pHppIoctl->Header.ReturnCode = IOS_HPP_HBA_BUSY;
		    else if (pExtension->stateFlags & PCS_HBA_EXPANDING)
			    pHppIoctl->Header.ReturnCode = IOS_HPP_HBA_EXPANDING;
		    else
		    {
			MDACD_HOLD_IO(pExtension);
			if (HotPlugStartStopController(pExtension, Srb, pPseudoExtension, 0, 2))
			{
			    pHppIoctl->Header.ReturnCode = IOS_HPP_HBA_CACHE_IN_USE;
			    MDACD_FREE_IO(pExtension);
			}
			else
			    status = IOP_HPP_ISSUED;
		    }
		    break;

		case HPPSS_POWER_FAULT:

		    DebugPrint((0, "HPPSS_POWER_FAULT\n"));

		    // set state flags to power fault.
    
		    PCS_SET_PWR_FAULT(pExtension->stateFlags);
    
		    // Let timer know about this.
    
		    pExtension->controlFlags |= LCS_HPP_POWER_FAULT;
    
		    break;

		case HPPSS_POWER_OFF_WARNING:

		    DebugPrint((0, "HPPSS_POWER_OFF_WARNING\n"));

		    if (pExtension->stateFlags & PCS_HBA_EXPANDING)
		    {
			DebugPrint((0, "\tPCS_HBA_EXPANDING\n"));
			pHppIoctl->Header.ReturnCode = IOS_HPP_HBA_EXPANDING;
		    }
		    else if (pExtension->controlFlags & ~LCS_HBA_TIMER_ACTIVE)
		    {
			DebugPrint((0, "\tcFlags %x\n", pExtension->controlFlags));
			pHppIoctl->Header.ReturnCode = IOS_HPP_HBA_BUSY;
		    }
		    else if (!(pExtension->stateFlags & PCS_HPP_POWER_DOWN))
		    {
			MDACD_HOLD_IO(pExtension);
			if (HotPlugStartStopController(pExtension, Srb, pPseudoExtension, 0, 2))
			{
			    DebugPrint((0, "\tret HBA_CACHE_IN_USE\n"));
			    pHppIoctl->Header.ReturnCode = IOS_HPP_HBA_CACHE_IN_USE;
			    MDACD_FREE_IO(pExtension);
			}
			else
			    status = IOP_HPP_ISSUED;
		    }

		    // No associated event expected by service.

		    break;

		case HPPSS_POWER_OFF:

		    DebugPrint((0, "HPPSS_POWER_OFF\n"));

		    // Verify that we received a prior POWER_OFF_WARNING.
		    // If not, we are in fault state.

		    if (!(pExtension->stateFlags & PCS_HPP_POWER_DOWN))
		    {
			// if cache is in use return error.

			if (pExtension->stateFlags & PCS_HBA_CACHE_IN_USE)
			{
			    pHppIoctl->Header.ReturnCode = IOS_HPP_HBA_CACHE_IN_USE;
			}

			// This is a fault condition. Schedule event.

			DebugPrint((0, "HPPSS_POWER_OFF: FAULT\n"));

			PCS_SET_PWR_FAULT(pExtension->stateFlags);

			pExtension->controlFlags |= LCS_HPP_POWER_FAULT;
		    }

		    break;

		case HPPSS_POWER_ON_WARNING:

		    // This warning is not needed or acted upon.

		    DebugPrint((0, "HPPSS_POWER_ON_WARNING\n"));

		    if (pExtension->controlFlags & ~LCS_HBA_TIMER_ACTIVE)
		    {
			pHppIoctl->Header.ReturnCode = IOS_HPP_HBA_BUSY;
		    }

		    break;

		case HPPSS_RESET:
		case HPPSS_POWER_ON:

		    DebugPrint((0, "HPPSS_POWER_ON\n"));

		    // complete outstanding SP request with reset bus.

		    ScsiPortCompleteRequest(pExtension,
					    SP_UNTAGGED,
					    SP_UNTAGGED,
					    SP_UNTAGGED,
					    SRB_STATUS_BUS_RESET);

		    PCS_SET_UNFAIL(pExtension->stateFlags);
		    PCS_SET_PWR_ON(pExtension->stateFlags);

		    // Set Logical flag to schedule power-up operations.

		    pExtension->controlFlags |= LCS_HPP_POWER_UP;

		    break;

		case HPPSS_RESET_WARNING:

		    DebugPrint((0, "HPPSS_RESET_WARNING\n"));

		    // Not implemented by service

		    break;

		default:
			pHppIoctl->Header.ReturnCode = IOS_HPP_BAD_REQUEST;
			break;
	    }

send_event:
	    if (rcmcEventFlag)
	    {
		DebugPrint((0, "call HotPlugSendEvent\n"));

		HotPlugSendEvent(pExtension, &rcmcEvent, EVT_TYPE_RCMC);
	    }

	    break;
	}

	case IOC_HPP_PCI_CONFIG_MAP:
	{
	    PHPP_PCI_CONFIG_MAP pPciConfig;
	    ULONG inx;

	    DebugPrint((0, "IOC_HPP_PCI_CONFIG_MAP\n"));

	    // Verify that buffer is sufficient.

	    if (pHppIoctl->Header.Length < sizeof(HPP_PCI_CONFIG_MAP))
	    {
		DebugPrint((0, "Buffer len %x, required len %x\n",
				pHppIoctl->Header.Length, sizeof(HPP_PCI_CONFIG_MAP)));

		pHppIoctl->Header.ReturnCode = IOS_HPP_BUFFER_TOO_SMALL;

		break;
	    }

	    pPciConfig = (PHPP_PCI_CONFIG_MAP) pHppIoctl->ReturnData;

	    pExtension = HotPlugFindExtension(&pPciConfig->sControllerID);

	    if (! pExtension)
	    {
		pHppIoctl->Header.ReturnCode = IOS_HPP_INVALID_CONTROLLER;
		break;
	    }

	    if (pExtension->ctp->cd_BusType != DAC_BUS_PCI)
	    {
		DebugPrint((0, "IOC_HPP_PCI_CONFIG_MAP: ext %x bus type (%x) is !PCI.\n",
				pExtension,
				pExtension->ctp->cd_BusType));

		pHppIoctl->Header.ReturnCode = IOS_HPP_INVALID_BUS_TYPE;

		break;
	    }


	    pPciConfig->ulPciConfigMapVersion = HPP_CONFIG_MAP_VERSION_10;

	    switch (pExtension->ctp->cd_vidpid)
	    {
		case MDAC_DEVPIDPG:
		    pPciConfig->ulNumberOfPciDevices = 2;

		    //
		    // supply Bus/Device/Function information for bridge device.
		    //
	
		    pPciConfig->sDeviceInfo[0].sPciDescriptor.ucBusNumber = pExtension->ctp->cd_BusNo;
		    pPciConfig->sDeviceInfo[0].sPciDescriptor.fcDeviceNumber = pExtension->ctp->cd_SlotNo;
		    pPciConfig->sDeviceInfo[0].sPciDescriptor.fcFunctionNumber = 0;

		    //
		    // supply bus/device/func# information for local device.
		    //
	
		    pPciConfig->sDeviceInfo[1].sPciDescriptor.ucBusNumber =
			 pExtension->ctp->cd_BusNo;
	
		    pPciConfig->sDeviceInfo[1].sPciDescriptor.fcDeviceNumber =
			 pExtension->ctp->cd_SlotNo;
	
		    pPciConfig->sDeviceInfo[1].sPciDescriptor.fcFunctionNumber =
			 pExtension->ctp->cd_FuncNo;

		    DebugPrint((0, "PG bridge device is at %d:%d:%d(b:d:f)\n",
				    pExtension->pciDeviceInfo[0].busNumber,
				    pExtension->pciDeviceInfo[0].deviceNumber,
				    pExtension->pciDeviceInfo[0].functionNumber));

		    DebugPrint((0, "local device is at %d:%d:%d(b:d:f)\n",
				    pExtension->pciDeviceInfo[1].busNumber,
				    pExtension->pciDeviceInfo[1].deviceNumber,
				    pExtension->pciDeviceInfo[1].functionNumber));

		    for (inx = 0; inx < pPciConfig->ulNumberOfPciDevices; inx++)
		    {
			pPciConfig->sDeviceInfo[inx].ulNumberOfRanges = 2;
	
			pPciConfig->sDeviceInfo[inx].sPciConfigRangeDesc[0].ucStart = 6;
			pPciConfig->sDeviceInfo[inx].sPciConfigRangeDesc[0].ucEnd = 63;
	
			pPciConfig->sDeviceInfo[inx].sPciConfigRangeDesc[1].ucStart = 4;
			pPciConfig->sDeviceInfo[inx].sPciConfigRangeDesc[1].ucEnd = 5;
	
	
			// for the local device we need to specify the number of access ranges
			// and lengths for each so that the RCMC service can validate a
			// replacement controller's ranges against the removed adapter's.
	
			if (inx == 1)
			{
			    pPciConfig->sDeviceInfo[inx].ucBaseAddrVerifyCount = (u08bits )(pExtension->numAccessRanges);

			    DebugPrint((0, "PG local device Access Range Count %d\n", pExtension->numAccessRanges));
	
			    for (j = 0; j < pExtension->numAccessRanges; j++)
			    {
				pPciConfig->sDeviceInfo[inx].ulBaseAddrLength[j] =
				    pExtension->accessRangeLength[j];

				DebugPrint((0, "inx %d length 0x%x\n", j, pExtension->accessRangeLength[j]));
			    }
			}
		    }

		    break;

		case MDAC_DEVPIDPV:
		    pPciConfig->ulNumberOfPciDevices = 3;

		    for (inx = 0; inx < pPciConfig->ulNumberOfPciDevices; inx++)
		    {
			//
			// supply Bus/Device/Function information for Digital Bridge device.
			//
	    
			pPciConfig->sDeviceInfo[inx].sPciDescriptor.ucBusNumber =
			    pExtension->pciDeviceInfo[inx].busNumber;
    
			pPciConfig->sDeviceInfo[inx].sPciDescriptor.fcDeviceNumber =
			    pExtension->pciDeviceInfo[inx].deviceNumber;
    
			pPciConfig->sDeviceInfo[inx].sPciDescriptor.fcFunctionNumber =
			    pExtension->pciDeviceInfo[inx].functionNumber;
    
    
			DebugPrint((0, "PCI device %d at %d:%d:%d(b:d:f)\n", inx,
					pExtension->pciDeviceInfo[inx].busNumber,
					pExtension->pciDeviceInfo[inx].deviceNumber,
					pExtension->pciDeviceInfo[inx].functionNumber));

			pPciConfig->sDeviceInfo[inx].ulNumberOfRanges = 2;
	
			pPciConfig->sDeviceInfo[inx].sPciConfigRangeDesc[0].ucStart = 6;
			pPciConfig->sDeviceInfo[inx].sPciConfigRangeDesc[0].ucEnd = 63;
	
			pPciConfig->sDeviceInfo[inx].sPciConfigRangeDesc[1].ucStart = 4;
			pPciConfig->sDeviceInfo[inx].sPciConfigRangeDesc[1].ucEnd = 5;
	
	
			// for the local device we need to specify the number of access ranges
			// and lengths for each so that the RCMC service can validate a
			// replacement controller's ranges against the removed adapter's.
	
			if (inx == 1)   // For Foot Bridge
			{
			    pPciConfig->sDeviceInfo[inx].ucBaseAddrVerifyCount = (u08bits )(pExtension->numAccessRanges);
	
			    DebugPrint((0, "Foot Bridge Access Range Count %d\n", pExtension->numAccessRanges));

			    for (j = 0; j < pExtension->numAccessRanges; j++)
			    {
				pPciConfig->sDeviceInfo[inx].ulBaseAddrLength[j] =
				    pExtension->accessRangeLength[j];

				DebugPrint((0, "inx %d length 0x%x\n", j, pExtension->accessRangeLength[j]));
			    }
			}
		    }

		    break;

		case MDAC_DEVPIDBA:

		    pPciConfig->ulNumberOfPciDevices = 2;

		    for (inx = 0; inx < pPciConfig->ulNumberOfPciDevices; inx++)
		    {
			//
			// supply Bus/Device/Function information for Digital Bridge device.
			//
	    
			pPciConfig->sDeviceInfo[inx].sPciDescriptor.ucBusNumber =
			    pExtension->pciDeviceInfo[inx].busNumber;
    
			pPciConfig->sDeviceInfo[inx].sPciDescriptor.fcDeviceNumber =
			    pExtension->pciDeviceInfo[inx].deviceNumber;
    
			pPciConfig->sDeviceInfo[inx].sPciDescriptor.fcFunctionNumber =
			    pExtension->pciDeviceInfo[inx].functionNumber;
    
    
			DebugPrint((0, "PCI device %d at %d:%d:%d(b:d:f)\n", inx,
					pExtension->pciDeviceInfo[inx].busNumber,
					pExtension->pciDeviceInfo[inx].deviceNumber,
					pExtension->pciDeviceInfo[inx].functionNumber));

			pPciConfig->sDeviceInfo[inx].ulNumberOfRanges = 2;
	
			pPciConfig->sDeviceInfo[inx].sPciConfigRangeDesc[0].ucStart = 6;
			pPciConfig->sDeviceInfo[inx].sPciConfigRangeDesc[0].ucEnd = 63;
	
			pPciConfig->sDeviceInfo[inx].sPciConfigRangeDesc[1].ucStart = 4;
			pPciConfig->sDeviceInfo[inx].sPciConfigRangeDesc[1].ucEnd = 5;
	
	
			// for the local device we need to specify the number of access ranges
			// and lengths for each so that the RCMC service can validate a
			// replacement controller's ranges against the removed adapter's.
	
			if (inx == 1)   // For Foot Bridge
			{
			    pPciConfig->sDeviceInfo[inx].ucBaseAddrVerifyCount = (u08bits )(pExtension->numAccessRanges);
	
			    DebugPrint((0, "Foot Bridge Access Range Count %d\n", pExtension->numAccessRanges));

			    for (j = 0; j < pExtension->numAccessRanges; j++)
			    {
				pPciConfig->sDeviceInfo[inx].ulBaseAddrLength[j] =
				    pExtension->accessRangeLength[j];

				DebugPrint((0, "inx %d length 0x%x\n", j, pExtension->accessRangeLength[j]));
			    }
			}
		    }

		    break;

		case MDAC_DEVPIDLP:
		    pPciConfig->ulNumberOfPciDevices = 2;

		    //
		    // supply Bus/Device/Function information for bridge device.
		    //
	
		    pPciConfig->sDeviceInfo[0].sPciDescriptor.ucBusNumber = pExtension->ctp->cd_BusNo;
		    pPciConfig->sDeviceInfo[0].sPciDescriptor.fcDeviceNumber = pExtension->ctp->cd_SlotNo;
		    pPciConfig->sDeviceInfo[0].sPciDescriptor.fcFunctionNumber = 0;

		    //
		    // supply bus/device/func# information for local device.
		    //
	
		    pPciConfig->sDeviceInfo[1].sPciDescriptor.ucBusNumber =
			 pExtension->ctp->cd_BusNo;
	
		    pPciConfig->sDeviceInfo[1].sPciDescriptor.fcDeviceNumber =
			 pExtension->ctp->cd_SlotNo;
	
		    pPciConfig->sDeviceInfo[1].sPciDescriptor.fcFunctionNumber = 1;


		    DebugPrint((0, "PG bridge device is at %d:%d:%d(b:d:f)\n",
				    pExtension->pciDeviceInfo[0].busNumber,
				    pExtension->pciDeviceInfo[0].deviceNumber,
				    pExtension->pciDeviceInfo[0].functionNumber));

		    DebugPrint((0, "local device is at %d:%d:%d(b:d:f)\n",
				    pExtension->pciDeviceInfo[1].busNumber,
				    pExtension->pciDeviceInfo[1].deviceNumber,
				    pExtension->pciDeviceInfo[1].functionNumber));

		    for (inx = 0; inx < pPciConfig->ulNumberOfPciDevices; inx++)
		    {
				pPciConfig->sDeviceInfo[inx].ulNumberOfRanges = 2;
		
				pPciConfig->sDeviceInfo[inx].sPciConfigRangeDesc[0].ucStart = 6;
				pPciConfig->sDeviceInfo[inx].sPciConfigRangeDesc[0].ucEnd = 63;
	
				pPciConfig->sDeviceInfo[inx].sPciConfigRangeDesc[1].ucStart = 4;
				pPciConfig->sDeviceInfo[inx].sPciConfigRangeDesc[1].ucEnd = 5;
	
	
				// for the local device we need to specify the number of access ranges
				// and lengths for each so that the RCMC service can validate a
				// replacement controller's ranges against the removed adapter's.
	
				if (inx == 1)
				{
					pPciConfig->sDeviceInfo[inx].ucBaseAddrVerifyCount = (u08bits )(pExtension->numAccessRanges);

				    DebugPrint((0, "PG local device Access Range Count %d\n", pExtension->numAccessRanges));
		
				    for (j = 0; j < pExtension->numAccessRanges; j++)
				    {
						pPciConfig->sDeviceInfo[inx].ulBaseAddrLength[j] =
						  pExtension->accessRangeLength[j];

						DebugPrint((0, "inx %d length 0x%x\n", j, pExtension->accessRangeLength[j]));
					}
				}
		    }

		    break;

	default:
		    pPciConfig->ulNumberOfPciDevices = 0;
		    break;
	    }

	    break;
	}

	case IOC_HPP_DIAGNOSTICS:
	default:
		DebugPrint((0, "Bad Request\n"));
		pHppIoctl->Header.ReturnCode = IOS_HPP_BAD_REQUEST;
		break;
    }

    return (status);
		
}

BOOLEAN
HotPlugPseudo_entry(
    IN PVOID HwDeviceExtension,
    IN PSCSI_REQUEST_BLOCK Srb
)
{
    PPSEUDO_DEVICE_EXTENSION pPseudoExtension = HwDeviceExtension;
    UCHAR status;
    ULONG inx, tmp;
//    MLXSPLVAR;
//    MLXSPL();
MdacInt3();
    DebugPrint((1, "HotPlugPseudo_entry: Entry\n"));

    switch (Srb->Function)
    {
	case SRB_FUNCTION_RESET_BUS:
	    status = SRB_STATUS_SUCCESS;
	    break;

	case SRB_FUNCTION_EXECUTE_SCSI:
	    switch (Srb->Cdb[0])
	    {
		case SCSIOP_TEST_UNIT_READY:
		    DebugPrint((0, "SCSIOP_TEST_UNIT_READY\n"));
		    status = SRB_STATUS_SUCCESS;
		    break;

		case SCSIOP_READ_CAPACITY:
		    DebugPrint((0, "SCSIOP_READ_CAPACITY\n"));

		    if ((Srb->PathId == 0) && (Srb->TargetId == 0))
		    {
			ULONG blockSize = 0;
			ULONG numberOfBlocks = 0;

			REVERSE_BYTES(
			    &((PREAD_CAPACITY_DATA)Srb->DataBuffer)->BytesPerBlock,
			    &blockSize);

			REVERSE_BYTES(
			    &((PREAD_CAPACITY_DATA)Srb->DataBuffer)->LogicalBlockAddress,
			    &numberOfBlocks);

			status = SRB_STATUS_SUCCESS;
		    }
		    else
			status = SRB_STATUS_ERROR;
		    break;

		case SCSIOP_INQUIRY:

		    if (Srb->Lun || Srb->TargetId)
		    {
			status = SRB_STATUS_SELECTION_TIMEOUT;
			break;
		    }

		    DebugPrint((1, "SCSIOP_INQUIRY for Pseudo Hot Plug device\n"));

		    for (inx = 0; inx < Srb->DataTransferLength; inx++)
			((PUCHAR)Srb->DataBuffer)[inx] = 0;

		    ((PINQUIRYDATA)Srb->DataBuffer)->DeviceType = DEVICE_QUALIFIER_NOT_SUPPORTED;

		    mdac_copy("MylexPHPPSEUDO          ",
			    ((PINQUIRYDATA)Srb->DataBuffer)->VendorId,
			     24);

		    tmp = pPseudoExtension->hotplugVersion;

		    for (inx = 0; inx < 4; inx++)
		    {
			((PINQUIRYDATA)Srb->DataBuffer)->ProductRevisionLevel[inx] = (UCHAR)tmp + 0x30;
			tmp >>= 8;
		    }

		    status = SRB_STATUS_SUCCESS;
		    break;

		case SCSIOP_VERIFY:
		    status = SRB_STATUS_SUCCESS;
		    break;

		default:
		    DebugPrint((0, "HotPlugPseudo_entry, Cdb[0] %x not handled.\n", Srb->Cdb[0]));
		    status = SRB_STATUS_INVALID_REQUEST;
		    break;
	    }
	    break;

	case SRB_FUNCTION_FLUSH:
	case SRB_FUNCTION_SHUTDOWN:

	    DebugPrint((0, "SRB_FUNCTION_SHUTDOWN\n"));
	    status = SRB_STATUS_SUCCESS;
	    break;

	case SRB_FUNCTION_IO_CONTROL:
	{
	    PMDAC_HPP_IOCTL_BUFFER pIoctlBuffer = (PMDAC_HPP_IOCTL_BUFFER) Srb->DataBuffer;

	    DebugPrint((1, "SRB_FUNCTION_IO_CONTROL\n"));

	    if (mdac_cmp(pIoctlBuffer->Header.Signature, MLX_HPP_SIGNATURE, 8))
	    {
		DebugPrint((0, "SRB_FUNCTION_IO_CONTROL: Signature does not match.\n"));
		status = SRB_STATUS_INVALID_REQUEST;
		break;
	    }

	    if (HotPlugProcessIoctl(pPseudoExtension, Srb) == IOP_HPP_ISSUED)
		status = SRB_STATUS_PENDING;
	    else
		status = SRB_STATUS_SUCCESS;

	    break;
	}

	default:
	    DebugPrint((0, "HotPlugPseudo_entry: Function Code %x not handled.\n", Srb->Function));
	    status = SRB_STATUS_INVALID_REQUEST;
	    break;
    }

    if (status != SRB_STATUS_PENDING)
    {
	Srb->SrbStatus = status;

	mdacScsiPortNotification(pPseudoExtension,Srb);
    }
    else
    {
	// increment count of pending requests
	// schedule timer if need be.

	mdac_link_lock();
	if (!pPseudoExtension->numberOfPendingRequests++)
	{
	    mdac_link_unlock();

	    DebugPrint((1, "Pseudo_entry: schedule RequestCompletion Timer\n"));
    
//	    MLXSPLX();

	    HotPlugRequestCompletionTimer(pPseudoExtension);
	    goto php_next_request;
	}
	else
	    mdac_link_unlock();
    }

//    MLXSPLX();

php_next_request:

    //
    // Indicate to system that the controller can take another request for this device.
    //

    ScsiPortNotification(NextLuRequest, pPseudoExtension, 0, 0, 0);

    return (TRUE);
}

BOOLEAN
HotPlugPseudoResetBus(
	IN PVOID HwDeviceExtension,
	IN ULONG PathId
)
{
	MdacInt3();
    DebugPrint((0, "HotPlugPseudoResetBus: Entry\n"));

    return (TRUE);
}

#endif

#ifdef WINNT_50

SCSI_ADAPTER_CONTROL_STATUS
Dac960AdapterControl(
	IN PVOID HwDeviceExtension,
	IN SCSI_ADAPTER_CONTROL_TYPE ControlType,
	IN PVOID Parameters
)

/*++

Routine Description:

	This is the Hardware Adapter Control routine for the DAC960 SCSI adapter.

Arguments:

	HwDeviceExtension - HBA miniport driver's adapter data storage
	ControlType - control code - stop/restart codes etc.,
	Parameters - relevant i/o data buffer

Return Value:

	SUCCESS, if operation successful.

--*/

{
    PDEVICE_EXTENSION deviceExtension = HwDeviceExtension;
    PSCSI_SUPPORTED_CONTROL_TYPE_LIST querySupportedControlTypes;
    ULONG control;
    mdac_ctldev_t MLXFAR *ctp = ((PDEVICE_EXTENSION)HwDeviceExtension)->ctp;


	 MdacInt3();


    if (ControlType == ScsiQuerySupportedControlTypes)
    {
	querySupportedControlTypes = (PSCSI_SUPPORTED_CONTROL_TYPE_LIST) Parameters;

	DebugPrint((0, "Dac960AdapterControl: QuerySupportedControlTypes, MaxControlType 0x%x devExt 0x%I\n",
			querySupportedControlTypes->MaxControlType, deviceExtension));

	for (control = 0; control < querySupportedControlTypes->MaxControlType; control++)
	{
	    switch (control) {
		case ScsiQuerySupportedControlTypes:
		case ScsiStopAdapter:
//		case ScsiRestartAdapter:
		    querySupportedControlTypes->SupportedTypeList[control] = TRUE;
		    break;

		default:
		    querySupportedControlTypes->SupportedTypeList[control] = FALSE;
		    break;
	    }
	}

	return (ScsiAdapterControlSuccess);
    }

//    if (ControlType == ScsiRestartAdapter)
//    {
//        MdacInt3();
//	mdac_ctlinit(ctp);
//	return (ScsiAdapterControlSuccess);
//    }	

    if (ControlType != ScsiStopAdapter)
    {
	DebugPrint((0, "Dac960AdapterControl: control type 0x%x not supported. devExt 0x%I\n",
			ControlType, deviceExtension));

	return (ScsiAdapterControlUnsuccessful);
    }

    DebugPrint((0, "Dac960AdapterControl: #cmds outstanding 0x%x for ctp 0x%I\n",
		ctp->cd_ActiveCmds, ctp));

//@Kawase08/22/2000    if (gam_present) *(u32bits MLXFAR *)(ctp->cd_mdac_pres_addr) = -1L;
    if (gam_present && ctp->cd_mdac_pres_addr!=0)
    {
        *(u32bits MLXFAR *)(ctp->cd_mdac_pres_addr) = -1L;
    }

    //
    // ControlType is ScsiStopAdapter. Shutdown the controller.
    //
    mdac_flushcache(ctp);
    (*ctp->cd_DisableIntr)(ctp);

    ctp->cd_irq = 0; 
    ctp->cd_Status  &=  ~MDACD_PRESENT;

    --mdacActiveControllers;
    return (ScsiAdapterControlSuccess);
}

#endif

ULONG
DriverEntry (
	IN PVOID DriverObject,
	IN PVOID Argument2
)

/*++

Routine Description:

	Installable driver initialization entry point for system.


Arguments:

	Driver Object

Return Value:

	Status from ScsiPortInitialize()

--*/

{
	HW_INITIALIZATION_DATA hwInitializationData;
	ULONG inx;
	ULONG SlotNumber;
	ULONG Status1 = 0;
	ULONG Status2 = 0;
	UCHAR vendorId[4] = {'1', '0', '6', '9'};
	UCHAR deviceId[4] = {'0', '0', '0', '1'};

	DebugPrint((0,"\nMylex Raid SCSI Miniport Driver\n"));
	MdacInt3();
	//
	// Disable Advanced Interrupt mode - can not coexist with HotPlug, ALPHA
	//

	mdac_advanceintrdisable=1;

#ifdef MLX_WIN9X
	mdac_advancefeaturedisable=1;
#endif
	mdacnt_initialize();

	// Zero out structure.

	for (inx=0; inx<sizeof(HW_INITIALIZATION_DATA); inx++)
		((PUCHAR)&hwInitializationData)[inx] = 0;

	// Set size of hwInitializationData.

	hwInitializationData.HwInitializationDataSize = sizeof(HW_INITIALIZATION_DATA);

	// Set entry points.

	hwInitializationData.HwInitialize  = Dac960Initialize;
	hwInitializationData.HwStartIo     = mdac_entry;
	hwInitializationData.HwInterrupt   = Dac960Interrupt;
	hwInitializationData.HwResetBus    = Dac960ResetBus;

#ifdef WINNT_50
	hwInitializationData.HwAdapterControl = Dac960AdapterControl;
   

#endif

	//
	// Show two access ranges - adapter registers and BIOS.
	//

	hwInitializationData.NumberOfAccessRanges = 2;

	//
	// Indicate will need physical addresses.
	//

	hwInitializationData.NeedPhysicalAddresses = TRUE;

	hwInitializationData.MapBuffers = TRUE;

	//
	// Indicate auto request sense is supported.
	//

	hwInitializationData.AutoRequestSense     = TRUE;
	hwInitializationData.MultipleRequestPerLu = TRUE;
	hwInitializationData.TaggedQueuing 	= TRUE;
	//
	// Specify size of extensions.
	//

	hwInitializationData.DeviceExtensionSize = sizeof(DEVICE_EXTENSION);
	hwInitializationData.SrbExtensionSize = MDAC_SRB_EXTENSION_SIZE;

	//
	// Set PCI ids.
	//

	hwInitializationData.DeviceId = &deviceId;
	hwInitializationData.DeviceIdLength = 4;
	hwInitializationData.VendorId = &vendorId;
	hwInitializationData.VendorIdLength = 4;

	hwInitializationData.AdapterInterfaceType = PCIBus;
	hwInitializationData.HwFindAdapter = Dac960PciFindAdapterOld;

#ifdef LEGACY_API

	//
	// Attempt PCI initialization for old DAC960 PCI (Device Id - 0001)
	// Controllers.
	//

	Status1 = ScsiPortInitialize(DriverObject,
				     Argument2,
				     &hwInitializationData,
				     NULL);

	DebugPrint((0, "After OS FWV2x scan. Status1 %x\n", Status1));

	//
	// Attempt PCI initialization for new DAC960 PCI (Device Id - 0002)
	// Controllers.
	//

	deviceId[3] = '2';

	Status2 = ScsiPortInitialize(DriverObject,
				     Argument2,
				     &hwInitializationData,
				     NULL);

	Status1 = Status2 < Status1 ? Status2 : Status1;

	DebugPrint((0, "After OS FWV3x scan. Status1 %x Status2 %x\n", Status1, Status2));

	//
	// Attempt PCI initialization for PCI DAC960 PG (Device Id - 0010)
	// Controllers.
	//

	deviceId[2] = '1';
	deviceId[3] = '0';

	Status2 = ScsiPortInitialize(DriverObject,
				     Argument2,
				     &hwInitializationData,
				     NULL);

	Status1 = Status2 < Status1 ? Status2 : Status1;

	DebugPrint((0, "After OS PG scan. Status1 %x Status2 %x\n", Status1, Status2));

	//
	// Attempt PCI initialization for PCI DAC1164P Controllers.
	//

	vendorId[0] = '1';
	vendorId[1] = '0';
	vendorId[2] = '1';
	vendorId[3] = '1';
	deviceId[0] = '1';
	deviceId[1] = '0';
	deviceId[2] = '6';
	deviceId[3] = '5';

	hwInitializationData.NumberOfAccessRanges = 3;
	Status2 = ScsiPortInitialize(DriverObject,
				     Argument2,
				     &hwInitializationData,
				     NULL);
	Status1 = Status2 < Status1 ? Status2 : Status1;

	DebugPrint((0, "After OS scan for 1164P. Status1 %x Status2 %x\n", Status1, Status2));

	if (Dac1164PDetected == FALSE)
	{
	    DebugPrint((0,"\nNT did not detect DAC1164P. Checking for DAC1164P\n"));

	    forceScanDac1164P = TRUE;
    
	    hwInitializationData.DeviceId = 0;
	    hwInitializationData.DeviceIdLength = 0;
	    hwInitializationData.VendorId = 0;
	    hwInitializationData.VendorIdLength = 0;
	    hwInitializationData.HwFindAdapter = Dac960PciFindAdapterNew;
	    hwInitializationData.NumberOfAccessRanges = 1;
    
	    hwInitializationData.AdapterInterfaceType = PCIBus;
    
	    Status2 = ScsiPortInitialize(DriverObject,
					 Argument2,
					 &hwInitializationData,
					 NULL);

	    Status1 = Status2 < Status1 ? Status2 : Status1;

	    forceScanDac1164P = FALSE;

	    DebugPrint((0, "After Driver 1164P scan. Status1 %x Status2 %x\n", Status1, Status2));

	}
#endif /* LEGACY_API */

#ifndef MLX_WIN9X
#ifdef NEW_API

	//
	// For PCI controllers with IOSpace and MemorySpace,
	// Windows 95/98 will map IO Space only.
	//
	// However IOSpace can not be used on BigApple controlers.
	//

	MdacInt3();
	//
	// Attempt PCI initialization for PCI EXR2000 Controllers.
	//

	vendorId[0] = '1';
	vendorId[1] = '0';
	vendorId[2] = '6';
	vendorId[3] = '9';
	deviceId[0] = 'B';
	deviceId[1] = 'A';
	deviceId[2] = '5';
	deviceId[3] = '6';

	//
	// Set PCI ids.
	//

	hwInitializationData.NumberOfAccessRanges = 2;

	Status1 = ScsiPortInitialize(DriverObject,
				     Argument2,
				     &hwInitializationData,
				     NULL);

	DebugPrint((0, "After OS Scan for EXR Controllers. Status1 %x\n", Status1));

	//
	// Attempt PCI initialization for Leopard Controllers.
	//

	vendorId[0] = '1';
	vendorId[1] = '0';
	vendorId[2] = '6';
	vendorId[3] = '9';
	deviceId[0] = '0';
	deviceId[1] = '0';
	deviceId[2] = '5';
	deviceId[3] = '0';

	//
	// Set PCI ids.
	//

	hwInitializationData.DeviceId = &deviceId;
	hwInitializationData.DeviceIdLength = 4;
	hwInitializationData.VendorId = &vendorId;
	hwInitializationData.VendorIdLength = 4;
	hwInitializationData.HwFindAdapter = Dac960PciFindAdapterOld;
	hwInitializationData.NumberOfAccessRanges = 2;

	Status2 = ScsiPortInitialize(DriverObject,
				     Argument2,
				     &hwInitializationData,
				     NULL);

	Status1 = Status2 < Status1 ? Status2 : Status1;

	DebugPrint((0, "After OS Scan for Leopard Controllers. Status1 %x Status2 %x\n", Status1, Status2));

	if (EXR2000Detected == FALSE)
	{
	    DebugPrint((0,"\nOS did not detect EXR2000. Checking for EXR2000\n"));

	    forceScanEXR2000 = TRUE;
    
	    hwInitializationData.DeviceId = 0;
	    hwInitializationData.DeviceIdLength = 0;
	    hwInitializationData.VendorId = 0;
	    hwInitializationData.VendorIdLength = 0;
	    hwInitializationData.HwFindAdapter = Dac960PciFindAdapterNew;
	    hwInitializationData.NumberOfAccessRanges = 1;
    
	    hwInitializationData.AdapterInterfaceType = PCIBus;
    
	    Status2 = ScsiPortInitialize(DriverObject,
					 Argument2,
					 &hwInitializationData,
					 NULL);

	    Status1 = Status2 < Status1 ? Status2 : Status1;

	    forceScanEXR2000 = FALSE;

	    DebugPrint((0, "After Driver EXR2000 scan. Status1 %x Status2 %x\n", Status1, Status2));
	}

	if (EXR3000Detected == FALSE)
	{

	    DebugPrint((0,"\nOS did not detect EXR3000. Checking for EXR3000\n"));

	    forceScanEXR3000 = TRUE;
    
	    Status2 = ScsiPortInitialize(DriverObject,
					 Argument2,
					 &hwInitializationData,
					 NULL);

	    Status1 = Status2 < Status1 ? Status2 : Status1;

	    forceScanEXR3000 = FALSE;

	    DebugPrint((0, "After Driver EXR3000 scan. Status1 %x Status2 %x\n", Status1, Status2));
	}

	if (LEOPDetected == FALSE)
	{

	    DebugPrint((0,"\nOS did not detect Leopard. Checking for Leopard\n"));

	    forceScanLEOP = TRUE;
    
	    Status2 = ScsiPortInitialize(DriverObject,
					 Argument2,
					 &hwInitializationData,
					 NULL);

	    Status1 = Status2 < Status1 ? Status2 : Status1;

	    forceScanLEOP = FALSE;

	    DebugPrint((0, "After Driver LEOPARD scan. Status1 %x Status2 %x\n", Status1, Status2));
	}

	if (LYNXDetected == FALSE)
	{

	    DebugPrint((0,"\nOS did not detect Lynx. Checking for Lynx\n"));

	    forceScanLYNX = TRUE;
    
	    Status2 = ScsiPortInitialize(DriverObject,
					 Argument2,
					 &hwInitializationData,
					 NULL);

	    Status1 = Status2 < Status1 ? Status2 : Status1;

	    forceScanLYNX = FALSE;

	    DebugPrint((0, "After Driver Lynx scan. Status1 %x Status2 %x\n", Status1, Status2));
	}

	if (BOBCATDetected == FALSE)
	{

	    DebugPrint((0,"\nOS did not detect BobCat. Checking for BobCat\n"));

	    forceScanBOBCAT = TRUE;
    
	    Status2 = ScsiPortInitialize(DriverObject,
					 Argument2,
					 &hwInitializationData,
					 NULL);

	    Status1 = Status2 < Status1 ? Status2 : Status1;

	    forceScanBOBCAT = FALSE;

	    DebugPrint((0, "After Driver BobCat scan. Status1 %x Status2 %x\n", Status1, Status2));
	}

#endif /* NEW_API */
#endif /* ndef MLX_WIN9X */

#if !defined(MLX_NT_ALPHA) && !defined(MLX_WIN9X)

	if ((Dac1164PDetected == FALSE) &&  (Dac960PGDetected == FALSE)  &&
	    (EXR3000Detected == FALSE)  && (LEOPDetected == FALSE) &&  
	    (LYNXDetected == FALSE)  && (BOBCATDetected == FALSE))  
	{
	    return (0);
	}



	mdacActiveControllers = mda_Controllers;
	//
	// fake a Pseudo controller for handling Hot-Plug IOCTLs
	//

	// Zero out structure.

	for (inx=0; inx<sizeof(HW_INITIALIZATION_DATA); inx++)
		((PUCHAR)&hwInitializationData)[inx] = 0;

	// Set size of hwInitializationData.

	hwInitializationData.HwInitializationDataSize = sizeof(HW_INITIALIZATION_DATA);

	// Set entry points.

	hwInitializationData.HwInitialize  = HotPlugPseudoInitialize;
	hwInitializationData.HwStartIo     = HotPlugPseudo_entry;
	hwInitializationData.HwInterrupt   = NULL;
	hwInitializationData.HwResetBus    = HotPlugPseudoResetBus;

	//
	// Don't need any access ranges.
	//

	hwInitializationData.NumberOfAccessRanges = 0;

	//
	// Indicate will need physical addresses.
	//

	hwInitializationData.NeedPhysicalAddresses = TRUE;

	hwInitializationData.MapBuffers = TRUE;
	hwInitializationData.AutoRequestSense     = FALSE;
	hwInitializationData.MultipleRequestPerLu = TRUE;
	hwInitializationData.TaggedQueuing 	= TRUE;
	//
	// Specify size of extensions.
	//

	hwInitializationData.DeviceExtensionSize = sizeof(DEVICE_EXTENSION);
	hwInitializationData.SrbExtensionSize = MDAC_SRB_EXTENSION_SIZE;
	DebugPrint((1,"\nScanning for Pseudo controller.\n"));

	//
	// Attempt PCI initialization for Pseudo controller
	//

	hwInitializationData.AdapterInterfaceType = PCIBus;
	hwInitializationData.HwFindAdapter = HotPlugPseudoFindAdapter;
	SlotNumber = 0;

	Status2 = ScsiPortInitialize(DriverObject,
				     Argument2,
				     &hwInitializationData,
				     &SlotNumber);

	DebugPrint((0, "After OS PseudoController scan. Status1 %x Status2 %x\n", Status1, Status2));
#endif

	return (0);

} // end DriverEntry()

u32bits MLXFAR
gam_copy(sp,dp,sz)
u08bits MLXFAR *sp;
u08bits MLXFAR *dp;
u32bits sz;
{
	u32bits resd = sz % sizeof(u32bits);
	sz = sz / sizeof(u32bits);      /* get 32bits count value */
	for(; sz; sp+=sizeof(u32bits), dp += sizeof(u32bits), sz--)
		*((u32bits*)dp) = *((u32bits*)sp);
	for (sz=resd; sz; sp++, dp++, sz--) *dp = *sp;
	return 0;
}

#ifdef MLX_NT
BOOLEAN
Dac960Interrupt(
	IN PVOID HwDeviceExtension
)
{
	if (mdacintr((UINT_PTR)HwDeviceExtension))
	{
	    //we get stray interrupts in the hibernation path - why???
	    if (MaxMemToAskFor == REDUCEDMEMSIZE)
			return (TRUE); 
	    return (FALSE);
	}
	return (TRUE);                
}

BOOLEAN
mdacnt_allocmemory(
    mdac_ctldev_t MLXFAR *ctp
)
{
	mdac_mem_t MLXFAR *mem_list[MDAC_MAX4KBMEMSEGS];
	mdac_mem_t MLXFAR *mp;
	u32bits index;

	for (index = 0; index < MDAC_MAX4KBMEMSEGS; index++)
	{
	    mem_list[index] = mdac_alloc4kb(ctp);
	}

	for (index = 0; index < MDAC_MAX4KBMEMSEGS; index++)
	{
	    mp = mem_list[index];
	    if (mp) mdac_free4kb(ctp,mp);
	    mem_list[index] = NULL;
	}

	for (index = 0; index < MDAC_MAX8KBMEMSEGS; index++)
	{
	    mem_list[index] = mdac_alloc8kb(ctp);
	}

	for (index = 0; index < MDAC_MAX8KBMEMSEGS; index++)
	{
	    mp = mem_list[index];
	    if (mp) mdac_free8kb(ctp,mp);
	    mem_list[index] = NULL;
	}

	return TRUE;
}

BOOLEAN
mdacnt_initialize()
{
	TIME_FIELDS    timeFields;

	timeFields.Year = 1970;
	timeFields.Month = 1;
	timeFields.Day = 1;
	timeFields.Hour = 0;
	timeFields.Minute = 0;
	timeFields.Second = 0;
	timeFields.Milliseconds = 0;
	timeFields.Weekday = 0;
	mdac_commoninit();


	return (TRUE);
}


VOID
nt_delay10us()
{
    ScsiPortStallExecution(10);
}


u32bits 
nt_ctime()
{
	return(0);
}

u32bits
nt_clbolt()
{
	return(0);
}

void
mdac_wakeup(u32bits MLXFAR *chan)
{
}

u32bits
mdac_sleep(u32bits MLXFAR *chan, u32bits signal)
{
    return(0);
}


ULONG
GamCopyInOut(UCHAR MLXFAR *sp, UCHAR MLXFAR *dp, ULONG sz, ULONG direction)
{
    gam_copy(sp, dp, sz);
    return(0);
}

u32bits mdacnt_timeout(func, tm)
u32bits func, tm;
{
	return(0);
}

#elif MLX_WIN9X

BOOLEAN
Dac960Interrupt(
	IN PVOID HwDeviceExtension
)
{
//	MLXSPLVAR;
//	MLXSPL();
	if (mdacintr((UINT_PTR)HwDeviceExtension))
	{
//	    MLXSPLX();
	    return (FALSE);
	}
//	MLXSPLX();

	return (TRUE);                
}

BOOLEAN
mdacnt_initialize()
{
    u32bits inx;

    if (driverInitDone == FALSE)
    {
	driverInitDone = TRUE;

	for (inx=0; inx < MDAC_MEM_LIST_SIZE; inx++)
	    mdac_mem_list[inx].used = 0;

	mdac_commoninit();
    }

    return (TRUE);
}

VOID
mdacw95_delay10us()
{
    ScsiPortStallExecution(10);
}

u32bits 
mdacw95_ctime()
{
	return(0);
}

u32bits
mdacw95_clbolt()
{
	return(0);
}

ULONG
GamCopyInOut(UCHAR MLXFAR *sp, UCHAR MLXFAR *dp, ULONG sz, ULONG direction)
{
    return(0);
}
#if 1
u32bits
mdac_sleep(u32bits MLXFAR *chan, u32bits signal)
{
//    MLXSPLVAR;
    VMM_SEMAPHORE hsemaphore;

    mdac_sleep_unlock();

    DebugPrint((mdacnt_dbg , "Before Sleep, Chan=%lx\n", (u32bits)chan));
    hsemaphore = Create_Semaphore(0);
    DebugPrint((mdacnt_dbg , "Create_Semaphore ret: hsemaphore %lx\n", (u32bits)hsemaphore));
    if (hsemaphore == 0) {
	mdac_sleep_lock();  // NOTE: can the lock be still held ?.
	return (1);
    }

    // store semaphore handle in the sleep channel

    *chan = (u32bits) hsemaphore;
#if 0
//    MLXSPLX();
#else
//    MLXSPL0();
#endif

    DebugPrint((mdacnt_dbg, "Wait on Semaphore handle %lx\n", (u32bits)hsemaphore));

#if 0
    Wait_Semaphore(hsemaphore, (BLOCK_FORCE_SVC_INTS | BLOCK_ENABLE_INTS | BLOCK_THREAD_IDLE | BLOCK_THREAD_IDLE | BLOCK_SVC_INTS | BLOCK_SVC_IF_INTS_LOCKED));
#else
    Wait_Semaphore(hsemaphore, (BLOCK_ENABLE_INTS | BLOCK_SVC_IF_INTS_LOCKED | BLOCK_SVC_INTS));
#endif

    DebugPrint((mdacnt_dbg, "Destroy Semaphore handle %lx\n", (u32bits)hsemaphore));

    Destroy_Semaphore(hsemaphore);

    DebugPrint((mdacnt_dbg, "Semaphore handle %lx destroyed.\n", (u32bits)hsemaphore));
#if 1
//    MLXSPLX();
//    MLXSPL();
#endif

    mdac_sleep_lock();

    return(0);
}

void
mdac_wakeup(u32bits MLXFAR *chan)
{
    DebugPrint((0, "mdac_wakeup: chan = %lx, hsempahore = %lx\n", (u32bits)chan, (u32bits)*chan));
    Signal_Semaphore((VMM_SEMAPHORE)*chan); // returns with interrupts enabled
    return;
}
#else
u32bits
mdac_sleep(u32bits MLXFAR *chan, u32bits signal)
{
//    MLXSPLVAR;

    mdac_sleep_unlock();

//    MLXSPLX();

    DebugPrint((mdacnt_dbg , "Before block, Chan=%lx\n", (u32bits)chan));

    _BlockOnID((u32bits)chan, (BLOCK_ENABLE_INTS | BLOCK_SVC_INTS | BLOCK_SVC_IF_INTS_LOCKED));

    DebugPrint((mdacnt_dbg , "after block, Chan=%lx\n", (u32bits)chan));

//    MLXSPL();

    mdac_sleep_lock();

    return(0);
}

void
mdac_wakeup(u32bits MLXFAR *chan)
{
    DebugPrint((0, "mdac_wakeup: chan = %lx\n", (u32bits)chan));
    _SignalID((u32bits)chan); // returns with interrupts enabled
    return;
}
#endif

u32bits
mdacw95_allocmem(mdac_ctldev_t MLXFAR *ctp, u32bits sz)
{
    u32bits numpages = (sz + MDAC_PAGEOFFSET) / MDAC_PAGESIZE;
    u32bits linearaddress;
    u32bits physicaladdress;
    u32bits i;

    if (!numpages)
    {
	DebugPrint((0, "mdacw95_allocmem: numpages 0\n"));
	return (numpages);
    }

    linearaddress = (u32bits) _PageAllocate(numpages, PG_SYS, 0, 0, 0, 0x100000, (PVOID)&physicaladdress, (PAGECONTIG | PAGEFIXED | PAGEUSEALIGN));

    DebugPrint((1, "mdacw95_allocmem: sz %lx, #pages %lx, la %lx, pa %lx\n",
		sz, numpages, linearaddress, physicaladdress));

    // update memory block linked list

    mdac_link_lock();

    for (i = 0; i < MDAC_MEM_LIST_SIZE; i++)
    {
	if (mdac_mem_list[i].used) continue;
	break;
    }

    if (i < MDAC_MEM_LIST_SIZE) {
	mdac_mem_list[i].used =  1;
	mdac_mem_list[i].virtualPageNumber = linearaddress >> 12;
	mdac_mem_list[i].physicalAddress = physicaladdress;
	mdac_mem_list[i].size   = numpages;
    }
    else
    {
	DebugPrint((0, "mdacw95_allocmem: mdac_mem_list table full\n"));
	linearaddress = 0;
    }

    mdac_link_unlock();

    return(linearaddress);
}

u32bits
mdacw95_freemem(mdac_ctldev_t MLXFAR *ctp, u32bits address, u32bits sz)
{
    u32bits i;
    u32bits numpages = (sz + MDAC_PAGEOFFSET) / MDAC_PAGESIZE;
    u32bits status;

    if (!numpages)
    {
	DebugPrint((0, "mdacw95_freemem: numpages 0\n"));
	return (numpages);
    }

    mdac_link_lock();

    for (i = 0; i < MDAC_MEM_LIST_SIZE; i++)
    {
	if (mdac_mem_list[i].used &&
	     mdac_mem_list[i].virtualPageNumber == (address >> 12)) break;
    }
    if (i < MDAC_MEM_LIST_SIZE) {
	mdac_mem_list[i].used =  0;
	mdac_mem_list[i].virtualPageNumber = 0;
	mdac_mem_list[i].physicalAddress = 0;
	mdac_mem_list[i].size   = 0;
    }
    else
    {
	DebugPrint((0, "mdacw95_freemem: could not find entry for address %lx\n", address));
	mdac_link_unlock();

	return (0);
    }

    mdac_link_unlock();

    status = _LinPageUnLock((DWORD)(address >> 12), (DWORD)numpages, (DWORD)0);

    DebugPrint((2, "mdacw95_freemem: sz %lx, numpages %lx, _PageUnlock status %lx\n",
		sz, numpages, status));

    status = _PageFree((PVOID)address, 0);

    DebugPrint((2, "mdacw95_freemem: _PageFree status %lx\n", status));

    return(0);
}

u32bits
mdacw95_maphystokv(u32bits physaddr, u32bits sz)
{
    u32bits linearaddress;

    linearaddress = (u32bits) _MapPhysToLinear(physaddr, sz, 0);

    DebugPrint((2, "mdacw95_maphystokv: pa %lx, sz %lx, la %lx\n",
		physaddr, sz, linearaddress));

    if (linearaddress == 0xFFFFFFFF)
	return (0);

    return (linearaddress);
}

u32bits
mdacw95_kvtophys(mdac_ctldev_t MLXFAR *ctp, u32bits address)
{
    u32bits i;
    u32bits physaddress;
    u32bits pageNumber = address >> 12;

    for (i = 0; i < MDAC_MEM_LIST_SIZE; i++)
    {
	if (!mdac_mem_list[i].used) continue;

	if ((mdac_mem_list[i].virtualPageNumber <= pageNumber) &&
	    (pageNumber < mdac_mem_list[i].virtualPageNumber + mdac_mem_list[i].size))
	{
	    break;
	}
    }
    if (i < MDAC_MEM_LIST_SIZE) {
	physaddress = mdac_mem_list[i].physicalAddress +
			((pageNumber - mdac_mem_list[i].virtualPageNumber) << 12) +
			(address & MDAC_PAGEOFFSET);
    }
    else
    {
	DebugPrint((0, "mdacw95_kvtophys: could not find entry for address %lx\n", address));
	physaddress = 0;
    }

    DebugPrint((2, "mdacw95_kvtophys: pa %lx, va %lx\n",
		physaddress, address));

    return (physaddress);
}

VOID
mdacw95_timeout(u32bits fn, u32bits tm)
{
//    HTIMEOUT htimeout;
//    htimeout = Set_Global_Time_Out((VMM_TIMEOUT_HANDLER)fn, (CMS)(tm * 1000), 0);

    return;
}

#endif // MLX_WIN9X

u32bits MLXFAR
mdac_osreqstart(
	mdac_ctldev_t MLXFAR *ctp
)
{
	PSCSI_REQUEST_BLOCK srb;

	dqosreq(ctp, srb, NextSrb);

	if (srb)
	{
		mdac_entry((PVOID)ctp->cd_deviceExtension, srb);
	}

	return (0);
}

//
// Use this function to issue cache flush command.
//

u32bits MLXFAR
ntmdac_flushcache(ctp, osrqp, timeout, flag)
mdac_ctldev_t MLXFAR *ctp;
OSReq_t     MLXFAR *osrqp;
u32bits timeout;
u32bits flag;
{
	mdac_req_t MLXFAR *rqp;
    ntmdac_alloc_req_ret(ctp,&rqp,(PSCSI_REQUEST_BLOCK)osrqp,ERR_NOMEM);
	rqp->rq_OSReqp = osrqp;
	rqp->rq_FinishTime = mda_CurTime + timeout;

	if (ctp->cd_Status & MDACD_NEWCMDINTERFACE)
	{
	    mdaczero(ncmdp,mdac_commandnew_s);
	    ncmdp->nc_TimeOut = 0;
	    ncmdp->nc_Command = MDACMD_IOCTL;
	    if (flag)
		ncmdp->nc_SubIOCTLCmd = MDACIOCTL_PAUSEDEV;
	    else
		ncmdp->nc_SubIOCTLCmd = MDACIOCTL_FLUSHDEVICEDATA;
	    ncmdp->nc_Cdb[0] = MDACDEVOP_RAIDCONTROLLER;
	}
	else
	{
	    dcmd4p->mb_MailBox0_3 = 0; dcmd4p->mb_MailBox4_7 = 0;
	    dcmd4p->mb_MailBox8_B = 0; dcmd4p->mb_MailBoxC_F = 0;
	    dcmdp->mb_Command = DACMD_FLUSH;
	}
	MLXSTATS(ctp->cd_CmdsDone++;)
	rqp->rq_CompIntr = mdac_flushcmdintr;
	return mdac_send_cmd(rqp);
}

u32bits MLXFAR
mdac_flushcmdintr(
	mdac_req_t MLXFAR *rqp
)
{
	PSCSI_REQUEST_BLOCK srb = rqp->rq_OSReqp;
	PVOID deviceExtension = (PVOID) rqp->rq_ctp->cd_deviceExtension;

	if (dcmdp->mb_Status)
	    DebugPrint((0, "Cache Flush command error sts 0x%x\n", dcmdp->mb_Status));

	mdac_free_req(rqp->rq_ctp, rqp);

	//
	// Complete request.
	//

	srb->SrbStatus = SRB_STATUS_SUCCESS;

	RequestCompleted(deviceExtension,
			 srb);

	return (0);
}

u32bits MLXFAR
mdac_rwcmdintr(
	mdac_req_t MLXFAR *rqp
)
{
	mdac_req_t      MLXFAR *srqp;
	PSCSI_REQUEST_BLOCK srb;
	PVOID deviceExtension;

	for (srqp=rqp ; 1 ; rqp=rqp->rq_Next)
	{
	    srb = rqp->rq_OSReqp;
	    deviceExtension = (PVOID) rqp->rq_ctp->cd_deviceExtension;
	    //
	    // Map DAC960 completion status to SRB status.
	    //
    
	    switch (dcmdp->mb_Status)
	    {
		case DACMDERR_NOERROR:
		    srb->SrbStatus = SRB_STATUS_SUCCESS;
		    break;
    
		case DACMDERR_OFFLINEDRIVE:
		    DebugPrint((0, "CC for Srb %I, c %x p %x t %x\n",
				srb,
				rqp->rq_ctp->cd_ControllerNo,
				srb->PathId,
				srb->TargetId));

		    srb->SrbStatus = SRB_STATUS_NO_DEVICE;
		    break;
    
		case DACMDERR_NOCODE:
		    srb->SrbStatus = SRB_STATUS_INVALID_REQUEST;
		    break;
    
		case DACMDERR_DATAERROR_FW2X:
		case DACMDERR_DATAERROR_FW3X:
		    DebugPrint((0, "SE/BD for Srb %I, c %x p %x t %x\n",
				srb,
				rqp->rq_ctp->cd_ControllerNo,
				srb->PathId,
				srb->TargetId));

		    if(srb->SenseInfoBufferLength) 
		    {
			ULONG i;
		    
			for (i = 0; i < srb->SenseInfoBufferLength; i++)
			    ((PUCHAR)srb->SenseInfoBuffer)[i] = 0;
				    
			((PSENSE_DATA) srb->SenseInfoBuffer)->ErrorCode = 0x70;
			((PSENSE_DATA) srb->SenseInfoBuffer)->SenseKey = SCSI_SENSE_MEDIUM_ERROR;
    
			if (srb->SrbFlags & SRB_FLAGS_DATA_IN)
			    ((PSENSE_DATA) srb->SenseInfoBuffer)->AdditionalSenseCode = 0x11;
				    
			srb->SrbStatus = SRB_STATUS_ERROR | SRB_STATUS_AUTOSENSE_VALID;
    
			DebugPrint((0, 
				    "DAC960: System Drive %d, cmd sts = 1, sense info returned\n",
				    srb->TargetId));
    
		    }   
		    else
		    {
			srb->SrbStatus = SRB_STATUS_ERROR;
		    }
    
		    break;

		case DCMDERR_DRIVERTIMEDOUT:
		    DebugPrint((0, "DRVRTOUT, Srb %I Function %x\n",
				srb,
				srb->Function));
		    srb->SrbStatus = SRB_STATUS_TIMEOUT;                
		    break;

		case DACMDERR_INVALID_SYSTEM_DRIVE:
		    DebugPrint((0, "INVALID_SYSTEM_DRIVE, Srb %I\n", srb));
		    srb->SrbStatus = SRB_STATUS_NO_DEVICE;
		    break;

		case DACMDERR_CONTROLLER_BUSY:
		    DebugPrint((0, "CONTROLLER_BUSY, Srb %x\n", srb));
		    srb->SrbStatus = SRB_STATUS_BUSY;
		    break;

		case DACMDERR_INVALID_PARAMETER:
		    DebugPrint((0, "INVALID_PARAMETER, Srb %I\n", srb));
		    srb->SrbStatus = SRB_STATUS_INVALID_REQUEST;
		    break;

		case DACMDERR_RESERVATION_CONFLICT:
		    DebugPrint((0, "RESERVATION_CONFLICT, Srb %I\n", srb));
		    srb->ScsiStatus = SCSISTAT_RESERVATION_CONFLICT;
		    srb->SrbStatus = SRB_STATUS_ERROR;
		    break;
    
		default:
		    DebugPrint((0, "DAC960: Unrecognized status %x\n",
				dcmdp->mb_Status));
    
		    srb->SrbStatus = SRB_STATUS_ERROR;
		    break;
	    }
    
	    //
	    // Complete request.
	    //
    
	    RequestCompleted(deviceExtension,
			     srb);
    
	    if (!rqp->rq_Next) break;
	}
	mdac_free_req_list(srqp, rqp);
	return (0);
}



/* post a command completion for new interface */

u32bits MLXFAR
rqp_completion_intr(
	mdac_req_t MLXFAR *rqp
)
{
	PSCSI_REQUEST_BLOCK srb;
	PVOID deviceExtension;

DebugPrint((0, "rqp_completion_intr: rqp = %x, Cmd = %x , offset 21(decimal) = %x\n",
			rqp, *(((u08bits MLXFAR *)(rqp)) + 0xc2),*(((u08bits MLXFAR *)(rqp)) + 0xc0 + 21)));

	srb = rqp->rq_OSReqp;
	deviceExtension = (PVOID) rqp->rq_ctp->cd_deviceExtension;
	
	// Map DAC960 completion status to SRB status.
	    
	switch ( dcmdp->mb_Status )
	{
		case DACMDERR_NOERROR:
		    srb->SrbStatus = SRB_STATUS_SUCCESS;
		    break;

		case UCST_CHECK:
		case UCST_BUSY:
		{
		    /* set the check condition error */

		    ULONG requestSenseLength;

		    if ( dcmdp->mb_Status == UCST_BUSY )
		    {
			DebugPrint((0,"mdac_newcmd_intr: sts BUSY, c %x t %x l %x\n",
				    srb->PathId,
				    srb->TargetId,
				    srb->Lun));

//                      mdac_link_lock_st(pdp->pd_Status &= ~MDACPDS_PRESENT);
			srb->SrbStatus = SRB_STATUS_BUSY;
			break;
		    }

		    srb->ScsiStatus = SCSISTAT_CHECK_CONDITION;
		    srb->SrbStatus = SRB_STATUS_ERROR;
		    break;
		}
    
		case DACMDERR_NOCODE:
		    DebugPrint((mdacnt_dbg, "mdac_newcmd_intr: NOCODE %d\n", dcmdp->mb_Status));
		    srb->SrbStatus = SRB_STATUS_INVALID_REQUEST;
		    break;

		case DACMDERR_DATAERROR_FW2X:
		case DACMDERR_DATAERROR_FW3X:
		    DebugPrint((0, "mdac_newcmd_intr: SE/BD for Srb %I, c %x p %x t %x\n",
				srb,
				rqp->rq_ctp->cd_ControllerNo,
				srb->PathId,
				srb->TargetId));

		    srb->SrbStatus = SRB_STATUS_ERROR;

		    break;

		case DCMDERR_DRIVERTIMEDOUT:
		    DebugPrint((0, "mdac_newcmd_intr: DRVRTOUT, Srb %I Function %x\n",
				srb,
				srb->Function));
		    srb->SrbStatus = SRB_STATUS_TIMEOUT;                
		    break;

		case DACMDERR_SELECTION_TIMEOUT:
		    DebugPrint((0, "mdac_newcmd_intr: SELECTION TIMEOUT, Srb %I Function %x\n",
				srb,
				srb->Function));
		    srb->SrbStatus = SRB_STATUS_SELECTION_TIMEOUT;
		    break;

		case DACMDERR_INVALID_SYSTEM_DRIVE:
		    DebugPrint((0, "mdac_newcmd_intr: INVALID_SYSTEM_DRIVE, Srb %I\n", srb));
		    srb->SrbStatus = SRB_STATUS_NO_DEVICE;
		    break;

		case DACMDERR_CONTROLLER_BUSY:
		    DebugPrint((0, "mdac_newcmd_intr: CONTROLLER_BUSY, Srb %I\n", srb));
		    srb->SrbStatus = SRB_STATUS_BUSY;
		    break;

		case DACMDERR_INVALID_PARAMETER:
		    DebugPrint((0, "mdac_newcmd_intr: INVALID_PARAMETER, Srb %I\n", srb));
		    srb->SrbStatus = SRB_STATUS_INVALID_REQUEST;
		    break;

		case DACMDERR_RESERVATION_CONFLICT:
		    DebugPrint((0, "mdac_newcmd_intr: RESERVATION_CONFLICT, Srb %I\n", srb));
		    srb->ScsiStatus = SCSISTAT_RESERVATION_CONFLICT;
		    srb->SrbStatus = SRB_STATUS_ERROR;
		    break;
    
		default:
		    srb->SrbStatus = SRB_STATUS_ERROR;
		    break;
	    }
    
	    // Complete request.
    
	    RequestCompleted(deviceExtension,srb);
    	    return (0);
}


/* post a command completion for new interface */

u32bits MLXFAR
mdac_newcmd_intr(
	mdac_req_t MLXFAR *rqp
)
{
	mdac_req_t      MLXFAR *srqp;
	PSCSI_REQUEST_BLOCK srb;
	PVOID deviceExtension;

	for (srqp=rqp ; 1 ; rqp=rqp->rq_Next)
	{
	    srb = rqp->rq_OSReqp;
	    deviceExtension = (PVOID) rqp->rq_ctp->cd_deviceExtension;
	    //
	    // Map DAC960 completion status to SRB status.
	    //
    
	    switch ( dcmdp->mb_Status )
	    {
		case DACMDERR_NOERROR:
		    srb->SrbStatus = SRB_STATUS_SUCCESS;
		    break;

		case UCST_CHECK:
		case UCST_BUSY:
		{
		    /* set the check condition error */

		    ULONG requestSenseLength;

		    if ( dcmdp->mb_Status == UCST_BUSY )
		    {
			DebugPrint((0,"mdac_newcmd_intr: sts BUSY, c %x t %x l %x\n",
				    srb->PathId,
				    srb->TargetId,
				    srb->Lun));

//                      mdac_link_lock_st(pdp->pd_Status &= ~MDACPDS_PRESENT);
			srb->SrbStatus = SRB_STATUS_BUSY;
			break;
		    }
		    else
		    {
		    }

		    requestSenseLength = mlx_min(srb->SenseInfoBufferLength,
						    ncmdp->nc_SenseSize);

		    DebugPrint((1,"\tsibl %d dbsl %d rsl %d\n",
				    srb->SenseInfoBufferLength,
				    ncmdp->nc_SenseSize,
				    requestSenseLength));

		    srb->ScsiStatus = SCSISTAT_CHECK_CONDITION;
		    srb->SrbStatus = SRB_STATUS_ERROR;

		    if (requestSenseLength)
		    {
			srb->SrbStatus |= SRB_STATUS_AUTOSENSE_VALID;
//                      mdac_link_lock_st(pdp->pd_Status &= ~MDACPDS_PRESENT);
		    }

		    break;
		}
    
		case DACMDERR_NOCODE:
		    DebugPrint((mdacnt_dbg, "mdac_newcmd_intr: NOCODE %d\n", dcmdp->mb_Status));
		    srb->SrbStatus = SRB_STATUS_INVALID_REQUEST;
		    break;

		case DACMDERR_DATAERROR_FW2X:
		case DACMDERR_DATAERROR_FW3X:
		    DebugPrint((0, "mdac_newcmd_intr: SE/BD for Srb %I, c %x p %x t %x\n",
				srb,
				rqp->rq_ctp->cd_ControllerNo,
				srb->PathId,
				srb->TargetId));

		    srb->SrbStatus = SRB_STATUS_ERROR;

		    break;

		case DCMDERR_DRIVERTIMEDOUT:
		    DebugPrint((0, "mdac_newcmd_intr: DRVRTOUT, Srb %I Function %x\n",
				srb,
				srb->Function));
		    srb->SrbStatus = SRB_STATUS_TIMEOUT;                
		    break;

		case DACMDERR_SELECTION_TIMEOUT:
		    DebugPrint((0, "mdac_newcmd_intr: SELECTION TIMEOUT, Srb %I Function %x\n",
				srb,
				srb->Function));
		    srb->SrbStatus = SRB_STATUS_SELECTION_TIMEOUT;
		    break;

		case DACMDERR_INVALID_SYSTEM_DRIVE:
		    DebugPrint((0, "mdac_newcmd_intr: INVALID_SYSTEM_DRIVE, Srb %I\n", srb));
		    srb->SrbStatus = SRB_STATUS_NO_DEVICE;
		    break;

		case DACMDERR_CONTROLLER_BUSY:
		    DebugPrint((0, "mdac_newcmd_intr: CONTROLLER_BUSY, Srb %I\n", srb));
		    srb->SrbStatus = SRB_STATUS_BUSY;
		    break;

		case DACMDERR_INVALID_PARAMETER:
		    DebugPrint((0, "mdac_newcmd_intr: INVALID_PARAMETER, Srb %I\n", srb));
		    srb->SrbStatus = SRB_STATUS_INVALID_REQUEST;
		    break;

		case DACMDERR_RESERVATION_CONFLICT:
		    DebugPrint((0, "mdac_newcmd_intr: RESERVATION_CONFLICT, Srb %I\n", srb));
		    srb->ScsiStatus = SCSISTAT_RESERVATION_CONFLICT;
		    srb->SrbStatus = SRB_STATUS_ERROR;
		    break;
    
		default:
		    srb->SrbStatus = SRB_STATUS_ERROR;
		    break;
	    }
    
	    //
	    // Complete request.
	    //
    
	    RequestCompleted(deviceExtension,
			     srb);
    
	    if (!rqp->rq_Next) break;
	}

	mdac_free_req_list(srqp, rqp);
	return (0);
}

u32bits
mdacnt_fake_datatxfer_intr(mdac_req_t *rqp)
{
	mdac_ctldev_t   *ctp = rqp->rq_ctp;
	PSCSI_REQUEST_BLOCK srb = (PSCSI_REQUEST_BLOCK)rqp->rq_OSReqp;

	//
	// Set Error only if fake data transfer failed.
	// Else, the requestor has already set srb->SrbStatus to appropriate value.
	//

	if (dcmdp->mb_Status)
	{
	    DebugPrint((0, "fdti: ctp 0x%I, cmd failed sts 0x%x\n", ctp, dcmdp->mb_Status));
	    srb->SrbStatus = SRB_STATUS_ERROR;
	}
	else
	    srb->SrbStatus = SRB_STATUS_SUCCESS;

	DebugPrint((1, "fdti: ctp 0x%I, 0x54 cmd success.\n", ctp));

	mdac_free_req(ctp,rqp);

	//
	// Complete request.
	//

	RequestCompleted((PVOID) ctp->cd_deviceExtension,
			 srb);
	return (0);
}

u32bits
mdacnt_fake_datatxfer(ctp, sdp, sz, srb, dataBuffer)
mdac_ctldev_t *ctp;
u08bits *sdp;
u32bits sz;
PSCSI_REQUEST_BLOCK srb;
PVOID dataBuffer;
{
	mdac_req_t *rqp;
	ULONG length = sz;

	ntmdac_alloc_req_ret(ctp,&rqp,srb,ERR_NOMEM);
	mdaccopy(sdp, rqp->rq_SGVAddr, sz);
	rqp->rq_OSReqp = srb;
	rqp->rq_ctp = ctp;
	dcmdp->mb_Command = DACMD_PHYS2PHYSCOPY;
	dcmdp->mb_Datap = ScsiPortConvertPhysicalAddressToUlong(
			    ScsiPortGetPhysicalAddress(
						(PVOID)ctp->cd_deviceExtension,
						srb,
						dataBuffer,
						&length));

	DebugPrint((1, "senseBuffer 0x%I, esp 0x%I, sz %d bytes\n", dcmdp->mb_Datap,
				rqp->rq_SGPAddr.bit31_0, sz));

	MLXSWAP(dcmdp->mb_Datap);
	dcmd4p->mb_MailBox4_7 = rqp->rq_SGPAddr.bit31_0;

	MLXSWAP(dcmd4p->mb_MailBox4_7);
	dcmdp->mb_MailBox2 = sz & 0xFF;
	dcmdp->mb_MailBox3 = (sz >> 8) & 0xFF;
	dcmdp->mb_MailBoxC = 0;
	rqp->rq_CompIntr = mdacnt_fake_datatxfer_intr;

	return mdac_send_cmd(rqp);
}

u32bits MLXFAR
mdac_fake_scdb_done(
	mdac_req_t MLXFAR *rqp,
	u08bits MLXFAR *sdp,
	u32bits sz,
	ucscsi_exsense_t MLXFAR *esp
)
{
	mdac_ctldev_t MLXFAR *ctp = rqp->rq_ctp;
	PSCSI_REQUEST_BLOCK Srb = (PSCSI_REQUEST_BLOCK)rqp->rq_OSReqp;
	ULONG length;

	if (!Srb) return(0);

	if (ctp->cd_Status & MDACD_CLUSTER_NODE)
	{
	    if (!dcmdp->mb_Status)
	    {
		Srb->SrbStatus = SRB_STATUS_SUCCESS;

		if (sz)
		{
		    ScsiPortMoveMemory(Srb->DataBuffer, (PVOID)sdp, sz);
//		    mdaccopy(sdp, Srb->DataBuffer, sz);
//		    mdacnt_fake_datatxfer(ctp, sdp, sz, Srb, Srb->DataBuffer);
//		    return (0);
		}
		goto completeRequest;
	    }

	    switch (dcmdp->mb_Status) {
		case DACMDERR_INVALID_SYSTEM_DRIVE:
		    Srb->SrbStatus = SRB_STATUS_NO_DEVICE;
		    break;
    
		case DACMDERR_CONTROLLER_BUSY:
		    Srb->SrbStatus = SRB_STATUS_BUSY;
		    break;
    
		case DACMDERR_INVALID_PARAMETER:
		    Srb->SrbStatus = SRB_STATUS_INVALID_REQUEST;
		    break;
    
		case DACMDERR_RESERVATION_CONFLICT:
		    Srb->ScsiStatus = SCSISTAT_RESERVATION_CONFLICT;
		    Srb->SrbStatus = SRB_STATUS_ERROR;
		    break;
    
		default:
		    Srb->SrbStatus = SRB_STATUS_ERROR;
		    break;
	    }

	    goto completeRequest;
	}

	if (esp)
	{
#if 1
	    Srb->SrbStatus = SRB_STATUS_NO_DEVICE;
	    goto completeRequest;
#endif
	    DebugPrint((0, "mdac_fake_scdb_done: esp %Ix\n",esp));

	    if (Srb->SenseInfoBufferLength > ucscsi_exsense_s)
		Srb->SenseInfoBufferLength = ucscsi_exsense_s;

	    Srb->SrbStatus = SRB_STATUS_ERROR;

	    if (Srb->SenseInfoBufferLength)
	    {
		Srb->SrbStatus |= SRB_STATUS_AUTOSENSE_VALID;

		if (ctp->cd_FWVersion >= DAC_FW407)
		{
		    DebugPrint((0, "FW >= 407: call fake_dataxfer\n"));
		    mdacnt_fake_datatxfer(ctp, esp, Srb->SenseInfoBufferLength,
					  Srb, Srb->SenseInfoBuffer);
		    return (0);
		}
		else
		    ScsiPortMoveMemory(Srb->SenseInfoBuffer, (PVOID)esp, Srb->SenseInfoBufferLength);
	    }
	} 
	else 
	{
	    DebugPrint((1, "mdac_fake_scdb_done: esp NULL\n"));

	    length = Srb->DataTransferLength > sz ? sz : Srb->DataTransferLength;

	    Srb->SrbStatus = SRB_STATUS_SUCCESS;

    	    if (length && sdp)
	    {
		    ScsiPortMoveMemory(Srb->DataBuffer, (PVOID)sdp, length);	    
	    }

	}

completeRequest:
	//
	// Complete request.
	//

	RequestCompleted((PVOID) ctp->cd_deviceExtension,Srb);
	return (0);
}

u32bits MLXFAR
mdac_send_scdb_intr(
	mdac_req_t MLXFAR *rqp
)
{
	mdac_physdev_t MLXFAR *pdp = rqp->rq_pdp;
	PSCSI_REQUEST_BLOCK   srb = rqp->rq_OSReqp;
	PVOID deviceExtension = (PVOID)rqp->rq_ctp->cd_deviceExtension;
	u16bits status = dcmdp->mb_Status;

	switch (status)
	{
		case 0x00:
			srb->SrbStatus = SRB_STATUS_SUCCESS;
			break;

		case UCST_CHECK:
		case UCST_BUSY:
		{
			ULONG requestSenseLength;

			DebugPrint((0,"mdac_send_scdb_intr: sts %x, c %x t %x l %x\n",
					 status,
					 srb->PathId,
					 srb->TargetId,
					 srb->Lun));

			if (status == UCST_BUSY)
			{
			    mdac_link_lock_st(pdp->pd_Status &= ~MDACPDS_PRESENT);
			    srb->SrbStatus = SRB_STATUS_BUSY;
			    break;
			}

			requestSenseLength =
				srb->SenseInfoBufferLength <
				dcdbp->db_SenseLen      ?
				srb->SenseInfoBufferLength:
				dcdbp->db_SenseLen;

			DebugPrint((0,"\tsibl %d dbsl %d rsl %d\n",
					srb->SenseInfoBufferLength,
					dcdbp->db_SenseLen,
					requestSenseLength));

			srb->ScsiStatus = SCSISTAT_CHECK_CONDITION;
			srb->SrbStatus = SRB_STATUS_ERROR;

			if (requestSenseLength)
			{
			    ScsiPortMoveMemory(srb->SenseInfoBuffer, (PVOID)dcdbp->db_SenseData, requestSenseLength);
			    srb->SrbStatus |= SRB_STATUS_AUTOSENSE_VALID;
			    mdac_link_lock_st(pdp->pd_Status &= ~MDACPDS_PRESENT);
			}

			DebugPrint((0, "\tSrbStatus %x ScsiStatus %x SrbFlags %x\n",
				    srb->SrbStatus, srb->ScsiStatus, srb->SrbFlags));
			break;
		}

		case DACMDERR_SELECTION_TIMEOUT:
		case DACMDERR_RESET_TIMEOUT:
			DebugPrint((0,"mdac_send_scdb_intr: sts %x, c %x t %x l %x\n",
					 status,
					 srb->PathId,
					 srb->TargetId,
					 srb->Lun));
			mdac_link_lock_st(pdp->pd_Status &= ~MDACPDS_PRESENT);
			srb->SrbStatus = SRB_STATUS_SELECTION_TIMEOUT;
			break;
			
		case DCMDERR_DRIVERTIMEDOUT:
			DebugPrint((0, "DCDB: DRVRTOUT, Srb %I\n", srb));
			srb->SrbStatus = SRB_STATUS_TIMEOUT;
			break;
			
		default:
			DebugPrint((0,"mdsi: inv Req, sts %x, c %x t %x l %x\n",
					 status,
					 srb->PathId,
					 srb->TargetId,
					 srb->Lun));
			srb->SrbStatus = SRB_STATUS_INVALID_REQUEST;
			break;
	}

	mdac_free_req(rqp->rq_ctp, rqp);

	mdac_start_next_scdb(pdp);

	//
	// Complete request.
	//

	RequestCompleted(deviceExtension,
			 srb);

	return (0);
}


//
//jhr - For this function to work correctly it needs to be turned
//      into a macro.  Otherwise the returns will not give the
//		desired result in the macro that executes this code.
//
/* alloc mdac_req buffer, if not possible return ERR_NOMEM 
 * This function serves two purposes.						
 * 1)	If this is W2k and SRB is valid, carve a request	
 *		block and S/G list out of the SRB Extension.		
 *		If SRB is not valid, allocate a request block and	
 *		S/G list out of our local pool.							  
 * 2)	If is not W2k always allocate a request block and	
 *		S/G list out of our local pool.						*/
u32bits
ntmdac_alloc_req_ret(
mdac_ctldev_t MLXFAR *ctp,
mdac_req_t MLXFAR **rqpp,
PSCSI_REQUEST_BLOCK Srb,
u32bits rc
)
{
#ifdef MLX_NT 
	if (Srb)
	{
		mdac_zero(Srb->SrbExtension,sizeof(mdac_req_t));
		*rqpp = (mdac_req_t MLXFAR *)(Srb->SrbExtension);	
		mlx_kvtophyset((*rqpp)->rq_PhysAddr,ctp,*rqpp);
		(*rqpp)->rq_Next = NULL;
		
		/* Compute an offset into the SRB Extension for our S/G list, then 
		** compute the physical address of the S/G list, then compute the "max" dmasize. 
		*/

		(*rqpp)->rq_SGVAddr = (mdac_sglist_t MLXFAR *)&(*rqpp)->rq_SGList;
		mlx_kvtophyset((*rqpp)->rq_SGPAddr,ctp,(*rqpp)->rq_SGVAddr);
		(*rqpp)->rq_MaxSGLen = (ctp->cd_Status & MDACD_NEWCMDINTERFACE)? MDAC_MAXSGLISTSIZENEW : MDAC_MAXSGLISTSIZE;

		//jhr This is incorrect for NT but I am not changing it yet.

		(*rqpp)->rq_MaxDMASize = ((*rqpp)->rq_MaxSGLen & ~1) * MDAC_PAGESIZE;
		(*rqpp)->rq_OpFlags = MDAC_RQOP_FROM_SRB;
		(*rqpp)->rq_ctp = ctp; 
	        mdaczero((*rqpp)->rq_SGList,rq_sglist_s); 
		return 0;

	} else
	{
		//
		//jhr - No SRB so allocate the "normal" way.
		//
		mdac_alloc_req_ret_original(ctp,((mdac_req_t MLXFAR *)(*rqpp)),rc);
		return 0;

	}
#else
		mdac_alloc_req_ret_original(ctp,((mdac_req_t MLXFAR *)(*rqpp)),rc);
#endif

	return 0;
}

#ifdef OLD_CODE

u32bits MLXFAR
mdac_setupdma(
	mdac_req_t MLXFAR *rqp
)
{
	PSCSI_REQUEST_BLOCK Srb = rqp->rq_OSReqp;
	PUCHAR dataPointer =  rqp->rq_OSReqp->DataBuffer;
	ULONG sz = rqp->rq_OSReqp->DataTransferLength;
	mdac_sglist_t *sgp = rqp->rq_SGList;
	PDEVICE_EXTENSION deviceExtension = (PDEVICE_EXTENSION)rqp->rq_ctp->cd_deviceExtension;
	ULONG length;

	//
	// Build Scatter/Gather list.
	//

	for (rqp->rq_SGLen = 0; ; sgp++, rqp->rq_SGLen++)
	{
		//
		// Get Physical address and length of contiguous
		// physical buffer
		//

		sgp->sg_PhysAddr = ScsiPortConvertPhysicalAddressToUlong(
					ScsiPortGetPhysicalAddress(
						deviceExtension,
						Srb,
						dataPointer,
						&length));

		MLXSWAP(sgp->sg_PhysAddr);

		if (length > sz)
			length = sz;

		sgp->sg_DataSize = length;
		MLXSWAP(sgp->sg_DataSize);

		sz -= length;
		dataPointer += length;

		if (sz == 0)
			break;
	}

	if (rqp->rq_SGLen)
	{
		dcmdp->mb_Datap = rqp->rq_PhysAddr.bit31_0 + offsetof(mdac_req_t, rq_SGList);
		dcmdp->mb_Command |= DACMD_WITHSG;
		rqp->rq_SGLen++;
	} 
	else 
	{
		dcmdp->mb_Datap = sgp->sg_PhysAddr;
		dcmdp->mb_Command &= ~DACMD_WITHSG;
	}

	return (0);
}

//
// Build Scatter/Gather list.
//
u32bits MLXFAR
mdac_setupdma_big(
	mdac_req_t MLXFAR *rqp,
	s32bits sz
)
{
	PSCSI_REQUEST_BLOCK Srb = rqp->rq_OSReqp;
	mdac_sglist_t *sgp = rqp->rq_SGList;
	ULONG off;
	ULONG *Pages;

	DebugPrint((1,"Size %x dataOffset %x PageAddr %x\n",
	       sz,rqp->rq_DataOffset,Pages));
#ifdef  MLX_NT_ALPHA
	if (!Srb) {
	    sgp++;
	    goto laststage;
	}
#endif  /*MLX_NT_ALPHA*/
	rqp->rq_SGLen = 0;
	if (Srb) {
	    PDEVICE_EXTENSION deviceExtension = (PDEVICE_EXTENSION)rqp->rq_ctp->cd_deviceExtension;
	    PUCHAR dataPointer = (PUCHAR)(rqp->rq_OSReqp->DataBuffer) + rqp->rq_DataOffset;
	    for (;sz>0 ; sgp++, rqp->rq_SGLen++)
	    {
		    //
		    // Get Physical address and length of contiguous
		    // physical buffer
		    //
    
		    sgp->sg_PhysAddr = ScsiPortConvertPhysicalAddressToUlong(
					    ScsiPortGetPhysicalAddress(
						    deviceExtension,
						    Srb,
						    dataPointer,
						    &off));
    
		    MLXSWAP(sgp->sg_PhysAddr);
		    if (off > sz) off = sz;
		    sgp->sg_DataSize = off;
		    MLXSWAP(sgp->sg_DataSize);
		    sz -= off;
		    dataPointer += off;
	    }
    
	    dcmdp->mb_Datap = rqp->rq_PhysAddr.bit31_0 + offsetof(mdac_req_t, rq_SGList);
	    dcmdp->mb_Command |= DACMD_WITHSG;
	    return (0);
	}
	/* skip all entries belonging to offset */
	for (Pages = (ULONG *)rqp->rq_PageList, off=rqp->rq_DataOffset; off; off-=PAGE_SIZE,Pages++)
	{
		if (off >= PAGE_SIZE) continue; /* skip this one */
		sgp->sg_PhysAddr=(Pages[0] << PAGE_SHIFT)+off;
		MLXSWAP(sgp->sg_PhysAddr);
		sgp->sg_DataSize=(PAGE_SIZE-off)>sz?sz:PAGE_SIZE-off; sz-=sgp->sg_DataSize; MLXSWAP(sgp->sg_DataSize);

		if ( !sgp->sg_PhysAddr )
		{
		    DebugPrint((0,"sg_Physaddr-s %x length %x off %x\n",
				sgp->sg_PhysAddr,sgp->sg_DataSize,off));
		}

		rqp->rq_SGLen++; sgp++; Pages++;
		break;
	}

	for (; sz>0 ; sgp++,Pages++,rqp->rq_SGLen++)
	{
		sgp->sg_PhysAddr=(u32bits)(Pages[0] << PAGE_SHIFT ); MLXSWAP(sgp->sg_PhysAddr);
		sgp->sg_DataSize=
		 (PAGE_SIZE>sz)?sz:PAGE_SIZE; sz-=sgp->sg_DataSize; MLXSWAP(sgp->sg_DataSize);


		if (!sgp->sg_PhysAddr)
		{
		    DebugPrint((0,"sg_Physaddr %x length %x\n",
				sgp->sg_PhysAddr,sgp->sg_DataSize));
		}
	}
laststage:
	if (rqp->rq_SGLen == 1)
	{
	    dcmdp->mb_Datap = (--sgp)->sg_PhysAddr;
	    dcmdp->mb_Command &= ~DACMD_WITHSG;
	    return 0;
	}
	dcmdp->mb_Datap = rqp->rq_PhysAddr.bit31_0 + offsetof(mdac_req_t, rq_SGList);
	dcmdp->mb_Command |= DACMD_WITHSG;
	return 0;
}

#endif

u32bits MLXFAR
mdac_setupdma_32bits(
	mdac_req_t MLXFAR *rqp
)
{
	mdac_sglist_t *sgp;
	s32bits sz;
	ULONG off;
	ULONG *Pages;
	PSCSI_REQUEST_BLOCK Srb = rqp->rq_OSReqp;

	rqp->rq_DMAAddr = rqp->rq_SGPAddr;
	sgp = rqp->rq_SGVAddr;
	sz = mlx_min(rqp->rq_MaxDMASize, rqp->rq_ResdSize);
	rqp->rq_DMASize = 0;
	rqp->rq_SGLen = 0;

#ifdef  MLX_NT_ALPHA
	if (!Srb) {
	    sgp++;
	    goto laststage;
	}
#endif  /*MLX_NT_ALPHA*/

	if (!Srb)
	{

#ifdef  _WIN64
		return -1; //because code below is dependent on 4k page size
#else

		/* skip all entries belonging to offset */
		for (Pages = (ULONG *)rqp->rq_PageList, off=rqp->rq_DataOffset; off; off-=PAGE_SIZE,Pages++)
		{
			if (off >= PAGE_SIZE)
				continue; /* skip this one */
			sgp->sg_PhysAddr = (u32bits)(Pages[0] << PAGE_SHIFT)+off; MLXSWAP(sgp->sg_PhysAddr);
			sgp->sg_DataSize = mlx_min((PAGE_SIZE-off), (u32bits )sz);

			sz -= sgp->sg_DataSize;
			rqp->rq_DMASize += sgp->sg_DataSize;
			MLXSWAP(sgp->sg_DataSize);
			rqp->rq_SGLen++; sgp++; Pages++;

			break;
		}

		for (; (sz > 0) && (rqp->rq_SGLen < rqp->rq_MaxSGLen); sgp++,Pages++,rqp->rq_SGLen++)
		{
			sgp->sg_PhysAddr=(u32bits)(Pages[0] << PAGE_SHIFT ); MLXSWAP(sgp->sg_PhysAddr);
			sgp->sg_DataSize= mlx_min(sz, PAGE_SIZE);

			sz -= sgp->sg_DataSize;
			rqp->rq_DMASize += sgp->sg_DataSize;
			MLXSWAP(sgp->sg_DataSize);
		}
#endif // ndef _WIN64
	} else
	{

	    PDEVICE_EXTENSION deviceExtension = (PDEVICE_EXTENSION)rqp->rq_ctp->cd_deviceExtension;
	    PUCHAR dataPointer = (PUCHAR)(rqp->rq_OSReqp->DataBuffer) + rqp->rq_DataOffset;
	    for (; ((sz > 0) && (rqp->rq_SGLen < rqp->rq_MaxSGLen)) ; sgp++, rqp->rq_SGLen++)
	    {
		    //
		    // Get Physical address and length of contiguous
		    // physical buffer
		    //
    
		    sgp->sg_PhysAddr = ScsiPortConvertPhysicalAddressToUlong(
					    ScsiPortGetPhysicalAddress(
						    deviceExtension,
						    Srb,
						    dataPointer,
						    &off));

		    MLXSWAP(sgp->sg_PhysAddr);
		    if (off > (ULONG) sz)
				off = sz;
		    sgp->sg_DataSize = off;
		    rqp->rq_DMASize += sgp->sg_DataSize;
		    MLXSWAP(sgp->sg_DataSize);
		    sz -= off;
		    dataPointer += off;
             }

	}

	if (rqp->rq_SGLen == 1)
	{
	    rqp->rq_SGLen = 0;
	    rqp->rq_DMAAddr.bit31_0 = (--sgp)->sg_PhysAddr;
	    rqp->rq_DMASize = mlx_min(rqp->rq_ResdSize, rqp->rq_MaxDMASize);
	}

	return 0;
}

u32bits MLXFAR
mdac_setupdma_64bits(
	mdac_req_t MLXFAR *rqp
)
{
	PSCSI_REQUEST_BLOCK Srb = rqp->rq_OSReqp;
	mdac_sglist64b_t *sgp;
	s32bits sz;
	u32bits off;
    UINT_PTR *Pages;
	u64bits tmp;
	ULONGLONG longlongvar;

#ifdef  MLX_NT_ALPHA
	if (!Srb) {
	    sgp++;
	    goto laststage;
	}
#endif  /*MLX_NT_ALPHA*/

	rqp->rq_DMAAddr = rqp->rq_SGPAddr;
	sgp = (mdac_sglist64b_t MLXFAR *)rqp->rq_SGVAddr;
	sz = mlx_min(rqp->rq_MaxDMASize, rqp->rq_ResdSize);
	rqp->rq_DMASize = 0;
	rqp->rq_SGLen = 0;

	if( sgp->sg_DataSize.bit31_0 )  // Zero our S/G list memory if this is not the first pass.
	{
	    mdaczero( rqp->rq_SGVAddr, rqp->rq_MaxSGLen * (2 * sizeof(mdac_sglist_t)) ); //jhr 2*8=16
	}



	if (!Srb)
	    {

	//
	// Set SenseBuffer information
	//

	ncmdp->nc_SenseSize = 0;
	ncmdp->nc_Sensep.bit31_0 = 0;
	ncmdp->nc_Sensep.bit63_32 = 0;

	/* skip all entries belonging to offset */
	for (Pages = rqp->rq_PageList, off=rqp->rq_DataOffset; off; off-=PAGE_SIZE,Pages++)
	{

		if (off >= PAGE_SIZE)
			continue; /* skip this one */
		/*
		if (Pages[0] & 0xf00000)
			MdacInt3();
		*/
        tmp.bit31_0 = (u32bits)(Pages[0]);
#ifdef _WIN64
        tmp.bit63_32 = (u32bits)(Pages[0]>>32);
#else
		tmp.bit63_32 	= 0;
#endif
		longlongvar	= *((ULONGLONG *)&(tmp));
		*((ULONGLONG *)&(sgp->sg_PhysAddr)) = ((longlongvar << PAGE_SHIFT)+off);
		MLXSWAP(sgp->sg_PhysAddr);
		sgp->sg_DataSize.bit31_0 = (PAGE_SIZE-off)>(u32bits)sz?sz:PAGE_SIZE-off; sz-=sgp->sg_DataSize.bit31_0;
		rqp->rq_DMASize += sgp->sg_DataSize.bit31_0;
		MLXSWAP(sgp->sg_DataSize);
		rqp->rq_SGLen++; sgp++; Pages++;
		break;
	}

	for (; ((sz > 0) && (rqp->rq_SGLen < rqp->rq_MaxSGLen)); sgp++,Pages++,rqp->rq_SGLen++)
	{
		/*
		if (Pages[0] & 0xf00000)
			MdacInt3();
		*/
        tmp.bit31_0 = (u32bits)(Pages[0]);
#ifdef _WIN64
        tmp.bit63_32 = (u32bits)(Pages[0]>>32);
#else
		tmp.bit63_32 	= 0;
#endif
		longlongvar	= *((ULONGLONG *)&(tmp));
		*((ULONGLONG *)&(sgp->sg_PhysAddr)) = ((longlongvar << PAGE_SHIFT));
		MLXSWAP(sgp->sg_PhysAddr);
		sgp->sg_DataSize.bit31_0 = (PAGE_SIZE>sz)?sz:PAGE_SIZE; sz-=sgp->sg_DataSize.bit31_0;
		rqp->rq_DMASize += sgp->sg_DataSize.bit31_0;
		MLXSWAP(sgp->sg_DataSize);
	}
	} else
	{
	    PDEVICE_EXTENSION deviceExtension = (PDEVICE_EXTENSION)rqp->rq_ctp->cd_deviceExtension;
	    PUCHAR dataPointer = (PUCHAR)(rqp->rq_OSReqp->DataBuffer) + rqp->rq_DataOffset;

	    //
	    // Set SenseBuffer information
	    //

		*((SCSI_PHYSICAL_ADDRESS *)&(ncmdp->nc_Sensep))=
			(ScsiPortGetPhysicalAddress((PVOID)(rqp->rq_ctp->cd_deviceExtension),Srb,
			(PVOID)Srb->SenseInfoBuffer,&off));


	    ncmdp->nc_SenseSize = mlx_min(Srb->SenseInfoBufferLength,off);

	    for (; ((sz > 0) && (rqp->rq_SGLen < rqp->rq_MaxSGLen)); sgp++, rqp->rq_SGLen++)
	    {
		    //
		    // Get Physical address and length of contiguous
		    // physical buffer
		    //

			*((SCSI_PHYSICAL_ADDRESS *)&(sgp->sg_PhysAddr))=
				(ScsiPortGetPhysicalAddress((PVOID)(rqp->rq_ctp->cd_deviceExtension),Srb,
				(PVOID)dataPointer,&off));

		    MLXSWAP(sgp->sg_PhysAddr);
		    if (off > (ULONG) sz) 
				off = sz;
		    sgp->sg_DataSize.bit31_0 = off;
		    MLXSWAP(sgp->sg_DataSize);
		    rqp->rq_DMASize += off;
		    sz -= off;
		    dataPointer += off;
	    }
	}

	if (rqp->rq_SGLen == 1)
	{
	    rqp->rq_SGLen = 0;
	    rqp->rq_DMAAddr = (--sgp)->sg_PhysAddr;
	    rqp->rq_DMASize = mlx_min(rqp->rq_ResdSize, rqp->rq_MaxDMASize);
	}

	return 0;
}

#if defined(MLX_NT_ALPHA)

u32bits
MdacKvToPhys(ctp, vaddr)
mdac_ctldev_t MLXFAR *ctp;
mdac_mem_t MLXFAR *vaddr;
{
    u32bits vpage, paddr = 0;
    PMDAC_CTRL_INFO ctrlp;
    PMDAC_DSM_ADDR pDsm;

    if (!vaddr) return(0);
    if (!ctp) return(ScsiPortConvertPhysicalAddressToUlong(MmGetPhysicalAddress((PVOID)(vaddr))));
    ctrlp = MdacCtrlInfoPtr[ctp->cd_ControllerNo];
    if ((!ctrlp->DsmStack4k) && (!ctrlp->DsmStack8k)) return(0);
    vpage = (u32bits) vaddr & 0xFFFFF000;
    mdac_link_lock();
    pDsm = ctrlp->DsmStack4k;
    while (pDsm) {
	if ((pDsm->VAddr & 0xFFFFF000) == vpage) {
	    paddr = (pDsm->PAddr & 0xFFFFF000) + ((u32bits)vaddr & 0xFFF);
	    goto found_it;
	}
	pDsm = pDsm->Next;
    }
    vpage = (u32bits) vaddr & 0xFFFFE000;
    pDsm = ctrlp->DsmStack8k;
    while (pDsm) {
	if ((pDsm->VAddr & 0xFFFFE000) == vpage) {
	    paddr = (pDsm->PAddr & 0xFFFFE000) + ((u32bits)vaddr & 0x1FFF);
	    goto found_it;
	}
	pDsm = pDsm->Next;
    }
found_it:
    mdac_link_unlock();
    return(paddr);
}

/* Start of the Device Specific Memory alloc/free routines */
u32bits
mlx_allocdsm4kb(ctp)
mdac_ctldev_t MLXFAR *ctp;
{
    u32bits vaddr;
    PHYSICAL_ADDRESS physaddr;
    PMDAC_CTRL_INFO ctrlp;
    PMDAC_DSM_ADDR pDsm;

DebugPrint((GamDbgAlpha, "in: mlx_allocdsm4kb, ctp=0x%I\n", ctp));
    ctrlp = MdacCtrlInfoPtr[ctp->cd_ControllerNo];
    vaddr = (u32bits) HalAllocateCommonBuffer(ctrlp->AdapterObject,
	0x1000, &physaddr, FALSE);
    if ((PVOID)vaddr == NULL) return(0);
    mdac_link_lock();
    if (pDsm = ctrlp->DsmHeap4k) {
	ctrlp->DsmHeap4k = pDsm->Next;
	pDsm->Next = ctrlp->DsmStack4k;
	ctrlp->DsmStack4k = pDsm;
	pDsm->VAddr = vaddr;
	pDsm->PhysAddrNT = physaddr;
	pDsm->PAddr = ScsiPortConvertPhysicalAddressToUlong(physaddr);
    }
    else {
	HalFreeCommonBuffer(ctrlp->AdapterObject, 0x1000, physaddr, (PVOID)vaddr, FALSE);
	vaddr = 0;
    }
    mdac_link_unlock();
DebugPrint((GamDbgAlpha, "out: mlx_allocdsm4kb, vaddr=0x%I, paddr=0x%I\n", vaddr, pDsm->PAddr));
    return(vaddr);
}

u32bits
mlx_allocdsm8kb(ctp)
mdac_ctldev_t MLXFAR *ctp;
{
    u32bits vaddr;
    PHYSICAL_ADDRESS physaddr;
    PMDAC_CTRL_INFO ctrlp;
    PMDAC_DSM_ADDR pDsm;

DebugPrint((GamDbgAlpha, "in: mlx_allocdsm8kb, ctp=0x%I\n", ctp));
    ctrlp = MdacCtrlInfoPtr[ctp->cd_ControllerNo];
    vaddr = (u32bits) HalAllocateCommonBuffer(ctrlp->AdapterObject,
	0x2000, &physaddr, FALSE);
    if ((PVOID)vaddr == NULL) return(0);
    mdac_link_lock();
    if (pDsm = ctrlp->DsmHeap8k) {
	ctrlp->DsmHeap8k = pDsm->Next;
	pDsm->Next = ctrlp->DsmStack8k;
	ctrlp->DsmStack8k = pDsm;
	pDsm->VAddr = vaddr;
	pDsm->PhysAddrNT = physaddr;
	pDsm->PAddr = ScsiPortConvertPhysicalAddressToUlong(physaddr);
DebugPrint((GamDbgAlpha, "success: mlx_allocdsm8kb, vaddr=0x%I, paddr=0x%I\n", vaddr, pDsm->PAddr));
    }
    else {
	HalFreeCommonBuffer(ctrlp->AdapterObject, 0x2000, physaddr, (PVOID)vaddr, FALSE);
DebugPrint((0, "fail: mlx_allocdsm8kb\n"));
	vaddr = 0;
    }
    mdac_link_unlock();
    return(vaddr);
}

void
mlx_freedsm4kb(ctp, mp)
mdac_ctldev_t MLXFAR *ctp;
mdac_mem_t MLXFAR *mp;
{
    MDAC_IRQL_VARS;
    PMDAC_CTRL_INFO ctrlp;
    PMDAC_DSM_ADDR pDsm, pDsmPrev;
    PHYSICAL_ADDRESS physAddrNT;

DebugPrint((GamDbgAlpha, "in: mlx_freedsm4kb, ctp=0x%I, mp=0x%I\n", ctp, mp));
    if (!mp || !ctp) return;
    ctrlp = MdacCtrlInfoPtr[ctp->cd_ControllerNo];
    if (!ctrlp->DsmStack4k) return;
    mdac_link_lock();
    pDsmPrev = pDsm = ctrlp->DsmStack4k;
    while (pDsm) {
	if (pDsm->VAddr == mp) {
	    pDsm->VAddr = 0;
	    physAddrNT = pDsm->PhysAddrNT;
	    break;
	}
	pDsmPrev = pDsm;
	pDsm = pDsm->Next;
    }
    if (pDsm == pDsmPrev) ctrlp->DsmStack4k = (pDsm ? pDsm->Next : NULL);
    else pDsmPrev->Next = pDsm->Next;
    pDsm->Next = ctrlp->DsmHeap4k;
    ctrlp->DsmHeap4k = pDsm;
    mdac_link_unlock();
DebugPrint((0, "Halfree(4k): physaddr=0x%I, vaddr=0x%I\n", physAddrNT, mp));
    MDAC_LOWER_IRQL();
    HalFreeCommonBuffer(ctrlp->AdapterObject, 0x1000, physAddrNT, mp, FALSE);
    MDAC_RAISE_IRQL();
DebugPrint((GamDbgAlpha, "out: mlx_freedsm4kb\n"));
}

void
mlx_freedsm8kb(ctp, mp)
mdac_ctldev_t MLXFAR *ctp;
mdac_mem_t MLXFAR *mp;
{
    MDAC_IRQL_VARS;
    PMDAC_CTRL_INFO ctrlp;
    PMDAC_DSM_ADDR pDsm, pDsmPrev;
    PHYSICAL_ADDRESS physAddrNT;

DebugPrint((GamDbgAlpha, "in: mlx_freedsm8kb, ctp=0x%I, mp=0x%I\n", ctp, mp));
    if (!mp || !ctp) return;
    ctrlp = MdacCtrlInfoPtr[ctp->cd_ControllerNo];
    if (!ctrlp->DsmStack8k) return;
    mdac_link_lock();
    pDsmPrev = pDsm = ctrlp->DsmStack8k;
    while (pDsm) {
	if (pDsm->VAddr == mp) {
	    pDsm->VAddr = 0;
	    physAddrNT = pDsm->PhysAddrNT;
	    break;
	}
	pDsmPrev = pDsm;
	pDsm = pDsm->Next;
    }
    if (pDsm == pDsmPrev) ctrlp->DsmStack8k = (pDsm ? pDsm->Next : NULL);
    else pDsmPrev->Next = pDsm->Next;
    pDsm->Next = ctrlp->DsmHeap8k;
    ctrlp->DsmHeap8k = pDsm;
    mdac_link_unlock();
DebugPrint((0, "Halfree(8k): physaddr=0x%I, vaddr=0x%I\n", physAddrNT, mp));
    MDAC_LOWER_IRQL();
    HalFreeCommonBuffer(ctrlp->AdapterObject, 0x2000, physAddrNT, mp, FALSE);
    MDAC_RAISE_IRQL();
DebugPrint((GamDbgAlpha, "out: mlx_freedsm8kb\n"));
}

/* End the Device Specific Memory alloc/free routines */
#endif  /*MLX_NT_ALPHA*/

/*==========================DATAREL STARTS==================================*/
/* datarel entry with rqp has 4 KB buffer. After req buffer, os buffer starts.
** After OS buffer, Address list (0x600 bytes).
** After Address list, length list (0x600 bytes).
*/
#define mdac_datarel_send_cmd_os(rqp)  0
     

u32bits MLXFAR
mdac_datarel_rwtestintr_os(osrqp)
OSReq_t MLXFAR *osrqp;
{
	return 0;
}

/* set SG List sizes, and first memory address only */
u32bits MLXFAR
mdac_datarel_setsgsize_os(rqp)
mdac_req_t MLXFAR *rqp;
{
	return 0;
}

u32bits MLXFAR
mdac_datarel_setrwcmd_os(rqp)
mdac_req_t MLXFAR *rqp;
{
	return 0;
}


#if defined(_WIN64) || defined(SCSIPORT_COMPLIANT)

u32bits MLXFAR
mdac_simple_lock (lock_variable)
mdac_lock_t MLXFAR *lock_variable;
{
    if (mdac_spinlockfunc!=0)
        mdac_spinlockfunc(lock_variable);
//    else
//   	 mdac_simple_lock_stub(lock_variable);
    return 0;
}

u32bits MLXFAR
mdac_simple_unlock (lock_variable)
mdac_lock_t MLXFAR *lock_variable;
{
    if (mdac_unlockfunc!=0)
        mdac_unlockfunc(lock_variable);
//    else
//        mdac_simple_unlock_stub(lock_variable);
    return 0;
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\port\scsi\miniport\mylex\dac2w2k\io\mlxprint.c ===
/**************************************************************************
 *                COPYRIGHT (C) Mylex Corporation 1992-1998               *
 *                                                                        *
 * This software is furnished under a license and may be used and copied  * 
 * only in accordance with the terms and conditions of such license and   * 
 * with inclusion of the above copyright notice. This software or any     * 
 * other copies thereof may not be provided or otherwise made available   * 
 * to any other person. No title to, nor ownership of the software is     * 
 * hereby transferred.                                                    *
 *                                                                        *
 * The information in this software is subject to change without notices  *
 * and should not be construed as a commitment by Mylex Corporation       *
 *                                                                        *
 **************************************************************************/

#define	spr_va_type	u32bits
#define spr_fieldlen(type) \
	((sizeof(type) + sizeof(spr_va_type) - 1) & ~(sizeof(spr_va_type) - 1))

#define	spr_va_arg(list, type) \
	   (*((type *)((list += spr_fieldlen(type)) - spr_fieldlen(type))))

#define	spr_put(s,n) mlxcopy(s, sp, n), sp+=n

#define SPR_SNLEN	5 /* Length of string used when printing a NaN */

#define	SPR_HIBITL	(1UL << ((sizeof(long)*8) - 1))
#define	SPR_HIBITI	(1UL << ((sizeof(u32bits)*8) - 1))
#define	SPR_MAXINT	(~SPR_HIBITI)

#define	SPR_MAXDIGS	11 /* Maximum number of digits in any integer representation */
#define	SPR_MAXECVT	23 /* Maximum total number of digits in E format */
#define SPR_MAXFCVT	60 /* Maximum number of digits after decimal point in F format */
#define SPR_MAXFSIG	SPR_MAXECVT /* Maximum significant figures in a floating-point number */
#define SPR_MAXESIZ	7 /* Maximum number of characters in an exponent */
#define	SPR_MAXEXP	4934 /* Maximum (positive) exponent */

/* bit positions for flags used in mlx_sprintf */
#define	SPR_LENGTH	0x0001	/* l */
#define	SPR_FPLUS	0x0002	/* + */
#define	SPR_FMINUS	0x0004	/* - */
#define	SPR_FBLANK	0x0008	/* blank */
#define	SPR_FSHARP	0x0010	/* # */
#define	SPR_PADZERO	0x0020	/* padding zeroes requested via '0' */
#define	SPR_DOTSEEN	0x0040	/* dot appeared in format specification */
#define	SPR_SUFFIX	0x0080	/* a suffix is to appear in the output */
#define	SPR_RZERO	0x0100	/* there will be trailing zeros in output */
#define	SPR_LZERO	0x0200	/* there will be leading zeroes in output */
#define	SPR_SHORT	0x0400	/* h */
#define	SPR_LONGD	0x0800	/* L */
#define	SPR_FQUOTE	0x1000	/* single quote */

s08bits	mlxspr_blanks[] = "                    ";
s08bits	mlxspr_zeroes[] = "00000000000000000000";
s08bits	mlxspr_uphex[] = "0123456789ABCDEF";
s08bits	mlxspr_lohex[] = "0123456789abcdef";
	static const char  lc_nan[] = "nan0x";
	static const char  uc_nan[] = "NAN0X";
	static const char  lc_inf[] = "inf";
	static const char  uc_inf[] = "INF";

/* C-Library routines for floating conversion */
#ifdef	KAILASH
extern s08bits MLXFAR *fcvt(), MLXFAR *ecvt(), MLXFAR *fcvtl(), MLXFAR *ecvtl();
#endif

/* Positional Parameter information */
#define SPR_MAXARGS	30 /* max. number of args for fast positional paramters */

#define	spr_va_list_t	s08bits	MLXFAR *
/* spr_stva_list is used to subvert C's restriction that a variable with array
** type can not appear on the left hand side of an assignment operator. By
** putting the array inside a structure, the functionality of assigning to the
** whole array through a simple assignment is achieved..
*/
typedef struct spr_stva_list
{
	spr_va_list_t	ap;
} spr_stva_list_t;

#ifdef	__MLX_STDC__
extern	u32bits	MLXFAR	mlx_strspn(u08bits MLXFAR *, u08bits MLXFAR *);
extern	s32bits	MLXFAR	mlx_str232bits(u08bits MLXFAR*, u08bits	MLXFAR**, s32bits);
extern	u32bits	MLXFAR	mlx_lowdigit(long MLXFAR *);
extern	u32bits	MLXFAR	mlx_printest(void);
extern	u08bits	MLXFAR * MLXFAR mlx_sprintf(u08bits MLXFAR*, s08bits MLXFAR*, ...);
extern	void	MLXFAR	mlxspr_mkarglist(s08bits MLXFAR*, u08bits MLXFAR*, u08bits MLXFAR**);
extern	void	MLXFAR	mlxspr_getarg(s08bits MLXFAR*, u08bits MLXFAR**, s32bits);
#endif	/* __MLX_STDC__ */

u32bits MLXFAR mlx_strlen(u08bits  MLXFAR *);
u08bits MLXFAR * MLXFAR mlx_strcpy(u08bits  MLXFAR *, u08bits  MLXFAR *);
u08bits MLXFAR * MLXFAR mlx_strncpy(u08bits MLXFAR *,u08bits MLXFAR *,size_t);
u08bits MLXFAR * MLXFAR mlx_strchr(u08bits  MLXFAR *, u08bits );
u08bits MLXFAR * MLXFAR mlx_strrchr(u08bits  MLXFAR *, u08bits );
s32bits MLXFAR mlx_strcmp (s08bits  MLXFAR *, s08bits  MLXFAR *);
s32bits MLXFAR mlx_strncmp (s08bits  MLXFAR *, s08bits  MLXFAR *,int );
u08bits MLXFAR * MLXFAR mlx_strcat(u08bits MLXFAR *, u08bits MLXFAR *);
u08bits MLXFAR * MLXFAR mlx_strncat(u08bits MLXFAR *,u08bits MLXFAR *,int);
u08bits MLXFAR * MLXFAR mlx_strpbrk(u08bits  MLXFAR *, u08bits MLXFAR *); 

extern int _mlxerrno;
/* Values are developed in this buffer */
s08bits	mlxspr_buf[mlx_max(SPR_MAXDIGS, 1+mlx_max(SPR_MAXFCVT+SPR_MAXEXP, SPR_MAXECVT))];

/* this buf is only used for single quote grouping creation */
s08bits spr_workbuf[mlx_max(SPR_MAXDIGS, 1+mlx_max(SPR_MAXFCVT+SPR_MAXEXP, SPR_MAXECVT))];

/* Return the number of characters in the maximum leading segment of string
** which consists solely of characters from charset.
*/
u32bits	MLXFAR
mlx_strspn(sp, csp)
u08bits	MLXFAR *sp;	/* string address */
u08bits	MLXFAR *csp;	/* character set address */
{
	u08bits	MLXFAR *savesp = sp;
	u08bits	MLXFAR *savecsp = csp;
	for(; *sp; sp++)
	{
		for(csp = savecsp; *csp && (*csp != *sp); csp++);
		if(*csp == 0) break;
	}
	return (sp-savesp);
}

#define	MLX_MAXBASE	('z' - 'a' + 1 + 10)
s32bits	MLXFAR
mlx_str232bits(sp, np, base)
u08bits	MLXFAR*	sp;
u08bits	MLXFAR**np;
s32bits	base;
{
	s32bits val, c, multmin, limit;
	s32bits	cv, neg = 0;
	s08bits	MLXFAR**cp = np;

	if (cp) *cp = sp; /* in case no number is formed */
	if ((base > MLX_MAXBASE) || (base == 1))
	{
		_mlxerrno = MLXERR_INVAL;
		return (0); /* base is invalid -- should be a fatal error */
	}
	if (!mlx_alnum(c = *sp))
	{
		while (mlx_space(c)) c = *++sp;
		switch (c)
		{
		case '-': neg++; /* FALLTHROUGH */
		case '+': c = *++sp;
		}
	}
	if (!base)
		if (c != '0') base = 10;
		else if (sp[1] == 'x' || sp[1] == 'X') base = 16;
		else base = 8;
	if (!mlx_alnum(c) || (cv=mlx_digit(c))>=base) return 0; /* no number formed */
	if ((base==16) && (c=='0') && (sp[1]=='x') || (sp[1]=='X') && mlx_hex(sp[2]))
		c = *(sp+=2); /* skip over leading "0x" or "0X" */

	/* this code assumes that abs(S32BITS_MIN) >= abs(S32BITS_MAX) */
	limit  = (neg)? S32BITS_MIN : -S32BITS_MAX;
	multmin = limit / base;
	val = -mlx_digit(c);
	for (c=*++sp; mlx_alnum(c) && ((cv = mlx_digit(c))<base); val-=cv, c=*++sp)
	{	/* accumulate neg avoids surprises near S32BITS_MAX */
		if (val < multmin) goto overflow;
		val *= base;
		if (val < (limit + cv)) goto overflow;
	}
	if (cp) *cp = sp;
	return neg? val : -val;

overflow:
	for (c=*++sp; mlx_alnum(c) && (cv = mlx_digit(c)) < base; (c = *++sp));
	if (cp) *cp = sp;
	_mlxerrno = MLXERR_BIGDATA;
	return neg? S32BITS_MIN : S32BITS_MAX;
}

/* This function computes the decimal low-order digit of the number pointed to
** by valp, and returns this digit after dividing *valp by ten.  This function
** is called ONLY to compute the low-order digit of a long whose high-order
** bit is set.
*/
u32bits	MLXFAR
mlx_lowdigit(valp)
long MLXFAR *valp;
{
	s32bits lowbit = *valp & 1;
	long value = (*valp >> 1) & ~SPR_HIBITL;
	*valp = value / 5;
	return 	value % 5 * 2 + lowbit + '0';
}

u08bits	MLXFAR*
mlx_sprintf(sp, fmtp, val0)
u08bits	MLXFAR	*sp;
s08bits	MLXFAR	*fmtp;
u32bits	val0;
{
	u08bits	fcode;		/* Format code */
	s08bits	MLXFAR *ssp=sp;	/* save the buffer address */
	s08bits	MLXFAR *prefixp;/* Pointer to sign, "0x", "0X", or empty */
	s08bits	MLXFAR *suffixp;/* Exponent or empty */

	s32bits	width, prec;	/* Field width and precision */
	long	val;		/* The value being converted, if integer */
	long	qval;		/* temp variable */
	double	dval;		/* The value being converted, if real */
	long double ldval;	/* The value being converted, if long double */
	s32bits	neg_in=0;	/* Flag for negative infinity or NaN */
	s32bits	ngrp;		/* number of digits to be put into current group */
	s08bits	MLXFAR	*tab;	/* Pointer to a translate table for digits of whatever radix */
	s08bits	MLXFAR *scp, MLXFAR *ecp; /* Starting and ending points for value to be printed */

	s32bits	kinx, knum, lradix, mradix; /* Work variables */
	s08bits	expbuf[SPR_MAXESIZ+1]; /* Buffer to create exponent */
	s32bits	count = 0; /* This variable counts output characters. */
	s32bits	lzero, rzero; /* Number of padding zeroes required on the left and right */

	/* Flags - bit positions defined by LENGTH, FPLUS, FMINUS, FBLANK, and
	** FSHARP are set if corresponding character is in format Bit position
	** defined by PADZERO means extra space in the field should be padded
	** with leading zeroes rather than with blanks
	*/
	u32bits	flags;		/* format flag values */
	s32bits	suffixlength;	/* Length of prefix and of suffix */
	s32bits	otherlength;	/* Combined length of leading zeroes, trailing zeroes, and suffix */
	s32bits	decpt, sign;	/* Output values from fcvt and ecvt */

	/* Variables used to flag an infinities and nans, resp. Nan_flg is
	** used with two purposes: to flag a NaN and as the length of the
	** string ``NAN0X'' (``nan0x'')
	*/
	s32bits	inf_nan = 0, NaN_flg = 0 ;

	s08bits	MLXFAR	*SNAN; /* Pointer to string "NAN0X" or "nan0x" */

	/* variables for positional parameters */
	s32bits	fpos = 1;	/* 1 if first positional parameter */
	s08bits	*sfmtp = fmtp;	/* save the beginning of the format */
	u08bits	MLXFAR *argsp;	/* used to step through the argument list */
	u08bits	MLXFAR *sargsp;	/* used to save the start of the argument list */
	u08bits	MLXFAR *bargsp;	/* used to restore args if positional width or precision */

	/* array giving the appropriate values for va_arg() to retrieve the
	** corresponding argument:	
	** arglist[0] is the first argument
	** arglist[1] is the second argument, etc.
	*/
	u08bits	MLXFAR *arglist[SPR_MAXARGS];

	s32bits	starflg = 0;		/* set to 1 if * format specifier seen */
	/* Initialize argsp and sargsp to the start of the argument list. */
	argsp = (u08bits MLXFAR *)&fmtp;
	spr_va_arg(argsp, u08bits MLXFAR *);	/* adjust to first parameter */
	sargsp = argsp;

	/*
	** The main loop -- this loop goes through one iteration
	** for each string of ordinary characters or format specification.
	**/
main_loop:
	for (fcode=*fmtp; fcode && (fcode!='%'); fmtp++, sp++, fcode=*fmtp)
		*sp = fcode;
	if (!fcode)
	{	/* end of format; return */
		*sp = 0;
		return ssp;
	}

	/*
	** % has been found. The following switch is used to parse the format
	** specification and to perform the operation specified by the format
	** letter.  The program repeatedly goes back to this switch until the
	** format letter is encountered.
	*/
	width=0; otherlength=0; suffixlength=0; flags=0; prefixp=NULL;
	fmtp++;

par_loop:	/* parameter loop */
	switch (fcode = *fmtp++)
	{
	case '-':
		flags |= SPR_FMINUS;
		flags &= ~SPR_PADZERO; /* ignore 0 flag */
		goto par_loop;
	case '+': flags |= SPR_FPLUS;			goto par_loop;
	case ' ': flags |= SPR_FBLANK;			goto par_loop;
	case '#': flags |= SPR_FSHARP;			goto par_loop;
	case '\'': flags |= SPR_FQUOTE;			goto par_loop;

	/* Scan the field width and precision */
	case '.': flags |= SPR_DOTSEEN; prec = 0;	goto par_loop;
	case '*':
		if (mlx_numeric(*fmtp))
		{
			starflg = 1;
			bargsp = argsp;
			goto par_loop;
		}
		if (!(flags & SPR_DOTSEEN))
		{
			width = spr_va_arg(argsp, u32bits);
			if (width >= 0) goto par_loop;
			width = -width;
			flags ^= SPR_FMINUS;
			goto par_loop;
		}
		prec = spr_va_arg(argsp, u32bits);
		if (prec >= 0) goto par_loop;
		prec = 0;
		flags &= ~SPR_DOTSEEN;
		goto par_loop;

	case '$':
	{
		s32bits	position;
		u08bits	MLXFAR *targsp;
		if (fpos)
		{
			mlxspr_mkarglist(sfmtp, sargsp, arglist);
			fpos = 0;
		}
		if (flags & SPR_DOTSEEN)
			position = prec, prec = 0;
		else
			position = width, width = 0;
		if (position <= 0)
		{	/* illegal position */
			fmtp--;
			goto main_loop;
		}
		if (position <= SPR_MAXARGS)
			targsp = arglist[position - 1];
		else
		{
			targsp = arglist[SPR_MAXARGS - 1];
			mlxspr_getarg(sfmtp, &targsp, position);
		}
		if (!starflg) argsp = targsp;
		else
		{
			starflg = 0;
			argsp = bargsp;
			if (flags & SPR_DOTSEEN)
			{
				if ((prec = spr_va_arg(targsp, u32bits)) < 0)
					prec = 0, flags &= ~SPR_DOTSEEN;
			} else
			{
				if ((width=spr_va_arg(targsp,u32bits)) < 0)
					width = -width, flags ^= SPR_FMINUS;
			}
		}
		goto par_loop;
	}

	case '0': /* leading zero in width means pad with leading zeros */
		if (!(flags & (SPR_DOTSEEN | SPR_FMINUS))) flags |= SPR_PADZERO;
	case '1':
	case '2':
	case '3':
	case '4':
	case '5':
	case '6':
	case '7':
	case '8':
	case '9':
		for (kinx=fcode-'0'; mlx_numeric(fcode=*fmtp); fmtp++)
			kinx = (kinx * 10) + (fcode - '0');
		if (flags & SPR_DOTSEEN) prec = kinx;
		else width = kinx;
		goto par_loop;

	/* Scan the length modifier */
	case 'l': flags |= SPR_LENGTH;	goto par_loop; 
	case 'h': flags |= SPR_SHORT;	goto par_loop; 
	case 'L': flags |= SPR_LONGD;	goto par_loop; 

	/*
	** The character addressed by format must be the format letter -- there
	** is nothing left for it to be. The status of the +, -, #, and blank
	** flags are reflected in the variable "flags".  "width" and "prec"
	** contain numbers corresponding to the digit strings before and after
	** the decimal point, respectively. If there was no decimal point, then
	** flags & SPR_DOTSEEN is false and the value of prec is meaningless.
	** The following switch cases set things up for printing.  What
	** ultimately gets printed will be padding blanks, a prefix, left
	** padding zeroes, a value, right padding zeroes, a suffix, and more
	** padding blanks.  Padding blanks will not appear simultaneously on
	** both the left and the right.  Each case in this switch will compute
	** the value, and leave in several variables the information necessary
	** to construct what is to be printed.  
	**
	** The prefix is a sign, a blank, "0x", "0X", or null, and is addressed
	** by "prefixp".
	**
	** The suffix is either null or an exponent, and is addressed by
	** "suffixp". If there is a suffix, the flags bit SUFFIX will be set.
	**
	** The value to be printed starts at "scp" and continues up to and not
	** including "ecp".
	**
	** "lzero" and "rzero" will contain the number of padding zeroes
	** required on the left and right, respectively. The flags bits
	** SPR_LZERO and SPR_RZERO tell whether padding zeros are required.
	**
	** The number of padding blanks, and whether they go on the left or the
	** right, will be computed on exit from the switch.
	*/

	/*
	** decimal fixed point representations
	**
	** SPR_HIBITL is 100...000 binary, and is equal to the maximum negative
	** number. We assume a 2's complement machine
	*/
	case 'i':
	case 'd':
		/* Fetch the argument to be printed */
		val = (flags & SPR_LENGTH)? spr_va_arg(argsp, long) : spr_va_arg(argsp, u32bits);

		if (flags & SPR_SHORT) val = (short)val;
		if ((flags & SPR_PADZERO) && (flags & SPR_DOTSEEN))
			flags &= ~SPR_PADZERO; /* ignore 0 flag */
		ecp = scp = mlxspr_buf+SPR_MAXDIGS; /* Set buffer pointer to last digit */
		/* If signed conversion, make sign */
		if (val < 0)
		{
			prefixp = "-";
			/* Negate, checking in advance for possible overflow. */
			if (val != SPR_HIBITL) val = -val;
			else     /* number is -HIBITL; convert last digit now and get positive number */
				*--scp = mlx_lowdigit(&val);
		} else if (flags & SPR_FPLUS) prefixp = "+";
		else if (flags & SPR_FBLANK) prefixp = " ";

decimal:
		qval = val;
		if (qval <= 9)
		{
			if (qval || !(flags & SPR_DOTSEEN)) *--scp = qval + '0';
		} else
		{
			do {
				kinx = qval;
				qval /= 10;
				*--scp = kinx - qval * 10 + '0';
			} while (qval > 9);
			*--scp = qval + '0';
		}
		/* Calculate minimum padding zero requirement */
		if ((flags & SPR_DOTSEEN) && ((kinx=prec - (ecp - scp)) > 0))
			otherlength = lzero = kinx, flags |= SPR_LZERO;
		break;

	case 'u':	/* Fetch the argument to be printed */
		val = (flags & SPR_LENGTH)? spr_va_arg(argsp, long) : spr_va_arg(argsp, u32bits);
		if (flags & SPR_SHORT) val = (unsigned short)val;
		if ((flags & SPR_PADZERO) && (flags & SPR_DOTSEEN))
			flags &= ~SPR_PADZERO; /* ignore 0 flag */
		ecp = scp = mlxspr_buf+SPR_MAXDIGS; /* Set buffer pointer to last digit */
		if (val & SPR_HIBITL) *--scp = mlx_lowdigit(&val);
		goto decimal;

	/*
	** non-decimal fixed point representations for radix equal to a power
	** of two "mradix" is one less than the radix for the conversion.
	** "lradix" is one less than the base 2 log of the radix for the
	** conversion. Conversion is unsigned. HIBITL is 100...000 binary, and
	** is equal to the maximum negative number. We assume a 2's complement
	** machine
	*/
	case 'o': mradix = 7; lradix = 2; goto fixed;
	case 'X':
	case 'x':
	case 'p':
		mradix = 15; lradix = 3;
fixed:
		flags &= ~SPR_FQUOTE;
		/* Fetch the argument to be printed */
		val = (flags & SPR_LENGTH)? spr_va_arg(argsp, long) : spr_va_arg(argsp, u32bits);
		if (flags & SPR_SHORT) val = (u16bits)val;
		if ((flags & SPR_PADZERO) && (flags & SPR_DOTSEEN))
			flags &= ~SPR_PADZERO; /* ignore 0 flag */
		tab = (fcode=='X') ? mlxspr_uphex : mlxspr_lohex; /* Set translate table for digits */
put_pc:		/* Entry point when printing a double which is a NaN Develop the digits of the value */
		ecp = scp = mlxspr_buf+SPR_MAXDIGS; /* Set buffer pointer to last digit */
		qval = val;
		if (qval == 0)
		{
			if (!(flags & SPR_DOTSEEN))
				otherlength = lzero = 1, flags |= SPR_LZERO;
		} else
		do {
			*--scp = tab[qval & mradix];
			qval = ((qval >> 1) & ~SPR_HIBITL) >> lradix;
		} while (qval);

		/* Calculate minimum padding zero requirement */
		if ((flags & SPR_DOTSEEN) && ((kinx = prec - (ecp - scp)) > 0))
			otherlength = lzero = kinx, flags |= SPR_LZERO;

		/* Handle the # flag */
		if ((flags & SPR_FSHARP) && val)
		switch (fcode)
		{
		case 'o':
			if (!(flags & SPR_LZERO))
				otherlength=lzero=1, flags |= SPR_LZERO;
			break;
		case 'x': prefixp = "0x"; break;
		case 'X': prefixp = "0X"; break;
		}
		break;

#ifdef	KAILASH
		/*
		** E-format.  The general strategy here is fairly easy: we take
		** what ecvt gives us and re-format it.
		*/
		case 'E':
		case 'e':

			flags &= ~FQUOTE;
			if(flags & LONGD) {	/* long double	*/
				/* Establish default precision */
				if (!(flags & DOTSEEN))
					prec = 6;

				/* Fetch the value */
				ldval = spr_va_arg(argsp, long double);

				/* Check for NaNs and Infinities */
				if (IsNANorINFLD(ldval))  {
					if (IsINFLD(ldval)) {
						if (IsNegNANLD(ldval)) 
							neg_in = 1;
						inf_nan = 1;
						bp = (char *)((fcode == 'E') ? 
							uc_inf : lc_inf);
						p = bp + 3;
						break;
					}
					else {
						if (IsNegNANLD(ldval)) 
							neg_in = 1;
						inf_nan = 1;
						val = GETNaNPCLD(ldval); 
						NaN_flg = SPR_SNLEN;
						mradix = 15;
						lradix = 3;
						if (fcode == 'E') {
							SNAN = uc_nan;
							tab =  uc_digs;
						}
						else {
							SNAN = lc_nan;
							tab = lc_digs;
						}
						goto put_pc;
					}
				}
				/* Develop the mantissa */
				bp = ecvtl(ldval, min(prec + 1, MAXECVT), 
					&decpt, &sign);
			}
			else {	/* "regular" double	*/
				/* Establish default precision */
				if (!(flags & DOTSEEN))
					prec = 6;

				/* Fetch the value */
				dval = spr_va_arg(argsp, double);

				/* Check for NaNs and Infinities */
				if (IsNANorINF(dval))  {
					if (IsINF(dval)) {
						if (IsNegNAN(dval)) 
							neg_in = 1;
						inf_nan = 1;
						bp = (char *)((fcode == 'E') ? 
							uc_inf : lc_inf);
						p = bp + 3;
						break;
					}
					else {
						if (IsNegNAN(dval)) 
							neg_in = 1;
						inf_nan = 1;
						val = GETNaNPC(dval); 
						NaN_flg = SPR_SNLEN;
						mradix = 15;
						lradix = 3;
						if (fcode == 'E') {
							SNAN = uc_nan;
							tab =  uc_digs;
						}
						else {
							SNAN = lc_nan;
							tab = lc_digs;
						}
						goto put_pc;
					}
				}
				/* Develop the mantissa */
				bp = ecvt(dval, min(prec + 1, MAXECVT), 
					&decpt, &sign);
			}

			/* Determine the prefix */
		e_merge:
			if (sign) prefixp = "-";
			else if (flags & SPR_FPLUS) prefixp = "+";
			else if (flags & FBLANK) prefixp = " ";

			/* Place the first digit in the buffer*/
			p = &mlxspr_buf[0];
			*p++ = (*bp != '\0') ? *bp++ : '0';

			/* Put in a decimal point if needed */
			if (prec != 0 || (flags & FSHARP))
				*p++ = _numeric[0];

			/* Create the rest of the mantissa */
			{ register rz = prec;
				for ( ; rz > 0 && *bp != '\0'; --rz)
					*p++ = *bp++;
				if (rz > 0) {
					otherlength = rzero = rz;
					flags |= RZERO;
				}
			}

			bp = &mlxspr_buf[0];

			/* Create the exponent */
			*(suffix = &expbuf[MAXESIZ]) = '\0';

/*LONG DOUBLE*/		if(((flags & LONGD) /*&& ldval != 0*/) 
			     || (dval != 0)) {
				register int nn = decpt - 1;
				if (nn < 0)
				    nn = -nn;
				for ( ; nn > 9; nn /= 10)
					*--suffixp = todigit(nn % 10);
				*--suffixp = todigit(nn);
			}

			/* Prepend leading zeroes to the exponent */
			while (suffixp > &expbuf[MAXESIZ - 2])
				*--suffixp = '0';

			/* Put in the exponent sign */
			if(flags & LONGD)
/*LONG DOUBLE*/			*--suffixp=(decpt > 0 /*|| ldval == 0*/) ? '+' : '-';
			else
				*--suffixp=(decpt > 0 || dval == 0) ? '+' : '-';

			/* Put in the e */
			*--suffixp = isupper(fcode) ? 'E'  : 'e';

			/* compute size of suffix */
			otherlength += (suffixlength = &expbuf[MAXESIZ] - suffixp);
			flags |= SUFFIX;

			break;

		case 'f':
			/*
			 * F-format floating point.  This is a
			 * good deal less simple than E-format.
			 * The overall strategy will be to call
			 * fcvt, reformat its result into buf,
			 * and calculate how many trailing
			 * zeroes will be required.  There will
			 * never be any leading zeroes needed.
			 */

			if(flags & LONGD) {	/* dealing with long double */
				/* Establish default precision */
				if (!(flags & DOTSEEN))
					prec = 6;

				/* Fetch the value */
				ldval = spr_va_arg(argsp, long double);
	
       		                /* Check for NaNs and Infinities  */
				if (IsNANorINFLD(ldval)) {
					if (IsINFLD(ldval)) {
						if (IsNegNANLD(ldval))
							neg_in = 1;
						inf_nan = 1;
						bp = (char *)lc_inf;
						p = bp + 3;
						break;
					}
					else {
						if (IsNegNANLD(ldval)) 
							neg_in = 1;
						inf_nan = 1;
						val  = GETNaNPCLD(ldval);
						NaN_flg = SPR_SNLEN;
						mradix = 15;
						lradix = 3;
						tab =  lc_digs;
						SNAN = lc_nan;
						goto put_pc;
					}
				} 
				/* Do the conversion */
				bp = fcvtl(ldval, min(prec, MAXFCVT), &decpt, 
					&sign);
			}
			else {	/* dealing with "regular" double	*/
				/* Establish default precision */
				if (!(flags & DOTSEEN))
					prec = 6;

				/* Fetch the value */
				dval = spr_va_arg(argsp, double);
	
       		                /* Check for NaNs and Infinities  */
				if (IsNANorINF(dval)) {
					if (IsINF(dval)) {
						if (IsNegNAN(dval))
							neg_in = 1;
						inf_nan = 1;
						bp = (char *)lc_inf;
						p = bp + 3;
						break;
					}
					else {
						if (IsNegNAN(dval)) 
							neg_in = 1;
						inf_nan = 1;
						val  = GETNaNPC(dval);
						NaN_flg = SPR_SNLEN;
						mradix = 15;
						lradix = 3;
						tab =  lc_digs;
						SNAN = lc_nan;
						goto put_pc;
					}
				} 
				/* Do the conversion */
				bp = fcvt(dval, min(prec, MAXFCVT), &decpt, 
					&sign);
			}
			/* Determine the prefix */
		f_merge:
			if (sign && decpt > -prec && *bp != '0') prefixp = "-";
			else if (flags & SPR_FPLUS) prefixp = "+";
			else if (flags & SPR_FBLANK) prefixp = " ";

			/* Initialize buffer pointer */
			p = &mlxspr_buf[0];

			{ register int nn = decpt;

				/* Emit the digits before the decimal point */
				k = 0;
				do {
					*p++ = (nn <= 0 || *bp == '\0' 
						|| k >= MAXFSIG) ?
				    		'0' : (k++, *bp++);
				} while (--nn > 0);

				/* Decide whether we need a decimal point */
				if ((flags & FSHARP) || prec > 0)
					*p++ = _numeric[0];

				/* Digits (if any) after the decimal point */
				nn = min(prec, MAXFCVT);
				if (prec > nn) {
					flags |= RZERO;
					otherlength = rzero = prec - nn;
				}
				while (--nn >= 0)
					*p++ = (++decpt <= 0 || *bp == '\0' ||
				   	    k >= MAXFSIG) ? '0' : (k++, *bp++);
			}

			bp = &mlxspr_buf[0];

			break;

		case 'G':
		case 'g':
			/*
			 * g-format.  We play around a bit
			 * and then jump into e or f, as needed.
			 */
		
			if(flags & LONGD) {	/* long double	*/
				/* Establish default precision */
				if (!(flags & DOTSEEN))
					prec = 6;
				else if (prec == 0)
					prec = 1;

				/* Fetch the value */
				ldval = spr_va_arg(argsp, long double);

				/* Check for NaN and Infinities  */
				if (IsNANorINFLD(ldval)) {
					if (IsINFLD(ldval)) {
						if (IsNegNANLD(ldval)) 
							neg_in = 1;
						bp = (char *)((fcode == 'G') ? 
							uc_inf : lc_inf);
						p = bp + 3;
						inf_nan = 1;
						break;
					}
					else {
						if (IsNegNANLD(ldval)) 
							neg_in = 1;
						inf_nan = 1;
						val  = GETNaNPCLD(ldval);
						NaN_flg = SPR_SNLEN;
						mradix = 15;
						lradix = 3;
						if ( fcode == 'G') {
							SNAN = uc_nan;
							tab = uc_digs;
						}
						else {
							SNAN = lc_nan;
							tab =  lc_digs;
						}
						goto put_pc;
					}
				} 
				/* Do the conversion */
				bp = ecvtl(ldval, min(prec, MAXECVT), &decpt, 
					&sign);
			}
			else {	/* "regular" double	*/
				/* Establish default precision */
				if (!(flags & DOTSEEN))
					prec = 6;
				else if (prec == 0)
					prec = 1;

				/* Fetch the value */
				dval = spr_va_arg(argsp, double);

				/* Check for NaN and Infinities  */
				if (IsNANorINF(dval)) {
					if (IsINF(dval)) {
						if (IsNegNAN(dval)) 
							neg_in = 1;
						bp = (char *)((fcode == 'G') ? 
							uc_inf : lc_inf);
						p = bp + 3;
						inf_nan = 1;
						break;
					}
					else {
						if (IsNegNAN(dval)) 
							neg_in = 1;
						inf_nan = 1;
						val  = GETNaNPC(dval);
						NaN_flg = SPR_SNLEN;
						mradix = 15;
						lradix = 3;
						if ( fcode == 'G') {
							SNAN = uc_nan;
							tab = uc_digs;
						}
						else {
							SNAN = lc_nan;
							tab =  lc_digs;
						}
						goto put_pc;
					}
				} 

				/* Do the conversion */
				bp = ecvt(dval, min(prec, MAXECVT), &decpt, 
					&sign);
			}
/*LONG DOUBLE*/		if((flags & LONGD) /*&& ldval == 0*/)
				/*decpt = 1*/;
			else if(dval == 0)
				decpt = 1;

			{ register int kk = prec;
				if (!(flags & FSHARP)) {
					n = mlx_strlen(bp);
					if (n < kk)
						kk = n;
					while (kk >= 1 && bp[kk-1] == '0')
						--kk;
				}
				
				if (decpt < -3 || decpt > prec) {
					prec = kk - 1;
					goto e_merge;
				}
				prec = kk - decpt;
				goto f_merge;
			}
#endif	/* KAILASH */

	case '%': mlxspr_buf[0] = fcode; goto c_merge;
	case 'c':
		mlxspr_buf[0] = spr_va_arg(argsp, u32bits);
c_merge:	flags &= ~SPR_FQUOTE;
		ecp = (scp = &mlxspr_buf[0]) + 1;
		break;

#ifndef NO_MSE
	case 'C':
	{
		wchar_t wc;
		flags &= ~SPR_FQUOTE;
		/*CONSTANTCONDITION*/
		wc = (sizeof(wchar_t) < sizeof(u32bits))?
			spr_va_arg(argsp, u32bits) : spr_va_arg(argsp, wchar_t);
		if ((kinx = wctomb(mlxspr_buf, wc)) < 0) kinx=0; /* bogus wc */
		ecp = (scp=mlxspr_buf) + kinx;
		break;
	}
#endif /*NO_MSE*/

	case 's':
		flags &= ~SPR_FQUOTE;
		scp = spr_va_arg(argsp, s08bits MLXFAR *);
		if (!(flags & SPR_DOTSEEN)) ecp = scp + mlx_strlen(scp);
		else
		{	/* a strnlen function would  be useful here! */
			s08bits *qp = scp;
			while (*qp++ && (--prec >= 0)) ;
			ecp = qp - 1;
		}
		break;

#ifndef NO_MSE
	case 'S':
	{
			wchar_t *wp, *wp0;
			int n, tot;

			/*
			* Handle S conversion entirely here, not below.
			* Only prescan the input if there's a chance
			* for left padding.
			*/
			flags &= ~SPR_FQUOTE;
			wp0 = spr_va_arg(argsp, wchar_t *);
			if (width && (flags & SPR_FMINUS) == 0)
			{
				n = 0;
				for (wp = wp0; *wp != 0; wp++)
				{
					if ((kinx = wctomb(mlxspr_buf, *wp)) > 0)
					{
						n += kinx;
						if ((flags & SPR_DOTSEEN) && (n > prec))
						{
							n -= kinx;
							break;
						}
					}
				}
				if (width > n)
				{
					n = width - n;
					count += n;
					spr_put(mlxspr_blanks, n);
					width = 0;
				}
			}
			if ((flags & SPR_DOTSEEN) == 0)
				prec = SPR_MAXINT;
			/*
			* Convert one wide character at a time into the
			* local buffer and then copy it to the stream.
			* This isn't very efficient, but it's correct.
			*/
			tot = 0;
			wp = wp0;
			while (*wp != 0)
			{
				if ((kinx = wctomb(mlxspr_buf, *wp++)) <= 0)
					continue;
				if ((prec -= kinx) < 0)
					break;
				spr_put(mlxspr_buf, kinx);
				tot += kinx;
			}
			count += tot;
			if (width > tot)
			{
				tot = width - tot;
				count += tot;
				spr_put(mlxspr_blanks, tot);
			}
			goto main_loop;
		}
#endif /*NO_MSE*/

	case 'n':
		flags &= ~SPR_FQUOTE;
		if (flags & SPR_LENGTH)
		{
			long MLXFAR *svcount = spr_va_arg(argsp, long MLXFAR *);
			*svcount = count;
		} else if (flags & SPR_SHORT)
		{
			u16bits MLXFAR *svcount = (u16bits MLXFAR*)spr_va_arg(argsp, short MLXFAR *);
			*svcount = (u16bits)count;
		} else
		{
			u32bits *svcount = spr_va_arg(argsp, u32bits MLXFAR *);
			*svcount = count;
		}
		goto main_loop;

	/* this is technically an error; what we do is to back up the format
	** pointer to the offending char and continue with the format scan
	*/
	default:
		fmtp--;
		goto main_loop;
	} /* end of par_loop */

	if (inf_nan)
	{
		if (neg_in) { prefixp = "-"; neg_in = 0; }
		else if (flags & SPR_FPLUS) prefixp = "+";
		else if (flags & SPR_FBLANK) prefixp = " ";
		inf_nan = 0;
	}

#ifdef	KAILASH
	if ((flags & SPR_FQUOTE) && _numeric[1] && ((ngrp = _grouping[0]) > 0))
	{
		unsigned char *grp;  /* ptr to current grouping num */
			int   bplen;	     /* length of string bp */
			int   decpos = -1;/* position of decimal point in bp */
			char *q;
			int i;
			int decimals;

			grp = _grouping;
			bplen = p - bp;
			for(q = bp;q!=p;q++)
				if(*q == _numeric[0])
					decpos = q - bp;
			q = &workbuf[sizeof(workbuf)];
			*--q = '\0';
			if(decpos >= 0){  /* value contains a decimal point */
				for(p = &bp[bplen],i=bplen-(&p[decpos]-p); i>0; i--)
					*--q = *--p;
				}
			decimals = p - bp;
				/* now we just have digits to the left of */
				/* the decimal point.  put in the thousand */
				/* separator according to _grouping */
			while(decimals > 0){
				if(ngrp == 0){
					*--q = _numeric[1]; /* thousands sep */
					if((ngrp = *++grp) <= 0)
						ngrp = *--grp;	/* repeat grp */
					continue;
					}
				*--q = *--p;
				ngrp--;
				decimals--;
				}
				
			/* restore bp and p to point to the new string */
			bp = q;
			for(p=q;*q;p++,q++)
				;	/* empty for loop */
	}
#endif

	/* Calculate number of padding blanks */
	kinx = (knum = ecp - scp) + otherlength + NaN_flg + ((prefixp)?mlx_strlen(prefixp) : 0);
	if (width <= kinx) count += kinx;
	else
	{
		count += width;
		/* Set up for padding zeroes if requested Otherwise emit
		** padding blanks unless output is to be left-justified.
		*/
		if (flags & SPR_PADZERO)
		{
			if (!(flags & SPR_LZERO))
			{
				flags |= SPR_LZERO;
				lzero = width - kinx;
			}
			else
				lzero += width - kinx;
			kinx = width; /* cancel padding blanks */
		} else /* Blanks on left if required */
			if (!(flags & SPR_FMINUS))
				spr_put(mlxspr_blanks, width - kinx);
	}

	if (prefixp) /* Prefix, if any */
		for ( ; *prefixp; sp++, prefixp++)
			*sp = *prefixp;

	/* If value is NaN, put string NaN*/
	if (NaN_flg)
	{
		spr_put(SNAN,SPR_SNLEN);
		NaN_flg = 0;
	}

	if (flags & SPR_LZERO) spr_put(mlxspr_zeroes, lzero); /* Zeroes on the left */
	if (knum > 0) spr_put(scp, knum); /* The value itself */
	if (!(flags & (SPR_RZERO | SPR_SUFFIX | SPR_FMINUS))) goto main_loop;
	if (flags & SPR_RZERO) spr_put(mlxspr_zeroes, rzero); /* Zeroes on the right */
	if (flags & SPR_SUFFIX) spr_put(suffixp, suffixlength); /* The suffix */
	if ((flags&SPR_FMINUS) && (width > kinx)) spr_put(mlxspr_blanks, width - kinx); /* Blanks on the right if required */
	goto main_loop;
}

/* This function initializes arglist, to contain the appropriate va_list values
** for the first MAXARGS arguments.
*/
void	MLXFAR
mlxspr_mkarglist(fmt, argsp, arglist)
s08bits	MLXFAR	*fmt;
u08bits	MLXFAR	*argsp;
u08bits	MLXFAR	*arglist[];
{
	static u08bits digits[] = "0123456789", skips[] = "# +-'.0123456789h$";

	enum types {INT = 1, LONG, WCHAR, CHAR_PTR, DOUBLE, LONG_DOUBLE,
		VOID_PTR, LONG_PTR, INT_PTR, WCHAR_PTR};
	enum types typelist[SPR_MAXARGS], curtype;
	s32bits maxnum, n, curargno, flags;

	/*
	** Algorithm:
	**  1. set all argument types to zero.
	**  2. walk through fmt putting arg types in typelist[].
	**  3. walk through args using spr_va_arg(argsp, typelist[n]) and set
	**     arglist[] to the appropriate values.
	** Assumptions:	Cannot use %*$... to specify variable position.
	*/
	mlxzero(typelist, sizeof(typelist));
	maxnum = -1;
	curargno = 0;
	while ((fmt = mlx_strchr(fmt, '%')) != 0)
	{
		fmt++;	/* skip % */
		if (fmt[n = mlx_strspn(fmt, digits)] == '$')
		{
			curargno = mlx_str232bits(fmt,NULL,10) - 1; /* convert to zero base */
			if (curargno < 0) continue;
			fmt += n + 1;
		}
		flags = 0;
	again:;
		fmt += mlx_strspn(fmt, skips);
		switch (*fmt++)
		{
		case '%': continue; /* there is no argument! */
		case 'l': flags |= 0x1; goto again;
		case 'L':
			flags |= 0x4;
			goto again;
		case '*':	/* int argument used for value */
			/* check if there is a positional parameter */
			if (mlx_numeric(*fmt)) {
				int	targno;
				targno = mlx_str232bits(fmt,NULL,10) - 1;
				fmt += mlx_strspn(fmt, digits);
				if (*fmt == '$')
					fmt++; /* skip '$' */
				if (targno >= 0 && targno < SPR_MAXARGS) {
					typelist[targno] = INT;
					if (maxnum < targno)
						maxnum = targno;
				}
				goto again;
			}
			flags |= 0x2;
			curtype = INT;
			break;
		case 'e':
		case 'E':
		case 'f':
		case 'g':
		case 'G':
			if(flags & 0x4) curtype = LONG_DOUBLE;
			else curtype = DOUBLE;
			break;
		case 's':
			curtype = CHAR_PTR;
			break;
		case 'p':
			curtype = VOID_PTR;
			break;
		case 'n':
			if (flags & 0x1)
				curtype = LONG_PTR;
			else
				curtype = INT_PTR;
			break;
#ifndef NO_MSE
		case 'C':
			/*CONSTANTCONDITION*/
			if (sizeof(wchar_t) < sizeof(int))
				curtype = INT;
			else
				curtype = WCHAR;
			break;
		case 'S':
			curtype = WCHAR_PTR;
			break;
#endif /*NO_MSE*/
		default:
			if (flags & 0x1)
				curtype = LONG;
			else
				curtype = INT;
			break;
		}
		if (curargno >= 0 && curargno < SPR_MAXARGS)
		{
			typelist[curargno] = curtype;
			if (maxnum < curargno)
				maxnum = curargno;
		}
		curargno++;	/* default to next in list */
		if (flags & 0x2)	/* took care of *, keep going */
		{
			flags ^= 0x2;
			goto again;
		}
	}
	for (n = 0 ; n <= maxnum; n++)
	{
		arglist[n] = argsp;
		if (typelist[n] == 0)
			typelist[n] = INT;
		
		switch (typelist[n])
		{
		case INT:
			(void) spr_va_arg(argsp, int);
			break;
#ifndef NO_MSE
		case WCHAR:
			(void) spr_va_arg(argsp, wchar_t);
			break;
		case WCHAR_PTR:
			(void) spr_va_arg(argsp, wchar_t *);
			break;
#endif /*NO_MSE*/
		case LONG:
			(void) spr_va_arg(argsp, long);
			break;
		case CHAR_PTR:
			(void) spr_va_arg(argsp, char *);
			break;
		case DOUBLE:
			(void) spr_va_arg(argsp, double);
			break;
		case LONG_DOUBLE:
			(void) spr_va_arg(argsp, long double);
			break;
		case VOID_PTR:
			(void) spr_va_arg(argsp, void *);
			break;
		case LONG_PTR:
			(void) spr_va_arg(argsp, long *);
			break;
		case INT_PTR:
			(void) spr_va_arg(argsp, int *);
			break;
		}
	}
}

/*
** This function is used to find the va_list value for arguments whose
** position is greater than SPR_MAXARGS.  This function is slow, so hopefully
** SPR_MAXARGS will be big enough so that this function need only be called in
** unusual circumstances.
** pargs is assumed to contain the value of arglist[SPR_MAXARGS - 1].
*/
void	MLXFAR
mlxspr_getarg(fmtp, pargs, argno)
s08bits	MLXFAR	*fmtp;
u08bits	MLXFAR	*pargs[];
s32bits	argno;
{
	static u08bits digits[] = "0123456789", skips[] = "# +-'.0123456789h$";
	s32bits i, n, curargno, flags;
	s08bits	MLXFAR	*sfmtp = fmtp;
	s32bits	found = 1;

	i = SPR_MAXARGS;
	curargno = 1;
	while (found)
	{
		fmtp = sfmtp;
		found = 0;
		while ((i != argno) && (fmtp = mlx_strchr(fmtp, '%')) != 0)
		{
			fmtp++;	/* skip % */
			if (fmtp[n = mlx_strspn(fmtp, digits)] == '$')
			{
				curargno = mlx_str232bits(fmtp, NULL, 10);
				if (curargno <= 0)
					continue;
				fmtp += n + 1;
			}

			/* find conversion specifier for next argument */
			if (i != curargno)
			{
				curargno++;
				continue;
			} else
				found = 1;
			flags = 0;
		again:;
			fmtp += mlx_strspn(fmtp, skips);
			switch (*fmtp++)
			{
			case '%':	/*there is no argument! */
				continue;
			case 'l':
				flags |= 0x1;
				goto again;
			case 'L':
				flags |= 0x4;
				goto again;
			case '*':	/* int argument used for value */
				/* check if there is a positional parameter;
				 * if so, just skip it; its size will be
				 * correctly determined by default */
				if (mlx_numeric(*fmtp)) {
					fmtp += mlx_strspn(fmtp, digits);
					if (*fmtp == '$')
						fmtp++; /* skip '$' */
					goto again;
				}
				flags |= 0x2;
				(void)spr_va_arg((*pargs), int);
				break;
			case 'e':
			case 'E':
			case 'f':
			case 'g':
			case 'G':
				if (flags & 0x1)
					(void)spr_va_arg((*pargs), double);
				else if (flags & 0x4)
					(void)spr_va_arg((*pargs), long double);
				else (void)spr_va_arg((*pargs), double);
				break;
			case 's':
				(void)spr_va_arg((*pargs), char *);
				break;
			case 'p':
				(void)spr_va_arg((*pargs), void *);
				break;
			case 'n':
				if (flags & 0x1)
					(void)spr_va_arg((*pargs), long *);
				else
					(void)spr_va_arg((*pargs), int *);
				break;
#ifndef NO_MSE
			case 'C':
				/*CONSTANTCONDITION*/
				if (sizeof(wchar_t) < sizeof(int))
					(void)spr_va_arg((*pargs), int);
				else
					(void)spr_va_arg((*pargs), wchar_t);
				break;
			case 'S':
				(void)spr_va_arg((*pargs), wchar_t *);
				break;
#endif /*NO_MSE*/
			default:
				if (flags & 0x1)
					(void)spr_va_arg((*pargs), long int);
				else
					(void)spr_va_arg((*pargs), int);
				break;
			}
			i++;
			curargno++;	/* default to next in list */
			if (flags & 0x2)	/* took care of *, keep going */
			{
				flags ^= 0x2;
				goto again;
			}
		}

		/* missing specifier for parameter, assume parameter is an int */
		if (!found && i != argno) {
			(void)spr_va_arg((*pargs), int);
			i++;
			curargno = i;
			found = 1;
		}
	}
}

#ifdef	SPR_TEST
s08bits	mlx_teststr[128];
mlx_printutest(val)
u32bits	val;
{
	printf("%10u %7u %2u %u\n",val,val,val,val);
	printf(mlx_sprintf(mlx_teststr,"%10u %7u %2u %u\n",val,val,val,val));

	printf("%010u %07u %02u %0u\n",val,val,val,val);
	printf(mlx_sprintf(mlx_teststr,"%010u %07u %02u %0u\n",val,val,val,val));

	printf("%10.7u %7.5u %2.1u %0.1u\n",val,val,val,val);
	printf(mlx_sprintf(mlx_teststr,"%10.7u %7.5u %2.1u %0.1u\n",val,val,val,val));

	printf("%010.7u %07.5u %02.1u %00.1u\n",val,val,val,val);
	printf(mlx_sprintf(mlx_teststr,"%010.7u %07.5u %02.1u %00.1u\n",val,val,val,val));
}

mlx_printdtest(val)
u32bits	val;
{
	printf("%10d %7d %2d %d\n",val,val,val,val);
	printf(mlx_sprintf(mlx_teststr,"%10d %7d %2d %d\n",val,val,val,val));

	printf("%010d %07d %02d %0d\n",val,val,val,val);
	printf(mlx_sprintf(mlx_teststr,"%010d %07d %02d %0d\n",val,val,val,val));

	printf("%10.7d %7.5d %2.1d %0.1d\n",val,val,val,val);
	printf(mlx_sprintf(mlx_teststr,"%10.7d %7.5d %2.1d %0.1d\n",val,val,val,val));

	printf("%010.7d %07.5d %02.1d %00.1d\n",val,val,val,val);
	printf(mlx_sprintf(mlx_teststr,"%010.7d %07.5d %02.1d %00.1d\n",val,val,val,val));
}

mlx_printotest(val)
u32bits	val;
{
	printf("%10o %7o %2o %o\n",val,val,val,val);
	printf(mlx_sprintf(mlx_teststr,"%10o %7o %2o %o\n",val,val,val,val));

	printf("%010o %07o %02o %0o\n",val,val,val,val);
	printf(mlx_sprintf(mlx_teststr,"%010o %07o %02o %0o\n",val,val,val,val));

	printf("%10.7o %7.5o %2.1o %0.1o\n",val,val,val,val);
	printf(mlx_sprintf(mlx_teststr,"%10.7o %7.5o %2.1o %0.1o\n",val,val,val,val));

	printf("%010.7o %07.5o %02.1o %00.1o\n",val,val,val,val);
	printf(mlx_sprintf(mlx_teststr,"%010.7o %07.5o %02.1o %00.1o\n",val,val,val,val));
}

mlx_printxtest(val)
u32bits	val;
{
	printf("%10x %7x %2x %x\n",val,val,val,val);
	printf(mlx_sprintf(mlx_teststr,"%10x %7x %2x %x\n",val,val,val,val));

	printf("%010x %07x %02x %0x\n",val,val,val,val);
	printf(mlx_sprintf(mlx_teststr,"%010x %07x %02x %0x\n",val,val,val,val));

	printf("%10.7x %7.5x %2.1x %0.1x\n",val,val,val,val);
	printf(mlx_sprintf(mlx_teststr,"%10.7x %7.5x %2.1x %0.1x\n",val,val,val,val));

	printf("%010.7x %07.5x %02.1x %00.1x\n",val,val,val,val);
	printf(mlx_sprintf(mlx_teststr,"%010.7x %07.5x %02.1x %00.1x\n",val,val,val,val));
}

mlx_printXtest(val)
u32bits	val;
{
	printf("%10X %7X %2X %X\n",val,val,val,val);
	printf(mlx_sprintf(mlx_teststr,"%10X %7X %2X %X\n",val,val,val,val));

	printf("%010X %07X %02X %0X\n",val,val,val,val);
	printf(mlx_sprintf(mlx_teststr,"%010X %07X %02X %0X\n",val,val,val,val));

	printf("%10.7X %7.5X %2.1X %0.1X\n",val,val,val,val);
	printf(mlx_sprintf(mlx_teststr,"%10.7X %7.5X %2.1X %0.1X\n",val,val,val,val));

	printf("%010.7X %07.5X %02.1X %00.1X\n",val,val,val,val);
	printf(mlx_sprintf(mlx_teststr,"%010.7X %07.5X %02.1X %00.1X\n",val,val,val,val));
}

u32bits	MLXFAR
mlx_printest()
{
	u32bits val;
	val = 1234;

	mlx_printutest(1234);
	mlx_printutest(0x80000000);
	mlx_printutest(0x80000012);

	mlx_printdtest(1234);
	mlx_printdtest(0x80000000);
	mlx_printdtest(0x80000012);

	mlx_printotest(1234);
	mlx_printotest(0x80000000);
	mlx_printotest(0x80000012);

	mlx_printxtest(1234);
	mlx_printxtest(0x80000000);
	mlx_printxtest(0x80000012);

	mlx_printXtest(1234);
	mlx_printXtest(0x80000000);
	mlx_printXtest(0x80000012);

	printf(mlx_sprintf(mlx_teststr,"test1=%s test2=%u test3=%17.10s\n","test1",7,"test3"));
}
#endif	/* SPR_TEST */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\port\scsi\miniport\mylex\dac2w2k\io\mdacdrv.c ===
/**************************************************************************
 *                COPYRIGHT (C) Mylex Corporation 1992-1999               *
 *                                                                        *
 * This software is furnished under a license and may be used and copied  * 
 * only in accordance with the terms and conditions of such license and   * 
 * with inclusion of the above copyright notice. This software or any     * 
 * other copies thereof may not be provided or otherwise made available   * 
 * to any other person. No title to, nor ownership of the software is     * 
 * hereby transferred.                                                    *
 *                                                                        *
 * The information in this software is subject to change without notices  *
 * and should not be construed as a commitment by Mylex Corporation       *
 *                                                                        *
 **************************************************************************/

/*
** NOTE:
** All functions in this module must run interrupt protected except
** mdacopen, mdacclose, mdacioctl, mdac_timer.
** mdac_physdev activity will be controlled by mdac_link_lock.
** mdac_link_lock controls all link type of operation - queueing, allocation/
** deallocation of memory etc.
** mdac_link_lock controls the physical device operation for DAC960 family.
** mdac_link_locks are the last lock in chain, no lock should be held after
** this lock has been held.
**
** Old controller can not handle bit 63 to 32. Therefore we will ignore bit
** 63 to 32 in code. Therefore rq_PhysAddr.bit31_0 will be used.
*/


#ifdef  MLX_SCO
#include "sys/types.h"
#include "sys/sysmacros.h"
#include "sys/param.h"
#include "sys/errno.h"
#include "sys/immu.h"
#include "sys/cmn_err.h"
#include "sys/scsi.h"
#include "sys/devreg.h"
#include "sys/ci/cilock.h"
#include "sys/ci/ciintr.h"
#elif   MLX_UW
#define HBA_PREFIX      mdacuw
#include "sys/types.h"
#include "sys/sysmacros.h"
#include "sys/param.h"
#include "sys/errno.h"
#include "sys/time.h"
#include "sys/immu.h"
#include "sys/systm.h"
#include "sys/ksynch.h"
#include "sys/ddi.h"
#include "sys/cmn_err.h"
#include "sys/moddefs.h"
#include "sys/resmgr.h"
#include "sys/sdi.h"
#include "sys/hba.h"
#elif   MLX_NW
#include "npaext.h"
#include "npa.h"
#include "npa_cdm.h"
#elif   MLX_NT
#include "ntddk.h"
#include "scsi.h"
#include "ntddscsi.h"
#include "sys/mdacntd.h"
#elif   MLX_DOS
#include "stdio.h"
#include "stdlib.h"
#include "dos.h"
#include "string.h"
#include "process.h"
#include "conio.h"
#include "time.h"
#elif MLX_WIN9X
#define WANTVXDWRAPS
#include <basedef.h>
#include <vmm.h>
#include <debug.h>
#include <vxdwraps.h>
#include <scsi.h>
#include "sys/mdacntd.h"
#elif   MLX_SOL
#include "sys/scsi/scsi.h"
#include "sys/mdacsol.h"
#elif MLX_OS2
#include "os2.h"
#include "dos.h"
#include "bseerr.h"
#include "infoseg.h"
#include "sas.h"
#include "scsi.h"
#include "devhdr.h"
#include "devcmd.h"

#include "dskinit.h"
#include "iorb.h"
#include "strat2.h"
#include "reqpkt.h"
#include "dhcalls.h"
#include "addcalls.h"
#include "rmcalls.h"
#endif  /* End of ALL OS specific Include files */

#ifdef MLX_DOS
#include "shared/mlxtypes.h"
#include "shared/mlxparam.h"
#include "sys/mdacver.h"
#include "shared/dac960if.h"
#include "shared/mlxscsi.h"
#include "shared/mlxhw.h"
#else
#include "sys/mlxtypes.h"
#include "sys/mlxparam.h"
#include "sys/mdacver.h"
#include "sys/dac960if.h"
#include "sys/mlxscsi.h"
#include "sys/mlxhw.h"
#endif

#ifndef MLX_DOS
#include "sys/mlxperf.h"
#include "sys/drlapi.h"
#endif /* MLX_DOS */

#ifdef MLX_DOS
#include "shared/mdacapi.h"
#include "shared/mdrvos.h"
#include "shared/mdacdrv.h"
#else
#include "sys/mdacapi.h"
#include "sys/mdrvos.h"
#include "sys/mdacdrv.h"
#endif

UINT_PTR globaldebug[200] = {0};
u32bits globaldebugcount =0;
u32bits IOCTLTrackBuf[200] = {0};
u32bits IOCTLTrackBufCount =0;
u08bits debugPointerCount=0;
UINT_PTR debugPointer[100];

extern void ia64debug(UINT_PTR i);
extern void ia64debugPointer(UINT_PTR add);
extern void IOCTLTrack(u32bits ioctl);
extern void mybreak(void);

#ifndef MLX_NT 
#define DebugPrint(x)
#else
extern void MdacInt3(void);

extern void Gam_Mdac_MisMatch(mdac_req_t MLXFAR *rqp);
extern u32bits ntmdac_alloc_req_ret(
	mdac_ctldev_t MLXFAR *ctp,
	mdac_req_t MLXFAR **rqpp,
	OSReq_t MLXFAR *osrqp,
	u32bits rc
	);
#endif


#if     defined(MLX_SOL_SPARC) || defined(MLX_NT_ALPHA) || defined(WINNT_50)
extern  u32bits MLXFAR mdac_os_gam_cmd(mdac_req_t MLXFAR *rqp);
extern  u32bits MLXFAR mdac_os_gam_new_cmd(mdac_req_t MLXFAR *rqp);
#else   /*MLX_SOL_SPARC || MLX_NT_ALPHA */
#define mdac_os_gam_cmd mdac_gam_cmd
#define mdac_os_gam_new_cmd     mdac_gam_new_cmd
#endif  /*MLX_SOL_SPARC || MLX_NT_ALPHA */

u32bits mdac_valid_mech1 = 0;
u32bits mdacdevflag = 0;
u32bits mdac_driver_ready=0;
u32bits mdac_irqlevel=0;

u32bits mdac_advancefeaturedisable=0;   /* non zero if advanced feature disabled */
u32bits mdac_advanceintrdisable=1;      /* non zero if advanced intr feature disabled */
u32bits MdacFirstIoctl          = 1;
u32bits mdac_ignoreofflinesysdevs=1;    /* non zero if offline logical device to be ignored during scan */
u32bits mdac_reportscanneddisks=0;      /* non zero if scanned disk to be reported */
u32bits mdac_datarel_cpu_family=0,mdac_datarel_cpu_model=0,mdac_datarel_cpu_stepping=0;
u08bits mdac_monthstr[36] ="JanFebMarAprMayJunJulAugSepOctNovDec";
u08bits mdac_hexd[] = "0123456789ABCDEF";
dga_driver_version_t mdac_driver_version =
{
	0,              /* No error code */
	DGA_DRV_MAJ,    /* Driver Major version number */
	DGA_DRV_MIN,    /* Driver Minor version number */
	' ',            /* Interim release */
	MLXVID_TYPE,    /* vendor name (default Mylex) */
	DGA_DBM,        /* Driver Build Date - Month */
	DGA_DBD,        /* Driver Build Date - Date */
	DGA_DBC,        /* Driver Build Date - Year */
	DGA_DBY,        /* Driver Build Date - Year */
	DGA_DBN,        /* Build Number */
	GAMOS_TYPE,     /* OS Type */
	MDACENDIAN_TYPE /* SysFlags */
};

mdac_ctldev_t   mdac_ctldevtbl[MDAC_MAXCONTROLLERS+1];  /*  = {0}; */
mdac_ctldev_t   MLXFAR* mdac_lastctp=mdac_ctldevtbl;/*last+1 controller addr */
mdac_ctldev_t   MLXFAR* mdac_masterintrctp=0;   /* master interrupt controller*/
mdac_pldev_t    mdac_pldevtbl[MDAC_MAXPLDEVS+1];        /*  = {0}; */
mdac_pldev_t    MLXFAR* mdac_lastplp=mdac_pldevtbl; /* last+1 device addr */
mda_sizelimit_t mdac_sizelimitbl[MDAC_MAXSIZELIMITS];   /* ={0}; */
mda_sizelimit_t MLXFAR* mdac_lastslp=mdac_sizelimitbl;/*last+1 device size limit*/
mdac_reqsense_t mdac_reqsensetbl[MDAC_MAXREQSENSES];    /* sense data table */
#define         mdac_lastrqsp &mdac_reqsensetbl[MDAC_MAXREQSENSES]
u32bits         mdac_reqsenseinx=0;     /* sense index if no free space */
mda_sysinfo_t   mda_sysi={0};
dac_hwfwclock_t mdac_hwfwclock={0};
u08bits         mdac_VendorID[USCSI_VIDSIZE] = "MYLEX   ";
u08bits         mdac_driver_name[16] = "mdac";

mdac_ttbuf_t    mdac_ttbuftbl[MDAC_MAXTTBUFS] = {0};
mdac_ttbuf_t    MLXFAR* mdac_curttbp=mdac_ttbuftbl;/* current time trace buf */
#define mdac_ttbuftblend (&mdac_ttbuftbl[MDAC_MAXTTBUFS])
u32bits mdac_ttwaitchan=0,mdac_ttwaitime=0,mdac_tthrtime=0;

u32bits mdac_simple_waitlock_cnt;               /* # times lock waited */
u64bits mdac_simple_waitloop_cnt;               /* # times lock loop waited */
u32bits         mdac_flushdata = 0;             /* access will flush writes */
u08bits MLXFAR* mdac_flushdatap = (u08bits MLXFAR *)&mdac_flushdata; /* access will flush writes */
u32bits MLXFAR* mdac_intrstatp;                 /* interrupt status address */
#ifdef MLX_FIXEDPOOL
u64bits         mdac_pintrstatp;                /* interrupt status physical address */
#endif
dac_biosinfo_t  MLXFAR* mdac_biosp = 0;         /* BIOS space mapped address */
/* HOTLINKS */
u32bits gam_present = 0;
u32bits failGetGAM = 0;
/* HOTLINKS */
#ifndef MLX_DOS
#ifdef _WIN64
//drliostatus_t   MLXFAR* mdac_drliosp[DRLMAX_RWTEST];    
//drlcopy_t       MLXFAR* mdac_drlcopyp[DRLMAX_COPYCMP];  
#else
drliostatus_t   MLXFAR* mdac_drliosp[DRLMAX_RWTEST];    
drlcopy_t       MLXFAR* mdac_drlcopyp[DRLMAX_COPYCMP];  
#endif
drlrwtest_t     mdac_drlsigrwt;
drlcopy_t       mdac_drlsigcopycmp;
#else
mdac_req_t MLXFAR *mdac_scanq = (mdac_req_t MLXFAR *) NULL;
#define vadpsize  (mdac_req_s - offsetof(rqp->rq_SGList))
#define rdcmdp    (&rqp->rq_DacCmd) 
#endif /* MLX_DOS */
#include "mdacdrv.pro"

/*=================================================================*/
mdac_lock_t mdac_link_lck;
mdac_lock_t mdac_timetrace_lck;
mdac_lock_t mdac_sleep_lck;

#if !defined(MLX_NT) && !defined(MLX_WIN9X)
extern  u32bits MLXFAR  u08bits_in_mdac(u32bits);
extern  u32bits MLXFAR  u16bits_in_mdac(u32bits);
extern  u32bits MLXFAR  u32bits_in_mdac(u32bits);
extern  void    MLXFAR  u08bits_out_mdac(u32bits, u32bits);
extern  void    MLXFAR  u16bits_out_mdac(u32bits, u32bits);
extern  void    MLXFAR  u32bits_out_mdac(u32bits, u32bits);
#endif

u32bits (MLXFAR *mdac_spinlockfunc)() = 0;   /* Pointer to Spinlock Function */
u32bits (MLXFAR *mdac_unlockfunc)() = 0;     /* Pointer to Unlock Function */
u32bits (MLXFAR *mdac_prelockfunc)() = 0;    /* Pointer to Prelock Function */
u32bits (MLXFAR *mdac_postlockfunc)() = 0;    /* Pointer to Postlock Function */

/*=================================================================*/
/* Macros to deal with most of the common functionality */

/* do mdac_link_locked statement */
#define mdac_link_lock_st(st) \
{ \
	mdac_link_lock(); \
	st; \
	mdac_link_unlock(); \
}

/* record new found controller */
#define mdac_newctlfound() \
{ \
	if (mda_Controllers < MDAC_MAXCONTROLLERS) \
	{ \
		ctp++; \
		mda_Controllers++; \
		mdac_lastctp = &mdac_ctldevtbl[mda_Controllers]; \
	} \
	else \
		mda_TooManyControllers++; \
}

/* queue one request in waiting queue of controller */
#define qreq(ctp,rqp) \
{ \
	MLXSTATS(ctp->cd_CmdsWaited++;) \
	ctp->cd_CmdsWaiting++; \
	if (ctp->cd_FirstWaitingReq) ctp->cd_LastWaitingReq->rq_Next = rqp; \
	else ctp->cd_FirstWaitingReq = rqp; \
	ctp->cd_LastWaitingReq = rqp; \
	rqp->rq_Next = NULL; \
}

/* dequeue one waiting request from waiting queue of controller */
#define dqreq(ctp,rqp) \
	if (rqp=ctp->cd_FirstWaitingReq) \
	{       /* remove the request from chain */ \
		ctp->cd_FirstWaitingReq = rqp->rq_Next; \
		ctp->cd_CmdsWaiting--; \
	}

/* queue physical device request */
#define pdqreq(ctp,rqp,pdp) \
{ \
	MLXSTATS(ctp->cd_SCDBWaited++;) \
	ctp->cd_SCDBWaiting++; \
	if (pdp->pd_FirstWaitingReq) pdp->pd_LastWaitingReq->rq_Next = rqp; \
	else pdp->pd_FirstWaitingReq = rqp; \
	pdp->pd_LastWaitingReq = rqp; \
	rqp->rq_Next = NULL; \
}

/* allocate a command id, assume command id will never run out */
#define mdac_get_cmdid(ctp,rqp) \
{ \
	ctp->cd_FreeCmdIDList=(rqp->rq_cmdidp=ctp->cd_FreeCmdIDList)->cid_Next;\
	MLXSTATS(ctp->cd_FreeCmdIDs--;) \
	if (ctp->cd_Status & MDACD_NEWCMDINTERFACE) \
		ncmdp->nc_CmdID = (u16bits) rqp->rq_cmdidp->cid_cmdid; \
	else \
		dcmdp->mb_CmdID = (u08bits) rqp->rq_cmdidp->cid_cmdid; \
}

/* free a command id */
#define mdac_free_cmdid(ctp,rqp) \
{ \
	rqp->rq_cmdidp->cid_Next = ctp->cd_FreeCmdIDList; \
	ctp->cd_FreeCmdIDList = rqp->rq_cmdidp; \
	MLXSTATS(ctp->cd_FreeCmdIDs++;) \
}

#ifdef MLX_SMALLSGLIST
/* set SGlen for SCSI cdb according to firmware */
#define mdac_setscdbsglen(ctp) \
{ \
	if (ctp->cd_FWVersion < (u16bits) DAC_FW300) \
	{ \
		dcmdp->mb_MailBoxC = (u08bits)rqp->rq_SGLen; \
		dcdbp->db_PhysDatap = dcmdp->mb_Datap; \
	} \
	else    /* Be careful, first SG entry is ignored */ \
		dcdbp->db_PhysDatap = (dcmdp->mb_MailBox2 = (u08bits)rqp->rq_SGLen)? \
			dcmdp->mb_Datap-mdac_sglist_s : dcmdp->mb_Datap; \
	MLXSWAP(dcdbp->db_PhysDatap); \
	dcmdp->mb_Datap = rqp->rq_PhysAddr.bit31_0 + offsetof(mdac_req_t, rq_scdb); \
	MLXSWAP(dcmdp->mb_Datap); \
}

/* set SCSI data transfer size, must be called after setting db_CdbLen */
#define mdac_setcdbtxsize(sz) \
{ \
	rqp->rq_ResdSize = sz; \
	dcdbp->db_TxSize = (u16bits)sz; MLXSWAP(dcdbp->db_TxSize); \
	dcdbp->db_CdbLen |= (u08bits)((sz) & 0xF0000) >> (16-4) ; /* bit 19..16 */ \
}

#else // MLX_SMALLSGLIST

/* set SGlen for SCSI cdb according to firmware */
#define mdac_setscdbsglen(ctp) \
{ \
	if (ctp->cd_FWVersion < (u16bits) DAC_FW300) \
	{ \
		dcmdp->mb_MailBoxC = (u08bits) rqp->rq_SGLen; \
		dcdbp->db_PhysDatap = rqp->rq_DMAAddr.bit31_0; \
	} \
	else    /* Be careful, first SG entry is ignored */ \
		dcdbp->db_PhysDatap = (dcmdp->mb_MailBox2 = (u08bits)rqp->rq_SGLen)? \
			rqp->rq_DMAAddr.bit31_0 - mdac_sglist_s : rqp->rq_DMAAddr.bit31_0; \
	MLXSWAP(dcdbp->db_PhysDatap); \
	dcmdp->mb_Datap = rqp->rq_PhysAddr.bit31_0 + offsetof(mdac_req_t, rq_scdb); \
	MLXSWAP(dcmdp->mb_Datap); \
}

/* set SCSI data transfer size, must be called after setting db_CdbLen */
#define mdac_setcdbtxsize(sz) \
{ \
	rqp->rq_ResdSize = sz; \
	dcdbp->db_TxSize = (u16bits)sz; MLXSWAP(dcdbp->db_TxSize); \
	dcdbp->db_CdbLen |= ((sz) & 0xF0000) >> (16-4) ; /* bit 19..16 */ \
}

#endif // MLX_SMALLSGLIST

/* get SCSI data transfer size */
#define mdac_getcdbtxsize() \
	(mlxswap(dcdbp->db_TxSize) + ((dcdbp->db_CdbLen&0xF0) << (16-4)))

/* setup version 2x commands */
#define mdac_setcmd_v2x(ctp) \
{ \
	ctp->cd_InquiryCmd = DACMD_INQUIRY_V2x; \
	ctp->cd_ReadCmd = DACMD_READ_V2x; \
	ctp->cd_WriteCmd = DACMD_WRITE_V2x; \
	ctp->cd_SendRWCmd = mdac_send_rwcmd_v2x; \
	ctp->cd_SendRWCmdBig = mdac_send_rwcmd_v2x_big; \
}

/* setup version 3x commands */
#define mdac_setcmd_v3x(ctp) \
{ \
	ctp->cd_InquiryCmd = DACMD_INQUIRY_V3x; \
	ctp->cd_ReadCmd = DACMD_READ_OLD_V3x; \
	ctp->cd_WriteCmd = DACMD_WRITE_OLD_V3x; \
	ctp->cd_SendRWCmd = mdac_send_rwcmd_v3x; \
	ctp->cd_SendRWCmdBig = mdac_send_rwcmd_v3x_big; \
}

/* setup version new commands */
#define mdac_setcmd_new(ctp) \
{ \
	ctp->cd_InquiryCmd = MDACIOCTL_GETCONTROLLERINFO; \
	ctp->cd_ReadCmd = UCSCMD_EREAD; \
	ctp->cd_WriteCmd = UCSCMD_EWRITE; \
	ctp->cd_SendRWCmd = NULL; \
	ctp->cd_SendRWCmdBig = mdac_send_newcmd_big; \
}

/* set controller addresses */
#define mdac_setctladdrs(ctp,va,mboxreg,statreg,intrreg,localreg,systemreg,errstatreg) \
{ \
	ctp->cd_MailBox = (va) + (mboxreg); \
	ctp->cd_CmdIDStatusReg = ctp->cd_MailBox + (statreg); \
	ctp->cd_DacIntrMaskReg = (va) + (intrreg); \
	ctp->cd_LocalDoorBellReg = (va) + (localreg); \
	ctp->cd_SystemDoorBellReg = (va) + (systemreg); \
	ctp->cd_ErrorStatusReg = (va) + (errstatreg); \
}

/* complete the given request */
#define mdac_completereq(ctp,rqp) \
{ \
	if (ctp->cd_TimeTraceEnabled) mdac_tracetime(rqp); \
	if (ctp->cd_CmdsWaiting) mdac_reqstart(ctp); \
	if (ctp->cd_OSCmdsWaiting) mdac_osreqstart(ctp); \
	rqp->rq_Next = NULL; \
	(*rqp->rq_CompIntr)(rqp); \
}

/* change the 16 byte command to 32 byte command if possible */
#define mdac_16to32bcmdiff(rqp) \
{ \
	if ((rqp->rq_SGLen == 2) && (rqp->rq_ctp->cd_Status & MDACD_HOSTMEMAILBOX32)) \
	{       /* setup 32 byte mailbox for read / write command */ \
		dcmdp->mb_Command = DACMD_READ_WITH2SG | (dcmdp->mb_Command&1); /* set new command with proper direction */ \
		dcmdp->mb_MailBox3 &= 0x7;      /* drop the old logical device number */ \
		dcmdp->mb_MailBoxD = rqp->rq_SysDevNo; \
		dcmd32p->mb_MailBox10_13 = rqp->rq_SGList[0].sg_PhysAddr; \
		dcmd32p->mb_MailBox14_17 = rqp->rq_SGList[0].sg_DataSize; \
		dcmd32p->mb_MailBox18_1B = rqp->rq_SGList[1].sg_PhysAddr; \
		dcmd32p->mb_MailBox1C_1F = rqp->rq_SGList[1].sg_DataSize; \
	} \
	else if ((rqp->rq_SGLen > 33) && (rqp->rq_ctp->cd_Status & MDACD_HOSTMEMAILBOX32)) \
	{       /* setup 32 byte mailbox for large read / write command */ \
		dcmdp->mb_Command = DACMD_READ_WITH2SG | DACMD_WITHSG | (dcmdp->mb_Command&1); /* set new command with proper direction */ \
		dcmdp->mb_MailBox3 &= 0x7;      /* drop the old logical device number */ \
		dcmdp->mb_MailBoxD = rqp->rq_SysDevNo; \
	} \
}

/* setup 64 byte command memory address */
#define mdac_setupnewcmdmem(rqp) \
{ \
	MLXSWAP(ncmdp->nc_ReqSensep); \
	ncmdp->nc_TxSize = (u32bits)rqp->rq_DMASize; MLXSWAP(ncmdp->nc_TxSize); \
	if (rqp->rq_SGLen) \
	{ \
		if (rqp->rq_SGLen <= 2) \
		{       /* Create two SG entries as part of command */ \
			mdac_sglist64b_t MLXFAR *sgp = (mdac_sglist64b_t MLXFAR *)rqp->rq_SGVAddr; \
			ncmdp->nc_SGList0 = *(sgp+0); \
			if (rqp->rq_SGLen == 2) \
				ncmdp->nc_SGList1 = *(sgp+1); \
			ncmdp->nc_CCBits &= ~MDACMDCCB_WITHSG; \
		} \
		else \
		{ \
			nsgp->ncsg_ListLen0=(u16bits)rqp->rq_SGLen; MLXSWAP(nsgp->ncsg_ListLen0); \
			nsgp->ncsg_ListPhysAddr0 = rqp->rq_DMAAddr; MLXSWAP(nsgp->ncsg_ListPhysAddr0); \
			ncmdp->nc_CCBits |= MDACMDCCB_WITHSG; \
		} \
	} \
	else \
	{ \
		ncmdp->nc_SGList0.sg_PhysAddr = rqp->rq_DMAAddr; MLXSWAP(ncmdp->nc_SGList0.sg_PhysAddr); \
		ncmdp->nc_SGList0.sg_DataSize.bit31_0 = rqp->rq_DMASize; MLXSWAP(ncmdp->nc_SGList0.sg_DataSize); \
		ncmdp->nc_CCBits &= ~MDACMDCCB_WITHSG; \
	} \
}

/* transfer the status and residue values */

#define mdac_setiostatus(ctp, status)	\
{	\
	if (ctp->cd_Status & MDACD_NEWCMDINTERFACE) \
	{ \
		if (dcmdp->mb_Status = (u16bits )(status & 0x00FF) )	\
		{       /* transfer other information */	\
			rqp->rq_HostStatus = (u08bits )(status & 0x00FF);	\
			rqp->rq_TargetStatus = (u08bits )(status>>8) & 0x00FF;	\
			if (rqp->rq_HostStatus == UCST_CHECK)	\
			{	\
				ncmdp->nc_SenseSize = rqp->rq_TargetStatus;	\
				rqp->rq_TargetStatus = 0;	\
			}	\
		}	\
	} else \
	{ \
		if (dcmdp->mb_Status = status) \
		{       /* transfer other information */ \
			rqp->rq_HostStatus = (u08bits )(dcmdp->mb_Status>>8) & 0xFF; \
			rqp->rq_TargetStatus = (u08bits )(dcmdp->mb_Status & 0xFF); \
		} \
	} \
	rqp->rq_ResdSize+=(rqp->rq_CurIOResdSize=ctp->cd_LastCmdResdSize);	\
	/* seems we need to adjust rqp->rq_DataOffset also */	\
}

#ifdef MLX_DOS
#define setreqdetailsnew(rqp,cmd) \
{ \
	rqp->rq_FinishTime=mda_CurTime + (rqp->rq_TimeOut=ncmdp->nc_TimeOut=17);\
	ncmdp->nc_Command = MDACMD_IOCTL; \
	ncmdp->nc_CCBits = MDACMDCCB_READ; \
	ncmdp->nc_Sensep.bit31_0 = 0;\
	ncmdp->nc_Sensep.bit63_32=0;\
	ncmdp->nc_SenseSize=0; \
	ncmdp->nc_SubIOCTLCmd = cmd;\
}
#endif
/*------------------------------------------------------------------*/

#ifdef  MLX_SCO
#include "mdacsco.c"
#elif   MLX_UW
#include "mdacuw.c"
#elif NETWARE
#include "mdacnw.c"
#elif MLX_NT
#include "mdacnt.c"
#elif   MLX_DOS
#include "mdacdos.c"
#elif MLX_WIN9X
#include "mdacnt.c"
#elif MLX_SOL_SPARC
#include "mdacslsp.c"
#elif MLX_SOL_X86
#include "mdacsl86.c"
#elif MLX_OS2
#include "mdacos2.c"
#endif  /* OS specific functions */

uosword MLXFAR
mdac_setb(dp,val,sz)
u08bits MLXFAR* dp;
uosword val, sz;
{
	for (; sz; dp++, sz--) 
		*dp = (u08bits) val;
	return sz;
}


#if defined(MLX_OS2) || defined(MLX_WIN31) || defined(MLX_SOL)
u32bits MLXFAR
mdac_copy(sp,dp,sz)
u08bits MLXFAR *sp;
u08bits MLXFAR *dp;
u32bits sz;
{
	for(; sz ; sp++,dp++,sz--) *dp = *sp;
	return 0;
}

u32bits MLXFAR
mdac_zero(dp,sz)
u08bits MLXFAR *dp;
u32bits sz;
{
	for (; sz; dp++, sz--) *dp = 0;
	return 0;
}
#else
u32bits MLXFAR
mdac_copy(sp,dp,sz)
u08bits MLXFAR *sp;
u08bits MLXFAR *dp;
u32bits sz;
{
	u32bits resd = sz % sizeof(u32bits);
	sz = sz / sizeof(u32bits);      /* get 32bits count value */
	for(; sz; sp+=sizeof(u32bits), dp += sizeof(u32bits), sz--)
		*((u32bits MLXFAR*)dp) = *((u32bits MLXFAR*)sp);
	for (sz=resd; sz; sp++, dp++, sz--) *dp = *sp;
	return 0;
}

u32bits MLXFAR
mdac_zero(dp,sz)
u08bits MLXFAR *dp;
u32bits sz;
{
	u32bits resd = sz % sizeof(u32bits);
	sz = sz / sizeof(u32bits);      /* get 32bits count value */
	for(; sz; dp+=sizeof(u32bits), sz--)
		*((u32bits MLXFAR*)dp) = 0;
	for (sz=resd; sz; dp++, sz--)
		*dp = 0;
	return 0;
}
#endif /* MLX_OS2 || MLX_WIN31 */

/* it will compare two strings with ? ignored. return 0 if match, else 1 */
uosword MLXFAR
mdac_strcmp(sp,dp,sz)
u08bits MLXFAR *sp;
u08bits MLXFAR *dp;
UINT_PTR sz;
{
	for (; sz; sp++, dp++, sz--)
	{
		if ((*sp) == (*dp)) continue;
		if ((*sp == (u08bits)'?') || (*dp == (u08bits)'?')) continue;
		return 1;
	}
	return 0;
}

u32bits MLXFAR
mdac_cmp(sp,dp,sz)
u08bits MLXFAR* sp;
u08bits MLXFAR* dp;
u32bits sz;
{
	for (; sz; sp++, dp++, sz--)
		if ((*sp) != (*dp)) return 1;
	return 0;
}

size_t  MLXFAR
mdac_strlen(sp)
u08bits MLXFAR* sp;
{
	u08bits MLXFAR *s0;
	for (s0=sp; *sp; sp++);
	return sp - s0;
}

/* Convert a binary number to an HEX Ascii NULL terminated string, return string address */
u08bits MLXFAR*
mdac_bin2hexstr(sp,val)
u08bits MLXFAR* sp;
u32bits val;
{
	u32bits inx;
	u08bits MLXFAR *ssp = sp;
	u08bits buf[16];
	for (inx=0,buf[0]='0'; val; val=val>>4)
		buf[inx++] = mdac_hexd[val & 0xF];
	if (!inx) inx++;
	while (inx)
		*sp++ = buf[--inx];
	*sp = 0;
	return ssp;
}
 
u08bits MLXFAR *
mdac_allocmem(ctp,sz)
mdac_ctldev_t MLXFAR *ctp;
u32bits sz;
{
	u08bits MLXFAR *mp = (u08bits MLXFAR *)mlx_allocmem(ctp,sz);
	if (mp) mdaczero(mp,sz);
	return mp;
}

/* generate the busname in string */
u08bits  MLXFAR *
mdac_bus2str(bustype)
u32bits bustype;
{
	static u08bits ds[16];
	switch(bustype)
	{
	case DAC_BUS_EISA:      return (u08bits MLXFAR *)"EISA";
	case DAC_BUS_MCA:       return (u08bits MLXFAR *)"MCA ";
	case DAC_BUS_PCI:       return (u08bits MLXFAR *)"PCI ";
	case DAC_BUS_VESA:      return (u08bits MLXFAR *)"VESA";
	case DAC_BUS_ISA:       return (u08bits MLXFAR *)"ISA ";
	}
	ds[0] = ((bustype>>4)&0xF)+'0'; ds[1] = (bustype&0xF)+'0';
	return ds;
}

u08bits MLXFAR *
mdac_ctltype2str(ctltype)
u32bits ctltype;
{
	static u08bits ds[16];
	switch(ctltype)
	{
	case DACTYPE_DAC960E:   return (u08bits MLXFAR *)"DAC960E         ";
	case DACTYPE_DAC960M:   return (u08bits MLXFAR *)"DAC960M         ";
	case DACTYPE_DAC960PD:  return (u08bits MLXFAR *)"DAC960PD        ";
	case DACTYPE_DAC960PL:  return (u08bits MLXFAR *)"DAC960PL        ";
	case DACTYPE_DAC960PDU: return (u08bits MLXFAR *)"DAC960PDU       ";
	case DACTYPE_DAC960PE:  return (u08bits MLXFAR *)"DAC960PE        ";
	case DACTYPE_DAC960PG:  return (u08bits MLXFAR *)"DAC960PG        ";
	case DACTYPE_DAC960PJ:  return (u08bits MLXFAR *)"DAC960PJ        ";
	case DACTYPE_DAC960PTL0:return (u08bits MLXFAR *)"DAC960PTL0      ";
	case DACTYPE_DAC960PTL1:return (u08bits MLXFAR *)"DAC960PTL1      ";
	case DACTYPE_DAC960PR:  return (u08bits MLXFAR *)"DAC960PR        ";
	case DACTYPE_DAC960PRL: return (u08bits MLXFAR *)"DAC960PRL       ";
	case DACTYPE_DAC960PT:  return (u08bits MLXFAR *)"DAC960PT        ";
	case DACTYPE_DAC1164P:  return (u08bits MLXFAR *)"DAC1164P        ";
	}
	ds[0] = ((ctltype>>4)&0xF)+'0'; ds[1] = (ctltype&0xF)+'0';
	for (ctltype=2; ctltype<USCSI_PIDSIZE; ctltype++) ds[ctltype] = ' ';
	return ds;
}

u08bits MLXFAR *
mdac_ctltype2stronly(ctp)
mdac_ctldev_t   MLXFAR *ctp;
{
	u32bits inx;
	static u08bits ds[17];
		u08bits u08Count=0;
	u08bits MLXFAR  *sp = ctp->cd_ControllerName;
	for (inx=0; inx<16; inx++)
		{
	    if ( ( (ds[inx]=sp[inx]) == 0x20) )
			{ 
				if (u08Count) break;
				else u08Count++;
			}
		}
	ds[inx] = 0;
	return ds;
}

/* set controller functions */
void
mdac_setctlfuncs(mdac_ctldev_t   MLXFAR *ctp,
				 void (MLXFAR * disintr)(struct  mdac_ctldev MLXFAR *),
				 void (MLXFAR * enbintr)(struct  mdac_ctldev MLXFAR *),
				 u32bits (MLXFAR * rwstat)(struct  mdac_ctldev MLXFAR *),
				 u32bits (MLXFAR * ckmbox)(struct  mdac_ctldev MLXFAR *),
				 u32bits (MLXFAR * ckintr)(struct  mdac_ctldev MLXFAR *),
				 u32bits (MLXFAR * sendcmd)(mdac_req_t MLXFAR *rqp),
				 u32bits (MLXFAR * reset)(struct  mdac_ctldev MLXFAR *)
				 ) 
{ 
	ctp->cd_DisableIntr = disintr; 
	ctp->cd_EnableIntr = enbintr; 
	ctp->cd_ReadCmdIDStatus = rwstat; 
	ctp->cd_CheckMailBox = ckmbox; 
	ctp->cd_PendingIntr =  ckintr; 
	ctp->cd_SendCmd =  sendcmd; 
	ctp->cd_ResetController = reset; 
}



/* #if defined(_WIN64) || defined(SCSIPORT_COMPLIANT)  */
/* #ifdef NEVER */  // there are too many problems associated w/ the time trace stuff


#ifndef MLX_DOS
/* Get the first valid time trace data to user */
u32bits MLXFAR
mdac_firstimetracedata(ttip)
mda_timetrace_info_t MLXFAR *ttip;
{
	mdac_ttbuf_t MLXFAR *ttbp;
	for (ttip->tti_PageNo=0xFFFFFFFF, ttbp=mdac_ttbuftbl; ttbp<mdac_ttbuftblend; ttbp++)
		if ((ttbp->ttb_PageNo < ttip->tti_PageNo) && ttbp->ttb_Datap) ttip->tti_PageNo = ttbp->ttb_PageNo;
	return mdac_getimetracedata(ttip);
}

/* get the trace data information, enter interrupt protected */
u32bits MLXFAR
mdac_getimetracedata(ttip)
mda_timetrace_info_t MLXFAR *ttip;
{
	mdac_ttbuf_t MLXFAR *ttbp;
	for (ttbp=mdac_ttbuftbl; ttbp<mdac_ttbuftblend; ttbp++)
	{
		if (!ttbp->ttb_Datap) break;    /* No more buffers */
		if (ttbp->ttb_PageNo != ttip->tti_PageNo) continue;
		ttip->tti_DataSize = ttbp->ttb_DataSize;
		return MLXERR_FAULT;	// until we design a compliant way of copying kernel to user space

//		return mlx_copyout(ttbp->ttb_Datap,ttip->tti_Datap,ttip->tti_DataSize)? MLXERR_FAULT : 0;
	}
	return mdac_ttbuftbl[0].ttb_Datap? MLXERR_NOENTRY : MLXERR_NOACTIVITY;
}

/* flush the time trace data information, enter interrupt protected */
u32bits MLXFAR
mdac_flushtimetracedata(ttip)
mda_timetrace_info_t MLXFAR *ttip;
{
	mdac_ttbuf_t MLXFAR *ttbp;
	mdac_timetrace_lock();
	for (ttbp=mdac_ttbuftbl; ttbp<mdac_ttbuftblend; ttbp++)
		if (ttbp->ttb_Datap) ttbp->ttb_PageNo = 0xFFFFFFFF;
	if (mdac_ttbuftbl[0].ttb_Datap) mdac_ttstartnewpage();
	mdac_timetrace_unlock();
	return mdac_ttbuftbl[0].ttb_Datap? 0 : MLXERR_NOACTIVITY;
}
#endif /* MLX_DOS */

/* Allocate memory for time trace buffer. Enter interrupt protected */
u32bits MLXFAR
mdac_allocmemtt(ents)
u32bits ents;
{
	mdac_ttbuf_t MLXFAR *ttbp;
	u32bits sz=((ents*mda_timetrace_s)+MDAC_PAGEOFFSET) & MDAC_PAGEMASK;
	return  MLXERR_NOMEM; // because of compliance problems in mdac_ttstartnewpage!
#ifdef NEVER
	mdac_timetrace_lock();
	ents = (u32bits)mdac_ttbuftbl[0].ttb_Datap;     /* 0 for first time */
	for (ttbp=mdac_ttbuftbl; (ttbp<mdac_ttbuftblend) && sz; ttbp++, sz-=MDAC_PAGESIZE)
	{
		if (ttbp->ttb_Datap) continue;
		mdac_timetrace_unlock();
		ttbp->ttb_Datap = (u08bits MLXFAR*)mdac_alloc4kb(mdac_ctldevtbl); /* we may loose memory */
		mdac_timetrace_lock();
	}
	for (ttbp=mdac_ttbuftbl; ttbp<&mdac_ttbuftbl[MDAC_MAXTTBUFS-1]; ttbp++)
		if (!((ttbp+1)->ttb_Datap)) break;
		else ttbp->ttb_Next = ttbp+1;
	ttbp->ttb_Next = mdac_ttbuftbl;
	if (mdac_ttbuftbl[0].ttb_Datap && !ents) mdac_ttstartnewpage(); /* only first time */
	mdac_timetrace_unlock();
	return mdac_ttbuftbl[0].ttb_Datap? 0 : MLXERR_NOMEM;
#endif
}

#ifndef MLX_DOS
/* starts the next page for tracing, mdac_timetrace_lock must be held */
void    MLXFAR
mdac_ttstartnewpage()
{
	u32bits tm = MLXCLBOLT();
	mdac_ttbuf_t            MLXFAR  *ttbp = mdac_curttbp;
	mlxperf_abstime_t       MLXFAR  *abstimep;
	ttbp->ttb_Datap[ttbp->ttb_DataSize] = MLXPERF_UNUSEDSPACE;
	ttbp->ttb_DataSize = MDAC_PAGESIZE;
	mdac_curttbp = ttbp = ttbp->ttb_Next;
	ttbp->ttb_DataSize = 0;
	ttbp->ttb_PageNo = ++mda_ttCurPage;
	abstimep = (mlxperf_abstime_t MLXFAR*)ttbp->ttb_Datap;
	abstimep->abs_RecordType = MLXPERF_ABSTIME;
	abstimep->abs_Time10ms0 = (u08bits)(tm & 0xFF);
	abstimep->abs_Time10ms1 = (u08bits)((tm>>8) & 0xFF);
	abstimep->abs_Time10ms2 = (u08bits)((tm>>16) & 0xFF);
	abstimep->abs_Time = MLXCTIME();
	abstimep++;             /* points to time trace record */
#define mpttp   ((mlxperf_timetrace_t MLXFAR*)abstimep)
	mpttp->tt_RecordType = MLXPERF_TIMETRACE;
	mpttp->tt_TraceSize = mlxperf_timetrace_s;
	ttbp->ttb_DataSize = mlxperf_abstime_s + mlxperf_timetrace_s;
#undef  mpttp
	if (mda_ttWaitCnts) mdac_wakeup((u32bits MLXFAR *)&mdac_ttwaitchan);
}

/* Do time trace for one command which just finished */
u32bits MLXFAR
mdac_tracetime(rqp)
mdac_req_t MLXFAR *rqp;
{
	mda_timetrace_t MLXFAR *ttp;
	mdac_timetrace_lock();
	if (mdac_curttbp->ttb_DataSize > (MDAC_PAGESIZE-mda_timetrace_s))
		mdac_ttstartnewpage();  /* start a new page */
	ttp = (mda_timetrace_t MLXFAR*)(mdac_curttbp->ttb_Datap+mdac_curttbp->ttb_DataSize);
	MLXSTATS(mda_TimeTraceDone++;)
	ttp->tt_ControllerNo = rqp->rq_ctp->cd_ControllerNo;
	ttp->tt_OpStatus = (dcmdp->mb_Status)? MDAC_TTOPS_ERROR : 0;
	if ((((ttp->tt_FinishTime=MLXCLBOLT())-rqp->rq_ttTime)>5) || !mdac_tthrtime)
	{
		ttp->tt_HWClocks = ttp->tt_FinishTime - rqp->rq_ttTime;
		ttp->tt_OpStatus |= MDAC_TTOPS_HWCLOCKS10MS;
	}
	else
	{
		u32bits clk = mdac_read_hwclock();
		if (!(ttp->tt_HWClocks = mlxclkdiff(clk,rqp->rq_ttHWClocks))) mdac_enable_hwclock();
	}
	if (rqp->rq_ctp->cd_Status & MDACD_NEWCMDINTERFACE)
	{       /* this is new interface */
		ttp->tt_DevNo = mdac_chantgt(rqp->rq_ChannelNo,rqp->rq_TargetID);
		ttp->tt_IOSizeBlocks = rqp->rq_DMASize/DAC_BLOCKSIZE;
		if (ncmdp->nc_CCBits & MDACMDCCB_READ) ttp->tt_OpStatus |= MDAC_TTOPS_READ;
		if (ncmdp->nc_CCBits & MDACMDCCB_WITHSG) ttp->tt_OpStatus|=MDAC_TTOPS_WITHSG;
		switch (ncmdp->nc_Command)
		{
		case MDACMD_SCSI:
		case MDACMD_SCSILC:
		case MDACMD_SCSIPT:
		case MDACMD_SCSILCPT:
			ttp->tt_OpStatus |= MDAC_TTOPS_SCDB;
			switch(ttp->tt_Cmd=nscdbp->ucs_cmd)
			{
			case UCSCMD_EREAD:
			case UCSCMD_EWRITE:
			case UCSCMD_EWRITEVERIFY:
				ttp->tt_BlkNo = UCSGETG1ADDR(scdbp);
				break;
			case UCSCMD_READ:
			case UCSCMD_WRITE:
				ttp->tt_BlkNo = UCSGETG0ADDR(scdbp);
				break;
			default: ttp->tt_BlkNo = 0; break;
			}
			break;

		case MDACMD_IOCTL:
			ttp->tt_Cmd = ncmdp->nc_SubIOCTLCmd;
			ttp->tt_BlkNo = 0;
			break;
		}
		goto tracedone;
	}
	if (dcmdp->mb_Command&DACMD_WITHSG) ttp->tt_OpStatus|=MDAC_TTOPS_WITHSG;
	ttp->tt_Cmd = dcmdp->mb_Command;
	switch(dcmdp->mb_Command & ~DACMD_WITHSG)
	{
	case DACMD_DCDB:
		ttp->tt_OpStatus |= MDAC_TTOPS_SCDB;
		if (mdac_getcdbtxsize()) ttp->tt_OpStatus |= MDAC_TTOPS_RESID;
		ttp->tt_IOSizeBlocks = rqp->rq_ResdSize/DAC_BLOCKSIZE;
		ttp->tt_DevNo = dcdbp->db_ChannelTarget;
		if ((dcdbp->db_DATRET&DAC_DCDB_XFER_MASK)!=DAC_XFER_WRITE)
			ttp->tt_OpStatus |= MDAC_TTOPS_READ;
		switch(ttp->tt_Cmd=scdbp->ucs_cmd)
		{
		case UCSCMD_EREAD:
		case UCSCMD_EWRITE:
		case UCSCMD_EWRITEVERIFY:
			ttp->tt_BlkNo = UCSGETG1ADDR(scdbp);
			break;
		case UCSCMD_READ:
		case UCSCMD_WRITE:
			ttp->tt_BlkNo = UCSGETG0ADDR(scdbp);
			break;
		default: ttp->tt_BlkNo = 0; break;
		}
		break;
	case DACMD_WRITE_V2x:
	case DACMD_READ_V2x:
		ttp->tt_BlkNo = dcmdp->mb_MailBox4 + (dcmdp->mb_MailBox5<<8)+
			(dcmdp->mb_MailBox6<<16)+((dcmdp->mb_MailBox3&0xC0)<<(24-6));
		ttp->tt_IOSizeBlocks=dcmdp->mb_MailBox2+((dcmdp->mb_MailBox3&0x3F)<<8);
		ttp->tt_DevNo = dcmdp->mb_SysDevNo;
		if (!(dcmdp->mb_Command&1)) ttp->tt_OpStatus|=MDAC_TTOPS_READ;
		break;
	case DACMD_WRITE_OLD_V3x:
	case DACMD_READ_OLD_V3x:
		ttp->tt_BlkNo = mlxswap(dcmd4p->mb_MailBox4_7);
		ttp->tt_IOSizeBlocks=dcmdp->mb_MailBox2+((dcmdp->mb_MailBox3&0x7)<<8);
		ttp->tt_DevNo = dcmdp->mb_MailBox3 >> 3;
		if (!(dcmdp->mb_Command&1)) ttp->tt_OpStatus|=MDAC_TTOPS_READ;
		break;
	case DACMD_WRITE_WITH2SG:
	case DACMD_READ_WITH2SG:
		ttp->tt_BlkNo = mlxswap(dcmd4p->mb_MailBox4_7);
		ttp->tt_IOSizeBlocks=dcmdp->mb_MailBox2+(dcmdp->mb_MailBox3<<8);
		ttp->tt_DevNo = dcmdp->mb_MailBoxD;
		if (!(dcmdp->mb_Command&1)) ttp->tt_OpStatus|=MDAC_TTOPS_READ;
		break;
	case DACMD_WRITE_V3x:
	case DACMD_READ_V3x:
		ttp->tt_BlkNo = mlxswap(dcmd4p->mb_MailBox4_7);
		ttp->tt_IOSizeBlocks=dcmdp->mb_MailBox2+(dcmdp->mb_MailBox3<<8);
		ttp->tt_DevNo = dcmdp->mb_MailBoxC;
		if (dcmdp->mb_Command&1) ttp->tt_OpStatus|=MDAC_TTOPS_READ;
		break;
	case DACMD_PHYSDEV_STATE_V2x:
	case DACMD_PHYSDEV_STATE_V3x:
		ttp->tt_BlkNo = 0; ttp->tt_IOSizeBlocks = 0;
		ttp->tt_DevNo = ChanTgt(dcmdp->mb_ChannelNo,dcmdp->mb_TargetID);
		ttp->tt_OpStatus |= MDAC_TTOPS_READ;
		break;
	default:
		ttp->tt_BlkNo = 0; ttp->tt_IOSizeBlocks = 0; ttp->tt_DevNo = 0;
		ttp->tt_OpStatus |= MDAC_TTOPS_READ;
		break;
	}
tracedone:
	mdac_curttbp->ttb_DataSize += mda_timetrace_s;
	((mlxperf_timetrace_t MLXFAR*)(mdac_curttbp->ttb_Datap+mlxperf_abstime_s))->tt_TraceSize += mda_timetrace_s;
	mdac_timetrace_unlock();
	return 0;
}
#endif /* MLX_DOS */

/* #endif */   // ifdef NEVER
/* #endif */  //  if _WIN64 or SCSIPORT_COMPLIANT




/*==========================MEMORY MANAGEMENT STARTS========================*/
/* memory allocation and freeing functions, enter here interrupt protected */
mdac_mem_t MLXFAR *
mdac_alloc4kb(ctp)
mdac_ctldev_t MLXFAR *ctp;
{
	mdac_mem_t MLXFAR *mp;
	mdac_link_lock();

	if (mp=ctp->cd_4KBMemList)
	{
		ctp->cd_4KBMemList = mp->dm_next;
		ctp->cd_FreeMemSegs4KB--;
		mdac_link_unlock();
		mdaczero(mp,4*ONEKB);
		return mp;
	}
	mdac_link_unlock();
	if (!(mp = (mdac_mem_t MLXFAR *)mlx_alloc4kb(ctp)))
	{
	     return mp;
	}
	if (((UINT_PTR) mp) & MDAC_PAGEOFFSET) ctp->cd_MemUnAligned4KB++;
	MLXSTATS(ctp->cd_MemAlloced4KB += 4*ONEKB);
	mdaczero(mp,4*ONEKB);
	return mp;
}


void    MLXFAR
mdac_free4kb(ctp,mp)
mdac_ctldev_t MLXFAR *ctp;
mdac_mem_t MLXFAR *mp;
{
	if (ctp->cd_FreeMemSegs4KB >= MDAC_MAX4KBMEMSEGS)
	{
		mlx_free4kb(ctp,(u08bits *)mp);
		MLXSTATS(ctp->cd_MemAlloced4KB -= 4*ONEKB;)
		return;
	}
	mdac_link_lock();
	mp->dm_Size = 4*ONEKB;
	mp->dm_next = ctp->cd_4KBMemList;
	ctp->cd_4KBMemList = mp;
	ctp->cd_FreeMemSegs4KB++;
	mdac_link_unlock();
}

mdac_mem_t MLXFAR *
mdac_alloc8kb(ctp)
mdac_ctldev_t MLXFAR *ctp;
{
	mdac_mem_t MLXFAR *mp;
	mdac_link_lock();
	if (mp=ctp->cd_8KBMemList)
	{
		ctp->cd_8KBMemList = mp->dm_next;
		ctp->cd_FreeMemSegs8KB--;
		mdac_link_unlock();
		mdaczero(mp,8*ONEKB);
		return mp;
	}
	mdac_link_unlock();
	if (!(mp = (mdac_mem_t MLXFAR *)mlx_alloc8kb(ctp))) return mp;
	if (((UINT_PTR) mp) & MDAC_PAGEOFFSET) ctp->cd_MemUnAligned8KB++;
	MLXSTATS(ctp->cd_MemAlloced8KB += 8*ONEKB);
	mdaczero(mp,8*ONEKB);
	return mp;
}

void    MLXFAR
mdac_free8kb(ctp,mp)
mdac_ctldev_t MLXFAR *ctp;
mdac_mem_t MLXFAR *mp;
{
	if (ctp->cd_FreeMemSegs8KB >= (4*MDAC_MAX8KBMEMSEGS))
	{
		mlx_free8kb(ctp,(u08bits *)mp);
		MLXSTATS(ctp->cd_MemAlloced8KB -= 8*ONEKB;)
		return;
	}
	mdac_link_lock();
	mp->dm_Size = 8*ONEKB;
	mp->dm_next = ctp->cd_8KBMemList;
	ctp->cd_8KBMemList = mp;
	ctp->cd_FreeMemSegs8KB++;
	mdac_link_unlock();
}

/* allocate new req buffers and return count */
u32bits MLXFAR
mdac_allocreqbufs(ctp, nb)
mdac_ctldev_t MLXFAR *ctp;
u32bits nb;
{
	u32bits inx,cnt=0;
	mdac_req_t MLXFAR *rqp;
	for (nb=(nb/((4*ONEKB)/mdac_req_s)+1); nb; nb--)
	{       /* allocate the required buffers for this controller */
		if (!(rqp=(mdac_req_t MLXFAR *)mdac_alloc4kb(ctp))) break;
		mdac_link_lock();
		for (inx=(4*ONEKB)/mdac_req_s; inx; rqp++,cnt++,inx--)
		{
			mlx_kvtophyset(rqp->rq_PhysAddr,ctp,rqp);
			rqp->rq_Next = ctp->cd_FreeReqList;
			ctp->cd_FreeReqList= rqp;
			rqp->rq_SGVAddr = (mdac_sglist_t MLXFAR *)&rqp->rq_SGList;
			mlx_kvtophyset(rqp->rq_SGPAddr,ctp,rqp->rq_SGVAddr);
			rqp->rq_MaxSGLen = (ctp->cd_Status & MDACD_NEWCMDINTERFACE)? MDAC_MAXSGLISTSIZENEW : MDAC_MAXSGLISTSIZE;
			rqp->rq_MaxDMASize = (rqp->rq_MaxSGLen & ~1) * MDAC_PAGESIZE;
			MLXSTATS(ctp->cd_ReqBufsAlloced++;ctp->cd_ReqBufsFree++;)
		}
		mdac_link_unlock();
	}
	return cnt;
}

/* set up large SG List address for the system */
u08bits MLXFAR *
mdac_setuplsglvaddr(rqp)
mdac_req_t      MLXFAR *rqp;
{
	mdac_ctldev_t   MLXFAR  *ctp = rqp->rq_ctp;
	if (!(rqp->rq_LSGVAddr = (u08bits MLXFAR *)mdac_alloc4kb(ctp))) return rqp->rq_LSGVAddr;
	rqp->rq_SGVAddr = (mdac_sglist_t MLXFAR *)rqp->rq_LSGVAddr;
	mlx_kvtophyset(rqp->rq_SGPAddr,ctp,rqp->rq_LSGVAddr);
	rqp->rq_MaxSGLen = mlx_min(ctp->cd_MaxSGLen, MDAC_PAGESIZE/mdac_sglist64b_s);
	rqp->rq_MaxDMASize = (rqp->rq_MaxSGLen  & ~1) * MDAC_PAGESIZE;
	return rqp->rq_LSGVAddr;
}

/* adjust the maximum dma size information in request buffer list */
u32bits MLXFAR
mdac_setnewsglimit(rqp,sglen)
mdac_req_t      MLXFAR *rqp;
u32bits sglen;
{
	for (; rqp; rqp=rqp->rq_Next)
	{       /* adjust all rq_MaxSGLen based on the controller value */
		rqp->rq_MaxSGLen = mlx_min(rqp->rq_MaxSGLen, sglen);
		rqp->rq_MaxDMASize = (rqp->rq_MaxSGLen & ~1) * MDAC_PAGESIZE;
	}
	return 0;
}
/*==========================MEMORY MANAGEMENT ENDS======================*/

/*==========================OS INTERFACE STARTS=========================*/
u32bits MLXFAR
mdacopen(devp, flag, type, cred_p)
{
	return 0;
}

u32bits MLXFAR
mdacclose(dev, flag, cred_p)
{
	return 0;
}

/* This function is called on shutdown and interrupt is protected */
#if     MLX_SCO || MLX_UW
void    MLXFAR
mdachalt()
{
	mdac_ctldev_t MLXFAR *ctp;
	MLXSPLVAR;

	MLXSPL();
	for(ctp = mdac_ctldevtbl; ctp < mdac_lastctp; ctp++)
	{
		if (!(ctp->cd_Status&MDACD_PRESENT)) continue;
		if (ctp->cd_ActiveCmds)
			cmn_err(CE_CONT,"WARNING: Incomplete %d I/Os at halt time\n",ctp->cd_ActiveCmds);
		cmn_err(CE_CONT,"Flushing Controller : %d %s cache ... ",
			ctp->cd_ControllerNo, ctp->cd_ControllerName);
		if (mdac_flushcache(ctp)) cmn_err(CE_CONT,"Failed ");
		cmn_err(CE_CONT,"Done.\n");
	}
	MLXSPLX();
}
#endif  /* MLX_SCO || MLX_UW */

u32bits MLXFAR
mdacioctl(dev, cmd, dp)
u32bits dev, cmd;
u08bits MLXFAR *dp;
{
	MLXSPLVAR;
	u08bits params[MLXIOCPARM_SIZE];
	if ((cmd&MLXIOC_IN)&&(mlx_copyin(dp,params,MLXIOCPARM_LEN(cmd)))) return ERR_FAULT;
	MLXSPL();
	mdac_ioctl(dev,cmd,params);
	MLXSPLX();
	if ((cmd&MLXIOC_OUT)&&(mlx_copyout(params,dp,MLXIOCPARM_LEN(cmd)))) return ERR_FAULT;
	MLXSTATS(mda_IoctlsDone++;)
	return 0;
}

#define seterrandret(x) {((mda_time_t MLXFAR *)dp)->dtm_ErrorCode= (u32bits)x; return 0;}
#define ctlno2ctp(ctlno) \
{       /* translate controller no to controller ptr */ \
	if ((ctlno) >= mda_Controllers) goto out_nodev; \
	ctp = &mdac_ctldevtbl[ctlno]; \
} 


u32bits MLXFAR
reject_backdoor_request()
{
	return 1;
}


/* Enter here interrupt protected */
/* dev is same as Controller Number in the case of NT */
#ifdef MLX_OS2
u32bits MLXFAR _loadds 
#else
u32bits MLXFAR
#endif
mdac_ioctl(dev, cmd, dp)
u32bits dev, cmd;
u08bits MLXFAR *dp;
{
	mdac_ctldev_t MLXFAR *ctp;
	mdac_req_t    MLXFAR *temprqp;
    u08bits irql;

	((dga_driver_version_t MLXFAR *)dp)->dv_ErrorCode = 0;
#define scp     ((mda_controller_info_t MLXFAR *)dp)
#ifdef  WINNT_50
	if (MdacFirstIoctl)
	{
		/*
		** under W2K, don't start the watchdog timer till we are way past the 
		** loading/unloading of the hibernation driver
		*/
		mlx_timeout(mdac_timer,MDAC_IOSCANTIME);
		MdacFirstIoctl = 0;
	}
#endif

	if (cmd == MDACIOC_GETCONTROLLERINFO)
	{
		ctlno2ctp(scp->ci_ControllerNo);
		mdaczero(dp,mda_controller_info_s);
		scp->ci_ControllerNo = ctp->cd_ControllerNo;
		scp->ci_ControllerType = ctp->cd_ControllerType;
		scp->ci_MaxChannels = ctp->cd_MaxChannels;
		scp->ci_MaxTargets = ctp->cd_MaxTargets;
		scp->ci_MaxLuns = ctp->cd_MaxLuns;
		scp->ci_MaxSysDevs = ctp->cd_MaxSysDevs;
		scp->ci_MaxTags = ctp->cd_MaxTags;
		scp->ci_MaxCmds = ctp->cd_MaxCmds;
		scp->ci_ActiveCmds = ctp->cd_ActiveCmds;
		scp->ci_MaxDataTxSize = ctp->cd_MaxDataTxSize;
		scp->ci_MaxSCDBTxSize = ctp->cd_MaxSCDBTxSize;
		scp->ci_BusType = ctp->cd_BusType;
		scp->ci_BusNo = ctp->cd_BusNo;
		scp->ci_FuncNo = ctp->cd_FuncNo;
		scp->ci_SlotNo = ctp->cd_SlotNo;
		scp->ci_InterruptVector = ctp->cd_InterruptVector;
		scp->ci_InterruptType = ctp->cd_InterruptType;
		scp->ci_irq = ctp->cd_irq;
		scp->ci_IntrShared = ctp->cd_IntrShared;
		scp->ci_IntrActive = ctp->cd_IntrActive;
		scp->ci_FWVersion = ctp->cd_FWVersion;
		scp->ci_FWBuildNo = ctp->cd_FWBuildNo;
		scp->ci_FWTurnNo = ctp->cd_FWTurnNo;
		scp->ci_Status = ctp->cd_Status;
		scp->ci_TimeTraceEnabled = ctp->cd_TimeTraceEnabled;
		scp->ci_BaseAddr = ctp->cd_BaseAddr;
		scp->ci_BaseSize = ctp->cd_BaseSize;
		scp->ci_MemBasePAddr = ctp->cd_MemBasePAddr;
		scp->ci_MemBaseVAddr = ctp->cd_MemBaseVAddr;
		scp->ci_MemBaseSize = ctp->cd_MemBaseSize;
		scp->ci_IOBaseAddr = ctp->cd_IOBaseAddr;
		scp->ci_IOBaseSize = ctp->cd_IOBaseSize;
		scp->ci_BIOSAddr = ctp->cd_BIOSAddr;
		scp->ci_BIOSSize = ctp->cd_BIOSSize;
		scp->ci_BIOSHeads = ctp->cd_BIOSHeads;
		scp->ci_BIOSTrackSize = ctp->cd_BIOSTrackSize;
		scp->ci_MinorBIOSVersion = ctp->cd_MinorBIOSVersion;
		scp->ci_MajorBIOSVersion = ctp->cd_MajorBIOSVersion;
		scp->ci_InterimBIOSVersion = ctp->cd_InterimBIOSVersion;
		scp->ci_BIOSVendorName = ctp->cd_BIOSVendorName;
		scp->ci_BIOSBuildMonth = ctp->cd_BIOSBuildMonth;
		scp->ci_BIOSBuildDate = ctp->cd_BIOSBuildDate;
		scp->ci_BIOSBuildYearMS = ctp->cd_BIOSBuildYearMS;
		scp->ci_BIOSBuildYearLS = ctp->cd_BIOSBuildYearLS;
		scp->ci_BIOSBuildNo = ctp->cd_BIOSBuildNo;
		scp->ci_OSCap = ctp->cd_OSCap;
		scp->ci_vidpid = ctp->cd_vidpid;
		scp->ci_FreeCmdIDs = ctp->cd_FreeCmdIDs;
		scp->ci_OSCmdsWaited = ctp->cd_OSCmdsWaited;
		scp->ci_SCDBDone = ctp->cd_SCDBDone;
		scp->ci_SCDBDoneBig = ctp->cd_SCDBDoneBig;
		scp->ci_SCDBWaited = ctp->cd_SCDBWaited;
		scp->ci_SCDBWaiting = ctp->cd_SCDBWaiting;
		scp->ci_CmdsDone = ctp->cd_CmdsDone;
		scp->ci_CmdsDoneBig = ctp->cd_CmdsDoneBig;
		scp->ci_CmdsWaited = ctp->cd_CmdsWaited;
		scp->ci_CmdsWaiting = ctp->cd_CmdsWaiting;
		scp->ci_OSCmdsWaiting = ctp->cd_OSCmdsWaiting;
		scp->ci_MailBoxCmdsWaited = ctp->cd_MailBoxCmdsWaited;
		scp->ci_CmdTimeOutDone = ctp->cd_CmdTimeOutDone;
		scp->ci_CmdTimeOutNoticed = ctp->cd_CmdTimeOutNoticed;
		scp->ci_MailBoxTimeOutDone = ctp->cd_MailBoxTimeOutDone;
		scp->ci_PhysDevTestDone = ctp->cd_PhysDevTestDone;
		scp->ci_IntrsDone = ctp->cd_IntrsDone;
		scp->ci_IntrsDoneWOCmd = ctp->cd_IntrsDoneWOCmd;
		scp->ci_IntrsDoneSpurious = ctp->cd_IntrsDoneSpurious;
		scp->ci_CmdsDoneSpurious = ctp->cd_CmdsDoneSpurious;
		scp->ci_SpuriousCmdStatID = ctp->cd_SpuriousCmdStatID;
		scp->ci_MailBox = ctp->cd_MailBox;
		scp->ci_CmdIDStatusReg = ctp->cd_CmdIDStatusReg;
		scp->ci_BmicIntrMaskReg = ctp->cd_BmicIntrMaskReg;
		scp->ci_DacIntrMaskReg = ctp->cd_DacIntrMaskReg;
		scp->ci_LocalDoorBellReg = ctp->cd_LocalDoorBellReg;
		scp->ci_SystemDoorBellReg = ctp->cd_SystemDoorBellReg;
		scp->ci_DoorBellSkipped = ctp->cd_DoorBellSkipped;
		scp->ci_PDScanChannelNo = ctp->cd_PDScanChannelNo;
		scp->ci_PDScanTargetID = ctp->cd_PDScanTargetID;
		scp->ci_PDScanLunID = ctp->cd_PDScanLunID;
		scp->ci_PDScanValid = ctp->cd_PDScanValid;
		scp->ci_Ctp = (UINT_PTR MLXFAR *)ctp;
		mdaccopy(ctp->cd_ControllerName,scp->ci_ControllerName,USCSI_PIDSIZE);
		return 0;
	}
	if (cmd == MDACIOC_RESETALLCONTROLLERSTAT)
	{
		for(ctp=mdac_ctldevtbl; ctp<mdac_lastctp; ctp++)
			mdac_resetctlstat(ctp);
		mda_StrayIntrsDone=0; mda_IoctlsDone=0;
		mda_TimerDone=0; mda_TimeTraceDone=0;
		mda_ClustCompDone=0; mda_ClustCmdsDone=0;
		return 0;
	}
	if (cmd == MDACIOC_RESETCONTROLLERSTAT)
	{
		ctlno2ctp(scp->ci_ControllerNo);
		return mdac_resetctlstat(ctp);
	}
#undef  scp
#define pdsp    ((mda_physdev_stat_t MLXFAR *)dp)
	if (cmd == MDACIOC_GETPHYSDEVSTAT)
	{
		mdac_physdev_t MLXFAR *pdp;
		ctlno2ctp(pdsp->pds_ControllerNo);
		if (pdsp->pds_ChannelNo >= ctp->cd_MaxChannels) goto out_nodev;
		if (pdsp->pds_TargetID >= ctp->cd_MaxTargets) goto out_nodev;
		if (pdsp->pds_LunID >= ctp->cd_MaxLuns) goto out_nodev;
		pdp = dev2pdp(ctp,pdsp->pds_ChannelNo,pdsp->pds_TargetID,pdsp->pds_LunID);
		if (!(pdp->pd_Status & (MDACPDS_PRESENT|MDACPDS_BUSY))) goto out_nodev;
		pdsp->pds_DevType = pdp->pd_DevType;
		pdsp->pds_BlkSize = pdp->pd_BlkSize;
		pdsp->pds_Status = pdp->pd_Status;
		if (pdp->pd_FirstWaitingReq)pdsp->pds_Status|=MDACPDS_WAIT;
		return 0;
	}
#undef  pdsp
#ifndef MLX_DOS
#define ttip    ((mda_timetrace_info_t MLXFAR *)dp)
	if (cmd == MDACIOC_ENABLECTLTIMETRACE)
	{
		ctlno2ctp(ttip->tti_ControllerNo);
		if (ttip->tti_ErrorCode=mdac_allocmemtt(ttip->tti_MaxEnts)) return 0;
		ctp->cd_TimeTraceEnabled = 1;
out_tti0:       mdac_enable_hwclock();
		if (ttip->tti_MaxEnts & 1) mdac_tthrtime = 1;   /* enable high resolution timer */
out_tti:        ttip->tti_time = MLXCTIME();
		ttip->tti_ticks = MLXCLBOLT();
		ttip->tti_hwclocks = (unsigned short) mdac_read_hwclock();
		ttip->tti_LastPageNo = mda_ttCurPage;
		return 0;
	}
	if (cmd == MDACIOC_ENABLEALLTIMETRACE)
	{
		if (ttip->tti_ErrorCode=mdac_allocmemtt(ttip->tti_MaxEnts)) return 0;
		for(ctp=mdac_ctldevtbl; ctp<mdac_lastctp; ctp++)
			ctp->cd_TimeTraceEnabled = 1;
		goto out_tti0;
	}
	if (cmd == MDACIOC_DISABLECTLTIMETRACE)
	{
		ctlno2ctp(ttip->tti_ControllerNo);
		ctp->cd_TimeTraceEnabled = 0;
		goto out_tti;
	}
	if (cmd == MDACIOC_DISABLEALLTIMETRACE)
	{
		for(ctp=mdac_ctldevtbl; ctp<mdac_lastctp; ctp++)
			ctp->cd_TimeTraceEnabled = 0;
		mdac_tthrtime = 0;
		goto out_tti;
	}
	if (cmd == MDACIOC_WAITIMETRACEDATA)
	{       /* Timer will wakeup if not enough data */
		if (!mdac_ttbuftbl[0].ttb_Datap) seterrandret(ERR_NOACTIVITY);
		if ((ttip->tti_PageNo != (ttip->tti_LastPageNo=mda_ttCurPage)) &&
		   (!(ttip->tti_ErrorCode=mdac_getimetracedata(ttip))))
			goto out_tti;
		if (ttip->tti_PageNo<mda_ttCurPage) seterrandret(MLXERR_NOENTRY);
		mdac_sleep_lock();
		if (mdac_ttwaitime > (mda_CurTime+ttip->tti_TimeOut))
			mdac_ttwaitime = mda_CurTime+ttip->tti_TimeOut;
		mda_ttWaitCnts++;
		cmd = mdac_sleep(&mdac_ttwaitchan,MLX_WAITWITHSIGNAL);
		mda_ttWaitCnts--;
		mdac_sleep_unlock();
		if (cmd) seterrandret(MLXERR_INTRRUPT); /* we got signal */
		cmd = MDACIOC_GETIMETRACEDATA;  /* fall through */
	}
	if (cmd == MDACIOC_GETIMETRACEDATA)
	{
		ttip->tti_ErrorCode=mdac_getimetracedata(ttip);
		goto out_tti;
	}
	if (cmd == MDACIOC_FIRSTIMETRACEDATA)
	{
		ttip->tti_ErrorCode=mdac_firstimetracedata(ttip);
		goto out_tti;
	}
	if (cmd == MDACIOC_FLUSHALLTIMETRACEDATA)
	{
		ttip->tti_ErrorCode=mdac_flushtimetracedata(ttip);
		goto out_tti;
	}
#undef  ttip
#define pfp     ((mda_ctlsysperfdata_t MLXFAR *)dp)
	if (cmd == MDACIOC_GETCTLPERFDATA)
	{       /* get controller performance data */
		ctlno2ctp(pfp->prf_ControllerNo);
		mdaczero(dp,mda_ctlsysperfdata_s);
		pfp->prf_CmdTimeOutDone = ctp->cd_CmdTimeOutDone;
		pfp->prf_CmdTimeOutNoticed = ctp->cd_CmdTimeOutNoticed;
		pfp->prf_MailBoxTimeOutDone = ctp->cd_MailBoxTimeOutDone;
		pfp->prf_MailBoxCmdsWaited = ctp->cd_MailBoxCmdsWaited;
		pfp->prf_ActiveCmds = ctp->cd_ActiveCmds;
		pfp->prf_SCDBDone = ctp->cd_SCDBDone;
		pfp->prf_SCDBDoneBig = ctp->cd_SCDBDoneBig;
		pfp->prf_SCDBWaited = ctp->cd_SCDBWaited;
		pfp->prf_SCDBWaiting = ctp->cd_SCDBWaiting;
		pfp->prf_CmdsDone = ctp->cd_CmdsDone;
		pfp->prf_CmdsDoneBig = ctp->cd_CmdsDoneBig;
		pfp->prf_CmdsWaited = ctp->cd_CmdsWaited;
		pfp->prf_CmdsWaiting = ctp->cd_CmdsWaiting;
		pfp->prf_OSCmdsWaited = ctp->cd_OSCmdsWaited;
		pfp->prf_OSCmdsWaiting = ctp->cd_OSCmdsWaiting;
		pfp->prf_IntrsDoneSpurious = ctp->cd_IntrsDoneSpurious;
		pfp->prf_IntrsDone = ctp->cd_IntrsDone;
		pfp->prf_Reads = ctp->cd_Reads;
		pfp->prf_ReadsKB = ctp->cd_ReadBlks>>1;
		pfp->prf_Writes = ctp->cd_Writes;
		pfp->prf_WritesKB = ctp->cd_WriteBlks>>1;
		pfp->prf_time = MLXCTIME();
		pfp->prf_ticks = MLXCLBOLT();
		return 0;
	}
	if (cmd == MDACIOC_GETSYSPERFDATA)
	{       /* get system performance data */
		mdaczero(dp,mda_ctlsysperfdata_s);
		pfp->prf_time = MLXCTIME();
		pfp->prf_ticks = MLXCLBOLT();
		pfp->prf_ControllerNo = (unsigned char) mda_Controllers;
		for (ctp=mdac_ctldevtbl; ctp<mdac_lastctp; ctp++)
		{
			pfp->prf_CmdTimeOutDone += ctp->cd_CmdTimeOutDone;
			pfp->prf_CmdTimeOutNoticed += ctp->cd_CmdTimeOutNoticed;
			pfp->prf_MailBoxTimeOutDone += ctp->cd_MailBoxTimeOutDone;
			pfp->prf_MailBoxCmdsWaited += ctp->cd_MailBoxCmdsWaited;
			pfp->prf_ActiveCmds += ctp->cd_ActiveCmds;
			pfp->prf_SCDBDone += ctp->cd_SCDBDone;
			pfp->prf_SCDBDoneBig += ctp->cd_SCDBDoneBig;
			pfp->prf_SCDBWaited += ctp->cd_SCDBWaited;
			pfp->prf_SCDBWaiting += ctp->cd_SCDBWaiting;
			pfp->prf_CmdsDone += ctp->cd_CmdsDone;
			pfp->prf_CmdsDoneBig += ctp->cd_CmdsDoneBig;
			pfp->prf_CmdsWaited += ctp->cd_CmdsWaited;
			pfp->prf_CmdsWaiting += ctp->cd_CmdsWaiting;
			pfp->prf_OSCmdsWaited += ctp->cd_OSCmdsWaited;
			pfp->prf_OSCmdsWaiting += ctp->cd_OSCmdsWaiting;
			pfp->prf_IntrsDoneSpurious += ctp->cd_IntrsDoneSpurious;
			pfp->prf_IntrsDone += ctp->cd_IntrsDone;
			pfp->prf_Reads += ctp->cd_Reads;
			pfp->prf_ReadsKB += ctp->cd_ReadBlks>>1;
			pfp->prf_Writes += ctp->cd_Writes;
			pfp->prf_WritesKB += ctp->cd_WriteBlks>>1;
		}
		return 0;
	}
#undef  pfp
	if ((cmd==MDACIOC_GETDRIVERVERSION) || (cmd==DRLIOC_GETDRIVERVERSION))
		return *((dga_driver_version_t MLXFAR *)dp) = mdac_driver_version,0;
#endif /* MLX_DOS */
	if (cmd == MDACIOC_GETSYSINFO)
	{       /* put lock waiting count before returning data */
		mda_LockWaitDone = mdac_simple_waitlock_cnt;
		mda_LockWaitLoopDone = mdac_simple_waitloop_cnt;
		return *((mda_sysinfo_t MLXFAR *)dp) = mda_sysi, 0;
	}
#define sip     ((mda_sysinfo_t MLXFAR *)dp)
	if (cmd == MDACIOC_SETSYSINFO)
	{       /* setup different sysinfo tuneable parameters */
		if (sip->si_SetOffset == offsetof(mda_sysinfo_t, si_TotalCmdsToWaitForZeroIntr))
			return mda_TotalCmdsToWaitForZeroIntr = sip->si_TotalCmdsToWaitForZeroIntr, 0;
		seterrandret(ERR_NODEV);
	}
#undef  sip
	if (cmd == MDACIOC_USER_CMD)
	{
		ctlno2ctp(((mda_user_cmd_t MLXFAR *)dp)->ucmd_ControllerNo);
		seterrandret(mdac_user_dcmd(ctp,(mda_user_cmd_t MLXFAR *)dp));
	}
	if (cmd == MDACIOC_USER_CDB)
	{
		ctlno2ctp(((mda_user_cdb_t MLXFAR *)dp)->ucdb_ControllerNo);
		seterrandret(mdac_user_dcdb(ctp,(mda_user_cdb_t MLXFAR *)dp));
	}
	if (cmd == MDACIOC_STARTHWCLK)
	{
		mdac_enable_hwclock();
		cmd = MDACIOC_GETSYSTIME;       /* fall through */
	}
#define dtp     ((mda_time_t MLXFAR *)dp)
	if (cmd == MDACIOC_GETSYSTIME)
	{
		dtp->dtm_time = MLXCTIME();
		dtp->dtm_ticks = MLXCLBOLT();
		dtp->dtm_hwclk = mdac_read_hwclock();
		dtp->dtm_cpuclk.bit31_0=0; dtp->dtm_cpuclk.bit63_32=0;
		if (mdac_datarel_cpu_family==5) mdac_readtsc(&dtp->dtm_cpuclk);
		return 0;
	}
#undef  dtp
#define gfp     ((mda_gamfuncs_t MLXFAR *)dp)
	if (cmd == MDACIOC_GETGAMFUNCS)
	{
	    DebugPrint((mdacnt_dbg2, "cmd 0x%x, MDACIOC_GETGAMFUNCS\n",cmd));
		if (failGetGAM)
		{
		    seterrandret(ERR_NODEV);
		}
		mdaczero(dp,mda_gamfuncs_s);
#ifdef MDAC_CLEAN_IOCTL
		gfp->gf_Ioctl = reject_backdoor_request;
		gfp->gf_GamCmd = reject_backdoor_request;
		gfp->gf_GamNewCmd = reject_backdoor_request;
#else
		gfp->gf_Ioctl = mdac_ioctl;
		gfp->gf_GamCmd = mdac_os_gam_cmd;
		gfp->gf_GamNewCmd = mdac_os_gam_new_cmd;
#endif
		gfp->gf_ReadWrite = mdac_readwrite;
		gfp->gf_MaxIrqLevel = mdac_irqlevel;
		gfp->gf_Signature = MDA_GAMFUNCS_SIGNATURE_2;
		gfp->gf_MacSignature = MDA_MACFUNCS_SIGNATURE_3;
		gfp->gf_Ctp = (u32bits MLXFAR *)(&mdac_ctldevtbl[dev]);
		gfp->gf_CtlNo = (u08bits)dev;
#ifdef  MLX_NT_ALPHA
		gfp->gf_Alloc4KB = mlx_allocdsm4kb;
		gfp->gf_Free4KB = mlx_freedsm4kb;
		gfp->gf_KvToPhys = MdacKvToPhys;
		gfp->gf_AdpObj = (u32bits)MdacCtrlInfoPtr[gfp->gf_CtlNo]->AdapterObject;
		gfp->gf_MaxMapReg = (u08bits)MdacCtrlInfoPtr[gfp->gf_CtlNo]->MaxMapReg;
#endif  /*MLX_NT_ALPHA*/
		gam_present = 1L; /* HOTLINKS */
		return 0;
	}
#undef  gfp
/* HOTLINKS */
#define gfp     ((mda_setgamfuncs_t MLXFAR *)dp)
	if (cmd == MDACIOC_SETGAMFUNCS)
	{
	    DebugPrint((mdacnt_dbg2, "MDACIOC_SETGAMFUNCS: Selector: %d, ctp 0x%I, addr 0x%I\n",
		gfp->gfs_Selector, gfp->gfs_Ctp, gfp->gfs_mdacpres));

		switch (gfp->gfs_Selector)
		{
		case MDAC_PRESENT_ADDR:
			if ((mdac_ctldev_t MLXFAR *)(gfp->gfs_Ctp))
			{
						ia64debug((UINT_PTR)0x1);
						ia64debug((UINT_PTR)(gfp->gfs_Ctp));
						ia64debug((UINT_PTR)0x2);
						ia64debug((UINT_PTR)(&((mdac_ctldev_t MLXFAR *)(gfp->gfs_Ctp))->cd_cmdid2req));
						ia64debug((UINT_PTR)0x3);
						ia64debug((UINT_PTR)(&((mdac_ctldev_t MLXFAR *)(gfp->gfs_Ctp))->cd_mdac_pres_addr));
						ia64debug((UINT_PTR)0x4);
						ia64debug((UINT_PTR)(((mdac_ctldev_t MLXFAR *)(gfp->gfs_Ctp))->cd_mdac_pres_addr));
						ia64debug((UINT_PTR)0x5);
						ia64debug((UINT_PTR)gfp);
						ia64debug((UINT_PTR)0x6);
						ia64debug((UINT_PTR)&gfp->gfs_mdacpres);
						ia64debug((UINT_PTR)0x7);
						ia64debug((UINT_PTR)gfp->gfs_mdacpres);
((mdac_ctldev_t MLXFAR *)(gfp->gfs_Ctp))->cd_mdac_pres_addr = (UINT_PTR)(gfp->gfs_mdacpres);
						ia64debug((UINT_PTR)0x8);
									
			}	
				gam_present = 1;
			break;
		case GAM_PRESENT:
			gam_present = gfp->gfs_gampres;
			break;
		}
		return 0;
	}
#undef  gfp
/* HOTLINKS */
#ifndef MLX_DOS
#define tmp     ((drltime_t MLXFAR *)dp)
	if (cmd == DRLIOC_GETTIME)
	{
		tmp->drltm_time = MLXCTIME();
		tmp->drltm_lbolt = MLXCLBOLT();
		tmp->drltm_hwclk = mdac_read_hwclock();
		tmp->drltm_pclk.bit31_0=0; tmp->drltm_pclk.bit63_32=0;
		if (mdac_datarel_cpu_family==5) mdac_readtsc(&tmp->drltm_pclk);
		return 0;
	}
#undef  tmp
	if (cmd == DRLIOC_GETSIGINFO)
		return mdaccopy(&mdac_drlsigrwt,dp,drlrwtest_s);
	if (cmd == DRLIOC_READTEST)
		seterrandret(mdac_datarel_rwtest((drlrwtest_t MLXFAR *)dp,MDAC_RQOP_READ));
	if (cmd == DRLIOC_WRITETEST)
		seterrandret(mdac_datarel_rwtest((drlrwtest_t MLXFAR *)dp,MDAC_RQOP_WRITE));
	if (cmd == DRLIOC_GETDEVSIZE)
		seterrandret(mdac_datarel_devsize((drldevsize_t MLXFAR*)dp));
	if (cmd == DRLIOC_SIGCOPY) return mdaccopy(&mdac_drlsigcopycmp,dp,drlcopy_s);
	if ((cmd == DRLIOC_DATACOPY) || (cmd == DRLIOC_DATACMP))
		seterrandret(mdac_datarel_copycmp((drlcopy_t MLXFAR*)dp,cmd));
#endif /* MLX_DOS */
#define biosip  ((mda_biosinfo_t MLXFAR *)dp)
	if (cmd == MDACIOC_GETBIOSINFO)
	{
		dac_biosinfo_t MLXFAR *biosp;
		ctlno2ctp(biosip->biosi_ControllerNo);
		if (!(biosp=mdac_getpcibiosaddr(ctp))) seterrandret(MLXERR_NOCONF);
		mdaccopy(biosp,biosip->biosi_Info,MDAC_BIOSINFOSIZE);
		return 0;
	}
#undef  biosip
#define acmdip  ((mda_activecmd_info_t MLXFAR *)dp)
	if (cmd == MDACIOC_GETACTIVECMDINFO)
	{
		ctlno2ctp(acmdip->acmdi_ControllerNo);
        mdac_prelock(&irql);
		mdac_ctlr_lock(ctp);
		for ( ; acmdip->acmdi_CmdID<MDAC_MAXCOMMANDS; acmdip->acmdi_CmdID++)
		{
			if (!(temprqp = ctp->cd_cmdid2req[acmdip->acmdi_CmdID])) continue;
			if (((temprqp->rq_FinishTime-temprqp->rq_TimeOut)+acmdip->acmdi_TimeOut) > mda_CurTime) continue;
			acmdip->acmdi_ActiveTime = mda_CurTime;
			mdaccopy(temprqp,acmdip->acmdi_Info,MDAC_ACTIVECMDINFOSIZE);
			mdac_ctlr_unlock(ctp);
            mdac_postlock(irql);
			return 0;
		}
		mdac_ctlr_unlock(ctp);
        mdac_postlock(irql);
		acmdip->acmdi_ErrorCode = MLXERR_NOENTRY;
		return 0;
	}
#undef  acmdip
#ifndef MLX_DOS
	if ((cmd == DRLIOC_GETRWTESTSTATUS) || (cmd == DRLIOC_STOPRWTEST) ||
	    (cmd == DRLIOC_GOODRWTESTSTATUS))
		seterrandret(mdac_datarel_rwtest_status((drl_rwteststatus_t MLXFAR *)dp,cmd));
	if ((cmd == DRLIOC_GETCOPYCMPSTATUS) || (cmd == DRLIOC_STOPCOPYCMP) ||
	    (cmd == DRLIOC_GOODCOPYCMPSTATUS))
		seterrandret(mdac_datarel_copycmp_status((drl_copycmpstatus_t MLXFAR *)dp,cmd));
#endif /* MLX_DOS */
	if (cmd == MDACIOC_GETPCISLOTINFO)
		seterrandret(mdac_pcislotinfo((mda_pcislot_info_t MLXFAR*)dp,MDAC_RQOP_READ));
	if (cmd == MDACIOC_GETSIZELIMIT)
		seterrandret(mdac_getsizelimit((mda_sizelimit_info_t MLXFAR*)dp));
	if (cmd == MDACIOC_SETSIZELIMIT)
		seterrandret(mdac_setsizelimit((mda_sizelimit_info_t MLXFAR*)dp));

/* Add following for macdisk support, 09/26/2000 @Kawase */
#define mfp     ((mda_macdiskfunc_t MLXFAR *)dp)
	if (cmd == MDACIOC_GETMACDISKFUNC)
	{
		mdaczero(dp,mda_macdiskfunc_s);
		mfp->mf_ReadWrite = mdac_readwrite;
		mfp->mf_MaxIrqLevel = mdac_irqlevel;
		mfp->mf_Signature = MDA_GAMFUNCS_SIGNATURE_2;
		mfp->mf_MacSignature = MDA_MACFUNCS_SIGNATURE_3;
		mfp->mf_Ctp = (u32bits MLXFAR *)(&mdac_ctldevtbl[dev]);
		mfp->mf_CtlNo = (u08bits)dev;
#ifdef  MLX_NT_ALPHA
		mfp->mf_Alloc4KB = mlx_allocdsm4kb;
		mfp->mf_Free4KB = mlx_freedsm4kb;
		mfp->mf_KvToPhys = MdacKvToPhys;
		mfp->mf_AdpObj = (u32bits)MdacCtrlInfoPtr[mfp->gf_CtlNo]->AdapterObject;
		mfp->mf_MaxMapReg = (u08bits)MdacCtrlInfoPtr[mfp->gf_CtlNo]->MaxMapReg;
#endif  /*MLX_NT_ALPHA*/
		return 0;
	}
#undef  mfp

#define mfp     ((mda_setmacdiskfunc_t MLXFAR *)dp)
	if (cmd == MDACIOC_SETMACDISKFUNC)
	{
        mdac_spinlockfunc = mfp->mfs_SpinLock;
        mdac_unlockfunc = mfp->mfs_UnLock;
        mdac_prelockfunc = mfp->mfs_PreLock;
        mdac_postlockfunc = mfp->mfs_PostLock;
		return 0;
	}
#undef mfp

	seterrandret(ERR_NOCODE);
out_nodev:seterrandret(ERR_NODEV);
}

u32bits MLXFAR
mdac_req_pollwake(rqp)
mdac_req_t MLXFAR *rqp;
{
	mdac_sleep_lock();
	rqp->rq_Poll = 0;
	mdac_wakeup((u32bits MLXFAR *)&rqp->rq_PollWaitChan);
	mdac_sleep_unlock();
	return 0;
}

u32bits MLXFAR
mdac_req_pollwait(rqp)
mdac_req_t MLXFAR *rqp;
{
	mdac_sleep_lock();
	while (rqp->rq_Poll)
		mdac_sleep((u32bits MLXFAR *)&rqp->rq_PollWaitChan,MLX_WAITWITHOUTSIGNAL);
	mdac_sleep_unlock();
	return 0;
}


#undef  seterrandret
#undef  ctlno2ctp

u32bits MLXFAR
mdac_resetctlstat(ctp)
mdac_ctldev_t MLXFAR *ctp;
{
	ctp->cd_Reads=0; ctp->cd_ReadBlks=0; ctp->cd_Writes=0; ctp->cd_WriteBlks=0;
	ctp->cd_OSCmdsWaited=0; ctp->cd_PhysDevTestDone=0;
	ctp->cd_SCDBDone=0; ctp->cd_SCDBDoneBig=0; ctp->cd_SCDBWaited=0;
	ctp->cd_CmdsDone=0; ctp->cd_CmdsDoneBig=0; ctp->cd_CmdsWaited=0;
	ctp->cd_IntrsDone=0; ctp->cd_IntrsDoneSpurious=0;
	ctp->cd_SpuriousCmdStatID = 0; ctp->cd_CmdsDoneSpurious = 0;
	ctp->cd_MailBoxCmdsWaited=0; ctp->cd_MailBoxTimeOutDone=0;
	ctp->cd_CmdTimeOutDone=0; ctp->cd_CmdTimeOutNoticed=0;
	ctp->cd_DoorBellSkipped=0;
	return 0;
}

/*==========================OS INTERFACE ENDS===========================*/

/*------------------------------------------------------------------*/
/* Reset the controller */
u32bits MLXFAR
mdac_reset_MCA(ctp)
mdac_ctldev_t MLXFAR *ctp;
{
	return MLXERR_NOCODE;
}

u32bits MLXFAR
mdac_reset_EISA_PCIPD(ctp)
mdac_ctldev_t MLXFAR *ctp;
{
	return u08bits_out_mdac(ctp->cd_LocalDoorBellReg, MDAC_RESET_CONTROLLER), 0;
}

u32bits MLXFAR
mdac_reset_PCIPDMEM(ctp)
mdac_ctldev_t MLXFAR *ctp;
{
	return u08bits_write(ctp->cd_LocalDoorBellReg, MDAC_RESET_CONTROLLER), 0;
}

u32bits MLXFAR
mdac_reset_PCIPG(ctp)
mdac_ctldev_t MLXFAR *ctp;
{
	u32bits inx;
	mda_pcislo