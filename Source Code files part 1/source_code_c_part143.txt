tes a scasb/w/d opcode.

Arguments:

    P - Supplies a pointer to the emulation context structure.

Return Value:

    None.

--*/

{

    ULONG Count;

    //
    // If a repeat prefix is active, then the loop count is specified
    // by eCX. Otherwise, the loop count is one.
    //

    Count = 1;
    if (P->RepeatPrefixActive != FALSE) {
        if (P->OpaddrPrefixActive != FALSE) {
            Count = P->Gpr[ECX].Exx;

        } else {
            Count = P->Gpr[CX].Xx;
        }
    }

    //
    // Set source value.
    //

    XmSetSourceValue(P, (PVOID)&P->Gpr[EAX].Exx);

    //
    // Compare items from source and destination.
    //

    while (Count != 0) {

        //
        // Set destination value.
        //

        XmSetDestinationValue(P, XmGetStringAddress(P, ES, EDI));

        //
        // Compare source with destination operand and decrement loop count.
        // If ZF is not equal to the repeat Z flag condition, then terminate
        // the loop.
        //

        XmCompareOperands(P);
        Count -= 1;
        if (P->Eflags.EFLAG_ZF != P->RepeatZflag) {
            break;
        }
    }

    //
    // If a repeat prefix is active, then set the final count value.
    //

    if (P->RepeatPrefixActive != FALSE) {
        if (P->OpaddrPrefixActive != FALSE) {
            P->Gpr[ECX].Exx = Count;

        } else {
            P->Gpr[CX].Xx = (USHORT)Count;
        }
    }

    return;
}

VOID
XmStosOp (
    IN PRXM_CONTEXT P
    )

/*++

Routine Description:

    This function emulates a stosb/w/d opcode.

Arguments:

    P - Supplies a pointer to the emulation context structure.

Return Value:

    None.

--*/

{

    ULONG Count;

    //
    // If a repeat prefix is active, then the loop count is specified
    // by eCX. Otherwise, the loop count is one.
    //

    Count = 1;
    if (P->RepeatPrefixActive != FALSE) {
        if (P->OpaddrPrefixActive != FALSE) {
            Count = P->Gpr[ECX].Exx;
            P->Gpr[ECX].Exx = 0;

        } else {
            Count = P->Gpr[CX].Xx;
            P->Gpr[CX].Xx = 0;
        }
    }

    //
    // Set source value.
    //

    XmSetSourceValue(P, (PVOID)&P->Gpr[EAX].Exx);

    //
    // Move items from source to destination.
    //

    while (Count != 0) {

        //
        // Set destination address and store result.
        //

        P->DstLong = (ULONG UNALIGNED *)XmGetStringAddress(P, ES, EDI);
        XmStoreResult(P, P->SrcValue.Long);
        Count -= 1;
    }

    return;
}

VOID
XmCompareOperands (
    IN PRXM_CONTEXT P
    )

/*++

Routine Description:

    This function compares two operands and computes the resulting condition
    codes.

Arguments:

    P - Supplies a pointer to the emulation context structure.

Return Value:

    None.

--*/

{

    ULONG CarryFlag;
    ULONG OverflowFlag;
    ULONG SignFlag;
    ULONG ZeroFlag;
    union {
        UCHAR ResultByte;
        ULONG ResultLong;
        USHORT ResultWord;
    } u;

    //
    // Switch on data type.
    //

    switch (P->DataType) {

        //
        // The operation datatype is byte.
        //

    case BYTE_DATA:
        CarryFlag = (P->SrcValue.Byte < P->DstValue.Byte);
        u.ResultByte = P->SrcValue.Byte - P->DstValue.Byte;
        OverflowFlag = (((u.ResultByte ^ P->SrcValue.Byte) &
                        (u.ResultByte ^ P->DstValue.Byte)) >> 7) & 0x1;

        SignFlag = (u.ResultByte >> 7) & 0x1;
        ZeroFlag = (u.ResultByte == 0);
        u.ResultLong = u.ResultByte;
        break;

        //
        // The operation datatype is word.
        //

    case WORD_DATA:
        CarryFlag = (P->SrcValue.Word < P->DstValue.Word);
        u.ResultWord = P->SrcValue.Word - P->DstValue.Word;
        OverflowFlag = (((u.ResultWord ^ P->SrcValue.Word) &
                        (u.ResultWord ^ P->DstValue.Word)) >> 15) & 0x1;

        SignFlag = (u.ResultWord >> 15) & 0x1;
        ZeroFlag = (u.ResultWord == 0);
        u.ResultLong = u.ResultWord;
        break;

        //
        // The operation datatype is long.
        //

    case LONG_DATA:
        CarryFlag = (P->SrcValue.Long < P->DstValue.Long);
        u.ResultLong = P->SrcValue.Long - P->DstValue.Long;
        OverflowFlag = (((u.ResultLong ^ P->SrcValue.Long) &
                        (u.ResultLong ^ P->DstValue.Long)) >> 31) & 0x1;

        SignFlag = (u.ResultLong >> 31) & 0x1;
        ZeroFlag = (u.ResultLong == 0);
        break;
    }

    //
    // Compute auxilary carry flag, parity flag, and store all flags in
    // the flags register.
    //

    P->Eflags.EFLAG_CF = CarryFlag;
    P->Eflags.EFLAG_PF = XmComputeParity(u.ResultLong);
    P->Eflags.EFLAG_AF = ((P->DstValue.Byte & 0xf) + (P->SrcValue.Byte & 0xf)) >> 4;
    P->Eflags.EFLAG_ZF = ZeroFlag;
    P->Eflags.EFLAG_SF = SignFlag;
    P->Eflags.EFLAG_OF = OverflowFlag;
    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\hals\x86new\x86bios.c ===
/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    x86bios.c

Abstract:

    This module implements supplies the HAL interface to the 386/486
    real mode emulator for the purpose of emulating BIOS calls..

Author:

    David N. Cutler (davec) 13-Nov-1994

Environment:

    Kernel mode only.

Revision History:

--*/

#include "nthal.h"
#include "hal.h"
#include "xm86.h"
#include "x86new.h"
#include "pci.h"

//
// Define the size of low memory.
//

#define LOW_MEMORY_SIZE 0x800

//
// Define storage for low emulated memory.
//

UCHAR x86BiosLowMemory[LOW_MEMORY_SIZE + 3];
ULONG x86BiosScratchMemory;

//
// Define storage to capture the base address of I/O space, the base address
// of I/O memory space, and the base address of the video frame buffer.
//

ULONG_PTR x86BiosFrameBuffer;
ULONG_PTR x86BiosIoMemory;
ULONG_PTR x86BiosIoSpace;

//
// Define an area of storage to allow for buffer passing between the BIOS
// and native mode code.
//

ULONG_PTR x86BiosTransferMemory = 0;
ULONG x86BiosTransferLength = 0;

//
// Define BIOS initialized state.
//

BOOLEAN x86BiosInitialized = FALSE;

//
// Define storage for PCI BIOS initialization state.
//

UCHAR XmNumberPciBusses = 0;
BOOLEAN XmPciBiosPresent = FALSE;
PGETSETPCIBUSDATA XmGetPciData;
PGETSETPCIBUSDATA XmSetPciData;


ULONG XmPCIConfigAddress = 0;     // Current Value of emulated PCI Address Port

ULONG
x86BiosReadPciAddressPort(
    IN XM_OPERATION_DATATYPE DataType,
    IN USHORT PortNumber
    );

VOID
x86BiosWritePciAddressPort(
    IN XM_OPERATION_DATATYPE DataType,
    IN USHORT PortNumber,
    IN ULONG Value
    );

ULONG
x86BiosReadPciDataPort(
    IN XM_OPERATION_DATATYPE DataType,
    IN USHORT PortNumber
    );

VOID
x86BiosWritePciDataPort(
    IN XM_OPERATION_DATATYPE DataType,
    IN USHORT PortNumber,
    IN ULONG Value
    );

ULONG
x86BiosReadIoSpace (
    IN XM_OPERATION_DATATYPE DataType,
    IN USHORT PortNumber
    )

/*++

Routine Description:

    This function reads from emulated I/O space.

Arguments:

    DataType - Supplies the datatype for the read operation.

    PortNumber - Supplies the port number in I/O space to read from.

Return Value:

    The value read from I/O space is returned as the function value.

    N.B. If an aligned operation is specified, then the individual
        bytes are read from the specified port one at a time and
        assembled into the specified datatype.

--*/

{

    ULONG Result;

    union {
        PUCHAR Byte;
        PUSHORT Word;
        PULONG Long;
    } u;

    //
    // If we have access to the HAL config space routines intercept accesses to
    // the PCI Config Ports and emulate them.
    //

    if (XmPciBiosPresent) {

        if ((PCI_TYPE1_ADDR_PORT <= PortNumber) &&
            (PortNumber <= (PCI_TYPE1_ADDR_PORT + 3))) {

            return x86BiosReadPciAddressPort(DataType,
                                             PortNumber - PCI_TYPE1_ADDR_PORT);

        } else if ((XmPCIConfigAddress & (1 << 31)) &&
                   (PCI_TYPE1_DATA_PORT <= PortNumber) &&
                   (PortNumber <= (PCI_TYPE1_DATA_PORT + 3))) {

            return x86BiosReadPciDataPort(DataType,
                                          PortNumber - PCI_TYPE1_DATA_PORT);
        }
    }

    //
    // Compute port address and read port.
    //

    u.Long = (PULONG)(x86BiosIoSpace + PortNumber);
    if (DataType == BYTE_DATA) {
        Result = READ_PORT_UCHAR(u.Byte);

    } else if (DataType == LONG_DATA) {
        if (((ULONG_PTR)u.Long & 0x3) != 0) {
            Result = (READ_PORT_UCHAR(u.Byte + 0)) |
                     (READ_PORT_UCHAR(u.Byte + 1) << 8) |
                     (READ_PORT_UCHAR(u.Byte + 2) << 16) |
                     (READ_PORT_UCHAR(u.Byte + 3) << 24);

        } else {
            Result = READ_PORT_ULONG(u.Long);
        }

    } else {
        if (((ULONG_PTR)u.Word & 0x1) != 0) {
            Result = (READ_PORT_UCHAR(u.Byte + 0)) |
                     (READ_PORT_UCHAR(u.Byte + 1) << 8);

        } else {
            Result = READ_PORT_USHORT(u.Word);
        }
    }

    return Result;
}

VOID
x86BiosWriteIoSpace (
    IN XM_OPERATION_DATATYPE DataType,
    IN USHORT PortNumber,
    IN ULONG Value
    )

/*++

Routine Description:

    This function write to emulated I/O space.

    N.B. If an aligned operation is specified, then the individual
        bytes are written to the specified port one at a time.

Arguments:

    DataType - Supplies the datatype for the write operation.

    PortNumber - Supplies the port number in I/O space to write to.

    Value - Supplies the value to write.

Return Value:

    None.

--*/

{

    union {
        PUCHAR Byte;
        PUSHORT Word;
        PULONG Long;
    } u;

    //
    // If we have access to the HAL config space routines intercept accesses to
    // the PCI Config Ports and emulate them.
    //

    if (XmPciBiosPresent) {

        if ((PCI_TYPE1_ADDR_PORT <= PortNumber) &&
            (PortNumber <= (PCI_TYPE1_ADDR_PORT + 3))) {

            x86BiosWritePciAddressPort(DataType,
                                       PortNumber - PCI_TYPE1_ADDR_PORT,
                                       Value);
            return;

        } else if ((XmPCIConfigAddress & (1 << 31)) &&
                   (PCI_TYPE1_DATA_PORT <= PortNumber) &&
                   (PortNumber <= (PCI_TYPE1_DATA_PORT + 3))) {

            x86BiosWritePciDataPort(DataType,
                                    PortNumber - PCI_TYPE1_DATA_PORT,
                                    Value);
            return;
        }
    }

    //
    // Compute port address and read port.
    //

    u.Long = (PULONG)(x86BiosIoSpace + PortNumber);
    if (DataType == BYTE_DATA) {
        WRITE_PORT_UCHAR(u.Byte, (UCHAR)Value);

    } else if (DataType == LONG_DATA) {
        if (((ULONG_PTR)u.Long & 0x3) != 0) {
            WRITE_PORT_UCHAR(u.Byte + 0, (UCHAR)(Value));
            WRITE_PORT_UCHAR(u.Byte + 1, (UCHAR)(Value >> 8));
            WRITE_PORT_UCHAR(u.Byte + 2, (UCHAR)(Value >> 16));
            WRITE_PORT_UCHAR(u.Byte + 3, (UCHAR)(Value >> 24));

        } else {
            WRITE_PORT_ULONG(u.Long, Value);
        }

    } else {
        if (((ULONG_PTR)u.Word & 0x1) != 0) {
            WRITE_PORT_UCHAR(u.Byte + 0, (UCHAR)(Value));
            WRITE_PORT_UCHAR(u.Byte + 1, (UCHAR)(Value >> 8));

        } else {
            WRITE_PORT_USHORT(u.Word, (USHORT)Value);
        }
    }

    return;
}

PVOID
x86BiosTranslateAddress (
    IN USHORT Segment,
    IN USHORT Offset
    )

/*++

Routine Description:

    This translates a segment/offset address into a memory address.

Arguments:

    Segment - Supplies the segment register value.

    Offset - Supplies the offset within segment.

Return Value:

    The memory address of the translated segment/offset pair is
    returned as the function value.

--*/

{

    ULONG Value;

    //
    // Compute the logical memory address and case on high hex digit of
    // the resultant address.
    //

    Value = Offset + (Segment << 4);
    Offset = (USHORT)(Value & 0xffff);
    Value &= 0xf0000;
    switch ((Value >> 16) & 0xf) {

        //
        // Interrupt vector/stack space.
        //

    case 0x0:
        if (Offset > LOW_MEMORY_SIZE) {
            x86BiosScratchMemory = 0;
            return (PVOID)&x86BiosScratchMemory;

        } else {
            return (PVOID)(&x86BiosLowMemory[0] + Offset);
        }

        //
        // The memory range from 0x10000 to 0x8ffff reads as zero
        // and writes are ignored.
        //

    case 0x1:
    case 0x3:
    case 0x4:
    case 0x5:
    case 0x6:
    case 0x7:
    case 0x8:
        x86BiosScratchMemory = 0;
        return (PVOID)&x86BiosScratchMemory;

    case 0x9:
        //
        // BUGBUG: Found a VGA adapter loaded in segment 9
        // Emulator assumptions about video adapters needs to be
        // looked at
        //
        return (PVOID)(x86BiosIoMemory + Offset + Value);

        //
        // The memory range from 0x20000 to 0x20fff is used to transfer
        // buffers between native mode and emulated mode.
        //

    case 0x2:
        if (Offset < x86BiosTransferLength) {
            return (PVOID)(x86BiosTransferMemory + Offset);
        } else {
            x86BiosScratchMemory = 0;
            return (PVOID)&x86BiosScratchMemory;
        }

        //
        // The memory range from 0xa0000 to 0xbffff maps to the
        // framebuffer if previously specified, otherwise I/O memory.
        //

    case 0xa:
    case 0xb:
        if (x86BiosFrameBuffer != 0) {
            return (PVOID)(x86BiosFrameBuffer + Offset + Value);
        }

        //
        // The memory range from 0xc0000 to 0xfffff maps to I/O memory
        //

    case 0xc:
    case 0xd:
    case 0xe:
    case 0xf:
        return (PVOID)(x86BiosIoMemory + Offset + Value);

    DEFAULT_UNREACHABLE;
    }
}

VOID
x86BiosInitializeBios (
    IN PVOID BiosIoSpace,
    IN PVOID BiosIoMemory
    )

/*++

Routine Description:

    This function initializes x86 BIOS emulation.

Arguments:

    BiosIoSpace - Supplies the base address of the I/O space to be used
        for BIOS emulation.

    BiosIoMemory - Supplies the base address of the I/O memory to be
        used for BIOS emulation.

Return Value:

    None.

--*/

{

    //
    // Initialize x86 BIOS emulation.
    //

    x86BiosInitializeBiosShadowed(BiosIoSpace,
                                  BiosIoMemory,
                                  NULL);

    return;
}

VOID
x86BiosInitializeBiosEx (
    IN PVOID BiosIoSpace,
    IN PVOID BiosIoMemory,
    IN PVOID BiosFrameBuffer,
    IN PVOID BiosTransferMemory,
    IN ULONG TransferLength
    )

/*++

Routine Description:

    This function initializes x86 BIOS emulation.

Arguments:

    BiosIoSpace - Supplies the base address of the I/O space to be used
        for BIOS emulation.

    BiosIoMemory - Supplies the base address of the I/O memory to be
        used for BIOS emulation.

Return Value:

    None.

--*/

{

    //
    // Initialize x86 BIOS emulation.
    //

    x86BiosInitializeBiosShadowed(BiosIoSpace,
                                  BiosIoMemory,
                                  BiosFrameBuffer
                                  );

    x86BiosTransferMemory = (ULONG_PTR)BiosTransferMemory;
    x86BiosTransferLength = TransferLength;

    return;
}


VOID
x86BiosInitializeBiosShadowed (
    IN PVOID BiosIoSpace,
    IN PVOID BiosIoMemory,
    IN PVOID BiosFrameBuffer
    )

/*++

Routine Description:

    This function initializes x86 BIOS emulation.

Arguments:

    BiosIoSpace - Supplies the base address of the I/O space to be used
        for BIOS emulation.

    BiosIoMemory - Supplies the base address of the I/O memory to be
        used for BIOS emulation.

    BiosFrameBuffer - Supplies the base address of the video frame buffer
        to be used for bios emulation.

Return Value:

    None.

--*/

{

    //
    // Zero low memory.
    //

    memset(&x86BiosLowMemory, 0, LOW_MEMORY_SIZE);

    //
    // Save base address of I/O memory and I/O space.
    //

    x86BiosIoSpace = (ULONG_PTR)BiosIoSpace;
    x86BiosIoMemory = (ULONG_PTR)BiosIoMemory;
    x86BiosFrameBuffer = (ULONG_PTR)BiosFrameBuffer;

    //
    // Initialize the emulator and the BIOS.
    //

    XmInitializeEmulator(0,
                         LOW_MEMORY_SIZE,
                         x86BiosReadIoSpace,
                         x86BiosWriteIoSpace,
                         x86BiosTranslateAddress);

    x86BiosInitialized = TRUE;
    return;
}

VOID
x86BiosInitializeBiosShadowedPci (
    IN PVOID BiosIoSpace,
    IN PVOID BiosIoMemory,
    IN PVOID BiosFrameBuffer,
    IN UCHAR NumberPciBusses,
    IN PGETSETPCIBUSDATA GetPciData,
    IN PGETSETPCIBUSDATA SetPciData
    )

/*++

Routine Description:

    This function initializes x86 BIOS emulation and also sets up the
    emulator with BIOS shadowed and PCI functions enabled. Since the
    PCI specification requires BIOS shadowing, there isn't any need
    to provide a function that turns on the PCI functions, but doesn't
    shadow the BIOS.

Arguments:

    BiosIoSpace - Supplies the base address of the I/O space to be used
        for BIOS emulation.

    BiosIoMemory - Supplies the base address of the I/O memory to be
        used for BIOS emulation.

    BiosFrameBuffer - Supplies the base address of the video frame buffer
        to be used for bios emulation.

    NumberPciBusses - Supplies the number of PCI busses in the system.

    GetPciData - Supplies the address of a function to read the PCI
        configuration space.

    SetPciData - Supplies the address of a function to write the PCI
        configuration space.

Return Value:

    None.

--*/

{

    //
    // Enable PCI BIOS support.
    //

    XmPciBiosPresent = TRUE;
    XmGetPciData = GetPciData;
    XmSetPciData = SetPciData;
    XmNumberPciBusses = NumberPciBusses;

    //
    // Initialize x86 BIOS emulation.
    //

    x86BiosInitializeBiosShadowed(BiosIoSpace,
                                  BiosIoMemory,
                                  BiosFrameBuffer);

    return;
}

XM_STATUS
x86BiosExecuteInterrupt (
    IN UCHAR Number,
    IN OUT PXM86_CONTEXT Context,
    IN PVOID BiosIoSpace OPTIONAL,
    IN PVOID BiosIoMemory OPTIONAL
    )

/*++

Routine Description:

    This function executes an interrupt by calling the x86 emulator.

Arguments:

    Number - Supplies the number of the interrupt that is to be emulated.

    Context - Supplies a pointer to an x86 context structure.

    BiosIoSpace - Supplies an optional base address of the I/O space
        to be used for BIOS emulation.

    BiosIoMemory - Supplies an optional base address of the I/O memory
        to be used for BIOS emulation.

Return Value:

    The emulation completion status.

--*/

{

    //
    // Execute x86 interrupt.
    //

    return x86BiosExecuteInterruptShadowed(Number,
                                           Context,
                                           BiosIoSpace,
                                           BiosIoMemory,
                                           NULL);
}

XM_STATUS
x86BiosExecuteInterruptShadowed (
    IN UCHAR Number,
    IN OUT PXM86_CONTEXT Context,
    IN PVOID BiosIoSpace OPTIONAL,
    IN PVOID BiosIoMemory OPTIONAL,
    IN PVOID BiosFrameBuffer OPTIONAL
    )

/*++

Routine Description:

    This function executes an interrupt by calling the x86 emulator.

Arguments:

    Number - Supplies the number of the interrupt that is to be emulated.

    Context - Supplies a pointer to an x86 context structure.

    BiosIoSpace - Supplies an optional base address of the I/O space
        to be used for BIOS emulation.

    BiosIoMemory - Supplies an optional base address of the I/O memory
        to be used for BIOS emulation.

    BiosFrameBuffer - Supplies an optional base address of the video
        frame buffer to be used for bios emulation.

Return Value:

    The emulation completion status.

--*/

{

    XM_STATUS Status;

    //
    // If a new base address is specified, then set the appropriate base.
    //

    if (BiosIoSpace != NULL) {
        x86BiosIoSpace = (ULONG_PTR)BiosIoSpace;
    }

    if (BiosIoMemory != NULL) {
        x86BiosIoMemory = (ULONG_PTR)BiosIoMemory;
    }

    if (BiosFrameBuffer != NULL) {
        x86BiosFrameBuffer = (ULONG_PTR)BiosFrameBuffer;
    }

    //
    // Execute the specified interrupt.
    //

    Status = XmEmulateInterrupt(Number, Context);
    if (Status != XM_SUCCESS) {
        DbgPrint("HAL: Interrupt emulation failed, status %lx\n", Status);
    }

    return Status;
}

XM_STATUS
x86BiosExecuteInterruptShadowedPci (
    IN UCHAR Number,
    IN OUT PXM86_CONTEXT Context,
    IN PVOID BiosIoSpace OPTIONAL,
    IN PVOID BiosIoMemory OPTIONAL,
    IN PVOID BiosFrameBuffer OPTIONAL,
    IN UCHAR NumberPciBusses,
    IN PGETSETPCIBUSDATA GetPciData,
    IN PGETSETPCIBUSDATA SetPciData
    )

/*++

Routine Description:

    This function executes an interrupt by calling the x86 emulator.

Arguments:

    Number - Supplies the number of the interrupt that is to be emulated.

    Context - Supplies a pointer to an x86 context structure.

    BiosIoSpace - Supplies an optional base address of the I/O space
        to be used for BIOS emulation.

    BiosIoMemory - Supplies an optional base address of the I/O memory
        to be used for BIOS emulation.

    NumberPciBusses - Supplies the number of PCI busses in the system.

    GetPciData - Supplies the address of a function to read the PCI
        configuration space.

    SetPciData - Supplies the address of a function to write the PCI
        configuration space.

Return Value:

    The emulation completion status.

--*/

{

    //
    // Enable PCI BIOS support.
    //

    XmPciBiosPresent = TRUE;
    XmGetPciData = GetPciData;
    XmSetPciData = SetPciData;
    XmNumberPciBusses = NumberPciBusses;

    //
    // Execute x86 interrupt.
    //

    return x86BiosExecuteInterruptShadowed(Number,
                                           Context,
                                           BiosIoSpace,
                                           BiosIoMemory,
                                           BiosFrameBuffer);
}

XM_STATUS
x86BiosInitializeAdapter(
    IN ULONG Adapter,
    IN OUT PXM86_CONTEXT Context OPTIONAL,
    IN PVOID BiosIoSpace OPTIONAL,
    IN PVOID BiosIoMemory OPTIONAL
    )
/*++

Routine Description:

    This function initializes the adapter whose BIOS starts at the
    specified 20-bit address.

Arguments:

    Adpater - Supplies the 20-bit address of the BIOS for the adapter
        to be initialized.

Return Value:

    The emulation completion status.

--*/

{

    //
    // Initialize the specified adapter.
    //

    return x86BiosInitializeAdapterShadowed(Adapter,
                                            Context,
                                            BiosIoSpace,
                                            BiosIoMemory,
                                            NULL);
}

XM_STATUS
x86BiosInitializeAdapterShadowed (
    IN ULONG Adapter,
    IN OUT PXM86_CONTEXT Context OPTIONAL,
    IN PVOID BiosIoSpace OPTIONAL,
    IN PVOID BiosIoMemory OPTIONAL,
    IN PVOID BiosFrameBuffer OPTIONAL
    )

/*++

Routine Description:

    This function initializes the adapter whose BIOS starts at the
    specified 20-bit address.

Arguments:

    Adpater - Supplies the 20-bit address of the BIOS for the adapter
        to be initialized.

Return Value:

    The emulation completion status.

--*/

{

    PUCHAR Byte;
    XM86_CONTEXT State;
    USHORT Offset;
    USHORT Segment;
    XM_STATUS Status;

    //
    // If BIOS emulation has not been initialized, then return an error.
    //

    if (x86BiosInitialized == FALSE) {
        return XM_EMULATOR_NOT_INITIALIZED;
    }

    //
    // If an emulator context is not specified, then use a default
    // context.
    //

    if (ARGUMENT_PRESENT(Context) == FALSE) {
        State.Eax = 0;
        State.Ecx = 0;
        State.Edx = 0;
        State.Ebx = 0;
        State.Ebp = 0;
        State.Esi = 0;
        State.Edi = 0;
        Context = &State;
    }

    //
    // If a new base address is specified, then set the appropriate base.
    //

    if (BiosIoSpace != NULL) {
        x86BiosIoSpace = (ULONG_PTR)BiosIoSpace;
    }

    if (BiosIoMemory != NULL) {
        x86BiosIoMemory = (ULONG_PTR)BiosIoMemory;
    }

    if (BiosFrameBuffer != NULL) {
        x86BiosFrameBuffer = (ULONG_PTR)BiosFrameBuffer;
    }

    //
    // If the specified adpater is not BIOS code, then return an error.
    //

    Segment = (USHORT)((Adapter >> 4) & 0xf000);
    Offset = (USHORT)(Adapter & 0xffff);
    Byte = (PUCHAR)x86BiosTranslateAddress(Segment, Offset);

    if ((*Byte++ != 0x55) || (*Byte != 0xaa)) {
        return XM_ILLEGAL_CODE_SEGMENT;
    }

    //
    // Call the BIOS code to initialize the specified adapter.
    //

    Adapter += 3;
    Segment = (USHORT)((Adapter >> 4) & 0xf000);
    Offset = (USHORT)(Adapter & 0xffff);
    Status = XmEmulateFarCall(Segment, Offset, Context);
    if (Status != XM_SUCCESS) {
        DbgPrint("HAL: Adapter initialization falied, status %lx\n", Status);
    }
    return Status;
}

XM_STATUS
x86BiosInitializeAdapterShadowedPci(
    IN ULONG Adapter,
    IN OUT PXM86_CONTEXT Context OPTIONAL,
    IN PVOID BiosIoSpace OPTIONAL,
    IN PVOID BiosIoMemory OPTIONAL,
    IN PVOID BiosFrameBuffer OPTIONAL,
    IN UCHAR NumberPciBusses,
    IN PGETSETPCIBUSDATA GetPciData,
    IN PGETSETPCIBUSDATA SetPciData
    )

/*++

Routine Description:

    This function initializes the adapter whose BIOS starts at the
    specified 20-bit address.

Arguments:

    Adpater - Supplies the 20-bit address of the BIOS for the adapter
        to be initialized.

Return Value:

    The emulation completion status.

--*/

{

    //
    // Enable PCI BIOS support.
    //

    XmPciBiosPresent = TRUE;
    XmGetPciData = GetPciData;
    XmSetPciData = SetPciData;
    XmNumberPciBusses = NumberPciBusses;

    //
    // Initialize the specified adapter.
    //

    return x86BiosInitializeAdapterShadowed(Adapter,
                                            Context,
                                            BiosIoSpace,
                                            BiosIoMemory,
                                            BiosFrameBuffer);
}

ULONG
x86BiosReadPciAddressPort(
    IN XM_OPERATION_DATATYPE DataType,
    IN USHORT PortNumber
    )

/*++

Routine Description:

    This function reads from emulated I/O space.

Arguments:

    DataType - Supplies the datatype for the read operation.

    PortNumber - Supplies the port number in I/O space to read from.

Return Value:

    The value read from I/O space is returned as the function value.

    N.B. If an aligned operation is specified, then the individual
        bytes are read from the specified port one at a time and
        assembled into the specified datatype.

--*/

{
    ULONG Result;

    //
    // We assume that DataType is the number of bytes - 1.  If this ever changes
    // then this routine needs to be rewritten.
    //
    C_ASSERT(BYTE_DATA == 0);
    C_ASSERT(WORD_DATA == 1);
    C_ASSERT(LONG_DATA == 3);

    //
    // If we don't have access to the HAL config space routines just return 0.
    //
    if (!XmPciBiosPresent) {
        return 0;
    }

    //
    // Make sure they aren't trying to read past the end of the register, we'll
    // fill any extra bytes with zeroes.
    //

    if ((PortNumber + DataType) > 3) {

        ASSERT(0);
        DataType = 3 - PortNumber;
    }

    //
    // Compute port address and read port.
    //

    switch (DataType) {

    case BYTE_DATA:
        Result = (ULONG)*(((PUCHAR)&XmPCIConfigAddress) + PortNumber);
        break;

    case WORD_DATA:
        Result = (ULONG)*(USHORT UNALIGNED *)(((PUCHAR)&XmPCIConfigAddress) + PortNumber);
        break;

    case 2:     // Special case that results from reading 4 bytes starting at port CF9
        Result = (ULONG)*(USHORT UNALIGNED *)(((PUCHAR)&XmPCIConfigAddress) + PortNumber);
        Result |= ((ULONG)*(((PUCHAR)&XmPCIConfigAddress) + 3)) << 16;
        break;

    case LONG_DATA:
        ASSERT(PortNumber == 0);
        Result = (ULONG)XmPCIConfigAddress;
        break;

    default:
        ASSERT(0);
        Result = 0;
        break;
    }

    return Result;
}

VOID
x86BiosWritePciAddressPort(
    IN XM_OPERATION_DATATYPE DataType,
    IN USHORT PortNumber,
    IN ULONG Value
    )

/*++

Routine Description:

    This function write to emulated I/O space.

    N.B. If an aligned operation is specified, then the individual
        bytes are written to the specified port one at a time.

Arguments:

    DataType - Supplies the datatype for the write operation.

    PortNumber - Supplies the port number in I/O space to write to.

    Value - Supplies the value to write.

Return Value:

    None.

--*/

{
    //
    // We assume that DataType is the number of bytes - 1.  If this ever changes
    // then this routine needs to be rewritten.
    //
    C_ASSERT(BYTE_DATA == 0);
    C_ASSERT(WORD_DATA == 1);
    C_ASSERT(LONG_DATA == 3);

    //
    // If we don't have access to the HAL config space routines just ignore.
    //
    if (!XmPciBiosPresent) {
        return;
    }

    //
    // Make sure they aren't trying to write past the end of the register, we'll
    // ignore any extra bytes.
    //

    if ((PortNumber + DataType) > 3) {

        ASSERT(0);
        DataType = 3 - PortNumber;
    }

    //
    // Compute port address and write port.
    //

    switch (DataType) {

    case BYTE_DATA:
        *(((PUCHAR)&XmPCIConfigAddress) + PortNumber) = (UCHAR)Value;
        break;

    case WORD_DATA:
        *(USHORT UNALIGNED *)(((PUCHAR)&XmPCIConfigAddress) + PortNumber) = (USHORT)Value;
        break;

    case 2:     // Special case that results from reading 4 bytes starting at port CF9
        *(USHORT UNALIGNED *)(((PUCHAR)&XmPCIConfigAddress) + PortNumber) = (USHORT)Value;
        *(((PUCHAR)&XmPCIConfigAddress) + 3) = (UCHAR)(Value >> 16);
        break;

    case LONG_DATA:
        ASSERT(PortNumber == 0);
        XmPCIConfigAddress = Value;
        break;

    default:
        ASSERT(0);
        break;
    }

    //
    // Clean up low order two bits, these are forced to zero in the real
    // hardware.
    //

    XmPCIConfigAddress &= ~0x3;

    return;
}

ULONG
x86BiosReadPciDataPort(
    IN XM_OPERATION_DATATYPE DataType,
    IN USHORT PortNumber
    )

/*++

Routine Description:

    This function reads from emulated I/O space.

Arguments:

    DataType - Supplies the datatype for the read operation.

    PortNumber - Supplies the port number in I/O space to read from.

Return Value:

    The value read from I/O space is returned as the function value.

    N.B. If an aligned operation is specified, then the individual
        bytes are read from the specified port one at a time and
        assembled into the specified datatype.

--*/

{
    ULONG Result;
    PCI_SLOT_NUMBER Slot;

    //
    // We assume that DataType is the number of bytes - 1.  If this ever changes
    // then this routine needs to be rewritten.
    //
    C_ASSERT(BYTE_DATA == 0);
    C_ASSERT(WORD_DATA == 1);
    C_ASSERT(LONG_DATA == 3);

    //
    // Make sure they aren't trying to read past the end of the register, we'll
    // ignore any extra bytes.
    //

    if ((PortNumber + DataType) > 3) {

        ASSERT(0);
        DataType = 3 - PortNumber;
    }

    //
    // Unpack the Slot/Function information
    //
    Slot.u.AsULONG = 0;
    Slot.u.bits.DeviceNumber   = (XmPCIConfigAddress >> 11) & 0x1F;
    Slot.u.bits.FunctionNumber = (XmPCIConfigAddress >> 8) & 0x07;

    if (XmGetPciData((XmPCIConfigAddress >> 16) & 0xFF,     // Bus Number
                     Slot.u.AsULONG,                        // Device, Function
                     &Result,
                     (XmPCIConfigAddress & 0xFF) | PortNumber,  // Offset
                     DataType + 1                               // Length
                     ) == 0)
    {
        Result = (ULONG)(1 << ((DataType + 1) << 3)) - 1;
    }

    return Result;
}

VOID
x86BiosWritePciDataPort(
    IN XM_OPERATION_DATATYPE DataType,
    IN USHORT PortNumber,
    IN ULONG Value
    )

/*++

Routine Description:

    This function write to emulated I/O space.

    N.B. If an aligned operation is specified, then the individual
        bytes are written to the specified port one at a time.

Arguments:

    DataType - Supplies the datatype for the write operation.

    PortNumber - Supplies the port number in I/O space to write to.

    Value - Supplies the value to write.

Return Value:

    None.

--*/

{
    PCI_SLOT_NUMBER Slot;

    //
    // We assume that DataType is the number of bytes - 1.  If this ever changes
    // then this routine needs to be rewritten.
    //
    C_ASSERT(BYTE_DATA == 0);
    C_ASSERT(WORD_DATA == 1);
    C_ASSERT(LONG_DATA == 3);

    //
    // Make sure they aren't trying to write past the end of the register, we'll
    // ignore any extra bytes.
    //

    if ((PortNumber + DataType) > 3) {

        ASSERT(0);
        DataType = 3 - PortNumber;
    }

    //
    // Unpack the Slot/Function information
    //
    Slot.u.AsULONG = 0;
    Slot.u.bits.DeviceNumber   = (XmPCIConfigAddress >> 11) & 0x1F;
    Slot.u.bits.FunctionNumber = (XmPCIConfigAddress >> 8) & 0x07;

    if (XmSetPciData((XmPCIConfigAddress >> 16) & 0xFF,     // Bus Number
                     Slot.u.AsULONG,                        // Device, Function
                     &Value,
                     (XmPCIConfigAddress & 0xFF) | PortNumber,  // Offset
                     DataType + 1                               // Length
                     ) == 0)
    {
        ASSERT(0);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\hals\x86new\shiftops.c ===
/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    mulops.c

Abstract:

    This module implements the code to emulate the shift opcodes.

Author:

    David N. Cutler (davec) 21-Sep-1994

Environment:

    Kernel mode only.

Revision History:

--*/

#include "nthal.h"
#include "emulate.h"

VOID
XmRolOp (
    IN PRXM_CONTEXT P
    )

/*++

Routine Description:

    This function emulates a rol opcode.

Arguments:

    P - Supplies a pointer to the emulation context structure.

Return Value:

    None.

--*/

{

    ULONG Carry;
    ULONG Count;
    ULONG Mask;
    ULONG Shift;
    ULONG Value;

    //
    // Rotate destination left and store result.
    //

    Shift = ((P->DataType + 1) << 3) - 1;
    Mask = ((1 << Shift) - 1) | (1 << Shift);
    Value = P->DstValue.Long;
    Count = P->SrcValue.Long & Shift;
    if (Count != 0) {
        if (Count == 1) {
            P->Eflags.EFLAG_OF = (Value >> Shift) ^ (Value >> (Shift - 1));
        }

        do {
            Carry = Value >> Shift;
            Value = Carry | ((Value << 1) & Mask);
            Count -= 1;
        } while (Count != 0);

        P->Eflags.EFLAG_CF = Carry;
    }

    XmStoreResult(P, Value);
    return;
}

VOID
XmRorOp (
    IN PRXM_CONTEXT P
    )

/*++

Routine Description:

    This function emulates a ror opcode.

Arguments:

    P - Supplies a pointer to the emulation context structure.

Return Value:

    None.

--*/

{

    ULONG Carry;
    ULONG Count;
    ULONG Shift;
    ULONG Value;

    //
    // Rotate destination right and store result.
    //

    Shift = ((P->DataType + 1) << 3) - 1;
    Value = P->DstValue.Long;
    Count = P->SrcValue.Long & Shift;
    if (Count != 0) {
        if (Count == 1) {
            P->Eflags.EFLAG_OF = (Value >> Shift) ^ (Value & 0x1);
        }

        do {
            Carry = Value & 1;
            Value = (Carry << Shift) | (Value >> 1);
            Count -= 1;
        } while (Count != 0  );

        P->Eflags.EFLAG_CF = Carry;
    }

    XmStoreResult(P, Value);
    return;
}

VOID
XmRclOp (
    IN PRXM_CONTEXT P
    )

/*++

Routine Description:

    This function emulates a rcl opcode.

Arguments:

    P - Supplies a pointer to the emulation context structure.

Return Value:

    None.

--*/

{

    ULONG Carry;
    ULONG Count;
    ULONG Mask;
    ULONG Shift;
    ULONG Temp;
    ULONG Value;

    //
    // Rotate destination left through carry and store result.
    //

    Shift = ((P->DataType + 1) << 3) - 1;
    Mask = ((1 << Shift) - 1) | (1 << Shift);
    Value = P->DstValue.Long;
    Count = P->SrcValue.Long & Shift;
    Carry = P->Eflags.EFLAG_CF;
    if (Count != 0) {
        if (Count == 1) {
            P->Eflags.EFLAG_OF = (Value >> Shift) ^ (Value >> (Shift - 1));
        }

        do  {
            Temp = Value >> Shift;
            Value = ((Value << 1) & Mask) | Carry;
            Carry = Temp;
            Count -= 1;
        } while (Count != 0);
    }

    XmStoreResult(P, Value);
    P->Eflags.EFLAG_CF = Carry;
    return;
}

VOID
XmRcrOp (
    IN PRXM_CONTEXT P
    )

/*++

Routine Description:

    This function emulates a rcr opcode.

Arguments:

    P - Supplies a pointer to the emulation context structure.

Return Value:

    None.

--*/

{

    ULONG Carry;
    ULONG Count;
    ULONG Shift;
    ULONG Temp;
    ULONG Value;

    //
    // Rotate destination right through carry and store result.
    //

    Shift = ((P->DataType + 1) << 3) - 1;
    Value = P->DstValue.Long;
    Count = P->SrcValue.Long & Shift;
    Carry = P->Eflags.EFLAG_CF;
    if (Count != 0) {
        if (Count == 1) {
            P->Eflags.EFLAG_OF = (Value >> Shift) ^ Carry;
        }

        do  {
            Temp = Value & 1;
            Value = (Carry << Shift) | (Value >> 1);
            Carry = Temp;
            Count -= 1;
        } while (Count != 0);
    }

    XmStoreResult(P, Value);
    P->Eflags.EFLAG_CF = Carry;
    return;
}

VOID
XmShlOp (
    IN PRXM_CONTEXT P
    )

/*++

Routine Description:

    This function emulates a shl opcode.

Arguments:

    P - Supplies a pointer to the emulation context structure.

Return Value:

    None.

--*/

{

    ULONG Carry;
    ULONG Count;
    ULONG Overflow;
    ULONG Shift;
    ULONG Value;

    //
    // Shift destination left logical and store result.
    //

    Shift = ((P->DataType + 1) << 3) - 1;
    Value = P->DstValue.Long;
    Count = P->SrcValue.Long;
    if (Count != 0) {
        if (P->DataType == LONG_DATA) {
            Overflow = (Value ^ (Value << 1)) >> 31;
            Carry = Value >> (32 - Count);
            Value <<= Count;

        } else if (P->DataType == WORD_DATA) {
            Overflow = (Value ^ (Value << 1)) >> 15;
            Carry = Value >> (16 - Count);
            Value = (Value << Count) & 0xffff;

        } else {
            Overflow = (Value ^ (Value << 1)) >> 7;
            Carry = Value >> (8 - Count);
            Value = (Value << Count) & 0xff;
        }

        P->Eflags.EFLAG_CF = Carry;
        P->Eflags.EFLAG_OF = Overflow;
        P->Eflags.EFLAG_PF = XmComputeParity(Value);
        P->Eflags.EFLAG_ZF = (Value == 0);
        P->Eflags.EFLAG_SF = Value >> Shift;
    }

    XmStoreResult(P, Value);
    return;
}

VOID
XmShrOp (
    IN PRXM_CONTEXT P
    )

/*++

Routine Description:

    This function emulates a shr opcode.

Arguments:

    P - Supplies a pointer to the emulation context structure.

Return Value:

    None.

--*/

{

    ULONG Carry;
    ULONG Count;
    ULONG Overflow;
    ULONG Shift;
    ULONG Value;

    //
    // Shift destination right logical and store result.
    //

    Shift = ((P->DataType + 1) << 3) - 1;
    Value = P->DstValue.Long;
    Count = P->SrcValue.Long;
    if (Count != 0) {
        if (P->DataType == LONG_DATA) {
            Overflow = Value >> 31;
            Carry = Value >> (Count - 1);
            Value >>= Count;

        } else if (P->DataType == WORD_DATA) {
            Overflow = Value >> 15;
            Carry = Value >> (Count - 1);
            Value >>= Count;

        } else {
            Overflow = Value >> 7;
            Carry = Value >> (Count - 1);
            Value >>= Count;
        }

        P->Eflags.EFLAG_CF = Carry;
        P->Eflags.EFLAG_OF = Overflow;
        P->Eflags.EFLAG_PF = XmComputeParity(Value);
        P->Eflags.EFLAG_ZF = (Value == 0);
        P->Eflags.EFLAG_SF = Value >> Shift;
    }

    XmStoreResult(P, Value);
    return;
}

VOID
XmSarOp (
    IN PRXM_CONTEXT P
    )

/*++

Routine Description:

    This function emulates a sar opcode.

Arguments:

    P - Supplies a pointer to the emulation context structure.

Return Value:

    None.

--*/

{

    ULONG Carry;
    ULONG Count;
    ULONG Shift;
    LONG Value;

    //
    // Shift destination right arithmetic and store result.
    //

    Shift = ((P->DataType + 1) << 3) - 1;
    Value = (LONG)P->DstValue.Long;
    Count = P->SrcValue.Long;
    if (Count != 0) {
        if (P->DataType == LONG_DATA) {
            Carry = Value >> (Count - 1);
            Value >>= Count;

        } else if (P->DataType == WORD_DATA) {
            Carry = Value >> (Count - 1);
            Value = ((Value << 16) >> (Count + 16)) & 0xffff;

        } else {
            Carry = Value >> (Count - 1);
            Value = ((Value << 24) >> (Count + 24)) & 0xff;
        }

        P->Eflags.EFLAG_CF = Carry;
        P->Eflags.EFLAG_OF = 0;
        P->Eflags.EFLAG_PF = XmComputeParity(Value);
        P->Eflags.EFLAG_ZF = (Value == 0);
        P->Eflags.EFLAG_SF = Value >> Shift;
    }

    XmStoreResult(P, (ULONG)Value);
    return;
}

VOID
XmShldOp (
    IN PRXM_CONTEXT P
    )

/*++

Routine Description:

    This function emulates a shld opcode.

Arguments:

    P - Supplies a pointer to the emulation context structure.

Return Value:

    None.

--*/

{

    ULONG Carry;
    ULONG Count;
    ULONG High;
    ULONG Low;
    ULONG Sign;

    //
    // Double shift left logical and store result.
    //
    // The low 32-bits of the shift are the source.
    // The high 32-bits of the shift are the destination.
    // The shift count has been masked modulo the datatype.
    //
    // This shift is equivalent to extracting the high 32-bits of the left
    // shifted result.
    //

    Low = P->SrcValue.Long;
    High = P->DstValue.Long;
    Count = P->Shift;
    if (Count != 0) {
        if (P->DataType == LONG_DATA) {
            if (Count == 1) {
                P->Eflags.EFLAG_OF = (High ^ (High << 1)) >> 31;
            }

            Carry = High >> (32 - Count);
            High = (High << Count) | (Low >> (32 - Count));
            Sign = High >> 31;

        } else {
            if (Count == 1) {
                P->Eflags.EFLAG_OF = (High ^ (High << 1)) >> 15;
            }

            Carry = High >> (16 - Count);
            High = ((High << Count) | (Low >> (16 - Count))) & 0xffff;
            Sign = High >> 15;
        }

        P->Eflags.EFLAG_CF = Carry;
        P->Eflags.EFLAG_PF = XmComputeParity(High);
        P->Eflags.EFLAG_ZF = (High == 0);
        P->Eflags.EFLAG_SF = Sign;
    }

    XmStoreResult(P, High);
    return;
}

VOID
XmShrdOp (
    IN PRXM_CONTEXT P
    )

/*++

Routine Description:

    This function emulates a shrd opcode.

Arguments:

    P - Supplies a pointer to the emulation context structure.

Return Value:

    None.

--*/

{

    ULONG Carry;
    ULONG Count;
    ULONG High;
    ULONG Low;
    ULONG Sign;

    //
    // Double shift right logical and store result.
    //
    // The high 32-bits of the shift are the source.
    // The low 32-bits of the shift are the destination.
    // The shift count has been masked modulo the datatype.
    //
    // This shift is equivalent to extracting the low 32-bits of the right
    // shifted result.
    //

    High = P->SrcValue.Long;
    Low = P->DstValue.Long;
    Count = P->Shift;
    if (Count != 0) {
        if (P->DataType == LONG_DATA) {
            if (Count == 1) {
                P->Eflags.EFLAG_OF = High ^ (Low >> 31);
            }

            Carry = Low >> (Count - 1);
            Low = (High << (32 - Count)) | (Low >> Count);
            Sign = Low >> 31;

        } else {
            if (Count == 1) {
                P->Eflags.EFLAG_OF = High ^ (Low >> 15);
            }

            Carry = Low >> (Count - 1);
            Low = ((High << (16 - Count)) | (Low >> Count)) & 0xffff;
            Sign = Low >> 15;
        }

        P->Eflags.EFLAG_CF = Carry;
        P->Eflags.EFLAG_PF = XmComputeParity(Low);
        P->Eflags.EFLAG_ZF = (Low == 0);
        P->Eflags.EFLAG_SF = Sign;
    }

    XmStoreResult(P, Low);
    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\hals\x86new\utility.c ===
/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    utility.c

Abstract:

    This module implements utility functions.

Author:

    David N. Cutler (davec) 7-Sep-1994

Environment:

    Kernel mode only.

Revision History:

--*/

#include "nthal.h"
#include "emulate.h"

//
// Define bit count array.
//

UCHAR XmBitCount[] = {0, 1, 1, 2, 1, 2, 2, 3, 1, 2, 2, 3, 2, 3, 3, 4};

ULONG
XmComputeParity (
    IN ULONG Result
    )

/*++

Routine Description:

    This function computes the parity of the low byte of the specified
    result.

Arguments:

    Result - Supplies the result for which the parity flag is computed.

Return Value:

    The parity flag value.

--*/

{

    ULONG Count;

    //
    // Sum the bits in the result and return the complement of the low bit.
    //

    Count = XmBitCount[Result & 0xf];
    Count += XmBitCount[(Result >> 4) & 0xf];
    return (~Count) & 1;
}

UCHAR
XmGetCodeByte (
    IN PRXM_CONTEXT P
    )

/*++

Routine Description:

    This function gets the next code byte from the instruction stream.

Arguments:

    P - Supplies a pointer to an emulator context structure.

Return Value:

    The next byte form the instruction stream.

--*/

{

    ULONG Offset;

    //
    // If the current IP is within the code segment, then return the
    // next byte from the instrcution stream and increment the IP value.
    // Otherwise, raise an exception.
    //

    Offset = P->Eip;
    if (Offset > P->SegmentLimit[CS]) {
        longjmp(&P->JumpBuffer[0], XM_SEGMENT_LIMIT_VIOLATION);
    }

    P->Ip += 1;
    return *(PUCHAR)((P->TranslateAddress)(P->SegmentRegister[CS], (USHORT)Offset));
}

UCHAR
XmGetByteImmediate (
    IN PRXM_CONTEXT P
    )

/*++

Routine Description:

    This function gets an unsigned immediate byte operand from the
    code stream and returns a byte value.

Arguments:

    P - Supplies a pointer to an emulator context structure.

Return Value:

    The next byte from the instruction stream.

--*/

{

    UCHAR Byte;

    //
    // Get immediate byte from the code stream.
    //

    Byte = XmGetCodeByte(P);
    XmTraceInstruction(BYTE_DATA, (ULONG)Byte);
    return Byte;
}

USHORT
XmGetByteImmediateToWord (
    IN PRXM_CONTEXT P
    )

/*++

Routine Description:

    This function gets an unsigned immediate byte operand from the
    code stream and returns a zero extended byte to word value.

Arguments:

    P - Supplies a pointer to an emulator context structure.

Return Value:

    The next byte from the instruction stream zero extended to a word.

--*/

{

    USHORT Word;

    //
    // Get immediate byte from the code stream.
    //

    Word = XmGetCodeByte(P);
    XmTraceInstruction(BYTE_DATA, (ULONG)((UCHAR)Word));
    return Word;
}

ULONG
XmGetByteImmediateToLong (
    IN PRXM_CONTEXT P
    )

/*++

Routine Description:

    This function gets an unsigned immediate byte operand from the
    code stream and returns a zero extended byte to long value.

Arguments:

    P - Supplies a pointer to an emulator context structure.

Return Value:

    The next byte from the instruction stream zero extended to a long.

--*/

{

    ULONG Long;

    //
    // Get immediate byte from the code stream.
    //

    Long = XmGetCodeByte(P);
    XmTraceInstruction(BYTE_DATA, (ULONG)((UCHAR)Long));
    return Long;
}

USHORT
XmGetSignedByteImmediateToWord (
    IN PRXM_CONTEXT P
    )

/*++

Routine Description:

    This function gets an unsigned immediate byte operand from the
    code stream and returns a sign extended byte to word value.

Arguments:

    P - Supplies a pointer to an emulator context structure.

Return Value:

    The next byte from the instruction stream sign extended to a word.

--*/

{

    USHORT Word;

    //
    // Get immediate byte from the code stream.
    //

    Word = (USHORT)((SHORT)((SCHAR)XmGetCodeByte(P)));
    XmTraceInstruction(BYTE_DATA, (ULONG)((UCHAR)Word));
    return Word;
}

ULONG
XmGetSignedByteImmediateToLong (
    IN PRXM_CONTEXT P
    )

/*++

Routine Description:

    This function gets an unsigned immediate byte operand from the
    code stream and returns a sign extended byte to long value.

Arguments:

    P - Supplies a pointer to an emulator context structure.

Return Value:

    The next byte from the instruction stream sign extended to a long.

--*/

{

    ULONG Long;

    //
    // Get immediate byte from the code stream.
    //

    Long = (ULONG)((LONG)((SCHAR)XmGetCodeByte(P)));
    XmTraceInstruction(BYTE_DATA, (ULONG)((UCHAR)Long));
    return Long;
}

USHORT
XmGetWordImmediate (
    IN PRXM_CONTEXT P
    )

/*++

Routine Description:

    This function gets an unsigned immediate word operand from the
    code stream and returns a word value.

Arguments:

    P - Supplies a pointer to an emulator context structure.

Return Value:

    The next word from the instruction stream.

--*/

{

    USHORT Word;

    //
    // Get immediate word from the code stream.
    //

    Word = XmGetCodeByte(P);
    Word += XmGetCodeByte(P) << 8;
    XmTraceInstruction(WORD_DATA, (ULONG)Word);
    return Word;
}

ULONG
XmGetLongImmediate (
    IN PRXM_CONTEXT P
    )

/*++

Routine Description:

    This function gets an unsigned immediate long operand from the
    code stream and returns a long value.

Arguments:

    P - Supplies a pointer to an emulator context structure.

Return Value:

    The next long from the instruction stream.

--*/

{

    ULONG Long;

    //
    // Get immediate long from the code stream.
    //

    Long = XmGetCodeByte(P);
    Long += XmGetCodeByte(P) << 8;
    Long += XmGetCodeByte(P) << 16;
    Long += XmGetCodeByte(P) << 24;
    XmTraceInstruction(LONG_DATA, Long);
    return Long;
}

ULONG
XmPopStack (
    IN PRXM_CONTEXT P
    )

/*++

Routine Description:

    This function pops an operand from the stack.

Arguments:

    P - Supplies a pointer to the emulation context structure.

Return Value:

    None.

--*/

{

    ULONG Offset;

    //
    // Compute the new stack address and compare against the segment limit.
    // If the new address is greater than the limit, then raise an exception.
    // Otherwise, perform the push operation.
    //

    Offset = P->Gpr[ESP].Exx;
    if (Offset > (ULONG)(P->SegmentLimit[SS] - P->DataType)) {
        longjmp(&P->JumpBuffer[0], XM_STACK_UNDERFLOW);
    }

    P->Gpr[ESP].Exx += (P->DataType + 1);
    XmSetSourceValue(P, (P->TranslateAddress)(P->SegmentRegister[SS], (USHORT)Offset));
    return P->SrcValue.Long;
}

VOID
XmPushStack (
    IN PRXM_CONTEXT P,
    IN ULONG Value
    )

/*++

Routine Description:

    This function pushes an operand on the stack.

Arguments:

    P - Supplies a pointer to the emulation context structure.

    Value - Supplies the value to be pushed.

Return Value:

    None.

--*/

{

    ULONG Offset;

    //
    // Compute the new stack address and compare against the segment limit.
    // If the new address is greater than the limit, then raise an exception.
    // Otherwise, perform the push operation.
    //

    Offset = P->Gpr[ESP].Exx - P->DataType - 1;
    if (Offset > (ULONG)(P->SegmentLimit[SS] - P->DataType)) {
        longjmp(&P->JumpBuffer[0], XM_STACK_OVERFLOW);
    }

    P->Gpr[ESP].Exx = Offset;
    P->DstLong = (ULONG UNALIGNED *)((P->TranslateAddress)(P->SegmentRegister[SS],
                                                           (USHORT)Offset));

    XmStoreResult(P, Value);
    return;
}

VOID
XmSetDataType (
    IN PRXM_CONTEXT P
    )

/*++

Routine Description:

    This function sets the data type of the operation based on the width
    bit of the current opcode.

Arguments:

    P - Supplies a pointer to an emulator context structure.

Return Value:

    None.

--*/

{

    //
    // If the width bit is zero, then the data type is byte. Otherwise,
    // the datatype is determined by the presence of absence of a operand
    // size prefix.
    //

    if ((P->CurrentOpcode & WIDTH_BIT) == 0) {
        P->DataType = BYTE_DATA;

    } else if (P->OpsizePrefixActive != FALSE) {
        P->DataType = LONG_DATA;

    } else {
        P->DataType = WORD_DATA;
    }

    return;
}

VOID
XmStoreResult (
    IN PRXM_CONTEXT P,
    IN ULONG Result
    )

/*++

Routine Description:

    This function stores the result of an operation.

Arguments:

    P - Supplies a pointer to an emulator context structure.

    Result - Supplies the result value to store.

Return Value:

    None.

--*/

{

    //
    // Store result of operation.
    //

    if (P->DataType == BYTE_DATA) {
        *P->DstByte = (UCHAR)Result;

    } else if (P->DataType == WORD_DATA) {
        if (((ULONG_PTR)P->DstWord & 0x1) == 0) {
            *((PUSHORT)(P->DstWord)) = (USHORT)Result;

        } else {
            *P->DstWord = (USHORT)Result;
        }

    } else {

#ifdef _IA64_

        //
        // Hack to force the compiler to generate unaligned
        // accesses.  We can remove it when the compiler is
        // fixed.
        //

        *P->DstLong = Result;
#else
       
        if (((ULONG_PTR)P->DstLong & 0x3) == 0) {
            *((PULONG)(P->DstLong)) = Result;

        } else {
            *P->DstLong = Result;

       }

#endif // #ifdef _IA64_ 

    }

    XmTraceResult(P, Result);
    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\hals\x86new\xm86.h ===
/*++ BUILD Version: 0000    // Increment this if a change has global effects

Copyright (c) 1994  Microsoft Corporation

Module Name:

    xm86.h

Abstract:

    This module contains the public header file that describes the
    interfaces to the 386/486 real mode emulator.

Author:

    David N. Cutler (davec) 13-Nov-1994

Revision History:

--*/

#ifndef _XM86_
#define _XM86_

//
// Define internal error codes.
//

typedef enum _XM_STATUS {
    XM_SUCCESS = 1,
    XM_DIVIDE_BY_ZERO,
    XM_DIVIDE_QUOTIENT_OVERFLOW,
    XM_EMULATOR_NOT_INITIALIZED,
    XM_HALT_INSTRUCTION,
    XM_ILLEGAL_CODE_SEGMENT,
    XM_ILLEGAL_INDEX_SPECIFIER,
    XM_ILLEGAL_LEVEL_NUMBER,
    XM_ILLEGAL_PORT_NUMBER,
    XM_ILLEGAL_GENERAL_SPECIFIER,
    XM_ILLEGAL_REGISTER_SPECIFIER,
    XM_ILLEGAL_INSTRUCTION_OPCODE,
    XM_INDEX_OUT_OF_BOUNDS,
    XM_SEGMENT_LIMIT_VIOLATION,
    XM_STACK_OVERFLOW,
    XM_STACK_UNDERFLOW,
    XM_MAXIMUM_INTERNAL_CODE
} XM_STATUS;

//
// Define operand data types.
//

typedef enum _XM_OPERATION_DATATYPE {
    BYTE_DATA = 0,
    WORD_DATA = 1,
    LONG_DATA = 3
} XM_OPERATION_DATATYPE;

//
// Define emulator context structure.
//

typedef struct _XM86_CONTEXT {
    ULONG Eax;
    ULONG Ecx;
    ULONG Edx;
    ULONG Ebx;
    ULONG Ebp;
    ULONG Esi;
    ULONG Edi;
    USHORT SegDs;
    USHORT SegEs;
} XM86_CONTEXT, *PXM86_CONTEXT;

//
// Define address translation callback function type.
//

typedef
PVOID
(*PXM_TRANSLATE_ADDRESS) (
    IN USHORT Segment,
    IN USHORT Offset
    );

//
// Define read and write I/O space callback function types.
//

typedef
ULONG
(*PXM_READ_IO_SPACE) (
    IN XM_OPERATION_DATATYPE DataType,
    IN USHORT PortNumber
    );

typedef
VOID
(*PXM_WRITE_IO_SPACE) (
    IN XM_OPERATION_DATATYPE DataType,
    IN USHORT PortNumber,
    IN ULONG Value
    );

//
// Define emulator public interface function prototypes.
//

XM_STATUS
XmEmulateFarCall (
    IN USHORT Segment,
    IN USHORT Offset,
    IN OUT PXM86_CONTEXT Context
    );

XM_STATUS
XmEmulateInterrupt (
    IN UCHAR Interrupt,
    IN OUT PXM86_CONTEXT Context
    );

VOID
XmInitializeEmulator (
    IN USHORT StackSegment,
    IN USHORT StackOffset,
    IN PXM_READ_IO_SPACE ReadIoSpace,
    IN PXM_WRITE_IO_SPACE WriteIoSpace,
    IN PXM_TRANSLATE_ADDRESS TranslateAddress
    );

#endif // _XM86_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\hals\x86new\x86new.h ===
/*++ BUILD Version: 0000    // Increment this if a change has global effects

Copyright (c) 1994  Microsoft Corporation

Module Name:

    x86new.h

Abstract:

    This module contains the public header file that describes the
    HAL interfaces to the 386/486 BIOS emulation.

Author:

    David N. Cutler (davec) 13-Nov-1994

Revision History:

--*/

#ifndef _X86NEW_
#define _X86NEW_

//
// PCI Bios function code defintitions.
//
// AH:
//

#define PCI_FUNCTION_ID         0xb1

//
// AL:
//

#define PCI_BIOS_PRESENT        0x01
#define PCI_FIND_DEVICE         0x02
#define PCI_FIND_CLASS_CODE     0x03
#define PCI_GENERATE_CYCLE      0x06
#define PCI_READ_CONFIG_BYTE    0x08
#define PCI_READ_CONFIG_WORD    0x09
#define PCI_READ_CONFIG_DWORD   0x0a
#define PCI_WRITE_CONFIG_BYTE   0x0b
#define PCI_WRITE_CONFIG_WORD   0x0c
#define PCI_WRITE_CONFIG_DWORD  0x0d
#define PCI_GET_IRQ_ROUTING     0x0e
#define PCI_SET_IRQ             0x0f

//
// PCI Bios function return code values.
//

#define PCI_SUCCESS             0x00
#define PCI_NOT_SUPPORTED       0x81
#define PCI_BAD_VENDOR_ID       0x83
#define PCI_DEVICE_NOT_FOUND    0x86
#define PCI_BAD_REGISTER        0x87
#define PCI_SET_FAILED          0x88
#define PCI_BUFFER_TOO_SMALL    0x89

//
// Miscellaneous PCI codes.
//

#define PCI_CONFIG_MECHANISM_2  0x02
#define PCI_ILLEGAL_VENDOR_ID   0xffff

//
// Define PCI get/set function type.
//

typedef
ULONG
(*PGETSETPCIBUSDATA)(
    IN ULONG BusNumber,
    IN ULONG SlotNumber,
    IN PVOID Buffer,
    IN ULONG Offset,
    IN ULONG Length
    );

//
// Define BIOS emulation interfaces.
//

VOID
x86BiosInitializeBios (
    IN PVOID BiosIoSpace,
    IN PVOID BiosIoMemory
    );

VOID
x86BiosInitializeBiosEx (
    IN PVOID BiosIoSpace,
    IN PVOID BiosIoMemory,
    IN PVOID BiosFrameBuffer,
    IN PVOID BiosTransferMemory,
    IN ULONG TransferLength
    );

VOID
x86BiosInitializeBiosShadowed (
    IN PVOID BiosIoSpace,
    IN PVOID BiosIoMemory,
    IN PVOID BiosFrameBuffer
    );

VOID
x86BiosInitializeBiosShadowedPci (
    IN PVOID BiosIoSpace,
    IN PVOID BiosIoMemory,
    IN PVOID BiosFrameBuffer,
    IN UCHAR NumberPciBusses,
    IN PGETSETPCIBUSDATA GetPciData,
    IN PGETSETPCIBUSDATA SetPciData
    );

XM_STATUS
x86BiosExecuteInterrupt (
    IN UCHAR Number,
    IN OUT PXM86_CONTEXT Context,
    IN PVOID BiosIoSpace OPTIONAL,
    IN PVOID BiosIoMemory OPTIONAL
    );

XM_STATUS
x86BiosExecuteInterruptShadowed (
    IN UCHAR Number,
    IN OUT PXM86_CONTEXT Context,
    IN PVOID BiosIoSpace OPTIONAL,
    IN PVOID BiosIoMemory OPTIONAL,
    IN PVOID BiosFrameBuffer OPTIONAL
    );

XM_STATUS
x86BiosExecuteInterruptShadowedPci (
    IN UCHAR Number,
    IN OUT PXM86_CONTEXT Context,
    IN PVOID BiosIoSpace OPTIONAL,
    IN PVOID BiosIoMemory OPTIONAL,
    IN PVOID BiosFrameBuffer OPTIONAL,
    IN UCHAR NumberPciBusses,
    IN PGETSETPCIBUSDATA GetPciData,
    IN PGETSETPCIBUSDATA SetPciData
    );

XM_STATUS
x86BiosInitializeAdapter (
    IN ULONG Adapter,
    IN OUT PXM86_CONTEXT Context OPTIONAL,
    IN PVOID BiosIoSpace OPTIONAL,
    IN PVOID BiosIoMemory OPTIONAL
    );

XM_STATUS
x86BiosInitializeAdapterShadowed (
    IN ULONG Adapter,
    IN OUT PXM86_CONTEXT Context OPTIONAL,
    IN PVOID BiosIoSpace OPTIONAL,
    IN PVOID BiosIoMemory OPTIONAL,
    IN PVOID BiosFrameBuffer OPTIONAL
    );

XM_STATUS
x86BiosInitializeAdapterShadowedPci(
    IN ULONG Adapter,
    IN OUT PXM86_CONTEXT Context OPTIONAL,
    IN PVOID BiosIoSpace OPTIONAL,
    IN PVOID BiosIoMemory OPTIONAL,
    IN PVOID BiosFrameBuffer OPTIONAL,
    IN UCHAR NumberPciBusses,
    IN PGETSETPCIBUSDATA GetPciData,
    IN PGETSETPCIBUSDATA SetPciData
    );

#endif // _X86NEW_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\headless\bootprov\bootinstprov.cpp ===
//***************************************************************************
//
//  INSTPRO.CPP
//
//  Module: WMI Instance provider code for Boot Parameters
//
//  Purpose: Defines the CInstPro class.  An object of this class is
//           created by the class factory for each connection.
//
//  Copyright (c) 1997-1999 Microsoft Corporation
//
//***************************************************************************

#include <objbase.h>
#include "bootini.h"
#include <process.h>


//***************************************************************************
//
// CBootInstPro::CBootInstPro
// CBootInstPro::~CInstPro
//
//***************************************************************************

CBootInstPro::CBootInstPro(BSTR ObjectPath, BSTR User, BSTR Password, IWbemContext * pCtx)
{
    m_pNamespace = NULL;
    m_cRef=0;
    InterlockedIncrement(&g_cObj);
    return;
}

CBootInstPro::~CBootInstPro(void)
{
    if(m_pNamespace)
        m_pNamespace->Release();
    InterlockedDecrement(&g_cObj);
    return;
}

//***************************************************************************
//
// CBootInstPro::QueryInterface
// CBootInstPro::AddRef
// CBootInstPro::Release
//
// Purpose: IUnknown members for CInstPro object.
//***************************************************************************


STDMETHODIMP CBootInstPro::QueryInterface(REFIID riid, PPVOID ppv)
{
    *ppv=NULL;

    // Since we have dual inheritance, it is necessary to cast the return type

    if(riid== IID_IWbemServices)
       *ppv=(IWbemServices*)this;

    if(IID_IUnknown==riid || riid== IID_IWbemProviderInit)
       *ppv=(IWbemProviderInit*)this;
    

    if (NULL!=*ppv) {
        AddRef();
        return NOERROR;
        }
    else
        return E_NOINTERFACE;
  
}


STDMETHODIMP_(ULONG) CBootInstPro::AddRef(void)
{
    return ++m_cRef;
}

STDMETHODIMP_(ULONG) CBootInstPro::Release(void)
{
    ULONG nNewCount = InterlockedDecrement((long *)&m_cRef);
    if (0L == nNewCount)
        delete this;
    
    return nNewCount;
}

/***********************************************************************
*                                                                      *
*   CBootInstPro::Initialize                                                *
*                                                                      *
*   Purpose: This is the implementation of IWbemProviderInit. The method  *
*   is need to initialize with CIMOM.                                    *
*                                                                      *
***********************************************************************/

STDMETHODIMP CBootInstPro::Initialize(LPWSTR pszUser,
                                  LONG lFlags,
                                  LPWSTR pszNamespace,
                                  LPWSTR pszLocale,
                                  IWbemServices *pNamespace, 
                                  IWbemContext *pCtx,
                                  IWbemProviderInitSink *pInitSink
                                  )
{
    if(pNamespace)
        pNamespace->AddRef();
    m_pNamespace = pNamespace;

    //Let CIMOM know you are initialized
    //==================================
    
    pInitSink->SetStatus(WBEM_S_INITIALIZED,0);
    return WBEM_S_NO_ERROR;
}




//***************************************************************************
//
// CBootInstPro::GetObjectByPath
// CBootInstPro::GetObjectByPathAsync
//
// Purpose: Creates an instance given a particular path value.
//
//***************************************************************************



SCODE CBootInstPro::GetObjectAsync(const BSTR ObjectPath,
                                   long lFlags,
                                   IWbemContext  *pCtx,
                                   IWbemObjectSink FAR* pHandler
                                   )
{
    SCODE sc;
    int iCnt;
    IWbemClassObject FAR* pNewInst;
    IWbemClassObject FAR* pNewOSInst;
    IWbemClassObject *pClass;
  

    // Do a check of arguments and make sure we have pointer to Namespace

    if(pHandler == NULL || m_pNamespace == NULL)
        return WBEM_E_INVALID_PARAMETER;
    if(wcscmp(ObjectPath,L"BootLoaderParameters=@") == 0){
        // fill in the loader parameters and return
        sc = m_pNamespace->GetObject(L"BootLoaderParameters", 0, pCtx, &pClass, NULL);
        if(sc != S_OK){
            return WBEM_E_FAILED;
        }
        sc = pClass->SpawnInstance(0,&pNewInst);
        if(FAILED(sc)){
            return sc;
        }
        pClass->Release();
        sc = GetBootLoaderParameters(m_pNamespace, pNewInst, pCtx);
        if(sc != S_OK){
            pNewInst->Release();
            return sc;
        }
        pHandler->Indicate(1,&pNewInst);
        pNewInst->Release();
        pHandler->SetStatus(0,sc,NULL, NULL);
        return S_OK;
    }
    return WBEM_E_INVALID_PARAMETER;
 
}

SCODE CBootInstPro::PutInstanceAsync(IWbemClassObject *pInst,
                                     long lFlags,
                                     IWbemContext  *pCtx,
                                     IWbemObjectSink FAR* pHandler
                                     )
{
    IWbemClassObject *pClass;
    IWbemClassObject *pOldInst;
    SCODE sc;


    if(pHandler == NULL || m_pNamespace == NULL)
        return WBEM_E_INVALID_PARAMETER;
    sc = m_pNamespace->GetObject(L"OSParameters", 0, pCtx, &pClass, NULL);
    if(sc != S_OK){
        return WBEM_E_FAILED;
    }
    
    LONG ret = SaveBootFile(pInst,pClass);
    pClass->Release();
    if (ret) {
        return WBEM_E_FAILED;
    }
    pHandler->SetStatus(0,sc,NULL, NULL);
    return WBEM_S_NO_ERROR;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\headless\bootprov\debug.cpp ===
#include "bootini.h"

#if DBG==1
VOID LogTrace(ULONG trace,
             PCHAR str
             )
{
    DWORD len;

    HANDLE fh = CreateFile("bootinstprov.log",
                           GENERIC_READ|GENERIC_WRITE,
                           0,// Exclusive Access
                           NULL,
                           OPEN_ALWAYS,
                           FILE_ATTRIBUTE_NORMAL|FILE_FLAG_WRITE_THROUGH,
                           NULL
                           );
    len = SetFilePointer(fh,
                         0,
                         NULL,
                         FILE_END
                         );
    if (fh != INVALID_HANDLE_VALUE) {
        WriteFile(fh,
                  str,
                  strlen(str),
                  &len,
                  NULL
                  );
        CloseHandle(fh);
    }
    return;


}
LPVOID BPAlloc(int len)
{

    LPVOID mem = HeapAlloc(GetProcessHeap(),
                           HEAP_ZERO_MEMORY,
                           len);
    CHAR buffer[256];
    sprintf(buffer, "Allocated %d at memory 0x%x\n", len, mem);
    LogTrace(0, buffer);
    return mem;

}

VOID
BPFree(LPVOID mem)
{
    BOOL ret = HeapFree(GetProcessHeap(),
                        0,
                        mem
                        );
    CHAR buffer[256];
    if(ret){
        sprintf(buffer, "Freed at memory 0x%x with TRUE\n",mem);
    }
    else{
        sprintf(buffer, "Freed at memory 0x%x with FALSE\n",mem);
    }
    LogTrace(0, buffer);
    
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\headless\bootprov\classfac.cpp ===
//***************************************************************************
//
//  CLASSFAC.CPP
//
//  Module: WMI Instance provider sample code
//
//  Purpose: Contains the class factory.  This creates objects when
//           connections are requested.
//
//  Copyright (c) 1997-1999 Microsoft Corporation
//
//***************************************************************************

#include <objbase.h>
#include "bootini.h"

//***************************************************************************
//
// CBootProvFactory::CBootProvFactory
// CBootProvFactory::~CBootProvFactory
//
// Constructor Parameters:
//  None
//***************************************************************************

CBootProvFactory::CBootProvFactory()
{
    m_cRef=0L;
    return;
}

CBootProvFactory::~CBootProvFactory(void)
{
    return;
}

//***************************************************************************
//
// CBootProvFactory::QueryInterface
// CBootProvFactory::AddRef
// CBootProvFactory::Release
//
// Purpose: Standard Ole routines needed for all interfaces
//
//***************************************************************************


STDMETHODIMP CBootProvFactory::QueryInterface(REFIID riid
    , PPVOID ppv)
{
    *ppv=NULL;

    if (IID_IUnknown==riid || IID_IClassFactory==riid)
        *ppv=this;

    if (NULL!=*ppv)
        {
        ((LPUNKNOWN)*ppv)->AddRef();
        return NOERROR;
        }

    return E_NOINTERFACE;
}

STDMETHODIMP_(ULONG) CBootProvFactory::AddRef(void)
{
    return ++m_cRef;
}

STDMETHODIMP_(ULONG) CBootProvFactory::Release(void)
{
    ULONG nNewCount = InterlockedDecrement((long *)&m_cRef);
    if (0L == nNewCount)
        delete this;
    
    return nNewCount;
}

//***************************************************************************
//
// CBootProvFactory::CreateInstance
//
// Purpose: Instantiates a Locator object returning an interface pointer.
//
// Parameters:
//  pUnkOuter       LPUNKNOWN to the controlling IUnknown if we are
//                  being used in an aggregation.
//  riid            REFIID identifying the interface the caller
//                  desires to have for the new object.
//  ppvObj          PPVOID in which to store the desired
//                  interface pointer for the new object.
//
// Return Value:
//  HRESULT         NOERROR if successful, otherwise E_NOINTERFACE
//                  if we cannot support the requested interface.
//***************************************************************************

STDMETHODIMP CBootProvFactory::CreateInstance(LPUNKNOWN pUnkOuter
    , REFIID riid, PPVOID ppvObj)
{
    CBootInstPro *   pObj;
    HRESULT hr;

    *ppvObj=NULL;

    // This object doesnt support aggregation.

    if (NULL!=pUnkOuter)
        return CLASS_E_NOAGGREGATION;

    // Create the locator object.
    
    pObj=new CBootInstPro();
    if (NULL==pObj)
        return E_OUTOFMEMORY;

    hr=pObj->QueryInterface(riid, ppvObj);

    //Kill the object if initial creation or Init failed.

    if (FAILED(hr))
        delete pObj;
    return hr;
}

//***************************************************************************
//
// CBootProvFactory::LockServer
//
// Purpose:
//  Increments or decrements the lock count of the DLL.  If the
//  lock count goes to zero and there are no objects, the DLL
//  is allowed to unload.  See DllCanUnloadNow.
//
// Parameters:
//  fLock           BOOL specifying whether to increment or
//                  decrement the lock count.
//
// Return Value:
//  HRESULT         NOERROR always.
//***************************************************************************


STDMETHODIMP CBootProvFactory::LockServer(BOOL fLock)
{
    if (fLock)
        InterlockedIncrement(&g_cLock);
    else
        InterlockedDecrement(&g_cLock);
    return NOERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\headless\bootprov\bootini.h ===
//***************************************************************************
//
//  bootini.h
//
//  Module: WMI Instance provider code for boot parameters
//
//  Purpose: Genral purpose include file.
//
//  Copyright (c) 1997-1999 Microsoft Corporation
//
//***************************************************************************

#ifndef _bootini_H_
#define _bootini_H_

#include <wbemprov.h>
#include <stdio.h>
#include <tchar.h>
#include <windows.h>
#include <wbemcli.h>

typedef LPVOID * PPVOID;

// Provider interfaces are provided by objects of this class
 
class CBootInstPro : public IWbemServices, public IWbemProviderInit
{
protected:
    ULONG              m_cRef;         //Object reference count
    IWbemServices *  m_pNamespace;
public:
    CBootInstPro(BSTR ObjectPath = NULL, BSTR User = NULL, BSTR Password = NULL, IWbemContext * pCtx=NULL);
    ~CBootInstPro(void);

    //Non-delegating object IUnknown

    STDMETHODIMP         QueryInterface(REFIID, PPVOID);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

    //IWbemProviderInit

    HRESULT STDMETHODCALLTYPE Initialize(LPWSTR pszUser,
                                         LONG lFlags,
                                         LPWSTR pszNamespace,
                                         LPWSTR pszLocale,
                                         IWbemServices *pNamespace,
                                         IWbemContext *pCtx,
                                         IWbemProviderInitSink *pInitSink
                                         );

    //IWbemServices  

    HRESULT STDMETHODCALLTYPE OpenNamespace( const BSTR Namespace,
                                             long lFlags,
                                             IWbemContext __RPC_FAR *pCtx,
                                             IWbemServices __RPC_FAR *__RPC_FAR *ppWorkingNamespace,
                                             IWbemCallResult __RPC_FAR *__RPC_FAR *ppResult) 
    {
        return WBEM_E_NOT_SUPPORTED;
    };

    HRESULT STDMETHODCALLTYPE CancelAsyncCall( IWbemObjectSink __RPC_FAR *pSink) 
    {
        return WBEM_E_NOT_SUPPORTED;
    };
        
    HRESULT STDMETHODCALLTYPE QueryObjectSink(long lFlags,
                                              IWbemObjectSink __RPC_FAR *__RPC_FAR *ppResponseHandler
                                              ) 
    {
        return WBEM_E_NOT_SUPPORTED;
    };
        
    HRESULT STDMETHODCALLTYPE GetObject(const BSTR ObjectPath,
                                        long lFlags,
                                        IWbemContext __RPC_FAR *pCtx,
                                        IWbemClassObject __RPC_FAR *__RPC_FAR *ppObject,
                                        IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult
                                        ) 
    {
        return WBEM_E_NOT_SUPPORTED;
    };
        
    HRESULT STDMETHODCALLTYPE GetObjectAsync(const BSTR ObjectPath,
                                             long lFlags,
                                             IWbemContext __RPC_FAR *pCtx,
                                             IWbemObjectSink __RPC_FAR *pResponseHandler
                                             );
        
    HRESULT STDMETHODCALLTYPE PutClass(IWbemClassObject __RPC_FAR *pObject,
                                       long lFlags,
                                       IWbemContext __RPC_FAR *pCtx,
                                       IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult
                                       )
     {
         return WBEM_E_NOT_SUPPORTED;
    };
    
    HRESULT STDMETHODCALLTYPE PutClassAsync(IWbemClassObject __RPC_FAR *pObject,
                                            long lFlags,
                                            IWbemContext __RPC_FAR *pCtx,
                                            IWbemObjectSink __RPC_FAR *pResponseHandler
                                            ) 
    {
        return WBEM_E_NOT_SUPPORTED;
    };
        
    HRESULT STDMETHODCALLTYPE DeleteClass(const BSTR Class,
                                          long lFlags,
                                          IWbemContext __RPC_FAR *pCtx,
                                          IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult
                                          )
    {
        return WBEM_E_NOT_SUPPORTED;
    };
        
    HRESULT STDMETHODCALLTYPE DeleteClassAsync(const BSTR Class,
                                               long lFlags,
                                               IWbemContext __RPC_FAR *pCtx,
                                               IWbemObjectSink __RPC_FAR *pResponseHandler
                                               ) 
    {
        return WBEM_E_NOT_SUPPORTED;
    };
        
    HRESULT STDMETHODCALLTYPE CreateClassEnum(const BSTR Superclass,
                                              long lFlags,
                                              IWbemContext __RPC_FAR *pCtx,
                                              IEnumWbemClassObject __RPC_FAR *__RPC_FAR *ppEnum
                                              ) 
    {
        return WBEM_E_NOT_SUPPORTED;
    };
        
    HRESULT STDMETHODCALLTYPE CreateClassEnumAsync(const BSTR Superclass,
                                                   long lFlags,
                                                   IWbemContext __RPC_FAR *pCtx,
                                                   IWbemObjectSink __RPC_FAR *pResponseHandler
                                                   ) 
    {
        return WBEM_E_NOT_SUPPORTED;
    };
        
    HRESULT STDMETHODCALLTYPE PutInstance(IWbemClassObject __RPC_FAR *pInst,
                                          long lFlags,
                                          IWbemContext __RPC_FAR *pCtx,
                                          IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult
                                          ) 
    {
        return WBEM_E_NOT_SUPPORTED;
    };
        
    HRESULT STDMETHODCALLTYPE PutInstanceAsync(IWbemClassObject __RPC_FAR *pInst,
                                               long lFlags,
                                               IWbemContext __RPC_FAR *pCtx,
                                               IWbemObjectSink __RPC_FAR *pResponseHandler
                                               );
        
    HRESULT STDMETHODCALLTYPE DeleteInstance(const BSTR ObjectPath,
                                             long lFlags,
                                             IWbemContext __RPC_FAR *pCtx,
                                             IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult
                                             ) 
    {
        return WBEM_E_NOT_SUPPORTED;
    };
        
    HRESULT STDMETHODCALLTYPE DeleteInstanceAsync(const BSTR ObjectPath,
                                                  long lFlags,
                                                  IWbemContext __RPC_FAR *pCtx,
                                                  IWbemObjectSink __RPC_FAR *pResponseHandler
                                                  ) 
    {
        return WBEM_E_NOT_SUPPORTED;
    };
        
    HRESULT STDMETHODCALLTYPE CreateInstanceEnum(const BSTR Class,
                                                 long lFlags,
                                                 IWbemContext __RPC_FAR *pCtx,
                                                 IEnumWbemClassObject __RPC_FAR *__RPC_FAR *ppEnum
                                                 ) 
    {
        return WBEM_E_NOT_SUPPORTED;
    };
        
    HRESULT STDMETHODCALLTYPE CreateInstanceEnumAsync(const BSTR Class,
                                                      long lFlags,
                                                      IWbemContext __RPC_FAR *pCtx,
                                                      IWbemObjectSink __RPC_FAR *pResponseHandler
                                                      )
    {
        return WBEM_E_NOT_SUPPORTED;
    }
    HRESULT STDMETHODCALLTYPE ExecQuery(const BSTR QueryLanguage,
                                        const BSTR Query,
                                        long lFlags,
                                        IWbemContext __RPC_FAR *pCtx,
                                        IEnumWbemClassObject __RPC_FAR *__RPC_FAR *ppEnum) 
    {
        return WBEM_E_NOT_SUPPORTED;
    };
        
    HRESULT STDMETHODCALLTYPE ExecQueryAsync(const BSTR QueryLanguage,
                                             const BSTR Query,
                                             long lFlags,
                                             IWbemContext __RPC_FAR *pCtx,
                                             IWbemObjectSink __RPC_FAR *pResponseHandler
                                             ) 
    {
        return WBEM_E_NOT_SUPPORTED;
    };
        
    HRESULT STDMETHODCALLTYPE ExecNotificationQuery(const BSTR QueryLanguage,
                                                    const BSTR Query,
                                                    long lFlags,
                                                    IWbemContext __RPC_FAR *pCtx,
                                                    IEnumWbemClassObject __RPC_FAR *__RPC_FAR *ppEnum
                                                    ) 
    {
        return WBEM_E_NOT_SUPPORTED;
    };
        
    HRESULT STDMETHODCALLTYPE ExecNotificationQueryAsync(const BSTR QueryLanguage,
                                                         const BSTR Query,
                                                         long lFlags,
                                                         IWbemContext __RPC_FAR *pCtx,
                                                         IWbemObjectSink __RPC_FAR *pResponseHandler
                                                         ) 
    {
        return WBEM_E_NOT_SUPPORTED;
    };
        
    HRESULT STDMETHODCALLTYPE ExecMethod(const BSTR, 
                                         const BSTR, 
                                         long, IWbemContext*,
                                         IWbemClassObject*, 
                                         IWbemClassObject**, 
                                         IWbemCallResult**
                                         ) 
    {
        return WBEM_E_NOT_SUPPORTED;
    }

    HRESULT STDMETHODCALLTYPE ExecMethodAsync(const BSTR, 
                                              const BSTR, 
                                              long,
                                              IWbemContext*, 
                                              IWbemClassObject*, 
                                              IWbemObjectSink*
                                              ) 
    {
        return WBEM_E_NOT_SUPPORTED;
    }

};

typedef CBootInstPro *PCBootInstPro;

// This class is the class factory for CInstPro objects.

class CBootProvFactory : public IClassFactory
    {
    protected:
        ULONG           m_cRef;

    public:
        CBootProvFactory(void);
        ~CBootProvFactory(void);

        //IUnknown members
        STDMETHODIMP         QueryInterface(REFIID, PPVOID);
        STDMETHODIMP_(ULONG) AddRef(void);
        STDMETHODIMP_(ULONG) Release(void);

        //IClassFactory members
        STDMETHODIMP         CreateInstance(LPUNKNOWN, 
                                            REFIID,
                                            PPVOID
                                            );

        STDMETHODIMP         LockServer(BOOL);
    };

typedef CBootProvFactory *PCBootProvFactory;



// These variables keep track of when the module can be unloaded

extern long       g_cObj;
extern long       g_cLock;

// General purpose utilities.  

SCODE 
GetBootLoaderParameters(IWbemServices *m_pNamespace,
                        IWbemClassObject *pNewInst,
                        IWbemContext  *pCtx
                        ); 

extern "C" BOOL WINAPI LibMain32(HINSTANCE hInstance, 
                                 ULONG ulReason, 
                                 LPVOID pvReserved
                                 );

LONG 
SaveBootFile(IWbemClassObject *pInst,
             IWbemClassObject *pClass
             );


HANDLE GetFileHandle(PCHAR data,
                     DWORD dwCreationDisposition,
                     DWORD dwAccess
                     );
PCHAR
GetBootFileName(
    );

typedef struct {
    CHAR Default[256];
    long Delay;
    CHAR Redirect[32];
} BootLoaderParams;
#if DBG==1
LPVOID BPAlloc(int len);
VOID BPFree(LPVOID mem);
#else
#define BPAlloc(x) HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, x)
#define BPFree(x) HeapFree(GetProcessHeap(), 0, x)
#endif
extern BootLoaderParams blp;
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\headless\bootprov\maindll.cpp ===
//***************************************************************************
//
//  MAINDLL.CPP
// 
//  Module: WMI Instance provider code for boot parameters
//
//  Purpose: Contains DLL entry points.  Also has code that controls
//           when the DLL can be unloaded by tracking the number of
//           objects and locks as well as routines that support
//           self registration.
//
//  Copyright (c) 1997-1999 Microsoft Corporation
//
//***************************************************************************

#include <initguid.h>
#include <objbase.h>
#include "bootini.h"

HMODULE ghModule;

// TODO, GuidGen should be used to generate a unique number for any 
// providers that are going to be used for anything more extensive 
// than just testing.

DEFINE_GUID(CLSID_instprovider,0x22cb8761, 0x914a, 0x11cf, 0xb7, 0x5, 0x0, 0xaa, 0x0, 0x62, 0xcb, 0xb8);
// {22CB8761-914A-11cf-B705-00AA0062CBB8}

//Count number of objects and number of locks.

long       g_cObj=0;
long       g_cLock=0;

//***************************************************************************
//
// LibMain32
//
// Purpose: Entry point for DLL.
//
// Return: TRUE if OK.
//
//***************************************************************************

BOOL WINAPI LibMain32(HINSTANCE hInstance, ULONG ulReason
    , LPVOID pvReserved)
{
    if (DLL_PROCESS_ATTACH==ulReason)
        ghModule = hInstance;
    return TRUE;
}

//***************************************************************************
//
//  DllGetClassObject
//
//  Purpose: Called by Ole when some client wants a class factory.  Return 
//           one only if it is the sort of class this DLL supports.
//
//***************************************************************************


STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, PPVOID ppv)
{
    HRESULT hr;
    CBootProvFactory *pObj;

    if (CLSID_instprovider!=rclsid)
        return E_FAIL;

    pObj=new CBootProvFactory();

    if (NULL==pObj)
        return E_OUTOFMEMORY;

    hr=pObj->QueryInterface(riid, ppv);

    if (FAILED(hr))
        delete pObj;

    return hr;
}

//***************************************************************************
//
// DllCanUnloadNow
//
// Purpose: Called periodically by Ole in order to determine if the
//          DLL can be freed.
//
// Return:  S_OK if there are no objects in use and the class factory 
//          isn't locked.
//
//***************************************************************************

STDAPI DllCanUnloadNow(void)
{
    SCODE   sc;

    //It is OK to unload if there are no objects or locks on the 
    // class factory.
    
    sc=(0L==g_cObj && 0L==g_cLock) ? S_OK : S_FALSE;
    return sc;
}

//***************************************************************************
//
// DllRegisterServer
//
// Purpose: Called during setup or by regsvr32.
//
// Return:  NOERROR if registration successful, error otherwise.
//***************************************************************************

STDAPI DllRegisterServer(void)
{   
    char       szID[128];
    WCHAR      wcID[128];
    char       szCLSID[128];
    char       szModule[MAX_PATH];
    char * pName = "WMI Boot Instance Provider";
    char * pModel = "Both";
    HKEY hKey1, hKey2;

    // Create the path.

    StringFromGUID2(CLSID_instprovider, wcID, 128);
    wcstombs(szID, wcID, 128);
    lstrcpy(szCLSID, TEXT("Software\\classes\\CLSID\\"));
    lstrcat(szCLSID, szID);

    // Create entries under CLSID

    RegCreateKey(HKEY_LOCAL_MACHINE, szCLSID, &hKey1);
    RegSetValueEx(hKey1, NULL, 0, REG_SZ, (BYTE *)pName, lstrlen(pName)+1);
    RegCreateKey(hKey1,"InprocServer32",&hKey2);

    GetModuleFileName(ghModule, szModule,  MAX_PATH);
    RegSetValueEx(hKey2, NULL, 0, REG_SZ, (BYTE *)szModule, 
                                        lstrlen(szModule)+1);
    RegSetValueEx(hKey2, "ThreadingModel", 0, REG_SZ, 
                                        (BYTE *)pModel, lstrlen(pModel)+1);
    RegCloseKey(hKey1);
    RegCloseKey(hKey2);
    return NOERROR;
}

//***************************************************************************
//
// DllUnregisterServer
//
// Purpose: Called when it is time to remove the registry entries.
//
// Return:  NOERROR if registration successful, error otherwise.
//***************************************************************************

STDAPI DllUnregisterServer(void)
{
    char       szID[128];
    WCHAR      wcID[128];
    char  szCLSID[128];
    HKEY hKey;

    // Create the path using the CLSID

    StringFromGUID2(CLSID_instprovider, wcID, 128);
    wcstombs(szID, wcID, 128);
    lstrcpy(szCLSID, TEXT("Software\\classes\\CLSID\\"));
    lstrcat(szCLSID, szID);

    // First delete the InProcServer subkey.

    DWORD dwRet = RegOpenKey(HKEY_LOCAL_MACHINE, szCLSID, &hKey);
    if(dwRet == NO_ERROR)
    {
        RegDeleteKey(hKey, "InProcServer32");
        RegCloseKey(hKey);
    }

    dwRet = RegOpenKey(HKEY_LOCAL_MACHINE, "Software\\classes\\CLSID", &hKey);
    if(dwRet == NO_ERROR)
    {
        RegDeleteKey(hKey,szID);
        RegCloseKey(hKey);
    }

    return NOERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\headless\bootprov\save.cpp ===
//***************************************************************************
//
//  save.cpp
//
//  Module: WMI Instance provider code for boot parameters
//
//  Purpose: Saving boot parameters.  
//
//  Copyright (c) 1997-1999 Microsoft Corporation
//
//***************************************************************************
#include "bootini.h"

VOID
WriteStringToFile(HANDLE fh,
                  PCHAR str
                  )
{
    DWORD dwlen;
    BOOL ret = WriteFile(fh,
                         str,
                         strlen(str),
                         &dwlen,
                         NULL
                         );
}


ULONG
WriteDefaultParams(IWbemClassObject *pInst,
                   PCHAR data,
                   PCHAR def,
                   SAFEARRAY *psa,
                   HANDLE BootFile,
                   PWCHAR wredir
                   )
{
    VARIANT v,v1;
    CIMTYPE type;
    IWbemClassObject *pOSInst;
    int wlen, slen;
    int len;
    PCHAR str;
    BOOL found;
    
    HRESULT hret = pInst->Get(L"Default",
                              0,
                              &v,
                              &type,
                              NULL
                              );
    if(hret != WBEM_S_NO_ERROR){
        return -1;
    }
    if(v.vt != VT_BSTR){
        return -1;
    }
    LONG uBound;
    hret = SafeArrayGetUBound(psa,
                              1,
                              &uBound
                              );
    for(LONG i = 0; i<=uBound; i++){
        hret = SafeArrayGetElement(psa,
                                   &i,
                                   &pOSInst
                                   );
        if(hret != S_OK){
            pOSInst->Release();
            return -1;
        }
        hret = pOSInst->Get(L"OperatingSystem",
                            0,
                            &v1,
                            &type,
                            NULL
                            );
        if(hret != WBEM_S_NO_ERROR){
            pOSInst->Release();
            return -1;
        }
        if(v1.vt != VT_BSTR){
            pOSInst->Release();
            return -1;
        }
        if(wcscmp(v.bstrVal,v1.bstrVal) == 0){
            break;
        }
        pOSInst->Release();
    }
    VariantClear(&v);
    VariantClear(&v1);
    PCHAR temp;
    if(i <= uBound){
        hret = pOSInst->Get(L"Directory",
                            0,
                            &v,
                            &type,
                            NULL
                            );
        if(hret != WBEM_S_NO_ERROR){
            pOSInst->Release();
            return -1;
        }
        if(v.vt != VT_BSTR){
            pOSInst->Release();
            return -1;
        }
        wlen = wcslen(v.bstrVal);
        slen = wlen*sizeof(WCHAR) + 1;
        str = (PCHAR) BPAlloc(slen);
        if (!str) {
            return -1;
        }
        len =  WideCharToMultiByte(CP_ACP,
                                   0,
                                   v.bstrVal,
                                   wlen,
                                   str,
                                   slen-1,
                                   NULL,
                                   NULL
                                   );
        str[len] = (CHAR)0;
        // check to see if this is a valid directory 
        temp = strstr(data,"[operating system]");
        found = FALSE;
        if(temp){
            do{
                // Remove all white spaces
                while(*temp == ' ' || *temp == '\r' || *temp == '\n'){
                    temp ++;
                }
                // check 
                if(strncmp(str,temp,strlen(str)) == 0){
                    found = TRUE;
                    WriteStringToFile(BootFile,
                                      "default="
                                      );
                    WriteStringToFile(BootFile,
                                      str
                                      );
                    WriteStringToFile(BootFile,
                                      "\r\n"
                                      );
                    break;

                }
                // Go to next line
                while(*temp && (*temp != '\r' || *temp != '\n')){
                    temp ++;
                }
            }while (*temp && *temp != '[');
        }
        BPFree(str);
        VariantClear(&v);
        pOSInst->Release();
    }
    if((found == FALSE) && def){
        WriteStringToFile(BootFile,
                          def
                          );
        WriteStringToFile(BootFile,
                          "\r\n"
                          );
    }
    if(wcscmp(wredir,L"no")){
        wlen = wcslen(wredir);
        slen = wlen*sizeof(WCHAR) + 2;
        str = (PCHAR) BPAlloc(slen);
        if (!str) {
            return -1;
        }
        len =  WideCharToMultiByte(CP_ACP,
                                   0,
                                   wredir,
                                   wlen,
                                   str,
                                   slen,
                                   NULL,
                                   NULL
                                   );
        str[len] = (CHAR)0;
        WriteStringToFile(BootFile,
                          "redirect="
                          );
        WriteStringToFile(BootFile,
                          str
                          );
        WriteStringToFile(BootFile,
                          "\r\n"
                          );
        BPFree(str);
    }
    hret = pInst->Get(L"Delay",
                      0,
                      &v,
                      &type,
                      NULL
                      );
    if(hret != WBEM_S_NO_ERROR){
        return -1;
    }

    if(v.vt != VT_I4){
        return -1;
    }
    str = (PCHAR) BPAlloc(32);
    sprintf(str, "%d",v.lVal);
    WriteStringToFile(BootFile,
                      "timeout="
                      );
    WriteStringToFile(BootFile,
                      str
                      );
    WriteStringToFile(BootFile,
                      "\r\n"
                      );
    BPFree(str);
    return 0;

}

LONG
WriteOSLine(HANDLE fh,
            PCHAR line,
            PCHAR pchar,
            SAFEARRAY *psa,
            SAFEARRAY *org,
            IWbemClassObject *pClass,
            BOOL redir
            )
{
    // Search through the entire instance for the 
    // necessary line
    VARIANT v;
    IWbemClassObject *pOSInst;
    HRESULT hret;
    CIMTYPE type;
    int slen,wlen;
    PCHAR str;
    BOOL found = FALSE;
    SAFEARRAYBOUND sb;

    // Code is rendered really inefficient because of error checking 
    // maybe should use the exception mechanism to take care of all 
    // these errors.

    PWCHAR wdata = (PWCHAR)BPAlloc((pchar - line + 1)*sizeof(WCHAR) 
                                   );
    if(!wdata){
        return -1;
    }
    int len =  MultiByteToWideChar(CP_ACP,
                                   0,
                                   line,
                                   pchar-line,
                                   wdata,
                                   pchar-line
                                   );
    wdata[len] = (WCHAR)0;
    LONG uBound;
    hret = SafeArrayGetUBound(org,
                              1,
                              &uBound
                              );
    if (hret != S_OK) {
        WriteStringToFile(fh,
                          line
                          );
        WriteStringToFile(fh,
                          "\r\n"
                          );
        BPFree(wdata);
        return 0;
    }
    for(LONG i = 0;i <= uBound; i++){
        hret = SafeArrayGetElement(org,
                                   &i,
                                   &pOSInst
                                   );
        if(hret != S_OK){
            BPFree(wdata);
            return -1;
        }
        hret = pOSInst->Get(L"Directory",
                            0,
                            &v,
                            &type,
                            NULL
                            );
        if(hret != WBEM_S_NO_ERROR){
            BPFree(wdata);
            pOSInst->Release();
            return -1;
        }
        if(v.vt != VT_BSTR){
            BPFree(wdata);
            pOSInst->Release();
            return -1;
        }
        if(wcscmp(v.bstrVal,wdata)){
            pOSInst->Release();
            VariantClear(&v);
            continue;
        }
        found = TRUE;
        pOSInst->Release();
        VariantClear(&v);
        break;
    }
    if(!found){
        WriteStringToFile(fh,
                          line
                          );
        WriteStringToFile(fh,
                          "\r\n"
                          );
        BPFree(wdata);
        return 0;

    }
    hret = SafeArrayGetUBound(psa,
                              1,
                              &uBound
                              );
    if (hret != S_OK) {
        WriteStringToFile(fh,
                          line
                          );
        WriteStringToFile(fh,
                          "\r\n"
                          );
        return 0;
    }
    for(LONG i = 0;i <= uBound; i++){
        hret = SafeArrayGetElement(psa,
                                   &i,
                                   &pOSInst
                                   );
        if(hret != S_OK){
            BPFree(wdata);
            return -1;
        }
        hret = pOSInst->Get(L"Directory",
                            0,
                            &v,
                            &type,
                            NULL
                            );
        if(hret != WBEM_S_NO_ERROR){
            BPFree(wdata);
            pOSInst->Release();
            return -1;
        }
        if(v.vt != VT_BSTR){
            BPFree(wdata);
            pOSInst->Release();
            return -1;
        }
        if(wcscmp(v.bstrVal,wdata)){
            pOSInst->Release();
            VariantClear(&v);
            continue;
        }
        VariantClear(&v);

    // form the correct string. 
        hret = pOSInst->Get(L"OperatingSystem",
                            0,
                            &v,
                            &type,
                            NULL
                            );
        if(hret != WBEM_S_NO_ERROR){
            BPFree(wdata);
            pOSInst->Release();
            return -1;
        }
        if(v.vt != VT_BSTR){
            BPFree(wdata);
            pOSInst->Release();
            return -1;
        }
        wlen = wcslen(v.bstrVal);
        slen = wlen*sizeof(WCHAR) + 1;
        str = (PCHAR) BPAlloc(slen);
        if (!str) {
            BPFree(wdata);
            pOSInst->Release();
            return -1;
        }
        len =  WideCharToMultiByte(CP_ACP,
                                   0,
                                   v.bstrVal,
                                   wlen,
                                   str,
                                   slen,
                                   NULL,
                                   NULL
                                   );
        *pchar=0;
        WriteStringToFile(fh,
                          line
                          );
        *pchar = '=';
        WriteStringToFile(fh,
                          "="
                          );
        WriteStringToFile(fh,
                          str
                      );
        BPFree(str);
        VariantClear(&v);
        hret = pOSInst->Get(L"Rest",
                            0,
                            &v,
                            &type,
                            NULL
                            );
        if(hret != WBEM_S_NO_ERROR){
            BPFree(wdata);
            pOSInst->Release();
            return -1;
        }
        if(v.vt != VT_BSTR){
            BPFree(wdata);
            pOSInst->Release();
            return -1;
        }
        wlen = wcslen(v.bstrVal);
        slen = wlen*sizeof(WCHAR) + 1;
        str = (PCHAR) BPAlloc(slen);
        if (!str) {
            BPFree(wdata);
            pOSInst->Release();
            return -1;
        }
        len =  WideCharToMultiByte(CP_ACP,
                                   0,
                                   v.bstrVal,
                                   wlen,
                                   str,
                                   slen,
                                   NULL,
                                   NULL
                                   );
        WriteStringToFile(fh,
                          " "
                          );
        WriteStringToFile(fh,
                          str
                          );
        BPFree(str);
        hret = pOSInst->Get(L"Redirect",
                            0,
                            &v,
                            &type,
                            NULL
                            );
        if(hret != WBEM_S_NO_ERROR){
            BPFree(wdata);
            pOSInst->Release();
            return -1;
        }
        if(v.vt != VT_BOOL){
            BPFree(wdata);
            pOSInst->Release();
            return -1;
        }
        if(v.boolVal && redir){// Loader also must be redirected
            WriteStringToFile(fh,
                              " /redirect"
                              );
        }
        VariantClear(&v);
        hret = pOSInst->Get(L"Fastdetect",
                            0,
                            &v,
                            &type,
                            NULL
                            );
        if(hret != WBEM_S_NO_ERROR){
            BPFree(wdata);
            pOSInst->Release();
            return -1;
        }
        if(v.vt != VT_BOOL){
            BPFree(wdata);
            pOSInst->Release();
            return -1;
        }
        if(v.boolVal){
            WriteStringToFile(fh,
                              " /fastdetect"
                              );
        }
        VariantClear(&v);
        hret = pOSInst->Get(L"Debug",
                            0,
                            &v,
                            &type,
                            NULL
                            );
        if(hret != WBEM_S_NO_ERROR){
            BPFree(wdata);
            pOSInst->Release();
            return -1;
        }
        if(v.vt != VT_BOOL){
            BPFree(wdata);
            pOSInst->Release();
            return -1;
        }
        if(v.boolVal){
            WriteStringToFile(fh,
                              " /debug"
                              );
        }
        VariantClear(&v);
        WriteStringToFile(fh,
                          "\r\n"
                          );
        pOSInst->Release();
        found = TRUE;
        if(i != uBound){
            // Shorten the array. After all u have a copy
            hret = SafeArrayGetElement(psa,
                                       &uBound,
                                       &pOSInst
                                       );
            if(hret != S_OK){
                BPFree(wdata);
                return -1;
            }
            hret = SafeArrayPutElement(psa,
                                       &i,
                                       pOSInst
                                       );
            pOSInst->Release();
        }
        sb.cElements = uBound;
        sb.lLbound = 0;
        hret = SafeArrayRedim(psa,
                              &sb
                              );
        uBound -= 1;
        i-=1; // so that the currently swapped element is looked at now.
    }
    if(!found){
        WriteStringToFile(fh,
                          line
                          );
        WriteStringToFile(fh,
                          "\r\n"
                          );
    }
    BPFree(wdata);
    return 0;
}



LONG 
SaveBootFile(IWbemClassObject *pInst,
             IWbemClassObject *pClass
             )
{

    VARIANT v;
    VARIANT v1;
    BOOL redir;
    BOOL ret;
    DWORD dwlen;
    CIMTYPE type;
    HRESULT hret;
    PCHAR temp1,pchar;
    SAFEARRAY *org;
    
    temp1 = NULL;
    PCHAR fileName = GetBootFileName();
    HANDLE BootFile = GetFileHandle(fileName,OPEN_EXISTING, GENERIC_READ);
    BPFree(fileName);
    if (BootFile == INVALID_HANDLE_VALUE){
        return -1;
    }
    DWORD dwsize = GetFileSize(BootFile,
                               NULL
                               );
    if(dwsize == -1){
        CloseHandle(BootFile);
        return -1;
    }
    PCHAR data =(PCHAR)  BPAlloc(dwsize + sizeof(CHAR));
    if(!data){
        return -1;
    }

    DWORD dwret = ReadFile(BootFile,
                           (LPVOID) data,
                           dwsize,
                           &dwlen,
                           NULL
                           );

    if(dwret == 0){
        dwret = GetLastError();
        BPFree(data);
        CloseHandle(BootFile);
        return -1;
    }
    CloseHandle(BootFile);
    BootFile = GetFileHandle("boot.bak", TRUNCATE_EXISTING, GENERIC_WRITE);
    hret = pInst->Get(L"operating_systems",
                      0,
                      &v,
                      &type,
                      NULL
                      );
    if(hret != WBEM_S_NO_ERROR){
        BPFree(data);
        CloseHandle(BootFile);
        return -1;
    }

    VARTYPE t = VT_ARRAY|VT_UNKNOWN;
    if(v.vt != t){
        BPFree(data);
        CloseHandle(BootFile);
        return -1;
    }
    hret = SafeArrayCopy(v.parray, &org);
    
    if(hret != WBEM_S_NO_ERROR){
        BPFree(data);
        CloseHandle(BootFile);
        return -1;
    }
    hret = pInst->Get(L"Redirect",
                      0,
                      &v1,
                      &type,
                      NULL
                      );
    if(hret != WBEM_S_NO_ERROR){
        BPFree(data);
        CloseHandle(BootFile);
        return -1;
    }

    if(v1.vt != VT_BSTR){
        BPFree(data);
        CloseHandle(BootFile);
        return -1;
    }
    redir = FALSE;
    if(wcscmp(v1.bstrVal,L"no")){
        redir = TRUE;
    }
    CHAR sep[] = "\r\n";
    PCHAR temp = strtok(data, sep);
    while(temp){
        // ignore leading spaces
        while(*temp && (*temp == ' ')){
            temp ++;
        }
        if (strncmp(temp,"[boot loader]",strlen("[boot loader]"))==0) {
            // Ok, boot loader section. Write it.
            do{
                pchar = strchr(temp,'=');
                if((!pchar) ||(strncmp(temp,"default",strlen("default"))
                   && strncmp(temp,"redirect",strlen("redirect"))
                   && strncmp(temp,"timeout",strlen("timeout")))){
                    // Write the default string
                    WriteStringToFile(BootFile,temp);
                    WriteStringToFile(BootFile,"\r\n");
                }
                if(strncmp(temp,"default",strlen("default")) == 0){
                    // store the default string
                    temp1 = temp;
                }
                temp = strtok(NULL, sep);
            }while(temp && (*temp != '['));
            if(WriteDefaultParams(pInst,data,temp1,v.parray,BootFile,v1.bstrVal)){
                BPFree(data);
                CloseHandle(BootFile);
                return -1;
            }
            continue;
        }
        if(strcmp(temp,"[operating systems]")==0){
            // dealing with the operating systems line
            // So get the Safe Array
            do{
                temp1 = temp;
                if(*temp1 != ';'){
                    // comment line are ignored. 
                    pchar = strchr(temp,'=');
                    if(pchar){
                        if(WriteOSLine(BootFile,temp1, pchar, org ,v.parray, pClass,redir)){
                            BPFree(data);
                            CloseHandle(BootFile);
                            return -1;
                        }
                        temp = strtok(NULL,sep);
                        continue;
                    }
                }
                WriteStringToFile(BootFile, temp);
                WriteStringToFile(BootFile,"\r\n");
                temp = strtok(NULL,sep);
            }while(temp && (*temp != '['));
            SafeArrayDestroy(org);
            VariantClear(&v);
            continue;
        }
        WriteStringToFile(BootFile,temp);
        WriteStringToFile(BootFile,"\r\n");
        temp = strtok(NULL,sep);
    }
    CloseHandle(BootFile);
    fileName = GetBootFileName();
    if(!fileName){
        return -1;
    }
    ret = CopyFile("boot.bak",
                   fileName,
                   FALSE
                   );
    BPFree(fileName);
    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\headless\bootprov\getparams.cpp ===
//***************************************************************************
//
//  getparams.cpp
//
//  Module: WMI Instance provider code for boot parameters
//
//  Purpose: Extracting boot parameters.  
//
//  Copyright (c) 1997-1999 Microsoft Corporation
//
//***************************************************************************

#include "bootini.h"

SCODE ParseLine(IWbemClassObject *pNewOSInst,
                PCHAR line,
                PCHAR options
                )
{
    PCHAR rest; // the rest of the options cannot be bigger than this.
    int size = strlen(line);
    int len;
    SCODE sc;
    VARIANT v;
    BOOL found=FALSE;

    rest = (PCHAR) BPAlloc(size);
    if (!rest) {
        return WBEM_E_FAILED;
    }
    PWCHAR wstr;
    wstr = (PWCHAR) BPAlloc(size*sizeof(WCHAR));
    if (!wstr) {
        BPFree(rest);
        return WBEM_E_FAILED;
    }
    
    *options = 0; //Later fill in the '=' 
    len = MultiByteToWideChar(CP_ACP,
                              0,
                              line,
                              strlen(line),
                              wstr,
                              size
                              );
    wstr[len] = (WCHAR) 0;
    v.vt = VT_BSTR;
    v.bstrVal = SysAllocString(wstr);
    sc = pNewOSInst->Put(L"Directory", 0,&v, 0);
    VariantClear(&v);
    PCHAR temp = options + 1;
    *options = '=';
    PCHAR temp1;
    // Rest of the stuff is filled in during initialization
    while(*temp){ // We know line ends with a null
        while(*temp && *temp == ' '){
            temp ++;
        }
        if(*temp == 0) break;
        // Get the new string 
        temp1 = temp;
        if(*temp == '"'){
            // could be the name of the OS
            do {
                temp1++;
            }while(*temp1 && (*temp1 != '"'));
            if(*temp1){
                temp1++;
            }
            else{
                BPFree(rest);
                BPFree(wstr);
                return WBEM_E_FAILED;
            }
            len = MultiByteToWideChar(CP_ACP,
                                      0,
                                      temp,
                                      temp1-temp,
                                      wstr,
                                      size
                                      );
            wstr[len] = (WCHAR) 0;
            v.vt = VT_BSTR;
            v.bstrVal = SysAllocString(wstr);
            sc = pNewOSInst->Put(L"OperatingSystem", 0,&v, 0);
            VariantClear(&v);
            temp = temp1;
            continue;
        }
        do{
            temp1++;
        }while((*temp1) && (*temp1 != ' ') && (*temp1 != '/'));
                 // Now we have the option between temp1 and temp2.
        if(strncmp(temp,"/redirect", strlen("/redirect")) == 0){
            v.vt = VT_BOOL;
            v.boolVal = TRUE;
            sc = pNewOSInst->Put(L"Redirect", 0,&v, 0);
            VariantClear(&v);
            temp = temp1;
            continue;
        }
        if(strncmp(temp,"/debug", strlen("/debug")) == 0){
            // fill in the redirect flag.
            v.vt = VT_BOOL;
            v.boolVal = TRUE;
            sc = pNewOSInst->Put(L"Debug", 0,&v, 0);
            VariantClear(&v);
            temp = temp1;
            continue;
        }

        if(strncmp(temp,"/fastdetect", strlen("/fastdetect")) == 0){
            // fill in the redirect flag.
            v.vt = VT_BOOL;
            v.boolVal = TRUE;
            sc = pNewOSInst->Put(L"Fastdetect", 0,&v, 0);
            VariantClear(&v);
            temp = temp1;
            continue;
        }
        strncat(rest,temp, temp1-temp);
        strcat(rest," ");
        temp = temp1;
    }
    len = MultiByteToWideChar(CP_ACP,
                              0,
                              rest,
                              strlen(rest),
                              wstr,
                              size
                              );
    wstr[len] = (WCHAR) 0;
    v.vt=VT_BSTR;
    v.bstrVal = SysAllocString(wstr);
    sc = pNewOSInst->Put(L"Rest", 0,&v, 0);
    VariantClear(&v);
    BPFree(rest);
    BPFree(wstr);
    return sc;
}


SCODE
ParseBootFile(IWbemClassObject *pClass,
              PCHAR data, 
              PWCHAR *wdef, 
              PCHAR red,
              PLONG pdelay,
              SAFEARRAY **psa
              )
{
    IWbemClassObject FAR* pNewOSInst;
    HRESULT ret;
    int dwRet;
    SCODE sc;
    SAFEARRAYBOUND bound[1];
    long index;
    PCHAR def=NULL;
    PCHAR pChar;
    VARIANT v;
    HRESULT hret;
    CIMTYPE type;
    
    // Ok, start string manipulation.

    // Read each line and glean the required information
    CHAR sep[] = "\r\n";
    PCHAR temp1;

    PCHAR temp = strtok(data,sep);
    int i = 0;
    strcpy(red,"no"); // Put in the default values for these.
    *pdelay = 30;
    while(temp){
        // Ignore spaces
        while(*temp && *temp == ' '){
            temp++;
        }
        if(*temp == ';'){// comment line
            temp = strtok(NULL,sep);
            continue;
        }
        if(strncmp(temp,"[boot loader]",strlen("[boot loader]"))==0){
            do{
                temp1 = strchr(temp,'=');
                if(!temp1){
                    // weird stuff is going on
                    // could be a comment line or some such thing
                    temp = strtok(NULL,sep);
                    continue;
                }
                else{
                    temp1++;
                }
                while(*temp1 && *temp1 == ' ' ){
                    temp1++;
                }
                if(strncmp(temp,"default",strlen("default"))==0){
                    def= temp1;
                    temp = strtok(NULL,sep);
                    continue;
                }
                if(strncmp(temp,"redirect",strlen("redirect"))==0){
                    sscanf(temp1, "%s",red);
                    temp = strtok(NULL,sep);
                    continue;
                }
                if(strncmp(temp,"timeout=",strlen("timeout="))==0){
                    sscanf(temp1, "%d",pdelay);
                }
                temp = strtok(NULL,sep);
            }while(temp && (*temp != '[')); // next section has begun
            continue;
        }
        if(strncmp(temp,"[operating systems]",strlen("[operating systems]")) == 0){
            bound[0].lLbound = 0;
            bound[0].cElements = 0;
            *psa = SafeArrayCreate(VT_UNKNOWN,
                                   1,
                                   bound
                                   );  

            if(*psa == NULL){
                return WBEM_E_FAILED;
            }
            do{

                // Trim leading spaces
                while (*temp == ' '){
                    temp ++;
                }
                // Skip comment lines
                if ( *temp != ';' ){
                    // pChar will point at the directory

                    PCHAR pChar = strchr(temp,'=');

                    // We must have an = sign or this is an invalid string

                    if (pChar){
                        // Punch in a null
                        // Increase the number of elements
                        index = (long) bound[0].cElements;
                        bound[0].cElements += 1;
                        ret = SafeArrayRedim(*psa,
                                             bound
                                             );
                        if(ret != S_OK){
                            SafeArrayDestroy(*psa);
                            return WBEM_E_FAILED;
                        }
                        sc = pClass->SpawnInstance(0,&pNewOSInst);
                        // Start filling in the new instance
                        if(FAILED(sc)){
                            SafeArrayDestroy(*psa);
                            return sc;
                        }
                        sc = ParseLine(pNewOSInst,temp,pChar);
                        if (sc != S_OK) {
                            SafeArrayDestroy(*psa);
                            return sc;
                        }
                        ret = SafeArrayPutElement(*psa,
                                                  &index,
                                                  pNewOSInst
                                                  );
                        if(ret != S_OK){
                            SafeArrayDestroy(*psa);
                            return WBEM_E_FAILED;
                        }
                    }
                }
                temp = strtok(NULL,sep);
            }while(temp && (*temp != '['));
        }
    }

    // Now find out if the default operating system is in one of the
    // Convert the default string to a proper displayable value.
    if(def){
        int size = strlen(def);
        int len;
        *wdef = (PWCHAR) BPAlloc((size+1)*sizeof(WCHAR));
        
        if(*wdef == NULL){
            SafeArrayDestroy(*psa);
            return WBEM_E_FAILED;
        }
        len = MultiByteToWideChar(CP_ACP,
                                  0,
                                  def,
                                  size,
                                  *wdef,
                                  size
                                  );
        (*wdef)[len] = (WCHAR) 0;
        LONG uBound;
        IWbemClassObject *pOSInst;
        hret = SafeArrayGetUBound(*psa,
                                  1,
                                  &uBound
                                  );
        LONG i;
        for(i = 0; i<=uBound; i++){
            hret = SafeArrayGetElement(*psa,
                                       &i,
                                       &pOSInst
                                       );
            if(hret != S_OK){
                pOSInst->Release();
                SafeArrayDestroy(*psa);
                BPFree(*wdef);
                return WBEM_E_FAILED;
            }
            hret = pOSInst->Get(L"Directory",
                                0,
                                &v,
                                &type,
                                NULL
                                );
            if(hret != WBEM_S_NO_ERROR){
                SafeArrayDestroy(*psa);
                pOSInst->Release();
                BPFree(*wdef);
                return -1;
            }
            if(v.vt != VT_BSTR){
                SafeArrayDestroy(*psa);
                pOSInst->Release();
                BPFree(*wdef);
                return -1;
            }
            if(wcscmp(v.bstrVal,*wdef) == 0){
                VariantClear(&v);
                break;
            }
        }
        BPFree(*wdef);
        if(i > uBound){
            SafeArrayDestroy(*psa);
            return WBEM_E_FAILED;
        }
        hret=pOSInst->Get(L"OperatingSystem",
                          0,
                          &v,
                          &type,
                          NULL
                          );
        pOSInst->Release();
        if(hret != WBEM_S_NO_ERROR){
            SafeArrayDestroy(*psa);
            return WBEM_E_FAILED;
        }
        if(v.vt != VT_BSTR){
            SafeArrayDestroy(*psa);
            return WBEM_E_FAILED;
        }
        *wdef = (PWCHAR) BPAlloc(wcslen(v.bstrVal) + sizeof(WCHAR));
        if(*wdef == NULL){
            return -1;
        }
        wcscpy(*wdef,v.bstrVal);
        VariantClear(&v);
    }
    return S_OK;
}

SCODE
GetLoaderParameters(HANDLE BootFile,
                    IWbemClassObject *pNewInst,
                    IWbemClassObject *pClass
                    )
{
    // Read the entire file into memory if you can otherwise forget about it. 
    VARIANT v;
    LONG dwret;
    SCODE sc;
    DWORD dwlen;


    DWORD dwsize = GetFileSize(BootFile,
                               NULL
                               );
    if(dwsize == -1){
        return WBEM_E_FAILED;
    }
    PCHAR data =(PCHAR)  BPAlloc(dwsize + sizeof(CHAR));
    if(!data){
        return WBEM_E_FAILED;
    }
    dwret = ReadFile(BootFile,
                     (LPVOID) data,
                     dwsize,
                     &dwlen,
                     NULL
                     );

    if(dwret == 0){
        BPFree(data);
        return GetLastError();
    }
    
    // Parse the code and return the answers in two arrays, and a safe array
    SAFEARRAY *psa;
    CHAR red[32];
    LONG delay;
    PWCHAR wdef=NULL;
    sc = ParseBootFile(pClass,
                       data, 
                       &wdef, 
                       red,
                       &delay,
                       &psa
                       );
    
    BPFree(data);
    if (sc != S_OK) {
        return sc;
    }

    // fill in the New Instance

    // Fill in the default OS.
    v.vt = VT_BSTR;
    int len;
    v.bstrVal = SysAllocString(wdef);
    sc = pNewInst->Put(L"Default", 0,&v, 0);
    VariantClear(&v);
    BPFree(wdef);
    
    //Fill in the redirect parameter
    WCHAR wred[32];
    len = MultiByteToWideChar(CP_ACP,
                              0,
                              red,
                              strlen(red),
                              wred,
                              32
                              );
    wred[len] = (WCHAR) 0;
    v.vt = VT_BSTR;
    v.bstrVal = SysAllocString(wred);
    sc = pNewInst->Put(L"Redirect", 0, &v, 0);
    VariantClear(&v);

    // Fill in the delay

    v.vt = VT_I4;
    v.lVal = delay;
    sc = pNewInst->Put(L"Delay", 0, &v, 0);
    VariantClear(&v);

    // Fill in the OS in the file
    v.vt = VT_ARRAY|VT_UNKNOWN;
    v.parray = psa;
    sc = pNewInst->Put(L"operating_systems", 0, &v, 0);
    VariantClear(&v);
    return S_OK;
}

//BOOLEAN first=TRUE;

SCODE
GetBootLoaderParameters(IWbemServices * m_pNamespace,
                        IWbemClassObject *pNewInst,
                        IWbemContext *pCtx
                        )
{
    HANDLE BootFile;
    SCODE sc;
    IWbemClassObject *pClass;
    IWbemObjectTextSrc *pSrc;
    BSTR strText;
    HRESULT hr;
/*
    if (first) {
        first = FALSE;
        return WBEM_E_FAILED;
    }
*/
    // Read the file and set in the values.
    if(pNewInst == NULL){
        return WBEM_E_INVALID_PARAMETER;
    }

    // Get a handle to the boot file.
    PCHAR data = GetBootFileName();
    if(!data){
        return WBEM_E_FAILED;
    }
    BootFile = GetFileHandle(data,OPEN_EXISTING,GENERIC_READ);
    BPFree(data);
    if(BootFile == INVALID_HANDLE_VALUE){
        return WBEM_E_FAILED;
    }
    sc = m_pNamespace->GetObject(L"OSParameters", 0, pCtx, &pClass, NULL);
    if (sc != S_OK) {
        return WBEM_E_FAILED;
    }
    sc = GetLoaderParameters(BootFile, pNewInst, pClass);
    CloseHandle(BootFile);
    pClass->Release();
    if (sc != S_OK) {
        return WBEM_E_FAILED;
    }

    pSrc = NULL;
    IWbemClassObject *pInstance;

    if(SUCCEEDED(hr = CoCreateInstance (CLSID_WbemObjectTextSrc, NULL, CLSCTX_INPROC_SERVER,                            
                                        IID_IWbemObjectTextSrc, (void**) &pSrc))) {
        if (pSrc) {
            if(SUCCEEDED(hr = pSrc->GetText(0, pNewInst, WMI_OBJ_TEXT_WMI_DTD_2_0, pCtx, &strText))) {
                if( SUCCEEDED( hr = pSrc->CreateFromText( 0, strText, WMI_OBJ_TEXT_WMI_DTD_2_0, 
                                                            NULL, &pInstance) ) ) {
                    pInstance->Release();
                    sc = 0;
                } else {
                    sc = hr;
                }
                SysFreeString(strText);
            }
            else {
                printf("GetText failed with %x\n", hr);
            }
            pSrc->Release();
        }

    }
    else
        printf("CoCreateInstance on WbemObjectTextSrc failed with %x\n", hr);

    return sc;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\headless\bootprov\utils.cpp ===
//***************************************************************************
//
//  UTILS.CPP
//
//  Module: WMI Instance provider code for boot parameters
//
//  Purpose: General purpose utilities.  
//
//  Copyright (c) 1997-1999 Microsoft Corporation
//
//***************************************************************************

#include <objbase.h>
#include "bootini.h"

LPTSTR IDS_RegBootDirKey = _T("BootDir");
LPTSTR IDS_BootIni = _T("boot.ini");
LPTSTR IDS_CBootIni = _T("c:\\boot.ini");
LPTSTR IDS_RegCurrentNTVersionSetup = _T("SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Setup");


PCHAR
GetBootFileName(
    )
{
    HKEY h_key;
    LPTSTR data = NULL;
    DWORD cbdata;
    DWORD type;
    LONG ret;

    ret = RegOpenKeyEx(HKEY_LOCAL_MACHINE, 
                       IDS_RegCurrentNTVersionSetup, 
                       0,
                       KEY_READ,
                       &h_key
                       );
    if (ret != ERROR_SUCCESS) {
        return NULL;
    }
    cbdata = 0;

    ret = RegQueryValueEx(h_key,
                          IDS_RegBootDirKey,
                          NULL,
                          &type,
                          (LPBYTE) data,
                          &cbdata
                          );

    if(ret == ERROR_MORE_DATA){
        data = (LPTSTR) BPAlloc(cbdata + 
                                (_tcslen(IDS_BootIni)+1)*sizeof(TCHAR));
        ret=RegQueryValueEx(h_key,
                            IDS_RegBootDirKey,
                            NULL,
                            &type,
                            (LPBYTE) data,
                            &cbdata
                            );

    }
    else{
        data = (LPTSTR) BPAlloc((_tcslen(IDS_CBootIni)+1)*sizeof(TCHAR));
    }
    if(data){
        _tcscat(data, IDS_CBootIni);
    }
    else{
        return NULL;
    }
    return data;
}

HANDLE GetFileHandle(PCHAR data,
                     DWORD dwCreationDisposition,
                     DWORD dwAccess
                     )
{

    LONG ret;
    
    if(!data){
        return INVALID_HANDLE_VALUE;
    }
    HANDLE h = CreateFile(data, 
                          dwAccess, 
                          FILE_SHARE_READ,  // Exclusive Write Access
                          NULL, 
                          dwCreationDisposition, 
                          0, 
                          NULL
                          ) ;
    if(INVALID_HANDLE_VALUE==h){
        ret=GetLastError();

    }
    return h;
    
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\headless\cmd\sacsess\main.cpp ===
/*++

Copyright (c) 1999-2001  Microsoft Corporation

Module Name:

    main.cpp

Abstract:

    entry point for command console shell session

Author:

    Brian Guarraci (briangu) 2001.

Revision History:

--*/

#include <CmnHdr.h>
#include <New.h>
#include <utils.h>
#include <Session.h>

int __cdecl 
NoMoreMemory( 
    size_t size 
    )
/*++

Routine Description:

    C++ new error handler
    
Arguments:

    size_t  - size of request                     
          
Return Value:

    status                             

--*/
{
    ASSERT(0);

    UNREFERENCED_PARAMETER(size);

    ExitProcess( 1 );
}

int __cdecl 
main()
/*++

Routine Description:

    This is the main entry point for the session

Arguments:

    None                                                
          
Return Value:

    status            

--*/
{
    CSession *pClientSession = NULL;

    //
    // Install the new error handler
    //
    _set_new_handler( NoMoreMemory );

    //
    // create the session
    //
    pClientSession = new CSession;
    
    if( pClientSession )
    {

        __try
        {
            if( pClientSession->Init() )
            {
                pClientSession->WaitForIo();
            }
        }
        __finally
        { 
            pClientSession->Shutdown(); 
            delete pClientSession;
        }
    }
    
    return( 0 );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\headless\cmd\profile\loadprofile.cpp ===
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Module Name:

    loadprofile.cpp

  Abstract:

    test LoadUserProfile

 -----------------------------------------------------------------------------*/

#define UNICODE 1
#define _UNICODE 1

#include <stdio.h>
#include <stdlib.h>
#include <windows.h>
#include <userenv.h>
#include <ntsecapi.h>

bool 
SetCurrentEnvironmentVariables(
    PWCHAR              pchEnvironment
    )
// Sets each environment variable in the block pchEnvironment into the
// current process' environment block by calling WIN::SetEnvironmentVariable
{
    WCHAR* pch = pchEnvironment;
    WCHAR* pchName;
    BOOL fStatus = TRUE;

    if (pch) {

        while (*pch) {
            
            // save pointer to beginning of name
            pchName = pch;

            // skip possible leading equals sign
            if (*pch == '=') {
                pch++;
            }

            // advance to equals sign separating name from value
            while (*pch != '=') {
                pch++;
            }

            // null-terminate name, overwriting equals sign
            *pch++ = 0;

            // set the value. pchName now points to the name and pch points to the value
//            fStatus = SetEnvironmentVariableW(pchName, pch);

            printf("%S=%S\n", pchName, pch);

            if ( ! fStatus ) {
                return false;
            }

            // advance over the value
            while (*pch++ != 0) {
                ;
            }

            // we're now positioned at the next name, or at the block's null
            // terminator and we're ready to go again
        
        }
    
    }
                                                                                                                     
    return true;
}

DWORD
__cdecl 
wmain (INT argc, WCHAR* argv[])
{
    DWORD           dwRet           = -1;
    HANDLE          hToken          = NULL;
    PROFILEINFOW    ProfileInfo     = { 0 };
    TCHAR           pwszUserName[MAX_PATH];
    DWORD           dwSize = MAX_PATH - 1;
    PWCHAR          pchSystemEnvironment;


    if ( ! OpenProcessToken (
                GetCurrentProcess(),
                TOKEN_ALL_ACCESS,
                &hToken
                ) )
    {
        printf("error: LogonUser - %d\n", GetLastError() );
        goto end;
    }

    dwRet = GetUserName(
        pwszUserName,
        &dwSize
        );

    if (!dwRet) {
        printf("error: GetUserName - %d\n", GetLastError() );
        goto end;
    }

    ProfileInfo.dwSize      = sizeof ( ProfileInfo );
    ProfileInfo.dwFlags     = PI_NOUI;
    ProfileInfo.lpUserName  = pwszUserName;

    if ( ! LoadUserProfile (
        hToken,
        &ProfileInfo
        ) )
    {
        
        printf("error: LoadUserProfile - %d\n", GetLastError() );
        goto end;
    
    } else {

        printf("LoadUserProfile succeeded for user: %S.\n", pwszUserName);

        //
        // Load the user's environment block so we can inject it into their current
        // environment
        //
        if (CreateEnvironmentBlock((void**)&pchSystemEnvironment, hToken, FALSE)) {                

            printf("Successfully Loaded environment block:\n");

            // set each machine environment variable into the current process's environment block
            SetCurrentEnvironmentVariables(pchSystemEnvironment);

            // we're done with the block so destroy it
            DestroyEnvironmentBlock(pchSystemEnvironment);

        } else {
            printf("error: Could not get environment block.");
        }

    }

    dwRet = 0;

end:

    if ( hToken )
    {
        if ( ProfileInfo.hProfile )
        {
            UnloadUserProfile ( hToken, ProfileInfo.hProfile );
        }

#if 0
        if ( pProfileBuffer )
        {
            LsaFreeReturnBuffer ( pProfileBuffer );
        }
#endif

        CloseHandle ( hToken );
    }

    return dwRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\headless\cmd\sacsess\redraw.cpp ===
/*++

Copyright (c) 1999-2001  Microsoft Corporation

Module Name:

    redraw.cpp

Abstract:

    This file implements redraw handler class.

Author:

    Brian Guarraci (briangu) 2001.

Revision History:

--*/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <process.h>

#include "cmnhdr.h"
#include "redraw.h"
#include "nullio.h"
#include "utils.h"

CRedrawHandler::CRedrawHandler(
    IN CLockableIoHandler   *IoHandler
    )
        
/*++

Routine Description:

    Constructor
    
Arguments:

    IoHanlder   - the IoHanlder the redraw handler handles events for
    
Return Value:

    N/A

--*/
{
    
    ASSERT(IoHandler != NULL);
    
    //
    // Default: writing is not enabled
    //
    m_WriteEnabled = FALSE;
    
    //
    // Assign our IoHandler
    //
    m_IoHandler = IoHandler;

    //
    // 
    //
    m_ThreadExitEvent           = NULL;
    m_RedrawEventThreadHandle   = INVALID_HANDLE_VALUE;
    m_RedrawEvent               = INVALID_HANDLE_VALUE;

    //
    // Initialize the critical secion we use for the mirror string
    //
    InitializeCriticalSection(&m_CriticalSection); 

    //
    // Allocate and initialize the mirror string
    //
    m_MirrorStringIndex = 0;
    m_MirrorString      = new WCHAR[MAX_MIRROR_STRING_LENGTH+1];
    
    RtlZeroMemory(m_MirrorString, (MAX_MIRROR_STRING_LENGTH+1) * sizeof(WCHAR));

}
                 
CRedrawHandler::~CRedrawHandler()
/*++

Routine Description:

    Desctructor

Arguments:

    N/A
          
Return Value:

    N/A

--*/
{

    //
    // If the TimeOut thread is running, then stop it
    //
    if ((m_RedrawEventThreadHandle != INVALID_HANDLE_VALUE) &&
        ((m_ThreadExitEvent != NULL))) {
        
        //
        // Tell the TimeOut Thread to exit
        //
        SetEvent(m_ThreadExitEvent);
        
        //
        // Wait for the threads to exit
        //
        WaitForSingleObject(
            m_RedrawEventThreadHandle, 
            INFINITE
            );
    
    }

    //
    // if we have the exit event,
    // then release it
    //
    if (m_ThreadExitEvent != NULL) {
        CloseHandle(m_ThreadExitEvent);
    }

    //
    // if we have the redraw thread event,
    // then release it
    //
    if (m_RedrawEventThreadHandle != INVALID_HANDLE_VALUE) {
        CloseHandle(m_RedrawEventThreadHandle);
    }

    //
    // Note: we need to release attributes that the thread
    //       uses after we terminate the thread, otherwise
    //       the thread may attempt to access these attributes
    //       before it exits.
    //

    //
    // release the critical section
    //
    DeleteCriticalSection(&m_CriticalSection);

    //
    // release the mirror string
    //
    delete [] m_MirrorString;

}

CRedrawHandler*
CRedrawHandler::Construct(
    IN CLockableIoHandler   *IoHandler,
    IN HANDLE               RedrawEvent
    )
/*++

Routine Description:

    This routine constructs a security IoHandler connected
    to a channel with the specified attributes.

Arguments:

    IoHandler   - the IoHandler to write to 
    Attributes  - the attributes of the new channel   
          
Return Value:

    Success - A ptr to a CRedrawHandler object.
    Failure - NULL

--*/
{
    BOOL            bStatus;
    CRedrawHandler  *RedrawHandler;

    //
    // default
    //
    bStatus = FALSE;
    RedrawHandler = NULL;
    
    do {

        ASSERT(IoHandler);
        if (!IoHandler) {
            break;
        }
        ASSERT(RedrawEvent != NULL);
        if (RedrawEvent == NULL) {
            break;
        }
        ASSERT(RedrawEvent != INVALID_HANDLE_VALUE);
        if (RedrawEvent == INVALID_HANDLE_VALUE) {
            break;
        }

        //
        // Create a new RedrawHandler
        //
        RedrawHandler = new CRedrawHandler(IoHandler);

        //
        // Keep the RedrawEvent so we know when to redraw the 
        // authentication screen
        //
        RedrawHandler->m_RedrawEvent = RedrawEvent;

        //
        // Create the event used to signal the threads to exit
        //
        RedrawHandler->m_ThreadExitEvent = CreateEvent( NULL, TRUE, FALSE, NULL );
        ASSERT(RedrawHandler->m_ThreadExitEvent != NULL);
        if (RedrawHandler->m_ThreadExitEvent == NULL) {
            break;
        }

        //
        // Create thread to handle redraw events
        //
        RedrawHandler->m_RedrawEventThreadHandle = (HANDLE)_beginthreadex(
            NULL,
            0,
            CRedrawHandler::RedrawEventThread,
            RedrawHandler,
            0,
            (unsigned int*)&RedrawHandler->m_RedrawEventThreadTID
            );

        if (RedrawHandler->m_RedrawEventThreadHandle == INVALID_HANDLE_VALUE) {
            break;
        }
    
        //
        // we were successful
        //
        bStatus = TRUE;

    } while ( FALSE );

    //
    // cleanup if necessary
    //
    if (! bStatus) {
        
        if (RedrawHandler) {
            
            //
            // we cant create the handler
            //
            delete RedrawHandler;
            
            //
            // send back a null
            //
            RedrawHandler = NULL;
        
        }
    
        //
        // if the thread event was created,
        // then close it
        //
        if (RedrawHandler->m_ThreadExitEvent != NULL) {
            CloseHandle(RedrawHandler->m_ThreadExitEvent);
        }
    
    }

    return RedrawHandler;
}

BOOL
CRedrawHandler::Write(
    PBYTE   Buffer,
    ULONG   BufferSize
    )
/*++

Routine Description:

    This routine is a shim for the IoHandler write routine.
    It writes the string to both the channel
    and to the end of the mirror string.  

Arguments:

    Buffer      - the string to write
    BufferSize  - the string size in bytes
          
Return Value:

    TRUE    - no errors
    FALSE   - otherwise

--*/
{
    BOOL    bSuccess;
    ULONG   Length;

    //
    // default: we succeeded
    //
    bSuccess = TRUE;

    __try {
        
        //
        // syncronize access to the mirror string
        //
        EnterCriticalSection(&m_CriticalSection); 
        
        //
        // Append the buffer to our internal mirror 
        // of what we have sent
        //
        // Note: the incoming buffer points to a WCHAR array,
        //       hence, we divide by sizeof(WCHAR) to compute
        //       the # of WCHARs
        //
        Length = BufferSize / sizeof(WCHAR);

        //
        // Do boundary checking
        //
        ASSERT(m_MirrorStringIndex + Length <= MAX_MIRROR_STRING_LENGTH);
        if (m_MirrorStringIndex + Length > MAX_MIRROR_STRING_LENGTH) {
            bSuccess = FALSE;
            __leave;
        }

        //
        // Copy the string into our mirror buffer
        //
        wcsncpy(
            &m_MirrorString[m_MirrorStringIndex],
            (PWSTR)Buffer,
            Length
            );

        //
        // Adjust our index into the mirror string
        //
        m_MirrorStringIndex += Length;

        //
        // Write the message if we can
        //
        if (m_WriteEnabled) {
            
            bSuccess = m_IoHandler->GetUnlockedIoHandler()->Write( 
                Buffer,
                BufferSize
                );

            m_IoHandler->GetUnlockedIoHandler()->Flush(); 
        
        }
    
    }
    __finally
    {
        LeaveCriticalSection(&m_CriticalSection); 
    }
    
    return bSuccess;
}

BOOL
CRedrawHandler::Flush(
    VOID
    )
/*++

Routine Description:

Arguments:
          
Return Value:


--*/
{
    //
    // Pass through to the IoHandler
    //
    return m_IoHandler->GetUnlockedIoHandler()->Flush();
}


VOID
CRedrawHandler::Reset(
    VOID
    )
/*++

Routine Description:

    This routine "clears the screen"

Arguments:

    None                                
          
Return Value:

    None    

--*/
{
    __try {
        
        //
        // syncronize access to the mirror string
        //
        EnterCriticalSection(&m_CriticalSection); 
        
        //
        // reset the mirror string attributes
        //
        m_MirrorStringIndex = 0;
        m_MirrorString[m_MirrorStringIndex] = UNICODE_NULL;
    
    }
    __finally
    {
        LeaveCriticalSection(&m_CriticalSection); 
    }
}

BOOL
CRedrawHandler::WriteMirrorString(
    VOID
    )
/*++

Routine Description:

    This routine writes the entire current Mirror string to the channel.
    
Arguments:

    None          
                                           
Return Value:

    TRUE    - no errors
    FALSE   - otherwise

--*/
{
    BOOL    bSuccess;
    
    //
    // Default: we succeeded
    //
    bSuccess = TRUE;

    //
    // Only write if our IoHandler is locked.
    //
    // If they are unlocked, they will handle
    // the redraw events.  If they are locked,
    // we need to handle them.
    //
    if (m_IoHandler->IsLocked() && m_WriteEnabled) {
        
        __try {
            
            //
            // syncronize access to the mirror string
            //
            EnterCriticalSection(&m_CriticalSection); 
            
            //
            // Write the message
            //
            bSuccess = m_IoHandler->GetUnlockedIoHandler()->Write( 
                (PBYTE)m_MirrorString,
                m_MirrorStringIndex * sizeof(WCHAR)
                );

            m_IoHandler->GetUnlockedIoHandler()->Flush(); 
        
        }
        __finally
        {
            LeaveCriticalSection(&m_CriticalSection); 
        }
    
    }
    
    return bSuccess;
}

unsigned int
CRedrawHandler::RedrawEventThread(
    PVOID   pParam
    )
/*++

Routine Description:

    This routine handles the redraw event from the SAC driver.
     
    It does this by being a combination event handler and screen
    scraper.  When the event fires, we immediately attempt to 
    draw the latest screen and then it goes into screen scraping
    mode.  This duality ensures that if we service the event
    before we actually write anything to the mirror string,
    that we push the string to the user correctly.
    
Arguments:

    pParam  - thread context
          
Return Value:

    thread return value                            

--*/
{                       
    BOOL                bContinueSession;
    DWORD               dwRetVal;
    CRedrawHandler  *IoHandler;
    HANDLE              handles[2];
    WCHAR               LastSeen[MAX_MIRROR_STRING_LENGTH+1];
     
    enum { 
        THREAD_EXIT = WAIT_OBJECT_0, 
        CHANNEL_REDRAW_EVENT
        };

    //
    // default: listen
    //
    bContinueSession = TRUE;
    
    //
    // Get the session object
    // 
    IoHandler = (CRedrawHandler*)pParam;

    //
    // Default: it is not an appropriate time to scrape
    //
    InterlockedExchange(&IoHandler->m_WriteEnabled, FALSE);

    //
    // Assign the events to listen for
    //
    handles[0] = IoHandler->m_ThreadExitEvent;
    handles[1] = IoHandler->m_RedrawEvent;

    //
    // While we should listen:
    //
    //  1. wait for a HasNewDataEvent from the SAC driver
    //  2. wait for a CloseEvent from the SAC driver
    // 
    while ( bContinueSession ) {
        
        ULONG   HandleCount;
        
        //
        // If scraping is enabled, 
        // then don't wait on the scrape event.
        //
        // Note: the redraw event must be the last event
        //       in the handles array
        //
        HandleCount = IoHandler->m_WriteEnabled ? 1 : 2;
        
        //
        // Wait for our events
        //
        dwRetVal = WaitForMultipleObjects(
            HandleCount,
            handles, 
            FALSE, 
            100 // 100ms
            );

        switch ( dwRetVal ) {
        case CHANNEL_REDRAW_EVENT: {
            
            //
            // We need to scrape the mirror string to ensure we
            // got all of the mirror string to the user
            //
            InterlockedExchange(&IoHandler->m_WriteEnabled, TRUE);
            
            //
            // attempt to redraw the authentication screen
            //
            bContinueSession = IoHandler->WriteMirrorString();
            
            break;
        
        case WAIT_TIMEOUT:
            
            if (IoHandler->m_WriteEnabled) {
                
                //
                // Here we do a simplified screen scraping using the Mirror
                // string as our "screen."  The purpose of this scraping
                // is to ensure that the user gets the latest authentication
                // screen. If we don't do this, it is possible for the Mirror
                // string to be updated after we catch the Redraw event,
                // which results in us not sending the entire Mirror string.
                //
                __try {

                    BOOL    bDifferent;

                    //
                    // syncronize access to the mirror string
                    //
                    EnterCriticalSection(&IoHandler->m_CriticalSection); 

                    //
                    // See if our last seen string == the current mirror string
                    //
                    bDifferent = (wcscmp(LastSeen, IoHandler->m_MirrorString) == 0);

                    //
                    // If there is a difference, 
                    // then we need to update the screen
                    //
                    if (bDifferent) {

                        //
                        // attempt to redraw the authentication screen
                        //
                        bContinueSession = IoHandler->WriteMirrorString();

                        //
                        // make the current mirror string, our last
                        //
                        ASSERT(wcslen(IoHandler->m_MirrorString) <= MAX_MIRROR_STRING_LENGTH);

                        wcscpy(LastSeen, IoHandler->m_MirrorString);
                    
                    }

                }
                __finally
                {
                    LeaveCriticalSection(&IoHandler->m_CriticalSection); 
                }
            
                //
                // Wait until the event clears by looking
                // for a WAIT_TIMEOUT
                //
                dwRetVal = WaitForSingleObject(
                    IoHandler->m_RedrawEvent,
                    0
                    );

                //
                // Check the wait result
                //
                switch (dwRetVal) {
                case WAIT_TIMEOUT:

                    //
                    // We need to stop scraping now
                    //
                    InterlockedExchange(&IoHandler->m_WriteEnabled, FALSE);

                    break;

                default:
                    
                    ASSERT (dwRetVal != WAIT_FAILED);
                    if (dwRetVal == WAIT_FAILED) {
                        bContinueSession = false;
                    }
                    
                    break;

                }

            }
            
            break;

        }

        default:
            
            //
            // incase WAIT_FAILED, call GetLastError()
            //
            ASSERT(dwRetVal != WAIT_FAILED);
            
            //
            // An error has occured, stop listening
            // 
            bContinueSession = FALSE;
            
            break;
        }
    }
    
    return 0;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\headless\cmd\sacsess\cmnhdr.h ===
/*++

Copyright (c) 2001 Microsoft Corporation

Module Name:

    cmnhdr.h

Abstract:

    common header class for the SAC session project

Author:

    Brian Guarraci (briangu), 2001                                                       
                                                   
Revision History:

--*/

#if !defined ( _CMNHDR_H_ )
#define _CMNHDR_H_

#pragma warning(disable:4127)   // condition expression is constant

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <Shlwapi.h>

// Windows Version Build Option
#ifdef _WIN32_WINNT
#undef _WIN32_WINNT
#endif
#define _WIN32_WINNT 0x0500

// Force all EXEs/DLLs to use STRICT type checking
#ifndef STRICT
#define STRICT
#endif

// Unicode Build Option
#ifndef UNICODE
#define UNICODE
#endif

//When using Unicode Win32 functions, use Unicode C-Runtime functions, too
#ifndef _UNICODE
#ifdef UNICODE
#define _UNICODE
#endif
#endif

#define ASSERT_STATUS(_C, _S)\
    ASSERT((_C));\
    if (!(_C)) {\
        return(_S);\
    }

#define SACSVR_PARAMETERS_KEY               L"System\\CurrentControlSet\\Services\\Sacsvr\\Parameters"
#define SACSVR_TIMEOUT_INTERVAL_VALUE       TEXT("TimeOutInterval")
#define SACSVR_TIMEOUT_DISABLED_VALUE       TEXT("TimeOutDisabled")
#define SACSVR_LOAD_PROFILES_DISABLED_VALUE TEXT("LoadProfilesDisabled")
                                              
#endif // _CMNHDR_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\headless\cmd\sacsess\scraper.cpp ===
/*++

Copyright (c) 1999-2001  Microsoft Corporation

Module Name:

    scraper.cpp

Abstract:

    Implementation of scraper base class.

Author:

    Brian Guarraci (briangu) 2001.

Revision History:

--*/

#include <stdio.h>

#include "scraper.h"

CScraper::CScraper(
    VOID
    )
/*++

Routine Description:

    Default constructor (don't use)
    
Arguments:

    None                                   
          
Return Value:

    N/A    

--*/
{
    
    m_hConBufIn         = INVALID_HANDLE_VALUE;
    m_hConBufOut        = INVALID_HANDLE_VALUE;

    m_IoHandler         = NULL;
    
    m_wMaxCols          = 0;
    m_wMaxRows          = 0;
    m_wCols             = 0;
    m_wRows             = 0;

}

CScraper::CScraper(
    CIoHandler  *IoHandler,
    WORD        wCols,
    WORD        wRows
    )
/*++

Routine Description:

    Constructor

Arguments:

    IoHandler   - the IoHandler to write the result of the
                  screen scraping to
    wCols       - the # of cols that the scraped app should have
    wRows       - the # of rows that the scraped app should have                         
          
Return Value:

    N/A

--*/
{
    
    m_hConBufIn         = INVALID_HANDLE_VALUE;
    m_hConBufOut        = INVALID_HANDLE_VALUE;

    m_IoHandler         = IoHandler;
    
    m_wMaxCols          = wCols;
    m_wCols             = wCols;
    
    m_wMaxRows          = wRows;
    m_wRows             = wRows;

}
        
CScraper::~CScraper()
/*++

Routine Description:

    Destructor
    
Arguments:

    N/A
          
Return Value:

    N/A

--*/
{
    if (m_hConBufIn != INVALID_HANDLE_VALUE) {
        CloseHandle( m_hConBufIn );
    }
    
    if (m_hConBufOut != INVALID_HANDLE_VALUE) {
        CloseHandle( m_hConBufOut );
    }
}


VOID
CScraper::SetConOut(
    HANDLE  ConOut
    )
/*++

Routine Description:

    This routine sets the console output handle the screen scraper
    uses to scrape from.  This should be the conout handle that the
    app the scraper is scraping for is writing to.

Arguments:

    ConOut  - the console output handle                                                  
          
Return Value:

    None

--*/
{
    m_hConBufOut = ConOut;
}

VOID
CScraper::SetConIn(
    HANDLE  ConIn
    )
/*++

Routine Description:

    This routine sets the console input that the screen scraper
    will use - actually, this is the conin handle that will be
    used by the app that the screen scraper is scraping for.

Arguments:

    ConIn    - the console input handle           
          
Return Value:

    None  

--*/
{
    m_hConBufIn = ConIn;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\headless\cmd\sacsess\secio.cpp ===
/*++

Copyright (c) 1999-2001  Microsoft Corporation

Module Name:

    secio.cpp

Abstract:

    This file contains the implementation of the CSecurityIoHandler
    class which enapsulates the primary security elements used by
    the CSession class. 

    TODO: this class needs to use a TermCap class to abstract the screen
          controls - currently, the class implicitly uses VT-UTF8

Author:

    Brian Guarraci (briangu) 2001.

Revision History:

--*/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <process.h>

#include "cmnhdr.h"
#include "secio.h"
#include "nullio.h"
#include "sacmsg.h"
#include "utils.h"

#define VTUTF8_CLEAR_SCREEN L"\033[2J\033[0;0H"

#define READ_BUFFER_LENGTH  512
#define READ_BUFFER_SIZE    (READ_BUFFER_LENGTH * sizeof(WCHAR))

CSecurityIoHandler::CSecurityIoHandler(
    IN CIoHandler   *LockedIoHandler,
    IN CIoHandler   *UnlockedIoHandler
    ) : CLockableIoHandler(
            LockedIoHandler,
            UnlockedIoHandler
            )
        
/*++

Routine Description:

    Constructor
    
Arguments:

    LockedIoHandler     - the IoHandler to use when the channel is locked
    UnlockedIoHandler   - the IoHandler to use when the channel is unlocked
    
Return Value:

    N/A

--*/
{

    //
    // Lock the IoHandler so that the read/write routines
    // are disabled.
    //
    Lock();

    //
    // Validate that our Io Handler pointers are valid
    //
    // This way, we don't have to check everytime we want
    // to use them.
    //
    ASSERT(myLockedIoHandler != NULL);
    ASSERT(myUnlockedIoHandler != NULL);
    ASSERT(myIoHandler != NULL);

    //
    // initialize our internal lock event 
    //
    m_InternalLockEvent = 0;

    //
    // init
    //
    m_StartedAuthentication = FALSE;


}

CSecurityIoHandler::~CSecurityIoHandler()
/*++

Routine Description:

    Desctructor

Arguments:

    N/A
          
Return Value:

    N/A

--*/
{

    //
    // Notify the remote user that we are shutting down the 
    // command console session
    //
    WriteResourceMessage(SHUTDOWN_NOTICE);
    
    //
    // release the redraw handler
    //
    if (m_RedrawHandler) {
        delete m_RedrawHandler;
    }
    
    //
    // The CLockableIoHandler destructor deletes the IoHandlers for us.
    //
    NOTHING;

    //
    // If the TimeOut thread is running, then stop it
    //
    if ((m_TimeOutThreadHandle != INVALID_HANDLE_VALUE) &&
        (m_ThreadExitEvent != NULL)) {
        
        //
        // Tell the TimeOut Thread to exit
        //
        SetEvent(m_ThreadExitEvent);

        //
        // Wait for the thread to exit
        //
        WaitForSingleObject(
            m_TimeOutThreadHandle, 
            INFINITE
            );
    
    }

    //
    // Close the internal lock event
    //
    if (m_InternalLockEvent) {
        CloseHandle(m_InternalLockEvent);
    }

    //
    // Close the thread exit handle
    //
    if (m_ThreadExitEvent != NULL) {
        CloseHandle(m_ThreadExitEvent);
    }

    //
    // Close the thread handle
    //
    if (m_TimeOutThreadHandle != INVALID_HANDLE_VALUE) {
        CloseHandle(m_TimeOutThreadHandle);
    }

}

CSecurityIoHandler*
CSecurityIoHandler::Construct(
    IN SAC_CHANNEL_OPEN_ATTRIBUTES  Attributes
    )
/*++

Routine Description:

    This routine constructs a security IoHandler connected
    to a channel with the specified attributes.

Arguments:

    Attributes  - the attributes of the new channel   
          
Return Value:

    Success - A ptr to a CSecurityIoHandler object.
    Failure - NULL

--*/
{
    BOOL                bSuccess;
    CSecurityIoHandler  *IoHandler;
    CIoHandler          *SacIoHandler;
    CIoHandler          *NullIoHandler;

    //
    // default: failed to construct
    //
    bSuccess        = FALSE;
    IoHandler       = NULL;
    SacIoHandler    = NULL;
    NullIoHandler   = NULL;

    do {

        BOOL    bStatus;

        //
        // Validate the LockEvent for the timeout thread
        //
        ASSERT(Attributes.LockEvent != NULL);
        if (Attributes.LockEvent == NULL) {
            break;
        }
        
        ASSERT(Attributes.LockEvent != INVALID_HANDLE_VALUE);
        if (Attributes.LockEvent == INVALID_HANDLE_VALUE) {
            break;
        }
        
        //
        // Validate the CloseEvent for the WaitForInput thread
        //
        ASSERT(Attributes.CloseEvent != NULL);
        if (Attributes.CloseEvent == NULL) {
            break;
        }
        ASSERT(Attributes.CloseEvent != INVALID_HANDLE_VALUE);
        if (Attributes.CloseEvent == INVALID_HANDLE_VALUE) {
            break;
        }
        
        //
        // Validate the RedrawEvent for the Redraw IoHandler
        //
        ASSERT(Attributes.RedrawEvent != NULL);
        if (Attributes.RedrawEvent == NULL) {
            break;
        }
        ASSERT(Attributes.RedrawEvent != INVALID_HANDLE_VALUE);
        if (Attributes.RedrawEvent == INVALID_HANDLE_VALUE) {
            break;
        }

        //
        // Attempt to open a SAC channel
        //
        SacIoHandler = CSacIoHandler::Construct(Attributes);

        //
        // If we failed to open the SAC channel, 
        // then notify the caller that we failed by returning null
        //
        if (SacIoHandler == NULL) {
            break;
        }

        //
        // Get the Null Io Handler to be the locked IoHandler
        //
        NullIoHandler = new CNullIoHandler();

        //
        // Create a new SAC IoHandler
        //
        IoHandler = new CSecurityIoHandler(
            NullIoHandler,
            SacIoHandler
            );

        //
        // Create the event we will use to signal that a timeout
        // occured while we were trying to authenticate a user
        //
        IoHandler->m_InternalLockEvent = CreateEvent( NULL, TRUE, FALSE, NULL );
        ASSERT(IoHandler->m_InternalLockEvent);
        if (IoHandler->m_InternalLockEvent == 0) {
            break;
        }
        
        //
        // Keep the LockEvent for the timeout thread
        // Keep the CloseEvent for the WaitForInput thread
        //
        IoHandler->m_CloseEvent     = Attributes.CloseEvent;
        IoHandler->m_LockEvent      = Attributes.LockEvent;
        IoHandler->m_RedrawEvent    = Attributes.RedrawEvent;

        //
        // Create the event used to signal the threads to exit
        //
        IoHandler->m_ThreadExitEvent = CreateEvent( NULL, TRUE, FALSE, NULL );
        if (IoHandler->m_ThreadExitEvent == NULL) {
            break;
        }

        //
        // Start the timeout thread if we need to
        //
        bStatus = IoHandler->InitializeTimeOutThread();
        if (! bStatus) {
            break;
        }

        //
        // Create handler for redraw events
        //
        IoHandler->m_RedrawHandler = CRedrawHandler::Construct(
            IoHandler,
            Attributes.RedrawEvent
            );

        ASSERT(IoHandler->m_RedrawHandler);
        if (IoHandler->m_RedrawHandler == NULL) {
            break;
        }
    
        //
        // we were successful
        //
        bSuccess = TRUE;

    } while ( FALSE );

    //
    // if we were not successful
    // then clean up
    //
    if (! bSuccess) {

        //
        // Note: we do not need to clean up the Lock, Close, and Redraw events
        //       because we do not own them.  Also, we do not need
        //       to clean up the NullIo and SacIo IoHandlers because
        //       they are cleaned up by the LockIo parent class.
        //

        if (IoHandler) {
            delete IoHandler;
            IoHandler = NULL;
        }

    }

    return IoHandler;
}

BOOL
CSecurityIoHandler::Write(
    PBYTE   Buffer,
    ULONG   BufferSize
    )
/*++

Routine Description:

    This routine implements the IoHandler Write behavior.

Arguments:

    (see iohandler)
          
Return Value:

    (see iohandler)

--*/
{

    //
    // Pass through to the secured Io Handler
    //
    return myIoHandler->Write(
        Buffer,
        BufferSize
        );

}

BOOL
CSecurityIoHandler::Flush(
    VOID
    )
/*++

Routine Description:

    This routine implements the IoHandler Flush behavior.

Arguments:

    (see iohandler)
          
Return Value:

    (see iohandler)

--*/
{
    //
    // Pass through to the secured Io Handler
    //
    return myIoHandler->Flush();
}

BOOL
CSecurityIoHandler::Read(
    PBYTE   Buffer,
    ULONG   BufferSize,
    PULONG  ByteCount
    )
/*++

Routine Description:

    This routine implements the IoHandler Read behavior and
    resets the timeout counter when ever there is a successful
    read.
     
Arguments:

    (see iohandler)
          
Return Value:

    (see iohandler)

--*/
{
    BOOL    bSuccess;

    //
    // Pass through to the secured Io Handler
    //
    // if this iohandler is locked, 
    // then the caller will be reading from the NullIoHandler
    // else they will read from the UnlockedIoHandler
    //
    bSuccess = myIoHandler->Read(
                            Buffer,
                            BufferSize,
                            ByteCount
                            );

    //
    // If the sesssion received new user input,
    // then reset the timeout counter
    //
    if (*ByteCount > 0) {
        ResetTimeOut();
    }

    return bSuccess;
}

BOOL
CSecurityIoHandler::ReadUnlockedIoHandler(
    PBYTE   Buffer,
    ULONG   BufferSize,
    PULONG  ByteCount
    )
/*++

Routine Description:

    This routine reads a character from the unlocked io hander
    so that we can authenticate the user while the scraper still 
    uses the LockedIohandler.
    
    resets the timeout counter when ever there is a successful
    read.
     
Arguments:

    (see iohandler)
          
Return Value:

    (see iohandler)

--*/
{
    BOOL    bSuccess;

    //
    // Pass through to the secured Io Handler
    //
    bSuccess = myUnlockedIoHandler->Read(
                            Buffer,
                            BufferSize,
                            ByteCount
                            );

    //
    // If the sesssion received new user input,
    // then reset the timeout counter
    //
    if (*ByteCount > 0) {
        ResetTimeOut();
    }

    return bSuccess;
}

BOOL
CSecurityIoHandler::HasNewData(
    PBOOL   InputWaiting
    )
/*++

Routine Description:

    This routine implements the IoHandler HasNewData behavior.

Arguments:

    (see iohandler)
          
Return Value:

    (see iohandler)


--*/
{
    
    //
    // Pass through to the secured Io Handler
    //
    return myIoHandler->HasNewData(InputWaiting);

}

BOOL
CSecurityIoHandler::WriteResourceMessage(
    IN INT  MsgId
    )
/*++

Routine Description:

    This routine writes a resource string message to
    the Unlocked ioHandler.             

Arguments:

    MsgId   - the id of the message to write                           
          
Return Value:

    TRUE    - the message was loaded and written
    FALSE   - failed

--*/
{
    UNICODE_STRING  UnicodeString = {0};
    BOOL            bSuccess;

    //
    // Default: failed
    //
    bSuccess = FALSE;

    //
    // Attempt to load the string and write it
    // 
    do {

        if ( LoadStringResource(&UnicodeString, MsgId) ) {

            //
            // Terminate the string at the %0 marker, if it is present
            //
            if( wcsstr( UnicodeString.Buffer, L"%0" ) ) {
                *((PWCHAR)wcsstr( UnicodeString.Buffer, L"%0" )) = L'\0';
            }

            //
            // Write the message
            //
            bSuccess = m_RedrawHandler->Write( 
                (PUCHAR)UnicodeString.Buffer,
                (ULONG)(wcslen( UnicodeString.Buffer) * sizeof(WCHAR))
                );

            if (!bSuccess) {
                break;
            }

            bSuccess = m_RedrawHandler->Flush(); 

        }
    
    } while ( FALSE );

    return bSuccess;
}

BOOL 
CSecurityIoHandler::LoadStringResource(
    IN  PUNICODE_STRING pUnicodeString,
    IN  INT             MsgId
    )
/*++

Routine Description:

    This is a simple implementation of LoadString().

Arguments:

    usString        - Returns the resource string.
    MsgId           - Supplies the message id of the resource string.
  
Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{

    NTSTATUS        Status;
    PMESSAGE_RESOURCE_ENTRY MessageEntry;
    ANSI_STRING     AnsiString;

    Status = RtlFindMessage( NtCurrentPeb()->ImageBaseAddress,
                             (ULONG_PTR) RT_MESSAGETABLE, 
                             0,
                             (ULONG)MsgId,
                             &MessageEntry
                           );

    if (!NT_SUCCESS( Status )) {
        return FALSE;
    }

    if (!(MessageEntry->Flags & MESSAGE_RESOURCE_UNICODE)) {
        RtlInitAnsiString( &AnsiString, (PCSZ)&MessageEntry->Text[ 0 ] );
        Status = RtlAnsiStringToUnicodeString( pUnicodeString, &AnsiString, TRUE );
        if (!NT_SUCCESS( Status )) {
            return FALSE;
        }
    } else {
        RtlCreateUnicodeString(pUnicodeString, (PWSTR)MessageEntry->Text);
    }

    return TRUE;
}

BOOL
CSecurityIoHandler::AuthenticateCredentials(
    IN  PWSTR   UserName,
    IN  PWSTR   DomainName,
    IN  PWSTR   Password,
    OUT PHANDLE pUserToken
    )
/*++

Routine Description:

    This routine will attempt to authenticate the supplied credentials.

Arguments:

    UserName            - Supplied UserName
    
    DomainName          - Supplied DomainName
        
    Password            - Supplied Password
    
    pUserToken          - Holds the valid token for the authenticated user
                          credentials.

Return Value:

    TRUE  - Credentials successfully authenticated.
    FALSE - Credentials failed to authenticate.

Security:

    interface: exposes user input to LogonUser()

--*/

{
    BOOL    b;

    //
    // Notify the user that we are attempting to authenticate
    //
    WriteResourceMessage(LOGIN_IN_PROGRESS);

    //
    // Try the authentication.
    //
    b = LogonUser( UserName,
                   DomainName,
                   Password,
                   LOGON32_LOGON_INTERACTIVE,
                   LOGON32_PROVIDER_DEFAULT,
                   pUserToken );

    if (b) {
        
        //
        // Reset the timeout counter before we start the thread
        //
        ResetTimeOut();
    
    } else {

        //
        // Wait 3 seconds before returning control to user in
        // order to slow iterative attacks
        //
        Sleep(3000);

        //
        // Notify the user that the attempt failed
        //
        WriteResourceMessage(LOGIN_FAILURE);
        
        //
        // Wait for a key press
        //
        WaitForUserInput(TRUE);
            
    }

    return b;
}

BOOL
CSecurityIoHandler::RetrieveCredential(
    OUT PWSTR   String,
    IN  ULONG   StringLength,
    IN  BOOL    EchoClearText
    )
/*++

Routine Description:

    This routine will request credentials from the user.  Those
    credentials are then returned to the caller.
    
Arguments:

    String          - on success, contains the credential
    StringLength    - the # of WCHARS (length) in the string (includes NULL termination)
    EchoClearText   - TRUE: echo user input in clear text
                      FALSE: echo user input as '*'
    
Return Value:

    TRUE  - Credential recieved.
    FALSE - Something failed when we were trying to get credentials
            from the user.

Security:

    interface: external input
               echos user input

--*/
{
    PWCHAR          buffer;
    ULONG           bufferSize;
    ULONG           i, j;
    BOOLEAN         Done = FALSE;
    BOOL            bSuccess;

    //
    // validate parameters
    //
    if (! String) {
        return FALSE;
    }
    if (StringLength < 1) {
        return FALSE;
    }

    //
    // default: failed
    //
    bSuccess = FALSE;

    //
    // allocate the buffer we'll use to read the channel
    //
    buffer = new WCHAR[READ_BUFFER_LENGTH];

    //
    // default: start at the first character
    //
    i = 0;
    
    //
    // default: we need to read user input
    //
    Done = FALSE;

    //
    // Attempt to retrieve the credential
    //
    while ( !Done ) {

        //
        // Wait until the user inputs something
        //
        bSuccess = WaitForUserInput(FALSE);

        if (!bSuccess) {
            Done = TRUE;
            continue;
        }
        
        //
        // Read what the user input
        //
        
        //
        // we should be in a locked state now
        // which implies we are using the unlocked 
        // io handler - the scraper is using the locked one
        //
        ASSERT(myLockedIoHandler == myIoHandler);

        bSuccess = ReadUnlockedIoHandler( 
            (PUCHAR)buffer,
            READ_BUFFER_SIZE,
            &bufferSize
            );
         
        if (bSuccess) {

            //
            // We have received at least one character
            // hence by setting this to true, we enable
            // the internal lock event to succeed in
            // resetting the authentication attempt
            // that is, if the user starts to authenticate
            // and stops before finishing, the timer will
            // fire and reset the authentication attempt
            //
            m_StartedAuthentication = TRUE;

            //
            // Process the characters he gave us.
            //
            // Note: the buffer contains WCHARs, hence we need to
            //       divide the returned buffersize by sizeof(WCHAR) in
            //       order to get the # of wchars to process.
            //
            for ( j = 0; j < bufferSize/sizeof(WCHAR); j++ ) {

                //
                // stop if:
                //
                //  we reached the end of the Credentials buffer (not including the NULL)
                //  we received a CR || LF
                //
                if ( (i >= (StringLength-1)) || (buffer[j] == 0x0D) || (buffer[j] == 0x0A) ) {
                    Done = TRUE;
                    break;
                }

                //
                // handle user input
                //
                if( buffer[j] == '\b' ) {

                    //
                    // The user gave us a backspace.  We should cover up the
                    // character on the screen, then backup our index so we
                    // essentially forget the last thing he gave us.
                    //
                    // If the very first thing the user did was type in a backspace,
                    // no need to back anything up.
                    //
                    if( i > 0 ) {
                        
                        i--;
                        
                        String[i] = L'\0';
                        
                        bSuccess = m_RedrawHandler->Write( 
                            (PUCHAR)L"\b \b",
                            (ULONG)(wcslen(L"\b \b") * sizeof(WCHAR))
                            );
                        
                        if (!bSuccess) {

                            //
                            // write failed: exit
                            //

                            Done = TRUE;

                        }
                    
                    }

                } else if (buffer[j] < ' ') {
                
                    //
                    // If the character is less than ' ' (a control char), 
                    // then ignore it
                    //
                    NOTHING;

                } else {

                    //
                    // It was a valid character: remember the input and echo it back
                    // to the user.
                    //
                    
                    String[i] = buffer[j];
                    
                    i++;                    
                    
                    //
                    // Echo according to caller specifications
                    //
                    bSuccess = m_RedrawHandler->Write( 
                        EchoClearText ? (PUCHAR)&buffer[j] : (PUCHAR)L"*",
                        sizeof(WCHAR) 
                        );
                
                    if (!bSuccess) {
                        
                        //
                        // write failed: exit
                        //
                        
                        Done = TRUE;
                    
                    }

                }
                
            }

            if (bSuccess) {
                
                //
                // Flush any text echoing we've done.
                //
                bSuccess = m_RedrawHandler->Flush(); 
            
                if (!bSuccess) {

                    //
                    // write failed: exit
                    //

                    Done = TRUE;

                }
            
            }
        
        } else {
            
            //
            // read failed: exit
            //
            Done = TRUE;

        }
    
    }

    //
    // Terminate the credential
    //
    String[i] = UNICODE_NULL;

    //
    // release the read buffer
    //
    delete [] buffer;

    return bSuccess;

}

BOOL
CSecurityIoHandler::RetrieveCredentials(
    IN OUT PWSTR   UserName,
    IN     ULONG   UserNameLength,
    IN OUT PWSTR   DomainName,
    IN     ULONG   DomainNameLength,
    IN OUT PWSTR   Password,
    IN     ULONG   PasswordLength
    )

/*++

Routine Description:

    This routine will request credentials from the user.  Those
    credentials are then returned to the caller.
    
Arguments:

    UserName            - Buffer to hold the UserName
    UserNameLength      - Length of the UserName buffer 
    
    DomainName          - Buffer to hold the DomainName
    DomainNameLength    - Length of the DomainName buffer
    
    Password            - Buffer to hold the Password
    PasswordLength      - Length of the Password buffer
    
Return Value:

    TRUE  - Credentials recieved.
    FALSE - Something failed when we were trying to get credentials
            from the user.

--*/

{
    BOOL            HaveDomainName;
    BOOL            bSuccess;

    //
    // Initialize the flag that we use to keep track
    // of when the user first starts to authenticate.
    // that is, after they enter at least one character
    // they have started to authenticate.
    //
    m_StartedAuthentication = FALSE;

    //
    // Initialize our redraw screen 
    //
    m_RedrawHandler->Reset();

    //
    // Clear the screen
    //
    m_RedrawHandler->Write(
        (PUCHAR)VTUTF8_CLEAR_SCREEN,
        (ULONG)(wcslen( VTUTF8_CLEAR_SCREEN ) * sizeof(WCHAR))
        );
    m_RedrawHandler->Flush(); 

    //
    // Put up the login banner.
    //
    if (! WriteResourceMessage(LOGIN_BANNER) ) {
        return FALSE;
    }

    //
    // Prompt for user name.
    //
    if (! WriteResourceMessage(USERNAME_PROMPT) ) {
        return FALSE;
    }
    
    if ( UserName[0] != UNICODE_NULL ) {

        //
        // We were supplied a UserName.  Put that up and proceed.
        //
        m_RedrawHandler->Write( 
            (PUCHAR)UserName,
            (ULONG)(wcslen( UserName ) * sizeof(WCHAR))
            );
        m_RedrawHandler->Flush(); 
    
        //
        // If we were given the username, we conclude that
        // they gave us the domain name as well.  We need
        // to do this since the domain name may be empty
        // and we automatlically conclude that because the
        // domain name is empty we need to retrieve it.
        // 
        HaveDomainName = TRUE;

    } else {

        //
        // Retrieve the UserName.
        //
        bSuccess = RetrieveCredential(
            UserName,
            UserNameLength,
            TRUE
            );

        if (!bSuccess) {
            return FALSE;
        }

        //
        // We need to retrieve the domain name too.
        //
        HaveDomainName = FALSE;
    
    }

    //
    //
    //
    m_RedrawHandler->Write( 
        (PUCHAR)L"\r\n",
        (ULONG)(wcslen(L"\r\n") * sizeof(WCHAR))
        );
    m_RedrawHandler->Flush(); 
    
    //
    // Prompt for domain name
    //
    if (! WriteResourceMessage(DOMAINNAME_PROMPT) ) {
        return FALSE;
    }
    
    //
    // Prompt for domain name.
    //
    if ( HaveDomainName ) {

        //
        // We were supplied a username.  Put that up and proceed.
        //
        m_RedrawHandler->Write( 
            (PUCHAR)DomainName,
            (ULONG)(wcslen( DomainName ) * sizeof(WCHAR))
            );
        m_RedrawHandler->Flush(); 
    
    } else {

        //
        // Retrieve the DomainName.
        //
        bSuccess = RetrieveCredential(
            DomainName,
            DomainNameLength,
            TRUE
            );

        if (!bSuccess) {
            return FALSE;
        }

        //
        // If user entered a blank domain, force it to '.'
        // which implies local machine domain
        //
        if (wcslen(DomainName) == 0) {
            wsprintf(
                DomainName,
                L"."
                );
        }

    }

    //
    //
    //
    m_RedrawHandler->Write( 
        (PUCHAR)L"\r\n",
        (ULONG)(wcslen(L"\r\n") * sizeof(WCHAR))
        );
    
    //
    // Prompt for password.
    //
    if (! WriteResourceMessage(PASSWORD_PROMPT) ) {
        return FALSE;
    }

    //
    // Retrieve the Password.
    //
    bSuccess = RetrieveCredential(
        Password,
        PasswordLength,
        FALSE
        );

    if (!bSuccess) {
        return FALSE;
    }

    //
    //
    //
    m_RedrawHandler->Write( 
        (PUCHAR)L"\r\n",
        (ULONG)(wcslen(L"\r\n") * sizeof(WCHAR))
        );
    m_RedrawHandler->Flush(); 

    return TRUE;

}

VOID
CSecurityIoHandler::ResetTimeOut(
    VOID
    )
/*++

Routine Description:

    This routine resets the StartTickCount to 0      
          
Arguments:

    None                                                 
          
Return Value:

    None    

--*/
{
    ULONG   TimerTick;

    //
    // Get the current timer tick
    //
    TimerTick = GetTickCount();

    //
    // Reset the timeout counter by making the current timer tick 
    // the starting tick count
    //
    InterlockedExchange(&m_StartTickCount, TimerTick);

#if ENABLE_EVENT_DEBUG
    {                                                                           
        WCHAR   blob[256];                                                      
        wsprintf(blob,L"ResetTimeOut\n");
        OutputDebugString(blob);                                                
    }
#endif

}

BOOL
CSecurityIoHandler::TimeOutOccured(
    VOID
    )
/*++

Routine Description:

    This routine determines if the specified timeout interval
    has been reached.  It takes the specified TickCount and
    compares it to the m_StartTickCount.  If the interval equals
    or exceeds the timeout interval, then a timeout has occured. 

Arguments:

    None
          
Return Value:

    TRUE    - The timeout interval has been reached
    FALSE   - otherwise

--*/
{
    BOOL    bTimedOut;
    DWORD   DeltaT;

    //
    // default: we did not time out
    //
    bTimedOut = FALSE;

    //
    // See if we timed out
    //
    DeltaT = GetAndComputeTickCountDeltaT(m_StartTickCount);
    
    if (DeltaT >= m_TimeOutInterval) {

        //
        // Reset the timeout counter 
        //
        ResetTimeOut();

        //
        // We timed out
        //
        bTimedOut = TRUE;
        
#if ENABLE_EVENT_DEBUG
        {                                                                           
            WCHAR   blob[256];                                                      
            wsprintf(blob,L"TimeOutOccured\n");
            OutputDebugString(blob);                                                
        }
#endif
    
    }

    return bTimedOut;

}

BOOL
CSecurityIoHandler::InitializeTimeOutThread(
    VOID
    )
/*++

Routine Description:

    This routine initializes the timeout thread if timeout
    behavior is enabled.

Arguments:

    None
          
Return Value:

    TRUE    Success
    FALSE   Otherwise

--*/
{
    BOOL    bSuccess;

    //
    // default: failed to init
    //
    bSuccess = FALSE;

    //
    // default: we do not have a timeout thread
    //
    m_TimeOutThreadHandle = INVALID_HANDLE_VALUE;

    //
    // determine if we need a timeout thread
    // if we do, then set one up
    //
    do {

        //
        // If the timeout behavior is disabled,
        // then we are done.
        //
        if (IsTimeOutEnabled() == FALSE) {

            //
            // No Initialization required
            //
            bSuccess = TRUE;

            break;

        }
    
        //
        // determine the time out interval
        //
        if (GetTimeOutInterval(&m_TimeOutInterval) == TRUE) {

            //
            // Reset the timeout counter before we start the thread
            //
            ResetTimeOut();

            //
            // Create thread to handle Input
            //
            m_TimeOutThreadHandle = (HANDLE)_beginthreadex(
                NULL,
                0,
                CSecurityIoHandler::TimeOutThread,
                this,
                0,
                (unsigned int*)&m_TimeOutThreadTID
                );

            if (m_TimeOutThreadHandle == INVALID_HANDLE_VALUE) {
                break;
            }

            //
            // we successfully started the thread
            //
            bSuccess = TRUE;
        
        }
    
    } while ( FALSE );

    return bSuccess;
}

BOOL
CSecurityIoHandler::GetTimeOutInterval(
    OUT PULONG  TimeOutDuration
    )

/*++

Routine Description:

    This routine determines the timeout interval.
    
    It attempts to read the registry and use a specified
    value from there, or defaults.

Arguments:

    TimeOutDuration - the determined timeout interval

Return Value:

    TRUE    - TimeOutDuration is valid
    FALSE   - otherwise              

Security:

    interface: registry

--*/

{
    DWORD       rc;
    HKEY        hKey;
    DWORD       DWord;
    DWORD       dwsize;
    DWORD       DataType;

    //
    // See if the user gave us a registry key to define the timeout duration
    //
    rc = RegOpenKeyEx( HKEY_LOCAL_MACHINE,
                       SACSVR_PARAMETERS_KEY,
                       0,
                       KEY_READ,
                       &hKey );
    
    if( rc == NO_ERROR ) {
        
        dwsize = sizeof(DWORD);
        
        rc = RegQueryValueEx(
                        hKey,
                        SACSVR_TIMEOUT_INTERVAL_VALUE,
                        NULL,
                        &DataType,
                        (LPBYTE)&DWord,
                        &dwsize );

        RegCloseKey( hKey );

        if ((rc == NO_ERROR) && 
            (DataType == REG_DWORD) && 
            (dwsize == sizeof(DWORD))
            ) {

            //
            // Convert the specified timeout from minutes --> ms
            //
            *TimeOutDuration = DWord * (60 * 1000);
        
            //
            // A timeout interval of 0 is not allowed, default.
            //
            if (*TimeOutDuration == 0) {

                *TimeOutDuration = DEFAULT_TIME_OUT_INTERVAL;

            } 

            //
            // clamp the timeout interval to a reasonable value
            //
            if (*TimeOutDuration > MAX_TIME_OUT_INTERVAL) {

                *TimeOutDuration = MAX_TIME_OUT_INTERVAL;

            }

            return TRUE;

        }

    }

    //
    // Default: timeout duration 
    //
    *TimeOutDuration = DEFAULT_TIME_OUT_INTERVAL;

    return TRUE;

}

BOOL
CSecurityIoHandler::IsTimeOutEnabled(
    VOID
    )

/*++

Routine Description:

    This routine determines if the timeout behavior is enabled
    by the system.

Arguments:

    None.

Return Value:

    TRUE    - timeout behavior is enabled
    FALSE   - otherwise              

Security:

    interface: registry

--*/

{
    DWORD       rc;
    HKEY        hKey;
    DWORD       DWord;
    DWORD       dwsize;
    DWORD       DataType;

    //
    // See if the user gave us a registry key to disable the timeout behavior
    //
    rc = RegOpenKeyEx( HKEY_LOCAL_MACHINE,
                       SACSVR_PARAMETERS_KEY,
                       0,
                       KEY_READ,
                       &hKey );
    
    if( rc == NO_ERROR ) {
        
        dwsize = sizeof(DWORD);

        rc = RegQueryValueEx(
                        hKey,
                        SACSVR_TIMEOUT_DISABLED_VALUE,
                        NULL,
                        &DataType,
                        (LPBYTE)&DWord,
                        &dwsize );

        RegCloseKey( hKey );

        if ((rc == NO_ERROR) && 
            (DataType == REG_DWORD) && 
            (dwsize == sizeof(DWORD))
            ) {
            
            return DWord == 1 ? FALSE : TRUE;
        
        }
    
    }

    //
    // default: timeout is enabled
    //
    return TRUE;

}

unsigned int
CSecurityIoHandler::TimeOutThread(
    PVOID   pParam
    )
/*++

Routine Description:

    This routine is a the timeout management thread.
    
    When the Timeout interval is reached, this routine
    fires the lock event and causes the session to perform
    its locking behavior.
    
Arguments:

    pParam  - thread context
          
Return Value:

    thread return value                            

--*/
{
    CSecurityIoHandler  *IoHandler;
    BOOL                bContinueSession;
    DWORD               dwRetVal;
    DWORD               dwPollInterval;
    HANDLE              handles[2];
    ULONG               HandleCount;
    BOOL                bRedrawEventSignaled;

    enum { 
        CHANNEL_THREAD_EXIT_EVENT = WAIT_OBJECT_0, 
        CHANNEL_REDRAW_EVENT
        };

    //
    // Get the session object
    // 
    IoHandler = (CSecurityIoHandler*)pParam;

    //
    // Assign the events to listen for
    //
    handles[0] = IoHandler->m_ThreadExitEvent;
    handles[1] = IoHandler->m_RedrawEvent;
    
    //
    // default: listen
    //
    bContinueSession = TRUE;

    //
    // wait on the redraw event
    //
    bRedrawEventSignaled = FALSE;

    //
    // Poll Interval = 1 second
    //
    dwPollInterval = 1000;

    //
    // While we should listen...
    //
    while ( bContinueSession ) {

        HandleCount = bRedrawEventSignaled ? 1 : 2;

        //
        // Wait for our exit event
        //
        dwRetVal = WaitForMultipleObjects(
            HandleCount,
            handles,
            FALSE,
            dwPollInterval
            );

        switch ( dwRetVal ) {
        
        case CHANNEL_REDRAW_EVENT: 

            //
            // reset the timeout if someone switches back to a channel
            //
            IoHandler->ResetTimeOut();

            //
            // We don't need to waint on this event again until it clears
            //
            bRedrawEventSignaled = TRUE;

            break;

        case WAIT_TIMEOUT: {
        
            //
            // Check for timeout 
            //
            if (IoHandler->TimeOutOccured()) {
            
                //
                // set the lock event causing
                // the command console session to lock.
                //
                SetEvent(IoHandler->m_LockEvent);
            
                //
                // Set the internal lock event
                //
                SetEvent(IoHandler->m_InternalLockEvent);
            
            }

            //
            // Wait until the event clears by looking
            // for a WAIT_TIMEOUT
            //
            dwRetVal = WaitForSingleObject(
                IoHandler->m_RedrawEvent,
                0
                );

            //
            // Check the wait result
            //
            switch (dwRetVal) {
            case WAIT_TIMEOUT:

                //
                // It's ok to wait for this event again
                //
                bRedrawEventSignaled = FALSE;

                break;

            default:

                ASSERT (dwRetVal != WAIT_FAILED);
                if (dwRetVal == WAIT_FAILED) {
                    bContinueSession = false;
                }

                break;

            }
            
            break;
        
        }

        case CHANNEL_THREAD_EXIT_EVENT: 
        default:
            
            //
            // incase WAIT_FAILED, call GetLastError()
            //
            ASSERT(dwRetVal != WAIT_FAILED);

            //
            // An error has occured, stop listening
            // 
            bContinueSession = FALSE;
            
            break;
        
        }
    
    }
    
    return 0;

}

BOOL
CSecurityIoHandler::WaitForUserInput(
    IN BOOL Consume
    )
/*++

Routine Description:

    This routine blocks waiting for user input.
    
Arguments:

    Consume - if TRUE, this routine eats the character that caused
              the the channel to have new data. 

Return Value:

    TRUE    - no errors
    FALSE   - otherwise

--*/
{
    BOOL    bSuccess;
    DWORD   dwRetVal;
    BOOL    bHasNewData;
    BOOL    done;
    HANDLE  handles[2];

    enum { 
        CHANNEL_CLOSE_EVENT = WAIT_OBJECT_0, 
        CHANNEL_LOCK_EVENT
        };

    //
    // Assign the events to listen for
    //
    handles[0] = m_CloseEvent;
    handles[1] = m_InternalLockEvent;

    //
    // Default: we succeeded
    //
    bSuccess = TRUE;

    //
    // Default: we loop
    //
    done = FALSE;

    //
    // Wait for a key press
    //
    while (!done) {

        dwRetVal = WaitForMultipleObjects(
            sizeof(handles) / sizeof(handles[0]),
            handles,
            FALSE,
            20 // 20ms
            );

        switch(dwRetVal) {
        case CHANNEL_CLOSE_EVENT:
            
            //
            // The channel closed, we need to exit
            //
            //
            // The channel has locked, 
            // or the timeout has gone fired and we need to 
            //      clear the current logon attempt
            // in either case, we need to exit
            //
            done = TRUE;

            //
            // Our attempt to get new data failed
            //
            bSuccess = FALSE;
            
            break;

        case CHANNEL_LOCK_EVENT:
            
            //
            // clear the internal lock event
            //
            ResetEvent(m_InternalLockEvent);

            if (m_StartedAuthentication) {
                
#if ENABLE_EVENT_DEBUG
                {                                                                           
                    WCHAR   blob[256];                                                      
                    wsprintf(blob,L"ResettingAuthentication\n");
                    OutputDebugString(blob);                                                
                }
#endif
                
                //
                // the timeout has gone fired and we need to 
                //      clear the current logon attempt
                //
                done = TRUE;

                //
                // Our attempt to get new data failed
                //
                bSuccess = FALSE;
            
            }
            
            break;
                
        case WAIT_TIMEOUT:
            
            //
            // we should be in a locked state now
            // which implies we are using the unlocked 
            // io handler - the scraper is using the locked one
            //
            ASSERT(myLockedIoHandler == myIoHandler);
            
            //
            // determine the input buffer status
            //
            bSuccess = myUnlockedIoHandler->HasNewData(&bHasNewData);

            if (! bSuccess) {
                done = TRUE;
                break;
            }

            if (bHasNewData) {
                
                //
                // We have new data, so we need to exit
                //
                done = TRUE;

                //
                // Consume character the character which caused
                // the waitforuserinput to return
                //
                if (Consume) {

                    WCHAR   buffer;
                    ULONG   bufferSize;

                    bSuccess = ReadUnlockedIoHandler( 
                        (PUCHAR)&buffer,
                        sizeof(WCHAR),
                        &bufferSize
                        );

                }

            }
            
            break;
        
        default:
            
            //
            // We should not get here unless something broke
            //
            ASSERT(0);

            bSuccess = FALSE;
            done = TRUE;
            
            break;
        }
    }

    return bSuccess;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\headless\cmd\sacsess\scraper.h ===
/*++

Copyright (c) 1999-2001  Microsoft Corporation

Module Name:

    scraper.h

Abstract:

    Class for defining base scraper behavior.

Author:

    Brian Guarraci (briangu) 2001.

Revision History:

--*/

#ifndef __SCRAPER__H__
#define __SCRAPER__H__

#include <iohandler.h>

class CScraper {

protected:

    CScraper();
    
    CIoHandler  *m_IoHandler;
    
    //
    // max dimensions of the scraping window
    //
    WORD        m_wMaxCols;
    WORD        m_wMaxRows;

    //
    // current dimensions of the scraping window
    // 
    // NOTE: may be less than max if the scraping
    //       window has a max size < ours
    //
    WORD        m_wCols;
    WORD        m_wRows;
    
    //
    //
    //
    HANDLE      m_hConBufIn;
    HANDLE      m_hConBufOut;
    
    VOID
    SetConOut(
        HANDLE
        );

    VOID
    SetConIn(
        HANDLE
        );

public:
    
    virtual BOOL

    Start( 
        VOID
        ) = 0;
    
    virtual BOOL
    Write(
        VOID
        ) = 0;
    
    virtual BOOL 
    Read(
        VOID
        ) = 0;

    virtual BOOL
    DisplayFullScreen(
        VOID
        ) = 0;
    
    CScraper(
        CIoHandler  *IoHandler,
        WORD        wCols,
        WORD        wRows
        );
    
    virtual ~CScraper();

};

#endif __SCRAPER__H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\headless\cmd\sacsess\redraw.h ===
/*++

Copyright (c) 2001 Microsoft Corporation

Module Name:

    redraw.h

Abstract:

    Define the base lockable IoHandler redraw handler class.  
    
    The main purpose of this class is to provide a means for a
    lockable IoHandler to refresh it screen when the IoHandler
    is locked.  For instance, the security IoHandler does authentication
    when it is locked, and this class provides the mechanism for
    the authentication screen to be refreshed when appropriate.

Author:

    Brian Guarraci (briangu), 2001        
            
Revision History:

--*/
#if !defined( _REDRAW_H_ )
#define _REDRAW_H_

#include "lockio.h"
#include <emsapi.h>

//
// Define the max string length we allow for mirroring the 
// authentication dialog
//
#define MAX_MIRROR_STRING_LENGTH 1024

class CRedrawHandler {
    
protected:

    //
    // Prevent this class from being instantiated directly
    //
    CRedrawHandler(
        IN CLockableIoHandler   *IoHandler
        );

    //
    // The iohandler that the redraw handler
    // is handling redraw events for
    //
    CLockableIoHandler  *m_IoHandler;

    //
    // Redraw event and thread attributes
    //
    HANDLE  m_ThreadExitEvent;
    HANDLE  m_RedrawEvent;
    HANDLE  m_RedrawEventThreadHandle;
    DWORD   m_RedrawEventThreadTID;
    
    //
    // Mirror string attributes
    //
    LONG                m_WriteEnabled;
    ULONG               m_MirrorStringIndex;
    PWCHAR              m_MirrorString;
    CRITICAL_SECTION    m_CriticalSection;
    
    //
    // Prototypes
    //
    static unsigned int
    RedrawEventThread(
        PVOID
        );
    
    BOOL
    WriteMirrorString(
        VOID
        );

public:
    
    virtual ~CRedrawHandler();
    
    static CRedrawHandler*
    CRedrawHandler::Construct(
        IN CLockableIoHandler   *IoHandler,
        IN HANDLE               RedrawEvent
        );

    //
    // Write BufferSize bytes
    //
    virtual BOOL
    Write(
        PBYTE   Buffer,
        ULONG   BufferSize
        );

    //
    // Flush any unsent data
    //
    virtual BOOL
    Flush(
        VOID
        );
    
    //
    // Reset the mirror string
    //
    VOID
    Reset(
        VOID
        );

};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\headless\cmd\sacsess\session.h ===
/*++

Copyright (c) 2001 Microsoft Corporation

Module Name:

    session.h

Abstract:

    Base class for screen scraped sessions.
            
Author:

    Brian Guarraci (briangu), 2001
    
Revision History:

--*/

#if !defined( _SESSION_H_ )
#define _SESSION_H_

#include <cmnhdr.h>
#include <TChar.h>
#include <Shell.h>
#include <Scraper.h>
#include "iohandler.h"
#include "secio.h"
#include "scraper.h"

extern "C" {
#include <ntddsac.h>
#include <sacapi.h>
}

#define MAX_HANDLES 4

#define DEFAULT_COLS    80
#define DEFAULT_ROWS    24

#define MAX_USERNAME_LENGTH     256
#define MAX_DOMAINNAME_LENGTH   255
#define MAX_PASSWORD_LENGTH     256

// milliseconds
#define MIN_POLL_INTERVAL   100 

class CSession {

    //
    // Primary classes used by the session
    //
    CShell              *m_Shell;
    CScraper            *m_Scraper;
    CSecurityIoHandler  *m_ioHandler;

    //
    // The COL/ROW dimesions of the session
    //
    WORD        m_wCols; 
    WORD        m_wRows;

    //
    // WaitForIo Attributes
    //
    BOOL        m_bContinueSession;
    DWORD       m_dwHandleCount;
    HANDLE      m_rghHandlestoWaitOn[ MAX_HANDLES ]; 

    //
    // Events used by the session
    //
    HANDLE      m_ThreadExitEvent;
    HANDLE      m_SacChannelCloseEvent;
    HANDLE      m_SacChannelHasNewDataEvent;
    HANDLE      m_SacChannelLockEvent;
    HANDLE      m_SacChannelRedrawEvent;

    //
    // Username and Password of authenticated user
    //
    WCHAR       m_UserName[MAX_USERNAME_LENGTH+1];
    WCHAR       m_DomainName[MAX_DOMAINNAME_LENGTH+1];

    //
    // Scrape interval counter
    //
    DWORD       m_dwPollInterval;

    //
    // User input handler thread attributes
    //
    HANDLE      m_InputThreadHandle;
    DWORD       m_InputThreadTID;
    
    //
    // Worker thread to process user input
    //
    static unsigned int 
    InputThread(
        PVOID pParam
        );

    //
    // User authentication method
    //
    BOOL
    Authenticate(
        OUT PHANDLE phToken
        );

    //
    // Unlock the session 
    //
    BOOL
    Unlock(
        VOID
        );

    //
    // Lock the session 
    //
    BOOL
    Lock(
        VOID
        );

public:

    CSession();
    virtual ~CSession();
    
    BOOL    Init();
    void    WaitForIo();
    void    Shutdown();
    void    AddHandleToWaitOn( HANDLE );
    
};

#endif // _SESSION_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\headless\cmd\sacsess\session.cpp ===
/*++

Copyright (c) 1999-2001  Microsoft Corporation

Module Name:

    session.cpp

Abstract:

    Class for creating a command console shell

Author:

    Brian Guarraci (briangu) 2001.

Revision History:

--*/

#include <Session.h>
#include <assert.h>
#include <process.h>

#include "secio.h"
#include "utils.h"
#include "scraper.h"
#include "vtutf8scraper.h"

extern "C" {
#include <ntddsac.h>
#include <sacapi.h>
}

CSession::CSession() 
/*++

Routine Description:

    Constructor              
                  
Arguments:

    None           
          
Return Value:

    N/A    

--*/
{
    
    //
    //
    //
    m_dwPollInterval = MIN_POLL_INTERVAL;
    
    //
    // Initialize the # of rows and cols the session
    // screen will have
    //
    m_wCols = DEFAULT_COLS;
    m_wRows = DEFAULT_ROWS;

    //
    // Initialize the username and password for
    // the authentication of a user
    //
    RtlZeroMemory(m_UserName, sizeof(m_UserName));
    RtlZeroMemory(m_DomainName, sizeof(m_DomainName));
            
    //
    // Initialize the WaitForIo attributes
    //
    m_bContinueSession = true;
    m_dwHandleCount = 0;
    
    //
    // NULL all event the handles we use
    //
    m_ThreadExitEvent = NULL;
    m_SacChannelCloseEvent = NULL;
    m_SacChannelHasNewDataEvent = NULL;
    m_SacChannelLockEvent = NULL;
    m_SacChannelRedrawEvent = NULL;
    
    //
    // thread handle is invalid
    //
    m_InputThreadHandle = INVALID_HANDLE_VALUE;

    //
    //
    //
    m_ioHandler = NULL;
    m_Scraper = NULL;
    m_Shell = NULL;

}

CSession::~CSession()
/*++

Routine Description:

    Destructor              
                  
Arguments:

    N/A    
          
Return Value:

    N/A    

--*/
{
    
    if (m_Shell) {
        delete m_Shell;
    }
    if (m_Scraper) {
        delete m_Scraper;
    }
    if (m_ioHandler) {
        delete m_ioHandler;
    }
    
    if (m_ThreadExitEvent) {
        CloseHandle( m_ThreadExitEvent );
    }
    if (m_SacChannelCloseEvent) {
        CloseHandle( m_SacChannelCloseEvent );
    }
    if (m_SacChannelHasNewDataEvent) {
        CloseHandle( m_SacChannelHasNewDataEvent );
    }
    if (m_SacChannelLockEvent) {
        CloseHandle( m_SacChannelLockEvent );
    }
    if (m_SacChannelRedrawEvent) {
        CloseHandle( m_SacChannelRedrawEvent );
    }

}

BOOL
CSession::Authenticate(
    OUT PHANDLE phToken
    )
/*++

Routine Description:

    This routine attempts to authenticate a user (if necessary) and
    acquire credentials.

Arguments:

    hToken  - on success, contains the authenticated credentials
          
Return Value:

    TRUE    - success
    FALSE   - otherwise

Security:

    interface: 
    
        registry 
        external input
        LogonUser()
        

--*/
{
    BOOL    bSuccess;
    PWCHAR  Password;
    
    //
    // Allocate the password on the heap
    //
    Password = new WCHAR[MAX_PASSWORD_LENGTH+1];
    
    //
    // Purge the password buffer
    //
    RtlZeroMemory(Password, (MAX_PASSWORD_LENGTH+1) * sizeof(Password[0]));
    
    //
    // Default: the credentials are invalid
    //
    *phToken = INVALID_HANDLE_VALUE;

    //
    // Default: we were successful
    //
    bSuccess = TRUE;

    //
    // Attempt to authenticate a user if authentication
    // as actually needed.
    //
    do {

        if( NeedCredentials() ) {

            //
            // Get the credentials to authenticate
            //
            bSuccess = m_ioHandler->RetrieveCredentials(
                m_UserName,
                sizeof(m_UserName) / sizeof(m_UserName[0]),
                m_DomainName,
                sizeof(m_DomainName) / sizeof(m_DomainName[0]),
                Password,
                MAX_PASSWORD_LENGTH+1
                );

            if (!bSuccess) {
                break;
            }

            //
            // Attempt the actual authentication
            //
            bSuccess = m_ioHandler->AuthenticateCredentials(
                m_UserName,
                m_DomainName,
                Password,
                phToken
                );

            if (!bSuccess) {
                break;
            }

        }
    
    } while ( FALSE );

    //
    // Purge and release the password buffer
    //
    RtlSecureZeroMemory(Password, (MAX_PASSWORD_LENGTH+1) * sizeof(Password[0]));
    delete [] Password;

    return bSuccess;
}

BOOL
CSession::Lock(
    VOID
    )
/*++

Routine Description:

    This routine manages the locking of the session.
        
Arguments:

    None
          
Return Value:

    status

--*/
{
    
    //
    // Lock the IOHandler
    //
    // this causes the Security Iohandler to switch from using
    // the SAC IOHandler to using the NULLIO handler.
    //
    m_ioHandler->Lock();

    return TRUE;
}

BOOL
CSession::Unlock(
    VOID
    )
/*++

Routine Description:

    This routine manages the unlocking of the session after a user
    has authenticated.
        
Arguments:

    None
          
Return Value:

    status

--*/
{
    BOOL    bStatus;

    //
    // Unlock the IOHandler
    //
    // this causes the Security Iohandler to switch from using
    // the NULLIO handler to using the SAC IOhandler
    //
    m_ioHandler->Unlock();
    
    //
    // It is possible that the Lock Event was signalled while we were
    // waiting for authentication
    //
    // e.g. Imagine a user starting a cmd session,
    //      not logging in, and walking away for longer than the timeout
    //      period
    //
    //      -or-
    //
    //      a SAC "lock" command was issued while the session was already
    //      locked.
    //
    // After the user logs on successfully, we should not lock again.
    // Hence, we need to reset the lock event.
    //
    // Note: It is not correct to do this in the security IO handler, as it
    // should not have global knowledge of all the circumstances that
    // can signal the lock event.
    //
    bStatus = ResetEvent(m_SacChannelLockEvent);

    return bStatus;
}

BOOL
CSession::Init(
    VOID
    )
/*++

Routine Description:

    This routine does the core initialization for the session.
    
    If this routine is successful, the WaitForIo routine may be called.
        
Arguments:

    None
          
Return Value:

    TRUE    - the session was successfully initialized
    FALSE   - otherwise

--*/
{
    SAC_CHANNEL_OPEN_ATTRIBUTES Attributes;
    HANDLE                      hToken;
    BOOL                        bSuccess;

    //
    // Initialize the last error status
    //
    SetLastError( 0 );

    //
    // Construct the manually resetting events that we'll use
    //
    // Note: we do not need to CloseHandle() on the events if
    //       fail because they are cleaned up in the destructor
    //
    m_SacChannelLockEvent = CreateEvent( NULL, TRUE, FALSE, NULL );
    ASSERT_STATUS(m_SacChannelLockEvent, FALSE);
    
    m_SacChannelCloseEvent = CreateEvent( NULL, TRUE, FALSE, NULL );
    ASSERT_STATUS(m_SacChannelCloseEvent, FALSE);
    
    m_ThreadExitEvent = CreateEvent( NULL, TRUE, FALSE, NULL );
    ASSERT_STATUS(m_ThreadExitEvent, FALSE);
    
    m_SacChannelHasNewDataEvent = CreateEvent( NULL, TRUE, FALSE, NULL );
    ASSERT_STATUS(m_SacChannelHasNewDataEvent, FALSE);
    
    m_SacChannelRedrawEvent = CreateEvent( NULL, TRUE, FALSE, NULL );
    ASSERT_STATUS(m_SacChannelRedrawEvent, FALSE);
    
    //
    // Configure the attributes of the command console channel
    //
    // Note: we don't use all of the attributes since most are defaulted
    //       in the SAC driver
    // 
    RtlZeroMemory(&Attributes, sizeof(SAC_CHANNEL_OPEN_ATTRIBUTES));

    Attributes.Flags            = SAC_CHANNEL_FLAG_CLOSE_EVENT | 
                                  SAC_CHANNEL_FLAG_HAS_NEW_DATA_EVENT |
                                  SAC_CHANNEL_FLAG_LOCK_EVENT | 
                                  SAC_CHANNEL_FLAG_REDRAW_EVENT;
    Attributes.CloseEvent       = m_SacChannelCloseEvent;
    Attributes.HasNewDataEvent  = m_SacChannelHasNewDataEvent;
    Attributes.LockEvent        = m_SacChannelLockEvent;
    Attributes.RedrawEvent      = m_SacChannelRedrawEvent;

    //
    // Attempt to open the Secure Io Handler to the SAC command console channel
    //
    m_ioHandler = CSecurityIoHandler::Construct(Attributes);
    
    if (! m_ioHandler) {
        return FALSE;
    }

    //
    // Attempt to authenticate the session user
    //
    bSuccess = Authenticate(&hToken);
    
    if (!bSuccess) {
        return (FALSE);
    }

    //
    // The user successfully authenticated, so unlock the session
    //
    Unlock();

    //
    // Create the scraper we'll use for this session
    //
    m_Scraper = new CVTUTF8Scraper(
        m_ioHandler,
        m_wCols,
        m_wRows
        );
    
    //
    // Create the shell we'll use for this session
    //
    m_Shell = new CShell();

    //
    // Attempt to launch the command console session
    //
    bSuccess = m_Shell->StartUserSession (
        this,
        hToken 
        );
    ASSERT_STATUS(bSuccess, FALSE);

    //
    // We are done with the token
    //
    CloseHandle(hToken);

    //
    // Start the scraper
    //
    bSuccess = m_Scraper->Start();
    ASSERT_STATUS(bSuccess, FALSE);
    
    //
    // The scraping thread needs to also listen if the SAC channel closes
    //
    AddHandleToWaitOn(m_SacChannelCloseEvent);
    AddHandleToWaitOn(m_SacChannelLockEvent);
    AddHandleToWaitOn(m_SacChannelRedrawEvent);

    //
    // Create threads to handle Input
    //
    m_InputThreadHandle = (HANDLE)_beginthreadex(
        NULL,
        0,
        CSession::InputThread,
        this,
        0,
        (unsigned int*)&m_InputThreadTID
        );

    ASSERT_STATUS(m_InputThreadHandle != INVALID_HANDLE_VALUE, FALSE);
    
    //
    // We successfully initialized the session
    //
    return( TRUE );
}

void
CSession::AddHandleToWaitOn( HANDLE hNew )
/*++

Routine Description:

    This routine adds a handle to an array of handles
    that will be waiting on in "WaitForIo"    

    Note: the handle array is fixed length, so if there
          are additional handles which need to be waited
          on, MAX_HANDLES must be modified 
        
Arguments:

    hNew    - the new handle to wait on                                          
          
Return Value:

    None

--*/
{
    ASSERT( m_dwHandleCount < MAX_HANDLES );
    ASSERT( hNew );

    //
    // Add the new handle to our array of multiple handles
    //
    m_rghHandlestoWaitOn[ m_dwHandleCount ] = hNew;
    
    //
    // Account for the new handle
    //
    m_dwHandleCount++;

}

void
CSession::WaitForIo(
    VOID
    )
/*++

Routine Description:

    This routine is the main work loop for the session and
    is responsible for:
    
        running the scraper
        handling the session close event
        handling the session redraw event
        handling the session lock event
          
Arguments:

    None
          
Return Value:

    None    

--*/
{
    DWORD   dwRetVal = WAIT_FAILED;
    BOOL    ScrapeEnabled;
     
    enum { 
        CMD_KILLED = WAIT_OBJECT_0, 
        CHANNEL_CLOSE_EVENT,
        CHANNEL_LOCK_EVENT,
        CHANNEL_REDRAW_EVENT
        };

    //
    // Default: it is not an appropriate time to scrape
    //
    ScrapeEnabled = FALSE;

    //
    // Service the session's events 
    //
    while ( m_bContinueSession ) {
        
        ULONG   HandleCount;
        
        //
        // If scraping is enabled, 
        // then don't wait on the scrape event.
        //
        // Note: the redraw event must be the last event
        //       in the m_rghHandlestoWaitOn array
        //
        HandleCount = ScrapeEnabled ? m_dwHandleCount - 1 : m_dwHandleCount;

        dwRetVal = WaitForMultipleObjects(
            HandleCount, 
            m_rghHandlestoWaitOn, 
            FALSE, 
            m_dwPollInterval 
            );
        
        switch ( dwRetVal ) {
        
        case CHANNEL_REDRAW_EVENT:

            ASSERT(!ScrapeEnabled);    

            //
            // Tell the screen scraper we need a full dump of it's screen
            //
            m_Scraper->DisplayFullScreen();

            //
            // We are now an appropriate time to scrape
            //
            ScrapeEnabled = TRUE;

            break;

        case WAIT_TIMEOUT:
            
            if (ScrapeEnabled) {
                
                //
                // Scrape
                //
                m_bContinueSession = m_Scraper->Write();
            
                //
                // Wait until the event clears by looking
                // for a WAIT_TIMEOUT
                //
                dwRetVal = WaitForSingleObject(
                    m_SacChannelRedrawEvent,
                    0
                    );

                //
                // Check the wait result
                //
                switch (dwRetVal) {
                case WAIT_TIMEOUT:

                    //
                    // We need to stop scraping now
                    //
                    ScrapeEnabled = FALSE;

                    break;

                default:
                    
                    ASSERT (dwRetVal != WAIT_FAILED);
                    if (dwRetVal == WAIT_FAILED) {
                        m_bContinueSession = false;
                    }
                    
                    break;

                }

            }
            
            break;

        case CHANNEL_LOCK_EVENT:
            
            BOOL    bSuccess;
            HANDLE  hToken;
            
            //
            // Lock the session
            //
            Lock();

            //
            // Attempt to authenticate the session user
            //
            bSuccess = Authenticate(&hToken);

            if (bSuccess) {
                
                //
                // The user successfully authenticated, so unlock the session
                //
                Unlock();

                //
                // Tell the screen scraper we need a full dump of it's screen
                //
                m_Scraper->DisplayFullScreen();

            } else {
                
                //
                // Loop back around to the WaitForMultipleObjects so that
                // we can catch the close event if it occurred
                //
                NOTHING;

            }
            
            break;

        case CMD_KILLED:
        case CHANNEL_CLOSE_EVENT:
            //
            // Tell the Input Thread to exit
            //
            SetEvent(m_ThreadExitEvent);
        
        default:
            //
            // incase WAIT_FAILED, call GetLastError()
            //
            ASSERT( dwRetVal != WAIT_FAILED);
            
            m_bContinueSession = false;
            
            break;
        }
    }
    return;
}

void
CSession::Shutdown(
    VOID
    )
/*++

Routine Description:

    This routine does the cleanup work for shutting down the session.    
        
    Note: this routine does not free memory    
        
Arguments:

    None                                                                     
          
Return Value:

    None
        
--*/
{
    //
    // Shutdown the shell
    //
    if (m_Shell) {
        m_Shell->Shutdown();
    }

    //
    // If we started the input thread,
    // then shut it down
    //
    if (m_InputThreadHandle != INVALID_HANDLE_VALUE) {
        
        //
        // Wait for the thread to exit
        //
        WaitForSingleObject(
            m_InputThreadHandle,
            INFINITE
            );

        CloseHandle(m_InputThreadHandle);
    
    }

}

unsigned int
CSession::InputThread(
    PVOID   pParam
    )
/*++

Routine Description:

    This routine provides asynchronous support for handling
    user-input from the IoHandler to the session.  
                                           
Arguments:

    pParam - thread context                                  
          
Return Value:

    status                           

--*/
{
    BOOL        bContinueSession;
    DWORD       dwRetVal;
    CSession    *session;
    HANDLE      handles[2];

    //
    // default: listen
    //
    bContinueSession = TRUE;

    //
    // Get the session object
    // 
    session = (CSession*)pParam;

    //
    // Assign the events to listen for
    //
    handles[0] = session->m_SacChannelHasNewDataEvent;
    handles[1] = session->m_ThreadExitEvent;

    //
    // While we should listen:
    //
    //  1. wait for a HasNewDataEvent from the SAC driver
    //  2. wait for a CloseEvent from the SAC driver
    // 
    while ( bContinueSession ) {
        
        //
        // Wait for our events
        //
        dwRetVal = WaitForMultipleObjects(
            sizeof(handles)/sizeof(HANDLE), 
            handles, 
            FALSE, 
            INFINITE
            );

        switch ( dwRetVal ) {
        case WAIT_OBJECT_0: {
            
            //
            // Read user-input from the channel
            //
            bContinueSession = session->m_Scraper->Read();        
            
            break;
        
        }

        default:
            
            //
            // incase WAIT_FAILED, call GetLastError()
            //
            ASSERT(dwRetVal != WAIT_FAILED);
            

            //
            // An error has occured, stop listening
            // 
            bContinueSession = FALSE;
            
            break;
        }
    }
    
    return 0;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\headless\cmd\sacsess\secio.h ===
/*++

Copyright (c) 1999-2001  Microsoft Corporation

Module Name:

    secio.h

Abstract:

    Security IO Handler class

Author:

    Brian Guarraci (briangu) 2001.

Revision History:

--*/

#if !defined( _SECURE_IO_H_ )
#define _SECURE_IO_H_

#include "iohandler.h"
#include "sacio.h"
#include "lockio.h"
#include "redraw.h"
#include <emsapi.h>

//
// Max TimeOut Interval == 24 hours
//
#define MAX_TIME_OUT_INTERVAL  (24 * 60 * (60 * 1000)) 

// 30 minutes
#define DEFAULT_TIME_OUT_INTERVAL  (30 * (60 * 1000))

class CSecurityIoHandler : public CLockableIoHandler {
    
private:

    //
    // Prevent this class from being instantiated directly
    //
    CSecurityIoHandler(
        IN CIoHandler   *LockedIoHandler,
        IN CIoHandler   *UnlockedIoHandler
        );

protected:

    //
    // attributes used for the TimeOut behavior
    //
    HANDLE  m_ThreadExitEvent;
    HANDLE  m_RedrawEvent;
    HANDLE  m_LockEvent;
    HANDLE  m_InternalLockEvent;
    HANDLE  m_CloseEvent;
    HANDLE  m_TimeOutThreadHandle;
    DWORD   m_TimeOutThreadTID;
    LONG    m_StartTickCount;
    ULONG   m_TimeOutInterval;
    BOOL    m_StartedAuthentication;
    
    //
    //
    //
    CRedrawHandler  *m_RedrawHandler;
    
    //
    //
    //
    BOOL
    WaitForUserInput(
        IN BOOL Consume
        );

    BOOL
    IsTimeOutEnabled(
        VOID
        );

    BOOL
    GetTimeOutInterval(
        OUT PULONG  TimeOutDuration
        );

    BOOL
    InitializeTimeOutThread(
        VOID
        );

    BOOL
    TimeOutOccured(
        VOID
        );
    
    VOID
    ResetTimeOut(
        VOID
        );

    static unsigned int
    TimeOutThread(
        PVOID
        );

    BOOL
    RetrieveCredential(
        OUT PWSTR   String,
        IN  ULONG   StringLength,
        IN  BOOL    EchoClearText
        );

    BOOL 
    LoadStringResource(
        IN  PUNICODE_STRING pUnicodeString,
        IN  INT             MsgId
        );

    BOOL
    WriteResourceMessage(
        IN INT  MsgId
        );

        
    //
    // Read BufferSize bytes
    //
    inline virtual BOOL
    ReadUnlockedIoHandler(
        PBYTE  Buffer,
        ULONG   BufferSize,
        PULONG  ByteCount
        );

public:
    
    virtual ~CSecurityIoHandler();
    
    static CSecurityIoHandler*
    CSecurityIoHandler::Construct(
        IN SAC_CHANNEL_OPEN_ATTRIBUTES  Attributes
        );

    //
    // Write BufferSize bytes
    //
    inline virtual BOOL
    Write(
        PBYTE   Buffer,
        ULONG   BufferSize
        );

    //
    // Flush any unsent data
    //
    inline virtual BOOL
    Flush(
        VOID
        );

    //
    // Read BufferSize bytes
    //
    inline virtual BOOL
    Read(
        PBYTE  Buffer,
        ULONG   BufferSize,
        PULONG  ByteCount
        );

    //
    // Determine if the ioHandler has new data to read
    //
    inline virtual BOOL
    HasNewData(
        PBOOL   InputWaiting
        );
    
    BOOL
    RetrieveCredentials(
        IN OUT PWSTR   UserName,
        IN     ULONG   UserNameLength,
        IN OUT PWSTR   DomainName,
        IN     ULONG   DomainNameLength,
        IN OUT PWSTR   Password,
        IN     ULONG   PasswordLength
        );

    BOOL
    AuthenticateCredentials(
        IN  PWSTR   UserName,
        IN  PWSTR   DomainName,
        IN  PWSTR   Password,
        OUT PHANDLE pUserToken
        );

};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\headless\cmd\sacsess\shell.h ===
/*++

Copyright (c) 1999-2001  Microsoft Corporation

Module Name:

    shell.h

Abstract:

    Class for creating a command console shell

Author:

    Brian Guarraci (briangu) 2001.

Revision History:

--*/

#if !defined( _SHELL_H_ )
#define _SHELL_H_

#include <cmnhdr.h>
//#include <userenv.h>

class CSession;
class CScraper;

class CShell 
{

protected:
    
    //
    // attributes for managing cmd.exe profile & process
    // 
    HANDLE      m_hProcess;
    HANDLE      m_hProfile;
    BOOL        m_bHaveProfile;                                         
    HWINSTA     m_hWinSta;
    HDESK       m_hDesktop;

    BOOL CreateIOHandles(
        OUT PHANDLE ConOut,
        OUT PHANDLE ConIn
        );
    
    BOOL StartProcess(
        HANDLE
        );

    BOOL
    IsLoadProfilesEnabled(
        VOID
        );

    PTCHAR
    GetPathOfTheExecutable(
        VOID
        );

public:
    
    void Shutdown();

    BOOL StartUserSession(
        CSession    *session,
        HANDLE      hToken
        );
    
    CShell();

    virtual ~CShell();
    
};

#endif // _SHELL_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\headless\cmd\sacsess\utils.h ===
/*++

Copyright (c) 2001 Microsoft Corporation

Module Name:

    utils.h

Abstract:

    general utilities

Author:

    Brian Guarraci (briangu), 2001

Revision History:

--*/
#ifndef _MYUTIL_H
#define _MYUTIL_H

#include <windows.h>
#include <userenv.h>

#define MAX_CHANNEL_COUNT 10

#define INHERITABLE_NULL_DESCRIPTOR_ATTRIBUTE( sa ) \
    sa.nLength = sizeof( SECURITY_ATTRIBUTES ); \
    sa.bInheritHandle = TRUE; \
    sa.lpSecurityDescriptor = NULL;

void FillProcessStartupInfo(
    STARTUPINFO *, 
    PWCHAR,
    HANDLE, 
    HANDLE, 
    HANDLE 
    );
bool NeedCredentials( VOID );

BOOL AddAceToWindowStation(HWINSTA hwinsta, PSID psid);
BOOL AddAceToDesktop(HDESK hdesk, PSID psid);
BOOL GetLogonSID (HANDLE hToken, PSID *ppsid);
VOID FreeLogonSID (PSID *ppsid);

BOOL 
GrantAccessToDefaultDesktop(
    IN HANDLE   hToken
);

DWORD
GetAndComputeTickCountDeltaT(
    IN DWORD    StartTick
    );

bool
CreateSACSessionWinStaAndDesktop(
    IN  HANDLE      hToken,
    OUT HWINSTA     *hOldWinSta,
    OUT HWINSTA     *hWinSta,
    OUT HDESK       *hDesktop,
	OUT PWCHAR		*winStaName
);

BOOL
UtilUnloadEnvironment(
    IN PVOID   pchEnvBlock
);   

BOOL
UtilLoadEnvironment(
    IN  HANDLE  hToken,
    OUT PVOID   *pchEnvBlock
);   

BOOL
UtilUnloadProfile(
    IN HANDLE   hToken,
    IN HANDLE   hProfile 
);

BOOL
UtilLoadProfile(
    IN  HANDLE      hToken,
    OUT HANDLE      *hProfile
);

#endif //_MYUTIL_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\headless\cmd\sacsess\vtutf8scraper.cpp ===
/*++

Copyright (c) 1999-2001  Microsoft Corporation

Module Name:

    vtutf8scraper.cpp

Abstract:

    Class for performing vtutf8 screen scrapning of a command console shell

Author:

    Brian Guarraci (briangu) 2001.

Revision History:

    (remotely based on scraper.cpp from telnet code)

--*/

#include <cmnhdr.h>
#include <Scraper.h>
#include <utils.h>
#include "vtutf8scraper.h"

//
// Termcap globals
//
#define CM_STRING_LENGTH    9
LPWSTR lpszCMResultsBuffer = NULL;

//the string is of the form <ESC>[ Ps m
#define SGR_STRING_LENGTH   6
PWCHAR szSGRStr = NULL; 

#define SGR( szSGRString, num )                 \
    wnsprintf(                                  \
        szSGRString,                            \
        sizeof(WCHAR) * SGR_STRING_LENGTH,      \
        L"\033[%dm",                            \
        num                                     \
        );                                      \
    szSGRString[SGR_STRING_LENGTH-1] = UNICODE_NULL;

//
// Number of seconds before we timeout waiting for
// the next character in the 
//  <esc>ctrl-a
//  <esc>ctrl-c
//  <esc>ctrl-u
//
#define ESC_CTRL_SEQUENCE_TIMEOUT (2 * 1000)

//
// Tick Marker for when we get an esc-ctrl-X sequence
//
DWORD   TimedEscSequenceTickCount = 0;

//
// Globals for tracking the screen scraping attributes
//
COORD   coExpectedCursor    = { ~0, ~0 };
BOOL    fBold               = false;
WORD    wExistingAttributes = 0;
WORD    wDefaultAttributes  = 0;
    
//
//
//
#define MAX_SIZEOF_SCREEN (m_wMaxRows * m_wMaxCols * sizeof( CHAR_INFO ))

//
//
//
#define DBG_DUMP_SCREEN_INFO()\
    {                                                                           \
        WCHAR   blob[256];                                                      \
        wsprintf(blob,L"wRows: %d\n", m_wRows);                                 \
        OutputDebugString(blob);                                                \
        wsprintf(blob,L"wCols: %d\n", m_wCols);                                 \
        OutputDebugString(blob);                                                \
        wsprintf(blob,L"r*c: %d\n", m_wRows * m_wCols);                         \
        OutputDebugString(blob);                                                \
        wsprintf(blob,L"sizeof: %d\n", sizeof(CHAR_INFO));                      \
        OutputDebugString(blob);                                                \
        wsprintf(blob,L"r*c*s: %d\n", m_wRows * m_wCols * sizeof(CHAR_INFO));   \
        OutputDebugString(blob);                                                \
        wsprintf(blob,L"max: %d\n", MAX_SIZEOF_SCREEN);                         \
        OutputDebugString(blob);                                                \
    }

CVTUTF8Scraper::CVTUTF8Scraper()
/*++

Routine Description:

    Default constructor - this should not be used.
    
Arguments:

    None
          
Return Value:

   N/A

--*/
{
    
    pLastSeen = NULL;
    pCurrent = NULL;
    
    m_hConBufIn  = NULL;
    m_hConBufOut = NULL;
    
    m_dwInputSequenceState  = IP_INIT;
    m_dwDigitInTheSeq       = 0;

    m_readBuffer        = NULL;
    
    lpszCMResultsBuffer = NULL;
    szSGRStr            = NULL;

}

CVTUTF8Scraper::CVTUTF8Scraper(
    CIoHandler  *IoHandler,
    WORD        wCols,
    WORD        wRows
    ) : CScraper(
            IoHandler,
            wCols,
            wRows
            )

/*++

Routine Description:

    Constructor - parameterized
    
Arguments:

    IoHandler   - IoHandler the scraper should use
    wCols       - the # of rows the console screen buffer should have
    wRows       - the # of cols the console screen buffer should have
          
Return Value:

    N/A

--*/
{
    
    pLastSeen = NULL;
    pCurrent = NULL;

    m_dwInputSequenceState  = IP_INIT;
    m_dwDigitInTheSeq       = 0;

    m_readBuffer        = new WCHAR[READ_BUFFER_LENGTH];
    
    lpszCMResultsBuffer = new WCHAR[CM_STRING_LENGTH];
    szSGRStr            = new WCHAR[SGR_STRING_LENGTH];

}
        
CVTUTF8Scraper::~CVTUTF8Scraper()
/*++

Routine Description:

    Destructor

Arguments:

    N/A          
          
Return Value:

    N/A   

--*/
{
    //
    // release our screen buffers
    //
    if( pLastSeen )
    {
        delete[] pLastSeen;
    }
    if( pCurrent )
    {
        delete[] pCurrent;
    }
    if (m_readBuffer) {
        delete[] m_readBuffer;
    }
    if (lpszCMResultsBuffer) {
        delete[] lpszCMResultsBuffer;
    }
    if (szSGRStr) {
        delete[] szSGRStr;
    }

    //
    // Parent CScraper closes Con I/O handles
    //
    NOTHING;

}

void
CVTUTF8Scraper::ResetLastScreen(
    VOID
    )
/*++

Routine Description:

    Reset the memory of the last display
    
    This forces the screen scraper to think that everything
    is different, hence it sends a full screen dump

Arguments:

    None
          
Return Value:

    None

--*/
{

    //
    // clear the screen buffers and screen info
    //
    memset( &LastCSBI, 0, sizeof( LastCSBI ) );
    memset( pLastSeen, 0, MAX_SIZEOF_SCREEN );
    memset( pCurrent, 0, MAX_SIZEOF_SCREEN );
    
    fBold = false;
    wExistingAttributes = 0;
    wDefaultAttributes  = 0;

}


BOOL
CVTUTF8Scraper::DisplayFullScreen(
    VOID
    )
/*++

Routine Description:

    This routine forces the screen scraper to think that everything
    is different, hence it sends a full screen dump

Arguments:

    None
          
Return Value:

    TRUE    - success
    FALSE   - otherwise        

--*/
{
    BOOL    bSuccess;

    //
    // Reset the memory of the last display
    //
    // This forces the screen scraper to think that everything
    // is different, hence it sends a full screen dump
    //
    ResetLastScreen();

    //
    // Call the screen scraper
    //
    bSuccess = Write();

    return bSuccess;
}

BOOL
CVTUTF8Scraper::SetScreenBufferInfo(
    VOID
    )
/*++

Routine Description:

    This routine sets the current console screen buffer's 
    parameters to what we think they should be.  The primary
    purpose for this routine is to provide a means to change
    the screen buffer max X/Y to the m_wCols/m_wRows so that
    the output fits in our scraping window.

Arguments:

    pCSBI   - the current console screen buffer info

Return Value:

    TRUE    - success
    FALSE   - otherwise        
        
--*/
{
    COORD coordLargest;
    COORD coordSize;
    
    //
    // Start with our max window size and shrink if we need to
    //
    m_wCols = m_wMaxCols;
    m_wRows = m_wMaxRows;

    //
    // Get the current window info
    //
    coordLargest = GetLargestConsoleWindowSize( m_hConBufOut );

    if( coordLargest.X < m_wCols  && coordLargest.X != 0 )
    {
        m_wCols = coordLargest.X;
    }

    if( coordLargest.Y < m_wRows && coordLargest.Y != 0 )
    {
        m_wRows = coordLargest.Y;
    }

    //
    // make the window the size we think it should be
    //
    coordSize.X = m_wCols;
    coordSize.Y = m_wRows;

    SetConsoleScreenBufferSize( CVTUTF8Scraper::m_hConBufOut, coordSize );
    
    return( TRUE );
}

BOOL
CVTUTF8Scraper::SetWindowInfo(
    VOID
    )
/*++

Routine Description:

    This routine sets the initial console window info.

Arguments:

    None
          
Return Value:

    TRUE    - success
    FALSE   - otherwise    

--*/
{
    COORD coordLargest;
    SMALL_RECT sr;    
    COORD coordSize;
    CONSOLE_SCREEN_BUFFER_INFO csbi;
    
    //
    // Start with our max window size and shrink if we need to
    //
    m_wCols = m_wMaxCols;
    m_wRows = m_wMaxRows;
    
    //
    // Get the current window info
    //
    coordLargest = GetLargestConsoleWindowSize( m_hConBufOut );

    if( coordLargest.X < m_wCols  && coordLargest.X != 0 )
    {
        m_wCols = coordLargest.X;
    }

    if( coordLargest.Y < m_wRows && coordLargest.Y != 0 )
    {
        m_wRows = coordLargest.Y;
    }

    //
    //
    //
    sr.Top = 0;
    sr.Bottom = ( WORD )( m_wRows - 1 );
    sr.Right = ( WORD ) ( m_wCols - 1 );
    sr.Left = 0;

    //
    //
    //
    coordSize.X = m_wCols;
    coordSize.Y = m_wRows;

    //
    //
    //
    GetConsoleScreenBufferInfo( CVTUTF8Scraper::m_hConBufOut, &csbi);

    // Logic:  If the Old Window Size is less than the new Size then we set
    // the Screen Buffer Size first and then set the Window Size.
    // If the Old Window Size is Greater than the new Size then we set the
    // window Size first and then the Screen Buffer.

    // The above is because the Buffer Size always has to be greater than or
    // equal to the Window Size.
    if ( (csbi.dwSize.X < coordSize.X) || (csbi.dwSize.Y < coordSize.Y) )
    {
        COORD coordTmpSize = { 0, 0 };

        coordTmpSize .X = ( csbi.dwSize.X < coordSize.X ) ? coordSize.X  : csbi.dwSize.X;
        coordTmpSize .Y = ( csbi.dwSize.Y < coordSize.Y ) ? coordSize.Y  : csbi.dwSize.Y;

        SetConsoleScreenBufferSize ( CVTUTF8Scraper::m_hConBufOut, coordTmpSize );
        SetConsoleWindowInfo ( CVTUTF8Scraper::m_hConBufOut, TRUE, &sr );
        SetConsoleScreenBufferSize ( CVTUTF8Scraper::m_hConBufOut, coordSize );
    }
    else  
    {
        SetConsoleWindowInfo( CVTUTF8Scraper::m_hConBufOut, TRUE, &sr );
        SetConsoleScreenBufferSize( CVTUTF8Scraper::m_hConBufOut, coordSize );
    }
    
    return( TRUE );
}

BOOL
CVTUTF8Scraper::InitScraper(
    VOID
    )
/*++

Routine Description:

    This routine initializes the local scraper configures the console 
    to be the dimensions that the scraper requires.

Arguments:

    None      
          
Return Value:

    TRUE    - the scraper was initialized
    FALSE   - otherwise
        
--*/
{
    
    //
    // Configure the console dimensions
    //
    if( !SetWindowInfo() )
    {
        return( FALSE );
    }
    
    //
    // Create and initialize the scraper buffers
    //
    if( pLastSeen )
    {
        delete[] pLastSeen;
    }
    if( pCurrent )
    {
        delete[] pCurrent;
    }

    pLastSeen = ( PCHAR_INFO ) new char[MAX_SIZEOF_SCREEN];
    pCurrent  = ( PCHAR_INFO ) new char[MAX_SIZEOF_SCREEN];
    
    ASSERT(pLastSeen);
    ASSERT(pCurrent);
    
    if( !pLastSeen || !pCurrent )
    {
        return ( FALSE );
    }

    //
    // Initialize the screen buffers and info
    //
    memset( &LastCSBI, 0, sizeof( LastCSBI ) );
    memset( pCurrent, 0, MAX_SIZEOF_SCREEN );
    memset( pLastSeen, 0, MAX_SIZEOF_SCREEN );
    
    return( TRUE );
}

BOOL
CVTUTF8Scraper::CreateIOHandle(
    IN  PWCHAR  HandleName,
    OUT PHANDLE pHandle
    )
/*++

Routine Description:

    This routine opens a handle of the specified name.
    
    Note: This routine used to open CONIN$ and CONOUT$ handles
    for the console being scraped.     
         
Arguments:

    HandleName  - the name of the handle to open
    pHandle     - on success, the resulting handle      
          
Return Value:

    TRUE    - the handle was created
    FALSE   - otherwise                          

--*/
{
    BOOL    bSuccess;

    //
    // default: failed to open handle
    //
    bSuccess = FALSE;

    do {

        //
        // Attempt to open the console input handle
        //
        *pHandle = CreateFile(
            HandleName, 
            GENERIC_READ | GENERIC_WRITE, 
            0, 
            NULL, 
            OPEN_EXISTING, 
            FILE_ATTRIBUTE_NORMAL, 
            NULL 
            );
        
        ASSERT( *pHandle != INVALID_HANDLE_VALUE );
        
        if ( *pHandle == INVALID_HANDLE_VALUE) {
            break;
        }

        //
        // We were successful
        //
        bSuccess = TRUE;

    } while ( FALSE );

    return bSuccess;
}

BOOL
CVTUTF8Scraper::CreateConsoleOutHandle(
    VOID
    )
/*++

Routine Description:

    This routine creates a CONOUT$ handle to the current console screen buffer.                 
                     
Arguments:

    None                                                                               
          
Return Value:

    TRUE    - the handle was created
    FALSE   - otherwise                          

--*/
{
    BOOL                bSuccess;
    HANDLE              h;  

    //
    // Close the current console out handle
    //
    if ((m_hConBufOut != NULL) && (m_hConBufOut != INVALID_HANDLE_VALUE)) {
        CloseHandle(m_hConBufOut);
    }

    //
    // Create the new console out handle
    //
    bSuccess = CreateIOHandle(
        L"CONOUT$",
        &h
        );

    if (bSuccess) {
        SetConOut(h);
    }

    return bSuccess;
}

BOOL
CVTUTF8Scraper::CreateConsoleInHandle(
    VOID
    )
/*++

Routine Description:

    This routine creates a CONIN$ handle to the current console screen buffer.                 

Arguments:

    None
          
Return Value:

    TRUE    - the handle was created
    FALSE   - otherwise                          

--*/
{
    BOOL                bSuccess;
    HANDLE              h;  

    //
    // Close the current console in handle
    //
    if ((m_hConBufIn != NULL) && (m_hConBufIn != INVALID_HANDLE_VALUE)) {
        CloseHandle(m_hConBufIn);
    }
    
    //
    // Create the new console out handle
    //
    bSuccess = CreateIOHandle(
        L"CONIN$",
        &h
        );

    if (bSuccess) {
        SetConIn(h);
    }

    return bSuccess;
}

BOOL
CVTUTF8Scraper::CreateIOHandles(
    VOID
    )
/*++

Routine Description:

    This routine creates CONIN$ and CONOUT$ handles to the 
    current console screen buffer.                 
        
Arguments:

    None
          
Return Value:

    TRUE    - the handles were created
    FALSE   - otherwise                          

--*/
{
    //
    // note: the scraper parent class will reap the std io handles
    //
    return ((CreateConsoleOutHandle()) && (CreateConsoleInHandle()));
}


BOOL
CVTUTF8Scraper::Start(
    VOID
    )
/*++

Routine Description:

    This routine initializes the scraper and prepares it so
    that this routine can be immediately followed by a Write().
             
Arguments:

    None

Return Value:

    TRUE    - the scraper was started
    FALSE   - otherwise
    
--*/
{
    BOOL    bSuccess;

    //
    // Create the Console IO Handles
    //
    bSuccess = CreateIOHandles();
    ASSERT_STATUS(bSuccess, FALSE);
    
    //
    // Initialize the scraper
    //
    bSuccess = InitScraper();
    ASSERT_STATUS(bSuccess, FALSE);

    //
    // Reset the last screen display memory
    //
    ResetLastScreen();

    return( TRUE ); 
}

BOOL
CVTUTF8Scraper::Write(
    VOID
    )
/*++

Routine Description:

    This routine scrapes the current console buffer and writes the emulated
    terminal output to the current IoHandler.                      
            
    Note: In order to guarantee coherency between what the scaper sees and 
          the apps being scraped, this routine ensures the current screen 
          buffer is of the expected dimensions the scraper cares about.  
          If the dimensions are not correct, it forces them to what it expects.  
          For instance, Edit resizes the window to 80x25, but the scraper may
          expect 80x24, so the console buffer gets resized to 80x24.              
                                
Arguments:

    None                                                 
          
Return Value:

    TRUE    - the write operation was successful
    FALSE   - otherwise    

Security:

    Interface:
    
        Console - we write user input to the console

--*/
{          
    BOOL    bSuccess;
    DWORD   dwStatus;

    //
    // Open a handle to the active console screen buffer
    //
    // Note: This is a necessary step.
    //       We need to ensure we have a handle to the
    //       current console screen buffer before we 
    //       attempt to screen scrape.
    //       The reason we concern ourselves with having
    //       the current screen buffer handle is because
    //       apps can use the CreateConsoleScreenBuffer & 
    //       SetConsoleActiveScreenBuffer APIs.  These
    //       APIs effectively invalidate our CONOUT$ until
    //       they switch back to their original conout handle.
    //       A typical use scenario is:
    // 
    //       1. get original conout handle:
    //          PrevConsole = GetStdHandle(STD_OUTPUT_HANDLE);
    //       2. create a new console screen buffer
    //       3. set new screen buffer as the active one
    //       4. do work using new screen buffer...
    //       5. set screen buffer to original
    //
    if ( !CreateConsoleOutHandle() ) {
        //Could be an application that does not share its screen buffer
        return TRUE;
    }

    //
    // Read the current screen buffer info
    //
    dwStatus = GetConsoleScreenBufferInfo( m_hConBufOut, &CSBI );
    ASSERT( dwStatus );
    if( !dwStatus )
    {
        return ( FALSE );
    }    
    
    //
    // Make sure the screen buffer size hasn't changed.
    // if it has, then set it back.
    //
    if (CSBI.dwMaximumWindowSize.X > m_wCols || 
        CSBI.dwMaximumWindowSize.Y > m_wRows
        ) {
        
        //
        // We have detected a change in the screen buffer settings
        // this very likely means that an app has created a new
        // screen buffer and made it the active one.  In order
        // to not confuse the app during its initialization phase
        // we need to pause for a short period before resetting
        // the screen buffer parameters.
        //
        Sleep(100);

        //
        // 
        //
        if( !SetScreenBufferInfo() ) {
            return( FALSE );
        }
        
        //
        // reread the current screen buffer info
        //
        dwStatus = GetConsoleScreenBufferInfo( m_hConBufOut, &CSBI );
        ASSERT( dwStatus );
        if( !dwStatus )
        {
            return ( FALSE );
        }    
    
    }

    //
    // Perform the screen scraping
    //
    bSuccess = CompareAndUpdate( 
        m_wRows, 
        m_wCols, 
        pCurrent, 
        pLastSeen, 
        &CSBI, 
        &LastCSBI
        );

    return bSuccess;
}

BOOL
CVTUTF8Scraper::Read()
/*++

Routine Description:

    this routine retrieves user-input from the IoHandler and
    sends it to the current console buffer.
            
Arguments:

    None                                       
          
Return Value:

    TRUE    - the read operation was successful
    FALSE   - otherwise

Security:

    Inteface:
    
        external input --> internal 
        
--*/
{
    DWORD       i;
    BOOL        dwStatus = 0;
    DWORD       dwCharsTransferred = 0;
    ULONG       bufferSize;
    BOOL        bInEnhancedCharSequence;            
    BOOL        bSuccess;

    //
    // read Channel::stdin
    //
    bSuccess = m_IoHandler->Read(
        (PUCHAR)m_readBuffer,
        READ_BUFFER_SIZE,
        &bufferSize
        );
    
    if (!bSuccess) {
        return (FALSE);    
    }
    
    //
    // Determine the # of WCHARs read
    //
    dwCharsTransferred = bufferSize / sizeof(WCHAR);

    //
    // Process the read characters
    //
    for( i=0;  i < dwCharsTransferred; i++ ) {
        
        //
        // Examine the input stream and parse out any VT-UTF8 escape sequences
        // that are present.
        //
        bInEnhancedCharSequence = ProcessEnhancedKeys( m_readBuffer[i] );
        
        //
        // If the last character processed started/continued an
        // enhanced key sequence, then continue processing enhanced
        // keys
        //
        if (bInEnhancedCharSequence) {                
            continue;
        }

        //
        // Handle ctrl-c (this behavior is taken from tlntsess.exe)
        //
        if( (UCHAR)m_readBuffer[i] == CTRLC ) {
            
            //
            //The follwing is the observed behaviour of CTRL C
            //When ENABLE_PROCESSED_INPUT mode is not enabled, pass CTRL C as
            //input to the console input buffer.
            //When ENABLE_PROCESSED_INPUT mode is enabled, generate CTTRL C signal
            //and also unblock any ReadConsoleInput. This behaviour is what is observed
            // and not from any documentation.
            //
            DWORD dwMode = 0;
            
            GetConsoleMode( m_hConBufIn, &dwMode );
            
            if( dwMode &  ENABLE_PROCESSED_INPUT ) {
                GenerateConsoleCtrlEvent( CTRL_C_EVENT, 0);
                continue;
            }
        
        } 
            
        //
        // Send the character to the command console
        //
        dwStatus = WriteAKeyToCMD(m_readBuffer[i]);
        
        if( !dwStatus ) {
            return ( FALSE );
        }
    
    }
    
    return( TRUE );
}

DWORD 
CVTUTF8Scraper::WriteAKeyToCMD( 
    WCHAR   Char
    )
/*++

Routine Description:

    This routine sends a character to the console.
               
Arguments:

    Char    - the character to send                                                            
          
Return Value:

    status                               

--*/
{
    DWORD       dwStatus;
    SHORT       vk;
    BYTE        vkcode;
    WORD        wScanCode;

    //
    // default: failure
    //
    dwStatus = 0;

    //
    // Get the virtual key scan code for the character
    //
    vk = VkKeyScan( (UCHAR)Char );

    if( vk != 0xffff )
    {
        DWORD        dwShiftcode;

        //
        // translates (maps) a virtual-key code into a scan code 
        //
        vkcode = LOBYTE( vk );
        wScanCode = ( WORD )MapVirtualKey( vkcode, 0 );

        //
        // determine if any modifiers need to be sent 
        //
        dwShiftcode = 0;
        
        if( HIBYTE( vk ) & 1 ) {
            dwShiftcode |= SHIFT_PRESSED;
        }
        if( HIBYTE( vk ) & 2 ) {
            dwShiftcode |= LEFT_CTRL_PRESSED;
        }
        if( HIBYTE( vk ) & 4 ) {
            dwShiftcode |= LEFT_ALT_PRESSED;
        }

        //
        // Send the character and modifiers
        //
        dwStatus = WriteAKeyToCMD( 
            TRUE,
            vkcode, 
            wScanCode, 
            Char, 
            dwShiftcode
            );

    }

    return dwStatus;
}

DWORD 
CVTUTF8Scraper::WriteAKeyToCMD( 
    WORD    wVKCode, 
    WORD    wVSCode, 
    WCHAR   Char, 
    DWORD   dwCKState 
    )
/*++

Routine Description:

    This routine sends a character which has already been scanned
    to the console.
          
Arguments:

    wVKCode     - the virtual key code 
    wVSCode     - the scan code
    Char        - the character to send
    dwCKState   - the control key state
          
Return Value:


--*/
{
    return WriteAKeyToCMD(
        TRUE,
        wVKCode,
        wVSCode,
        Char,
        dwCKState
        );
}

DWORD 
CVTUTF8Scraper::WriteAKeyToCMD( 
    BOOL    bKeyDown,
    WORD    wVKCode, 
    WORD    wVSCode, 
    WCHAR   Char, 
    DWORD   dwCKState 
    )
/*++

Routine Description:

    This routine sends a character which has already been scanned
    to the console.  In addition, the caller can specify the key
    press status of this character.
    
Arguments:

    bKeyDown    - the key status of the character
    wVKCode     - the virtual key code 
    wVSCode     - the scan code
    Char        - the character to send
    dwCKState   - the control key state
                                   
Return Value:

    Status

Security:

    external input --> interal 
    
        we write data retrieved from remote user to the
        cmd console stdin
        
--*/
{
    DWORD dwStatus = 0;
    DWORD dwCount  = 0;
    INPUT_RECORD input;

    ZeroMemory( &input, sizeof( INPUT_RECORD ) );

    input.EventType = KEY_EVENT;
    input.Event.KeyEvent.bKeyDown = bKeyDown;
    input.Event.KeyEvent.wRepeatCount = 1;

    input.Event.KeyEvent.wVirtualKeyCode = wVKCode;
    input.Event.KeyEvent.wVirtualScanCode = wVSCode;
    input.Event.KeyEvent.uChar.UnicodeChar = Char;
    input.Event.KeyEvent.dwControlKeyState = dwCKState;
    
    dwStatus = WriteConsoleInput( m_hConBufIn, &input, 1, &dwCount );

    return dwStatus;
}

BOOL
CVTUTF8Scraper::IsValidControlSequence(
    VOID
    )
/*++

Routine Description:

    Determine how long it has been since the esc-ctrl-a sequence

Arguments:

    None  
          
Return Value:

    TRUE    - the control sequence has occured with the allowable time-frame
    FALSE   - otherwise

--*/
{
    DWORD   DeltaT;

    DeltaT = GetAndComputeTickCountDeltaT(TimedEscSequenceTickCount);

    return (DeltaT <= ESC_CTRL_SEQUENCE_TIMEOUT);
}

BOOL 
CVTUTF8Scraper::ProcessEnhancedKeys( 
    IN WCHAR    cCurrentChar 
    )
/*++

Routine Description:

    This routine parse the character stream and determines if there
    have been any enhanced key sequences.  If so, it removes the sequence
    from the character stream and send the key to the console.

Arguments:

    cCurrentChar    - the current character in the stream
          
Return Value:

    TRUE    - The character processed started/continued an enhanced key sequence
    FALSE   - otherwise

--*/
{
    BOOL bRetVal = true;

    switch( m_dwInputSequenceState )
    {
    case IP_INIT:
        
        switch (cCurrentChar) {
        case ESC:
            
            //
            // We are now in an <esc> sequence
            //
            m_dwInputSequenceState = IP_ESC_RCVD;
            
            break;
        
        default:
            
            //
            // Not any special char
            //
            bRetVal = false;
            
            break;

        }
        
        break;

    case IP_ESC_RCVD:
        
        m_dwInputSequenceState = IP_INIT;
        
        //
        // Map the VT-UTF8 encodings of the ENHANCED keys
        //
        switch (cCurrentChar) {
        case '[':
            m_dwInputSequenceState = IP_ESC_BRACKET_RCVD;
            break;

        case 'h':
            WriteAKeyToCMD( VK_HOME, VS_HOME, 0, ENHANCED_KEY );
            break;

        case 'k':
            WriteAKeyToCMD( VK_END, VS_END, 0, ENHANCED_KEY );
            break;

        case '+':
            WriteAKeyToCMD( VK_INSERT, VS_INSERT, 0, ENHANCED_KEY );
            break;

        case '-':
            WriteAKeyToCMD( VK_DELETE, VS_DELETE, 0, ENHANCED_KEY );
            break;

        case '?':   // page up
            WriteAKeyToCMD( VK_PRIOR, VS_PRIOR, 0, ENHANCED_KEY );
            break;

        case '/':   // page down
            WriteAKeyToCMD( VK_NEXT, VS_NEXT, 0, ENHANCED_KEY );
            break;

        case '1':   // F1
            WriteAKeyToCMD( VK_F1, VK_F1, 0, ENHANCED_KEY );
            break;

        case '2':   // F2
            WriteAKeyToCMD( VK_F2, VK_F2, 0, ENHANCED_KEY );
            break;

        case '3':   // F3
            WriteAKeyToCMD( VK_F3, VS_F3, 0, ENHANCED_KEY );
            break;

        case '4':   // F4
            WriteAKeyToCMD( VK_F4, VS_F4, 0, ENHANCED_KEY );
            break;

        case '5':   // F5
            WriteAKeyToCMD( VK_F5, VS_F5, 0, ENHANCED_KEY );
            break;

        case '6':   // F6
            WriteAKeyToCMD( VK_F6, VS_F6, 0, ENHANCED_KEY );
            break;

        case '7':   // F7
            WriteAKeyToCMD( VK_F7, VS_F7, 0, ENHANCED_KEY );
            break;

        case '8':   // F8
            WriteAKeyToCMD( VK_F8, VS_F8, 0, ENHANCED_KEY );
            break;                    

        case '9':   // F9
            WriteAKeyToCMD( VK_F9, VS_F9, 0, ENHANCED_KEY );
            break;

        case '0':   // F10
            WriteAKeyToCMD( VK_F10, VS_F10, 0, ENHANCED_KEY );
            break;

        case '!':   // F11
            WriteAKeyToCMD( VK_F11, VS_F11, 0, ENHANCED_KEY );
            break;

        case '@':   // F12
            WriteAKeyToCMD( VK_F12, VS_F12, 0, ENHANCED_KEY );
            break;

        case CTRLA:
            
            m_dwInputSequenceState = IP_ESC_CTRL_A_RCVD;
            
            //
            // Mark when we received this sequence
            //
            TimedEscSequenceTickCount = GetTickCount();

            break;

        case CTRLS:   
            
            m_dwInputSequenceState = IP_ESC_CTRL_S_RCVD;
            
            //
            // Mark when we received this sequence
            //
            TimedEscSequenceTickCount = GetTickCount();

            break;

        case CTRLC:   
            
            m_dwInputSequenceState = IP_ESC_CTRL_C_RCVD;
            
            //
            // Mark when we received this sequence
            //
            TimedEscSequenceTickCount = GetTickCount();

            break;

        default:
            
            //
            // Write already received escape as it is and return false
            //
            WriteAKeyToCMD( VK_ESCAPE, VS_ESCAPE, ESC, ENHANCED_KEY );
            
            bRetVal = false;
            
            break;
        }
        
        break;

    case IP_ESC_BRACKET_RCVD:        
        
        m_dwInputSequenceState = IP_INIT;
        
        switch( cCurrentChar )
        {
        case 'A':
            WriteAKeyToCMD( VK_UP, VS_UP, 0, ENHANCED_KEY );                    
            break;

        case 'B':
            WriteAKeyToCMD( VK_DOWN, VS_DOWN, 0, ENHANCED_KEY );
            break;

        case 'C':
            WriteAKeyToCMD( VK_RIGHT, VS_RIGHT, 0, ENHANCED_KEY );
            break;

        case 'D':
            WriteAKeyToCMD( VK_LEFT, VS_LEFT, 0, ENHANCED_KEY );
            break;

        default:
            
            //
            // Send the <esc>[ characters through since a valid sequence
            // was not recognized
            //
            WriteAKeyToCMD( VK_ESCAPE, VS_ESCAPE, ESC, ENHANCED_KEY );            
            WriteAKeyToCMD( VS_LEFT_BRACKET, VS_LEFT_BRACKET, '[', 0 );
            
            //
            // Not any special char
            //
            bRetVal = false;
            break;
        
        }
        
        break;

    case IP_ESC_CTRL_A_ESC_RCVD:
        
        m_dwInputSequenceState = IP_INIT;
        
        switch (cCurrentChar) {
        case CTRLA: 
            
            //
            // If we arrived here within 2 seconds 
            // then we should process the current character as an alt sequence
            // otherwise, there is nothing to do
            //
            if (IsValidControlSequence()) {
                
                //
                // Send: <alt-pressed><alt-released>
                //
                // Normally this should be benign, but some apps may 
                // respond to this - for instance move the user to the menu
                // bar
                //
                WriteAKeyToCMD( TRUE, VK_MENU, VS_MENU, 0, ENHANCED_KEY );
                WriteAKeyToCMD( FALSE, VK_MENU, VS_MENU, 0, ENHANCED_KEY );
            
                break;
            } 
            
            //
            // if the <esc><ctrl-a><esc><ctrl-a> sequenced timed-out, 
            // then fall through and do the default behavior.
            //

        default:
                
            //
            // We either timed-out after the <esc><ctrl-a><esc>
            // or we received the following sequence:
            //
            // <esc><ctrl-a><esc>X
            //
            // We know that the <esc><ctrl-a><esc> was valid because
            // we arrived here.  Hence, in either case the translation
            // should be:
            //
            // <alt-esc>X
            //
            WriteAKeyToCMD( TRUE, VK_MENU, VS_MENU, 0, ENHANCED_KEY );
            WriteAKeyToCMD(ESC);
            WriteAKeyToCMD( FALSE, VK_MENU, VS_MENU, 0, ENHANCED_KEY );
            
            //
            // Send the current character (X) through to be processed normally
            //
            bRetVal = false;
    
            break;
        }
        
        break;

    case IP_ESC_CTRL_A_RCVD:

        m_dwInputSequenceState = IP_INIT;

        switch (cCurrentChar) {
        
        case ESC: 
            
            //
            // If we arrived here within 2 seconds of receiving the ctrl-a
            // then we should process the current character as an alt sequence
            // otherwise, there is nothing to do
            //
            
            if (IsValidControlSequence()) {
            
                //
                // We need to move to the <esc><ctrl-a><esc> state
                //
                m_dwInputSequenceState = IP_ESC_CTRL_A_ESC_RCVD;
            
                //
                // Mark when we received this sequence
                //
                TimedEscSequenceTickCount = GetTickCount();
            
            } else {

                //Not any special char
                bRetVal = false;

            }
            
            break;

        default:
            
            //
            // If we arrived here within 2 seconds of receiving the ctrl-a
            // then we should process the current character as an alt sequence
            // otherwise, there is nothing to do
            //
    
            if (IsValidControlSequence()) {
                
                WriteAKeyToCMD( TRUE, VK_MENU, VS_MENU, 0, ENHANCED_KEY );
                WriteAKeyToCMD(cCurrentChar);
                WriteAKeyToCMD( FALSE, VK_MENU, VS_MENU, 0, ENHANCED_KEY );
            
            } else {
                
                //Not any special char
                bRetVal = false;
    
            }
            
            break;
        }

        break;

    case IP_ESC_CTRL_C_RCVD:

        m_dwInputSequenceState = IP_INIT;

        //
        // If we arrived here within 2 seconds of receiving the ctrl-c
        // then we should process the current character as an alt sequence
        // otherwise, there is nothing to do
        //

        if (IsValidControlSequence()) {

            WriteAKeyToCMD( TRUE, VK_CONTROL, VS_CONTROL, 0, ENHANCED_KEY );
            WriteAKeyToCMD(cCurrentChar);
            WriteAKeyToCMD( FALSE, VK_CONTROL, VS_CONTROL, 0, ENHANCED_KEY );

        } else {

            //Not any special char
            bRetVal = false;

        }
        
        break;

    case IP_ESC_CTRL_S_RCVD:
        
        m_dwInputSequenceState = IP_INIT;
        
        //
        // If we arrived here within 2 seconds of receiving the ctrl-c
        // then we should process the current character as an alt sequence
        // otherwise, there is nothing to do
        //

        if (IsValidControlSequence()) {
            
            WriteAKeyToCMD( TRUE, VK_SHIFT, VS_SHIFT, 0, ENHANCED_KEY );
            WriteAKeyToCMD(cCurrentChar);
            WriteAKeyToCMD( FALSE, VK_SHIFT, VS_SHIFT, 0, ENHANCED_KEY );
        
        } else {
            
            //Not any special char
            bRetVal = false;

        }
        
        break;
    
    default:
        //Should not happen
        ASSERT( 0 );
    }
       
    return bRetVal;
}

BOOL 
CVTUTF8Scraper::SendBytes( 
    PUCHAR pucBuf, 
    DWORD dwLength 
    )
/*++

Routine Description:

    This routine sends an array of bytes to the IoHandler.                   
                       
Arguments:

    pucBuf      - the array to send
    dwLength    - the # of bytes to send          
                                                          
Return Value:

    Status
    
Security:

    internal --> external
    
        we are sending internal data to remote user
    
--*/
{
    
    ASSERT(pucBuf);

    return m_IoHandler->Write(
        pucBuf,
        dwLength
        );
    
}

BOOL
CVTUTF8Scraper::SendString( 
    PWCHAR  pwch
    )
/*++

Routine Description:

    This routine sends a WCHAR string to the IoHandler.         
             
Arguments:

    pwch   - the string to send          
                                                 
Return Value:

    Status

--*/
{
    
    ASSERT(pwch);
    
    return SendBytes( 
        ( PUCHAR )pwch,  
        (ULONG)(wcslen(pwch) * sizeof(WCHAR))
        );    

}

BOOL
CVTUTF8Scraper::SendColorInfo( 
    WORD    wAttributes 
    ) 
/*++

Routine Description:

    This routine assembles a VT-UTF8 encoded color attibutes command
    and sends it to the IoHandler        
        
Arguments:

    wAttributes - the attributes to encode
          
Return Value:

    Status

--*/
{
    BOOL    bSuccess;

    //
    // default
    //
    bSuccess = FALSE;

    do {

        if( wAttributes & BACKGROUND_INTENSITY )
        {
            //do nothing.
            //There is no equivalent capability on vtutf8
            NOTHING;
        }

        if( wAttributes & FOREGROUND_INTENSITY )
        {
            if( !fBold )
            {
                SGR( szSGRStr, 1 ); //Bold
                
                bSuccess = SendString( szSGRStr );
                if (! bSuccess) {
                    break;
                }

                fBold = true;
            }
        } 
        else
        {
            if( fBold )
            {
                SGR( szSGRStr, 22 ); //Bold off
                
                bSuccess = SendString( szSGRStr );
                if (! bSuccess) {
                    break;
                }
                
                fBold = false;
            }
        }

        WORD wColor = 0;

        if( wAttributes & FOREGROUND_BLUE )
        {
            wColor = ( WORD )(  wColor | 0x0004 );
        } 

        if( wAttributes & FOREGROUND_GREEN )
        {
            wColor = ( WORD )( wColor | 0x0002 );
        } 

        if( wAttributes & FOREGROUND_RED )
        {
            wColor = ( WORD )( wColor | 0x0001 );
        } 

        wColor += 30;   //Base value for foreground colors
        SGR( szSGRStr, wColor );
        bSuccess = SendString( szSGRStr );

        if (! bSuccess) {
            break;
        }

        //WORD wColor = 0;
        wColor = 0;

        if( wAttributes & BACKGROUND_BLUE )
        {
            wColor = ( WORD )( wColor | 0x0004 );
        } 

        if( wAttributes & BACKGROUND_GREEN )
        {
            wColor = ( WORD )( wColor | 0x0002 );
        }    

        if( wAttributes & BACKGROUND_RED )
        {
            wColor = ( WORD )( wColor | 0x0001 );
        } 

        wColor += 40;   //Base value for Background colors
        SGR( szSGRStr, wColor );
        bSuccess = SendString( szSGRStr );
    
    } while ( FALSE );

    return bSuccess;
}

#define COMPARE_ROWS(currentRow, lastSeenRow, result) \
    for(i = 0; i < wCols; ++i ) \
    { \
        if( pCurrent[ ( currentRow ) * wCols + i].Char.UnicodeChar != \
            pLastSeen[ ( lastSeenRow ) * wCols + i].Char.UnicodeChar ) \
        {\
            (result) = 0; \
            break;\
        } \
        if( ( wDefaultAttributes != pCurrent[ ( currentRow ) * wCols + i]. \
              Attributes ) && \
              ( pCurrent[ ( currentRow ) * wCols + i].Attributes !=  \
              pLastSeen[ ( lastSeenRow ) * wCols + i].Attributes ) ) \
        { \
           (result) = 0; \
           break; \
        } \
    } 

//row, column are over the wire should be w.r.t screen. 
//So, +1 for both row, column
#define POSITION_CURSOR( row, column )                  \
    ASSERT(row <= 23);                                  \
    {                                                   \
        CursorMove(                                     \
            lpszCMResultsBuffer,                        \
            ( WORD ) ( ( row ) + 1 ),                   \
            ( WORD ) ( ( column ) + 1 )                 \
            );                                          \
        bSuccess = SendString( lpszCMResultsBuffer );   \
        if (!bSuccess) {                                \
            break;                                      \
        }                                               \
    }


//
// Send columns [begin -- end] characters on <row>
//
// Note: Because we are modeling a unicode console, we have to be careful about 
//      what we decide to represent as vtutf8.  Characters that take up more than
//      one screen cell in the console have to be processed so we don't send
//      redundant data.  
//
//      Hence, we only send a character if the cell contains:
//
//      1. a single byte character
//      2. the first position of a unicode character
//          You can tell the first character position of a unicode characeter
//          because the cells are enumarated.  The enumeration is determined by:
//
//          enum = (CHAR_INFO.Attributes & 0x0000ff00) >> 8
//
#if 0
//
// Very noisy debug version
//
#define SEND_ROW( row, begin, end ) \
    {                                                                               \
        CHAR_INFO   chi;                                                            \
        UCHAR       x;                                                              \
        WCHAR       blob[256];                                                      \
        wsprintf(blob,L"\r\n(row=%d:begin=%d:end=%d)\r\n", row, begin, end);        \
        OutputDebugString(blob);                                                    \
        for(LONG c = ( begin ); c < ( end ); ++c ) {                                \
            if( wExistingAttributes != pCurrent[( row ) * wCols + c].Attributes ) { \
                wExistingAttributes = pCurrent[ ( row ) * wCols + c].Attributes;    \
                wDefaultAttributes  = ( WORD )~0;                                   \
                bSuccess = SendColorInfo( wExistingAttributes );                    \
                if (!bSuccess) {                                                    \
                    break;                                                          \
                }                                                                   \
                wsprintf(blob,L"(Color:%x)", wExistingAttributes);                  \
                OutputDebugString(blob);                                            \
            }                                                                       \
            chi = pCurrent[ ( row ) * wCols + c];                                   \
            x = (UCHAR)((chi.Attributes & 0x0000ff00) >> 8);                        \
            wsprintf(blob,L"(%x)", chi.Char.UnicodeChar);                           \
            OutputDebugString(blob);                                                \
            if (x < 2) {                                                            \
                bSuccess = SendChar( chi.Char.UnicodeChar );                        \
                if (!bSuccess) {                                                    \
                    break;                                                          \
                }                                                                   \
            }                                                                       \
        }                                                                           \
    }
#else
#define SEND_ROW( row, begin, end ) \
    {                                                                               \
        CHAR_INFO   chi;                                                            \
        UCHAR       x;                                                              \
        for(LONG c = ( begin ); c < ( end ); ++c ) {                                \
            if( wExistingAttributes != pCurrent[( row ) * wCols + c].Attributes ) { \
                wExistingAttributes = pCurrent[ ( row ) * wCols + c].Attributes;    \
                wDefaultAttributes  = ( WORD )~0;                                   \
                bSuccess = SendColorInfo( wExistingAttributes );                    \
                if (!bSuccess) {                                                    \
                    break;                                                          \
                }                                                                   \
            }                                                                       \
            chi = pCurrent[ ( row ) * wCols + c];                                   \
            x = (UCHAR)((chi.Attributes & 0x0000ff00) >> 8);                        \
            if (x < 2) {                                                            \
                bSuccess = SendChar( chi.Char.UnicodeChar );                        \
                if (!bSuccess) {                                                    \
                    break;                                                          \
                }                                                                   \
            }                                                                       \
        }                                                                           \
    }
#endif

#define GET_DEFAULT_COLOR \
    if( wDefaultAttributes == 0 ) \
    { \
        wDefaultAttributes  = pCurrent[ 0 ].Attributes; \
        wExistingAttributes = pCurrent[ 0 ].Attributes; \
    }

#define IS_BLANK( row, col ) \
    ( pCurrent[ ( row ) * wCols + ( col ) ].Char.UnicodeChar == ' ' )

#define IS_DIFFERENT_COLOR( row, col, attribs ) \
    ( pCurrent[ ( row ) * wCols + ( col ) ].Attributes != ( attribs ) )

#define IS_CHANGE_IN_COLOR( row, col ) \
    ( pCurrent[ ( row ) * wCols + ( col ) ].Attributes != \
    pLastSeen[ ( row ) * wCols + ( col ) ].Attributes )

#define IS_CHANGE_IN_CHAR( row, col ) \
    ( pCurrent[ ( row ) * wCols + ( col ) ].Char.UnicodeChar != \
    pLastSeen[ ( row ) * wCols + ( col )].Char.UnicodeChar )
 

BOOL
CVTUTF8Scraper::CompareAndUpdate( 
    WORD wRows, 
    WORD wCols, 
    PCHAR_INFO pCurrent,
    PCHAR_INFO pLastSeen,
    PCONSOLE_SCREEN_BUFFER_INFO pCSBI,
    PCONSOLE_SCREEN_BUFFER_INFO pLastCSBI
    )
/*++

Routine Description:

    This routine does the core work for scraping the screen.
    
Algorithm: 
    
    This routine does a row-by-row comparision.
    If a row is found to be different, it figures out which region
    of the row is different and sends that sub-row piece.
                  
Arguments:

    wRows       - the # of rows to scrape
    wCols       - the # of cols to scrape
    pCurrent    - the current scraper buffer
    pLastSeen   - the last scraper buffer
    pCSBI       - the current Console Screen Buffer Info   
    pLastCSBI   - the current Console Screen Buffer Info   
          
Return Value:

    TRUE    - success
    FALSE   - otherwise

--*/
{
    INT         i;
    WORD        wRow;
    WORD        wCol;
    INT         iStartCol;
    INT         iEndCol;
    BOOL        fBlankLine;
    COORD       coordDest;
    COORD       coordOrigin;
    SMALL_RECT  srSource;
    BOOL        DifferenceFound;
    BOOL        bSuccess;
    
    //
    // default: we succeeded
    //
    bSuccess = TRUE;

    //
    // Default: no difference found
    //
    DifferenceFound = false;

    //
    //
    //
    GET_DEFAULT_COLOR;

    //
    // Read the console character matrix
    //
    ASSERT(wCols <= m_wMaxCols);
    ASSERT(wRows <= m_wMaxRows);

    coordDest.X = wCols;
    coordDest.Y = wRows;
    
    coordOrigin.X = 0;
    coordOrigin.Y = 0;
    
    srSource.Left = 0;
    srSource.Top = 0;
    srSource.Right = ( WORD ) ( wCols - 1 );
    srSource.Bottom = ( WORD ) ( wRows - 1 );

    bSuccess = ReadConsoleOutput( 
        m_hConBufOut, 
        pCurrent, 
        coordDest,
        coordOrigin, 
        &srSource 
        );
    if( !bSuccess )
    {
        return ( FALSE );
    }

    //
    // Search the current and last screen buffers for differences.
    //
    wRow = wCol = 0;

    while ( wRow < wRows ) {
        
        //
        // Compare the current row (wRow)
        //
        if( memcmp( &pCurrent[wRow * wCols], 
                    &pLastSeen[wRow * wCols],
                    wCols * sizeof( CHAR_INFO ) ) != 0 
            ) {
            
            //
            // A difference was found
            //
            DifferenceFound = true;

            //
            // Initialize the difference tracking markers
            //
            iStartCol = -1;
            iEndCol = -1;
            fBlankLine = true;
            
            //
            // Determine where in the current row the rows differ
            //
            for (i = 0 ; i < wCols; ++i ) {
                
                if( IS_DIFFERENT_COLOR( wRow, i, wDefaultAttributes ) && 
                    IS_CHANGE_IN_COLOR( wRow, i ) 
                    ) {
                   
                    if( iStartCol == -1 )
                    {
                        iStartCol = i;
                    }

                   iEndCol = i;
                   fBlankLine = false;                   
                
                }
                
                if( IS_CHANGE_IN_CHAR( wRow, i ) ) {
                   
                    if( iStartCol == -1 ) {
                       iStartCol = i;
                    }
                   
                    iEndCol = i;
                
                }
                
                if( fBlankLine && !IS_BLANK( wRow, i ) ) {

                   fBlankLine = false;
                
                }
            
            }

            if( fBlankLine ) {
                
                POSITION_CURSOR( wRow, 0 );
                
                CursorEOL();

                coExpectedCursor.Y  = wRow;
                coExpectedCursor.X  = 0;
            
            } else if( iStartCol != -1 ) {
                
                if( wRow != coExpectedCursor.Y || iStartCol != coExpectedCursor.X ) {
                    
                    POSITION_CURSOR( wRow, iStartCol );

                    coExpectedCursor.X  = ( SHORT )iStartCol;
                    coExpectedCursor.Y  = wRow;
                
                }

                SEND_ROW( wRow, iStartCol, iEndCol+1 );    
            
                coExpectedCursor.X = ( SHORT ) ( coExpectedCursor.X + iEndCol - iStartCol + 1 );
           
            }    
        
        }
        
        ++wRow;            
    
    }     
        
    //
    // If we found a difference while doing the screen compares
    // or if the cursor moved in the console, 
    // then update the cursor position
    //
    if( DifferenceFound ||
        ( memcmp( &pCSBI->dwCursorPosition, &pLastCSBI->dwCursorPosition, sizeof( COORD ) ) != 0 ) 
        ) {

        do {

            //
            // Move the cursor to where it's supposed to be
            //
            POSITION_CURSOR( 
                pCSBI->dwCursorPosition.Y, 
                pCSBI->dwCursorPosition.X 
                );

            coExpectedCursor.X  = pCSBI->dwCursorPosition.X;
            coExpectedCursor.Y  = pCSBI->dwCursorPosition.Y;

            //
            // Copy pCurrent onto pLastSeen
            //
            memcpy( pLastSeen, pCurrent, wCols * wRows * sizeof( CHAR_INFO ) );
            memcpy( pLastCSBI, pCSBI, sizeof( CONSOLE_SCREEN_BUFFER_INFO ) );

            //
            // There is a difference between this screen and the last, 
            // so we have written the changes.  Now that we are done
            // writing the changes, we need to flush the data we've written.
            //
            m_IoHandler->Flush();
        
        } while ( FALSE );
    
    }

    return( bSuccess );
}

LPWSTR 
CVTUTF8Scraper::CursorMove( 
    OUT LPWSTR  pCmsResult,
    IN  WORD    y, 
    IN  WORD    x 
    )
/*++

Routine Description:

    This routine assembles an Ansi escape sequence to position
    the cursor on a Ansi terminal
    
Arguments:

    lpCmsResult   - on exit, buffer contains the string
    y               - the Y cursor position
    x               - the X cursor position           
          
Return Value:

    the pointer into the result buffer at the NULL 

--*/
{
#if DBG
    PWCHAR  pBegin;

    pBegin = pCmsResult;
#endif

    ASSERT(pCmsResult);

    //
    // Assemble the prefix sequence prefix
    //
    pCmsResult[0] = 0x1B;   // <esc>
    pCmsResult[1] = L'[';
    
    pCmsResult++;
    pCmsResult++;

    //
    // Translate the Y position
    //
    // 1 or 2 characters consumed
    // 
    pCmsResult = FastIToA_10( 
        y, 
        pCmsResult 
        );

    //
    // Insert the delimiter
    //
    *pCmsResult = L';';
    pCmsResult++;

    //
    // Translate the X position
    //
    // 1 or 2 characters consumed
    // 
    pCmsResult = FastIToA_10( 
        x,
        pCmsResult 
        );
    
    //
    // Insert the suffix
    //
    *pCmsResult = L'H';
    pCmsResult++;

    //
    // Terminate the string
    //
    *pCmsResult = UNICODE_NULL;
    
    //
    // make sure we have a valid string length
    //
    ASSERT(wcslen(pBegin) <= CM_STRING_LENGTH - 1);

    return ( pCmsResult );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\headless\cmd\sacsess\shell.cpp ===
/*++

Copyright (c) 1999-2001  Microsoft Corporation

Module Name:

    shell.cpp

Abstract:

    Class for creating a command console shell

Author:

    Brian Guarraci (briangu) 2001.

Revision History:

--*/

#include <cmnhdr.h>
#include <utils.h>
#include <Shell.h>
#include <Session.h>
 
//
// default shell
//
#define DEFAULT_SHELL  L"cmd.exe"

CShell::CShell()
/*++

Routine Description:

    Constructor              
                  
Arguments:

    None           
          
Return Value:

    N/A    

--*/
{
    m_hProcess      = NULL;
    m_bHaveProfile  = FALSE;                                         
    m_hProfile      = INVALID_HANDLE_VALUE;
    m_hWinSta       = NULL;
    m_hDesktop      = NULL;

}

CShell::~CShell()
/*++

Routine Description:

    Destructor              
                  
Arguments:

    N/A    
          
Return Value:

    N/A    

--*/
{
    NOTHING;    
}

BOOL 
CShell::StartUserSession (
    CSession    *session,
    HANDLE      hToken
    )
/*++

Routine Description:

    This routine launches the user-mode shell process, which
    will serve as the session process.

Arguments:

    session - the session to associate this process with
    hToken  - authenticated credentials to start the process with                                      
                                      
Return Value:

    TRUE    - the user-mode process was started successfully
    FALSE   - otherwise
                                                                     
--*/
{
    BOOL    bSuccess;

    //
    // Attempt to launch the shell process
    //
    bSuccess = StartProcess( hToken );
    ASSERT_STATUS(bSuccess, FALSE);

    //
    // Tell the session to wait on the process handle
    // This way, if the process exits, the session will
    // know about it.
    //
    session->AddHandleToWaitOn( m_hProcess );

    return( bSuccess );

}

BOOL
CShell::CreateIOHandles(
    OUT PHANDLE ConOut,
    OUT PHANDLE ConIn
    )
/*++

Routine Description:

    Allocate a new console and create the IO handles
    that will be used by the command console process

    Note: the console out handle created here is only
          valid for the screen buffer used by the command
          console process. If the user runs the an app
          which uses the CreateConsoleScreenBuffer and
          SetConsoleActiveScreenBuffer APIs, the scraper
          must create a new CONOUT$ handle to point to 
          the new screen buffer.

Arguments:

    ConOut   - the new console out handle
    ConIn    - the new console in handle
          
Return Value:

    TRUE    - the handles were created
    FALSE   - otherwise

--*/
{
    SECURITY_ATTRIBUTES sa;

    INHERITABLE_NULL_DESCRIPTOR_ATTRIBUTE( sa );
    
    //
    // default: we didnt open the stdio handles
    //
    *ConOut = INVALID_HANDLE_VALUE;
    *ConIn = INVALID_HANDLE_VALUE;

    //
    // We don't need to create a new console because
    // the process was created with CREATE_NEW_CONSOLE
    //

    //
    // Open the console input handle
    //
    *ConIn = CreateFile(
        L"CONIN$", 
        GENERIC_READ | GENERIC_WRITE, 
        0, 
        &sa, 
        OPEN_EXISTING, 
        FILE_ATTRIBUTE_NORMAL, 
        NULL 
        );
    ASSERT( *ConIn != INVALID_HANDLE_VALUE );
    if ( INVALID_HANDLE_VALUE == *ConIn) {
        goto ExitOnError;
    }

    //
    // Open the console output handle
    //
    *ConOut = CreateFile(
        L"CONOUT$", 
        GENERIC_READ | GENERIC_WRITE, 
        0, 
        &sa,
        OPEN_EXISTING, 
        FILE_ATTRIBUTE_NORMAL, 
        NULL 
        );
    ASSERT( *ConOut != INVALID_HANDLE_VALUE );
    if ( INVALID_HANDLE_VALUE == *ConOut ) {
        goto ExitOnError;
    }

    return(TRUE);

ExitOnError :    

    if (*ConOut != INVALID_HANDLE_VALUE) {
        CloseHandle(*ConOut);
    }
    if (*ConIn != INVALID_HANDLE_VALUE) {
        CloseHandle(*ConIn);
    }
    
    return( FALSE );
}

BOOL 
CShell::StartProcess (
    HANDLE  hToken
    )
/*++

Routine Description:

    This routine creates and initializes the shell process.  
    
    SECURITY: (dependencies)
        
        environmentblock    to get path of cmd.exe
            
        cmd.exe             the shell process
            
        CreateProcess...()  initiates shell process
            
        console             stdio pipes
    
        registry            determine:
         
                            1. if we should load profile
                            2. which create process method to use
        
        user profile        loaded and applied to user token
    
Arguments:

    hToken - if needed, the authenticated credentials to start the 
             process with.                              
          
Return Value:

    TRUE    - the process was started successfully
    FALSE   - otherwise                          

--*/
{
    STARTUPINFO         si;
    BOOL                bRetVal = TRUE;
    DWORD               dwExitCode = 0;
    BOOL                b;
    HANDLE              hStdError = INVALID_HANDLE_VALUE;
    HANDLE              hHandleToDuplicate = INVALID_HANDLE_VALUE;
    HANDLE              hConOut = INVALID_HANDLE_VALUE;
    HANDLE              hConIn = INVALID_HANDLE_VALUE;
    PTCHAR              pCmdBuf;
    BOOL                bHaveEnvironment;
    LPVOID              lpEnv;
    PWCHAR              DefaultShell = DEFAULT_SHELL;

    //
    // Allocate a new console and create the IO handles
    // that will be used by the command console process
    //
    b = CreateIOHandles(
        &hConOut,
        &hConIn
        );
    
    if (!b) {
        goto ExitOnError;
    }

    //
    // we want to use the console out as the std err
    //
    hHandleToDuplicate = hConOut;

    b = DuplicateHandle( 
        GetCurrentProcess(), 
        hHandleToDuplicate,
        GetCurrentProcess(), 
        &hStdError,
        0,
        TRUE, 
        DUPLICATE_SAME_ACCESS
        );
    
    if (!b) {
        hStdError = hConOut;
    }

    //
    // Restores normal processing of CTRL+C input,
    // (behavior is iherited by child process)
    //
    SetConsoleCtrlHandler( NULL, FALSE );

    //
    // If the admin/registry has specified that it is ok to load profiles,
    // the attempt to do so
    //
    if (IsLoadProfilesEnabled()) {
        
        //
        // Attempt to load the user's profile
        //    
        m_bHaveProfile = UtilLoadProfile(
            hToken, 
            &m_hProfile
            );

        //
        // Attempt to load the user's environment block
        //    
        bHaveEnvironment = UtilLoadEnvironment(
            hToken, 
            &lpEnv
            );
    
        if (!bHaveEnvironment) {
            lpEnv = NULL;
        }
        
    } else {

        //
        // nothing was loaded
        //
        lpEnv = NULL;
        bHaveEnvironment = FALSE;
        
        m_bHaveProfile = FALSE;
        
    }

    //
    // If the command console session requires authentication,
    // then create the cmd.exe process in the context that the
    // user authenticated in - otherwise, create the process
    // in the context that the service runs in.
    //
    if( NeedCredentials() ) {

        ASSERT( hToken != INVALID_HANDLE_VALUE);
        
        do {

            PROCESS_INFORMATION     pi;
            HWINSTA                 hOldWinSta;
            PWCHAR                  winStaName;

            //
            // We need to grant permission to the default desktop
            // 
            b = CreateSACSessionWinStaAndDesktop(
                hToken,
                &hOldWinSta,
                &m_hWinSta,
                &m_hDesktop,
                &winStaName
                );

            if (!b) {
                ASSERT(0);
                break;
            }

            do {

                //
                // configure the command console process startup
                // info to use the handles we want and other misc.
                // config details.
                //
                FillProcessStartupInfo( 
                    &si,
                    winStaName,
                    hConIn, 
                    hConOut, 
                    hStdError 
                    );

                //
                // get the pathname to the SAC session exe
                //
                pCmdBuf = GetPathOfTheExecutable();

                if (pCmdBuf == NULL) {
                    b = FALSE;
                    break;
                }

                //
                // Create the cmd.exe process as user referred by hToken
                //
                b = CreateProcessAsUser(
                    hToken,                     // HANDLE hToken
                    pCmdBuf,                    // application name
                    DefaultShell,               // command line
                    NULL,                       // process security descriptor
                    NULL,                       // thread security descriptor
                    TRUE,                       // handle inheritance?
                    CREATE_UNICODE_ENVIRONMENT | CREATE_SEPARATE_WOW_VDM, // creation flags
                    lpEnv,                      // environment block
                    NULL,                       // current directory
                    &si,                        // startup information
                    &pi );                      // process information

                //
                // NOTE: CreateProcessAsUser API Issue
                //
                // we must keep the handles to the desktop and window station
                // open until the cmd.exe process handle is signaled - the
                // process is closed.  The reason for this is that the
                // CreateProcessAsUser routine returns BEFORE the cmd.exe
                // process is fully initialized.  Hence, there are no
                // references to the winsta/desktop pair taken.  If we close
                // the handles they will be cleaned up because we are the only
                // reference.  The cmd.exe process will then try to reference
                // the winsta/desktop and fail because they are gone - it'll
                // get an "GDI out of resources" type message.  Typically,
                // with CreateProcessAsUser, you'd use WaitForProcessIdle to
                // ensure the process is initialized - you could then safely
                // close the handles to the winsta/desktop pair.  However,
                // for console apps, WaitForProcessIdle returns IMMEDIATELY.
                // Thus we are forced to hold the handles until we are sure
                // the process is doe with them.
                //

                //
                // release the executable path
                //
                delete [] pCmdBuf;

                if (!b) {
                    break;
                }

                //
                // Make sure the cmd.exe process didn't die
                //
                GetExitCodeProcess( pi.hProcess, &dwExitCode );

                if ( dwExitCode != STILL_ACTIVE ) {
                    b = FALSE;
                    bRetVal = FALSE;
                    break;
                }

                //
                // keep the handle to the cmd.exe process
                //
                m_hProcess = pi.hProcess;

                //
                // close the handle to the cmd.exe thread 
                //
                if (pi.hThread != INVALID_HANDLE_VALUE) {
                    CloseHandle( pi.hThread );
                }

            } while(FALSE);

            if (winStaName) {
                delete [] winStaName;
            }
            if (hOldWinSta) {
                SetProcessWindowStation(hOldWinSta);
            }
        } while ( FALSE );
        
    } else {
        
        do {

            PROCESS_INFORMATION pi;
            
            //
            // configure the command console process startup
            // info to use the handles we want and other misc.
            // config details.
            //
            FillProcessStartupInfo( 
                &si,
                L"winsta0\\default",
                hConIn, 
                hConOut, 
                hStdError 
                );

            //
            // get the pathname to the SAC session exe
            //
            pCmdBuf = GetPathOfTheExecutable();

            if (pCmdBuf == NULL) {
                b = FALSE;
                break;
            }

            //
            // Create the cmd.exe process as the same user running the service
            //
            b = CreateProcess(
                pCmdBuf,                    // application name
                DefaultShell,               // command line
                NULL,                       // process security descriptor
                NULL,                       // thread security descriptor
                TRUE,                       // handle inheritance?
                CREATE_UNICODE_ENVIRONMENT | CREATE_SEPARATE_WOW_VDM, // creation flags
                lpEnv,                      // environment block
                NULL,                       // current directory
                &si,                        // startup information
                &pi );                      // process information
        
            //
            // release the executable path
            //
            delete [] pCmdBuf;

            if (!b) {
                break;
            }

            //
            // Make sure the cmd.exe process didn't die
            //
            GetExitCodeProcess( pi.hProcess, &dwExitCode );

            if ( dwExitCode != STILL_ACTIVE ) {
                b = FALSE;
                bRetVal = FALSE;
                break;
            }

            //
            // keep the handle to the cmd.exe process
            //
            m_hProcess = pi.hProcess;

            //
            // close the handle to the cmd.exe thread 
            //
            if (pi.hThread != INVALID_HANDLE_VALUE) {
                CloseHandle( pi.hThread );
            }
        
        } while ( FALSE );
    
    }
    
    //
    // If we were able to load the user's environment,
    // then unload it
    //
    if (bHaveEnvironment) {

        UtilUnloadEnvironment((PVOID)lpEnv);

        bHaveEnvironment = FALSE;
        lpEnv = NULL;

    }

    //
    // Ignore ctrl+c input
    //
    SetConsoleCtrlHandler( NULL, TRUE );

    //
    // If we failed,
    // then cleanup
    //
    if( !b ) {
        bRetVal = FALSE;
        goto ExitOnError;
    }

    goto Done;

ExitOnError:
    
    //
    // If we were able to load the user's profile,
    // then unload it
    //
    if (m_bHaveProfile) {

        UtilUnloadProfile(
            hToken,
            m_hProfile
            );

        m_bHaveProfile = FALSE;

    }

Done:
    
    //
    // We don't need these handles anymore
    // 
    if ((hStdError != INVALID_HANDLE_VALUE) && (hStdError != hConOut)) {
        CloseHandle( hStdError );
    }
    if (hConIn != INVALID_HANDLE_VALUE) {
        CloseHandle( hConIn );
    }
    if (hConOut != INVALID_HANDLE_VALUE) {
        CloseHandle( hConOut );
    }
    
    return( bRetVal );
}

void 
CShell::Shutdown (
    VOID
    )
/*++

Routine Description:

    This routine cleans up the shell process.    
        
Arguments:

    None                                             
          
Return Value:

    None
        
--*/
{

    //
    // if we have started the cmd process,
    // then terminate it
    //
    if (m_hProcess != INVALID_HANDLE_VALUE) {
        
        HANDLE  hToken = INVALID_HANDLE_VALUE;
        BOOL    bHaveToken;
        
        //
        // Load the user token for the cmd process
        // so we can unload the profile and environment
        //
        bHaveToken = OpenProcessToken(
            m_hProcess,
            TOKEN_ALL_ACCESS,
            &hToken
            );
        
        //
        // terminate the cmd process
        //
        TerminateProcess(m_hProcess, 0); 
        
        //
        // we are done with the process
        //
        CloseHandle( m_hProcess ); 
    
        //
        // unroll user token settings
        //
        if (bHaveToken) {

            //
            // If we were able to load the user's profile,
            // then unload it
            //
            if (m_bHaveProfile) {
                
                UtilUnloadProfile(
                    hToken,
                    m_hProfile
                    );
            
                m_bHaveProfile = FALSE;

            }

            //
            // we are done with the token
            //
            if (hToken != INVALID_HANDLE_VALUE) {
                CloseHandle(hToken);
            }

        }
    
    }

    //
    // now that the cmd.exe process is done (or died)
    // we can close the desktop and winsta handles
    //
    if (m_hDesktop != NULL) {
        CloseDesktop(m_hDesktop);
    }
    if (m_hWinSta != NULL) {
        CloseWindowStation(m_hWinSta);
    }

}                

BOOL
CShell::IsLoadProfilesEnabled(
    VOID
    )

/*++

Routine Description:
                                   
    This routine determines if the profile loading behavior is enabled

Arguments:

    None.

Return Value:

    TRUE    - profile loading behavior is enabled
    FALSE   - otherwise              

--*/

{
    DWORD       rc;
    HKEY        hKey;
    DWORD       DWord;
    DWORD       dwsize;
    DWORD       DataType;

    //
    // See if the user gave us a registry key to disable the profile loading behavior
    //
    rc = RegOpenKeyEx( HKEY_LOCAL_MACHINE,
                       SACSVR_PARAMETERS_KEY,
                       0,
                       KEY_READ,
                       &hKey );
    
    if( rc == NO_ERROR ) {
        
        dwsize = sizeof(DWORD);
        
        rc = RegQueryValueEx(
                        hKey,
                        SACSVR_LOAD_PROFILES_DISABLED_VALUE,
                        NULL,
                        &DataType,
                        (LPBYTE)&DWord,
                        &dwsize );

        RegCloseKey( hKey );

        if ((rc == NO_ERROR) && 
            (DataType == REG_DWORD) && 
            (dwsize == sizeof(DWORD))
            ) {
            
            return DWord == 1 ? FALSE : TRUE;
        
        }
    
    }

    //
    // default: Loading profiles is enabled
    //
    return TRUE;

}

PTCHAR
CShell::GetPathOfTheExecutable(
    VOID
    )
/*++

Routine Description:

    Find out where the SAC session executable is located.

Arguments:

    NONE
                    
Return Value:

    Failure: NULL
    SUCCESS: pointer to path (caller must free)    

--*/
{
    PTCHAR  SystemDir;
    PTCHAR  pBuffer;
    ULONG   length;

    //
    // allocate the buffe we'll use to hold the system path
    //
    SystemDir = new TCHAR[MAX_PATH+1];

    //
    // default: we didnt create a new path
    //
    pBuffer = NULL;

    do {

        //
        // get the system path
        // 
        length = GetSystemDirectoryW(SystemDir, MAX_PATH+1);

        if (length == 0) {
            break;            
        }

        //
        // compute the length
        //
        length += 1; // backslash
        length += lstrlen(DEFAULT_SHELL);
        length += 1; // NULL termination

        //
        // allocate our new path
        //
        pBuffer = new TCHAR[length];

        if (pBuffer == NULL) {
            break;
        }

        //
        // create the path
        //
        wnsprintf(
            pBuffer,
            length,
            L"%s\\%s",
            SystemDir,
            DEFAULT_SHELL
            );

    } while ( FALSE );
    
    delete [] SystemDir;

    return pBuffer;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\headless\cmd\sacsvr\handler.c ===
#include "sacsvr.h"

SERVICE_STATUS          MyServiceStatus; 
SERVICE_STATUS_HANDLE   MyServiceStatusHandle; 

VOID 
MyServiceCtrlHandler (
                     DWORD Opcode
                     ) 
{ 
    DWORD status; 

    switch (Opcode) {
    case SERVICE_CONTROL_PAUSE: 
        MyServiceStatus.dwCurrentState = SERVICE_PAUSED; 
        break; 

    case SERVICE_CONTROL_CONTINUE: 
        MyServiceStatus.dwCurrentState = SERVICE_RUNNING; 
        break; 

    case SERVICE_CONTROL_STOP: 
    case SERVICE_CONTROL_SHUTDOWN: 

        MyServiceStatus.dwWin32ExitCode = 0; 
        MyServiceStatus.dwCurrentState  = SERVICE_STOP_PENDING; 
        MyServiceStatus.dwCheckPoint    = 0; 
        MyServiceStatus.dwWaitHint      = 0; 

        //
        // Notify the SCM that we are attempting to shutdown
        //
        if (!SetServiceStatus(MyServiceStatusHandle, &MyServiceStatus)) {
            status = GetLastError(); 
            SvcDebugOut(" [MY_SERVICE] SetServiceStatus error %ld\n",status); 
        }

        //
        // Service specific code goes here
        //
        // <<begin>>
        SvcDebugOut(" [MY_SERVICE] Stopping MyService \n",0); 
        Stop();
        SvcDebugOut(" [MY_SERVICE] Stopped MyService \n",0); 
        // <<end>>

        //
        // Notify the SCM that we are shutdown
        //
        MyServiceStatus.dwWin32ExitCode = 0; 
        MyServiceStatus.dwCurrentState  = SERVICE_STOPPED; 
        MyServiceStatus.dwCheckPoint    = 0; 
        MyServiceStatus.dwWaitHint      = 0; 

        SvcDebugOut(" [MY_SERVICE] Leaving MyService \n",0); 
        break; 

    case SERVICE_CONTROL_INTERROGATE: 
        // Fall through to send current status. 
        break; 

    default: 
        SvcDebugOut(" [MY_SERVICE] Unrecognized opcode %ld\n", Opcode); 
        break;
    } 

    // Send current status. 
    if (!SetServiceStatus (MyServiceStatusHandle,  &MyServiceStatus)) {
        status = GetLastError(); 
        SvcDebugOut(" [MY_SERVICE] SetServiceStatus error %ld\n",status); 
    }

    return; 
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\headless\cmd\sacsess\utils.cpp ===
/*++

Copyright (c) 1999-2001  Microsoft Corporation

Module Name:

    utils.cpp

Abstract:

    utility routines

Author:

    Brian Guarraci (briangu) 2001.

Revision History:


--*/

#include <TChar.h>
#include <stdlib.h>

#include "cmnhdr.h"
#include <utils.h>
#include <Sddl.h>
#include <Shlwapi.h>

#define SECURITY_WIN32

#include <security.h>
#include <secext.h>
                    
#define DESKTOP_ALL (DESKTOP_READOBJECTS        | \
                     DESKTOP_CREATEWINDOW       | \
                     DESKTOP_CREATEMENU         | \
                     DESKTOP_HOOKCONTROL        | \
                     DESKTOP_JOURNALRECORD      | \
                     DESKTOP_JOURNALPLAYBACK    | \
                     DESKTOP_ENUMERATE          | \
                     DESKTOP_WRITEOBJECTS       | \
                     DESKTOP_SWITCHDESKTOP      | \
                     STANDARD_RIGHTS_REQUIRED     \
                     )
#define WINSTA_ALL (WINSTA_ENUMDESKTOPS         | \
                    WINSTA_READATTRIBUTES       | \
                    WINSTA_ACCESSCLIPBOARD      | \
                    WINSTA_CREATEDESKTOP        | \
                    WINSTA_WRITEATTRIBUTES      | \
                    WINSTA_ACCESSGLOBALATOMS    | \
                    WINSTA_EXITWINDOWS          | \
                    WINSTA_ENUMERATE            | \
                    WINSTA_READSCREEN           | \
                    STANDARD_RIGHTS_REQUIRED      \
                    )
#define GENERIC_ACCESS (GENERIC_READ | GENERIC_WRITE | GENERIC_EXECUTE | GENERIC_ALL)
#define MAXDWORD (~(DWORD)0)

void
FillProcessStartupInfo( 
    IN OUT  STARTUPINFO *si, 
	IN		PWCHAR		desktopName,
	IN      HANDLE      hStdinPipe, 
    IN      HANDLE      hStdoutPipe,
    IN      HANDLE      hStdError 
    )
/*++

Routine Description:

    This routine populates the process startup info
    with the std I/O/error handles and other necessary
    elements for creating a cmd process to run under
    the session.

Arguments:

    si          - the STARTUPINFO structure
    hStdinPipe  - the standard input handle
    hStdoutPipe - the standard output handle
    hStdError   - the standard error handle
          
Return Value:

    None

--*/
{
    
    ASSERT( si != NULL );

    //
    // Initialize the SI
    //
    ZeroMemory(si, sizeof(STARTUPINFO));
    
    si->cb            = sizeof(STARTUPINFO);
    
    //
    // Populate the I/O Handles
    //
    si->dwFlags       = STARTF_USESTDHANDLES;
    si->hStdInput     = hStdinPipe;
    si->hStdOutput    = hStdoutPipe;
    si->hStdError     = hStdError;
    
    //
    // We need this when we create a process as a user
    // so that console i/o works.
    //
    si->lpDesktop      = desktopName;

    return;

}

bool
NeedCredentials(
    VOID
    )

/*++

Routine Description:

    This routine will detect if the user must give us credentials.
    
    If so, we return TRUE, if not, we'll return FALSE.

Arguments:

    None.

Return Value:

    TRUE  - The user must provide us some credentials.
    FALSE - The user doesn't need to give us any credentials.

Security:

    interface: registry

--*/

{
    DWORD       rc;
    HKEY        hKey;
    DWORD       DWord;
    DWORD       dwsize;
    DWORD       DataType;

    //
    // See if we're in Setup.  If so, then there's no need to ask
    // for any credentials.
    //
    rc = RegOpenKeyEx( HKEY_LOCAL_MACHINE,
                       L"System\\Setup",
                       0,
                       KEY_READ,
                       &hKey );
    
    if( rc == NO_ERROR ) {
        
        dwsize = sizeof(DWORD);
        
        rc = RegQueryValueEx(
                        hKey,
                        TEXT("SystemSetupInProgress"),
                        NULL,
                        &DataType,
                        (LPBYTE)&DWord,
                        &dwsize );

        RegCloseKey( hKey );

        if ((rc == NO_ERROR) && 
            (DataType == REG_DWORD) && 
            (dwsize == sizeof(DWORD))
            ) {
            
            if (DWord == 1) {
                return FALSE;
            }

        }

    }

    //
    // Default to returning that login credentials are required.
    //
    return TRUE;

}

BOOL 
GetLogonSID (
    IN  HANDLE  hToken, 
    OUT PSID    *ppsid
    ) 
/*++

Routine Description:

    This routine retrieves the SID of a given access token.

Arguments:

    hToken  - access token
    ppsid   - on success, contains the SID      

Return Value:

    Status    

--*/
{
    
    BOOL bSuccess = FALSE;
    DWORD dwIndex;
    DWORD dwLength = 0;
    PTOKEN_GROUPS ptg = NULL;

    //
    // Get required buffer size and allocate the TOKEN_GROUPS buffer.
    //
    if (!GetTokenInformation(
        hToken,         // handle to the access token
        TokenGroups,    // get information about the token's groups 
        (LPVOID) ptg,   // pointer to TOKEN_GROUPS buffer
        0,              // size of buffer
        &dwLength       // receives required buffer size
        )) {
        
        if (GetLastError() != ERROR_INSUFFICIENT_BUFFER) {
            goto Cleanup;
        }
    
        ptg = (PTOKEN_GROUPS)HeapAlloc(
            GetProcessHeap(),
            HEAP_ZERO_MEMORY, 
            dwLength);
    
        if (ptg == NULL) {
            goto Cleanup;
        }
    
    }

    //
    // Get the token group information from the access token.
    //
    if (!GetTokenInformation(
        hToken,         // handle to the access token
        TokenGroups,    // get information about the token's groups 
        (LPVOID) ptg,   // pointer to TOKEN_GROUPS buffer
        dwLength,       // size of buffer
        &dwLength       // receives required buffer size
        )) {
        goto Cleanup;
    }

    //
    // Loop through the groups to find the logon SID.
    //
    for (dwIndex = 0; dwIndex < ptg->GroupCount; dwIndex++) 
        
        if ((ptg->Groups[dwIndex].Attributes & SE_GROUP_LOGON_ID) == SE_GROUP_LOGON_ID) {
            
            // Found the logon SID; make a copy of it.

            dwLength = GetLengthSid(ptg->Groups[dwIndex].Sid);
            
            *ppsid = (PSID) HeapAlloc(
                GetProcessHeap(),
                HEAP_ZERO_MEMORY, 
                dwLength
                );
            
            if (*ppsid == NULL) {
                goto Cleanup;
            }
            
            if (!CopySid(dwLength, *ppsid, ptg->Groups[dwIndex].Sid)) {
            
                HeapFree(GetProcessHeap(), 0, (LPVOID)*ppsid);
            
                goto Cleanup;
            
            }
            
            break;
      
        }

    bSuccess = TRUE;

Cleanup: 

    // Free the buffer for the token groups.
    
    if (ptg != NULL) {
        HeapFree(GetProcessHeap(), 0, (LPVOID)ptg);
    }
    
    return bSuccess;
}

VOID 
FreeLogonSID (
    IN OUT PSID *ppsid
    ) 
/*++

Routine Description:

    Counterpart to GetLogonSID (Release the logon SID) 

Arguments:

    ppsid   - the sid to release


Return Value:

    None

--*/
{
    HeapFree(GetProcessHeap(), 0, (LPVOID)*ppsid);
}

DWORD
GetAndComputeTickCountDeltaT(
    IN DWORD    StartTick
    )
/*++

Routine Description:

    Determine how long it has been since the esc-ctrl-a sequence

Arguments:

    StartTick   - the timer tick at the beginning of the time-span      
          
Return Value:  

    The deltaT

--*/
{
    DWORD   TickCount;
    DWORD   DeltaT;
    
    //
    // get the current tick count to compare against the start tick cnt
    //
    TickCount = GetTickCount();
    
    //
    // Account for the tick count rollover every 49.7 days of system up time
    //
    if (TickCount < StartTick) {
        DeltaT = (~((DWORD)0) - StartTick) + TickCount;
    } else {
        DeltaT = TickCount - StartTick;
    }

    return DeltaT;
}

BOOL
NtGetUserName (
    OUT LPTSTR  *pUserName
    )
/*+++

Description:
    
    This routine calls the GetUserNameEx WIN32 call to get the
    SAM compatible user id of the user under which this process is running. The 
    user id is returned through a static buffer pUserName and must be freed by
    the caller.

Arguments:
    None

Return Values:
    None

Security:

    interface: system info

---*/
{
    BOOL    bSuccess;
    DWORD   dwError = 0;
    LPTSTR  wcUserIdBuffer;
    ULONG   ulUserIdBuffSize;

    //
    // default: the username pointer is NULL until success
    //
    *pUserName = NULL;

    //
    // default: reasonable initial size
    //
    ulUserIdBuffSize = 256;

    //
    // attempt to load the username
    // grow the username buffer if necessary
    //
    do {

        //
        // allocate the username buffer according
        // to the current attempt size
        //
        wcUserIdBuffer = new TCHAR[ulUserIdBuffSize];

        //
        // attempt to get the username
        //
        bSuccess = GetUserNameEx( 
            NameSamCompatible,
            wcUserIdBuffer,
            &ulUserIdBuffSize 
            );
        
        if ( !bSuccess ) {
        
            dwError = GetLastError();
            
            if ( dwError != STATUS_BUFFER_TOO_SMALL ) {
            
                delete [] wcUserIdBuffer;
                
                break;

            }

        } else {
        
            //
            // the username buffer is valid
            //
            *pUserName = wcUserIdBuffer;
            
            break;
        
        }
        
    } while ( dwError == STATUS_BUFFER_TOO_SMALL );

    return bSuccess;
}

BOOL
UtilLoadProfile(
    IN  HANDLE      hToken,
    OUT HANDLE      *hProfile
)   
/*++

Routine Description:

    This routine loads the profile and environment block for the specified
    user (hToken).  These operations are combined becuase we will always need
    to do both here.

    Note: the caller must call UtilUnloadProfile when done.
                    
Arguments:

    hToken      - the specified user's authenticated token
    hProfile    - on success, contains the user's profile handle 

Return Value:

    TRUE    - success
    FALSE   - otherwise

Security:

    interface: user profile api & DS

--*/
{
    LPTSTR          pwszUserName;
    BOOL            bSuccess;
    PROFILEINFO     ProfileInfo;

    if (hToken == INVALID_HANDLE_VALUE) {
        return FALSE;
    }

    if (hProfile == NULL) {
        ASSERT(0);
        return FALSE;
    }

    //
    //
    //
    *hProfile = INVALID_HANDLE_VALUE;

    //
    // default: unsuccussful
    //
    bSuccess = FALSE;

    __try {
        
        //
        // clear the profile handle
        //
        RtlZeroMemory(&ProfileInfo, sizeof(PROFILEINFO));

        do {

            //
            // Become the specified user so we can get the username
            //
            bSuccess = ImpersonateLoggedOnUser(hToken);
        
            if (!bSuccess) {
                break;
            }
        
            //
            // get the username for the profile
            //
            bSuccess = NtGetUserName(
                &pwszUserName
                );
        
            ASSERT(bSuccess);

            //
            // return to the previous state
            //
            if (!RevertToSelf() || !bSuccess || pwszUserName == NULL) {
                bSuccess = FALSE;
                break;
            }
        
            //
            // Populate the profile structure so that we can 
            // attempt to load the profile for the specified user
            //
            ProfileInfo.dwSize      = sizeof ( PROFILEINFO );
            ProfileInfo.dwFlags     = PI_NOUI;
            ProfileInfo.lpUserName  = pwszUserName;
        
            //
            // Load the profile
            //
            bSuccess = LoadUserProfile (
                hToken,
                &ProfileInfo
                );
        
            //
            // we are done with the username
            //
            delete[] pwszUserName;
        
            if (!bSuccess) {
                break;
            } 
        
            //
            // return the registry key handle 
            //
            *hProfile = ProfileInfo.hProfile;

        } while ( FALSE );
    
    }
    __except(EXCEPTION_EXECUTE_HANDLER) {
        bSuccess = FALSE;
    }

    return bSuccess;
}

BOOL
UtilLoadEnvironment(
    IN  HANDLE          hToken,
    OUT PVOID           *pchEnvBlock
    )   
/*++

Routine Description:

    This routine loads the environment block for the specified user (hToken).  

    Note: the caller must call UtilUnloadEnvironment when done.
                    
Arguments:

    hToken      - the specified user's authenticated token
    pchEnvBlock - on success, points to the env. block

Return Value:

    TRUE    - success
    FALSE   - otherwise

--*/
{
    BOOL            bSuccess;

    if (hToken == INVALID_HANDLE_VALUE) {
        return FALSE;
    }

    if (pchEnvBlock == NULL) {
        ASSERT(0);
        return FALSE;
    }

    //
    // default: unsuccussful
    //
    bSuccess = FALSE;

    __try {
        
        //
        // Load the user's environment block  
        //
        bSuccess = CreateEnvironmentBlock(
            (void**)pchEnvBlock, 
            hToken, 
            FALSE    
            );
    
        if (!bSuccess) {
        
            //
            // Ensure that the env. block ptr is NULL
            //
            *pchEnvBlock = NULL;
        
        }
    
    }
    __except(EXCEPTION_EXECUTE_HANDLER) {
        bSuccess = FALSE;
    }

    return bSuccess;
}

BOOL
UtilUnloadProfile(
    IN HANDLE   hToken,
    IN HANDLE   hProfile
)   
/*++

Routine Description:

    This routine unloads the profile the specified user (hToken).
                         
Arguments:

    hToken      - the specified user's authenticated token
    hProfile    - the profile handle to unload

Return Value:

    TRUE    - success
    FALSE   - otherwise

--*/
{
    BOOL            bSuccess;

    if (hToken == INVALID_HANDLE_VALUE) {
        return FALSE;
    }

    if (hProfile == INVALID_HANDLE_VALUE) {
        ASSERT(0);
        return FALSE;
    }

    //
    // default: unsuccussful
    //
    bSuccess = FALSE;

    __try {
        
        bSuccess = UnloadUserProfile(
            hToken,
            hProfile
            );

    }
    __except(EXCEPTION_EXECUTE_HANDLER) {
        bSuccess = FALSE;
    }

    return bSuccess;
}

 
BOOL
UtilUnloadEnvironment(
    IN PVOID    pchEnvBlock
)   
/*++

Routine Description:

    This routine unloads the environment block for the specified user.
                            
Arguments:

    pchEnvBlock - the env. block 

Return Value:

    TRUE    - success
    FALSE   - otherwise

--*/
{
    BOOL            bSuccess;

    if (pchEnvBlock == NULL) {
        ASSERT(0);
        return FALSE;
    }

    //
    // default: unsuccussful
    //
    bSuccess = FALSE;
                                            
    __try {
        
        bSuccess = DestroyEnvironmentBlock(pchEnvBlock);

    }
    __except(EXCEPTION_EXECUTE_HANDLER) {
        bSuccess = FALSE;
    }

    return bSuccess;
}

BOOL
BuildSACWinStaDesktopName(
	IN	PWCHAR	winStaName,
	OUT	PWCHAR	*desktopName
	)
/*++

Routine Description:


Arguments:


Return Value:

    Status                                     

Security:

--*/
{
	ULONG	l;
	PWSTR	postfix = L"Default";

	//
	// 
	//
	*desktopName = NULL;

	do {

		l  = lstrlen(winStaName);
		l += 1; // for backslash
		l += lstrlen(postfix);
		
		*desktopName = new WCHAR[l+1];

		wnsprintf(
			*desktopName,
			l+1,
			L"%s\\%s",
			winStaName,
			postfix
			);

	} while(FALSE);

	return TRUE;
}

BOOL
BuildSACWinStaName(
	OUT	PWCHAR	*winStaName
	)
/*++

Routine Description:

    Creates a winStaName.  This string is the concatenation of "SACWinSta"
    with the string version of a GUID generated in this function.

Arguments:

    winStaName - pointer to the address the windows station name will be
                 written.

Return Value:

    TRUE on success, FALSE otherwise.                              

Security:

--*/
{
	BOOL	   bSuccess = TRUE;
    RPC_STATUS rpcStatus;
	ULONG	   l;
	PWSTR	   prefix = L"SACWinSta";
    UUID       Uuid;
    LPWSTR     UuidString = NULL;

	//
	// 
	//
	*winStaName = NULL;

	do {

        //
        // Create a Uuid.  
        //
        rpcStatus = UuidCreate(&Uuid);

        if (rpcStatus != RPC_S_OK) {
            bSuccess = FALSE;
            break;
        }

        //
        // Create a string for the Uuid
        //
        rpcStatus = UuidToString(&Uuid, &UuidString);

        if (rpcStatus != RPC_S_OK) {
            bSuccess = FALSE;
            break;
        }


		//
        // Calculate the required length for the windows station name.
		//
		l  = lstrlen(prefix);
        l += lstrlen(UuidString); 

		//
		// Create the windows station name buffer
		//
		*winStaName = new WCHAR[l+1];

		//
		// "SACWinSta"UUID
		//
		wnsprintf(
			*winStaName,
			l+1,
			L"%s%s",
			prefix,
            UuidString
			);

		//
		// Convert the '-'s from the Uuid to alphanumeric characters.
		//
		for(ULONG i = 0; i < wcslen(*winStaName); i++) {
			if ((*winStaName)[i] == L'-') {
				(*winStaName)[i] = L'0';
			}
		}

        //
        // Free memory allocated by UuidToString
        //
        RpcStringFree(&UuidString);

	} while(FALSE);

	return bSuccess;
}

bool
CreateSACSessionWinStaAndDesktop(
    IN	HANDLE		hToken,
	OUT	HWINSTA		*hOldWinSta,
	OUT HWINSTA		*hWinSta,
	OUT	HDESK		*hDesktop,
	OUT	PWCHAR		*winStaName
)
/*++

Routine Description:

    This routine creates a window station and desktop pair for
	the user logging in.  The name of the winsta\desktop pair 
	is of the form:

	SACWinSta<Uuid>\Default

	The net result of this behavior is to have a unique window
	station for each sacsess.  Doing so mitigates any spoofing
    security risks.   

	NOTE: Only Admins (and higher) can create named window 
	stations, so name squatting is mitigated.

	We close the handles to the the window station and desktop
	after we are done with them so that when the last session
	exits, the winsta and desktop objects get automatically
	cleaned up.  This prevents us from having to garbage collect.

Arguments:

    hToken  - the user to grant access to                                                                         

Return Value:

    Status                                     

Security:

    interface: console

--*/
{
    bool                    bStatus = FALSE;
    BOOL                    bRetVal = FALSE;
    DWORD					dwErrCode = 0;
    PSID                    pSidAdministrators = NULL;
    PSID                    pSidUser = NULL;
    PSID                    pSidLocalSystem = NULL;
    int                     aclSize = 0;
    ULONG                   i;
    PACL                    newACL = NULL;
    SECURITY_DESCRIPTOR     sd;
    SECURITY_INFORMATION    si = DACL_SECURITY_INFORMATION;
    ACCESS_ALLOWED_ACE      *pace = NULL;
    SID_IDENTIFIER_AUTHORITY local_system_authority = SECURITY_NT_AUTHORITY;

	//
	//
	//
	*hOldWinSta = NULL;
	*hWinSta = NULL;
	*hDesktop = NULL;
	*winStaName = NULL;

	//
	//
	//
    *hOldWinSta = GetProcessWindowStation();
    if ( !*hOldWinSta )
    {
        goto ExitOnError;
    }

	//
    // Build administrators alias sid
    //
	if (! AllocateAndInitializeSid(
		&local_system_authority,
		2, /* there are only two sub-authorities */
		SECURITY_BUILTIN_DOMAIN_RID,
		DOMAIN_ALIAS_RID_ADMINS,
		0,0,0,0,0,0, /* Don't care about the rest */
		&pSidAdministrators
		))
    {
        goto ExitOnError;
    }

    //Build LocalSystem sid
    if (! AllocateAndInitializeSid(
		&local_system_authority,
		1, /* there is only two sub-authority */
		SECURITY_LOCAL_SYSTEM_RID,
		0,0,0,0,0,0,0, /* Don't care about the rest */
		&pSidLocalSystem
		))
    {
        goto ExitOnError;
    }

    //
    // Get the SID for the client's logon session.
    //
    if (!GetLogonSID(hToken, &pSidUser)) {
        goto ExitOnError;
    }

	//
    // Allocate size for 4 ACEs. 
	// We need to add one more InheritOnly ACE for the objects that 
	// get created under the WindowStation.
	//
	aclSize = sizeof(ACL) + 
		(4*sizeof(ACCESS_ALLOWED_ACE) - 4*sizeof(DWORD)) + 
		GetLengthSid(pSidAdministrators) + 
		2*GetLengthSid(pSidUser) + 
		GetLengthSid(pSidLocalSystem);

    newACL  = (PACL) new BYTE[aclSize];
    if (newACL == NULL)
    {
        goto ExitOnError;
    }

	//
	//
	//
    if (!InitializeAcl(newACL, aclSize, ACL_REVISION))
    {
        goto ExitOnError;
    }

	//
	//
	//
	pace = (ACCESS_ALLOWED_ACE *)HeapAlloc(
		GetProcessHeap(),
		HEAP_ZERO_MEMORY,
		sizeof(ACCESS_ALLOWED_ACE) + GetLengthSid(pSidUser) - sizeof(DWORD)
		);
    if (pace == NULL)
    {
        goto ExitOnError;
    }

	//
    // Create InheritOnly ACE. The objects ( like Desktop ) that get created 
	// under the WindowStation, will inherit these security Attributes.
    // This is done because we should not allow WRITE_DAC and few other permissions to all users.
    //
	pace->Header.AceType  = ACCESS_ALLOWED_ACE_TYPE;
    pace->Header.AceFlags = CONTAINER_INHERIT_ACE |
                            INHERIT_ONLY_ACE      |
                            OBJECT_INHERIT_ACE;
    pace->Header.AceSize  = sizeof(ACCESS_ALLOWED_ACE) +
                            (WORD)GetLengthSid(pSidUser) - 
							sizeof(DWORD);
    pace->Mask            = DESKTOP_ALL & ~(WRITE_DAC | WRITE_OWNER | DELETE);

	if (!CopySid(GetLengthSid(pSidUser), &pace->SidStart, pSidUser))
    {
        goto ExitOnError;
    }

	if (!AddAce(
		newACL,
		ACL_REVISION,
		MAXDWORD,
		(LPVOID)pace,
		pace->Header.AceSize
		))
    {
        goto ExitOnError;
    }
	if (!AddAccessAllowedAce(newACL, ACL_REVISION, WINSTA_ALL | GENERIC_ALL , pSidAdministrators))
    {
        goto ExitOnError;
    }
    if (!AddAccessAllowedAce(newACL, ACL_REVISION, WINSTA_ALL | GENERIC_ALL, pSidLocalSystem))
    {
        goto ExitOnError;
    }
	if (!AddAccessAllowedAce(newACL, 
		ACL_REVISION, 
		WINSTA_ALL & ~(WRITE_DAC | WRITE_OWNER | WINSTA_CREATEDESKTOP | DELETE), 
		pSidUser
		))
    {
        goto ExitOnError;
    }

	if ( !InitializeSecurityDescriptor(&sd, SECURITY_DESCRIPTOR_REVISION ) )
    {
        goto ExitOnError;
    }

    if ( !SetSecurityDescriptorDacl(&sd, TRUE, newACL, FALSE) )
    {
        goto ExitOnError;
    }


	//
	// Each sacsess will have it's own windows station.  Overwise there is a
    // spoofing security risk.  Each windows station has a unique name that
    // is generated below.  Using this name, we will attempt to create the
    // windows station.  The first time we successfully create a windowss 
    // station, break out of the loop.  Loop for more then the max
    // number of channels to mitigate denial of service because there was
    // a windows station opened by service other than us with a name we
    // requested.
    //
    for (i = 0; 
         (*hWinSta == NULL) && (i < MAX_CHANNEL_COUNT * MAX_CHANNEL_COUNT);
         i++) {
        
        //
        // Create the windows station name
        //
        if (BuildSACWinStaName(winStaName)) 
        {
            //
            // Attempt to create windows station. 
            //
            *hWinSta = CreateWindowStation( 
                *winStaName, 
                CWF_CREATE_ONLY,
                MAXIMUM_ALLOWED, 
                NULL
                );
        }        
    }

	if ( !*hWinSta )
    {
        goto ExitOnError;
    }

	if (!SetUserObjectSecurity(*hWinSta,&si,&sd))
    {
        goto ExitOnError;
    }

	bRetVal = SetProcessWindowStation( *hWinSta );
    if ( !bRetVal )
    {
        goto ExitOnError;
    }

	*hDesktop = CreateDesktop( 
		L"Default", 
		NULL, 
		NULL, 
		0, 
        MAXIMUM_ALLOWED, 
		NULL 
		);
    if ( *hDesktop == NULL )
    {
        goto ExitOnError;
    }

	{
		PWCHAR	temp;

		if (!BuildSACWinStaDesktopName(*winStaName,&temp)) 
		{
			goto ExitOnError;	
		}

		delete [] *winStaName;

		*winStaName = temp;

#if 0
		OutputDebugString(L"\n");
		OutputDebugString(*winStaName);
		OutputDebugString(L"\n");
#endif

	}

	bStatus = TRUE;
    goto Done;

ExitOnError:
    
	dwErrCode = GetLastError();

	if (*hOldWinSta) 
	{
		SetProcessWindowStation( *hOldWinSta );
	}
	if (*hWinSta)
	{
		CloseWindowStation(*hWinSta);
	}
	if (*hDesktop) 
	{
		CloseDesktop(*hDesktop);
	}

Done:
	if ( pSidAdministrators != NULL )
    {
        FreeSid (pSidAdministrators );
    }
    if ( pSidLocalSystem!= NULL )
    {
        FreeSid (pSidLocalSystem);
    }
    if ( pSidUser!= NULL )
    {
        FreeLogonSID (&pSidUser);
    }
	if (newACL) 
	{
        delete [] newACL;
	}
	if (pace) 
	{
        HeapFree(GetProcessHeap(), 0, (LPVOID)pace);
	}

	return( bStatus );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\headless\cmd\sacsess\vtutf8scraper.h ===
/*++

Copyright (c) 2001 Microsoft Corporation

Module Name:

    vtutf8scraper.h

Abstract:

    Define VT-UTF8 compatible screen scraper.

Author:

    Brian Guarraci (briangu), 2001                                         
                                                 
Revision History:

    (remotely based on scraper.cpp from telnet code)

--*/

#ifndef __VTUTF8_SCRAPER__H__
#define __VTUTF8_SCRAPER__H__

#include <iohandler.h>
#include <scraper.h>

#define VT_ESC              0x1B

#define CTRLC               0x03
#define CTRLA               0x01
#define CTRLQ               0x11
#define CTRLS               0x13
#define CTRLU               0x15

#define ESC                 '\033'

#define VS_ESCAPE           1
#define VS_O                24
#define VS_LEFT_BRACKET     26
#define VS_CONTROL          29
#define VS_SHIFT            54
#define VS_MENU             56
#define VS_F1               59
#define VS_F2               60
#define VS_F3               61
#define VS_F4               62
#define VS_F5               63
#define VS_F6               64
#define VS_F7               65
#define VS_F8               66
#define VS_F9               67
#define VS_F10              68
#define VS_PAUSE            70 
#define VS_HOME             71 
#define VS_UP               72
#define VS_PRIOR            73 
#define VS_LEFT             75
#define VS_RIGHT            77
#define VS_END              79 
#define VS_DOWN             80
#define VS_NEXT             81      
#define VS_INSERT           82 
#define VS_DELETE           83
#define VS_F11              87
#define VS_F12              88

//
// Length & size of buffer used to read from the channel
//
#define READ_BUFFER_LENGTH  2048
#define READ_BUFFER_SIZE    (READ_BUFFER_LENGTH*sizeof(WCHAR))

//
// Define the Process Enhanced Key parser states
//
enum {
    IP_INIT, 
    IP_ESC_RCVD,
    IP_ESC_BRACKET_RCVD,
    IP_ESC_CTRL_A_RCVD,
    IP_ESC_CTRL_A_ESC_RCVD,
    IP_ESC_CTRL_C_RCVD,
    IP_ESC_CTRL_S_RCVD
};

class CVTUTF8Scraper : public CScraper {

protected:

    CONSOLE_SCREEN_BUFFER_INFO CSBI;
    CONSOLE_SCREEN_BUFFER_INFO LastCSBI;

    PCHAR_INFO  pLastSeen;
    PCHAR_INFO  pCurrent;

    DWORD       m_dwInputSequenceState;
    DWORD       m_dwDigitInTheSeq;

    PWCHAR      m_readBuffer;

    inline BOOL
    CursorEOL(
        VOID
        )
    {
        return SendString(L"\033[K");
    }

    LPWSTR 
    CursorMove( 
        OUT LPWSTR  lpszCmsResult,
        IN  WORD    wHorPos, 
        IN  WORD    wVertPos 
        );
    
    inline PWCHAR
    FastIToA_10(
        IN ULONG    x,
        IN PWCHAR   Buffer
        )
    /*++
    
    Routine Description:
    
        This is equivalent to _itoa( x, Buffer, 10 );
        
        where 0 <= x <= 99
        
    Arguments:
    
        x       - the integer to translate
        Buffer  - the destination buffer              
                
    Return Value:
    
        The address of the buffer immediately after the last character
        produce as a result of this ItoA operation
                                        
    --*/
    {
        PWCHAR  AfterP;

        AfterP = Buffer + 2;

        switch (x) {
        
        case 0: Buffer[0] = L'0'; AfterP = Buffer + 1; break;
        case 1: Buffer[0] = L'1'; AfterP = Buffer + 1; break;
        case 2: Buffer[0] = L'2'; AfterP = Buffer + 1; break;
        case 3: Buffer[0] = L'3'; AfterP = Buffer + 1; break;
        case 4: Buffer[0] = L'4'; AfterP = Buffer + 1; break;
        case 5: Buffer[0] = L'5'; AfterP = Buffer + 1; break;
        case 6: Buffer[0] = L'6'; AfterP = Buffer + 1; break;
        case 7: Buffer[0] = L'7'; AfterP = Buffer + 1; break;
        case 8: Buffer[0] = L'8'; AfterP = Buffer + 1; break;
        case 9: Buffer[0] = L'9'; AfterP = Buffer + 1; break;

        case 10: Buffer[1] = L'0'; Buffer[0] = L'1'; break;
        case 11: Buffer[1] = L'1'; Buffer[0] = L'1'; break;
        case 12: Buffer[1] = L'2'; Buffer[0] = L'1'; break;
        case 13: Buffer[1] = L'3'; Buffer[0] = L'1'; break;
        case 14: Buffer[1] = L'4'; Buffer[0] = L'1'; break;
        case 15: Buffer[1] = L'5'; Buffer[0] = L'1'; break;
        case 16: Buffer[1] = L'6'; Buffer[0] = L'1'; break;
        case 17: Buffer[1] = L'7'; Buffer[0] = L'1'; break;
        case 18: Buffer[1] = L'8'; Buffer[0] = L'1'; break;
        case 19: Buffer[1] = L'9'; Buffer[0] = L'1'; break;

        case 20: Buffer[1] = L'0'; Buffer[0] = L'2'; break;
        case 21: Buffer[1] = L'1'; Buffer[0] = L'2'; break;
        case 22: Buffer[1] = L'2'; Buffer[0] = L'2'; break;
        case 23: Buffer[1] = L'3'; Buffer[0] = L'2'; break;
        case 24: Buffer[1] = L'4'; Buffer[0] = L'2'; break;
        case 25: Buffer[1] = L'5'; Buffer[0] = L'2'; break;
        case 26: Buffer[1] = L'6'; Buffer[0] = L'2'; break;
        case 27: Buffer[1] = L'7'; Buffer[0] = L'2'; break;
        case 28: Buffer[1] = L'8'; Buffer[0] = L'2'; break;
        case 29: Buffer[1] = L'9'; Buffer[0] = L'2'; break;

        case 30: Buffer[1] = L'0'; Buffer[0] = L'3'; break;
        case 31: Buffer[1] = L'1'; Buffer[0] = L'3'; break;
        case 32: Buffer[1] = L'2'; Buffer[0] = L'3'; break;
        case 33: Buffer[1] = L'3'; Buffer[0] = L'3'; break;
        case 34: Buffer[1] = L'4'; Buffer[0] = L'3'; break;
        case 35: Buffer[1] = L'5'; Buffer[0] = L'3'; break;
        case 36: Buffer[1] = L'6'; Buffer[0] = L'3'; break;
        case 37: Buffer[1] = L'7'; Buffer[0] = L'3'; break;
        case 38: Buffer[1] = L'8'; Buffer[0] = L'3'; break;
        case 39: Buffer[1] = L'9'; Buffer[0] = L'3'; break;

        case 40: Buffer[1] = L'0'; Buffer[0] = L'4'; break;
        case 41: Buffer[1] = L'1'; Buffer[0] = L'4'; break;
        case 42: Buffer[1] = L'2'; Buffer[0] = L'4'; break;
        case 43: Buffer[1] = L'3'; Buffer[0] = L'4'; break;
        case 44: Buffer[1] = L'4'; Buffer[0] = L'4'; break;
        case 45: Buffer[1] = L'5'; Buffer[0] = L'4'; break;
        case 46: Buffer[1] = L'6'; Buffer[0] = L'4'; break;
        case 47: Buffer[1] = L'7'; Buffer[0] = L'4'; break;
        case 48: Buffer[1] = L'8'; Buffer[0] = L'4'; break;
        case 49: Buffer[1] = L'9'; Buffer[0] = L'4'; break;

        case 50: Buffer[1] = L'0'; Buffer[0] = L'5'; break;
        case 51: Buffer[1] = L'1'; Buffer[0] = L'5'; break;
        case 52: Buffer[1] = L'2'; Buffer[0] = L'5'; break;
        case 53: Buffer[1] = L'3'; Buffer[0] = L'5'; break;
        case 54: Buffer[1] = L'4'; Buffer[0] = L'5'; break;
        case 55: Buffer[1] = L'5'; Buffer[0] = L'5'; break;
        case 56: Buffer[1] = L'6'; Buffer[0] = L'5'; break;
        case 57: Buffer[1] = L'7'; Buffer[0] = L'5'; break;
        case 58: Buffer[1] = L'8'; Buffer[0] = L'5'; break;
        case 59: Buffer[1] = L'9'; Buffer[0] = L'5'; break;

        case 60: Buffer[1] = L'0'; Buffer[0] = L'6'; break;
        case 61: Buffer[1] = L'1'; Buffer[0] = L'6'; break;
        case 62: Buffer[1] = L'2'; Buffer[0] = L'6'; break;
        case 63: Buffer[1] = L'3'; Buffer[0] = L'6'; break;
        case 64: Buffer[1] = L'4'; Buffer[0] = L'6'; break;
        case 65: Buffer[1] = L'5'; Buffer[0] = L'6'; break;
        case 66: Buffer[1] = L'6'; Buffer[0] = L'6'; break;
        case 67: Buffer[1] = L'7'; Buffer[0] = L'6'; break;
        case 68: Buffer[1] = L'8'; Buffer[0] = L'6'; break;
        case 69: Buffer[1] = L'9'; Buffer[0] = L'6'; break;
        
        case 70: Buffer[1] = L'0'; Buffer[0] = L'7'; break;
        case 71: Buffer[1] = L'1'; Buffer[0] = L'7'; break;
        case 72: Buffer[1] = L'2'; Buffer[0] = L'7'; break;
        case 73: Buffer[1] = L'3'; Buffer[0] = L'7'; break;
        case 74: Buffer[1] = L'4'; Buffer[0] = L'7'; break;
        case 75: Buffer[1] = L'5'; Buffer[0] = L'7'; break;
        case 76: Buffer[1] = L'6'; Buffer[0] = L'7'; break;
        case 77: Buffer[1] = L'7'; Buffer[0] = L'7'; break;
        case 78: Buffer[1] = L'8'; Buffer[0] = L'7'; break;
        case 79: Buffer[1] = L'9'; Buffer[0] = L'7'; break;

        case 80: Buffer[1] = L'0'; Buffer[0] = L'8'; break;
        case 81: Buffer[1] = L'1'; Buffer[0] = L'8'; break;
        case 82: Buffer[1] = L'2'; Buffer[0] = L'8'; break;
        case 83: Buffer[1] = L'3'; Buffer[0] = L'8'; break;
        case 84: Buffer[1] = L'4'; Buffer[0] = L'8'; break;
        case 85: Buffer[1] = L'5'; Buffer[0] = L'8'; break;
        case 86: Buffer[1] = L'6'; Buffer[0] = L'8'; break;
        case 87: Buffer[1] = L'7'; Buffer[0] = L'8'; break;
        case 88: Buffer[1] = L'8'; Buffer[0] = L'8'; break;
        case 89: Buffer[1] = L'9'; Buffer[0] = L'8'; break;

        case 90: Buffer[1] = L'0'; Buffer[0] = L'9'; break;
        case 91: Buffer[1] = L'1'; Buffer[0] = L'9'; break;
        case 92: Buffer[1] = L'2'; Buffer[0] = L'9'; break;
        case 93: Buffer[1] = L'3'; Buffer[0] = L'9'; break;
        case 94: Buffer[1] = L'4'; Buffer[0] = L'9'; break;
        case 95: Buffer[1] = L'5'; Buffer[0] = L'9'; break;
        case 96: Buffer[1] = L'6'; Buffer[0] = L'9'; break;
        case 97: Buffer[1] = L'7'; Buffer[0] = L'9'; break;
        case 98: Buffer[1] = L'8'; Buffer[0] = L'9'; break;
        case 99: Buffer[1] = L'9'; Buffer[0] = L'9'; break;

        default: 
            ASSERT(0); 
            //
            // put the cursor at some safe location
            //
            Buffer[0] = L'0';
            Buffer[1] = L'0';
            break;
        }

        return AfterP;
    }
    
    BOOL    InitScraper( VOID );
    
    void    ResetLastScreen(VOID);
    
    BOOL    CreateIOHandles(VOID);
    BOOL    CreateConsoleOutHandle(VOID);
    BOOL    CreateConsoleInHandle(VOID);
    BOOL
    CreateIOHandle(
        IN  PWCHAR   HandleName,
        OUT PHANDLE  pHandle
        );


    inline BOOL
    SendChar( 
        IN WCHAR    ch
        )
    {
        return SendBytes( ( PUCHAR )&ch, sizeof(WCHAR) );
    }

    BOOL    
    SendString( 
        PWCHAR 
        );
    
    BOOL    
    SendBytes( 
        PUCHAR, 
        DWORD 
        );
    
    BOOL    
    SendColorInfo( 
        WORD 
        );

    BOOL    
    SetWindowInfo(
        VOID
        );
    
    BOOL    
    SetScreenBufferInfo(
        VOID
        );

    BOOL    
    ProcessEnhancedKeys(
        IN WCHAR
        );
    
    BOOL    
    IsValidControlSequence(
        VOID
        );
    
    DWORD   
    WriteAKeyToCMD( 
        WCHAR 
        );
    
    DWORD   
    WriteAKeyToCMD( 
        WORD, 
        WORD, 
        WCHAR, 
        DWORD 
        );
    
    DWORD 
    WriteAKeyToCMD( 
        BOOL    bKeyDown,
        WORD    wVKCode, 
        WORD    wVSCode, 
        WCHAR   Char, 
        DWORD   dwCKState 
        );

    BOOL 
    CompareAndUpdate(
        WORD,
        WORD,
        PCHAR_INFO, 
        PCHAR_INFO,
        PCONSOLE_SCREEN_BUFFER_INFO,
        PCONSOLE_SCREEN_BUFFER_INFO
        );

private: 

    //
    // Don't let this construct be called directly
    //
    CVTUTF8Scraper();

public:
    
    BOOL    Start( VOID );
    BOOL    Write( VOID );
    BOOL    Read( VOID );
    BOOL    DisplayFullScreen(VOID);
    
    CVTUTF8Scraper(
        CIoHandler  *IoHandler,
        WORD        wCols,
        WORD        wRows
        );
    
    virtual ~CVTUTF8Scraper();

};

#endif __VTUTF8_SCRAPER__H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\headless\cmd\sacsvr\main.c ===
#include "sacsvr.h"
#include "sacmsg.h"

#define SACSVR_SERVICE_KEY  L"System\\CurrentControlSet\\Services\\SacSvr"
#define SACSVR_PARAMETERS_KEY  L"System\\CurrentControlSet\\Services\\SacSvr\\Parameters"
#define SVCHOST_LOCATION    L"Software\\Microsoft\\Windows NT\\CurrentVersion\\Svchost"
#define SERVICE_NAME        L"sacsvr"
#define SERVICE_IMAGEPATH   L"%SystemRoot%\\System32\\svchost.exe -k "
#define SERVICE_DLL         L"%SystemRoot%\\System32\\sacsvr.dll"
#define SVCHOST_GROUP       L"netsvcs"
#define SERVICE_OBJECTNAME  L"LocalSystem"

SERVICE_STATUS          MyServiceStatus; 
SERVICE_STATUS_HANDLE   MyServiceStatusHandle; 

VOID  
MyServiceStart(
    DWORD   argc, 
    LPTSTR  *argv
    ); 
VOID  
MyServiceCtrlHandler(
    DWORD opcode
    );

DWORD 
MyServiceInitialization(
    DWORD   argc, 
    LPTSTR  *argv, 
    DWORD   *specificError
    ); 

void WINAPI
ServiceMain(
    DWORD   argc,
    LPTSTR  *argv
    ) 
{ 
    DWORD status; 

    UNREFERENCED_PARAMETER(argc);
    UNREFERENCED_PARAMETER(argv);

    MyServiceStatus.dwServiceType        = SERVICE_WIN32; 
    MyServiceStatus.dwCurrentState       = SERVICE_START_PENDING; 
    MyServiceStatus.dwControlsAccepted   = SERVICE_ACCEPT_STOP | SERVICE_ACCEPT_PAUSE_CONTINUE; 
    MyServiceStatus.dwWin32ExitCode      = 0; 
    MyServiceStatus.dwServiceSpecificExitCode = 0; 
    MyServiceStatus.dwCheckPoint         = 0; 
    MyServiceStatus.dwWaitHint           = 3000; 

    MyServiceStatusHandle = RegisterServiceCtrlHandler(
        L"sacsvr", 
        MyServiceCtrlHandler
        ); 

    if (MyServiceStatusHandle == (SERVICE_STATUS_HANDLE)0) {
        SvcDebugOut(" [MY_SERVICE] RegisterServiceCtrlHandler failed %d\n", GetLastError()); 
        return; 
    }

    // Initialization complete - report running status. 
    MyServiceStatus.dwCurrentState       = SERVICE_RUNNING;
    MyServiceStatus.dwCheckPoint         = 0; 
    MyServiceStatus.dwWaitHint           = 0; 

    if (!SetServiceStatus (MyServiceStatusHandle, &MyServiceStatus)) {
        status = GetLastError(); 
        SvcDebugOut(" [MY_SERVICE] SetServiceStatus error %ld\n",status); 
    }

    //
    // Service specific code goes here
    //
    Run();

    // Service complete - report running status. 
    MyServiceStatus.dwCurrentState       = SERVICE_STOPPED;
    
    if (!SetServiceStatus (MyServiceStatusHandle, &MyServiceStatus)) {
        status = GetLastError(); 
        SvcDebugOut(" [MY_SERVICE] SetServiceStatus error %ld\n",status); 
    }
    
    return; 
} 

VOID SvcDebugOut(LPSTR String, DWORD Status) 
{ 
#if 0
    CHAR  Buffer[1024]; 
    if (strlen(String) < 1000) {
        sprintf(Buffer, String, Status); 
        OutputDebugStringA(Buffer); 
        printf("%s", Buffer); 
    }
#else
    UNREFERENCED_PARAMETER(String);
    UNREFERENCED_PARAMETER(Status);
#endif
} 

BOOL
pStartService(
    IN PCWSTR ServiceName
    )
{
    SC_HANDLE hSC,hSCService;
    BOOL b = FALSE;

    //
    // Open a handle to the service controller manager
    //
    hSC = OpenSCManager(NULL,NULL,SC_MANAGER_ALL_ACCESS);
    if(hSC == NULL) {
        return(FALSE);
    }
    
    hSCService = OpenService(hSC,ServiceName,SERVICE_START);

    if(hSCService) {
        b = StartService(hSCService,0,NULL);
        if(!b && (GetLastError() == ERROR_SERVICE_ALREADY_RUNNING)) {
            //
            // Service is already running.
            //
            b = TRUE;
        }
    }
        
    CloseServiceHandle(hSC);

    return(b);
}

BOOL 
LoadStringResource(
    IN  PUNICODE_STRING pUnicodeString,
    IN  INT             MsgId
    )
/*++

Routine Description:

    This is a simple implementation of LoadString().

Arguments:

    usString        - Returns the resource string.
    MsgId           - Supplies the message id of the resource string.
  
Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{

    NTSTATUS        Status;
    PMESSAGE_RESOURCE_ENTRY MessageEntry;
    ANSI_STRING     AnsiString;
    HANDLE          myHandle = 0;

    myHandle = GetModuleHandle((LPWSTR)L"sacsvr.dll");
    if( !myHandle ) {
        return FALSE;
    }

    Status = RtlFindMessage( myHandle,
                             (ULONG_PTR) RT_MESSAGETABLE, 
                             0,
                             (ULONG)MsgId,
                             &MessageEntry
                           );

    if (!NT_SUCCESS( Status )) {
        return FALSE;
    }

    if (!(MessageEntry->Flags & MESSAGE_RESOURCE_UNICODE)) {
        RtlInitAnsiString( &AnsiString, (PCSZ)&MessageEntry->Text[ 0 ] );
        Status = RtlAnsiStringToUnicodeString( pUnicodeString, &AnsiString, TRUE );
        if (!NT_SUCCESS( Status )) {
            return FALSE;
        }
    } else {
        RtlCreateUnicodeString(pUnicodeString, (PWSTR)MessageEntry->Text);
    }

    return TRUE;
}


STDAPI
DllRegisterServer(
    VOID
    )
/*++

Routine Description:

    Add entries to the system registry.

Arguments:

    NONE

Return Value:

    S_OK if everything went okay.
    
--*/

{
    UNICODE_STRING UnicodeString = {0};
    HKEY        hKey = INVALID_HANDLE_VALUE;
    PWSTR       Data = NULL;
    PWSTR       p = NULL;
    HRESULT     ReturnValue = S_OK;
    ULONG       dw, Size, Type, BufferSize, dwDisposition;
    BOOLEAN     ServiceAlreadyPresent;
    HANDLE      Handle = INVALID_HANDLE_VALUE;
    NTSTATUS    Status;
    OBJECT_ATTRIBUTES ObjectAttributes;
    IO_STATUS_BLOCK StatusBlock;
    UINT        OldMode;

    //
    // See if the machine is running headless right now.
    //
    RtlInitUnicodeString(&UnicodeString,L"\\Device\\SAC");
    InitializeObjectAttributes(
        &ObjectAttributes,
        &UnicodeString,
        OBJ_CASE_INSENSITIVE,
        NULL,
        NULL
        );

    OldMode = SetErrorMode(SEM_FAILCRITICALERRORS);
    Status = NtCreateFile(
        &Handle,
        FILE_READ_ATTRIBUTES,
        &ObjectAttributes,
        &StatusBlock,
        NULL,
        FILE_ATTRIBUTE_NORMAL,
        FILE_SHARE_READ,
        FILE_OPEN,
        0,
        NULL,
        0
        );
    SetErrorMode(OldMode);
    CloseHandle(Handle);
    if (!NT_SUCCESS(Status)) {
        return S_OK;
    }

    //
    // Add our entry into HKLM\Software\Microsoft\Windows NT\CurrentVersion\Svchost\<SVCHOST_GROUP>
    //
    dw = RegOpenKeyEx( HKEY_LOCAL_MACHINE,
                       SVCHOST_LOCATION,
                       0,
                       KEY_ALL_ACCESS,                       
                       &hKey );
    if( dw != ERROR_SUCCESS ) {
        ReturnValue = E_UNEXPECTED;
        goto DllRegisterServer_Exit;
    }

    Size = 0;
    dw = RegQueryValueEx( hKey,
                          SVCHOST_GROUP,
                          NULL,
                          &Type,
                          NULL,
                          &Size );
    if( (dw != ERROR_SUCCESS) || (Size == 0) ) {
        ReturnValue = E_UNEXPECTED;
        goto DllRegisterServer_Exit;
    }

    //
    // allocate a new buffer to hold the list + possobly the new
    // sacsvr entry (we may not need it)
    //
    BufferSize = Size + (ULONG)((wcslen(SERVICE_NAME) + 1) * sizeof(WCHAR));
    Data = malloc(BufferSize);
    if (Data == NULL) {
        ReturnValue = E_OUTOFMEMORY;
        goto DllRegisterServer_Exit;
    }

    dw = RegQueryValueEx( hKey,
                          SVCHOST_GROUP,
                          NULL,
                          &Type,
                          (LPBYTE)Data,
                          &Size );
    if( (dw != ERROR_SUCCESS) || (Size == 0) ) {
        ReturnValue = E_UNEXPECTED;
        goto DllRegisterServer_Exit;
    }

    //
    // Do we need to add our entry?
    //
    p = Data;
    ServiceAlreadyPresent = FALSE;
    while( (*p != '\0') && (p < (Data+(Size/sizeof(WCHAR)))) ) {
        if( !_wcsicmp( p, SERVICE_NAME ) ) {
            ServiceAlreadyPresent = TRUE;
            break;
        }
        p += wcslen(p);
        p++;
    }

    if( !ServiceAlreadyPresent ) {
        //
        // Jump to the end of our buffer, append our service,
        // double-terminate the MULTI_SZ structure, then write
        // it all back out.
        //
        p = Data + (Size/sizeof(WCHAR));
        p--;
        wcscpy( p, SERVICE_NAME );
        p = p + wcslen(SERVICE_NAME);
        p++;
        *p = L'\0';
    
        dw = RegSetValueEx( hKey,
                            SVCHOST_GROUP,
                            0,
                            Type,
                            (LPBYTE)Data,
                            BufferSize );
        
        if( (dw != ERROR_SUCCESS) || (Size == 0) ) {
            ReturnValue = E_UNEXPECTED;
            goto DllRegisterServer_Exit;
        }
    }

    free( Data );
    Data = NULL;
    
    RegCloseKey( hKey );
    hKey = INVALID_HANDLE_VALUE;

    //
    // Create/populate the sacsvr key under HKLM\System\CCS\Service
    //
    dw = RegCreateKeyEx( HKEY_LOCAL_MACHINE,
                         SACSVR_SERVICE_KEY,
                         0,
                         NULL,
                         REG_OPTION_NON_VOLATILE,
                         KEY_WRITE,
                         NULL,
                         &hKey,
                         &dwDisposition );
    if( dw != ERROR_SUCCESS ) {
        ReturnValue = E_UNEXPECTED;
        goto DllRegisterServer_Exit;
    }

    //
    // Description Value.
    //
    if( LoadStringResource(&UnicodeString, SERVICE_DESCRIPTION) ) {

        //
        // Terminate the string at the %0 marker, if it is present
        //
        if( wcsstr( UnicodeString.Buffer, L"%0" ) ) {
            *((PWCHAR)wcsstr( UnicodeString.Buffer, L"%0" )) = L'\0';
        }
    } else {
        ReturnValue = E_UNEXPECTED;
        goto DllRegisterServer_Exit;
    }
    
    dw = RegSetValueEx( hKey,
                        L"Description",
                        0,
                        REG_SZ,
                        (LPBYTE)UnicodeString.Buffer,
                        (ULONG)(wcslen( UnicodeString.Buffer) * sizeof(WCHAR) ));
    if( dw != ERROR_SUCCESS ) {
        ReturnValue = E_UNEXPECTED;
        goto DllRegisterServer_Exit;
    }

    //
    // Display Value.
    //
    if( LoadStringResource(&UnicodeString, SERVICE_DISPLAY_NAME) ) {

        //
        // Terminate the string at the %0 marker, if it is present
        //
        if( wcsstr( UnicodeString.Buffer, L"%0" ) ) {
            *((PWCHAR)wcsstr( UnicodeString.Buffer, L"%0" )) = L'\0';
        }
    } else {
        ReturnValue = E_UNEXPECTED;
        goto DllRegisterServer_Exit;
    }
    
    dw = RegSetValueEx( hKey,
                        L"DisplayName",
                        0,
                        REG_SZ,
                        (LPBYTE)UnicodeString.Buffer,
                        (ULONG)(wcslen( UnicodeString.Buffer) * sizeof(WCHAR) ));
    if( dw != ERROR_SUCCESS ) {
        ReturnValue = E_UNEXPECTED;
        goto DllRegisterServer_Exit;
    }

    //
    // ErrorControl.
    //
    Size = 1;
    dw = RegSetValueEx( hKey,
                        L"ErrorControl",
                        0,
                        REG_DWORD,
                        (LPBYTE)&Size,
                        sizeof(DWORD) );
    if( dw != ERROR_SUCCESS ) {
        ReturnValue = E_UNEXPECTED;
        goto DllRegisterServer_Exit;
    }

    //
    // ImagePath
    //
    dw = RegSetValueEx( hKey,
                        L"ImagePath",
                        0,
                        REG_EXPAND_SZ,
                        (LPBYTE)(SERVICE_IMAGEPATH SVCHOST_GROUP),
                        (ULONG)(wcslen(SERVICE_IMAGEPATH SVCHOST_GROUP) * sizeof(WCHAR) ));
    if( dw != ERROR_SUCCESS ) {
        ReturnValue = E_UNEXPECTED;
        goto DllRegisterServer_Exit;
    }

    //
    // ObjectName
    //
    dw = RegSetValueEx( hKey,
                        L"ObjectName",
                        0,
                        REG_SZ,
                        (LPBYTE)SERVICE_OBJECTNAME,
                        (ULONG)(wcslen(SERVICE_OBJECTNAME) * sizeof(WCHAR) ));
    if( dw != ERROR_SUCCESS ) {
        ReturnValue = E_UNEXPECTED;
        goto DllRegisterServer_Exit;
    }

    //
    // Start
    //
    Size = 2;
    dw = RegSetValueEx( hKey,
                        L"Start",
                        0,
                        REG_DWORD,
                        (LPBYTE)&Size,
                        sizeof(DWORD) );
    if( dw != ERROR_SUCCESS ) {
        ReturnValue = E_UNEXPECTED;
        goto DllRegisterServer_Exit;
    }

    //
    // Type
    //
    Size = 32;
    dw = RegSetValueEx( hKey,
                        L"Type",
                        0,
                        REG_DWORD,
                        (LPBYTE)&Size,
                        sizeof(DWORD) );
    if( dw != ERROR_SUCCESS ) {
        ReturnValue = E_UNEXPECTED;
        goto DllRegisterServer_Exit;
    }

    RegCloseKey( hKey );
    hKey = INVALID_HANDLE_VALUE;

    //
    // Create/populate the Parameters key under HKLM\System\CCS\Service\sacsvr
    //
    dw = RegCreateKeyEx( HKEY_LOCAL_MACHINE,
                         SACSVR_PARAMETERS_KEY,
                         0,
                         NULL,
                         REG_OPTION_NON_VOLATILE,
                         KEY_WRITE,
                         NULL,
                         &hKey,
                         &dwDisposition );
    if( dw != ERROR_SUCCESS ) {
        ReturnValue = E_UNEXPECTED;
        goto DllRegisterServer_Exit;
    }

    //
    // ServiceDll
    //
    dw = RegSetValueEx( hKey,
                        L"ServiceDll",
                        0,
                        REG_EXPAND_SZ,
                        (LPBYTE)SERVICE_DLL,
                        (ULONG)(wcslen( SERVICE_DLL) * sizeof(WCHAR) ));
    if( dw != ERROR_SUCCESS ) {
        ReturnValue = E_UNEXPECTED;
        goto DllRegisterServer_Exit;
    }

    RegCloseKey( hKey );
    hKey = INVALID_HANDLE_VALUE;



    //
    // Try to start the service.
    //
    if( !pStartService(SERVICE_NAME) ) {
        //
        // That's okay.
        //
        // ReturnValue = E_UNEXPECTED;
        // goto DllRegisterServer_Exit;
    }

DllRegisterServer_Exit:
    if( hKey != INVALID_HANDLE_VALUE ) {
        RegCloseKey( hKey );
    }

    if( Data != NULL ) {
        free( Data );
    }

    return ReturnValue;

}

STDAPI
DllUnregisterServer(
    VOID
    )
/*++

Routine Description:

    Delete entries to the system registry.

Arguments:

    NONE

Return Value:

    S_OK if everything went okay.
    
--*/

{

    HRESULT     ReturnValue = S_OK;
    ULONG       dw, StartType;
    HKEY        hKey = INVALID_HANDLE_VALUE;
    
    //
    // turn off the sacsvr start value.
    //
    dw = RegOpenKeyEx( HKEY_LOCAL_MACHINE,
                       SACSVR_SERVICE_KEY,
                       0,
                       KEY_ALL_ACCESS,                       
                       &hKey );
    if( dw != ERROR_SUCCESS ) {
        ReturnValue = E_UNEXPECTED;
        goto DllUnRegisterServer_Exit;
    }

    StartType = 4;
    dw = RegSetValueEx( hKey,
                        L"Start",
                        0,
                        REG_DWORD,
                        (LPBYTE)&StartType,
                        sizeof(DWORD) );
    if( dw != ERROR_SUCCESS ) {
        ReturnValue = E_UNEXPECTED;
        goto DllUnRegisterServer_Exit;
    }

    RegCloseKey( hKey );
    hKey = INVALID_HANDLE_VALUE;

DllUnRegisterServer_Exit:
    if( hKey != INVALID_HANDLE_VALUE ) {
        RegCloseKey( hKey );
    }

    return ReturnValue;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\headless\cmd\sacsvr\sacsvr.h ===
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <winsvc.h>             // Service control APIs
#include <rpc.h>
#include <stdlib.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <Shlwapi.h>

#include <sacapi.h>
#include <ntddsac.h>

#pragma warning(disable:4127)   // condition expression is constant

VOID SvcDebugOut(LPSTR String, DWORD Status);

VOID 
MyServiceCtrlHandler (
    DWORD Opcode
    );

BOOL
Run(
    VOID
    );

BOOL
Stop(
    VOID
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\headless\ems\sac\sacrunner\inclfile.h ===
#ifndef __INCLFILE
#define __INCLFILE

#include <windows.h>
#include <TCHAR.H>


#include <iostream>
#include <fstream>
#include <time.h>


typedef std::basic_fstream<TCHAR> fstream;
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\headless\ems\sac\saccommunicator\saccommunicator.h ===
// SacCommunicator.h: interface for the CSacCommunicator class.
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_SACCOMMUNICATOR_H__F1BA07A7_478E_4E36_9780_22B5924F722D__INCLUDED_)
#define AFX_SACCOMMUNICATOR_H__F1BA07A7_478E_4E36_9780_22B5924F722D__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000


#include <string>

// sac-code definitions
#ifdef _SACUNICODE
	
	typedef		wchar_t		SAC_CHAR, *SAC_STR;
	#define					SAC_STRCMP					wcscmp
	#define					SAC_STRLEN					wcslen
	#define					SAC_TEXT(str)				(L str)

#else

	typedef		char		SAC_CHAR, *SAC_STR;
	#define					SAC_STRCMP					strcmp
	#define					SAC_STRLEN					strlen
	#define					SAC_TEXT(str)				(str)

#endif 

typedef std::basic_string<SAC_CHAR> SacString;

#define BUF_LEN 512 // generic buffer length

class CSacCommunicator  
{

public:

	static LPTSTR s_vctrCommPorts[]; // Supported Communication Port Names Vector
	static SacString s_strDummyReponse;

	static BOOL XReadFile(
		HANDLE hFile,                // handle to file
		LPVOID lpBuffer,             // data buffer
		DWORD nNumberOfBytesToRead,  // number of bytes to read
		LPDWORD lpNumberOfBytesRead, // number of bytes read
		LPOVERLAPPED lpOverlapped,    // overlapped buffer
		time_t tmTimeout  // time-out
		);

	CSacCommunicator(int nCommPort, DCB dcb);
	virtual ~CSacCommunicator();

	BOOL Connect();			// connect to port
	BOOL Disconnect();		// disconnect

	BOOL IsConnected();		// check whether port open


	BOOL PokeSac();			// verfies that sac is on the line - DISABLED

	BOOL SacCommand(SAC_STR szRequest, SacString& strResponse= s_strDummyReponse, BOOL bPoke= TRUE, time_t tmTimeOut= 5000 /* ms */);
	// sends a sac command and receives the response, can pre-poke to check that sac is listening
	// pre-poking is based on PokeSac() which is currently disabled

	BOOL PagingOff(SacString& strResponse=s_strDummyReponse); // disables paging the display

private:
	
	int				m_nCommPort;	// com port # [1 or 2]
	HANDLE			m_hCommPort;	// handle to the file representing com port

	DCB				m_dcb;			// connection params

	void _Construct(int nCommPort, DCB dcb);
	void _Clean();

};

#endif // !defined(AFX_SACCOMMUNICATOR_H__F1BA07A7_478E_4E36_9780_22B5924F722D__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\headless\cmd\sacsvr\saccmd.c ===
#include "sacsvr.h"

#include <TChar.h>

//
// Handle to the SAC Driver object
//
//  The SAC driver requires us to use the same driver handle
//  that we registered with, to unregister.
//  Hence, we must keep this handle after we register ourselves
//  with the SAC driver so that we can unregister.
//
HANDLE  m_SacDriverHandle = INVALID_HANDLE_VALUE;

//
// This event is fired when the SAC driver wants us 
// to launch a Command Prompt session
//
HANDLE  m_RequestSacCmdEvent = NULL;

//
// In response to our attempt at launching a Command Prompt session,
// we signal the appropriate status event
//
HANDLE  m_RequestSacCmdSuccessEvent = NULL;
HANDLE  m_RequestSacCmdFailureEvent = NULL;

//
// the Command Prompt session exe
//
#define SAC_CMD_SCRAPER_PATH  TEXT("sacsess.exe")

#define SETREGISTRYDW( constVal, keyHandle1, keyHandle2, keyName, val, size )   \
    val = constVal ;                                                            \
    if( RegSetValueEx( keyHandle2, keyName, 0, REG_DWORD, (LPBYTE)&val, size    \
                )  != ERROR_SUCCESS )                                           \
    {                                                                           \
        if(  keyHandle1 ) {                                                     \
            RegCloseKey(  keyHandle1 );                                         \
        }                                                                       \
        RegCloseKey(  keyHandle2 );                                             \
        return ( FALSE );                                                       \
    }

#define REG_CONSOLE_KEY    L".DEFAULT\\Console"

//Add other FAREAST languages
#define JAP_CODEPAGE 932
#define CHS_CODEPAGE 936
#define KOR_CODEPAGE 949
#define CHT_CODEPAGE 950
#define JAP_FONTSIZE 786432
#define CHT_FONTSIZE 917504
#define KOR_FONTSIZE 917504
#define CHS_FONTSIZE 917504

BOOL
CreateClient(
    DWORD*      pdwPid
    );

BOOL
CreateSessionProcess(
    DWORD*        dwProcessId, 
    HANDLE*       hProcess
    );

BOOL
SetServiceStartType(
    IN PWSTR RegKey,
    IN DWORD StartType
    )

/*++

Routine Description:


Arguments:

    None.

Return Value:

    true - success
    false, otherwise

--*/

{
    DWORD       rc;
    HKEY        hKey;

    //
    // Open the service configuration key
    //
    rc = RegOpenKeyEx( HKEY_LOCAL_MACHINE,
                       RegKey,
                       0,
                       KEY_WRITE,
                       &hKey );
    
    if( rc == NO_ERROR ) {
        
        rc = RegSetValueEx(
                        hKey,
                        TEXT("Start"),
                        0,
                        REG_DWORD,
                        (LPBYTE)&StartType,
                        sizeof(DWORD)
                        );

        RegCloseKey( hKey );

    }

    //
    // Success
    //
    return rc == NO_ERROR ? TRUE : FALSE;

}

BOOL
InitSacCmd(
    VOID
    )
/*++

Routine Description:

    This routine initializes the relationship between the SACDRV and this service.
    We register an event with the SACDRV so that when a 'cmd' command is executed
    in the EMS, the event is fired and we launch a sac cmd session.

Arguments:

    none

Return Value:

    TRUE    - if SacCmd was initialized successfully
    
    otherwise, FALSE

--*/
{
    BOOL                    bStatus;

    //
    // Initialize the our SAC Cmd Info
    //
    do {

        //
        // These events use the auto-reset mechanism since they are used as syncronization events
        //
        m_RequestSacCmdEvent        = CreateEvent( NULL, FALSE, FALSE, NULL );
        if (m_RequestSacCmdEvent == NULL) {
            bStatus = FALSE;
            break;
        }
        m_RequestSacCmdSuccessEvent = CreateEvent( NULL, FALSE, FALSE, NULL );
        if (m_RequestSacCmdSuccessEvent == NULL) {
            bStatus = FALSE;
            break;
        }
        m_RequestSacCmdFailureEvent = CreateEvent( NULL, FALSE, FALSE, NULL );
        if (m_RequestSacCmdFailureEvent == NULL) {
            bStatus = FALSE;
            break;
        }

        //
        // Reset the service start type to Manual. By doing this,
        // we enable the scenario where the system boots with headless
        // enabled and then the user disables headless.  In this scenario,
        // the service will not auto start next boot.  This works because
        // the SAC driver moves the service start type from manual to auto,
        // if and only if the start type is manual.
        //
        // Note: we do this before we register with the SAC so we are sure
        //       it happens
        //
        bStatus = SetServiceStartType(
            L"System\\CurrentControlSet\\Services\\sacsvr",
            SERVICE_DEMAND_START 
            );

        if (! bStatus) {
            SvcDebugOut("Failed to set service start type\n", bStatus);
            break;
        } else {
            SvcDebugOut("Succeded to set service start type\n", bStatus);
        }
    
        //
        // Send the SAC Driver the event handles and the pointer to our
        // communication buffer
        //
        bStatus = SacRegisterCmdEvent(
            &m_SacDriverHandle,
            m_RequestSacCmdEvent,
            m_RequestSacCmdSuccessEvent,
            m_RequestSacCmdFailureEvent
            );
        
        if (! bStatus) {
            SvcDebugOut("Failed registration\n", bStatus);
        } else {
            SvcDebugOut("Succeeded registration\n", bStatus);
        }

    } while ( FALSE );

    //
    // clean up, if necessary
    //
    if (!bStatus) {
        if (m_RequestSacCmdEvent != NULL) {
            CloseHandle(m_RequestSacCmdEvent);
            m_RequestSacCmdEvent = NULL;
        }
        if (m_RequestSacCmdSuccessEvent != NULL) {
            CloseHandle(m_RequestSacCmdSuccessEvent);
            m_RequestSacCmdSuccessEvent = NULL;
        }
        if (m_RequestSacCmdFailureEvent != NULL) {
            CloseHandle(m_RequestSacCmdFailureEvent);
            m_RequestSacCmdFailureEvent = NULL;
        }
    }
    return bStatus;                      
}

BOOL
ShutdownSacCmd(
    void
    )
/*++

Routine Description:

    This routine removes the relationship between the SACDRV and this service.

Arguments:

    none

Return Value:

    TRUE    - if SacCmd was initialized successfully
    
    otherwise, FALSE

--*/
{
    BOOL                    Status;

    //
    // default status
    //
    Status = TRUE;

    //
    // Send the SAC Driver notification to remove the event handles 
    // and the pointer to our communication buffer
    //
    if (! SacUnRegisterCmdEvent(&m_SacDriverHandle)) {

        Status = FALSE;

    }

    return Status;
}

VOID
CompleteSacRequest(
    BOOLEAN Status
    )
/*++

Routine Description:

    This routine notifies the SAC driver about the status
    of the attempt to launc the SAC session.

Arguments:

    Status  - TRUE if the session was successfully launched,
              FALSE otherwise

Return Value:

    None

--*/
{

    //
    // Fire the event corresponding to the request completion status
    //

    if (Status == TRUE) {
        SetEvent(m_RequestSacCmdSuccessEvent);
    } else {
        SetEvent(m_RequestSacCmdFailureEvent);
    }

}

BOOL
ListenerThread(
    VOID
    )
/*++

Routine Description:

    This routine waits around for a "lauch a SAC session" 
    event message from the SAC driver.

Arguments:

    None

Return Value:

    Status

--*/
{
    HANDLE  eventArray[ 1 ];
    DWORD   dwWaitRet = 0;
    DWORD   dwPid = 0;
    BOOL    bContinue;
    BOOL    bStatus;

    //
    // setup the event array
    //
    enum {
        SAC_CMD_LAUNCH_EVENT = WAIT_OBJECT_0 
    };

    eventArray[ 0 ] = m_RequestSacCmdEvent;

    //
    // While we want to continue, service events
    //

    bStatus = TRUE;

    bContinue = TRUE;

    while ( bContinue ) {

        dwWaitRet = WaitForMultipleObjects (
            sizeof(eventArray)/sizeof(HANDLE), 
            eventArray, 
            FALSE, 
            INFINITE 
            );

        switch (dwWaitRet) {
        case SAC_CMD_LAUNCH_EVENT:

            //
            // Attempt to launch the command console process
            //

            if ( !CreateClient( &dwPid ) ) {
                
                //
                // Notify the SAC driver that we failed to 
                // launch the SAC session
                //
                CompleteSacRequest( FALSE );

                bStatus = FALSE;

                break;
            }

            //
            // Notify the SAC driver that we successfully 
            // launched the SAC session
            //
            CompleteSacRequest(TRUE);

            break;

        default:

            bContinue = FALSE;

            bStatus = FALSE;

            break;

        }
    }

    return( bStatus ); 
}

BOOL
CreateClient(
    OUT DWORD   *pdwPid
    )
/*++

Routine Description:

    This routine launches the SAC session

Arguments:

    pdwPid  - the PID of the newly created SAC session process

Return Value:

    Status

--*/
{
    BOOL    bRetVal;
    BOOL    bSuccess;
    DWORD   dwProcessId;
    HANDLE  hProcess;
    DWORD   dwExitCode;

    //
    // default: we failed to create the process
    //
    bRetVal = FALSE;
    hProcess = NULL;

    do {

        //
        // Create the Command Console session process
        //
        bSuccess = CreateSessionProcess(
            &dwProcessId, 
            &hProcess
            );

        if ( !bSuccess ) {
            break;
        }

        if ( hProcess == NULL ) {
            break;
        }
        
        //
        // Send back PID to caller
        //
        *pdwPid = dwProcessId;

        //
        // Check if the process has really started. It may not have started properly 
        // in the following cases and yet the createprocess return code 
        // will not say it
        //
        //  1. Could not launch process on the desktop because of lack of perms or 
        //     heap memory. Doing GetExitCodeProcess immediate may not help always.
        //
        GetExitCodeProcess( hProcess, &dwExitCode );

        //
        // Make sure the process is still active before we declare victory
        //
        if (dwExitCode != STILL_ACTIVE ) {
            break;
        }

        //
        // We successfully created the process
        // 
        bRetVal = TRUE;        
    
    } while ( FALSE );

    //
    // We are done with the process handle
    //
    if (hProcess) {
        CloseHandle( hProcess ); 
    }

    return(bRetVal);
}

PTCHAR
GetPathOfTheExecutable(
    VOID
    )
/*++

Routine Description:

    Find out where the SAC session executable is located.

Arguments:

    NONE
                    
Return Value:

    Failure: NULL
    SUCCESS: pointer to path (caller must free)    

--*/
{
    TCHAR   SystemDir[MAX_PATH+1];
    PTCHAR  pBuffer;
    ULONG   length;

    //
    // default: we didnt create a new path
    //
    pBuffer = NULL;

    do {

        //
        // get the system path
        // 
        length = GetSystemDirectoryW(SystemDir, MAX_PATH+1);

        if (length == 0) {
            break;            
        }

        //
        // compute the length
        //
        length += 1; // backslash
        length += lstrlen(SAC_CMD_SCRAPER_PATH);
        length += 1; // NULL termination

        //
        // allocate our new path
        //
        pBuffer = malloc(length * sizeof(WCHAR));

        if (pBuffer == NULL) {
            break;
        }

        //
        // create the path
        //
        wnsprintf(
            pBuffer,
            length,
            TEXT("%s\\%s"),
            SystemDir,
            SAC_CMD_SCRAPER_PATH
            );

    } while ( FALSE );
    
    return pBuffer;
}

void
FillProcessStartupInfo(
    STARTUPINFO *si
    )
/*++

Routine Description:

    Populate the process startup info structure for the 
    SAC session process.

Arguments:
                
    si  - the startup info
        
Return Value:

    None

--*/
{
    ASSERT( si != NULL );

    ZeroMemory(si, sizeof(STARTUPINFO));

    si->cb            = sizeof(STARTUPINFO);
    si->wShowWindow   = SW_SHOW;

    return;
}

BOOL
CreateSessionProcess(
    OUT DWORD   *dwProcessId, 
    OUT HANDLE  *hProcess
    )
/*++

Routine Description:

    This routine does the real work to launch the SAC session process.

Arguments:
                
    dwProcessId - the PID of the SAC session process
        
Return Value:

    TRUE - the process was created successfully,
    FALSE - otherwise

--*/
{
    PROCESS_INFORMATION pi;
    STARTUPINFO         si;
    PTCHAR              pCmdBuf;
    BOOL                dwStatus;
    PWCHAR              SessionPath = SAC_CMD_SCRAPER_PATH;

    do {

        //
        // get the pathname to the SAC session exe
        //
        pCmdBuf = GetPathOfTheExecutable();

        if (pCmdBuf == NULL) {
            dwStatus = FALSE;
            break;
        }

        //
        //
        //
        FillProcessStartupInfo( &si );

        //
        //
        //
        dwStatus = CreateProcess(
            pCmdBuf, 
            SessionPath, 
            NULL, 
            NULL, 
            TRUE,
            CREATE_NEW_PROCESS_GROUP | CREATE_NEW_CONSOLE, 
            NULL, 
            NULL, 
            &si, 
            &pi
            );

        //
        // release our SAC session path
        //
        free(pCmdBuf);

        if ( !dwStatus ) {
            break;
        }

        //
        //
        //
        *hProcess = pi.hProcess;

        CloseHandle( pi.hThread );

        *dwProcessId = pi.dwProcessId;
    
    } while ( FALSE );

    return( dwStatus );
}

BOOL
FormSACSessKeyForCmd( 
    LPWSTR *lpszKey 
    )
/*++

Routine Description:

    This routine forms the reg key used to specify the console
    fonts for the sacsess.exe app.
    
    See comments for HandleJapSpecificRegKeys
    
    Mem allocation by this function.
    To be deleted by the caller.

    (based on telnet's FormTlntSessKeyForCmd)

Arguments:
                
    lpszKey - on success, contains the key name
        
Return Value:

    TRUE    - We completed successfully
    FALSE   - otherwise

--*/
{

    WCHAR   szPathName[MAX_PATH+1];
    WCHAR   session_path[MAX_PATH*2];
    LPTSTR  pSlash;
    wint_t  ch;
    LPTSTR  pBackSlash;
    DWORD   length_required;

    //
    //
    //
    if( !GetModuleFileName( NULL, szPathName, MAX_PATH+1 ) )
    {
        return ( FALSE );
    }
    szPathName[MAX_PATH] = UNICODE_NULL;

    //
    // Nuke the trailing "sacsvr.exe"
    //
    pSlash = wcsrchr( szPathName, L'\\' );

    if( pSlash == NULL )
    {
        return ( FALSE );
    }
    else
    {
        *pSlash = L'\0';
    }

    //
    // Replace all '\\' with '_' This format is required for the console to
    // interpret the key.
    //
    ch = L'\\';
    pBackSlash = NULL;

    while ( 1 )
    {
        pBackSlash = wcschr( szPathName, ch );

        if( pBackSlash == NULL )
        {
            break;
        }
        else
        {
            *pBackSlash = L'_';
        }
    }

    //
    //
    //
    _snwprintf(session_path, MAX_PATH*2 - 1, L"%s_sacsess.exe", szPathName);
    session_path[MAX_PATH*2 - 1] = L'\0'; // snwprintf could return non-null terminated string, if the buffer size is an exact fit

    length_required = (DWORD)(wcslen( REG_CONSOLE_KEY ) + wcslen( session_path ) + 2);
    *lpszKey = malloc(length_required * sizeof(WCHAR));

    if( *lpszKey == NULL )
    {
        return( FALSE );
    }

    //
    //
    //
    _snwprintf(*lpszKey, length_required - 1, L"%s\\%s", REG_CONSOLE_KEY, session_path );
    (*lpszKey)[length_required - 1] = L'\0'; // snwprintf could return non-null terminated string, if the buffer size is an exact fit

    return ( TRUE );
}

BOOL
HandleFarEastSpecificRegKeys(
    VOID
    )
/*++

Routine Description:

    If Japanese codepage, then we need to verify 3 registry settings for
    console fonts:
    HKEY_USERS\.DEFAULT\Console\FaceName :REG_SZ:lr SVbN
            where the FaceName is "MS gothic" written in Japanese full widthKana
    HKEY_USERS\.DEFAULT\Console\FontFamily:REG_DWORD:0x36
    HKEY_USERS\.DEFAULT\Console\C:_SFU_Telnet_sacsess.exe\FontFamily:REG_DWORD: 0x36
    where the "C:" part is the actual path to SFU installation

    (based on telnet's HandleFarEastSpecificRegKeys)

Arguments:
                
    None
        
Return Value:

    TRUE    - We completed successfully
    FALSE   - otherwise

--*/
{
    HKEY hk;
    DWORD dwFontSize = 0;
    const TCHAR szJAPFaceName[] = { 0xFF2D ,0xFF33 ,L' ' ,0x30B4 ,0x30B7 ,0x30C3 ,0x30AF ,L'\0' };
    const TCHAR szCHTFaceName[] = { 0x7D30 ,0x660E ,0x9AD4 ,L'\0'};
    const TCHAR szKORFaceName[] = { 0xAD74 ,0xB9BC ,0xCCB4 ,L'\0'};
    const TCHAR szCHSFaceName[] = { 0x65B0 ,0x5B8B ,0x4F53 ,L'\0' };
    TCHAR szFaceNameDef[256];
    DWORD dwCodePage = GetACP();
    DWORD dwFaceNameSize = 0;
    DWORD dwFontFamily = 54;
    DWORD dwFontWeight = 400;
    DWORD dwHistoryNoDup = 0;
    DWORD dwSize = 0;


    switch (dwCodePage)
    {
        case JAP_CODEPAGE:
            _tcscpy(szFaceNameDef, szJAPFaceName); //On JAP, set the FaceName to "MS Gothic"
            dwFontSize = JAP_FONTSIZE;
            break;
        case CHT_CODEPAGE:
            _tcscpy(szFaceNameDef, szCHTFaceName); //On CHT, set the FaceName to "MingLiU"
            dwFontSize = CHT_FONTSIZE;
            break;
        case KOR_CODEPAGE:
            _tcscpy(szFaceNameDef, szKORFaceName);//On KOR, set the FaceName to "GulimChe"
            dwFontSize = KOR_FONTSIZE;
            break;
        case CHS_CODEPAGE:
            _tcscpy(szFaceNameDef, szCHSFaceName);//On CHS, set the FaceName to "NSimSun"
            dwFontSize = CHS_FONTSIZE;
            break;
        default:
            _tcscpy(szFaceNameDef,L"\0");
            break;
    }

    dwFaceNameSize = (DWORD)(( _tcslen( szFaceNameDef ) + 1 ) * sizeof( TCHAR ));

    if( !RegOpenKeyEx( HKEY_USERS, REG_CONSOLE_KEY, 0, KEY_SET_VALUE, &hk ) )
    {
        DWORD   dwVal;
        LPWSTR  lpszKey;
        HKEY    hk2;

        RegSetValueEx(
            hk, 
            L"FaceName", 
            0, 
            REG_SZ, 
            (LPBYTE) szFaceNameDef, 
            dwFaceNameSize 
            );

        dwSize = sizeof( DWORD );

        SETREGISTRYDW( dwFontFamily, NULL, hk, L"FontFamily", dwVal,dwSize );

        lpszKey = NULL;
        
        if ( !FormSACSessKeyForCmd( &lpszKey ) ) {
            RegCloseKey( hk );
            return( FALSE );
        }

        hk2 = NULL;

        if ( RegCreateKey( HKEY_USERS, lpszKey, &hk2 ) ) {
            free(lpszKey);
            return( FALSE );
        }
        free(lpszKey);

        dwSize = sizeof( DWORD );

        SETREGISTRYDW( dwFontFamily, hk, hk2, L"FontFamily", dwVal, dwSize);
        SETREGISTRYDW( dwCodePage, hk, hk2, L"CodePage", dwVal, dwSize );
        SETREGISTRYDW( dwFontSize, hk, hk2, L"FontSize", dwVal, dwSize);
        SETREGISTRYDW( dwFontWeight, hk, hk2, L"FontWeight", dwVal, dwSize );
        SETREGISTRYDW( dwHistoryNoDup, hk, hk2, L"HistoryNoDup", dwVal, dwSize );

        RegSetValueEx( 
            hk2, 
            L"FaceName", 
            0, 
            REG_SZ, 
            (LPBYTE) szFaceNameDef, 
            dwFaceNameSize 
            );

        RegCloseKey( hk2 );
        RegCloseKey( hk );

        return( TRUE );
    }

    return ( FALSE );
}

BOOL
InitializeGlobalObjects(
    VOID
    )
/*++

Routine Description:

    This routine performs init of the global settings
    needed by the service or will be needed by the session.

Arguments:
                
    None
        
Return Value:

    TRUE    - We completed successfully
    FALSE   - otherwise

--*/
{
   
    DWORD   dwCodePage;
    BOOL    bStatus;

    do {

        //
        // notify the SAC driver that we are ready to launch sessions
        //
        bStatus = InitSacCmd();

        if (! bStatus) {
            SvcDebugOut("RUN: Failed SAC init: %x\n", bStatus);
            break;
        }

        //
        // make sure we have the Console fonts set up properly for
        // far-east builds.  We need to do this, or when we call 
        // ReadConsoleOutput in sacsess, we will get back a malformed
        // screen frame buffer - it will not have properly constructed
        // double width jpn chars, for instance.
        //
        dwCodePage = GetACP();

        if ( dwCodePage == JAP_CODEPAGE || 
             dwCodePage == CHS_CODEPAGE ||
             dwCodePage == CHT_CODEPAGE || 
             dwCodePage == KOR_CODEPAGE ) {

            //
            // Fareast code page
            //
            bStatus = HandleFarEastSpecificRegKeys();
                
            if( !bStatus )
            {
                SvcDebugOut("RUN: Failed to handle FES init: %x\n", bStatus);
                break;
            }
       }
    
    } while ( FALSE );
  
   return bStatus;

}

BOOL
Run(
   VOID
   )
/*++

Routine Description:

    This routine registers the service with the SAC driver
    and waits for messages from the SAC driver to launch SAC sessions.

Arguments:
                
    None
        
Return Value:

    TRUE    - We completed successfully
    FALSE   - otherwise

--*/
{
    BOOL    Status;

    do {

        //
        //
        //
        Status = InitializeGlobalObjects();
        
        if (! Status) {
            SvcDebugOut("RUN: Failed init of global objects: %x\n", Status);
            break;
        }

        //
        //
        //
        Status = ListenerThread();

        if (! Status) {
            SvcDebugOut("RUN: Failed Listener: %x\n", Status);
            break;
        }
    
    } while (FALSE);

    return Status;
}

BOOL
Stop(
    VOID
    )
/*++

Routine Description:

    Shutdown the service, which in this case implies
    that we unregister with the SAC driver so it knows
    we aren't listening anymore.

Arguments:
                
    None
        
Return Value:

    TRUE    - We completed successfully
    FALSE   - otherwise

--*/
{
    BOOL    Status;

    Status = ShutdownSacCmd();

    return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\headless\ems\sac\saccommunicator\saccommunicator.cpp ===
// SacCommunicator.cpp: implementation of the CSacCommunicator class.
//
//////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "SacCommunicator.h"

#include "Debug.cpp"

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

LPTSTR CSacCommunicator::s_vctrCommPorts[]= {_T("COM1"), _T("COM2"), NULL};
SacString CSacCommunicator::s_strDummyReponse;

BOOL CSacCommunicator::XReadFile(
		HANDLE hFile,                // handle to file
		LPVOID lpBuffer,             // data buffer
		DWORD nNumberOfBytesToRead,  // number of bytes to read
		LPDWORD lpNumberOfBytesRead, // number of bytes read
		LPOVERLAPPED lpOverlapped,    // overlapped buffer
		time_t tmTimeout  // time-out
)
{
	time_t tmInitReadTime, tmCurrTime;
	time(&tmInitReadTime); // stamp

	BOOL bLastRead;

	while (!(bLastRead= ReadFile(hFile, lpBuffer, nNumberOfBytesToRead, lpNumberOfBytesRead, lpOverlapped)) || !*lpNumberOfBytesRead)
	{
		time(&tmCurrTime); // stamp

		if (tmCurrTime-tmInitReadTime>tmTimeout)
			break;
	}

	return bLastRead;
}

CSacCommunicator::CSacCommunicator(int nCommPort, DCB dcb)
{
	_Construct(nCommPort, dcb);
}

CSacCommunicator::~CSacCommunicator()
{
	_Clean();
}

void CSacCommunicator::_Construct(int nCommPort, DCB dcb)
{
	m_nCommPort= nCommPort;
	m_dcb= dcb;

	m_hCommPort= INVALID_HANDLE_VALUE;
}

void CSacCommunicator::_Clean()
{
	if (IsConnected())
		Disconnect();
}

BOOL CSacCommunicator::Connect()
{
	m_hCommPort= CreateFile(s_vctrCommPorts[m_nCommPort], GENERIC_READ|GENERIC_WRITE, 0, NULL, OPEN_EXISTING, 0, NULL);
	// open handle

	if (m_hCommPort!=INVALID_HANDLE_VALUE)
	{
		if (!SetCommMask(m_hCommPort, EV_RXCHAR)) // masking all events but the char. read event
			return FALSE; // init call has to succeed

		COMMTIMEOUTS tmouts;
		ZeroMemory(&tmouts,sizeof(COMMTIMEOUTS));
		tmouts.ReadIntervalTimeout= MAXDWORD; // no blocking

		if (!SetCommTimeouts(m_hCommPort, &tmouts)) // non-blocking read
			return FALSE; // has to succeed as well
	}

	return m_hCommPort!=INVALID_HANDLE_VALUE; // check if succeeded
}

BOOL CSacCommunicator::Disconnect()
{
	CloseHandle(m_hCommPort); // close the handle

	m_hCommPort= INVALID_HANDLE_VALUE;
	return m_hCommPort==INVALID_HANDLE_VALUE; // has to succeed
}

BOOL CSacCommunicator::IsConnected()
{
	return m_hCommPort!=INVALID_HANDLE_VALUE;
}

BOOL CSacCommunicator::PokeSac() // currently disabled
{
	return FALSE;
}

BOOL CSacCommunicator::SacCommand(SAC_STR szRequest, SacString& strResponse, BOOL bPoke, time_t tmTimeout)
{
	time_t tmInitTime, tmCurrTime;
	time(&tmInitTime);

	strResponse= ""; // init response

	if (bPoke) // if asked:
/*		if (!PokeSac()) // poke sac
			return FALSE; // make sure to get response*/
		0; // disabled
		

	DWORD nBytesWritten, nBytesRead;
	SAC_CHAR szReturned[BUF_LEN]; // whatever is written by sac
	
	for (int i= 0; i<SAC_STRLEN(szRequest); i++) // baby-feeding sac
	{
		if (!WriteFile( m_hCommPort, szRequest+i, sizeof(SAC_CHAR), &nBytesWritten, NULL)) // feed sac
			return FALSE; // io must succeed

		time(&tmCurrTime);
		tmTimeout-= tmCurrTime-tmInitTime;
		if (!XReadFile( m_hCommPort, szReturned, sizeof(SAC_CHAR), &nBytesRead, NULL, tmTimeout)||!nBytesRead) // feed sac
			return FALSE; // io must succeed && must receive echo back
	}

	time(&tmCurrTime);
	tmTimeout-= tmCurrTime-tmInitTime;
	if (!XReadFile( m_hCommPort, szReturned, sizeof(SAC_CHAR), &nBytesRead, NULL, tmTimeout)||!nBytesRead) // feed sac
		return FALSE; // io must succeed && must receive echo back

//	DWORD dwEvtMask;
	
	DWORD dwErrors; // port errors
	COMSTAT stat;   // io status


	time(&tmInitTime);

	do
	{

		//dwEvtMask= 0;
		//while (!(dwEvtMask & EV_RXCHAR)
		//	if (!WaitCommEvent(m_hCommPort, &dwEvtMask, NULL))
		//		return FALSE;

		ClearCommError(m_hCommPort, &dwErrors, &stat); // peek into buffer

		if (!ReadFile(m_hCommPort, szReturned, stat.cbInQue, &nBytesRead, NULL)) // receive echo-back
			return FALSE; // io must succeed
		
		if (!nBytesRead)
			continue; // save some worthless instructions then

		szReturned[nBytesRead]= '\0'; // fix it
		strResponse.append(szReturned); // add to response

		time(&tmCurrTime);
	} while ((strResponse.rfind(SAC_TEXT("SAC>"))==SacString::npos)&&(tmCurrTime-tmInitTime<tmTimeout));

 	int nPosSacPrompt= strResponse.rfind(SAC_TEXT("SAC>"));
	if (!nPosSacPrompt)
		return FALSE; // no prompt back 

	strResponse.erase(nPosSacPrompt, SAC_STRLEN(SAC_TEXT("SAC>")));

	return TRUE; // at last sac echoed back!!!
}

BOOL CSacCommunicator::PagingOff(SacString& strResponse)
{
	if (!SacCommand(SAC_STR("p\r"), strResponse, FALSE)) // toggle paging
		return FALSE;

	if (strResponse.find(SAC_STR("OFF"))!=SacString::npos) // check state
		return TRUE;

	// if we r here then supposedly it's on, need to toggle once more
	if (!SacCommand(SAC_STR("p\r"), strResponse, FALSE)) // toggle paging
		return FALSE;

	if (strResponse.find(SAC_STR("OFF"))!=SacString::npos) // re-check
		return TRUE;

	return FALSE; // desperate
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\headless\ems\sac\sacrunner\ntlog.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1996 - 1997.
//
//  File:       ntlog.cxx
//
//  Contents:   implemntation of CNtLog
//
//  Classes:
//
//  Functions:
//
//  Notes: loginf.h is where app specific setting should go
//
//  History:    8-23-96   benl   Created
//
//----------------------------------------------------------------------------

#include <windows.h>
#include <tchar.h>
#include <stdlib.h>
#include <stdio.h>
#include <assert.h>
//#include <iostream.h>
#include <ntlog.h>
#include "ntlog.hxx"

// #include "loginf.h"     //put any ntlog settings in here // not needed 4 now
// instead
#define LOG_OPTIONS 0

//constants
const int BUFLEN = 255;


//+---------------------------------------------------------------------------
//
//  Member:     CNtLog::Init
//
//  Synopsis:   set up logging
//
//  Arguments:  [lpLogFile] -- log file name
//
//  Returns:     TRUE if successful
//
//  History:    8-23-96   benl   Created
//
//  Notes:
//
//----------------------------------------------------------------------------

BOOL CNtLog::Init(LPCTSTR lpLogFile)
{
    WIN32_FIND_DATA wfd;
    HANDLE h;
    INT iNumExt = 0;

    if (lpLogFile)
    {
        _sntprintf(_lpName,MAX_PATH,_T("%s"),lpLogFile);

        //repeat until we have a name that doesn't exist
        do {
            h = ::FindFirstFile(_lpName,&wfd);
            if ( h != INVALID_HANDLE_VALUE )
            {
                _sntprintf(_lpName,MAX_PATH, _T("%s.%d"),lpLogFile,iNumExt++);
                ::FindClose(h);
            } else break;
        } while (1);

        //Now set up the log
        _hLog = ::tlCreateLog(_lpName, LOG_OPTIONS );
    } else
    {
        //set up log with no associated file
        _lpName[0] = _T('\0');
        _hLog = ::tlCreateLog(NULL, LOG_OPTIONS );

    }

    if ( !_hLog ) {
        _ftprintf(stderr, _T("CNtLog::Init:  tlCreateLog %s failed\n"),
                  lpLogFile);
        if (lpLogFile)
            ::DeleteFile(_lpName);
        return FALSE;
    }

    //Add main thread as a participant
    ::tlAddParticipant(_hLog, 0, 0 );

    _dwLevel = TLS_TEST;

    return TRUE;
} //CNtLog::Init



//+---------------------------------------------------------------------------
//
//  Member:     CNtLog::Error
//
//  Synopsis:
//
//  Arguments:  [fmt] -- format string like any other printf func.
//
//  Returns:
//
//  History:    8-23-96   benl   Created
//
//  Notes:
//
//----------------------------------------------------------------------------

VOID CNtLog::Error (LPCTSTR fmt, ...)
{
    va_list vl;
    TCHAR lpBuffer[BUFLEN];

    va_start (vl, fmt);
    _vsntprintf(lpBuffer,BUFLEN,fmt,vl);
    tlLog(_hLog, TLS_BLOCK | _dwLevel, TEXT(__FILE__),(int)__LINE__, lpBuffer);
    _tprintf(_T("Error: %s\n"), lpBuffer);
    va_end (vl);
} //CNtLog::Error //CNtLog::Error


//+---------------------------------------------------------------------------
//
//  Member:     CNtLog::Warn
//
//  Synopsis:
//
//  Arguments:  [fmt] --
//
//  Returns:
//
//  History:    8-23-96   benl   Created
//
//  Notes:
//
//----------------------------------------------------------------------------

VOID CNtLog::Warn  (LPCTSTR fmt, ...)
{
    va_list vl;
    TCHAR lpBuffer[BUFLEN];

    va_start (vl, fmt);
    _vsntprintf(lpBuffer,BUFLEN,fmt,vl);
    tlLog(_hLog,TLS_WARN | _dwLevel, TEXT(__FILE__),(int)__LINE__, lpBuffer);
    _tprintf(_T("Warning: %s\n"), lpBuffer);
    va_end (vl);
} //CNtLog::Warn



//+---------------------------------------------------------------------------
//
//  Member:     CNtLog::Info
//
//  Synopsis:
//
//  Arguments:  [fmt] --
//
//  Returns:
//
//  History:    8-23-96   benl   Created
//
//  Notes:
//
//----------------------------------------------------------------------------

VOID CNtLog::Info  (LPCTSTR fmt, ...)
{
    va_list vl;
    TCHAR lpBuffer[BUFLEN];

    va_start (vl, fmt);
    _vsntprintf(lpBuffer,BUFLEN,fmt,vl);
    tlLog(_hLog,TLS_INFO | _dwLevel, TEXT(__FILE__),(int)__LINE__, lpBuffer);
    _tprintf(_T("%s\n"), lpBuffer);
    va_end (vl);
} //CNtLog::Info


//+---------------------------------------------------------------------------
//
//  Member:     CNtLog::Pass
//
//  Synopsis:
//
//  Arguments:  [fmt] --
//
//  Returns:
//
//  History:    8-26-96   benl   Created
//
//  Notes:
//
//----------------------------------------------------------------------------

VOID CNtLog::Pass( LPCTSTR fmt, ...)
{
   va_list vl;
   TCHAR lpBuffer[BUFLEN];

   va_start (vl, fmt);
   _vsntprintf(lpBuffer,BUFLEN,fmt,vl);
   tlLog(_hLog,TLS_PASS | _dwLevel, TEXT(__FILE__),(int)__LINE__, lpBuffer);
   //_tprintf(_T("Pass: %s\n"), lpBuffer);
   va_end (vl);
} //CNtLog::Pass


//+---------------------------------------------------------------------------
//
//  Member:     CNtLog::Fail
//
//  Synopsis:
//
//  Arguments:  [fmt] --
//
//  Returns:
//
//  History:    8-26-96   benl   Created
//
//  Notes:
//
//----------------------------------------------------------------------------

VOID CNtLog::Fail( LPCTSTR fmt, ...)
{
   va_list vl;
   TCHAR lpBuffer[BUFLEN];

   va_start (vl, fmt);
   _vsntprintf(lpBuffer,BUFLEN,fmt,vl);
   tlLog(_hLog,TLS_SEV2 | _dwLevel, TEXT(__FILE__),(int)__LINE__, lpBuffer);
   _tprintf(_T("Fail: %s\n"), lpBuffer);
   va_end (vl);
} //CNtLog::Fail



//+---------------------------------------------------------------------------
//
//  Member:     CNtLog::Close
//
//  Synopsis:
//
//  Arguments:  [bDelete] --
//
//  Returns:
//
//  History:    8-23-96   benl   Created
//
//  Notes:
//
//----------------------------------------------------------------------------

VOID CNtLog::Close(BOOL bDelete)
{

    assert(_hLog != NULL);

    tlReportStats(_hLog);
    tlRemoveParticipant(_hLog);
    tlDestroyLog(_hLog);

    if (bDelete && _lpName[0] != _T('\0'))
        ::DeleteFile(_lpName);

    //cleanup variables
    _lpName[0] = _T('\0');
    _hLog = NULL;
} //CNtLog::Close


//+---------------------------------------------------------------------------
//
//  Member:     CNtLog::AttachThread
//
//  Synopsis:
//
//  Arguments:  (none)
//
//  Returns:
//
//  History:    12-04-1996   benl   Created
//
//  Notes:
//
//----------------------------------------------------------------------------

VOID CNtLog::AttachThread()
{
    tlAddParticipant(_hLog, 0, 0);
} //CNtLog::AttachThread



//+---------------------------------------------------------------------------
//
//  Member:     CNtLog::DetachThread
//
//  Synopsis:
//
//  Arguments:  (none)
//
//  Returns:
//
//  History:    12-04-1996   benl   Created
//
//  Notes:
//
//----------------------------------------------------------------------------

VOID CNtLog::DetachThread()
{
    tlRemoveParticipant(_hLog);
} //CNtLog::DetachThread


//+---------------------------------------------------------------------------
//
//  Member:      CNtLog::StartVariation
//
//  Synopsis:
//
//  Arguments:  (none)
//
//  Returns:
//
//  History:    9-18-1997   benl   Created
//
//  Notes:
//
//----------------------------------------------------------------------------

VOID CNtLog::StartVariation()
{
    _dwLevel = TLS_VARIATION;
    tlStartVariation(_hLog);
} // CNtLog::StartVariation


//+---------------------------------------------------------------------------
//
//  Member:      CNtLog::EndVariation
//
//  Synopsis:
//
//  Arguments:  (none)
//
//  Returns:
//
//  History:    9-18-1997   benl   Created
//
//  Notes:
//
//----------------------------------------------------------------------------

VOID CNtLog::EndVariation()
{
    DWORD   dwResult;
    _dwLevel = TLS_TEST;
    dwResult = tlEndVariation(_hLog);
    tlLog(_hLog, dwResult | TL_TEST, _T("Variation result"));
} // CNtLog::EndVariation
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\headless\lib\kmode\c\ksacapi\ksacapi.c ===
/*++

Copyright (c) 1993 Microsoft Corporation

Module Name:

    ksacapi.c

Abstract:

    Kernel mode SAC api

Author:

    Brian Guarraci (briangu), 2001

Revision History:

--*/

#include "ksacapip.h"

#include <ksacapi.h>
#include <ntddsac.h>

//
// Machine Information table and routines.
//
#define INIT_OBJA(Obja,UnicodeString,UnicodeText)           \
                                                            \
    RtlInitUnicodeString((UnicodeString),(UnicodeText));    \
                                                            \
    InitializeObjectAttributes(                             \
        (Obja),                                             \
        (UnicodeString),                                    \
        OBJ_CASE_INSENSITIVE,                               \
        NULL,                                               \
        NULL                                                \
        )

//
// Memory management routine aliases
//                                     
#define KSAC_API_ALLOCATE_MEMORY(_s)  
#define KSAC_API_FREE_MEMORY(_p)      

#define KSAC_API_ASSERT(c,s)\
    ASSERT(c);\
    if (!(c)) {\
        return s;\
    }

#define KSAC_VALIDATE_CHANNEL_HANDLE(_h)\
    KSAC_API_ASSERT(                                \
        _h->ChannelHandle->DriverHandle,            \
        STATUS_INVALID_PARAMETER_1                  \
        );                                          \
    KSAC_API_ASSERT(                                                \
        _h->ChannelHandle->DriverHandle != INVALID_HANDLE_VALUE,    \
        STATUS_INVALID_PARAMETER_1                  \
        );                                          \
    KSAC_API_ASSERT(                                \
        _h->SacEventHandle != INVALID_HANDLE_VALUE, \
        STATUS_INVALID_PARAMETER_1                  \
        );                                          \
    KSAC_API_ASSERT(                                \
        _h->SacEvent != NULL,                       \
        STATUS_INVALID_PARAMETER_1                  \
        );                                          



NTSTATUS
KSacHandleOpen(
    OUT HANDLE*     SacHandle,
    OUT HANDLE*     SacEventHandle,
    OUT PKEVENT*    SacEvent
    )

/*++

Routine Description:

    This routine opens a handle to the SAC driver and
    creates and initializes an associated syncrhonization event.

Arguments:

    SacHandle       - the driver handle
    SacEventHandle  - the event handle
    SacEvent        - the sac event

Return Value:

    Status
    
--*/

{
    NTSTATUS                Status;
    OBJECT_ATTRIBUTES       ObjAttr;
    UNICODE_STRING          UnicodeString;
    IO_STATUS_BLOCK         IoStatusBlock;
          
    KSAC_API_ASSERT(SacHandle == NULL, STATUS_INVALID_PARAMETER_1);
    KSAC_API_ASSERT(SacEventHandle == NULL, STATUS_INVALID_PARAMETER_2);
    KSAC_API_ASSERT(SacEvent == NULL, STATUS_INVALID_PARAMETER_3);

    //
    // Open the SAC driver
    //
    INIT_OBJA(&ObjAttr, &UnicodeString, L"\\Device\\SAC");

    Status = ZwCreateFile(
        *SacHandle,
        GENERIC_READ | GENERIC_WRITE | SYNCHRONIZE,
        &ObjAttr,
        &IoStatusBlock,
        NULL,
        FILE_ATTRIBUTE_NORMAL,
        FILE_SHARE_READ | FILE_SHARE_WRITE,
        FILE_OPEN,
        0,
        NULL,
        0 
        );

    if (!NT_SUCCESS(Status)) {
        return Status;
    }

    //
    // Initialize the SAC Kernel event 
    //
    RtlInitUnicodeString(&UnicodeString, L"\\SetupDDSacEvent");

    *SacEvent = IoCreateSynchronizationEvent(
        &UnicodeString, 
        SacEventHandle
        );

    if (*SacEvent == NULL) {
        ZwClose(*SacHandle);
        return STATUS_UNSUCCESSFUL;
    }

    return STATUS_SUCCESS;
}

NTSTATUS
KSacHandleClose(
    IN OUT HANDLE*  SacHandle,
    IN OUT HANDLE*  SacEventHandle,
    IN OUT PKEVENT* SacEvent
    )

/*++

Routine Description:

    This routine closes a handle to the SAC driver and
    closes the associated syncrhonization event.

Arguments:

    SacHandle       - the driver handle
    SacEventHandle  - the event handle
    SacEvent        - the sac event

Return Value:

    Status

--*/

{
    KSAC_API_ASSERT(*SacHandle != NULL, STATUS_INVALID_PARAMETER_1);
    KSAC_API_ASSERT(*SacEventHandle != NULL, STATUS_INVALID_PARAMETER_2);

    UNREFERENCED_PARAMETER(SacEvent);

    ZwClose(*SacHandle);
    ZwClose(*SacEventHandle);
    
    //
    // Null the handles
    //
    *SacEventHandle = NULL;
    *SacHandle = NULL;

    return STATUS_SUCCESS;
}


NTSTATUS
KSacChannelOpen(
    OUT PKSAC_CHANNEL_HANDLE            SacChannelHandle,
    IN  PSAC_CHANNEL_OPEN_ATTRIBUTES    SacChannelAttributes
    )

/*++

Routine Description:

    This routine opens a SAC channel with the specified attributes.

Arguments:

    SacChannelHandle        - on success, contains the handle to the new channel
    SacChannelAttributes    - the attributes of the new channel

Return Value:

    Status
    
--*/

{
    NTSTATUS                Status;
    OBJECT_ATTRIBUTES       ObjAttr;
    UNICODE_STRING          UnicodeString;
    IO_STATUS_BLOCK         IoStatusBlock;
    ULONG                   OpenChannelCmdSize;
    PSAC_CMD_OPEN_CHANNEL   OpenChannelCmd;
    SAC_RSP_OPEN_CHANNEL    OpenChannelRsp;
    HANDLE                  DriverHandle;
    HANDLE                  SacEventHandle;
    PKEVENT                 SacEvent;

    KSAC_API_ASSERT(SacChannelHandle != NULL, STATUS_INVALID_PARAMETER_1);
    KSAC_API_ASSERT(SacChannelAttributes != NULL, STATUS_INVALID_PARAMETER_2);
    
    //
    // default: we didn't get a valid handle
    //
    RtlZeroMemory(SacChannelHandle, sizeof(KSAC_CHANNEL_HANDLE));
    
    //
    // Verify that if the user wants to use the CLOSE_EVENT, we received one to use
    //
    KSAC_API_ASSERT(
        ((SacChannelAttributes->Flags & SAC_CHANNEL_FLAG_CLOSE_EVENT) 
         && SacChannelAttributes->CloseEvent) ||
        (!(SacChannelAttributes->Flags & SAC_CHANNEL_FLAG_CLOSE_EVENT) 
         && !SacChannelAttributes->CloseEvent),
        STATUS_INVALID_PARAMETER_2
        );

    //
    // Verify that if the user wants to use the HAS_NEW_DATA_EVENT, we received one to use
    //
    KSAC_API_ASSERT(
        ((SacChannelAttributes->Flags & SAC_CHANNEL_FLAG_HAS_NEW_DATA_EVENT) 
         && SacChannelAttributes->HasNewDataEvent) ||
        (!(SacChannelAttributes->Flags & SAC_CHANNEL_FLAG_HAS_NEW_DATA_EVENT) 
         && !SacChannelAttributes->HasNewDataEvent),
        STATUS_INVALID_PARAMETER_2
        );

#if ENABLE_CHANNEL_LOCKING
    //
    // Verify that if the user wants to use the LOCK_EVENT, we received one to use
    //
    KSAC_API_ASSERT(
        ((SacChannelAttributes->Flags & SAC_CHANNEL_FLAG_LOCK_EVENT) 
         && SacChannelAttributes->LockEvent) ||
        (!(SacChannelAttributes->Flags & SAC_CHANNEL_FLAG_LOCK_EVENT) 
         && !SacChannelAttributes->LockEvent),
        STATUS_INVALID_PARAMETER_2
        );
#endif

    //
    // Verify that if the user wants to use the REDRAW_EVENT, we received one to use
    //
    KSAC_API_ASSERT(
        ((SacChannelAttributes->Flags & SAC_CHANNEL_FLAG_REDRAW_EVENT) 
         && SacChannelAttributes->RedrawEvent) ||
        (!(SacChannelAttributes->Flags & SAC_CHANNEL_FLAG_REDRAW_EVENT) 
         && !SacChannelAttributes->RedrawEvent),
        STATUS_INVALID_PARAMETER_2
        );

    //
    // If the channel type isn't cmd, 
    // then make sure they sent us a name.
    //
    if (SacChannelAttributes->Type != ChannelTypeCmd) {

        KSAC_API_ASSERT(SacChannelAttributes->Name, STATUS_INVALID_PARAMETER_2);

    } else {

        //
        // Make sure they didn't pass us a name or description.
        //
        KSAC_API_ASSERT(SacChannelAttributes->Name == NULL, STATUS_INVALID_PARAMETER_2);
        KSAC_API_ASSERT(SacChannelAttributes->Description == NULL, STATUS_INVALID_PARAMETER_2);

    }

    //
    // create the Open Channel message structure
    //
    OpenChannelCmdSize  = sizeof(SAC_CMD_OPEN_CHANNEL);
    OpenChannelCmd = (PSAC_CMD_OPEN_CHANNEL)KSAC_API_ALLOCATE_MEMORY(OpenChannelCmdSize);
    
    ASSERT(OpenChannelCmd);
    if (!OpenChannelCmd) {
        return STATUS_NO_MEMORY;
    }

    RtlZeroMemory(OpenChannelCmd, OpenChannelCmdSize);

    //
    // default: we failed
    //
    Status = STATUS_UNSUCCESSFUL;

    //
    // Attempt to open the new channel
    //
    do {

        //
        // initialize the Open Channel message structure
        //
        OpenChannelCmd->Attributes = SacChannelAttributes;

        //
        // Get a handle to the SAC driver
        //
        Status = KSacHandleOpen(
            &DriverHandle,
            &SacEventHandle,
            &SacEvent
            );

        if (!NT_SUCCESS(Status)) {
            break;
        }

        //
        // Send down an IOCTL for opening a channel
        //
        Status = ZwDeviceIoControlFile(
            DriverHandle,
            SacEventHandle,
            NULL,
            NULL,
            &IoStatusBlock,
            IOCTL_SAC_OPEN_CHANNEL,
            OpenChannelCmd,
            OpenChannelCmdSize,
            &OpenChannelRsp,
            sizeof(OpenChannelRsp)
            );

        if (Status == STATUS_PENDING) {

            LARGE_INTEGER           TimeOut;

            TimeOut.QuadPart = Int32x32To64((LONG)90000, -1000);

            Status = KeWaitForSingleObject(
                SacEvent, 
                Executive, 
                KernelMode, 
                FALSE, 
                &TimeOut
                );

            if (Status == STATUS_SUCCESS) {
                Status = IoStatusBlock.Status;
            }

        }

        if (!NT_SUCCESS(Status)) {

            KSacClose(
                &DriverHandle,
                &SacEventHandle,
                &SacEvent
                );

            break;

        }

        //
        // the new channel was created, so pass back the handle to it
        //
        SacChannelHandle->ChannelHandle->DriverHandle    = DriverHandle;
        SacChannelHandle->ChannelHandle->ChannelHandle   = OpenChannelRsp.Handle;
        SacChannelHandle->SacEventHandle  = SacEventHandle;
        SacChannelHandle->SacEvent        = SacEvent;

    } while ( FALSE );
    
    //
    // we are done with the cmd structure
    //
    FREE_POOL(OpenChannelCmd);
    
    return Status;
}

NTSTATUS
KSacChannelClose(
    IN OUT  PKSAC_CHANNEL_HANDLE    SacChannelHandle
    )
/*++

Routine Description:


Arguments:

    None.

Return Value:

    None.

--*/
{
    NTSTATUS                        Status;
    IO_STATUS_BLOCK                 IoStatusBlock;
    SAC_CMD_CLOSE_CHANNEL           CloseChannelCmd;
    
    KSAC_VALIDATE_CHANNEL_HANDLE(SacChannelHandle);

    //
    // Get the channel handle
    //
    CloseChannelCmd.Handle.ChannelHandle = SacChannelHandle->ChannelHandle->ChannelHandle;
    
    //
    // Send down an IOCTL for closing a channel
    //
    Status = ZwDeviceIoControlFile(
        SacChannelHandle->ChannelHandle->DriverHandle,
        SacChannelHandle->SacEventHandle,
        NULL,
        NULL,
        &IoStatusBlock,
        IOCTL_SAC_CLOSE_CHANNEL,
        &CloseChannelCmd,
        sizeof(CloseChannelCmd),
        NULL,
        0
        );
    
    if (Status == STATUS_PENDING) {
    
        LARGE_INTEGER                   TimeOut;
        
        TimeOut.QuadPart = Int32x32To64((LONG)90000, -1000);
        
        Status = KeWaitForSingleObject(
            SacChannelHandle->SacEvent, 
            Executive, 
            KernelMode, 
            FALSE, 
            &TimeOut
            );
    
        if (Status == STATUS_SUCCESS) {
            Status = IoStatusBlock.Status;
        }
    
    }

    //
    // Close the driver handle
    //
    KSacHandleClose(
        &SacChannelHandle->ChannelHandle->DriverHandle,
        &SacChannelHandle->SacEventHandle,
        &SacChannelHandle->SacEvent
        );

    //
    // Null the channel handle since it is no longer valid
    //
    RtlZeroMemory(SacChannelHandle, sizeof(KSAC_CHANNEL_HANDLE));

    return Status;
}

NTSTATUS
KSacChannelWrite(
    IN PKSAC_CHANNEL_HANDLE SacChannelHandle,
    IN PCBYTE               Buffer,
    IN ULONG                BufferSize
    )

/*++

Routine Description:

    Write the given buffer to the specified SAC Channel       

Arguments:

    SacChannelHandle    - The channel to write the buffer to
    Buffer              - data buffer
    BufferSize          - size of the buffer

Return Value:

    Status

--*/
    
{
    NTSTATUS                Status;
    IO_STATUS_BLOCK         IoStatusBlock;
    ULONG                   WriteChannelCmdSize;
    PSAC_CMD_WRITE_CHANNEL  WriteChannelCmd;
    
    KSAC_VALIDATE_CHANNEL_HANDLE(SacChannelHandle);
    KSAC_API_ASSERT(Buffer, STATUS_INVALID_PARAMETER_2);
    
    //
    // initialize the Write To Channel message structure
    //
    WriteChannelCmdSize = sizeof(SAC_CMD_WRITE_CHANNEL) + (BufferSize * sizeof(UCHAR));
    WriteChannelCmd = (PSAC_CMD_WRITE_CHANNEL)KSAC_API_ALLOCATE_MEMORY(WriteChannelCmdSize);
    KSAC_API_ASSERT(WriteChannelCmd, FALSE);

    //
    // Zero the command structure
    //
    RtlZeroMemory(WriteChannelCmd, WriteChannelCmdSize);

    //
    // Set the length of the string to send
    //
    // Note: Size does not include the terminating NULL, 
    //       becase we don't want to send that.
    //
    WriteChannelCmd->Size = BufferSize;

    //
    // Set the buffer to be written
    //
    WriteChannelCmd->Buffer = Buffer;

    //
    // Indicate which channel this command is for
    //
    WriteChannelCmd->Handle.ChannelHandle = SacChannelHandle->ChannelHandle->ChannelHandle;

    //
    // Send the string to the channel
    //
    Status = ZwDeviceIoControlFile(
        SacChannelHandle->ChannelHandle->DriverHandle,
        SacChannelHandle->SacEventHandle,
        NULL,
        NULL,
        &IoStatusBlock,
        IOCTL_SAC_WRITE_CHANNEL,
        WriteChannelCmd,
        WriteChannelCmdSize,
        NULL,
        0
        );

    if (Status == STATUS_PENDING) {

        LARGE_INTEGER           TimeOut;
        
        TimeOut.QuadPart = Int32x32To64((LONG)90000, -1000);

        Status = KeWaitForSingleObject(
            SacChannelHandle->SacEvent, 
            Executive, 
            KernelMode, 
            FALSE, 
            &TimeOut
            );

        if (Status == STATUS_SUCCESS) {
            Status = IoStatusBlock.Status;
        }

    }

    return Status;
}

NTSTATUS
KSacChannelRawWrite(
    IN KSAC_CHANNEL_HANDLE  SacChannelHandle,
    IN PCBYTE               Buffer,
    IN ULONG                BufferSize
    )

/*++

Routine Description:

    Write the given buffer to the specified SAC Channel       

Arguments:

    SacChannelHandle    - The channel to write the buffer to
    Buffer              - data buffer
    BufferSize          - size of the buffer

Return Value:

    Status

--*/
    
{
                      
    //
    // relay the write to the actual write routine
    //

    return KSacChannelWrite(
        SacChannelHandle,
        Buffer,
        BufferSize
        );

}

NTSTATUS
KSacChannelVTUTF8WriteString(
    IN KSAC_CHANNEL_HANDLE  SacChannelHandle,
    IN PCWSTR               String
    )

/*++

Routine Description:

    This routine writes a null-terminated Unicode String to the specified Channel.

Arguments:

    SacChannelHandle    - The channel to write the buffer to
    String              - A null-terminated Unicode string

Return Value:

    Status

    TRUE --> the buffer was sent

--*/
    
{
    BOOL    Status;
    ULONG   BufferSize;

    //
    // Treating the String as a data buffer, we calculate it's size
    // not including the null termination
    //

    BufferSize = wcslen(String) * sizeof(WCHAR);

    KSAC_API_ASSERT(BufferSize > 0, FALSE);

    //
    // Write the data to the channel
    //

    Status = SacChannelWrite(
        SacChannelHandle,
        (PCBYTE)String,
        BufferSize
        );

    return Status;

}

NTSTATUS
KSacChannelVTUTF8Write(
    IN KSAC_CHANNEL_HANDLE  SacChannelHandle,
    IN PCWCHAR              Buffer,
    IN ULONG                BufferSize
    )

/*++

Routine Description:

    This routines writes an array of WCHAR to the VTUTF8 channel specified.

Arguments:

    SacChannelHandle    - The channel to write the buffer to
    Buffer              - data buffer
    BufferSize          - size of the buffer

    Note: Buffer is not null-terminated
          BufferSize should not count a null-termination.
                                     
Return Value:

    Status

--*/
    
{
    //
    // relay the write to the actual write routine
    //

    return KSacChannelWrite(
        SacChannelHandle,
        (PCBYTE)Buffer,
        BufferSize
        );
}

NTSTATUS
KSacChannelHasNewData(
    IN  PKSAC_CHANNEL_HANDLE    SacChannelHandle,
    OUT PBOOLEAN                InputWaiting 
    )

/*++

Routine Description:

    This routine checks to see if there is any waiting input for 
    the channel specified by the handle

Arguments:

    SacChannelHandle    - the channel to write the string to
    InputWaiting        - the input buffer status
    
Return Value:

    Status

--*/

{
    HEADLESS_RSP_POLL       Response;
    NTSTATUS                Status;
    SIZE_T                  Length;
    IO_STATUS_BLOCK         IoStatusBlock;
    SAC_CMD_POLL_CHANNEL    PollChannelCmd;
    SAC_RSP_POLL_CHANNEL    PollChannelRsp;

    KSAC_VALIDATE_KSAC_CHANNEL_HANDLE(SacChannelHandle);
    
    //
    // Initialize the Poll command
    //
    RtlZeroMemory(&PollChannelCmd, sizeof(SAC_RSP_POLL_CHANNEL));
    
    PollChannelCmd.Handle.ChannelHandle = SacChannelHandle->ChannelHandle->ChannelHandle;
    
    //
    // Send down an IOCTL for polling a channel
    //
    Status = ZwDeviceIoControlFile(
        SacChannelHandle->ChannelHandle->DriverHandle,
        SacChannelHandle->SacEventHandle,
        NULL,
        NULL,
        &IoStatusBlock,
        IOCTL_SAC_POLL_CHANNEL,
        &PollChannelCmd,
        sizeof(PollChannelCmd),
        &PollChannelRsp,
        sizeof(PollChannelRsp)
        );

    if (Status == STATUS_PENDING) {

        LARGE_INTEGER TimeOut;
        
        TimeOut.QuadPart = Int32x32To64((LONG)90000, -1000);

        Status = KeWaitForSingleObject(
            SacChannelHandle->SacEvent, 
            Executive, 
            KernelMode, 
            FALSE, 
            &TimeOut
            );

        if (Status == STATUS_SUCCESS) {
            Status = IoStatusBlock.Status;
        }

    }

    //
    // Return the status to the user
    //
    if (NT_SUCCESS(Status)) {
        *InputWaiting = PollChannelRsp.InputWaiting;
    } else {
        *InputWaiting = FALSE;
    }
    
    return Status;
}

NTSTATUS
KSacChannelRead(
    IN  PKSAC_CHANNEL_HANDLE SacChannelHandle,
    IN  PCBYTE               Buffer,
    IN  ULONG                BufferSize,
    OUT PULONG               ByteCount
    )

/*++

Routine Description:

    This routine reads data from the channel specified.

Arguments:

    SacChannelHandle    - the channel to read from
    Buffer              - destination buffer
    BufferSize          - size of the destination buffer (bytes)
    ByteCount           - the actual # of byte read
    
Return Value:

    Status

--*/

{
    UCHAR                   Byte;
    BOOLEAN                 Success;
    TIME_FIELDS             StartTime;
    TIME_FIELDS             EndTime;
    HEADLESS_RSP_GET_BYTE   Response;
    SIZE_T                  Length;
    NTSTATUS                Status;
    IO_STATUS_BLOCK         IoStatusBlock;
    SAC_CMD_READ_CHANNEL    ReadChannelCmd;
    ULONG                   ReadChannelRspSize;   
    PSAC_RSP_READ_CHANNEL   ReadChannelRsp;

    KSAC_VALIDATE_KSAC_CHANNEL_HANDLE(SacChannelHandle);
    KSAC_API_ASSERT(Buffer, STATUS_INVALID_PARAMETER_2);
    KSAC_API_ASSERT(BufferSize > 0, STATUS_INVALID_PARAMETER_2);
    
    //
    // Initialize the IOCTL command
    //
    ReadChannelCmd.Handle.ChannelHandle = SacChannelHandle->ChannelHandle->ChannelHandle;
    
    //
    // Initialize the IOCTL response
    //
    ReadChannelRsp          = (PSAC_RSP_READ_CHANNEL)Buffer;

    //
    // Send down an IOCTL for reading a channel
    //
    Status = ZwDeviceIoControlFile(
        SacChannelHandle->ChannelHandle->DriverHandle,
        SacChannelHandle->SacEventHandle,
        NULL,
        NULL,
        &IoStatusBlock,
        IOCTL_SAC_READ_CHANNEL,
        &ReadChannelCmd,
        sizeof(ReadChannelCmd),
        ReadChannelRsp,
        ReadChannelRspSize
        );

    if (Status == STATUS_PENDING) {

        LARGE_INTEGER           TimeOut;
        
        TimeOut.QuadPart = Int32x32To64((LONG)90000, -1000);

        Status = KeWaitForSingleObject(
            SacChannelHandle->SacEvent, 
            Executive, 
            KernelMode, 
            FALSE, 
            &TimeOut
            );

        if (Status == STATUS_SUCCESS) {
            Status = IoStatusBlock.Status;
        }

    }

    return Status;
}

NTSTATUS
KSacChannelVTUTF8Read(
    IN  SAC_CHANNEL_HANDLE  SacChannelHandle,
    OUT PWSTR               Buffer,
    IN  ULONG               BufferSize,
    OUT PULONG              ByteCount
    )

/*++

Routine Description:

    This routine reads data from the channel specified.

Arguments:

    SacChannelHandle    - the channel to read from
    Buffer              - destination buffer
    BufferSize          - size of the destination buffer (bytes)
    ByteCount           - the actual # of byte read
    
    Note: the Buffer upon return is NOT null terminated                               
                                   
Return Value:

    Status

--*/

{

    return KSacChannelRead(
        SacChannelHandle,
        (PBYTE)Buffer,
        BufferSize,
        ByteCount
        );

}

NTSTATUS
KSacChannelRawRead(
    IN  KSAC_CHANNEL_HANDLE SacChannelHandle,
    OUT PBYTE               Buffer,
    IN  ULONG               BufferSize,
    OUT PULONG              ByteCount
    )

/*++

Routine Description:

    This routine reads data from the channel specified.

Arguments:

    SacChannelHandle    - the channel to read from
    Buffer              - destination buffer
    BufferSize          - size of the destination buffer (bytes)
    ByteCount           - the actual # of byte read
    
Return Value:

    Status

--*/

{
    
    return KSacChannelRead(
        SacChannelHandle,
        Buffer,
        BufferSize,
        ByteCount
        );

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\headless\lib\sources.inc ===
BASE_SAC_UMODE=$(PROJECT_ROOT)\headless\lib\umode

BASE_SAC_UMODE_C_API_INC=$(BASE_SAC_UMODE)\C\sacapi
BASE_SAC_UMODE_C_API_LIB=$(BASE_SAC_UMODE)\C\sacapi\$(O)\sacapi.lib

BASE_SAC_UMODE_CPP_API_INC=$(BASE_SAC_UMODE)\CPP\emsapi;$(BASE_SAC_UMODE)\CPP\iohandler
BASE_SAC_UMODE_CPP_API_LIB=$(BASE_SAC_UMODE)\CPP\emsapi\$(O)\emsapi.lib $(BASE_SAC_UMODE)\CPP\iohandler\$(O)\iohandler.lib
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\headless\ems\sac\sacrunner\sacrunner.cpp ===
// SacRunner.cpp : Defines the entry point for the console application.
//

#include "inclfile.h"

#include "..\SacCommunicator\SacCommunicator.h"

#include "ntlog.hxx"

#define BUFFER_SIZE 1024

LPCTSTR g_vConnectionParams[]= {"COM1", "9600", "8", "0", "1"};

BOOL    g_bVerbose       = FALSE;

LPCTSTR g_szInputFileName= NULL;
LPCTSTR g_szRespDir      = NULL;

LPCTSTR g_szLogFileName  = NULL;
LPCTSTR g_szNtLogFile    = NULL;
LPCTSTR g_szBvtLogFile    = NULL;

CNtLog  g_ntlogLogger;

UINT g_nPassTotal= 0, g_nFailTotal= 0;

BOOL WriteBvtLog(LPCTSTR szBvtLogFile, double ratioPassLimit, UINT nPassTotal, UINT nFailTotal, time_t tmStart, time_t tmFinish)
{
	fstream f(szBvtLogFile, std::ios::out);

	if (!f.is_open())
		return FALSE;

	LPCTSTR vTestResults[]= {_T("NOCONFIG"), _T("PASS"), _T("FAIL")};
	int nTestResult= !(nPassTotal||nFailTotal) ? 0 : (nPassTotal/(nPassTotal+nFailTotal)<ratioPassLimit)+1;

	f<<"[TESTRESULT]\n";
	f<<"\tTEST:        Basic Sac Stress\n";
	f<<"\tRESULT:      "<<vTestResults[nTestResult]<<'\n';
	f<<"\tCONTACT:     ahmedt\n";
	f<<"\tPM CONTACT:  pasquale\n";
	f<<"\tDEV PRIME:   adamba\n";
	f<<"\tDEV ALT:     adamba\n";
	f<<"\tTEST PRIME:  ahmedt\n";
	f<<"\tTEST ALT:    rgeorge\n";

	struct tm *ptminfoStart, *ptminfoFinish, tminfoStart, tminfoFinish;
	ptminfoStart= localtime(&tmStart);
	tminfoStart= *ptminfoStart;

	ptminfoFinish= localtime(&tmFinish);
	tminfoFinish= *ptminfoFinish;

	f<<"\tSTART TIME:\t\t"<<tminfoStart.tm_mon<<'/'<<tminfoStart.tm_mday<<'/'<<tminfoStart.tm_year<<' '<<tminfoStart.tm_hour<<':'<<tminfoStart.tm_min<<':'<<tminfoStart.tm_sec<<'\n';
	f<<"\tEND TIME:\t\t"<<tminfoFinish.tm_mon<<'/'<<tminfoFinish.tm_mday<<'/'<<tminfoFinish.tm_year<<' '<<tminfoFinish.tm_hour<<':'<<tminfoFinish.tm_min<<':'<<tminfoFinish.tm_sec<<'\n';


	f<<"\n\t[Detailed Results]\n";
	f<<"\t\tPass Count:"<< g_nPassTotal<<'\n';
	f<<"\t\tFail Count:"<< g_nFailTotal<<'\n';
	f<<"\t\t\tFor more info check the command log-file: "<< g_szLogFileName<<'\n';
	f<<"\t[/Detailed Results]\n\n";


	f<<"[/TESTRESULT]\n";

	f.close();

	return TRUE;

}

BOOL RunSac(LPCTSTR szFileName, int nCommPortId, DCB dcb, BOOL b2Screen, LPCTSTR szLogfileName= NULL, LPCSTR szResponseDir= NULL, LPCTSTR szNtLogFile= NULL)
{
	fstream f(szFileName, std::ios::in); // opening file
	if (!f.is_open()) // checking if open
		return FALSE; // cannot open input file then we have nothing to do

	fstream log_f; // log file
	BOOL bLog; // whether to log or not
	if (szLogfileName&&*szLogfileName) // if name supplied
		log_f.open(szLogfileName, std::ios::out); // open file

	bLog= log_f.is_open(); // only can log if log file is open

	CSacCommunicator SacCl(nCommPortId, dcb); // creating a sac client

	if (!SacCl.Connect()) // connecting to sac
	{
		log_f.close();
		f.close();
		return FALSE; // cannot init connection
	}
	// file is open if we r here and connected to port

	BOOL bNtLog; // whether or not having an nt log

	if (bNtLog= szNtLogFile!=NULL) // in order for that a file name has to be supplied
	{
		bNtLog= g_ntlogLogger.Init(szNtLogFile); // and intialization has to succeed so as to be able to log

		if (bNtLog)
			g_ntlogLogger.AttachThread();
	}


	// poke sac
	if (!SacCl.SacCommand( SAC_STR("\r") ))
		return FALSE;

	int nLineNo= 0;
	while (!f.eof())
	{
		++nLineNo; // another line

		if (b2Screen)
			std::cout<<"Line: "<<nLineNo<<'\n'; // echo line #


		TCHAR szStaticBuffer[BUFFER_SIZE]; // reading buffer
		LPTSTR szBuffer;

		szBuffer= szStaticBuffer;
		f.getline(szBuffer, BUFFER_SIZE-1); // reading line taking into consideration the \r appended later


		while (*szBuffer==' '||*szBuffer=='\t')
			szBuffer++; // eat white

		if (!*szBuffer||*szBuffer=='#'||*szBuffer=='\r'||*szBuffer=='\n') // skip empty lines
		{
			if (b2Screen)
				std::cout<<"\tline skipped!!"<<std::endl;
						
			continue; // a comment or an empty line
		}

		int i= 0;
		while (szBuffer[i]!='\0'&&szBuffer[i]!=':')
		{
			if (!_tcsncmp(szBuffer+i, _T("\\\\"), 2))
				break; // rest of line comment

			i++;
		}

		int nCount= 1; // default count is 1
		if (szBuffer[i]==':') // if count present
		{
			int j= 1;
			while (szBuffer[i+j]!='\0')
			{
				if (!_tcsncmp(szBuffer+i+j, _T("//"), 2))
					break;
				j++;
			}

			szBuffer[i+j]= '\0';

			nCount= _ttoi(szBuffer+i+1); // get count
			szBuffer[i]='\0'; // remove it from string
		}

		for (i= _tcslen(szBuffer); i>0&&(szBuffer[i-1]==' '||szBuffer[i-1]=='\t'); i--)
			;

		szBuffer[i]='\0';

		_tcscat(szBuffer, _T("\r")); // append CR

		for (i= 0; i<nCount; i++)
		{
			BOOL bSuccess;
			SacString strResponse;

			if (!_tcscmp(szBuffer, "Paging Off\r")) // look for special command
				bSuccess= SacCl.PagingOff(strResponse);
			else
				bSuccess= SacCl.SacCommand(szBuffer, strResponse, FALSE, 5000);

			g_nPassTotal+= bSuccess;
			g_nFailTotal+= !bSuccess;


			if (szResponseDir) // if output dir specified
			{
				TCHAR szResponseFileBuf[BUFFER_SIZE];

				_tcscpy(szResponseFileBuf, szResponseDir);
				sprintf(szResponseFileBuf+_tcslen(szResponseFileBuf), "\\L%d_C%d.out", nLineNo, i);

				fstream out_f(szResponseFileBuf, std::ios::out);
				if (out_f.is_open())
					out_f<<strResponse.data(); // log out

				out_f.close(); // close out file
			}


			LPCTSTR vstrStatus[]= { _T("FAILURE"), _T("SUCCESS") }; // status string vector

			if (b2Screen)
				std::cout<<"\tCount: "<<i+1<< " -> "<< vstrStatus[bSuccess]<< std::endl; // report 2 screen

			if (bLog)
			{
				log_f<< "Line["<< nLineNo<< "]\\ Count[" <<i+1<<"]-> Command: ";
				log_f<< szBuffer<< "\tStatus: "<< vstrStatus[bSuccess]<< std::endl; // report to log file
			}

			if (bNtLog)
				if (bSuccess)
					if (strResponse.length())
						g_ntlogLogger.Pass("Sac Responded -> L[%d], C[%d]: %s", nLineNo, i, szBuffer);
					else
						g_ntlogLogger.Warn("Sac NIL Response -> L[%d], C[%d]: %s", nLineNo, i, szBuffer);
				else
					g_ntlogLogger.Fail("Sac Communication Failed -> L[%d], C[%d]: %s", nLineNo, i, szBuffer);

		}
	}

	// finally
	goto Terminate;
	Terminate:
	SacCl.Disconnect(); // close connection
	log_f.close(); // close general log
	f.close(); // close input file

	if (bNtLog)
	{
		g_ntlogLogger.DetachThread();
		g_ntlogLogger.Close();
	}


	return TRUE; // that's it
}

BOOL GetArgs(int argc, LPTSTR argv[], LPCTSTR szErrBuffer= NULL)
{

	if (*argv[1]!='-'&&*argv[1]!='/')
		g_szInputFileName= argv[1];

	for (int i= 1; i<argc; i++)
	{
		if (*argv[i]=='-'||*argv[i]=='/')
			switch (*(argv[i]+1))
			{
				case 'I':
					if (*(argv[i]+2))
						g_szInputFileName= argv[i]+2;
					else
						g_szInputFileName= argv[++i];
					break;
				case 'V':
					if (!*(argv[i]+2))
						g_bVerbose= TRUE;
					else
						return FALSE;
					
					break;
				case 'L':
					if (*(argv[i]+2))
						g_szLogFileName= argv[i]+2;
					else
						g_szLogFileName= argv[++i];
					break;
				case 'N':
					if (!_tcsncmp(argv[i]+2, _T("TL"), 2))
						if (*(argv[i]+4))
							g_szNtLogFile= argv[i]+4;
						else
							g_szNtLogFile= argv[++i];
					break;
				case 'B':
					if (!_tcsncmp(argv[i]+2, _T("VTL"), 2))
						if (*(argv[i]+5))
							g_szBvtLogFile= argv[i]+4;
						else
							g_szBvtLogFile= argv[++i];
					break;
				case 'D':
					if (*(argv[i]+2))
						g_szRespDir= argv[i]+2;
					else
						g_szRespDir= argv[++i];
					break;
				case 'C': // -C 9600, 8,N, 1
//					TCHAR* pCurr= *(argv[i]+2)? (argv[i]+2) : argv[++i];
					TCHAR* pCurr= argv[i]+2;

					for (int j= 0; j<4; j++)
					{
						int k;

						if (!*pCurr)
							pCurr= argv[++i];

						for (k= 0; pCurr[k]&&pCurr[k]!=','; )
							k++;

						pCurr[k]= '\0';

						g_vConnectionParams[j]= pCurr;

						pCurr+= k+1;
					}
					break;
			}
	}

	return TRUE;
}

int __cdecl main(int argc, char* argv[])
{
	DCB dcb;

	GetArgs(argc, argv);

	if (!g_szInputFileName)
	{
		std::cout<< "Erorr: no input file name supplied"<< std::endl;
		return !0;
	}

	std::cout<< "attempting to run w/ following options:"<< std::endl;

	if (g_szLogFileName)
		std::cout<< "logging to: "<< g_szLogFileName<< '\n';
	else
		std::cout<< "no log filename supplied, logging truned off\n";

	if (g_szNtLogFile)
		std::cout<< "nt log will be written to: "<< g_szLogFileName<< ".*\n";
	else
		std::cout<< "no nt-log filename supplied, nt-logging truned off\n";

	if (g_szRespDir)
		std::cout<< "sac output files will be located in: "<< g_szRespDir<< "\\\n";
	else
		std::cout<< "no directory specified for sac output files, using current\n";

	if (g_bVerbose)
		std::cout<< "running verbose...\n";
	else
		std::cout<< "running non-verbose...\n";

	std::cout<<std::endl;

	for (int i= 0; CSacCommunicator::s_vctrCommPorts[i]; i++)
		if (!_tcscmp(CSacCommunicator::s_vctrCommPorts[i], g_vConnectionParams[0]))
			break;

	int nCommPort= i;

	BuildCommDCB( CSacCommunicator::s_vctrCommPorts[nCommPort], &dcb);
	dcb.BaudRate = _ttoi(g_vConnectionParams[1]);   // set the baud rate
	dcb.ByteSize = (BYTE) _ttoi(g_vConnectionParams[2]);   // data size, xmit, and rcv
	dcb.Parity   = (BYTE) _ttoi(g_vConnectionParams[3]);   // parity bit
	dcb.StopBits = (BYTE) _ttoi(g_vConnectionParams[4]);   // one stop bit

	time_t tmStart, tmFinish;
	BOOL bTestResult;
	time(&tmStart);
	bTestResult= RunSac(g_szInputFileName, nCommPort, dcb, g_bVerbose, g_szLogFileName, g_szRespDir, g_szNtLogFile);
	time(&tmFinish);

	if (bTestResult)
	{
		WriteBvtLog(g_szBvtLogFile, 0.5, g_nPassTotal, g_nFailTotal, tmStart, tmFinish);
		std::cout<< "\nTEST RESULT: SUCCEEDED!!!\n";
	}
	else
	{
		WriteBvtLog(g_szBvtLogFile, 0.5, 0, 0, tmStart, tmFinish);
		std::cout<< "\nTEST RESULT: NOCONFIG | FAILED!!!\n";
	}

	return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\headless\ems\sac\sacrunner\ntlog.h ===
/*---------------------------------------------------------------------------*\
| NTLOG OBJECT
|   This module defines the NTLOG object.  This header must be include in all
|   modules which make NTLOG calls, or utilizes the definitions.
|
|
| Copyright (C) 1990-1994 Microsoft Corp.
|
| created: 01-Oct-90
| history: 01-Oct-90 <chriswil> created.
|          05-Feb-91 <chriswil> added NOPROLOG style.
|          23-Feb-91 <chriswil> expanded log-flags to DWORD.
|          28-May-91 <chriswil> added per-thread variation tracking.
|          19-Mar-92 <chriswil> redefined struct for shared memory.
|          10-Oct-92 <martys>   added thread macros
|          05-Oct-93 <chriswil> unicode enabled.
|		   10-Oct-96 (darrenf)  fixed _FILE_ for unicode, added _NTLOG_LOGPATH handling
|
\*---------------------------------------------------------------------------*/

#ifndef _NTLOG_
#define _NTLOG_

// If doing C++ stuff, this needs to be here to
// prevent decorating of symbols.
//
#ifdef __cplusplus
extern "C" {
#endif

// **NEW** 10/26/96 Log path environment variable **NEW**
// if the environment variable _NTLOG_LOGPATH is set to a non-empty string
// the value of this variable will be prepended to the log name
// The path should NOT include a trailing backslash.

// No validation is performed on the path, however, if the value is invalid,
// the call to tlCreateLog will fail because CreateFile will fail.

// Basically should be used to force logfiles to a location other than the current directory
// without changing the source file.

// **NEW** 1/20/97 environment variable to force diffable files **NEW**
// if the environment variable _NTLOG_DIFFABLE is set, then log files
// will not contain process and thread specific data, and time and date data.
//


// NTLOG STYLES
//  The folowing are logging levels in which the Log Object can prejudice
//  itself.  These are used by the tlLogCreate() in initializing the
//  Log Object information.  A combination of characteristics is obtained
//  by bitwise OR'ing these identifiers together.
//
#define LOG_LEVELS    0x0000FFFFL    // These are used to mask out the
#define LOG_STYLES    0xFFFF0000L    // styles or levels from log object.

#define TLS_LOGALL    0x0000FFFFL    // Log output.  Logs all the time.
#define TLS_LOG       0x00000000L    // Log output.  Logs all the time.
#define TLS_INFO      0x00002000L    // Log information.
#define TLS_ABORT     0x00000001L    // Log Abort, then kill process.
#define TLS_SEV1      0x00000002L    // Log at Severity 1 level
#define TLS_SEV2      0x00000004L    // Log at Severity 2 level
#define TLS_SEV3      0x00000008L    // Log at Severity 3 level
#define TLS_WARN      0x00000010L    // Log at Warn level
#define TLS_PASS      0x00000020L    // Log at Pass level
#define TLS_BLOCK     0x00000400L    // Block the variation.
#define TLS_BREAK     0x00000800L    // Debugger break;
#define TLS_CALLTREE  0x00000040L    // Log call-tree (function tracking).
#define TLS_SYSTEM    0x00000080L    // Log System debug.
#define TLS_TESTDEBUG 0x00001000L    // Debug level.
#define TLS_TEST      0x00000100L    // Log Test information (user).
#define TLS_VARIATION 0x00000200L    // Log testcase level.

#define TLS_REFRESH   0x00010000L    // Create new file || trunc to zero.
#define TLS_SORT      0x00020000L    // Sort file output by instance.
#define TLS_DEBUG     0x00040000L    // Output to debug (com) monitor).
#define TLS_MONITOR   0x00080000L    // Output to 2nd screen.
#define TLS_VIDCOLOR  0x00100000L    // Use different colors for display output
#define TLS_PROLOG    0x00200000L    // Prolog line information.
#define TLS_WINDOW    0x00400000L    // Log to windows.
#define TLS_ACCESSON  0x00800000L    // Keep log-file open.
#define TLS_DIFFABLE  0x01000000L    // make log file windiff'able (no dates..)
#define TLS_NOHEADER  0x02000000L    // suppress headers so it is more diffable
#define TLS_TIMESTAMP 0x04000000L    // To print the timestamps
#define TLS_VIDEOLOG  0x08000000L    // convert ?.log to ?.bpp.log (color depth)
#define TLS_HTML      0x10000000L    // write log file as an html.


// NTLOG tlLogOut() PARAMETERS
//   The following defines are used in the tlLogOut() function to output the
//   filename and line numbers associated with the caller.  This uses the
//   preprocessors capabilities for obtaining the file/line.
//
#define TL_LOG       TLS_LOG      ,TEXT(__FILE__),(int)__LINE__
#define TL_ABORT     TLS_ABORT    ,TEXT(__FILE__),(int)__LINE__
#define TL_SEV1      TLS_SEV1     ,TEXT(__FILE__),(int)__LINE__
#define TL_SEV2      TLS_SEV2     ,TEXT(__FILE__),(int)__LINE__
#define TL_SEV3      TLS_SEV3     ,TEXT(__FILE__),(int)__LINE__
#define TL_WARN      TLS_WARN     ,TEXT(__FILE__),(int)__LINE__
#define TL_PASS      TLS_PASS     ,TEXT(__FILE__),(int)__LINE__
#define TL_BLOCK     TLS_BLOCK    ,TEXT(__FILE__),(int)__LINE__
#define TL_INFO      TLS_INFO     ,TEXT(__FILE__),(int)__LINE__
#define TL_BREAK     TLS_BREAK    ,TEXT(__FILE__),(int)__LINE__
#define TL_CALLTREE  TLS_CALLTREE ,TEXT(__FILE__),(int)__LINE__
#define TL_SYSTEM    TLS_SYSTEM   ,TEXT(__FILE__),(int)__LINE__
#define TL_TESTDEBUG TLS_TESTDEBUG,TEXT(__FILE__),(int)__LINE__
#define TL_TEST      TLS_TEST     ,TEXT(__FILE__),(int)__LINE__
#define TL_VARIATION TLS_VARIATION,TEXT(__FILE__),(int)__LINE__


//  Struct used by tlGet/SetVar/TestStats
//
typedef struct _NTLOGSTATS {
    int nAbort;
    int nBlock;
    int nSev1;
    int nSev2;
    int nSev3;
    int nWarn;
    int nPass;
}
NTLOGSTATS, *LPNTLOGSTATS;


//  Use enumerated indexes to access palette.
//  Colors are defined in wincon.h

typedef struct _VIDEOPALETTE {
    WORD  wINDEX_DEFAULT;
    WORD  wINDEX_INFO;
    WORD  wINDEX_SEV1;
    WORD  wINDEX_SEV2;
    WORD  wINDEX_SEV3;
    WORD  wINDEX_BLOCK;
    WORD  wINDEX_ABORT;
    WORD  wINDEX_WARN;
    WORD  wINDEX_PASS;
}
VIDEOPALETTE, *LPVIDEOPALETTE;


// NTLOG API (EXPORT METHODS)
//   These routines are exported from the library.  These should be the only
//   interface with the NTLOG object.
//
HANDLE APIENTRY  tlCreateLog_W(LPCWSTR,DWORD);
HANDLE APIENTRY  tlCreateLog_A(LPCSTR,DWORD);
HANDLE APIENTRY  tlCreateLogEx_W(LPCWSTR,DWORD,LPSECURITY_ATTRIBUTES);
HANDLE APIENTRY  tlCreateLogEx_A(LPCSTR,DWORD,LPSECURITY_ATTRIBUTES);
BOOL   APIENTRY  tlDestroyLog(HANDLE);
BOOL   APIENTRY  tlAddParticipant(HANDLE,DWORD,int);
BOOL   APIENTRY  tlRemoveParticipant(HANDLE);
DWORD  APIENTRY  tlParseCmdLine_W(LPCWSTR);
DWORD  APIENTRY  tlParseCmdLine_A(LPCSTR);
int    APIENTRY  tlGetLogFileName_W(HANDLE,LPWSTR);
int    APIENTRY  tlGetLogFileName_A(HANDLE,LPSTR);
BOOL   APIENTRY  tlSetLogFileName_W(HANDLE,LPCWSTR);
BOOL   APIENTRY  tlSetLogFileName_A(HANDLE,LPCSTR);
DWORD  APIENTRY  tlGetLogInfo(HANDLE);
DWORD  APIENTRY  tlSetLogInfo(HANDLE,DWORD);
HANDLE APIENTRY  tlPromptLog(HWND,HANDLE);
int    APIENTRY  tlGetTestStat(HANDLE,DWORD);
int    APIENTRY  tlGetVariationStat(HANDLE,DWORD);
VOID   APIENTRY  tlClearTestStats(HANDLE);
VOID   APIENTRY  tlClearVariationStats(HANDLE);
VOID   APIENTRY  tlSetTestStats(HANDLE,LPNTLOGSTATS);
VOID   APIENTRY  tlSetVariationStats(HANDLE,LPNTLOGSTATS);
BOOL   APIENTRY  tlStartVariation(HANDLE);
DWORD  APIENTRY  tlEndVariation(HANDLE);
VOID   APIENTRY  tlReportStats(HANDLE);
BOOL   APIENTRY  tlLogX_W(HANDLE,DWORD,LPCWSTR,int,LPCWSTR);
BOOL   APIENTRY  tlLogX_A(HANDLE,DWORD,LPCSTR,int,LPCSTR);
BOOL   FAR cdecl tlLog_W(HANDLE,DWORD,LPCWSTR,int,LPCWSTR,...);
BOOL   FAR cdecl tlLog_A(HANDLE,DWORD,LPCSTR,int,LPCSTR,...);
BOOL   APIENTRY  tlGetVideoPalette(HANDLE,LPVIDEOPALETTE);
BOOL   APIENTRY  tlSetVideoPalette(HANDLE,LPVIDEOPALETTE);
BOOL   APIENTRY  tlResetVideoPalette(HANDLE);
VOID   APIENTRY  tlAdjustFileName_W(HANDLE,LPWSTR,UINT);
VOID   APIENTRY  tlAdjustFileName_A(HANDLE,LPSTR,UINT);
BOOL   APIENTRY  tlIsTerminalServerSession();

#ifdef UNICODE
#define tlCreateLog         tlCreateLog_W
#define tlCreateLogEx       tlCreateLogEx_W
#define tlParseCmdLine      tlParseCmdLine_W
#define tlGetLogFileName    tlGetLogFileName_W
#define tlSetLogFileName    tlSetLogFileName_W
#define tlLogX              tlLogX_W
#define tlLog               tlLog_W
#define tlAdjustFileName    tlAdjustFileName_W
#else
#define tlCreateLog         tlCreateLog_A
#define tlCreateLogEx       tlCreateLogEx_A
#define tlParseCmdLine      tlParseCmdLine_A
#define tlGetLogFileName    tlGetLogFileName_A
#define tlSetLogFileName    tlSetLogFileName_A
#define tlLogX              tlLogX_A
#define tlLog               tlLog_A
#define tlAdjustFileName    tlAdjustFileName_A
#endif



// RATS MACROS
//   These macros are provided as a common logging interface which is
//   compatible with the RATS logging-macros.
//
#define TESTDATA                 HANDLE        hLog;
#define TESTOTHERDATA            extern HANDLE hLog;


//  These must be useless.  TL_* macros do not include TLS_TEST or
//  TLS_VARIATION, so they DO NOT count in the stats.  Leaving them around
//  for 'backwards compatibility, if anyone was actually using them...
//
#define L_PASS                   hLog,TL_PASS
#define L_WARN                   hLog,TL_WARN
#define L_DEBUG                  hLog,TL_TESTDEBUG
#define L_TRACE                  hLog,TL_SYSTEM
#define L_FAIL                   hLog,TL_SEV1
#define L_FAIL2                  hLog,TL_SEV2
#define L_FAIL3                  hLog,TL_SEV3
#define L_BLOCK                  hLog,TL_BLOCK


//  macros for incrementing test/variation counts for various log levels
//
#define L_TESTPASS                   hLog,TLS_TEST | TL_PASS
#define L_TESTWARN                   hLog,TLS_TEST | TL_WARN
#define L_TESTDEBUG                  hLog,TLS_TEST | TL_TESTDEBUG
#define L_TESTTRACE                  hLog,TLS_TEST | TL_SYSTEM
#define L_TESTFAIL                   hLog,TLS_TEST | TL_SEV1
#define L_TESTFAIL2                  hLog,TLS_TEST | TL_SEV2
#define L_TESTFAIL3                  hLog,TLS_TEST | TL_SEV3
#define L_TESTBLOCK                  hLog,TLS_TEST | TL_BLOCK
#define L_TESTABORT                  hLog,TLS_TEST | TL_ABORT

#define L_VARPASS                   hLog,TLS_VARIATION | TL_PASS
#define L_VARWARN                   hLog,TLS_VARIATION | TL_WARN
#define L_VARDEBUG                  hLog,TLS_VARIATION | TL_TESTDEBUG
#define L_VARTRACE                  hLog,TLS_VARIATION | TL_SYSTEM
#define L_VARFAIL                   hLog,TLS_VARIATION | TL_SEV1
#define L_VARFAIL2                  hLog,TLS_VARIATION | TL_SEV2
#define L_VARFAIL3                  hLog,TLS_VARIATION | TL_SEV3
#define L_VARBLOCK                  hLog,TLS_VARIATION | TL_BLOCK
#define L_VARABORT                  hLog,TLS_VARIATION | TL_ABORT


#define TESTBEGIN(cmd,logfilename){                                                       \
                                      DWORD __tlFlags;                                    \
                                      __tlFlags = tlParseCmdLine(cmd);                    \
                                      hLog      = tlCreateLog(logfilename,__tlFlags);     \
                                      tlAddParticipant(hLog,0l,0);

#define TESTEND                       tlRemoveParticipant(hLog);                          \
                                      tlDestroyLog(hLog);                                 \
                                  }

#define VARIATION(name,flags)    if(tlStartVariation(hLog))                                                  \
                                 {                                                                           \
                                     DWORD __dwResult;                                                       \
                                     tlLog(hLog,TL_VARIATION,TEXT("%s"),(LPTSTR)name);

#define ENDVARIATION                 __dwResult = tlEndVariation(hLog);                                      \
                                     tlLog(hLog,__dwResult | TL_VARIATION,TEXT("End Variation reported"));   \
                                 }


#define ENTERTHREAD(_hLG,_szNM)  {                                                                           \
                                    LPTSTR _lpFN = _szNM;                                                    \
                                    tlAddParticipant(_hLG,0,0);                                              \
                                    tlLog(_hLG,TL_CALLTREE,TEXT("Entering %s()"),(LPTSTR)_lpFN);


#define LEAVETHREAD(_hLG,_ret)                                                                               \
                                    tlLog(_hLG,TL_CALLTREE,TEXT("Exiting  %s()"),(LPTSTR)_lpFN);             \
                                    tlRemoveParticipant(_hLG);                                               \
                                    return(_ret);                                                            \
                                 }

#define LEAVETHREADVOID(_hLG)                                                                                \
                                     tlLog(_hLG,TL_CALLTREE,TEXT("Exiting  %s()"),(LPTSTR)_lpFN);            \
                                     tlRemoveParticipant(_hLG);                                              \
                                     return;                                                                 \
                                 }


// Macro to report variation PASS/FAIL statistic (based on an expression)
//
#define THPRINTF                tlLog
#define TESTRESULT(expr,msg)    (expr) ? tlLog(L_TESTPASS,TEXT("%s"),(LPTSTR)msg) : tlLog(L_TESTFAIL2,TEXT("%s"),(LPTSTR)msg)
#define TESTFAIL(msg)           TESTSEV2(msg)
#define TESTSEV1(msg)           tlLog(L_TESTFAIL ,TEXT("%s"),(LPTSTR)msg);
#define TESTSEV2(msg)           tlLog(L_TESTFAIL2,TEXT("%s"),(LPTSTR)msg);
#define TESTSEV3(msg)           tlLog(L_TESTFAIL3,TEXT("%s"),(LPTSTR)msg);
#define TESTPASS(msg)           tlLog(L_TESTPASS ,TEXT("%s"),(LPTSTR)msg);
#define TESTABORT(msg)          tlLog(L_TESTABORT,TEXT("%s"),(LPTSTR)msg);
#define TESTWARN(expr,msg)      if(expr) tlLog(L_TESTWARN,TEXT("%s"),(LPTSTR)msg);
#define TESTBLOCK(expr,msg)     if(expr) tlLog(L_TESTBLOCK,TEXT("%s"),(LPTSTR)msg);

#define VARRESULT(expr,msg)    (expr) ? tlLog(L_VARPASS,TEXT("%s"),(LPTSTR)msg) : tlLog(L_VARFAIL2,TEXT("%s"),(LPTSTR)msg)
#define VARFAIL(msg)           VARSEV2(msg)
#define VARSEV1(msg)           tlLog(L_VARFAIL ,TEXT("%s"),(LPTSTR)msg);
#define VARSEV2(msg)           tlLog(L_VARFAIL2,TEXT("%s"),(LPTSTR)msg);
#define VARSEV3(msg)           tlLog(L_VARFAIL3,TEXT("%s"),(LPTSTR)msg);
#define VARPASS(msg)           tlLog(L_VARPASS ,TEXT("%s"),(LPTSTR)msg);
#define VARABORT(msg)          tlLog(L_VARABORT,TEXT("%s"),(LPTSTR)msg);
#define VARWARN(expr,msg)      if(expr) tlLog(L_VARWARN,TEXT("%s"),(LPTSTR)msg);
#define VARBLOCK(expr,msg)     if(expr) tlLog(L_VARBLOCK,TEXT("%s"),(LPTSTR)msg);


#define VAR_SI          0x01                                 // Ship Issue
#define VAR_NSI         0x02                                 // Non-ship Issue
#define VAR_LI          0x03                                 // Less Important
#define VAR_ISSUE_MASK  0x03                                 // To get ship-issue bits only
#define VAR_TIMEABLE    0x04                                 // Var. used in timing suites
#define CORE_API        0x08                                 // API is in most used list
#define CORE_SI         (CORE_API | VAR_TIMEABLE | VAR_SI )  //
#define CORE_NSI        (CORE_API | VAR_TIMEABLE | VAR_NSI)  //
#define NONCORE_SI      (VAR_TIMEABLE | VAR_SI )             //
#define NONCORE_NSI     (VAR_TIMEABLE | VAR_NSI)             //



// CALLTREE Macros
//   These macros are useful for bracketing function-calls.
//
#define ENTER(_hLG,_szNM) {                                                                 \
                              LPTSTR _lpFN = _szNM;                                         \
                              tlLog(_hLG,TL_CALLTREE,TEXT("Entering %s()"),(LPTSTR)_lpFN);


#define LEAVE(_hLG,_ret)                                                                    \
                              tlLog(_hLG,TL_CALLTREE,TEXT("Exiting  %s()"),(LPTSTR)_lpFN);  \
                              return(_ret);                                                 \
                          }

#define LEAVEVOID(_hLG)                                                                     \
                              tlLog(_hLG,TL_CALLTREE,TEXT("Exiting  %s()"),(LPTSTR)_lpFN);  \
                              return;                                                       \
                          }

#ifdef __cplusplus
}
#endif

#define LPSZ_KEY_EMPTY    TEXT("None")
#define LPSZ_TERM_SERVER  TEXT("Terminal Server")

#endif  // _NTLOG_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\headless\lib\kmode\c\ksacapi\ksacapi.h ===
/*++

Copyright (c) 2001  Microsoft Corporation

Module Name:

    ksacapi.c

Abstract:

    This is the C library header used to interface to SAC driver.

Author:

    Brian Guarraci (briangu)

Revision History:

--*/

#ifndef _KSAC_API_H
#define _KSAC_API_H

#include <ksacapip.h>
#include <ntddsac.h>

//
// This structure contains the Sac Channel Handle
// as well as kernel mode specific attributes
//
typedef struct _KSAC_CHANNEL_HANDLE {
    SAC_CHANNEL_HANDLE  ChannelHandle;
    HANDLE              SacEventHandle;
    PKEVENT             SacEvent;
} KSAC_CHANNEL_HANDLE, *PKSAC_CHANNEL_HANDLE;

//
// this should really be in windefs or somewhere like that.
//               
typedef const PBYTE  PCBYTE;
typedef const PWCHAR PCWCHAR;

BOOL
KSacChannelOpen(
    OUT PKSAC_CHANNEL_HANDLE            SacChannelHandle,
    IN  PSAC_CHANNEL_OPEN_ATTRIBUTES    SacChannelAttributes
    );

BOOL
KSacChannelClose(
    IN OUT PKSAC_CHANNEL_HANDLE  SacChannelHandle
    );

BOOL
KSacChannelWrite(
    IN KSAC_CHANNEL_HANDLE  SacChannelHandle,
    IN PCBYTE               Buffer,
    IN ULONG                BufferSize
    );

BOOL
KSacChannelRawWrite(
    IN KSAC_CHANNEL_HANDLE  SacChannelHandle,
    IN PCBYTE               Buffer,
    IN ULONG                BufferSize
    );

BOOL
KSacChannelVTUTF8Write(
    IN KSAC_CHANNEL_HANDLE  SacChannelHandle,
    IN PCWCHAR              Buffer,
    IN ULONG                BufferSize
    );

BOOL
KSacChannelVTUTF8WriteString(
    IN KSAC_CHANNEL_HANDLE  SacChannelHandle,
    IN PCWSTR               String
    );

BOOL
KSacChannelHasNewData(
    IN  KSAC_CHANNEL_HANDLE SacChannelHandle,
    OUT PBOOL               InputWaiting 
    );

BOOL
KSacChannelGetAttribute(
    IN  KSAC_CHANNEL_HANDLE             SacChannelHandle,
    IN  SAC_CHANNEL_ATTRIBUTE           SacChannelAttribute,
    OUT PSAC_RSP_GET_CHANNEL_ATTRIBUTE  SacChannelAttributeValue
    );

BOOL
KSacChannelSetAttribute(
    IN KSAC_CHANNEL_HANDLE      SacChannelHandle,
    IN SAC_CHANNEL_ATTRIBUTE    SacChannelAttribute,
    IN PVOID                    SacChannelAttributeValue
    );

BOOL
KSacChannelGetStatus(
    IN  KSAC_CHANNEL_HANDLE     SacChannelHandle,
    OUT PSAC_CHANNEL_STATUS     SacChannelStatus
    );

BOOL
KSacChannelRead(
    IN  KSAC_CHANNEL_HANDLE SacChannelHandle,
    OUT PBYTE               Buffer,
    IN  ULONG               BufferSize,
    OUT PULONG              ByteCount
    );

BOOL
KSacChannelRawRead(
    IN  KSAC_CHANNEL_HANDLE SacChannelHandle,
    OUT PBYTE               Buffer,
    IN  ULONG               BufferSize,
    OUT PULONG              ByteCount
    );

BOOL
KSacChannelVTUTF8Read(
    IN  KSAC_CHANNEL_HANDLE SacChannelHandle,
    OUT PWSTR               Buffer,
    IN  ULONG               BufferSize,
    OUT PULONG              ByteCount
    );

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\headless\ems\sac\sacrunner\saccommunicator.cpp ===
// SacCommunicator.cpp: implementation of the CSacCommunicator class.
//
//////////////////////////////////////////////////////////////////////

#include "inclfile.h"

#include "..\SacCommunicator\SacCommunicator.h"

//#include "Debug.cpp"

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

LPTSTR CSacCommunicator::s_vctrCommPorts[]= {_T("COM1"), _T("COM2"), NULL};
SacString CSacCommunicator::s_strDummyReponse;

BOOL CSacCommunicator::XReadFile(
		HANDLE hFile,                // handle to file
		LPVOID lpBuffer,             // data buffer
		DWORD nNumberOfBytesToRead,  // number of bytes to read
		LPDWORD lpNumberOfBytesRead, // number of bytes read
		LPOVERLAPPED lpOverlapped,    // overlapped buffer
		time_t tmTimeout  // time-out
)
{
	time_t tmInitReadTime, tmCurrTime;
	time(&tmInitReadTime); // stamp

	BOOL bLastRead;

	while (!(bLastRead= ReadFile(hFile, lpBuffer, nNumberOfBytesToRead, lpNumberOfBytesRead, lpOverlapped)) || !*lpNumberOfBytesRead)
	{
		time(&tmCurrTime); // stamp

		if (tmCurrTime-tmInitReadTime>tmTimeout)
			break;
	}

	return bLastRead;
}

CSacCommunicator::CSacCommunicator(int nCommPort, DCB dcb)
{
	_Construct(nCommPort, dcb);
}

CSacCommunicator::~CSacCommunicator()
{
	_Clean();
}

void CSacCommunicator::_Construct(int nCommPort, DCB dcb)
{
	m_nCommPort= nCommPort;
	m_dcb= dcb;

	m_hCommPort= INVALID_HANDLE_VALUE;
}

void CSacCommunicator::_Clean()
{
	if (IsConnected())
		Disconnect();
}

BOOL CSacCommunicator::Connect()
{
	m_hCommPort= CreateFile(s_vctrCommPorts[m_nCommPort], GENERIC_READ|GENERIC_WRITE, 0, NULL, OPEN_EXISTING, 0, NULL);
	// open handle

	if (m_hCommPort!=INVALID_HANDLE_VALUE)
	{
		if (!SetCommMask(m_hCommPort, EV_RXCHAR)) // masking all events but the char. read event
			return FALSE; // init call has to succeed

		COMMTIMEOUTS tmouts;
		ZeroMemory(&tmouts,sizeof(COMMTIMEOUTS));
		tmouts.ReadIntervalTimeout= MAXDWORD; // no blocking

		if (!SetCommTimeouts(m_hCommPort, &tmouts)) // non-blocking read
			return FALSE; // has to succeed as well
	}

	return m_hCommPort!=INVALID_HANDLE_VALUE; // check if succeeded
}

BOOL CSacCommunicator::Disconnect()
{
	CloseHandle(m_hCommPort); // close the handle

	m_hCommPort= INVALID_HANDLE_VALUE;
	return m_hCommPort==INVALID_HANDLE_VALUE; // has to succeed
}

BOOL CSacCommunicator::IsConnected()
{
	return m_hCommPort!=INVALID_HANDLE_VALUE;
}

BOOL CSacCommunicator::PokeSac() // currently disabled
{
	return FALSE;
}

BOOL CSacCommunicator::SacCommand(SAC_STR szRequest, SacString& strResponse, BOOL bPoke, time_t tmTimeout)
{
	time_t tmInitTime, tmCurrTime;
	time(&tmInitTime);

	strResponse= ""; // init response

	if (bPoke) // if asked:
/*		if (!PokeSac()) // poke sac
			return FALSE; // make sure to get response*/
		0; // disabled
		

	DWORD nBytesWritten, nBytesRead;
	SAC_CHAR szReturned[BUF_LEN]; // whatever is written by sac
	
	for (int i= 0; i<SAC_STRLEN(szRequest); i++) // baby-feeding sac
	{
		if (!WriteFile( m_hCommPort, szRequest+i, sizeof(SAC_CHAR), &nBytesWritten, NULL)) // feed sac
			return FALSE; // io must succeed

		time(&tmCurrTime);
		tmTimeout-= tmCurrTime-tmInitTime;
		if (!XReadFile( m_hCommPort, szReturned, sizeof(SAC_CHAR), &nBytesRead, NULL, tmTimeout)||!nBytesRead) // feed sac
			return FALSE; // io must succeed && must receive echo back
	}

	time(&tmCurrTime);
	tmTimeout-= tmCurrTime-tmInitTime;
	if (!XReadFile( m_hCommPort, szReturned, sizeof(SAC_CHAR), &nBytesRead, NULL, tmTimeout)||!nBytesRead) // feed sac
		return FALSE; // io must succeed && must receive echo back

//	DWORD dwEvtMask;
	
	DWORD dwErrors; // port errors
	COMSTAT stat;   // io status


	time(&tmInitTime);

	do
	{

		//dwEvtMask= 0;
		//while (!(dwEvtMask & EV_RXCHAR)
		//	if (!WaitCommEvent(m_hCommPort, &dwEvtMask, NULL))
		//		return FALSE;

		ClearCommError(m_hCommPort, &dwErrors, &stat); // peek into buffer

		if (!ReadFile(m_hCommPort, szReturned, stat.cbInQue, &nBytesRead, NULL)) // receive echo-back
			return FALSE; // io must succeed
		
		if (!nBytesRead)
			continue; // save some worthless instructions then

		szReturned[nBytesRead]= '\0'; // fix it
		strResponse.append(szReturned); // add to response

		time(&tmCurrTime);
	} while ((strResponse.rfind(SAC_TEXT("SAC>"))==SacString::npos)&&(tmCurrTime-tmInitTime<tmTimeout));

 	int nPosSacPrompt= strResponse.rfind(SAC_TEXT("SAC>"));
	if (!nPosSacPrompt)
		return FALSE; // no prompt back 

	strResponse.erase(nPosSacPrompt, SAC_STRLEN(SAC_TEXT("SAC>")));

	return TRUE; // at last sac echoed back!!!
}

BOOL CSacCommunicator::PagingOff(SacString& strResponse)
{
	if (!SacCommand(SAC_STR("p\r"), strResponse, FALSE)) // toggle paging
		return FALSE;

	if (strResponse.find(SAC_STR("OFF"))!=SacString::npos) // check state
		return TRUE;

	// if we r here then supposedly it's on, need to toggle once more
	if (!SacCommand(SAC_STR("p\r"), strResponse, FALSE)) // toggle paging
		return FALSE;

	if (strResponse.find(SAC_STR("OFF"))!=SacString::npos) // re-check
		return TRUE;

	return FALSE; // desperate
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\headless\lib\kmode\c\ksacapi\ksacapip.h ===
/*++

Copyright (c) 1995 Microsoft Corporation

Module Name:

    ksacapip.h
    
Abstract:

    Private top-level header file for SAC API module.

Author:

    Brian Guarraci (briangu)
    
Revision History:

--*/


//
// System header files
//
#include "wdm.h"
#include "nt.h"
#include "windef.h"
//#include "ntrtl.h"
//#include "nturtl.h"
//#include "windows.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\headless\lib\umode\c\sacapi\sacapip.h ===
/*++

Copyright (c) 1995 Microsoft Corporation

Module Name:

    sacapip.h
    
Abstract:

    Private top-level header file for SAC API module.

Author:

    Brian Guarraci (briangu)
    
Revision History:

--*/


//
// System header files
//
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
//#define OEMRESOURCE     // setting this gets OBM_ constants in windows.h
#include <windows.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\headless\lib\umode\cpp\emsapi\emsapip.h ===
/*++

Copyright (c) 1995 Microsoft Corporation

Module Name:

    sacapip.h
    
Abstract:

    Private top-level header file for SAC API module.

Author:

    Brian Guarraci (briangu)
    
Revision History:

--*/


//
// System header files
//
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
//#define OEMRESOURCE     // setting this gets OBM_ constants in windows.h
#include <windows.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\headless\lib\umode\cpp\emsapi\emsapi.h ===
/*++

Copyright (c) 2001 Microsoft Corporation

Module Name:

    emsapi.h

Abstract:

    This module provides the C++ foundation classes for implementing
    SAC channels.

Author:

    Brian Guarraci (briangu), 2001             
                 
Revision History:

--*/
#ifndef _EMS_API_H
#define _EMS_API_H

extern "C" {
#include <sacapi.h>
}

///////////////////////////////////////////////////////////
//
// This class defines the base channel object.  It is primarily
// a base interface class with a handle to the channel.  Children
// of this are generally variations of the interface.
//
///////////////////////////////////////////////////////////

class EMSChannel {

protected:

    //
    // Don't let users instantiate directly
    //
    EMSChannel();

    //
    // Status determining if we have a valid channel handle
    //
    BOOL    myHaveValidHandle;

    inline BOOL
    HaveValidHandle(
        VOID
        )
    {
        return myHaveValidHandle;
    }

    //
    // The channel handle the instace refers to
    //
    SAC_CHANNEL_HANDLE  myEMSChannelHandle;

    //
    // opens the channel during construction
    //
    BOOL
    virtual Open(
        IN  SAC_CHANNEL_OPEN_ATTRIBUTES ChannelAttributes
        );
    
    //
    // closes the channel during destruction
    //
    BOOL
    virtual Close(
        VOID
        );

public:

    virtual ~EMSChannel();

    static EMSChannel*
    Construct(
        IN  SAC_CHANNEL_OPEN_ATTRIBUTES ChannelAttributes
        );
    
    //
    // Get the channel handle
    //
    inline SAC_CHANNEL_HANDLE
    GetEMSChannelHandle(
        VOID
        )
    {
        return myEMSChannelHandle; 
    }
    
    //
    // Determine if the channel has new data to read
    //
    BOOL
    HasNewData(
        OUT PBOOL               InputWaiting 
        );

};

///////////////////////////////////////////////////////////
//
///////////////////////////////////////////////////////////

class EMSRawChannel : public EMSChannel {

protected:

    //
    // Don't let users instantiate the channel directly
    //
    EMSRawChannel();

public:

    static EMSRawChannel*
    Construct(
        IN  SAC_CHANNEL_OPEN_ATTRIBUTES ChannelAttributes
        );
    
    virtual ~EMSRawChannel();

    //
    // Manual I/O functions
    //

    BOOL
    Write(
        IN PCBYTE   Buffer,
        IN ULONG    BufferSize
        );
    
    BOOL
    Read(
        OUT PBYTE   Buffer,
        IN  ULONG   BufferSize,
        OUT PULONG  ByteCount
        );

};

///////////////////////////////////////////////////////////
//
///////////////////////////////////////////////////////////

class EMSVTUTF8Channel : public EMSChannel {

private:

    //
    // Don't let users instantiate the channel directly
    //
    EMSVTUTF8Channel();

public:

    virtual ~EMSVTUTF8Channel();
    
    static EMSVTUTF8Channel*
    Construct(
        IN  SAC_CHANNEL_OPEN_ATTRIBUTES ChannelAttributes
        );
    
    BOOL
    Write(
        IN PCWCHAR  Buffer,
        IN ULONG    BufferSize
        );
    
    BOOL
    Write(
        IN PCWSTR   Buffer
        );
    
    BOOL
    Read(
        OUT PWSTR   Buffer,
        IN  ULONG   BufferSize,
        OUT PULONG  ByteCount
        );


};

///////////////////////////////////////////////////////////
//
///////////////////////////////////////////////////////////

class EMSCmdChannel : public EMSChannel {

protected:

    //
    // Don't let users instantiate the channel directly
    //
    EMSCmdChannel();

public:

    static EMSCmdChannel*
    Construct(
        IN  SAC_CHANNEL_OPEN_ATTRIBUTES ChannelAttributes
        );
    
    virtual ~EMSCmdChannel();

    BOOL
    Write(
        IN PCBYTE   Buffer,
        IN ULONG    BufferSize
        );
    
    BOOL
    Read(
        OUT PBYTE   Buffer,
        IN  ULONG   BufferSize,
        OUT PULONG  ByteCount
        );

};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\headless\lib\umode\cpp\emsapi\channel.cpp ===
/*++

Copyright (c) 2001 Microsoft Corporation

Module Name:

    channel.cpp    

Abstract:

    This module implements the foundation channel classes.           
               
Author:

    Brian Guarraci (briangu), 2001                                                          
                                                          
Revision History:

--*/

#include <emsapip.h>
#include <emsapi.h>
#include <ntddsac.h>

EMSChannel::EMSChannel()
/*++

Routine Description:

    Constructor

Arguments:

    None           
               
Return Value:

    N/A
        
--*/
{
    //
    // We do not have a handle yet, 
    // so prevent ourselves from calling Close()
    //
    myHaveValidHandle = FALSE;
}

EMSChannel::~EMSChannel()
/*++

Routine Description:

    Desctructor

Arguments:

    N/A
               
Return Value:

    N/A
        
--*/
{
    //
    // If we have a valid handle, 
    // then close the channel
    //
    if (HaveValidHandle()) {
        Close();
    }
}

EMSChannel*
EMSChannel::Construct(
    IN  SAC_CHANNEL_OPEN_ATTRIBUTES ChannelAttributes
    )
/*++

Routine Description:

    Create a new channel object

Arguments:

    ChannelAttributes   - the attributes of the channel to create
                            
Return Value:

    Status

    TRUE  --> pHandle is valid
     
--*/
{
    EMSChannel  *Channel;

    //
    // Create an uninitialized channel object
    //
    Channel = new EMSChannel();

    //
    // Attempt to open the specified channel
    //
    Channel->myHaveValidHandle = Channel->Open(ChannelAttributes);

    //
    // If we failed, then delete our channel object
    //
    if (!Channel->HaveValidHandle()) {
        
        delete Channel;
        
        //
        // return a NULL channel object
        // 
        Channel = NULL;
    
    } 

    return Channel;
}

BOOL
EMSChannel::Open(
    IN  SAC_CHANNEL_OPEN_ATTRIBUTES ChannelAttributes
    )
/*++

Routine Description:

    Open a SAC channel of the specified name

Arguments:

    EMSChannelName      - The name of the newly created channel
    ChannelAttributes   - the attributes of the channel to create
                        
Return Value:

    Status

    TRUE  --> pHandle is valid
     
--*/

{
    
    ASSERT(! HaveValidHandle());

    //
    // Attempt to open the channel
    //
    return SacChannelOpen(
        &myEMSChannelHandle,
        &ChannelAttributes
        );

}
    
BOOL
EMSChannel::Close(
    VOID
    )    

/*++

Routine Description:

    Close the specified SAC channel 
                
    NOTE: the channel pointer is made NULL under all conditions

Arguments:

    None

Return Value:

    Status
    
    TRUE --> the channel was closed or we didn't need to close it

--*/

{
    
    ASSERT(HaveValidHandle());

    //
    // attempt to close the channel
    //
    return SacChannelClose(
        &myEMSChannelHandle
        );

}

BOOL
EMSChannel::HasNewData(
    OUT PBOOL               InputWaiting 
    )

/*++

Routine Description:

    This routine checks to see if there is any waiting input for 
    the channel specified by the handle

Arguments:

    InputWaiting        - the input buffer status
    
Return Value:

    Status

    TRUE --> the buffer was sent

--*/

{

    ASSERT(HaveValidHandle());

    return SacChannelHasNewData(
        GetEMSChannelHandle(),
        InputWaiting
        );

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\headless\lib\umode\c\sacapi\sacapi.h ===
/*++

Copyright (c) 2001  Microsoft Corporation

Module Name:

    sacapi.c

Abstract:

    This is the C library header used to interface to SAC driver.

Author:

    Brian Guarraci (briangu)

Revision History:

--*/

#ifndef _SAC_API_H
#define _SAC_API_H

#include <ntddsac.h>

//
// this should really be in windefs or somewhere like that.
//               
typedef const PBYTE  PCBYTE;
typedef const PWCHAR PCWCHAR;

BOOL
SacChannelOpen(
    OUT PSAC_CHANNEL_HANDLE             SacChannelHandle,
    IN  PSAC_CHANNEL_OPEN_ATTRIBUTES    SacChannelAttributes
    );

BOOL
SacChannelClose(
    IN OUT PSAC_CHANNEL_HANDLE  SacChannelHandle
    );

BOOL
SacChannelWrite(
    IN SAC_CHANNEL_HANDLE   SacChannelHandle,
    IN PCBYTE               Buffer,
    IN ULONG                BufferSize
    );

BOOL
SacChannelRawWrite(
    IN SAC_CHANNEL_HANDLE   SacChannelHandle,
    IN PCBYTE               Buffer,
    IN ULONG                BufferSize
    );

BOOL
SacChannelVTUTF8Write(
    IN SAC_CHANNEL_HANDLE   SacChannelHandle,
    IN PCWCHAR              Buffer,
    IN ULONG                BufferSize
    );

BOOL
SacChannelVTUTF8WriteString(
    IN SAC_CHANNEL_HANDLE   SacChannelHandle,
    IN PCWSTR               String
    );

BOOL
SacChannelHasNewData(
    IN  SAC_CHANNEL_HANDLE  SacChannelHandle,
    OUT PBOOL               InputWaiting 
    );

BOOL
SacChannelRead(
    IN  SAC_CHANNEL_HANDLE  SacChannelHandle,
    OUT PBYTE               Buffer,
    IN  ULONG               BufferSize,
    OUT PULONG              ByteCount
    );

BOOL
SacChannelRawRead(
    IN  SAC_CHANNEL_HANDLE  SacChannelHandle,
    OUT PBYTE               Buffer,
    IN  ULONG               BufferSize,
    OUT PULONG              ByteCount
    );

BOOL
SacChannelVTUTF8Read(
    IN  SAC_CHANNEL_HANDLE  SacChannelHandle,
    OUT PWSTR               Buffer,
    IN  ULONG               BufferSize,
    OUT PULONG              ByteCount
    );

BOOL
SacRegisterCmdEvent(
    OUT HANDLE      *pDriverHandle,
    IN  HANDLE       RequestSacCmdEvent,
    IN  HANDLE       RequestSacCmdSuccessEvent,
    IN  HANDLE       RequestSacCmdFailureEvent
    );

BOOL
SacUnRegisterCmdEvent(
    IN OUT HANDLE   *pDriverHandle
    );

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\headless\lib\umode\cpp\emsapi\cmdchan.cpp ===
/*++

Copyright (c) 2001 Microsoft Corporation

Module Name:

    cmdchan.cpp

Abstract:

    This module implements the Cmd console session class that
    is used by sacsess.

Author:

    Brian Guarraci (briangu), 2001
                       
Revision History:

--*/
#include <emsapip.h>
#include <emsapi.h>
#include <ntddsac.h>

EMSCmdChannel::EMSCmdChannel(
    VOID
    )
/*++

Routine Description:

    Constructor

Arguments:

    None
               
Return Value:

    N/A
        
--*/
{
    NOTHING;
}
     
EMSCmdChannel::~EMSCmdChannel()
/*++

Routine Description:

    Desctructor

Arguments:

    N/A
               
Return Value:

    N/A
        
--*/
{
    NOTHING;
}

EMSCmdChannel*
EMSCmdChannel::Construct(
    IN  SAC_CHANNEL_OPEN_ATTRIBUTES ChannelAttributes
    )
/*++

Routine Description:

    Create a new channel object

Arguments:

    EMSCmdChannelName          - The name of the newly created channel
                        
Return Value:

    Status

    TRUE  --> pHandle is valid
     
--*/
{
    EMSCmdChannel       *Channel;

    //
    // Force the appropriate channel attributes
    //
    ChannelAttributes.Type = ChannelTypeCmd;

    //
    // Attempt to open the channel
    //
    Channel = (EMSCmdChannel*) EMSChannel::Construct(
        ChannelAttributes
        );

    return Channel;
}

BOOL
EMSCmdChannel::Write(
    IN PCBYTE   Buffer,
    IN ULONG    BufferSize
    )

/*++

Routine Description:

    Write the given buffer to the specified SAC Channel       

Arguments:

    String  - Unicode string to write

Return Value:

    Status

    TRUE --> the buffer was sent

--*/
    
{

    return SacChannelRawWrite(
        GetEMSChannelHandle(),
        Buffer,
        BufferSize
        );

}

BOOL
EMSCmdChannel::Read(
    OUT PBYTE                Buffer,
    IN  ULONG                BufferSize,
    OUT PULONG               ByteCount
    )

/*++

Routine Description:

    This routine reads data from the channel specified.

Arguments:

    Buffer              - destination buffer
    BufferSize          - size of the destination buffer (bytes)
    ByteCount           - the actual # of byte read
    
Return Value:

    Status

    TRUE --> the buffer was sent

--*/

{

    return SacChannelRawRead(
        GetEMSChannelHandle(),
        Buffer,
        BufferSize,
        ByteCount
        );

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\headless\lib\umode\c\sacapi\sacapi.c ===
/*++

Copyright (c) 2001  Microsoft Corporation

Module Name:

    sacapi.c

Abstract:

    This is the C library used to interface to SAC driver.

Author:

    Brian Guarraci (briangu)

Revision History:

--*/

#include "sacapip.h"

#include <sacapi.h>
#include <ntddsac.h>

#if DBG
//
// Counter to keep track of how many driver handles have been
// requested and released.
//
static ULONG    DriverHandleRefCount = 0;
#endif

//
// Memory management routine aliases
//                                     
#define SAC_API_ALLOCATE_MEMORY(s)  LocalAlloc(LPTR, (s))
#define SAC_API_FREE_MEMORY(p)      LocalFree(p)

//
// enhanced assertion:
//
// First assert the condition,
// if ASSERTs are turned off,
// we bail out of the function with a status
//
#define SAC_API_ASSERT(c,s) \
    ASSERT(c);              \
    if (!(c)) {             \
        Status = s;         \
        __leave;            \
    }

typedef GUID*   PGUID;

BOOL
SacHandleOpen(
    OUT HANDLE* SacHandle
    )
/*++

Routine Description:

    Initialize a handle to the SAC driver

Arguments:

    SacHandle   - A pointer to the SAC Handle
    
Return Value:

    Status

    TRUE  --> SacHandle is valid
     
--*/
{
    BOOL    Status;

    Status = TRUE;

    __try {
        
        SAC_API_ASSERT(SacHandle, FALSE);

        //
        // Open the SAC
        //
        // SECURITY:
        //
        //  this handle cannot be inherited
        //
        *SacHandle = CreateFile(
            L"\\\\.\\SAC",
            GENERIC_READ | GENERIC_WRITE,
            0,
            NULL,
            OPEN_EXISTING,
            0,
            NULL 
            );
    
        if (*SacHandle == INVALID_HANDLE_VALUE) {
            
            Status = FALSE;
        
        } 
#if DBG
        else {
            InterlockedIncrement((volatile long *)&DriverHandleRefCount);
        }
#endif
    
    }
    __except(EXCEPTION_EXECUTE_HANDLER) {
        ASSERT(0);
        Status = FALSE;
    }

    return Status;
}

BOOL
SacHandleClose(
    IN OUT HANDLE*  SacHandle
    )
/*++

Routine Description:

    Close the handle to the SAC driver

Arguments:

    SacHandle   - A handle to the SAC driver

Return Value:

    Status
    
    TRUE --> SacHandle is now invalid (NULL)
      
--*/
{
    BOOL    Status;

    //
    // default: we succeeded to close the handle
    //
    Status = TRUE;
    
    __try {
        
        SAC_API_ASSERT(SacHandle, FALSE);
        SAC_API_ASSERT(*SacHandle != INVALID_HANDLE_VALUE, FALSE);
    
        //
        // close the handle to the SAC driver
        //
        Status = CloseHandle(*SacHandle);

        if (Status == TRUE) {
            
            //
            // NULL the SAC driver handle
            //
            *SacHandle = INVALID_HANDLE_VALUE;
        
#if DBG
            InterlockedDecrement((volatile long *)&DriverHandleRefCount);
#endif
        
        }
        
    }
    __except(EXCEPTION_EXECUTE_HANDLER) {
        ASSERT(0);
        Status = FALSE;
    }
    
    return Status;
}

BOOL
SacChannelOpen(
    OUT PSAC_CHANNEL_HANDLE             SacChannelHandle,
    IN  PSAC_CHANNEL_OPEN_ATTRIBUTES    SacChannelAttributes
    )
/*++

Routine Description:

    Open a SAC channel of the specified name

Arguments:

    SacChannelHandle            - The handle to the newly created channel
    SacChannelAttributes        - The attributes describing the new channel
                    
    Note: The SacChannelDescription parameter is optional.  
          
          If SacChannelDescription != NULL, 
            then the Channel description will be assigned the Unicode string pointed to
            by SacChannelDescription.    
          If SacChannelDescription == NULL, 
            then the Channel description will be null upon creation.    
                        
Return Value:

    Status

    TRUE  --> pHandle is valid
     
--*/

{
    BOOL                    Status;
    ULONG                   OpenChannelCmdSize;
    PSAC_CMD_OPEN_CHANNEL   OpenChannelCmd;
    SAC_RSP_OPEN_CHANNEL    OpenChannelRsp;
    DWORD                   Feedback;
    HANDLE                  DriverHandle;

    //
    // default
    //
    Status = FALSE;
    OpenChannelCmdSize = 0;
    OpenChannelCmd = NULL;
    DriverHandle = INVALID_HANDLE_VALUE;

    __try {
        
        SAC_API_ASSERT(SacChannelHandle, FALSE);
        SAC_API_ASSERT(SacChannelAttributes, FALSE);

        //
        // Get a handle to the driver and store it in the 
        // Channel handle.  This way, the api user doesn't have
        // explicitly open/close the driver handle.
        // 
        Status = SacHandleOpen(&DriverHandle);

        if ((Status != TRUE) ||
            (DriverHandle == INVALID_HANDLE_VALUE)) {
            Status = FALSE;
            __leave;
        }

        SAC_API_ASSERT(Status == TRUE, FALSE);
        SAC_API_ASSERT(DriverHandle != INVALID_HANDLE_VALUE, FALSE);

        //
        // Verify that if the user wants to use the CLOSE_EVENT, we received one to use
        //
        SAC_API_ASSERT(
            ((SacChannelAttributes->Flags & SAC_CHANNEL_FLAG_CLOSE_EVENT) 
             && SacChannelAttributes->CloseEvent) ||
            (!(SacChannelAttributes->Flags & SAC_CHANNEL_FLAG_CLOSE_EVENT) 
             && !SacChannelAttributes->CloseEvent),
            FALSE
            );

        //
        // Verify that if the user wants to use the HAS_NEW_DATA_EVENT, we received one to use
        //
        SAC_API_ASSERT(
            ((SacChannelAttributes->Flags & SAC_CHANNEL_FLAG_HAS_NEW_DATA_EVENT) 
             && SacChannelAttributes->HasNewDataEvent) ||
            (!(SacChannelAttributes->Flags & SAC_CHANNEL_FLAG_HAS_NEW_DATA_EVENT) 
             && !SacChannelAttributes->HasNewDataEvent),
            FALSE
            );

#if ENABLE_CHANNEL_LOCKING
        //
        // Verify that if the user wants to use the LOCK_EVENT, we received one to use
        //
        SAC_API_ASSERT(
            ((SacChannelAttributes->Flags & SAC_CHANNEL_FLAG_LOCK_EVENT) 
             && SacChannelAttributes->LockEvent) ||
            (!(SacChannelAttributes->Flags & SAC_CHANNEL_FLAG_LOCK_EVENT) 
             && !SacChannelAttributes->LockEvent),
            FALSE
            );
#endif

        //
        // Verify that if the user wants to use the REDRAW_EVENT, we received one to use
        //
        SAC_API_ASSERT(
            ((SacChannelAttributes->Flags & SAC_CHANNEL_FLAG_REDRAW_EVENT) 
             && SacChannelAttributes->RedrawEvent) ||
            (!(SacChannelAttributes->Flags & SAC_CHANNEL_FLAG_REDRAW_EVENT) 
             && !SacChannelAttributes->RedrawEvent),
            FALSE
            );

        //
        // If the channel type isn't cmd, 
        // then make sure they sent us a name.
        //
        if (SacChannelAttributes->Type != ChannelTypeCmd) {

            SAC_API_ASSERT(SacChannelAttributes->Name, FALSE);

        }

        __try {

            //
            // create and initialize the Open Channel message structure
            //
            OpenChannelCmdSize = sizeof(SAC_CMD_OPEN_CHANNEL);
            OpenChannelCmd = (PSAC_CMD_OPEN_CHANNEL)SAC_API_ALLOCATE_MEMORY(OpenChannelCmdSize);
            SAC_API_ASSERT(OpenChannelCmd, FALSE);

            //
            // Populate the new channel attributes
            //
            OpenChannelCmd->Attributes = *SacChannelAttributes;

            //
            // If the channel type isn't cmd, 
            // then make sure they sent us a name.
            //
            if (SacChannelAttributes->Type == ChannelTypeCmd) {

                //
                // force the name and description to be empty
                //
                OpenChannelCmd->Attributes.Name[0] = UNICODE_NULL;
                OpenChannelCmd->Attributes.Description[0] = UNICODE_NULL;

            }

            //
            // Send down an IOCTL for opening a channel
            //
            Status = DeviceIoControl(
                DriverHandle,
                IOCTL_SAC_OPEN_CHANNEL,
                OpenChannelCmd,
                OpenChannelCmdSize,
                &OpenChannelRsp,
                sizeof(SAC_RSP_OPEN_CHANNEL),
                &Feedback,
                0
                );

            //
            // if the channel was not successfully created, NULL
            // the channel handle
            //
            if (Status == FALSE) {

                __leave;

            }

            //
            // the new channel was created, so pass back the handle to it
            //
            SacChannelHandle->DriverHandle  = DriverHandle;
            SacChannelHandle->ChannelHandle = OpenChannelRsp.Handle.ChannelHandle;

        }
        __except(EXCEPTION_EXECUTE_HANDLER) {
            
            Status = FALSE;
            
        }
    
    }
    __finally {
        
        if (OpenChannelCmd) {

            //
            // free the Open Channel message structure
            //
            SAC_API_FREE_MEMORY(OpenChannelCmd);

        }
        
        if (Status == FALSE) {
            
            if (DriverHandle != INVALID_HANDLE_VALUE) {
                
                //
                // Release the driver handle
                //
                SacHandleClose(&DriverHandle);
                
                //
                // NULL the sac channel handle
                //
                RtlZeroMemory(SacChannelHandle, sizeof(SAC_CHANNEL_HANDLE));
            
            }
        
        }
    
    }

    return Status;
}

BOOL
SacChannelClose(
    IN OUT PSAC_CHANNEL_HANDLE  SacChannelHandle
    )    

/*++

Routine Description:

    Close the specified SAC channel 
                
    NOTE: the channel pointer is made NULL under all conditions

Arguments:

    SacChannelHandle    - Channel to be closed

Return Value:

    Status
    
    TRUE --> the channel was closed

--*/

{
    BOOL                    Status;
    SAC_CMD_CLOSE_CHANNEL   CloseChannelCmd;
    DWORD                   Feedback;

    __try {
        
        if (!SacChannelHandle ||
            (SacChannelHandle == INVALID_HANDLE_VALUE) ||
            (SacChannelHandle->DriverHandle == INVALID_HANDLE_VALUE) ||
            !SacChannelHandle->DriverHandle) {
            Status = FALSE;
            __leave;
        }

        SAC_API_ASSERT(SacChannelHandle, FALSE);
        SAC_API_ASSERT(SacChannelHandle->DriverHandle != INVALID_HANDLE_VALUE, FALSE);
    
        //
        // initialize the Close Channel message
        //
        RtlZeroMemory(&CloseChannelCmd, sizeof(SAC_CMD_CLOSE_CHANNEL));

        CloseChannelCmd.Handle.ChannelHandle = SacChannelHandle->ChannelHandle;

        //
        // Send down the IOCTL for closing the channel
        //
        Status = DeviceIoControl(
            SacChannelHandle->DriverHandle,
            IOCTL_SAC_CLOSE_CHANNEL,
            &CloseChannelCmd,
            sizeof(SAC_CMD_CLOSE_CHANNEL),
            NULL,
            0,
            &Feedback,
            0
            );

        //
        // Close the handle to the driver
        //
        SacHandleClose(&SacChannelHandle->DriverHandle);
        
        //
        // The channel handle is no longer valid, so NULL it
        //
        RtlZeroMemory(&SacChannelHandle->ChannelHandle, sizeof(GUID));

    }
    __except(EXCEPTION_EXECUTE_HANDLER) {
        Status = FALSE;
    }

    return Status;
}

BOOL
SacChannelWrite(
    IN SAC_CHANNEL_HANDLE   SacChannelHandle,
    IN PCBYTE               Buffer,
    IN ULONG                BufferSize
    )

/*++

Routine Description:

    Write the given buffer to the specified SAC Channel       

Arguments:

    SacChannelHandle    - The channel to write the buffer to
    Buffer              - data buffer
    BufferSize          - size of the buffer

Return Value:

    Status

    TRUE --> the buffer was sent

--*/
    
{
    BOOL                        Status;
    ULONG                       WriteChannelCmdSize;
    PSAC_CMD_WRITE_CHANNEL      WriteChannelCmd;
    DWORD                       Feedback;

    //
    // Default
    //
    Status = FALSE;
    WriteChannelCmdSize = 0;
    WriteChannelCmd = NULL;

    __try {

        SAC_API_ASSERT(SacChannelHandle.DriverHandle, FALSE);
        SAC_API_ASSERT(SacChannelHandle.DriverHandle != INVALID_HANDLE_VALUE, FALSE);
        SAC_API_ASSERT(Buffer, FALSE);
        SAC_API_ASSERT(BufferSize > 0, FALSE);

        //
        // create and initialize the Open Channel message structure
        //
        WriteChannelCmdSize = sizeof(SAC_CMD_WRITE_CHANNEL) + BufferSize;
        WriteChannelCmd = (PSAC_CMD_WRITE_CHANNEL)SAC_API_ALLOCATE_MEMORY(WriteChannelCmdSize);
        SAC_API_ASSERT(WriteChannelCmd, FALSE);

        __try {
            
            //
            // Indicate which channel this command is for
            //
            WriteChannelCmd->Handle.ChannelHandle = SacChannelHandle.ChannelHandle;

            //
            // Set the length of the string to send
            //
            // Note: Size does not include the terminating NULL, 
            //       becase we don't want to send that.
            //
            WriteChannelCmd->Size = BufferSize;

            //
            // Set the buffer to be written
            //
            RtlCopyMemory(
                &(WriteChannelCmd->Buffer),
                Buffer,
                BufferSize
                );

            //
            // Send down the IOCTL for writing the message
            //
            Status = DeviceIoControl(
                SacChannelHandle.DriverHandle,
                IOCTL_SAC_WRITE_CHANNEL,
                WriteChannelCmd,
                WriteChannelCmdSize,
                NULL,
                0,
                &Feedback,
                0
                );
        
        }
        __except(EXCEPTION_EXECUTE_HANDLER) {
            Status = FALSE;
        }
    
    }
    __finally {

        //
        // if the cmd memory was allocated, 
        // then release it
        //
        if (WriteChannelCmd) {
            SAC_API_FREE_MEMORY(WriteChannelCmd);
        }

    }

    return Status;
}

BOOL
SacChannelRawWrite(
    IN SAC_CHANNEL_HANDLE   SacChannelHandle,
    IN PCBYTE               Buffer,
    IN ULONG                BufferSize
    )

/*++

Routine Description:

    Write the given buffer to the specified SAC Channel       

Arguments:

    SacChannelHandle    - The channel to write the buffer to
    Buffer              - data buffer
    BufferSize          - size of the buffer

Return Value:

    Status

    TRUE --> the buffer was sent

--*/
    
{
                      
    //
    // relay the write to the actual write routine
    //

    return SacChannelWrite(
        SacChannelHandle,
        Buffer,
        BufferSize
        );

}

BOOL
SacChannelVTUTF8WriteString(
    IN SAC_CHANNEL_HANDLE   SacChannelHandle,
    IN PCWSTR               String
    )

/*++

Routine Description:

    This routine writes a null-terminated Unicode String to the specified Channel.

Arguments:

    SacChannelHandle    - The channel to write the buffer to
    String              - A null-terminated Unicode string

Return Value:

    Status

    TRUE --> the buffer was sent

--*/
    
{
    BOOL    Status;
    ULONG   BufferSize;

    __try {
        
        //
        // Treating the String as a data buffer, we calculate it's size
        // not including the null termination
        //

        BufferSize = (ULONG)(wcslen(String) * sizeof(WCHAR));
    
        SAC_API_ASSERT(BufferSize > 0, FALSE);

        //
        // Write the data to the channel
        //

        Status = SacChannelWrite(
            SacChannelHandle,
            (PCBYTE)String,
            BufferSize
            );
    
    }
    __except(EXCEPTION_EXECUTE_HANDLER) {
        Status = FALSE;
    }

    return Status;

}


BOOL
SacChannelVTUTF8Write(
    IN SAC_CHANNEL_HANDLE   SacChannelHandle,
    IN PCWCHAR              Buffer,
    IN ULONG                BufferSize
    )

/*++

Routine Description:

    This routines writes an array of WCHAR to the VTUTF8 channel specified.

Arguments:

    SacChannelHandle    - The channel to write the buffer to
    Buffer              - data buffer
    BufferSize          - size of the buffer

    Note: Buffer is not null-terminated
          BufferSize should not count a null-termination.
                                     
Return Value:

    Status

    TRUE --> the buffer was sent

--*/
    
{
    //
    // relay the write to the actual write routine
    //

    return SacChannelWrite(
        SacChannelHandle,
        (PCBYTE)Buffer,
        BufferSize
        );
}


BOOL
SacChannelHasNewData(
    IN  SAC_CHANNEL_HANDLE  SacChannelHandle,
    OUT PBOOL               InputWaiting 
    )

/*++

Routine Description:

    This routine checks to see if there is any waiting input for 
    the channel specified by the handle

Arguments:

    SacChannelHandle    - the channel to write the string to
    InputWaiting        - the input buffer status
    
Return Value:

    Status

    TRUE --> the buffer status was retrieved

--*/

{
    BOOL                    Status;
    SAC_CMD_POLL_CHANNEL    PollChannelCmd;
    SAC_RSP_POLL_CHANNEL    PollChannelRsp;
    DWORD                   Feedback;

    __try {

        SAC_API_ASSERT(SacChannelHandle.DriverHandle, FALSE);
        SAC_API_ASSERT(SacChannelHandle.DriverHandle != INVALID_HANDLE_VALUE, FALSE);

        //
        // Initialize and populate the poll command structure
        //
        RtlZeroMemory(&PollChannelCmd, sizeof(SAC_CMD_POLL_CHANNEL));

        PollChannelCmd.Handle.ChannelHandle = SacChannelHandle.ChannelHandle;

        //
        // Send down the IOCTL to poll for new input
        //
        Status = DeviceIoControl(
            SacChannelHandle.DriverHandle,
            IOCTL_SAC_POLL_CHANNEL,
            &PollChannelCmd,
            sizeof(SAC_CMD_POLL_CHANNEL),
            &PollChannelRsp,
            sizeof(SAC_RSP_POLL_CHANNEL),
            &Feedback,
            0
            );

        if (Status) {
            *InputWaiting = PollChannelRsp.InputWaiting;
        }
    
    } 
    __except(EXCEPTION_EXECUTE_HANDLER) {
        Status = FALSE;
    }

    return Status;

}

BOOL
SacChannelRead(
    IN  SAC_CHANNEL_HANDLE  SacChannelHandle,
    OUT PBYTE               Buffer,
    IN  ULONG               BufferSize,
    OUT PULONG              ByteCount
    )

/*++

Routine Description:

    This routine reads data from the channel specified.

Arguments:

    SacChannelHandle    - the channel to read from
    Buffer              - destination buffer
    BufferSize          - size of the destination buffer (bytes)
    ByteCount           - the actual # of byte read
    
Return Value:

    Status

    TRUE --> the buffer was read

--*/

{
     BOOL                   Status;
     SAC_CMD_READ_CHANNEL   ReadChannelCmd;
     PSAC_RSP_READ_CHANNEL  ReadChannelRsp;

     __try {
         
         SAC_API_ASSERT(SacChannelHandle.DriverHandle, FALSE);
         SAC_API_ASSERT(SacChannelHandle.DriverHandle != INVALID_HANDLE_VALUE, FALSE);
         SAC_API_ASSERT(Buffer, FALSE);
         SAC_API_ASSERT(ByteCount, FALSE);

         //
         // Populate the read channel cmd
         //
         RtlZeroMemory(&ReadChannelCmd, sizeof(SAC_CMD_READ_CHANNEL));

         ReadChannelCmd.Handle.ChannelHandle    = SacChannelHandle.ChannelHandle;
         ReadChannelRsp                         = (PSAC_RSP_READ_CHANNEL)Buffer;

         //
         // Send down the IOCTL to read input
         //
         Status = DeviceIoControl(
            SacChannelHandle.DriverHandle,
            IOCTL_SAC_READ_CHANNEL,
            &ReadChannelCmd,
            sizeof(SAC_CMD_READ_CHANNEL),
            ReadChannelRsp,
            BufferSize,
            ByteCount,
            0
            );
     
     }
     __except(EXCEPTION_EXECUTE_HANDLER) {
         Status = FALSE;
     }

     return Status;

}

BOOL
SacChannelVTUTF8Read(
    IN  SAC_CHANNEL_HANDLE  SacChannelHandle,
    OUT PWSTR               Buffer,
    IN  ULONG               BufferSize,
    OUT PULONG              ByteCount
    )

/*++

Routine Description:

    This routine reads data from the channel specified.

Arguments:

    SacChannelHandle    - the channel to read from
    Buffer              - destination buffer
    BufferSize          - size of the destination buffer (bytes)
    ByteCount           - the actual # of byte read
    
    Note: the Buffer upon return is NOT null terminated                               
                                   
Return Value:

    Status

    TRUE --> the buffer was read

--*/

{

    return SacChannelRead(
        SacChannelHandle,
        (PBYTE)Buffer,
        BufferSize,
        ByteCount
        );

}

BOOL
SacChannelRawRead(
    IN  SAC_CHANNEL_HANDLE  SacChannelHandle,
    OUT PBYTE               Buffer,
    IN  ULONG               BufferSize,
    OUT PULONG              ByteCount
    )

/*++

Routine Description:

    This routine reads data from the channel specified.

Arguments:

    SacChannelHandle    - the channel to read from
    Buffer              - destination buffer
    BufferSize          - size of the destination buffer (bytes)
    ByteCount           - the actual # of byte read
    
Return Value:

    Status

    TRUE --> the buffer was read

--*/

{
    
    return SacChannelRead(
        SacChannelHandle,
        Buffer,
        BufferSize,
        ByteCount
        );

}

BOOL
SacRegisterCmdEvent(
    OUT HANDLE      *pDriverHandle,
    IN  HANDLE       RequestSacCmdEvent,
    IN  HANDLE       RequestSacCmdSuccessEvent,
    IN  HANDLE       RequestSacCmdFailureEvent
    )

/*++

Routine Description:

    This routine configures the SAC driver with the event handlers
    and needed to implement the ability to launch cmd consoles via 
    a user-mode service app.

    Note: Only one registration can exist at a time in the SAC driver.

Arguments:

    pDriverHandle               - on success, contains the driver handle used to register
    RequestSacCmdEvent          - the event triggered when the SAC wants to launch a cmd console
    RequestSacCmdSuccessEvent   - the event triggered when the cmd console has successfully launched
    RequestSacCmdFailureEvent   - the event triggered when the cmd console has failed to launch
    
Return Value:

    Status

    TRUE --> the cmd event was registered with the SAC driver

--*/

{
    BOOL                    Status;
    DWORD                   Feedback;
    SAC_CMD_SETUP_CMD_EVENT SacCmdEvent;
    HANDLE                  DriverHandle;

    //
    // default
    //
    *pDriverHandle = INVALID_HANDLE_VALUE;

    __try {
        
        SAC_API_ASSERT(pDriverHandle != NULL, FALSE);
        SAC_API_ASSERT(RequestSacCmdEvent, FALSE);
        SAC_API_ASSERT(RequestSacCmdSuccessEvent, FALSE);
        SAC_API_ASSERT(RequestSacCmdFailureEvent, FALSE);

        //
        // Get a handle to the driver. This way, the api user doesn't have
        // explicitly open/close the driver handle.
        // 
        Status = SacHandleOpen(&DriverHandle);

        if ((Status != TRUE) ||
            (DriverHandle == INVALID_HANDLE_VALUE)) {
            Status = FALSE;
            __leave;
        }
        
        SAC_API_ASSERT(Status == TRUE, FALSE);
        SAC_API_ASSERT(DriverHandle != INVALID_HANDLE_VALUE, FALSE);
        
        //
        // Initialize the our SAC Cmd Info
        //
        SacCmdEvent.RequestSacCmdEvent          = RequestSacCmdEvent;
        SacCmdEvent.RequestSacCmdSuccessEvent   = RequestSacCmdSuccessEvent;
        SacCmdEvent.RequestSacCmdFailureEvent   = RequestSacCmdFailureEvent;

        //
        // Send down the IOCTL for setting up the SAC Cmd launch event
        //
        Status = DeviceIoControl(
            DriverHandle,
            IOCTL_SAC_REGISTER_CMD_EVENT,
            &SacCmdEvent,
            sizeof(SAC_CMD_SETUP_CMD_EVENT),
            NULL,
            0,
            &Feedback,
            0
            );
    

        //
        // if we were successful,
        // then keep the driver handle
        //
        if (Status) {
            
            *pDriverHandle = DriverHandle;
        
        } else {

            //
            // Close the driver handle
            //
            SacHandleClose(&DriverHandle);

        }

    }
    __except(EXCEPTION_EXECUTE_HANDLER) {
        Status = FALSE;
    }

    return Status;
}

BOOL
SacUnRegisterCmdEvent(
    IN OUT HANDLE      *pDriverHandle
    )

/*++

Routine Description:

    This routine unregisters the event information required
    to launch cmd consoles via a user-mode service app.

Arguments:

    pDriverHandle   -   on entry, contains the driver handle that was used to 
                                register the cmd event info
                        on success, contains INVALID_HANDLE_VALUE
    
Return Value:

    Status

    TRUE --> the cmd event was unregistered with the SAC driver

--*/

{
    BOOL                    Status;
    DWORD                   Feedback;

    //
    // default
    //
    Status = FALSE;

    __try {

        SAC_API_ASSERT(*pDriverHandle != INVALID_HANDLE_VALUE, FALSE);
                
        //
        // Send down the IOCTL for unregistering the SAC Cmd launch event
        //
        Status = DeviceIoControl(
            *pDriverHandle,
            IOCTL_SAC_UNREGISTER_CMD_EVENT,
            NULL,
            0,
            NULL,
            0,
            &Feedback,
            0
            );
    
        //
        // Close the driver handle
        //
        SacHandleClose(pDriverHandle);

    }
    __except(EXCEPTION_EXECUTE_HANDLER) {
        Status = FALSE;
    }

    return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\headless\lib\umode\cpp\iohandler\iohandler.cpp ===
/*++

Copyright (c) 2001 Microsoft Corporation

Module Name:

    iohandler.cpp

Abstract:

    This module implements the base IoHandler class.

Author:

    Brian Guarraci (briangu), 2001

Revision History:

--*/
#include "iohandler.h"

CIoHandler::CIoHandler(
    VOID
    )
/*++

Routine Description:

    IoHandler constructor    
        
Arguments:

    None   
       
Return Value:

    N/A

--*/
{
    NOTHING;
}

CIoHandler::~CIoHandler()
/*++

Routine Description:

    IoHandler destructor    

Arguments:

    N/A            
          
Return Value:

    N/A                    

--*/
{
    NOTHING;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\headless\lib\umode\cpp\iohandler\iohandler.h ===
/*++

Copyright (c) 2001 Microsoft Corporation

Module Name:

    iohandler.h

Abstract:

    This module implements the IoHandler class.
    
    The IoHandler class defines a wrapper interface for constructing
    filter read/write handlers for SAC channel I/O.

Author:

    Brian Guarraci (briangu), 2001

Revision History:

--*/
#if !defined( _IOHANDLER_H_ )
#define _IOHANDLER_H_

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>

class CIoHandler
{
    
protected:

    //
    // Prevent this class from begin instantiated directly
    //
    CIoHandler();

public:
    
    virtual ~CIoHandler();
    
    //
    // Send BufferSize bytes
    //
    virtual BOOL
    Write(
        PBYTE   Buffer,
        ULONG   BufferSize
        ) = 0;

    //
    // Flush any unsent data
    //
    virtual BOOL
    Flush(
        VOID
        ) = 0;

    //
    // Read BufferSize bytes
    //
    virtual BOOL
    Read(
        PBYTE   Buffer,
        ULONG   BufferSize,
        PULONG  ByteCount
        ) = 0;

    //
    // Determine if the ioHandler has new data to read
    //
    virtual BOOL
    HasNewData(
        PBOOL   InputWaiting
        ) = 0;
    
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\headless\lib\umode\cpp\emsapi\vtutf8chan.cpp ===
/*++

Copyright (c) 2001 Microsoft Corporation

Module Name:

    vtutf8chan.cpp

Abstract:

    This module provides the implementation for the VT-UTF8
    compatible channels.

Author:

    Brian Guarraci (briangu), 2001                    
                        
Revision History:

--*/
#include <emsapip.h>
#include <emsapi.h>
#include <ntddsac.h>

EMSVTUTF8Channel::EMSVTUTF8Channel(
    VOID
    )
/*++

Routine Description:

    Constructor

Arguments:

    None           
               
Return Value:

    N/A
        
--*/
{
}
     
EMSVTUTF8Channel::~EMSVTUTF8Channel()
/*++

Routine Description:

    Desctructor

Arguments:

    N/A
               
Return Value:

    N/A
        
--*/
{
}
    

EMSVTUTF8Channel*
EMSVTUTF8Channel::Construct(
    IN  SAC_CHANNEL_OPEN_ATTRIBUTES ChannelAttributes
    )
/*++

Routine Description:

    Create a new channel object

Arguments:

    EMSVTUTF8ChannelName          - The name of the newly created channel
                        
Return Value:

    Status

    TRUE  --> pHandle is valid
     
--*/
{
    EMSVTUTF8Channel    *Channel;

    //
    // Force the appropriate channel attributes
    //
    ChannelAttributes.Type = ChannelTypeVTUTF8;

    //
    // Attempt to open the channel
    //
    Channel = (EMSVTUTF8Channel*) EMSChannel::Construct(
        ChannelAttributes
        );

    return Channel;
}

BOOL
EMSVTUTF8Channel::Write(
    IN PCWSTR   String
    )

/*++

Routine Description:

    Write the given buffer to the specified SAC Channel       

Arguments:

    String  - Unicode string to write

Return Value:

    Status

    TRUE --> the buffer was sent

--*/
    
{

    return SacChannelVTUTF8WriteString(
        GetEMSChannelHandle(),
        String
        );

}

BOOL
EMSVTUTF8Channel::Write(
    IN PCWCHAR  Buffer,
    IN ULONG    BufferSize
    )

/*++

Routine Description:

    Write the given buffer to the specified SAC Channel       

Arguments:

    String  - Unicode string to write

Return Value:

    Status

    TRUE --> the buffer was sent

--*/
    
{

    return SacChannelVTUTF8Write(
        GetEMSChannelHandle(),
        Buffer,
        BufferSize
        );

}


BOOL
EMSVTUTF8Channel::Read(
    OUT PWSTR                Buffer,
    IN  ULONG                BufferSize,
    OUT PULONG               ByteCount
    )

/*++

Routine Description:

    This routine reads data from the channel specified.

Arguments:

    Buffer              - destination buffer
    BufferSize          - size of the destination buffer (bytes)
    ByteCount           - the actual # of byte read
    
Return Value:

    Status

    TRUE --> the buffer was sent

--*/

{

    return SacChannelVTUTF8Read(
        GetEMSChannelHandle(),
        Buffer,
        BufferSize,
        ByteCount
        );

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\headless\lib\umode\cpp\emsapi\rawchan.cpp ===
/*++

Copyright (c) 2001 Microsoft Corporation

Module Name:

    rawchan.cpp

Abstract:

    This module provides the raw channel implementation.           
               
Author:

    Brian Guarraci (briangu), 2001
    
Revision History:

--*/
#include <emsapip.h>
#include <emsapi.h>
#include <ntddsac.h>

EMSRawChannel::EMSRawChannel(
    VOID
    )
/*++

Routine Description:

    Constructor

Arguments:

    None           
               
Return Value:

    N/A
        
--*/
{
}
     
EMSRawChannel::~EMSRawChannel()
/*++

Routine Description:

    Desctructor

Arguments:

    N/A
               
Return Value:

    N/A
        
--*/
{
}

EMSRawChannel*
EMSRawChannel::Construct(
    IN  SAC_CHANNEL_OPEN_ATTRIBUTES ChannelAttributes
    )
/*++

Routine Description:

    Create a new channel object

Arguments:

    EMSRawChannelName          - The name of the newly created channel
                        
Return Value:

    Status

    TRUE  --> pHandle is valid
     
--*/
{
    EMSRawChannel       *Channel;

    //
    // Force the appropriate channel attributes
    //
    ChannelAttributes.Type = ChannelTypeRaw;

    //
    // Attempt to open the channel
    //
    Channel= (EMSRawChannel*) EMSChannel::Construct(
        ChannelAttributes
        );
    
    return Channel;
}

BOOL
EMSRawChannel::Write(
    IN PCBYTE   Buffer,
    IN ULONG    BufferSize
    )

/*++

Routine Description:

    Write the given buffer to the specified SAC Channel       

Arguments:

    String  - Unicode string to write

Return Value:

    Status

    TRUE --> the buffer was sent

--*/
    
{

    return SacChannelRawWrite(
        GetEMSChannelHandle(),
        Buffer,
        BufferSize
        );

}

BOOL
EMSRawChannel::Read(
    OUT PBYTE                Buffer,
    IN  ULONG                BufferSize,
    OUT PULONG               ByteCount
    )

/*++

Routine Description:

    This routine reads data from the channel specified.

Arguments:

    Buffer              - destination buffer
    BufferSize          - size of the destination buffer (bytes)
    ByteCount           - the actual # of byte read
    
Return Value:

    Status

    TRUE --> the buffer was sent

--*/

{

    return SacChannelRawRead(
        GetEMSChannelHandle(),
        Buffer,
        BufferSize,
        ByteCount
        );

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\headless\lib\umode\cpp\iohandler\lockio.cpp ===
/*++

Copyright (c) 2001 Microsoft Corporation

Module Name:

    lockio.cpp

Abstract:

    This module implements the lockable IoHandler class.          
              
    The purpose of this class is to provide a means for a seamless switchable
    IoHandler so that I/O can be turned off/on when appropriate.
    
    For instance, when the IoHandler is locked, the client I/O
    can be redirected to a NULL IoHandler which effectively turns
    off I/O for the client, but the client doesn't have to be notified
    of this event.                                    
                                  
Author:

    Brian Guarraci (briangu), 2001

Revision History:

--*/
#include "lockio.h"

CLockableIoHandler::CLockableIoHandler(
    VOID
    )
/*++

Routine Description:

    Constructor

Arguments:

    None
          
Return Value:

    N/A           

--*/
{

    //
    // Initilize the locked Io Handler
    //
    myLockedIoHandler = NULL;

    //
    // Initilize the unlocked IoHandler
    //
    myUnlockedIoHandler = NULL;

}

CLockableIoHandler::CLockableIoHandler(
    IN CIoHandler*  LockedIoHandler,
    IN CIoHandler*  UnlockedIoHandler
    )
/*++

Routine Description:

    Constructor

Arguments:

    LockedIoHandler     - the IoHandler to use when locked
    UnlockedIoHandler   - the IoHandler to use when unlocked
          
Return Value:

    N/A           

--*/
{

    //
    // Initilize the locked Io Handler
    //
    myLockedIoHandler = LockedIoHandler;

    //
    // Initilize the unlocked IoHandler
    //
    myUnlockedIoHandler = UnlockedIoHandler;

}

CLockableIoHandler::~CLockableIoHandler()
/*++

Routine Description:

    Destructor

Arguments:

    N/A           
          
Return Value:

    N/A           

--*/
{
    //
    // Cleanup allocated Io Handlers
    //
    if (myUnlockedIoHandler) {
        delete myUnlockedIoHandler;
    }
    if (myLockedIoHandler) {
        delete myLockedIoHandler;
    }
}

void
CLockableIoHandler::Lock(
    VOID
    )
/*++

Routine Description:

    Lock: 

    When the IoHandler is locked, the read and write routines
    do not send data.  If they are called, they return TRUE,
    but no data is sent.  To prevent accidental loss of data,
    routines that use the IoHandler should call the IsLocked()
    method to determine the status before hand.
                
Arguments:

    None
    
Return Value:

    None

--*/
{
    InterlockedExchangePointer((PVOID*)&myIoHandler, (PVOID)myLockedIoHandler);
}

void
CLockableIoHandler::Unlock(
    VOID
    )
/*++

Routine Description:

    This routine unlocks the IoHandler.  
    
    When the IoHandler is unlocked, the read and write routines 
    are enabled and routines that use the IoHandler can succesfully
    perform I/O.

Arguments:

    None
        
Return Value:

    None

--*/
{
    InterlockedExchangePointer((PVOID*)&myIoHandler, (PVOID)myUnlockedIoHandler);
}

BOOL
CLockableIoHandler::IsLocked(
    VOID
    )
/*++

Routine Description:

    This routine determines of the IoHandler is locked.
                
Arguments:

    None
        
Return Value:

    TRUE    - if IoHandler is locked
    FALSE   - if IoHandler is not locked

--*/
{
    return(myIoHandler == myLockedIoHandler);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\headless\lib\umode\cpp\iohandler\nullio.cpp ===
/*++

Copyright (c) 2001 Microsoft Corporation

Module Name:

    nullio.cpp

Abstract:

    This module implements the NULL IoHandler.
    
    The purpose of this IoHandler is to provide a NULL
    channel for lockable IoHandlers.  When the IoHandler
    is locked, the IoHandler client writes to a NULL device.          
              
Author:

    Brian Guarraci (briangu), 2001

Revision History:

--*/
#include "nullio.h"

CNullIoHandler::CNullIoHandler(
    VOID
    )
/*++

Routine Description:

    Constructor

Arguments:

    None
          
Return Value:

    N/A

--*/
{
    NOTHING;
}

CNullIoHandler::~CNullIoHandler(
    )
/*++

Routine Description:

    Destructor

Arguments:

    N/A           
          
Return Value:

    N/A           

--*/
{
    NOTHING;
}

BOOL
CNullIoHandler::Write(
    IN PBYTE    Buffer,
    IN ULONG    BufferSize
    )
/*++

Routine Description:

   This routine impelements the write IoHandler operation.
   
Arguments:

    Buffer      - the data to send
    BufferSize  - the size of the buffer in bytes                                                       
          
Return Value:

    TRUE    - success
    FALSE   - otherwise                                                 

--*/
{
    
    UNREFERENCED_PARAMETER(Buffer);
    UNREFERENCED_PARAMETER(BufferSize);
    
    //
    // Do Nothing
    //
    return TRUE;
}

BOOL
CNullIoHandler::Flush(
    VOID
    )
/*++

Routine Description:

    This routine implements the Flush IoHandler method.
    
Arguments:

    None            
          
Return Value:

    TRUE    - success
    FALSE   - otherwise                                                 

--*/
{
    //
    // Do Nothing
    //
    return TRUE;
}

BOOL
CNullIoHandler::Read(
    OUT PBYTE   Buffer,
    IN  ULONG   BufferSize,
    OUT PULONG  ByteCount
    )
/*++

Routine Description:

    This routine implements the Read IoHandler method.

Arguments:

    Buffer      - on success, contains the read data
    BufferSize  - the size of the read buffer in bytes
    ByteCount   - on success, contains the # of bytes read                                                    
          
Return Value:

    TRUE    - success
    FALSE   - otherwise                                                 

--*/
{

    UNREFERENCED_PARAMETER(Buffer);
    UNREFERENCED_PARAMETER(BufferSize);

    //
    // No data was read
    //
    *ByteCount = 0;
    
    return TRUE;
}

BOOL
CNullIoHandler::HasNewData(
    IN PBOOL    InputWaiting
    )
/*++

Routine Description:

    This routine impelements the HasNewData IoHandler method.                
                
Arguments:

    InputWaiting    - on success, contains the status of the channel's
                      input buffer.
          
Return Value:

    TRUE    - success
    FALSE   - otherwise                                                 

--*/
{
    
    //
    // There is no new data
    //
    *InputWaiting = FALSE;

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\headless\lib\umode\cpp\iohandler\nullio.h ===
/*++

Copyright (c) 2001 Microsoft Corporation

Module Name:

    nullio.h

Abstract:

    This module defines the NULL IoHandler class.
    
    The purpose of this IoHandler is to provide a NULL
    channel for lockable IoHandlers.  When the IoHandler
    is locked, the IoHandler client writes to a NULL device.          

Author:

    Brian Guarraci (briangu), 2001

Revision History:

--*/
#if !defined( _NULL_IO_H_ )
#define _NULL_IO_H_

#include "iohandler.h"
#include <emsapi.h>

class CNullIoHandler : public CIoHandler
{

public:
    
    CNullIoHandler();
    virtual ~CNullIoHandler();
    
    //
    // Write BufferSize bytes
    //
    BOOL
    Write(
        IN PBYTE    Buffer,
        IN ULONG    BufferSize
        );

    //
    // Flush any unsent data
    //
    BOOL
    Flush(
        VOID
        );

    //
    // Write BufferSize bytes
    //
    BOOL
    Read(
        OUT PBYTE   Buffer,
        IN  ULONG   BufferSize,
        OUT PULONG  ByteCount
        );

    //
    // Determine if the ioHandler has new data to read
    //
    BOOL
    HasNewData(
        OUT PBOOL   InputWaiting
        );
    
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\headless\lib\umode\cpp\iohandler\lockio.h ===
/*++

Copyright (c) 2001 Microsoft Corporation

Module Name:

    lockio.h

Abstract:

    This module defines the lockable IoHandler.
    
    The purpose of this class is to provide a means for a seamless switchable
    IoHandler so that I/O can be turned off/on when appropriate.
    
    For instance, when the IoHandler is locked, the client I/O
    can be redirected to a NULL IoHandler which effectively turns
    off I/O for the client, but the client doesn't have to be notified
    of this event.                                    

Author:

    Brian Guarraci (briangu), 2001

Revision History:

--*/
#if !defined( _LOCKABLE_IO_H_ )
#define _LOCKABLE_IO_H_

#include "iohandler.h"
#include <emsapi.h>

class CLockableIoHandler : public CIoHandler
{
    
private:

    //
    // Prevent this class from being instantiated without params
    //
    CLockableIoHandler();

protected:

    //
    // This is the Io Hander we send data to when
    // the channel is unlocked
    //
    CIoHandler  *myUnlockedIoHandler;

    //
    // This is the Io Hander we send data to when
    // the channel is locked
    //
    CIoHandler  *myLockedIoHandler;

    //
    // Our Io Handler that we'll use to communicate to when
    // passing data through or authenticating
    //
    CIoHandler  *myIoHandler;


public:
    
    //
    // Constructor
    //
    CLockableIoHandler(
        IN CIoHandler*  LockedIoHandler,
        IN CIoHandler*  UnlockedIoHandler
        );
    
    virtual ~CLockableIoHandler();
    
    //
    // Get the unlocked IoHandler
    //
    inline CIoHandler*
    GetUnlockedIoHandler(
        VOID
        )
    {
        return myUnlockedIoHandler;
    }

    //
    // Get the Locked IoHandler
    //
    inline CIoHandler*
    GetLockedIoHandler(
        VOID
        )
    {
        return myLockedIoHandler;
    }
    
    //
    // Lock: 
    //
    // When the IoHandler is locked, the read and write routines
    // do not send data.  If they are called, they return TRUE,
    // but no data is sent.  To prevent accidental loss of data,
    // routines that use the IoHandler should call the IsLocked()
    // method to determine the status before hand.
    //
    virtual void
    Lock(
        VOID
        );

    //
    // Lock: 
    //
    // Unlock the read and write methods.  (See Lock for details)
    //
    virtual void
    Unlock(
        VOID
        );

    //
    // Determines if the IoHandler is locked.
    //
    virtual BOOL
    IsLocked(
        VOID
        );

};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\headless\lib\umode\cpp\iohandler\sacio.h ===
/*++

Copyright (c) 2001 Microsoft Corporation

Module Name:

    sacio.h

Abstract:

    This module implements a SAC channel IoHandler.  
    
    The purpose of this IoHandler is to provide an
    interface for doing buffered channel I/O.

Author:

    Brian Guarraci (briangu), 2001

Revision History:

--*/
#if !defined( _SAC_IO_H_ )
#define _SAC_IO_H_

#include "iohandler.h"
#include <emsapi.h>

class CSacIoHandler : public CIoHandler
{
    
    EMSCmdChannel*  mySacChannel;

    //
    // Prevent this class from being instantiated directly
    //
    CSacIoHandler();

    //
    // Write buffer attributes
    //
    PBYTE   mySendBuffer;
    ULONG   mySendBufferIndex;

public:
    
    static CSacIoHandler*
    CSacIoHandler::Construct(
        IN SAC_CHANNEL_OPEN_ATTRIBUTES  Attributes
        );

    //
    // Write BufferSize bytes
    //
    inline virtual BOOL
    Write(
        IN PBYTE    Buffer,
        IN ULONG    BufferSize
        );

    //
    // Flush any unsent data
    //
    inline virtual BOOL
    Flush(
        VOID
        );

    //
    // Write BufferSize bytes
    //
    inline virtual BOOL
    Read(
        OUT PBYTE   Buffer,
        IN  ULONG   BufferSize,
        OUT PULONG  ByteCount
        );

    //
    // Determine if the ioHandler has new data to read
    //
    inline virtual BOOL
    HasNewData(
        OUT PBOOL   InputWaiting
        );
    
    virtual ~CSacIoHandler();
    
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\headless\lib\umode\cpp\iohandler\sacio.cpp ===
/*++

Copyright (c) 2001 Microsoft Corporation

Module Name:

    sacio.cpp

Abstract:

    This module implements the SAC IoHandler functionality.
    
    The SAC IoHandler implements a write buffer so that the 
    # of calls to teh SAC driver are reduced.

Author:

    Brian Guarraci (briangu), 2001

Revision History:

--*/
#include "sacio.h"

//
// Enable the write buffer
//
#define USE_SEND_BUFFER 1

//
// The size of the write buffer
//
#define SEND_BUFFER_SIZE 8192

CSacIoHandler::CSacIoHandler(
    VOID
    )
/*++

Routine Description:

    Constructor

Arguments:

    None
          
Return Value:

    N/A           

--*/
{
    //
    // We don't yet have a SAC channel object
    //
    mySacChannel = NULL;

    //
    // Create a send buffer
    //
    mySendBufferIndex = 0;
    mySendBuffer = new BYTE[SEND_BUFFER_SIZE];

}

CSacIoHandler::~CSacIoHandler(
    )
/*++

Routine Description:

    Destructor

Arguments:

    N/A           
          
Return Value:

    N/A           

--*/
{
    if (mySacChannel) {
        delete mySacChannel;
    }

    delete [] mySendBuffer;
}

CSacIoHandler*
CSacIoHandler::Construct(
    IN SAC_CHANNEL_OPEN_ATTRIBUTES  Attributes
    )
/*++

Routine Description:

    static constructor - this does the real construction         
             
Arguments:

    Attributes   - attributes of the SAC channel to create                                                            
          
Return Value:

    On success, a pointer to the new IoHandler                                    
    On failure, NULL

--*/
{
    CSacIoHandler               *IoHandler;

    //
    // Create a new SAC IoHandler
    //
    IoHandler = new CSacIoHandler();

    //
    // Attempt to open a SAC channel
    //
    IoHandler->mySacChannel = EMSCmdChannel::Construct(Attributes);

    //
    // If we failed to open the SAC channel, 
    // then destroy the IoHandler and notify the caller
    // that we failed by returning null
    //
    if (IoHandler->mySacChannel == NULL) {
        delete IoHandler;
        return NULL;
    }

    return IoHandler;
}

BOOL
CSacIoHandler::Write(
    IN PBYTE    Buffer,
    IN ULONG    BufferSize
    )
/*++

Routine Description:

   This routine impelements a buffered write IoHandler operation.
   
Arguments:

    Buffer      - the data to send
    BufferSize  - the size of the buffer in bytes                                                       
          
Return Value:

    TRUE    - success
    FALSE   - otherwise                                                 

--*/
{
#if USE_SEND_BUFFER

    //
    // If the requested buffer to send is bigger than the
    // remaining local buffer, send the local buffer.
    //
    if (mySendBufferIndex + BufferSize > SEND_BUFFER_SIZE) {

        if (! Flush()) {
            return FALSE;
        }
    
    }  

//    ASSERT(mySendBufferIndex + BufferSize <= SEND_BUFFER_SIZE);
    
    //
    // Copy the incoming buffer into our local buffer
    //
    RtlCopyMemory(
        &mySendBuffer[mySendBufferIndex],
        Buffer,
        BufferSize
        );

    //
    // Account for the added buffer contents
    //
    mySendBufferIndex += BufferSize;
        
//    ASSERT(mySendBufferIndex % sizeof(WCHAR) == 0);
    
    //
    // we succeeded
    //
    return TRUE;

#else
    
     
    //
    // Send the local buffer to the SAC channel
    //
    bSuccess = mySacChannel->Write(
        (PCWCHAR)Buffer,
        BufferSize
        );

    //
    // Reset the local buffer index
    //
    mySendBufferIndex = 0;
    
    return bSuccess;

#endif
}

BOOL
CSacIoHandler::Flush(
    VOID
    )
/*++

Routine Description:

    This routine implements the Flush IoHandler method.
    
    If there is any data stored in the write buffer, it
    is flushed to the SAC channel.
               
Arguments:

    None            
          
Return Value:

    TRUE    - success
    FALSE   - otherwise                                                 

--*/
{
#if USE_SEND_BUFFER
    
    BOOL    bSuccess;

    //
    // default: we succeeded
    //
    bSuccess = TRUE;

#if 0
    TCHAR   Buffer[1024];

    wsprintf(Buffer, TEXT("buffsize=%d\r\n"), mySendBufferIndex);
    OutputDebugString(Buffer);       
#endif

    //
    // Send the local buffer to the SAC channel
    //
    if (mySendBufferIndex > 0) {
        
        bSuccess = mySacChannel->Write(
            mySendBuffer,
            mySendBufferIndex
            );

        //
        // Reset the local buffer index
        //
        mySendBufferIndex = 0;
    
    }
    
    return bSuccess;
#else
    return TRUE;
#endif
}

BOOL
CSacIoHandler::Read(
    OUT PBYTE   Buffer,
    IN  ULONG   BufferSize,
    OUT PULONG  ByteCount
    )
/*++

Routine Description:

    This routine implements the Read IoHandler method.

Arguments:

    Buffer      - on success, contains the read data
    BufferSize  - the size of the read buffer in bytes
    ByteCount   - on success, contains the # of bytes read                                                    
          
Return Value:

    TRUE    - success
    FALSE   - otherwise                                                 

--*/
{
    if (!mySacChannel) {
        return FALSE;
    }

    //
    // Read data from the channel
    //
    return mySacChannel->Read(
        Buffer,
        BufferSize,
        ByteCount
        );
}

//
// Determine if the ioHandler has new data to read
//
BOOL
CSacIoHandler::HasNewData(
    OUT PBOOL   InputWaiting
    )
/*++

Routine Description:

    This routine impelements the HasNewData IoHandler method.                
                
Arguments:

    InputWaiting    - on success, contains the status of the channel's
                      input buffer.
          
Return Value:

    TRUE    - success
    FALSE   - otherwise                                                 

--*/
{
    //
    // Determine if the channel has new data
    //
    return mySacChannel->HasNewData(InputWaiting);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\headless\setup\resource.h ===
#define IDD_ABORTDIALOG 100
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\headless\tcsrv\admin\console\tcadmin.h ===
/* 
 * Copyright (c) Microsoft Corporation
 * 
 * Module Name : 
 *        tcadmin.h
 *
 * Header file for the administration utility.
 * 
 * Sadagopan Rajaram -- Dec 20, 1999
 *
 */


#include <tchar.h>
#include <stdlib.h>
#include <stdio.h>
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <ntseapi.h>

#include <windows.h>
#include <winsock2.h>
#include <align.h>
#include <smbgtpt.h>
#include <dsgetdc.h>
#include <lm.h>
#include <winldap.h>
#include <dsrole.h>
#include <rpc.h>
#include <ntdsapi.h>

#include <lmcons.h>
#include <lmerr.h>
#include <lmsname.h>
#include <rpc.h>
#include <security.h>   // General definition of a Security Support Provider
#include <ntlmsp.h>
#include <spseal.h>
#include <userenv.h>
#include <setupapi.h>
#include <ntddser.h>
#include <conio.h>
#include "msg.h"
#include "tcsrvc.h"
extern PVOID ResourceImageBase;
extern FARPROC setparams;
extern FARPROC getparams;
extern FARPROC deletekey;
extern HANDLE hConsoleInput;
extern HANDLE hConsoleOutput;
extern TCHAR lastChar;
#ifdef MAX_BUFFER_SIZE
#undef MAX_BUFFER_SIZE
#define MAX_BUFFER_SIZE 257
#endif
#define NUMBER_FIELDS 6
#define NUMBER_OF_STATES 7

#define SERIAL_DEVICE_KEY _T("HARDWARE\\DEVICEMAP\\SERIALCOMM")
#define DEFAULT_BAUD_RATE 9600
#define TCAlloc(x) malloc(x)
#define TCFree(x)  free(x)

BOOL
Browse(
    );


VOID 
DisplayScreen(
    UINT MessageID
    );

int
DisplayEditMenu(
    TCHAR *name,
    int nameLen,
    TCHAR *device,
    int deviceLen,
    UINT *BaudRate,
    UCHAR *WordLen,
    UCHAR *Parity,
    UCHAR *StopBits
    );


LPTSTR
RetreiveMessageText(
    IN     ULONG  MessageId
    );


LONG
GetLine(
    LPTSTR str,
    int index,
    int MaxLength
    );

VOID
DisplayParameters(
    LPCTSTR *message,
    LPCTSTR name,
    LPCTSTR device,
    UINT baudRate,
    UCHAR wordLen,
    UCHAR parity,
    UCHAR stopBits
    );

VOID SendParameterChange(
    );

VOID
GetStatus(
    );

VOID
StartTCService(
    );

VOID
StopTCService(
    );

VOID
AddAllComPorts(
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\headless\tcsrv\admin\data\dll.c ===
#include "tcdata.h"
#include "tcsrvc.h"

// The key to the registry where the paramters are present.

//
// Called by CRT when _DllMainCRTStartup is the DLL entry point
//
BOOL
WINAPI
DllMain(
    IN HANDLE DllHandle,
    IN DWORD  Reason,
    IN LPVOID Reserved
    )
{
    HKEY lock,l_hkey;
    LONG retVal;
    DWORD disposition;

    UNREFERENCED_PARAMETER(Reserved);
    UNREFERENCED_PARAMETER(Reason);
    return TRUE;

}

LONG 
TCLock(
    PHANDLE lock
    )
{
    LONG RetVal; 

    (*lock) = CreateMutex(NULL,
                          FALSE,
                          TCSERV_MUTEX_NAME
                          );
    if ((*lock)) {
       RetVal = WaitForSingleObject(*lock,INFINITE);
       if (RetVal == WAIT_FAILED) {
           return GetLastError();
       }
       else{
           return ERROR_SUCCESS;
       }
    }
    else{
        return GetLastError();
    }
}

VOID
TCUnlock(
    HANDLE lock
    )
{
    if (lock) {
        ReleaseMutex(lock);
        CloseHandle(lock);
    }
    return;
}

LONG GetParametersByName(
    TCHAR *name,
    int *nameLen,
    TCHAR *device,
    int *deviceLen,
    PUCHAR stopBits,
    PUCHAR parity,
    PUINT baudRate,
    PUCHAR wordLen
    )
{
    LONG RetVal;
    HKEY m_child;
    DWORD lpcdata, lpType,dat;
    HANDLE lock;
    HKEY m_hkey;



    RetVal = TCLock(&lock);
    if (RetVal != ERROR_SUCCESS) {
        TCUnlock(lock);
        return RetVal;
    }
    RetVal = RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                          HKEY_TCSERV_PARAMETER_KEY,
                          0,
                          KEY_ALL_ACCESS,
                          &m_hkey
                              );
    if(RetVal != ERROR_SUCCESS){
        TCUnlock(lock);
        return RetVal;
    }
    RetVal= RegOpenKeyEx(m_hkey,
                         name,  // subkey name
                         0,   // reserved
                         KEY_ALL_ACCESS, // security access mask
                         &m_child
                         );
    if(RetVal != ERROR_SUCCESS){
        RegCloseKey(m_hkey);
        TCUnlock(lock);
        return RetVal;
    }
    RetVal = RegQueryValueEx(m_child,
                             _TEXT("Device"),
                             NULL,  
                             &lpType,
                             (LPBYTE)device,
                             deviceLen
                             );
    (*deviceLen) = (*deviceLen) - 1;
    if(RetVal != ERROR_SUCCESS){
        RegCloseKey(m_child);
        RegCloseKey(m_hkey);
        TCUnlock(lock);
        return RetVal;
    }
    lpcdata = sizeof(UINT);
    RetVal = RegQueryValueEx(m_child,
                             _TEXT("Baud Rate"),
                             NULL,  
                             &lpType,
                             (LPBYTE)baudRate,
                             &lpcdata
                             );
    lpcdata = sizeof(DWORD);
    dat = (DWORD) *stopBits;
    RetVal = RegQueryValueEx(m_child,
                             _TEXT("Stop Bits"),
                             NULL,  
                             &lpType,
                             (LPBYTE)&dat,
                             &lpcdata
                             );
    *stopBits = (UCHAR) dat;
    dat = (DWORD) *wordLen;
    lpcdata = sizeof(DWORD);
    RetVal = RegQueryValueEx(m_child,
                             _TEXT("Word Length"),
                             NULL,  
                             &lpType,
                             (LPBYTE)&dat,
                             &lpcdata
                             );
    *wordLen = (UCHAR) dat;
    lpcdata = sizeof(DWORD);
    dat = (DWORD) *parity;
    RetVal = RegQueryValueEx(m_child,
                             _TEXT("Parity"),
                             NULL,  
                             &lpType,
                             (LPBYTE)&dat,
                             &lpcdata
                             );
    *parity = (UCHAR) dat;
    RegCloseKey(m_child);
    RegCloseKey(m_hkey);
    TCUnlock(lock);
    return ERROR_SUCCESS;
}


LONG
GetParametersAtIndex(
    int index,
    TCHAR *name,
    int *nameLen,
    TCHAR *device,
    int *deviceLen,
    PUCHAR stopBits,
    PUCHAR parity,
    PUINT baudRate,
    PUCHAR wordLen
    )
{
    LONG RetVal;
    FILETIME lpftLastWriteTime;
    HANDLE lock;
    HKEY m_hkey;

    if ((name == NULL) || (device == NULL)) {
        return -1;
    }
    RetVal = TCLock(&lock);
    if (RetVal != ERROR_SUCCESS) {
        TCUnlock(lock);
        return RetVal;
    }
    RetVal = RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                          HKEY_TCSERV_PARAMETER_KEY,
                          0,
                          KEY_ALL_ACCESS,
                          &m_hkey
                          );
    if(RetVal != ERROR_SUCCESS){
        TCUnlock(lock);
        return RetVal;
    }
    RetVal = RegEnumKeyEx(m_hkey,
                          index,
                          name,
                          nameLen,
                          NULL,
                          NULL,
                          NULL,
                          &lpftLastWriteTime
                          ); 
    if(RetVal != ERROR_SUCCESS){ 
        RegCloseKey(m_hkey);
        TCUnlock(lock);
        return RetVal;
    }
    RegCloseKey(m_hkey);
    TCUnlock(lock);
    return (GetParametersByName(name,
                                nameLen,
                                device,
                                deviceLen,
                                stopBits,
                                parity,
                                baudRate,
                                wordLen));
}


LONG
SetParameters(
    TCHAR *name,
    TCHAR *device,
    PUCHAR stopBits,
    PUCHAR parity,
    PUINT baudRate,
    PUCHAR wordLen
    )
{
    LONG RetVal;
    HKEY m_child, m_hkey;
    int lpcdata;
    DWORD dat;
    HANDLE lock;

    if ((name == NULL) || (device == NULL)) {
        return -1;
    }
    if(_tcslen(name) == 0 || _tcslen(device) == 0){
        return -1;
    }
    RetVal = TCLock(&lock);
    if (RetVal != ERROR_SUCCESS) {
        TCUnlock(lock);
        return RetVal;
    }
    RetVal = RegCreateKeyEx(HKEY_LOCAL_MACHINE,
                            HKEY_TCSERV_PARAMETER_KEY,
                            0,
                            NULL,
                            0,
                            KEY_ALL_ACCESS,
                            NULL,
                            &m_hkey,
                            NULL
                            );
    if(RetVal != ERROR_SUCCESS){
        RegCloseKey(m_hkey);
        TCUnlock(lock);
        return RetVal;
    }
    RetVal= RegCreateKeyEx(m_hkey,
                           name,  // subkey name
                           0,   // reserved
                           NULL,
                           0,
                           KEY_ALL_ACCESS, // security access mask
                           NULL,
                           &m_child,
                           NULL
                           );
    if(RetVal != ERROR_SUCCESS){
        RegCloseKey(m_hkey);
        TCUnlock(lock);
        return RetVal;
    }
    lpcdata = _tcslen(device)*sizeof(TCHAR);
    RetVal = RegSetValueEx(m_child,
                           _TEXT("Device"),
                           0,  
                           REG_SZ,
                           (LPBYTE)device,
                           lpcdata
                           );
    if(RetVal != ERROR_SUCCESS){
        RegCloseKey(m_child);
        RegCloseKey(m_hkey);
        TCUnlock(lock);
        return RetVal;
    }
    if(baudRate){
        lpcdata = sizeof(UINT);
        RetVal = RegSetValueEx(m_child,
                               _TEXT("Baud Rate"),
                               0,  
                               REG_DWORD,
                               (LPBYTE)baudRate,
                               lpcdata
                               );
        if(RetVal != ERROR_SUCCESS){
            RegCloseKey(m_child);
            RegCloseKey(m_hkey);
            TCUnlock(lock);
            return RetVal;
        }

    }
    if(stopBits){
        dat =(DWORD)  *stopBits;
        lpcdata = sizeof(DWORD);
        RetVal = RegSetValueEx(m_child,
                               _TEXT("Stop Bits"),
                               0,  
                               REG_DWORD,
                               (LPBYTE)&dat,
                               lpcdata
                               );
        if(RetVal != ERROR_SUCCESS){
            RegCloseKey(m_child);
            RegCloseKey(m_hkey);
            TCUnlock(lock);
            return RetVal;
        }
    }
    if(wordLen){
        lpcdata = sizeof(DWORD);
        dat = (DWORD) *wordLen;
        RetVal = RegSetValueEx(m_child,
                               _TEXT("Word Length"),
                               0,  
                               REG_DWORD,
                               (LPBYTE)&dat,
                               lpcdata
                               );
        if(RetVal != ERROR_SUCCESS){
            RegCloseKey(m_child);
            RegCloseKey(m_hkey);
            TCUnlock(lock);
            return RetVal;
        }
    }
    if(parity){
        lpcdata = sizeof(DWORD);
        dat = (DWORD) *parity;
        RetVal = RegSetValueEx(m_child,
                             _TEXT("Parity"),
                             0,  
                             REG_DWORD,
                             (LPBYTE)&dat,
                             lpcdata
                             );
        if(RetVal != ERROR_SUCCESS){
            RegCloseKey(m_child);
            RegCloseKey(m_hkey);
            TCUnlock(lock);
            return RetVal;
        }
    }
    RegCloseKey(m_child);
    RegCloseKey(m_hkey);
    TCUnlock(lock);
    return ERROR_SUCCESS;

}

LONG
DeleteKey(
    LPCTSTR name
    )
{
    LONG RetVal;
    HANDLE lock;
    HKEY m_hkey;

    RetVal = TCLock(&lock);
    if (RetVal != ERROR_SUCCESS) {
        return RetVal;
    }
    RetVal = RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                          HKEY_TCSERV_PARAMETER_KEY,
                          0,
                          KEY_ALL_ACCESS,
                          &m_hkey
                              );
    if(RetVal != ERROR_SUCCESS){
        RegCloseKey(m_hkey);
        TCUnlock(lock);
        return RetVal;
    }
    RetVal =  RegDeleteKey(m_hkey,
                           name
                           );
    RegCloseKey(m_hkey);
    TCUnlock(lock);
    return RetVal;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\headless\tcsrv\admin\data\tcdata.h ===
/* 
 * tcdata.h
 * 
 * Contains header information for the data part of the 
 * tcadmin utility.
 * 
 * Sadagopan Rajaram - Dec 27th, 1999.
 *
 */

//
//  NT public header files
//
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <ntseapi.h>

#include <windows.h>
#include <winsock2.h>
#include <align.h>
#include <smbgtpt.h>
#include <dsgetdc.h>
#include <lm.h>
#include <winldap.h>
#include <dsrole.h>
#include <rpc.h>
#include <ntdsapi.h>

#include <lmcons.h>
#include <lmerr.h>
#include <lmsname.h>
#include <rpc.h>
#include <security.h>
#include <ntlmsp.h>
#include <spseal.h>
#include <userenv.h>
#include <setupapi.h>

//
// C Runtime library
//

#include <process.h>
#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <tchar.h>

extern HKEY m_hkey;
extern HKEY m_lock;
extern int m_pid;

#define HKEY_PARAMETERS_LOCK _T("System\\CurrentControlSet\\Services\\TCSERV\\Lock")
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\headless\setup\main.cpp ===
#include <windows.h>
#include <stdio.h>
#include <conio.h>
#include <stdlib.h>
#include <ntddsac.h>
#include <emsapi.h>
#include <ASSERT.h>
#include "resource.h"

#define ANNOUNCE_CHANNEL 0
#define DUMPFILE_MESSAGE 1
#define FILLINFILE_MESSAGE 2
#define SUCCESS_MESSAGE 3
#define FAILURE_MESSAGE 4
#define NO_UNATTEND_FILE 5

typedef struct _UserInputParams {
    EMSRawChannel* Channel; // headless channel object
    HANDLE hInputCompleteEvent; //signals that the user is done.
    HANDLE hRemoveUI;  //signals that we should abort.
} UserInputParams, *PUserInputParams;
    

SAC_CHANNEL_OPEN_ATTRIBUTES GlobalChannelAttributes;

BOOL
IsWorkToDo(
    )
{
    WCHAR PathToUnattendFile[MAX_PATH];
    WCHAR Buffer[256];
    WIN32_FIND_DATA finddata;
    HANDLE hFile;

    ExpandEnvironmentStrings(
        L"%systemroot%\\system32\\$winnt$.inf",
        PathToUnattendFile,
        sizeof(PathToUnattendFile)/sizeof(WCHAR));

    //
    // see if there is an unattend file.  If there isn't then we must have
    // work to do.
    //
    if (!(hFile = FindFirstFile(PathToUnattendFile,&finddata))) {
        return(TRUE);
    }

    FindClose(hFile);

    //
    // Now look at that unattend file and see if it has the 
    // "unattendmode=fullunattend" flag in it.  If it doesn't,
    // then we have work to do.                                                       
    //
    if (GetPrivateProfileString(
                    L"Data",
                    L"UnattendMode",
                    L"",
                    Buffer,
                    sizeof(Buffer),
                    PathToUnattendFile) &&
        !wcscmp(Buffer,L"FullUnattended")) {
        return(FALSE);
    }

    return(TRUE);

}

BOOL 
IsHeadlessPresent(
    OUT EMSRawChannel **Channel
    )
{
    BOOL RetVal;
    
    *Channel = EMSRawChannel::Construct(GlobalChannelAttributes);

    RetVal = (*Channel != NULL);

    return(RetVal);
}
    
INT 
StartSetupProcess(
    IN int argc,
    IN WCHAR *argv[]
    )
{
    BOOL Status;
    STARTUPINFO si;
    PROCESS_INFORMATION pi;
    PWSTR CmdLineArgs;
    int i,len;
    WCHAR PathToSetup[MAX_PATH];

    RtlZeroMemory(&si,sizeof(si));
    RtlZeroMemory(&pi,sizeof(pi));

    GetStartupInfo(&si);

    ExpandEnvironmentStrings( L"%systemroot%\\system32\\setup.exe",
                              PathToSetup,
                              sizeof(PathToSetup)/sizeof(WCHAR));

    len = 0;
    for (i = 1; i< argc; i++) {
        len += (wcslen(argv[i])+1)*sizeof(WCHAR);
    }

    CmdLineArgs = NULL;
    if (len) {
        CmdLineArgs = (PWSTR)HeapAlloc(GetProcessHeap(),0,len);        
        if (CmdLineArgs) {
            CmdLineArgs[0] = L'\0';
            for (i = 1; i< argc; i++) {
               wcscat(CmdLineArgs, argv[i]);
               wcscat(CmdLineArgs, L"\0");
            }
        }
    }
    
    Status = CreateProcess(
            PathToSetup,
            CmdLineArgs,
            NULL,
            NULL,
            FALSE,
            DETACHED_PROCESS|NORMAL_PRIORITY_CLASS,
            NULL,
            NULL,
            &si,
            &pi);

    if (Status == TRUE) {
        CloseHandle(pi.hThread);
        CloseHandle(pi.hProcess);
    }

    if (CmdLineArgs) {
        HeapFree(GetProcessHeap(),0,CmdLineArgs);
    }

    return( (Status == TRUE) 
             ? 0 
             : 1 );

}

BOOL
PromptUserForData(
    EMSRawChannel *Channel,
    DWORD ResourceId
    )
{
    PCWSTR Text;
    DWORD Len;
    switch(ResourceId) {
        case ANNOUNCE_CHANNEL:
            Text =  L"\r\n\r\n\r\nWelcome to GUI-mode setup.  It appears that you have not configured the\r\nsetup process to run completely unattended.\r\nWould you like to input an unattend file now?\r\nPress \"Y\" to indicate Yes, \"D\" to indicate yes (also dump the current\r\nunattended file settings), anything else to indicate no.\r\n";
            break;
        case DUMPFILE_MESSAGE:
            Text = L"\r\n\r\nThis is the current contents of the unattended text file.\r\n";
            break;
        case FILLINFILE_MESSAGE:
            Text = L"\r\nInput a new unattend text file, followed by the EOF specifier (<control>+Z)\r\n";
            break;
        case SUCCESS_MESSAGE:
            Text = L"Successfully created an unattend setup file.  Setup will now proceeed in an unattended manner.\r\n";
            break;    
        case FAILURE_MESSAGE:
            Text = L"\r\nCould not create a valid unattend setup file.  Setup will proceeed, but it may\r\nnot be fully unattended.\r\n";
            break;
        case NO_UNATTEND_FILE:
            Text = L"There is currently no unattend file present on the system.\r\n";
            break;
        default:
            Text = L"Unknown Resource ID.\r\n";
            assert(FALSE);
            break;
    }

    return(Channel->Write((PCBYTE)Text,wcslen(Text)*sizeof(WCHAR)));

    
}

BOOL
OpenFile(
    LPCTSTR FileName,
    DWORD AccessMode,
    DWORD CreationFlags,
    PHANDLE hFile)
{
    WCHAR FullPathToFile[MAX_PATH];

    ExpandEnvironmentStrings( 
        FileName, 
        FullPathToFile, 
        sizeof(FullPathToFile)/sizeof(WCHAR));

    *hFile = CreateFile(
                FullPathToFile,
                AccessMode,
                FILE_SHARE_READ,
                NULL,
                CreationFlags,
                FILE_ATTRIBUTE_NORMAL,
                NULL);

    if (*hFile == INVALID_HANDLE_VALUE) {
        return(FALSE);
    }

    return(TRUE);
}

BOOL
MyDeleteFile(
    LPCTSTR FileName
    )
{
    WCHAR FullPathToFile[MAX_PATH];

    ExpandEnvironmentStrings( 
        FileName, 
        FullPathToFile, 
        sizeof(FullPathToFile)/sizeof(WCHAR));

    return(DeleteFile(FullPathToFile));
    
}


BOOL
MyCopyFile(
    LPCTSTR SourceFileName,
    LPCTSTR DestFileName,
    BOOL FailIfExists)
{
    WCHAR SourceFullPath[MAX_PATH],DestFullPath[MAX_PATH];
    
    ExpandEnvironmentStrings( 
                    SourceFileName, 
                    SourceFullPath, 
                    sizeof(SourceFullPath)/sizeof(WCHAR));

    ExpandEnvironmentStrings( 
                    DestFileName, 
                    DestFullPath, 
                    sizeof(DestFullPath)/sizeof(WCHAR));
            
    return (CopyFile(SourceFullPath,
                     DestFullPath,
                     FailIfExists));    
}


BOOL
DumpFileToHeadlessPort(
    EMSRawChannel *Channel,
    LPCTSTR FileName
    )
{
    HANDLE hFile;
    DWORD Size,SizeHigh,ActuallyRead;
    LONG High = 0;
    CHAR Buffer[80];

    if (!OpenFile(FileName, GENERIC_READ, OPEN_EXISTING, &hFile)) {
        PromptUserForData(Channel,NO_UNATTEND_FILE);
        return(FALSE);
    }
    
    SetFilePointer(hFile,0,&High,FILE_BEGIN);

    //bugbug handle large files
    Size = GetFileSize(hFile,&SizeHigh);
    while(Size != 0) {
        if (ReadFile(hFile,Buffer,sizeof(Buffer),&ActuallyRead,NULL)) {
            Channel->Write((PCBYTE)Buffer,ActuallyRead);
            Size -= ActuallyRead;
        } else {
            break;
        }
    }
    
    CloseHandle(hFile);
    return(TRUE);

}

BOOL
AppendDataToFile(
    EMSRawChannel *Channel,
    HANDLE hFile,
    PBOOL UserComplete
    )
{
    CHAR Buffer[80];
    DWORD BytesRead,BytesWritten;
    DWORD i;
    BOOL  Done = FALSE;

    while(!Done) {
        if (!Channel->Read((PBYTE)Buffer,sizeof(Buffer),&BytesRead)) {
            return(FALSE);
        }
             
        //
        // zero-based
        //
        if (Buffer[BytesRead-1] == 0x1a) {
            *UserComplete = TRUE;
            BytesRead -=1;
            Done = TRUE;
        }

        if (BytesRead) {
        
            if (!WriteFile(
                    hFile,
                    Buffer,
                    BytesRead,
                    &BytesWritten,
                    NULL) ||
                BytesWritten != BytesRead) {
                return(FALSE);
            }

            //
            // echo back to user
            //
            Channel->Write((PBYTE)Buffer,BytesRead);

        }
    
        if (!Done) {
            BOOL NewData = FALSE;
            if (!Channel->HasNewData(&NewData) || NewData == FALSE) {
                Done = TRUE;
            }
        }        
    }
         
    return(TRUE);
}

BOOL
ValidateTempUnattendFile(
    PCWSTR FileName
    )
{
    WCHAR PathToUnattendFile[MAX_PATH];
    WCHAR Buffer[256];
    
    ExpandEnvironmentStrings(
        FileName,
        PathToUnattendFile,
        sizeof(PathToUnattendFile)/sizeof(WCHAR));

    //
    // look at that unattend file and see if it has the 
    // "unattendmode=fullunattend" flag in it.  If it doesn't,
    // then the inf is not valid.                                                       
    //
    if (GetPrivateProfileString(
                    L"Data",
                    L"UnattendMode",
                    L"",
                    Buffer,
                    sizeof(Buffer),
                    PathToUnattendFile) &&
        !_wcsicmp(Buffer,L"FullUnattended")) {
        return(TRUE);
    }
    
    return(FALSE);
}


DWORD    
PromptForUserInputThreadOverHeadlessConnection(
    PVOID params
    )
{
    PUserInputParams Params = (PUserInputParams)params;
    EMSRawChannel *Channel = Params->Channel;
    HANDLE Handles[2];
    BOOL Abort = FALSE;
    BOOL Verbose = TRUE;
    BOOL UserComplete = FALSE;
    CHAR Buffer[10];
    ULONG BytesRead;
    HANDLE hTempUnattendFile;
    DWORD Result;

    //  
    // prompt the user so they know what's going on.
    //
    PromptUserForData(Channel,ANNOUNCE_CHANNEL);

    Handles[0] = Params->hRemoveUI;
    //
    // bugbug should really get this from our object...
    // 
    Handles[1] = GlobalChannelAttributes.HasNewDataEvent;
    
    //
    // wait for user input.
    //
    Result = WaitForMultipleObjects(2,Handles,FALSE,INFINITE);

    //
    // Did user abort?
    //
    if (Result == WAIT_OBJECT_0) {
        Abort = TRUE;
        goto ExitThread;        
    }

    //
    // We got new data.
    //
    if (Result == WAIT_OBJECT_0+1) {
        if (!Channel->Read(
                 (PBYTE)Buffer,
                 sizeof(Buffer),
                 &BytesRead)) {
            //
            // error reading data.  bail out.
            //
            PromptUserForData(Channel,FAILURE_MESSAGE);
            goto ExitThread;
        }
    }

    assert(Result == WAIT_OBJECT_0+1);

    if (Buffer[0] != 'Y' && Buffer[0] != 'y' &&
        Buffer[0] != 'D' && Buffer[0] != 'd') {
        PromptUserForData(Channel,FAILURE_MESSAGE);
        goto ExitThread;
    }

    if (Buffer[0] == 'D' || Buffer[0] == 'd') {
        Verbose = TRUE; 
    } else {
        Verbose = FALSE;        
    }
    
    //
    // now dump the unattend file over the port so they know what they have...
    //    
    if (Verbose) {
        PromptUserForData(Channel,DUMPFILE_MESSAGE);
        DumpFileToHeadlessPort(Channel,L"%systemroot%\\system32\\$winnt$.inf");
    }

    if (!OpenFile(
            L"%systemroot%\\system32\\EMSUnattend.txt", 
            GENERIC_READ | GENERIC_WRITE, 
            CREATE_ALWAYS, 
            &hTempUnattendFile)) {
        PromptUserForData(Channel,FAILURE_MESSAGE);
        goto ExitThread;
    }
    

    Handles[0] = Params->hRemoveUI;
    //
    // bugbug should really get this from our object...
    // 
    Handles[1] = GlobalChannelAttributes.HasNewDataEvent;
    //
    // now wait for the user to finish providing input.
    //
    PromptUserForData(Channel,FILLINFILE_MESSAGE);

    
    while(1) {
        Result = WaitForMultipleObjects(2,Handles,FALSE,INFINITE);
        if (Result = WAIT_OBJECT_0) {
            Abort = TRUE;
            CloseHandle(hTempUnattendFile);
            MyDeleteFile(L"%systemroot%\\system32\\EMSUnattend.txt");
            break;
        }

        if (!AppendDataToFile(
                        Channel,
                        hTempUnattendFile,
                        &UserComplete)) {
            PromptUserForData(Channel,FAILURE_MESSAGE);
            CloseHandle(hTempUnattendFile);
            MyDeleteFile(L"%systemroot%\\system32\\EMSUnattend.txt");
            break;
        }

        if (UserComplete) {
            CloseHandle(hTempUnattendFile);

            if (ValidateTempUnattendFile(
                            L"%systemroot%\\system32\\EMSUnattend.txt")) {
                MyCopyFile(
                    L"%systemroot%\\system32\\$winnt$.inf",
                    L"%systemroot%\\system32\\$winnt$.bak",
                    TRUE);

                MyCopyFile(
                    L"%systemroot%\\system32\\EMSUnattend.txt",
                    L"%systemroot%\\system32\\$winnt$.inf",
                    FALSE);

                PromptUserForData(Channel,SUCCESS_MESSAGE);
            } else {
                PromptUserForData(Channel,FAILURE_MESSAGE);                
            }
            break;
        }

    }

ExitThread:
    
    SetEvent(Params->hInputCompleteEvent);

    Sleep(5000);
    
    return 0;
}

INT_PTR CALLBACK 
UserInputAbortProc(
    HWND hwndDlg,  // handle to dialog box
    UINT uMsg,     // message
    WPARAM wParam, // first message parameter
    LPARAM lParam  // second message parameter
    )
{
    BOOL retval = FALSE;
    static UINT_PTR TimerId;
    static HANDLE hRemoveUI;
    
    switch(uMsg) {
    case WM_INITDIALOG:
        hRemoveUI = (HANDLE)lParam;
        if (!(TimerId = SetTimer(hwndDlg,0,1000,NULL))) {
            EndDialog(hwndDlg,0);
        }
        break;

    case WM_TIMER:
        if (WaitForSingleObject(hRemoveUI,0) == WAIT_OBJECT_0) {
            KillTimer(hwndDlg,TimerId);
            EndDialog(hwndDlg,1);
        }
        break;

    case WM_COMMAND:
        switch (HIWORD( wParam ))
        {
        case BN_CLICKED:
            switch (LOWORD( wParam ))
            {
            case IDOK:
            case IDCANCEL:
                EndDialog(hwndDlg,2);
            }
        };
    }

    return(retval);

}


DWORD    
PromptForUserInputThreadViaLocalDialog(
    PVOID params
    )
{
    PUserInputParams Params = (PUserInputParams)params;
    
    DialogBoxParam(
            GetModuleHandle(NULL),
            MAKEINTRESOURCE(IDD_ABORTDIALOG),
            NULL,
            UserInputAbortProc,
            (LPARAM)Params->hRemoveUI);
        
    SetEvent(Params->hInputCompleteEvent);
    
    return 0;
}


BOOL
InitializeGlobalChannelAttributes(
    PSAC_CHANNEL_OPEN_ATTRIBUTES ChannelAttributes
    )
{
    RtlZeroMemory(ChannelAttributes,sizeof(SAC_CHANNEL_OPEN_ATTRIBUTES));
    ChannelAttributes->Type = ChannelTypeRaw;
    ChannelAttributes->Name = L"Unattended Setup Channel";
    ChannelAttributes->Description = L"Gives the ability to input unattended setup parameters before proceeding with GUI-Setup.";
    ChannelAttributes->Flags = SAC_CHANNEL_FLAG_HAS_NEW_DATA_EVENT;
    ChannelAttributes->HasNewDataEvent = CreateEvent(NULL,FALSE,FALSE,NULL);
    ChannelAttributes->ApplicationType = NULL;

    return((ChannelAttributes->HasNewDataEvent != NULL) 
            ? TRUE
            : FALSE);

}

int __cdecl
wmain(
    IN int argc,
    WCHAR *argvW[]
    )
{
    UserInputParams Params,ParamsDialog;
    EMSRawChannel *Channel = NULL;
    DWORD ThreadId;
    HANDLE Handles[2];
    HANDLE hThreadHeadless = NULL,hThreadUI = NULL;

    RtlZeroMemory(&Params,sizeof(Params));
    RtlZeroMemory(&ParamsDialog,sizeof(ParamsDialog));

    InitializeGlobalChannelAttributes(&GlobalChannelAttributes);
    
    //
    // Check if headless feature is present on this machine.  If not, just
    // run setup like normal.
    //
    if(!IsHeadlessPresent(&Channel)) {
        goto run_setup;
    }

    //
    // Check if there is any work for us to do.  If not, just run setup like
    // normal.
    //
    if (!IsWorkToDo()) {
        goto run_setup;
    }

    //
    // Create another thread for getting data from the user.
    //
    Params.Channel = Channel;
    Params.hInputCompleteEvent  = CreateEvent(NULL,TRUE,FALSE,NULL);
    ParamsDialog.hInputCompleteEvent  = CreateEvent(NULL,TRUE,FALSE,NULL);    
    Params.hRemoveUI = ParamsDialog.hRemoveUI = CreateEvent(NULL,TRUE,FALSE,NULL);    
    
    if (!Params.hInputCompleteEvent || 
        !ParamsDialog.hInputCompleteEvent ||
        !Params.hRemoveUI) {
        goto run_setup;
    }

    if (!(hThreadHeadless = CreateThread(
                    NULL,
                    0,
                    &PromptForUserInputThreadOverHeadlessConnection,
                    &Params,
                    0,
                    &ThreadId))) {
            goto run_setup;
    } 

    if (!(hThreadUI = CreateThread(
            NULL,
            0,
            &PromptForUserInputThreadViaLocalDialog,
            &ParamsDialog,
            0,
            &ThreadId))) {
        goto run_setup;
    }    

    
    Handles[0] = Params.hInputCompleteEvent;
    Handles[1] = ParamsDialog.hInputCompleteEvent;

    WaitForMultipleObjects(2,Handles,FALSE,INFINITE);
    
    SetEvent(Params.hRemoveUI);

    Handles[0] = hThreadHeadless;
    Handles[1] = hThreadUI;
    
    WaitForMultipleObjects(2,Handles,TRUE,INFINITE);    

run_setup:
    if (hThreadHeadless) {
        CloseHandle(hThreadHeadless);
    }

    if (hThreadUI) {
        CloseHandle(hThreadUI);
    }

    if (Params.hInputCompleteEvent) {
        CloseHandle(Params.hInputCompleteEvent);
    }

    if (ParamsDialog.hInputCompleteEvent) {
        CloseHandle(ParamsDialog.hInputCompleteEvent);
    }

    if (Params.hRemoveUI) {
        CloseHandle(Params.hRemoveUI);
    }
    
    if (Channel) {
        delete (Channel);
    }

    return (StartSetupProcess(argc, argvW));

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\headless\tcsrv\admin\console\utils.c ===
/*
 * Copyright (c) Microsoft Corporation
 * 
 * Module Name : 
 *        utils.c
 *
 * Contains all the work needed to present the console
 *
 * 
 * Sadagopan Rajaram -- Dec 20, 1999
 *
 */

#include "tcadmin.h"

BOOL AnsiStatus = (sizeof(TCHAR) == sizeof(CHAR));


BOOL
Browse(
    )
{
    int index,j;
    LONG retVal;
    DWORD len;
    TCHAR name[MAX_BUFFER_SIZE];
    LPTSTR message[NUMBER_FIELDS + 1];
    TCHAR device[MAX_BUFFER_SIZE];
    int nameLen, deviceLen;
    UINT baudRate;
    LPTSTR temp;
    UCHAR stopBits, parity, wordLen;
    BOOL cont = TRUE;
    TCHAR key;
    LPTSTR confirm;
    BOOL readRet;

    for(index = 0; index < NUMBER_FIELDS; index ++){
        message[index]  = RetreiveMessageText(MSG_NAME_PROMPT+index);
        if (!message[index]) {
            for(j=index-1; j>=0;j--){
                TCFree(message[j]);
            }
            _tprintf(_T("Cannot find Resources\n"));
            return FALSE;
        }
        temp = message[index];
        while(*temp != _T('%')){
            temp++;
        }
        *temp = (TCHAR) 0;
    }
    message[index]  = RetreiveMessageText(MSG_NAME_PROMPT+index);
    if (!message[index]) {
        for(j=index-1; j>=0;j--){
            TCFree(message[j]);
        }
        _tprintf(_T("Cannot find Resources\n"));
        index ++;
        return FALSE;
    }
    confirm = RetreiveMessageText(MSG_CONFIRM_PROMPT);
    if (!confirm) {
        for(j=index-1; j>=0;j--){
            TCFree(message[j]);
        }
        _tprintf(_T("Cannot find Resources\n"));
        index ++;
        return FALSE;
    }
    confirm[_tcslen(confirm) - 2] = _T('\0');                              
    index = 0;
    do{
        parity = NO_PARITY;
        baudRate = DEFAULT_BAUD_RATE;
        stopBits = 0;
        wordLen = 8;
        nameLen = deviceLen =MAX_BUFFER_SIZE;
        name[0] = device[0] = (TCHAR) 0;
        retVal = (LONG) (getparams)(index,
                                    name,
                                    &nameLen,
                                    device, 
                                    &deviceLen,
                                    &stopBits,
                                    &parity,
                                    &baudRate,
                                    &wordLen
                                    );
        if(retVal != ERROR_SUCCESS){
            if (retVal == ERROR_NO_MORE_ITEMS){
                index --;
                if(index < 0 ) {
                    cont=FALSE;
                    continue;
                }
                goto input;
            }
            else{
                _tprintf(_T("%d\n"),retVal);
                cont=FALSE;
            }
            continue;
        }
        DisplayParameters(message, 
                          name,
                          device,
                          baudRate,
                          wordLen,
                          parity,
                          stopBits
                          );
        _tprintf(_T("%s"),message[6]);
input:
        readRet = ReadFile(hConsoleInput,
                           &key,
                           sizeof(TCHAR),
                           &len,
                           NULL
                           );
        if(!readRet || !len){
            exit(1);
        }
        if(lastChar == _T('\r') && key == _T('\n')){
            lastChar = key;
            goto input;
        }

        lastChar = key;
        switch(key){
        case _T('p'):
        case _T('P'):
            if(index == 0){
                goto input;
            }
            index --;
            break;
        case _T('n'):
        case _T('N'):
            index ++;
            break;
        case _T('m'):
        case _T('M'):
            cont=FALSE;
            break;
        case _T('d'):
        case _T('D'):
            retVal = (LONG) (deletekey)(name);
            if(index > 0){
                index --;
            }
            break;
        case _T('e'):
        case _T('E'):
            retVal = DisplayEditMenu(name,
                                     _tcslen(name),
                                     device,
                                     _tcslen(device),
                                     &baudRate,
                                     &wordLen,
                                     &parity,
                                     &stopBits
                                     );

            if(retVal == ERROR_SUCCESS){
                DisplayParameters(message, 
                                  name,
                                  device,
                                  baudRate,
                                  wordLen,
                                  parity,
                                  stopBits
                                  );
                _tprintf(_T("%s"),confirm);
                do{
                    readRet = ReadFile(hConsoleInput,
                                       &key,
                                       sizeof(TCHAR),
                                       &len,
                                       NULL
                                   );
                    if(!readRet || !len){
                        exit(1);
                    }
                    if(lastChar != _T('\r') || key != _T('\n')){
                        lastChar = key;
                        break;
                    }
                    lastChar = key;
                }while(1);

                if((key == _T('y')) 
                   || (key == _T('Y'))){
                    retVal = (LONG) (setparams)(name,
                                                device,
                                                &stopBits,
                                                &parity,
                                                &baudRate,
                                                &wordLen
                                                );
                    if(retVal != ERROR_SUCCESS){
                        temp = RetreiveMessageText(MSG_ERROR_SET);
                        temp[_tcslen(temp) - 2 ] = _T('\0');
                        if(temp){
                            _tprintf(_T("%s %d"),temp,retVal);
                        }
                        TCFree(temp);
                    }
                }
            }
            break;
        default:
            goto input;
        }

    }while(cont);

    for(index = 0; index <= NUMBER_FIELDS; index ++){
        TCFree(message[index]);
    }

    return TRUE;
}

VOID DisplayScreen(
    UINT MessageID
    )
{
    LPTSTR Message;
    DWORD len;

    Message = RetreiveMessageText(MessageID);
    if (!Message) {
        _tprintf(_T("Cannot retreive message\n"));
        return;
    }
    _tprintf(_T("%s"),Message);
    TCFree(Message);
    return;
}

int 
DisplayEditMenu(
    TCHAR *name,
    int nameLen,
    TCHAR *device,
    int deviceLen,
    UINT *BaudRate,
    UCHAR *WordLen,
    UCHAR *Parity,
    UCHAR *StopBits
    )
{


    LPTSTR message,temp,curr;
    int i;
    DWORD len;
    BOOL ret;
    TCHAR buffer[MAX_BUFFER_SIZE];
    int dat;

    message = RetreiveMessageText(MSG_NAME_PROMPT);
    if(! message){
        return -1;
    }
    temp = message;
    while(*temp != _T('%')){
        temp ++;
    }
    *temp = (TCHAR) 0;
    _tprintf(_T("%s"),message);
    TCFree(message);
    while(!GetLine(name, nameLen, MAX_BUFFER_SIZE));
    message = RetreiveMessageText(MSG_DEVICE_PROMPT);
    if(! message){
        return -1;
    }
    temp = message;
    while(*temp != _T('%')){
        temp ++;
    }
    *temp = (TCHAR) 0;
    _tprintf(_T("%s"),message);
    TCFree(message);
    while(!GetLine(device, deviceLen, MAX_BUFFER_SIZE));
    message = RetreiveMessageText(MSG_BAUD_PROMPT);
    if(! message){
        return -1;
    }
    temp = message;
    while(*temp != _T('%')){
        temp ++;
    }
    *temp = (TCHAR) 0;
    _tprintf(_T("%s"),message);
    TCFree(message);
    _stprintf(buffer,_T("%d"),*BaudRate);
    while(!GetLine(buffer,_tcslen(buffer) , MAX_BUFFER_SIZE));
    _stscanf(buffer,_T("%d"),BaudRate); 
    message = RetreiveMessageText(MSG_WORD_PROMPT);
    if(! message){
        return -1;
    }
    temp = message;
    while(*temp != _T('%')){
        temp ++;
    }
    *temp = (TCHAR) 0;
    _tprintf(_T("%s"),message);
    TCFree(message);
    _stprintf(buffer,_T("%d"),*WordLen);
    while(!GetLine(buffer,_tcslen(buffer) , MAX_BUFFER_SIZE));
    _stscanf(buffer,_T("%d"),&dat); 
    *WordLen = (UCHAR) dat;
    message = RetreiveMessageText(MSG_PARITY_PROMPT2);
    if(! message){
        return -1;
    }
    temp = curr = message;
    while(*temp != _T('%')){
        temp ++;
    }
    *temp = (TCHAR) 0;
    _tprintf(_T("%s%d"),curr,NO_PARITY);
    curr = &(temp[1]);
    while(*temp != _T('%')){
        temp ++;
    }
    *temp = (TCHAR) 0;
    _tprintf(_T("%s%d"),curr,ODD_PARITY);
    curr = &(temp[1]);
    while(*temp != _T('%')){
        temp ++;
    }
    *temp = (TCHAR) 0;
    _tprintf(_T("%s%d"),curr,EVEN_PARITY);
    curr = &(temp[1]);
    while(*temp != _T('%')){
        temp ++;
    }
    *temp = (TCHAR) 0;
    _tprintf(_T("%s%d"),curr,MARK_PARITY);
    curr = &(temp[1]);
    while(*temp != _T('%')){
        temp ++;
    }
    *temp = (TCHAR) 0;
    _tprintf(_T("%s%d"),curr,SPACE_PARITY);
    curr = &(temp[1]);
    while(*temp != _T('%')){
        temp ++;
    }
    *temp = (TCHAR) 0;
    _tprintf(_T("%s"),curr);
    TCFree(message);
    _stprintf(buffer,_T("%d"),*Parity);
    while(!GetLine(buffer,_tcslen(buffer) , MAX_BUFFER_SIZE));
    _stscanf(buffer,_T("%d"),&dat); 
    *Parity = (UCHAR) dat;
    message = RetreiveMessageText(MSG_STOP_PROMPT2);
    if(! message){
        return -1;
    }
    temp = curr = message;
    while(*temp != _T('%')){
        temp ++;
    }
    *temp = (TCHAR) 0;
    _tprintf(_T("%s%d"),curr,STOP_BIT_1);
    curr = &(temp[1]);
    while(*temp != _T('%')){
        temp ++;
    }
    *temp = (TCHAR) 0;
    _tprintf(_T("%s%d"),curr,STOP_BITS_1_5);
    curr = &(temp[1]);
    while(*temp != _T('%')){
        temp ++;
    }
    *temp = (TCHAR) 0;
    _tprintf(_T("%s%d"),curr,STOP_BITS_2);
    curr = &(temp[1]);
    while(*temp != _T('%')){
        temp ++;
    }
    *temp = (TCHAR) 0;
    _tprintf(_T("%s"),curr);
    TCFree(message);
    _stprintf(buffer,_T("%d"),*StopBits);
    while(!GetLine(buffer,_tcslen(buffer) , MAX_BUFFER_SIZE));
    _stscanf(buffer,_T("%d"),&dat); 
    *StopBits = (UCHAR) dat;

    return ERROR_SUCCESS;

}

LPTSTR
RetreiveMessageText(
    IN     ULONG  MessageId
    )
{
    ULONG LenBytes;
    PMESSAGE_RESOURCE_ENTRY MessageEntry;
    BOOLEAN IsUnicode;
    ANSI_STRING AnsiString;
    UNICODE_STRING UnicodeString;
    NTSTATUS Status;
    LPTSTR MessageText;

    Status = RtlFindMessage(
                ResourceImageBase,
                (ULONG)(ULONG_PTR)RT_MESSAGETABLE,
                0,
                MessageId,
                &MessageEntry
                );

    if(!NT_SUCCESS(Status)) {
        _tprintf(_T("TCADMIN: Can't find message 0x%lx\n"),MessageId);
        return(NULL);
    }

    IsUnicode = (BOOLEAN)((MessageEntry->Flags & 
                           MESSAGE_RESOURCE_UNICODE) != 0);

    //
    // Get the size in bytes of a buffer large enough to hold the
    // message and its terminating nul wchar.  If the message is
    // unicode, then this value is equal to the size of the message.
    // If the message is not unicode, then we have to calculate this value.
    //
    if(IsUnicode) {
        #ifdef UNICODE
        LenBytes = (wcslen((PWSTR)MessageEntry->Text) 
                    + 1)*sizeof(WCHAR);
        #else
        LenBytes = wcstombs(NULL,(PWSTR)MessageEntry->Text, 0);
        #endif
    } else {

        //
        // RtlAnsiStringToUnicodeSize includes an implied wide-nul terminator
        // in the count it returns.
        //
        #ifdef UNICODE
        AnsiString.Buffer = MessageEntry->Text;
        AnsiString.Length = (USHORT)strlen(MessageEntry->Text);
        AnsiString.MaximumLength = AnsiString.Length;

        LenBytes = RtlAnsiStringToUnicodeSize(&AnsiString);
        #else
        LenBytes = strlen((PCHAR) MessageEntry->Text);
        #endif
    }

    LenBytes += sizeof(TCHAR);
    //
    // allocate a buffer.
    //
    MessageText = (LPTSTR) TCAlloc(LenBytes);
    if(MessageText == NULL) {
        return(NULL);
    }
    memset(MessageText,0,LenBytes);
    if(IsUnicode) {

        //
        // Message is already unicode; just copy it into the buffer.
        //
        #ifdef UNICODE
        wcscpy(MessageText,(PWSTR)MessageEntry->Text);
        #else
        LenBytes = wcstombs((PCHAR) MessageText, 
                            (PWCHAR) MessageEntry->Text, 
                            LenBytes);
        #endif

    } else {

        //
        // Message is not unicode; convert in into the buffer.
        //
        #ifdef UNICODE
        UnicodeString.Buffer = MessageText;
        UnicodeString.Length = 0;
        UnicodeString.MaximumLength = (USHORT)LenBytes;

        RtlAnsiStringToUnicodeString(&UnicodeString,
                                     &AnsiString,
                                     FALSE
                                     );
        #else
        strcpy((PCHAR) MessageText, (PCHAR) MessageEntry->Text);
        #endif
    }

    return(MessageText);
}

LONG
GetLine(
    LPTSTR str,
    int index,
    int MaxLength
    )
{
    DWORD len;
    DWORD size;
    TCHAR buffer[3];
    BOOL ret;

    str[index] = (TCHAR) 0;
    FlushConsoleInputBuffer(hConsoleInput);
    _tprintf(_T("%s"),str);
    buffer[0] = buffer[2] = (TCHAR) 0x8;
    buffer[1] = (TCHAR) 0;
    do{
        if (index == MaxLength) {
            index--;
        }

        //
        // Read a (possibly) partial command line.
        //
        do{
            ret = ReadFile(hConsoleInput,
                           &(str[index]),
                           sizeof(TCHAR),
                           &len,
                           NULL
                           );
            if(!ret || !len){
                exit(1);
            }
            if(lastChar != _T('\r') || str[index] != _T('\n')){
                //ignore \r\n combinations
                lastChar = str[index];
                break;
            }
            lastChar = str[index];
        }while(1);
        
        lastChar = str[index];
        if ((str[index] == (TCHAR) 0x8) ||   // backspace (^h)
            (str[index] == (TCHAR) 0x7F)) {  // delete
            if (index > 0) {
                WriteConsole(hConsoleOutput,
                             buffer,
                             3,
                             &len,
                             NULL
                             );
                index--;
            }
        } else {
            WriteConsole(hConsoleOutput,
                         &(str[index]),
                         1,
                         &len,
                         NULL
                         );
            index++;
        }
    } while ((index == 0) || ((str[index - 1] != _T('\n')) &&(str[index-1] != _T('\r'))));

    if(str[index-1] == _T('\r')){
        buffer[0] = '\n';
        str[index - 1] = '\0';
    }
    else{
        buffer[0] = _T('\r');
        str[index-1] ='\0';
    }

    WriteConsole(hConsoleOutput,
                 buffer,
                 1,
                 &len,
                 NULL
                 );
    FlushConsoleInputBuffer(hConsoleInput);
    return index;
}

VOID
DisplayParameters(
    LPCTSTR *message,
    LPCTSTR name,
    LPCTSTR device,
    UINT baudRate,
    UCHAR wordLen,
    UCHAR parity,
    UCHAR stopBits
    )
{
    _tprintf(_T("%s "),message[0]);
    _tprintf(_T("%s\n"),name);
    _tprintf(_T("%s "),message[1]);
    _tprintf(_T("%s\n"),device);
    _tprintf(_T("%s "),message[2]);
    _tprintf(_T("%d\n"),baudRate);
    _tprintf(_T("%s "),message[3]);
    _tprintf(_T("%d\n"),wordLen);
    _tprintf(_T("%s "),message[4]);
    switch(parity){
    case NO_PARITY:
        _tprintf(_T("NONE\n"));
        break;
    case ODD_PARITY:
        _tprintf(_T("ODD\n"));
        break;
    case EVEN_PARITY:
        _tprintf(_T("EVEN\n"));
        break;
    case MARK_PARITY:
        _tprintf(_T("MARK\n"));
        break;
    case SPACE_PARITY:
        _tprintf(_T("SPACE\n"));
        break;
    default:
        _tprintf(_T("NONE\n"));
        break;
    }
    _tprintf(_T("%s "),message[5]);
    switch(stopBits){
    case STOP_BIT_1:
        _tprintf(_T("1\n"));
        break;
    case STOP_BITS_1_5:
        _tprintf(_T("1.5\n"));
        break;
    case STOP_BITS_2:
        _tprintf(_T("2\n"));
        break;
    default:
        _tprintf(_T("1\n"));
        break;
    }

}

VOID SendParameterChange(
    )
{
    SC_HANDLE sc_handle;
    SC_HANDLE tc_handle;
    LPTSTR temp;
    BOOL ret;
    SERVICE_STATUS status;

    sc_handle = OpenSCManager(NULL,
                             NULL,
                             GENERIC_READ
                             );
    if (sc_handle == NULL){
        temp = RetreiveMessageText(CANNOT_OPEN_SERVICE_MANAGER);
        if(temp){
            temp[_tcslen(temp) - 2] = (TCHAR) 0;
            _tprintf(_T("%s"), temp);
            return;
        }
    }
    tc_handle = OpenService(sc_handle,
                            TCSERV_NAME,
                            SERVICE_ALL_ACCESS
                            );

    if (tc_handle == NULL){
        temp = RetreiveMessageText(CANNOT_OPEN_SERVICE);
        if(temp){
            temp[_tcslen(temp) - 2] = (TCHAR) 0;
            _tprintf(_T("%s %d"), temp,GetLastError());
            TCFree(temp);
            CloseServiceHandle(sc_handle);
            return;
        }
    }
    ret = ControlService(tc_handle,
                         SERVICE_CONTROL_PARAMCHANGE,
                         &status
                         );
    if(ret == FALSE){
        temp = RetreiveMessageText(CANNOT_SEND_PARAMETER_CHANGE);
        if(temp){
            temp[_tcslen(temp) - 2] = (TCHAR) 0;
            _tprintf(_T("%s %d"), temp, GetLastError());
            TCFree(temp);
            CloseServiceHandle(tc_handle);
            CloseServiceHandle(sc_handle);
            return;
        }
    }
    temp = RetreiveMessageText(SUCCESSFULLY_SENT_PARAMETER_CHANGE);
    if(temp){
        _tprintf(_T("%s"), temp);
        TCFree(temp);
    }
    CloseServiceHandle(tc_handle);
    CloseServiceHandle(sc_handle);
    return;

}

VOID
GetStatus(
    )
{
    SC_HANDLE sc_handle;
    SC_HANDLE tc_handle;
    DWORD len;
    int i;
    LPTSTR temp;
    BOOL ret;
    SERVICE_STATUS_PROCESS status;
    DWORD val[] = {
        SERVICE_STOPPED,
        SERVICE_START_PENDING,
        SERVICE_STOP_PENDING,
        SERVICE_RUNNING,
        SERVICE_CONTINUE_PENDING,
        SERVICE_PAUSE_PENDING,
        SERVICE_PAUSED
        };

    sc_handle = OpenSCManager(NULL,
                             NULL,
                             GENERIC_READ
                             );
    if (sc_handle == NULL){
        temp = RetreiveMessageText(CANNOT_OPEN_SERVICE_MANAGER);
        if(temp){
            temp[_tcslen(temp) - 2] = (TCHAR) 0;
            _tprintf(_T("%s"), temp);
            return;
        }
    }
    tc_handle = OpenService(sc_handle,
                            TCSERV_NAME,
                            SERVICE_ALL_ACCESS
                            );

    if (tc_handle == NULL){
        temp = RetreiveMessageText(CANNOT_OPEN_SERVICE);
        if(temp){
            temp[_tcslen(temp) - 2] = (TCHAR) 0;
            _tprintf(_T("%s %d"), temp,GetLastError());
            TCFree(temp);
            CloseServiceHandle(sc_handle);
            return;
        }
    }
    ret = QueryServiceStatusEx(tc_handle,
                               SC_STATUS_PROCESS_INFO,
                               (LPBYTE) &status,
                               sizeof(status),
                               &len
                               );
    if(ret == FALSE){
        temp = RetreiveMessageText(CANNOT_QUERY_STATUS);
        if(temp){
            temp[_tcslen(temp) - 2] = (TCHAR) 0;
            _tprintf(_T("%s %d"), temp, GetLastError());
            TCFree(temp);
            CloseServiceHandle(tc_handle);
            CloseServiceHandle(sc_handle);
            return;
        }
    }
    temp = RetreiveMessageText(QUERY_STATUS_SUCCESS);
    if(temp){
        temp[_tcslen(temp) -2 ] = (TCHAR) 0;
        _tprintf(_T("%s"), temp);
        TCFree(temp);
        for(i = 0 ; i<NUMBER_OF_STATES; i++){
            if(val[i] == status.dwCurrentState) break;
        }
        temp = RetreiveMessageText(SERVICE_STOPPED_MESSAGE + i);
        if(temp){
            _tprintf(_T("%s"),temp);
            TCFree(temp);
        }

    }
    CloseServiceHandle(tc_handle);
    CloseServiceHandle(sc_handle);
    return;
    
}

VOID StopTCService(
    )
{
    SC_HANDLE sc_handle;
    SC_HANDLE tc_handle;
    LPTSTR temp;
    BOOL ret;
    SERVICE_STATUS status;

    sc_handle = OpenSCManager(NULL,
                             NULL,
                             GENERIC_READ
                             );
    if (sc_handle == NULL){
        temp = RetreiveMessageText(CANNOT_OPEN_SERVICE_MANAGER);
        if(temp){
            temp[_tcslen(temp) - 2] = (TCHAR) 0;
            _tprintf(_T("%s"), temp);
            return;
        }
    }
    tc_handle = OpenService(sc_handle,
                            TCSERV_NAME,
                            SERVICE_ALL_ACCESS
                            );

    if (tc_handle == NULL){
        temp = RetreiveMessageText(CANNOT_OPEN_SERVICE);
        if(temp){
            temp[_tcslen(temp) - 2] = (TCHAR) 0;
            _tprintf(_T("%s %d"), temp,GetLastError());
            TCFree(temp);
            CloseServiceHandle(sc_handle);
            return;
        }
    }
    ret = ControlService(tc_handle,
                         SERVICE_CONTROL_STOP,
                         &status
                         );
    if(ret == FALSE){
        temp = RetreiveMessageText(CANNOT_SEND_STOP);
        if(temp){
            temp[_tcslen(temp) - 2] = (TCHAR) 0;
            _tprintf(_T("%s %d"), temp, GetLastError());
            TCFree(temp);
            CloseServiceHandle(tc_handle);
            CloseServiceHandle(sc_handle);
            return;
        }
    }
    temp = RetreiveMessageText(SUCCESSFULLY_SENT_STOP);
    if(temp){
        _tprintf(_T("%s"), temp);
        TCFree(temp);
    }
    CloseServiceHandle(tc_handle);
    CloseServiceHandle(sc_handle);
    return;

}

VOID StartTCService(
    )
{
    SC_HANDLE sc_handle;
    SC_HANDLE tc_handle;
    LPTSTR temp;
    BOOL ret;
    SERVICE_STATUS status;

    sc_handle = OpenSCManager(NULL,
                             NULL,
                             GENERIC_READ
                             );
    if (sc_handle == NULL){
        temp = RetreiveMessageText(CANNOT_OPEN_SERVICE_MANAGER);
        if(temp){
            temp[_tcslen(temp) - 2] = (TCHAR) 0;
            _tprintf(_T("%s"), temp);
            return;
        }
    }
    tc_handle = OpenService(sc_handle,
                            TCSERV_NAME,
                            SERVICE_ALL_ACCESS
                            );

    if (tc_handle == NULL){
        temp = RetreiveMessageText(CANNOT_OPEN_SERVICE);
        if(temp){
            temp[_tcslen(temp) - 2] = (TCHAR) 0;
            _tprintf(_T("%s %d"), temp,GetLastError());
            TCFree(temp);
            CloseServiceHandle(sc_handle);
            return;
        }
    }
    ret = StartService(tc_handle,
                       0,
                       NULL
                       );
    if(ret == FALSE){
        temp = RetreiveMessageText(CANNOT_SEND_START);
        if(temp){
            temp[_tcslen(temp) - 2] = (TCHAR) 0;
            _tprintf(_T("%s %d"), temp, GetLastError());
            TCFree(temp);
            CloseServiceHandle(tc_handle);
            CloseServiceHandle(sc_handle);
            return;
        }
    }
    temp = RetreiveMessageText(SUCCESSFULLY_SENT_START);
    if(temp){
        _tprintf(_T("%s"), temp);
        TCFree(temp);
    }
    CloseServiceHandle(tc_handle);
    CloseServiceHandle(sc_handle);
    return;

}

VOID
AddAllComPorts(
    )
/* 
 * Adds all the Com ports in the system as parameters to bridge
 * Reads key HKEY_LOCAL_MACHINE\HARDWARE\DEVICEMAP\SERIALCOMM
 * Each value name is a com device name. The friendly name is the 
 * value data
 * 
 */
{
    DWORD index;
    HKEY m_hkey;
    ULONG retVal;
    LPTSTR temp;
    TCHAR device[MAX_BUFFER_SIZE*2];
    TCHAR name[MAX_BUFFER_SIZE];
    UINT baudRate;
    DWORD type;
    DWORD deviceLen,nameLen;
    UCHAR stopBits, parity, wordLen;
    
    index = 0;

    retVal = RegOpenKey(HKEY_LOCAL_MACHINE,
                        SERIAL_DEVICE_KEY,
                        &m_hkey
                        );
    if(retVal != ERROR_SUCCESS){
        _tprintf(_T("%d\n"),retVal);
        return;
    }

    index = 0;
    while(1){
        deviceLen = nameLen = MAX_BUFFER_SIZE;
        retVal = RegEnumValue(m_hkey,
                              index,
                              device,
                              &deviceLen,
                              NULL,
                              &type,
                              name,
                              &nameLen
                              );
        if(retVal != ERROR_SUCCESS){
            if(retVal != ERROR_NO_MORE_ITEMS){
                _tprintf(_T("%d\n"),retVal);
            }
            break;
        }
        stopBits = STOP_BIT_1;
        parity = NO_PARITY;
        baudRate = DEFAULT_BAUD_RATE;
        wordLen = SERIAL_DATABITS_8;
        _stprintf(device, "\\??\\%s",name);
        retVal = (ULONG) (setparams)(name,
                                     device,
                                     &stopBits,
                                     &parity,
                                     &baudRate,
                                     &wordLen
                                     );
        if(retVal != ERROR_SUCCESS){
            temp = RetreiveMessageText(MSG_ERROR_SET);
            temp[_tcslen(temp) - 2 ] = _T('\0');
            if(temp){
                _tprintf(_T("%s %d"),temp,retVal);
            }
            TCFree(temp);
            break;
        }
        index ++;

    }
    retVal = RegCloseKey(m_hkey);




}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\headless\tcsrv\admin\console\main.c ===
/*
 * Module - main.c
 * 
 * Presents the tcservice data in a simple console mode 
 * application.
 * 
 * 
 * Sadagopan Rajaram - Dec 20 1999.
 * 
 */
 
#include "tcadmin.h"

FARPROC getparams=NULL;
FARPROC setparams=NULL;
FARPROC deletekey = NULL;
PVOID ResourceImageBase=NULL;
HANDLE hConsoleInput=NULL;
HANDLE hConsoleOutput = NULL;
TCHAR lastChar = (TCHAR) 0;

int __cdecl
main(
    IN int argc,
    char *argv[]
    )
{
    // Just load the library.
    HINSTANCE hinstLib;
    TCHAR key;
    LPTSTR buff;
    int result;
    int nameLen,deviceLen;
    UINT BaudRate;
    DWORD len;
    UCHAR WordLen,StopBits,Parity;
    BOOL fFreeResult;
    LONG retVal;
    TCHAR name[MAX_BUFFER_SIZE];
    TCHAR device[MAX_BUFFER_SIZE];
    BOOL cont=TRUE;
    LPTSTR temp;
    BOOL readRet;



    hConsoleInput = GetStdHandle(STD_INPUT_HANDLE);
                         
    if(hConsoleInput != INVALID_HANDLE_VALUE){
        SetConsoleMode(hConsoleInput,
                       ENABLE_PROCESSED_OUTPUT
                       );
    }
    else {
        return 1;
    }
    hConsoleOutput = GetStdHandle(STD_OUTPUT_HANDLE);
    if(hConsoleOutput != INVALID_HANDLE_VALUE){
        SetConsoleMode(hConsoleOutput,
                       ENABLE_PROCESSED_OUTPUT|
                       ENABLE_WRAP_AT_EOL_OUTPUT
                       );
    }
    else {
        return 1;
    }
    hinstLib = LoadLibrary(_T("tcdata")); 
    RtlPcToFileHeader(main,&ResourceImageBase);
    if(!ResourceImageBase){
        _tprintf(_T("Cannot find image base\n"));
        return 1;
    }
    // If the handle is valid, try to get the function address.
 
    if(!hinstLib){    
        buff=RetreiveMessageText(MSG_CANNOT_LOAD);
        if(buff){
            _tprintf(_T("%s"),buff);
        }
        return 1;
    }
    buff = RetreiveMessageText(MSG_PROCEDURE_NOT_FOUND);
    getparams = GetProcAddress(hinstLib, "GetParametersAtIndex");
    if(!getparams){
        if(buff){
            _tprintf(_T("%s"),buff);
        }
        return 1;
    }
    setparams = GetProcAddress(hinstLib, "SetParameters");
    if(!setparams){
        if(buff){
            _tprintf(_T("%s"),buff);
        }
        return 1;
    }
    deletekey = GetProcAddress(hinstLib, "DeleteKey");
    if(!deletekey){
        if(buff){
            _tprintf(_T("%s"),buff);
        }
        return 1;
    }
    TCFree(buff);
    buff = RetreiveMessageText(MSG_MAIN_SCREEN);
    if(!buff){
        return 1;
    }
    while(cont){
        _tprintf(_T("%s"),buff);
        do{
            readRet = ReadFile(hConsoleInput,
                               &key,
                               sizeof(TCHAR),
                               &len,
                               NULL
                               );
            if(!readRet || !len){
                exit(1);
            }
            if(lastChar != _T('\r') || key != _T('\n')){
                lastChar = key;
                break;
            }
            lastChar = key;
        }while(1);

        switch(key){
        case _T('0'):
            cont=FALSE;
            break;
        case _T('1'):
            // Browse through the registry
            Browse();
            break;
        case _T('2'): 
            // Add a key to the registry 
            // send an add message to the 
            // service if it exists.
            BaudRate = DEFAULT_BAUD_RATE;
            StopBits = STOP_BIT_1;
            Parity = NO_PARITY;
            WordLen = SERIAL_DATABITS_8;

            retVal  = DisplayEditMenu(name,
                                   0,
                                   device,
                                   0,
                                   &BaudRate,
                                   &WordLen,
                                   &Parity,
                                   &StopBits
                                   );
            temp = RetreiveMessageText(MSG_CONFIRM_PROMPT);
            if(!temp){
               return 1;
            }
            temp[_tcslen(temp) -2] = '\0';
            _tprintf(_T("%s"),temp);
            TCFree(temp);
            do{
                readRet = ReadFile(hConsoleInput,
                                   &key,
                                   sizeof(TCHAR),
                                   &len,
                                   NULL
                                   );
                if(!readRet || !len){
                    exit(1);
                }
                if(lastChar != _T('\r') || key != _T('\n')){
                    lastChar = key;
                    break;
                }
                lastChar = key;
            }while(1);

            if((key == _T('y')) 
               || (key == _T('Y'))){
                retVal = (LONG) (setparams)(name,
                                            device,
                                            &StopBits,
                                            &Parity,
                                            &BaudRate,
                                            &WordLen
                                            );
                if(retVal != ERROR_SUCCESS){
                    temp = RetreiveMessageText(MSG_ERROR_SET);
                    if(temp){
                        temp[_tcslen(temp) - 2 ] = _T('\0');
                        _tprintf(_T("%s %d"),temp,retVal);
                        TCFree(temp);
                    }
                }
            }
            break;
        case _T('3'):
            SendParameterChange();
            break;
        case _T('4'):
            GetStatus();
            break;
        case _T('5'):
            StartTCService();
            break;
        case _T('6'):
            StopTCService();
            break;
        case _T('7'):
            AddAllComPorts();
            break;
        default:
            DisplayScreen(MSG_HELP_SCREEN);
            do{
                readRet = ReadFile(hConsoleInput,
                                   &key,
                                   sizeof(TCHAR),
                                   &len,
                                   NULL
                                   );
                if(!readRet || !len){
                    exit(1);
                }
                if(lastChar != _T('\r') || key != _T('\n')){
                    lastChar = key;
                    break;
                }
                lastChar = key;
            }while(1);

            break;
            
        }

    }
    fFreeResult = FreeLibrary(hinstLib);
    return 0;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\headless\tcsrv\client\keymap.h ===
/*
 *
 *
 * Keycode definitions for special keys
 *
 * On systems that have any of these keys, the routine 'inchar' in the
 * machine-dependent code should return one of the codes here.
 */

#define ZERO            ((TCHAR) 0x00)
#define ESCP            ((TCHAR) 0x1B)
#define K_HOME          ((TCHAR) 0x80)
#define K_END           ((TCHAR) 0x81)
#define K_INSERT        ((TCHAR) 0x82)
#define K_DELETE        ((TCHAR) 0x83)
#define K_UARROW        ((TCHAR) 0x84)
#define K_DARROW        ((TCHAR) 0x85)
#define K_LARROW        ((TCHAR) 0x86)
#define K_RARROW        ((TCHAR) 0x87)
#define K_CGRAVE        ((TCHAR) 0x88)    /* control grave accent */
#define K_PAGEUP        ((TCHAR) 0x89)
#define K_PAGEDOWN      ((TCHAR) 0x8A)

#define K_F1            ((TCHAR) 0x8B)    /* function keys */
#define K_F2            ((TCHAR) 0x8C)
#define K_F3            ((TCHAR) 0x8D)
#define K_F4            ((TCHAR) 0x8E)
#define K_F5            ((TCHAR) 0x8F)
#define K_F6            ((TCHAR) 0x90)
#define K_F7            ((TCHAR) 0x91)
#define K_F8            ((TCHAR) 0x92)
#define K_F9            ((TCHAR) 0x93)
#define K_F10           ((TCHAR) 0x94)
#define K_F11           ((TCHAR) 0x95)
#define K_F12           ((TCHAR) 0x96)

#define K_SF1           ((TCHAR) 0x97)    /* shifted function keys */
#define K_SF2           ((TCHAR) 0x98)
#define K_SF3           ((TCHAR) 0x99)
#define K_SF4           ((TCHAR) 0x9A)
#define K_SF5           ((TCHAR) 0x9B)
#define K_SF6           ((TCHAR) 0x9C)
#define K_SF7           ((TCHAR) 0x9D)
#define K_SF8           ((TCHAR) 0x9E)
#define K_SF9           ((TCHAR) 0x9F)
#define K_SF10          ((TCHAR) 0xA0)
#define K_SF11          ((TCHAR) 0xA1)
#define K_SF12          ((TCHAR) 0xA2)

#define CTLA            ((TCHAR) 0x01)
#define CTLB            ((TCHAR) 0x02)
#define CTLC            ((TCHAR) 0x03)
#define CTLD            ((TCHAR) 0x04)
#define CTLE            ((TCHAR) 0x05)
#define CTLF            ((TCHAR) 0x06)
#define CTLG            ((TCHAR) 0x07)
#define CTLH            ((TCHAR) 0x08)
#define CTLI            ((TCHAR) 0x09)
#define CTLJ            ((TCHAR) 0x0A)
#define CTLK            ((TCHAR) 0x0B)
#define CTLL            ((TCHAR) 0x0C)
#define CTLM            ((TCHAR) 0x0D)
#define CTLN            ((TCHAR) 0x0E)
#define CTLO            ((TCHAR) 0x0F)
#define CTLP            ((TCHAR) 0x10)
#define CTLQ            ((TCHAR) 0x11)
#define CTLR            ((TCHAR) 0x12)
#define CTLS            ((TCHAR) 0x13)
#define CTLT            ((TCHAR) 0x14)
#define CTLU            ((TCHAR) 0x15)
#define CTLV            ((TCHAR) 0x16)
#define CTLW            ((TCHAR) 0x17)
#define CTLX            ((TCHAR) 0x18)
#define CTLY            ((TCHAR) 0x19)
#define CTLZ            ((TCHAR) 0x1A)
#define CTL1            ((TCHAR) 0x1B)
#define CTL2            ((TCHAR) 0x1C)
#define CTL3            ((TCHAR) 0x1D)
#define CTL4            ((TCHAR) 0x1E)
#define CTL5            ((TCHAR) 0x1F)

/*
    for keyboard translation tables
*/

#define K_EN            K_END
#define K_HO            K_HOME
#define K_LE            K_LARROW
#define K_RI            K_RARROW
#define K_UP            K_UARROW
#define K_DO            K_DARROW
#define K_IN            K_INSERT
#define K_DE            K_DELETE
#define K_CG            K_CGRAVE
#define K_PU            K_PAGEUP
#define K_PD            K_PAGEDOWN

#define K_FA            K_F10
#define K_FB            K_F11
#define K_FC            K_F12

#define K_S1            K_SF1
#define K_S2            K_SF2
#define K_S3            K_SF3
#define K_S4            K_SF4
#define K_S5            K_SF5
#define K_S6            K_SF6
#define K_S7            K_SF7
#define K_S8            K_SF8
#define K_S9            K_SF9
#define K_SA            K_SF10
#define K_SB            K_SF11
#define K_SC            K_SF12
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\headless\tcsrv\client\console.c ===
/* 
 * Copyright (c) Microsoft Corporation
 * 
 * Module Name : 
 *        console.c
 *
 * Hacks to read characters from the NT console 
 * Taken from nt\sdktools\vi\nt.c 
 * 
 * 
 * Sadagopan Rajaram -- Nov 5, 1999
 *
 */

#include "tcclnt.h"
#include "keymap.h"

#define     MAX_VK   0x7f

TCHAR RegularTable[] =  {ZERO, ZERO, ZERO, ZERO, ZERO, ZERO, ZERO, ZERO,
              /* 08 */  ZERO, ZERO, ZERO, ZERO, ZERO, ZERO, ZERO, ZERO,
              /* 10 */  ZERO, ZERO, ZERO, ZERO, ZERO, ZERO, ZERO, ZERO,
              /* 18 */  ZERO, ZERO, ZERO, ESCP, ZERO, ZERO, ZERO, ZERO,
              /* 20 */  ZERO, K_PU, K_PD, K_EN, K_HO, K_LE, K_UP, K_RI,
              /* 28 */  K_DO, ZERO, ZERO, ZERO, ZERO, K_IN, K_DE, ZERO,
              /* 30 */  ZERO, ZERO, ZERO, ZERO, ZERO, ZERO, ZERO, ZERO,
              /* 38 */  ZERO, ZERO, ZERO, ZERO, ZERO, ZERO, ZERO, ZERO,
              /* 40 */  ZERO, ZERO, ZERO, ZERO, ZERO, ZERO, ZERO, ZERO,
              /* 48 */  ZERO, ZERO, ZERO, ZERO, ZERO, ZERO, ZERO, ZERO,
              /* 50 */  ZERO, ZERO, ZERO, ZERO, ZERO, ZERO, ZERO, ZERO,
              /* 58 */  ZERO, ZERO, ZERO, ZERO, ZERO, ZERO, ZERO, ZERO,
              /* 60 */  ZERO, ZERO, ZERO, ZERO, ZERO, ZERO, ZERO, ZERO,
              /* 68 */  ZERO, ZERO, ZERO, ZERO, ZERO, ZERO, ZERO, ZERO,
              /* 70 */  K_F1, K_F2, K_F3, K_F4, K_F5, K_F6, K_F7, K_F8,
              /* 78 */  K_F9, K_FA, K_FB, K_FC, ZERO, ZERO, ZERO, ZERO};

TCHAR ShiftedTable[] = { ZERO, ZERO, ZERO, ZERO, ZERO, ZERO, ZERO, ZERO,
              /* 08 */  ZERO, ZERO, ZERO, ZERO, ZERO, ZERO, ZERO, ZERO,
              /* 10 */  ZERO, ZERO, ZERO, ZERO, ZERO, ZERO, ZERO, ZERO,
              /* 18 */  ZERO, ZERO, ZERO, ESCP, ZERO, ZERO, ZERO, ZERO,
              /* 20 */  ZERO, K_PU, K_PD, K_EN, K_HO, K_LE, K_UP, K_RI,
              /* 28 */  K_DO, ZERO, ZERO, ZERO, ZERO, K_IN, K_DE, ZERO,
              /* 30 */  ZERO, ZERO, ZERO, ZERO, ZERO, ZERO, ZERO, ZERO,
              /* 38 */  ZERO, ZERO, ZERO, ZERO, ZERO, ZERO, ZERO, ZERO,
              /* 40 */  ZERO, ZERO, ZERO, ZERO, ZERO, ZERO, ZERO, ZERO,
              /* 48 */  ZERO, ZERO, ZERO, ZERO, ZERO, ZERO, ZERO, ZERO,
              /* 50 */  ZERO, ZERO, ZERO, ZERO, ZERO, ZERO, ZERO, ZERO,
              /* 58 */  ZERO, ZERO, ZERO, ZERO, ZERO, ZERO, ZERO, ZERO,
              /* 60 */  ZERO, ZERO, ZERO, ZERO, ZERO, ZERO, ZERO, ZERO,
              /* 68 */  ZERO, ZERO, ZERO, ZERO, ZERO, ZERO, ZERO, ZERO,
              /* 70 */  K_S1, K_S2, K_S3, K_S4, K_S5, K_S6, K_S7, K_S8,
              /* 78 */  K_S9, K_SA, K_SB, K_SC, ZERO, ZERO, ZERO, ZERO};

TCHAR ControlTable[] = { ZERO, ZERO, ZERO, ZERO, ZERO, ZERO, ZERO, ZERO,
              /* 08 */  ZERO, ZERO, ZERO, ZERO, ZERO, ZERO, ZERO, ZERO,
              /* 10 */  ZERO, ZERO, ZERO, ZERO, ZERO, ZERO, ZERO, ZERO,
              /* 18 */  ZERO, ZERO, ZERO, ESCP, ZERO, ZERO, K_CG, ZERO,
              /* 20 */  ZERO, K_PU, K_PD, K_EN, K_HO, K_LE, K_UP, K_RI,
              /* 28 */  K_DO, ZERO, ZERO, ZERO, ZERO, K_IN, K_DE, ZERO,
              /* 30 */  ZERO, ZERO, ZERO, ZERO, ZERO, ZERO, ZERO, ZERO,
              /* 38 */  ZERO, ZERO, ZERO, ZERO, ZERO, ZERO, ZERO, ZERO,
              /* 40 */  ZERO, CTLA, CTLB, CTLC, CTLD, CTLE, CTLF, CTLG,
              /* 48 */  CTLH, CTLI, CTLJ, CTLK, CTLL, CTLM, CTLN, CTLO,
              /* 50 */  CTLP, CTLQ, CTLR, CTLS, CTLT, CTLU, CTLV, CTLW,
              /* 58 */  CTLX, CTLY, CTLZ, CTL1, CTL2, CTL3, CTL4, CTL5,
              /* 60 */  ZERO, ZERO, ZERO, ZERO, ZERO, ZERO, ZERO, ZERO,
              /* 68 */  ZERO, ZERO, ZERO, ZERO, ZERO, ZERO, ZERO, ZERO,
              /* 70 */  ZERO, ZERO, ZERO, ZERO, ZERO, ZERO, ZERO, ZERO,
              /* 78 */  ZERO, ZERO, ZERO, ZERO, ZERO, ZERO, ZERO, ZERO};

#define ALT_PRESSED (RIGHT_ALT_PRESSED | LEFT_ALT_PRESSED)
#define CTL_PRESSED (RIGHT_CTRL_PRESSED | LEFT_CTRL_PRESSED)
#define CONTROL_ALT (ALT_PRESSED | CTL_PRESSED)

/*
 * inTCHAR() - get a TCHARacter from the keyboard
 * Reads only ascii TCHARacters from the keyboard.
 */
void
inchar(CHAR *buff)
{
    INPUT_RECORD    InputRec;
    DWORD           NumRead;
    int len;

    while(1) {    /* loop until we get a valid console event */
        ReadConsoleInput(InputHandle,&InputRec,1,&NumRead);
        if((InputRec.EventType == KEY_EVENT)
           && (InputRec.Event.KeyEvent.bKeyDown)){
            KEY_EVENT_RECORD *KE = &InputRec.Event.KeyEvent;
            TCHAR *Table;


            if(KE->dwControlKeyState & ALT_PRESSED) {
                if ((KE->uChar.AsciiChar == 'x')||(KE->uChar.AsciiChar == 'X')) {
                    exit(0);
                }
                continue;       // no ALT keys allowed.
            } else{
                if(KE->dwControlKeyState & CTL_PRESSED) {
                    Table = ControlTable;
                } else {
                   // We might have a character in Unicode
                    #ifdef UNICODE
                    if(KE->uChar.UnicodeChar) {    // no control, no alt
                        // convert to dbcs character and return
                        len= wctomb(buff,KE->uChar.UnicodeChar);
                        if(len == -1){
                            continue;
                        }
                        buff[len] = (CHAR) 0;
                        return;
                    #else
                    if(KE->uChar.AsciiChar){
                        buff[0] = KE->uChar.AsciiChar;
                        buff[1] = (CHAR) 0;
                        return;
                    #endif

                    } else {
                        if(KE->dwControlKeyState & SHIFT_PRESSED) {
                            Table = ShiftedTable;
                        } else {
                            Table = RegularTable;
                        }
                    }
                }
            }

            if((KE->wVirtualKeyCode > MAX_VK) || !Table[KE->wVirtualKeyCode]) {
                continue;
            }
            #ifdef UNICODE
            // convert to dbcs character and return
            len= wctomb(buff,Table[KE->wVirtualKeyCode]);
            if(len == -1){
                continue;
            }
            buff[len] = (CHAR) 0;
            #else 
            buff[0] = Table[KE->wVirtualKeyCode];
            buff[1] = (CHAR) 0;
            #endif
            return;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\headless\tcsrv\client\main.c ===
/*
 * Copyright (c) Microsoft Corporation
 *
 * Module Name :
 *        main.c
 *
 * This is the main file containing the client code.
 *
 *
 * Sadagopan Rajaram -- Oct 14, 1999
 *
 */

// Can kill this program on a normal NT console using the
// Alt - X Key combination. Just a shortcut, that is all.
// Serves no useful purpose.

#include "tcclnt.h"
#include "tcsrvc.h"

WSABUF ReceiveBuffer;
CHAR RecvBuf[MAX_BUFFER_SIZE];
IO_STATUS_BLOCK IoStatus;
HANDLE InputHandle;
DWORD bytesRecvd;
WSAOVERLAPPED junk;
SOCKET cli_sock;
DWORD flags;

#if _MSC_FULL_VER >= 13008827
#pragma warning(push)
#pragma warning(disable:4715)			// Not all control paths return (due to infinite loop)
#endif

DWORD
inputUpdate(
    PVOID dummy
    )
{
    // Runs in a single thread getting all the inputs
    // from the keyboard.

    ULONG result;
    // gets a multibyte string for every character
    // pressed on the keyboard.
    CHAR r[MB_CUR_MAX + 1];

    while(1){
         r[0] = _T('\0');
         inchar(r);
         // BUGBUG - Performance issues in sending a single character
         // at a time across the n/w
        if(strlen(r)){
            // may send a single byte or two bytes.
            send(cli_sock,r,strlen(r),0);
        }
    }
    return 1;

}

#if _MSC_FULL_VER >= 13008827
#pragma warning(pop)
#endif

VOID sendUpdate(
    IN DWORD dwError,
    IN DWORD cbTransferred,
    IN LPWSAOVERLAPPED lpOverLapped,
    IN DWORD dwFlags
    )
{
    int error,i;
    // Receives a packet and sends it through the stream parser
    // BUGBUG - For effeciency it can be made inline.
    // I am not sure of the performance increase, but it should
    // be substantial as we will be sending a lot of data.

    if(dwError != 0){
        exit(1);
    }
    for(i=0;i < (int)cbTransferred;i++){
        PrintChar(ReceiveBuffer.buf[i]);
    }
    // Repost the receive on the socket.

    error = WSARecv(cli_sock,
                    &ReceiveBuffer,
                    1,
                    &bytesRecvd,
                    &flags,
                    &junk,
                    sendUpdate
                    );
    if((error == SOCKET_ERROR)
       &&(WSAGetLastError()!=WSA_IO_PENDING)){
        // Implies something wrong with the socket.
        exit(1);
    }
    return;

}

int __cdecl
main(
    IN int argc,
    char *argv[]
    )
/*++
   Opens a single port, binds to the tcserver and passes information back and forth.
--*/
{
    struct sockaddr_in srv_addr,cli_addr;
    LPHOSTENT host_info;
    CLIENT_INFO SendInfo;
    int status;
    WSADATA data;
    #ifdef UNICODE
    // BUGBUG - Trying to write a code that works for
    // both Unicode and ASCII. Gets multi byte sequences
    // Confusion when the tcclnt and tcclnt are in different
    // modes.
    ANSI_STRING Src;
    UNICODE_STRING Dest;
    #endif
    NTSTATUS Status;
    HANDLE Thread;
    DWORD ThreadId;
    COORD coord;
    SMALL_RECT rect;
    int RetVal;
    struct hostent *ht;
    ULONG r;
    TCHAR Buffer[80];



    if((argc<2) || (argc >4)){
        // Error in running the program
        printf("Usage - tcclnt COMPORTNAME [ipaddress]\n");
        exit(0);
    }

    ThreadId = GetEnvironmentVariable(_T("TERM"),Buffer , 80);
    // We need to know if we have a vt100 screen or an ANSI screen.
    AttributeFunction = ProcessTextAttributes;
    if(ThreadId >0){
        // Terminal type exists in the environment.
        // Use it
        if((_tcsncmp(Buffer, _T("VT100"), 5) == 0)||
            _tcsncmp(Buffer, _T("vt100"),5) ==0 )
            AttributeFunction = vt100Attributes;
    }

    hConsoleOutput = GetStdHandle(STD_OUTPUT_HANDLE);
    coord.X = MAX_TERMINAL_WIDTH;
    coord.Y = MAX_TERMINAL_HEIGHT;
    rect.Left = rect.Top = 0;
    rect.Right = MAX_TERMINAL_WIDTH -1;
    rect.Bottom = MAX_TERMINAL_HEIGHT -1;

    if(hConsoleOutput == NULL){
        printf("Could not get current console handle %d\n", GetLastError());
        return 1;
    }

    RetVal = SetConsoleScreenBufferSize(hConsoleOutput,
                                        coord
                                        );

    RetVal = SetConsoleWindowInfo(hConsoleOutput,
                                  TRUE,
                                  &rect
                                  );
    if (RetVal == FALSE) {
        printf("Could not set window size %d\n", GetLastError());
        return 1;
    }
    RetVal = SetConsoleMode(hConsoleOutput,ENABLE_PROCESSED_OUTPUT);
    if(RetVal == FALSE){
        printf("Could not console mode %d\n", GetLastError());
        return 1;
    }

    /* Set up client socket */
    InputHandle = GetStdHandle(STD_INPUT_HANDLE);
    if(InputHandle == NULL) return 1;
    SetConsoleMode(InputHandle, 0);
    status=WSAStartup(514,&data);

    if(status){
        printf("Cannot start up %d\n",status);
        return(1);
    }

    cli_sock=WSASocket(PF_INET,SOCK_STREAM,0,NULL,0,WSA_FLAG_OVERLAPPED);

    if (cli_sock==INVALID_SOCKET){
        printf("Windows Sockets error %d: Couldn't create socket.",
                WSAGetLastError());
        return(1);
    }

    cli_addr.sin_family=AF_INET;
    cli_addr.sin_addr.s_addr=INADDR_ANY;
    cli_addr.sin_port=0;                /* no specific port req'd */

    /* Bind client socket to any local interface and port */

    if (bind(cli_sock,(LPSOCKADDR)&cli_addr,sizeof(cli_addr))==SOCKET_ERROR){
        printf("Windows Sockets error %d: Couldn't bind socket.",
                WSAGetLastError());
        return(1);
    }

    srv_addr.sin_family = AF_INET;
    if(argc == 3){
        srv_addr.sin_addr.s_addr = inet_addr(argv[2]);
        if (srv_addr.sin_addr.s_addr == INADDR_NONE) {
            ht = gethostbyname(argv[2]);
            if(!ht || !ht->h_addr){ // cannot resolve the name
                printf("Cannot resolve %s", argv[2]);
                exit(1);
            }
            memcpy((&(srv_addr.sin_addr.s_addr)),ht->h_addr, ht->h_length);
        }
    }
    else{
        srv_addr.sin_addr.s_addr = inet_addr("127.0.0.1");
    }
    srv_addr.sin_port=htons(SERVICE_PORT);

    /* Connect to FTP server at address SERVER */

    if (connect(cli_sock,(LPSOCKADDR)&srv_addr,sizeof(srv_addr))==SOCKET_ERROR){
        printf("Windows Sockets error %d: Couldn't connect socket.\n",
               WSAGetLastError());
        return(1);
    }

    SendInfo.len = sizeof(CLIENT_INFO);

    #ifdef UNICODE
    Src.Buffer = argv[1];
    Src.Length = (USHORT)strlen(argv[1]);
    Dest.Buffer = SendInfo.device;
    Dest.MaximumLength = MAX_BUFFER_SIZE;
    Status = RtlAnsiStringToUnicodeString(&Dest, &Src, FALSE);
    if (!NT_SUCCESS(Status)) {
        printf("RtlAnsiStringToUnicodeString failed, ec = 0x%08x\n",Status);
        exit(1);
    }
    send(cli_sock, (PCHAR) &SendInfo, sizeof(CLIENT_INFO), 0);
    #else
    // We are sending to an ANSI String
    strcpy(SendInfo.device, argv[1]);
    send(cli_sock, (PCHAR) &SendInfo, sizeof(CLIENT_INFO), 0);
    #endif
    ReceiveBuffer.len = MAX_BUFFER_SIZE;
    ReceiveBuffer.buf = RecvBuf;
    status=WSARecv(cli_sock,
            &ReceiveBuffer,
            1,
            &bytesRecvd,
            &flags,
            &junk,
            sendUpdate
            );
    if((status == SOCKET_ERROR)
       &&(WSAGetLastError() != WSA_IO_PENDING)){
        printf("Error in recv %d\n",WSAGetLastError());
        exit(1);
    }
    // Create a thread that gets input from the console
    // to send to the bridge.
    Thread = CreateThread(NULL,
                          0,
                          inputUpdate,
                          NULL,
                          0,
                          &ThreadId
                          );
    if (Thread== NULL) {
        exit(1);
    }
    CloseHandle(Thread);

    while(1){
        // Put this thread in an alertable
        // state so that the receive calls can
        // asynchronously terminate within the
        // context of this thread.
        status=SleepEx(INFINITE,TRUE);
    }
    // We never return here.
    closesocket(cli_sock);
    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\headless\tcsrv\server\bridge.c ===
/* 
 * Copyright (c) Microsoft Corporation
 * 
 * Module Name : 
 *        bridge.c
 *
 * This contains the main worker thread that passes information between the clients 
 * the Com port.
 * 
 * Sadagopan Rajaram -- Oct 15, 1999
 *
 */

#include "tcsrv.h"
#include "tcsrvc.h"
#include "proto.h"

 
DWORD 
bridge(
    PCOM_PORT_INFO pComPortInfo
    )
{
    NTSTATUS Status;
    PCONNECTION_INFO pTemp;
    DWORD waitStatus; 
    int SocketStatus;


    Status = ReadFile(pComPortInfo->ComPortHandle, 
                      pComPortInfo->Buffer,
                      MAX_QUEUE_SIZE,
                      &(pComPortInfo->BytesRead),
                      &(pComPortInfo->Overlapped)
                      );
    if (!NT_SUCCESS(Status)) {
        TCDebugPrint(("Could not read from Com Port %x\n",GetLastError()));
        goto end;
    }

    while(1){
        MutexLock(pComPortInfo);
        // Get the new sockets that have been added to the port since
        // you were asleep. Send them the requested information and add 
        // them to the connections list so that they are primed to receive 
        // information.
        while(pComPortInfo->Sockets != NULL){
            pTemp = pComPortInfo->Sockets;
            SocketStatus = 1;
            if(pTemp->Flags){
                SocketStatus=GetBufferInfo(pTemp, pComPortInfo);
                pTemp->Flags = 0;
            }
            TCDebugPrint(("Got conn\n"));
            pComPortInfo->Sockets = pTemp->Next;
            pTemp->Next = pComPortInfo->Connections;
            pComPortInfo->Connections = pTemp;
            if (SocketStatus == SOCKET_ERROR) {
                TCDebugPrint(("something wrong with socket %d\n",
                              WSAGetLastError()));
                CleanupSocket(pTemp);
                continue;
            }
            SocketStatus = WSARecv(pTemp->Socket, 
                             &(pTemp->Buffer),
                             1 ,
                             &(pTemp->BytesRecvd),
                             &(pTemp->Flags),
                             &(pTemp->Overlapped),
                             updateComPort
                             );
            if (SocketStatus == SOCKET_ERROR ) {
                SocketStatus = WSAGetLastError();
                if (SocketStatus != WSA_IO_PENDING) {
                    TCDebugPrint(("something wrong with socket %d\n",
                              SocketStatus));
                    CleanupSocket(pTemp);
                }
            }
        }
        MutexRelease(pComPortInfo);
wait:
        waitStatus=NtWaitForMultipleObjects(4, 
                                            pComPortInfo->Events, 
                                            WaitAny, 
                                            TRUE,
                                            NULL
                                            );
        if(waitStatus == WAIT_FAILED){
            TCDebugPrint(("Fatal Error %x", waitStatus));
            closesocket(MainSocket);
            goto end;
        }
        else{
            if(waitStatus == WAIT_IO_COMPLETION){
                goto wait;
            }
            waitStatus = waitStatus - WAIT_OBJECT_0;
            switch(waitStatus){
            case 0:
                Status = STATUS_SUCCESS;
                goto end;
                break;
            case 1:
                ResetEvent(pComPortInfo->Events[1]);
                break;
            case 2:
                ResetEvent(pComPortInfo->Events[2]);
                updateClients(pComPortInfo);
                goto wait;
                break;
            case 3:
                Status = STATUS_SUCCESS;
                ResetEvent(pComPortInfo->Events[3]);
                goto end;
                break;
            default:
                goto wait;
                break;
            }

        }
    }
end:

    // Cancel the pending IRPs and close all the sockets.
    TCDebugPrint(("Cancelling all irps and shutting down the thread\n"));
    MutexLock(pComPortInfo);
    CancelIo(pComPortInfo->ComPortHandle);
    NtClose(pComPortInfo->ComPortHandle);
    while(pComPortInfo->Sockets != NULL){
        pTemp = pComPortInfo->Sockets;
        closesocket(pTemp->Socket);
        pComPortInfo->Sockets = pTemp->Next;
        pTemp->Next = NULL;
        TCFree(pTemp);
    }
    pTemp = pComPortInfo->Connections;
    while(pTemp != NULL){
        closesocket(pTemp->Socket);
        pTemp = pTemp->Next;
    }
    pComPortInfo->ShuttingDown = TRUE;
    if(pComPortInfo->Connections == NULL) SetEvent(pComPortInfo->TerminateEvent);
    MutexRelease(pComPortInfo);
wait2:
    waitStatus=NtWaitForSingleObject(pComPortInfo->TerminateEvent,TRUE,NULL);
    if(waitStatus == WAIT_IO_COMPLETION){
        goto wait2;
    }
    TCDebugPrint(("End of COM port\n"));
    return Status;
}

VOID 
CALLBACK
updateComPort(
    IN DWORD dwError, 
    IN DWORD cbTransferred, 
    IN LPWSAOVERLAPPED lpOverlapped, 
    IN DWORD dwFlags
    )

/*++ 
    Writes the data that it has gotten from the socket to all the connection
    that it currently has and to the com port.
--*/
{


    PCONNECTION_INFO pTemp = (PCONNECTION_INFO) lpOverlapped->hEvent;
    PCONNECTION_INFO pConn;
    PCOM_PORT_INFO pComPort;
    int Status;

    pComPort = pTemp->pComPortInfo;
    MutexLock(pComPort);
    if((cbTransferred == 0) && (dwError == 0)) {
        // For byte stream socket, this indicates graceful closure
        CleanupSocket(pTemp);
        MutexRelease(pComPort);
        return;
    }
    // If socket closed, remove it from the connection list. 
    if(pComPort->ShuttingDown){
        CleanupSocket(pTemp);
        if(pComPort->Connections == NULL){
            SetEvent(pComPort->TerminateEvent);
            MutexRelease(pComPort);
            return;
        }
        MutexRelease(pComPort);
        return;
    }
    if (dwError != 0) {
        // Something wrong with the connection. Close the socket and
        // delete it from the listeners list.
        CleanupSocket(pTemp);
        MutexRelease(pComPort);
        return;
    }

    Status =WriteFile(pComPort->ComPortHandle,
              (pTemp->Buffer).buf,
              cbTransferred,
              &(pTemp->BytesRecvd),
              &(pComPort->WriteOverlapped)
              );
    if(!Status){
        if(GetLastError() != ERROR_IO_PENDING)
            TCDebugPrint(("Error writing to comport %d",GetLastError()));
    }
    Status = WSARecv(pTemp->Socket, 
                     &(pTemp->Buffer),
                     1 ,
                     &(pTemp->BytesRecvd),
                     &(pTemp->Flags),
                     &(pTemp->Overlapped),
                     updateComPort
                     );
    if (Status == SOCKET_ERROR ) {
        Status = WSAGetLastError();
        if (Status != WSA_IO_PENDING) {
            TCDebugPrint(("something wrong with socket %d\n",
                          Status));
            CleanupSocket(pTemp);
        }
    }
    MutexRelease(pComPort);
    return;
}

VOID
updateClients(
    PCOM_PORT_INFO pComPortInfo

    )
/*++
    Writes the data that it has gotten from the com port to all the connection
    that it currently has
--*/
{
    PCONNECTION_INFO pConn;
    BOOL Status;
    DWORD Error;
    NTSTATUS stat;


  
    if((pComPortInfo->Overlapped.InternalHigh == 0)||
        (!NT_SUCCESS(pComPortInfo->Overlapped.Internal))){
        TCDebugPrint(("Problem with Com Port %x\n", pComPortInfo->Overlapped.Internal));
        MutexLock(pComPortInfo);
        if(pComPortInfo->ShuttingDown){
            // will never occur because this is a procedure called from
            // the thread
            MutexRelease(pComPortInfo);
            return;
        }
        if (pComPortInfo->Overlapped.Internal == STATUS_CANCELLED){
            // something wrong, try reinitializing the com port
            // this thing happens every time the m/c on the other end 
            // reboots. Pretty painful.Probably can improve this later.
            // Why should the reboot cause this com port 
            // to go awry ?? 
            stat = NtClose(pComPortInfo->ComPortHandle);
            if(!NT_SUCCESS(stat)){
                TCDebugPrint(("Cannot close handle\n"));
            }
            stat = InitializeComPort(pComPortInfo);
            if(!NT_SUCCESS(stat)){
                TCDebugPrint(("Cannot reinitialize com port\n"));
                MutexRelease(pComPortInfo);
                return;
            }
        }
        Status = ReadFile(pComPortInfo->ComPortHandle, 
                          pComPortInfo->Buffer,
                          MAX_QUEUE_SIZE,
                          &(pComPortInfo->BytesRead),
                          &(pComPortInfo->Overlapped)
                          );
        if(Status == 0){
            if ((Error = GetLastError()) != ERROR_IO_PENDING) {
                TCDebugPrint(("Error = %d\n", Error));
            }
        }
        MutexRelease(pComPortInfo);

        return;
    }
    MutexLock(pComPortInfo);
    Enqueue(pComPortInfo);
    pConn = pComPortInfo->Connections;
    while(pConn!=NULL){
        send(pConn->Socket, 
             pComPortInfo->Buffer, 
             (int)pComPortInfo->Overlapped.InternalHigh,
             0
             );
        pConn = pConn->Next;
    } 
    Status = ReadFile(pComPortInfo->ComPortHandle, 
                      pComPortInfo->Buffer,
                      MAX_QUEUE_SIZE,
                      &(pComPortInfo->BytesRead),
                      &(pComPortInfo->Overlapped)
                      );
    if (Status == 0) {
        if((Error=GetLastError())!= ERROR_IO_PENDING){
            TCDebugPrint(("Problem with Com Port %x\n", Error));
        }
    }
    MutexRelease(pComPortInfo);
    return;
}

VOID CleanupSocket(
    PCONNECTION_INFO pConn
    )
{
    PCOM_PORT_INFO pTemp;
    PCONNECTION_INFO pPrevConn;

    // Assume that the structure is locked earlier. 
    // the socket connection is closed when this occurs.
    // We free the socket either if the TCP port on the 
    // client end has died or we are deleting this com port.
    pTemp = pConn->pComPortInfo;
    if(pConn == pTemp->Connections) {
        pTemp->Connections = pConn->Next;
    }
    else{
        pPrevConn = pTemp->Connections;
        while((pPrevConn !=NULL) &&(pPrevConn->Next != pConn)){
            pPrevConn=pPrevConn->Next;
        }
        if(pPrevConn == NULL) return;
        pPrevConn->Next = pConn->Next;
     }
    pConn->Next = NULL;
    TCFree(pConn); 

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\headless\tcsrv\server\debug.c ===
/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    debug.c

Abstract:

    This file contains debugging macros for the Terminal Concentrator server.

Author:

    Madan Appiah  (madana)  10-Sep-1993
    Modifications - Sadagopan Rajaram 11th Nov 99

Environment:

    User Mode - Win32

Revision History:


--*/


//
// Adds a MEMORYBLOCK to the memory tracking list.
//

#include <tcsrv.h>

#if DBG==1

LPMEMORYBLOCK g_TraceMemoryTable;
CRITICAL_SECTION g_TraceMemoryCS;

HGLOBAL
TCReAlloc(
    HGLOBAL mem,
    DWORD size,
    LPCSTR comment
    )
{
    HGLOBAL temp;
    LPMEMORYBLOCK pmbHead;
    DWORD nBytes=0;


    temp = DebugAlloc(GMEM_ZEROINIT, size, comment);
    if(temp != NULL){
        EnterCriticalSection( &g_TraceMemoryCS );
        pmbHead = g_TraceMemoryTable;

        while ( pmbHead && pmbHead->hglobal != mem )
        {
            pmbHead = pmbHead->pNext;
        }
        if(pmbHead){   
            nBytes = pmbHead->dwBytes;
        }
        LeaveCriticalSection(&g_TraceMemoryCS);
        if(nBytes){
            memcpy(temp, mem, nBytes);
            DebugFree(mem);
        }
    }
    return temp;
}

HGLOBAL
DebugMemoryAdd(
    HGLOBAL hglobal,
    DWORD   dwBytes,
    LPCSTR pszComment 
    )
{
    if ( hglobal )
    {
        LPMEMORYBLOCK pmb     = (LPMEMORYBLOCK) GlobalAlloc(
                                                    GMEM_FIXED,
                                                    sizeof(MEMORYBLOCK) );

        if ( !pmb )
        {
            GlobalFree( hglobal );
            return NULL;
        }

        pmb->hglobal    = hglobal;
        pmb->dwBytes    = dwBytes;
        pmb->pszComment = pszComment;

        EnterCriticalSection( &g_TraceMemoryCS );

        pmb->pNext         = g_TraceMemoryTable;
        g_TraceMemoryTable = pmb;

        TCDebugPrint(("DebugAlloc: 0x%08x alloced %d (%s) with 0x%08x\n", hglobal, dwBytes, 
                      pmb->pszComment, pmb ));

        LeaveCriticalSection( &g_TraceMemoryCS );
    }

    return hglobal;
}

//
// Removes a MEMORYBLOCK to the memory tracking list.
//
void
DebugMemoryDelete(
    HGLOBAL hglobal )
{
    if ( hglobal )
    {
        LPMEMORYBLOCK pmbHead;
        LPMEMORYBLOCK pmbLast = NULL;

        EnterCriticalSection( &g_TraceMemoryCS );
        pmbHead = g_TraceMemoryTable;

        while ( (pmbHead) && (pmbHead->hglobal != hglobal ))
        {
            pmbLast = pmbHead;
            pmbHead = pmbLast->pNext;
        }
        if ( pmbHead )
        {
            HGLOBAL *p;
            if ( pmbLast )
            {
                pmbLast->pNext = pmbHead->pNext;
            }
            else
            {
                g_TraceMemoryTable = pmbHead->pNext;
            }

            TCDebugPrint(("DebugFree: 0x%08x freed %d (%s)\n",pmbHead->hglobal,pmbHead->dwBytes,
                pmbHead->pszComment ));

            p = (HGLOBAL)((LPBYTE)hglobal + pmbHead->dwBytes);
            if ( *p != hglobal )
            {
                TCDebugPrint(("DebugFree: Heap check FAILED for 0x%08x %u bytes (%s).\n",
                    hglobal, pmbHead->dwBytes, pmbHead->pszComment));
            }

            memset( hglobal, 0xFE, pmbHead->dwBytes + sizeof(HGLOBAL));
            memset( pmbHead, 0xFD, sizeof(MEMORYBLOCK) );
            pmbHead->pNext = NULL;
            GlobalFree( pmbHead );

        }
        else
        {
            HGLOBAL *p;

            TCDebugPrint(("DebugFree: 0x%08x not found in memory table\n", hglobal ));
            memset( hglobal, 0xFE, (int)GlobalSize( hglobal ));
        }

        LeaveCriticalSection( &g_TraceMemoryCS );

    }
}

//
// Allocates memory and adds the MEMORYBLOCK to the memory tracking list.
//
HGLOBAL
DebugAlloc(
    UINT uFlags,
    DWORD   dwBytes,
    LPCSTR pszComment )
{
    HGLOBAL hglobal;

    HGLOBAL *p;
    hglobal = GlobalAlloc( uFlags, dwBytes + sizeof(HGLOBAL));
    if (hglobal == NULL) {
        TCDebugPrint(("No memory %s %d\n", pszComment, GetLastError()));
        return NULL;
    }
    p = (HGLOBAL)((LPBYTE)hglobal + dwBytes);
    *p = hglobal;

    return DebugMemoryAdd( hglobal,dwBytes, pszComment );
}

//
// Remove the MEMORYBLOCK to the memory tracking list, memsets the
// memory to 0xFE and then frees the memory.
//
HGLOBAL
DebugFree(
    HGLOBAL hglobal )
{
    DebugMemoryDelete( hglobal );

    return GlobalFree( hglobal );
}

//
// Checks the memory tracking list. If it is not empty, it will dump the
// list and break.
//
void
DebugMemoryCheck( )
{
    BOOL          fFoundLeak = FALSE;
    LPMEMORYBLOCK pmb;

    EnterCriticalSection( &g_TraceMemoryCS );

    pmb = g_TraceMemoryTable;
    while ( pmb )
    {
        LPMEMORYBLOCK pTemp;
        
        if ( fFoundLeak == FALSE )
        {
            TCDebugPrint(("\n***************************** Memory leak detected *****************************\n\n"));
            TCDebugPrint(("Memory leak at %x, %s", pmb->hglobal, pmb->pszComment));
            fFoundLeak = TRUE;
        }
        pTemp = pmb;
        pmb = pmb->pNext;
        memset( pTemp, 0xFD, sizeof(MEMORYBLOCK) );
        GlobalFree( pTemp );
    }

    if ( fFoundLeak == TRUE )
    {
        TCDebugPrint(("\n***************************** Memory leak detected *****************************\n\n"));
    }

    LeaveCriticalSection( &g_TraceMemoryCS );

    //BinlAssert( !fFoundLeak );
}


#endif // DBG==1
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\headless\tcsrv\inc\tcsrvc.h ===
/* 
 * Copyright (c) Microsoft Corporation
 * 
 * Module Name : 
 *       tcsrvc.h
 *
 * Contains the structure definition for exchanging information between 
 * the client and the server.
 *
 * 
 * Sadagopan Rajaram -- Oct 18, 1999
 *
 */

#define TCSERV_MUTEX_NAME _T("Microsoft-TCSERV-Mutex")

#ifndef MAX_BUFFER_SIZE
#define MAX_BUFFER_SIZE 256
#endif


typedef struct _CLIENT_INFO{
    int len;
    TCHAR device[MAX_BUFFER_SIZE];
} CLIENT_INFO, *PCLIENT_INFO;

#define SERVICE_PORT 3876

#define HKEY_TCSERV_PARAMETER_KEY _T("System\\CurrentControlSet\\Services\\TCSERV\\Parameters")

#define TCSERV_NAME _T("TCSERV")
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\headless\tcsrv\client\tcclnt.h ===
/* 
 * Copyright (c) Microsoft Corporation
 * 
 * Module Name : 
 *        tcclnt.h
 *
 * Contains the include files used by the client
 *
 * 
 * Sadagopan Rajaram -- Oct 18, 1999
 *
 */

//
//  NT public header files
//
#include <tchar.h>
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <ntseapi.h>

#include <windows.h>
#include <winsock2.h>
#include <align.h>
#include <smbgtpt.h>
#include <dsgetdc.h>
#include <lm.h>
#include <winldap.h>
#include <dsrole.h>
#include <rpc.h>
#include <ntdsapi.h>

#include <lmcons.h>
#include <lmerr.h>
#include <lmsname.h>
#include <rpc.h>
#include <security.h>   // General definition of a Security Support Provider
#include <ntlmsp.h>
#include <spseal.h>
#include <userenv.h>
#include <setupapi.h>

//
// C Runtime library includes.
//

#include <stdlib.h>
#include <stdio.h>
#include <string.h>

//
// netlib header.
//

#include <lmcons.h>
#include <secobj.h>
#include <conio.h>

#define MAX_TERMINAL_WIDTH 80
#define MAX_TERMINAL_HEIGHT 24

extern HANDLE hConsoleOutput;
extern HANDLE InputHandle;
extern VOID (*AttributeFunction)(PCHAR,int); 
// BUGBUG - dont know where this constant is really defined
#undef MB_CUR_MAX
#define MB_CUR_MAX 2

VOID 
ProcessEscapeSequence(
    PCHAR Buffer,
    int length
    );

BOOLEAN 
FinalCharacter(
    CHAR c
    );

VOID 
PrintChar(
    CHAR c
    );

VOID
ProcessTextAttributes(
    PCHAR Buffer,
    int length
    );

VOID inchar(
    CHAR *buff
    );

VOID
vt100Attributes(
    PCHAR Buffer,
    int length
    );

VOID
OutputConsole(
    CHAR byte
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\headless\tcsrv\client\parser.c ===
/* 
 * Copyright (c) Microsoft Corporation
 * 
 * Module Name : 
 *        parser.c
 *
 * This is the file containing the client code for parsing vt100 escape sequences 
 * into console mode output. 
 * 
 * 
 * Sadagopan Rajaram -- Nov 3, 1999
 *
 */

#include "tcclnt.h"

 
CHAR FinalCharacters[] = "mHJKr";
HANDLE hConsoleOutput;
BOOLEAN InEscape=FALSE; 
BOOLEAN lastCharM = FALSE;
CHAR EscapeBuffer[MAX_TERMINAL_WIDTH];
int index=0;
SHORT ScrollTop = 0;
SHORT ScrollBottom = MAX_TERMINAL_HEIGHT -1; 
#ifdef UNICODE
int DBCSIndex = 0;
CHAR DBCSArray[MB_CUR_MAX+1];
#endif

VOID (*AttributeFunction)(PCHAR, int);

VOID 
PrintChar(
    CHAR c
    )
{
    // A boolean variable to check if we are processing an escape sequence

    if(c == '\033'){
        InEscape = TRUE;
        EscapeBuffer[0] = c;
        index = 1;
        return;
    }
    if(InEscape == TRUE){
        if(index == MAX_TERMINAL_WIDTH){
            // vague escape sequence,give up processing
            InEscape = FALSE;
            index=0;
            return;
        }
        EscapeBuffer[index]=c;
        index++;
        if(FinalCharacter(c)){
            if(c=='m'){
                // maybe getting \017
                lastCharM = TRUE;
            }
            ProcessEscapeSequence(EscapeBuffer, index);
            InEscape = FALSE;
            index=0;
        }
        return;
    }
    if(lastCharM && c == '\017'){
        lastCharM = FALSE;
        return;
    }
    OutputConsole(c);
    return;
}

BOOLEAN 
FinalCharacter(
    CHAR c
    )
{

    if(strchr(FinalCharacters,c)){
        return TRUE;
    }
    return FALSE;

}

VOID 
ProcessEscapeSequence(
    PCHAR Buffer,
    int length
    )
{


    // BUGBUG - Function too big, can optimize code size by having 
    // an action variable which is initialized when the strings are 
    // compared, so that cut and paste code can be eliminated.

    CONSOLE_SCREEN_BUFFER_INFO csbInfo;
    ULONG charsToWrite;
    ULONG charsWritten;
    PCHAR pTemp;
    int RetVal;



    if (length == 3) {
        // One of the home cursor or clear to end of display
        if (strncmp(Buffer,"\033[H",length)==0) {
            // Home the cursor
            csbInfo.dwCursorPosition.X = 0;
            csbInfo.dwCursorPosition.Y = 0;
            SetConsoleCursorPosition(hConsoleOutput,
                                     csbInfo.dwCursorPosition
                                     );
            return;
        }
        if(strncmp(Buffer,"\033[J", length) == 0){
            // clear to end of display assuming 80 X 24 size
            RetVal = GetConsoleScreenBufferInfo(hConsoleOutput,
                                                &csbInfo
                                                );
            if (RetVal == FALSE) {
                return;
            }
            SetConsoleMode(hConsoleOutput,
                           ENABLE_WRAP_AT_EOL_OUTPUT|ENABLE_PROCESSED_OUTPUT
                           );

            charsToWrite = (MAX_TERMINAL_HEIGHT - 
                            csbInfo.dwCursorPosition.Y)*MAX_TERMINAL_WIDTH - 
                csbInfo.dwCursorPosition.X;
            
            RetVal = FillConsoleOutputAttribute(hConsoleOutput,
                                                csbInfo.wAttributes,
                                                charsToWrite,
                                                csbInfo.dwCursorPosition,
                                                &charsWritten
                                                );
            RetVal = FillConsoleOutputCharacter(hConsoleOutput,
                                                0,
                                                charsToWrite,
                                                csbInfo.dwCursorPosition,
                                                &charsWritten
                                                );


            SetConsoleMode(hConsoleOutput,
                           ENABLE_PROCESSED_OUTPUT
                           );
            SetConsoleCursorPosition(hConsoleOutput,
                                     csbInfo.dwCursorPosition
                                     );
            return;
        }
        if(strncmp(Buffer,"\033[K", length) == 0){
            // clear to end of line assuming 80 X 24 size
            RetVal = GetConsoleScreenBufferInfo(hConsoleOutput,
                                                &csbInfo
                                                );
            if (RetVal == FALSE) {
                return;
            }
            charsToWrite = (MAX_TERMINAL_WIDTH - csbInfo.dwCursorPosition.X);
            RetVal = FillConsoleOutputAttribute(hConsoleOutput,
                                                csbInfo.wAttributes,
                                                charsToWrite,
                                                csbInfo.dwCursorPosition,
                                                &charsWritten
                                                );
            RetVal = FillConsoleOutputCharacter(hConsoleOutput,
                                                0,
                                                charsToWrite,
                                                csbInfo.dwCursorPosition,
                                                &charsWritten
                                                );
            SetConsoleCursorPosition(hConsoleOutput,
                                     csbInfo.dwCursorPosition
                                     );
            return;
        }
        if (strncmp(Buffer,"\033[r", length) == 0) {
            ScrollTop = 0;
            ScrollBottom = MAX_TERMINAL_HEIGHT -1;
        }
    }

    if (length == 4) {
        // One of the home cursor or clear to end of display
        if (strncmp(Buffer,"\033[0H",length)==0) {
            // Home the cursor
            csbInfo.dwCursorPosition.X = 0;
            csbInfo.dwCursorPosition.Y = 0;
            SetConsoleCursorPosition(hConsoleOutput,
                                     csbInfo.dwCursorPosition
                                     );
            return;
        }
        if(strncmp(Buffer,"\033[2J",length) == 0){
            // Home the cursor
            csbInfo.dwCursorPosition.X = 0;
            csbInfo.dwCursorPosition.Y = 0;
            SetConsoleCursorPosition(hConsoleOutput,
                                     csbInfo.dwCursorPosition
                                     );
            sprintf(Buffer, "\033[0J");
        }

        if(strncmp(Buffer,"\033[0J", length) == 0){
            // clear to end of display assuming 80 X 24 size
            RetVal = GetConsoleScreenBufferInfo(hConsoleOutput,
                                                &csbInfo
                                                );
            if (RetVal == FALSE) {
                return;
            }
            SetConsoleMode(hConsoleOutput,
                           ENABLE_WRAP_AT_EOL_OUTPUT|ENABLE_PROCESSED_OUTPUT
                           );

            charsToWrite = (MAX_TERMINAL_HEIGHT - 
                            csbInfo.dwCursorPosition.Y)*MAX_TERMINAL_WIDTH - 
                csbInfo.dwCursorPosition.X;
            
            RetVal = FillConsoleOutputAttribute(hConsoleOutput,
                                                csbInfo.wAttributes,
                                                charsToWrite,
                                                csbInfo.dwCursorPosition,
                                                &charsWritten
                                                );
            RetVal = FillConsoleOutputCharacter(hConsoleOutput,
                                                0,
                                                charsToWrite,
                                                csbInfo.dwCursorPosition,
                                                &charsWritten
                                                );


            SetConsoleMode(hConsoleOutput,
                           ENABLE_PROCESSED_OUTPUT
                           );
            SetConsoleCursorPosition(hConsoleOutput,
                                     csbInfo.dwCursorPosition
                                     );
            return;
        }
        if((strncmp(Buffer,"\033[0K", length) == 0) || 
           (strncmp(Buffer,"\033[2K",length) == 0)){
            // clear to end of line assuming 80 X 24 size
            RetVal = GetConsoleScreenBufferInfo(hConsoleOutput,
                                                &csbInfo
                                                );
            if (RetVal == FALSE) {
                return;
            }
            charsToWrite = (MAX_TERMINAL_WIDTH - csbInfo.dwCursorPosition.X);
            RetVal = FillConsoleOutputAttribute(hConsoleOutput,
                                                csbInfo.wAttributes,
                                                charsToWrite,
                                                csbInfo.dwCursorPosition,
                                                &charsWritten
                                                );
            RetVal = FillConsoleOutputCharacter(hConsoleOutput,
                                                0,
                                                charsToWrite,
                                                csbInfo.dwCursorPosition,
                                                &charsWritten
                                                );
            SetConsoleCursorPosition(hConsoleOutput,
                                     csbInfo.dwCursorPosition
                                     );
            return;
        }
        if((strncmp(Buffer,"\033[0m", length) == 0)||
           (strncmp(Buffer,"\033[m\017", length) == 0)){
            // clear all attributes and set Text attributes to black on white
            SetConsoleTextAttribute(hConsoleOutput, 
                             FOREGROUND_RED |FOREGROUND_BLUE |FOREGROUND_GREEN
                             );

            return;
        }
    }

    if(Buffer[length-1] == 'm'){
        //set the text attributes
        // clear all attributes and set Text attributes to white on black
        SetConsoleTextAttribute(hConsoleOutput, 
                         FOREGROUND_RED |FOREGROUND_BLUE |FOREGROUND_GREEN
                         );
        AttributeFunction(Buffer, length);
        return;
    }


    if(Buffer[length -1] == 'H'){
        // Set cursor position
        if (sscanf(Buffer,"\033[%d;%d", &charsToWrite, &charsWritten) == 2) {
            csbInfo.dwCursorPosition.Y = (SHORT)(charsToWrite -1);
            csbInfo.dwCursorPosition.X = (SHORT)(charsWritten -1);
            SetConsoleCursorPosition(hConsoleOutput,
                                     csbInfo.dwCursorPosition
                                     );
        }
        return;

    }
    if(Buffer[length -1] == 'r'){
        // Set scroll region
        sscanf(Buffer,"\033[%d;%d", &charsToWrite,&charsWritten);
        if ((charsToWrite < 1) 
            || (charsToWrite > MAX_TERMINAL_HEIGHT)
            || (charsWritten < charsToWrite)) { 
            return;
        }
        ScrollTop    = (SHORT)(charsToWrite -1);
        ScrollBottom = (SHORT)(charsWritten -1);
    }
    return;
}

VOID
ProcessTextAttributes(
    PCHAR Buffer,
    int length
    )
{
    PCHAR CurrLoc = Buffer;
    ULONG Attribute;
    WORD TextAttribute = 0;
    BOOLEAN Reverse = FALSE;
    PCHAR pTemp;
    
    while(*CurrLoc != 'm'){
        if((*CurrLoc < '0') || (*CurrLoc >'9' )){
            CurrLoc ++;
        }else{
            if (sscanf(CurrLoc,"%d", &Attribute) != 1) {
                return;
            }
            switch(Attribute){
            case 1:
                TextAttribute = TextAttribute | FOREGROUND_INTENSITY;
                break;
            case 37:
                TextAttribute = TextAttribute|FOREGROUND_RED |FOREGROUND_BLUE |FOREGROUND_GREEN;
                break;
            case 47:
                TextAttribute = TextAttribute|BACKGROUND_RED |BACKGROUND_BLUE |BACKGROUND_GREEN;
                break;
            case 34:
                TextAttribute = TextAttribute|FOREGROUND_BLUE;
                break;
            case 44:
                TextAttribute = TextAttribute|BACKGROUND_BLUE;
                break;
            case 31: 
                TextAttribute = TextAttribute|FOREGROUND_RED;
                break;
            case 41:
                TextAttribute = TextAttribute|BACKGROUND_RED;
                break;
            case 33: 
                TextAttribute = TextAttribute|FOREGROUND_GREEN|FOREGROUND_BLUE;
                break;
            case 43:
                TextAttribute = TextAttribute|BACKGROUND_GREEN|BACKGROUND_BLUE;
                break;
            case 7:
                // Reverse the background and foreground colors
                Reverse=TRUE;
            default:
                break;
            }
            pTemp = strchr(CurrLoc, ';');
            if(pTemp == NULL){
                pTemp = strchr(CurrLoc, 'm');
            }
            if(pTemp == NULL) {
                break;
            }
            CurrLoc = pTemp;

        }
    }
    if (Reverse) {
        if ((!TextAttribute) || 
            (TextAttribute == FOREGROUND_INTENSITY)) {
            // Reverse vt100 escape sequence.
            TextAttribute = TextAttribute | 
                BACKGROUND_RED |BACKGROUND_BLUE |BACKGROUND_GREEN;
        }
    }
    if(TextAttribute){
        SetConsoleTextAttribute(hConsoleOutput,
                         TextAttribute
                         );
    }
    return;

}


VOID
vt100Attributes(
    PCHAR Buffer,
    int length
    )
{
    PCHAR CurrLoc = Buffer;
    ULONG Attribute;
    WORD TextAttribute = 0;
    PCHAR pTemp;

    while(*CurrLoc != 'm'){
        if((*CurrLoc < '0') || (*CurrLoc >'9' )){
            CurrLoc ++;
        }else{
            if (sscanf(CurrLoc,"%d", &Attribute) != 1) {
                return;
            }

            switch(Attribute){
            case 1:
                TextAttribute = TextAttribute | FOREGROUND_INTENSITY;
                break;
            case 5:
                TextAttribute = TextAttribute | BACKGROUND_INTENSITY;
                break;
            case 7:
                TextAttribute = TextAttribute | 
                BACKGROUND_RED |BACKGROUND_BLUE |BACKGROUND_GREEN;
                break;
            default:
                break;
            }
            pTemp = strchr(CurrLoc, ';');
            if(pTemp == NULL){
                pTemp = strchr(CurrLoc, 'm');
            }
            if(pTemp == NULL) {
                break;
            }
            CurrLoc = pTemp;

        }
    }
    if(TextAttribute){
        SetConsoleTextAttribute(hConsoleOutput,
                                TextAttribute
                                );
    }
    return;
}

VOID
OutputConsole(
    CHAR byte
    )
{

    CONSOLE_SCREEN_BUFFER_INFO csbInfo;
    COORD dwBufferCoord;
    SMALL_RECT sRect;
    BOOL RetVal;
    TCHAR Char;
    SHORT ypos;
    CHAR_INFO Fill;
    DWORD charsWritten;


    if (byte == '\n'){
        RetVal = GetConsoleScreenBufferInfo(hConsoleOutput,
                                            &csbInfo
                                            );
        if (RetVal == FALSE) {
            return;
        }
        ypos = csbInfo.dwCursorPosition.Y;
        if ((ypos == ScrollBottom ) || (ypos == MAX_TERMINAL_HEIGHT -1 )) {
            // Do the scrolling
            dwBufferCoord.X = 0;
            dwBufferCoord.Y = ScrollBottom;
            Fill.Char.UnicodeChar = (WCHAR) 0;
            Fill.Attributes = FOREGROUND_RED |FOREGROUND_BLUE |FOREGROUND_GREEN;
            if ((ypos == ScrollBottom) 
                && (ScrollTop != ScrollBottom)) {
                sRect.Left   = 0;
                sRect.Top    = ScrollTop + 1;
                sRect.Right  = MAX_TERMINAL_WIDTH-1;
                sRect.Bottom = ScrollBottom;
                dwBufferCoord.Y = ScrollTop;
                dwBufferCoord.X = 0;
                RetVal =  ScrollConsoleScreenBuffer(hConsoleOutput,
                                                    &sRect,
                                                    NULL,
                                                    dwBufferCoord,
                                                    &Fill
                                                    );
                dwBufferCoord.Y = ScrollBottom;

            } else {
                if (ypos == MAX_TERMINAL_HEIGHT -1){
                    sRect.Left   = 0;
                    sRect.Top    = 1;
                    sRect.Right  = MAX_TERMINAL_WIDTH-1;
                    sRect.Bottom = MAX_TERMINAL_HEIGHT - 1;
                    dwBufferCoord.Y = 0;
                    dwBufferCoord.X = 0;
                    RetVal =  ScrollConsoleScreenBuffer(hConsoleOutput,
                                                        &sRect,
                                                        NULL,
                                                        dwBufferCoord,
                                                        &Fill
                                                        );
                    dwBufferCoord.Y = MAX_TERMINAL_HEIGHT -1;
                }
            }
            RetVal = FillConsoleOutputCharacter(hConsoleOutput,
                                                (TCHAR) 0,
                                                MAX_TERMINAL_WIDTH,
                                                dwBufferCoord,
                                                &charsWritten
                                                );
            return;

        } else {

            csbInfo.dwCursorPosition.Y = ypos + 1;

            SetConsoleCursorPosition(hConsoleOutput,
                                     csbInfo.dwCursorPosition
                                     );
        }
        return;
    }
    if (byte == '\r'){
        RetVal = GetConsoleScreenBufferInfo(hConsoleOutput,
                                            &csbInfo
                                            );
        if (RetVal == FALSE) {
            return;
        }
        csbInfo.dwCursorPosition.X = 0;

        SetConsoleCursorPosition(hConsoleOutput,
                                 csbInfo.dwCursorPosition
                                 );
        return;
    }

     
    Char = (TCHAR) byte;

    #ifdef UNICODE
    DBCSArray[DBCSIndex] = byte;
    if(DBCSIndex ==0){
        if(isleadbyte(byte)){
            DBCSIndex ++;
            return;
        }
    }
    else{
      mbtowc(&Char, DBCSArray, 2);
      DBCSIndex  = 0;
    }
    #endif
    _tprintf(_T("%c"),Char);
    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\headless\tcsrv\server\debug.h ===
/*++

Copyright (c) 1994-7  Microsoft Corporation

Module Name:

    debug.h

Abstract:

    This file contains debugging macros for the binl server.

Author:

    Colin Watson (colinw)  14-Apr-1997

Environment:

    User Mode - Win32

Revision History:


--*/


#if DBG==1
// Leak detection
//


#define INITIALIZE_TRACE_MEMORY     InitializeCriticalSection( &g_TraceMemoryCS );\
                                    g_TraceMemoryTable = NULL;
#define UNINITIALIZE_TRACE_MEMORY   DebugMemoryCheck( );\
                                    DeleteCriticalSection( &g_TraceMemoryCS );

extern CRITICAL_SECTION g_TraceMemoryCS;

typedef struct _MEMORYBLOCK {
    HGLOBAL hglobal;
    DWORD   dwBytes;
    UINT    uFlags;
    LPCSTR pszComment;
    struct _MEMORYBLOCK *pNext;
} MEMORYBLOCK, *LPMEMORYBLOCK;

extern LPMEMORYBLOCK g_TraceMemoryTable;

HGLOBAL
DebugAlloc(
    UINT    uFlags,
    DWORD   dwBytes,
    LPCSTR pszComment );

void
DebugMemoryDelete(
    HGLOBAL hglobal );

HGLOBAL
DebugMemoryAdd(
    HGLOBAL hglobal,
    DWORD   dwBytes,
    LPCSTR pszComment );

HGLOBAL
DebugFree(
    HGLOBAL hglobal );

void
DebugMemoryCheck( );

HGLOBAL
TCReAlloc(
    HGLOBAL mem,
    DWORD size,
    LPCSTR comment
    );


#define TCAllocate(x,s) DebugAlloc(GMEM_ZEROINIT, x, s)
#define TCFree(x)     DebugFree(x)
        
#define TCDebugPrint(x) DbgPrint x

#else   // not DBG

#define INITIALIZE_TRACE_MEMORY
#define UNINITIALIZE_TRACE_MEMORY

#define TCDebugPrint(x) 
#define TCAllocate(x,s) HeapAlloc(GetProcessHeap(),HEAP_ZERO_MEMORY, x)
#define TCFree(x)     HeapFree(GetProcessHeap(),0,x)
#define TCReAlloc(x, y , z) HeapReAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, x,y)


#endif // not DBG
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\headless\tcsrv\server\init.c ===
/* 
 * Copyright (c) Microsoft Corporation
 * 
 * Module Name : 
 *        init.c
 *
 * Initilization functions
 * Where possible, code has been obtained from BINL server.
 * 
 * Sadagopan Rajaram -- Oct 14, 1999
 *
 */
#include "tcsrv.h"
#include <ntddser.h>
#include "tcsrvc.h"
#include "proto.h"

PHANDLE Threads;
PCOM_PORT_INFO ComPortInfo;
int ComPorts;
SOCKET MainSocket;
HANDLE TerminateService;
CRITICAL_SECTION GlobalMutex;

NTSTATUS Initialize(
    )
/*++ 
    This function performs the initialization routine by opening the COM ports, 
    allocating circular buffers for each of the COM ports. All these values are 
    in the registry. 
    
    Threads are started for reading from each of the COM ports. These buffers 
    are protected by mutual exclusion variables.
    
    Caveat for me - Remember all the allocation done here. you need to free them 
    when you leave the system.
    
    Return Value : 
        Success if successful in doing everything, else an error code.
    
--*/  
    
{
    int number=1; 
    int i;
    HKEY hKey, hParameter;
    PCOM_PORT_INFO pTempInfo;
    NTSTATUS Status;
    LPTSTR name,device;
    int index;
    LONG RetVal;
    HANDLE lock;


    // Global variable carrying information about the COM ports.
    ComPortInfo = NULL;
    ComPorts = 0;

    RetVal = TCLock(&lock);
    if(RetVal != ERROR_SUCCESS){
        TCDebugPrint(("Cannot Lock Registry %d\n", RetVal));
        return RetVal;
    }
    RetVal = RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                          HKEY_TCSERV_PARAMETER_KEY,
                          0,
                          KEY_ALL_ACCESS,
                          &hKey
                          );
    if(RetVal != ERROR_SUCCESS){
        TCDebugPrint(("Cannot open Registry Key %d\n", RetVal));
        return RetVal;
    }

    // Read the correct parameters from the registry until you get no more.

    index= 0;
    while(1) {
        RetVal = GetNextParameter(hKey,
                                  index,
                                  &hParameter,
                                  &name
                                  );
        if (RetVal == ERROR_NO_MORE_ITEMS) {
            TCUnlock(lock);
            TCDebugPrint(("Done with registry\n"));
            break;
        }
        if(RetVal != ERROR_SUCCESS){
            TCUnlock(lock);
            TCDebugPrint(("Problem with registry, %d\n", RetVal));
            return RetVal;
        }
        RetVal = GetNameOfDeviceFromRegistry(hParameter,
                                             &device
                                             );
        if(RetVal != ERROR_SUCCESS){
            TCFree(name);
            continue;
        }
        
        pTempInfo = GetComPortParameters(hParameter);
        RegCloseKey(hParameter);

        if(pTempInfo == NULL){
            TCFree(name);
            TCFree(device);
            RegCloseKey(hKey);
            TCUnlock(lock);
            return RetVal;
        }

        pTempInfo->Device.Buffer = device;
        pTempInfo->Name.Buffer = name;
        pTempInfo->Name.Length = (_tcslen(pTempInfo->Name.Buffer))*sizeof(TCHAR);
        pTempInfo->Device.Length = (_tcslen(pTempInfo->Device.Buffer)) * sizeof(TCHAR);
        Status = AddComPort(pTempInfo);
    
        // Open the Com port and start the worker thread.

        if(Status != STATUS_SUCCESS){
            FreeComPortInfo(pTempInfo);
            TCDebugPrint(("Could not initialize com port\n"));
        }
        index++;
    }
    return (STATUS_SUCCESS);
}

NTSTATUS
AddComPort(
    PCOM_PORT_INFO pComPortInfo
    )
/*++
    Adds a Com port to the global list and reallocates the threads and 
    allows dynamic changes to the com ports being serviced.
--*/
{
    // Lock down the global data so that it is consistent.
    NTSTATUS Status;

    pComPortInfo->Events[0] = TerminateService;
    pComPortInfo->Events[1] = CreateEvent(NULL,TRUE,FALSE,NULL);
    if (pComPortInfo->Events[1]==NULL) {
        TCDebugPrint(("Event creation failed\n"));
        return(STATUS_NO_MEMORY);

    }
    pComPortInfo->Events[2] = CreateEvent(NULL,TRUE,FALSE,NULL);
    if (pComPortInfo->Events[2]==NULL) {
        TCDebugPrint(("Event creation failed\n"));
        return(STATUS_NO_MEMORY);

    }
    pComPortInfo->Overlapped.hEvent = pComPortInfo->Events[2];
    pComPortInfo->WriteOverlapped.hEvent = CreateEvent(NULL,TRUE,FALSE,NULL);
    if (pComPortInfo->WriteOverlapped.hEvent==NULL) {
        TCDebugPrint(("Write Event creation failed\n"));
        return(STATUS_NO_MEMORY);

    }
    InitializeCriticalSection(&(pComPortInfo->Mutex));
    pComPortInfo->TerminateEvent = CreateEvent(NULL,TRUE,FALSE,NULL);
    if(pComPortInfo->TerminateEvent== NULL){
        TCDebugPrint(("Terminate Event Creation Failed\n"));
        return(STATUS_NO_MEMORY);
    }
    pComPortInfo->Events[3] = CreateEvent(NULL,TRUE,FALSE,NULL);
    if(pComPortInfo->Events[3]== NULL){
        TCDebugPrint(("Terminate Event Creation Failed\n"));
        return(STATUS_NO_MEMORY);
    }
    pComPortInfo->ShuttingDown = FALSE;
    pComPortInfo->Deleted = FALSE;
    pComPortInfo->Sockets = NULL;
    pComPortInfo->Connections = NULL;
    pComPortInfo->Head=pComPortInfo->Tail =0;
    pComPortInfo->Number = 0;
    Status = InitializeComPort(pComPortInfo);
    if (Status == STATUS_SUCCESS) {
        return InitializeThread(pComPortInfo);
    }
    return Status;
}

NTSTATUS 
InitializeComPort(
    PCOM_PORT_INFO pComPortInfo
    )
/*++ 
    Start a thread to do stuff. But before that, it must initialize the Com Port
    and fill out the rest of the data structure.
--*/

{
    HANDLE temp;
    NTSTATUS Status;
    OBJECT_ATTRIBUTES Obja;
    SERIAL_BAUD_RATE BaudRate;
    SERIAL_LINE_CONTROL LineControl;
    SERIAL_TIMEOUTS NewTimeouts;
    ULONG ModemStatus;
    int i;
    
    #ifdef UNICODE

    InitializeObjectAttributes(&Obja,
                               &(pComPortInfo->Device), 
                               OBJ_CASE_INSENSITIVE,
                               NULL,
                               NULL
                               );
    #else
    UNICODE_STRING str;
    int len;
    // Here is where uniformity breaks down :-)
    len = (_tcslen(pComPortInfo->Device.Buffer)+1)*sizeof(WCHAR);
    str.Buffer = (PWCHAR) TCAllocate(len,"Unicode");
    str.MaximumLength = len*sizeof(WCHAR);
    str.Length = 0;
    if(str.Buffer == NULL){
        return STATUS_NO_MEMORY;
    }
    len = mbstowcs(str.Buffer,
                   pComPortInfo->Device.Buffer,
                   _tcslen(pComPortInfo->Device.Buffer)+1
                   );
    str.Buffer[len] = (TCHAR) 0;
    str.Length = wcslen(str.Buffer) * sizeof(WCHAR);
    InitializeObjectAttributes(&Obja,
                               &str, 
                               OBJ_CASE_INSENSITIVE,
                               NULL,
                               NULL
                               );
    #endif

    Status = NtCreateFile(&(pComPortInfo->ComPortHandle),
                          GENERIC_READ | GENERIC_WRITE |SYNCHRONIZE,
                          &Obja,
                          &(pComPortInfo->IoStatus),
                          0,
                          0,
                          FILE_SHARE_READ|FILE_SHARE_WRITE,
                          FILE_OPEN,
                          FILE_NON_DIRECTORY_FILE,
                          0,
                          0
                          );
    #ifdef UNICODE
    #else
    TCFree(str.Buffer);
    #endif

    if (!NT_SUCCESS(Status)) {
        TCDebugPrint(("Opening Com Device Failure %x\n",Status));
        return Status;
    }

    // Set Com Port Parameters
    // Set the baud rate
    //
    BaudRate.BaudRate = pComPortInfo->BaudRate;
    Status = NtDeviceIoControlFile(pComPortInfo->ComPortHandle,
                                   NULL,
                                   NULL,
                                   NULL,
                                   &(pComPortInfo->IoStatus),
                                   IOCTL_SERIAL_SET_BAUD_RATE,
                                   &BaudRate,
                                   sizeof(SERIAL_BAUD_RATE),
                                   NULL,
                                   0
                                  );

    if (!NT_SUCCESS(Status)) {
        NtClose(pComPortInfo->ComPortHandle);
        TCDebugPrint(("Can't set Baud rate %ld\n", Status));
        return Status;
    }
    
    //
    // Set 8-N-1 data
    //
    LineControl.WordLength = pComPortInfo->WordLength;
    LineControl.Parity = pComPortInfo->Parity;
    LineControl.StopBits = pComPortInfo->StopBits;
    Status = NtDeviceIoControlFile(pComPortInfo->ComPortHandle,
                                   NULL,
                                   NULL,
                                   NULL,
                                   &(pComPortInfo->IoStatus),
                                   IOCTL_SERIAL_SET_LINE_CONTROL,
                                   &LineControl,
                                   sizeof(SERIAL_LINE_CONTROL),
                                   NULL,
                                   0
                                  );

    if (!NT_SUCCESS(Status)) {
        NtClose(pComPortInfo->ComPortHandle);
        TCDebugPrint(("Can't set line control %lx\n",Status));
        return Status;
    }
    
    //
    // Check if we have a carrier
    //

    Status = NtDeviceIoControlFile(pComPortInfo->ComPortHandle,
                                   NULL,
                                   NULL,
                                   NULL,
                                   &(pComPortInfo->IoStatus),
                                   IOCTL_SERIAL_GET_MODEMSTATUS,
                                   NULL,
                                   0,
                                   &ModemStatus,
                                   sizeof(ULONG)
                                  );

    if (!NT_SUCCESS(Status)) {
        NtClose(pComPortInfo->ComPortHandle);
        TCDebugPrint(("Can't call the detect routine %lx\n",Status));
        return Status;
    }
    // BUGBUG - We do not bother about the presence of a carrier as the 
    // machine to which this bridge is connected may be down. 

    /*if ((ModemStatus & 0xB0) != 0xB0) {
        NtClose(pComPortInfo->ComPortHandle);
        TCDebugPrint(("Can't detect carrier %lx\n",ModemStatus));
        return STATUS_SERIAL_NO_DEVICE_INITED;
    }*/
    
    //
    // Set timeout values for reading
    // We should have a time out that reads from the read buffer 
    // as many characters as there are asked for or waits for the 
    // first available character
    //
    NewTimeouts.ReadIntervalTimeout = MAXULONG;
    NewTimeouts.ReadTotalTimeoutMultiplier = MAXULONG;
    NewTimeouts.ReadTotalTimeoutConstant = MAXULONG-1;
    NewTimeouts.WriteTotalTimeoutMultiplier = MAXULONG;
    NewTimeouts.WriteTotalTimeoutConstant = MAXULONG;
    Status = NtDeviceIoControlFile(pComPortInfo->ComPortHandle,
                                   NULL,
                                   NULL,
                                   NULL,
                                   &(pComPortInfo->IoStatus),
                                   IOCTL_SERIAL_SET_TIMEOUTS,
                                   &NewTimeouts,
                                   sizeof(SERIAL_TIMEOUTS),
                                   NULL,
                                   0
                                  );

    if (!NT_SUCCESS(Status)) {
        NtClose(pComPortInfo->ComPortHandle);
        TCDebugPrint(("Can't set time out values %lx\n",Status));
        return Status;
    }
    return STATUS_SUCCESS;

}

NTSTATUS
InitializeThread(
    PCOM_PORT_INFO pComPortInfo
    )
{
    NTSTATUS Status;
    HANDLE ThreadHandle;
    PHANDLE NewThreads;
    ULONG ThreadID;

    ThreadHandle=CreateThread(NULL,
                              THREAD_ALL_ACCESS,
                              bridge,
                              pComPortInfo,
                              0,
                              &ThreadID
                              );
    if(ThreadHandle == NULL){
        NtClose(pComPortInfo->ComPortHandle);
        TCDebugPrint(("Create Com Thread Failure %lx\n",GetLastError()));
        return GetLastError();
    } 
    EnterCriticalSection(&GlobalMutex);
    if(ComPorts == 0){
        NewThreads = (PHANDLE) TCAllocate(sizeof(HANDLE), "Thread");
    }
    else{
        NewThreads = (PHANDLE) TCReAlloc(Threads,
                                         (ComPorts+1)*sizeof(HANDLE),"Reallocation");
    }
    if(NewThreads == NULL){
        SetEvent(pComPortInfo->Events[3]);
        NtClose(pComPortInfo->ComPortHandle);
        NtClose(ThreadHandle);
        LeaveCriticalSection(&GlobalMutex);
        return STATUS_NO_MEMORY;
    }
    Threads = NewThreads;
    Threads[ComPorts] = ThreadHandle;
    pComPortInfo->Next = ComPortInfo;
    ComPortInfo = pComPortInfo;
    ComPorts++;
    LeaveCriticalSection(&GlobalMutex);
    return STATUS_SUCCESS;
}


SOCKET
ServerSocket(
    )
/*++
    Standard server binding code
--*/ 
{
    struct sockaddr_in srv_addr;
    int status; 
    WSADATA data;


    // Set the socket version to 2.2
    status=WSAStartup(514,&data);
    if(status){
        TCDebugPrint(("Cannot start up %d\n",status));
        return(INVALID_SOCKET);
    }
    TerminateService = CreateEvent(NULL,TRUE,FALSE,NULL);
    if(TerminateService == NULL){
        TCDebugPrint(("Cannot open Terminate Event %lx\n",GetLastError()));
        return INVALID_SOCKET;
    }
    MainSocket=WSASocket(AF_INET,SOCK_STREAM,0,NULL,0,WSA_FLAG_OVERLAPPED);
    if (MainSocket==INVALID_SOCKET){
        TCDebugPrint(("Could not open server socket %lx\n", WSAGetLastError()));
        return(MainSocket);
    }
    srv_addr.sin_family=AF_INET;
    srv_addr.sin_addr.s_addr=INADDR_ANY;
    // convert to network byte order. 
    // yechh!! bind does not automatically do it and
    // I got hurts in testing. (was so used to 
    // Unix big endian ordering == network byte ordering.
    srv_addr.sin_port=htons(SERVICE_PORT);        /* specific port for server to listen on */

    /* Bind socket to the appropriate port and interface (INADDR_ANY) */

    if (bind(MainSocket,(LPSOCKADDR)&srv_addr,sizeof(srv_addr))==SOCKET_ERROR){
        TCDebugPrint(("Windows Sockets error %d: Couldn't bind socket.",
                WSAGetLastError()));
        return(INVALID_SOCKET);
    }

    // Initialize the Global Mutex variable
    InitializeCriticalSection(&GlobalMutex);

    return(MainSocket);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\headless\tcsrv\server\handler.c ===
/* 
 * Copyright (c) Microsoft Corporation
 * 
 * Module Name : 
 *        handler.c
 *
 * Service Handler functions
 * Where possible, code has been obtained from BINL server.
 * 
 * Sadagopan Rajaram -- Oct 25, 1999
 *
 */
#include "tcsrv.h"
#include "tcsrvc.h"
#include "proto.h"

VOID
ServiceControlHandler(
    IN DWORD Opcode
    )
/*++

Routine Description:

    This is the service control handler of the Terminal Concentrator

Arguments:

    Opcode - Supplies a value which specifies the action for the
        service to perform.

Return Value:

    None.

--*/
{
    DWORD Error;

    switch (Opcode) {
    case SERVICE_CONTROL_STOP:                                                
    case SERVICE_CONTROL_SHUTDOWN:                                             
        EnterCriticalSection(&GlobalMutex);
        // We set the global state to a stop pending while the 
        // com ports destroy themselves. 
        // This is triggered by destroying the main socket.
        TCGlobalServiceStatus.dwCurrentState = SERVICE_STOP_PENDING;
        SetServiceStatus(TCGlobalServiceStatusHandle, &TCGlobalServiceStatus);
        closesocket(MainSocket);
        LeaveCriticalSection(&GlobalMutex);
        break;
    case SERVICE_CONTROL_PARAMCHANGE:

        EnterCriticalSection(&GlobalMutex);
        // If we are not currently running, but have been sent too many 
        // control parameter change requests, we say return.
        if(TCGlobalServiceStatus.dwCurrentState != SERVICE_RUNNING){
            LeaveCriticalSection(&GlobalMutex);
            return;
        }
        TCGlobalServiceStatus.dwCurrentState = SERVICE_PAUSED;
        SetServiceStatus(TCGlobalServiceStatusHandle, &TCGlobalServiceStatus);
        LeaveCriticalSection(&GlobalMutex);
        // Does the actual work of munging through the registry and 
        // finding out changes.
        UpdateChanges();
        break;
    }

    return;
}


VOID UpdateChanges(
    )
/*++ 
    Reads the parameters from the registry and then tries to add or delete com 
    ports as necessary
--*/
{

    PCOM_PORT_INFO pTempInfo;
    PCOM_PORT_INFO pTemp;
    PCOM_PORT_INFO addedPorts;
    LPTSTR device;
    LPTSTR name;
    BOOLEAN addPort;
    HKEY hKey, hParameter;
    NTSTATUS Status;
    int index;
    LONG RetVal;
    HANDLE lock;
    
    addedPorts = NULL;
    hKey = NULL;

    EnterCriticalSection(&GlobalMutex);
    pTempInfo = ComPortInfo;
    while(pTempInfo != NULL){
        // Sets the flag of Deleted to TRUE 
        // for all COM ports. If they are found
        // unchanged in the registry, we can leave
        // them. Changing session names are ok. 
        pTempInfo->Deleted = TRUE;
        pTempInfo= pTempInfo->Next;
    }
    LeaveCriticalSection(&GlobalMutex);
    RetVal = TCLock(&lock);
    if(RetVal != ERROR_SUCCESS){
        TCDebugPrint(("Cannot Lock Registry %d\n", RetVal));
        goto end;
    }
    RetVal = RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                          HKEY_TCSERV_PARAMETER_KEY,
                          0,
                          KEY_ALL_ACCESS,
                          &hKey
                          );
    if(RetVal != ERROR_SUCCESS){  
        TCUnlock(lock);
        TCDebugPrint(("Cannot open Registry Key %d\n", RetVal));
        goto end;
    }
    
    // Read the correct parameters from the registry until you get no more.

    index= 0;
    while(1) {
        RetVal = GetNextParameter(hKey,
                                  index,
                                  &hParameter,
                                  &name
                                  );
        if (RetVal == ERROR_NO_MORE_ITEMS) {
            TCUnlock(lock);
            TCDebugPrint(("Done with registry %d\n",index));
            break;
        }
        if(RetVal != ERROR_SUCCESS){
            TCUnlock(lock);
            TCDebugPrint(("Error reading registry %d\n",RetVal));
            goto end;
        }
        RetVal = GetNameOfDeviceFromRegistry(hParameter,
                                             &device
                                             );
        if(RetVal != ERROR_SUCCESS){
            TCFree(name);
            continue;
        }
        
        pTempInfo = GetComPortParameters(hParameter);
        RegCloseKey(hParameter);
        if(pTempInfo == NULL){   
            TCFree(name);
            TCFree(device);
            RegCloseKey(hKey);
            TCUnlock(lock);
            goto end;
        }
        pTempInfo->Device.Buffer = device;
        pTempInfo->Name.Buffer = name;
        pTempInfo->Name.Length = _tcslen(pTempInfo->Name.Buffer)*sizeof(TCHAR);
        pTempInfo->Device.Length = _tcslen(pTempInfo->Device.Buffer) * sizeof(TCHAR);

        EnterCriticalSection(&GlobalMutex);
        if(TCGlobalServiceStatus.dwCurrentState != SERVICE_PAUSED){
            // Somehow, the service has been shut down.
            RegCloseKey(hKey);
            FreeComPortInfo(pTempInfo);
            LeaveCriticalSection(&GlobalMutex);
            TCUnlock(lock);
            goto end;
        }
        pTemp = ComPortInfo;
        addPort = TRUE;
        while(pTemp){
            RetVal = ComPortInfoCompare(pTemp, pTempInfo);
            if(RetVal == SAME_ALL){
                pTemp->Deleted = FALSE;
                addPort = FALSE;
                break;
            }
            if (RetVal == SAME_DEVICE) {
                // User has changed configuration 
                // settings
                addPort  = TRUE;
                break;
            }
            if (RetVal == DIFFERENT_SESSION) {
                // Only session name has changed. So, we do not
                // need to delete the device. 
                pTemp->Deleted = FALSE;
                addPort = FALSE;
                TCFree(pTemp->Name.Buffer);
                pTemp->Name.Buffer = pTempInfo->Name.Buffer;
                pTempInfo->Name.Buffer = NULL;
                break;
            }
            // Different devices, so continue searching
            pTemp=pTemp->Next;
        }
        LeaveCriticalSection(&GlobalMutex);
        if (addPort == FALSE) {
            FreeComPortInfo(pTempInfo);
        }
        else{
            pTempInfo->Next = addedPorts;
            addedPorts= pTempInfo;
        }
        index++;
    }

    while(1){
        EnterCriticalSection(&GlobalMutex);
        if(TCGlobalServiceStatus.dwCurrentState != SERVICE_PAUSED){
            LeaveCriticalSection(&GlobalMutex);
            goto end;
        }
        pTempInfo = ComPortInfo;
        device = NULL;
        while(pTempInfo){
            if(pTempInfo->Deleted){
                // This is true if the configuration settings are 
                // changed or if the device has been really deleted. 
                device = pTempInfo->Device.Buffer;
                break;
            }
            pTempInfo = pTempInfo->Next;
        }
        LeaveCriticalSection(&GlobalMutex);
        if(device){
            Status = DeleteComPort(device);
        }
        else{
            break;
        }
    }

    while(addedPorts){
        pTempInfo = addedPorts;
        addedPorts = addedPorts->Next;
        Status = AddComPort(pTempInfo);
        if(Status != STATUS_SUCCESS){
            FreeComPortInfo(pTempInfo);
            TCDebugPrint(("Could not Initialize Com Port %x\n",Status));
        }
    }
end:
    while (addedPorts) {
        // We may have come here after an error condition.
        pTempInfo = addedPorts;
        addedPorts = pTempInfo->Next;
        pTempInfo->Next = NULL;
        FreeComPortInfo(pTempInfo);

    }
    EnterCriticalSection(&GlobalMutex);
    if(TCGlobalServiceStatus.dwCurrentState != SERVICE_PAUSED){
        LeaveCriticalSection(&GlobalMutex);
        return ;
    }
    TCGlobalServiceStatus.dwCurrentState = SERVICE_RUNNING;
    SetServiceStatus(TCGlobalServiceStatusHandle, &TCGlobalServiceStatus);
    LeaveCriticalSection(&GlobalMutex);
    return;

}


int 
ComPortInfoCompare(
    PCOM_PORT_INFO com1,
    PCOM_PORT_INFO com2
    )
{
    int ret;

    if (_tcscmp(com1->Device.Buffer, com2->Device.Buffer)) {
        // Different Devices
        return DIFFERENT_DEVICES;
    }
    // Same device
    ret = SAME_DEVICE;
    if ((com1->Parity != com2->Parity) ||
        (com1->StopBits != com2->StopBits) ||
        (com1->WordLength != com2->WordLength)||
        (com1->BaudRate != com2->BaudRate)){
        return ret;
    }
    if (_tcscmp(com1->Name.Buffer, com2->Name.Buffer)) {
        // Different Devices
        return DIFFERENT_SESSION;
    }
    return SAME_ALL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\headless\tcsrv\server\proto.h ===
/* 
 * Copyright (c) Microsoft Corporation
 * 
 * Module Name : 
 *       proto.h
 *
 * Contains the prototypes of all the functions used by the service.
 *
 * 
 * Sadagopan Rajaram -- Oct 18, 1999
 *
 */

 
VOID 
ServiceEntry(
    DWORD NumArgs,
    LPTSTR *ArgsArray
    );

DWORD
ProcessRequests(
    SOCKET socket
    );

DWORD
InitializeComPortConnection(
    SOCKET cli_sock
    );

NTSTATUS Initialize(
    );

NTSTATUS 
InitializeComPort(
    PCOM_PORT_INFO pComPortInfo
    );

SOCKET
ServerSocket(
    );

VOID 
Shutdown(
    NTSTATUS Status
    );

DWORD 
bridge(
    PCOM_PORT_INFO pComPortInfo
    );

VOID 
CALLBACK
updateComPort(
    IN DWORD dwError, 
    IN DWORD cbTransferred, 
    IN LPWSAOVERLAPPED lpOverlapped, 
    IN DWORD dwFlags
    );

VOID
updateClients(
    PCOM_PORT_INFO pComPortInfo
    );


VOID CleanupSocket(
    PCONNECTION_INFO pConn
    );


PCOM_PORT_INFO 
FindDevice(
    LPTSTR device,
    int   *pIndex
    );

NTSTATUS
AddComPort(
    PCOM_PORT_INFO pComPortInfo
    );

NTSTATUS
DeleteComPort(
    LPTSTR device
    );

LONG
GetNextParameter(
    HKEY hKey,
    DWORD dwIndex,
    PHKEY pChild,
    LPTSTR *Name
    );

LONG
GetNameOfDeviceFromRegistry(
    HKEY hKey,
    LPTSTR *device
    );

PCOM_PORT_INFO
GetComPortParameters(
    HKEY hKey
    );

VOID
FreeComPortInfo(
    PCOM_PORT_INFO pTemp
    );

VOID UpdateChanges(
    );

VOID
ServiceControlHandler(
    IN DWORD Opcode
    );

NTSTATUS
InitializeThread(
    PCOM_PORT_INFO pComPortInfo
    );

int GetBufferInfo(
    PCONNECTION_INFO pConnection,
    PCOM_PORT_INFO pComPortInfo
    );

VOID Enqueue(
    PCOM_PORT_INFO pComPortInfo
    );

int 
ComPortInfoCompare(
    PCOM_PORT_INFO com1,
    PCOM_PORT_INFO com2
    );

LONG 
TCLock(
    PHANDLE lock
    );

VOID
TCUnlock(
    HANDLE lock
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\headless\tcsrv\server\tcsrvt.c ===
/* 
 * Copyright (c) Microsoft Corporation
 * 
 * Module Name : 
 *        tcsrvt.c
 *
 * This is the main file containing the service setup routines
 * 
 * Sadagopan Rajaram -- Oct 14, 1999
 *
 */
 

#include "tcsrv.h"
#include "tcsrvc.h"
#include "proto.h"

int __cdecl
main (
    INT argc,
    CHAR **argv
    )
{
    int i;

    SERVICE_TABLE_ENTRY   DispatchTable[] = { 
        { _T("TCSERV"), ServiceEntry      }, 
        { NULL,              NULL          } 
    }; 
 
    if (!StartServiceCtrlDispatcher( DispatchTable)) 
    { 
        OutputDebugStringA(" [TCSERV] StartServiceCtrlDispatcher error"); 
    } 
    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\headless\tcsrv\server\utils.c ===
/* 
 * Copyright (c) Microsoft Corporation
 * 
 * Module Name : 
 *        utils.c
 *
 * Some utility functions used by the service. 
 * 
 * Sadagopan Rajaram -- Oct 18, 1999
 *
 */
 
 
#include "tcsrv.h"
#include <ntddser.h>
#include "tcsrvc.h"
#include "proto.h"

PCOM_PORT_INFO 
FindDevice(
    LPTSTR device,
    int *pIndex
    )
/*++
    Searches through the global list and returns the COM port with the 
    correct name
    Remember that the shared global variables are not locked during this 
    function call
--*/
{

    PCOM_PORT_INFO pTemp;

    int i=ComPorts-1;

    pTemp = ComPortInfo;
    while(pTemp){
        if(!((_tcscmp(pTemp->Device.Buffer,device)) && 
             (_tcscmp(pTemp->Name.Buffer, device))))
            break;
        pTemp = pTemp->Next;
        i--;
    }
    *pIndex = i;
    return pTemp;
}


LONG
GetNextParameter(
    HKEY hKey,
    DWORD dwIndex,
    PHKEY pChild,
    LPTSTR *Name
    )
/*++
    Gets the name of the Com Port. It is a user defined name and has nothing 
    to do with the device name in NT.   
    Return -
         A filled in Com port info, else NULL if end of Parameters is reached.
--*/ 
{

    LONG RetVal;
    // Registry names cannot be longer than 256 characters.
    TCHAR lpName[MAX_REGISTRY_NAME_SIZE];
    DWORD lpcName;
    FILETIME lpftLastWriteTime;

    lpcName = MAX_REGISTRY_NAME_SIZE;

    RetVal = RegEnumKeyEx(hKey,     
                          dwIndex,  
                          lpName,   
                          &lpcName, 
                          NULL,     
                          NULL,     
                          NULL,     
                          &lpftLastWriteTime
                          );
    if(RetVal != ERROR_SUCCESS){
        RegCloseKey(hKey);
        return RetVal;
    }

    *Name = (LPTSTR) TCAllocate(sizeof(TCHAR)*(lpcName+1),"Registry key");
    if((*Name) == NULL){
        RegCloseKey(hKey);
        return(ERROR_NOT_ENOUGH_MEMORY);
    }
    _tcscpy((*Name),lpName);
    RetVal= RegOpenKeyEx(hKey,
                         lpName,  // subkey name
                         0,   // reserved
                         KEY_ALL_ACCESS, // security access mask
                         pChild
                         );
    if(RetVal != ERROR_SUCCESS){
        RegCloseKey(hKey);
    }
    return RetVal;
}

LONG
GetNameOfDeviceFromRegistry(
    HKEY hKey,
    LPTSTR *device
    )
/*++
    Gets the NT device Name. If there is no device name, it is an error.
    
    Return-
           Device Name like L"\\device\\serial0"   
--*/
{
    LONG RetVal;
    DWORD lpType=0;
    LPTSTR lpData = NULL;
    DWORD lpcbData=0;

    RetVal = RegQueryValueEx(hKey,
                             _T("Device"),
                             NULL,  
                             &lpType,
                             (LPBYTE)lpData,
                             &lpcbData
                             );
    if((RetVal != ERROR_SUCCESS)
        &&(RetVal != ERROR_MORE_DATA)){
        RegCloseKey(hKey);
        return RetVal;
    }
    lpData = (LPTSTR) TCAllocate(lpcbData, "Device Name");
    if(lpData == NULL){
        RegCloseKey(hKey);
        return ERROR_NOT_ENOUGH_MEMORY;
    }
    RetVal = RegQueryValueEx(hKey,
                             _T("Device"),
                             NULL,  
                             &lpType,
                             (LPBYTE)lpData,
                             &lpcbData
                             );
    if(RetVal != ERROR_SUCCESS){
        RegCloseKey(hKey);
        TCFree(lpData);
        return RetVal;
    }
    *device = lpData;
    return ERROR_SUCCESS;

}

PCOM_PORT_INFO
GetComPortParameters(
    HKEY hKey
    )
{
    PCOM_PORT_INFO pComPortInfo;
    DWORD dwordsize;
    ULONG RetVal;
    DWORD data;
    
    dwordsize = sizeof(DWORD);

    pComPortInfo = (PCOM_PORT_INFO)TCAllocate(sizeof(COM_PORT_INFO),"Com Port Data");
    if(pComPortInfo== NULL){
        RegCloseKey(hKey);
        return NULL;
    }
    data = DEFAULT_BAUD_RATE;
    RetVal = RegQueryValueEx(hKey,
                             _T("Baud Rate"),
                             NULL,
                             NULL,
                             (LPBYTE) &data,
                             &(dwordsize)
                             );
    pComPortInfo->BaudRate = (ULONG) data;
    data = STOP_BIT_1;
    RetVal = RegQueryValueEx(hKey,
                             _T("Stop Bits"),
                             NULL,
                             NULL,
                             (LPBYTE) &data,
                             &(dwordsize)
                             );
    pComPortInfo->StopBits = (UCHAR) data;

    data = NO_PARITY;
    RetVal = RegQueryValueEx(hKey,
                             _T("Stop Bits"),
                             NULL,
                             NULL,
                             (LPBYTE) &data,
                             &(dwordsize)
                             );
    pComPortInfo->Parity = (UCHAR) data;

    data = SERIAL_DATABITS_8;
    RetVal = RegQueryValueEx(hKey,
                             _T("Word Length"),
                             NULL,
                             NULL,
                             (LPBYTE) &data,
                             &(dwordsize)
                             );
    pComPortInfo->WordLength = (UCHAR) data;

    return pComPortInfo;
}


VOID
FreeComPortInfo(
    PCOM_PORT_INFO pTemp
    )
{

   if(pTemp == NULL) return;
   if (pTemp->Device.Buffer) {
       TCFree(pTemp->Device.Buffer);
   }
   if(pTemp->Name.Buffer){
       TCFree(pTemp->Name.Buffer);
   }
   NtClose(pTemp->Events[1]);
   NtClose(pTemp->Events[2]);
   NtClose(pTemp->Events[3]);
   NtClose(pTemp->TerminateEvent);
   NtClose(pTemp->WriteOverlapped.hEvent);
   DeleteCriticalSection(&(pTemp->Mutex));
   TCFree(pTemp);
   return;
}

VOID Enqueue(
    PCOM_PORT_INFO pComPortInfo
    )
{
    int i,size,j,k;
    
    size = (int) pComPortInfo->Overlapped.InternalHigh;
    j = pComPortInfo->Tail;
    k = pComPortInfo->Head;
    for(i=0;i<size;i++){
        (pComPortInfo->Queue)[j] = (pComPortInfo->Buffer)[i];
        j = (j+1)% MAX_QUEUE_SIZE;
        if(k==j){
            k = (k+1)%MAX_QUEUE_SIZE;
        }
    }
    pComPortInfo->Head = k;
    pComPortInfo->Tail =j;

    return;
}

int GetBufferInfo(
    PCONNECTION_INFO pConnection,
    PCOM_PORT_INFO pComPortInfo
    )
{
    int i,size;
    int Status;
    
    size = 0;

    for(i=pComPortInfo->Head; (i != pComPortInfo->Tail ); i=(i+1)%(MAX_QUEUE_SIZE)){
        (pConnection->buffer)[size] = (pComPortInfo->Queue)[i];
        size++;
        if(size == MAX_BUFFER_SIZE){
            Status=send(pConnection->Socket, pConnection->buffer, size, 0);
            if(Status == SOCKET_ERROR){
                return Status;   
            }
            size = 0;
        }
    }
    if(size){
        Status = send(pConnection->Socket, pConnection->buffer, size, 0);
        if(Status == SOCKET_ERROR){
            return Status;
        }
    }

    return 0;
}

LONG 
TCLock(
    PHANDLE lock
    )
{
    LONG RetVal; 

    (*lock) = CreateMutex(NULL,
                          FALSE,
                          TCSERV_MUTEX_NAME
                          );
    if ((*lock)) {
       RetVal = WaitForSingleObject(*lock,INFINITE);
       if (RetVal == WAIT_FAILED) {
           return GetLastError();
       }
       else{
           return ERROR_SUCCESS;
       }
    }
    else{
        return GetLastError();
    }
}

VOID
TCUnlock(
    HANDLE lock
    )
{
    if (lock) {
        ReleaseMutex(lock);
        CloseHandle(lock);
    }
    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\headless\tcsrv\server\main.c ===
/* 
 * Copyright (c) Microsoft Corporation
 * 
 * Module Name : 
 *        main.c
 *
 * This is the main file containing the service entry and shutdown routines. 
 * Where possible, code has been obtained from BINL server.
 * 
 * Sadagopan Rajaram -- Oct 14, 1999
 *
 */
 
 
#include "tcsrv.h"
#include "tcsrvc.h"
#include "proto.h"

SERVICE_STATUS_HANDLE TCGlobalServiceStatusHandle;
SERVICE_STATUS TCGlobalServiceStatus;

VOID 
ServiceEntry(
    DWORD NumArgs,
    LPTSTR *ArgsArray
    )
/*++

Routine Description
    This is the main routine for the terminal concentrator service. After 
    initialization, the service processes requests on the main socket until 
    a terminate service has been signalled.

Arguments:
    NumArgs     - Number of strings in the ArgsArray
    ArgsArray   - String arguments
    pGlobalData - Contains the necessary global information needed to start 
                  the service

Return Value:
    None   

++*/
{
    // Initialize Status fields

    NTSTATUS status;
 
    TCGlobalServiceStatus.dwServiceType = SERVICE_WIN32_OWN_PROCESS;
    TCGlobalServiceStatus.dwCurrentState = SERVICE_START_PENDING;
    TCGlobalServiceStatus.dwControlsAccepted = SERVICE_ACCEPT_SHUTDOWN
        |SERVICE_ACCEPT_STOP
        |SERVICE_ACCEPT_PARAMCHANGE  ;
    TCGlobalServiceStatus.dwCheckPoint = 1;
    TCGlobalServiceStatus.dwWaitHint = 60000; // 60 secs.
    TCGlobalServiceStatus.dwWin32ExitCode = ERROR_SUCCESS;
    TCGlobalServiceStatus.dwServiceSpecificExitCode = 0;

  
    TCGlobalServiceStatusHandle= RegisterServiceCtrlHandler(TCSERV_NAME, 
                                                            ServiceControlHandler  
                                                            );
    if(TCGlobalServiceStatusHandle == INVALID_HANDLE_VALUE){
        return;
    }
    if(!SetServiceStatus(TCGlobalServiceStatusHandle, &TCGlobalServiceStatus)){
        return;
    }

    // Open a well known socket for the client to connect.

    INITIALIZE_TRACE_MEMORY
    MainSocket = ServerSocket();
    if(MainSocket == INVALID_SOCKET){
        // gone case . Terminate Service
        TCDebugPrint(("Cannot open Socket\n"));
        return;
    }
    
    
    // Initialize by getting control of the COM ports and starting threads 
    // for each of them.
    status = Initialize();

    if(status != STATUS_SUCCESS){
        TCDebugPrint(("Cannot Initialize\n"));
        Shutdown(status);
        return;
    }

    // Blindly loops around waiting for a request from the control socket and 
    // processes their requests.

    status = ProcessRequests(MainSocket);

    if (status != STATUS_SUCCESS){
        TCDebugPrint(("Ended with Error"));
    }

    Shutdown(status);

    return;

}


DWORD
ProcessRequests(
    SOCKET socket
    )
/*++ 
    Here we sit around waiting for connections. 
    Once we get a connection, we start a thread to get the required parameters
    and send the information to the thread processing that COM port.
--*/ 
{

    int status;
    SOCKET cli_sock;
    CLIENT_INFO ClientInfo;
    struct sockaddr_in cli_addr;
    int addr_len;
    ULONG argp;
    NTSTATUS Status;
    HANDLE ThreadHandle;
    PHANDLE NewThreads;
    ULONG ThreadID;

    status = listen(socket, SOMAXCONN);

    if (status == SOCKET_ERROR) {
        TCDebugPrint(("Cannot listen to socket %x\n",WSAGetLastError()));
        closesocket(socket);
        return (WSAGetLastError());
    }
    EnterCriticalSection(&GlobalMutex);
    if(TCGlobalServiceStatus.dwCurrentState != SERVICE_START_PENDING){
        LeaveCriticalSection(&GlobalMutex);
        return STATUS_SUCCESS;
    }
    TCGlobalServiceStatus.dwCurrentState = SERVICE_RUNNING;
    SetServiceStatus(TCGlobalServiceStatusHandle, &TCGlobalServiceStatus);
    LeaveCriticalSection(&GlobalMutex);

    while(1){
        cli_sock = accept(socket,NULL,NULL);
        if (cli_sock == INVALID_SOCKET){
            // got to shutdown - no Error here
            TCDebugPrint(("Main Socket No more %d\n",GetLastError()));
            return(STATUS_SUCCESS);
        }
        // receive the com port that the client wants to connect to.

        ThreadHandle=CreateThread(NULL,
                                  THREAD_ALL_ACCESS,
                                  (LPTHREAD_START_ROUTINE) InitializeComPortConnection,
                                  (LPVOID) cli_sock,
                                  0,
                                  &ThreadID
                                  );
        if(ThreadHandle == NULL){
            closesocket(cli_sock);
            TCDebugPrint(("Create connection Thread Failure %lx\n",GetLastError()));
        }
        else{
            NtClose(ThreadHandle);
        }
    }
    return(0);
}

DWORD
InitializeComPortConnection(
    SOCKET cli_sock
    )
{
    PCOM_PORT_INFO pTempInfo;
    PCONNECTION_INFO pConn;
    int i;
    BOOL ret;
    ULONG par;
    DWORD status;
    CLIENT_INFO ClientInfo;
    
    status = recv(cli_sock,
                  (PCHAR) &ClientInfo,
                  sizeof(CLIENT_INFO),
                  0
                  );
    if((status == SOCKET_ERROR) ||( status == 0)){
        //something wrong
        TCDebugPrint(("Receive Problem %x\n",WSAGetLastError()));
        closesocket(cli_sock);
        return 0;
    }
    ClientInfo.device[MAX_BUFFER_SIZE -1] = 0;
    EnterCriticalSection(&GlobalMutex);
    if(TCGlobalServiceStatus.dwCurrentState == SERVICE_STOP_PENDING){
        // Entire Service is shutting down.
        closesocket(cli_sock);
        LeaveCriticalSection(&GlobalMutex);
        return 1;
    }
    pTempInfo = FindDevice(ClientInfo.device, &i);
    if(!pTempInfo){
        closesocket(cli_sock);
        TCDebugPrint(("No Such Device\n"));
        LeaveCriticalSection(&GlobalMutex);
        return -1;
    }

    MutexLock(pTempInfo);
    if(pTempInfo->ShuttingDown){
        // The Com Port alone is shutting down, so 
        // make sure the socket goes away.
        closesocket(cli_sock);
        MutexRelease(pTempInfo);
        LeaveCriticalSection(&GlobalMutex);
        return -1;
    }
    pConn = TCAllocate(sizeof(CONNECTION_INFO),"New Connection");
    if(pConn == NULL){
        closesocket(cli_sock);
        MutexRelease(pTempInfo);
        LeaveCriticalSection(&GlobalMutex);
        return -1;
    }
    pConn->Socket = cli_sock;
    // Make the socket non-blocking so that receive
    // does not wait. 
    i = ioctlsocket(cli_sock,
                    FIONBIO,
                    &par
                    );
    if(i == SOCKET_ERROR){
        TCDebugPrint(("Error in setting socket parameters %d\n",GetLastError()));
    }
    pConn->pComPortInfo = pTempInfo;
    pConn->Next = pTempInfo->Sockets;
    pTempInfo->Sockets=pConn;
    pConn->Flags = ClientInfo.len;
    (pConn->Buffer).buf = pConn->buffer;
    (pConn->Buffer).len = MAX_BUFFER_SIZE;
    (pConn->Overlapped).hEvent = (WSAEVENT) pConn;
    ret = SetEvent(pTempInfo->Events[1]);
    if(ret == FALSE){
        TCDebugPrint(("Cannot signal object %d\n",GetLastError()));
    }
    MutexRelease(pTempInfo);
    LeaveCriticalSection(&GlobalMutex);
    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\headless\tcsrv\server\tcsrv.h ===
/* 
 * Copyright (c) Microsoft Corporation
 * 
 * Module Name : 
 *        tcsrv.h
 *
 * Contains the structure definitions and global variables used by the service
 *
 * Where possible, code has been obtained from BINL server.
 * 
 * Sadagopan Rajaram -- Oct 18, 1999
 *
 */

//
//  NT public header files
//
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <ntseapi.h>
#include <windows.h>
#include <winsock2.h>
#include <align.h>
#include <smbgtpt.h>
#include <dsgetdc.h>
#include <lm.h>
#include <winldap.h>
#include <dsrole.h>
#include <rpc.h>
#include <ntdsapi.h>

#include <lmcons.h>
#include <lmerr.h>
#include <lmsname.h>
#include <rpc.h>
#include <security.h>   // General definition of a Security Support Provider
#include <ntlmsp.h>
#include <spseal.h>
#include <userenv.h>
#include <setupapi.h>

//
// C Runtime library includes.
//

#include <stdlib.h>
#include <stdio.h>
#include <string.h>

//
// netlib header.
//

#include <lmcons.h>
#include <secobj.h>

//
// tcp services control hander file
//
#include <tchar.h>
#include "debug.h"

#define MAX_TERMINAL_WIDTH 80
#define MAX_BUFFER_SIZE 256
#define MAX_REGISTRY_NAME_SIZE 256
#define MAX_QUEUE_SIZE 1024
#define SAME_ALL 0
#define SAME_DEVICE 1
#define DIFFERENT_DEVICES 2
#define DIFFERENT_SESSION 4
#define DEFAULT_BAUD_RATE 9600

struct _COM_PORT_INFO;
#ifdef UNICODE
#define TSTRING UNICODE_STRING
#else
#define TSTRING ANSI_STRING
#endif
typedef struct _CONNECTION_INFO{
     SOCKET Socket;
     WSABUF Buffer;
     CHAR buffer[MAX_BUFFER_SIZE];
     DWORD BytesRecvd;
     DWORD Flags;
     IO_STATUS_BLOCK IoStatus;
     WSAOVERLAPPED Overlapped;
     struct _COM_PORT_INFO *pComPortInfo;
     struct _CONNECTION_INFO *Next;
} CONNECTION_INFO, *PCONNECTION_INFO;
 
typedef struct _COM_PORT_INFO{
    CRITICAL_SECTION Mutex;
    HANDLE Events[4];
    HANDLE ComPortHandle;
    HANDLE TerminateEvent;
    BOOLEAN ShuttingDown;
    BOOLEAN Deleted;
    TSTRING Device;
    TSTRING Name;
    ULONG BaudRate;
    UCHAR Parity;
    UCHAR StopBits;
    UCHAR WordLength;
    int Head;
    int Tail;
    int Number;
    CHAR Queue[MAX_QUEUE_SIZE];
    DWORD BytesRead;
    OVERLAPPED Overlapped;
    OVERLAPPED WriteOverlapped;
    IO_STATUS_BLOCK IoStatus;
    CHAR Buffer[MAX_BUFFER_SIZE];
    PCONNECTION_INFO Sockets;
    PCONNECTION_INFO Connections;
    struct _COM_PORT_INFO *Next;
}COM_PORT_INFO, *PCOM_PORT_INFO;

extern PCOM_PORT_INFO ComPortInfo;

extern int ComPorts;

extern PHANDLE Threads;

extern SOCKET MainSocket;

extern WSAEVENT TerminateService;

extern CRITICAL_SECTION GlobalMutex;

extern SERVICE_STATUS_HANDLE TCGlobalServiceStatusHandle;

extern SERVICE_STATUS TCGlobalServiceStatus;

#define MutexLock(x) EnterCriticalSection(&(x->Mutex))
#define MutexRelease(x) LeaveCriticalSection(&(x->Mutex))
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\headless\tcsrv\server\unlo.c ===
/* 
 * Copyright (c) Microsoft Corporation
 *         
 * Module Name : 
 *             unlo.c
 *         
 * Shut down and delete functions
 * Where possible, code has been obtained from BINL server.
 *         
 * Sadagopan Rajaram -- Oct 14, 1999
 *         
 */        
 
#include "tcsrv.h"
#include <ntddser.h>
#include "tcsrvc.h"
#include "proto.h"

NTSTATUS
DeleteComPort(
    LPTSTR device
    )
/*++ 
    Deletes a Com port from the list 
--*/
{

    BOOL ret;
    NTSTATUS Status;
    PCOM_PORT_INFO pPrev,pComPortInfo;
    HANDLE Thread;
    int index,i;

    EnterCriticalSection(&GlobalMutex);
    if(TCGlobalServiceStatus.dwCurrentState == SERVICE_STOP_PENDING){
        // Entire Service is shutting down.
        LeaveCriticalSection(&GlobalMutex);
        return STATUS_SUCCESS;
    }   // find the device needed to be deleted.
    pComPortInfo = FindDevice(device,&index); 
    if(!pComPortInfo){
        // Bah ! give me an existing device.
        LeaveCriticalSection(&GlobalMutex);
        return (STATUS_OBJECT_NAME_NOT_FOUND);
    }
    // Set the terminate event on the com port.
    ret = SetEvent(pComPortInfo->Events[3]);
    Thread = Threads[index];
    LeaveCriticalSection(&GlobalMutex);
    // wait for the com port thread to finish.
    Status = NtWaitForSingleObject(Thread, FALSE, NULL);
    if (Status == WAIT_FAILED) {
        // catastrophe
        return Status;
    }
    EnterCriticalSection(&GlobalMutex);
    // do this again as another delete or insert may have 
    // changed the index, though how is beyond me :-) 
    // if we are already shutting down the service.
    if(TCGlobalServiceStatus.dwCurrentState == SERVICE_STOP_PENDING){
        // Entire Service is shutting down.
        LeaveCriticalSection(&GlobalMutex);
        return STATUS_SUCCESS;
    }
    pComPortInfo = FindDevice(device,&index);
    if(!pComPortInfo){
        LeaveCriticalSection(&GlobalMutex);
        return (STATUS_OBJECT_NAME_NOT_FOUND);
    }
    if(pComPortInfo == ComPortInfo){
        ComPortInfo = pComPortInfo->Next;
    }
    else{
        pPrev = ComPortInfo;
        while(pPrev->Next != pComPortInfo){// Can never fail
            pPrev = pPrev->Next;
        }
        pPrev->Next = pComPortInfo->Next;
    }
    pComPortInfo->Next = NULL;
    FreeComPortInfo(pComPortInfo);
    NtClose(Threads[index]);
    for(i=index;i<ComPorts-1;i++){
        // move the threads array to the proper place
        Threads[i]=Threads[i+1];
    }
    ComPorts --;
    if(ComPorts == 0){
        TCFree(Threads);
        Threads=NULL;
    }
    LeaveCriticalSection(&GlobalMutex);
    return(STATUS_SUCCESS);

}

VOID 
Shutdown(
    NTSTATUS Status
    )
/*++
    Cleanly shut down the service. delete all threads, cancel all outstanding IRPs.
    Close all open sockets. 
--*/ 
{
    PCOM_PORT_INFO pTemp;
    int i;

    SetEvent(TerminateService); // all threads down
    // Can do this another way,
    // We can take each comport device and
    // delete it using the DeleteComPort 
    // function. But, this allows for maximum 
    // parallelism even in shutting down :-)

    if(Threads){
        WaitForMultipleObjects(ComPorts,Threads, TRUE, INFINITE); 
        // BUGBUG - what if thread is a rougue thread and
        // never comes back. Must use some reasonable
        // time out. 
        // Theory says INFINITE is the safest :-)
    }
    
    //All threads terminated.
    // Now start freeing all global memory
    // just using the locks as a safety measure.
    EnterCriticalSection(&GlobalMutex);
    while(ComPortInfo){
        pTemp = ComPortInfo;
        ComPortInfo=pTemp->Next;
        pTemp->Next = NULL;
        FreeComPortInfo(pTemp);

    }
    TCFree(Threads);         
    NtClose(TerminateService);
    LeaveCriticalSection(&GlobalMutex);

    UNINITIALIZE_TRACE_MEMORY
    //All done, now print status and exit.
    TCGlobalServiceStatus.dwCurrentState = SERVICE_STOPPED;
    SetServiceStatus(TCGlobalServiceStatusHandle, &TCGlobalServiceStatus);

    TCDebugPrint(("Shutdown Status = %lx\n",Status));
    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\headless\test\c\dmpfast\dmpfast.c ===
#include <windows.h>
#include <winioctl.h>
#include <stdio.h>
#include <malloc.h>
 
void NewLine(void); 
void ScrollScreenBuffer(HANDLE, INT); 
 
#define MyErrorExit

HANDLE _ScreenHandle; 
CONSOLE_SCREEN_BUFFER_INFO csbiInfo; 
 
void __cdecl wmain(void) 
{ 
    COORD   CursorPosition;
    WCHAR chBuffer[256]; 
    DWORD cRead, cWritten, fdwMode, fdwOldMode; 
    WORD wOldColorAttrs; 
    ULONG   i;
    HANDLE  _ScreenHandle;

    // Get handles to STDIN and STDOUT. 
    _ScreenHandle = CreateFile( (LPWSTR)L"CONOUT$",
                                GENERIC_READ | GENERIC_WRITE,
                                0,
                                NULL,
                                OPEN_EXISTING,
                                0,
                                NULL );


#if 0
    CursorPosition.Y = 24;
    CursorPosition.X = 1;
    SetConsoleCursorPosition( _ScreenHandle, CursorPosition );
#endif

    while (1) 
    { 
        for (i = 0; i < 100; i++) {
            
            wsprintf(chBuffer, L"%d percent completed, bob.                              \r", i);

            if (! WriteConsole( 
                _ScreenHandle,              // output handle 
                chBuffer,          // prompt string 
                wcslen(chBuffer), // string length 
                &cWritten,            // bytes written 
                NULL) )               // not overlapped 
            {
                break; 
            }
        }
    } 

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\headless\test\c\sources.inc ===
!IF 0

Copyright (c) 1989  Microsoft Corporation

Module Name:

    sources.

Abstract:

    This file specifies the target component being built and the list of
    sources files needed to build that component.  Also specifies optional
    compiler switches and libraries that are unique for the component being
    built.


Author:

    Steve Wood (stevewo) 12-Apr-1990

NOTE:   Commented description of this file is in \nt\bak\bin\sources.tpl

!ENDIF

MAJORCOMP=drivers
MINORCOMP=sac

#USE_VCCOM=1
#USE_NTDLL=1
USE_MSVCRT=1
#USE_NATIVE_EH=ASYNC
UMENTRY=wmain
UMTYPE=console

!include $(PROJECT_ROOT)\headless\lib\sources.inc

TARGETPATH=obj
TARGETTYPE=PROGRAM
TARGETLIBS=\
        $(SDK_LIB_PATH)\user32.lib    \
        $(SDK_LIB_PATH)\libc.lib    \
        $(SDK_LIB_PATH)\kernel32.lib \
        $(BASE_SAC_UMODE_C_API_LIB)    \
        $(SDK_LIB_PATH)\ntdll.lib

INCLUDES=\
         $(BASE_INC_PATH);\
         $(DRIVERS_INC_PATH);\
	 $(DDK_INC_PATH);\
         $(SDK_INC_PATH);\
         $(BASE_SAC_UMODE_C_API_INC)
                   
#C_DEFINES= $(C_DEFINES) -D_WINDOWS -DWIN32 -D_WIN32 -DUNICODE -D_UNICODE -DDBG
C_DEFINES= $(C_DEFINES) -DUNICODE -D_UNICODE

MSC_WARNING_LEVEL=/W3 /WX
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\headless\test\c\sachello\sachello.c ===
#include <windows.h>
#include <winioctl.h>
#include <stdio.h>
#include <malloc.h>
#include <Shlwapi.h>

#include <ntddsac.h>

#include <sacapi.h>

int _cdecl wmain(int argc, WCHAR **argv)
{
    SAC_CHANNEL_OPEN_ATTRIBUTES Attributes;
    SAC_CHANNEL_HANDLE          SacChannelHandle;
    int                         c;

    //
    // Configure the new channel
    //
    RtlZeroMemory(&Attributes, sizeof(SAC_CHANNEL_OPEN_ATTRIBUTES));

    Attributes.Type             = ChannelTypeVTUTF8;
    
    wnsprintf(
        Attributes.Name,
        SAC_MAX_CHANNEL_NAME_LENGTH+1,
        L"Hello"
        );
    wnsprintf(
        Attributes.Description,
        SAC_MAX_CHANNEL_DESCRIPTION_LENGTH+1,
        L"Hello"
        );
    Attributes.Flags            = 0;
    Attributes.CloseEvent       = NULL;
    Attributes.HasNewDataEvent  = NULL;

    //
    // Open the Hello channel
    //
    if (SacChannelOpen(
        &SacChannelHandle, 
        &Attributes
        )) {
        printf("Successfully opened new channel\n");
    } else {
        printf("Failed to open new channel\n");
        goto cleanup;
    }

    //
    // Write to the Hello Channel
    //
    {
        PWCHAR String = L"Hello, World!\r\n";

        if (SacChannelVTUTF8WriteString(
            SacChannelHandle, 
            String
            )) {
            printf("Successfully printed string to channel\n");
        } else {
            printf("Failed to print string to channel\n");
        }
        
    }

    //
    // Wait for user input
    //
    getc(stdin);

    //
    // Close the Hello Channel
    //
    if (SacChannelClose(&SacChannelHandle)) {
        printf("Successfully closed channel\n");
    } else {
        printf("Failed to close channel\n");
    }

cleanup:

    return 0;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\headless\test\c\sacsec\sacsec.c ===
#include <windows.h>
#include <winioctl.h>
#include <stdio.h>
#include <malloc.h>
#include <Shlwapi.h>

#include <ntddsac.h>

#include <sacapi.h>

int _cdecl wmain(int argc, WCHAR **argv)
{
    HANDLE  SacHandle;
    BOOL    Status;
    
    //
    // Open the SAC
    //
    // SECURITY:
    //
    //  this handle cannot be inherited
    //
    SacHandle = CreateFile(
        L"\\\\.\\SAC\\",
        0x1F01FF,
        0,
        NULL,
        OPEN_EXISTING,
        0,
        NULL 
        );

    if (SacHandle == INVALID_HANDLE_VALUE) {

        Status = FALSE;

    } 

    return 0;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\headless\test\c\sacstress\common\sacstress.c ===
#include <sacstress.h>

PWSTR
GenerateRandomStringW(
    IN ULONG    Length
    )
/*++

Routine Description:

    This routine generates a random alpha string of Length.

    Note: caller is responsible for freeing the allocated random string                                    
                                        
Arguments:

    Length - the length of the new string
                 
Return Value:

    The random string             
                 
--*/
{
    ULONG   i;
    PWSTR   String;
    ULONG   Size;

    //
    // Determine the byte count
    //
    Size = (Length + 1) * sizeof(WCHAR);

    //
    // allocate and init the random string
    //
    String = malloc(Size);

    if (String == NULL) {
        return String;
    }

    RtlZeroMemory(String, Size);

    //
    // Generate our random string
    //
    for (i = 0; i < Length; i++) {

        String[i] = (WCHAR)('A' + GET_RANDOM_NUMBER(26));
        
    }

    return String;
}

PSTR
GenerateRandomStringA(
    IN ULONG    Length
    )
/*++

Routine Description:

    This routine generates a random alpha string of Length.

    Note: caller is responsible for freeing the allocated random string                                    
                                        
Arguments:

    Length - the length of the new string
                 
Return Value:

    The random string             
                 
--*/
{
    ULONG   i;
    PSTR    String;
    ULONG   Size;

    //
    // Determine the byte count
    //
    Size = (Length + 1) * sizeof(UCHAR);

    //
    // allocate and init the random string
    //
    String = malloc(Size);

    if (String == NULL) {
        return String;
    }

    RtlZeroMemory(String, Size);

    //
    // Generate our random string
    //
    for (i = 0; i < Length; i++) {

        String[i] = (UCHAR)('A' + GET_RANDOM_NUMBER(26));
        
    }

    return String;
}

int
RunStress(
    IN CHANNEL_STRESS_THREAD    *ChannelTests,
    IN ULONG                    ChannelTestCount
    )
/*++

Routine Description:

    This routine runs ChannelTestCount threads which apply stress.

Arguments:
    
    ChannelTests        - function pointers to the stress threads
    ChannelTestCount    - # of stress threads
                                                                      
Return Value:

    status

--*/
{
    HANDLE              Channel[THREADCOUNT];
    CHANNEL_THREAD_DATA ChannelData[THREADCOUNT];
    HANDLE              ExitEvent;
    ULONG               i;

    //
    // Create the thread exit event
    //
    ExitEvent = CreateEvent( 
        NULL,         // no security attributes
        TRUE,         // manual-reset event
        FALSE,        // initial state is signaled
        NULL          // object name
        ); 

    if (ExitEvent == NULL) { 
        return 1;
    }

    //
    // Randomize
    //
    srand( (unsigned)time( NULL ) ); 

    //
    // create the worker threads
    //
    for (i = 0; i < THREADCOUNT; i++) {
        
        //
        // populate the thread data structure
        //
        
        ChannelData[i].ThreadId = i;
        ChannelData[i].ExitEvent = ExitEvent;

        //
        // create the thread
        //
        
        Channel[i] = CreateThread(
            NULL,
            0,
            ChannelTests[i],
            &(ChannelData[i]),
            0,
            NULL
            );

        if (Channel[i] == NULL) {
            goto cleanup;
        }

    }

    //
    // wait for local user to end the stress
    //
    getc(stdin);

cleanup:

    SetEvent(ExitEvent);

    WaitForMultipleObjects(
        THREADCOUNT,
        Channel,
        TRUE,
        INFINITE
        );

    for (i = 0; i < THREADCOUNT; i++) {
        CloseHandle(Channel[i]);
    }

    return 0;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\headless\test\c\sacspoof\sacspoof.c ===
#include <windows.h>
#include <winioctl.h>
#include <stdio.h>
#include <malloc.h>
#include <Shlwapi.h>

#include <ntddsac.h>

#include <sacapi.h>

typedef struct _BYTEWISE_UUID {

    ULONG   a;
    USHORT  b;
    USHORT  c;
    UCHAR   e[8];

} BYTEWISE_UUID, *PBYTEWISE_UUID;


int htoi( 
    char    *c
    )
{
    unsigned int result;
    
    (void) sscanf( (char *) c, "%x", &result );
    
    return result;
}

ULONG
AtoGUID(
    IN  WCHAR *s,
    OUT GUID  *g
    )
/*

Description:

    translate the given string representation of a GUID into a real GUID.

    expected string format:
    
    37a9b260-525d-11d6-870c-806d6172696f

Args:

    s - the string to translate
    g - on success, the returned guid
    
Return:

    1 - success
    0 - true    

*/
{
    ULONG           l;
    PBYTEWISE_UUID  p;
    ULONG           x;
    ULONG           y;

    l = wcslen(s);

    if (l != (16*2 + 4)) {
        return 0;
    }

    p = (PBYTEWISE_UUID)g;

    x = 0;
    y = 0;

    RtlZeroMemory(p, sizeof(BYTEWISE_UUID));

    p->a |= htoi((char *)&s[y++]) << 28; 
    p->a |= htoi((char *)&s[y++]) << 24;
    
    p->a |= htoi((char *)&s[y++]) << 20; 
    p->a |= htoi((char *)&s[y++]) << 16;

    p->a |= htoi((char *)&s[y++]) << 12; 
    p->a |= htoi((char *)&s[y++]) << 8;

    p->a |= htoi((char *)&s[y++]) << 4; 
    p->a |= htoi((char *)&s[y++]) << 0;

    // skip -
    y++;

    p->b |= htoi((char *)&s[y++]) << 12; 
    p->b |= htoi((char *)&s[y++]) << 8;
    
    p->b |= htoi((char *)&s[y++]) << 4; 
    p->b |= htoi((char *)&s[y++]) << 0;

    // skip -
    y++;
    
    p->c |= htoi((char *)&s[y++]) << 12; 
    p->c |= htoi((char *)&s[y++]) << 8;
    
    p->c |= htoi((char *)&s[y++]) << 4; 
    p->c |= htoi((char *)&s[y++]) << 0;

    // skip -
    y++;
    x = 0;

    p->e[x] |= htoi((char *)&s[y++]) << 4; 
    p->e[x] |= htoi((char *)&s[y++]) << 0; x++;

    p->e[x] |= htoi((char *)&s[y++]) << 4; 
    p->e[x] |= htoi((char *)&s[y++]) << 0; x++;
    
    // skip -
    y++;
    
    p->e[x] |= htoi((char *)&s[y++]) << 4; 
    p->e[x] |= htoi((char *)&s[y++]) << 0; x++;

    p->e[x] |= htoi((char *)&s[y++]) << 4; 
    p->e[x] |= htoi((char *)&s[y++]) << 0; x++;

    p->e[x] |= htoi((char *)&s[y++]) << 4; 
    p->e[x] |= htoi((char *)&s[y++]) << 0; x++;

    p->e[x] |= htoi((char *)&s[y++]) << 4; 
    p->e[x] |= htoi((char *)&s[y++]) << 0; x++;
    
    p->e[x] |= htoi((char *)&s[y++]) << 4; 
    p->e[x] |= htoi((char *)&s[y++]) << 0; x++;

    p->e[x] |= htoi((char *)&s[y++]) << 4; 
    p->e[x] |= htoi((char *)&s[y++]) << 0; x++;

    //

    wprintf(L"s = %s, g = %06x-%04x-%04x-%02x%02x-%02x%02x%02x%02x%02x%02x\r\n", 
            s,
            p->a, 
            p->b,
            p->c,
            p->e[0],
            p->e[1],
            p->e[2],
            p->e[3],
            p->e[4],
            p->e[5],
            p->e[6],
            p->e[7]
            );

    return 1;
}

int _cdecl wmain(int argc, WCHAR **argv)
{
    SAC_CHANNEL_OPEN_ATTRIBUTES Attributes;
    SAC_CHANNEL_HANDLE          SacChannelHandle;
    int                         c;

    //
    // Configure the new channel
    //
    RtlZeroMemory(&Attributes, sizeof(SAC_CHANNEL_OPEN_ATTRIBUTES));

    Attributes.Type             = ChannelTypeVTUTF8;
    
    wnsprintf(
        Attributes.Name,
        SAC_MAX_CHANNEL_NAME_LENGTH+1,
        L"Spoofer"
        );
    wnsprintf(
        Attributes.Description,
        SAC_MAX_CHANNEL_DESCRIPTION_LENGTH+1,
        L"Spoofer"
        );
    Attributes.Flags            = 0;
    Attributes.CloseEvent       = NULL;
    Attributes.HasNewDataEvent  = NULL;

    //
    // Open the Hello channel
    //
    if (SacChannelOpen(
        &SacChannelHandle, 
        &Attributes
        )) {
        printf("Successfully opened new channel\n");
    } else {
        printf("Failed to open new channel\n");
        goto cleanup;
    }

    //
    // tweak the sac channel handle to have the guid we specified at the 
    // command prompt
    //
    printf("driverhandle = %p\r\n", SacChannelHandle.DriverHandle);
    {
        ULONG   x;
        PBYTEWISE_UUID  p;

        p = (PBYTEWISE_UUID)&(SacChannelHandle.ChannelHandle);
        
        wprintf(L"g = %06x-%04x-%04x-%02x%02x-%02x%02x%02x%02x%02x%02x\r\n", 
                p->a, 
                p->b,
                p->c,
                p->e[0],
                p->e[1],
                p->e[2],
                p->e[3],
                p->e[4],
                p->e[5],
                p->e[6],
                p->e[7]
                );
    
    }

    AtoGUID(argv[1], &(SacChannelHandle.ChannelHandle));

    printf("driverhandle = %p\r\n", SacChannelHandle.DriverHandle);
    {
        ULONG   x;
        PBYTEWISE_UUID  p;

        p = (PBYTEWISE_UUID)&(SacChannelHandle.ChannelHandle);
        
        wprintf(L"g = %06x-%04x-%04x-%02x%02x-%02x%02x%02x%02x%02x%02x\r\n", 
                p->a, 
                p->b,
                p->c,
                p->e[0],
                p->e[1],
                p->e[2],
                p->e[3],
                p->e[4],
                p->e[5],
                p->e[6],
                p->e[7]
                );
    
    }
    
    //
    // Write to the Hello Channel
    //
    {
        PWCHAR String = L"Hello, World!\r\n";

        if (SacChannelVTUTF8WriteString(
            SacChannelHandle, 
            String
            )) {
            printf("Successfully printed string to channel\n");
        } else {
            printf("Failed to print string to channel\n");
        }
        
    }

    //
    // Wait for user input
    //
    getc(stdin);

    //
    // Close the Hello Channel
    //
    if (SacChannelClose(&SacChannelHandle)) {
        printf("Successfully closed channel\n");
    } else {
        printf("Failed to close channel\n");
    }

cleanup:
    
    return 0;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\headless\test\c\sacstress\sacraw\sacraw.c ===
#include <sacstress.h>

DWORD
ChannelThreadRawWrite(
    PVOID   Data
    )
{
    SAC_CHANNEL_OPEN_ATTRIBUTES Attributes;
    SAC_CHANNEL_HANDLE          SacChannelHandle;
    PCHANNEL_THREAD_DATA        ChannelThreadData;
    DWORD                       Status;
    ULONG                       i;
    PUCHAR                      Buffer;
    BOOL                        bContinue;
    ULONG                       k;
    PWSTR                       Name;
    PWSTR                       Description;
    BOOL                        bSuccess;

    ChannelThreadData = (PCHANNEL_THREAD_DATA)Data;
    
    //
    // Perform thread work
    //
    bContinue = TRUE;

    while (bContinue) {

        //
        // See if we need to exit the thread
        //
        Status = WaitForSingleObject(
            ChannelThreadData->ExitEvent,
            THREAD_WAIT_TIMEOUT
            );

        if (Status != WAIT_TIMEOUT) {
            bContinue = FALSE;
            continue;
        } 
        
        //
        // Configure the new channel
        //
        RtlZeroMemory(&Attributes, sizeof(SAC_CHANNEL_OPEN_ATTRIBUTES));

        //
        // generate a random name and description
        //
        // Note: we make the maxlength > than the allowed to test the driver, etc.
        //
        Name = GenerateRandomStringW(GET_RANDOM_NUMBER(SAC_MAX_CHANNEL_NAME_LENGTH*2));
        Description = GenerateRandomStringW(GET_RANDOM_NUMBER(SAC_MAX_CHANNEL_DESCRIPTION_LENGTH*2));

        Attributes.Type             = ChannelTypeRaw;
        Attributes.Name             = Name;
        Attributes.Description      = Description;
        Attributes.Flags            = 0;
        Attributes.CloseEvent       = NULL;
        Attributes.HasNewDataEvent  = NULL;
        Attributes.ApplicationType  = NULL;

        //
        // Open the channel
        //
        bSuccess = SacChannelOpen(
            &SacChannelHandle, 
            &Attributes
            );
        
        //
        // We are done with the random strings
        //
        free(Name);
        free(Description);
        
        if (bSuccess) {
            printf("%d: Successfully opened new channel\n", ChannelThreadData->ThreadId);
        } else {
            printf("%d: Failed to open new channel\n", ChannelThreadData->ThreadId);
            continue;
        }

        //
        // randomly determine how long we'll loop
        //
        k = GET_RANDOM_NUMBER(MAX_ITER_COUNT);

        //
        // Generate a random string of random length to send
        //
        Buffer = GenerateRandomStringA(k);          

        do {

            //
            // Write the entire string first so a test app can compare the following output
            //
            bSuccess = SacChannelRawWrite(
                SacChannelHandle, 
                Buffer,
                k * sizeof(UCHAR)
                );

            if (!bSuccess) {
                printf("%d: Failed to print string to channel\n", ChannelThreadData->ThreadId);
                bContinue = FALSE;
                break;
            }

            //
            // Loop and write
            //
            for (i = 0; i < k; i++) {

                //
                // See if we need to exit the thread
                //
                Status = WaitForSingleObject(
                    ChannelThreadData->ExitEvent,
                    THREAD_WAIT_TIMEOUT
                    );

                if (Status != WAIT_TIMEOUT) {
                    bContinue = FALSE;
                    break;
                } 

                //
                // Write to the channel
                //
                bSuccess = SacChannelRawWrite(
                    SacChannelHandle, 
                    Buffer,
                    i * sizeof(UCHAR)
                    );

                if (!bSuccess) {
                    printf("%d: Failed to print string to channel\n", ChannelThreadData->ThreadId);
                    bContinue = FALSE;
                    break;
                }

                //
                // Write to the channel
                //
                bSuccess = SacChannelRawWrite(
                    SacChannelHandle, 
                    "\r\n",
                    strlen("\r\n") * sizeof(UCHAR)
                    );

                if (!bSuccess) {
                    printf("%d: Failed to print string to channel\n", ChannelThreadData->ThreadId);
                    bContinue = FALSE;
                    break;
                }

            }

        } while ( FALSE );
        
        //
        // Release the random string
        //
        free(Buffer);

        //
        // Close the channel
        //
        if (SacChannelClose(&SacChannelHandle)) {
            printf("%d: Successfully closed channel\n", ChannelThreadData->ThreadId);
        } else {
            bContinue = FALSE;
            printf("%d: Failed to close channel\n", ChannelThreadData->ThreadId);
        }

    }

    return 0;

}

DWORD (*ChannelTests[THREADCOUNT])(PVOID) = {
    ChannelThreadRawWrite,
    ChannelThreadRawWrite,
    ChannelThreadRawWrite,
    ChannelThreadRawWrite,
    ChannelThreadRawWrite,
    ChannelThreadRawWrite,
    ChannelThreadRawWrite,
    ChannelThreadRawWrite,
    ChannelThreadRawWrite,
    ChannelThreadRawWrite,
    ChannelThreadRawWrite,
    ChannelThreadRawWrite,
    ChannelThreadRawWrite,
    ChannelThreadRawWrite,
    ChannelThreadRawWrite,
    ChannelThreadRawWrite,
};

int _cdecl 
wmain(
    int argc, 
    WCHAR **argv
    )
{

    return RunStress(
        ChannelTests,
        THREADCOUNT
        );

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\headless\test\c\sacloop\sacloop.c ===
#include <windows.h>
#include <winioctl.h>
#include <stdio.h>
#include <malloc.h>

#include <ntddsac.h>

#include <sacapi.h>

#include <assert.h>

#define THREADCOUNT 2
#define THREAD_WAIT_TIMEOUT 50

enum { 
    EXIT_EVENT = WAIT_OBJECT_0,
    CHANNEL_CLOSE_EVENT,
    CHANNEL_HAS_NEW_DATA_EVENT
    };

typedef struct _CHANNEL_THREAD_DATA {

    HANDLE  ExitEvent;
    HANDLE  HasNewDataEvent;
    HANDLE  CloseEvent;

    WCHAR   ChannelName[SAC_MAX_CHANNEL_NAME_LENGTH];
    WCHAR   ChannelDescription[SAC_MAX_CHANNEL_DESCRIPTION_LENGTH];

    SAC_CHANNEL_HANDLE      SacChannelHandle;

} CHANNEL_THREAD_DATA, *PCHANNEL_THREAD_DATA;
                
DWORD
ChannelThreadRawWrite(
    PVOID   Data
    )
{
    PCHANNEL_THREAD_DATA    ChannelThreadData;
    DWORD                   Status;
    BOOL                    bContinue;
    DWORD                   dwRetVal;
    UCHAR                   Buffer[0x1000];
    ULONG                   BufferSize;
    HANDLE                  handles[2];
    ULONG                   i;
    ULONG                   k;
    HANDLE                  hFile;

    ChannelThreadData = (PCHANNEL_THREAD_DATA)Data;

    //
    // Create destination file for read data
    //
    hFile = CreateFile(
        L"sacloop.in",
        GENERIC_READ,                // open for writing 
        0,                            // do not share 
        NULL,                         // no security 
        OPEN_EXISTING,                // overwrite existing 
        FILE_ATTRIBUTE_NORMAL,        // normal file 
        NULL);                        // no attr. template 
     
    if (hFile == INVALID_HANDLE_VALUE) 
    { 
        return 0;
    } 

    //
    // Perform thread work
    //
    
    handles[0] = ChannelThreadData->ExitEvent;
    handles[1] = ChannelThreadData->CloseEvent;

    bContinue = TRUE;

    while (bContinue) {

        dwRetVal = WaitForMultipleObjects(
            sizeof(handles)/sizeof(handles[0]), 
            handles, 
            FALSE, 
            THREAD_WAIT_TIMEOUT
            );
        
        switch( dwRetVal )
        {
        
        case EXIT_EVENT:
        case CHANNEL_CLOSE_EVENT:
            // close
            bContinue = FALSE;
            break;
        
        case WAIT_TIMEOUT:
            
            //
            // write Channel::stdout
            //
            
            bContinue = ReadFile(
                hFile, 
                &Buffer, 
                1, 
                &BufferSize, 
                NULL
                ); 
            
            if (bContinue) {

                bContinue = SacChannelRawWrite(
                    ChannelThreadData->SacChannelHandle,
                    Buffer,
                    BufferSize
                    );

            }
            
            break;

        default:
            break;
        }
    
    }

    CloseHandle(hFile);
    
    return 0;

}

DWORD
ChannelThreadRawRead(
    PVOID   Data
    )
{
    PCHANNEL_THREAD_DATA    ChannelThreadData;
    DWORD                   Status;
    BOOL                    bContinue;
    DWORD                   dwRetVal;
    UCHAR                   Buffer[0x1000];
    ULONG                   BufferSize;
    HANDLE                  handles[3];
    HANDLE                  hFile;

    ChannelThreadData = (PCHANNEL_THREAD_DATA)Data;

    //
    // Create destination file for read data
    //
    hFile = CreateFile(
        L"sacloop.out",
        GENERIC_WRITE,                // open for writing 
        0,                            // do not share 
        NULL,                         // no security 
        CREATE_ALWAYS,                // overwrite existing 
        FILE_ATTRIBUTE_NORMAL,        // normal file 
        NULL);                        // no attr. template 
     
    if (hFile == INVALID_HANDLE_VALUE) 
    { 
        return 0;
    } 
    
    //
    // Perform thread work
    //
    
    handles[0]                 = ChannelThreadData->ExitEvent;
    handles[1]        = ChannelThreadData->CloseEvent;
    handles[2] = ChannelThreadData->HasNewDataEvent;

    bContinue = TRUE;

    while (bContinue) {

        dwRetVal = WaitForMultipleObjects(
            sizeof(handles)/sizeof(handles[0]), 
            handles, 
            FALSE, 
            INFINITE
            );
        
        switch( dwRetVal )
        {
        
        case EXIT_EVENT:
        case CHANNEL_CLOSE_EVENT:
            // close
            bContinue = FALSE;
            break;
        
        case CHANNEL_HAS_NEW_DATA_EVENT:

            //
            // read Channel::stdin
            //
            bContinue = SacChannelRead(
                ChannelThreadData->SacChannelHandle,
                (PUCHAR)Buffer,
                sizeof(Buffer),
                &BufferSize
                );
            
            if (bContinue) {

                DWORD   dwBytesWritten;

                bContinue = WriteFile(
                    hFile, 
                    Buffer, 
                    BufferSize, 
                    &dwBytesWritten, 
                    NULL
                    ); 

            }

            break;

        default:
            break;
        }

    
    }

    CloseHandle(hFile);

    return 0;

}

DWORD (*ChannelTests[THREADCOUNT])(PVOID) = {
    ChannelThreadRawWrite,
    ChannelThreadRawRead
};

int _cdecl 
wmain(
    int argc, 
    WCHAR **argv
    )
{
    SAC_CHANNEL_OPEN_ATTRIBUTES Attributes;
    HANDLE                      Channel[THREADCOUNT];
    CHANNEL_THREAD_DATA         ChannelData;
    ULONG                       i;

    ChannelData.ExitEvent       = CreateEvent( NULL, TRUE, FALSE, NULL );
    ChannelData.CloseEvent      = CreateEvent( NULL, TRUE, FALSE, NULL );
    ChannelData.HasNewDataEvent = CreateEvent( NULL, TRUE, FALSE, NULL );
    
    swprintf(
        ChannelData.ChannelDescription,
        L"simsess test channel"
        );
    
    swprintf(
        ChannelData.ChannelName,
        L"simsess"
        );

    //
    // Configure the new channel
    //
    RtlZeroMemory(&Attributes, sizeof(SAC_CHANNEL_OPEN_ATTRIBUTES));

    Attributes.Type             = ChannelTypeRaw;
    Attributes.Name             = ChannelData.ChannelName;
    Attributes.Description      = ChannelData.ChannelDescription;
    Attributes.Flags            = SAC_CHANNEL_FLAG_HAS_NEW_DATA_EVENT | SAC_CHANNEL_FLAG_CLOSE_EVENT;
    Attributes.CloseEvent       = ChannelData.CloseEvent;
    Attributes.HasNewDataEvent  = ChannelData.HasNewDataEvent;
    Attributes.ApplicationType  = NULL;
    
    //
    // Open the channel
    //
    if (SacChannelOpen(
        &ChannelData.SacChannelHandle, 
        &Attributes
        )) {
        printf("Successfully opened new channel\n");
    } else {
        printf("Failed to open new channel\n");
        goto cleanup;
    }

    //
    // create the worker threads
    //
    for (i = 0; i < THREADCOUNT; i++) {
        
        //
        // create the thread
        //
        
        Channel[i] = CreateThread(
            NULL,
            0,
            ChannelTests[i],
            &ChannelData,
            0,
            NULL
            );

        if (Channel[i] == NULL) {
            goto cleanup;
        }

    }

    //
    // wait for local user to end the stress
    //
    getc(stdin);

cleanup:

    SetEvent(ChannelData.ExitEvent);

    WaitForMultipleObjects(
        THREADCOUNT,
        Channel,
        TRUE,
        INFINITE
        );

    for (i = 0; i < THREADCOUNT; i++) {
        CloseHandle(Channel[i]);
    }

    SacChannelClose(&ChannelData.SacChannelHandle);

    return 0;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\headless\test\c\sacstress\common\sacstress.h ===
#include <windows.h>
#include <winioctl.h>
#include <stdio.h>
#include <malloc.h>
#include <time.h>
#include <ntddsac.h>

#include <sacapi.h>

#include <assert.h>
#include <stdlib.h>

//
// General stress constants
//
#define THREADCOUNT 16
#define THREAD_WAIT_TIMEOUT 2

#define MAX_STRING_LENGTH 2048
#define MAX_ITER_COUNT  2000
                                
//
// Random # generator
//
#define GET_RANDOM_NUMBER(_k) ((rand()*((DWORD) _k))/RAND_MAX)

//
// Function type of stress threads
//
typedef DWORD (*CHANNEL_STRESS_THREAD)(PVOID);

//
// Structure passed to each stress thread
//
typedef struct _CHANNEL_THREAD_DATA {

    ULONG               ThreadId;
    HANDLE              ExitEvent;
    
} CHANNEL_THREAD_DATA, *PCHANNEL_THREAD_DATA;
    
//
// Prototypes
//
PWSTR
GenerateRandomStringW(
    IN ULONG    Length
    );

PSTR
GenerateRandomStringA(
    IN ULONG    Length
    );

int
RunStress(
    IN CHANNEL_STRESS_THREAD    *ChannelTests,
    IN ULONG                    ChannelTestCount
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\headless\test\c\sacstress\sacoc\sacoc.c ===
#include <sacstress.h>

DWORD
ChannelThreadOpenClose(
    PVOID   Data
    )
{
    SAC_CHANNEL_OPEN_ATTRIBUTES Attributes;
    SAC_CHANNEL_HANDLE          SacChannelHandle;
    PCHANNEL_THREAD_DATA        ChannelThreadData;
    DWORD                       Status;
    ULONG                       i;
    PUCHAR                      Buffer;
    BOOL                        bContinue;
    ULONG                       k;
    PWSTR                       Name;
    PWSTR                       Description;
    BOOL                        bSuccess;

    ChannelThreadData = (PCHANNEL_THREAD_DATA)Data;
    
    //
    // Perform thread work
    //
    bContinue = TRUE;

    while (bContinue) {

        //
        // See if we need to exit the thread
        //
        Status = WaitForSingleObject(
            ChannelThreadData->ExitEvent,
            THREAD_WAIT_TIMEOUT
            );

        if (Status != WAIT_TIMEOUT) {
            bContinue = FALSE;
            continue;
        } 
        
        //
        // Configure the new channel
        //
        RtlZeroMemory(&Attributes, sizeof(SAC_CHANNEL_OPEN_ATTRIBUTES));

        //
        // generate a random name and description
        //
        // Note: we make the maxlength > than the allowed to test the driver, etc.
        //
        Name = GenerateRandomStringW(SAC_MAX_CHANNEL_NAME_LENGTH*2);
        Description = GenerateRandomStringW(SAC_MAX_CHANNEL_DESCRIPTION_LENGTH*2);

        Attributes.Type             = ChannelTypeRaw;
        Attributes.Name             = Name;
        Attributes.Description      = Description;
        Attributes.Flags            = 0;
        Attributes.CloseEvent       = NULL;
        Attributes.HasNewDataEvent  = NULL;
        Attributes.ApplicationType  = NULL;

        //
        // Open the channel
        //
        bSuccess = SacChannelOpen(
            &SacChannelHandle, 
            &Attributes
            );
        
        //
        // We are done with the random strings
        //
        free(Name);
        free(Description);
        
        if (bSuccess) {
            printf("%S: Successfully opened new channel\n", Attributes.Name);
        } else {
            printf("%S: Failed to open new channel\n", Attributes.Name);
            continue;
        }

        //
        // Close the channel
        //
        if (SacChannelClose(&SacChannelHandle)) {
            printf("%S: Successfully closed channel\n", Attributes.Name);
        } else {
            bContinue = FALSE;
            printf("%S: Failed to close channel\n", Attributes.Name);
        }

    }

    return 0;

}

DWORD (*ChannelTests[THREADCOUNT])(PVOID) = {
    ChannelThreadOpenClose,
    ChannelThreadOpenClose,
    ChannelThreadOpenClose,
    ChannelThreadOpenClose,
    ChannelThreadOpenClose,
    ChannelThreadOpenClose,
    ChannelThreadOpenClose,
    ChannelThreadOpenClose,
    ChannelThreadOpenClose,
    ChannelThreadOpenClose,
    ChannelThreadOpenClose,
    ChannelThreadOpenClose,
    ChannelThreadOpenClose,
    ChannelThreadOpenClose,
    ChannelThreadOpenClose,
    ChannelThreadOpenClose,
};

int _cdecl 
wmain(
    int argc, 
    WCHAR **argv
    )
{

    return RunStress(
        ChannelTests,
        THREADCOUNT
        );

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\headless\test\c\sacstress\sacvtutf8\sacvtutf8.c ===
#include <sacstress.h>

DWORD
ChannelThreadVTUTF8Write(
    PVOID   Data
    )
{
    SAC_CHANNEL_OPEN_ATTRIBUTES Attributes;
    SAC_CHANNEL_HANDLE          SacChannelHandle;
    PCHANNEL_THREAD_DATA        ChannelThreadData;
    DWORD                       Status;
    ULONG                       i;
    PWCHAR                      Buffer;
    BOOL                        bContinue;
    ULONG                       k;
    PWSTR                       Name;
    PWSTR                       Description;
    BOOL                        bSuccess;

    ChannelThreadData = (PCHANNEL_THREAD_DATA)Data;

    //
    // Perform thread work
    //
    bContinue = TRUE;

    while (bContinue) {

        //
        // See if we need to exit the thread
        //
        Status = WaitForSingleObject(
            ChannelThreadData->ExitEvent,
            THREAD_WAIT_TIMEOUT
            );

        if (Status != WAIT_TIMEOUT) {
            bContinue = FALSE;
            continue;
        } 
        
        //
        // Configure the new channel
        //
        RtlZeroMemory(&Attributes, sizeof(SAC_CHANNEL_OPEN_ATTRIBUTES));

        //
        // generate a random name and description
        //
        // Note: we make the maxlength > than the allowed to test the driver, etc.
        //
        Name = GenerateRandomStringW(GET_RANDOM_NUMBER(SAC_MAX_CHANNEL_NAME_LENGTH*2));
        Description = GenerateRandomStringW(GET_RANDOM_NUMBER(SAC_MAX_CHANNEL_DESCRIPTION_LENGTH*2));

        Attributes.Type             = ChannelTypeVTUTF8;
        Attributes.Name             = Name;
        Attributes.Description      = Description;
        Attributes.Flags            = 0;
        Attributes.CloseEvent       = NULL;
        Attributes.HasNewDataEvent  = NULL;
        Attributes.ApplicationType  = NULL;

        //
        // Open the channel
        //
        bSuccess = SacChannelOpen(
            &SacChannelHandle, 
            &Attributes
            );
        
        //
        // We are done with the random strings
        //
        free(Name);
        free(Description);
        
        if (bSuccess) {
            printf("%d: Successfully opened new channel\n", ChannelThreadData->ThreadId);
        } else {
            printf("%d: Failed to open new channel\n", ChannelThreadData->ThreadId);
            continue;
        }

        //
        // randomly determine how long we'll loop
        //
        k = GET_RANDOM_NUMBER(MAX_ITER_COUNT);

        //
        // Generate a random string of random length to send
        //
        Buffer = GenerateRandomStringW(k);          

        do {

            //
            // Write the entire string first so a test app can compare the following output
            //
            bSuccess = SacChannelVTUTF8Write(
                SacChannelHandle, 
                Buffer,
                k * sizeof(WCHAR)
                );

            if (!bSuccess) {
                printf("%d: Failed to print string to channel\n", ChannelThreadData->ThreadId);
                bContinue = FALSE;
                break;
            }

            //
            // Loop and write
            //
            for (i = 0; i < k; i++) {

                //
                // See if we need to exit the thread
                //
                Status = WaitForSingleObject(
                    ChannelThreadData->ExitEvent,
                    THREAD_WAIT_TIMEOUT
                    );

                if (Status != WAIT_TIMEOUT) {
                    bContinue = FALSE;
                    break;
                } 

                //
                // Write to the channel
                //
                bSuccess = SacChannelVTUTF8Write(
                    SacChannelHandle, 
                    Buffer,
                    i * sizeof(WCHAR)
                    );

                if (!bSuccess) {
                    printf("%d: Failed to print string to channel\n", ChannelThreadData->ThreadId);
                    bContinue = FALSE;
                    break;
                }

                //
                // Write to the channel
                //
                bSuccess = SacChannelVTUTF8WriteString(
                    SacChannelHandle, 
                    L"\r\n"
                    );

                if (!bSuccess) {
                    printf("%d: Failed to print string to channel\n", ChannelThreadData->ThreadId);
                    bContinue = FALSE;
                    break;
                }

            }

        } while ( FALSE );
        
        //
        // Release the random string
        //
        free(Buffer);

        //
        // Close the channel
        //
        if (SacChannelClose(&SacChannelHandle)) {
            printf("%d: Successfully closed channel\n", ChannelThreadData->ThreadId);
        } else {
            bContinue = FALSE;
            printf("%d: Failed to close channel\n", ChannelThreadData->ThreadId);
        }

    }

    return 0;

}

//
// Define our tests
//
DWORD (*ChannelTests[THREADCOUNT])(PVOID) = {
    ChannelThreadVTUTF8Write,
    ChannelThreadVTUTF8Write,
    ChannelThreadVTUTF8Write,
    ChannelThreadVTUTF8Write,
    ChannelThreadVTUTF8Write,
    ChannelThreadVTUTF8Write,
    ChannelThreadVTUTF8Write,
    ChannelThreadVTUTF8Write,
    ChannelThreadVTUTF8Write,
    ChannelThreadVTUTF8Write,
    ChannelThreadVTUTF8Write,
    ChannelThreadVTUTF8Write,
    ChannelThreadVTUTF8Write,
    ChannelThreadVTUTF8Write,
    ChannelThreadVTUTF8Write,
    ChannelThreadVTUTF8Write,
};

int _cdecl 
wmain(
    int argc, 
    WCHAR **argv
    )
{

    return RunStress(
        ChannelTests,
        THREADCOUNT
        );

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\headless\test\c\simsess\simsess.c ===
#include <windows.h>
#include <winioctl.h>
#include <stdio.h>
#include <malloc.h>

#include <ntddsac.h>

#include <sacapi.h>

#include <assert.h>

#define THREADCOUNT 2
#define THREAD_WAIT_TIMEOUT 50

enum { 
    EXIT_EVENT = WAIT_OBJECT_0,
    CHANNEL_CLOSE_EVENT,
    CHANNEL_HAS_NEW_DATA_EVENT
    };

typedef struct _CHANNEL_THREAD_DATA {

    HANDLE  ExitEvent;
    HANDLE  HasNewDataEvent;
    HANDLE  CloseEvent;

    WCHAR   ChannelName[SAC_MAX_CHANNEL_NAME_LENGTH];
    WCHAR   ChannelDescription[SAC_MAX_CHANNEL_DESCRIPTION_LENGTH];

    SAC_CHANNEL_HANDLE      SacChannelHandle;

} CHANNEL_THREAD_DATA, *PCHANNEL_THREAD_DATA;
                
DWORD
ChannelThreadVTUTF8Write(
    PVOID   Data
    )
{
    PCHANNEL_THREAD_DATA    ChannelThreadData;
    DWORD                   Status;
    BOOL                    bContinue;
    DWORD                   dwRetVal;
    WCHAR                   Buffer[0x1000];
    ULONG                   BufferSize;
    HANDLE                  handles[2];
    ULONG                   i;
    ULONG                   k;

    ChannelThreadData = (PCHANNEL_THREAD_DATA)Data;

    //
    // Perform thread work
    //
    
    handles[0] = ChannelThreadData->ExitEvent;
    handles[1] = ChannelThreadData->CloseEvent;

    bContinue = TRUE;
    k = 0;

    while (bContinue) {

        dwRetVal = WaitForMultipleObjects(
            sizeof(handles)/sizeof(handles[0]), 
            handles, 
            FALSE, 
            100
            );
        
        switch( dwRetVal )
        {
        
        case EXIT_EVENT:
        case CHANNEL_CLOSE_EVENT:
            // close
            bContinue = FALSE;
            break;
        
        case WAIT_TIMEOUT:
            
            for (i = 0; i < 24; i++) {

                //
                //
                //
                swprintf(
                    Buffer,
                    L"%08d:abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuv\r\n",
                    k++
                    );

                //
                // Write to the Channel
                //
                if (SacChannelVTUTF8Write(
                    ChannelThreadData->SacChannelHandle, 
                    Buffer,
                    wcslen(Buffer)*sizeof(WCHAR)
                    )
                    ) {
                } else {
                    printf("%S: Failed to print string to channel\n", ChannelThreadData->ChannelName);
                    break;
                }

            }
            
            break;

        default:
            break;
        }

    
    }

    return 0;

}

DWORD
ChannelThreadVTUTF8Read(
    PVOID   Data
    )
{
    PCHANNEL_THREAD_DATA    ChannelThreadData;
    DWORD                   Status;
    BOOL                    bContinue;
    DWORD                   dwRetVal;
    WCHAR                   Buffer[0x1000];
    ULONG                   BufferSize;
    HANDLE                  handles[2];

    ChannelThreadData = (PCHANNEL_THREAD_DATA)Data;

    //
    // Perform thread work
    //
    
    handles[0] = ChannelThreadData->ExitEvent;
    handles[1] = ChannelThreadData->CloseEvent;

    bContinue = TRUE;

    while (bContinue) {

        dwRetVal = WaitForMultipleObjects(
            sizeof(handles)/sizeof(handles[0]), 
            handles, 
            FALSE, 
            INFINITE
            );
        
        switch( dwRetVal )
        {
        
        case EXIT_EVENT:
        case CHANNEL_CLOSE_EVENT:
            // close
            bContinue = FALSE;
            break;
        
        case WAIT_TIMEOUT:

            //
            // read Channel::stdin
            //
            bContinue = SacChannelRead(
                ChannelThreadData->SacChannelHandle,
                (PUCHAR)Buffer,
                sizeof(Buffer),
                &BufferSize
                );
            
            break;

        default:
            break;
        }

    
    }

    return 0;

}

DWORD (*ChannelTests[THREADCOUNT])(PVOID) = {
    ChannelThreadVTUTF8Write,
    ChannelThreadVTUTF8Read
};

int _cdecl 
wmain(
    int argc, 
    WCHAR **argv
    )
{
    SAC_CHANNEL_OPEN_ATTRIBUTES Attributes;
    HANDLE                      Channel[THREADCOUNT];
    CHANNEL_THREAD_DATA         ChannelData;
    ULONG                       i;

    ChannelData.ExitEvent       = CreateEvent( NULL, FALSE, FALSE, NULL );
    ChannelData.CloseEvent      = CreateEvent( NULL, FALSE, FALSE, NULL );
    
    ChannelData.HasNewDataEvent = CreateEvent( NULL, TRUE, FALSE, NULL );
    
    swprintf(
        ChannelData.ChannelDescription,
        L"simsess test channel"
        );
    
    swprintf(
        ChannelData.ChannelName,
        L"simsess"
        );

    //
    // Configure the new channel
    //
    RtlZeroMemory(&Attributes, sizeof(SAC_CHANNEL_OPEN_ATTRIBUTES));

    Attributes.Type             = ChannelTypeVTUTF8;
    Attributes.Name             = ChannelData.ChannelName;
    Attributes.Description      = ChannelData.ChannelDescription;
    Attributes.Flags            = SAC_CHANNEL_FLAG_HAS_NEW_DATA_EVENT | SAC_CHANNEL_FLAG_CLOSE_EVENT;
    Attributes.CloseEvent       = ChannelData.CloseEvent;
    Attributes.HasNewDataEvent  = ChannelData.HasNewDataEvent;
    Attributes.ApplicationType  = NULL;
    
    //
    // Open the channel
    //
    if (SacChannelOpen(
        &ChannelData.SacChannelHandle, 
        &Attributes
        )) {
        printf("Successfully opened new channel\n");
    } else {
        printf("Failed to open new channel\n");
        goto cleanup;
    }

    //
    // create the worker threads
    //
    for (i = 0; i < THREADCOUNT; i++) {
        
        //
        // create the thread
        //
        
        Channel[i] = CreateThread(
            NULL,
            0,
            ChannelTests[i],
            &ChannelData,
            0,
            NULL
            );

        if (Channel[i] == NULL) {
            goto cleanup;
        }

    }

    //
    // wait for local user to end the stress
    //
    getc(stdin);

cleanup:

    SetEvent(ChannelData.ExitEvent);

    WaitForMultipleObjects(
        THREADCOUNT,
        Channel,
        TRUE,
        INFINITE
        );

    for (i = 0; i < THREADCOUNT; i++) {
        CloseHandle(Channel[i]);
    }

    return 0;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\headless\test\cpp\emsecho\emsecho.cpp ===
#include <windows.h>
#include <winioctl.h>
#include <stdio.h>
#include <malloc.h>

#include <ntddsac.h>

#include <emsapi.h>

#define THREAD_WAIT_TIMEOUT    100
#define THREADCOUNT 2

typedef struct _CHANNEL_THREAD_DATA {

    HANDLE              ExitEvent;
    
    WCHAR               ChannelName[SAC_MAX_CHANNEL_NAME_LENGTH];
    WCHAR               ChannelDescription[SAC_MAX_CHANNEL_DESCRIPTION_LENGTH];

} CHANNEL_THREAD_DATA, *PCHANNEL_THREAD_DATA;
                
DWORD
ChannelThreadVTUTF8Echo(
    PVOID   Data
    )
{
    EMSVTUTF8Channel*        Channel;
    PCHANNEL_THREAD_DATA    ChannelThreadData;
    DWORD                   Status;
    ULONG                   i;
    WCHAR                   Buffer[256];
    ULONG                   ByteCount;
    BOOL                    bStatus;
    BOOL                    InputWaiting;

    ChannelThreadData = (PCHANNEL_THREAD_DATA)Data;

    SAC_CHANNEL_OPEN_ATTRIBUTES Attributes;

    //
    // Configure the new channel
    //
    RtlZeroMemory(&Attributes, sizeof(SAC_CHANNEL_OPEN_ATTRIBUTES));
    
    Attributes.Type             = ChannelTypeVTUTF8;
    Attributes.Name             = ChannelThreadData->ChannelName;
    Attributes.Description      = ChannelThreadData->ChannelDescription;
    Attributes.Flags            = 0;
    Attributes.CloseEvent       = NULL;
    Attributes.HasNewDataEvent  = NULL;
    Attributes.ApplicationType  = NULL;
    
    //
    // Open the Hello channel
    //
    Channel = EMSVTUTF8Channel::Construct(Attributes);

    //
    // See if the channel was created
    //
    if (Channel == NULL) {
        return 0;
    }

    //
    // Perform thread work
    //

    i=0;

    while (1) {

        Status = WaitForSingleObject(
            ChannelThreadData->ExitEvent,
            THREAD_WAIT_TIMEOUT
            );

        if (Status != WAIT_TIMEOUT) {
            break;
        } 

        //
        // See if there is data to echo
        //
        bStatus = Channel->HasNewData(&InputWaiting);

        if (InputWaiting) {

            //
            // Read from channel
            //
            bStatus = Channel->Read(
                Buffer,
                sizeof(Buffer),
                &ByteCount
                );

            if (bStatus) {
                
                //
                // Echo to the channel
                //
                bStatus = Channel->Write(
                    Buffer,
                    ByteCount
                    );
                if (! bStatus) {
                    printf("%S: Failed to print string to channel\n", ChannelThreadData->ChannelName);
                }
            
            } else {
                printf("%S: Failed to print string to channel\n", ChannelThreadData->ChannelName);
            }

        }
    
    }

    delete Channel;

    return 0;

}

DWORD
ChannelThreadRawEcho(
    PVOID   Data
    )
{
    EMSRawChannel*          Channel;
    PCHANNEL_THREAD_DATA    ChannelThreadData;
    DWORD                   Status;
    ULONG                   i;
    BYTE                    Buffer[256];
    ULONG                   ByteCount;
    BOOL                    bStatus;
    BOOL                    InputWaiting;

    ChannelThreadData = (PCHANNEL_THREAD_DATA)Data;

    SAC_CHANNEL_OPEN_ATTRIBUTES Attributes;

    //
    // Configure the new channel
    //
    RtlZeroMemory(&Attributes, sizeof(SAC_CHANNEL_OPEN_ATTRIBUTES));
    
    Attributes.Type             = ChannelTypeRaw;
    Attributes.Name             = ChannelThreadData->ChannelName;
    Attributes.Description      = ChannelThreadData->ChannelDescription;
    Attributes.Flags            = 0;
    Attributes.CloseEvent       = NULL;
    Attributes.HasNewDataEvent  = NULL;
    Attributes.ApplicationType  = NULL;
    
    //
    // Open the Hello channel
    //
    Channel = EMSRawChannel::Construct(Attributes);

    //
    // See if the channel was created
    //
    if (Channel == NULL) {
        return 0;
    }

    //
    // Perform thread work
    //

    i=0;

    while (1) {

        Status = WaitForSingleObject(
            ChannelThreadData->ExitEvent,
            THREAD_WAIT_TIMEOUT
            );

        if (Status != WAIT_TIMEOUT) {
            break;
        } 

        //
        // See if there is data to echo
        //
        bStatus = Channel->HasNewData(&InputWaiting);

        if (InputWaiting) {

            //
            // Read from channel
            //
            bStatus = Channel->Read(
                Buffer,
                sizeof(Buffer),
                &ByteCount
                );

            if (bStatus) {
                
                //
                // Echo to the channel
                //
                bStatus = Channel->Write(
                    Buffer,
                    ByteCount
                    );
                if (! bStatus) {
                    printf("%S: Failed to print string to channel\n", ChannelThreadData->ChannelName);
                }
            
            } else {
                printf("%S: Failed to print string to channel\n", ChannelThreadData->ChannelName);
            }

        }
    
    }

    delete Channel;

    return 0;

}

DWORD (*ChannelTests[THREADCOUNT])(PVOID) = {
    ChannelThreadVTUTF8Echo,
    ChannelThreadRawEcho
};

int _cdecl 
wmain(
    int argc, 
    WCHAR **argv
    )
{
    HANDLE              Channel[THREADCOUNT];
    CHANNEL_THREAD_DATA ChannelData[THREADCOUNT];
    HANDLE              ExitEvent;
    ULONG               i;

    ExitEvent = CreateEvent( 
        NULL,         // no security attributes
        TRUE,         // manual-reset event
        FALSE,        // initial state is signaled
        NULL          // object name
        ); 

    if (ExitEvent == NULL) { 
        return 1;
    }

    //
    // create the worker threads
    //
    for (i = 0; i < THREADCOUNT; i++) {
        
        //
        // populate the thread data structure
        //
        
        ChannelData[i].ExitEvent = ExitEvent;
        wsprintf(
            ChannelData[i].ChannelName,
            L"CT%02d",
            i
            );
        ChannelData[i].ChannelDescription[0] = UNICODE_NULL;

        //
        // create the thread
        //
        
        Channel[i] = CreateThread(
            NULL,
            0,
            ChannelTests[i],
            &(ChannelData[i]),
            0,
            NULL
            );

        if (Channel[i] == NULL) {
            goto cleanup;
        }

    }

    //
    // wait for local user to end the stress
    //
    getc(stdin);

cleanup:

    SetEvent(ExitEvent);

    WaitForMultipleObjects(
        THREADCOUNT,
        Channel,
        TRUE,
        INFINITE
        );

    for (i = 0; i < THREADCOUNT; i++) {
        CloseHandle(Channel[i]);
    }

    return 0;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\headless\test\cpp\sources.inc ===
!IF 0

Copyright (c) 1989  Microsoft Corporation

Module Name:

    sources.

Abstract:

    This file specifies the target component being built and the list of
    sources files needed to build that component.  Also specifies optional
    compiler switches and libraries that are unique for the component being
    built.


Author:

    Steve Wood (stevewo) 12-Apr-1990

NOTE:   Commented description of this file is in \nt\bak\bin\sources.tpl

!ENDIF

MAJORCOMP=drivers
MINORCOMP=sac

#USE_VCCOM=1
#USE_NTDLL=1
USE_MSVCRT=1
#USE_NATIVE_EH=ASYNC
UMENTRY=wmain
UMTYPE=console

!include $(PROJECT_ROOT)\headless\lib\sources.inc

TARGETPATH=obj
TARGETTYPE=PROGRAM
TARGETLIBS=\
        $(SDK_LIB_PATH)\user32.lib    \
        $(SDK_LIB_PATH)\libc.lib    \
        $(SDK_LIB_PATH)\kernel32.lib \
        $(SDK_LIB_PATH)\ntdll.lib       \
        $(BASE_SAC_UMODE_C_API_LIB)    \
        $(BASE_SAC_UMODE_CPP_API_LIB)    

INCLUDES=$(BASE_SAC_UMODE_C_API_INC);\
         $(BASE_SAC_UMODE_CPP_API_INC);\
         $(BASE_INC_PATH);\
         $(DRIVERS_INC_PATH);\
	 $(DDK_INC_PATH);\
         $(SDK_INC_PATH);
                   
#C_DEFINES= $(C_DEFINES) -D_WINDOWS -DWIN32 -D_WIN32 -DUNICODE -D_UNICODE -DDBG
C_DEFINES= $(C_DEFINES) -DUNICODE -D_UNICODE

MSC_WARNING_LEVEL=/W3 /WX
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\headless\test\cpuhog\cpuhog.c ===
#include <windows.h>
#include <stdio.h>
#include <conio.h>
#include <stdlib.h>


#define TOTAL_COUNT (100000000)


//
// DON'T UNCOMMENT THIS LINE UNTIL YOU'RE READY
// TO RUN THE WHOLE TEST.  YOU WON'T BE ABLE TO
// BREAK IN UNTIL THE TEST ENDS!!!
//
#define GO_FOREVER (1)

#define MAX_MEMORY  (256)


DWORD
MyWorkerThread(
    PVOID   ThreadParameter
    )
/*++

    Pretend to be busy.

--*/
{
ULONG   i;
PVOID   TmpPtr = NULL;
ULONG   MemorySize;


#ifdef GO_FOREVER
    while( 1 ) {
#else
    for( i = 0; i < TOTAL_COUNT; i++ ) {
#endif

        MemorySize = rand() % MAX_MEMORY;
    }
    
    return 0;
}


int
__cdecl
main( int   argc, char *argv[])
{
ULONG   i;
DWORD   ThreadId;
SYSTEM_INFO SystemInfo;
HANDLE  MyHandle;
HANDLE  *HandlePtr = NULL;


    printf( "This program is for testing purposes only.\n" );
    printf( "It is designed to consume all available CPU cycles.\n" );
    printf( "\n" );
    printf( "IT WILL RENDER YOUR SYSTEM UNRESPONSIVE!\n" );
    printf( "\n" );
    printf( "Press the '+' key to continue, or any other key to exit.\n" );
    if( _getch() != '+' ) {
        printf( "Exiting...\n" );
        return;
    }
    

    printf( "working..." );


    //
    // Figure out how many CPUs we have.  We'll want to create a thread
    // for each one so that there is no available resources.
    //
    GetSystemInfo( &SystemInfo );

    //
    // Allocate an array of handles for each one of the processors.
    //
    HandlePtr = (HANDLE *)malloc( sizeof(HANDLE) * SystemInfo.dwNumberOfProcessors );
    if( HandlePtr == NULL ) {
        printf( "We failed to allocate any memory.\n" );
        return;
    }


    //
    // Let this guy get lots of CPU time.
    //
    if (!SetPriorityClass(GetCurrentProcess(),REALTIME_PRIORITY_CLASS)) {
        printf("Failed to raise to realtime priority\n");
    }



    //
    // Now go create a bunch of threads so that we tie up all available time
    // on all CPUs.
    //
    for( i = 0; i < SystemInfo.dwNumberOfProcessors; i++ ) {
        HandlePtr[i] = CreateThread( NULL,
                                     0,
                                     MyWorkerThread,
                                     UIntToPtr( i ),
                                     CREATE_SUSPENDED,
                                     &ThreadId );

        if( HandlePtr[i] != NULL ) {
             SetThreadPriority( HandlePtr[i],
                                THREAD_PRIORITY_TIME_CRITICAL );
            ResumeThread( HandlePtr[i] );
        }
    }


    //
    // Now wait for them to finish.
    //
    WaitForMultipleObjects( SystemInfo.dwNumberOfProcessors,
                            HandlePtr,
                            TRUE,
                            INFINITE );

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\headless\test\cpp\emsstress\emsstress.cpp ===
#include <windows.h>
#include <winioctl.h>
#include <stdio.h>
#include <malloc.h>

#include <ntddsac.h>

#include <emsapi.h>

#include <new.h>

#define THREADCOUNT 16
#define THREAD_WAIT_TIMEOUT 10

typedef struct _CHANNEL_THREAD_DATA {

    HANDLE              ExitEvent;
    
    WCHAR               ChannelName[SAC_MAX_CHANNEL_NAME_LENGTH];
    WCHAR               ChannelDescription[SAC_MAX_CHANNEL_DESCRIPTION_LENGTH];

} CHANNEL_THREAD_DATA, *PCHANNEL_THREAD_DATA;
                
DWORD
ChannelThreadVTUTF8Write(
    PVOID   Data
    )
{
    EMSVTUTF8Channel*        Channel;
    PCHANNEL_THREAD_DATA    ChannelThreadData;
    DWORD                   Status;
    ULONG                   i;
    WCHAR                   Buffer[256];


    ChannelThreadData = (PCHANNEL_THREAD_DATA)Data;

    SAC_CHANNEL_OPEN_ATTRIBUTES Attributes;

    //
    // Configure the new channel
    //
    RtlZeroMemory(&Attributes, sizeof(SAC_CHANNEL_OPEN_ATTRIBUTES));

    Attributes.Type             = ChannelTypeVTUTF8;
    Attributes.Name             = ChannelThreadData->ChannelName;
    Attributes.Description      = ChannelThreadData->ChannelDescription;
    Attributes.Flags            = 0;
    Attributes.CloseEvent       = NULL;
    Attributes.HasNewDataEvent  = NULL;
    Attributes.LockEvent        = NULL;
    Attributes.ApplicationType  = NULL;

    //
    // Open the Hello channel
    //
    Channel = EMSVTUTF8Channel::Construct(Attributes);

    //
    // See if the channel was created
    //
    if (Channel == NULL) {
        return 0;
    }

    //
    // Perform thread work
    //

    i=0;

    while (1) {

        Status = WaitForSingleObject(
            ChannelThreadData->ExitEvent,
            THREAD_WAIT_TIMEOUT
            );

        if (Status != WAIT_TIMEOUT) {
            break;
        } 

        wsprintf(
            Buffer,
            L"%s: %d\r\n",
            ChannelThreadData->ChannelName,
            i++
            );

        //
        // Write to the Hello Channel
        //
        if (Channel->Write(Buffer)) {
#if 0
            printf("%S: Successfully printed string to channel\n", ChannelThreadData->ChannelName);
#endif        
        } else {
            printf("%S: Failed to print string to channel\n", ChannelThreadData->ChannelName);
        }
    
    }

    delete Channel;

    return 0;

}

DWORD
ChannelThreadRawWrite(
    PVOID   Data
    )
{
    EMSRawChannel*          Channel;
    PCHANNEL_THREAD_DATA    ChannelThreadData;
    DWORD                   Status;
    ULONG                   i;
    BYTE                    Buffer[256];


    ChannelThreadData = (PCHANNEL_THREAD_DATA)Data;

    SAC_CHANNEL_OPEN_ATTRIBUTES Attributes;

    //
    // Configure the new channel
    //
    RtlZeroMemory(&Attributes, sizeof(SAC_CHANNEL_OPEN_ATTRIBUTES));
    
    Attributes.Type             = ChannelTypeRaw;
    Attributes.Name             = ChannelThreadData->ChannelName;
    Attributes.Description      = ChannelThreadData->ChannelDescription;
    Attributes.Flags            = 0;
    Attributes.CloseEvent       = NULL;
    Attributes.HasNewDataEvent  = NULL;
    Attributes.LockEvent        = NULL;
    Attributes.ApplicationType  = NULL;
    
    //
    // Open the Hello channel
    //
    Channel = EMSRawChannel::Construct(Attributes);

    //
    // See if the channel was created
    //
    if (Channel == NULL) {
        return 0;
    }

    //
    // Perform thread work
    //

    i=0;

    while (1) {

        Status = WaitForSingleObject(
            ChannelThreadData->ExitEvent,
            THREAD_WAIT_TIMEOUT
            );

        if (Status != WAIT_TIMEOUT) {
            break;
        } 

        sprintf(
            (CHAR*)Buffer,
            "%S: %d\r\n",
            ChannelThreadData->ChannelName,
            i++
            );

        //
        // Write to the Hello Channel
        //
        if (Channel->Write(
                Buffer,
                strlen((CHAR*)Buffer)
                )) {
#if 0
            printf("%S: Successfully printed string to channel\n", ChannelThreadData->ChannelName);
#endif        
        } else {
            printf("%S: Failed to print string to channel\n", ChannelThreadData->ChannelName);
        }
    
    }

    delete Channel;

    return 0;

}

DWORD
ChannelThreadOpenCloseVTUTF8(
    PVOID   Data
    )
{
    EMSRawChannel*          Channel;
    PCHANNEL_THREAD_DATA    ChannelThreadData;
    DWORD                   Status;
    ULONG                   i;

    ChannelThreadData = (PCHANNEL_THREAD_DATA)Data;

    SAC_CHANNEL_OPEN_ATTRIBUTES Attributes;

    //
    // Configure the new channel
    //
    RtlZeroMemory(&Attributes, sizeof(SAC_CHANNEL_OPEN_ATTRIBUTES));
    
    Attributes.Type             = ChannelTypeVTUTF8;
    Attributes.Name             = ChannelThreadData->ChannelName;
    Attributes.Description      = ChannelThreadData->ChannelDescription;
    Attributes.Flags            = 0;
    Attributes.CloseEvent       = NULL;
    Attributes.HasNewDataEvent  = NULL;
    Attributes.LockEvent        = NULL;
    Attributes.ApplicationType  = NULL;

    //
    // Perform thread work
    //

    i=0;

    while (1) {

        Status = WaitForSingleObject(
            ChannelThreadData->ExitEvent,
            THREAD_WAIT_TIMEOUT
            );

        if (Status != WAIT_TIMEOUT) {
            break;
        } 

        //
        // Open the Hello channel
        //
        Channel = EMSRawChannel::Construct(Attributes);

        //
        // See if the channel was created
        //
        if (Channel == NULL) {
            continue;
        }
        
        delete Channel;

    }

    return 0;

}

DWORD
ChannelThreadOpenCloseRaw(
    PVOID   Data
    )
{
    EMSRawChannel*          Channel;
    PCHANNEL_THREAD_DATA    ChannelThreadData;
    DWORD                   Status;
    ULONG                   i;

    ChannelThreadData = (PCHANNEL_THREAD_DATA)Data;

    SAC_CHANNEL_OPEN_ATTRIBUTES Attributes;

    RtlZeroMemory(&Attributes, sizeof(SAC_CHANNEL_OPEN_ATTRIBUTES));
    
    //
    // Configure the new channel
    //
    Attributes.Type             = ChannelTypeRaw;
    Attributes.Name             = ChannelThreadData->ChannelName;
    Attributes.Description      = ChannelThreadData->ChannelDescription;
    Attributes.Flags            = 0;
    Attributes.CloseEvent       = NULL;
    Attributes.HasNewDataEvent  = NULL;
    Attributes.LockEvent        = NULL;
    Attributes.ApplicationType  = NULL;

    //
    // Perform thread work
    //

    i=0;

    while (1) {

        Status = WaitForSingleObject(
            ChannelThreadData->ExitEvent,
            THREAD_WAIT_TIMEOUT
            );

        if (Status != WAIT_TIMEOUT) {
            break;
        } 

        //
        // Open the Hello channel
        //
        Channel = EMSRawChannel::Construct(Attributes);

        //
        // See if the channel was created
        //
        if (Channel == NULL) {
            continue;
        }
        
        delete Channel;

    }

    return 0;

}

DWORD (*ChannelTests[THREADCOUNT])(PVOID) = {
    ChannelThreadVTUTF8Write,
    ChannelThreadVTUTF8Write,
    ChannelThreadVTUTF8Write,
    ChannelThreadVTUTF8Write,
    ChannelThreadRawWrite,
    ChannelThreadRawWrite,
    ChannelThreadRawWrite,
    ChannelThreadRawWrite,
    ChannelThreadOpenCloseRaw,
    ChannelThreadOpenCloseRaw,
    ChannelThreadOpenCloseRaw,
    ChannelThreadOpenCloseRaw,
    ChannelThreadOpenCloseVTUTF8,
    ChannelThreadOpenCloseVTUTF8,
    ChannelThreadOpenCloseVTUTF8,
    ChannelThreadOpenCloseVTUTF8
};

int __cdecl
NoMoreMemory( 
    size_t 
    )
{
    DebugBreak();
    
    OutputDebugString(L"EMS Stress: NoMoreMemory!!\r\n");

    ExitProcess( 1 );
}

int _cdecl 
wmain(
    int argc, 
    WCHAR **argv
    )
{
    HANDLE              Channel[THREADCOUNT];
    CHANNEL_THREAD_DATA ChannelData[THREADCOUNT];
    HANDLE              ExitEvent;
    ULONG               i;

    _set_new_handler( NoMoreMemory );
    
    ExitEvent = CreateEvent( 
        NULL,         // no security attributes
        TRUE,         // manual-reset event
        FALSE,        // initial state is signaled
        NULL          // object name
        ); 

    if (ExitEvent == NULL) { 
        return 1;
    }

    //
    // create the worker threads
    //
    for (i = 0; i < THREADCOUNT; i++) {
        
        //
        // populate the thread data structure
        //
        
        ChannelData[i].ExitEvent = ExitEvent;
        wsprintf(
            ChannelData[i].ChannelName,
            L"CT%02d",
            i
            );
        ChannelData[i].ChannelDescription[0] = UNICODE_NULL;

        //
        // create the thread
        //
        
        Channel[i] = CreateThread(
            NULL,
            0,
            ChannelTests[i],
            &(ChannelData[i]),
            0,
            NULL
            );

        if (Channel[i] == NULL) {
            goto cleanup;
        }

    }

    //
    // wait for local user to end the stress
    //
    getc(stdin);

cleanup:

    SetEvent(ExitEvent);

    WaitForMultipleObjects(
        THREADCOUNT,
        Channel,
        TRUE,
        INFINITE
        );

    for (i = 0; i < THREADCOUNT; i++) {
        CloseHandle(Channel[i]);
    }

    return 0;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\headless\test\cpp\emsfile\emsfile.cpp ===
#include <windows.h>
#include <winioctl.h>
#include <stdio.h>
#include <malloc.h>

#include <ntddsac.h>

#include <emsapi.h>

#define THREAD_WAIT_TIMEOUT    100
#define THREADCOUNT 2

typedef struct _CHANNEL_THREAD_DATA {

    HANDLE              ExitEvent;
    
    WCHAR               ChannelName[SAC_MAX_CHANNEL_NAME_LENGTH];
    WCHAR               ChannelDescription[SAC_MAX_CHANNEL_DESCRIPTION_LENGTH];

} CHANNEL_THREAD_DATA, *PCHANNEL_THREAD_DATA;
                
DWORD
ChannelThreadVTUTF8Echo(
    PVOID   Data
    )
{
    EMSVTUTF8Channel*        Channel;
    PCHANNEL_THREAD_DATA    ChannelThreadData;
    DWORD                   Status;
    ULONG                   i;
    WCHAR                   Buffer[256];
    ULONG                   ByteCount;
    BOOL                    bStatus;
    BOOL                    InputWaiting;
    HANDLE                  hFile; 

    ChannelThreadData = (PCHANNEL_THREAD_DATA)Data;

    SAC_CHANNEL_OPEN_ATTRIBUTES Attributes;

    //
    // Configure the new channel
    //
    Attributes.Type             = ChannelTypeVTUTF8;
    Attributes.Name             = ChannelThreadData->ChannelName;
    Attributes.Description      = ChannelThreadData->ChannelDescription;
    Attributes.Flags            = 0;
    Attributes.CloseEvent       = NULL;
    Attributes.HasNewDataEvent  = NULL;
    Attributes.ApplicationType  = NULL;
    
    //
    // Open the Hello channel
    //
    Channel = EMSVTUTF8Channel::Construct(Attributes);

    //
    // See if the channel was created
    //
    if (Channel == NULL) {
        return 0;
    }
    
    //
    // open dump file
    //
    hFile = CreateFile(
        L"emsvtutf8.txt",
        GENERIC_WRITE,                // open for writing 
        0,                            // do not share 
        NULL,                         // no security 
        CREATE_ALWAYS,                // overwrite existing 
        FILE_ATTRIBUTE_NORMAL,        // normal file 
        NULL);                        // no attr. template 
     
    if (hFile == INVALID_HANDLE_VALUE) 
    { 
        return 0;
    } 

    //
    // Perform thread work
    //

    i=0;

    while (1) {

        Status = WaitForSingleObject(
            ChannelThreadData->ExitEvent,
            THREAD_WAIT_TIMEOUT
            );

        if (Status != WAIT_TIMEOUT) {
            CloseHandle(hFile);
            break;
        } 

        //
        // See if there is data to echo
        //
        bStatus = Channel->HasNewData(&InputWaiting);

        if (InputWaiting) {

            //
            // Read from channel
            //
            bStatus = Channel->Read(
                Buffer,
                sizeof(Buffer),
                &ByteCount
                );

            if (bStatus) {
                
                //
                // Dump to a file
                //
                WriteFile(
                    hFile,
                    Buffer,
                    ByteCount,
                    &i,
                    NULL
                    );
            
                //
                // Echo to the channel
                //
                bStatus = Channel->Write(
                    Buffer,
                    ByteCount
                    );
                if (! bStatus) {
                    printf("%S: Failed to print string to channel\n", ChannelThreadData->ChannelName);
                }
            
            } else {
                printf("%S: Failed to print string to channel\n", ChannelThreadData->ChannelName);
            }

        }
    
    }

    delete Channel;

    return 0;

}

DWORD
ChannelThreadRawEcho(
    PVOID   Data
    )
{
    EMSRawChannel*          Channel;
    PCHANNEL_THREAD_DATA    ChannelThreadData;
    DWORD                   Status;
    ULONG                   i;
    BYTE                    Buffer[256];
    ULONG                   ByteCount;
    BOOL                    bStatus;
    BOOL                    InputWaiting;
    HANDLE                  hFile;

    ChannelThreadData = (PCHANNEL_THREAD_DATA)Data;

    SAC_CHANNEL_OPEN_ATTRIBUTES Attributes;

    //
    // Configure the new channel
    //
    RtlZeroMemory(&Attributes, sizeof(SAC_CHANNEL_OPEN_ATTRIBUTES));
    
    Attributes.Type             = ChannelTypeRaw;
    Attributes.Name             = ChannelThreadData->ChannelName;
    Attributes.Description      = ChannelThreadData->ChannelDescription;
    Attributes.Flags            = 0;
    Attributes.CloseEvent       = NULL;
    Attributes.HasNewDataEvent  = NULL;
    Attributes.ApplicationType  = NULL;
    
    //
    // Open the Hello channel
    //
    Channel = EMSRawChannel::Construct(Attributes);

    //
    // See if the channel was created
    //
    if (Channel == NULL) {
        return 0;
    }
    
    //
    // open dump file
    //
    hFile = CreateFile(
        L"emsraw.txt",
        GENERIC_WRITE,                // open for writing 
        0,                            // do not share 
        NULL,                         // no security 
        CREATE_ALWAYS,                // overwrite existing 
        FILE_ATTRIBUTE_NORMAL,        // normal file 
        NULL);                        // no attr. template 
     
    if (hFile == INVALID_HANDLE_VALUE) 
    { 
        return 0;
    } 
    
    //
    // Perform thread work
    //

    i=0;

    while (1) {

        Status = WaitForSingleObject(
            ChannelThreadData->ExitEvent,
            THREAD_WAIT_TIMEOUT
            );

        if (Status != WAIT_TIMEOUT) {
            CloseHandle(hFile);
            break;
        } 

        //
        // See if there is data to echo
        //
        bStatus = Channel->HasNewData(&InputWaiting);

        if (InputWaiting) {

            //
            // Read from channel
            //
            bStatus = Channel->Read(
                Buffer,
                sizeof(Buffer),
                &ByteCount
                );

            if (bStatus) {
                
                //
                // Dump to a file
                //
                WriteFile(
                    hFile,
                    Buffer,
                    ByteCount,
                    &i,
                    NULL
                    );

                //
                // Echo to the channel
                //
                bStatus = Channel->Write(
                    Buffer,
                    ByteCount
                    );
                if (! bStatus) {
                    printf("%S: Failed to print string to channel\n", ChannelThreadData->ChannelName);
                }
            
            } else {
                printf("%S: Failed to print string to channel\n", ChannelThreadData->ChannelName);
            }

        }
    
    }

    delete Channel;

    return 0;

}

DWORD (*ChannelTests[THREADCOUNT])(PVOID) = {
    ChannelThreadVTUTF8Echo,
    ChannelThreadRawEcho
};

int _cdecl 
wmain(
    int argc, 
    WCHAR **argv
    )
{
    HANDLE              Channel[THREADCOUNT];
    CHANNEL_THREAD_DATA ChannelData[THREADCOUNT];
    HANDLE              ExitEvent;
    ULONG               i;

    ExitEvent = CreateEvent( 
        NULL,         // no security attributes
        TRUE,         // manual-reset event
        FALSE,        // initial state is signaled
        NULL          // object name
        ); 

    if (ExitEvent == NULL) { 
        return 1;
    }

    //
    // create the worker threads
    //
    for (i = 0; i < THREADCOUNT; i++) {
        
        //
        // populate the thread data structure
        //
        
        ChannelData[i].ExitEvent = ExitEvent;
        wsprintf(
            ChannelData[i].ChannelName,
            L"CT%02d",
            i
            );
        ChannelData[i].ChannelDescription[0] = UNICODE_NULL;

        //
        // create the thread
        //
        
        Channel[i] = CreateThread(
            NULL,
            0,
            ChannelTests[i],
            &(ChannelData[i]),
            0,
            NULL
            );

        if (Channel[i] == NULL) {
            goto cleanup;
        }

    }

    //
    // wait for local user to end the stress
    //
    getc(stdin);

cleanup:

    SetEvent(ExitEvent);

    WaitForMultipleObjects(
        THREADCOUNT,
        Channel,
        TRUE,
        INFINITE
        );

    for (i = 0; i < THREADCOUNT; i++) {
        CloseHandle(Channel[i]);
    }

    return 0;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\headless\test\cpp\emslock\emslock.cpp ===
#include <windows.h>
#include <winioctl.h>
#include <stdio.h>
#include <malloc.h>

#include <emsapi.h>

int _cdecl wmain(int argc, WCHAR **argv)
{
    EMSRawChannel*  channel;
    UCHAR       Buffer[256];
    ULONG       CharCount;
    UCHAR       AssembledString[1024];
    ULONG       TotalCharCount;
    SAC_CHANNEL_OPEN_ATTRIBUTES Attributes;
    DWORD       dwStatus;
    HANDLE      LockEvent;

    LockEvent = CreateEvent( NULL, FALSE, FALSE, NULL );

    if (LockEvent == INVALID_HANDLE_VALUE) {
        return 0;
    }

    //
    // Configure the new channel
    //
    Attributes.Type             = ChannelTypeVTUTF8;
    Attributes.Name             = L"locker";
    Attributes.Description      = NULL;
    Attributes.Flags            = SAC_CHANNEL_FLAG_LOCK_EVENT;
    Attributes.CloseEvent       = NULL;
    Attributes.HasNewDataEvent  = NULL;
    Attributes.LockEvent        = LockEvent;
    Attributes.ApplicationType  = NULL;
   
    //
    // Open the Hello channel
    //
    channel = EMSRawChannel::Construct(Attributes);

    //
    // See if the channel was created
    //
    if (channel == NULL) {
        return 0;
    }

    do {
        
        //
        // Write to the Hello Channel
        //
        if (channel->Write(
            (PBYTE)"Hello, World! waiting for lock event!\r\n",
            sizeof("Hello, World! waiting for lock event!\r\n")
            )) {
            printf("Successfully printed string to channel\n");
        } else {
            printf("Failed to print string to channel\n");
            break;
        }

        dwStatus = WaitForSingleObject(
            LockEvent,
            INFINITE
            );

        switch (dwStatus) {
        case WAIT_OBJECT_0:
            if (channel->Write(
                (PBYTE)"Received lock event!\r\n",
                sizeof("Received lock event!\r\n")
                )) {
                printf("Successfully printed string to channel\n");
            } else {
                printf("Failed to print string to channel\n");
                break;
            }
            break;
        default:
            if (channel->Write(
                (PBYTE)"DID NOT RECEIVE lock event!\r\n",
                sizeof("DID NOT RECEIVE lock event!\r\n")
                )) {
                printf("Successfully printed string to channel\n");
            } else {
                printf("Failed to print string to channel\n");
                break;
            }
            break;
        }
    
    } while (FALSE);

    //
    // Close the Hello Channel
    //
    delete channel;

    return 0;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\headless\test\driver_match\dm.c ===
/*++
    Driver Match will parse a set of files, remember the list
    of drivers in each file, and print the drivers common to
    all the XML files.
--*/


#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <stdio.h>
#include <conio.h>
#include <stdlib.h>
#include <TCHAR.h>

#include <diamondd.h>
#include <lzexpand.h>
#include <fcntl.h>


#define OSVERSION_TAG   L"<OSVER>"
#define DRIVER_TAG      L"<DRIVER>"
#define FILENAME_TAG    L"<FILENAME>"
#define VERSION_TAG     L"<VERSION>"
#define MANUFACT_TAG    L"<MANUFACTURER>"
#define MICROSOFT_MANUFACTURER L"Microsoft Corporation"



//
// Info about a specific driver.
//
typedef struct _FILE_ENTRY {

    struct _FILE_ENTRY  *Next;

    PTSTR               FileName;
    struct _VERSION_ENTRY *VersionList;
    //PTSTR               FileVersion;
    ULONG               RefCount;

} FILE_ENTRY, *PFILE_ENTRY;

typedef struct _VERSION_ENTRY {
    struct _VERSION_ENTRY *Next;
    PFILE_ENTRY         FileEntry;
    PTSTR               FileVersion;
    ULONG               RefCount;
} VERSION_ENTRY, *PVERSION_ENTRY;


PFILE_ENTRY         MasterFileList = NULL;
ULONG               FilesProcessed = 0;
BOOLEAN             ExcludeMicrosoftDrivers = FALSE;



//
// Diamond stuff so we can crack .CAB files.
//
HFDI FdiContext;   
DWORD LastError;
ERF FdiError;
PVOID DecompBuffer = NULL;
ULONG SizeOfFileInDecompressBuffer = 0;
ULONG DecompressBufferSize;

//
// This is the value we return to diamond when it asks us to create
// the target file.
//
#define DECOMP_MAGIC_HANDLE 0x87654



//
// Private malloc/free routines so we can track memory
// if we ever want to.
//
VOID *MyMalloc( size_t Size )
{
    PVOID ReturnPtr = NULL;

    ReturnPtr = malloc(Size);
    if( ReturnPtr ) {
        RtlZeroMemory( ReturnPtr, Size );
    }

    return ReturnPtr;
}

VOID MyFree( PVOID Ptr )
{
    free( Ptr );
}

PSTR
UnicodeStringToAnsiString(
    PWSTR StringW
    ) 
{
    UNICODE_STRING UStr;
    ANSI_STRING AStr;
    ULONG AnsiLength,Index;

    RtlInitUnicodeString(&UStr, StringW);

    AnsiLength = RtlUnicodeStringToAnsiSize(&UStr);

    AStr.MaximumLength = (USHORT)AnsiLength;
    AStr.Length = (USHORT) AnsiLength - 1;

    AStr.Buffer = MyMalloc(AStr.MaximumLength);

    if (!AStr.Buffer) {
        return(NULL);
    }

    RtlUnicodeToMultiByteN( AStr.Buffer,
                            AStr.Length,
                            &Index,
                            UStr.Buffer,
                            UStr.Length
                            );

    return(AStr.Buffer);
}


PVOID
DIAMONDAPI
SpdFdiAlloc(
    IN ULONG NumberOfBytes
    )

/*++

Routine Description:

    Callback used by FDICopy to allocate memory.

Arguments:

    NumberOfBytes - supplies desired size of block.

Return Value:

    Returns pointer to a block of memory or NULL
    if memory cannot be allocated.

--*/

{
    return(MyMalloc(NumberOfBytes));
}


VOID
DIAMONDAPI
SpdFdiFree(
    IN PVOID Block
    )

/*++

Routine Description:

    Callback used by FDICopy to free a memory block.
    The block must have been allocated with SpdFdiAlloc().

Arguments:

    Block - supplies pointer to block of memory to be freed.

Return Value:

    None.

--*/

{
    MyFree(Block);
}


INT_PTR
DIAMONDAPI
SpdFdiOpen(
    IN PSTR FileName,
    IN int  oflag,
    IN int  pmode
    )

/*++

Routine Description:

    Callback used by FDICopy to open files.

    This routine is capable only of opening existing files.

    When making changes here, also take note of other places
    that open the file directly (search for SpdFdiOpen)

Arguments:

    FileName - supplies name of file to be opened.

    oflag - supplies flags for open.

    pmode - supplies additional flags for open.

Return Value:

    Handle to open file or -1 if error occurs.

--*/

{
    HANDLE h;
    
    UNREFERENCED_PARAMETER(pmode);

    if(oflag & (_O_WRONLY | _O_RDWR | _O_APPEND | _O_CREAT | _O_TRUNC | _O_EXCL)) {
        LastError = ERROR_INVALID_PARAMETER;
        return(-1);
    }

    h = CreateFileA(FileName,
                    GENERIC_READ,
                    FILE_SHARE_READ,
                    NULL,
                    OPEN_EXISTING,
                    0,
                    NULL);
    if(h == INVALID_HANDLE_VALUE) {
        LastError = GetLastError();
        return(-1);
    }

    return (INT_PTR)h;
}

UINT
DIAMONDAPI
SpdFdiRead(
    IN  INT_PTR Handle,
    OUT PVOID pv,
    IN  UINT  ByteCount
    )

/*++

Routine Description:

    Callback used by FDICopy to read from a file.

Arguments:

    Handle - supplies handle to open file to be read from.

    pv - supplies pointer to buffer to receive bytes we read.

    ByteCount - supplies number of bytes to read.

Return Value:

    Number of bytes read or -1 if an error occurs.

--*/

{
    DWORD d;
    HANDLE hFile = (HANDLE)Handle;
    DWORD bytes;
    UINT rc;

    if (Handle == DECOMP_MAGIC_HANDLE) {
        return(-1);
    }

    if(ReadFile(hFile,pv,(DWORD)ByteCount,&bytes,NULL)) {
        rc = (UINT)bytes;
    } else {
        d = GetLastError();
        rc = (UINT)(-1);
        
        LastError = d;
    }
    return rc;
}


UINT
DIAMONDAPI
SpdFdiWrite(
    IN INT_PTR Handle,
    IN PVOID pv,
    IN UINT  ByteCount
    )

/*++

Routine Description:

    Callback used by FDICopy to write to a file.

Arguments:

    Handle - supplies handle to open file to be written to.

    pv - supplies pointer to buffer containing bytes to write.

    ByteCount - supplies number of bytes to write.

Return Value:

    Number of bytes written (ByteCount) or -1 if an error occurs.

--*/

{
   if (Handle != DECOMP_MAGIC_HANDLE) {
       return(-1);       
   }
    
   //
   // Check for overflow.
   //
   if(SizeOfFileInDecompressBuffer+ByteCount > DecompressBufferSize) {
       return((UINT)(-1));
   }

   RtlCopyMemory(
       (PCHAR)DecompBuffer + SizeOfFileInDecompressBuffer,
       pv,
       ByteCount
       );

   SizeOfFileInDecompressBuffer += ByteCount;
   return(ByteCount);

}


int
DIAMONDAPI
SpdFdiClose(
    IN INT_PTR Handle
    )

/*++

Routine Description:

    Callback used by FDICopy to close files.

Arguments:

    Handle - handle of file to close.

Return Value:

    0 (success).

--*/

{
    BOOL success = FALSE;

    if (Handle != DECOMP_MAGIC_HANDLE) {
        CloseHandle((HANDLE)Handle);
    }

    //
    // Always act like we succeeded.
    //
    return 0;
}


long
DIAMONDAPI
SpdFdiSeek(
    IN INT_PTR Handle,
    IN long Distance,
    IN int  SeekType
    )

/*++

Routine Description:

    Callback used by FDICopy to seek files.

Arguments:

    Handle - handle of file to close.

    Distance - supplies distance to seek. Interpretation of this
        parameter depends on the value of SeekType.

    SeekType - supplies a value indicating how Distance is to be
        interpreted; one of SEEK_SET, SEEK_CUR, SEEK_END.

Return Value:

    New file offset or -1 if an error occurs.

--*/

{
    LONG rc;
    DWORD d;
    HANDLE hFile = (HANDLE)Handle;
    DWORD pos_low;
    DWORD method;

    if (Handle == DECOMP_MAGIC_HANDLE) {
        return(-1);
    }

    switch(SeekType) {
        case SEEK_SET:
            method = FILE_BEGIN;
            break;

        case SEEK_CUR:
            method = FILE_CURRENT;
            break;

        case SEEK_END:
            method = FILE_END;
            break;

        default:
            return -1;
    }

    pos_low = SetFilePointer(hFile,(DWORD)Distance,NULL,method);
    if(pos_low == INVALID_SET_FILE_POINTER) {
        d = GetLastError();
        rc = -1L;

        LastError = d;
    } else {
        rc = (long)pos_low;
    }

    return(rc);
}



BOOL
DiamondInitialize(
    VOID
    )

/*++

Routine Description:

    Per-thread initialization routine for Diamond.
    Called once per thread.

Arguments:

    None.

Return Value:

    Boolean result indicating success or failure.
    Failure can be assumed to be out of memory.

--*/

{
    
    BOOL retval = FALSE;
    
    try {

        //
        // Initialize a diamond context.
        //
        FdiContext = FDICreate(
                        SpdFdiAlloc,
                        SpdFdiFree,
                        SpdFdiOpen,
                        SpdFdiRead,
                        SpdFdiWrite,
                        SpdFdiClose,
                        SpdFdiSeek,
                        cpuUNKNOWN,
                        &FdiError
                        );

        if(FdiContext) {
            retval = TRUE;
        }

    } except(EXCEPTION_EXECUTE_HANDLER) {
        retval = FALSE;
    }

    return(retval);
}


VOID
DiamondTerminate(
    VOID
    )
/*++

Routine Description:

    Per-thread termination routine for Diamond.
    Called internally.

Arguments:

    None.

Return Value:

    Boolean result indicating success or failure.
    Failure can be assumed to be out of memory.

--*/
{
    FDIDestroy(FdiContext);
    FdiContext = NULL;
}

INT_PTR 
DIAMONDAPI
NotifyFunction(
    FDINOTIFICATIONTYPE fdint,
    PFDINOTIFICATION    pfdin)
{
    switch(fdint) {
        case fdintCOPY_FILE:
            if (_strcmpi(pfdin->psz1,"sysdata.xml") == 0) {
                DecompressBufferSize = pfdin->cb+2;
                DecompBuffer = MyMalloc(DecompressBufferSize);
                if (!DecompBuffer) {
                    return(-1);
                }
                SizeOfFileInDecompressBuffer = 0;
                return(DECOMP_MAGIC_HANDLE);
            }
            return(0);
            break;

    case fdintCLOSE_FILE_INFO:
        if (pfdin->hf == DECOMP_MAGIC_HANDLE) {
            return(TRUE);
        }
        return(FALSE);
        break;

    default:
        return(0);
    }

    return(0);
}

BOOL
DiamondExtractFileIntoBuffer(
    PTSTR DirectoryName,
    PTSTR FileName,
    PVOID *Buffer,
    PDWORD FileSize
    )
{
    HANDLE h;
    PSTR FileNameA;
    PSTR DirectoryNameA;
    CHAR File[MAX_PATH];
    ULONG i;

#ifdef UNICODE
    FileNameA = UnicodeStringToAnsiString(FileName);
    DirectoryNameA = UnicodeStringToAnsiString(DirectoryName);
#else
    DirectoryNameA = DirectoryName;
    FileNameA = FileName;
#endif

    strcpy(File, DirectoryNameA);
    i = strlen(File);
    if (File[i-1] != '\\') {
        File[i] = '\\';
        File[i+1] = '\0';
    }
    strcat(File, FileNameA);
     
    h = (HANDLE)SpdFdiOpen(File, 0, 0);

    if (h == INVALID_HANDLE_VALUE) {
        return(FALSE);
    }

    SpdFdiSeek( (INT_PTR)h, 0, SEEK_SET );

    DecompBuffer = NULL;
    LastError = ERROR_SUCCESS;
#if 0
    GetCurrentDirectoryA(MAX_PATH,Dir);
    i = strlen(Dir);
    Dir[i] = '\\';
    Dir[i+1] = '\0';
#endif

    if (!FDICopy(FdiContext,
                 FileNameA,
                 DirectoryNameA,// Dir,//FileNameA,
                 0,
                 NotifyFunction,
                 NULL,
                 Buffer)) {
        return(FALSE);
    }

    SpdFdiClose((INT_PTR)h);

#ifdef UNICODE
    MyFree(FileNameA);
    MyFree(DirectoryNameA);
#endif

    if (LastError == ERROR_SUCCESS) {
        if (DecompBuffer) {
            *Buffer = DecompBuffer;
            *FileSize = DecompressBufferSize;
            return(TRUE);
        } else {
            return(FALSE);
        }        
    } else {
        return(FALSE);
    }

}


void
Usage( char *AppName )
{
    if (AppName == NULL) {
        return;
    }
    printf( "\n\n" );
    printf( "Usage: %s [-m] <filename>\n", AppName );
    printf( "    Searchs the given XML files for all the drivers and\n" );
    printf( "    collates a list of drivers common to all the files.\n" );
    printf( "\n" );
    printf( "    -m  (OPTIONAL) Exclude drivers manufactured by Microsoft Corporation.\n" );
    printf( "\n" );
    printf( "    <filename>  May contain wildcards.  Search this file(s) for drivers.\n" );
    printf( "\n" );
    printf( "    EXAMPLE:\n" );
    printf( "    %s -m sysdata*.xml\n", AppName );
    printf( "\n" );
    printf( "    This would examine every file which matches the pattern 'sysdata*.xml'\n" );
    printf( "    and build a list of non-Microsoft drivers which are common to all the files.\n" );
    printf( "\n\n" );

}



BOOL
AddDriverEntry(
    PWSTR           DriverName,
    PWSTR           DriverVersion
    )
/*++

Routine Description:

    Insert a driver entry into the MasterFileList.  Note that it should be inserted in
    ascending order with respect to the FileName.

Arguments:

    DriverName      Name of the specified driver.
    
    DriverVersion   String containing the version of the specified driver.

Return Value:

--*/
{
    PFILE_ENTRY LastEntry = NULL;
    PFILE_ENTRY ThisEntry = NULL;
    PVERSION_ENTRY ThisVEntry = NULL;
    PVERSION_ENTRY LastVEntry = NULL;



    if( DriverName == NULL ) {
        //printf( "AddDriverEntry: Bad incoming parameter\n" );
        return(FALSE);
    }

    //printf( "AddDriverEntry Enter: Adding filename %S\n", DriverName );

    if( MasterFileList == NULL ) {
        //
        // First entry for the machine.
        //
        //printf( "    Adding the very first entry.\n" );
        MasterFileList = MyMalloc(sizeof(FILE_ENTRY));
        if (!MasterFileList) {
            return(FALSE);
        }
        
        ThisVEntry = MyMalloc(sizeof(VERSION_ENTRY));
        if (!ThisVEntry) {
            MyFree(MasterFileList);
            MasterFileList = NULL;
            return(FALSE);
        }

        MasterFileList->FileName = DriverName;
        MasterFileList->VersionList = ThisVEntry;
        MasterFileList->Next = NULL;
        MasterFileList->RefCount = 1;
        ThisVEntry->FileEntry  = MasterFileList;
        ThisVEntry->RefCount = 1;
        ThisVEntry->FileVersion = DriverVersion;
        ThisVEntry->Next = NULL;
        
        return(TRUE);
    }

    LastEntry = MasterFileList;
    ThisEntry = MasterFileList;

    //
    // Find a spot to add this driver into our list.
    //
    while( ThisEntry &&
           (_wcsicmp(ThisEntry->FileName, DriverName) < 0)) {
        //printf( "        Checking against filename %S\n", ThisEntry->FileName );
        LastEntry = ThisEntry;
        ThisEntry = ThisEntry->Next;
    }
    

    //
    // Handle all the cases that would make use break out of the above loop.
    //
    if( ThisEntry == NULL ) {
        //
        // insert at the tail.
        //
        //printf( "            Inserting at the tail of our list.\n" );
        LastEntry->Next = MyMalloc(sizeof(FILE_ENTRY));
        if (!LastEntry->Next) {
            return(FALSE);
        }
        LastEntry->Next->VersionList = MyMalloc(sizeof(VERSION_ENTRY));
        if (!LastEntry->Next->VersionList) {
            MyFree(LastEntry->Next);
            LastEntry->Next = NULL;
            return(FALSE);
        }

        ThisEntry = LastEntry->Next;
        ThisEntry->FileName = DriverName;
        ThisEntry->RefCount = 1;
        ThisEntry->Next = NULL;
        ThisEntry->VersionList->FileVersion = DriverVersion;
        ThisEntry->VersionList->FileEntry = ThisEntry;
        ThisEntry->VersionList->Next = NULL;
        ThisEntry->VersionList->RefCount = 1;
        
        return(TRUE);
    }


    if( !_wcsicmp(ThisEntry->FileName, DriverName)) {
        //printf( "            Found a duplicate drivername!\n" );
        
        ThisEntry->RefCount++;

        LastVEntry = ThisEntry->VersionList;
        ThisVEntry = ThisEntry->VersionList;

        //
        // Find a spot to add this driver into our list.
        //
        while( ThisVEntry &&
               (_wcsicmp(ThisVEntry->FileVersion, DriverVersion) < 0)) {
            //printf( "        Checking against version %S\n", ThisVEntry->FileVersion );
            LastVEntry = ThisVEntry;
            ThisVEntry = ThisVEntry->Next;
        }

        if (!ThisVEntry) {
            //printf( "            Inserting version at the tail of our list.\n" );
            LastVEntry->Next = MyMalloc(sizeof(VERSION_ENTRY));
            if (!LastVEntry->Next) {
                MyFree(LastVEntry->Next);
                LastVEntry->Next = NULL;
                return(FALSE);
            }
            
            ThisVEntry = LastVEntry->Next;
            ThisVEntry->FileVersion = DriverVersion;
            ThisVEntry->FileEntry = ThisEntry;
            ThisVEntry->Next = NULL;
            ThisVEntry->RefCount = 1;
            return(TRUE);
        }

        if (!_wcsicmp(ThisVEntry->FileVersion, DriverVersion)) {
            ThisVEntry->RefCount++;
            return(TRUE);
        }

        if (LastVEntry == ThisVEntry) {
            //
            // Put it at the very head of the list
            //
            //printf( "            Inserting version at the head of our list.\n" );
            ThisVEntry = ThisEntry->VersionList;
            ThisEntry->VersionList = MyMalloc(sizeof(VERSION_ENTRY));
            if (!ThisEntry->VersionList) {
                ThisEntry->VersionList = ThisVEntry;
                return(FALSE);
            }
            
            ThisEntry->VersionList->FileVersion = DriverVersion;
            ThisEntry->VersionList->FileEntry = ThisEntry;
            ThisEntry->VersionList->Next = LastVEntry;
            ThisEntry->VersionList->RefCount = 1;
            return(TRUE);
        }

        //
        // insert between LastEntry and ThisEntry
        //
        LastVEntry->Next = MyMalloc(sizeof(VERSION_ENTRY));
        if (!LastVEntry->Next) {
            LastVEntry->Next = ThisVEntry;
            return(FALSE);
        }
        LastVEntry->Next->FileVersion = DriverVersion;
        LastVEntry->Next->FileEntry = LastEntry->Next;
        LastVEntry->Next->RefCount = 1;
        LastVEntry->Next->Next = ThisVEntry;

        return(TRUE);
        
    }
    
    if( LastEntry == ThisEntry ) {
        //
        // Put it at the very head of the list
        //
        //printf( "            Inserting at the head of our list.\n" );
        ThisEntry = MasterFileList;
        MasterFileList = MyMalloc(sizeof(FILE_ENTRY));
        if (!MasterFileList) {
            MasterFileList = ThisEntry;
            return(FALSE);
        }
        MasterFileList->VersionList = MyMalloc(sizeof(VERSION_ENTRY));
        if (!MasterFileList->VersionList) {
            MyFree(MasterFileList);
            MasterFileList = ThisEntry;
            return(FALSE);
        }

        ThisEntry = LastEntry;
        
        MasterFileList->FileName = DriverName;
        MasterFileList->RefCount = 1;
        MasterFileList->Next = LastEntry;

        MasterFileList->VersionList->FileVersion = DriverVersion;
        MasterFileList->VersionList->FileEntry = MasterFileList;
        MasterFileList->VersionList->Next = NULL;
        MasterFileList->VersionList->RefCount = 1;
        
        
    } else {
        //
        // insert betwee LastEntry and ThisEntry
        //
        LastEntry->Next = MyMalloc(sizeof(FILE_ENTRY));
        if (!LastEntry->Next) {
            LastEntry->Next = ThisEntry;
            return(FALSE);
        }
        LastEntry->Next->VersionList = MyMalloc(sizeof(VERSION_ENTRY));
        if (!LastEntry->Next->VersionList) {
            MyFree(LastEntry->Next);
            LastEntry->Next = ThisEntry;
            return(FALSE);
        }

        LastEntry->Next->RefCount = 1;
        LastEntry->Next->Next = ThisEntry;
        LastEntry->Next->FileName = DriverName;

        LastEntry->Next->VersionList->FileVersion = DriverVersion;
        LastEntry->Next->VersionList->FileEntry = LastEntry->Next;
        LastEntry->Next->VersionList->Next = NULL;
        LastEntry->Next->VersionList->RefCount = 1;
        
        

        //printf( "            LastEntry: %S DriverEntry: %S NextEntry: %S\n",LastEntry->FileName, DriverName, ThisEntry->FileName );
    }

    return(TRUE);
}


PWSTR
ExtractAndDuplicateString(
    PWSTR   BufferPointer
    )
/*++

Routine Description:

    Extract a file name from the given buffer, allocate memory and return
    a copy of the extracted string.

Arguments:

    BufferPointer   Pointer to a buffer which is assumed to be the start
                    of a string.  We continue to inspect the incoming
                    buffer until we get to the start of an XML tag.
                    At that point, assume the string is ending, copy the
                    string into a secondary buffer and return that buffer.
                    
                    N.B.  The caller is responsible for freeing the memory
                          we've allocated!

Return Value:

    Pointer to the allocated memory.

    NULL if we fail.

--*/
{
PWSTR   TmpPtr = NULL;
PWSTR   ReturnPtr = NULL;

    TmpPtr = BufferPointer;
    while( TmpPtr && (*TmpPtr) && (*TmpPtr != L'<') ) {
        TmpPtr++;
    }

    if( *TmpPtr == L'<' ) {
        ULONG SizeInBytes;
         
        SizeInBytes = ((TmpPtr - BufferPointer) + 1) * sizeof(WCHAR);
        ReturnPtr = MyMalloc( SizeInBytes );
        wcsncpy( ReturnPtr, BufferPointer, (TmpPtr - BufferPointer) );
    }

    return ReturnPtr;
}

BOOL
ProcessFile(
    PTSTR DirectoryName,
    PTSTR FileName
    )
/*++

Routine Description:

    Parse through the given file (XML file) and remember all the
    driver files specified in it.

Arguments:

    DirectoryName Directory file is present in.
    FileName   Name of the file we'll parse.

Return Value:

    TRUE - we successfully inserted the file into our list.

    FALSE - we failed.

--*/
{
HANDLE          FileHandle = INVALID_HANDLE_VALUE;
PUCHAR          FileBuffer = NULL;
ULONG           i = 0;
DWORD           FileSize = 0;
BOOLEAN         b = FALSE;
PWSTR           MyPtr;
PWSTR           DriverName;
PWSTR           DriverVersion;
PWSTR           ManufacturerName;
BOOL            Status;


    
    if( !FileName ) {
        return FALSE;
    }

    _wcslwr( FileName );
    if( wcsstr(FileName,L".cab") ) {
        //
        // They've sent us a cab.  Call special code to crack
        // the cab, and extract the xml file into our buffer.
        //
        if (!DiamondExtractFileIntoBuffer(DirectoryName, FileName, &FileBuffer,&FileSize)) {
            return(FALSE);
        }
    } else {

        FileHandle = CreateFile( FileName, GENERIC_READ, FILE_SHARE_READ, NULL, OPEN_EXISTING, 0, NULL );
        if( FileHandle == INVALID_HANDLE_VALUE) { return(FALSE); }
        FileSize = GetFileSize( FileHandle, NULL );
        if( FileSize == (DWORD)(-1) ) { return(FALSE); };
    
        FileBuffer = MyMalloc(FileSize + 3);
        if( FileBuffer == NULL ) {
            // printf( "No System resources!\n" );
            return(FALSE);
        }
    
        b = (BOOLEAN)ReadFile( FileHandle, FileBuffer, FileSize, &i, NULL );
        CloseHandle( FileHandle );
    }

    
    //
    // We've got the file up in memory (in FileBuffer), now parse it.
    //
    MyPtr = (PWSTR)FileBuffer;
    while( MyPtr < (PWSTR)(FileBuffer + FileSize - (wcslen(DRIVER_TAG) * sizeof(WCHAR))) ) {
        
        // find the driver tag
        if( !_wcsnicmp((MyPtr), DRIVER_TAG, wcslen(DRIVER_TAG)) ) {

            // FileName tag.
            while( *MyPtr && (_wcsnicmp((MyPtr), FILENAME_TAG, wcslen(FILENAME_TAG))) ) {
                if (MyPtr < (PWSTR)(FileBuffer + FileSize - (wcslen(FILENAME_TAG) * sizeof(WCHAR)))) {
                    MyPtr++;
                } else {
                    Status = FALSE;
                    goto exit;
                }
            }
            MyPtr += wcslen(FILENAME_TAG);
            DriverName = ExtractAndDuplicateString( MyPtr );
            // printf( "Found Driver name %S\n", DriverName );


            // Driver Version
            while( *MyPtr && (_wcsnicmp((MyPtr), VERSION_TAG, wcslen(VERSION_TAG))) ) {
                if (MyPtr < (PWSTR)(FileBuffer + FileSize - (wcslen(VERSION_TAG) * sizeof(WCHAR)))) {
                    MyPtr++;
                } else {
                    Status = FALSE;
                    goto exit;
                }
            }
            MyPtr += wcslen(VERSION_TAG);
            DriverVersion = ExtractAndDuplicateString( MyPtr );
            // printf( "    Version: %S\n", DriverVersion );


            // Manufacturer
            while( *MyPtr && (_wcsnicmp((MyPtr), MANUFACT_TAG, wcslen(MANUFACT_TAG))) ) {
                if (MyPtr < (PWSTR)(FileBuffer + FileSize - (wcslen(MANUFACT_TAG) * sizeof(WCHAR)))) {
                    MyPtr++;
                } else {
                    Status = FALSE;
                    goto exit;
                }
            }
            MyPtr += wcslen(MANUFACT_TAG);
            ManufacturerName = ExtractAndDuplicateString( MyPtr );
            //printf( "    Manufacturer name %S\n", ManufacturerName );

            if( ExcludeMicrosoftDrivers &&
                !_wcsicmp(ManufacturerName, MICROSOFT_MANUFACTURER) ) {
                // skip it.
                // printf( "        Skipping Driver: %S\n", DriverName );
                if( DriverName ) {
                    MyFree( DriverName );
                }
                if( DriverVersion ) {
                    MyFree( DriverVersion );
                }
            } else {
                // printf( "        Addinging Driver: %S\n", DriverName );
                AddDriverEntry( DriverName, DriverVersion );
            }

            MyFree( ManufacturerName );
            
        } else {
            if (MyPtr < (PWSTR)(FileBuffer + FileSize)) {
                MyPtr++;
            } else {
                Status = FALSE;
                goto exit;
            }            
        }
    }

    Status = TRUE;

exit:
    if( FileBuffer ) {
        MyFree( FileBuffer );
    }

    return(Status);

}

VOID
PrintNode(
    PFILE_ENTRY Entry
    )
{
    PVERSION_ENTRY V;
    _tprintf( TEXT("%d %s ("), Entry->RefCount, Entry->FileName);
    V = Entry->VersionList;
    while (V) {
        _tprintf( TEXT("%d %s %c"), 
                 V->RefCount, 
                 V->FileVersion, 
                 V->Next 
                  ? TEXT(',') 
                  : TEXT(')') );
        V = V->Next;
    }

    _tprintf( TEXT("\r\n"));
}

VOID
DumpFileList(
    VOID
    )
/*++

Routine Description:

    Walk our list of files, printing out those which are found on all machines
    and those which are not.

Arguments:

    NONE.

Return Value:

    NONE.

--*/
{
PFILE_ENTRY     MyFileEntry;

    if( MasterFileList == NULL ) {
        return;
    }

#if 0
    _tprintf( TEXT("\nThe following %sdrivers were NOT found in all machines.\n"), 
              ExcludeMicrosoftDrivers 
               ? TEXT("Non-Microsoft ")
               : TEXT("") );
    MyFileEntry = MasterFileList;
    while( MyFileEntry ) {
        if( MyFileEntry->RefCount != FilesProcessed ) {
            PrintNode(MyFileEntry);            
        }
        MyFileEntry = MyFileEntry->Next;
    }


    _tprintf( TEXT("\nThe following %sdrivers were found in all machines.\n"), 
              ExcludeMicrosoftDrivers 
               ? TEXT("Non-Microsoft ") 
               : TEXT("") );
    MyFileEntry = MasterFileList;
    while( MyFileEntry ) {
        if( MyFileEntry->RefCount == FilesProcessed ) {
            PrintNode(MyFileEntry);
        }
        MyFileEntry = MyFileEntry->Next;
    }

#else
    MyFileEntry = MasterFileList;
    while( MyFileEntry ) {
        PrintNode(MyFileEntry);        
        MyFileEntry = MyFileEntry->Next;
    }

#endif


}

 int
__cdecl
main( int   argc, char *argv[])
{
WCHAR       TmpDirectoryString[MAX_PATH];
WCHAR       TmpName[MAX_PATH];
PWSTR       p;
HANDLE      FindHandle;
WIN32_FIND_DATA FoundData;
DWORD       i;
#if 1
HANDLE      FileHandle;
DWORD       FileSize;
PVOID       FileBuffer;
BOOL        b;
PSTR        DirectoryName,FileName,Ptr,Ptr2;
CHAR        OldChar;
WCHAR       DName[MAX_PATH];
WCHAR       FName[MAX_PATH];
#endif

    
    //
    // Load Arguments.
    //
    if( argc < 2 ) {
        Usage( argv[0] );
        return 1;
    }

    if( !_stricmp("/m", argv[1]) || !_stricmp("-m",argv[1]) ) {
        printf( "Exculding all Microsoft Drivers.\n" );
        ExcludeMicrosoftDrivers = TRUE;
    }

#if 0
    swprintf( TmpDirectoryString, L"%S", argv[argc-1] );

    FindHandle = FindFirstFile( TmpDirectoryString, &FoundData );
    if( (FindHandle == INVALID_HANDLE_VALUE) || (FindHandle == NULL) ) {
        printf( "Failed to find file: %S\n", TmpDirectoryString );
        return 0;
    }

    p = wcsrchr(TmpDirectoryString, L'\\');
    *(p+1) = L'\0';


    DiamondInitialize();

    //
    // Look at every file like this one and populate our driver database.
    //
    do {

        if( !(FoundData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) ) {

            //printf( "    Processing file: %S\n", FoundData.cFileName );

            if (ProcessFile( TmpDirectoryString, FoundData.cFileName )) {
                FilesProcessed++;
            }

        }
    } while( FindNextFile( FindHandle, &FoundData ) );
#else

    DiamondInitialize();

    swprintf( TmpDirectoryString, L"%S", argv[argc-1] );
    FileHandle = CreateFile( TmpDirectoryString, GENERIC_READ, FILE_SHARE_READ, NULL, OPEN_EXISTING, 0, NULL );
    if( FileHandle == INVALID_HANDLE_VALUE) { return(FALSE); }
    FileSize = GetFileSize( FileHandle, NULL );
    if( FileSize == (DWORD)(-1) ) { return(FALSE); };
    
    FileBuffer = MyMalloc(FileSize + 3);
    if( FileBuffer == NULL ) {
        return -1;
    }

    b = (BOOLEAN)ReadFile( FileHandle, FileBuffer, FileSize, &i, NULL );
    CloseHandle( FileHandle );

    Ptr = (PSTR)FileBuffer;
    while(Ptr < (PCHAR)FileBuffer + FileSize) {
        Ptr2 = DirectoryName = Ptr;
        while(*Ptr2 != '\r') {
            Ptr2++;
        }
        Ptr = Ptr2+2;
        *Ptr2 = '\0';
        
        Ptr2 = strrchr(DirectoryName, '\\');
        Ptr2+=1;
        FileName = Ptr2;
        OldChar = *Ptr2;
        *Ptr2 = '\0';
        swprintf( DName, L"%S", DirectoryName );
        
        *Ptr2 = OldChar;
        swprintf( FName, L"%S", FileName );

        //printf( "    Processing file: %s\n", FileName );

        if (ProcessFile( DName, FName )) {
            //printf( "    Successfully processed: %s\n", FileName );
            FilesProcessed++;
        } else {
            //printf( "    Failed to process: %s\n", FileName );
        }
        
    }

#endif


    //
    // Print out one of the lists.  They should all be the same.
    //

    printf("Sucessfully processed %d files.\r\n", FilesProcessed);
    DumpFileList();


    DiamondTerminate();
    return 0;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\headless\test\cpp\emshello\emshello.cpp ===
#include <windows.h>
#include <winioctl.h>
#include <stdio.h>
#include <malloc.h>

#include <emsapi.h>

int _cdecl wmain(int argc, WCHAR **argv)
{
    EMSRawChannel*  channel;
    UCHAR       Buffer[256];
    ULONG       CharCount;
    UCHAR       AssembledString[1024];
    ULONG       TotalCharCount;
    SAC_CHANNEL_OPEN_ATTRIBUTES Attributes;

    //
    // Configure the new channel
    //
    RtlZeroMemory(&Attributes, sizeof(SAC_CHANNEL_OPEN_ATTRIBUTES));

    Attributes.Type             = ChannelTypeVTUTF8;
    Attributes.Name             = L"Hello";
    Attributes.Description      = NULL;
    Attributes.Flags            = 0;
    Attributes.CloseEvent       = NULL;
    Attributes.HasNewDataEvent  = NULL;
    Attributes.ApplicationType  = NULL;
    
    //
    // Open the Hello channel
    //
    channel = EMSRawChannel::Construct(Attributes);

    //
    // See if the channel was created
    //
    if (channel == NULL) {
        return 0;
    }

    do {
        
        //
        // Write to the Hello Channel
        //
        if (channel->Write(
            (PBYTE)"Hello, World! Type 'wow' to exit\r\n",
            sizeof("Hello, World! Type 'wow' to exit\r\n")
            )) {
            printf("Successfully printed string to channel\n");
        } else {
            printf("Failed to print string to channel\n");
            break;
        }

        //
        // Get remote user input
        //
        AssembledString[0] = '\0';
        TotalCharCount = 0;

        while(!(TotalCharCount == sizeof(AssembledString)-1))
        {

            //
            // Wait for remote user input
            //
            while(1) {

                BOOL    InputWaiting;

                if (channel->HasNewData(
                    &InputWaiting
                    ))
                {
                    if (InputWaiting) {
                        break;
                    }
                } else {
                    printf("Failed to poll channel\n");
                    break;
                }
            }
            
            if (channel->Read(
                Buffer,
                sizeof(Buffer),
                &CharCount
                )) {

                if (TotalCharCount + CharCount > sizeof(AssembledString)-1) {
                    CharCount = sizeof(AssembledString)-1 - TotalCharCount;
                }

                TotalCharCount += CharCount;

                strncat((CHAR*)AssembledString, (CHAR*)Buffer, CharCount);

            } else {
                printf("Failed to read channel\n");
                break;
            }

            //
            // echo string back to remote user
            // 
            if (channel->Write(
                (PBYTE)Buffer,
                CharCount
                )) {
                printf("Successfully printed string to channel\n");
            } else {
                printf("Failed to print string to channel\n");
                break;
            }
            
            if (strstr((CHAR*)AssembledString, "wow") != NULL) {

                //
                // Write to the Hello Channel
                //
                if (channel->Write(
                    (PBYTE)"\r\nExiting\r\n",
                    sizeof("\r\nExiting\r\n")
                    )) {
                    printf("Successfully printed string to channel\n");
                } else {
                    printf("Failed to print string to channel\n");
                }
                
                break;
            
            }
        }

    
    } while (FALSE);

    //
    // Close the Hello Channel
    //
    delete channel;

    return 0;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\headless\watcher\childfrm.h ===
// ChildFrm.h : interface of the CChildFrame class
//
/////////////////////////////////////////////////////////////////////////////

#if !defined(AFX_CHILDFRM_H__952CE458_7A87_478A_B722_0240CA1D831E__INCLUDED_)
#define AFX_CHILDFRM_H__952CE458_7A87_478A_B722_0240CA1D831E__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000


class CChildFrame : public CMDIChildWnd
{
	DECLARE_DYNCREATE(CChildFrame)
public:
	CChildFrame();

// Attributes
public:

// Operations
public:

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CChildFrame)
	virtual BOOL PreCreateWindow(CREATESTRUCT& cs);
	//}}AFX_VIRTUAL

// Implementation
public:
	virtual ~CChildFrame();
#ifdef _DEBUG
	virtual void AssertValid() const;
	virtual void Dump(CDumpContext& dc) const;
#endif

// Generated message map functions
protected:
	//{{AFX_MSG(CChildFrame)
		// NOTE - the ClassWizard will add and remove member functions here.
		//    DO NOT EDIT what you see in these blocks of generated code!
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

/////////////////////////////////////////////////////////////////////////////

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_CHILDFRM_H__952CE458_7A87_478A_B722_0240CA1D831E__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\headless\watcher\mainfrm.h ===
// MainFrm.h : interface of the CMainFrame class
//
/////////////////////////////////////////////////////////////////////////////

#if !defined(AFX_MAINFRM_H__38761070_0598_4D11_9F1E_BD4D0572E5BD__INCLUDED_)
#define AFX_MAINFRM_H__38761070_0598_4D11_9F1E_BD4D0572E5BD__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

class CMainFrame : public CMDIFrameWnd
{
	DECLARE_DYNAMIC(CMainFrame)
public:
	CMainFrame();

// Attributes
public:

// Operations
public:

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CMainFrame)
	virtual BOOL PreCreateWindow(CREATESTRUCT& cs);
	//}}AFX_VIRTUAL

// Implementation
public:
	virtual ~CMainFrame();
#ifdef _DEBUG
	virtual void AssertValid() const;
	virtual void Dump(CDumpContext& dc) const;
#endif

protected:  // control bar embedded members
	CStatusBar  m_wndStatusBar;

// Generated message map functions
protected:
	//{{AFX_MSG(CMainFrame)
	afx_msg int OnCreate(LPCREATESTRUCT lpCreateStruct);
		// NOTE - the ClassWizard will add and remove member functions here.
		//    DO NOT EDIT what you see in these blocks of generated code!
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

/////////////////////////////////////////////////////////////////////////////

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_MAINFRM_H__38761070_0598_4D11_9F1E_BD4D0572E5BD__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\headless\watcher\mainfrm.cpp ===
// MainFrm.cpp : implementation of the CMainFrame class
//

#include "stdafx.h"
#include "watcher.h"

#include "MainFrm.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CMainFrame

IMPLEMENT_DYNAMIC(CMainFrame, CMDIFrameWnd)

BEGIN_MESSAGE_MAP(CMainFrame, CMDIFrameWnd)
    //{{AFX_MSG_MAP(CMainFrame)
        // NOTE - the ClassWizard will add and remove mapping macros here.
        //    DO NOT EDIT what you see in these blocks of generated code !
    ON_WM_CREATE()
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

static UINT indicators[] =
{
    ID_SEPARATOR,           // status line indicator
    ID_INDICATOR_CAPS,
    ID_INDICATOR_NUM,
    ID_INDICATOR_SCRL,
};

/////////////////////////////////////////////////////////////////////////////
// CMainFrame construction/destruction

CMainFrame::CMainFrame()
{
    // TODO: add member initialization code here
    
}

CMainFrame::~CMainFrame()
{
}

int CMainFrame::OnCreate(LPCREATESTRUCT lpCreateStruct)
{
    if (CMDIFrameWnd::OnCreate(lpCreateStruct) == -1)
        return -1;
    
    if (!m_wndStatusBar.Create(this) ||
        !m_wndStatusBar.SetIndicators(indicators,
          sizeof(indicators)/sizeof(UINT)))
    {
        TRACE0("Failed to create status bar\n");
        return -1;      // fail to create
    }

    
    return 0;
}

BOOL CMainFrame::PreCreateWindow(CREATESTRUCT& cs)
{
    if( !CMDIFrameWnd::PreCreateWindow(cs) )
        return FALSE;
    // TODO: Modify the Window class or styles here by modifying
    //  the CREATESTRUCT cs

    return TRUE;
}

/////////////////////////////////////////////////////////////////////////////
// CMainFrame diagnostics

#ifdef _DEBUG
void CMainFrame::AssertValid() const
{
    CMDIFrameWnd::AssertValid();
}

void CMainFrame::Dump(CDumpContext& dc) const
{
    CMDIFrameWnd::Dump(dc);
}

#endif //_DEBUG

/////////////////////////////////////////////////////////////////////////////
// CMainFrame message handlers
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\headless\watcher\parameterdialog.cpp ===
// ParameterDialog.cpp : implementation file
//

#include "stdafx.h"
#include "watcher.h"
#include "ParameterDialog.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// ParameterDialog dialog


ParameterDialog::ParameterDialog(CWnd* pParent /*=NULL*/)
    : CDialog(ParameterDialog::IDD, pParent)
{
    //{{AFX_DATA_INIT(ParameterDialog)
        // NOTE: the ClassWizard will add member initialization here
    Machine = "";
    Command="";
    Port = TELNET_PORT;
    tcclnt = 0;
    language = 0;
	DeleteValue = FALSE;
    history = 0;
    //}}AFX_DATA_INIT
}


void ParameterDialog::DoDataExchange(CDataExchange* pDX)
{
    CDialog::DoDataExchange(pDX);
    //{{AFX_DATA_MAP(ParameterDialog)
        // NOTE: the ClassWizard will add DDX and DDV calls here
    DDX_Text(pDX, IDC_MACHINE, Machine);
    DDV_MaxChars(pDX, Machine, 256);
    DDX_Text(pDX, IDC_COMMAND, Command);    
    DDV_MaxChars(pDX, Command, 256);
    DDX_Text(pDX, IDC_LOGIN, LoginName);    
    DDV_MaxChars(pDX, Command, 256);
    DDX_Text(pDX, IDC_PASSWD, LoginPasswd);    
    DDV_MaxChars(pDX, Command, 256);
    DDX_Text(pDX, IDC_SESSION, Session);    
    DDV_MaxChars(pDX, Session, 256);
	DDV_MinChars(pDX,Session);
    DDX_Text(pDX,IDC_PORT, Port);
    DDX_CBIndex(pDX,IDC_HISTORY,history);
    DDX_CBIndex(pDX,IDC_TELNET,tcclnt);
    DDX_CBIndex(pDX,IDC_LANGUAGE,language);
    //}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(ParameterDialog, CDialog)
    //{{AFX_MSG_MAP(ParameterDialog)
        // NOTE: the ClassWizard will add message map macros here
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// ParameterDialog message handlers



void ParameterDialog::DDV_MinChars(CDataExchange *pDX, CString &str)
{
	if(pDX->m_bSaveAndValidate == FALSE){
		return;
	}

	if(str == TEXT("")){
		pDX->Fail();
		return;
	}

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\headless\watcher\childfrm.cpp ===
// ChildFrm.cpp : implementation of the CChildFrame class
//
#include "StdAfx.h"
#include "watcher.h"

#include "ChildFrm.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CChildFrame

IMPLEMENT_DYNCREATE(CChildFrame, CMDIChildWnd)

BEGIN_MESSAGE_MAP(CChildFrame, CMDIChildWnd)
	//{{AFX_MSG_MAP(CChildFrame)
		// NOTE - the ClassWizard will add and remove mapping macros here.
		//    DO NOT EDIT what you see in these blocks of generated code !
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CChildFrame construction/destruction

CChildFrame::CChildFrame()
{
	// TODO: add member initialization code here
	
}

CChildFrame::~CChildFrame()
{
}

BOOL CChildFrame::PreCreateWindow(CREATESTRUCT& cs)
{
	// TODO: Modify the Window class or styles here by modifying
	//  the CREATESTRUCT cs

	if( !CMDIChildWnd::PreCreateWindow(cs) )
		return FALSE;

	return TRUE;
}



/////////////////////////////////////////////////////////////////////////////
// CChildFrame diagnostics

#ifdef _DEBUG
void CChildFrame::AssertValid() const
{
	CMDIChildWnd::AssertValid();
}

void CChildFrame::Dump(CDumpContext& dc) const
{
	CMDIChildWnd::Dump(dc);
}

#endif //_DEBUG

/////////////////////////////////////////////////////////////////////////////
// CChildFrame message handlers
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\headless\watcher\managedialog.h ===
#if !defined(AFX_MANAGEDIALOG_H__AEF13AD1_98C6_4DDF_80F8_F74873918D25__INCLUDED_)
#define AFX_MANAGEDIALOG_H__AEF13AD1_98C6_4DDF_80F8_F74873918D25__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000
// ManageDialog.h : header file
//
#include "watcher.h"
#include "ParameterDialog.h"
/////////////////////////////////////////////////////////////////////////////
// ManageDialog dialog

class ManageDialog : public CDialog
{
// Construction
public:
        void SetApplicationPtr(CWatcherApp *watcher);
        ManageDialog(CWnd* pParent = NULL);   // standard constructor

// Dialog Data
        //{{AFX_DATA(ManageDialog)
        enum { IDD = Manage };
                // NOTE: the ClassWizard will add data members here
        //}}AFX_DATA


// Overrides
        // ClassWizard generated virtual function overrides
        //{{AFX_VIRTUAL(ManageDialog)
        protected:
        virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
        //}}AFX_VIRTUAL

// Implementation
protected:
        CWatcherApp *m_watcher;
        int m_Index;
        UINT Port;
        int lang;
        int tc;
        int hist;
        CString Session;
        CString LoginPasswd;
        CString LoginName;
        CString language;
        CString tcclnt;
        CString Command;
        CString Machine;
        CString history;

        void GetSetParameters(ParameterDialog &pd);
        int SetParameters(CString &mac, 
                          CString &com, 
                          CString &lgnName, 
                          CString &lgnPasswd, 
                          UINT port, 
                          int lang, 
                          int tc,
                          int hist,
                          HKEY &child
                          );
        // Generated message map functions
        //{{AFX_MSG(ManageDialog)
        afx_msg void OnEditButton();
        afx_msg void OnDeleteButton();
        afx_msg void OnNewButton();
        afx_msg void OnNextButton();
        afx_msg void OnPrevButton();
        virtual void OnOK();
        //}}AFX_MSG
        DECLARE_MESSAGE_MAP()
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_MANAGEDIALOG_H__AEF13AD1_98C6_4DDF_80F8_F74873918D25__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\headless\watcher\managedialog.cpp ===
// ManageDialog.cpp : implementation file
//

#include "stdafx.h"
#include "ManageDialog.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// ManageDialog dialog


ManageDialog::ManageDialog(CWnd* pParent /*=NULL*/)
:CDialog(ManageDialog::IDD, pParent),
 m_watcher(NULL),
 m_Index(0),
 Port(23),
 lang(0),
 tc(0),
 hist(0)
{
    //{{AFX_DATA_INIT(ManageDialog)
    // NOTE: the ClassWizard will add member initialization here
    //}}AFX_DATA_INIT
}


void ManageDialog::DoDataExchange(CDataExchange* pDX)
{
    CDialog::DoDataExchange(pDX);
    CEdit *ctrl;
    BOOL ret;
    
    //{{AFX_DATA_MAP(ManageDialog)
    ctrl = (CEdit *)GetDlgItem(IDC_MACHINE_NAME_MANAGE);
    ret = ctrl->SetReadOnly(FALSE);
    DDX_Text(pDX, IDC_MACHINE_NAME_MANAGE, Machine);
    ret = ctrl->SetReadOnly(TRUE);
    ctrl = (CEdit *)GetDlgItem(IDC_COMMAND_MANAGE);
    ret = ctrl->SetReadOnly(FALSE);
    DDX_Text(pDX, IDC_COMMAND_MANAGE, Command);    
    ret = ctrl->SetReadOnly(TRUE);
    ctrl = (CEdit *)GetDlgItem(IDC_LOGIN_MANAGE);
    ret = ctrl->SetReadOnly(FALSE);
    DDX_Text(pDX, IDC_LOGIN_MANAGE, LoginName);    
    ret = ctrl->SetReadOnly(TRUE);
    ctrl = (CEdit *)GetDlgItem(IDC_PASSWD_MANAGE);
    ret = ctrl->SetReadOnly(FALSE);
    DDX_Text(pDX, IDC_PASSWD_MANAGE, LoginPasswd);    
    ret = ctrl->SetReadOnly(TRUE);
    ctrl = (CEdit *)GetDlgItem(IDC_SESSION_MANAGE);
    ret = ctrl->SetReadOnly(FALSE);
    DDX_Text(pDX, IDC_SESSION_MANAGE, Session);    
    ret = ctrl->SetReadOnly(TRUE);
    ctrl = (CEdit *)GetDlgItem(IDC_PORT_MANAGE);
    ret = ctrl->SetReadOnly(FALSE);
    DDX_Text(pDX,IDC_PORT_MANAGE, Port);
    ret = ctrl->SetReadOnly(TRUE);
    ctrl = (CEdit *)GetDlgItem(IDC_CLIENT_MANAGE);
    ret = ctrl->SetReadOnly(FALSE);
    DDX_Text(pDX,IDC_CLIENT_MANAGE,tcclnt);
    ret = ctrl->SetReadOnly(TRUE);
    ctrl = (CEdit *)GetDlgItem(IDC_LANGUAGE_MANAGE);
    ret = ctrl->SetReadOnly(FALSE);
    DDX_Text(pDX,IDC_LANGUAGE_MANAGE,language);
    ret = ctrl->SetReadOnly(TRUE);
    ctrl = (CEdit *)GetDlgItem(IDC_HISTORY_MANAGE);
    ret = ctrl->SetReadOnly(FALSE);
    DDX_Text(pDX,IDC_HISTORY_MANAGE,history);
    ret = ctrl->SetReadOnly(TRUE);
    // NOTE: the ClassWizard will add DDX and DDV calls here
    //}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(ManageDialog, CDialog)
    //{{AFX_MSG_MAP(ManageDialog)
    ON_BN_CLICKED(EDIT_BUTTON, OnEditButton)
    ON_BN_CLICKED(DELETE_BUTTON, OnDeleteButton)
    ON_BN_CLICKED(NEW_BUTTON, OnNewButton)
    ON_BN_CLICKED(NEXT_BUTTON, OnNextButton)
    ON_BN_CLICKED(PREV_BUTTON, OnPrevButton)
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// ManageDialog message handlers

void ManageDialog::OnEditButton() 
{
    // TODO: Add your control notification handler code here
    ParameterDialog pd;

    pd.Session = (LPCTSTR) Session;
    pd.Machine = (LPCTSTR) Machine;
    pd.Command = (LPCTSTR) Command;
    CString temp;
    pd.language = lang;
    pd.tcclnt = tc;
    pd.history = hist;
    pd.LoginName = (LPCTSTR) LoginName;
    pd.LoginPasswd = (LPCTSTR) LoginPasswd;
    pd.Port = Port;
    GetSetParameters(pd);
    if(m_watcher){
        int ret = m_watcher->GetParametersByIndex(m_Index,
                                                  Session,
                                                  Machine,
                                                  Command,
                                                  Port,
                                                  lang,
                                                  tc,
                                                  hist,
                                                  LoginName,
                                                  LoginPasswd
                                                  );
        if(ret == ERROR_SUCCESS){
            language.LoadString(IDS_ENGLISH + lang);
            tcclnt.LoadString(IDS_TELNET + tc);
            history.LoadString(IDS_NO + hist);
        }
    }
    UpdateData(FALSE);
}

void ManageDialog::OnDeleteButton() 
{
    // TODO: Add your control notification handler code here
    HKEY &m_hkey = m_watcher->GetKey();

    if(!m_hkey){
        return;
    }
    int RetVal = RegDeleteKey(m_hkey,
                              (LPCTSTR) Session
                              );
    if (RetVal == ERROR_SUCCESS){
        m_Index = m_Index ? m_Index -1 : 0;
        if(m_watcher){
            ParameterDialog pd;
            pd.Session = Session;
            m_watcher->Refresh(pd,TRUE);
            RetVal = m_watcher->GetParametersByIndex(m_Index,
                                                     Session,
                                                     Machine,
                                                     Command,
                                                     Port,
                                                     lang,
                                                     tc,
                                                     hist,
                                                     LoginName,
                                                     LoginPasswd
                                                     );
            if(RetVal == ERROR_SUCCESS){
                language.LoadString(IDS_ENGLISH + lang);
                tcclnt.LoadString(IDS_TELNET + tc);
                history.LoadString(IDS_NO + hist);
            }
        }
    }
    UpdateData(FALSE);

}

void ManageDialog::OnNewButton() 
{
    // TODO: Add your control notification handler code here
    ParameterDialog pd;
    GetSetParameters(pd);

}

void ManageDialog::OnNextButton() 
{
    // TODO: Add your control notification handler code here
    int ret = 0;

    m_Index ++;
    if(m_watcher){
        ret = m_watcher->GetParametersByIndex(m_Index,
                                              Session,
                                              Machine,
                                              Command,
                                              Port,
                                              lang,
                                              tc,
                                              hist,
                                              LoginName,
                                              LoginPasswd
                                              );
        if(ret == ERROR_SUCCESS){
            language.LoadString(IDS_ENGLISH + lang);
            tcclnt.LoadString(IDS_TELNET + tc);
            history.LoadString(IDS_NO + hist);
        }
    }
    if (ret != 0){
        m_Index --;
        if(m_watcher){
            ret = m_watcher->GetParametersByIndex(m_Index,
                                                  Session,
                                                  Machine,
                                                  Command,
                                                  Port,
                                                  lang,
                                                  tc,
                                                  hist,
                                                  LoginName,
                                                  LoginPasswd
                                                  ); 
            if(ret == ERROR_SUCCESS){
                language.LoadString(IDS_ENGLISH + lang);
                tcclnt.LoadString(IDS_TELNET + tc);
                history.LoadString(IDS_NO + hist);
            }
        }
    }
    UpdateData(FALSE);
    return;

}

void ManageDialog::OnPrevButton() 
{
    // TODO: Add your control notification handler code here
    int ret = 0;

    m_Index = m_Index ? m_Index -1 : 0;
    if(m_watcher){
        ret = m_watcher->GetParametersByIndex(m_Index,
                                              Session,
                                              Machine,
                                              Command,
                                              Port,
                                              lang,
                                              tc,
                                              hist,
                                              LoginName,
                                              LoginPasswd
                                              );
        if(ret == ERROR_SUCCESS){
            language.LoadString(IDS_ENGLISH + lang);
            tcclnt.LoadString(IDS_TELNET + tc);
            history.LoadString(IDS_NO + hist);
        } 
    }
    if (ret != 0){
        m_Index =0;
        if(m_watcher){
            ret = m_watcher->GetParametersByIndex(m_Index,
                                                  Session,
                                                  Machine,
                                                  Command,
                                                  Port,
                                                  lang,
                                                  tc,
                                                  hist,
                                                  LoginName,
                                                  LoginPasswd
                                                  );
            if(ret == ERROR_SUCCESS){
                language.LoadString(IDS_ENGLISH + lang);
                tcclnt.LoadString(IDS_TELNET + tc);
                history.LoadString(IDS_NO + hist);
            }
        }
    }
    UpdateData(FALSE);
    return;
}

void ManageDialog::OnOK() 
{
    // TODO: Add extra validation here

    CDialog::OnOK();
}

void ManageDialog::SetApplicationPtr(CWatcherApp *watcher)
{

    int ret = 0;

    m_watcher = watcher;
    if(m_watcher){
        ret = m_watcher->GetParametersByIndex(m_Index,
                                              Session,
                                              Machine,
                                              Command,
                                              Port,
                                              lang,
                                              tc,
                                              hist,
                                              LoginName,
                                              LoginPasswd
                                              );
        if(ret == ERROR_SUCCESS){
            language.LoadString(IDS_ENGLISH + lang);
            tcclnt.LoadString(IDS_TELNET + tc);
            history.LoadString(IDS_NO + hist);
        }
    }
}

void ManageDialog::GetSetParameters(ParameterDialog &pd)
{
    HKEY m_child;

    INT_PTR ret = pd.DoModal();
    if (ret == IDOK){
        // Add it to the registry
        if(m_watcher){
            HKEY & m_hkey = m_watcher->GetKey();
            ret = RegCreateKeyEx(m_hkey,
                                 (LPCTSTR) pd.Session,   // subkey name
                                 0,                      // reserved
                                 NULL,                   // class string
                                 0,                      // special options
                                 KEY_ALL_ACCESS,         // desired security access
                                 NULL,                   // inheritance
                                 &m_child,               // key handle
                                 NULL                    // disposition value buffer
                                 );
            if (ret == ERROR_SUCCESS){
                ret = SetParameters(pd.Machine, pd.Command,
                                    pd.LoginName, pd.LoginPasswd,
                                    pd.Port, pd.language,
                                    pd.tcclnt,pd.history,
                                    m_child
                                    );
                if(ret == ERROR_SUCCESS){
                    m_watcher->Refresh(pd,FALSE);
                }
            }  
        }else{
            return;
        }
    }
}

int ManageDialog::SetParameters(CString &mac, 
                                CString &com, 
                                CString &lgnName, 
                                CString &lgnPasswd, 
                                UINT port, 
                                int lang, 
                                int tc, 
                                int hist,
                                HKEY &child
                                )
{
    DWORD lpcName;
    const TCHAR *lpName;
    int RetVal;
    int charSize = sizeof(TCHAR);

    lpcName = MAX_BUFFER_SIZE;
    lpName = (LPCTSTR) mac;
    lpcName = (mac.GetLength())*charSize;
    RetVal = RegSetValueEx(child,
                           _TEXT("Machine"),
                           NULL,  
                           REG_SZ,
                           (LPBYTE) lpName,
                           lpcName
                           );
    if(RetVal != ERROR_SUCCESS){
        return RetVal;
    }
    lpName = (LPCTSTR) com;
    lpcName = (com.GetLength())*charSize;
    RetVal = RegSetValueEx(child,
                           _TEXT("Command"),
                           NULL,  
                           REG_SZ,
                           (LPBYTE)lpName,
                           lpcName
                           );
    if(RetVal != ERROR_SUCCESS){
        return RetVal;
    }
    lpName = (LPCTSTR) lgnName;
    lpcName = (lgnName.GetLength())*charSize;
    RetVal = RegSetValueEx(child,
                           _TEXT("User Name"),
                           NULL,  
                           REG_SZ,
                           (LPBYTE)lpName,
                           lpcName
                           );
    if(RetVal != ERROR_SUCCESS){
        return RetVal;
    }
    lpName = (LPCTSTR) lgnPasswd;
    lpcName = (lgnPasswd.GetLength())*charSize;
    RetVal = RegSetValueEx(child,
                           _TEXT("Password"),
                           NULL,  
                           REG_SZ,
                           (LPBYTE)lpName,
                           lpcName
                           );
    if(RetVal != ERROR_SUCCESS){
        return RetVal;
    }

    lpcName = sizeof(UINT);
    RetVal = RegSetValueEx(child,
                           _TEXT("Port"),
                           NULL,  
                           REG_DWORD,
                           (LPBYTE)&port,
                           lpcName
                           );
    if(RetVal != ERROR_SUCCESS){
        return RetVal;
    }
    lpcName = sizeof(DWORD);
    RetVal = RegSetValueEx(child,
                           _TEXT("Client Type"),
                           NULL,  
                           REG_DWORD,
                           (LPBYTE)&tc,
                           lpcName
                           );
    if(RetVal != ERROR_SUCCESS){
        return RetVal;
    }
    lpcName = sizeof(DWORD);
    RetVal = RegSetValueEx(child,
                           _TEXT("Language"),
                           NULL,  
                           REG_DWORD,
                           (LPBYTE)&lang,
                           lpcName
                           );
    if(RetVal != ERROR_SUCCESS){
        return RetVal;
    }
    lpcName = sizeof(DWORD);
    RetVal = RegSetValueEx(child,
                           _TEXT("History"),
                           NULL,  
                           REG_DWORD,
                           (LPBYTE)&hist,
                           lpcName
                           );  
    if(RetVal != ERROR_SUCCESS){
        return RetVal;
    }
    // Now you can refresh the application.

    return RetVal;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\headless\watcher\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//	watcher.pch will be the pre-compiled header
//	stdafx.obj will contain the pre-compiled type information

#include "StdAfx.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\headless\watcher\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by watcher.rc
//
#define IDD_ABOUTBOX                    100
#define IDP_SOCKETS_INIT_FAILED         104
#define IDR_MAINFRAME                   128
#define IDR_WATCHETYPE                  129
#define Parameters                      130
#define Manage                          133
#define IDC_MACHINE_STATIC              1000
#define IDC_PORT_STATIC                 1001
#define IDC_COMMAND_CAPTION             1002
#define IDC_MACHINE                     1003
#define IDC_PORT                        1004
#define IDC_COMMAND                     1005
#define IDC_CLIENT_MANAGE               1006
#define IDC_TELNET                      1008
#define IDC_COMBO_STATIC                1009
#define IDC_LANGUAGE_STATIC             1010
#define IDC_LANGUAGE                    1011
#define IDC_LOGIN                       1012
#define IDC_STATIC_LOGIN                1013
#define IDC_PASSWD                      1014
#define NEW_BUTTON                      1014
#define IDC_STATIC_PASSWD               1015
#define DELETE_BUTTON                   1015
#define IDC_SESSION                     1016
#define EDIT_BUTTON                     1016
#define IDC_STATIC_SESSION              1017
#define NEXT_BUTTON                     1017
#define PREV_BUTTON                     1018
#define IDC_HISTORY                     1018
#define IDC_PASSWD_MANAGE               1019
#define IDC_STATIC_HISTORY              1019
#define IDC_STATIC_PASSWD_MANAGE        1020
#define IDC_SESSION_MANAGE              1021
#define IDC_STATIC_SESSION_MANAGE       1022
#define IDC_MACHINE_STATIC_MANAGE       1023
#define IDC_PORT_STATIC_MANAGE          1024
#define IDC_COMMAND_CAPTION_MANAGE      1025
#define IDC_COMBO_STATIC_MANAGE         1026
#define IDC_LANGUAGE_STATIC_MANAGE      1027
#define IDC_STATIC_LOGIN_MANAGE         1028
#define IDC_LOGIN_MANAGE                1029
#define IDC_LANGUAGE_MANAGE             1030
#define IDC_COMMAND_MANAGE              1031
#define IDC_PORT_MANAGE                 1032
#define IDC_MACHINE_NAME_MANAGE         1033
#define IDC_HISTORY_MANAGE              1034
#define IDC_STATIC_HISTORY_MANAGE       1035
#define ID_APP_PARAMETERS_SAVE          32774
#define ID_FILE_MANAGE                  32775
#define AFX_IDS_APP_PROFILE             57346
#define AFX_IDS_COMPANY                 57347
#define IDS_TELNET                      61446
#define IDS_TC                          61447
#define IDS_NO                          61448
#define IDS_YES                         61449
#define IDS_ENGLISH                     61450
#define IDS_JAPANESE                    61451
#define IDS_EUROPEAN                    61452
#define CREATE_WMI_OBJECT_FAILURE       61453
#define CREATE_TEXT_SRC_FAILURE         61454
#define CREATE_TC_SOCKET_FAILURE        61455
#define CREATE_TELNET_SOCKET_FAILURE    61456
#define CDC_TEXT_FAILURE                61457
#define SOCKET_CONNECTION_FAILED        61458
#define SOCKET_CREATION_FAILED          61459

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_3D_CONTROLS                     1
#define _APS_NEXT_RESOURCE_VALUE        136
#define _APS_NEXT_COMMAND_VALUE         32776
#define _APS_NEXT_CONTROL_VALUE         1035
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\headless\watcher\watcher.cpp ===
// watcher.cpp : Defines the class behaviors for the application.
//
#include "StdAfx.h"
#include "watcher.h"

#include "MainFrm.h"
#include "ChildFrm.h"
#include "watcherDoc.h"
#include "watcherView.h"
#include "ManageDialog.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CWatcherApp

BEGIN_MESSAGE_MAP(CWatcherApp, CWinApp)
    //{{AFX_MSG_MAP(CWatcherApp)
    ON_COMMAND(ID_APP_ABOUT, OnAppAbout)
    ON_COMMAND(ID_APP_EXIT, OnAppExit)
    //}}AFX_MSG_MAP
    // Standard file based document commands
    ON_COMMAND(ID_FILE_MANAGE,OnFileManage)
    ON_COMMAND(ID_DEFAULT_HELP, OnHelp)
    // Standard print setup command
    ON_COMMAND(ID_FILE_PRINT_SETUP, CWinApp::OnFilePrintSetup)
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CWatcherApp construction

CWatcherApp::CWatcherApp()
:m_hkey(NULL),
 m_pDocTemplate(NULL),
 m_pManageDialog(NULL)
{
        // TODO: add construction code here,
        // Place all significant initialization in InitInstance
}

/////////////////////////////////////////////////////////////////////////////
// The one and only CWatcherApp object

CWatcherApp theApp;

/////////////////////////////////////////////////////////////////////////////
// CWatcherApp initialization

BOOL CWatcherApp::InitInstance()
{
    if (!AfxSocketInit()){
        AfxMessageBox(IDP_SOCKETS_INIT_FAILED);
        return FALSE;
    }

    AfxEnableControlContainer();

    // Standard initialization
    // If you are not using these features and wish to reduce the size
    //  of your final executable, you should remove from the following
    //  the specific initialization routines you do not need.

    #ifdef _AFXDLL
    Enable3dControls();                     // Call this when using MFC in a shared DLL
    #else
    Enable3dControlsStatic();       // Call this when linking to MFC statically
    #endif

    // Change the registry key under which our settings are stored.
    // TODO: You should modify this string to be something appropriate
    // such as the name of your company or organization.
    // will do this in the ProcessShellCommand part.....

    //      SetRegistryKey(AFX_IDS_COMPANY);

    LoadStdProfileSettings();  // Load standard INI file options (including MRU)

    // Register the application's document templates.  Document templates
    //  serve as the connection between documents, frame windows and views.

    m_pDocTemplate = new CMultiDocTemplate(IDR_WATCHETYPE,
                                           RUNTIME_CLASS(CWatcherDoc),
                                           RUNTIME_CLASS(CChildFrame),
                                           // custom MDI child frame
                                           RUNTIME_CLASS(CWatcherView));
    if(!m_pDocTemplate){
        // Will almost never occur , but ...
        // Oops !!
        return FALSE;
    }
    AddDocTemplate(m_pDocTemplate);

    // create main MDI Frame window
    CMainFrame* pMainFrame = new CMainFrame;
    if(!pMainFrame){
        // Will almost never occur , but ...
        // Oops !!
        return FALSE;
    }

    if (!pMainFrame->LoadFrame(IDR_MAINFRAME))
        return FALSE;
    m_pMainWnd = pMainFrame;

    // Parse command line for standard shell commands, DDE, file open
    CCommandLineInfo cmdInfo;
    ParseCommandLine(cmdInfo);

    // The main window has been initialized, so show and update it.
    pMainFrame->ShowWindow(m_nCmdShow);
    pMainFrame->UpdateWindow();
    // Dispatch commands specified on the command line
    m_hkey = GetAppRegistryKey();

    if(m_hkey == NULL){
        return FALSE;
    }
    if (!ProcessShellCommand(cmdInfo))
        return FALSE;
    // Get the value of the key in the registry where all the parameters are stored.

    return TRUE;
}


/////////////////////////////////////////////////////////////////////////////
// CAboutDlg dialog used for App About

class CAboutDlg : public CDialog
{
public:
    CAboutDlg();

    // Dialog Data
    //{{AFX_DATA(CAboutDlg)
    enum { IDD = IDD_ABOUTBOX };
    //}}AFX_DATA

    // ClassWizard generated virtual function overrides
    //{{AFX_VIRTUAL(CAboutDlg)
protected:
    virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
    //}}AFX_VIRTUAL

    // Implementation
protected:
    //{{AFX_MSG(CAboutDlg)
    // No message handlers
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()
};

CAboutDlg::CAboutDlg() : CDialog(CAboutDlg::IDD)
{
    //{{AFX_DATA_INIT(CAboutDlg)
    //}}AFX_DATA_INIT
}

void CAboutDlg::DoDataExchange(CDataExchange* pDX)
{
    CDialog::DoDataExchange(pDX);
    //{{AFX_DATA_MAP(CAboutDlg)
    //}}AFX_DATA_MAP
}

BEGIN_MESSAGE_MAP(CAboutDlg, CDialog)
    //{{AFX_MSG_MAP(CAboutDlg)
    // No message handlers
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

// App command to run the dialog
void CWatcherApp::OnAppAbout()
{
    CAboutDlg aboutDlg;
    aboutDlg.DoModal();
}

/////////////////////////////////////////////////////////////////////////////
// CWatcherApp message handlers


void CWatcherApp::OnFileManage(){
    // Here we bring up the manage window.

    if (m_pManageDialog){
        m_pManageDialog->ShowWindow(SW_SHOWNORMAL);
        return;
    }
    // Actually construct the dialog box here
    m_pManageDialog = new ManageDialog();
    if( !m_pManageDialog){
        // Oops!! Memory problem
        return;
    }
    ((ManageDialog *) m_pManageDialog)->SetApplicationPtr(this);
    m_pManageDialog->Create(Manage);
    m_pManageDialog->ShowWindow(SW_SHOWNORMAL);
    return;
}


void CWatcherApp::OnHelp()
{
    // Need to expand on this a little bit.
    CWinApp::WinHelp(0,HELP_CONTENTS);
}

void CWatcherApp::ParseCommandLine(CCommandLineInfo& rCmdInfo)
{
    BOOL setReg = FALSE;
    for (int i = 1; i < __argc; i++){
        LPCTSTR pszParam = __targv[i];
        BOOL bFlag = FALSE;
        BOOL bLast = ((i + 1) == __argc);
        if (pszParam[0] == '-' || pszParam[0] == '/'){
            // remove flag specifier
            bFlag = TRUE;
            ++pszParam;
            if (_tcscmp(pszParam, TEXT("r")) == 0){
                // we are being given a new registry profile string
                // Can only change this from watcher.
                // HKEY_CURRENT_USER\\SOFTWARE\\%KEY%\\WATCHER
                if(!bLast) {
                    // the next argument is the string
                    SetRegistryKey(__targv[i+1]);
                    i++;
                    setReg = TRUE;
                    if(i==__argc){
                        if (rCmdInfo.m_nShellCommand == CCommandLineInfo::FileNew && !rCmdInfo.m_strFileName.IsEmpty())
                            rCmdInfo.m_nShellCommand = CCommandLineInfo::FileOpen;
                        rCmdInfo.m_bShowSplash = !rCmdInfo.m_bRunEmbedded && !rCmdInfo.m_bRunAutomated;
                    }
                    continue;
                }

            }
        }
        rCmdInfo.ParseParam(pszParam, bFlag, bLast);
    }
    if(!setReg){
        SetRegistryKey(AFX_IDS_COMPANY);
    }
}

BOOL CWatcherApp::ProcessShellCommand(CCommandLineInfo& rCmdInfo)
{
    BOOL bResult = TRUE;
    switch (rCmdInfo.m_nShellCommand)
        {
    case CCommandLineInfo::FileNew:
        // Load parameters from the registry
        bResult = LoadRegistryParameters();
    break;

    // If we've been asked to open a file, call OpenDocumentFile()

    case CCommandLineInfo::FileOpen:
        // cannot happen ...... maybe later allow the user to read
        // parameters from a file.
        break;

    // If the user wanted to print, hide our main window and
    // fire a message to ourselves to start the printing

    case CCommandLineInfo::FilePrintTo:
    case CCommandLineInfo::FilePrint:
        m_nCmdShow = SW_HIDE;
    ASSERT(m_pCmdInfo == NULL);
    OpenDocumentFile(rCmdInfo.m_strFileName);
    m_pCmdInfo = &rCmdInfo;
    m_pMainWnd->SendMessage(WM_COMMAND, ID_FILE_PRINT_DIRECT);
    m_pCmdInfo = NULL;
    bResult = FALSE;
    break;

    // If we're doing DDE, hide ourselves

    case CCommandLineInfo::FileDDE:
//        m_pCmdInfo = (CCommandLineInfo*)m_nCmdShow;
    m_nCmdShow = SW_HIDE;
    break;

    // If we've been asked to unregister, unregister and then terminate
    case CCommandLineInfo::AppUnregister:
        {
        UnregisterShellFileTypes();
        BOOL bUnregistered = Unregister();

        // if you specify /EMBEDDED, we won't make an success/failure box
        // this use of /EMBEDDED is not related to OLE

        if (!rCmdInfo.m_bRunEmbedded)
            {
            if (bUnregistered)
                AfxMessageBox(AFX_IDP_UNREG_DONE);
            else
                AfxMessageBox(AFX_IDP_UNREG_FAILURE);
        }
        bResult = FALSE;    // that's all we do

        // If nobody is using it already, we can use it.
        // We'll flag that we're unregistering and not save our state
        // on the way out. This new object gets deleted by the
        // app object destructor.

        if (m_pCmdInfo == NULL)
            {
            m_pCmdInfo = new CCommandLineInfo;
            m_pCmdInfo->m_nShellCommand = CCommandLineInfo::AppUnregister;
        }
    }
    break;
    }
    return bResult;
}

BOOL CWatcherApp::LoadRegistryParameters()
{

    DWORD dwIndex=0;
    CString sess,lgnName, lgnPasswd;
    CString mac, com;
    UINT port;
    LONG RetVal;
    int tc, lang,hist;


    //Get each session parameters from here
    // There are NO optional values.

    while(1){
        RetVal = GetParametersByIndex(dwIndex,
                                      sess,
                                      mac,
                                      com,
                                      port,
                                      lang,
                                      tc,
                                      hist,
                                      lgnName,
                                      lgnPasswd
                                      );
        if(RetVal == ERROR_NO_MORE_ITEMS){
            return TRUE;
        }
        if (RetVal != ERROR_SUCCESS) {
            return FALSE;
        }
        // Make sure that the string buffers are NOT shared by locking
        // them.
        mac.LockBuffer();
        com.LockBuffer();
        lgnName.LockBuffer();
        lgnPasswd.LockBuffer();
        sess.LockBuffer();        // Passing references is really cool.
        CreateNewSession(mac, com, port,lang, tc, hist,lgnName, lgnPasswd,sess);
        dwIndex ++;
    }
    return TRUE;
}

int CWatcherApp::GetParametersByIndex(int dwIndex,
                                      CString &sess,
                                      CString &mac,
                                      CString &com,
                                      UINT &port,
                                      int &lang,
                                      int &tc,
                                      int &hist,
                                      CString &lgnName,
                                      CString &lgnPasswd
                                      )
{
    LONG RetVal;
    TCHAR lpName[MAX_BUFFER_SIZE];
    DWORD lpcName;
    FILETIME lpftLastWriteTime;
    HKEY child;
    DWORD lpType = 0;


    if (m_hkey == NULL) return -1;
    lpcName = MAX_BUFFER_SIZE;
    RetVal = RegEnumKeyEx(m_hkey,
                      dwIndex,
                      lpName,
                      &lpcName,
                      NULL,
                      NULL,
                      NULL,
                      &lpftLastWriteTime
                          );
    if(RetVal == ERROR_NO_MORE_ITEMS){
        return RetVal;
    }

    if(RetVal != ERROR_SUCCESS){
        RegCloseKey(m_hkey);
        m_hkey = NULL;
        return FALSE;
    }

    sess = lpName;
    RetVal= RegOpenKeyEx(m_hkey,
                         lpName,  // subkey name
                         0,   // reserved
                         KEY_ALL_ACCESS, // security access mask
                         &child
                         );
    if(RetVal != ERROR_SUCCESS){
        // Hmm problem with main key itself
        RegCloseKey(m_hkey);
        m_hkey = NULL;
        return RetVal;
    }
    // We open the key corresponding to the session and then try to
    // obtain the parameters. Now, we need a lock possibly to achieve
    // synchronization.That would be a complete solution.
    // Use some kind of readers-writers solution.
    // Fault tolerant ???
    // Get the remaining parameters.
    RetVal = GetParameters(mac,
                           com,
                           lgnName,
                           lgnPasswd,
                           port,
                           lang,
                           tc,
                           hist,
                           child
                           );
    RegCloseKey(child);
    return RetVal;
}

void CWatcherApp::CreateNewSession(CString &mac,
                                   CString &com,
                                   UINT port,
                                   int lang,
                                   int tc,
                                   int hist,
                                   CString &lgnName,
                                   CString &lgnPasswd,
                                   CString &sess
                                   )
{
    CCreateContext con;
    CChildFrame *cmdiFrame;

    con.m_pNewViewClass = RUNTIME_CLASS(CWatcherView);
    con.m_pCurrentFrame = NULL;
    con.m_pNewDocTemplate = m_pDocTemplate;

    // A new document is created using these parameters.
    // BUGBUG - Memory inefficiency :-(
    // This function must be shared between the ManageDialog and
    // the Watcher Application.
    // Will probably declare them as friends of each other.
    // For the moment , let use have two copies of the function.
    con.m_pCurrentDoc = new CWatcherDoc(mac,
                                        com,
                                        port,
                                        tc,
                                        lang,
                                        hist,
                                        lgnName,
                                        lgnPasswd,
                                        sess
                                        );
    // Add the document to the template.
    // this is how the document is available to the document
    // manager.
    if(!con.m_pCurrentDoc){
        // Can occur if you keep on opening newer sessions.
        // Oops !!
        return;
    }
    m_pDocTemplate->AddDocument(con.m_pCurrentDoc);
    cmdiFrame = new CChildFrame();
    if(!cmdiFrame){
        // Oops !!
        return;
    }
    BOOL ret = cmdiFrame->LoadFrame(IDR_WATCHETYPE,
                               WS_OVERLAPPEDWINDOW|FWS_ADDTOTITLE,
                               NULL,
                               &con);
    ret = con.m_pCurrentDoc->OnNewDocument();
    cmdiFrame->InitialUpdateFrame(con.m_pCurrentDoc,TRUE);
    return;
}

int CWatcherApp::GetParameters(CString &mac,
                               CString &com,
                               CString &lgnName,
                               CString &lgnPasswd,
                               UINT &port,
                               int &lang,
                               int &tc,
                               int &hist,
                               HKEY &child
                               )
{

    DWORD lpcName, lpType;
    TCHAR lpName[MAX_BUFFER_SIZE];
    int RetVal;


    // I see this kind of function in all the programs that use the
    // registry. Should try to simplify this.
    // BUGBUG - Memory inefficiency :-(
    // This function must be shared between the ManageDialog and
    // the Watcher Application.
    // Will probably declare them as friends of each other.
    // For the moment , let use have two copies of the function.
    lpcName = MAX_BUFFER_SIZE;
    RetVal = RegQueryValueEx(child,
                             _TEXT("Machine"),
                             NULL,
                             &lpType,
                             (LPBYTE)lpName,
                             &lpcName
                             );
    if(RetVal != ERROR_SUCCESS){
        return RetVal;
    }
    mac = lpName;
    lpName[0] = 0;
    lpcName = MAX_BUFFER_SIZE;
    RetVal = RegQueryValueEx(child,
                             _TEXT("Command"),
                             NULL,
                             &lpType,
                             (LPBYTE)lpName,
                             &lpcName
                             );
    if(RetVal != ERROR_SUCCESS){
        return RetVal;
    }
    com = lpName;
    lpcName = MAX_BUFFER_SIZE;
    lpName[0] = 0;
    RetVal = RegQueryValueEx(child,
                             _TEXT("Password"),
                             NULL,
                             &lpType,
                             (LPBYTE)lpName,
                             &lpcName
                             );
    if(RetVal != ERROR_SUCCESS){
        return RetVal;
    }
    lgnPasswd = lpName;
    lpName[0] = 0;
    lpcName = MAX_BUFFER_SIZE;
    RetVal = RegQueryValueEx(child,
                             _TEXT("User Name"),
                             NULL,
                             &lpType,
                             (LPBYTE)lpName,
                             &lpcName
                             );
    if(RetVal != ERROR_SUCCESS){
        return RetVal;
    }
    lgnName = lpName;
    lpcName = sizeof(int);
    RetVal = RegQueryValueEx(child,
                             _TEXT("Port"),
                             NULL,
                             &lpType,
                             (LPBYTE)&port,
                             &lpcName
                             );
    if(RetVal != ERROR_SUCCESS){
        return RetVal;
    }
    lpcName = sizeof(int);
    RetVal = RegQueryValueEx(child,
                             _TEXT("Client Type"),
                             NULL,
                             &lpType,
                             (LPBYTE)&tc,
                             &lpcName
                             );
    if(RetVal != ERROR_SUCCESS){
        return RetVal;
    }
    lpcName = sizeof(int);
    RetVal = RegQueryValueEx(child,
                             _TEXT("Language"),
                             NULL,
                             &lpType,
                             (LPBYTE)&lang,
                             &lpcName
                             );
    if(RetVal != ERROR_SUCCESS){
        return RetVal;
    }
    lpcName = sizeof(int);
    RetVal = RegQueryValueEx(child,
                             _TEXT("History"),
                             NULL,
                             &lpType,
                             (LPBYTE)&hist,
                             &lpcName
                             );
    return RetVal;
}

void CWatcherApp::OnAppExit()
{
    // TODO: Add your command handler code here
    if (m_pManageDialog){
        delete m_pManageDialog;
    }
    if(m_hkey){
        RegCloseKey(m_hkey);
        m_hkey = NULL;
    }
    CWinApp::OnAppExit();
}

HKEY & CWatcherApp::GetKey()
{
    return m_hkey;
}

void CWatcherApp::Refresh(ParameterDialog &pd, BOOLEAN del){
    POSITION index;

    if(m_pDocTemplate == NULL){
        return;
    }
    CDocument *doc;
    CWatcherDoc *wdoc;
    index = m_pDocTemplate->GetFirstDocPosition();
    while(index != NULL){
        doc = m_pDocTemplate->GetNextDoc(index);
        if(doc->GetTitle() == pd.Session){
            // May be conflict
            if(doc->IsKindOf(RUNTIME_CLASS(CWatcherDoc))){
                wdoc = (CWatcherDoc *) doc;
                ParameterDialog & dpd = wdoc->GetParameters();
                if(EqualParameters(pd, dpd)==FALSE){
                    DeleteSession(doc);
                    if(!del){
                        CreateNewSession(pd.Machine, pd.Command, pd.Port,
                                         pd.language, pd.tcclnt, pd.history,
                                         pd.LoginName, pd.LoginPasswd,
                                         pd.Session
                                         );
                    }
                    return;
                }

            }else{
                // Doc Template returning junk values.
                return;
            }


        }
    }
    if(!del){
        CreateNewSession(pd.Machine, pd.Command, pd.Port,
                         pd.language, pd.tcclnt, pd.history,
                         pd.LoginName, pd.LoginPasswd,
                         pd.Session
                         );
    }

}

void CWatcherApp::DeleteSession(CDocument *wdoc)
{
    POSITION pos;
    pos = wdoc->GetFirstViewPosition();
    while (pos != NULL){
        CView* pView = wdoc->GetNextView(pos);
        CWnd *pParent = pView->GetParent();
        if(pParent){
            pParent->PostMessage(WM_CLOSE,0,0);
            return;
        }
    }


}

BOOLEAN CWatcherApp::EqualParameters(ParameterDialog & pd1, ParameterDialog & pd2)
{
     if((pd1.Session != pd2.Session)||
       (pd1.Machine != pd2.Machine)||
       (pd1.Command != pd2.Command)||
       (pd1.history != pd2.history)||
       (pd1.language != pd2.language)||
       (pd1.tcclnt != pd2.tcclnt)||
       (pd1.Port != pd2.Port)){
        return FALSE;
    }
    if((pd1.LoginPasswd != pd2.LoginPasswd)||
       (pd1.LoginName != pd2.LoginName)){
        return FALSE;
       }
    return TRUE;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\headless\watcher\watcherdoc.h ===
// watcherDoc.h : interface of the CWatcherDoc class
//
/////////////////////////////////////////////////////////////////////////////

#if !defined(AFX_WATCHERDOC_H__C1609D45_5255_456D_97BD_BF6372AFCBB1__INCLUDED_)
#define AFX_WATCHERDOC_H__C1609D45_5255_456D_97BD_BF6372AFCBB1__INCLUDED_

#include "ParameterDialog.h"    // Added by ClassView
#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000


class CWatcherDoc : public CDocument
{
protected: // create from serialization only
        CWatcherDoc();
        DECLARE_DYNCREATE(CWatcherDoc)

// Attributes
public:
        CWatcherDoc(CString &machine, CString &command, UINT port, 
                int tc, int lang, int hist, CString &lgnName, CString &lgnPasswd, CString &sess);

// Operations
public:

// Overrides
        // ClassWizard generated virtual function overrides
        //{{AFX_VIRTUAL(CWatcherDoc)
        public:
        virtual BOOL OnNewDocument();
        virtual void Serialize(CArchive& ar);
        virtual BOOL OnOpenDocument(LPCTSTR lpszPathName);
        //}}AFX_VIRTUAL

// Implementation
public:
        ParameterDialog & GetParameters();
        void ScrollData(BYTE byte, COLORREF foreground,COLORREF background,
                        int ScrollTop, int ScrollBottom);
        BOOL Unlock();
        BOOL Lock();
        TCHAR * GetDataLine(int line);
        void SetData(int x, int y, BYTE byte, int n, COLORREF foreground, COLORREF background);
        void SetData(int x, int y, TCHAR byte, COLORREF foreground, COLORREF background);
        TCHAR * GetData(void);
        COLORREF * GetForeground(void);
        COLORREF * GetBackground(void);
        virtual ~CWatcherDoc();
#ifdef _DEBUG
        virtual void AssertValid() const;
        virtual void Dump(CDumpContext& dc) const;
#endif

protected:

// Generated message map functions
protected:
        ParameterDialog Params;
        COLORREF Background[MAX_TERMINAL_HEIGHT*MAX_TERMINAL_WIDTH];
        COLORREF Foreground[MAX_TERMINAL_HEIGHT*MAX_TERMINAL_WIDTH];
        TCHAR Data[MAX_TERMINAL_WIDTH*MAX_TERMINAL_HEIGHT];
        CCriticalSection mutex;
        //{{AFX_MSG(CWatcherDoc)
                // NOTE - the ClassWizard will add and remove member functions here.
                //    DO NOT EDIT what you see in these blocks of generated code !
        //}}AFX_MSG
        DECLARE_MESSAGE_MAP()
};

/////////////////////////////////////////////////////////////////////////////

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_WATCHERDOC_H__C1609D45_5255_456D_97BD_BF6372AFCBB1__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\headless\watcher\watcherdoc.cpp ===
// watcherDoc.cpp : implementation of the CWatcherDoc class
//

#include "stdafx.h"
#include "watcher.h"

#include "watcherDoc.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CWatcherDoc

IMPLEMENT_DYNCREATE(CWatcherDoc, CDocument)

BEGIN_MESSAGE_MAP(CWatcherDoc, CDocument)
        //{{AFX_MSG_MAP(CWatcherDoc)
                // NOTE - the ClassWizard will add and remove mapping macros here.
                //    DO NOT EDIT what you see in these blocks of generated code!
        //}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CWatcherDoc construction/destruction

CWatcherDoc::CWatcherDoc()
{
        // TODO: add one-time construction code here
    COLORREF white = WHITE;
    COLORREF black = BLACK;
    int i,j,size;
    size = MAX_TERMINAL_WIDTH*MAX_TERMINAL_HEIGHT;
    INT_PTR nRet;
    nRet = Params.DoModal();
    if(nRet != IDOK){
        // kill document
        Params.DeleteValue = TRUE;
        return;
    }
    // TODO: add one-time construction code here
    memset(Data,0,MAX_TERMINAL_WIDTH*MAX_TERMINAL_HEIGHT*sizeof(TCHAR));
    for(i=0;i<size;i+=MAX_TERMINAL_WIDTH){
        for(j=0;j<MAX_TERMINAL_WIDTH;j++){
            Background[i+j] = black;
            Foreground[i+j] = white;
        }
    }
    return;
}
CWatcherDoc::CWatcherDoc(CString &machine, CString &command, UINT port, 
                int tc, int lang,int hist, CString &lgnName, CString &lgnPasswd, CString &sess)
{
        COLORREF white = WHITE;
    COLORREF black = BLACK;
    int i,j,size;
    size = MAX_TERMINAL_WIDTH*MAX_TERMINAL_HEIGHT;
        // TODO: add one-time construction code here
        Params.Machine = machine;
        Params.Command = command;
        Params.Port = port;
        Params.tcclnt = tc;
        Params.language = lang;
        Params.LoginName = lgnName;
        Params.LoginPasswd = lgnPasswd;
        Params.Session = sess;
    Params.history = hist;
    memset(Data,0,MAX_TERMINAL_WIDTH*MAX_TERMINAL_HEIGHT*sizeof(TCHAR));
    for(i=0;i<size;i+=MAX_TERMINAL_WIDTH){
        for(j=0;j<MAX_TERMINAL_WIDTH;j++){
            Background[i+j] = black;
            Foreground[i+j] = white;
        }
    }
    return;
}

CWatcherDoc::~CWatcherDoc()
{
}

BOOL CWatcherDoc::OnNewDocument()
{
        if (!CDocument::OnNewDocument())
                return FALSE;

        // TODO: add reinitialization code here
        // (SDI documents will reuse this document)

        return TRUE;
}

BOOL CWatcherDoc::OnOpenDocument(LPCTSTR lpszPathName)
{
        return CDocument::OnOpenDocument(lpszPathName);
}


/////////////////////////////////////////////////////////////////////////////
// CWatcherDoc serialization

void CWatcherDoc::Serialize(CArchive& ar)
{
        if (ar.IsStoring())
        {
                // TODO: add storing code here
        }
        else
        {
                // TODO: add loading code here
        }
}

/////////////////////////////////////////////////////////////////////////////
// CWatcherDoc diagnostics

#ifdef _DEBUG
void CWatcherDoc::AssertValid() const
{
        CDocument::AssertValid();
}

void CWatcherDoc::Dump(CDumpContext& dc) const
{
        CDocument::Dump(dc);
}
#endif //_DEBUG

/////////////////////////////////////////////////////////////////////////////
// CWatcherDoc commands

COLORREF * CWatcherDoc::GetBackground()
{
   return (Background);
}

COLORREF * CWatcherDoc::GetForeground()
{
    return (Foreground);
}


TCHAR * CWatcherDoc::GetData()
{
    return (Data);

}

void CWatcherDoc::SetData(int x, int y, TCHAR byte, 
                          COLORREF foreground, COLORREF background)
{
        if (x >= MAX_TERMINAL_WIDTH){
                return;
        }
        if (y>= MAX_TERMINAL_HEIGHT){
                return;
        }

    Data[x+y*MAX_TERMINAL_WIDTH] = byte;
    Foreground[x+y*MAX_TERMINAL_WIDTH] = foreground;
    Background[x+y*MAX_TERMINAL_WIDTH] = background;
    return;

}

void CWatcherDoc::SetData(int x, int y, BYTE byte, int n, 
                          COLORREF foreground, COLORREF background)
{

    int i,j;
    
    i=MAX_TERMINAL_WIDTH*y + x;
        if (i+n > MAX_TERMINAL_WIDTH*MAX_TERMINAL_HEIGHT) {
                return;
        }
    memset(&(Data[i]),byte, n*sizeof(TCHAR));
    for(j=0;j<n;j++){
        Foreground[i+j] = foreground;
        Background[i+j] = background;
    }
    return;

}

TCHAR * CWatcherDoc::GetDataLine(int line)
{
  return (&(Data[line*MAX_TERMINAL_WIDTH]));
}

BOOL CWatcherDoc::Lock()
{
    return mutex.Lock(INFINITE);
}

BOOL CWatcherDoc::Unlock()
{
    return mutex.Unlock();
}

void CWatcherDoc::ScrollData(BYTE byte, COLORREF foreground, COLORREF background,
                             int ScrollTop, int ScrollBottom)
{
    if ((ScrollTop < 1)||(ScrollBottom > MAX_TERMINAL_HEIGHT) || (ScrollTop > ScrollBottom)) {
        // error
        return;
    }
    int number = MAX_TERMINAL_WIDTH*(ScrollBottom - ScrollTop);
    int index1 = (ScrollTop-1)*MAX_TERMINAL_WIDTH;
    int index2 = index1 + MAX_TERMINAL_WIDTH;
    if (ScrollTop < ScrollBottom) {
        memmove(&(Data[index1]),&(Data[index2]), number*sizeof(TCHAR));
        memmove(&(Foreground[index1]),&(Foreground[index2]), number*sizeof(TCHAR));
        memmove(&(Background[index1]),&(Background[index2]), number*sizeof(TCHAR));
    }
   // number -= MAX_TERMINAL_WIDTH;
    index1 = MAX_TERMINAL_WIDTH*(ScrollBottom - 1);
    memset(&(Data[index1]), byte, MAX_TERMINAL_WIDTH*sizeof(TCHAR));
    for(int j=0;j<MAX_TERMINAL_WIDTH;j++){
        Foreground[index1+j] = foreground;
        Background[index1+j] = background;
    }
    return;

}

ParameterDialog & CWatcherDoc::GetParameters()
{
 return Params;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\headless\watcher\watcher.h ===
// watcher.h : main header file for the WATCHER application
//

#if !defined(AFX_WATCHER_H__691AA721_59DC_4A70_AB0E_224249D74256__INCLUDED_)
#define AFX_WATCHER_H__691AA721_59DC_4A70_AB0E_224249D74256__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#ifndef __AFXWIN_H__
#error include 'stdafx.h' before including this file for PCH
#endif

#include "resource.h"       // main symbols
#include "ParameterDialog.h"

/////////////////////////////////////////////////////////////////////////////
// CWatcherApp:
// See watcher.cpp for the implementation of this class
//

class CWatcherApp : public CWinApp
{
public:
    //void AddParameter();
    CWatcherApp();

    // Overrides
    // ClassWizard generated virtual function overrides
    //{{AFX_VIRTUAL(CWatcherApp)
public:
    // Making this public so that the Manage Dialog 
    // can access this function.
    int GetParametersByIndex(int dwIndex,
                             CString &sess,
                             CString &mac,
                             CString &com,
                             UINT &port,
                             int &lang,
                             int &tc,
                             int &hist,
                             CString &lgnName,
                             CString &lgnPasswd
                             );
    void Refresh(ParameterDialog &pd, BOOLEAN del);
    HKEY & GetKey();
    virtual BOOL InitInstance();
    virtual void ParseCommandLine(CCommandLineInfo& rCmdInfo);
    virtual BOOL ProcessShellCommand(CCommandLineInfo &rCmdInfo);
    //}}AFX_VIRTUAL

    // Implementation
    //{{AFX_MSG(CWatcherApp)
    afx_msg void OnAppAbout();
    afx_msg void OnAppExit();
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()
protected:
    // Reads in the parameters from the registry 
    // corresponding to the session.
    void DeleteSession(CDocument *wdoc);
    BOOLEAN EqualParameters(ParameterDialog & pd1, ParameterDialog & pd2);
    int GetParameters(CString &mac,
                      CString &com, 
                      CString &lgnName, 
                      CString &lgnPasswd, 
                      UINT &port,
                      int &lang,
                      int &tc, 
                      int & hist,
                      HKEY &child
                      );
    // does everything the document manager does when asked to 
    // create a new document. 
    void CreateNewSession(CString &mac, 
                          CString &com, 
                          UINT port, 
                          int lang, 
                          int tc, 
                          int hist,
                          CString &lgnName, 
                          CString &lgnPasswd, 
                          CString &sess
                          );
    BOOL LoadRegistryParameters();
    afx_msg void OnHelp();
    afx_msg void OnFileManage();
    HKEY m_hkey;
    CMultiDocTemplate * m_pDocTemplate;
    CDialog *m_pManageDialog;
};

/////////////////////////////////////////////////////////////////////////////

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_WATCHER_H__691AA721_59DC_4A70_AB0E_224249D74256__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\headless\watcher\stdafx.h ===
// stdafx.h : include file for standard system include files,
//  or project specific include files that are used frequently, but
//      are changed infrequently
//

#if !defined(AFX_STDAFX_H__D2DE24F7_ACC0_4A4A_B473_23DF6153FBE4__INCLUDED_)
#define AFX_STDAFX_H__D2DE24F7_ACC0_4A4A_B473_23DF6153FBE4__INCLUDED_
#if dbg ==1 && !defined (_DEBUG)
#define _DEBUG
#endif
#if _MSC_VER > 1000
#pragma once

#include <afxwin.h>         // MFC core and standard components
#define VC_EXTRALEAN        // Exclude rarely-used stuff from Windows headers

#include <afxext.h>         // MFC extensions
#include <afxdisp.h>        // MFC Automation classes

#ifndef _AFX_NO_AFXCMN_SUPPORT
#include <afxcmn.h>         // MFC support for Windows Common Controls
#endif // _AFX_NO_AFXCMN_SUPPORT

#include <afxsock.h>        // MFC socket extensions
#include <afxmt.h>          // MFC Multi threading support
//#include <afxdtctl.h>       // MFC support for Internet Explorer 4 Common Controls

#endif // _MSC_VER > 1000
//COLOR DEFINITIONS

#define WHITE RGB(128,128,128)
#define BLACK RGB(0,0,0)
#define BLUE RGB(0,0,128)
#define YELLOW RGB(0,128,128)
#define RED RGB(128,0,0)

// Code Page definitions
#define ENGLISH 437
#define JAPANESE 932
#define EUROPEAN 1250
#define MAX_LANGUAGES 3
#define MAX_BUFFER_SIZE 256
#define TELNET_PORT 23
#define MAX_TERMINAL_HEIGHT 24
#define MAX_TERMINAL_WIDTH 80

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line 
#endif //!defined(AFX_STDAFX_H__D2DE24F7_ACC0_4A4A_B473_23DF6153FBE4__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\headless\watcher\parameterdialog.h ===
#if !defined(AFX_PARAMETERDIALOG_H__E8ECC68E_A168_499A_8458_63293E3DD498__INCLUDED_)
#define AFX_PARAMETERDIALOG_H__E8ECC68E_A168_499A_8458_63293E3DD498__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000
// ParameterDialog.h : header file
//

/////////////////////////////////////////////////////////////////////////////
//  dialog

class ParameterDialog : public CDialog
{
// Construction
public:
        CString Session;
        CString LoginPasswd;
        CString LoginName;
        BOOL DeleteValue;
        int language;
        int tcclnt;
        int history;
        CString Command;
        CString Machine;
        UINT Port;
        ParameterDialog(CWnd* pParent = NULL);   // standard constructor

// Dialog Data
        //{{AFX_DATA(ParameterDialog)
        enum { IDD = Parameters };
                // NOTE: the ClassWizard will add data members here
        //}}AFX_DATA


// Overrides
        // ClassWizard generated virtual function overrides
        //{{AFX_VIRTUAL(ParameterDialog)
        protected:
        virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
        //}}AFX_VIRTUAL

// Implementation
protected:
        void DDV_MinChars(CDataExchange *pDX,CString &str);

        // Generated message map functions
        //{{AFX_MSG(ParameterDialog)
                // NOTE: the ClassWizard will add member functions here
        //}}AFX_MSG
        DECLARE_MESSAGE_MAP()
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_PARAMETERDIALOG_H__E8ECC68E_A168_499A_8458_63293E3DD498__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\headless\watcher\watchersocket.h ===
#if !defined(AFX_WATCHERSOCKET_H__52E4ADBF_C131_4999_9B73_88136FFBC4DD__INCLUDED_)
#define AFX_WATCHERSOCKET_H__52E4ADBF_C131_4999_9B73_88136FFBC4DD__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000
// WatcherSocket.h : header file
//



/////////////////////////////////////////////////////////////////////////////
// WatcherSocket command target

class WatcherSocket : public CSocket
{
// Attributes
public:
// Operations
public:
	WatcherSocket();
	virtual ~WatcherSocket();

// Overrides
public:
	void SetParentView(CView *view);
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(WatcherSocket)
	//}}AFX_VIRTUAL

	// Generated message map functions
	//{{AFX_MSG(WatcherSocket)
		// NOTE - the ClassWizard will add and remove member functions here.
	//}}AFX_MSG

// Implementation
protected:
	LPBYTE Command;
	CView * DocView;
	int lenCommand;
};

/////////////////////////////////////////////////////////////////////////////

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_WATCHERSOCKET_H__52E4ADBF_C131_4999_9B73_88136FFBC4DD__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\headless\watcher\watchersocket.cpp ===
// WatcherSocket.cpp : implementation file
//

#include "stdafx.h"
#include "watcher.h"
#include "WatcherSocket.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// WatcherSocket

WatcherSocket::WatcherSocket()
{
	DocView = NULL;
	Command = NULL;
}

WatcherSocket::~WatcherSocket()
{

	CSocket::~CSocket();
}


// Do not edit the following lines, which are needed by ClassWizard.
#if 0
BEGIN_MESSAGE_MAP(WatcherSocket, CSocket)
	//{{AFX_MSG_MAP(WatcherSocket)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()
#endif	// 0

/////////////////////////////////////////////////////////////////////////////
// WatcherSocket member functions

void WatcherSocket::SetParentView(CView *view)
{
    if (DocView) return;
    DocView = view;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\headless\watcher\watchertcclient.cpp ===
// WatcherTCClient.cpp : implementation file
//

#include "stdafx.h"
#include "WATCHER.h"
#include "WatcherTCClient.h"
#include "WATCHERView.h"
#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// WatcherTCClient

WatcherTCClient::WatcherTCClient(LPBYTE cmd, int cmdLen)
{
    DocView = NULL;
        lenCommand = cmdLen;
        Command = cmd;
}

WatcherTCClient::~WatcherTCClient()
{
        if(Command){
                delete [] Command;
                Command = NULL;
        }
        WatcherSocket::~WatcherSocket();
}


// Do not edit the following lines, which are needed by ClassWizard.
#if 0
BEGIN_MESSAGE_MAP(WatcherTCClient, WatcherSocket)
        //{{AFX_MSG_MAP(WatcherTCClient)
        //}}AFX_MSG_MAP
END_MESSAGE_MAP()
#endif  // 0

/////////////////////////////////////////////////////////////////////////////
// WatcherTCClient member functions

void WatcherTCClient::OnClose(int nErrorCode)
{
    BOOL ret = (DocView->GetParent())->PostMessage(WM_CLOSE,0,0);
    WatcherSocket::OnClose(nErrorCode);
    return;
}

void WatcherTCClient::OnReceive(int nErrorCode)
{
    BYTE Buffer[MAX_BUFFER_SIZE];
    int i,nRet;

    if (nErrorCode != 0) {
        (DocView->GetParent())->PostMessage(WM_CLOSE, 0,0);
        return;
    }
    nRet = Receive(Buffer, MAX_BUFFER_SIZE, 0);
    if(nRet <= 0) return;
    for(i=0;i<nRet;i++){
       ((CWatcherView *)DocView)->ProcessByte(Buffer[i]);
    }
        WatcherSocket::OnReceive(nErrorCode);
    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\headless\watcher\watcherview.h ===
// watcherView.h : interface of the CWatcherView class
//
/////////////////////////////////////////////////////////////////////////////

#if !defined(AFX_WATCHERVIEW_H__3A351A40_9441_4451_AA2B_C5D4C392CB1B__INCLUDED_)
#define AFX_WATCHERVIEW_H__3A351A40_9441_4451_AA2B_C5D4C392CB1B__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000
#include "ParameterDialog.h"
#include "watcherDoc.h"
#ifndef _WATCHER_SOCKET
#define _WATCHER_SOCKET
#include "WatcherSocket.h"
#endif

#define MAX_BELL_SIZE MAX_BUFFER_SIZE*8

class CWatcherView : public CView
{
protected: // create from serialization only
    CWatcherView();
    DECLARE_DYNCREATE(CWatcherView)

// Attributes
public:
    CWatcherDoc* GetDocument();

    // ClassWizard generated virtual function overrides
    //{{AFX_VIRTUAL(CWatcherView)
    virtual void OnInitialUpdate();
    virtual void OnDraw(CDC* pDC);  // overridden to draw this view
    virtual BOOL PreCreateWindow(CREATESTRUCT& cs);
protected:
    //}}AFX_VIRTUAL

// Implementation
public:
    void ProcessByte(BYTE byte);
    virtual ~CWatcherView();
#ifdef _DEBUG
    virtual void AssertValid() const;
    virtual void Dump(CDumpContext& dc) const;
#endif

protected:
    void ProcessBellSequence(CHAR *Buffer, int len);
    LCID Locale;
    int xpos;
    int ypos;
    int CharsInLine;
    int height;
    int width;
    int position;
    int index;
    #ifdef _UNICODE
    int dbcsIndex;
    #endif
    BOOL InEscape;
    WatcherSocket *Socket;
    CClientDC *cdc;
    COLORREF background;
    COLORREF foreground;
    UINT CodePage;
    int indexBell;
    BOOL BellStarted;
    BOOL InBell;
    int ScrollTop;
    int ScrollBottom;
    BOOL seenM;
    #ifdef _UNICODE
    BYTE DBCSArray[2];
    #endif
    BYTE BellBuffer[MAX_BELL_SIZE];
    BYTE EscapeBuffer[MAX_BUFFER_SIZE];
    CRITICAL_SECTION mutex;
    int GetTextWidth(TCHAR *Data, int number);
    BOOL IsPrintable(TCHAR Char);
    BOOL FinalCharacter(CHAR c);
    BOOL IsLeadByte(BYTE byte);
    void ProcessTextAttributes(PCHAR Buffer,int length);
    void ProcessEscapeSequence(PCHAR Buffer, int length);
    void PrintCharacter(BYTE byte);
    //{{AFX_MSG(CWatcherView)
    afx_msg void OnChar(UINT nChar, UINT nRepCnt, UINT nFlags);
    afx_msg void OnDestroy();
	afx_msg void OnKeyDown(UINT nChar, UINT nRepCnt, UINT nFlags);
	//}}AFX_MSG
    DECLARE_MESSAGE_MAP()
};

#ifndef _DEBUG  // debug version in watcherView.cpp
inline CWatcherDoc* CWatcherView::GetDocument()
   { return (CWatcherDoc*)m_pDocument; }
#endif

/////////////////////////////////////////////////////////////////////////////

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_WATCHERVIEW_H__3A351A40_9441_4451_AA2B_C5D4C392CB1B__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\headless\watcher\watchertcclient.h ===
#if !defined(AFX_WATCHERTCCLIENT_H__BD819878_DCEC_4CB6_B994_5E1B95003E1B__INCLUDED_)
#define AFX_WATCHERTCCLIENT_H__BD819878_DCEC_4CB6_B994_5E1B95003E1B__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000
// WatcherTCClient.h : header file
//

#include "WatcherSocket.h"


/////////////////////////////////////////////////////////////////////////////
// WatcherTCClient command target

class WatcherTCClient : public WatcherSocket
{
// Attributes
public:

// Operations
public:
	WatcherTCClient(LPBYTE cmd=NULL, int cmdLen=0);
	virtual ~WatcherTCClient();

// Overrides
public:

	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(WatcherTCClient)
	//}}AFX_VIRTUAL

	// Generated message map functions
	//{{AFX_MSG(WatcherTCClient)
		// NOTE - the ClassWizard will add and remove member functions here.
	//}}AFX_MSG
protected:
	void OnReceive(int nErrorCode);
	void OnClose(int nErrorCode);
};

/////////////////////////////////////////////////////////////////////////////

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_WATCHERTCCLIENT_H__BD819878_DCEC_4CB6_B994_5E1B95003E1B__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\headless\watcher\watchertelnetclient.cpp ===
// WatcherTelnetClient.cpp : implementation file
//

#include "stdafx.h"
#include "WATCHER.h"
#include "WatcherTelnetClient.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif
#include "WATCHERView.h"
/////////////////////////////////////////////////////////////////////////////
// WatcherTelnetClient

WatcherTelnetClient::WatcherTelnetClient(LPBYTE cmd, int cmdLen, 
                                         LPBYTE lgn, int lgnLen)
:CommandSequence(NO_COMMAND),
 lenLogin(lgnLen),
 Login(lgn),
 OptionIndex(0),
 PacketNumber(3),
 SentTermType(FALSE)
{
    Command = cmd;
    DocView = NULL;
    lenCommand = cmdLen;
}

WatcherTelnetClient::~WatcherTelnetClient()
{
    if (Login){
        delete [] Login;
        Login = NULL;
    }
    if (Command){
        delete [] Command;
        Command = NULL;
    }
    WatcherSocket::~WatcherSocket();

}


// Do not edit the following lines, which are needed by ClassWizard.
#if 0
BEGIN_MESSAGE_MAP(WatcherTelnetClient, WatcherSocket)
    //{{AFX_MSG_MAP(WatcherTelnetClient)
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()
#endif  // 0

/////////////////////////////////////////////////////////////////////////////
// WatcherTelnetClient member functions
void WatcherTelnetClient::OnReceive(int nErrorCode)
{
    BYTE Buffer[MAX_BUFFER_SIZE];
    int i,nRet,ret;

    
    if (nErrorCode != 0) {
        DocView->GetParent()->PostMessage(WM_CLOSE, 0,0);
        return;
    }
    nRet = Receive(Buffer, MAX_BUFFER_SIZE, 0);
    if(nRet <= 0) return;
    for(i=0;i<nRet;i++){
        ret = ProcessByte(Buffer[i]);
    }
    if (PacketNumber == 0){
        WatcherSocket::OnReceive(nErrorCode);
        return;
    }
    if(PacketNumber == 3){
        if(Login){
            Send(Login, lenLogin, 0);
        }
        PacketNumber --;
        WatcherSocket::OnReceive(nErrorCode);
        return;
    }
    if (SentTermType){
        if(PacketNumber == 1){
            if(Command){
                int ret = Send(Command, lenCommand, 0);
            }
        }
        PacketNumber --;
    }
    WatcherSocket::OnReceive(nErrorCode);
    return;
}


int WatcherTelnetClient::ProcessByte(BYTE byte)
{
    // Watch in general for Telnet Sequences and 
    // generate appropriate responses. 
    // Otherwise pass on the character to the View 
    // which will be configured for a particular console.

    if ((byte == 255)&&(CommandSequence == NO_COMMAND)){
        CommandSequence = IAC;
        return 0;
    }
    switch (CommandSequence){
    case NO_COMMAND:
        // Send the character to the document view
        ((CWatcherView *)DocView)->ProcessByte(byte);
        break;
    case IAC:
        // A Command Sequence is beginning
        CommandSequence = byte;
        break;
    case DO:
        // Options are here
        // Only one byte options allowed
        // So fall through
    case DONT:
        // Same as above;
    case WILL:
        // same
    case WONT:
        Options[OptionIndex] = byte;
        ProcessCommand(CommandSequence);
        CommandSequence=NO_COMMAND;
        OptionIndex = 0;
        break;
    case SB:
        // Might be a long list, so just go on
        // until a SE is encountered
       Options[OptionIndex]=byte;
        if (byte == SE){
            ProcessSBCommand(CommandSequence);
            OptionIndex = 0;
            CommandSequence = NO_COMMAND;
        }
        else{
            OptionIndex++;
            if (OptionIndex == MAX_BUFFER_SIZE){
                // Cant have such a long command, can we??
                OptionIndex = 0;
                CommandSequence = NO_COMMAND;
            }
        }
        break;
    default:
        // Cant recognize the command
        OptionIndex = 0;
        CommandSequence = NO_COMMAND;
        break;         
    }
    return 0;

}

void WatcherTelnetClient::ProcessCommand(BYTE cmd)
{
    BYTE sbuf[MAX_BUFFER_SIZE];

    switch(cmd){
    case DO:
        sbuf[0] = IAC;
        sbuf[1] = WONT;
        switch(Options[0]){
        case TO_NAWS:
            // terminal size is sent here.
            sbuf[1] = WILL;
            sbuf[2] = TO_NAWS;
            sbuf[3] = IAC;
            sbuf[4] = SB;
            sbuf[5] = TO_NAWS;
            sbuf[6] = 0;
            sbuf[7] = MAX_TERMINAL_WIDTH;
            sbuf[8] = 0;
            sbuf[9] = MAX_TERMINAL_HEIGHT;
            sbuf[10] = IAC;
            sbuf[11] = SE;
            Send(sbuf, 12, 0);
            break;
        case TO_TERM_TYPE:
            // will then subnegotiate the parameters. 
            sbuf[1]=WILL;
        default:
            // just negate everything you dont understand :-)
            sbuf[2] = Options[0];
            Send(sbuf,3,0);
            break;
        }
    default:
        break;
    }

}

void WatcherTelnetClient::ProcessSBCommand(BYTE cmd)
{
    BYTE sbuf[MAX_BUFFER_SIZE];
    switch(Options[0]){
    case TO_TERM_TYPE:
        sbuf[0] = IAC;
        sbuf[1] = SB;
        sbuf[2] = TO_TERM_TYPE;
        sbuf[3] = TT_IS;
        sbuf[4] = 'A';
        sbuf[5] = 'N';
        sbuf[6] = 'S';
        sbuf[7] = 'I';
        sbuf[8] = IAC;
        sbuf[9] = SE;
        Send(sbuf,10,0);
        // May have to renegotiate the terminal type. 
        // If we connect to a real Terminal concentrator
        // do we have to do all this ?? 
        SentTermType = TRUE;
        break;
    default:
        break;
    }
    return;
}

void WatcherTelnetClient::OnClose(int nErrorCode)
{
    // this was just for debug purposes. 
    // If the error code is not zero, ie we
    // had fatal errors on send and receive. 
    BOOL ret = (DocView->GetParent())->PostMessage(WM_CLOSE,0,0);
    WatcherSocket::OnClose(nErrorCode);
    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\headless\watcher\watcherview.cpp ===
// watcherView.cpp : implementation of the View class
//

#include "stdafx.h"
#include "watcher.h"
#include "watcherDoc.h"
#include "watcherView.h"
#include "WatcherTelnetClient.h"
#include "WatcherTCClient.h"
#include "tcsrvc.h"
#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif
#include <wbemidl.h>
#include "wbemDCpl.h"

#define CHECKERROR(HRES) if(FAILED(hres)) {_stprintf(buffer,_T("0x%x"),hres);\
            AfxFormatString1(rString, CREATE_WMI_OBJECT_FAILURE, buffer);\
            MessageBox(NULL,(LPCTSTR) rString,L"Watcher", MB_OK|MB_ICONEXCLAMATION);\
            delete [] messageBuffer;\
            return -1;\
            }

UINT
GenerateWMIEvent(LPTSTR messageBuffer
                )
{

    TCHAR buffer[MAX_BUFFER_SIZE];
    CString rString;
    HRESULT hres;

    hres = CoInitializeEx(NULL, COINIT_MULTITHREADED);

    CHECKERROR(hres);

    // Load provision code

    IWbemDecoupledEventSink* pConnection = NULL;
    hres = CoCreateInstance(CLSID_PseudoSink, NULL, CLSCTX_SERVER, 
                            IID_IWbemDecoupledEventSink, (void**)&pConnection);
    CHECKERROR(hres);

    // Connect and announce provider name (as in MOF)

    IWbemObjectSink* pSink = NULL;
    IWbemServices* pNamespace = NULL;
    hres = pConnection->Connect(L"root\\default", L"WatcherEventProv", 
                                0, &pSink, &pNamespace);
    CHECKERROR(hres);

    BSTR XMLData = SysAllocString(messageBuffer);
    IWbemObjectTextSrc *pSrc;
    IWbemClassObject *pInstance;


    if( SUCCEEDED( hres = CoCreateInstance ( CLSID_WbemObjectTextSrc, NULL, 
                                             CLSCTX_INPROC_SERVER,                        
                                             IID_IWbemObjectTextSrc, 
                                             (void**) &pSrc ) ) ) {
        if( SUCCEEDED( hres = pSrc->CreateFromText( 0, XMLData, WMI_OBJ_TEXT_WMI_DTD_2_0, 
                                                    NULL, &pInstance) ) ) {
            pSink->Indicate(1,&pInstance);
            pInstance->Release();
        }
        else{
            _stprintf(buffer,_T("0x%x"),hres);
            AfxFormatString1(rString, CREATE_WMI_OBJECT_FAILURE, buffer);
            MessageBox(NULL,(LPCTSTR) rString,L"Watcher", MB_OK|MB_ICONEXCLAMATION);
            pSrc->Release();
        }
    }
    else{
        _stprintf(buffer,_T("0x%x"),hres);
        AfxFormatString1(rString, CREATE_TEXT_SRC_FAILURE, buffer);
        MessageBox(NULL,(LPCTSTR) rString,L"Watcher", MB_OK|MB_ICONEXCLAMATION);
    }
    SysFreeString(XMLData);

    // Init data

    pConnection->Disconnect();
    pSink->Release();
    pConnection->Release();
    MessageBox(NULL,messageBuffer,L"",MB_OK|MB_ICONEXCLAMATION);
    delete [] messageBuffer;
    return 0;
}

/////////////////////////////////////////////////////////////////////////////
// CWatcherView

IMPLEMENT_DYNCREATE(CWatcherView, CView)

BEGIN_MESSAGE_MAP(CWatcherView, CView)
    //{{AFX_MSG_MAP(CWatcherView)
    ON_WM_CHAR()
    ON_WM_DESTROY()
        ON_WM_KEYDOWN()
        //}}AFX_MSG_MAP
    // Standard printing commands
    ON_COMMAND(ID_FILE_PRINT, CView::OnFilePrint)
    ON_COMMAND(ID_FILE_PRINT_DIRECT, CView::OnFilePrint)
    ON_COMMAND(ID_FILE_PRINT_PREVIEW, CView::OnFilePrintPreview)
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CWatcherView construction/destruction

CWatcherView::CWatcherView()
:xpos(0),
 ypos(0),
 CharsInLine(0),
 height(0),
 width(0),
 position(0),
 index(0),
#ifdef _UNICODE
 dbcsIndex(0),
#endif
 InEscape(FALSE),
 Socket(NULL),
 cdc(NULL),
 background(BLACK),
 foreground(WHITE),
 indexBell(0),
 BellStarted(FALSE),
 InBell(FALSE),
 ScrollTop(1),
 ScrollBottom(MAX_TERMINAL_HEIGHT),
 seenM(FALSE)
{
    // TODO: add construction code here
    InitializeCriticalSection(&mutex);
    return;
}

CWatcherView::~CWatcherView()
{
    DeleteCriticalSection(&mutex);
}

BOOL CWatcherView::PreCreateWindow(CREATESTRUCT& cs)
{
        // TODO: Modify the Window class or styles here by modifying
        //  the CREATESTRUCT cs

        return CView::PreCreateWindow(cs);
}

/////////////////////////////////////////////////////////////////////////////
// CWatcherView drawing

void CWatcherView::OnDraw(CDC* pDC)
{   
    TCHAR *Data,Char;
    int i,j, Height;
    int CharWidth, Position;
    int size;
    BOOL ret;
    COLORREF *Foreground;
    COLORREF *Background;

    CWatcherDoc* pDoc = GetDocument();
    ASSERT_VALID(pDoc);
    // TODO: add draw code for native data here
    ret = pDoc->Lock();
    if (ret == FALSE) return;
    Data = pDoc->GetData();
    size = MAX_TERMINAL_WIDTH*MAX_TERMINAL_HEIGHT;
    Background = pDoc->GetBackground();
    Foreground = pDoc->GetForeground();
    Height = 0;
 
    for(i=0;i<size;i+=MAX_TERMINAL_WIDTH){
        Position = 0;
        for(j=0;j<MAX_TERMINAL_WIDTH;j++){
            Char = Data[i + j]; 
            cdc->SetTextColor(Foreground[i+j]);
            cdc->SetBkColor(Background[i+j]);

            if (!cdc->GetOutputCharWidth(Char, Char, &CharWidth)) {
                return;
            }

            if(Char == 0xFFFF){
                continue;
            }               
            if(IsPrintable(Char)){
                cdc->FillSolidRect(Position,Height,CharWidth,
                                   height,Background[i+j]);
                cdc->TextOut(Position, Height,&Char, 1);
                Position = Position + CharWidth;
            }
            else{
                cdc->FillSolidRect(Position,Height,width,
                                   height,Background[i+j]);
                Position = Position + width;
            }
        }
        cdc->FillSolidRect(Position,Height, MAX_TERMINAL_WIDTH*width-Position,
                           height,Background[i+j-1]);
        Height = Height + height;
    }
    ret = pDoc->Unlock();
    return;
}

/////////////////////////////////////////////////////////////////////////////
// CWatcherView initial update of the document.
void CWatcherView::OnInitialUpdate()
{
    BOOL ret;
    TCHAR Buffer[256];
    CLIENT_INFO SendInfo;
    CFont font;
    UCHAR Charset;
    LPBYTE SocketBuffer;
    CString rString;

    ParameterDialog &Params=((CWatcherDoc *)GetDocument())->GetParameters();

    if(Params.DeleteValue == TRUE){
        ret = GetParent()->PostMessage(WM_CLOSE,0,0);
        return;
    }

    CString FaceName;
    switch(Params.language + IDS_ENGLISH){
    case IDS_ENGLISH:   
        CodePage = ENGLISH;
        Charset = ANSI_CHARSET;
        FaceName = TEXT("Courier New");
        break;
    case IDS_JAPANESE:
        CodePage = JAPANESE;
        Charset = SHIFTJIS_CHARSET;
//        Locale = MAKELCID(MAKELANGID(LANG_JAPANESE, SUBLANG_NEUTRAL),
//                          SORT_JAPANESE_UNICODE);
//        SetThreadLocale(Locale);
        FaceName = TEXT("MS Mincho");
        break;
    case IDS_EUROPEAN:
        CodePage = EUROPEAN;
        Charset = EASTEUROPE_CHARSET;
        FaceName = TEXT("Courier New");
        break;
    default:
        CodePage = ENGLISH;
        Charset = ANSI_CHARSET;
        FaceName = TEXT("Courier New");
        break;
    }
    
    VERIFY(font.CreateFont(16,                        // nHeight
                           0,                         // nWidth
                           0,                         // nEscapement
                           0,                         // nOrientation
                           FW_MEDIUM,                 // nWeight
                           FALSE,                     // bItalic
                           FALSE,                     // bUnderline
                           0,                         // cStrikeOut
                           Charset,                       // nCharSet
                           OUT_DEFAULT_PRECIS,        // nOutPrecision
                           CLIP_DEFAULT_PRECIS,       // nClipPrecision
                           DEFAULT_QUALITY,           // nQuality
                           FIXED_PITCH | FF_MODERN,  // nPitchAndFamily
                           FaceName));                 // lpszFacename
    cdc = new CClientDC(this);
    if(!cdc){
        ret = GetParent()->PostMessage(WM_CLOSE,0,0);
        return;
    }
    cdc->SelectObject(&font);
    CDocument *pDoc = GetDocument();
    if(pDoc){
        pDoc->SetTitle(Params.Session);
        pDoc->UpdateAllViews(NULL,0,NULL);
    }
    // Now create the socket and start the worker thread
    if(Params.tcclnt){
        // Assuming Unicode always....... (Can remove a lot of other junk)
        _tcscpy(SendInfo.device, (LPCTSTR) Params.Command);
        SendInfo.len = Params.history;
        int strsize = sizeof(CLIENT_INFO);
        SocketBuffer = new BYTE[strsize];
        SocketBuffer = (LPBYTE) ::memcpy(SocketBuffer,&SendInfo, strsize);
        Socket = new WatcherTCClient(SocketBuffer,strsize);
        if(!SocketBuffer || !Socket){
            AfxFormatString1(rString, CREATE_TC_SOCKET_FAILURE, L"");
            MessageBox((LPCTSTR) rString, L"Watcher", MB_OK|MB_ICONSTOP);
            ret = GetParent()->PostMessage(WM_CLOSE,0,0);
            return;
        }
    }
    else{
        LPBYTE LoginBuffer;
        int strsize,cmdsize; 
        CString login;
        CString comm;
        login = Params.LoginName + _TEXT("\r\n") + Params.LoginPasswd + _TEXT("\r\n");
        strsize = ::_tcslen((LPCTSTR) login);
        LoginBuffer = new BYTE [strsize*sizeof(TCHAR) + 2];
        strsize = WideCharToMultiByte(CodePage,0,(LPCTSTR)login,strsize,
                                      (LPSTR) LoginBuffer,strsize*sizeof(TCHAR),NULL,NULL);
        comm = Params.Command + _TEXT("\r\n");
        cmdsize = ::_tcslen((LPCTSTR) comm);
        SocketBuffer = new BYTE [cmdsize*sizeof(TCHAR) + 2];
        cmdsize = WideCharToMultiByte(CodePage,0,(LPCTSTR) comm,cmdsize,
                                      (LPSTR) SocketBuffer,cmdsize*sizeof(TCHAR),NULL,NULL);
        Socket = new WatcherTelnetClient(SocketBuffer,cmdsize,LoginBuffer,strsize);
        if(!Socket || !LoginBuffer || !SocketBuffer
           || !cmdsize || !strsize){
            AfxFormatString1(rString, CREATE_TELNET_SOCKET_FAILURE, L"");
            MessageBox((LPCTSTR) rString, L"Watcher",MB_OK|MB_ICONSTOP);
            ret = GetParent()->PostMessage(WM_CLOSE,0,0);
            return;
        }
    }
    ASSERT ( Socket != NULL );
    Socket->SetParentView(this);
    TEXTMETRIC TextProps;
    ret = cdc->GetOutputTextMetrics(&TextProps);    
    if(!ret){
        _stprintf(Buffer, _T("%d"),GetLastError());
        AfxFormatString1(rString, CDC_TEXT_FAILURE, Buffer);
        MessageBox((LPCTSTR) rString,L"Watcher", MB_OK|MB_ICONSTOP);
        ret = GetParent()->PostMessage(WM_CLOSE,0,0);
        return;
    }
    height = TextProps.tmHeight + 1;
    width = (TextProps.tmAveCharWidth);
    CWnd *parent = GetParent();
    if(!parent){
        // this is an  orphan child window
        return;
    }
    CRect wrect, crect;
    parent->GetClientRect(&crect);
    parent->GetWindowRect(&wrect);
    wrect.SetRect(0,
                  0,
                  wrect.Width() - crect.Width() + width*MAX_TERMINAL_WIDTH,
                  wrect.Height() - crect.Height() + height*MAX_TERMINAL_HEIGHT
                  );
    parent->MoveWindow(&wrect,TRUE);
    parent->GetClientRect(&crect);
  
    ret =Socket->Create(0,SOCK_STREAM,NULL);
    if(!ret){
        _stprintf(Buffer,_T("%d"),GetLastError());
        AfxFormatString1(rString, SOCKET_CREATION_FAILED, Buffer);
        MessageBox((LPCTSTR) rString, L"Watcher", MB_OK|MB_ICONSTOP);
        ret = parent->PostMessage(WM_CLOSE,0,0);
        return;
    }
    position = 0;
  

    ret = Socket->Connect((LPCTSTR) Params.Machine,Params.Port);
    if (!ret){
        _stprintf(Buffer,_T("%d"),GetLastError());
        AfxFormatString1(rString, SOCKET_CONNECTION_FAILED, (LPCTSTR) Buffer);
        MessageBox((LPCTSTR) rString, L"Watcher", MB_OK|MB_ICONSTOP);
        ret = parent->PostMessage(WM_CLOSE,0,0);
       return;
    }
    if(Params.tcclnt){
        ret = Socket->Send(SocketBuffer,sizeof(CLIENT_INFO),0);
    }
    CView::OnInitialUpdate();
        
    if(cdc){
        OnDraw(cdc);
    }
    return;
}

/////////////////////////////////////////////////////////////////////////////
// CWatcherView diagnostics

#ifdef _DEBUG
void CWatcherView::AssertValid() const
{
    CView::AssertValid();
}

void CWatcherView::Dump(CDumpContext& dc) const
{
    CView::Dump(dc);
}

CWatcherDoc* CWatcherView::GetDocument() // non-debug version is inline
{
    ASSERT(m_pDocument->IsKindOf(RUNTIME_CLASS(CWatcherDoc)));
    return (CWatcherDoc*)m_pDocument;
}
#endif //_DEBUG

/////////////////////////////////////////////////////////////////////////////
// CWatcherView message handlers

void CWatcherView::OnChar(UINT nChar, UINT nRepCnt, UINT nFlags) 
{
        // TODO: Add your message handler code here and/or call default
        // We will send the character across the network and that is all we do.
    int nRet;

    nRet=Socket->Send(&nChar, 1, 0);
        //CView::OnChar(nChar, nRepCnt, nFlags);
}




// REMARK - should we make this also a virtual function so that 
// if bell sequences are to be trapped, you just need to 
// extend this class ??
void CWatcherView::ProcessByte(BYTE byte)
{
    //Currently, just do a textout on the device
    // Store the character in the screen buffer
    // A boolean variable to check if we are processing an escape sequence

    EnterCriticalSection(&mutex);
  
    if(byte == 27){
        InEscape = TRUE;
        EscapeBuffer[0] = byte;
        index = 1;
        LeaveCriticalSection(&mutex);
        return;
    }
    // Escape characters are not found in the characters sent across the 
    // wire. Similarly, when we enter the Bell protocol, no bells can 
    // be found. 
    if(InEscape == TRUE){
        if(index == MAX_TERMINAL_WIDTH){
            // vague escape sequence,give up processing
            InEscape = FALSE;
            index=0;
            LeaveCriticalSection(&mutex);
            return;
        }
        EscapeBuffer[index]=byte;
        index++;
        if(FinalCharacter((CHAR) byte)){
            ProcessEscapeSequence((PCHAR)EscapeBuffer, index);
            InEscape = FALSE;
            index=0;
        }
        LeaveCriticalSection(&mutex);
        return;
    }
    if(InBell == TRUE){
        if(indexBell > MAX_BELL_SIZE){
            // What a bell sequence, I give up....
            InBell = FALSE;
            // Print all that stuff onto the screen
            for(int i = 0; i<indexBell; i++){
                PrintCharacter(BellBuffer[i]);
            }
            LeaveCriticalSection(&mutex);
            return;
        }
        // We are processing a bell seequnce.
        if(indexBell < 10){ 
            BellBuffer[indexBell] = byte;
            indexBell ++;
            if(strncmp((const char *)BellBuffer,"\007\007\007<?xml>\007",indexBell) == 0){
                if(indexBell == 9){
                    BellStarted = TRUE;
                }
            }else{
                InBell = FALSE;
                for(int i = 0; i<indexBell; i++){
                   PrintCharacter(BellBuffer[i]);
                }
            }
        }else{
            BellBuffer[indexBell] = byte;
            indexBell++;
            if(BellBuffer[indexBell-1] == 0x07){
                // ok, end reached, go on.
                InBell = FALSE;
                BellStarted = FALSE;
                ProcessBellSequence((char * )BellBuffer, indexBell);
                indexBell = 0;
            }
        }
        LeaveCriticalSection(&mutex);
        return;
    }
    if(byte == 0x07){
        // We got a bell
        // start looking for the bell protocol
        InEscape = FALSE;
        BellStarted = FALSE;
        InBell = TRUE;
        BellBuffer[0] = byte;
        indexBell = 1;
        LeaveCriticalSection(&mutex);
        return;
    }

    if (byte == '\017' && seenM) {
        seenM=FALSE;
        LeaveCriticalSection(&mutex);
        return;
    }
    seenM=FALSE;
    PrintCharacter(byte);
    LeaveCriticalSection(&mutex);
    return;
}

void CWatcherView::PrintCharacter(BYTE byte)
{

    TCHAR Char;
    int CharWidth;
    CWatcherDoc *pDoc;
    BOOL ret;
    LPTSTR DataLine;
    
    pDoc = (CWatcherDoc *)GetDocument(); 
    if(!pDoc){
        // something really fatal.
        return;
    }
    if(byte == 10){
        ypos++;
        if((ypos == MAX_TERMINAL_HEIGHT) || (ypos == ScrollBottom)){
            ret = pDoc->Lock();
            if (ypos == ScrollBottom) {
                pDoc->ScrollData(0,foreground,background,ScrollTop,ScrollBottom);
            }
            else{
                pDoc->ScrollData(0,foreground,background,1,MAX_TERMINAL_HEIGHT);
            }
            ypos = ypos -1;
            ret = pDoc->Unlock();
            OnDraw(cdc);
        }
        return;
    }

    if(byte == 13){
        xpos = 0;
        position = 0;
        return;
    }

    if (byte == 0x8) {
        // backspace character.
        ret = pDoc->Lock();
        if(xpos>0){
            xpos--;
            pDoc->SetData(xpos, ypos, 0, 
                          foreground, background);
            DataLine = pDoc->GetDataLine(ypos);
            position = 0;
            if (xpos > 0){
                position = GetTextWidth(DataLine, xpos);
            }
        }
        ret = pDoc->Unlock();
        OnDraw(cdc);
        return;
    }

    Char = byte;
#ifdef _UNICODE
    DBCSArray[dbcsIndex] = byte;
    if(dbcsIndex ==0){
        if(IsDBCSLeadByteEx(CodePage, byte)){
            dbcsIndex ++;
            return;
        }
    }
    else{
      MultiByteToWideChar(CodePage,0,(const char *)DBCSArray,2,&Char,1); 
          dbcsIndex  = 0;
    }
#endif
 

    if(xpos >= MAX_TERMINAL_WIDTH){
        //Before moving over to the next line clear to end of display 
        // using the current background
        if(cdc){
            cdc->FillSolidRect(position,ypos*height, MAX_TERMINAL_WIDTH*width-position,
                               height,background);
        }
        xpos = 0;
        position = 0;
        ypos++;
        if((ypos == MAX_TERMINAL_HEIGHT) || (ypos == ScrollBottom)){
            ret = pDoc->Lock();
            if (ypos == ScrollBottom) {
                pDoc->ScrollData(0,foreground,background,ScrollTop,ScrollBottom);
            }
            else{
                pDoc->ScrollData(0,foreground,background,1,MAX_TERMINAL_HEIGHT);
            }
            ypos = ypos -1;
            ret = pDoc->Unlock();
            OnDraw(cdc);
        }
    }

    ret =cdc->GetOutputCharWidth(Char, Char, &CharWidth);

    if(IsPrintable(Char)){
        cdc->FillSolidRect(position,ypos*height,CharWidth,
                           height,background);
        cdc->TextOut(position,ypos*height,&Char, 1); 
        position = position + CharWidth;
        if (CharWidth >= 2*width){
            ret = pDoc->Lock();
            pDoc->SetData(xpos, ypos, 0xFFFF, foreground, background);
            xpos++;
            ret = pDoc->Unlock();
        }
    }
    else{
        cdc->FillSolidRect(position,ypos*height,width,
                           height,background);
        position = position + width;
    }
    ret = pDoc->Lock();
    pDoc->SetData(xpos, ypos, Char, 
                  foreground, background);
    xpos++;
    ret = pDoc->Unlock();

}


void CWatcherView::ProcessEscapeSequence(PCHAR Buffer, int length)
{

    ULONG charsToWrite;
    ULONG charsWritten;
    TCHAR *DataLine;
    CWatcherDoc *pDoc;
    BOOL ret;

    pDoc = (CWatcherDoc *) GetDocument();
    if(!pDoc){
        // something really wrong, queitly ignore this 
        // escape sequence
        return;
    }

    if (length == 3) {
        // One of the home cursor or clear to end of display
        if(strncmp(Buffer,"\033[r",length)==0){
            ScrollTop = 1;
            ScrollBottom = MAX_TERMINAL_HEIGHT;
            return;
        }
        if (strncmp(Buffer,"\033[H",length)==0) {
            // Home the cursor
            xpos = 0;
            ypos = 0;
            position = 0;
            return;
        }
        if(strncmp(Buffer,"\033[J", length) == 0){
            // clear to end of display assuming 80 X 24 size
            ret = pDoc->Lock();
            if(cdc){
                cdc->FillSolidRect(0,(ypos+1)*height,MAX_TERMINAL_WIDTH*width,
                                   (MAX_TERMINAL_HEIGHT-ypos)*height,background);
                cdc->FillSolidRect(position,ypos*height, MAX_TERMINAL_WIDTH*width - position,
                                   height,background);
            }
            pDoc->SetData(xpos, ypos, 0,
                          (MAX_TERMINAL_HEIGHT - ypos)*MAX_TERMINAL_WIDTH -xpos,
                          foreground, background);
            ret = pDoc->Unlock();
        }
        if(strncmp(Buffer,"\033[K", length) == 0){
            // clear to end of line assuming 80 X 24 size
            if(cdc){
                cdc->FillSolidRect(position,ypos*height,MAX_TERMINAL_WIDTH*width - position,
                                   height,background);
            }
            ret = pDoc->Lock();
            pDoc->SetData(xpos, ypos, 0,
                          MAX_TERMINAL_WIDTH -xpos, foreground, background);
            ret = pDoc->Unlock();
            return;
        }
        if(strncmp(Buffer,"\033[m", length) == 0){
            // clear all attributes and set Text attributes to black on white
            background = BLACK;
            foreground = WHITE;
            seenM = TRUE;
            if(cdc){
                cdc->SetBkColor(background);
                cdc->SetTextColor(foreground);
            }
            return;
        }
    }
    if (length == 4) {
        // One of the home cursor or clear to end of display
        if (strncmp(Buffer,"\033[0H",length)==0) {
            // Home the cursor
            xpos = 0;
            ypos = 0;
            position = 0;
            return;
        }

        if(strncmp(Buffer,"\033[2J",length) == 0){
            xpos = 0; 
            ypos = 0; 
            position =0;
            sprintf(Buffer,"\033[0J");
        }

        if(strncmp(Buffer,"\033[0J", length) == 0){
            // clear to end of display assuming 80 X 24 size
            if (IsWindowEnabled()){
                cdc->FillSolidRect(0,(ypos+1)*height,MAX_TERMINAL_WIDTH*width,
                                   (MAX_TERMINAL_HEIGHT-ypos)*height,background);
                cdc->FillSolidRect(position,ypos*height, MAX_TERMINAL_WIDTH*width - position,
                                   height,background);
            }
            ret = pDoc->Lock();
            pDoc->SetData(xpos, ypos, 0,
                (MAX_TERMINAL_HEIGHT - ypos)*MAX_TERMINAL_WIDTH -xpos,
                foreground, background);
            ret = pDoc->Unlock();
        }
        if((strncmp(Buffer,"\033[0K", length) == 0) || 
           (strncmp(Buffer,"\033[2K",length) == 0)){
            // clear to end of line assuming 80 X 24 size
            if(cdc){
                cdc->FillSolidRect(position,ypos*height, MAX_TERMINAL_WIDTH*width-position,
                                   height,background);
            }
            ret = pDoc->Lock();
            pDoc->SetData(xpos, ypos, 0,
                MAX_TERMINAL_WIDTH -xpos, foreground, background);
            ret = pDoc->Unlock();
            return;
        }
        if((strncmp(Buffer,"\033[0m", length) == 0)||
           (strncmp(Buffer,"\033[m\017", length) == 0)){
            // clear all attributes and set Text attributes to black on white
            background = BLACK;
            foreground = WHITE;
            if(cdc){
                cdc->SetBkColor(background);
                cdc->SetTextColor(foreground);
            }
            return;
        }
    }
    if(Buffer[length-1] == 'm'){
        //set the text attributes
        // clear all attributes and set Text attributes to black on white
        ProcessTextAttributes((PCHAR) Buffer, length);
        return;
    }

    if(Buffer[length -1] == 'r'){
        if (sscanf(Buffer,"\033[%d;%dr", &charsToWrite, &charsWritten) == 2) {
            ScrollTop = (SHORT)charsToWrite;
            ScrollBottom = (SHORT)charsWritten;
        }
        return;
    }

    if(Buffer[length -1] == 'H'){
        if (sscanf(Buffer,"\033[%d;%dH", &charsToWrite, &charsWritten) == 2) {
            ypos = (SHORT)(charsToWrite -1);
            xpos = (SHORT)(charsWritten -1);
            ret = pDoc->Lock();
            DataLine = pDoc->GetDataLine(ypos);
            if (xpos >0){
                position = GetTextWidth(DataLine, xpos);
            }
            else{
                position = 0;
            }
            pDoc->Unlock();
        }
    }
    return;
}

void CWatcherView::ProcessTextAttributes(PCHAR Buffer, int length)
{

    PCHAR CurrLoc = Buffer;
    ULONG Attribute;
    PCHAR pTemp;
    COLORREF temp;
 
    while(*CurrLoc != 'm'){
        if((*CurrLoc < '0') || (*CurrLoc >'9' )){
            CurrLoc ++;
        }else{
            if (sscanf(CurrLoc,"%d", &Attribute) != 1) {
                return;
            }
            switch(Attribute){
            case 7:
                // switch the colors. This will make this code 
                // work for applications (written in an Unix world
                // for real VT100. )
                temp = foreground;
                foreground = background;
                background = temp;
                break;
            case 37:
                foreground  = WHITE;
                break;
            case 47:
                background = WHITE;
                break;
            case 34:
                foreground  = BLUE;
                break;
            case 44:
                background  = BLUE; 
                break;
            case 30:
                foreground = BLACK;
                break;
            case 40:
                background = BLACK;
            case 33:
                foreground = YELLOW;
                break;
            case 43:
                background = YELLOW;
            case 31:
                foreground = RED;
                break;
            case 41:
                background = RED;
            default:
                break;
            }
            pTemp = strchr(CurrLoc, ';');
            if(pTemp == NULL){
                pTemp = strchr(CurrLoc, 'm');
            }
            if(pTemp == NULL) {
                break;
            }
            CurrLoc = pTemp;

        }
    }
    cdc->SetBkColor(background);
    cdc->SetTextColor(foreground);
    return;
}

BOOL CWatcherView::FinalCharacter(CHAR c)
{

    CHAR FinalCharacters[]="mHJKr";

    if(strchr(FinalCharacters,c)){
        return TRUE;
    }
    return FALSE;

}

BOOL CWatcherView::IsPrintable(TCHAR Char)
{
        if (Char > 32) return TRUE;
        return FALSE;
}

void CWatcherView::OnDestroy() 
{
        if(Socket){
            delete Socket;
        }
        if(cdc){
            delete cdc;
        }
        CView::OnDestroy();

        // TODO: Add your message handler code here
        
}

int CWatcherView::GetTextWidth(TCHAR *Data, int number)
{
    int textWidth=0;
    int CharWidth;

    for(int i=0;i<number;i++){
        // For variable width characters like Japanese, we need to 
        // blank out the next character. 
        if(Data[i] == 0xFFFF){
            continue;
        }
        if(IsPrintable(Data[i])){
            if (cdc->GetOutputCharWidth(Data[i], Data[i], &CharWidth)) {
                textWidth += CharWidth;
            }
        }
        else{
            textWidth += width;
        }
    }
    return textWidth;               

}
// REMARK - Make this a virtual function so that 
// later writers can just extend this class and work 
// with the same framework. Now, the bell sequence 
// processing consists of nothing, but later can be 
// expanded to include WMI kind of processing.
void CWatcherView::ProcessBellSequence(CHAR *Buffer, int len)
{
    // Set this as the active window.
    // We will probably bring up a dialog box with
    // the bell parameters.

    WCHAR *messageBuffer;
    CHAR tempBuffer[MAX_BELL_SIZE + 1];
    int index =0;

    memset(tempBuffer,0, MAX_BELL_SIZE + 1);
    memcpy(tempBuffer, Buffer+16, len-24);
    tempBuffer[len-24] = (CHAR) 0;

    CWnd *parent = GetParent();
    CWnd *prev = parent->GetParent();
    if (prev && prev->IsKindOf(RUNTIME_CLASS(CMDIFrameWnd))){
        ((CMDIFrameWnd *) prev)->MDIActivate(parent);
        ((CMDIFrameWnd *) prev)->MDIRestore(parent);
    }
    else{
        ((CMDIChildWnd *)parent)->MDIActivate();
        ((CMDIChildWnd *)parent)->MDIRestore();
    }
    int convlen;
    messageBuffer = new WCHAR [MAX_BELL_SIZE + 1];
    messageBuffer[0] = 0;
    convlen = MultiByteToWideChar(CP_ACP,
                                  0,
                                  tempBuffer,
                                  -1,
                                  messageBuffer,
                                  MAX_BELL_SIZE);
    messageBuffer[convlen] = (WCHAR) 0;
    CWinThread *th = ::AfxBeginThread(AFX_THREADPROC (GenerateWMIEvent),
                                      messageBuffer
                                      );
    return;
}

void CWatcherView::OnKeyDown(UINT nChar, UINT nRepCnt, UINT nFlags) 
{
        // TODO: Add your message handler code here and/or call default
    switch(nChar) { 
    case VK_LEFT: 
        Socket->Send("\033OC",sizeof("\033OC"),0);
        break;
    case VK_RIGHT: 
        Socket->Send("\033OD",sizeof("\033OD"),0);
        break;
    case VK_UP: 
        Socket->Send("\033OA",sizeof("\033OA"),0);
        break;
    case VK_DOWN: 
        Socket->Send("\033OB",sizeof("\033OB"),0);
        break;
    case VK_F1: 
        Socket->Send("\033""1",sizeof("\033""1"),0);
        break;
    case VK_F2: 
        Socket->Send("\033""2",sizeof("\033""2"),0);
        break;
    case VK_F3: 
        Socket->Send("\033""3",sizeof("\033""3"),0);
        break;
    case VK_F4: 
        Socket->Send("\033""4",sizeof("\033""4"),0);
        break;      
    case VK_F12: 
        Socket->Send("\033@",sizeof("\033@"),0);
        break;      
    default: 
        break; 
    } 
    CView::OnKeyDown(nChar, nRepCnt, nFlags);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\headless\watcher\watchertelnetclient.h ===
#if !defined(AFX_WATCHERTELNETCLIEN_H__5CB77E83_A530_4398_B134_353F5F0C84E5__INCLUDED_)
#define AFX_WatcherTelnetClient_H__5CB77E83_A530_4398_B134_353F5F0C84E5__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000
// WatcherTelnetClient.h : header file
//
#include "WatcherSocket.h"

/////////////////////////////////////////////////////////////////////////////
// WatcherTelnetClient command target

/*
 * Definitions for the TELNET protocol.
 */
#define NO_COMMAND 0               /* No command processing */
#define IAC        255             /* interpret as command: */
#define DONT       254             /* you are not to use option */
#define DO         253             /* please, you use option */
#define WONT       252             /* I won't use option */
#define WILL       251             /* I will use option */
#define SB         250             /* interpret as subnegotiation */
#define GA         249             /* you may reverse the line */
#define EL         248             /* erase the current line */
#define EC         247             /* erase the current character */
#define AYT        246             /* are you there */
#define AO         245             /* abort output--but let prog finish */
#define IP         244             /* interrupt process--permanently */
#define BREAK      243             /* break */
#define DM         242             /* data mark--for connect. cleaning */
#define NOP        241             /* nop */
#define SE         240             /* end sub negotiation */

#define SYNCH   242             /* for telfunc calls */
/* Telnet options - Names have been truncated to be unique in 7 chars */


#define TO_BINARY       0       /* 8-bit data path */
#define TO_ECHO         1       /* echo */
#define TO_RCP          2       /* prepare to reconnect */
#define TO_SGA          3       /* suppress go ahead */
#define TO_NAMS         4       /* approximate message size */
#define TO_STATUS       5       /* give status */
#define TO_TM           6       /* timing mark */
#define TO_RCTE         7       /* remote controlled transmission and echo */
#define TO_NL           8       /* negotiate about output line width */
#define TO_NP           9       /* negotiate about output page size */
#define TO_NCRD         10      /* negotiate about CR disposition */
#define TO_NHTS         11      /* negotiate about horizontal tabstops */
#define TO_NHTD         12      /* negotiate about horizontal tab disposition */
#define TO_NFFD         13      /* negotiate about formfeed disposition */
#define TO_NVTS         14      /* negotiate about vertical tab stops */
#define TO_NVTD         15      /* negotiate about vertical tab disposition */
#define TO_NLFD         16      /* negotiate about output LF disposition */
#define TO_XASCII       17      /* extended ascic character set */
#define TO_LOGOUT       18      /* force logout */
#define TO_BM           19      /* byte macro */
#define TO_DET          20      /* data entry terminal */
#define TO_SUPDUP       21      /* supdup protocol */
#define TO_TERM_TYPE    24      /* terminal type */
#define TO_NAWS         31      // Negotiate About Window Size
#define TO_TOGGLE_FLOW_CONTROL 33  /* Enable & disable Flow control */
#define TO_ENVIRON      36      /* Environment Option */
#define TO_NEW_ENVIRON  39      /* New Environment Option */
#define TO_EXOPL        255     /* extended-options-list */

#define TO_AUTH         37      
#define TT_SEND         1
#define TT_IS           0

class WatcherTelnetClient : public WatcherSocket
{
// Attributes
public:

public:
    WatcherTelnetClient(LPBYTE cmd = NULL, int cmdLen=0, LPBYTE lgn = NULL, int lngLen=0 );
    virtual ~WatcherTelnetClient();

// Overrides
public:
	
    // ClassWizard generated virtual function overrides
    //{{AFX_VIRTUAL(WatcherTelnetClient)
    //}}AFX_VIRTUAL
    void OnReceive(int nErrorCode);
	void OnClose(int nErrorCode);
    // Generated message map functions
    //{{AFX_MSG(WatcherTelnetClient)
        // NOTE - the ClassWizard will add and remove member functions here.
    //}}AFX_MSG

// Implementation
protected:
	BYTE CommandSequence;
	int lenLogin;
	LPBYTE Login;
	int OptionIndex;
	int PacketNumber;
	BOOL SentTermType;
	BYTE Options[MAX_BUFFER_SIZE];

	void ProcessSBCommand(BYTE cmd);
	int ProcessByte(BYTE Char);
    void ProcessCommand(BYTE cmd);
};

/////////////////////////////////////////////////////////////////////////////

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_WatcherTelnetClient_H__5CB77E83_A530_4398_B134_353F5F0C84E5__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\inc\ntdlltrc.h ===
/*++

Copyright (c) 1997-2000 Microsoft Corporation

Module Name:

    NtdllTracer.h

Abstract:

	This file contains structures and functions definitions used in Ntdll 
	events tracing


--*/

#ifndef _NTDLL_WMI_TRACE_
#define _NTDLL_WMI_TRACE_

#define MEMORY_FROM_LOOKASIDE					1		//Activity from LookAside
#define MEMORY_FROM_LOWFRAG						2		//Activity from Low Frag Heap
#define MEMORY_FROM_MAINPATH					3		//Activity from Main Code Path
#define MEMORY_FROM_SLOWPATH                    4       //Activity from Slow Code Path

#define LOG_LOOKASIDE                           0x00000001       //Bit for LookAside trace

#define FAILED_TLSINDEX			-1
#define MAX_PID                 10

#ifndef UserSharedData
#define UserSharedData USER_SHARED_DATA
#endif

#define IsCritSecLogging(CriticalSection) ((USER_SHARED_DATA->TraceLogging & ENABLECRITSECTRACE) \
                         && CriticalSection != &UMLogCritSect \
                         && CriticalSection != &PMCritSect \
                         && CriticalSection != &NtdllTraceHandles->CriticalSection)


extern 
ULONG GlobalCounter;

#define IsHeapLogging(HeapHandle) (USER_SHARED_DATA->TraceLogging & ENABLEHEAPTRACE && \
                                  (EtwpProcessHeap || !GlobalCounter ) &&  \
                                   EtwpProcessHeap != HeapHandle)

typedef struct _THREAD_LOCAL_DATA THREAD_LOCAL_DATA, *PTHREAD_LOCAL_DATA, **PPTHREAD_LOCAL_DATA;

typedef struct _THREAD_LOCAL_DATA {

	PTHREAD_LOCAL_DATA  FLink;					//Forward Link
	PTHREAD_LOCAL_DATA  BLink;					//Backward Link
	PWMI_BUFFER_HEADER  pBuffer;				//Pointer to thread buffer info.
    LONG                ReferenceCount;

} THREAD_LOCAL_DATA, *PTHREAD_LOCAL_DATA, **PPTHREAD_LOCAL_DATA;

extern 
PVOID EtwpProcessHeap;

#ifndef EtwpGetCycleCount

__int64
EtwpGetCycleCount();

#endif // EtwpGetCycleCount

void 
ReleaseBufferLocation(PTHREAD_LOCAL_DATA pThreadLocalData);

NTSTATUS 
AcquireBufferLocation(PVOID *pEvent, PPTHREAD_LOCAL_DATA pThreadLocalData, PUSHORT ReqSize);

typedef struct _NTDLL_EVENT_COMMON {

  PVOID Handle;		        //Handle of Heap

}NTDLL_EVENT_COMMON, *PNTDLL_EVENT_COMMON;


typedef struct _NTDLL_EVENT_HANDLES {

	RTL_CRITICAL_SECTION	CriticalSection;			//Critical section
	ULONG					dwTlsIndex;					//TLS Index
	TRACEHANDLE				hRegistrationHandle;		//Registration Handle used for Unregistration.
	TRACEHANDLE				hLoggerHandle;				//Handle to Trace Logger
	PTHREAD_LOCAL_DATA		pThreadListHead;	        //Link List that contains all threads info invovled in tracing.

}NTDLL_EVENT_HANDLES, *PNTDLL_EVENT_HANDLES, **PPNTDLL_EVENT_HANDLES;

extern LONG TraceLevel;
extern PNTDLL_EVENT_HANDLES NtdllTraceHandles;
extern RTL_CRITICAL_SECTION UMLogCritSect;
extern RTL_CRITICAL_SECTION PMCritSect;
extern RTL_CRITICAL_SECTION LoaderLock;

#endif //_NTDLL_WMI_TRACE_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\inc\kdcom.h ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    ixkdcom.h

Abstract:

    This module contains the header file for a very simple com port package.

Author:

    Bryan M. Willman (bryanwi) 24-Sep-1990

Revision History:

    John Vert (jvert) 19-Jul-1991
        Moved into HAL
--*/

#define COM1_PORT   0x03f8
#define COM2_PORT   0x02f8
#define COM3_PORT   0x03e8
#define COM4_PORT   0x02e8

#define COM_DAT     0x00
#define COM_IEN     0x01            // interrupt enable register
#define COM_LCR     0x03            // line control registers
#define COM_MCR     0x04            // modem control reg
#define COM_LSR     0x05            // line status register
#define COM_MSR     0x06            // modem status register
#define COM_DLL     0x00            // divisor latch least sig
#define COM_DLM     0x01            // divisor latch most sig

#define COM_BI      0x10
#define COM_FE      0x08
#define COM_PE      0x04
#define COM_OE      0x02

#define LC_DLAB     0x80            // divisor latch access bit

#define CLOCK_RATE  0x1C200         // USART clock rate

#define MC_DTRRTS   0x03            // Control bits to assert DTR and RTS
#define MS_DSRCTSCD 0xB0            // Status bits for DSR, CTS and CD
#define MS_CD       0x80

#define BD_150      150
#define BD_300      300
#define BD_600      600
#define BD_1200     1200
#define BD_2400     2400
#define BD_4800     4800
#define BD_9600     9600
#define BD_14400    14400
#define BD_19200    19200
#define BD_56000    56000
#define BD_57600    57600
#define BD_115200   115200

#define COM_OUTRDY  0x20
#define COM_DATRDY  0x01

#define MSG_DEBUG_9600          "Switching debugger to 9600 baud\n"

//
// This bit controls the loopback testing mode of the device.  Basically
// the outputs are connected to the inputs (and vice versa).
//
#define SERIAL_MCR_LOOP     0x10

//
// This bit is used for general purpose output.
//
#define SERIAL_MCR_OUT1     0x04

//
// This bit contains the (complemented) state of the clear to send
// (CTS) line.
//
#define SERIAL_MSR_CTS      0x10

//
// This bit contains the (complemented) state of the data set ready
// (DSR) line.
//
#define SERIAL_MSR_DSR      0x20

//
// This bit contains the (complemented) state of the ring indicator
// (RI) line.
//
#define SERIAL_MSR_RI       0x40

//
// This bit contains the (complemented) state of the data carrier detect
// (DCD) line.
//
#define SERIAL_MSR_DCD      0x80

#define SERIAL_LSR_NOT_PRESENT  0xff

typedef struct _CPPORT {
    PUCHAR  Address;
    ULONG  Baud;
    USHORT  Flags;
    TIME_FIELDS     CarrierLostTime;
//    ULONG   LockVar;
//    KSPIN_LOCK Lock;
} CPPORT, *PCPPORT;

#define PORT_DEFAULTRATE    0x0001      // baud rate not specified, using default
#define PORT_MODEMCONTROL   0x0002      // using modem controls
#define PORT_SAVED          0x0004      // port is in saved state
#define PORT_NOCDLTIME      0x0010      // 'Carrier detect lost' time not set
#define PORT_DISBAUD        0x0020      // Display baud rate abbrv
#define PORT_SENDINGSTRING  0x0040      // Sending modem string (don't recurse)
#define PORT_MDM_CD         0x0080      // CD while in modem control mode

VOID
CpInitialize (
    PCPPORT  Port,
    PUCHAR  Address,
    ULONG Rate
    );

VOID
CpSetBaud (
    PCPPORT  Port,
    ULONG  Rate
    );

USHORT
CpQueryBaud (
    PCPPORT  Port
    );

VOID
CpPutByte (
    PCPPORT  Port,
    UCHAR   Byte
    );

USHORT
CpGetByte (
    PCPPORT  Port,
    PUCHAR  Byte,
    BOOLEAN WaitForData
    );

VOID
CpLockPort (
    PCPPORT Port
    );

VOID
CpUnlockPort (
    PCPPORT Port
    );

VOID
CpStallExecution (
    VOID
    );

BOOLEAN
CpDoesPortExist(
    IN PUCHAR Address
    );

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\inc\cardbus.h ===
/*++

Module Name:

    cardbus.h

Abstract:

    This header contains generic cardbus definitions.

Author(s):

    Neil Sandlin (neilsa)

Revisions:

--*/

#ifndef _CARDBUS_
#define _CARDBUS_

//
// Cardbus register definitions
//

typedef struct _CARDBUS_SOCKET_REGS {
    ULONG Event;
    ULONG Mask;
    ULONG PresentState;
    ULONG ForceEvent;
    ULONG Control;
} CARDBUS_SOCKET_REGS, *PCARDBUS_SOCKET_REGS;    

//
// Socket Event Register bits
//

#define SKTEVENT_CSTSCHG                0x00000001L
#define SKTEVENT_CCD1                   0x00000002L
#define SKTEVENT_CCD2                   0x00000004L
#define SKTEVENT_CCD_MASK               (SKTEVENT_CCD1 | SKTEVENT_CCD2)
#define SKTEVENT_POWERCYCLE             0x00000008L
#define SKTEVENT_MASK                   0x0000000fL

//
// Socket Mask Register bits
//

#define SKTMSK_CSTSCHG                  0x00000001L
#define SKTMSK_CCD                      0x00000006L
#define SKTMSK_CCD1                     0x00000002L
#define SKTMSK_CCD2                     0x00000004L
#define SKTMSK_POWERCYCLE               0x00000008L

//
// Socket Present State Register bits
//

#define SKTSTATE_CSTSCHG                0x00000001L
#define SKTSTATE_CCD1                   0x00000002L
#define SKTSTATE_CCD2                   0x00000004L
#define SKTSTATE_CCD_MASK               (SKTSTATE_CCD1 | SKTSTATE_CCD2)
#define SKTSTATE_POWERCYCLE             0x00000008L
#define SKTSTATE_CARDTYPE_MASK          0x00000030L
#define SKTSTATE_R2CARD                 0x00000010L
#define SKTSTATE_CBCARD                 0x00000020L
#define SKTSTATE_OPTI_DOCK              0x00000030L
#define CARDTYPE(dw)       ((dw) & SKTSTATE_CARDTYPE_MASK)
#define SKTSTATE_CARDINT                0x00000040L
#define SKTSTATE_NOTACARD               0x00000080L
#define SKTSTATE_DATALOST               0x00000100L
#define SKTSTATE_BADVCCREQ              0x00000200L
#define SKTSTATE_5VCARD                 0x00000400L
#define SKTSTATE_3VCARD                 0x00000800L
#define SKTSTATE_XVCARD                 0x00001000L
#define SKTSTATE_YVCARD                 0x00002000L
#define SKTSTATE_CARDVCC_MASK    (SKTSTATE_5VCARD | SKTSTATE_3VCARD | \
                SKTSTATE_XVCARD | SKTSTATE_YVCARD)
#define SKTSTATE_5VSOCKET               0x10000000L
#define SKTSTATE_3VSOCKET               0x20000000L
#define SKTSTATE_XVSOCKET               0x40000000L
#define SKTSTATE_YVSOCKET               0x80000000L
#define SKTSTATE_SKTVCC_MASK     (SKTSTATE_5VSOCKET | \
                SKTSTATE_3VSOCKET | \
                SKTSTATE_XVSOCKET | \
                SKTSTATE_YVSOCKET)

//
//Socket Froce Register bits
//

#define SKTFORCE_CSTSCHG                0x00000001L
#define SKTFORCE_CCD1                   0x00000002L
#define SKTFORCE_CCD2                   0x00000004L
#define SKTFORCE_POWERCYCLE             0x00000008L
#define SKTFORCE_R2CARD                 0x00000010L
#define SKTFORCE_CBCARD                 0x00000020L
#define SKTFORCE_NOTACARD               0x00000080L
#define SKTFORCE_DATALOST               0x00000100L
#define SKTFORCE_BADVCCREQ              0x00000200L
#define SKTFORCE_5VCARD                 0x00000400L
#define SKTFORCE_3VCARD                 0x00000800L
#define SKTFORCE_XVCARD                 0x00001000L
#define SKTFORCE_YVCARD                 0x00002000L
#define SKTFORCE_CVSTEST                0x00004000L
#define SKTFORCE_5VSOCKET               0x10000000L
#define SKTFORCE_3VSOCKET               0x20000000L
#define SKTFORCE_XVSOCKET               0x40000000L
#define SKTFORCE_YVSOCKET               0x80000000L

//
// Power Control Register bits
//

#define SKTPOWER_VPP_CONTROL            0x00000007L
#define SKTPOWER_VPP_OFF                0x00000000L
#define SKTPOWER_VPP_120V               0x00000001L
#define SKTPOWER_VPP_050V               0x00000002L
#define SKTPOWER_VPP_033V               0x00000003L
#define SKTPOWER_VPP_0XXV               0x00000004L
#define SKTPOWER_VPP_0YYV               0x00000005L
#define SKTPOWER_VCC_CONTROL            0x00000070L
#define SKTPOWER_VCC_OFF                0x00000000L
#define SKTPOWER_VCC_050V               0x00000020L
#define SKTPOWER_VCC_033V               0x00000030L
#define SKTPOWER_VCC_0XXV               0x00000040L
#define SKTPOWER_VCC_0YYV               0x00000050L
#define SKTPOWER_STOPCLOCK              0x00000080L

//
// Misc. CardBus Constants
//

#define EXCAREG_OFFSET                  0x0800

//
// PCI config space constants
//
#define CARDBUS_LEGACY_MODE_BASE_ADDR   0x44

#define CARDBUS_BRIDGE_CONTROL_RESET    0x40

#endif  // _CARDBUS_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\inc\pcmciap.h ===
/*++

Copyright (c) 1994-1999  Microsoft Corporation

Module Name:

    pcmciap.h

Abstract:

    This is the include file that defines constants 
    accessing the PCMCIA Adapters.

Author:

    Ravisankar Pudipeddi (ravisp) 1-Jan-1997

Revision History:

    Neil Sandlin (neilsa) 10-Oct-2001 (split from ntddpcm.h)

--*/

#ifndef _PCMCIAPH_
#define _PCMCIAPH_

#if _MSC_VER > 1000
#pragma once
#endif

//
// These are macros to manipulate the PcCardConfig type resource
// descriptors - which are set by configmgr when passing in override
// configurations.
//

//
// Type of the descriptor: 1 .. 0xFFFF
//
#define DPTYPE_PCMCIA_CONFIGURATION 0x1
#define DPTYPE_PCMCIA_MF_CONFIGURATION 0x2

//
// The device private structure for PC-Card configuration:
//
// Data[0] is configuration descriptior. Lay out below.
//   Byte 0: Configuration entry number (config index)
//   Byte 1: IO window flags
//   Byte 2: Type of configuration, hardcoded to DPTYPE_PCMCIA_CONFIGURATION
//   Byte 3: unused
//
// Data [1]:  Cardbase offset for first memory window, flags in upper byte
// Data [2]:  Cardbase offset for second memory window, flags in upper byte
//
//
// The device private structure for MF-Card configuration:
//
// Data[0] is configuration descriptior. Lay out below.
//   Byte 0: Configuration Option Register (config index)
//   Byte 1: Configuration and Status Register
//           Audio Enable (bit 3)
//   Byte 2: Type of configuration, hardcoded to DPTYPE_PCMCIA_MF_CONFIGURATION
//   Byte 3: Port Io resource descriptor index
//
// Data [1]:  Configuration Register base
// Data [2]:  Unused
//

//
// Macros for manipulating the IoResource device privates
//
#define PCMRES_SET_DESCRIPTOR_TYPE(IoResourceDesc, Type)    (IoResourceDesc)->u.DevicePrivate.Data[0] |= ((Type) << sizeof(UCHAR)*8*2)
#define PCMRES_GET_DESCRIPTOR_TYPE(IoResourceDesc) ((UCHAR) ((IoResourceDesc)->u.DevicePrivate.Data[0] >> sizeof(UCHAR)*8*2))

//
// Macros specific to DPTYPE_PCMCIA_CONFIGURATION
//

#define PCMRES_SET_CONFIG_INDEX(desc, ConfigIndex) (desc)->u.DevicePrivate.Data[0] |= ConfigIndex
#define PCMRES_GET_CONFIG_INDEX(desc)    ((UCHAR) ((desc)->u.DevicePrivate.Data[0]))
//
// Define maximum indeces for i/o and memory
//

#define PCMRES_PCMCIA_MAX_IO 2
#define PCMRES_PCMCIA_MAX_MEM 2

//
// Flag definitions for Data[0]
//

#define PCMRESF_IO_16BIT_ACCESS  0x00000100
#define PCMRESF_IO_ZERO_WAIT_8   0x00000200
#define PCMRESF_IO_SOURCE_16     0x00000400
#define PCMRESF_IO_WAIT_16       0x00000800
#define PCMRESF_IO_FLAGS_2       0x0000F000              // used by second window

#define PCMRESF_PCMCIA_TYPE_2    0x80000000              // new format indicator

//
// Flag definitions for Data[1], Data[2]
//

#define PCMRES_BASE64MB_MASK     0x03ffffff

#define PCMRESF_MEM_16BIT_ACCESS 0x04000000
#define PCMRESF_MEM_ATTRIBUTE    0x08000000
#define PCMRESF_MEM_WAIT_1       0x10000000
#define PCMRESF_MEM_WAIT_2       0x20000000
#define PCMRESF_MEM_WAIT_3       0x30000000

//
// Macros specific to DPTYPE_PCMCIA_CONFIGURATION
//


#define PCMRES_SET_IO_FLAG(desc, index, flag) (desc)->u.DevicePrivate.Data[0] |= (flag << (index * 4))
#define PCMRES_GET_IO_FLAG(desc, index, flag) (((desc)->u.DevicePrivate.Data[0] & (flag << (index * 4))) != 0)
 
#define PCMRES_SET_MEMORY_FLAG(desc, index, flag) (desc)->u.DevicePrivate.Data[index+1] |= flag 
#define PCMRES_GET_MEMORY_FLAG(desc, index, flag) (((desc)->u.DevicePrivate.Data[index+1] & flag) != 0)

#define PCMRES_SET_MEMORY_CARDBASE(desc, index, base)  (desc)->u.DevicePrivate.Data[index+1] |= (base & PCMRES_BASE64MB_MASK)
#define PCMRES_GET_MEMORY_CARDBASE(desc, index)       ((ULONG) ((desc)->u.DevicePrivate.Data[index+1] & PCMRES_BASE64MB_MASK))

#define PCMRES_SET_MEMORY_WAITSTATES PCMRES_SET_MEMORY_FLAG
#define PCMRES_GET_MEMORY_WAITSTATES(desc, index) ((UCHAR) (((desc)->u.DevicePrivate.Data[index+1] >> 28)) & 3)


//
// Macros specific to DPTYPE_PCMCIA_MF_CONFIGURATION
//

#define PCMRESF_AUDIO_ENABLE     0x00000800
#define PCMRES_MF_PORT_INDEX_SHIFT   24

#define PCMRES_SET_CONFIG_OPTIONS(desc, opt)      (desc)->u.DevicePrivate.Data[0] |= opt
#define PCMRES_GET_CONFIG_OPTIONS(desc) ((UCHAR) ((desc)->u.DevicePrivate.Data[0]))

#define PCMRES_SET_PORT_RESOURCE_INDEX(desc, Index)    (desc)->u.DevicePrivate.Data[0] |= ((Index) << PCMRES_MF_PORT_INDEX_SHIFT)
#define PCMRES_GET_PORT_RESOURCE_INDEX(desc) ((UCHAR) ((desc)->u.DevicePrivate.Data[0] >> PCMRES_MF_PORT_INDEX_SHIFT))

#define PCMRES_SET_AUDIO_ENABLE(desc)           (desc)->u.DevicePrivate.Data[0] |= PCMRESF_AUDIO_ENABLE
#define PCMRES_GET_AUDIO_ENABLE(desc) ((UCHAR) ((desc)->u.DevicePrivate.Data[0] &  PCMRESF_AUDIO_ENABLE) != 0)

#define PCMRES_SET_CONFIG_REGISTER_BASE(desc, cfgbase)  (desc)->u.DevicePrivate.Data[1] = cfgbase
#define PCMRES_GET_CONFIG_REGISTER_BASE(desc)          ((desc)->u.DevicePrivate.Data[1])

//
// The following macros are in the process of being obseleted
//

#define IORES_SET_DESCRIPTOR_TYPE PCMRES_SET_DESCRIPTOR_TYPE 
#define IORES_GET_DESCRIPTOR_TYPE PCMRES_GET_DESCRIPTOR_TYPE 

#define IORES_SET_CONFIG_INDEX PCMRES_SET_CONFIG_INDEX 
#define IORES_GET_CONFIG_INDEX PCMRES_GET_CONFIG_INDEX 

#define IORES_SET_IO_16BIT_ACCESS(desc)         PCMRES_SET_IO_FLAG(desc, 0, PCMRESF_IO_16BIT_ACCESS)
#define IORES_GET_IO_16BIT_ACCESS(desc)         PCMRES_GET_IO_FLAG(desc, 0, PCMRESF_IO_16BIT_ACCESS)
#define IORES_SET_IO_8BIT_ACCESS(desc)           
#define IORES_SET_IO_ZERO_WAIT_8(desc)          PCMRES_SET_IO_FLAG(desc, 0, PCMRESF_IO_ZERO_WAIT_8)
#define IORES_SET_IO_SOURCE_16(desc)            PCMRES_SET_IO_FLAG(desc, 0, PCMRESF_IO_SOURCE_16)
#define IORES_SET_IO_WAIT_16(desc)              PCMRES_SET_IO_FLAG(desc, 0, PCMRESF_IO_WAIT_16)
#define IORES_GET_IO_ZERO_WAIT_8(desc)          PCMRES_GET_IO_FLAG(desc, 0, PCMRESF_IO_ZERO_WAIT_8) 
#define IORES_GET_IO_SOURCE_16(desc)            PCMRES_GET_IO_FLAG(desc, 0, PCMRESF_IO_SOURCE_16)   
#define IORES_GET_IO_WAIT_16(desc)              PCMRES_GET_IO_FLAG(desc, 0, PCMRESF_IO_WAIT_16)     
#define IORES_SET_MEM_16BIT_ACCESS(desc)        PCMRES_SET_MEMORY_FLAG(desc, 0, PCMRESF_MEM_16BIT_ACCESS)
#define IORES_GET_MEM_16BIT_ACCESS(desc)        PCMRES_GET_MEMORY_FLAG(desc, 0, PCMRESF_MEM_16BIT_ACCESS)
#define IORES_SET_MEM_8BIT_ACCESS(desc)   
#define IORES_SET_MEM_1_ATTRIBUTE_ACCESS(desc)  PCMRES_SET_MEMORY_FLAG(desc, 0, PCMRESF_MEM_ATTRIBUTE)
#define IORES_GET_MEM_1_ATTRIBUTE_ACCESS(desc)  PCMRES_GET_MEMORY_FLAG(desc, 0, PCMRESF_MEM_ATTRIBUTE)
#define IORES_SET_MEM_2_ATTRIBUTE_ACCESS(desc)  PCMRES_SET_MEMORY_FLAG(desc, 1, PCMRESF_MEM_ATTRIBUTE)
#define IORES_GET_MEM_2_ATTRIBUTE_ACCESS(desc)  PCMRES_GET_MEMORY_FLAG(desc, 1, PCMRESF_MEM_ATTRIBUTE)
#define IORES_SET_MEMORY_CARDBASE_1(desc, base) PCMRES_SET_MEMORY_CARDBASE(desc, 0, base)
#define IORES_GET_MEMORY_CARDBASE_1(desc)       PCMRES_GET_MEMORY_CARDBASE(desc, 0)
#define IORES_SET_MEMORY_CARDBASE_2(desc, base) PCMRES_SET_MEMORY_CARDBASE(desc, 1, base)
#define IORES_GET_MEMORY_CARDBASE_2(desc)       PCMRES_GET_MEMORY_CARDBASE(desc, 1)      
#define IORES_SET_MEM_WAIT_ONE(desc)            PCMRES_SET_MEMORY_WAITSTATES(desc, 0, PCMRESF_MEM_WAIT_1)
#define IORES_SET_MEM_WAIT_TWO(desc)            PCMRES_SET_MEMORY_WAITSTATES(desc, 0, PCMRESF_MEM_WAIT_2)
#define IORES_SET_MEM_WAIT_THREE(desc)          PCMRES_SET_MEMORY_WAITSTATES(desc, 0, PCMRESF_MEM_WAIT_3)
#define IORES_GET_MEM_WAIT(desc)                PCMRES_GET_MEMORY_WAITSTATES(desc, 0)

#define IORES_SET_CONFIG_OPTIONS       PCMRES_SET_CONFIG_OPTIONS      
#define IORES_GET_CONFIG_OPTIONS       PCMRES_GET_CONFIG_OPTIONS      
#define IORES_SET_PORT_RESOURCE_INDEX  PCMRES_SET_PORT_RESOURCE_INDEX 
#define IORES_GET_PORT_RESOURCE_INDEX  PCMRES_GET_PORT_RESOURCE_INDEX 
#define IORES_SET_AUDIO_ENABLE         PCMRES_SET_AUDIO_ENABLE        
#define IORES_GET_AUDIO_ENABLE         PCMRES_GET_AUDIO_ENABLE        
#define IORES_SET_CONFIG_REGISTER_BASE PCMRES_SET_CONFIG_REGISTER_BASE
#define IORES_GET_CONFIG_REGISTER_BASE PCMRES_GET_CONFIG_REGISTER_BASE

#define CMRES_SET_DESCRIPTOR_TYPE      IORES_SET_DESCRIPTOR_TYPE
#define CMRES_GET_DESCRIPTOR_TYPE      IORES_GET_DESCRIPTOR_TYPE

#define CMRES_SET_CONFIG_INDEX         IORES_SET_CONFIG_INDEX
#define CMRES_GET_CONFIG_INDEX         IORES_GET_CONFIG_INDEX

#define CMRES_SET_IO_16BIT_ACCESS      IORES_SET_IO_16BIT_ACCESS
#define CMRES_GET_IO_16BIT_ACCESS      IORES_GET_IO_16BIT_ACCESS
#define CMRES_SET_IO_8BIT_ACCESS       IORES_SET_IO_8BIT_ACCESS

#define CMRES_SET_IO_ZERO_WAIT_8       IORES_SET_IO_ZERO_WAIT_8
#define CMRES_SET_IO_SOURCE_16         IORES_SET_IO_SOURCE_16
#define CMRES_SET_IO_WAIT_16           IORES_SET_IO_WAIT_16
#define CMRES_GET_IO_ZERO_WAIT_8       IORES_GET_IO_ZERO_WAIT_8
#define CMRES_GET_IO_SOURCE_16         IORES_GET_IO_SOURCE_16
#define CMRES_GET_IO_WAIT_16           IORES_GET_IO_WAIT_16

#define CMRES_SET_MEM_16BIT_ACCESS     IORES_SET_MEM_16BIT_ACCESS
#define CMRES_GET_MEM_16BIT_ACCESS     IORES_GET_MEM_16BIT_ACCESS
#define CMRES_SET_MEM_8BIT_ACCESS      IORES_SET_MEM_8BIT_ACCESS

#define CMRES_SET_MEM_WAIT_ONE         IORES_SET_MEM_WAIT_ONE
#define CMRES_SET_MEM_WAIT_TWO         IORES_SET_MEM_WAIT_TWO
#define CMRES_SET_MEM_WAIT_THREE       IORES_SET_MEM_WAIT_THREE
#define CMRES_GET_MEM_WAIT             IORES_GET_MEM_WAIT

#define CMRES_SET_MEM_1_ATTRIBUTE_ACCESS IORES_SET_MEM_1_ATTRIBUTE_ACCESS 
#define CMRES_GET_MEM_1_ATTRIBUTE_ACCESS IORES_GET_MEM_1_ATTRIBUTE_ACCESS 
#define CMRES_SET_MEM_2_ATTRIBUTE_ACCESS IORES_SET_MEM_2_ATTRIBUTE_ACCESS 
#define CMRES_GET_MEM_2_ATTRIBUTE_ACCESS IORES_GET_MEM_2_ATTRIBUTE_ACCESS 

#define CMRES_SET_MEMORY_CARDBASE_1    IORES_SET_MEMORY_CARDBASE_1
#define CMRES_GET_MEMORY_CARDBASE_1    IORES_GET_MEMORY_CARDBASE_1
#define CMRES_SET_MEMORY_CARDBASE_2    IORES_SET_MEMORY_CARDBASE_2
#define CMRES_GET_MEMORY_CARDBASE_2    IORES_GET_MEMORY_CARDBASE_2

#define CMRES_SET_CONFIG_OPTIONS       IORES_SET_CONFIG_OPTIONS
#define CMRES_GET_CONFIG_OPTIONS       IORES_GET_CONFIG_OPTIONS
#define CMRES_SET_PORT_RESOURCE_INDEX  IORES_SET_PORT_RESOURCE_INDEX
#define CMRES_GET_PORT_RESOURCE_INDEX  IORES_GET_PORT_RESOURCE_INDEX
#define CMRES_SET_AUDIO_ENABLE         IORES_SET_AUDIO_ENABLE
#define CMRES_GET_AUDIO_ENABLE         IORES_GET_AUDIO_ENABLE
#define CMRES_SET_CONFIG_REGISTER_BASE IORES_SET_CONFIG_REGISTER_BASE
#define CMRES_GET_CONFIG_REGISTER_BASE IORES_GET_CONFIG_REGISTER_BASE

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\inc\svcsp.h ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    svcsp.h

Abstract:

    This file contains definitions used by service dlls that
    run inside of services.exe.

Author:

    Jonathan Schwartz (jschwart)  20-Sep-2000

--*/

#ifndef _SVCSP_
#define _SVCSP_

#ifndef RPC_NO_WINDOWS_H // Don't let rpc.h include windows.h
#define RPC_NO_WINDOWS_H
#endif // RPC_NO_WINDOWS_H

#include <rpc.h>                    // RPC_IF_HANDLE

//
// Service DLLs loaded into services.exe all export the same main
// entry point.  SVCS_ENTRY_POINT defines that name.
//
// Note that SVCS_ENTRY_POINT_STRING is always ANSI, because that's
// what GetProcAddress takes.
//

#define SVCS_ENTRY_POINT        ServiceEntry
#define SVCS_ENTRY_POINT_STRING "ServiceEntry"

//
// Name for the common RPC pipe shared by all the RPC servers in services.exe.
// Note:  Because version 1.0 of WinNt had seperate names for each server's
// pipe, the client side names have remained the same.  Mapping to the new
// name is handled by the named pipe file system.
//

#define SVCS_RPC_PIPE           L"ntsvcs"

//
// Name for the common LRPC protocol and port available in services.exe.
//

#define SVCS_LRPC_PROTOCOL      L"ncalrpc"
#define SVCS_LRPC_PORT          L"ntsvcs"


//
// Start and stop RPC server entry point prototype.
//

typedef
NTSTATUS
(*PSVCS_START_RPC_SERVER) (
    IN LPTSTR InterfaceName,
    IN RPC_IF_HANDLE InterfaceSpecification
    );

typedef
NTSTATUS
(*PSVCS_STOP_RPC_SERVER) (
    IN RPC_IF_HANDLE InterfaceSpecification
    );



//
// Structure containing "global" data for the various DLLs.
//

typedef struct _SVCS_GLOBAL_DATA
{
    //
    // NT well-known SIDs
    //

    PSID NullSid;                   // No members SID
    PSID WorldSid;                  // All users SID
    PSID LocalSid;                  // NT local users SID
    PSID NetworkSid;                // NT remote users SID
    PSID LocalSystemSid;            // NT system processes SID
    PSID LocalServiceSid;           // NT LocalService SID
    PSID NetworkServiceSid;         // NT NetworkService SID
    PSID BuiltinDomainSid;          // Domain Id of the Builtin Domain
    PSID AuthenticatedUserSid;      // NT authenticated users SID

    //
    // Well Known Aliases.
    //
    // These are aliases that are relative to the built-in domain.
    //

    PSID AliasAdminsSid;            // Administrator Sid
    PSID AliasUsersSid;             // User Sid
    PSID AliasGuestsSid;            // Guest Sid
    PSID AliasPowerUsersSid;        // Power User Sid
    PSID AliasAccountOpsSid;        // Account Operator Sid
    PSID AliasSystemOpsSid;         // System Operator Sid
    PSID AliasPrintOpsSid;          // Print Operator Sid
    PSID AliasBackupOpsSid;         // Backup Operator Sid

    //
    // Entry points provided by services.exe
    //

    PSVCS_START_RPC_SERVER  StartRpcServer;
    PSVCS_STOP_RPC_SERVER   StopRpcServer;
    LPWSTR                  SvcsRpcPipeName;

    //
    // Miscellaneous useful data
    //
    BOOL  fSetupInProgress;         // TRUE if setup is in progress, FALSE otherwise
}
SVCS_GLOBAL_DATA, *PSVCS_GLOBAL_DATA;


//
// Service DLL entrypoint prototype
//

typedef
VOID
(*PSVCS_SERVICE_DLL_ENTRY) (
    IN DWORD argc,
    IN LPTSTR argv[],
    IN PSVCS_GLOBAL_DATA pGlobalData,
    IN HANDLE SvcReferenceHandle
    );

#endif  // ndef _SVCSP_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mspatch\api\misc.c ===
#include <precomp.h>

//
//  misc.c
//
//  Author: Tom McGuire (tommcg) 2/97 - 12/97
//
//  Copyright (C) Microsoft, 1997-1998.
//
//  MICROSOFT CONFIDENTIAL
//

typedef struct _SUBALLOCATOR SUBALLOCATOR, *PSUBALLOCATOR;

struct _SUBALLOCATOR {
    PVOID  VirtualListTerminator;
    PVOID *VirtualList;
    PCHAR  NextAvailable;
    PCHAR  LastAvailable;
    ULONG  GrowSize;
    };


const ULONG gCrcTable32[ 256 ] = {
    0x00000000, 0x77073096, 0xEE0E612C, 0x990951BA, 0x076DC419, 0x706AF48F,
    0xE963A535, 0x9E6495A3, 0x0EDB8832, 0x79DCB8A4, 0xE0D5E91E, 0x97D2D988,
    0x09B64C2B, 0x7EB17CBD, 0xE7B82D07, 0x90BF1D91, 0x1DB71064, 0x6AB020F2,
    0xF3B97148, 0x84BE41DE, 0x1ADAD47D, 0x6DDDE4EB, 0xF4D4B551, 0x83D385C7,
    0x136C9856, 0x646BA8C0, 0xFD62F97A, 0x8A65C9EC, 0x14015C4F, 0x63066CD9,
    0xFA0F3D63, 0x8D080DF5, 0x3B6E20C8, 0x4C69105E, 0xD56041E4, 0xA2677172,
    0x3C03E4D1, 0x4B04D447, 0xD20D85FD, 0xA50AB56B, 0x35B5A8FA, 0x42B2986C,
    0xDBBBC9D6, 0xACBCF940, 0x32D86CE3, 0x45DF5C75, 0xDCD60DCF, 0xABD13D59,
    0x26D930AC, 0x51DE003A, 0xC8D75180, 0xBFD06116, 0x21B4F4B5, 0x56B3C423,
    0xCFBA9599, 0xB8BDA50F, 0x2802B89E, 0x5F058808, 0xC60CD9B2, 0xB10BE924,
    0x2F6F7C87, 0x58684C11, 0xC1611DAB, 0xB6662D3D, 0x76DC4190, 0x01DB7106,
    0x98D220BC, 0xEFD5102A, 0x71B18589, 0x06B6B51F, 0x9FBFE4A5, 0xE8B8D433,
    0x7807C9A2, 0x0F00F934, 0x9609A88E, 0xE10E9818, 0x7F6A0DBB, 0x086D3D2D,
    0x91646C97, 0xE6635C01, 0x6B6B51F4, 0x1C6C6162, 0x856530D8, 0xF262004E,
    0x6C0695ED, 0x1B01A57B, 0x8208F4C1, 0xF50FC457, 0x65B0D9C6, 0x12B7E950,
    0x8BBEB8EA, 0xFCB9887C, 0x62DD1DDF, 0x15DA2D49, 0x8CD37CF3, 0xFBD44C65,
    0x4DB26158, 0x3AB551CE, 0xA3BC0074, 0xD4BB30E2, 0x4ADFA541, 0x3DD895D7,
    0xA4D1C46D, 0xD3D6F4FB, 0x4369E96A, 0x346ED9FC, 0xAD678846, 0xDA60B8D0,
    0x44042D73, 0x33031DE5, 0xAA0A4C5F, 0xDD0D7CC9, 0x5005713C, 0x270241AA,
    0xBE0B1010, 0xC90C2086, 0x5768B525, 0x206F85B3, 0xB966D409, 0xCE61E49F,
    0x5EDEF90E, 0x29D9C998, 0xB0D09822, 0xC7D7A8B4, 0x59B33D17, 0x2EB40D81,
    0xB7BD5C3B, 0xC0BA6CAD, 0xEDB88320, 0x9ABFB3B6, 0x03B6E20C, 0x74B1D29A,
    0xEAD54739, 0x9DD277AF, 0x04DB2615, 0x73DC1683, 0xE3630B12, 0x94643B84,
    0x0D6D6A3E, 0x7A6A5AA8, 0xE40ECF0B, 0x9309FF9D, 0x0A00AE27, 0x7D079EB1,
    0xF00F9344, 0x8708A3D2, 0x1E01F268, 0x6906C2FE, 0xF762575D, 0x806567CB,
    0x196C3671, 0x6E6B06E7, 0xFED41B76, 0x89D32BE0, 0x10DA7A5A, 0x67DD4ACC,
    0xF9B9DF6F, 0x8EBEEFF9, 0x17B7BE43, 0x60B08ED5, 0xD6D6A3E8, 0xA1D1937E,
    0x38D8C2C4, 0x4FDFF252, 0xD1BB67F1, 0xA6BC5767, 0x3FB506DD, 0x48B2364B,
    0xD80D2BDA, 0xAF0A1B4C, 0x36034AF6, 0x41047A60, 0xDF60EFC3, 0xA867DF55,
    0x316E8EEF, 0x4669BE79, 0xCB61B38C, 0xBC66831A, 0x256FD2A0, 0x5268E236,
    0xCC0C7795, 0xBB0B4703, 0x220216B9, 0x5505262F, 0xC5BA3BBE, 0xB2BD0B28,
    0x2BB45A92, 0x5CB36A04, 0xC2D7FFA7, 0xB5D0CF31, 0x2CD99E8B, 0x5BDEAE1D,
    0x9B64C2B0, 0xEC63F226, 0x756AA39C, 0x026D930A, 0x9C0906A9, 0xEB0E363F,
    0x72076785, 0x05005713, 0x95BF4A82, 0xE2B87A14, 0x7BB12BAE, 0x0CB61B38,
    0x92D28E9B, 0xE5D5BE0D, 0x7CDCEFB7, 0x0BDBDF21, 0x86D3D2D4, 0xF1D4E242,
    0x68DDB3F8, 0x1FDA836E, 0x81BE16CD, 0xF6B9265B, 0x6FB077E1, 0x18B74777,
    0x88085AE6, 0xFF0F6A70, 0x66063BCA, 0x11010B5C, 0x8F659EFF, 0xF862AE69,
    0x616BFFD3, 0x166CCF45, 0xA00AE278, 0xD70DD2EE, 0x4E048354, 0x3903B3C2,
    0xA7672661, 0xD06016F7, 0x4969474D, 0x3E6E77DB, 0xAED16A4A, 0xD9D65ADC,
    0x40DF0B66, 0x37D83BF0, 0xA9BCAE53, 0xDEBB9EC5, 0x47B2CF7F, 0x30B5FFE9,
    0xBDBDF21C, 0xCABAC28A, 0x53B39330, 0x24B4A3A6, 0xBAD03605, 0xCDD70693,
    0x54DE5729, 0x23D967BF, 0xB3667A2E, 0xC4614AB8, 0x5D681B02, 0x2A6F2B94,
    0xB40BBE37, 0xC30C8EA1, 0x5A05DF1B, 0x2D02EF8D };


#if defined( DEBUG ) || defined( DBG ) || defined( TESTCODE )

BOOL
Assert(
    LPCSTR szText,
    LPCSTR szFile,
    DWORD  dwLine
    )
    {
    CHAR Buffer[ 512 ];
    wsprintf( Buffer, "ASSERT( %s ) FAILED, %s (%d)\n", szText, szFile, dwLine );
    OutputDebugString( Buffer );
    DebugBreak();
    return FALSE;
    }

#endif


#ifdef DONTCOMPILE  // Not currently being used

VOID
InitializeCrc32Table(
    VOID
    )
    {
    ULONG i, j, Value;

    for ( i = 0; i < 256; i++ ) {
        for ( Value = i, j = 8; j > 0; j-- ) {
            if ( Value & 1 ) {
                Value = ( Value >> 1 ) ^ 0xEDB88320;
                }
            else {
                Value >>= 1;
                }
            }
        gCrcTable32[ i ] = Value;
        }
    }

#endif // DONTCOMPILE


#ifdef _M_IX86
#pragma warning( disable: 4035 )    // no return value
#endif

ULONG
Crc32(
    IN ULONG InitialCrc,
    IN PVOID Buffer,
    IN ULONG ByteCount
    )
    {

#ifdef DONTCOMPILE  // Not currently being used

    //
    //  First determine if the CRC table has been initialized by checking
    //  that the last value in it is nonzero.  Believe it or not, this is
    //  thread safe because two threads could initialize the table at the
    //  same time with no harm, and the last value to be initialized in the
    //  table is used to determine if the table has been initialized.  On
    //  all hardware platforms (including Alpha) it is safe to assume that
    //  an aligned DWORD written to memory by one processor will be seen by
    //  the other processor(s) as either containing the value previously
    //  contained in that memory location, or the new written value, but not
    //  some weird unpredictable value.
    //

    if ( gCrcTable32[ 255 ] == 0 ) {
        InitializeCrc32Table();
        }

#endif // DONTCOMPILE

#ifdef _M_IX86

    __asm {

            mov     ecx, ByteCount          ; number of bytes in buffer
            xor     ebx, ebx                ; ebx (bl) will be our table index
            mov     esi, Buffer             ; buffer pointer
            test    ecx, ecx                ; test for zero length buffer
            mov     eax, InitialCrc         ; CRC-32 value

            jnz     short loopentry         ; if non-zero buffer, start loop
            jmp     short exitfunc          ; else exit (crc already in eax)

looptop:    shr     eax, 8                  ; (crc>>8)                      (U1)
            mov     edx, gCrcTable32[ebx*4] ; fetch Table[ index ]          (V1)

            xor     eax, edx                ; crc=(crc>>8)^Table[index]     (U1)
loopentry:  mov     bl, [esi]               ; fetch next *buffer            (V1)

            inc     esi                     ; buffer++                      (U1)
            xor     bl, al                  ; index=(byte)crc^*buffer       (V1)

            dec     ecx                     ; adjust counter                (U1)
            jnz     short looptop           ; loop while nBytes             (V1)

            shr     eax, 8                  ; remaining math on last byte
            xor     eax, gCrcTable32[ebx*4] ; eax returns new crc value

exitfunc:

        }

#else // ! _M_IX86

    {
    ULONG  Value = InitialCrc;
    ULONG  Count = ByteCount;
    PUCHAR p     = Buffer;

    while ( Count-- ) {
        Value = ( Value >> 8 ) ^ gCrcTable32[ (UCHAR)( *p++ ^ Value ) ];
        }

    return Value;
    }

#endif // ! _M_IX86
    }

#ifdef _M_IX86
#pragma warning( default: 4035 )    // no return value
#endif


BOOL
SafeCompleteCrc32(
    IN  PVOID  Buffer,
    IN  ULONG  ByteCount,
    OUT PULONG CrcValue
    )
    {
    BOOL Success = TRUE;

    __try {
        *CrcValue = Crc32( 0xFFFFFFFF, Buffer, ByteCount ) ^ 0xFFFFFFFF;
        }
    __except( EXCEPTION_EXECUTE_HANDLER ) {
        SetLastError( GetExceptionCode() );
        Success = FALSE;
        }

    return Success;
    }


BOOL
SafeCompleteMD5(
    IN  PVOID     Buffer,
    IN  ULONG     ByteCount,
    OUT PMD5_HASH MD5Value
    )
    {
    BOOL Success = TRUE;

    __try {
        ComputeCompleteMD5( Buffer, ByteCount, MD5Value );
        }
    __except( EXCEPTION_EXECUTE_HANDLER ) {
        SetLastError( GetExceptionCode() );
        Success = FALSE;
        }

    return Success;
    }


BOOL
MyMapViewOfFileA(
    IN  LPCSTR  FileName,
    OUT ULONG  *FileSize,
    OUT HANDLE *FileHandle,
    OUT PVOID  *MapBase
    )
    {
    HANDLE InternalFileHandle;
    BOOL   Success;

    InternalFileHandle = CreateFileA(
                             FileName,
                             GENERIC_READ,
                             FILE_SHARE_READ | FILE_SHARE_WRITE,
                             NULL,
                             OPEN_EXISTING,
                             FILE_FLAG_SEQUENTIAL_SCAN,
                             NULL
                             );

    if ( InternalFileHandle != INVALID_HANDLE_VALUE ) {

        Success = MyMapViewOfFileByHandle(
                      InternalFileHandle,
                      FileSize,
                      MapBase
                      );

        if ( Success ) {

            *FileHandle = InternalFileHandle;

            return TRUE;
            }

        CloseHandle( InternalFileHandle );
        }

    return FALSE;
    }


BOOL
MyMapViewOfFileByHandle(
    IN  HANDLE  FileHandle,
    OUT ULONG  *FileSize,
    OUT PVOID  *MapBase
    )
    {
    ULONG  InternalFileSize;
    ULONG  InternalFileSizeHigh;
    HANDLE InternalMapHandle;
    PVOID  InternalMapBase;

    InternalFileSize = GetFileSize( FileHandle, &InternalFileSizeHigh );

    if ( InternalFileSizeHigh != 0 ) {
        SetLastError( ERROR_OUTOFMEMORY );
        return FALSE;
        }

    if ( InternalFileSize == 0 ) {
        *MapBase  = NULL;
        *FileSize = 0;
        return TRUE;
        }

    if ( InternalFileSize != 0xFFFFFFFF ) {

        InternalMapHandle = CreateFileMapping(
                                FileHandle,
                                NULL,
                                PAGE_WRITECOPY,
                                0,
                                0,
                                NULL
                                );

        if ( InternalMapHandle != NULL ) {

            InternalMapBase = MapViewOfFile(
                                  InternalMapHandle,
                                  FILE_MAP_COPY,
                                  0,
                                  0,
                                  0
                                  );

            CloseHandle( InternalMapHandle );

            if ( InternalMapBase != NULL ) {

                *MapBase  = InternalMapBase;
                *FileSize = InternalFileSize;

                return TRUE;
                }
            }
        }

    return FALSE;
    }


BOOL
MyCreateMappedFileA(
    IN  LPCSTR  FileName,
    IN  ULONG   InitialSize,
    OUT HANDLE *FileHandle,
    OUT PVOID  *MapBase
    )
    {
    HANDLE InternalFileHandle;
    BOOL   Success;

    InternalFileHandle = CreateFileA(
                             FileName,
                             GENERIC_READ | GENERIC_WRITE,
                             FILE_SHARE_READ,
                             NULL,
                             CREATE_ALWAYS,
                             FILE_ATTRIBUTE_NORMAL,
                             NULL
                             );

    if ( InternalFileHandle != INVALID_HANDLE_VALUE ) {

        Success = MyCreateMappedFileByHandle(
                       InternalFileHandle,
                       InitialSize,
                       MapBase
                       );

        if ( Success ) {

            *FileHandle = InternalFileHandle;

            return TRUE;
            }

        CloseHandle( InternalFileHandle );
        }

    return FALSE;
    }


BOOL
MyCreateMappedFileByHandle(
    IN  HANDLE FileHandle,
    IN  ULONG  InitialSize,
    OUT PVOID *MapBase
    )
    {
    HANDLE InternalMapHandle;
    PVOID  InternalMapBase;

    InternalMapHandle = CreateFileMapping(
                            FileHandle,
                            NULL,
                            PAGE_READWRITE,
                            0,
                            InitialSize,
                            NULL
                            );

    if ( InternalMapHandle != NULL ) {

        InternalMapBase = MapViewOfFile(
                              InternalMapHandle,
                              FILE_MAP_WRITE,
                              0,
                              0,
                              0
                              );

        CloseHandle( InternalMapHandle );

        if ( InternalMapBase != NULL ) {

            *MapBase = InternalMapBase;

            return TRUE;
            }
        }

    return FALSE;
    }


VOID
MyUnmapCreatedMappedFile(
    IN HANDLE    FileHandle,
    IN PVOID     MapBase,
    IN ULONG     FileSize,
    IN PFILETIME FileTime OPTIONAL
    )
    {
    FlushViewOfFile( MapBase, 0 );
    UnmapViewOfFile( MapBase );
    SetFilePointer( FileHandle, (LONG) FileSize, NULL, FILE_BEGIN );
    SetEndOfFile( FileHandle );
    SetFileTime( FileHandle, NULL, NULL, FileTime );
    }


PVOID
__fastcall
MyVirtualAlloc(
    ULONG Size
    )
    {
    return VirtualAlloc( NULL, Size, MEM_COMMIT, PAGE_READWRITE );
    }


VOID
__fastcall
MyVirtualFree(
    PVOID Allocation
    )
    {
    VirtualFree( Allocation, 0, MEM_RELEASE );
    }


HANDLE
CreateSubAllocator(
    IN ULONG InitialCommitSize,
    IN ULONG GrowthCommitSize
    )
    {
    PSUBALLOCATOR SubAllocator;
    ULONG InitialSize;
    ULONG GrowthSize;

    InitialSize = ROUNDUP2( InitialCommitSize, MINIMUM_VM_ALLOCATION );
    GrowthSize  = ROUNDUP2( GrowthCommitSize,  MINIMUM_VM_ALLOCATION );

    SubAllocator = MyVirtualAlloc( InitialSize );

    //
    //  If can't allocate entire initial size, back off to minimum size.
    //  Very large initial requests sometimes cannot be allocated simply
    //  because there is not enough contiguous address space.
    //

    if (( SubAllocator == NULL ) && ( InitialSize > GrowthSize )) {
        InitialSize  = GrowthSize;
        SubAllocator = MyVirtualAlloc( InitialSize );
        }

    if (( SubAllocator == NULL ) && ( InitialSize > MINIMUM_VM_ALLOCATION )) {
        InitialSize  = MINIMUM_VM_ALLOCATION;
        SubAllocator = MyVirtualAlloc( InitialSize );
        }

    if ( SubAllocator != NULL ) {
        SubAllocator->NextAvailable = (PCHAR)SubAllocator + ROUNDUP2( sizeof( SUBALLOCATOR ), SUBALLOCATOR_ALIGNMENT );
        SubAllocator->LastAvailable = (PCHAR)SubAllocator + InitialSize;
        SubAllocator->VirtualList   = (PVOID*)SubAllocator;
        SubAllocator->GrowSize      = GrowthSize;
        }

    return (HANDLE) SubAllocator;
    }


PVOID
__fastcall
SubAllocate(
    IN HANDLE hAllocator,
    IN ULONG  Size
    )
    {
    PSUBALLOCATOR SubAllocator = (PSUBALLOCATOR) hAllocator;
    PCHAR NewVirtual;
    PCHAR Allocation;
    ULONG AllocSize;
    ULONG Available;
    ULONG GrowSize;

    ASSERT( Size < (ULONG)( ~(( SUBALLOCATOR_ALIGNMENT * 2 ) - 1 )));

    AllocSize = ROUNDUP2( Size, SUBALLOCATOR_ALIGNMENT );

    Available = (ULONG)( SubAllocator->LastAvailable - SubAllocator->NextAvailable );

    if ( AllocSize <= Available ) {

        Allocation = SubAllocator->NextAvailable;

        SubAllocator->NextAvailable = Allocation + AllocSize;

        return Allocation;
        }

    //
    //  Insufficient VM, so grow it.  Make sure we grow it enough to satisfy
    //  the allocation request in case the request is larger than the grow
    //  size specified in CreateSubAllocator.
    //

#ifdef TESTCODE

    printf( "\nGrowing VM suballocater\n" );

#endif

    GrowSize = SubAllocator->GrowSize;

    if ( GrowSize < ( AllocSize + SUBALLOCATOR_ALIGNMENT )) {
        GrowSize = ROUNDUP2(( AllocSize + SUBALLOCATOR_ALIGNMENT ), MINIMUM_VM_ALLOCATION );
        }

    NewVirtual = MyVirtualAlloc( GrowSize );

    //
    //  If failed to alloc GrowSize VM, and the allocation could be satisfied
    //  with a minimum VM allocation, try allocating minimum VM to satisfy
    //  this request.
    //

    if (( NewVirtual == NULL ) && ( AllocSize <= ( MINIMUM_VM_ALLOCATION - SUBALLOCATOR_ALIGNMENT ))) {
        GrowSize = MINIMUM_VM_ALLOCATION;
        NewVirtual = MyVirtualAlloc( GrowSize );
        }

    if ( NewVirtual != NULL ) {

        //
        //  Set LastAvailable to end of new VM block.
        //

        SubAllocator->LastAvailable = NewVirtual + GrowSize;

        //
        //  Link new VM into list of VM allocations.
        //

        *(PVOID*)NewVirtual = SubAllocator->VirtualList;
        SubAllocator->VirtualList = (PVOID*)NewVirtual;

        //
        //  Requested allocation comes next.
        //

        Allocation = NewVirtual + SUBALLOCATOR_ALIGNMENT;

        //
        //  Then set the NextAvailable for what's remaining.
        //

        SubAllocator->NextAvailable = Allocation + AllocSize;

        //
        //  And return the allocation.
        //

        return Allocation;
        }

    //
    //  Could not allocate enough VM to satisfy request.
    //

    return NULL;
    }


VOID
DestroySubAllocator(
    IN HANDLE hAllocator
    )
    {
    PSUBALLOCATOR SubAllocator = (PSUBALLOCATOR) hAllocator;
    PVOID VirtualBlock = SubAllocator->VirtualList;
    PVOID NextVirtualBlock;

    do  {
        NextVirtualBlock = *(PVOID*)VirtualBlock;
        MyVirtualFree( VirtualBlock );
        VirtualBlock = NextVirtualBlock;
        }
    while ( VirtualBlock != NULL );
    }


LPSTR
__fastcall
MySubAllocStrDup(
    IN HANDLE SubAllocator,
    IN LPCSTR String
    )
    {
    ULONG Length = (ULONG)strlen( String );
    LPSTR Buffer = SubAllocate( SubAllocator, Length + 1 );

    if ( Buffer ) {
        memcpy( Buffer, String, Length );   // no need to copy NULL terminator
        }

    return Buffer;
    }


LPSTR
MySubAllocStrDupAndCat(
    IN HANDLE SubAllocator,
    IN LPCSTR String1,
    IN LPCSTR String2,
    IN CHAR   Separator
    )
    {
    ULONG Length1 = (ULONG)strlen( String1 );
    ULONG Length2 = (ULONG)strlen( String2 );
    LPSTR Buffer = SubAllocate( SubAllocator, Length1 + Length2 + 2 );

    if ( Buffer ) {

        memcpy( Buffer, String1, Length1 );

        if (( Separator != 0 ) && ( Length1 > 0 ) && ( Buffer[ Length1 - 1 ] != Separator )) {
            Buffer[ Length1++ ] = Separator;
            }

        memcpy( Buffer + Length1, String2, Length2 );   // no need to terminate
        }

    return Buffer;
    }


VOID
MyLowercase(
    IN OUT LPSTR String
    )
    {
    LPSTR p;

    for ( p = String; *p; p++ ) {
        if (( *p >= 'A' ) && ( *p <= 'Z' )) {
            *p |= 0x20;
            }
        }
    }



#ifdef DONTCOMPILE  // not used currently

DWORD MyProcessHeap;

PVOID
MyHeapAllocZero(
    IN ULONG Size
    )
    {
    PVOID Allocation;

    if ( MyProcessHeap == NULL ) {
        MyProcessHeap = GetProcessHeap();
        }

    Allocation = HeapAlloc( MyProcessHeap, HEAP_ZERO_MEMORY, Size );

    if ( Allocation == NULL ) {
        SetLastError( ERROR_OUTOFMEMORY );
        }

    return Allocation;
    }


VOID
MyHeapFree(
    IN PVOID Allocation
    )
    {
    HeapFree( MyProcessHeap, 0, Allocation );
    }

#endif // DONTCOMPILE


ULONG
HashName(
    IN LPCSTR Name
    )
    {
    ULONG Length = (ULONG)strlen( Name );
    ULONG Hash   = ~Length;

    while ( Length-- ) {
        Hash = _rotl( Hash, 3 ) ^ *Name++;
        }

    return Hash;
    }


ULONG
HashNameCaseInsensitive(
    IN LPCSTR Name
    )
    {
    ULONG Length = (ULONG)strlen( Name );
    ULONG Hash   = ~Length;

    while ( Length-- ) {
        Hash = _rotl( Hash, 3 ) ^ ( *Name++ & 0xDF );   // mask case bit
        }

    return Hash;
    }


UCHAR
__inline
LowNibbleToHexChar(
    ULONG Value
    )
    {
    return "0123456789abcdef"[ Value & 0x0000000F ];
    }


VOID
DwordToHexString(
    IN  DWORD Value,
    OUT LPSTR Buffer    // writes exactly 9 bytes including terminator
    )
    {
    ULONG i;

    Buffer[ 8 ] = 0;

    i = 8;

    do  {
        Buffer[ --i ] = LowNibbleToHexChar( Value );
        Value >>= 4;
        }
    while ( i != 0 );
    }


BOOL
HashToHexString(
    IN  PMD5_HASH HashValue,
    OUT LPSTR     Buffer                // must be at least 33 bytes
    )
    {
    ULONG i;

    for ( i = 0; i < sizeof( MD5_HASH ); i++ ) {

        *Buffer++ = LowNibbleToHexChar( HashValue->Byte[ i ] >> 4 );
        *Buffer++ = LowNibbleToHexChar( HashValue->Byte[ i ] );
        }

    *Buffer = 0;

    return TRUE;
    }
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mspatch\api\md5.h ===
/*
 ***********************************************************************
 ** md5.h -- Header file for implementation of MD5                    **
 ** RSA Data Security, Inc. MD5 Message-Digest Algorithm              **
 ** Created: 2/17/90 RLR                                              **
 ** Revised: 12/27/90 SRD,AJ,BSK,JT Reference C version               **
 ** Revised (for MD5): RLR 4/27/91                                    **
 **   -- G modified to have y&~z instead of y&z                       **
 **   -- FF, GG, HH modified to add in last register done             **
 **   -- Access pattern: round 2 works mod 5, round 3 works mod 3     **
 **   -- distinct additive constant for each step                     **
 **   -- round 4 added, working mod 7                                 **
 ***********************************************************************
 */

/*
 ***********************************************************************
 ** Copyright (C) 1990, RSA Data Security, Inc. All rights reserved.  **
 **                                                                   **
 ** License to copy and use this software is granted provided that    **
 ** it is identified as the "RSA Data Security, Inc. MD5 Message-     **
 ** Digest Algorithm" in all material mentioning or referencing this  **
 ** software or this function.                                        **
 **                                                                   **
 ** License is also granted to make and use derivative works          **
 ** provided that such works are identified as "derived from the RSA  **
 ** Data Security, Inc. MD5 Message-Digest Algorithm" in all          **
 ** material mentioning or referencing the derived work.              **
 **                                                                   **
 ** RSA Data Security, Inc. makes no representations concerning       **
 ** either the merchantability of this software or the suitability    **
 ** of this software for any particular purpose.  It is provided "as  **
 ** is" without express or implied warranty of any kind.              **
 **                                                                   **
 ** These notices must be retained in any copies of any part of this  **
 ** documentation and/or software.                                    **
 ***********************************************************************
 */

/*                                                                         */
/* This copy of md5.h modified and adapted for my purposes, tommcg 6/28/96 */
/*                                                                         */

#pragma warning( disable: 4201 4204 )


#ifndef VOID
    typedef void VOID;
#endif
#ifndef UCHAR
    typedef unsigned char UCHAR;
#endif
#ifndef ULONG
    typedef unsigned long ULONG;
#endif
#ifndef ULONGLONG
    typedef unsigned __int64 ULONGLONG;
#endif
#ifndef PCVOID
    typedef const void * PCVOID;
#endif
#ifndef IN
    #define IN
#endif
#ifndef OUT
    #define OUT
#endif


typedef struct _MD5_HASH MD5_HASH, *PMD5_HASH;

struct _MD5_HASH {
    union {
        ULONG Word32[  4 ];
        UCHAR Byte  [ 16 ];
        };
    };

#define MD5_INITIAL_VALUE { 0x67452301, 0xefcdab89, 0x98badcfe, 0x10325476 }

VOID
InitMD5(
    IN OUT PMD5_HASH HashValue
    );

VOID
UpdateMD5_64ByteChunk(
    IN OUT PMD5_HASH HashValue,         // existing hash value
    IN     PCVOID    DataChunk          // pointer to 64 bytes of data
    );

VOID
FinalizeMD5(
    IN OUT PMD5_HASH HashValue,         // existing hash value
    IN     PCVOID    RemainingData,     // remaining data to hash
    IN     ULONG     RemainingBytes,    // 0 <= RemainingBytes < 64
    IN     ULONGLONG TotalBytesHashed   // total bytes hashed
    );

VOID
ComputeCompleteMD5(                     // complete MD5 in one call
    IN  PCVOID    DataBuffer,           // buffer to compute MD5 over
    IN  ULONGLONG DataLength,           // bytes of data in buffer
    OUT PMD5_HASH HashValue             // return finalized MD5 value
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mspatch\api\md5.c ===
/*
 ***********************************************************************
 ** md5.c                                                             **
 ** RSA Data Security, Inc. MD5 Message-Digest Algorithm              **
 ** Created: 2/17/90 RLR                                              **
 ** Revised: 1/91 SRD,AJ,BSK,JT Reference C Version                   **
 ***********************************************************************
 */

/*
 ***********************************************************************
 ** Copyright (C) 1990, RSA Data Security, Inc. All rights reserved.  **
 **                                                                   **
 ** License to copy and use this software is granted provided that    **
 ** it is identified as the "RSA Data Security, Inc. MD5 Message-     **
 ** Digest Algorithm" in all material mentioning or referencing this  **
 ** software or this function.                                        **
 **                                                                   **
 ** License is also granted to make and use derivative works          **
 ** provided that such works are identified as "derived from the RSA  **
 ** Data Security, Inc. MD5 Message-Digest Algorithm" in all          **
 ** material mentioning or referencing the derived work.              **
 **                                                                   **
 ** RSA Data Security, Inc. makes no representations concerning       **
 ** either the merchantability of this software or the suitability    **
 ** of this software for any particular purpose.  It is provided "as  **
 ** is" without express or implied warranty of any kind.              **
 **                                                                   **
 ** These notices must be retained in any copies of any part of this  **
 ** documentation and/or software.                                    **
 ***********************************************************************
 */

//  Portions copyright (c) 1992 Microsoft Corp.
//  All rights reserved

//
//  This copy of md5.c modified and adapted for my purposes, tommcg 6/28/96
//  Copyright (C) 1996-1999, Microsoft Corporation.
//


#include "md5.h"

#ifndef PCUCHAR
    typedef const unsigned char * PCUCHAR;
#endif
#ifndef PCULONG
    typedef const unsigned long * PCULONG;
#endif

#include <stdlib.h>     /* _rotl */
#include <memory.h>     /* memcpy, memset */

#pragma intrinsic(memcpy, memset)

/* Constants for Transform routine. */
#define S11 7
#define S12 12
#define S13 17
#define S14 22
#define S21 5
#define S22 9
#define S23 14
#define S24 20
#define S31 4
#define S32 11
#define S33 16
#define S34 23
#define S41 6
#define S42 10
#define S43 15
#define S44 21


/* ROTATE_LEFT rotates x left n bits. */

#define ROTATE_LEFT(x, n) ((x << n) | (x >> (32 - n)))

//
//  Intel and PowerPC both have a hardware rotate instruction with intrinsic
//  (inline) function for them.  Rough measurements show a 25% speed increase
//  for Intel and 10% speed increase for PowerPC when using the instrinsic
//  rotate versus the above defined shift/shift/or implemenation.
//

#if defined(_M_IX86) || defined(_M_PPC)
    #undef  ROTATE_LEFT
    #define ROTATE_LEFT(x, n) _rotl(x, n)
    #pragma intrinsic(_rotl)
#endif


/* F, G and H are basic MD5 functions */
#define F(x, y, z) ((x & y) | (~x & z))
#define G(x, y, z) ((x & z) | (y & ~z))
#define H(x, y, z) (x ^ y ^ z)
#define I(x, y, z) (y ^ (x | ~z))


/* FF, GG, HH, and II transformations for rounds 1, 2, 3, and 4 */
/* Rotation is separate from addition to prevent recomputation */
#define FF(a, b, c, d, x, s, ac) \
   a += F(b, c, d) + x + ac; \
   a = ROTATE_LEFT(a, s); \
   a += b;

#define GG(a, b, c, d, x, s, ac) \
   a += G(b, c, d) + x + ac; \
   a = ROTATE_LEFT(a, s); \
   a += b;

#define HH(a, b, c, d, x, s, ac) \
   a += H(b, c, d) + x + ac; \
   a = ROTATE_LEFT(a, s); \
   a += b;

#define II(a, b, c, d, x, s, ac) \
   a += I(b, c, d) + x + ac; \
   a = ROTATE_LEFT(a, s); \
   a += b;


VOID
InitMD5(
    IN OUT PMD5_HASH HashValue
    )
    {
    HashValue->Word32[ 0 ] = 0x67452301;
    HashValue->Word32[ 1 ] = 0xefcdab89;
    HashValue->Word32[ 2 ] = 0x98badcfe;
    HashValue->Word32[ 3 ] = 0x10325476;
    }

VOID
UpdateMD5_64ByteChunk(
    IN OUT PMD5_HASH HashValue,         // existing hash value
    IN     PCVOID    DataChunk          // ULONG-aligned pointer to 64-byte message chunk
    )
    {
    PCULONG MessageWord32 = DataChunk;
    ULONG a = HashValue->Word32[ 0 ];
    ULONG b = HashValue->Word32[ 1 ];
    ULONG c = HashValue->Word32[ 2 ];
    ULONG d = HashValue->Word32[ 3 ];

    /* Round 1 */
    FF ( a, b, c, d, MessageWord32[  0 ], S11, 0xd76aa478 ) /* 1 */
    FF ( d, a, b, c, MessageWord32[  1 ], S12, 0xe8c7b756 ) /* 2 */
    FF ( c, d, a, b, MessageWord32[  2 ], S13, 0x242070db ) /* 3 */
    FF ( b, c, d, a, MessageWord32[  3 ], S14, 0xc1bdceee ) /* 4 */
    FF ( a, b, c, d, MessageWord32[  4 ], S11, 0xf57c0faf ) /* 5 */
    FF ( d, a, b, c, MessageWord32[  5 ], S12, 0x4787c62a ) /* 6 */
    FF ( c, d, a, b, MessageWord32[  6 ], S13, 0xa8304613 ) /* 7 */
    FF ( b, c, d, a, MessageWord32[  7 ], S14, 0xfd469501 ) /* 8 */
    FF ( a, b, c, d, MessageWord32[  8 ], S11, 0x698098d8 ) /* 9 */
    FF ( d, a, b, c, MessageWord32[  9 ], S12, 0x8b44f7af ) /* 10 */
    FF ( c, d, a, b, MessageWord32[ 10 ], S13, 0xffff5bb1 ) /* 11 */
    FF ( b, c, d, a, MessageWord32[ 11 ], S14, 0x895cd7be ) /* 12 */
    FF ( a, b, c, d, MessageWord32[ 12 ], S11, 0x6b901122 ) /* 13 */
    FF ( d, a, b, c, MessageWord32[ 13 ], S12, 0xfd987193 ) /* 14 */
    FF ( c, d, a, b, MessageWord32[ 14 ], S13, 0xa679438e ) /* 15 */
    FF ( b, c, d, a, MessageWord32[ 15 ], S14, 0x49b40821 ) /* 16 */

    /* Round 2 */
    GG ( a, b, c, d, MessageWord32[  1 ], S21, 0xf61e2562 ) /* 17 */
    GG ( d, a, b, c, MessageWord32[  6 ], S22, 0xc040b340 ) /* 18 */
    GG ( c, d, a, b, MessageWord32[ 11 ], S23, 0x265e5a51 ) /* 19 */
    GG ( b, c, d, a, MessageWord32[  0 ], S24, 0xe9b6c7aa ) /* 20 */
    GG ( a, b, c, d, MessageWord32[  5 ], S21, 0xd62f105d ) /* 21 */
    GG ( d, a, b, c, MessageWord32[ 10 ], S22, 0x02441453 ) /* 22 */
    GG ( c, d, a, b, MessageWord32[ 15 ], S23, 0xd8a1e681 ) /* 23 */
    GG ( b, c, d, a, MessageWord32[  4 ], S24, 0xe7d3fbc8 ) /* 24 */
    GG ( a, b, c, d, MessageWord32[  9 ], S21, 0x21e1cde6 ) /* 25 */
    GG ( d, a, b, c, MessageWord32[ 14 ], S22, 0xc33707d6 ) /* 26 */
    GG ( c, d, a, b, MessageWord32[  3 ], S23, 0xf4d50d87 ) /* 27 */
    GG ( b, c, d, a, MessageWord32[  8 ], S24, 0x455a14ed ) /* 28 */
    GG ( a, b, c, d, MessageWord32[ 13 ], S21, 0xa9e3e905 ) /* 29 */
    GG ( d, a, b, c, MessageWord32[  2 ], S22, 0xfcefa3f8 ) /* 30 */
    GG ( c, d, a, b, MessageWord32[  7 ], S23, 0x676f02d9 ) /* 31 */
    GG ( b, c, d, a, MessageWord32[ 12 ], S24, 0x8d2a4c8a ) /* 32 */

    /* Round 3 */
    HH ( a, b, c, d, MessageWord32[  5 ], S31, 0xfffa3942 ) /* 33 */
    HH ( d, a, b, c, MessageWord32[  8 ], S32, 0x8771f681 ) /* 34 */
    HH ( c, d, a, b, MessageWord32[ 11 ], S33, 0x6d9d6122 ) /* 35 */
    HH ( b, c, d, a, MessageWord32[ 14 ], S34, 0xfde5380c ) /* 36 */
    HH ( a, b, c, d, MessageWord32[  1 ], S31, 0xa4beea44 ) /* 37 */
    HH ( d, a, b, c, MessageWord32[  4 ], S32, 0x4bdecfa9 ) /* 38 */
    HH ( c, d, a, b, MessageWord32[  7 ], S33, 0xf6bb4b60 ) /* 39 */
    HH ( b, c, d, a, MessageWord32[ 10 ], S34, 0xbebfbc70 ) /* 40 */
    HH ( a, b, c, d, MessageWord32[ 13 ], S31, 0x289b7ec6 ) /* 41 */
    HH ( d, a, b, c, MessageWord32[  0 ], S32, 0xeaa127fa ) /* 42 */
    HH ( c, d, a, b, MessageWord32[  3 ], S33, 0xd4ef3085 ) /* 43 */
    HH ( b, c, d, a, MessageWord32[  6 ], S34, 0x04881d05 ) /* 44 */
    HH ( a, b, c, d, MessageWord32[  9 ], S31, 0xd9d4d039 ) /* 45 */
    HH ( d, a, b, c, MessageWord32[ 12 ], S32, 0xe6db99e5 ) /* 46 */
    HH ( c, d, a, b, MessageWord32[ 15 ], S33, 0x1fa27cf8 ) /* 47 */
    HH ( b, c, d, a, MessageWord32[  2 ], S34, 0xc4ac5665 ) /* 48 */

    /* Round 4 */
    II ( a, b, c, d, MessageWord32[  0 ], S41, 0xf4292244 ) /* 49 */
    II ( d, a, b, c, MessageWord32[  7 ], S42, 0x432aff97 ) /* 50 */
    II ( c, d, a, b, MessageWord32[ 14 ], S43, 0xab9423a7 ) /* 51 */
    II ( b, c, d, a, MessageWord32[  5 ], S44, 0xfc93a039 ) /* 52 */
    II ( a, b, c, d, MessageWord32[ 12 ], S41, 0x655b59c3 ) /* 53 */
    II ( d, a, b, c, MessageWord32[  3 ], S42, 0x8f0ccc92 ) /* 54 */
    II ( c, d, a, b, MessageWord32[ 10 ], S43, 0xffeff47d ) /* 55 */
    II ( b, c, d, a, MessageWord32[  1 ], S44, 0x85845dd1 ) /* 56 */
    II ( a, b, c, d, MessageWord32[  8 ], S41, 0x6fa87e4f ) /* 57 */
    II ( d, a, b, c, MessageWord32[ 15 ], S42, 0xfe2ce6e0 ) /* 58 */
    II ( c, d, a, b, MessageWord32[  6 ], S43, 0xa3014314 ) /* 59 */
    II ( b, c, d, a, MessageWord32[ 13 ], S44, 0x4e0811a1 ) /* 60 */
    II ( a, b, c, d, MessageWord32[  4 ], S41, 0xf7537e82 ) /* 61 */
    II ( d, a, b, c, MessageWord32[ 11 ], S42, 0xbd3af235 ) /* 62 */
    II ( c, d, a, b, MessageWord32[  2 ], S43, 0x2ad7d2bb ) /* 63 */
    II ( b, c, d, a, MessageWord32[  9 ], S44, 0xeb86d391 ) /* 64 */

    HashValue->Word32[ 0 ] += a;
    HashValue->Word32[ 1 ] += b;
    HashValue->Word32[ 2 ] += c;
    HashValue->Word32[ 3 ] += d;
    }


VOID
FinalizeMD5(
    IN OUT PMD5_HASH HashValue,
    IN     PCVOID    RemainingData,     // remaining data to hash
    IN     ULONG     RemainingBytes,    // 0 <= RemainingBytes < 64
    IN     ULONGLONG TotalBytesHashed   // total bytes hashed
    )
    {
    union {
        ULONGLONG Qword[  8 ];
        UCHAR     Byte [ 64 ];
        } LocalBuffer;

    //
    //  Always append a pad byte of 0x80 to the message.
    //
    //  If RemainingBytes is less than (but not equal to) 56 bytes, then
    //  the final bits hashed count will be stored in the last 8 bytes of
    //  this 64 byte hash chunk.
    //
    //  If RemainingBytes is exactly 56 bytes, the appended 0x80 pad byte
    //  will force an extra chunk.
    //
    //  If RemainingBytes is greater than or equal to 56 bytes, then the
    //  final bits hashed count will be stored in the last 8 bytes of the
    //  NEXT 64 byte chunk that is otherwise zeroed, so THIS chunk needs to
    //  be zero-padded beyond the first pad byte and then hashed, then zero
    //  the first 56 bytes of the LocalBuffer for the NEXT chunk hash.
    //

    RemainingBytes &= 63;           // only care about partial frames

    //
    //  Zero init local buffer.
    //

    memset( &LocalBuffer, 0, 64 );

    //
    //  Append 0x80 pad byte to message.
    //

    LocalBuffer.Byte[ RemainingBytes ] = 0x80;

    if ( RemainingBytes > 0 ) {

        //
        //  Copy remaining data bytes (0 < RemainingBytes < 64) to LocalBuffer
        //  (remainder of LocalBuffer already zeroed except for pad byte).
        //

        memcpy( &LocalBuffer, RemainingData, RemainingBytes );

        if ( RemainingBytes >= 56 ) {

            UpdateMD5_64ByteChunk( HashValue, &LocalBuffer );

            memset( &LocalBuffer, 0, 56 );

            }
        }

    //
    //  Number of BITS hashed goes into last 8 bytes of last chunk.  This
    //  is a 64-bit value.  Note that if the number of BITS exceeds 2^64
    //  then this number is the low order 64 bits of the result.
    ///

    LocalBuffer.Qword[ 7 ] = ( TotalBytesHashed * 8 );      // number of BITS

    UpdateMD5_64ByteChunk( HashValue, &LocalBuffer );

    }


VOID
ComputeCompleteMD5(
    IN  PCVOID    DataBuffer,
    IN  ULONGLONG DataLength,
    OUT PMD5_HASH HashValue
    )
    {
    PCUCHAR   DataPointer = DataBuffer;
    ULONGLONG ChunkCount  = DataLength / 64;
    ULONG     OddBytes    = (ULONG)DataLength & 63;

    InitMD5( HashValue );

    while ( ChunkCount-- ) {
        UpdateMD5_64ByteChunk( HashValue, DataPointer );
        DataPointer += 64;
        }

    FinalizeMD5( HashValue, DataPointer, OddBytes, DataLength );
    }
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mspatch\api\patchapi.h ===
//
//  patchapi.h
//
//  Interface for creating and applying patches to files.
//
//  Copyright (C) Microsoft, 1997-2000.
//

#ifndef _PATCHAPI_H_
#define _PATCHAPI_H_

#ifdef __cplusplus
extern "C" {
#endif

//
//  The following constants can be combined and used as the OptionFlags
//  parameter in the patch creation apis.
//

#define PATCH_OPTION_USE_BEST           0x00000000  // auto choose best (slower)

#define PATCH_OPTION_USE_LZX_BEST       0x00000003  // auto choose best of LZX
#define PATCH_OPTION_USE_LZX_A          0x00000001  // normal
#define PATCH_OPTION_USE_LZX_B          0x00000002  // better on some x86 binaries
#define PATCH_OPTION_USE_LZX_LARGE      0x00000004  // better support for files >8MB

#define PATCH_OPTION_NO_BINDFIX         0x00010000  // PE bound imports
#define PATCH_OPTION_NO_LOCKFIX         0x00020000  // PE smashed locks
#define PATCH_OPTION_NO_REBASE          0x00040000  // PE rebased image
#define PATCH_OPTION_FAIL_IF_SAME_FILE  0x00080000  // don't create if same
#define PATCH_OPTION_FAIL_IF_BIGGER     0x00100000  // fail if patch is larger than simply compressing new file (slower)
#define PATCH_OPTION_NO_CHECKSUM        0x00200000  // PE checksum zero
#define PATCH_OPTION_NO_RESTIMEFIX      0x00400000  // PE resource timestamps
#define PATCH_OPTION_NO_TIMESTAMP       0x00800000  // don't store new file timestamp in patch
#define PATCH_OPTION_SIGNATURE_MD5      0x01000000  // use MD5 instead of CRC32
#define PATCH_OPTION_RESERVED1          0x80000000  // (used internally)

#define PATCH_OPTION_VALID_FLAGS        0x80FF0007

#define PATCH_SYMBOL_NO_IMAGEHLP        0x00000001  // don't use imagehlp.dll
#define PATCH_SYMBOL_NO_FAILURES        0x00000002  // don't fail patch due to imagehlp failures
#define PATCH_SYMBOL_UNDECORATED_TOO    0x00000004  // after matching decorated symbols, try to match remaining by undecorated names
#define PATCH_SYMBOL_RESERVED1          0x80000000  // (used internally)


//
//  The following constants can be combined and used as the ApplyOptionFlags
//  parameter in the patch apply and test apis.
//

#define APPLY_OPTION_FAIL_IF_EXACT      0x00000001  // don't copy new file
#define APPLY_OPTION_FAIL_IF_CLOSE      0x00000002  // differ by rebase, bind
#define APPLY_OPTION_TEST_ONLY          0x00000004  // don't create new file
#define APPLY_OPTION_VALID_FLAGS        0x00000007

//
//  In addition to standard Win32 error codes, the following error codes may
//  be returned via GetLastError() when one of the patch APIs fails.
//

#define ERROR_PATCH_ENCODE_FAILURE          0xC00E3101  // create
#define ERROR_PATCH_INVALID_OPTIONS         0xC00E3102  // create
#define ERROR_PATCH_SAME_FILE               0xC00E3103  // create
#define ERROR_PATCH_RETAIN_RANGES_DIFFER    0xC00E3104  // create
#define ERROR_PATCH_BIGGER_THAN_COMPRESSED  0xC00E3105  // create
#define ERROR_PATCH_IMAGEHLP_FAILURE        0xC00E3106  // create

#define ERROR_PATCH_DECODE_FAILURE          0xC00E4101  // apply
#define ERROR_PATCH_CORRUPT                 0xC00E4102  // apply
#define ERROR_PATCH_NEWER_FORMAT            0xC00E4103  // apply
#define ERROR_PATCH_WRONG_FILE              0xC00E4104  // apply
#define ERROR_PATCH_NOT_NECESSARY           0xC00E4105  // apply
#define ERROR_PATCH_NOT_AVAILABLE           0xC00E4106  // apply

typedef BOOL (CALLBACK PATCH_PROGRESS_CALLBACK)(
    PVOID CallbackContext,
    ULONG CurrentPosition,
    ULONG MaximumPosition
    );

typedef PATCH_PROGRESS_CALLBACK *PPATCH_PROGRESS_CALLBACK;

typedef BOOL (CALLBACK PATCH_SYMLOAD_CALLBACK)(
    IN ULONG  WhichFile,          // 0 for new file, 1 for first old file, etc
    IN LPCSTR SymbolFileName,
    IN ULONG  SymType,            // see SYM_TYPE in imagehlp.h
    IN ULONG  SymbolFileCheckSum,
    IN ULONG  SymbolFileTimeDate,
    IN ULONG  ImageFileCheckSum,
    IN ULONG  ImageFileTimeDate,
    IN PVOID  CallbackContext
    );

typedef PATCH_SYMLOAD_CALLBACK *PPATCH_SYMLOAD_CALLBACK;

typedef struct _PATCH_IGNORE_RANGE {
    ULONG OffsetInOldFile;
    ULONG LengthInBytes;
    } PATCH_IGNORE_RANGE, *PPATCH_IGNORE_RANGE;

typedef struct _PATCH_RETAIN_RANGE {
    ULONG OffsetInOldFile;
    ULONG LengthInBytes;
    ULONG OffsetInNewFile;
    } PATCH_RETAIN_RANGE, *PPATCH_RETAIN_RANGE;

typedef struct _PATCH_OLD_FILE_INFO_A {
    ULONG               SizeOfThisStruct;
    LPCSTR              OldFileName;
    ULONG               IgnoreRangeCount;               // maximum 255
    PPATCH_IGNORE_RANGE IgnoreRangeArray;
    ULONG               RetainRangeCount;               // maximum 255
    PPATCH_RETAIN_RANGE RetainRangeArray;
    } PATCH_OLD_FILE_INFO_A, *PPATCH_OLD_FILE_INFO_A;

typedef struct _PATCH_OLD_FILE_INFO_W {
    ULONG               SizeOfThisStruct;
    LPCWSTR             OldFileName;
    ULONG               IgnoreRangeCount;               // maximum 255
    PPATCH_IGNORE_RANGE IgnoreRangeArray;
    ULONG               RetainRangeCount;               // maximum 255
    PPATCH_RETAIN_RANGE RetainRangeArray;
    } PATCH_OLD_FILE_INFO_W, *PPATCH_OLD_FILE_INFO_W;

typedef struct _PATCH_OLD_FILE_INFO_H {
    ULONG               SizeOfThisStruct;
    HANDLE              OldFileHandle;
    ULONG               IgnoreRangeCount;               // maximum 255
    PPATCH_IGNORE_RANGE IgnoreRangeArray;
    ULONG               RetainRangeCount;               // maximum 255
    PPATCH_RETAIN_RANGE RetainRangeArray;
    } PATCH_OLD_FILE_INFO_H, *PPATCH_OLD_FILE_INFO_H;

typedef struct _PATCH_OLD_FILE_INFO {
    ULONG               SizeOfThisStruct;
    union {
        LPCSTR          OldFileNameA;
        LPCWSTR         OldFileNameW;
        HANDLE          OldFileHandle;
        };
    ULONG               IgnoreRangeCount;               // maximum 255
    PPATCH_IGNORE_RANGE IgnoreRangeArray;
    ULONG               RetainRangeCount;               // maximum 255
    PPATCH_RETAIN_RANGE RetainRangeArray;
    } PATCH_OLD_FILE_INFO, *PPATCH_OLD_FILE_INFO;

typedef struct _PATCH_OPTION_DATA {
    ULONG                   SizeOfThisStruct;
    ULONG                   SymbolOptionFlags;      // PATCH_SYMBOL_xxx flags
    LPCSTR                  NewFileSymbolPath;      // always ANSI, never Unicode
    LPCSTR                 *OldFileSymbolPathArray; // array[ OldFileCount ]
    ULONG                   ExtendedOptionFlags;
    PPATCH_SYMLOAD_CALLBACK SymLoadCallback;
    PVOID                   SymLoadContext;
    } PATCH_OPTION_DATA, *PPATCH_OPTION_DATA;

//
//  Note that PATCH_OPTION_DATA contains LPCSTR paths, and no LPCWSTR (Unicode)
//  path argument is available, even when used with one of the Unicode APIs
//  such as CreatePatchFileW.  This is because the underlying system services
//  for symbol file handling (IMAGEHLP.DLL) only support ANSI file/path names.
//

//
//  A note about PATCH_RETAIN_RANGE specifiers with multiple old files:
//
//  Each old version file must have the same RetainRangeCount, and the same
//  retain range LengthInBytes and OffsetInNewFile values in the same order.
//  Only the OffsetInOldFile values can differ between old files for retain
//  ranges.
//

#ifdef IMPORTING_PATCHAPI_DLL
#define PATCHAPI WINAPI __declspec( dllimport )
#else
#define PATCHAPI WINAPI
#endif


//
//  The following prototypes are interface for creating patches from files.
//

BOOL
PATCHAPI
CreatePatchFileA(
    IN  LPCSTR OldFileName,
    IN  LPCSTR NewFileName,
    OUT LPCSTR PatchFileName,
    IN  ULONG  OptionFlags,
    IN  PPATCH_OPTION_DATA OptionData       // optional
    );

BOOL
PATCHAPI
CreatePatchFileW(
    IN  LPCWSTR OldFileName,
    IN  LPCWSTR NewFileName,
    OUT LPCWSTR PatchFileName,
    IN  ULONG   OptionFlags,
    IN  PPATCH_OPTION_DATA OptionData       // optional
    );

BOOL
PATCHAPI
CreatePatchFileByHandles(
    IN  HANDLE OldFileHandle,
    IN  HANDLE NewFileHandle,
    OUT HANDLE PatchFileHandle,
    IN  ULONG  OptionFlags,
    IN  PPATCH_OPTION_DATA OptionData       // optional
    );

BOOL
PATCHAPI
CreatePatchFileExA(
    IN  ULONG                    OldFileCount,          // maximum 255
    IN  PPATCH_OLD_FILE_INFO_A   OldFileInfoArray,
    IN  LPCSTR                   NewFileName,
    OUT LPCSTR                   PatchFileName,
    IN  ULONG                    OptionFlags,
    IN  PPATCH_OPTION_DATA       OptionData,            // optional
    IN  PPATCH_PROGRESS_CALLBACK ProgressCallback,
    IN  PVOID                    CallbackContext
    );

BOOL
PATCHAPI
CreatePatchFileExW(
    IN  ULONG                    OldFileCount,          // maximum 255
    IN  PPATCH_OLD_FILE_INFO_W   OldFileInfoArray,
    IN  LPCWSTR                  NewFileName,
    OUT LPCWSTR                  PatchFileName,
    IN  ULONG                    OptionFlags,
    IN  PPATCH_OPTION_DATA       OptionData,            // optional
    IN  PPATCH_PROGRESS_CALLBACK ProgressCallback,
    IN  PVOID                    CallbackContext
    );

BOOL
PATCHAPI
CreatePatchFileByHandlesEx(
    IN  ULONG                    OldFileCount,          // maximum 255
    IN  PPATCH_OLD_FILE_INFO_H   OldFileInfoArray,
    IN  HANDLE                   NewFileHandle,
    OUT HANDLE                   PatchFileHandle,
    IN  ULONG                    OptionFlags,
    IN  PPATCH_OPTION_DATA       OptionData,            // optional
    IN  PPATCH_PROGRESS_CALLBACK ProgressCallback,
    IN  PVOID                    CallbackContext
    );

BOOL
PATCHAPI
ExtractPatchHeaderToFileA(
    IN  LPCSTR PatchFileName,
    OUT LPCSTR PatchHeaderFileName
    );

BOOL
PATCHAPI
ExtractPatchHeaderToFileW(
    IN  LPCWSTR PatchFileName,
    OUT LPCWSTR PatchHeaderFileName
    );

BOOL
PATCHAPI
ExtractPatchHeaderToFileByHandles(
    IN  HANDLE PatchFileHandle,
    OUT HANDLE PatchHeaderFileHandle
    );

//
//  The following prototypes are interface for creating new file from old file
//  and patch file.  Note that it is possible for the TestApply API to succeed
//  but the actual Apply to fail since the TestApply only verifies that the
//  old file has the correct CRC without actually applying the patch.  The
//  TestApply API only requires the patch header portion of the patch file,
//  but its CRC must be fixed up.
//

BOOL
PATCHAPI
TestApplyPatchToFileA(
    IN LPCSTR PatchFileName,
    IN LPCSTR OldFileName,
    IN ULONG  ApplyOptionFlags
    );

BOOL
PATCHAPI
TestApplyPatchToFileW(
    IN LPCWSTR PatchFileName,
    IN LPCWSTR OldFileName,
    IN ULONG   ApplyOptionFlags
    );

BOOL
PATCHAPI
TestApplyPatchToFileByHandles(
    IN HANDLE PatchFileHandle,      // requires GENERIC_READ access
    IN HANDLE OldFileHandle,        // requires GENERIC_READ access
    IN ULONG  ApplyOptionFlags
    );

BOOL
PATCHAPI
ApplyPatchToFileA(
    IN  LPCSTR PatchFileName,
    IN  LPCSTR OldFileName,
    OUT LPCSTR NewFileName,
    IN  ULONG  ApplyOptionFlags
    );

BOOL
PATCHAPI
ApplyPatchToFileW(
    IN  LPCWSTR PatchFileName,
    IN  LPCWSTR OldFileName,
    OUT LPCWSTR NewFileName,
    IN  ULONG   ApplyOptionFlags
    );

BOOL
PATCHAPI
ApplyPatchToFileByHandles(
    IN  HANDLE PatchFileHandle,     // requires GENERIC_READ access
    IN  HANDLE OldFileHandle,       // requires GENERIC_READ access
    OUT HANDLE NewFileHandle,       // requires GENERIC_READ | GENERIC_WRITE
    IN  ULONG  ApplyOptionFlags
    );

BOOL
PATCHAPI
ApplyPatchToFileExA(
    IN  LPCSTR                   PatchFileName,
    IN  LPCSTR                   OldFileName,
    OUT LPCSTR                   NewFileName,
    IN  ULONG                    ApplyOptionFlags,
    IN  PPATCH_PROGRESS_CALLBACK ProgressCallback,
    IN  PVOID                    CallbackContext
    );

BOOL
PATCHAPI
ApplyPatchToFileExW(
    IN  LPCWSTR                  PatchFileName,
    IN  LPCWSTR                  OldFileName,
    OUT LPCWSTR                  NewFileName,
    IN  ULONG                    ApplyOptionFlags,
    IN  PPATCH_PROGRESS_CALLBACK ProgressCallback,
    IN  PVOID                    CallbackContext
    );

BOOL
PATCHAPI
ApplyPatchToFileByHandlesEx(
    IN  HANDLE                   PatchFileHandle,
    IN  HANDLE                   OldFileHandle,
    OUT HANDLE                   NewFileHandle,
    IN  ULONG                    ApplyOptionFlags,
    IN  PPATCH_PROGRESS_CALLBACK ProgressCallback,
    IN  PVOID                    CallbackContext
    );

//
//  The following prototypes provide a unique patch "signature" for a given
//  file.  Consider the case where you have a new foo.dll and the machines
//  to be updated with the new foo.dll may have one of three different old
//  foo.dll files.  Rather than creating a single large patch file that can
//  update any of the three older foo.dll files, three separate smaller patch
//  files can be created and "named" according to the patch signature of the
//  old file.  Then the patch applyer application can determine at runtime
//  which of the three foo.dll patch files is necessary given the specific
//  foo.dll to be updated.  If patch files are being downloaded over a slow
//  network connection (Internet over a modem), this signature scheme provides
//  a mechanism for choosing the correct single patch file to download at
//  application time thus decreasing total bytes necessary to download.
//

BOOL
PATCHAPI
GetFilePatchSignatureA(
    IN  LPCSTR FileName,
    IN  ULONG  OptionFlags,
    IN  PVOID  OptionData,
    IN  ULONG  IgnoreRangeCount,
    IN  PPATCH_IGNORE_RANGE IgnoreRangeArray,
    IN  ULONG  RetainRangeCount,
    IN  PPATCH_RETAIN_RANGE RetainRangeArray,
    IN  ULONG  SignatureBufferSize,
    OUT PVOID  SignatureBuffer
    );

BOOL
PATCHAPI
GetFilePatchSignatureW(
    IN  LPCWSTR FileName,
    IN  ULONG   OptionFlags,
    IN  PVOID   OptionData,
    IN  ULONG   IgnoreRangeCount,
    IN  PPATCH_IGNORE_RANGE IgnoreRangeArray,
    IN  ULONG   RetainRangeCount,
    IN  PPATCH_RETAIN_RANGE RetainRangeArray,
    IN  ULONG   SignatureBufferSizeInBytes,
    OUT PVOID   SignatureBuffer
    );

BOOL
PATCHAPI
GetFilePatchSignatureByHandle(
    IN  HANDLE  FileHandle,
    IN  ULONG   OptionFlags,
    IN  PVOID   OptionData,
    IN  ULONG   IgnoreRangeCount,
    IN  PPATCH_IGNORE_RANGE IgnoreRangeArray,
    IN  ULONG   RetainRangeCount,
    IN  PPATCH_RETAIN_RANGE RetainRangeArray,
    IN  ULONG   SignatureBufferSize,
    OUT PVOID   SignatureBuffer
    );


//
//  Depending on whether UNICODE is defined, map the generic API names to the
//  appropriate Unicode or Ansi APIs.
//

#ifdef UNICODE

    #define CreatePatchFile          CreatePatchFileW
    #define CreatePatchFileEx        CreatePatchFileExW
    #define TestApplyPatchToFile     TestApplyPatchToFileW
    #define ApplyPatchToFile         ApplyPatchToFileW
    #define ApplyPatchToFileEx       ApplyPatchToFileExW
    #define ExtractPatchHeaderToFile ExtractPatchHeaderToFileW
    #define GetFilePatchSignature    GetFilePatchSignatureW

#else

    #define CreatePatchFile          CreatePatchFileA
    #define CreatePatchFileEx        CreatePatchFileExA
    #define TestApplyPatchToFile     TestApplyPatchToFileA
    #define ApplyPatchToFile         ApplyPatchToFileA
    #define ApplyPatchToFileEx       ApplyPatchToFileExA
    #define ExtractPatchHeaderToFile ExtractPatchHeaderToFileA
    #define GetFilePatchSignature    GetFilePatchSignatureA

#endif // UNICODE

#ifdef __cplusplus
}
#endif

#endif // _PATCHAPI_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mspatch\api\misc.h ===
//
//  misc.h
//
//  Author: Tom McGuire (tommcg) 2/97 - 9/97
//
//  Copyright (C) Microsoft, 1997.
//
//  MICROSOFT CONFIDENTIAL
//

#ifndef _PATCH_MISC_H_
#define _PATCH_MISC_H_

#ifdef __cplusplus
extern "C" {
#endif

#pragma intrinsic( memcpy, memset, memcmp, strcpy, strcmp, strlen, strcat, abs, _rotl )

#ifndef ROUNDUP2
#define ROUNDUP2( x, n ) ((((ULONG)(x)) + (((ULONG)(n)) - 1 )) & ~(((ULONG)(n)) - 1 ))
#endif

#ifndef MIN
#define MIN( a, b ) (((a)<(b))?(a):(b))
#endif

#ifndef bool
typedef int bool;
#endif

#ifndef byte
typedef unsigned char byte;
#endif

#define SUBALLOCATOR_ALIGNMENT 8

#define MINIMUM_VM_ALLOCATION 0x10000


#if defined( DEBUG ) || defined( DBG ) || defined( TESTCODE )

#include <stdlib.h>
#include <stdio.h>

#endif


#ifndef ASSERT

BOOL
Assert(
    LPCSTR szText,
    LPCSTR szFile,
    DWORD  dwLine
    );

#if defined( DEBUG ) || defined( DBG ) || defined( TESTCODE )
#define ASSERT( a ) (( a ) ? 1 : Assert( #a, __FILE__, __LINE__ ))
#else
#define ASSERT( a )
#endif
#endif // ASSERT


VOID
InitializeCrc32Table(
    VOID
    );

ULONG
Crc32(
    IN ULONG InitialCrc,
    IN PVOID Buffer,
    IN ULONG ByteCount
    );

BOOL
SafeCompleteCrc32(
    IN  PVOID  Buffer,
    IN  ULONG  ByteCount,
    OUT PULONG CrcValue
    );

BOOL
SafeCompleteMD5(
    IN  PVOID     Buffer,
    IN  ULONG     ByteCount,
    OUT PMD5_HASH MD5Value
    );

BOOL
MyMapViewOfFileByHandle(
    IN  HANDLE  FileHandle,
    OUT ULONG  *FileSize,
    OUT PVOID  *MapBase
    );

BOOL
MyMapViewOfFileA(
    IN  LPCSTR  FileName,
    OUT ULONG  *FileSize,
    OUT HANDLE *FileHandle,
    OUT PVOID  *MapBase
    );

BOOL
MyCreateMappedFileA(
    IN  LPCSTR  FileName,
    IN  ULONG   InitialSize,
    OUT HANDLE *FileHandle,
    OUT PVOID  *MapBase
    );

BOOL
MyCreateMappedFileByHandle(
    IN  HANDLE FileHandle,
    IN  ULONG  InitialSize,
    OUT PVOID *MapBase
    );

VOID
MyUnmapCreatedMappedFile(
    IN HANDLE    FileHandle,
    IN PVOID     MapBase,
    IN ULONG     FileSize,
    IN PFILETIME FileTime OPTIONAL
    );

PVOID
__fastcall
MyVirtualAlloc(
    ULONG Size
    );

VOID
__fastcall
MyVirtualFree(
    PVOID Allocation
    );

HANDLE
CreateSubAllocator(
    IN ULONG InitialCommitSize,
    IN ULONG GrowthCommitSize
    );

PVOID
__fastcall
SubAllocate(
    IN HANDLE hAllocator,
    IN ULONG  Size
    );

VOID
DestroySubAllocator(
    IN HANDLE hAllocator
    );

LPSTR
__fastcall
MySubAllocStrDup(
    IN HANDLE SubAllocator,
    IN LPCSTR String
    );

LPSTR
MySubAllocStrDupAndCat(
    IN HANDLE SubAllocator,
    IN LPCSTR String1,
    IN LPCSTR String2,
    IN CHAR   Separator
    );

PVOID
MyHeapAllocZero(
    IN ULONG Size
    );

VOID
MyHeapFree(
    IN PVOID Allocation
    );

ULONG
HashName(
    IN LPCSTR Name
    );

ULONG
HashNameCaseInsensitive(
    IN LPCSTR Name
    );

VOID
MyLowercase(
    IN OUT LPSTR String
    );

VOID
DwordToHexString(
    IN  DWORD Value,
    OUT LPSTR Buffer    // writes exactly 9 bytes including terminator
    );

BOOL
HashToHexString(
    IN  PMD5_HASH HashValue,
    OUT LPSTR     Buffer        // must be at least 33 bytes
    );

//
//  FILETIME units are 100ns intervals from 01/01/1601.
//
//  ULONG units are seconds from 01/01/1970.
//
//  There are 10,000,000 FILETIME units in one second.
//
//  There are 11,644,473,600 seconds from 01/01/1601 to 01/01/1970.
//

#define FILETIME_UNITS_PER_SECOND      10000000
#define FILETIME_TO_ULONG_OFFSET    11644473600

VOID
__inline
UlongTimeToFileTime(
    IN  ULONG     UlongTime,
    OUT PFILETIME FileTime
    )
    {
    *(UNALIGNED DWORDLONG *)FileTime = ( UlongTime + FILETIME_TO_ULONG_OFFSET ) * FILETIME_UNITS_PER_SECOND;
    }

ULONG
__inline
FileTimeToUlongTime(
    IN PFILETIME FileTime
    )
    {
    return (ULONG)(( *(UNALIGNED DWORDLONG *)FileTime / FILETIME_UNITS_PER_SECOND ) - FILETIME_TO_ULONG_OFFSET );
    }


#ifdef __cplusplus
}
#endif

#endif // _PATCH_MISC_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mspatch\api\patchlzx.h ===
#ifndef _PATCH_LZX_H_
#define _PATCH_LZX_H_

#ifdef __cplusplus
extern "C" {
#endif

//
//  The patch code is using the LZX_MAXWINDOW value to compute
//  progress ranges.  We need a better way to compute progress
//  ranges that doesn't need to know the details of the underlying
//  compression engine.
//

#define LZX_MAXWINDOW_8   (8*1024*1024)  // 8MB
#define LZX_MAXWINDOW_32 (32*1024*1024)  // 32MB

#ifndef PFNALLOC
typedef PVOID ( __fastcall * PFNALLOC )( HANDLE hAllocator, ULONG Size );
#endif

//
//  The PFNALLOC function must return zeroed memory its caller, or NULL to
//  indicate insufficient memory.
//
//  Note that no PFNFREE corresponding to PFNALLOC is specified.  Functions
//  that take a PFNALLOC parameter use that routine for multiple allocations,
//  but it is the responsibility of the caller to free any allocations made
//  through the PFNALLOC allocator after the function has returned.  This
//  scheme is used to facilitate multiple allocations that can be freed with
//  a single call such as a HeapCreate/HeapAlloc[...]/HeapDestroy sequence.
//

ULONG
WINAPI
EstimateLzxCompressionMemoryRequirement(
    IN ULONG OldDataSize,
    IN ULONG NewDataSize,
    IN ULONG OptionFlags
    );

ULONG
WINAPI
EstimateLzxDecompressionMemoryRequirement(
    IN ULONG OldDataSize,
    IN ULONG NewDataSize,
    IN ULONG OptionFlags
    );

ULONG
WINAPI
RawLzxCompressBuffer(
    IN  PVOID    InDataBuffer,
    IN  ULONG    InDataSize,
    IN  ULONG    OutDataBufferSize,
    OUT PVOID    OutDataBuffer OPTIONAL,
    OUT PULONG   OutDataSize,
    IN  PFNALLOC pfnAlloc,
    IN  HANDLE   AllocHandle,
    IN  PPATCH_PROGRESS_CALLBACK ProgressCallback,
    IN  PVOID    CallbackContext,
    IN  ULONG    ProgressInitialValue,
    IN  ULONG    ProgressMaximumValue
    );

ULONG
WINAPI
CreateRawLzxPatchDataFromBuffers(
    IN  PVOID    OldDataBuffer,
    IN  ULONG    OldDataSize,
    IN  PVOID    NewDataBuffer,
    IN  ULONG    NewDataSize,
    IN  ULONG    PatchBufferSize,
    OUT PVOID    PatchBuffer,
    OUT ULONG   *PatchSize,
    IN  ULONG    OptionFlags,
    IN  PVOID    OptionData,
    IN  PFNALLOC pfnAlloc,
    IN  HANDLE   AllocHandle,
    IN  PPATCH_PROGRESS_CALLBACK ProgressCallback,
    IN  PVOID    CallbackContext,
    IN  ULONG    ProgressInitialValue,
    IN  ULONG    ProgressMaximumValue
    );

ULONG
WINAPI
ApplyRawLzxPatchToBuffer(
    IN  PVOID    OldDataBuffer,
    IN  ULONG    OldDataSize,
    IN  PVOID    PatchDataBuffer,
    IN  ULONG    PatchDataSize,
    OUT PVOID    NewDataBuffer,
    IN  ULONG    NewDataSize,
    IN  ULONG    OptionFlags,
    IN  PVOID    OptionData,
    IN  PFNALLOC pfnAlloc,
    IN  HANDLE   AllocHandle,
    IN  PPATCH_PROGRESS_CALLBACK ProgressCallback,
    IN  PVOID    CallbackContext,
    IN  ULONG    ProgressInitialValue,
    IN  ULONG    ProgressMaximumValue
    );

ULONG
__fastcall
LzxWindowSize(
    IN ULONG OldDataSize,
    IN ULONG NewDataSize,
    IN DWORD OptionFlags
    );

ULONG
__fastcall
LzxInsertSize(
    IN ULONG OldDataSize,
    IN DWORD OptionFlags
    );

#ifdef __cplusplus
}
#endif

#endif // _PATCH_LZX_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mspatch\api\patchapi.c ===
#include <precomp.h>

//
//  patchapi.c
//
//  Implementation of PatchAPI for creating and applying patches to files.
//
//  Author: Tom McGuire (tommcg) 2/97 - 9/97
//
//  Copyright (C) Microsoft, 1997-1999.
//
//  MICROSOFT CONFIDENTIAL
//

typedef struct _PATCH_DATA {
    PVOID PatchData;
    ULONG PatchSize;
    } PATCH_DATA, *PPATCH_DATA;

//
//  If we're building a DLL, and it's not the applyer-only DLL, we need to
//  hook DLL_PROCESS_DETACH so we can unload imagehlp.dll if we dynamically
//  load it.  We only need imagehlp.dll if we're creating patches.
//

#ifdef BUILDING_PATCHAPI_DLL
#ifndef PATCH_APPLY_CODE_ONLY

BOOL
WINAPI
DllEntryPoint(
    HANDLE hDll,
    DWORD  Reason,
    PVOID  Reserved     // NULL for dynamic unload, non-NULL for terminating
    )
    {
    if ( Reason == DLL_PROCESS_ATTACH ) {
        DisableThreadLibraryCalls( hDll );
        InitImagehlpCritSect();
        }
    else if (( Reason == DLL_PROCESS_DETACH ) && ( ! Reserved )) {
        UnloadImagehlp();
        }

    return TRUE;
    }

#endif // ! PATCH_APPLY_CODE_ONLY
#endif // BUILDING_PATCHAPI_DLL


BOOL
ProgressCallbackWrapper(
    IN PPATCH_PROGRESS_CALLBACK ProgressCallback,
    IN PVOID                    CallbackContext,
    IN ULONG                    CurrentPosition,
    IN ULONG                    MaximumPosition
    )
    {
    BOOL Success = TRUE;

    if ( ProgressCallback != NULL ) {

        __try {

            Success = ProgressCallback(
                          CallbackContext,
                          CurrentPosition,
                          MaximumPosition
                          );

            if (( ! Success ) && ( GetLastError() == ERROR_SUCCESS )) {
                SetLastError( ERROR_CANCELLED );
                }
            }

        __except( EXCEPTION_EXECUTE_HANDLER ) {
            SetLastError( ERROR_CANCELLED );
            Success = FALSE;
            }
        }

    return Success;
    }


BOOL
WINAPIV
NormalizeOldFileImageForPatching(
    IN PVOID FileMappedImage,
    IN ULONG FileSize,
    IN ULONG OptionFlags,
    IN PVOID OptionData,
    IN ULONG NewFileCoffBase,
    IN ULONG NewFileCoffTime,
    IN ULONG IgnoreRangeCount,
    IN PPATCH_IGNORE_RANGE IgnoreRangeArray,
    IN ULONG RetainRangeCount,
    IN PPATCH_RETAIN_RANGE RetainRangeArray,
    ...
    )
    {
    UP_IMAGE_NT_HEADERS32 NtHeader;
    PUCHAR MappedFile;
    BOOL   Modified;
    BOOL   Success;
    ULONG  i;

    MappedFile = FileMappedImage;
    Modified   = FALSE;
    Success    = TRUE;

    __try {

        NtHeader = GetNtHeader( MappedFile, FileSize );

        if ( NtHeader ) {

            //
            //  This is a coff image.
            //

            Modified = NormalizeCoffImage(
                           NtHeader,
                           MappedFile,
                           FileSize,
                           OptionFlags,
                           OptionData,
                           NewFileCoffBase,
                           NewFileCoffTime
                           );

            }

        else {

            //
            //  Other file type normalizations could be performed here.
            //

            }

#ifdef TESTCODE

        //
        //  The following test-only code creates a file containing
        //  the modified coff image to verify that the coff image
        //  is really a valid coff image.  This is for debugging
        //  only.
        //

        if ( Modified ) {

            HANDLE hFile = CreateFile(
                               "Normalized.out",
                               GENERIC_WRITE,
                               FILE_SHARE_READ,
                               NULL,
                               CREATE_ALWAYS,
                               FILE_ATTRIBUTE_NORMAL,
                               NULL
                               );

            if ( hFile != INVALID_HANDLE_VALUE ) {

                DWORD Actual;

                WriteFile( hFile, MappedFile, FileSize, &Actual, NULL );

                CloseHandle( hFile );

                }
            }

#endif // TESTCODE

        for ( i = 0; i < IgnoreRangeCount; i++ ) {
            if (( IgnoreRangeArray[ i ].OffsetInOldFile + IgnoreRangeArray[ i ].LengthInBytes ) <= FileSize ) {
                ZeroMemory( MappedFile + IgnoreRangeArray[ i ].OffsetInOldFile, IgnoreRangeArray[ i ].LengthInBytes );
                }
            }

        for ( i = 0; i < RetainRangeCount; i++ ) {
            if (( RetainRangeArray[ i ].OffsetInOldFile + RetainRangeArray[ i ].LengthInBytes ) <= FileSize ) {
                ZeroMemory( MappedFile + RetainRangeArray[ i ].OffsetInOldFile, RetainRangeArray[ i ].LengthInBytes );
                }
            }
        }

    __except( EXCEPTION_EXECUTE_HANDLER ) {
        SetLastError( GetExceptionCode() );
        Success = FALSE;
        }

    return Success;
    }


BOOL
PATCHAPI
GetFilePatchSignatureA(
    IN  LPCSTR FileName,
    IN  ULONG  OptionFlags,
    IN  PVOID  OptionData,
    IN  ULONG  IgnoreRangeCount,
    IN  PPATCH_IGNORE_RANGE IgnoreRangeArray,
    IN  ULONG  RetainRangeCount,
    IN  PPATCH_RETAIN_RANGE RetainRangeArray,
    IN  ULONG  SignatureBufferSize,
    OUT PVOID  SignatureBuffer
    )
    {
    BOOL   Success = FALSE;
    HANDLE FileHandle;

    FileHandle = CreateFileA(
                    FileName,
                    GENERIC_READ,
                    FILE_SHARE_READ | FILE_SHARE_WRITE,
                    NULL,
                    OPEN_EXISTING,
                    FILE_FLAG_SEQUENTIAL_SCAN,
                    NULL
                    );

    if ( FileHandle != INVALID_HANDLE_VALUE ) {

        Success = GetFilePatchSignatureByHandle(
                      FileHandle,
                      OptionFlags,
                      OptionData,
                      IgnoreRangeCount,
                      IgnoreRangeArray,
                      RetainRangeCount,
                      RetainRangeArray,
                      SignatureBufferSize,
                      SignatureBuffer
                      );

        CloseHandle( FileHandle );
        }

    return Success;
    }


BOOL
PATCHAPI
GetFilePatchSignatureW(
    IN  LPCWSTR FileName,
    IN  ULONG   OptionFlags,
    IN  PVOID   OptionData,
    IN  ULONG   IgnoreRangeCount,
    IN  PPATCH_IGNORE_RANGE IgnoreRangeArray,
    IN  ULONG   RetainRangeCount,
    IN  PPATCH_RETAIN_RANGE RetainRangeArray,
    IN  ULONG   SignatureBufferSizeInBytes,
    OUT PVOID   SignatureBuffer
    )
    {
    CHAR   AnsiSignatureBuffer[ 40 ];   // big enough for hex MD5 (33 bytes)
    HANDLE FileHandle;
    INT    Converted;
    BOOL   Success = FALSE;

    FileHandle = CreateFileW(
                    FileName,
                    GENERIC_READ,
                    FILE_SHARE_READ | FILE_SHARE_WRITE,
                    NULL,
                    OPEN_EXISTING,
                    FILE_FLAG_SEQUENTIAL_SCAN,
                    NULL
                    );

    if ( FileHandle != INVALID_HANDLE_VALUE ) {

        Success = GetFilePatchSignatureByHandle(
                      FileHandle,
                      OptionFlags,
                      OptionData,
                      IgnoreRangeCount,
                      IgnoreRangeArray,
                      RetainRangeCount,
                      RetainRangeArray,
                      sizeof( AnsiSignatureBuffer ),
                      AnsiSignatureBuffer
                      );

        if ( Success ) {

            //
            //  Worst case growth from ANSI to UNICODE is 2X.
            //

            if (( SignatureBufferSizeInBytes / 2 ) < ( strlen( AnsiSignatureBuffer ) + 1 )) {
                SetLastError( ERROR_INSUFFICIENT_BUFFER );
                Success = FALSE;
                }

            else {

                Converted = MultiByteToWideChar(
                                CP_ACP,
                                MB_PRECOMPOSED,
                                AnsiSignatureBuffer,
                                -1,
                                SignatureBuffer,
                                SignatureBufferSizeInBytes / 2
                                );

                Success = Converted ? TRUE : FALSE;
                }
            }

        CloseHandle( FileHandle );
        }

    return Success;
    }


BOOL
PATCHAPI
GetFilePatchSignatureByHandle(
    IN  HANDLE  FileHandle,
    IN  ULONG   OptionFlags,
    IN  PVOID   OptionData,
    IN  ULONG   IgnoreRangeCount,
    IN  PPATCH_IGNORE_RANGE IgnoreRangeArray,
    IN  ULONG   RetainRangeCount,
    IN  PPATCH_RETAIN_RANGE RetainRangeArray,
    IN  ULONG   SignatureBufferSize,
    OUT PVOID   SignatureBuffer
    )
    {
    PVOID FileMapped;
    ULONG FileSize;
    ULONG FileCrc;
    MD5_HASH FileMD5;
    BOOL  Success;

    Success = MyMapViewOfFileByHandle(
                  FileHandle,
                  &FileSize,
                  &FileMapped
                  );

    if ( Success ) {

        //
        //  Note that we must normalize to a fixed known rebase address,
        //  so the CRC from this might be different than the OldFileCrc
        //  in a patch header that is specific to a new file's rebase
        //  address.  Note that if PATCH_OPTION_NO_REBASE is specified
        //  then the rebase address is ignored.
        //

        Success = NormalizeOldFileImageForPatching(
                      FileMapped,
                      FileSize,
                      OptionFlags,
                      OptionData,
                      0x10000000,           // non-zero fixed coff base
                      0x10000000,           // non-zero fixed coff time
                      IgnoreRangeCount,
                      IgnoreRangeArray,
                      RetainRangeCount,
                      RetainRangeArray
                      );

        if ( Success ) {

            if ( OptionFlags & PATCH_OPTION_SIGNATURE_MD5 ) {

                Success = SafeCompleteMD5(
                            FileMapped,
                            FileSize,
                            &FileMD5
                            );

                if ( Success ) {

                    if ( SignatureBufferSize < 33 ) {
                        SetLastError( ERROR_INSUFFICIENT_BUFFER );
                        Success = FALSE;
                        }

                    else {
                        HashToHexString( &FileMD5, ((LPSTR) SignatureBuffer ));
                        }
                    }
                }

            else {    // signature type is CRC-32

                Success = SafeCompleteCrc32(
                            FileMapped,
                            FileSize,
                            &FileCrc
                            );

                if ( Success ) {

                    if ( SignatureBufferSize < 9 ) {
                        SetLastError( ERROR_INSUFFICIENT_BUFFER );
                        Success = FALSE;
                        }

                    else {
                        DwordToHexString( FileCrc, (LPSTR) SignatureBuffer );
                        }
                    }
                }
            }

        UnmapViewOfFile( FileMapped );
        }

    if (( ! Success ) &&
        ( GetLastError() == ERROR_SUCCESS )) {

        SetLastError( ERROR_EXTENDED_ERROR );
        }

    return Success;
    }


#ifndef PATCH_APPLY_CODE_ONLY

VOID
ReduceRiftTable(
    IN PRIFT_TABLE RiftTable
    )
    {
    PRIFT_ENTRY RiftEntryArray = RiftTable->RiftEntryArray;
    PUCHAR      RiftUsageArray = RiftTable->RiftUsageArray;
    ULONG       RiftEntryCount = RiftTable->RiftEntryCount;
    LONG        CurrentDisplacement;
    LONG        ThisDisplacement;
    ULONG       i;

    //
    //  Essentially we want to remove the usage count from any entry where
    //  the preceding USED entry would produce the same rift displacement.
    //
    //  The first used entry should contain a non-zero displacement (any
    //  USED entries before that should be marked UNUSED because they will
    //  coast from zero).
    //

    CurrentDisplacement = 0;

    for ( i = 0; i < RiftEntryCount; i++ ) {

        if ( RiftUsageArray[ i ] != 0 ) {

            ThisDisplacement = RiftEntryArray[ i ].NewFileRva - RiftEntryArray[ i ].OldFileRva;

            if ( ThisDisplacement == CurrentDisplacement ) {
                RiftUsageArray[ i ] = 0;    // not needed
                }
            else {
                CurrentDisplacement = ThisDisplacement;
                }
            }
        }
    }

#endif // PATCH_APPLY_CODE_ONLY


BOOL
WINAPIV
TransformOldFileImageForPatching(
    IN ULONG TransformOptions,
    IN PVOID OldFileMapped,
    IN ULONG OldFileSize,
    IN ULONG NewFileResTime,
    IN PRIFT_TABLE RiftTable,
    ...
    )
    {
    UP_IMAGE_NT_HEADERS32 NtHeader;
    BOOL Success = TRUE;

    __try {

        NtHeader = GetNtHeader( OldFileMapped, OldFileSize );

        if ( NtHeader ) {

            Success = TransformCoffImage(
                          TransformOptions,
                          NtHeader,
                          OldFileMapped,
                          OldFileSize,
                          NewFileResTime,
                          RiftTable,
                          NULL
                          );
            }

        else {

            //
            //  Other file type transformations could be performed here.
            //

            }

#ifndef PATCH_APPLY_CODE_ONLY

        if ( RiftTable->RiftUsageArray != NULL ) {
            ReduceRiftTable( RiftTable );
            }

#endif // PATCH_APPLY_CODE_ONLY

        }

    __except( EXCEPTION_EXECUTE_HANDLER ) {
        SetLastError( GetExceptionCode() );
        Success = FALSE;
        }

#ifdef TESTCODE

    //
    //  The following test-only code creates a file containing
    //  the modified coff image to verify that the coff image
    //  is really a valid coff image.  This is for debugging
    //  only.
    //

    if ( Success ) {

        HANDLE hFile = CreateFile(
                           "Transformed.out",
                           GENERIC_WRITE,
                           FILE_SHARE_READ,
                           NULL,
                           CREATE_ALWAYS,
                           FILE_ATTRIBUTE_NORMAL,
                           NULL
                           );

        if ( hFile != INVALID_HANDLE_VALUE ) {

            DWORD Actual;

            WriteFile( hFile, OldFileMapped, OldFileSize, &Actual, NULL );

            CloseHandle( hFile );

            }
        }

#endif // TESTCODE

    return Success;
    }


PUCHAR
__fastcall
VariableLengthUnsignedDecode(
    IN  PUCHAR Buffer,
    OUT PULONG ReturnValue
    )
    {
    PUCHAR p = Buffer;
    ULONG Value = 0;
    ULONG Shift = 0;

    do  {
        Value |= (( *p & 0x7F ) << Shift );
        Shift += 7;
        }
    while (( ! ( *p++ & 0x80 )) && ( Shift < 32 ));

    *ReturnValue = Value;

    return p;
    }


PUCHAR
__fastcall
VariableLengthSignedDecode(
    IN  PUCHAR Buffer,
    OUT PLONG  ReturnValue
    )
    {
    PUCHAR p = Buffer;
    ULONG Shift;
    LONG  Value;

    Value = *p & 0x3F;
    Shift = 6;

    if ( ! ( *p++ & 0x80 )) {
        do  {
            Value |= (( *p & 0x7F ) << Shift );
            Shift += 7;
            }
        while (( ! ( *p++ & 0x80 )) && ( Shift < 32 ));
        }

    if ( *Buffer & 0x40 ) {
        Value = -Value;
        }

    *ReturnValue = Value;

    return p;
    }


UCHAR
PatchVersion(
    IN ULONG PatchSignature
    )
    {
    union {
        ULONG Signature;
        UCHAR Byte[ 4 ];
        } u;

    u.Signature = PatchSignature;

    if (( u.Byte[ 0 ] == 'P' ) && ( u.Byte[ 1 ] == 'A' ) &&
        ( u.Byte[ 2 ] >= '0' ) && ( u.Byte[ 2 ] <= '9' ) &&
        ( u.Byte[ 3 ] >= '0' ) && ( u.Byte[ 3 ] <= '9' )) {

        return (UCHAR)(( u.Byte[ 2 ] - '0' ) * 10 + ( u.Byte[ 3 ] - '0' ));
        }

    return 0;
    }


BOOL
DecodePatchHeader(
    IN  PVOID               PatchHeader,
    IN  ULONG               PatchHeaderMaxSize,
    IN  HANDLE              SubAllocator,
    OUT PULONG              PatchHeaderActualSize,
    OUT PPATCH_HEADER_INFO *HeaderInfo
    )
    {
    PHEADER_OLD_FILE_INFO OldFileInfo;
    PPATCH_HEADER_INFO Header;
    ULONG  i, j;
    LONG   Delta;
    LONG   DeltaNew;
    ULONG  DeltaPos;
    ULONG  Length;
    ULONG  PreviousOffset;
    ULONG  PreviousOldRva;
    ULONG  PreviousNewRva;
    BOOL   Success;
    PUCHAR p;

    //
    //  A couple of implementation notes here.  The PatchHeaderMaxSize
    //  value does NOT guarantee that we won't try to read beyond that
    //  memory address in this routine.  This routine should be called
    //  under try/except to trap the case where we walk off the end of
    //  a corrupt patch header.  The PatchHeaderMaxSize is just a helper
    //  value that lets us know if we did have a corrupt header in the
    //  case where we walked too far but not off the end of the page.
    //

    Success = FALSE;

    p = PatchHeader;

    Header = SubAllocate( SubAllocator, sizeof( PATCH_HEADER_INFO ));

    //
    //  SubAllocate provides zeroed memory.
    //

    if ( Header != NULL ) {

        __try {

            Header->Signature = *(UNALIGNED ULONG *)( p );
            p += sizeof( ULONG );

            if ( Header->Signature != PATCH_SIGNATURE ) {
                if ( PatchVersion( Header->Signature ) > PatchVersion( PATCH_SIGNATURE )) {
                    SetLastError( ERROR_PATCH_NEWER_FORMAT );
                    }
                else {
                    SetLastError( ERROR_PATCH_CORRUPT );
                    }
                __leave;
                }

            Header->OptionFlags = *(UNALIGNED ULONG *)( p );
            p += sizeof( ULONG );

            //
            //  The PATCH_OPTION_NO_TIMESTAMP flag is stored inverse for
            //  backward compatibility, so flip it back here.
            //

            Header->OptionFlags ^= PATCH_OPTION_NO_TIMESTAMP;

            //
            //  Now check for invalid flags.
            //

            if ( Header->OptionFlags & ~PATCH_OPTION_VALID_FLAGS ) {
                SetLastError( ERROR_PATCH_CORRUPT );
                __leave;
                }

            //
            //  If the PATCH_OPTION_EXTENDED_OPTIONS flag is set, the next
            //  4 bytes is the ExtendedOptionFlags value.
            //

            if ( Header->OptionFlags & PATCH_OPTION_EXTENDED_OPTIONS ) {

                Header->ExtendedOptionFlags = *(UNALIGNED ULONG *)( p );
                p += sizeof( ULONG );
                }

            //
            //  No stored OptionData defined for now.
            //

            if ( ! ( Header->OptionFlags & PATCH_OPTION_NO_TIMESTAMP )) {

                Header->NewFileTime = *(UNALIGNED ULONG *)( p );
                p += sizeof( ULONG );
                }

            if ( ! ( Header->OptionFlags & PATCH_OPTION_NO_REBASE )) {

                Header->NewFileCoffBase = ((ULONG)*(UNALIGNED USHORT *)( p )) << 16;
                p += sizeof( USHORT );

                ASSERT( Header->NewFileCoffBase != 0 );

                //
                //  If NewFileTime is nonzero, CoffTime is stored as a signed
                //  delta from NewFileTime since they are usually very close.
                //  If NewFileTime is zero, CoffTime is encoded as a ULONG.
                //

                if ( Header->NewFileTime != 0 ) {

                    p = VariableLengthSignedDecode( p, &Delta );
                    Header->NewFileCoffTime = Header->NewFileTime - Delta;
                    }

                else {

                    Header->NewFileCoffTime = *(UNALIGNED ULONG *)( p );
                    p += sizeof( ULONG );
                    }
                }

            if ( ! ( Header->OptionFlags & PATCH_OPTION_NO_RESTIMEFIX )) {

                //
                //  If NewFileCoffTime is nonzero, ResTime is stored as a
                //  signed delta from NewFileCoffTime since they are usually
                //  very close.  If NewFileCoffTime is zero, ResTime is
                //  encoded as a ULONG.
                //

                if ( Header->NewFileCoffTime != 0 ) {

                    p = VariableLengthSignedDecode( p, &Delta );
                    Header->NewFileResTime = Header->NewFileCoffTime - Delta;
                    }

                else {

                    Header->NewFileResTime = *(UNALIGNED ULONG *)( p );
                    p += sizeof( ULONG );
                    }
                }

            p = VariableLengthUnsignedDecode( p, &Header->NewFileSize );

            Header->NewFileCrc = *(UNALIGNED ULONG *)( p );
            p += sizeof( ULONG );

            Header->OldFileCount = *p++;

            Header->OldFileInfoArray = SubAllocate( SubAllocator, Header->OldFileCount * sizeof( HEADER_OLD_FILE_INFO ));

            if ( Header->OldFileInfoArray == NULL ) {
                __leave;
                }

            for ( i = 0; i < Header->OldFileCount; i++ ) {

                OldFileInfo = &Header->OldFileInfoArray[ i ];

                p = VariableLengthSignedDecode( p, &Delta );

                if ((LONG)( Header->NewFileSize + Delta ) < 0 ) {
                    SetLastError( ERROR_PATCH_CORRUPT );
                    __leave;
                    }

                OldFileInfo->OldFileSize = Header->NewFileSize + Delta;

                OldFileInfo->OldFileCrc = *(UNALIGNED ULONG *)( p );
                p += sizeof( ULONG );

                OldFileInfo->IgnoreRangeCount = *p++;

                if ( OldFileInfo->IgnoreRangeCount != 0 ) {

                    OldFileInfo->IgnoreRangeArray = SubAllocate( SubAllocator, OldFileInfo->IgnoreRangeCount * sizeof( PATCH_IGNORE_RANGE ));

                    if ( OldFileInfo->IgnoreRangeArray == NULL ) {
                        __leave;
                        }

                    PreviousOffset = 0;

                    for ( j = 0; j < OldFileInfo->IgnoreRangeCount; j++ ) {

                        p = VariableLengthSignedDecode( p, &Delta );
                        p = VariableLengthUnsignedDecode( p, &Length );

                        OldFileInfo->IgnoreRangeArray[ j ].OffsetInOldFile = PreviousOffset + Delta;
                        OldFileInfo->IgnoreRangeArray[ j ].LengthInBytes = Length;

                        PreviousOffset = PreviousOffset + Delta + Length;

                        if ( PreviousOffset > OldFileInfo->OldFileSize ) {
                            SetLastError( ERROR_PATCH_CORRUPT );
                            __leave;
                            }
                        }
                    }

                OldFileInfo->RetainRangeCount = *p++;

                if ( OldFileInfo->RetainRangeCount != 0 ) {

                    OldFileInfo->RetainRangeArray = SubAllocate( SubAllocator, OldFileInfo->RetainRangeCount * sizeof( PATCH_RETAIN_RANGE ));

                    if ( OldFileInfo->RetainRangeArray == NULL ) {
                        __leave;
                        }

                    PreviousOffset = 0;

                    for ( j = 0; j < OldFileInfo->RetainRangeCount; j++ ) {

                        p = VariableLengthSignedDecode( p, &Delta );
                        p = VariableLengthSignedDecode( p, &DeltaNew );
                        p = VariableLengthUnsignedDecode( p, &Length );

                        OldFileInfo->RetainRangeArray[ j ].OffsetInOldFile = PreviousOffset + Delta;
                        OldFileInfo->RetainRangeArray[ j ].OffsetInNewFile = PreviousOffset + Delta + DeltaNew;
                        OldFileInfo->RetainRangeArray[ j ].LengthInBytes   = Length;

                        PreviousOffset = PreviousOffset + Delta + Length;

                        if (( PreviousOffset > OldFileInfo->OldFileSize ) ||
                            (( PreviousOffset + DeltaNew ) > Header->NewFileSize )) {
                            SetLastError( ERROR_PATCH_CORRUPT );
                            __leave;
                            }
                        }
                    }

                p = VariableLengthUnsignedDecode( p, &OldFileInfo->RiftTable.RiftEntryCount );

                if ( OldFileInfo->RiftTable.RiftEntryCount != 0 ) {

                    OldFileInfo->RiftTable.RiftEntryArray = SubAllocate( SubAllocator, OldFileInfo->RiftTable.RiftEntryCount * sizeof( RIFT_ENTRY ));

                    if ( OldFileInfo->RiftTable.RiftEntryArray == NULL ) {
                        __leave;
                        }

                    OldFileInfo->RiftTable.RiftUsageArray = NULL;

                    PreviousOldRva = 0;
                    PreviousNewRva = 0;

                    for ( j = 0; j < OldFileInfo->RiftTable.RiftEntryCount; j++ ) {

                        p = VariableLengthUnsignedDecode( p, &DeltaPos );
                        p = VariableLengthSignedDecode( p, &DeltaNew );

                        OldFileInfo->RiftTable.RiftEntryArray[ j ].OldFileRva = PreviousOldRva + DeltaPos;
                        OldFileInfo->RiftTable.RiftEntryArray[ j ].NewFileRva = PreviousNewRva + DeltaNew;

                        PreviousOldRva += DeltaPos;
                        PreviousNewRva += DeltaNew;
                        }
                    }

                p = VariableLengthUnsignedDecode( p, &OldFileInfo->PatchDataSize );
                }

            if ( p > ((PUCHAR)PatchHeader + PatchHeaderMaxSize )) {
                SetLastError( ERROR_PATCH_CORRUPT );
                __leave;
                }

            Success = TRUE;
            }

        __except( EXCEPTION_EXECUTE_HANDLER ) {
            SetLastError( ERROR_PATCH_CORRUPT );
            Success = FALSE;
            }
        }

    if ( Success ) {

        if ( PatchHeaderActualSize ) {
            *PatchHeaderActualSize = (ULONG)( p - (PUCHAR)PatchHeader );
            }

        if ( HeaderInfo ) {
            *HeaderInfo = Header;
            }
        }

    return Success;
    }


//
//  Following group of functions and exported apis are exclusively for
//  creating patches.  If we're only compiling the apply code, ignore
//  this group of functions.
//

#ifndef PATCH_APPLY_CODE_ONLY

PUCHAR
__fastcall
VariableLengthUnsignedEncode(
    OUT PUCHAR Buffer,
    IN  ULONG  Value
    )
    {
    UCHAR Byte = (UCHAR)( Value & 0x7F );       // low order 7 bits

    Value >>= 7;

    while ( Value ) {

        *Buffer++ = Byte;

        Byte = (UCHAR)( Value & 0x7F );         // next 7 higher order bits

        Value >>= 7;

        }

    *Buffer++ = (UCHAR)( Byte | 0x80 );

    return Buffer;
    }


PUCHAR
__fastcall
VariableLengthSignedEncode(
    OUT PUCHAR Buffer,
    IN  LONG   Value
    )
    {
    UCHAR Byte;

    if ( Value < 0 ) {
        Value = -Value;
        Byte = (UCHAR)(( Value & 0x3F ) | 0x40 );
        }
    else {
        Byte = (UCHAR)( Value & 0x3F );
        }

    Value >>= 6;

    while ( Value ) {

        *Buffer++ = Byte;

        Byte = (UCHAR)( Value & 0x7F );         // next 7 higher order bits

        Value >>= 7;

        }

    *Buffer++ = (UCHAR)( Byte | 0x80 );

    return Buffer;
    }


ULONG
EncodePatchHeader(
    IN  PPATCH_HEADER_INFO HeaderInfo,
    OUT PVOID              PatchHeaderBuffer
    )
    {
    PHEADER_OLD_FILE_INFO OldFileInfo;
    ULONG  i, j;
    LONG   Delta;
    ULONG  PreviousOffset;
    ULONG  PreviousOldRva;
    ULONG  PreviousNewRva;
    ULONG  ActiveRiftCount;

    PUCHAR p = PatchHeaderBuffer;

#ifdef TESTCODE
    PUCHAR q;
#endif // TESTCODE

    ASSERT( HeaderInfo->Signature == PATCH_SIGNATURE );
    ASSERT((( HeaderInfo->OptionFlags & ~PATCH_OPTION_VALID_FLAGS      ) == 0 ));
    ASSERT((( HeaderInfo->OptionFlags &  PATCH_OPTION_EXTENDED_OPTIONS ) != 0 ) == ( HeaderInfo->ExtendedOptionFlags != 0 ));
    ASSERT((( HeaderInfo->OptionFlags &  PATCH_OPTION_NO_TIMESTAMP     ) == 0 ) == ( HeaderInfo->NewFileTime         != 0 ));
    ASSERT((( HeaderInfo->OptionFlags &  PATCH_OPTION_NO_REBASE        ) == 0 ) == ( HeaderInfo->NewFileCoffBase     != 0 ));
    ASSERT((( HeaderInfo->OptionFlags &  PATCH_OPTION_NO_REBASE        ) == 0 ) == ( HeaderInfo->NewFileCoffTime     != 0 ));
    ASSERT((( HeaderInfo->OptionFlags &  PATCH_OPTION_NO_RESTIMEFIX    ) == 0 ) == ( HeaderInfo->NewFileResTime      != 0 ));

    *(UNALIGNED ULONG *)( p ) = HeaderInfo->Signature;
    p += sizeof( ULONG );

    //
    //  The PATCH_OPTION_NO_TIMESTAMP flag is stored inverse for
    //  backward compatibility, so flip it when storing it here.
    //

    *(UNALIGNED ULONG *)( p ) = ( HeaderInfo->OptionFlags ^ PATCH_OPTION_NO_TIMESTAMP );
    p += sizeof( ULONG );

    //
    //  If the PATCH_OPTION_EXTENDED_OPTIONS flag is set, the next
    //  4 bytes is the ExtendedOptionFlags value.
    //

    if ( HeaderInfo->OptionFlags & PATCH_OPTION_EXTENDED_OPTIONS ) {

        *(UNALIGNED ULONG *)( p ) = HeaderInfo->ExtendedOptionFlags;
        p += sizeof( ULONG );
        }

    //
    //  No stored OptionData defined for now.
    //

    if ( ! ( HeaderInfo->OptionFlags & PATCH_OPTION_NO_TIMESTAMP )) {

        *(UNALIGNED ULONG *)( p ) = HeaderInfo->NewFileTime;
        p += sizeof( ULONG );
        }

    if ( ! ( HeaderInfo->OptionFlags & PATCH_OPTION_NO_REBASE )) {

        ASSERT(( HeaderInfo->NewFileCoffBase >> 16 ) != 0 );

        *(UNALIGNED USHORT *)( p ) = (USHORT)( HeaderInfo->NewFileCoffBase >> 16 );
        p += sizeof( USHORT );

        //
        //  If NewFileTime is nonzero, CoffTime is stored as a signed
        //  delta from NewFileTime since they are usually very close.
        //  If NewFileTime is zero, CoffTime is encoded as a ULONG.
        //

        if ( HeaderInfo->NewFileTime != 0 ) {

            Delta = HeaderInfo->NewFileTime - HeaderInfo->NewFileCoffTime;
            p = VariableLengthSignedEncode( p, Delta );
            }

        else {

            *(UNALIGNED ULONG *)( p ) = HeaderInfo->NewFileCoffTime;
            p += sizeof( ULONG );
            }
        }

    if ( ! ( HeaderInfo->OptionFlags & PATCH_OPTION_NO_RESTIMEFIX )) {

        //
        //  If NewFileCoffTime is nonzero, ResTime is stored as a
        //  signed delta from NewFileCoffTime since they are usually
        //  very close.  If NewFileCoffTime is zero, ResTime is
        //  encoded as a ULONG.
        //

        if ( HeaderInfo->NewFileCoffTime != 0 ) {

            Delta = HeaderInfo->NewFileCoffTime - HeaderInfo->NewFileResTime;
            p = VariableLengthSignedEncode( p, Delta );
            }

        else {

            *(UNALIGNED ULONG *)( p ) = HeaderInfo->NewFileResTime;
            p += sizeof( ULONG );
            }
        }

    p = VariableLengthUnsignedEncode( p, HeaderInfo->NewFileSize );

    *(UNALIGNED ULONG *)( p ) = HeaderInfo->NewFileCrc;
    p += sizeof( ULONG );

    ASSERT( HeaderInfo->OldFileCount < 256 );

    *p++ = (UCHAR)( HeaderInfo->OldFileCount );

    for ( i = 0; i < HeaderInfo->OldFileCount; i++ ) {

        OldFileInfo = &HeaderInfo->OldFileInfoArray[ i ];

        Delta = OldFileInfo->OldFileSize - HeaderInfo->NewFileSize;
        p = VariableLengthSignedEncode( p, Delta );

        *(UNALIGNED ULONG *)( p ) = OldFileInfo->OldFileCrc;
        p += sizeof( ULONG );

        ASSERT( OldFileInfo->IgnoreRangeCount < 256 );

        *p++ = (UCHAR)( OldFileInfo->IgnoreRangeCount );

        PreviousOffset = 0;

        for ( j = 0; j < OldFileInfo->IgnoreRangeCount; j++ ) {

            Delta = OldFileInfo->IgnoreRangeArray[ j ].OffsetInOldFile - PreviousOffset;

            PreviousOffset = OldFileInfo->IgnoreRangeArray[ j ].OffsetInOldFile +
                             OldFileInfo->IgnoreRangeArray[ j ].LengthInBytes;

            ASSERT( PreviousOffset <= OldFileInfo->OldFileSize );

            p = VariableLengthSignedEncode( p, Delta );

            p = VariableLengthUnsignedEncode( p, OldFileInfo->IgnoreRangeArray[ j ].LengthInBytes );
            }

        ASSERT( OldFileInfo->RetainRangeCount < 256 );

        *p++ = (UCHAR)( OldFileInfo->RetainRangeCount );

        PreviousOffset = 0;

        for ( j = 0; j < OldFileInfo->RetainRangeCount; j++ ) {

            Delta = OldFileInfo->RetainRangeArray[ j ].OffsetInOldFile - PreviousOffset;

            PreviousOffset = OldFileInfo->RetainRangeArray[ j ].OffsetInOldFile +
                             OldFileInfo->RetainRangeArray[ j ].LengthInBytes;

            ASSERT( PreviousOffset <= OldFileInfo->OldFileSize );

            p = VariableLengthSignedEncode( p, Delta );

            Delta = OldFileInfo->RetainRangeArray[ j ].OffsetInNewFile -
                    OldFileInfo->RetainRangeArray[ j ].OffsetInOldFile;

            p = VariableLengthSignedEncode( p, Delta );

            p = VariableLengthUnsignedEncode( p, OldFileInfo->RetainRangeArray[ j ].LengthInBytes );
            }

        ActiveRiftCount = 0;

        ASSERT(( OldFileInfo->RiftTable.RiftEntryCount == 0 ) || ( OldFileInfo->RiftTable.RiftUsageArray != NULL ));

        for ( j = 0; j < OldFileInfo->RiftTable.RiftEntryCount; j++ ) {
            if ( OldFileInfo->RiftTable.RiftUsageArray[ j ] ) {
                ++ActiveRiftCount;
                }
            }

#ifdef TESTCODE2

        fprintf( stderr, "\n\n" );

#endif // TESTCODE2

#ifdef TESTCODE

        q = p;

#endif // TESTCODE

        if (( OldFileInfo->RiftTable.RiftEntryCount ) && ( ActiveRiftCount == 0 )) {

            //
            //  This is a special case.  We have a rift table but didn't use
            //  any entries during transformation.  This can happen if all the
            //  rifts coast to zero for extremely similar files.  If we encode
            //  the rift count as zero, no transformations will be performed
            //  during patch apply.  To prevent that, we'll encode one rift of
            //  0,0 which is usually just the implied initial rift.
            //

            ActiveRiftCount = 1;

            p = VariableLengthUnsignedEncode( p, ActiveRiftCount );
            p = VariableLengthUnsignedEncode( p, 0 );
            p = VariableLengthSignedEncode(   p, 0 );

            }

        else {

            p = VariableLengthUnsignedEncode( p, ActiveRiftCount );

            PreviousOldRva = 0;
            PreviousNewRva = 0;

            for ( j = 0; j < OldFileInfo->RiftTable.RiftEntryCount; j++ ) {

                if ( OldFileInfo->RiftTable.RiftUsageArray[ j ] ) {

#ifdef TESTCODE2
                    fprintf( stderr, "%9X ", OldFileInfo->RiftTable.RiftEntryArray[ j ].OldFileRva );
                    fprintf( stderr, "%9X ", OldFileInfo->RiftTable.RiftEntryArray[ j ].NewFileRva );
#endif // TESTCODE2

                    Delta = OldFileInfo->RiftTable.RiftEntryArray[ j ].OldFileRva - PreviousOldRva;

                    ASSERT( Delta > 0 );    // sorted by OldFileRva

#ifdef TESTCODE2
                    fprintf( stderr, "%9d ", Delta );

#endif // TESTCODE2

                    PreviousOldRva = OldFileInfo->RiftTable.RiftEntryArray[ j ].OldFileRva;

                    p = VariableLengthUnsignedEncode( p, Delta );

                    Delta = OldFileInfo->RiftTable.RiftEntryArray[ j ].NewFileRva - PreviousNewRva;

#ifdef TESTCODE2
                    fprintf( stderr, "%9d\n", Delta );
#endif // TESTCODE2

                    PreviousNewRva = OldFileInfo->RiftTable.RiftEntryArray[ j ].NewFileRva;

                    p = VariableLengthSignedEncode( p, Delta );
                    }
                }
            }

#ifdef TESTCODE

        if ( ActiveRiftCount > 0 ) {
            printf( "\r%9d rifts encoded in %d bytes (%.1f bytes per rift)\n", ActiveRiftCount, p - q, ((double)( p - q ) / ActiveRiftCount ));
            }

#endif // TESTCODE

        p = VariableLengthUnsignedEncode( p, OldFileInfo->PatchDataSize );
        }

    return (ULONG)( p - (PUCHAR) PatchHeaderBuffer );
    }


BOOL
PATCHAPI
CreatePatchFileA(
    IN  LPCSTR OldFileName,
    IN  LPCSTR NewFileName,
    OUT LPCSTR PatchFileName,
    IN  ULONG  OptionFlags,
    IN  PPATCH_OPTION_DATA OptionData   // optional
    )
    {
    PATCH_OLD_FILE_INFO_A OldFileInfo = {
                              sizeof( PATCH_OLD_FILE_INFO_A ),
                              OldFileName,
                              0,
                              NULL,
                              0,
                              NULL
                              };

    return CreatePatchFileExA(
               1,
               &OldFileInfo,
               NewFileName,
               PatchFileName,
               OptionFlags,
               OptionData,
               NULL,
               NULL
               );
    }


BOOL
PATCHAPI
CreatePatchFileW(
    IN  LPCWSTR OldFileName,
    IN  LPCWSTR NewFileName,
    OUT LPCWSTR PatchFileName,
    IN  ULONG   OptionFlags,
    IN  PPATCH_OPTION_DATA OptionData   // optional
    )
    {
    PATCH_OLD_FILE_INFO_W OldFileInfo = {
                              sizeof( PATCH_OLD_FILE_INFO_W ),
                              OldFileName,
                              0,
                              NULL,
                              0,
                              NULL
                              };

    return CreatePatchFileExW(
               1,
               &OldFileInfo,
               NewFileName,
               PatchFileName,
               OptionFlags,
               OptionData,
               NULL,
               NULL
               );
    }


BOOL
PATCHAPI
CreatePatchFileByHandles(
    IN  HANDLE OldFileHandle,
    IN  HANDLE NewFileHandle,
    OUT HANDLE PatchFileHandle,
    IN  ULONG  OptionFlags,
    IN  PPATCH_OPTION_DATA OptionData   // optional
    )
    {
    PATCH_OLD_FILE_INFO_H OldFileInfo = {
                              sizeof( PATCH_OLD_FILE_INFO_H ),
                              OldFileHandle,
                              0,
                              NULL,
                              0,
                              NULL
                              };

    return CreatePatchFileByHandlesEx(
               1,
               &OldFileInfo,
               NewFileHandle,
               PatchFileHandle,
               OptionFlags,
               OptionData,
               NULL,
               NULL
               );
    }


BOOL
PATCHAPI
CreatePatchFileExA(
    IN  ULONG                    OldFileCount,
    IN  PPATCH_OLD_FILE_INFO_A   OldFileInfoArray,
    IN  LPCSTR                   NewFileName,
    OUT LPCSTR                   PatchFileName,
    IN  ULONG                    OptionFlags,
    IN  PPATCH_OPTION_DATA       OptionData,            // optional
    IN  PPATCH_PROGRESS_CALLBACK ProgressCallback,
    IN  PVOID                    CallbackContext
    )
    {
    PPATCH_OLD_FILE_INFO_H OldFileInfoByHandle = NULL;
    HANDLE PatchFileHandle;
    HANDLE NewFileHandle;
    BOOL   Success;
    ULONG  i;

    if ( OldFileCount == 0 ) {
        SetLastError( ERROR_INVALID_PARAMETER );
        return FALSE;
    }

    OldFileInfoByHandle = HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, OldFileCount * sizeof(PATCH_OLD_FILE_INFO_H));
    if (!OldFileInfoByHandle) {
        SetLastError(ERROR_OUTOFMEMORY);
        return FALSE;
    }

    Success = TRUE;

    for ( i = 0; i < OldFileCount; i++ ) {

        OldFileInfoByHandle[ i ].SizeOfThisStruct = sizeof( PATCH_OLD_FILE_INFO_H );
        OldFileInfoByHandle[ i ].IgnoreRangeCount = OldFileInfoArray[ i ].IgnoreRangeCount;
        OldFileInfoByHandle[ i ].IgnoreRangeArray = OldFileInfoArray[ i ].IgnoreRangeArray;
        OldFileInfoByHandle[ i ].RetainRangeCount = OldFileInfoArray[ i ].RetainRangeCount;
        OldFileInfoByHandle[ i ].RetainRangeArray = OldFileInfoArray[ i ].RetainRangeArray;

        OldFileInfoByHandle[ i ].OldFileHandle = CreateFileA(
                                                     OldFileInfoArray[ i ].OldFileName,
                                                     GENERIC_READ,
                                                     FILE_SHARE_READ | FILE_SHARE_WRITE,
                                                     NULL,
                                                     OPEN_EXISTING,
                                                     FILE_FLAG_SEQUENTIAL_SCAN,
                                                     NULL
                                                     );

        if ( OldFileInfoByHandle[ i ].OldFileHandle == INVALID_HANDLE_VALUE ) {
            Success = FALSE;
            break;
            }
        }

    if ( Success ) {

        Success = FALSE;

        NewFileHandle = CreateFileA(
                            NewFileName,
                            GENERIC_READ,
                            FILE_SHARE_READ | FILE_SHARE_WRITE,
                            NULL,
                            OPEN_EXISTING,
                            FILE_FLAG_SEQUENTIAL_SCAN,
                            NULL
                            );

        if ( NewFileHandle != INVALID_HANDLE_VALUE ) {

            PatchFileHandle = CreateFileA(
                                  PatchFileName,
                                  GENERIC_READ | GENERIC_WRITE,
                                  FILE_SHARE_READ,
                                  NULL,
                                  CREATE_ALWAYS,
                                  FILE_ATTRIBUTE_NORMAL,
                                  NULL
                                  );

            if ( PatchFileHandle != INVALID_HANDLE_VALUE ) {

                Success = CreatePatchFileByHandlesEx(
                              OldFileCount,
                              OldFileInfoByHandle,
                              NewFileHandle,
                              PatchFileHandle,
                              OptionFlags,
                              OptionData,
                              ProgressCallback,
                              CallbackContext
                              );

                CloseHandle( PatchFileHandle );

                if ( ! Success ) {
                    DeleteFileA( PatchFileName );
                    }
                }

            CloseHandle( NewFileHandle );
            }
        }

    for ( i = 0; i < OldFileCount; i++ ) {
        if (( OldFileInfoByHandle[ i ].OldFileHandle != NULL ) &&
            ( OldFileInfoByHandle[ i ].OldFileHandle != INVALID_HANDLE_VALUE )) {

            CloseHandle( OldFileInfoByHandle[ i ].OldFileHandle );
            }
        }

    HeapFree(GetProcessHeap(), 0, OldFileInfoByHandle);

    return Success;
    }


BOOL
PATCHAPI
CreatePatchFileExW(
    IN  ULONG                    OldFileCount,
    IN  PPATCH_OLD_FILE_INFO_W   OldFileInfoArray,
    IN  LPCWSTR                  NewFileName,
    OUT LPCWSTR                  PatchFileName,
    IN  ULONG                    OptionFlags,
    IN  PPATCH_OPTION_DATA       OptionData,            // optional
    IN  PPATCH_PROGRESS_CALLBACK ProgressCallback,
    IN  PVOID                    CallbackContext
    )
    {
    PPATCH_OLD_FILE_INFO_H OldFileInfoByHandle = NULL;
    HANDLE PatchFileHandle;
    HANDLE NewFileHandle;
    BOOL   Success;
    ULONG  i;

    if ( OldFileCount == 0 ) {
        SetLastError( ERROR_INVALID_PARAMETER );
        return FALSE;
    }

    OldFileInfoByHandle = HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, OldFileCount * sizeof(PATCH_OLD_FILE_INFO_H));
    if (!OldFileInfoByHandle) {
        SetLastError(ERROR_OUTOFMEMORY);
        return FALSE;
    }

    Success = TRUE;

    for ( i = 0; i < OldFileCount; i++ ) {

        OldFileInfoByHandle[ i ].SizeOfThisStruct = sizeof( PATCH_OLD_FILE_INFO_H );
        OldFileInfoByHandle[ i ].IgnoreRangeCount = OldFileInfoArray[ i ].IgnoreRangeCount;
        OldFileInfoByHandle[ i ].IgnoreRangeArray = OldFileInfoArray[ i ].IgnoreRangeArray;
        OldFileInfoByHandle[ i ].RetainRangeCount = OldFileInfoArray[ i ].RetainRangeCount;
        OldFileInfoByHandle[ i ].RetainRangeArray = OldFileInfoArray[ i ].RetainRangeArray;

        OldFileInfoByHandle[ i ].OldFileHandle = CreateFileW(
                                                     OldFileInfoArray[ i ].OldFileName,
                                                     GENERIC_READ,
                                                     FILE_SHARE_READ | FILE_SHARE_WRITE,
                                                     NULL,
                                                     OPEN_EXISTING,
                                                     FILE_FLAG_SEQUENTIAL_SCAN,
                                                     NULL
                                                     );

        if ( OldFileInfoByHandle[ i ].OldFileHandle == INVALID_HANDLE_VALUE ) {
            Success = FALSE;
            break;
            }
        }

    if ( Success ) {

        Success = FALSE;

        NewFileHandle = CreateFileW(
                            NewFileName,
                            GENERIC_READ,
                            FILE_SHARE_READ | FILE_SHARE_WRITE,
                            NULL,
                            OPEN_EXISTING,
                            FILE_FLAG_SEQUENTIAL_SCAN,
                            NULL
                            );

        if ( NewFileHandle != INVALID_HANDLE_VALUE ) {

            PatchFileHandle = CreateFileW(
                                  PatchFileName,
                                  GENERIC_READ | GENERIC_WRITE,
                                  FILE_SHARE_READ,
                                  NULL,
                                  CREATE_ALWAYS,
                                  FILE_ATTRIBUTE_NORMAL,
                                  NULL
                                  );

            if ( PatchFileHandle != INVALID_HANDLE_VALUE ) {

                Success = CreatePatchFileByHandlesEx(
                              OldFileCount,
                              OldFileInfoByHandle,
                              NewFileHandle,
                              PatchFileHandle,
                              OptionFlags,
                              OptionData,
                              ProgressCallback,
                              CallbackContext
                              );

                CloseHandle( PatchFileHandle );

                if ( ! Success ) {
                    DeleteFileW( PatchFileName );
                    }
                }

            CloseHandle( NewFileHandle );
            }
        }

    for ( i = 0; i < OldFileCount; i++ ) {
        if (( OldFileInfoByHandle[ i ].OldFileHandle != NULL ) &&
            ( OldFileInfoByHandle[ i ].OldFileHandle != INVALID_HANDLE_VALUE )) {

            CloseHandle( OldFileInfoByHandle[ i ].OldFileHandle );
            }
        }

    HeapFree(GetProcessHeap(), 0, OldFileInfoByHandle);

    return Success;
    }


BOOL
PATCHAPI
CreatePatchFileByHandlesEx(
    IN  ULONG                    OldFileCount,
    IN  PPATCH_OLD_FILE_INFO_H   OldFileInfoArray,
    IN  HANDLE                   NewFileHandle,
    OUT HANDLE                   PatchFileHandle,
    IN  ULONG                    OptionFlags,
    IN  PPATCH_OPTION_DATA       OptionData,            // optional
    IN  PPATCH_PROGRESS_CALLBACK ProgressCallback,
    IN  PVOID                    CallbackContext
    )
    {
    PATCH_HEADER_INFO HeaderInfo;
    UP_IMAGE_NT_HEADERS32 NtHeader;
    UP_IMAGE_NT_HEADERS32 OldFileNtHeader;
    PPATCH_DATA PatchArray;
    PFILETIME PatchFileTime;
    FILETIME NewFileTime;
    PUCHAR   NewFileMapped;
    ULONG    NewFileSize;
    ULONG    NewFileCrc;
    ULONG    NewFileCoffBase;
    ULONG    NewFileCoffTime;
    ULONG    NewFileResTime;
    ULONG    NewFileCompressedSize;
    PUCHAR   OldFileMapped;
    ULONG    OldFileSize;
    ULONG    OldFileCrc;
    PUCHAR   PatchFileMapped;
    PUCHAR   PatchBuffer;
    ULONG    PatchBufferSize;
    PUCHAR   PatchAltBuffer;
    ULONG    PatchAltSize;
    ULONG    PatchDataSize;
    ULONG    PatchFileCrc;
    ULONG    HeaderSize;
    ULONG    HeaderOldFileCount;
    ULONG    ProgressPosition;
    ULONG    ProgressMaximum;
    ULONG    ErrorCode;
    BOOL     TryLzxBoth;
    BOOL     Success;
    BOOL     Transform;
    HANDLE   SubAllocatorHandle;
    ULONG    EstimatedLzxMemory;
    ULONG    ExtendedOptionFlags;
    ULONG    AltExtendedOptionFlags;
    ULONG    OldFileOriginalChecksum;
    ULONG    OldFileOriginalTimeDate;
    ULONG    i, j;
    PUCHAR   p;
    ULONG    LargestOldFileSize = 0;

    if (( OldFileCount == 0 ) || ( OldFileCount > 127 )) {
        SetLastError( ERROR_INVALID_PARAMETER );
        return FALSE;
        }

    if ( OptionFlags & PATCH_OPTION_SIGNATURE_MD5 ) {
        SetLastError( ERROR_INVALID_PARAMETER );
        return FALSE;
        }

    HeaderInfo.OldFileInfoArray = HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, OldFileCount * sizeof( HEADER_OLD_FILE_INFO ));
    if (!HeaderInfo.OldFileInfoArray) {
        SetLastError(ERROR_OUTOFMEMORY);
        return FALSE;
    }

    PatchArray = HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, OldFileCount * sizeof( PATCH_DATA ));
    if (!PatchArray) {
        HeapFree(GetProcessHeap(), 0, HeaderInfo.OldFileInfoArray);
        SetLastError(ERROR_OUTOFMEMORY);
        return FALSE;
    }

    if (( OptionFlags & 0x0000FFFF ) == PATCH_OPTION_USE_BEST ) {
        OptionFlags |= PATCH_OPTION_USE_LZX_BEST;
        }

    for ( i = 1; i < OldFileCount; i++ ) {
        if ( OldFileInfoArray[ i ].RetainRangeCount != OldFileInfoArray[ 0 ].RetainRangeCount ) {
            HeapFree(GetProcessHeap(), 0, PatchArray);
            HeapFree(GetProcessHeap(), 0, HeaderInfo.OldFileInfoArray);
            SetLastError( ERROR_PATCH_RETAIN_RANGES_DIFFER );
            return FALSE;
            }

        for ( j = 0; j < OldFileInfoArray[ 0 ].RetainRangeCount; j++ ) {
            if (( OldFileInfoArray[ i ].RetainRangeArray[ j ].OffsetInNewFile !=
                  OldFileInfoArray[ 0 ].RetainRangeArray[ j ].OffsetInNewFile ) ||
                ( OldFileInfoArray[ i ].RetainRangeArray[ j ].LengthInBytes !=
                  OldFileInfoArray[ 0 ].RetainRangeArray[ j ].LengthInBytes )) {

                HeapFree(GetProcessHeap(), 0, PatchArray);
                HeapFree(GetProcessHeap(), 0, HeaderInfo.OldFileInfoArray);
                SetLastError( ERROR_PATCH_RETAIN_RANGES_DIFFER );
                return FALSE;
                }
            }
        }

    ExtendedOptionFlags = 0;

    if (( OptionData ) && ( OptionData->SizeOfThisStruct >= sizeof( PATCH_OPTION_DATA ))) {
        ExtendedOptionFlags = OptionData->ExtendedOptionFlags;
        }

    Success = MyMapViewOfFileByHandle(
                  NewFileHandle,
                  &NewFileSize,
                  &NewFileMapped
                  );

    if ( ! Success ) {

        if ( GetLastError() == ERROR_SUCCESS ) {

            SetLastError( ERROR_EXTENDED_ERROR );
            }

        HeapFree(GetProcessHeap(), 0, PatchArray);
        HeapFree(GetProcessHeap(), 0, HeaderInfo.OldFileInfoArray);
        return FALSE;
        }

    GetFileTime( NewFileHandle, NULL, NULL, &NewFileTime );
    PatchFileTime = &NewFileTime;

    NewFileCoffBase    = 0;
    NewFileCoffTime    = 0;
    NewFileResTime     = 0;
    HeaderOldFileCount = 0;
    HeaderSize         = 0;
    NewFileCrc         = 0;     // prevent compiler warning

    ProgressPosition   = 0;
    ProgressMaximum    = 0;     // prevent compiler warning

    __try {

        NtHeader = GetNtHeader( NewFileMapped, NewFileSize );

        if ( ! ( OptionFlags & PATCH_OPTION_NO_REBASE )) {
            if ( NtHeader ) {
                NewFileCoffTime = NtHeader->FileHeader.TimeDateStamp;
                NewFileCoffBase = NtHeader->OptionalHeader.ImageBase;
                }
            else {
                OptionFlags |= PATCH_OPTION_NO_REBASE;
                }
            }

        if (( NtHeader ) && ( NtHeader->OptionalHeader.CheckSum == 0 )) {
            OptionFlags |= PATCH_OPTION_NO_CHECKSUM;
            }

        if ( ! ( OptionFlags & PATCH_OPTION_NO_RESTIMEFIX )) {

            if ( NtHeader ) {

                UP_IMAGE_RESOURCE_DIRECTORY ResDir;

                ResDir = ImageDirectoryMappedAddress(
                             NtHeader,
                             IMAGE_DIRECTORY_ENTRY_RESOURCE,
                             NULL,
                             NewFileMapped,
                             NewFileSize
                             );

                if ( ResDir ) {
                    NewFileResTime = ResDir->TimeDateStamp;
                    }
                }

            if ( NewFileResTime == 0 ) {
                OptionFlags |= PATCH_OPTION_NO_RESTIMEFIX;
                }
            }

        TryLzxBoth = FALSE;

        if (( OptionFlags & PATCH_OPTION_USE_LZX_BEST ) == PATCH_OPTION_USE_LZX_BEST ) {

            OptionFlags &= ~PATCH_OPTION_USE_LZX_B;     //  No E8 translation on first try.

            if ((( ! NtHeader ) && ( *(UNALIGNED USHORT *)NewFileMapped == 0x5A4D )) ||             // MZ, not PE
                (( NtHeader ) && ( NtHeader->FileHeader.Machine == IMAGE_FILE_MACHINE_I386 ))) {    // PE, i386

                TryLzxBoth = TRUE;  //  Will force E8 translation on second try.
                }
            }

        else if (( OptionFlags & PATCH_OPTION_USE_LZX_BEST ) == PATCH_OPTION_USE_LZX_B ) {

            //
            //  Caller is requesting forced E8 translation, so disable E8
            //  transformation.
            //

            if (( NtHeader ) && ( NtHeader->FileHeader.Machine == IMAGE_FILE_MACHINE_I386 )) {    // PE, i386
                ExtendedOptionFlags |= PATCH_TRANSFORM_NO_RELCALLS;
                }
            }

        ProgressMaximum = NewFileSize * OldFileCount;

        for ( i = 0; i < OldFileCount; i++ ) {
            OldFileSize = GetFileSize( OldFileInfoArray[ i ].OldFileHandle, NULL );

            if ( LargestOldFileSize < OldFileSize ) {
                LargestOldFileSize = OldFileSize;
                }

            ProgressMaximum += LzxInsertSize( OldFileSize, OptionFlags );
            }

        if ( TryLzxBoth ) {
            ProgressMaximum *= 2;
            }

        if ( OptionFlags & PATCH_OPTION_FAIL_IF_BIGGER ) {
            ProgressMaximum += NewFileSize;
            }

        Success = ProgressCallbackWrapper(
                      ProgressCallback,
                      CallbackContext,
                      0,
                      ProgressMaximum
                      );

        if ( ! Success ) {
            __leave;
            }

        for ( j = 0; j < OldFileInfoArray[ 0 ].RetainRangeCount; j++ ) {
            ZeroMemory(
                OldFileInfoArray[ 0 ].RetainRangeArray[ j ].OffsetInNewFile + NewFileMapped,
                OldFileInfoArray[ 0 ].RetainRangeArray[ j ].LengthInBytes
                );
            }

        NewFileCrc = Crc32( 0xFFFFFFFF, NewFileMapped, NewFileSize ) ^ 0xFFFFFFFF;

        PatchBufferSize = ROUNDUP2( NewFileSize + ( NewFileSize / 256 ), 0x10000 );

        Success = FALSE;

        for ( i = 0; i < OldFileCount; i++ ) {

            Success = MyMapViewOfFileByHandle(
                          OldFileInfoArray[ i ].OldFileHandle,
                          &OldFileSize,
                          &OldFileMapped
                          );

            if ( ! Success ) {
                break;
                }

            OldFileOriginalChecksum = 0;
            OldFileOriginalTimeDate = 0;
            OldFileNtHeader = NULL;

            __try {

                OldFileNtHeader = GetNtHeader( OldFileMapped, OldFileSize );

                if ( OldFileNtHeader ) {

                    OldFileOriginalChecksum = OldFileNtHeader->OptionalHeader.CheckSum;
                    OldFileOriginalTimeDate = OldFileNtHeader->FileHeader.TimeDateStamp;
                    }
                }

            __except( EXCEPTION_EXECUTE_HANDLER ) {
                }

            Success = NormalizeOldFileImageForPatching(
                          OldFileMapped,
                          OldFileSize,
                          OptionFlags,
                          OptionData,
                          NewFileCoffBase,
                          NewFileCoffTime,
                          OldFileInfoArray[ i ].IgnoreRangeCount,
                          OldFileInfoArray[ i ].IgnoreRangeArray,
                          OldFileInfoArray[ i ].RetainRangeCount,
                          OldFileInfoArray[ i ].RetainRangeArray
                          );

            if ( Success ) {

                Success = SafeCompleteCrc32( OldFileMapped, OldFileSize, &OldFileCrc );

                if ( Success ) {

                    //
                    //  First determine if this old file is the same as any already
                    //  processed old files.
                    //

                    Success = FALSE;

                    for ( j = 0; j < HeaderOldFileCount; j++ ) {

                        if (( HeaderInfo.OldFileInfoArray[ j ].OldFileCrc  == OldFileCrc  ) &&
                            ( HeaderInfo.OldFileInfoArray[ j ].OldFileSize == OldFileSize )) {

                            //
                            //  We have to remap the other old file here to make the
                            //  comparison.
                            //

                            PUCHAR CompareFileMapped;
                            ULONG  CompareFileSize;

                            Success = MyMapViewOfFileByHandle(
                                          HeaderInfo.OldFileInfoArray[ j ].OldFileHandle,
                                          &CompareFileSize,
                                          &CompareFileMapped
                                          );

                            if ( Success ) {

                                ASSERT( CompareFileSize == HeaderInfo.OldFileInfoArray[ j ].OldFileSize );

                                NormalizeOldFileImageForPatching(
                                    CompareFileMapped,
                                    CompareFileSize,
                                    OptionFlags,
                                    OptionData,
                                    NewFileCoffBase,
                                    NewFileCoffTime,
                                    HeaderInfo.OldFileInfoArray[ j ].IgnoreRangeCount,
                                    HeaderInfo.OldFileInfoArray[ j ].IgnoreRangeArray,
                                    HeaderInfo.OldFileInfoArray[ j ].RetainRangeCount,
                                    HeaderInfo.OldFileInfoArray[ j ].RetainRangeArray
                                    );

                                __try {
                                    Success = ( memcmp( CompareFileMapped, OldFileMapped, OldFileSize ) == 0 );
                                    }
                                __except( EXCEPTION_EXECUTE_HANDLER ) {
                                    SetLastError( GetExceptionCode() );
                                    Success = FALSE;
                                    }

                                UnmapViewOfFile( CompareFileMapped );

                                if ( Success ) {
                                    break;
                                    }
                                }
                            }
                        }

                    if ( ! Success ) {

                        //
                        //  Now see if old file is same as new file.
                        //

                        HeaderInfo.OldFileInfoArray[ HeaderOldFileCount ].RiftTable.RiftEntryAlloc = 0;
                        HeaderInfo.OldFileInfoArray[ HeaderOldFileCount ].RiftTable.RiftEntryCount = 0;
                        HeaderInfo.OldFileInfoArray[ HeaderOldFileCount ].RiftTable.RiftEntryArray = NULL;
                        HeaderInfo.OldFileInfoArray[ HeaderOldFileCount ].RiftTable.RiftUsageArray = NULL;

                        PatchBuffer = NULL;
                        PatchDataSize = 0;

                        if (( NewFileCrc == OldFileCrc  ) && ( NewFileSize == OldFileSize )) {

                            __try {
                                Success = ( memcmp( NewFileMapped, OldFileMapped, NewFileSize ) == 0 );
                                }
                            __except( EXCEPTION_EXECUTE_HANDLER ) {
                                SetLastError( GetExceptionCode() );
                                Success = FALSE;
                                }
                            }

                        if ( ! Success ) {

                            //
                            //  It's a unique file, so create the patch for it.
                            //
                            //  First we need to apply the transforms.
                            //

                            Transform = TRUE;

                            //
                            //  NOTE: This test for NtHeader is a perf tweak
                            //        for non-coff files.  If we ever have any
                            //        transformations for non-coff files, this
                            //        test should be removed.
                            //

                            if (( NtHeader ) && ( OldFileNtHeader )) {

                                //
                                //  See if rift table already provided by
                                //  caller so we don't need to generate it.
                                //

                                if (( OptionData ) &&
                                    ( OptionData->SizeOfThisStruct >= sizeof( PATCH_OPTION_DATA )) &&
                                    ( OptionData->SymbolOptionFlags & PATCH_SYMBOL_EXTERNAL_RIFT ) &&
                                    ( OptionData->OldFileSymbolPathArray ) &&
                                    ( OptionData->OldFileSymbolPathArray[ i ] )) {

                                    //
                                    //  This hidden private flag that tells us the rift information
                                    //  is already specified for us.  The LPCSTR pointer at
                                    //  OptionData->OldFileSymbolPathArray[ i ] is really a
                                    //  PRIFT_TABLE pointer.  Note that no validation of external
                                    //  rift data is performed (must be in ascending order with
                                    //  no OldRva duplicates).
                                    //
                                    //  We need to be careful to treat this external rift table
                                    //  differently in that we don't want to free the arrays
                                    //  like we do for our internally allocated rift tables.
                                    //  So, mark the RiftEntryAlloc field as zero to indicate
                                    //  that the rift arrays were not internally allocated.
                                    //

                                    PRIFT_TABLE ExternalRiftTable = (PVOID) OptionData->OldFileSymbolPathArray[ i ];

                                    HeaderInfo.OldFileInfoArray[ HeaderOldFileCount ].RiftTable.RiftEntryAlloc = 0;
                                    HeaderInfo.OldFileInfoArray[ HeaderOldFileCount ].RiftTable.RiftEntryCount = ExternalRiftTable->RiftEntryCount;
                                    HeaderInfo.OldFileInfoArray[ HeaderOldFileCount ].RiftTable.RiftEntryArray = ExternalRiftTable->RiftEntryArray;
                                    HeaderInfo.OldFileInfoArray[ HeaderOldFileCount ].RiftTable.RiftUsageArray = ExternalRiftTable->RiftUsageArray;
                                    }

                                else {

                                    //
                                    //  Need to allocate rift arrays and generate rift data.
                                    //  This (NewSize+OldSize)/sizeof(RIFT) allocation will
                                    //  provide enough space for one rift entry for every
                                    //  four bytes in the files.
                                    //

                                    ULONG AllocCount = ( NewFileSize + OldFileSize ) / sizeof( RIFT_ENTRY );

                                    HeaderInfo.OldFileInfoArray[ HeaderOldFileCount ].RiftTable.RiftEntryCount = 0;
                                    HeaderInfo.OldFileInfoArray[ HeaderOldFileCount ].RiftTable.RiftEntryAlloc = AllocCount;
                                    HeaderInfo.OldFileInfoArray[ HeaderOldFileCount ].RiftTable.RiftEntryArray = MyVirtualAlloc( AllocCount * sizeof( RIFT_ENTRY ));
                                    HeaderInfo.OldFileInfoArray[ HeaderOldFileCount ].RiftTable.RiftUsageArray = MyVirtualAlloc( AllocCount * sizeof( UCHAR ));

                                    if (( HeaderInfo.OldFileInfoArray[ HeaderOldFileCount ].RiftTable.RiftEntryArray == NULL ) ||
                                        ( HeaderInfo.OldFileInfoArray[ HeaderOldFileCount ].RiftTable.RiftUsageArray == NULL )) {

                                        Transform = FALSE;
                                        }

                                    else {

                                        Transform = GenerateRiftTable(
                                                        OldFileInfoArray[ i ].OldFileHandle,
                                                        OldFileMapped,
                                                        OldFileSize,
                                                        OldFileOriginalChecksum,
                                                        OldFileOriginalTimeDate,
                                                        NewFileHandle,
                                                        NewFileMapped,
                                                        NewFileSize,
                                                        OptionFlags,
                                                        OptionData,
                                                        i,
                                                        &HeaderInfo.OldFileInfoArray[ HeaderOldFileCount ].RiftTable
                                                        );

                                        ASSERT( HeaderInfo.OldFileInfoArray[ HeaderOldFileCount ].RiftTable.RiftEntryCount <= HeaderInfo.OldFileInfoArray[ HeaderOldFileCount ].RiftTable.RiftEntryAlloc );

#ifdef TESTCODE
                                        printf( "\r%9d unique rift entries generated\n", HeaderInfo.OldFileInfoArray[ HeaderOldFileCount ].RiftTable.RiftEntryCount );
#endif
                                        }
                                    }

                                if ( Transform ) {

                                    if ( HeaderInfo.OldFileInfoArray[ HeaderOldFileCount ].RiftTable.RiftEntryCount != 0 ) {

                                        Transform = TransformOldFileImageForPatching(
                                                        ExtendedOptionFlags,
                                                        OldFileMapped,
                                                        OldFileSize,
                                                        NewFileResTime,
                                                        &HeaderInfo.OldFileInfoArray[ HeaderOldFileCount ].RiftTable
                                                        );
                                        }
                                    }
                                }

                            if ( Transform ) {

                                PatchBuffer = MyVirtualAlloc( PatchBufferSize );

                                if ( PatchBuffer != NULL ) {

                                    EstimatedLzxMemory = EstimateLzxCompressionMemoryRequirement(
                                                             OldFileSize,
                                                             NewFileSize,
                                                             OptionFlags
                                                             );

                                    SubAllocatorHandle = CreateSubAllocator(
                                                             EstimatedLzxMemory,
                                                             MINIMUM_VM_ALLOCATION
                                                             );

                                    if ( SubAllocatorHandle != NULL ) {

                                        __try {
                                            ErrorCode = CreateRawLzxPatchDataFromBuffers(
                                                            OldFileMapped,
                                                            OldFileSize,
                                                            NewFileMapped,
                                                            NewFileSize,
                                                            PatchBufferSize,
                                                            PatchBuffer,
                                                            &PatchDataSize,
                                                            OptionFlags,
                                                            OptionData,
                                                            SubAllocate,
                                                            SubAllocatorHandle,
                                                            ProgressCallback,
                                                            CallbackContext,
                                                            ProgressPosition,
                                                            ProgressMaximum
                                                            );
                                            }
                                        __except( EXCEPTION_EXECUTE_HANDLER ) {
                                            ErrorCode = GetExceptionCode();
                                            }

                                        DestroySubAllocator( SubAllocatorHandle );

                                        if ( ErrorCode == NO_ERROR ) {

                                            Success = TRUE;

                                            if ( TryLzxBoth ) {

                                                AltExtendedOptionFlags = ExtendedOptionFlags;

                                                if (( NtHeader ) && ( ! ( AltExtendedOptionFlags | PATCH_TRANSFORM_NO_RELCALLS ))) {

                                                    //
                                                    //  Need to map, normalize, and transform
                                                    //  old file again without E8 transform.
                                                    //

                                                    AltExtendedOptionFlags |= PATCH_TRANSFORM_NO_RELCALLS;

                                                    UnmapViewOfFile( OldFileMapped );
                                                    OldFileMapped = NULL;

                                                    Success = MyMapViewOfFileByHandle(
                                                                  OldFileInfoArray[ i ].OldFileHandle,
                                                                  &OldFileSize,
                                                                  &OldFileMapped
                                                                  );

                                                    if ( Success ) {

                                                        Success = NormalizeOldFileImageForPatching(
                                                                      OldFileMapped,
                                                                      OldFileSize,
                                                                      OptionFlags,
                                                                      OptionData,
                                                                      NewFileCoffBase,
                                                                      NewFileCoffTime,
                                                                      OldFileInfoArray[ i ].IgnoreRangeCount,
                                                                      OldFileInfoArray[ i ].IgnoreRangeArray,
                                                                      OldFileInfoArray[ i ].RetainRangeCount,
                                                                      OldFileInfoArray[ i ].RetainRangeArray
                                                                      );

                                                        if ( Success ) {

                                                            if ( HeaderInfo.OldFileInfoArray[ HeaderOldFileCount ].RiftTable.RiftEntryCount != 0 ) {

                                                                Success = TransformOldFileImageForPatching(
                                                                              AltExtendedOptionFlags,
                                                                              OldFileMapped,
                                                                              OldFileSize,
                                                                              NewFileResTime,
                                                                              &HeaderInfo.OldFileInfoArray[ HeaderOldFileCount ].RiftTable
                                                                              );
                                                                }
                                                            }
                                                        }
                                                    }

                                                if ( Success ) {

                                                    PatchAltBuffer = MyVirtualAlloc( PatchBufferSize );

                                                    if ( PatchAltBuffer != NULL ) {

                                                        SubAllocatorHandle = CreateSubAllocator(
                                                                                 EstimatedLzxMemory,
                                                                                 MINIMUM_VM_ALLOCATION
                                                                                 );

                                                        if ( SubAllocatorHandle != NULL ) {

                                                            PatchAltSize = 0;   // prevent compiler warning

                                                            __try {
                                                                ErrorCode = CreateRawLzxPatchDataFromBuffers(
                                                                                OldFileMapped,
                                                                                OldFileSize,
                                                                                NewFileMapped,
                                                                                NewFileSize,
                                                                                PatchBufferSize,
                                                                                PatchAltBuffer,
                                                                                &PatchAltSize,
                                                                                OptionFlags | PATCH_OPTION_USE_LZX_B,
                                                                                OptionData,
                                                                                SubAllocate,
                                                                                SubAllocatorHandle,
                                                                                ProgressCallback,
                                                                                CallbackContext,
                                                                                ProgressPosition + NewFileSize + LzxInsertSize( OldFileSize, OptionFlags ),
                                                                                ProgressMaximum
                                                                                );
                                                                }
                                                            __except( EXCEPTION_EXECUTE_HANDLER ) {
                                                                ErrorCode = GetExceptionCode();
                                                                }

                                                            DestroySubAllocator( SubAllocatorHandle );

                                                            if (( ErrorCode == NO_ERROR ) && ( PatchAltSize <= PatchDataSize )) {
                                                                MyVirtualFree( PatchBuffer );
                                                                PatchBuffer   = PatchAltBuffer;
                                                                PatchDataSize = PatchAltSize;
                                                                ExtendedOptionFlags = AltExtendedOptionFlags;
                                                                }
                                                            else {
                                                                MyVirtualFree( PatchAltBuffer );
                                                                }
                                                            }
                                                        }
                                                    }
                                                }
                                            }

                                        else {
                                            SetLastError( ErrorCode );
                                            }
                                        }
                                    }
                                }
                            }

                        if ( Success ) {

                            PatchArray[ HeaderOldFileCount ].PatchData = PatchBuffer;
                            PatchArray[ HeaderOldFileCount ].PatchSize = PatchDataSize;

                            HeaderInfo.OldFileInfoArray[ HeaderOldFileCount ].OldFileHandle    = OldFileInfoArray[ i ].OldFileHandle;
                            HeaderInfo.OldFileInfoArray[ HeaderOldFileCount ].OldFileSize      = OldFileSize;
                            HeaderInfo.OldFileInfoArray[ HeaderOldFileCount ].OldFileCrc       = OldFileCrc;
                            HeaderInfo.OldFileInfoArray[ HeaderOldFileCount ].PatchDataSize    = PatchDataSize;
                            HeaderInfo.OldFileInfoArray[ HeaderOldFileCount ].IgnoreRangeCount = OldFileInfoArray[ i ].IgnoreRangeCount;
                            HeaderInfo.OldFileInfoArray[ HeaderOldFileCount ].IgnoreRangeArray = OldFileInfoArray[ i ].IgnoreRangeArray;
                            HeaderInfo.OldFileInfoArray[ HeaderOldFileCount ].RetainRangeCount = OldFileInfoArray[ i ].RetainRangeCount;
                            HeaderInfo.OldFileInfoArray[ HeaderOldFileCount ].RetainRangeArray = OldFileInfoArray[ i ].RetainRangeArray;

                            //
                            //  We overestimate (worst case) the possible
                            //  header size here.  Note that typical rift
                            //  encoding size is around 5 bytes per entry,
                            //  but we expect that to decrease when we switch
                            //  to Huffman encoding for the rift table.
                            //

                            HeaderSize += 32;
                            HeaderSize += HeaderInfo.OldFileInfoArray[ HeaderOldFileCount ].IgnoreRangeCount * sizeof( PATCH_IGNORE_RANGE );
                            HeaderSize += HeaderInfo.OldFileInfoArray[ HeaderOldFileCount ].RetainRangeCount * sizeof( PATCH_RETAIN_RANGE );
                            HeaderSize += HeaderInfo.OldFileInfoArray[ HeaderOldFileCount ].RiftTable.RiftEntryCount * sizeof( RIFT_ENTRY );

                            ++HeaderOldFileCount;
                            }
                        }
                    }
                }

            if ( OldFileMapped != NULL ) {
                UnmapViewOfFile( OldFileMapped );
                OldFileMapped = NULL;
                }

            if ( Success ) {

                ProgressPosition += ( LzxInsertSize( OldFileSize, OptionFlags ) + NewFileSize ) * ( TryLzxBoth ? 2 : 1 );

                Success = ProgressCallbackWrapper(
                              ProgressCallback,
                              CallbackContext,
                              ProgressPosition,
                              ProgressMaximum
                              );
                }

            if ( ! Success ) {
                break;
                }
            }
        }

    __except( EXCEPTION_EXECUTE_HANDLER ) {
        SetLastError( GetExceptionCode() );
        Success = FALSE;
        }

    if ( Success ) {

        if (( OptionFlags & PATCH_OPTION_FAIL_IF_SAME_FILE ) &&
            ( HeaderOldFileCount == 1 ) &&
            ( PatchArray[ 0 ].PatchSize == 0 )) {

            SetLastError( ERROR_PATCH_SAME_FILE );
            Success = FALSE;
            }
        }

    PatchBuffer   = NULL;
    PatchDataSize = 0;

    if ( Success ) {

        //
        //  Create header
        //

        Success = FALSE;

        HeaderSize = ROUNDUP2( HeaderSize, 0x10000 );

        PatchBuffer = MyVirtualAlloc( HeaderSize );

        if ( PatchBuffer != NULL ) {

            Success = TRUE;

            //
            //  Compute size of PatchData without the header.
            //

            PatchDataSize = 0;

            for ( i = 0; i < HeaderOldFileCount; i++ ) {
                PatchDataSize += PatchArray[ i ].PatchSize;
                }

            //
            //  Don't need to encode NewFileResTime if the patch is simply
            //  a header with no patch data (new file is same as old file).
            //  We do still need the NewFileCoffTime and NewFileCoffBase
            //  though because we still need to normalize the old file.
            //

            if ( PatchDataSize == 0 ) {
                OptionFlags |= PATCH_OPTION_NO_RESTIMEFIX;
                NewFileResTime = 0;
                }

            if ( ExtendedOptionFlags ) {
                OptionFlags |=  PATCH_OPTION_EXTENDED_OPTIONS;
                }
            else {
                OptionFlags &= ~PATCH_OPTION_EXTENDED_OPTIONS;
                }

            //
            //  Don't need to set PATCH_OPTION_LZX_LARGE unless an LZX window larger
            //  than 8Mb was used.  This allows backwards compatibility by default for
            //  files smaller than 8Mb.
            //

            if ( OptionFlags & PATCH_OPTION_USE_LZX_LARGE ) {

                if ( LzxWindowSize( LargestOldFileSize, NewFileSize, OptionFlags ) <= LZX_MAXWINDOW_8 ) {

                        OptionFlags &= ~PATCH_OPTION_USE_LZX_LARGE;
                    }
                }


            HeaderInfo.Signature           = PATCH_SIGNATURE;
            HeaderInfo.OptionFlags         = OptionFlags;
            HeaderInfo.ExtendedOptionFlags = ExtendedOptionFlags;
            HeaderInfo.OptionData          = OptionData;
            HeaderInfo.NewFileCoffBase     = NewFileCoffBase;
            HeaderInfo.NewFileCoffTime     = NewFileCoffTime;
            HeaderInfo.NewFileResTime      = NewFileResTime;
            HeaderInfo.NewFileSize         = NewFileSize;
            HeaderInfo.NewFileCrc          = NewFileCrc;
            HeaderInfo.OldFileCount        = HeaderOldFileCount;
            HeaderInfo.NewFileTime         = 0;

            if ( ! ( OptionFlags & PATCH_OPTION_NO_TIMESTAMP )) {

                HeaderInfo.NewFileTime = FileTimeToUlongTime( &NewFileTime );
                PatchFileTime = NULL;
                }

            HeaderSize = EncodePatchHeader( &HeaderInfo, PatchBuffer );

            PatchDataSize += HeaderSize + sizeof( ULONG );

            //
            //  Now we know the size of the patch file, so if we want to
            //  make sure it's not bigger than just compressing the new
            //  file, we need to compress the new file to see (the output
            //  of the compression is discarded -- we just want to know
            //  how big it would be.  Obviously if the patch file is bigger
            //  than the raw new file, no need to compress the new file to
            //  see if that is smaller!
            //

            if ( OptionFlags & PATCH_OPTION_FAIL_IF_BIGGER ) {

                if ( PatchDataSize > NewFileSize ) {
                    SetLastError( ERROR_PATCH_BIGGER_THAN_COMPRESSED );
                    Success = FALSE;
                    }

                else {

                    EstimatedLzxMemory = EstimateLzxCompressionMemoryRequirement(
                                             0,
                                             NewFileSize,
                                             0      // CAB has only 2Mb window size
                                             );

                    SubAllocatorHandle = CreateSubAllocator(
                                             EstimatedLzxMemory,
                                             MINIMUM_VM_ALLOCATION
                                             );

                    if ( SubAllocatorHandle != NULL ) {

                        NewFileCompressedSize = 0;  // prevent compiler warning

                        __try {
                            ErrorCode = RawLzxCompressBuffer(
                                            NewFileMapped,
                                            NewFileSize,
                                            0,
                                            NULL,
                                            &NewFileCompressedSize,
                                            SubAllocate,
                                            SubAllocatorHandle,
                                            ProgressCallback,
                                            CallbackContext,
                                            ProgressPosition,
                                            ProgressMaximum
                                            );
                            }
                        __except( EXCEPTION_EXECUTE_HANDLER ) {
                            ErrorCode = GetExceptionCode();
                            }

                        DestroySubAllocator( SubAllocatorHandle );

                        if ( ErrorCode == NO_ERROR ) {
                            if ( PatchDataSize > NewFileCompressedSize ) {
                                SetLastError( ERROR_PATCH_BIGGER_THAN_COMPRESSED );
                                Success = FALSE;
                                }
                            }
                        }
                    }

                if ( Success ) {

                    ProgressPosition += NewFileSize;

                    Success = ProgressCallbackWrapper(
                                  ProgressCallback,
                                  CallbackContext,
                                  ProgressPosition,
                                  ProgressMaximum
                                  );
                    }
                }
            }
        }

    UnmapViewOfFile( NewFileMapped );

    if ( Success ) {

        Success = MyCreateMappedFileByHandle(
                      PatchFileHandle,
                      PatchDataSize,
                      &PatchFileMapped
                      );

        if ( Success ) {

            __try {

                p = PatchFileMapped;
                CopyMemory( p, PatchBuffer, HeaderSize );
                p += HeaderSize;

                for ( i = 0; i < HeaderOldFileCount; i++ ) {
                    if ( PatchArray[ i ].PatchSize != 0 ) {
                        CopyMemory( p, PatchArray[ i ].PatchData, PatchArray[ i ].PatchSize );
                        p += PatchArray[ i ].PatchSize;
                        }
                    }

                PatchFileCrc = Crc32( 0xFFFFFFFF, PatchFileMapped, PatchDataSize - sizeof( ULONG ));

                *(UNALIGNED ULONG *)( PatchFileMapped + PatchDataSize - sizeof( ULONG )) = PatchFileCrc;

                }

            __except( EXCEPTION_EXECUTE_HANDLER ) {
                SetLastError( GetExceptionCode() );
                PatchDataSize = 0;
                Success = FALSE;
                }

            MyUnmapCreatedMappedFile(
                PatchFileHandle,
                PatchFileMapped,
                PatchDataSize,
                PatchFileTime
                );
            }
        }

    //
    //  Cleanup
    //

    if ( PatchBuffer ) {
        MyVirtualFree( PatchBuffer );
        }

    for ( i = 0; i < OldFileCount; i++ ) {
        if ( PatchArray[ i ].PatchData ) {
            MyVirtualFree( PatchArray[ i ].PatchData );
            }
        if ( HeaderInfo.OldFileInfoArray[ i ].RiftTable.RiftEntryAlloc ) {
            if ( HeaderInfo.OldFileInfoArray[ i ].RiftTable.RiftEntryArray ) {
                MyVirtualFree( HeaderInfo.OldFileInfoArray[ i ].RiftTable.RiftEntryArray );
                }
            if ( HeaderInfo.OldFileInfoArray[ i ].RiftTable.RiftUsageArray ) {
                MyVirtualFree( HeaderInfo.OldFileInfoArray[ i ].RiftTable.RiftUsageArray );
                }
            }
        }

    if ( Success ) {
        ASSERT( ProgressPosition == ProgressMaximum );
        }

    if (( ! Success ) &&
        ( GetLastError() == ERROR_SUCCESS )) {

        SetLastError( ERROR_EXTENDED_ERROR );
        }

    HeapFree(GetProcessHeap(), 0, PatchArray);
    HeapFree(GetProcessHeap(), 0, HeaderInfo.OldFileInfoArray);
    return Success;
    }


BOOL
PATCHAPI
ExtractPatchHeaderToFileA(
    IN  LPCSTR PatchFileName,
    OUT LPCSTR PatchHeaderFileName
    )
    {
    HANDLE PatchFileHandle;
    HANDLE HeaderFileHandle;
    BOOL   Success = FALSE;

    PatchFileHandle = CreateFileA(
                          PatchFileName,
                          GENERIC_READ,
                          FILE_SHARE_READ | FILE_SHARE_WRITE,
                          NULL,
                          OPEN_EXISTING,
                          FILE_FLAG_RANDOM_ACCESS,
                          NULL
                          );

    if ( PatchFileHandle != INVALID_HANDLE_VALUE ) {

        HeaderFileHandle = CreateFileA(
                               PatchHeaderFileName,
                               GENERIC_READ | GENERIC_WRITE,
                               FILE_SHARE_READ,
                               NULL,
                               CREATE_ALWAYS,
                               FILE_ATTRIBUTE_NORMAL,
                               NULL
                               );


        if ( HeaderFileHandle != INVALID_HANDLE_VALUE ) {

            Success = ExtractPatchHeaderToFileByHandles(
                          PatchFileHandle,
                          HeaderFileHandle
                          );

            CloseHandle( HeaderFileHandle );

            if ( ! Success ) {
                DeleteFileA( PatchHeaderFileName );
                }
            }

        CloseHandle( PatchFileHandle );
        }

    return Success;
    }


BOOL
PATCHAPI
ExtractPatchHeaderToFileW(
    IN  LPCWSTR PatchFileName,
    OUT LPCWSTR PatchHeaderFileName
    )
    {
    HANDLE PatchFileHandle;
    HANDLE HeaderFileHandle;
    BOOL   Success = FALSE;

    PatchFileHandle = CreateFileW(
                          PatchFileName,
                          GENERIC_READ,
                          FILE_SHARE_READ | FILE_SHARE_WRITE,
                          NULL,
                          OPEN_EXISTING,
                          FILE_FLAG_RANDOM_ACCESS,
                          NULL
                          );

    if ( PatchFileHandle != INVALID_HANDLE_VALUE ) {

        HeaderFileHandle = CreateFileW(
                               PatchHeaderFileName,
                               GENERIC_READ | GENERIC_WRITE,
                               FILE_SHARE_READ,
                               NULL,
                               CREATE_ALWAYS,
                               FILE_ATTRIBUTE_NORMAL,
                               NULL
                               );


        if ( HeaderFileHandle != INVALID_HANDLE_VALUE ) {

            Success = ExtractPatchHeaderToFileByHandles(
                          PatchFileHandle,
                          HeaderFileHandle
                          );

            CloseHandle( HeaderFileHandle );

            if ( ! Success ) {
                DeleteFileW( PatchHeaderFileName );
                }
            }

        CloseHandle( PatchFileHandle );
        }

    return Success;
    }


BOOL
PATCHAPI
ExtractPatchHeaderToFileByHandles(
    IN  HANDLE PatchFileHandle,
    OUT HANDLE PatchHeaderFileHandle
    )
    {
    PPATCH_HEADER_INFO HeaderInfo;
    HANDLE   SubAllocator;
    PUCHAR   PatchFileMapped;
    FILETIME PatchFileTime;
    ULONG    PatchFileSize;
    ULONG    PatchFileCrc;
    ULONG    PatchHeaderSize;
    ULONG    ActualSize;
    ULONG    i;
    BOOL     Success;
    BOOL     Mapped;

    Success = FALSE;

    Mapped = MyMapViewOfFileByHandle(
                 PatchFileHandle,
                 &PatchFileSize,
                 &PatchFileMapped
                 );

    if ( Mapped ) {

        GetFileTime( PatchFileHandle, NULL, NULL, &PatchFileTime );

        PatchFileCrc = 0;

        SafeCompleteCrc32( PatchFileMapped, PatchFileSize, &PatchFileCrc );

        if ( PatchFileCrc == 0xFFFFFFFF ) {

            SubAllocator = CreateSubAllocator( 0x10000, 0x10000 );

            if ( SubAllocator ) {

                Success = DecodePatchHeader(
                              PatchFileMapped,
                              PatchFileSize,
                              SubAllocator,
                              &PatchHeaderSize,
                              &HeaderInfo
                              );

                if ( Success ) {

                    //
                    //  Header extraction is provided so that a header without
                    //  the bulk of the patch data can be used to determine if
                    //  an old file is correct for this patch header (can be
                    //  patched).
                    //
                    //  Since the extracted header will not be used to actually
                    //  apply, we don't need any of the header data that is
                    //  used only for transformation (RiftTable and NewResTime).
                    //  Since NewResTime is typically encoded as one byte (as
                    //  delta from NewCoffTime), we won't bother throwing it
                    //  away, but we will throw away the RiftTable.
                    //
                    //  Zero out the rift entry counts, then re-create the
                    //  patch header with the zeroed rift counts (create over
                    //  the write-copy mapped patch file buffer, then write
                    //  that buffer to disk).
                    //

                    for ( i = 0; i < HeaderInfo->OldFileCount; i++ ) {
                        HeaderInfo->OldFileInfoArray[ i ].RiftTable.RiftEntryCount = 0;
                        }

                    __try {

                        PatchHeaderSize = EncodePatchHeader( HeaderInfo, PatchFileMapped );

                        PatchFileCrc = Crc32( 0xFFFFFFFF, PatchFileMapped, PatchHeaderSize );

                        *(UNALIGNED ULONG *)( PatchFileMapped + PatchHeaderSize ) = PatchFileCrc;

                        Success = WriteFile(
                                      PatchHeaderFileHandle,
                                      PatchFileMapped,
                                      PatchHeaderSize + sizeof( ULONG ),
                                      &ActualSize,
                                      NULL
                                      );
                        }

                    __except( EXCEPTION_EXECUTE_HANDLER ) {
                        SetLastError( GetExceptionCode() );
                        Success = FALSE;
                        }

                    if ( Success ) {
                        SetFileTime( PatchHeaderFileHandle, NULL, NULL, &PatchFileTime );
                        }
                    }

                DestroySubAllocator( SubAllocator );
                }
            }

        else {
            SetLastError( ERROR_PATCH_CORRUPT );
            }

        UnmapViewOfFile( PatchFileMapped );
        }

    return Success;
    }


#endif // ! PATCH_APPLY_CODE_ONLY


//
//  Following group of functions and exported apis are exclusively for
//  applying patches.  If we're only compiling the create code, ignore
//  this group of functions.
//

#ifndef PATCH_CREATE_CODE_ONLY

PVOID
SaveRetainRanges(
    IN PUCHAR MappedFile,
    IN ULONG  FileSize,
    IN ULONG  RetainRangeCount,
    IN PPATCH_RETAIN_RANGE RetainRangeArray,
    IN BOOL   SaveFromNewFile
    )
    {
    PUCHAR Buffer, p;
    ULONG  Offset;
    ULONG  TotalSize = 0;
    ULONG  i;

    for ( i = 0; i < RetainRangeCount; i++ ) {
        TotalSize += RetainRangeArray[ i ].LengthInBytes;
        }

    Buffer = MyVirtualAlloc( TotalSize );

    if ( Buffer ) {

        __try {

            p = Buffer;

            for ( i = 0; i < RetainRangeCount; i++ ) {

                Offset = SaveFromNewFile ?
                             RetainRangeArray[ i ].OffsetInNewFile :
                             RetainRangeArray[ i ].OffsetInOldFile;

                if (( Offset + RetainRangeArray[ i ].LengthInBytes ) <= FileSize ) {
                    CopyMemory( p, MappedFile + Offset, RetainRangeArray[ i ].LengthInBytes );
                    }

                p += RetainRangeArray[ i ].LengthInBytes;
                }
            }

        __except( EXCEPTION_EXECUTE_HANDLER ) {
            SetLastError( GetExceptionCode() );
            MyVirtualFree( Buffer );
            Buffer = NULL;
            }
        }

    return Buffer;
    }


BOOL
CreateNewFileFromOldFileMapped(
    IN  PUCHAR                   OldFileMapped,
    IN  ULONG                    OldFileSize,
    OUT HANDLE                   NewFileHandle,
    IN  PFILETIME                NewFileTime,
    IN  ULONG                    NewFileExpectedCrc,
    IN  ULONG                    RetainRangeCount,
    IN  PPATCH_RETAIN_RANGE      RetainRangeArray,
    IN  PUCHAR                   RetainBuffer,
    IN  PPATCH_PROGRESS_CALLBACK ProgressCallback,
    IN  PVOID                    CallbackContext
    )
    {
    PUCHAR NewFileMapped;
    ULONG  NewFileCrc;
    BOOL   Success;
    ULONG  i;

    Success = MyCreateMappedFileByHandle(
                  NewFileHandle,
                  OldFileSize,
                  &NewFileMapped
                  );

    if ( Success ) {

        __try {

            CopyMemory( NewFileMapped, OldFileMapped, OldFileSize );

            NewFileCrc = Crc32( 0xFFFFFFFF, NewFileMapped, OldFileSize ) ^ 0xFFFFFFFF;

            if ( NewFileCrc == NewFileExpectedCrc ) {

                for ( i = 0; i < RetainRangeCount; i++ ) {
                    if (( RetainRangeArray[ i ].OffsetInNewFile + RetainRangeArray[ i ].LengthInBytes ) <= OldFileSize ) {
                        CopyMemory(
                            RetainRangeArray[ i ].OffsetInNewFile + NewFileMapped,
                            RetainBuffer,
                            RetainRangeArray[ i ].LengthInBytes
                            );
                        }
                    RetainBuffer += RetainRangeArray[ i ].LengthInBytes;
                    }

                Success = ProgressCallbackWrapper(
                              ProgressCallback,
                              CallbackContext,
                              OldFileSize,
                              OldFileSize
                              );
                }

            else {
                SetLastError( ERROR_PATCH_WRONG_FILE );
                OldFileSize = 0;
                Success = FALSE;
                }
            }

        __except( EXCEPTION_EXECUTE_HANDLER ) {
            SetLastError( GetExceptionCode());
            OldFileSize = 0;
            Success = FALSE;
            }

        MyUnmapCreatedMappedFile(
            NewFileHandle,
            NewFileMapped,
            OldFileSize,
            NewFileTime
            );
        }

    return Success;
    }


BOOL
CreateNewFileFromPatchData(
    IN  PUCHAR                   OldFileMapped,
    IN  ULONG                    OldFileSize,
    IN  PUCHAR                   PatchData,
    IN  ULONG                    PatchDataSize,
    OUT HANDLE                   NewFileHandle,
    IN  ULONG                    NewFileSize,
    IN  PFILETIME                NewFileTime,
    IN  ULONG                    NewFileExpectedCrc,
    IN  ULONG                    RetainRangeCount,
    IN  PPATCH_RETAIN_RANGE      RetainRangeArray,
    IN  PUCHAR                   RetainBuffer,
    IN  ULONG                    OptionFlags,
    IN  PVOID                    OptionData,
    IN  PPATCH_PROGRESS_CALLBACK ProgressCallback,
    IN  PVOID                    CallbackContext
    )
    {
    HANDLE SubAllocatorHandle;
    ULONG  EstimatedLzxMemory;
    PUCHAR NewFileMapped;
    ULONG  NewFileCrc;
    ULONG  ErrorCode;
    BOOL   Success;
    ULONG  i;

    UNREFERENCED_PARAMETER( OptionData );

    Success = MyCreateMappedFileByHandle(
                  NewFileHandle,
                  NewFileSize,
                  &NewFileMapped
                  );

    if ( Success ) {

        ErrorCode = NO_ERROR;

        EstimatedLzxMemory = EstimateLzxDecompressionMemoryRequirement(
                                 OldFileSize,
                                 NewFileSize,
                                 OptionFlags
                                 );

        SubAllocatorHandle = CreateSubAllocator(
                                 EstimatedLzxMemory,
                                 MINIMUM_VM_ALLOCATION
                                 );

        if ( SubAllocatorHandle != NULL ) {

            __try {

                ErrorCode = ApplyRawLzxPatchToBuffer(
                                OldFileMapped,
                                OldFileSize,
                                PatchData,
                                PatchDataSize,
                                NewFileMapped,
                                NewFileSize,
                                OptionFlags,
                                OptionData,
                                SubAllocate,
                                SubAllocatorHandle,
                                ProgressCallback,
                                CallbackContext,
                                0,
                                NewFileSize
                                );

                if ( ErrorCode == NO_ERROR ) {

                    NewFileCrc = Crc32( 0xFFFFFFFF, NewFileMapped, NewFileSize ) ^ 0xFFFFFFFF;

                    if ( NewFileCrc == NewFileExpectedCrc ) {

                        for ( i = 0; i < RetainRangeCount; i++ ) {
                            if (( RetainRangeArray[ i ].OffsetInNewFile + RetainRangeArray[ i ].LengthInBytes ) <= OldFileSize ) {
                                CopyMemory(
                                    RetainRangeArray[ i ].OffsetInNewFile + NewFileMapped,
                                    RetainBuffer,
                                    RetainRangeArray[ i ].LengthInBytes
                                    );
                                }
                            RetainBuffer += RetainRangeArray[ i ].LengthInBytes;
                            }
                        }

                    else {

                        ErrorCode = ERROR_PATCH_WRONG_FILE;

                        }
                    }

#ifdef TESTCODE

                if ( ErrorCode != NO_ERROR ) {

                    HANDLE hFile = CreateFile(
                                       "Wrong.out",
                                       GENERIC_WRITE,
                                       FILE_SHARE_READ,
                                       NULL,
                                       CREATE_ALWAYS,
                                       FILE_ATTRIBUTE_NORMAL,
                                       NULL
                                       );

                    if ( hFile != INVALID_HANDLE_VALUE ) {

                        DWORD Actual;

                        WriteFile( hFile, NewFileMapped, NewFileSize, &Actual, NULL );

                        CloseHandle( hFile );

                        }
                    }

#endif // TESTCODE

                }

            __except( EXCEPTION_EXECUTE_HANDLER ) {
                ErrorCode = GetExceptionCode();
                }

            DestroySubAllocator( SubAllocatorHandle );
            }

        MyUnmapCreatedMappedFile(
            NewFileHandle,
            NewFileMapped,
            ( ErrorCode == NO_ERROR ) ? NewFileSize : 0,
            NewFileTime
            );

        if ( ErrorCode == NO_ERROR ) {
            Success = TRUE;
            }
        else {
            SetLastError( ErrorCode );
            Success = FALSE;
            }
        }

    return Success;
    }


BOOL
PATCHAPI
ApplyPatchToFileByHandlesEx(
    IN  HANDLE                   PatchFileHandle,
    IN  HANDLE                   OldFileHandle,
    OUT HANDLE                   NewFileHandle,
    IN  ULONG                    ApplyOptionFlags,
    IN  PPATCH_PROGRESS_CALLBACK ProgressCallback,
    IN  PVOID                    CallbackContext
    )
    {
    PHEADER_OLD_FILE_INFO OldFileInfo;
    PPATCH_HEADER_INFO HeaderInfo;
    PPATCH_RETAIN_RANGE RetainRangeArray;
    ULONG    RetainRangeCount;
    PUCHAR   RetainBuffer;
    HANDLE   SubAllocator;
    ULONG    PatchHeaderSize;
    FILETIME NewFileTime;
    PUCHAR   PatchFileMapped;
    ULONG    PatchFileSize;
    ULONG    PatchFileCrc;
    PUCHAR   PatchData;
    PUCHAR   OldFileMapped;
    ULONG    OldFileSize;
    ULONG    OldFileCrc;
    BOOL     Mapped;
    BOOL     Success;
    BOOL     Finished;
    ULONG    i;

    Success = FALSE;

    Mapped = MyMapViewOfFileByHandle(
                 PatchFileHandle,
                 &PatchFileSize,
                 &PatchFileMapped
                 );

    if ( Mapped ) {

        GetFileTime( PatchFileHandle, NULL, NULL, &NewFileTime );

        PatchFileCrc = 0;

        SafeCompleteCrc32( PatchFileMapped, PatchFileSize, &PatchFileCrc );

        if ( PatchFileCrc == 0xFFFFFFFF ) {

            SubAllocator = CreateSubAllocator( 0x10000, 0x10000 );

            if ( SubAllocator ) {

                Success = DecodePatchHeader(
                              PatchFileMapped,
                              PatchFileSize,
                              SubAllocator,
                              &PatchHeaderSize,
                              &HeaderInfo
                              );

                if ( Success ) {

                    //
                    //  Patch is valid.
                    //

                    Success = ProgressCallbackWrapper(
                                  ProgressCallback,
                                  CallbackContext,
                                  0,
                                  HeaderInfo->NewFileSize
                                  );

                    if ( Success ) {

                        Finished = FALSE;
                        Success  = FALSE;

                        if (( ! ( HeaderInfo->OptionFlags & PATCH_OPTION_NO_TIMESTAMP )) &&
                            ( HeaderInfo->NewFileTime != 0 )) {

                            UlongTimeToFileTime( HeaderInfo->NewFileTime, &NewFileTime );
                            }

                        OldFileSize = GetFileSize( OldFileHandle, NULL );

                        //
                        //  First see if the old file is really the new file.
                        //

                        if ( OldFileSize == HeaderInfo->NewFileSize ) {

                            Mapped = MyMapViewOfFileByHandle(
                                         OldFileHandle,
                                         &OldFileSize,
                                         &OldFileMapped
                                         );

                            if ( ! Mapped ) {
                                Success  = FALSE;
                                Finished = TRUE;
                                }

                            else {

                                RetainBuffer     = NULL;
                                OldFileCrc       = 0;
                                OldFileInfo      = &HeaderInfo->OldFileInfoArray[ 0 ];
                                RetainRangeCount = OldFileInfo->RetainRangeCount;
                                RetainRangeArray = OldFileInfo->RetainRangeArray;

                                if (( RetainRangeCount != 0 ) &&
                                    ( ! ( ApplyOptionFlags & APPLY_OPTION_TEST_ONLY ))) {

                                    RetainBuffer = SaveRetainRanges(
                                                       OldFileMapped,
                                                       OldFileSize,
                                                       RetainRangeCount,
                                                       RetainRangeArray,
                                                       TRUE
                                                       );

                                    if ( RetainBuffer == NULL ) {
                                        Finished = TRUE;
                                        }
                                    }

                                if ( ! Finished ) {

                                    __try {

                                        //
                                        //  First see if they match exact, without
                                        //  normalizing.
                                        //

                                        for ( i = 0; i < RetainRangeCount; i++ ) {
                                            if (( RetainRangeArray[ i ].OffsetInNewFile + RetainRangeArray[ i ].LengthInBytes ) <= OldFileSize ) {
                                                ZeroMemory( OldFileMapped + RetainRangeArray[ i ].OffsetInNewFile, RetainRangeArray[ i ].LengthInBytes );
                                                }
                                            }

                                        OldFileCrc = Crc32( 0xFFFFFFFF, OldFileMapped, OldFileSize ) ^ 0xFFFFFFFF;

                                        if ( OldFileCrc != HeaderInfo->NewFileCrc ) {

                                            //
                                            //  Don't match exact, so try with
                                            //  normalizing.
                                            //
                                            //  NOTE: We're assuming here that the
                                            //  zeroed retain ranges don't overlap
                                            //  with the binding info that we're
                                            //  correcting.
                                            //

                                            NormalizeOldFileImageForPatching(
                                                OldFileMapped,
                                                OldFileSize,
                                                HeaderInfo->OptionFlags,
                                                HeaderInfo->OptionData,
                                                HeaderInfo->NewFileCoffBase,
                                                HeaderInfo->NewFileCoffTime,
                                                0,
                                                NULL,
                                                0,
                                                NULL
                                                );

                                            OldFileCrc = Crc32( 0xFFFFFFFF, OldFileMapped, OldFileSize ) ^ 0xFFFFFFFF;
                                            }
                                        }

                                    __except( EXCEPTION_EXECUTE_HANDLER ) {
                                        SetLastError( GetExceptionCode() );
                                        Finished = TRUE;
                                        }

                                    if (( ! Finished ) &&
                                        ( OldFileCrc  == HeaderInfo->NewFileCrc  ) &&
                                        ( OldFileSize == HeaderInfo->NewFileSize )) {

                                        Finished = TRUE;

                                        if ( ApplyOptionFlags & APPLY_OPTION_FAIL_IF_EXACT ) {
                                            SetLastError( ERROR_PATCH_NOT_NECESSARY );
                                            Success = FALSE;
                                            }
                                        else if ( ApplyOptionFlags & APPLY_OPTION_TEST_ONLY ) {
                                            Success = TRUE;
                                            }
                                        else {
                                            Success = CreateNewFileFromOldFileMapped(
                                                          OldFileMapped,
                                                          OldFileSize,
                                                          NewFileHandle,
                                                          &NewFileTime,
                                                          HeaderInfo->NewFileCrc,
                                                          RetainRangeCount,
                                                          RetainRangeArray,
                                                          RetainBuffer,
                                                          ProgressCallback,
                                                          CallbackContext
                                                          );
                                            }
                                        }

                                    if ( RetainBuffer != NULL ) {
                                        MyVirtualFree( RetainBuffer );
                                        }
                                    }

                                UnmapViewOfFile( OldFileMapped );
                                }
                            }

                        if ( ! Finished ) {

                            //
                            //  Now see if the old file matches one of the old
                            //  files we have in our patch file.  For each set
                            //  of old file info in our patch file, we have to
                            //  remap the old file to check it since each old
                            //  file might have different ignore range parameters
                            //  (we modify the buffer for the ignore ranges).
                            //

                            PatchData = PatchFileMapped + PatchHeaderSize;
                            Success   = FALSE;

                            for ( i = 0; ( i < HeaderInfo->OldFileCount ) && ( ! Finished ) && ( ! Success ); i++ ) {

                                OldFileInfo = &HeaderInfo->OldFileInfoArray[ i ];

                                if ( OldFileInfo->OldFileSize == OldFileSize ) {

                                    Mapped = MyMapViewOfFileByHandle(
                                                 OldFileHandle,
                                                 &OldFileSize,
                                                 &OldFileMapped
                                                 );

                                    if ( ! Mapped ) {
                                        Finished = TRUE;
                                        }

                                    else {

                                        RetainBuffer = NULL;

                                        if (( OldFileInfo->RetainRangeCount != 0 ) &&
                                            ( ! ( ApplyOptionFlags & APPLY_OPTION_TEST_ONLY ))) {

                                            RetainBuffer = SaveRetainRanges(
                                                               OldFileMapped,
                                                               OldFileSize,
                                                               OldFileInfo->RetainRangeCount,
                                                               OldFileInfo->RetainRangeArray,
                                                               FALSE
                                                               );

                                            if ( RetainBuffer == NULL ) {
                                                Finished = TRUE;
                                                }
                                            }

                                        if ( ! Finished ) {

                                            NormalizeOldFileImageForPatching(
                                                OldFileMapped,
                                                OldFileSize,
                                                HeaderInfo->OptionFlags,
                                                HeaderInfo->OptionData,
                                                HeaderInfo->NewFileCoffBase,
                                                HeaderInfo->NewFileCoffTime,
                                                OldFileInfo->IgnoreRangeCount,
                                                OldFileInfo->IgnoreRangeArray,
                                                OldFileInfo->RetainRangeCount,
                                                OldFileInfo->RetainRangeArray
                                                );

                                            OldFileCrc = 0;

                                            if (( SafeCompleteCrc32( OldFileMapped, OldFileSize, &OldFileCrc )) &&
                                                ( OldFileCrc  == OldFileInfo->OldFileCrc  ) &&
                                                ( OldFileSize == OldFileInfo->OldFileSize )) {

                                                //
                                                //  CRC's match
                                                //

                                                if ( OldFileInfo->PatchDataSize == 0 ) {
                                                    if ( ApplyOptionFlags & APPLY_OPTION_FAIL_IF_CLOSE ) {
                                                        SetLastError( ERROR_PATCH_NOT_NECESSARY );
                                                        Finished = TRUE;
                                                        }
                                                    else if ( ApplyOptionFlags & APPLY_OPTION_TEST_ONLY ) {
                                                        Success = TRUE;
                                                        }
                                                    else {
                                                        Success = CreateNewFileFromOldFileMapped(
                                                                      OldFileMapped,
                                                                      OldFileSize,
                                                                      NewFileHandle,
                                                                      &NewFileTime,
                                                                      HeaderInfo->NewFileCrc,
                                                                      OldFileInfo->RetainRangeCount,
                                                                      OldFileInfo->RetainRangeArray,
                                                                      RetainBuffer,
                                                                      ProgressCallback,
                                                                      CallbackContext
                                                                      );
                                                        if ( ! Success ) {
                                                            Finished = TRUE;
                                                            }
                                                        }
                                                    }

                                                else {

                                                    if ( ApplyOptionFlags & APPLY_OPTION_TEST_ONLY ) {
                                                        Success = TRUE;
                                                        }
                                                    else if (( PatchData + OldFileInfo->PatchDataSize ) > ( PatchFileMapped + PatchFileSize )) {
                                                        SetLastError( ERROR_PATCH_NOT_AVAILABLE );
                                                        Finished = TRUE;
                                                        }
                                                    else {

                                                        Success = TRUE;

                                                        if ( OldFileInfo->RiftTable.RiftEntryCount != 0 ) {

                                                            Success = TransformOldFileImageForPatching(
                                                                          HeaderInfo->ExtendedOptionFlags,
                                                                          OldFileMapped,
                                                                          OldFileSize,
                                                                          HeaderInfo->NewFileResTime,
                                                                          &OldFileInfo->RiftTable
                                                                          );
                                                            }

                                                        if ( Success ) {

                                                            Success = CreateNewFileFromPatchData(
                                                                           OldFileMapped,
                                                                           OldFileSize,
                                                                           PatchData,
                                                                           OldFileInfo->PatchDataSize,
                                                                           NewFileHandle,
                                                                           HeaderInfo->NewFileSize,
                                                                           &NewFileTime,
                                                                           HeaderInfo->NewFileCrc,
                                                                           OldFileInfo->RetainRangeCount,
                                                                           OldFileInfo->RetainRangeArray,
                                                                           RetainBuffer,
                                                                           HeaderInfo->OptionFlags,
                                                                           HeaderInfo->OptionData,
                                                                           ProgressCallback,
                                                                           CallbackContext
                                                                           );
                                                            }

                                                        if ( ! Success ) {
                                                            Finished = TRUE;
                                                            }
                                                        }
                                                    }
                                                }

                                            if ( RetainBuffer != NULL ) {
                                                MyVirtualFree( RetainBuffer );
                                                }
                                            }

                                        UnmapViewOfFile( OldFileMapped );
                                        }
                                    }

                                PatchData += OldFileInfo->PatchDataSize;
                                }

                            if (( ! Finished ) && ( ! Success )) {
                                SetLastError( ERROR_PATCH_WRONG_FILE );
                                }
                            }
                        }
                    }

                DestroySubAllocator( SubAllocator );
                }
            }

        else {
            SetLastError( ERROR_PATCH_CORRUPT );
            }

        UnmapViewOfFile( PatchFileMapped );
        }

    if (( ! Success ) &&
        ( GetLastError() == ERROR_SUCCESS )) {

        SetLastError( ERROR_EXTENDED_ERROR );
        }

    return Success;
    }


BOOL
PATCHAPI
TestApplyPatchToFileByHandles(
    IN HANDLE PatchFileHandle,      // requires GENERIC_READ access
    IN HANDLE OldFileHandle,        // requires GENERIC_READ access
    IN ULONG  ApplyOptionFlags
    )
    {
    return ApplyPatchToFileByHandles(
               PatchFileHandle,
               OldFileHandle,
               INVALID_HANDLE_VALUE,
               ApplyOptionFlags | APPLY_OPTION_TEST_ONLY
               );
    }


BOOL
PATCHAPI
ApplyPatchToFileByHandles(
    IN  HANDLE PatchFileHandle,     // requires GENERIC_READ access
    IN  HANDLE OldFileHandle,       // requires GENERIC_READ access
    OUT HANDLE NewFileHandle,       // requires GENERIC_READ | GENERIC_WRITE
    IN  ULONG  ApplyOptionFlags
    )
    {
    return ApplyPatchToFileByHandlesEx(
               PatchFileHandle,
               OldFileHandle,
               NewFileHandle,
               ApplyOptionFlags,
               NULL,
               NULL
               );
    }


BOOL
PATCHAPI
TestApplyPatchToFileA(
    IN LPCSTR PatchFileName,
    IN LPCSTR OldFileName,
    IN ULONG  ApplyOptionFlags
    )
    {
    return ApplyPatchToFileA(
               PatchFileName,
               OldFileName,
               INVALID_HANDLE_VALUE,
               ApplyOptionFlags | APPLY_OPTION_TEST_ONLY
               );
    }


BOOL
PATCHAPI
ApplyPatchToFileA(
    IN  LPCSTR PatchFileName,
    IN  LPCSTR OldFileName,
    OUT LPCSTR NewFileName,
    IN  ULONG  ApplyOptionFlags
    )
    {
    return ApplyPatchToFileExA(
               PatchFileName,
               OldFileName,
               NewFileName,
               ApplyOptionFlags,
               NULL,
               NULL
               );
    }


BOOL
PATCHAPI
ApplyPatchToFileExA(
    IN  LPCSTR                   PatchFileName,
    IN  LPCSTR                   OldFileName,
    OUT LPCSTR                   NewFileName,
    IN  ULONG                    ApplyOptionFlags,
    IN  PPATCH_PROGRESS_CALLBACK ProgressCallback,
    IN  PVOID                    CallbackContext
    )
    {
    HANDLE PatchFileHandle;
    HANDLE OldFileHandle;
    HANDLE NewFileHandle;
    BOOL   Success = FALSE;

    PatchFileHandle = CreateFileA(
                          PatchFileName,
                          GENERIC_READ,
                          FILE_SHARE_READ | FILE_SHARE_WRITE,
                          NULL,
                          OPEN_EXISTING,
                          FILE_FLAG_SEQUENTIAL_SCAN,
                          NULL
                          );

    if ( PatchFileHandle != INVALID_HANDLE_VALUE ) {

        OldFileHandle = CreateFileA(
                            OldFileName,
                            GENERIC_READ,
                            FILE_SHARE_READ | FILE_SHARE_WRITE,
                            NULL,
                            OPEN_EXISTING,
                            FILE_FLAG_SEQUENTIAL_SCAN,
                            NULL
                            );

        if ( OldFileHandle != INVALID_HANDLE_VALUE ) {

            NewFileHandle = CreateFileA(
                                NewFileName,
                                GENERIC_READ | GENERIC_WRITE,
                                FILE_SHARE_READ,
                                NULL,
                                CREATE_ALWAYS,
                                FILE_ATTRIBUTE_NORMAL,
                                NULL
                                );

            if ( NewFileHandle != INVALID_HANDLE_VALUE ) {

                Success = ApplyPatchToFileByHandlesEx(
                              PatchFileHandle,
                              OldFileHandle,
                              NewFileHandle,
                              ApplyOptionFlags,
                              ProgressCallback,
                              CallbackContext
                              );

                CloseHandle( NewFileHandle );

                if ( ! Success ) {
                    DeleteFileA( NewFileName );
                    }
                }

            CloseHandle( OldFileHandle );
            }

        CloseHandle( PatchFileHandle );
        }

    return Success;
    }


BOOL
PATCHAPI
TestApplyPatchToFileW(
    IN LPCWSTR PatchFileName,
    IN LPCWSTR OldFileName,
    IN ULONG   ApplyOptionFlags
    )
    {
    return ApplyPatchToFileW(
               PatchFileName,
               OldFileName,
               INVALID_HANDLE_VALUE,
               ApplyOptionFlags | APPLY_OPTION_TEST_ONLY
               );
    }


BOOL
PATCHAPI
ApplyPatchToFileW(
    IN  LPCWSTR PatchFileName,
    IN  LPCWSTR OldFileName,
    OUT LPCWSTR NewFileName,
    IN  ULONG   ApplyOptionFlags
    )
    {
    return ApplyPatchToFileExW(
               PatchFileName,
               OldFileName,
               NewFileName,
               ApplyOptionFlags,
               NULL,
               NULL
               );
    }


BOOL
PATCHAPI
ApplyPatchToFileExW(
    IN  LPCWSTR                  PatchFileName,
    IN  LPCWSTR                  OldFileName,
    OUT LPCWSTR                  NewFileName,
    IN  ULONG                    ApplyOptionFlags,
    IN  PPATCH_PROGRESS_CALLBACK ProgressCallback,
    IN  PVOID                    CallbackContext
    )
    {
    HANDLE PatchFileHandle;
    HANDLE OldFileHandle;
    HANDLE NewFileHandle;
    BOOL   Success = FALSE;

    PatchFileHandle = CreateFileW(
                          PatchFileName,
                          GENERIC_READ,
                          FILE_SHARE_READ | FILE_SHARE_WRITE,
                          NULL,
                          OPEN_EXISTING,
                          FILE_FLAG_SEQUENTIAL_SCAN,
                          NULL
                          );

    if ( PatchFileHandle != INVALID_HANDLE_VALUE ) {

        OldFileHandle = CreateFileW(
                            OldFileName,
                            GENERIC_READ,
                            FILE_SHARE_READ | FILE_SHARE_WRITE,
                            NULL,
                            OPEN_EXISTING,
                            FILE_FLAG_SEQUENTIAL_SCAN,
                            NULL
                            );

        if ( OldFileHandle != INVALID_HANDLE_VALUE ) {

            NewFileHandle = CreateFileW(
                                NewFileName,
                                GENERIC_READ | GENERIC_WRITE,
                                FILE_SHARE_READ,
                                NULL,
                                CREATE_ALWAYS,
                                FILE_ATTRIBUTE_NORMAL,
                                NULL
                                );

            if ( NewFileHandle != INVALID_HANDLE_VALUE ) {

                Success = ApplyPatchToFileByHandlesEx(
                              PatchFileHandle,
                              OldFileHandle,
                              NewFileHandle,
                              ApplyOptionFlags,
                              ProgressCallback,
                              CallbackContext
                              );

                CloseHandle( NewFileHandle );

                if ( ! Success ) {
                    DeleteFileW( NewFileName );
                    }
                }

            CloseHandle( OldFileHandle );
            }

        CloseHandle( PatchFileHandle );
        }

    return Success;
    }

#endif // ! PATCH_CREATE_CODE_ONLY
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mspatch\api\patchlzx.c ===
#include <precomp.h>

//
//  patchlzx.c
//
//  Author: Tom McGuire (tommcg) 2/97 - 9/97
//
//  Copyright (C) Microsoft, 1997-1998.
//
//  MICROSOFT CONFIDENTIAL
//


#define LZX_BLOCKSIZE  0x8000   // 32K
#define LZX_MINWINDOW  0x20000  // 128K


typedef struct _LZX_OUTPUT_CONTEXT {
    PUCHAR                   PatchBufferPointer;
    ULONG                    PatchBufferSize;
    ULONG                    PatchSize;
    BOOL                     DiscardOutput;
    } LZX_OUTPUT_CONTEXT, *PLZX_OUTPUT_CONTEXT;


ULONG
__fastcall
LzxWindowSize(
    IN ULONG OldDataSize,
    IN ULONG NewDataSize,
    IN DWORD OptionFlags
    )
    {
    ULONG WindowSize;
    ULONG DataSize;

    DataSize = ROUNDUP2( OldDataSize, LZX_BLOCKSIZE ) + NewDataSize;

    if ( OptionFlags & PATCH_OPTION_USE_LZX_LARGE ) {
        if ( DataSize > LZX_MAXWINDOW_32 ) {
             DataSize = LZX_MAXWINDOW_32;
             }
        }
    else {
        if ( DataSize > LZX_MAXWINDOW_8 ) {
             DataSize = LZX_MAXWINDOW_8;
             }
        }

    for ( WindowSize = LZX_MINWINDOW;
          WindowSize < DataSize;
          WindowSize <<= 1
        );

    return WindowSize;
    }


ULONG
__fastcall
LzxInsertSize(
    IN ULONG OldDataSize,
    IN DWORD OptionFlags
    )
    {

    if ( OptionFlags & PATCH_OPTION_USE_LZX_LARGE ) {
        if ( OldDataSize > LZX_MAXWINDOW_32 ) {
             OldDataSize = LZX_MAXWINDOW_32;
             }
        }
    else {
        if ( OldDataSize > LZX_MAXWINDOW_8 ) {
             OldDataSize = LZX_MAXWINDOW_8;
             }
        }

    return OldDataSize;
    }


//
//  Following group of functions and exported apis are exclusively for
//  creating patches.  If we're only compiling the apply code, ignore
//  this group of functions.
//

#ifndef PATCH_APPLY_CODE_ONLY


ULONG
WINAPI
EstimateLzxCompressionMemoryRequirement(
    IN ULONG OldDataSize,
    IN ULONG NewDataSize,
    IN ULONG OptionFlags
    )
    {
    ULONG WindowSize = LzxWindowSize( OldDataSize, NewDataSize, OptionFlags );

    //
    //  Currently the LZX engine requires 9 times the size of the window
    //  plus a fixed overhead of just under 0x1A0000 bytes (1.7MB).
    //

    return (( WindowSize * 9 ) + 0x1A0000 );
    }


int
__stdcall
MyLzxOutputCallback(
    PVOID  CallerContext,
    PUCHAR CompressedData,
    LONG   CompressedSize,
    LONG   UncompressedSize
    )
    {
    PLZX_OUTPUT_CONTEXT OutputContext = CallerContext;

    UNREFERENCED_PARAMETER( UncompressedSize );

    OutputContext->PatchSize += CompressedSize + sizeof( USHORT );

    if ( ! OutputContext->DiscardOutput ) {
        if ( OutputContext->PatchSize <= OutputContext->PatchBufferSize ) {
            *(UNALIGNED USHORT *)( OutputContext->PatchBufferPointer ) = (USHORT) CompressedSize;
            memcpy( OutputContext->PatchBufferPointer + sizeof( USHORT ), CompressedData, CompressedSize );
            OutputContext->PatchBufferPointer += CompressedSize + sizeof( USHORT );
            }
        }

    return TRUE;
    }


ULONG
WINAPI
CreateRawLzxPatchDataFromBuffers(
    IN  PVOID    OldDataBuffer,
    IN  ULONG    OldDataSize,
    IN  PVOID    NewDataBuffer,
    IN  ULONG    NewDataSize,
    IN  ULONG    PatchBufferSize,
    OUT PVOID    PatchBuffer,
    OUT ULONG   *PatchSize,
    IN  ULONG    OptionFlags,
    IN  PVOID    OptionData,
    IN  PFNALLOC pfnAlloc,
    IN  HANDLE   AllocHandle,
    IN  PPATCH_PROGRESS_CALLBACK ProgressCallback,
    IN  PVOID    CallbackContext,
    IN  ULONG    ProgressInitialValue,
    IN  ULONG    ProgressMaximumValue
    )
    {
    UP_IMAGE_NT_HEADERS32 NtHeader;
    LZX_OUTPUT_CONTEXT OutputContext;
    PVOID  LzxContext;
    ULONG  LzxWindow;
    ULONG  LzxOptE8;
    LONG   LzxStatus;
    PUCHAR BlockPointer;
    ULONG  BytesRemaining;
    ULONG  OddBytes;
    LONG   Estimate;
    BOOL   Success;
    ULONG  ErrorCode;

    UNREFERENCED_PARAMETER( OptionData );

    ErrorCode = ERROR_INVALID_PARAMETER;

    if ( OptionFlags & ( PATCH_OPTION_USE_LZX_A | PATCH_OPTION_USE_LZX_B )) {

        ErrorCode = ERROR_OUTOFMEMORY;

        OutputContext.DiscardOutput = TRUE;

        LzxWindow = LzxWindowSize( OldDataSize, NewDataSize, OptionFlags );

        Success = LZX_EncodeInit(
                      &LzxContext,
                      LzxWindow,
                      LZX_BLOCKSIZE,
                      pfnAlloc,
                      AllocHandle,
                      MyLzxOutputCallback,
                      &OutputContext
                      );

        if ( Success ) {

            ULONG ProgressPosition = ProgressInitialValue;

            ErrorCode        = ERROR_PATCH_ENCODE_FAILURE;
            BlockPointer     = OldDataBuffer;
            BytesRemaining   = LzxInsertSize( OldDataSize, OptionFlags );
            OddBytes         = BytesRemaining % LZX_BLOCKSIZE;

#ifdef TRACING
            EncTracingDefineOffsets(
                LzxWindow,
                OddBytes ? (LZX_BLOCKSIZE - OddBytes) : 0,
                OddBytes ? (BytesRemaining + LZX_BLOCKSIZE - OddBytes) : BytesRemaining
                );
#endif

            if ( OddBytes ) {

                PUCHAR PadBuffer = pfnAlloc( AllocHandle, LZX_BLOCKSIZE );

                if ( PadBuffer == NULL ) {
                    ErrorCode = ERROR_OUTOFMEMORY;
                    Success   = FALSE;
                    }
                else {

                    memcpy(
                        PadBuffer + LZX_BLOCKSIZE - OddBytes,
                        BlockPointer,
                        OddBytes
                        );

                    Success = LZX_EncodeInsertDictionary(
                                  LzxContext,
                                  PadBuffer,
                                  LZX_BLOCKSIZE
                                  );

                    if ( Success ) {

                        ProgressPosition += OddBytes;

                        Success = ProgressCallbackWrapper(
                                      ProgressCallback,
                                      CallbackContext,
                                      ProgressPosition,
                                      ProgressMaximumValue
                                      );

                        if ( ! Success ) {
                            ErrorCode = GetLastError();
                            }
                        }

                    BlockPointer   += OddBytes;
                    BytesRemaining -= OddBytes;
                    }
                }

            while (( BytesRemaining ) && ( Success )) {

                ASSERT(( BytesRemaining % LZX_BLOCKSIZE ) == 0 );

                Success = LZX_EncodeInsertDictionary(
                              LzxContext,
                              BlockPointer,
                              LZX_BLOCKSIZE
                              );

                if ( Success ) {

                    ProgressPosition += LZX_BLOCKSIZE;

                    Success = ProgressCallbackWrapper(
                                  ProgressCallback,
                                  CallbackContext,
                                  ProgressPosition,
                                  ProgressMaximumValue
                                  );

                    if ( ! Success ) {
                        ErrorCode = GetLastError();
                        }
                    }

                BlockPointer   += LZX_BLOCKSIZE;
                BytesRemaining -= LZX_BLOCKSIZE;
                }

            if ( Success ) {

                LZX_EncodeResetState( LzxContext );

                LzxOptE8 = 0;

                NtHeader = GetNtHeader( NewDataBuffer, NewDataSize );

                //
                //  If file has MZ signature AND it's NOT a PE image,
                //  OR it's a PE image AND it's an i386 image, turn on
                //  the i386-specific E8 call translation optimization.
                //

                if (( OptionFlags & PATCH_OPTION_USE_LZX_B ) &&
                    ((( NtHeader ) && ( NtHeader->FileHeader.Machine == IMAGE_FILE_MACHINE_I386 )) ||
                     (( ! NtHeader ) && ( *(UNALIGNED USHORT *)NewDataBuffer == 0x5A4D )))) {

                    LzxOptE8 = NewDataSize;
                    }

                OutputContext.PatchBufferSize    = PatchBufferSize;
                OutputContext.PatchBufferPointer = PatchBuffer;
                OutputContext.PatchSize          = 0;
                OutputContext.DiscardOutput      = FALSE;

                BlockPointer   = NewDataBuffer;
                BytesRemaining = NewDataSize;
                LzxStatus      = ENCODER_SUCCESS;
                Success        = TRUE;

                while (( BytesRemaining >= LZX_BLOCKSIZE ) && ( LzxStatus == ENCODER_SUCCESS ) && ( Success )) {

                    LzxStatus = LZX_Encode(
                                    LzxContext,
                                    BlockPointer,
                                    LZX_BLOCKSIZE,
                                    &Estimate,
                                    LzxOptE8
                                    );

                    if ( LzxStatus == ENCODER_SUCCESS ) {

                        ProgressPosition += LZX_BLOCKSIZE;

                        Success = ProgressCallbackWrapper(
                                      ProgressCallback,
                                      CallbackContext,
                                      ProgressPosition,
                                      ProgressMaximumValue
                                      );

                        if ( ! Success ) {
                            ErrorCode = GetLastError();
                            }
                        }

                    BlockPointer   += LZX_BLOCKSIZE;
                    BytesRemaining -= LZX_BLOCKSIZE;
                    }

                if (( BytesRemaining ) && ( LzxStatus == ENCODER_SUCCESS ) && ( Success )) {

                    LzxStatus = LZX_Encode(
                                    LzxContext,
                                    BlockPointer,
                                    BytesRemaining,
                                    &Estimate,
                                    LzxOptE8
                                    );

                    if ( LzxStatus == ENCODER_SUCCESS ) {

                        ProgressPosition += BytesRemaining;

                        Success = ProgressCallbackWrapper(
                                      ProgressCallback,
                                      CallbackContext,
                                      ProgressPosition,
                                      ProgressMaximumValue
                                      );

                        if ( ! Success ) {
                            ErrorCode = GetLastError();
                            }
                        }
                    }

                if (( LzxStatus == ENCODER_SUCCESS ) && ( Success )) {

                    Success = LZX_EncodeFlush( LzxContext );

                    if ( Success ) {

                        ErrorCode  = ERROR_INSUFFICIENT_BUFFER;
                        *PatchSize = OutputContext.PatchSize;

                        if ( OutputContext.PatchSize <= OutputContext.PatchBufferSize ) {

                            ErrorCode = NO_ERROR;

                            }
                        }
                    }
                }
            }
        }

    return ErrorCode;
    }


ULONG
WINAPI
RawLzxCompressBuffer(
    IN  PVOID    InDataBuffer,
    IN  ULONG    InDataSize,
    IN  ULONG    OutDataBufferSize,
    OUT PVOID    OutDataBuffer OPTIONAL,
    OUT PULONG   OutDataSize,
    IN  PFNALLOC pfnAlloc,
    IN  HANDLE   AllocHandle,
    IN  PPATCH_PROGRESS_CALLBACK ProgressCallback,
    IN  PVOID    CallbackContext,
    IN  ULONG    ProgressInitialValue,
    IN  ULONG    ProgressMaximumValue
    )
    {
    UP_IMAGE_NT_HEADERS32 NtHeader;
    LZX_OUTPUT_CONTEXT OutputContext;
    ULONG  ProgressPosition;
    PVOID  LzxContext;
    ULONG  LzxWindow;
    ULONG  LzxOptE8;
    LONG   LzxStatus;
    PUCHAR BlockPointer;
    ULONG  BytesRemaining;
    LONG   Estimate;
    BOOL   Success;
    ULONG  ErrorCode;

    if ( OutDataBufferSize == 0 ) {
         OutDataBuffer = NULL;
         }
    else if ( OutDataBuffer == NULL ) {
         OutDataBufferSize = 0;
         }

    ErrorCode = ERROR_OUTOFMEMORY;

    OutputContext.DiscardOutput      = OutDataBuffer ? FALSE : TRUE;
    OutputContext.PatchBufferSize    = OutDataBufferSize;
    OutputContext.PatchBufferPointer = OutDataBuffer;
    OutputContext.PatchSize          = 0;

    LzxWindow = LzxWindowSize( 0, InDataSize, 0 );

    Success = LZX_EncodeInit(
                  &LzxContext,
                  LzxWindow,
                  LZX_BLOCKSIZE,
                  pfnAlloc,
                  AllocHandle,
                  MyLzxOutputCallback,
                  &OutputContext
                  );

    if ( Success ) {

        LzxOptE8 = 0;
        NtHeader = GetNtHeader( InDataBuffer, InDataSize );

        //
        //  If file has MZ signature AND it's NOT a PE image,
        //  OR it's a PE image AND it's an i386 image, turn on
        //  the i386-specific E8 call translation optimization.
        //

        if ((( NtHeader ) && ( NtHeader->FileHeader.Machine == IMAGE_FILE_MACHINE_I386 )) ||
            (( ! NtHeader ) && ( *(UNALIGNED USHORT *)InDataBuffer == 0x5A4D ))) {

            LzxOptE8 = InDataSize;
            }

        ProgressPosition = ProgressInitialValue;
        ErrorCode        = ERROR_PATCH_ENCODE_FAILURE;
        BlockPointer     = InDataBuffer;
        BytesRemaining   = InDataSize;
        LzxStatus        = ENCODER_SUCCESS;
        Success          = TRUE;

        while (( BytesRemaining >= LZX_BLOCKSIZE ) && ( LzxStatus == ENCODER_SUCCESS ) && ( Success )) {

            LzxStatus = LZX_Encode(
                            LzxContext,
                            BlockPointer,
                            LZX_BLOCKSIZE,
                            &Estimate,
                            LzxOptE8
                            );

            if ( LzxStatus == ENCODER_SUCCESS ) {

                ProgressPosition += LZX_BLOCKSIZE;

                Success = ProgressCallbackWrapper(
                              ProgressCallback,
                              CallbackContext,
                              ProgressPosition,
                              ProgressMaximumValue
                              );

                if ( ! Success ) {
                    ErrorCode = GetLastError();
                    }
                }

            BlockPointer   += LZX_BLOCKSIZE;
            BytesRemaining -= LZX_BLOCKSIZE;
            }

        if (( BytesRemaining ) && ( LzxStatus == ENCODER_SUCCESS ) && ( Success )) {

            LzxStatus = LZX_Encode(
                            LzxContext,
                            BlockPointer,
                            BytesRemaining,
                            &Estimate,
                            LzxOptE8
                            );

            if ( LzxStatus == ENCODER_SUCCESS ) {

                ProgressPosition += BytesRemaining;

                Success = ProgressCallbackWrapper(
                              ProgressCallback,
                              CallbackContext,
                              ProgressPosition,
                              ProgressMaximumValue
                              );

                if ( ! Success ) {
                    ErrorCode = GetLastError();
                    }
                }
            }

        if (( LzxStatus == ENCODER_SUCCESS ) && ( Success )) {

            Success = LZX_EncodeFlush( LzxContext );

            if ( Success ) {

                if ( OutDataSize ) {
                    *OutDataSize = OutputContext.PatchSize;
                    }

                if (( OutDataBufferSize ) && ( OutputContext.PatchSize > OutDataBufferSize )) {
                    ErrorCode = ERROR_INSUFFICIENT_BUFFER;
                    }
                else {
                    ErrorCode = NO_ERROR;
                    }
                }
            }
        }

    return ErrorCode;
    }

#endif // ! PATCH_APPLY_CODE_ONLY


//
//  Following group of functions and exported apis are exclusively for
//  applying patches.  If we're only compiling the create code, ignore
//  this group of functions.
//

#ifndef PATCH_CREATE_CODE_ONLY


ULONG
WINAPI
EstimateLzxDecompressionMemoryRequirement(
    IN ULONG OldDataSize,
    IN ULONG NewDataSize,
    IN ULONG OptionFlags
    )
    {
    ULONG WindowSize = LzxWindowSize( OldDataSize, NewDataSize, OptionFlags );

    //
    //  Currently the LZX decompression engine requires the size of the
    //  window plus some slop and the size of the context.  We'll add 64K
    //  to cover the context size and slop.
    //

    return ( WindowSize + 0x10000 );
    }


ULONG
WINAPI
ApplyRawLzxPatchToBuffer(
    IN  PVOID    OldDataBuffer,
    IN  ULONG    OldDataSize,
    IN  PVOID    PatchDataBuffer,
    IN  ULONG    PatchDataSize,
    OUT PVOID    NewDataBuffer,
    IN  ULONG    NewDataSize,
    IN  ULONG    OptionFlags,
    IN  PVOID    OptionData,
    IN  PFNALLOC pfnAlloc,
    IN  HANDLE   AllocHandle,
    IN  PPATCH_PROGRESS_CALLBACK ProgressCallback,
    IN  PVOID    CallbackContext,
    IN  ULONG    ProgressInitialValue,
    IN  ULONG    ProgressMaximumValue
    )
    {
    PVOID LzxContext;
    ULONG LzxWindow;
    BOOL  Success;
    ULONG ErrorCode;

    UNREFERENCED_PARAMETER( OptionData );

    ErrorCode = ERROR_INVALID_PARAMETER;

    if ( OptionFlags & ( PATCH_OPTION_USE_LZX_A | PATCH_OPTION_USE_LZX_B )) {

        ErrorCode = ERROR_OUTOFMEMORY;

        LzxWindow = LzxWindowSize( OldDataSize, NewDataSize, OptionFlags );

        Success = LZX_DecodeInit(
                      &LzxContext,
                      LzxWindow,
                      pfnAlloc,
                      AllocHandle
                      );

        if ( Success ) {

            ErrorCode = ERROR_PATCH_DECODE_FAILURE;

            Success = LZX_DecodeInsertDictionary(
                          LzxContext,
                          OldDataBuffer,
                          LzxInsertSize( OldDataSize, OptionFlags )
                          );

            if ( Success ) {

                PUCHAR CompressedInputPointer     = PatchDataBuffer;
                PUCHAR CompressedInputExtent      = CompressedInputPointer + PatchDataSize;
                PUCHAR UncompressedOutputPointer  = NewDataBuffer;
                ULONG  UncompressedBytesRemaining = NewDataSize;
                ULONG  ProgressPosition           = ProgressInitialValue;
                LONG   LzxStatus                  = 0;
                LONG   ActualSize;
                ULONG  UncompressedBlockSize;
                ULONG  CompressedBlockSize;

                while (( UncompressedBytesRemaining ) && ( LzxStatus == 0 )) {

                    UncompressedBlockSize = ( UncompressedBytesRemaining > LZX_BLOCKSIZE ) ? LZX_BLOCKSIZE : UncompressedBytesRemaining;

                    CompressedBlockSize = *(UNALIGNED USHORT *)( CompressedInputPointer );

                    CompressedInputPointer += sizeof( USHORT );

                    if (( CompressedInputPointer + CompressedBlockSize ) > CompressedInputExtent ) {
                        LzxStatus = 1;
                        break;
                        }

                    LzxStatus = LZX_Decode(
                                    LzxContext,
                                    UncompressedBlockSize,
                                    CompressedInputPointer,
                                    CompressedBlockSize,
                                    UncompressedOutputPointer,
                                    UncompressedBlockSize,
                                    &ActualSize
                                    );

                    CompressedInputPointer     += CompressedBlockSize;
                    UncompressedOutputPointer  += ActualSize;
                    UncompressedBytesRemaining -= ActualSize;
                    ProgressPosition           += ActualSize;

                    Success = ProgressCallbackWrapper(
                                  ProgressCallback,
                                  CallbackContext,
                                  ProgressPosition,
                                  ProgressMaximumValue
                                  );

                    if ( ! Success ) {
                        ErrorCode = GetLastError();
                        LzxStatus = 1;
                        }
                    }

                if ( LzxStatus == 0 ) {
                    ErrorCode = NO_ERROR;
                    }
                }
            }
        }

    return ErrorCode;
    }

#endif // ! PATCH_CREATE_CODE_ONLY
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mspatch\api\patchprv.h ===
//
//  patchprv.h
//
//  Private interface options for creating patch files.
//
//  Author: Tom McGuire (tommcg) 2/98
//
//  Copyright (C) Microsoft, 1997-1998.
//
//  MICROSOFT CONFIDENTIAL
//

#ifndef _PATCHPRV_H_
#define _PATCHPRV_H_

#ifdef __cplusplus
extern "C" {
#endif

#define PATCH_SIGNATURE     '91AP'          // PA19 patch signature

typedef struct _RIFT_ENTRY {
    ULONG OldFileRva;
    ULONG NewFileRva;
    } RIFT_ENTRY, *PRIFT_ENTRY;

typedef struct _RIFT_TABLE {
    ULONG       RiftEntryCount;
    ULONG       RiftEntryAlloc;
    PRIFT_ENTRY RiftEntryArray;
    PUCHAR      RiftUsageArray;
    } RIFT_TABLE, *PRIFT_TABLE;

typedef struct _PATCH_HEADER_OLD_FILE_INFO {
    HANDLE              OldFileHandle;
    ULONG               OldFileSize;
    ULONG               OldFileCrc;
    ULONG               PatchDataSize;
    ULONG               IgnoreRangeCount;
    PPATCH_IGNORE_RANGE IgnoreRangeArray;
    ULONG               RetainRangeCount;
    PPATCH_RETAIN_RANGE RetainRangeArray;
    RIFT_TABLE          RiftTable;
    } HEADER_OLD_FILE_INFO, *PHEADER_OLD_FILE_INFO;

typedef struct _PATCH_HEADER_INFO {
    ULONG Signature;
    ULONG OptionFlags;
    ULONG ExtendedOptionFlags;
    PVOID OptionData;
    ULONG NewFileCoffBase;
    ULONG NewFileCoffTime;
    ULONG NewFileResTime;
    ULONG NewFileTime;
    ULONG NewFileSize;
    ULONG NewFileCrc;
    ULONG OldFileCount;
    PHEADER_OLD_FILE_INFO OldFileInfoArray;
    } PATCH_HEADER_INFO, *PPATCH_HEADER_INFO;


BOOL
ProgressCallbackWrapper(
    IN PPATCH_PROGRESS_CALLBACK ProgressCallback,
    IN PVOID                    CallbackContext,
    IN ULONG                    CurrentPosition,
    IN ULONG                    MaximumPosition
    );

BOOL
WINAPIV
NormalizeOldFileImageForPatching(
    IN PVOID FileMappedImage,
    IN ULONG FileSize,
    IN ULONG OptionFlags,
    IN PVOID OptionData,
    IN ULONG NewFileCoffBase,
    IN ULONG NewFileCoffTime,
    IN ULONG IgnoreRangeCount,
    IN PPATCH_IGNORE_RANGE IgnoreRangeArray,
    IN ULONG RetainRangeCount,
    IN PPATCH_RETAIN_RANGE RetainRangeArray,
    ...
    );

BOOL
WINAPIV
TransformOldFileImageForPatching(
    IN ULONG TransformOptions,
    IN PVOID OldFileMapped,
    IN ULONG OldFileSize,
    IN ULONG NewFileResTime,
    IN PRIFT_TABLE RiftTable,
    ...
    );


//
//  The following is a private flag to indicate external rift data is being
//  specified in the OptionData->OldFileSymbolPathArray[ OldFileIndex ] field
//  (really a PRIFT_TABLE pointer).
//

#define PATCH_SYMBOL_EXTERNAL_RIFT      PATCH_SYMBOL_RESERVED1

//
//  The following is an internal flag stored in the patch header to indicate
//  the ExtendedOptionFlags field is present (non-zero) in the header.  It is
//  never necessary to specify this flag when creating a patch.
//

#define PATCH_OPTION_EXTENDED_OPTIONS   PATCH_OPTION_RESERVED1

//
//  Following are flags in the ExtendedOptionFlags field.
//

#define PATCH_TRANSFORM_NO_RELOCS       0x00000001  // don't xform relocs
#define PATCH_TRANSFORM_NO_IMPORTS      0x00000002  // don't xform imports
#define PATCH_TRANSFORM_NO_EXPORTS      0x00000004  // don't xform exports
#define PATCH_TRANSFORM_NO_RELJMPS      0x00000008  // don't xform E9 or 0F 8x instructions
#define PATCH_TRANSFORM_NO_RELCALLS     0x00000010  // don't xform E8 instructions
#define PATCH_TRANSFORM_NO_RESOURCE     0x00000020  // don't xform resources



VOID
__fastcall
RiftQsort(
    PRIFT_ENTRY LowerBound,
    PRIFT_ENTRY UpperBound
    );


#ifdef __cplusplus
}
#endif

#endif // _PATCHPRV_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mspatch\api\pestuff.c ===
#include <precomp.h>

//
//  pestuff.c
//
//  Author: Tom McGuire (tommcg) 2/97 - 3/98
//
//  Copyright (C) Microsoft, 1997-1999.
//
//  MICROSOFT CONFIDENTIAL
//


#define MAX_SYMBOL_NAME_LENGTH  2048


typedef struct _SYMBOL_CONTEXT SYMBOL_CONTEXT, *PSYMBOL_CONTEXT;

struct _SYMBOL_CONTEXT {
    SYMBOL_TREE NewDecoratedSymbolTree;
    SYMBOL_TREE NewUndecoratedSymbolTree;
    SYMBOL_TREE OldUndecoratedSymbolTree;
    ULONG_PTR   NewImageBase;
    ULONG_PTR   OldImageBase;
    ULONG       SymbolOptionFlags;
    PRIFT_TABLE RiftTable;
#ifdef TESTCODE
    HANDLE      OutFile;
#endif
    };


typedef struct _RELOC_ARRAY_ENTRY RELOC_ARRAY_ENTRY, *PRELOC_ARRAY_ENTRY;

struct _RELOC_ARRAY_ENTRY {
    ULONG  RelocRva;
    UCHAR  RelocType;
    USHORT HighAdjValue;
    };


#ifndef PATCH_APPLY_CODE_ONLY

#ifdef TESTCODE
ULONG CountDecoratedMatches;
ULONG CountUndecoratedMatches;
#endif

LPCSTR ImagehlpImportNames[] = {
           "SymInitialize",
           "SymGetOptions",
           "SymSetOptions",
           "SymLoadModule",
           "SymGetModuleInfo",
           "SymEnumerateSymbols",
           "UnDecorateSymbolName",
           "SymUnloadModule",
           "SymCleanup"
           };

#define COUNT_IMAGEHLP_IMPORTS ( sizeof( ImagehlpImportNames ) / sizeof( ImagehlpImportNames[ 0 ] ))

//
//  NOTE:  Above names must be in SAME ORDER as the prototypes below.
//

union {

    VOID ( __stdcall * Imports[ COUNT_IMAGEHLP_IMPORTS ] )();

    struct {
        BOOL  ( __stdcall * SymInitialize        )( HANDLE, LPCSTR, BOOL );
        DWORD ( __stdcall * SymGetOptions        )( VOID );
        DWORD ( __stdcall * SymSetOptions        )( DWORD );
        DWORD ( __stdcall * SymLoadModule        )( HANDLE, HANDLE, LPCSTR, LPCSTR, DWORD_PTR, DWORD );
        BOOL  ( __stdcall * SymGetModuleInfo     )( HANLDE, DWORD, PIMAGEHLP_MODULE );
        BOOL  ( __stdcall * SymEnumerateSymbols  )( HANDLE, DWORD_PTR, PSYM_ENUMSYMBOLS_CALLBACK, PVOID );
        BOOL  ( __stdcall * UnDecorateSymbolName )( LPCSTR, LPSTR, DWORD, DWORD );
        BOOL  ( __stdcall * SymUnloadModule      )( HANDLE, DWORD_PTR );
        BOOL  ( __stdcall * SymCleanup           )( HANDLE );
        };
    } Imagehlp;


BOOL ImagehlpCritSectInitialized;
CRITICAL_SECTION ImagehlpCritSect;
HANDLE hLibImagehlp;
HANDLE hProc;
IMAGEHLP_MODULE ImagehlpModuleInfo;

VOID
InitImagehlpCritSect(
    VOID
    )
    {
    if ( ! ImagehlpCritSectInitialized ) {
        InitializeCriticalSection( &ImagehlpCritSect );
        ImagehlpCritSectInitialized = TRUE;
        hProc = GetCurrentProcess();
        }
    }


BOOL
LoadImagehlp(
    VOID
    )
    {
    HANDLE hLib;
    ULONG i;

    if ( Imagehlp.Imports[ COUNT_IMAGEHLP_IMPORTS - 1 ] == NULL ) {

        hLib = LoadLibrary( "imagehlp.dll" );

        if ( hLib == NULL ) {
            return FALSE;
            }

        for ( i = 0; i < COUNT_IMAGEHLP_IMPORTS; i++ ) {

            Imagehlp.Imports[ i ] = GetProcAddress( hLib, ImagehlpImportNames[ i ] );

            if ( Imagehlp.Imports[ i ] == NULL ) {

                FreeLibrary( hLib );
                return FALSE;
                }
            }

        hLibImagehlp = hLib;
        }

    return TRUE;
    }


#ifdef BUILDING_PATCHAPI_DLL

VOID
UnloadImagehlp(
    VOID
    )
    {
    if ( hLibImagehlp ) {
        FreeLibrary( hLibImagehlp );
        hLibImagehlp = NULL;
        Imagehlp.Imports[ COUNT_IMAGEHLP_IMPORTS - 1 ] = NULL;
        DeleteCriticalSection( &ImagehlpCritSect );
        ImagehlpCritSectInitialized = FALSE;
        }
    }

#endif // BUILDING_PATCHAPI_DLL

#endif // ! PATCH_APPLY_CODE_ONLY


UP_IMAGE_NT_HEADERS32
__fastcall
GetNtHeader(
    IN PVOID MappedFile,
    IN ULONG MappedFileSize
    )
    {
    UP_IMAGE_DOS_HEADER   DosHeader;
    UP_IMAGE_NT_HEADERS32 RetHeader;
    UP_IMAGE_NT_HEADERS32 NtHeader;

    RetHeader = NULL;

    __try {

        if ( MappedFileSize >= 0x200 ) {

            DosHeader = (UP_IMAGE_DOS_HEADER) MappedFile;

            if ( DosHeader->e_magic == IMAGE_DOS_SIGNATURE ) {

                NtHeader = (UP_IMAGE_NT_HEADERS32)((PUCHAR) MappedFile + DosHeader->e_lfanew );

                if (((PUCHAR) NtHeader + sizeof( IMAGE_NT_HEADERS32 )) <= ((PUCHAR) MappedFile + MappedFileSize )) {

                    if ( NtHeader->Signature == IMAGE_NT_SIGNATURE ) {

                        if (NtHeader->OptionalHeader.Magic == IMAGE_NT_OPTIONAL_HDR32_MAGIC) {

                            RetHeader = NtHeader;

                            }
                        }
                    }
                }
            }
        }
    __except( EXCEPTION_EXECUTE_HANDLER ) {
        }

    return RetHeader;
    }


BOOL
__fastcall
IsImageRvaInExecutableSection(
    IN UP_IMAGE_NT_HEADERS32 NtHeader,
    IN ULONG Rva
    )
    {
    UP_IMAGE_SECTION_HEADER SectionHeader;
    ULONG SectionCount;
    ULONG i;

    SectionHeader = IMAGE_FIRST_SECTION( NtHeader );
    SectionCount  = NtHeader->FileHeader.NumberOfSections;

    for ( i = 0; i < SectionCount; i++ ) {
        if (( Rva >= SectionHeader[ i ].VirtualAddress ) &&
            ( Rva <  SectionHeader[ i ].VirtualAddress + SectionHeader[ i ].Misc.VirtualSize )) {

            return (( SectionHeader[ i ].Characteristics & IMAGE_SCN_MEM_EXECUTE ) ? TRUE : FALSE );
            }
        }

    return FALSE;
    }


ULONG
__fastcall
ImageRvaToFileOffset(
    IN UP_IMAGE_NT_HEADERS32 NtHeader,
    IN ULONG Rva
    )
    {
    UP_IMAGE_SECTION_HEADER SectionHeader;
    ULONG SectionCount;
    ULONG i;

    if ( Rva < NtHeader->OptionalHeader.SizeOfHeaders ) {
        return Rva;
        }

    SectionHeader = IMAGE_FIRST_SECTION( NtHeader );
    SectionCount  = NtHeader->FileHeader.NumberOfSections;

    for ( i = 0; i < SectionCount; i++ ) {
        if (( Rva >= SectionHeader[ i ].VirtualAddress ) &&
            ( Rva <  SectionHeader[ i ].VirtualAddress + SectionHeader[ i ].SizeOfRawData )) {

            return ( SectionHeader[ i ].PointerToRawData + ( Rva - SectionHeader[ i ].VirtualAddress ));
            }
        }

    return 0;
    }


PVOID
__fastcall
ImageRvaToMappedAddress(
    IN UP_IMAGE_NT_HEADERS32 NtHeader,
    IN ULONG Rva,
    IN PVOID MappedBase,
    IN ULONG MappedSize
    )
    {
    ULONG MappedOffset = ImageRvaToFileOffset( NtHeader, Rva );

    if (( MappedOffset ) && ( MappedOffset < MappedSize )) {
        return ((PUCHAR)MappedBase + MappedOffset );
        }

    return NULL;
    }

ULONG
__fastcall
ImageVaToFileOffset(
    IN UP_IMAGE_NT_HEADERS32 NtHeader,
    IN ULONG Va
    )
    {
    return ImageRvaToFileOffset( NtHeader, Va - NtHeader->OptionalHeader.ImageBase );
    }


PVOID
__fastcall
ImageVaToMappedAddress(
    IN UP_IMAGE_NT_HEADERS32 NtHeader,
    IN ULONG Va,
    IN PVOID MappedBase,
    IN ULONG MappedSize
    )
    {
    return ImageRvaToMappedAddress( NtHeader, Va - NtHeader->OptionalHeader.ImageBase, MappedBase, MappedSize );
    }


ULONG
__fastcall
ImageDirectoryRvaAndSize(
    IN  UP_IMAGE_NT_HEADERS32 NtHeader,
    IN  ULONG  DirectoryIndex,
    OUT PULONG DirectorySize
    )
    {
    if ( DirectoryIndex < NtHeader->OptionalHeader.NumberOfRvaAndSizes ) {

        if ( DirectorySize ) {
            *DirectorySize = NtHeader->OptionalHeader.DataDirectory[ DirectoryIndex ].Size;
            }

        return NtHeader->OptionalHeader.DataDirectory[ DirectoryIndex ].VirtualAddress;
        }

    return 0;
    }


ULONG
__fastcall
ImageDirectoryOffsetAndSize(
    IN  UP_IMAGE_NT_HEADERS32 NtHeader,
    IN  ULONG  DirectoryIndex,
    OUT PULONG DirectorySize
    )
    {
    ULONG Rva = ImageDirectoryRvaAndSize( NtHeader, DirectoryIndex, DirectorySize );

    if ( Rva ) {
        return ImageRvaToFileOffset( NtHeader, Rva );
        }

    return 0;
    }


PVOID
__fastcall
ImageDirectoryMappedAddress(
    IN  UP_IMAGE_NT_HEADERS32 NtHeader,
    IN  ULONG  DirectoryIndex,
    OUT PULONG DirectorySize,
    IN  PUCHAR MappedBase,
    IN  ULONG  MappedSize
    )
    {
    PUCHAR Directory;
    ULONG  LocalSize;
    ULONG  Rva;

    Rva = ImageDirectoryRvaAndSize( NtHeader, DirectoryIndex, &LocalSize );

    Directory = ImageRvaToMappedAddress( NtHeader, Rva, MappedBase, MappedSize );

    if (( Directory ) && (( Directory + LocalSize ) <= ( MappedBase + MappedSize ))) {

        if ( DirectorySize ) {
            *DirectorySize = LocalSize;
            }

        return Directory;
        }

    return NULL;
    }


ULONG
__fastcall
FileOffsetToImageRva(
    IN UP_IMAGE_NT_HEADERS32 NtHeader,
    IN ULONG FileOffset
    )
    {
    UP_IMAGE_SECTION_HEADER SectionHeader;
    ULONG SectionCount;
    ULONG i;

    SectionHeader = IMAGE_FIRST_SECTION( NtHeader );
    SectionCount  = NtHeader->FileHeader.NumberOfSections;

    for ( i = 0; i < SectionCount; i++ ) {
        if (( FileOffset >= SectionHeader[ i ].PointerToRawData ) &&
            ( FileOffset <  SectionHeader[ i ].PointerToRawData + SectionHeader[ i ].SizeOfRawData )) {

            return ( SectionHeader[ i ].VirtualAddress + ( FileOffset - SectionHeader[ i ].PointerToRawData ));
            }
        }

    return 0;
    }


ULONG
MappedAddressToImageRva(
    IN UP_IMAGE_NT_HEADERS32 NtHeader,
    IN PVOID MappedAddress,
    IN PVOID MappedFile
    )
    {
    LONG FileOffset = (LONG)((PUCHAR)MappedAddress - (PUCHAR)MappedFile);

    if ( FileOffset > 0 ) {
        return FileOffsetToImageRva( NtHeader, FileOffset );
        }

    return 0;
    }


BOOL
RebaseMappedImage(
    IN PUCHAR MappedFile,
    IN ULONG  FileSize,
    IN UP_IMAGE_NT_HEADERS32 NtHeader,
    IN ULONG  NewBase
    )
    {
    UP_IMAGE_BASE_RELOCATION RelocBlock;
    LONG                   RelocAmount;
    LONG                   RelocDirRemaining;
    ULONG                  RelocDirSize;
    PUCHAR                 RelocBlockMa;
    PUCHAR                 RelocFixupMa;
    ULONG                  RelocCount;
    USHORT UNALIGNED*      RelocEntry;
    PUCHAR                 MappedFileEnd;
    BOOL                   Modified;

    //
    //  Carefully rebase the image, ignoring invalid info as much as possible
    //  without taking an access violation.  We don't want to use try/except
    //  here because this code needs to be workable without any imports from
    //  kernel32.dll.  This code is not intended to catch errors in invalid
    //  rebase info -- it is intended to silently do the best it can at
    //  rebasing the image in memory.  If the rebase info is valid, it will
    //  correctly rebase the image.  If the rebase info is not valid, it will
    //  attempt to avoid causing an access violation.
    //

    ASSERT( NtHeader->OptionalHeader.ImageBase != NewBase );
    ASSERT(( NewBase & 0x0000FFFF ) == 0 );
    ASSERT(( NewBase & 0xFFFF0000 ) != 0 );

    Modified      = FALSE;
    MappedFileEnd = MappedFile + FileSize;
    RelocAmount   = NewBase - NtHeader->OptionalHeader.ImageBase;

    RelocBlock = ImageDirectoryMappedAddress( NtHeader, IMAGE_DIRECTORY_ENTRY_BASERELOC, &RelocDirSize, MappedFile, FileSize );

    if ( RelocBlock ) {

        NtHeader->OptionalHeader.ImageBase = NewBase;
        Modified = TRUE;

        RelocDirRemaining = (LONG)RelocDirSize;

        while ( RelocDirRemaining > 0 ) {

            if (( RelocBlock->SizeOfBlock <= (ULONG)RelocDirRemaining ) &&
                ( RelocBlock->SizeOfBlock > sizeof( IMAGE_BASE_RELOCATION ))) {

                //
                //  ImageRvaToMappedAddress returns NULL if the Rva is zero,
                //  but that is a valid base address of a reloc block.  Use
                //  ImageRvaToFileOffset instead.
                //

                RelocBlockMa = MappedFile + ImageRvaToFileOffset( NtHeader, RelocBlock->VirtualAddress );

                if ( RelocBlockMa ) {

                    RelocEntry = (PUSHORT)((PUCHAR)RelocBlock + sizeof( IMAGE_BASE_RELOCATION ));
                    RelocCount = ( RelocBlock->SizeOfBlock - sizeof( IMAGE_BASE_RELOCATION )) / sizeof( USHORT );

                    while ( RelocCount-- ) {

                        RelocFixupMa = RelocBlockMa + ( *RelocEntry & 0x0FFF );

                        if ( RelocFixupMa < MappedFileEnd ) {

                            switch ( *RelocEntry >> 12 ) {

                                case IMAGE_REL_BASED_HIGHLOW:

                                    *(UNALIGNED LONG *)RelocFixupMa += RelocAmount;
                                    break;

                                case IMAGE_REL_BASED_LOW:

                                    *(UNALIGNED USHORT *)RelocFixupMa = (USHORT)( *(UNALIGNED SHORT *)RelocFixupMa + RelocAmount );
                                    break;

                                case IMAGE_REL_BASED_HIGH:

                                    *(UNALIGNED USHORT *)RelocFixupMa = (USHORT)((( *(UNALIGNED USHORT *)RelocFixupMa << 16 ) + RelocAmount ) >> 16 );
                                    break;

                                case IMAGE_REL_BASED_HIGHADJ:

                                    ++RelocEntry;
                                    --RelocCount;

                                    *(UNALIGNED USHORT *)RelocFixupMa = (USHORT)((( *(UNALIGNED USHORT *)RelocFixupMa << 16 ) + *(UNALIGNED SHORT *)RelocEntry + RelocAmount + 0x8000 ) >> 16 );
                                    break;

                                //
                                //  Just skip and continue if we don't
                                //  recognize the reloc type.
                                //

                                }
                            }

                        ++RelocEntry;

                        }
                    }
                }

            RelocDirRemaining -= RelocBlock->SizeOfBlock;
            RelocBlock = (UP_IMAGE_BASE_RELOCATION)((PUCHAR)RelocBlock + RelocBlock->SizeOfBlock );

            }
        }

    return Modified;
    }


BOOL
UnBindMappedImage(
    IN PUCHAR MappedFile,
    IN ULONG  FileSize,
    IN UP_IMAGE_NT_HEADERS32 NtHeader
    )
    {
    UP_IMAGE_SECTION_HEADER  SectionHeader;
    UP_IMAGE_IMPORT_DESCRIPTOR ImportDesc;
    ULONG                    SectionCount;
    DWORDLONG                SectionName;
    PVOID                    BoundImportDir;
    ULONG                    BoundImportSize;
    ULONG UNALIGNED*         OriginalIat;
    ULONG UNALIGNED*         BoundIat;
    PUCHAR                   MappedFileEnd;
    BOOL                     Modified;
    ULONG                    i;

    Modified       = FALSE;
    MappedFileEnd  = MappedFile + FileSize;
    BoundImportDir = ImageDirectoryMappedAddress( NtHeader, IMAGE_DIRECTORY_ENTRY_BOUND_IMPORT, &BoundImportSize, MappedFile, FileSize );

    if ( BoundImportDir ) {

        //
        //  Zero the bound import directory and pointers to bound
        //  import directory.
        //

        ZeroMemory( BoundImportDir, BoundImportSize );

        NtHeader->OptionalHeader.DataDirectory[ IMAGE_DIRECTORY_ENTRY_BOUND_IMPORT ].VirtualAddress = 0;
        NtHeader->OptionalHeader.DataDirectory[ IMAGE_DIRECTORY_ENTRY_BOUND_IMPORT ].Size           = 0;

        Modified = TRUE;
        }

    //
    //  Now walk imports and zero the TimeDate and
    //  ForwarderChain fields.
    //

    ImportDesc = ImageDirectoryMappedAddress( NtHeader, IMAGE_DIRECTORY_ENTRY_IMPORT, NULL, MappedFile, FileSize );

    if ( ImportDesc ) {

        while (((ULONG_PTR)ImportDesc < ((ULONG_PTR)MappedFileEnd - sizeof( IMAGE_IMPORT_DESCRIPTOR ))) &&
               ( ImportDesc->Characteristics )) {

            if ( ImportDesc->TimeDateStamp ) {

                //
                //  This is a bound import.  Copy the unbound
                //  IAT over the bound IAT to restore.
                //

                ImportDesc->TimeDateStamp = 0;
                Modified = TRUE;

                OriginalIat = ImageRvaToMappedAddress( NtHeader, (ULONG)ImportDesc->OriginalFirstThunk, MappedFile, FileSize );
                BoundIat    = ImageRvaToMappedAddress( NtHeader, (ULONG)ImportDesc->FirstThunk,         MappedFile, FileSize );

                if (( OriginalIat ) && ( BoundIat )) {

                    while (((PUCHAR)OriginalIat < MappedFileEnd ) &&
                           ((PUCHAR)BoundIat    < MappedFileEnd ) &&
                           ( *OriginalIat )) {

                        *BoundIat++ = *OriginalIat++;
                        }
                    }
                }

            if ( ImportDesc->ForwarderChain ) {
                 ImportDesc->ForwarderChain = 0;
                 Modified = TRUE;
                 }

            ++ImportDesc;
            }
        }

    //
    //  The bind utility marks the .idata section as read-only so we want to
    //  change it back to read-write.
    //

    SectionHeader = IMAGE_FIRST_SECTION( NtHeader );
    SectionCount  = NtHeader->FileHeader.NumberOfSections;

    for ( i = 0; i < SectionCount; i++ ) {

        SectionName = *(UNALIGNED DWORDLONG*)( &SectionHeader[ i ].Name );
        SectionName |= 0x2020202020202020;  // fast lower case

        if ( SectionName == 0x202061746164692E ) {      // ".idata  "

            if ( ! ( SectionHeader[ i ].Characteristics & IMAGE_SCN_MEM_WRITE )) {

                SectionHeader[ i ].Characteristics |= ( IMAGE_SCN_MEM_READ | IMAGE_SCN_MEM_WRITE );
                Modified = TRUE;
                }

            break;
            }
        }

    return Modified;
    }


BOOL
SmashLockPrefixesInMappedImage(
    IN PUCHAR MappedFile,
    IN ULONG  FileSize,
    IN UP_IMAGE_NT_HEADERS32 NtHeader,
    IN UCHAR  NewOpCode      // X86_OPCODE_NOP or X86_OPCODE_LOCK
    )
    {
    UP_IMAGE_LOAD_CONFIG_DIRECTORY32 LoadConfig;
    ULONG UNALIGNED* LockPrefixEntry;
    PUCHAR LockPrefixInstruction;
    BOOL   Modified;

    Modified   = FALSE;
    LoadConfig = ImageDirectoryMappedAddress( NtHeader, IMAGE_DIRECTORY_ENTRY_LOAD_CONFIG, NULL, MappedFile, FileSize );

    if ( LoadConfig ) {

        if ( LoadConfig->LockPrefixTable ) {

            //
            //  The LoadConfig->LockPrefixTable field and
            //  the lock prefix addresses are stored in the
            //  image as image VA, not RVA values.
            //

            LockPrefixEntry = ImageVaToMappedAddress( NtHeader, LoadConfig->LockPrefixTable, MappedFile, FileSize );

            if ( LockPrefixEntry ) {

                while ( *LockPrefixEntry ) {

                    LockPrefixInstruction = ImageVaToMappedAddress( NtHeader, *LockPrefixEntry, MappedFile, FileSize );

                    if ( LockPrefixInstruction ) {

                        if ( *LockPrefixInstruction != NewOpCode ) {

                            //
                            //  Lock prefix instruction is not what we want,
                            //  so modify it.
                            //

                            *LockPrefixInstruction = NewOpCode;
                            Modified = TRUE;
                            }
                        }

                    ++LockPrefixEntry;

                    }
                }
            }
        }

    return Modified;
    }


USHORT
ChkSum(
    IN USHORT  Initial,
    IN PUSHORT Buffer,
    IN ULONG   Bytes
    )
    {
    USHORT UNALIGNED* p = Buffer;
    ULONG WordsRemaining = Bytes / 2;
    ULONG WordsInChunk;
    ULONG SumChunk;
    ULONG SumTotal;

    SumTotal = Initial;

    while ( WordsRemaining ) {

        WordsInChunk = WordsRemaining;

        if ( WordsInChunk > 0x10000 ) {
             WordsInChunk = 0x10000;
             }

        WordsRemaining -= WordsInChunk;

        SumChunk = 0;

        do  {
            SumChunk += *p++;
            }
        while ( --WordsInChunk != 0 );

        SumTotal += ( SumChunk >> 16 ) + ( SumChunk & 0xFFFF );
        }

    if ( Bytes % 2 ) {

        SumTotal += *((PBYTE) p);
        }

    return (USHORT)(( SumTotal >> 16 ) + ( SumTotal & 0xFFFF ));
    }


BOOL
NormalizeCoffImage(
    IN OUT UP_IMAGE_NT_HEADERS32 NtHeader,
    IN OUT PUCHAR MappedFile,
    IN     ULONG  FileSize,
    IN     ULONG  OptionFlags,
    IN     PVOID  OptionData,
    IN     ULONG  NewFileCoffBase,
    IN     ULONG  NewFileCoffTime
    )
    {
    BOOL Modified = FALSE;

    UNREFERENCED_PARAMETER( OptionData );

    if ( ! ( OptionFlags & PATCH_OPTION_NO_REBASE )) {

        if (( NewFileCoffTime != 0 ) && ( NtHeader->FileHeader.TimeDateStamp != NewFileCoffTime )) {
             NtHeader->FileHeader.TimeDateStamp = NewFileCoffTime;
             Modified = TRUE;
             }

        if (( NewFileCoffBase != 0 ) && ( NtHeader->OptionalHeader.ImageBase != NewFileCoffBase )) {
            Modified |= RebaseMappedImage( MappedFile, FileSize, NtHeader, NewFileCoffBase );
            }
        }

    if ( ! ( OptionFlags & PATCH_OPTION_NO_BINDFIX )) {
        Modified |= UnBindMappedImage( MappedFile, FileSize, NtHeader );
        }

    if ( ! ( OptionFlags & PATCH_OPTION_NO_LOCKFIX )) {
        Modified |= SmashLockPrefixesInMappedImage( MappedFile, FileSize, NtHeader, X86_OPCODE_LOCK );
        }

    //
    //  If the target file has zero checksum (PATCH_OPTION_NO_CHECKSUM),
    //  set the checksum in this image to zero.
    //
    //  Otherwise, if we either modified the image or if the image has
    //  a zero checksum, recompute the correct checksum.
    //

    if ( OptionFlags & PATCH_OPTION_NO_CHECKSUM ) {

        if ( NtHeader->OptionalHeader.CheckSum != 0 ) {
             NtHeader->OptionalHeader.CheckSum = 0;
             Modified = TRUE;
             }
        }

    else {

        if ( Modified ) {
             (ULONG)( NtHeader->OptionalHeader.CheckSum ) = 0;
             NtHeader->OptionalHeader.CheckSum = ChkSum( 0, (PVOID)MappedFile, FileSize ) + FileSize;
             }
        }

    return Modified;
    }


//
//  For some odd reason, the VC4 compiler says there is unreachable code
//  in the GetNewRvaFromRiftTable and FindRiftTableEntryForOldRva functions,
//  but I can't find it by inspection, and the VC5 and VC6 compilers don't
//  complain about it, so it's probably just a VC4 issue.  So, if the compiler
//  version is previous to VC5, disable this particular warning.
//

#if ( _MSC_VER < 1100 )
#pragma warning( disable: 4702 )    // unreachable code
#endif

ULONG
__fastcall
GetNewRvaFromRiftTable(
    IN PRIFT_TABLE RiftTable,
    IN ULONG OldRva
    )
    {
    PRIFT_ENTRY RiftEntryArray;
    ULONG NewRva;
    ULONG Index;
    ULONG MinIndexInclusive;
    ULONG MaxIndexExclusive;
    LONG  Displacement;
    BOOL  Found;

    //
    //  Rift table is in sorted order by OldRva, so do a binary search for
    //  matching or nearest preceding OldRva value.
    //

    RiftEntryArray    = RiftTable->RiftEntryArray;
    MaxIndexExclusive = RiftTable->RiftEntryCount;
    MinIndexInclusive = 0;
    Index             = 0;
    Found             = FALSE;

    while (( ! Found ) && ( MinIndexInclusive < MaxIndexExclusive )) {

        Index = ( MinIndexInclusive + MaxIndexExclusive ) / 2;    // won't overflow

        if ( RiftEntryArray[ Index ].OldFileRva < OldRva ) {
            MinIndexInclusive = Index + 1;
            }
        else if ( RiftEntryArray[ Index ].OldFileRva > OldRva ) {
            MaxIndexExclusive = Index;
            }
        else {
            Found = TRUE;
            break;
            }
        }

    if ( ! Found ) {

        //
        //  MinIndex is pointing to next highest entry, which could also be
        //  the zeroth entry if the search value was lower than anything in
        //  the table.
        //

        if ( MinIndexInclusive == 0 ) {
            return OldRva;  // zero displacement
            }

        Index = MinIndexInclusive - 1;
        }

    Displacement = (LONG)( RiftEntryArray[ Index ].NewFileRva - RiftEntryArray[ Index ].OldFileRva );

#ifndef PATCH_APPLY_CODE_ONLY

    //
    //  If we're updating the RiftUsageArray during compression, we want to
    //  mark the contributing entry as being used.
    //

    if ( RiftTable->RiftUsageArray != NULL ) {
         RiftTable->RiftUsageArray[ Index ] = 1;
         }

#endif

    NewRva = OldRva + Displacement;

    return NewRva;
    }


ULONG
__fastcall
FindRiftTableEntryForOldRva(
    IN PRIFT_TABLE RiftTable,
    IN ULONG OldRva
    )
    {
    PRIFT_ENTRY RiftEntryArray;
    ULONG MinIndexInclusive;
    ULONG MaxIndexExclusive;
    ULONG Index;
    BOOL  Found;

    //
    //  Rift table is in sorted order by OldRva, so do a binary search for
    //  matching or nearest preceding OldRva value.
    //

    RiftEntryArray    = RiftTable->RiftEntryArray;
    MaxIndexExclusive = RiftTable->RiftEntryCount;
    MinIndexInclusive = 0;
    Index             = 0;
    Found             = FALSE;

    while (( ! Found ) && ( MinIndexInclusive < MaxIndexExclusive )) {

        Index = ( MinIndexInclusive + MaxIndexExclusive ) / 2;    // won't overflow

        if ( RiftEntryArray[ Index ].OldFileRva < OldRva ) {
            MinIndexInclusive = Index + 1;
            }
        else if ( RiftEntryArray[ Index ].OldFileRva > OldRva ) {
            MaxIndexExclusive = Index;
            }
        else {
            Found = TRUE;
            break;
            }
        }

    if ( ! Found ) {

        //
        //  MinIndex is pointing to next highest entry, which could also be
        //  the zeroth entry if the search value was lower than anything in
        //  the table.
        //

        if ( MinIndexInclusive == 0 ) {
            return 0;
            }

        Index = MinIndexInclusive - 1;
        }

    return Index;
    }


#if ( _MSC_VER < 1100 )
#pragma warning( default: 4702 )    // unreachable code
#endif


VOID
__inline
ChangeOldRvaToNewRva(
    IN PRIFT_TABLE RiftTable,
    IN OUT PVOID AddressOfRvaToChange
    )
    {
    //
    //  Assuming all addresses of RVAs in a PE image are aligned.
    //

    ULONG UNALIGNED* RvaToChange = AddressOfRvaToChange;

    *RvaToChange = GetNewRvaFromRiftTable(
                       RiftTable,
                       *RvaToChange
                       );
    }


VOID
__inline
SwapRelocs(
    PRELOC_ARRAY_ENTRY One,
    PRELOC_ARRAY_ENTRY Two
    )
    {
    RELOC_ARRAY_ENTRY Tmp;

    Tmp  = *One;
    *One = *Two;
    *Two =  Tmp;
    }


VOID
__fastcall
RelocQsort(
    PRELOC_ARRAY_ENTRY LowerBound,
    PRELOC_ARRAY_ENTRY UpperBound
    )
    {
    PRELOC_ARRAY_ENTRY Lower = LowerBound;
    PRELOC_ARRAY_ENTRY Upper = UpperBound;
    PRELOC_ARRAY_ENTRY Pivot = Lower + (( Upper - Lower ) / 2 );
    ULONG PivotRva = Pivot->RelocRva;

    do  {

        while (( Lower <= Upper ) && ( Lower->RelocRva <= PivotRva )) {
            ++Lower;
            }

        while (( Upper >= Lower ) && ( Upper->RelocRva >= PivotRva )) {
            --Upper;
            }

        if ( Lower < Upper ) {
            SwapRelocs( Lower++, Upper-- );
            }
        }

    while ( Lower <= Upper );

    if ( Lower < Pivot ) {
        SwapRelocs( Lower, Pivot );
        Pivot = Lower;
        }
    else if ( Upper > Pivot ) {
        SwapRelocs( Upper, Pivot );
        Pivot = Upper;
        }

    if ( LowerBound < ( Pivot - 1 )) {
        RelocQsort( LowerBound, Pivot - 1 );
        }

    if (( Pivot + 1 ) < UpperBound ) {
        RelocQsort( Pivot + 1, UpperBound );
        }
    }


VOID
TransformOldFile_PE_Relocations(
    IN UP_IMAGE_NT_HEADERS32 NtHeader,
    IN PVOID       FileMappedImage,
    IN ULONG       FileSize,
    IN PRIFT_TABLE RiftTable,
    IN PUCHAR      HintMap
    )
    {
    PUCHAR  MappedFile;
    PUCHAR  MappedFileEnd;
    ULONG   ImageBaseVa;
    ULONG   ImageLastVa;
    PUCHAR  ImageFirstSectionMa;     // Mapped address
    ULONG   ImageFirstSectionVa;     // Virtual address
    ULONG   RelocDirOff;
    ULONG   RelocDirSize;
    LONG    RelocDirRemaining;
    UP_IMAGE_BASE_RELOCATION RelocBlock;
    UP_IMAGE_BASE_RELOCATION RelocBlockBaseMa;        // Mapped address
    ULONG   RelocBlockBaseVa;        // Virtual address
    ULONG   RelocCount;
    USHORT UNALIGNED* RelocEntry;
    USHORT UNALIGNED* RelocFirst;
    UCHAR   RelocType;
    PUCHAR  RelocFixupMa;            // Mapped address
    ULONG   RelocFixupVa;            // Virtual address
    ULONG   RelocFixupRva;
    ULONG   RelocTargetVa;           // Virtual address
    ULONG   RelocTargetRva;
    ULONG   NewRva;
    ULONG   NewVa;
    PRELOC_ARRAY_ENTRY RelocArray;
    ULONG   RelocArrayCount;
    ULONG   RelocArrayIndex;
    UP_IMAGE_SECTION_HEADER SectionHeader;
    ULONG     SectionCount;
    DWORDLONG SectionName;
    PUCHAR  p;
    ULONG   i;

#ifdef TESTCODE

    ULONG CountRelocChanges = 0;

#endif // TESTCODE

    MappedFile    = FileMappedImage;
    MappedFileEnd = MappedFile + FileSize;
    ImageBaseVa   = NtHeader->OptionalHeader.ImageBase;
    RelocDirOff   = ImageDirectoryOffsetAndSize( NtHeader, IMAGE_DIRECTORY_ENTRY_BASERELOC, &RelocDirSize );

    if (( RelocDirOff ) && (( RelocDirOff + RelocDirSize ) <= FileSize )) {

        memset( HintMap + RelocDirOff, 0x01, RelocDirSize );  // may need to be OR'd if other bits are used

        //  allocate an array for the new reloc entries, approximating the needed size

        RelocArray = MyVirtualAlloc( sizeof( *RelocArray ) * ( RelocDirSize / sizeof(USHORT)));

        if ( RelocArray != NULL ) {

            RelocArrayCount = 0;

            RelocBlock = (UP_IMAGE_BASE_RELOCATION)( MappedFile + RelocDirOff );

            RelocDirRemaining = (LONG)RelocDirSize;

            while ( RelocDirRemaining > 0 ) {

                if (( RelocBlock->SizeOfBlock <= (ULONG)RelocDirRemaining ) &&
                    ( RelocBlock->SizeOfBlock > sizeof( IMAGE_BASE_RELOCATION ))) {

                    //
                    //  ImageRvaToMappedAddress returns NULL if the Rva is zero,
                    //  but that is a valid base address of a reloc block.  Use
                    //  ImageRvaToFileOffset instead.
                    //

                    RelocBlockBaseMa = (UP_IMAGE_BASE_RELOCATION)( MappedFile + ImageRvaToFileOffset( NtHeader, RelocBlock->VirtualAddress ));

                    if ( RelocBlockBaseMa ) {

                        RelocBlockBaseVa = RelocBlock->VirtualAddress + ImageBaseVa;
                        RelocEntry       = (PUSHORT)((PUCHAR)RelocBlock + sizeof( IMAGE_BASE_RELOCATION ));
                        RelocCount       = ( RelocBlock->SizeOfBlock - sizeof( IMAGE_BASE_RELOCATION )) / sizeof( USHORT );

                        while ( RelocCount-- ) {

                            RelocType = (UCHAR)( *RelocEntry >> 12 );

                            if ( RelocType != IMAGE_REL_BASED_ABSOLUTE ) {

                                RelocFixupMa  = (PUCHAR)RelocBlockBaseMa + ( *RelocEntry & 0x0FFF );
                                RelocFixupVa  = RelocBlockBaseVa + ( *RelocEntry & 0x0FFF );
                                RelocFixupRva = RelocFixupVa - ImageBaseVa;

                                RelocArray[ RelocArrayCount ].RelocRva  = GetNewRvaFromRiftTable(
                                                                              RiftTable,
                                                                              RelocFixupRva
                                                                              );

                                RelocArray[ RelocArrayCount ].RelocType = RelocType;

                                switch ( RelocType ) {

                                    case IMAGE_REL_BASED_HIGHLOW:

                                        if ( RelocFixupMa < MappedFileEnd ) {

                                            *(UNALIGNED ULONG *)( HintMap + ( RelocFixupMa - MappedFile )) |= 0x01010101;

                                            //
                                            //  Target is a 32-bit VA that we want to
                                            //  change to the corresponding VA in the
                                            //  new file.
                                            //

                                            RelocTargetVa  = *(UNALIGNED ULONG *) RelocFixupMa;
                                            RelocTargetRva = RelocTargetVa - ImageBaseVa;

                                            NewRva = GetNewRvaFromRiftTable(
                                                         RiftTable,
                                                         RelocTargetRva
                                                         );

                                            if ( NewRva != RelocTargetRva ) {

                                                NewVa = NewRva + ImageBaseVa;
                                                *(UNALIGNED ULONG *) RelocFixupMa = NewVa;
#ifdef TESTCODE
                                                ++CountRelocChanges;
#endif // TESTCODE
                                                }

                                            }

                                        break;

                                    case IMAGE_REL_BASED_LOW:
                                    case IMAGE_REL_BASED_HIGH:

                                        if ( RelocFixupMa < MappedFileEnd ) {
                                            *(UNALIGNED USHORT *)( HintMap + ( RelocFixupMa - MappedFile )) |= 0x0101;
                                            }

                                        break;

                                    case IMAGE_REL_BASED_HIGHADJ:

                                        if ( RelocFixupMa < MappedFileEnd ) {
                                            *(UNALIGNED USHORT *)( HintMap + ( RelocFixupMa - MappedFile )) |= 0x0101;
                                            }

                                        ++RelocEntry;
                                        --RelocCount;

                                        RelocArray[ RelocArrayCount ].HighAdjValue = *RelocEntry;

                                        break;
                                    }

                                ++RelocArrayCount;
                                }

                            ++RelocEntry;
                            }
                        }
                    }

                RelocDirRemaining -= RelocBlock->SizeOfBlock;
                RelocBlock = (UP_IMAGE_BASE_RELOCATION)((PUCHAR)RelocBlock + RelocBlock->SizeOfBlock );
                }

#ifdef TESTCODE

            printf( "\r%9d modified reloc targets\n", CountRelocChanges );

#endif TESTCODE

            //
            //  Now we want to reconstruct the .reloc table based on the new values
            //  hoping that it will more closely match the .reloc table in the new
            //  file.
            //
            //  First we want to sort our RelocArray by Rva.
            //

            if ( RelocArrayCount > 1 ) {
                RelocQsort( &RelocArray[ 0 ], &RelocArray[ RelocArrayCount - 1 ] );

#ifdef TESTCODE

                for ( i = 0; i < RelocArrayCount - 1; i++ ) {
                    if ( RelocArray[ i ].RelocRva > RelocArray[ i + 1 ].RelocRva ) {

                        printf( "\nReloc sort failed at index %d of %d\n", i, RelocArrayCount );

                        for ( i = 0; i < RelocArrayCount; i++ ) {
                            printf( "%08X\n", RelocArray[ i ].RelocRva );
                            }

                        exit( 1 );
                        break;
                        }
                    }

#endif // TESTCODE

                }

            RelocDirRemaining = (LONG)RelocDirSize;

            //
            //  Look for .reloc section to determine max size we can use for new
            //  .reloc data (may be bigger than old RelocDirSize).
            //

            SectionHeader = IMAGE_FIRST_SECTION( NtHeader );
            SectionCount  = NtHeader->FileHeader.NumberOfSections;

            for ( i = 0; i < SectionCount; i++ ) {

                SectionName = *(UNALIGNED DWORDLONG*)( &SectionHeader[ i ].Name );
                SectionName |= 0x2020202020202020;  // fast lower case

                if ( SectionName == 0x2020636F6C65722E ) {      // ".reloc  "

                    if (( RelocDirOff >= SectionHeader[ i ].PointerToRawData ) &&
                        ( RelocDirOff <  SectionHeader[ i ].PointerToRawData + SectionHeader[ i ].SizeOfRawData )) {

                        RelocDirRemaining = ( SectionHeader[ i ].PointerToRawData + SectionHeader[ i ].SizeOfRawData ) - RelocDirOff;
                        }
                    }
                }

            RelocDirRemaining &= ~1;    // force to even value
            RelocBlock = (UP_IMAGE_BASE_RELOCATION)( MappedFile + RelocDirOff );
            RelocArrayIndex = 0;

            while (( RelocDirRemaining > sizeof( IMAGE_BASE_RELOCATION )) &&
                   ( RelocArrayIndex < RelocArrayCount )) {

                RelocBlock->VirtualAddress = ( RelocArray[ RelocArrayIndex ].RelocRva & 0xFFFFF000 );
                RelocFirst = RelocEntry    = (PUSHORT)((PUCHAR)RelocBlock + sizeof( IMAGE_BASE_RELOCATION ));
                RelocDirRemaining         -= sizeof( IMAGE_BASE_RELOCATION );

                while (( RelocDirRemaining > 0 ) &&
                       ( RelocArrayIndex < RelocArrayCount ) &&
                       (( RelocArray[ RelocArrayIndex ].RelocRva & 0xFFFFF000 ) == RelocBlock->VirtualAddress )) {

                    *RelocEntry++ = (USHORT)(( RelocArray[ RelocArrayIndex ].RelocType << 12 ) | ( RelocArray[ RelocArrayIndex ].RelocRva & 0x00000FFF ));
                    RelocDirRemaining -= sizeof( USHORT );

                    if ((( RelocArray[ RelocArrayIndex ].RelocType << 12 ) == IMAGE_REL_BASED_HIGHADJ ) &&
                        ( RelocDirRemaining > 0 )) {

                        *RelocEntry++ = RelocArray[ RelocArrayIndex ].HighAdjValue;
                        RelocDirRemaining -= sizeof( USHORT );
                        }

                    ++RelocArrayIndex;
                    }

                if (( RelocDirRemaining > 0 ) && ((ULONG_PTR)RelocEntry & 2 )) {
                    *RelocEntry++ = 0;
                    RelocDirRemaining -= sizeof( USHORT );
                    }

                RelocBlock->SizeOfBlock = (ULONG)((PUCHAR)RelocEntry - (PUCHAR)RelocFirst ) + sizeof( IMAGE_BASE_RELOCATION );
                RelocBlock = (UP_IMAGE_BASE_RELOCATION)((PUCHAR)RelocBlock + RelocBlock->SizeOfBlock );
                }

            MyVirtualFree( RelocArray );
            }
        }

    else {

        //
        //  No relocation table exists for this binary.  We can still perform
        //  this transformation for x86 images by inferring some of the
        //  relocation targets in the mapped image by scanning the image for
        //  4-byte values that are virtual addresses that fall within the
        //  mapped image range.  We start with the address of the first
        //  section, assuming no relocs occur in the image header.
        //

        if ( NtHeader->FileHeader.Machine == IMAGE_FILE_MACHINE_I386 ) {

            SectionHeader       = IMAGE_FIRST_SECTION( NtHeader );
            ImageFirstSectionMa = MappedFile  + SectionHeader->PointerToRawData;
            ImageFirstSectionVa = ImageBaseVa + SectionHeader->VirtualAddress;
            ImageLastVa         = ImageBaseVa + NtHeader->OptionalHeader.SizeOfImage;

            for ( p = ImageFirstSectionMa; p < ( MappedFileEnd - 4 ); p++ ) {

                RelocTargetVa = *(UNALIGNED ULONG *) p;

                if (( RelocTargetVa >= ImageFirstSectionVa ) && ( RelocTargetVa < ImageLastVa )) {

                    //
                    //  This looks like a 32-bit VA that points within the image,
                    //  so we'll transform it to the corresponding new address.
                    //

                    *(UNALIGNED ULONG *)( HintMap + ( p - MappedFile )) |= 0x01010101;

                    RelocTargetRva = RelocTargetVa - ImageBaseVa;

                    NewRva = GetNewRvaFromRiftTable( RiftTable, RelocTargetRva );

                    if ( NewRva != RelocTargetRva ) {
                        NewVa = NewRva + ImageBaseVa;
                        *(UNALIGNED ULONG *) p = NewVa;

#ifdef TESTCODE
                        ++CountRelocChanges;
#endif // TESTCODE

                        }

                    p += 3;
                    }
                }

#ifdef TESTCODE

            printf( "\r%9d modified inferred reloc targets\n", CountRelocChanges );

#endif // TESTCODE

            }
        }
    }


VOID
TransformOldFile_PE_Exports(
    IN UP_IMAGE_NT_HEADERS32 NtHeader,
    IN PVOID FileMappedImage,
    IN ULONG FileSize,
    IN PRIFT_TABLE RiftTable,
    IN PUCHAR HintMap
    )
    {
    UP_IMAGE_EXPORT_DIRECTORY ExportBlock;
    ULONG UNALIGNED* Entry;
    PUCHAR MappedFile;
    PUCHAR MappedFileEnd;
    ULONG  FileOffset;
    ULONG  ExportDirOff;
    ULONG  ExportDirSize;
    ULONG  EntryCount;

    MappedFile    = FileMappedImage;
    MappedFileEnd = MappedFile + FileSize;

    ExportDirOff = ImageDirectoryOffsetAndSize( NtHeader, IMAGE_DIRECTORY_ENTRY_EXPORT, &ExportDirSize );

    if (( ExportDirOff ) && (( ExportDirOff + ExportDirSize ) <= FileSize )) {

        memset( HintMap + ExportDirOff, 0x01, ExportDirSize );  // may need to be OR'd if other bits are used

        ExportBlock = (UP_IMAGE_EXPORT_DIRECTORY)( MappedFile + ExportDirOff );

        EntryCount = ExportBlock->NumberOfFunctions;
        FileOffset = ImageRvaToFileOffset( NtHeader, (ULONG) ExportBlock->AddressOfFunctions );

        memset( HintMap + FileOffset, 0x01, EntryCount * sizeof( ULONG )); // may need to be OR'd if other bits are used

        Entry = (PULONG)( MappedFile + FileOffset );

        while ( EntryCount-- ) {
            ChangeOldRvaToNewRva( RiftTable, Entry++ );
            }

        EntryCount = ExportBlock->NumberOfNames;
        FileOffset = ImageRvaToFileOffset( NtHeader, (ULONG) ExportBlock->AddressOfNames );

        memset( HintMap + FileOffset, 0x01, EntryCount * sizeof( ULONG )); // may need to be OR'd if other bits are used

        Entry = (PULONG)( MappedFile + FileOffset );

        while ( EntryCount-- ) {
            ChangeOldRvaToNewRva( RiftTable, Entry++ );
            }

        EntryCount = ExportBlock->NumberOfNames;
        FileOffset = ImageRvaToFileOffset( NtHeader, (ULONG) ExportBlock->AddressOfNameOrdinals );

        memset( HintMap + FileOffset, 0x01, EntryCount * sizeof( USHORT )); // may need to be OR'd if other bits are used

        ChangeOldRvaToNewRva( RiftTable, &ExportBlock->Name );
        ChangeOldRvaToNewRva( RiftTable, &ExportBlock->AddressOfFunctions );
        ChangeOldRvaToNewRva( RiftTable, &ExportBlock->AddressOfNames );
        ChangeOldRvaToNewRva( RiftTable, &ExportBlock->AddressOfNameOrdinals );
        }

    return;
    }


VOID
TransformOldFile_PE_Imports(
    IN UP_IMAGE_NT_HEADERS32 NtHeader,
    IN PVOID FileMappedImage,
    IN ULONG FileSize,
    IN PRIFT_TABLE RiftTable,
    IN PUCHAR HintMap
    )
    {
    UP_IMAGE_IMPORT_BY_NAME    ImportByNameData;
    UP_IMAGE_IMPORT_DESCRIPTOR ImportBlock;
    UP_IMAGE_THUNK_DATA32      ThunkDataStart;
    UP_IMAGE_THUNK_DATA32      ThunkData;
    PUCHAR MappedFile;
    PUCHAR MappedFileEnd;
    ULONG  FileOffset;
    ULONG  ImportDirOff;
    ULONG  ImportDirSize;
    ULONG  ImportByNameDataOffset;

    MappedFile    = FileMappedImage;
    MappedFileEnd = MappedFile + FileSize;

    ImportDirOff = ImageDirectoryOffsetAndSize( NtHeader, IMAGE_DIRECTORY_ENTRY_IMPORT, &ImportDirSize );

    if (( ImportDirOff ) && (( ImportDirOff + ImportDirSize ) <= FileSize )) {

        memset( HintMap + ImportDirOff, 0x01, ImportDirSize );  // may need to be OR'd if other bits are used

        ImportBlock = (UP_IMAGE_IMPORT_DESCRIPTOR)( MappedFile + ImportDirOff );

        while ( ImportBlock->OriginalFirstThunk ) {

            if ( ! ImportBlock->TimeDateStamp ) {

                FileOffset = ImageRvaToFileOffset( NtHeader, (ULONG) ImportBlock->OriginalFirstThunk );

                ThunkData = ThunkDataStart = (UP_IMAGE_THUNK_DATA32)( MappedFile + FileOffset );

                while ( ThunkData->u1.Ordinal != 0 ) {

                    if ( ! IMAGE_SNAP_BY_ORDINAL32( ThunkData->u1.Ordinal )) {

                        ImportByNameDataOffset = ImageRvaToFileOffset( NtHeader, (ULONG) ThunkData->u1.AddressOfData );

                        ImportByNameData = (UP_IMAGE_IMPORT_BY_NAME)( MappedFile + ImportByNameDataOffset );

                        memset( HintMap + ImportByNameDataOffset, 0x01, strlen( (LPSTR)ImportByNameData->Name ) + 3 ); // may need to be OR'd if other bits are used

                        ChangeOldRvaToNewRva( RiftTable, &ThunkData->u1.AddressOfData );
                        }

                    ThunkData++;
                    }

                memset( HintMap + FileOffset, 0x01, ((PUCHAR)ThunkData - (PUCHAR)ThunkDataStart )); // may need to be OR'd if other bits are used

                FileOffset = ImageRvaToFileOffset( NtHeader, (ULONG) ImportBlock->FirstThunk );

                ThunkData = ThunkDataStart = (UP_IMAGE_THUNK_DATA32)( MappedFile + FileOffset );

                while ( ThunkData->u1.Ordinal != 0 ) {

                    if ( ! IMAGE_SNAP_BY_ORDINAL32( ThunkData->u1.Ordinal )) {

                        ImportByNameDataOffset = ImageRvaToFileOffset( NtHeader, (ULONG) ThunkData->u1.AddressOfData );

                        ImportByNameData = (UP_IMAGE_IMPORT_BY_NAME)( MappedFile + ImportByNameDataOffset );

                        memset( HintMap + ImportByNameDataOffset, 0x01, strlen( (LPSTR)ImportByNameData->Name ) + 3 ); // may need to be OR'd if other bits are used

                        ChangeOldRvaToNewRva( RiftTable, &ThunkData->u1.AddressOfData );
                        }

                    ThunkData++;
                    }

                memset( HintMap + FileOffset, 0x01, ((PUCHAR)ThunkData - (PUCHAR)ThunkDataStart )); // may need to be OR'd if other bits are used
                }

            ChangeOldRvaToNewRva( RiftTable, &ImportBlock->Name );
            ChangeOldRvaToNewRva( RiftTable, &ImportBlock->OriginalFirstThunk );
            ChangeOldRvaToNewRva( RiftTable, &ImportBlock->FirstThunk );

            ImportBlock++;
            }
        }

    //
    //  Another other big thing that will prevent long matches through
    //  the IMAGE_IMPORT_BY_NAME entries is the Hint values which
    //  may change (from implib for dll being imported).  The Hint
    //  values are stored between each of the names.  Maybe a separate
    //  "hint rift table" to fix those, or zero out all the hints in
    //  both the old and new files, then after the new file is built,
    //  go fill-in the hint values.
    //
    //  Currently we have no infrastructure for pre-modification of
    //  the new file before compression and post-modification after
    //  decompression.
    //

    return;
    }


#ifdef DONTCOMPILE  // jmps2 and jmps3 are experimental


VOID
TransformOldFile_PE_RelativeJmps2(
    IN UP_IMAGE_NT_HEADERS32 NtHeader,
    IN PUCHAR OldFileMapped,
    IN ULONG  OldFileSize,
    IN PUCHAR NewFileMapped,         // OPTIONAL
    IN ULONG  NewFileSize,           // OPTIONAL
    IN PRIFT_TABLE RiftTable,
    IN PUCHAR HintMap
    )
    {
    UP_IMAGE_NT_HEADERS32   NewNtHeader;
    UP_IMAGE_SECTION_HEADER SectionHeader;
    ULONG  SectionCount;
    PUCHAR SectionStart;
    PUCHAR SectionExtent;
    PUCHAR SearchExtent;
    ULONG  SectionLength;
    ULONG  SectionOffset;
    ULONG  SectionBaseRva;
    ULONG  SectionLastRva;
    ULONG  ImageLastRva;
    LONG   Displacement;
    LONG   NewDisplacement;
    ULONG  OffsetInSection;
    ULONG  OriginRva;
    ULONG  TargetRva;
    ULONG  NewOriginRva;
    ULONG  NewTargetRva;
    ULONG  i;
    PUCHAR p;

    //
    //  For each executable section, scan for opcodes that indicate
    //  relative call or branch instructions (different opcodes for
    //  different machine types).
    //

#ifdef TESTCODE

    ULONG CountRelativeBranchChanges = 0;
    ULONG CountRiftModifications = 0;
    ULONG CountRiftDeletions = 0;

    ULONG CountUnmatchedBranches = 0;

    ULONG CountUnmatchedE8 = 0;
    ULONG CountUnmatchedE9 = 0;
    ULONG CountUnmatched0F = 0;

    ULONG CountUnmatchedE8Targets = 0;
    ULONG CountUnmatchedE9Targets = 0;
    ULONG CountUnmatched0FTargets = 0;

    ULONG CountUnmatchedE8Followers = 0;
    ULONG CountUnmatchedE9Followers = 0;
    ULONG CountUnmatched0FFollowers = 0;

    ULONG CountUnmatchedE8Instructions = 0;
    ULONG CountUnmatchedE9Instructions = 0;
    ULONG CountUnmatched0FInstructions = 0;

    ULONG CountBranchInversions = 0;

#endif // TESTCODE

    NewNtHeader   = NewFileMapped ? GetNtHeader( NewFileMapped, NewFileSize ) : NULL;
    ImageLastRva  = NtHeader->OptionalHeader.SizeOfImage;
    SectionHeader = IMAGE_FIRST_SECTION( NtHeader );
    SectionCount  = NtHeader->FileHeader.NumberOfSections;

    for ( i = 0; i < SectionCount; i++ ) {

        if ( SectionHeader[ i ].Characteristics & IMAGE_SCN_MEM_EXECUTE ) {

            SectionBaseRva = SectionHeader[ i ].VirtualAddress;
            SectionLength  = MIN( SectionHeader[ i ].Misc.VirtualSize, SectionHeader[ i ].SizeOfRawData );
            SectionOffset  = SectionHeader[ i ].PointerToRawData;
            SectionStart   = OldFileMapped + SectionOffset;
            SectionLastRva = SectionBaseRva + SectionLength;

            if (( SectionOffset < OldFileSize ) &&
                (( SectionOffset + SectionLength ) <= OldFileSize )) {

                if ( NtHeader->FileHeader.Machine == IMAGE_FILE_MACHINE_I386 ) {

                    SearchExtent = SectionStart + SectionLength - 5;

                    for ( p = SectionStart; p < SearchExtent; p++ ) {

                        if (( *p == 0xE8 ) ||       // call relative
                            ( *p == 0xE9 ) ||       // jmp relative
                            (( *p == 0x0F ) &&      // jcc relative (0F 8x)
                             (( *( p + 1 ) & 0xF0 ) == 0x80 ) &&
                             ( ++p < SearchExtent ))) {

                            //
                            //  Relative displacement is stored as
                            //  32-bit signed value following these
                            //  opcodes.  The displacement is relative
                            //  to the NEXT instruction, which is at
                            //  (p + 5).
                            //

                            Displacement = *(UNALIGNED LONG*)( p + 1 );

                            //
                            //  We expect a lot of false positives here because
                            //  occurences of <E8>, <E9>, and <0F><8x> will
                            //  likely occur in other parts of the instruction
                            //  stream so now we validate that the TargetRva
                            //  falls within the image and within an executable
                            //  section.
                            //
                            //  Also, for jmp and jcc instructions, verify that
                            //  the displacement is larger than +/- 127 because
                            //  if it wasn't, the instruction should have been
                            //  encoded as an 8-bit near branch, not a 32-bit
                            //  branch.  This prevents us from falsely matching
                            //  data that looks like:
                            //
                            //      xxE9xxxx 00000000
                            //

                            if (( *p == 0xE8 ) ||
                                ( Displacement >  127 ) ||
                                ( Displacement < -128 )) {

                                OffsetInSection = ( p + 5 ) - SectionStart;
                                OriginRva       = SectionBaseRva + OffsetInSection;
                                TargetRva       = OriginRva + Displacement;

                                if ((( TargetRva >= SectionBaseRva ) &&
                                     ( TargetRva <  SectionLastRva )) ||
                                    (( TargetRva <  ImageLastRva ) &&
                                     ( IsImageRvaInExecutableSection( NtHeader, TargetRva )))) {

                                    //
                                    //  Looks like a valid TargetRva.
                                    //

#ifndef PATCH_APPLY_CODE_ONLY

                                    //
                                    //  If we're creating the patch, then we need
                                    //  to validate the corresponding branch in the
                                    //  new file (might want to modify a rift entry).
                                    //

                                    if ( NewFileMapped != NULL ) {     // we're compressing

                                        BOOL OriginNext  = FALSE;
                                        BOOL OriginFound = FALSE;
                                        BOOL TargetNext  = FALSE;
                                        BOOL TargetFound = FALSE;

                                        ULONG  RiftIndexOrigin = FindRiftTableEntryForOldRva( RiftTable, OriginRva );
                                        ULONG  NewOriginRva = OriginRva + (LONG)( RiftTable->RiftEntryArray[ RiftIndexOrigin ].NewFileRva - RiftTable->RiftEntryArray[ RiftIndexOrigin ].OldFileRva );
                                        PUCHAR NewOriginMa  = NewFileMapped + ImageRvaToFileOffset( NewNtHeader, NewOriginRva );
#ifdef TESTCODE
                                        ULONG NewOriginRva1 = NewOriginRva;
                                        ULONG NewOriginMo1  = NewOriginMa - NewFileMapped;
                                        ULONG NewOriginVa1  = NewOriginRva + NewNtHeader->OptionalHeader.ImageBase;

                                        ULONG NewOriginRva2 = 0;
                                        ULONG NewOriginMo2  = 0;
                                        ULONG NewOriginVa2  = 0;

                                        UCHAR OldInstruction = *p;
                                        UCHAR NewInstruction = *( NewOriginMa - 5 );
                                        BOOL  InstructionsMatch = ( *p == *( NewOriginMa - 5 ));
                                        BOOL  FollowersMatch    = ( *( p + 5 ) == *NewOriginMa );
#endif // TESTCODE

                                        if (( *p == *( NewOriginMa - 5 )) &&    // instructions match, and
                                            (( *p == 0xE9 ) ||                  //   jmp instruction, or
                                             ( *( p + 5 ) == *NewOriginMa ))) { //   followers match

                                            OriginFound = TRUE;
                                            }

                                        else {

                                            if (( RiftIndexOrigin + 1 ) < RiftTable->RiftEntryCount ) {

                                                NewOriginRva = OriginRva + (LONG)( RiftTable->RiftEntryArray[ RiftIndexOrigin + 1 ].NewFileRva - RiftTable->RiftEntryArray[ RiftIndexOrigin + 1 ].OldFileRva );
                                                NewOriginMa  = NewFileMapped + ImageRvaToFileOffset( NewNtHeader, NewOriginRva );
#ifdef TESTCODE
                                                NewOriginRva2 = NewOriginRva;
                                                NewOriginMo2  = NewOriginMa - NewFileMapped;
                                                NewOriginVa2  = NewOriginRva + NewNtHeader->OptionalHeader.ImageBase;
#endif // TESTCODE

                                                if (( *p == *( NewOriginMa - 5 )) &&    // instructions match, and
                                                    (( *p == 0xE9 ) ||                  //   jmp instruction, or
                                                     ( *( p + 5 ) == *NewOriginMa ))) { //   followers match

                                                    OriginFound = TRUE;
                                                    OriginNext  = TRUE;
                                                    }
                                                }
                                            }

                                        if ( OriginFound ) {

                                            ULONG  RiftIndexTarget = FindRiftTableEntryForOldRva( RiftTable, TargetRva );
                                            ULONG  NewTargetRva = TargetRva + (LONG)( RiftTable->RiftEntryArray[ RiftIndexTarget ].NewFileRva - RiftTable->RiftEntryArray[ RiftIndexTarget ].OldFileRva );
                                            PUCHAR NewTargetMa  = NewFileMapped + ImageRvaToFileOffset( NewNtHeader, NewTargetRva );
                                            PUCHAR TargetMa = OldFileMapped + ImageRvaToFileOffset( NtHeader, TargetRva );

                                            if ( *NewTargetMa == *TargetMa ) {  // target instructions match
                                                TargetFound = TRUE;
                                                }

                                            else {

                                                if (( RiftIndexTarget + 1 ) < RiftTable->RiftEntryCount ) {

                                                    NewTargetRva = TargetRva + (LONG)( RiftTable->RiftEntryArray[ RiftIndexTarget + 1 ].NewFileRva - RiftTable->RiftEntryArray[ RiftIndexTarget + 1 ].OldFileRva );
                                                    NewTargetMa  = NewFileMapped + ImageRvaToFileOffset( NewNtHeader, NewTargetRva );

                                                    if ( *NewTargetMa == *TargetMa ) {  // target instructions match
                                                        TargetFound = TRUE;
                                                        TargetNext  = TRUE;
                                                        }
                                                    }
                                                }

                                            if ( TargetFound ) {    // target and origin found

                                                if ( OriginNext ) {

                                                    //
                                                    //  Coast the rift entry at [RiftIndexOrigin+1]
                                                    //  backwards to the Rva of the instruction.
                                                    //

                                                    LONG Delta = (LONG)( RiftTable->RiftEntryArray[ RiftIndexOrigin + 1 ].OldFileRva - OriginRva );

                                                    RiftTable->RiftEntryArray[ RiftIndexOrigin + 1 ].OldFileRva -= Delta;
                                                    RiftTable->RiftEntryArray[ RiftIndexOrigin + 1 ].NewFileRva -= Delta;
#ifdef TESTCODE
                                                    ++CountRiftModifications;
#endif // TESTCODE
                                                    ASSERT( RiftTable->RiftEntryArray[ RiftIndexOrigin ].OldFileRva <= RiftTable->RiftEntryArray[ RiftIndexOrigin + 1 ].OldFileRva );

                                                    if ( RiftTable->RiftEntryArray[ RiftIndexOrigin ].OldFileRva == RiftTable->RiftEntryArray[ RiftIndexOrigin + 1 ].OldFileRva ) {
                                                         RiftTable->RiftEntryArray[ RiftIndexOrigin ].NewFileRva =  RiftTable->RiftEntryArray[ RiftIndexOrigin + 1 ].NewFileRva;
#ifdef TESTCODE
                                                         ++CountRiftDeletions;
#endif // TESTCODE
                                                         }
                                                    }

                                                if ( TargetNext ) {

                                                    //
                                                    //  Coast the rift entry at [RiftIndexTarget+1]
                                                    //  backwards to the Rva of the target.
                                                    //

                                                    LONG Delta = (LONG)( RiftTable->RiftEntryArray[ RiftIndexTarget + 1 ].OldFileRva - TargetRva );

                                                    RiftTable->RiftEntryArray[ RiftIndexTarget + 1 ].OldFileRva -= Delta;
                                                    RiftTable->RiftEntryArray[ RiftIndexTarget + 1 ].NewFileRva -= Delta;
#ifdef TESTCODE
                                                    ++CountRiftModifications;
#endif // TESTCODE
                                                    ASSERT( RiftTable->RiftEntryArray[ RiftIndexTarget ].OldFileRva <= RiftTable->RiftEntryArray[ RiftIndexTarget + 1 ].OldFileRva );

                                                    if ( RiftTable->RiftEntryArray[ RiftIndexTarget ].OldFileRva == RiftTable->RiftEntryArray[ RiftIndexTarget + 1 ].OldFileRva ) {
                                                         RiftTable->RiftEntryArray[ RiftIndexTarget ].NewFileRva =  RiftTable->RiftEntryArray[ RiftIndexTarget + 1 ].NewFileRva;
#ifdef TESTCODE
                                                         ++CountRiftDeletions;
#endif // TESTCODE
                                                         }
                                                    }
                                                }
                                            }
#ifdef TESTCODE
                                        if ( ! (( OriginFound ) && ( TargetFound ))) {

                                            ++CountUnmatchedBranches;

                                            switch ( *p ) {

                                                case 0xE8:

                                                    ++CountUnmatchedE8;

                                                    if ( OriginFound ) {
                                                        ++CountUnmatchedE8Targets;
                                                        }
                                                    else if ( InstructionsMatch ) {
                                                        ASSERT( ! FollowersMatch );
                                                        ++CountUnmatchedE8Followers;
                                                        }
                                                    else {
                                                        ++CountUnmatchedE8Instructions;

                                                        printf( "\rUnmatched E8 at old RVA %08X (VA %08X, FO %08X)\n"
                                                                  "    with either new RVA %08X (VA %08X, FO %08X)\n"
                                                                  "     or backcoasted RVA %08X (VA %08X, FO %08X)\n\n",
                                                                OriginRva - 5,
                                                                ( OriginRva - 5 ) + NtHeader->OptionalHeader.ImageBase,
                                                                p - OldFileMapped,
                                                                NewOriginRva1,
                                                                NewOriginVa1,
                                                                NewOriginMo1,
                                                                NewOriginRva2,
                                                                NewOriginVa2,
                                                                NewOriginMo2
                                                              );
                                                        }


                                                    break;

                                                case 0xE9:

                                                    ++CountUnmatchedE9;

                                                    if ( OriginFound ) {
                                                        ++CountUnmatchedE9Targets;
                                                        }
                                                    else {
                                                        ++CountUnmatchedE9Instructions;
                                                        }

                                                    break;

                                                default:

                                                    ++CountUnmatched0F;

                                                    if ( OriginFound ) {
                                                        ++CountUnmatched0FTargets;
                                                        }
                                                    else if ( InstructionsMatch ) {
                                                        ASSERT( ! FollowersMatch );
                                                        ++CountUnmatched0FFollowers;
                                                        }
                                                    else {
                                                        ++CountUnmatched0FInstructions;
                                                        }

                                                    if ( ! InstructionsMatch ) {
                                                        if (( OldInstruction & ~1 ) == ( NewInstruction & ~1 )) {
                                                            ++CountBranchInversions;
                                                            }
                                                        }

                                                    break;

                                                }
                                            }
#endif // TESTCODE
                                        }

#endif // PATCH_APPLY_CODE_ONLY

                                    NewTargetRva = GetNewRvaFromRiftTable( RiftTable, TargetRva );
                                    NewOriginRva = GetNewRvaFromRiftTable( RiftTable, OriginRva );

                                    NewDisplacement = NewTargetRva - NewOriginRva;

                                    if ( NewDisplacement != Displacement ) {
                                        *(UNALIGNED LONG*)( p + 1 ) = NewDisplacement;
#ifdef TESTCODE
                                        ++CountRelativeBranchChanges;
#endif // TESTCODE
                                        }

                                    p += 4;
                                    }
                                }
                            }
                        }
                    }

                else if ( NtHeader->FileHeader.Machine == IMAGE_FILE_MACHINE_ALPHA ) {

                    //
                    //  Need to implement the scan for Alpha platform
                    //  relative call/jmp/jcc opcodes.
                    //

                    }
                }
            }
        }

#ifdef TESTCODE

    printf( "\r%d modified relative branches\n", CountRelativeBranchChanges );
    printf( "%d rift back-coasting modifications due to branch inspection\n", CountRiftModifications );
    printf( "%d rift deletions due to branch inspection back-coasting\n", CountRiftDeletions );
    printf( "%d total unmatched relative branches, composed of:\n", CountUnmatchedBranches );

    printf( "\t%d unmatched E8 (call)\n", CountUnmatchedE8 );
    printf( "\t\t%d unmatched E8 (call) instructions\n", CountUnmatchedE8Instructions );
    printf( "\t\t%d unmatched E8 (call) followers\n", CountUnmatchedE8Followers );
    printf( "\t\t%d unmatched E8 (call) targets\n", CountUnmatchedE8Targets );

    printf( "\t%d unmatched E9 (jmp)\n",    CountUnmatchedE9 );
    printf( "\t\t%d unmatched E9 (jmp) instructions\n", CountUnmatchedE9Instructions );
    printf( "\t\t%d unmatched E9 (jmp) targets\n", CountUnmatchedE9Targets );

    printf( "\t%d unmatched 0F 8x (jcc)\n", CountUnmatched0F );
    printf( "\t\t%d unmatched 0F 8x (jcc) instructions\n", CountUnmatched0FInstructions );
    printf( "\t\t\t%d unmatched 0F 8x (jcc) instruction inversions\n", CountBranchInversions );
    printf( "\t\t%d unmatched 0F 8x (jcc) followers\n", CountUnmatched0FFollowers );
    printf( "\t\t%d unmatched 0F 8x (jcc) targets\n", CountUnmatched0FTargets );

#endif // TESTCODE

    }


#ifdef _M_IX86

__inline char * mymemchr( char *buf, int c, unsigned count ) {

    __asm {
            mov     edi, buf
            mov     ecx, count
            mov     eax, c
            repne   scasb
            lea     eax, [edi-1]
            jz      RETURNIT
            xor     eax, eax
RETURNIT:
        }
    }

#else // ! _M_IX86

#define mymemchr memchr

#endif // ! _M_IX86



VOID
TransformOldFile_PE_RelativeJmps3(
    IN UP_IMAGE_NT_HEADERS32 NtHeader,
    IN PUCHAR OldFileMapped,
    IN ULONG  OldFileSize,
    IN PUCHAR NewFileMapped,         // OPTIONAL
    IN ULONG  NewFileSize,           // OPTIONAL
    IN PRIFT_TABLE RiftTable,
    IN PUCHAR HintMap
    )
    {
    UP_IMAGE_NT_HEADERS32   NewNtHeader;
    UP_IMAGE_SECTION_HEADER SectionHeader;
    ULONG  SectionCount;
    PUCHAR SectionStart;
    PUCHAR SectionExtent;
    ULONG  SearchExtent;
    ULONG  SectionLength;
    ULONG  SectionOffset;
    ULONG  SectionBaseRva;
    ULONG  SectionLastRva;
    ULONG  ImageLastRva;
    LONG   DisplacementValue;
    LONG   NewDisplacement;
    LONG   OffsetToRvaAdjust;
    ULONG  FileOffset;
    ULONG  TargetOffset;
    UCHAR  Instruction;
    ULONG  InstructionLength;
    ULONG  DisplacementOrigin;
    ULONG  DisplacementOffset;
    BOOL   Skip;
    ULONG  OffsetInSection;
    ULONG  OriginRva;
    ULONG  TargetRva;
    ULONG  NewOriginRva;
    ULONG  NewTargetRva;
    ULONG  i;
    ULONG  j;
    PUCHAR p;

    //
    //  For each executable section, scan for opcodes that indicate
    //  relative call or branch instructions (different opcodes for
    //  different machine types).
    //

#ifdef TESTCODE

    ULONG CountRelativeBranchChanges = 0;
    ULONG CountRiftModifications = 0;
    ULONG CountRiftDeletions = 0;

    ULONG CountUnmatchedBranches = 0;

    ULONG CountUnmatchedE8 = 0;
    ULONG CountUnmatchedE9 = 0;
    ULONG CountUnmatched0F = 0;

    ULONG CountUnmatchedE8Targets = 0;
    ULONG CountUnmatchedE9Targets = 0;
    ULONG CountUnmatched0FTargets = 0;

    ULONG CountUnmatchedE8Followers = 0;
    ULONG CountUnmatchedE9Followers = 0;
    ULONG CountUnmatched0FFollowers = 0;

    ULONG CountUnmatchedE8Instructions = 0;
    ULONG CountUnmatchedE9Instructions = 0;
    ULONG CountUnmatched0FInstructions = 0;

    ULONG CountBranchInversions = 0;

#endif // TESTCODE

    NewNtHeader   = NewFileMapped ? GetNtHeader( NewFileMapped, NewFileSize ) : NULL;
    ImageLastRva  = NtHeader->OptionalHeader.SizeOfImage - 1;
    SectionHeader = IMAGE_FIRST_SECTION( NtHeader );
    SectionCount  = NtHeader->FileHeader.NumberOfSections;

    for ( i = 0; i < SectionCount; i++ ) {

        if ( SectionHeader[ i ].Characteristics & IMAGE_SCN_MEM_EXECUTE ) {

            SectionBaseRva = SectionHeader[ i ].VirtualAddress;
            SectionLength  = MIN( SectionHeader[ i ].Misc.VirtualSize, SectionHeader[ i ].SizeOfRawData );
            SectionOffset  = SectionHeader[ i ].PointerToRawData;
            SectionStart   = OldFileMapped + SectionOffset;
            SectionLastRva = SectionBaseRva + SectionLength;
            OffsetToRvaAdjust = SectionHeader[ i ].VirtualAddress - SectionHeader[ i ].PointerToRawData;

            if (( SectionOffset < OldFileSize ) &&
                (( SectionOffset + SectionLength ) <= OldFileSize )) {

                if ( NtHeader->FileHeader.Machine == IMAGE_FILE_MACHINE_I386 ) {

                    SearchExtent = SectionOffset + SectionLength - 6;

                    for ( FileOffset = SectionOffset; FileOffset < SearchExtent; FileOffset++ ) {

                        Instruction = OldFileMapped[ FileOffset ];

                        switch ( Instruction ) {

                            case 0xE8:

                                InstructionLength  = 6;     // E8 xx xx xx xx yy
                                DisplacementOrigin = FileOffset + 5;
                                DisplacementOffset = 1;
                                break;

                            case 0xE9:

continue;

                                InstructionLength  = 5;     // E9 xx xx xx xx
                                DisplacementOrigin = FileOffset + 5;
                                DisplacementOffset = 1;
                                break;

                            case 0x0F:

continue;

                                if (( OldFileMapped[ FileOffset + 1 ] & 0xF0 ) != 0x80 ) {
                                    continue;
                                    }

                                InstructionLength  = 7;     // 0F 8x yy yy yy yy zz
                                DisplacementOrigin = FileOffset + 6;
                                DisplacementOffset = 2;
                                break;

                            default:

                                continue;

                            }

                        Skip = FALSE;

                        for ( j = 0; j < InstructionLength; j++ ) {
                            if ( HintMap[ FileOffset + j ] & 0x01 ) {
                                Skip = TRUE;
                                break;
                                }
                            }

                        if ( Skip ) {
                            continue;
                            }

                        DisplacementValue = *(UNALIGNED LONG*)( OldFileMapped + FileOffset + DisplacementOffset );

                        if (( Instruction != 0xE8 ) &&
                            (( DisplacementValue > 127 ) || ( DisplacementValue < -128 ))) {

                            continue;
                            }

                        OriginRva = DisplacementOrigin + OffsetToRvaAdjust;
                        TargetRva = OriginRva + DisplacementValue;

                        if ( TargetRva > ImageLastRva ) {
                            continue;
                            }

                        TargetOffset = ImageRvaToFileOffset( NtHeader, TargetRva );

                        if ( HintMap[ TargetOffset ] & 0x01 ) {
                            continue;
                            }

#ifndef PATCH_APPLY_CODE_ONLY

                        //
                        //  If we're creating the patch, then we want
                        //  to validate the corresponding branch in the
                        //  new file (might want to modify a rift entry).
                        //

                        if ( NewFileMapped != NULL ) {     // we're compressing

                            BOOL OriginNext  = FALSE;
                            BOOL OriginFound = FALSE;
                            BOOL TargetNext  = FALSE;
                            BOOL TargetFound = FALSE;

                            ULONG  RiftIndexOrigin = FindRiftTableEntryForOldRva( RiftTable, OriginRva );
                            ULONG  NewOriginRva = OriginRva + (LONG)( RiftTable->RiftEntryArray[ RiftIndexOrigin ].NewFileRva - RiftTable->RiftEntryArray[ RiftIndexOrigin ].OldFileRva );
                            PUCHAR NewOriginMa  = NewFileMapped + ImageRvaToFileOffset( NewNtHeader, NewOriginRva );
#ifdef TESTCODE
                            ULONG NewOriginRva1 = NewOriginRva;
                            ULONG NewOriginMo1  = NewOriginMa - NewFileMapped;
                            ULONG NewOriginVa1  = NewOriginRva + NewNtHeader->OptionalHeader.ImageBase;

                            ULONG NewOriginRva2 = 0;
                            ULONG NewOriginMo2  = 0;
                            ULONG NewOriginVa2  = 0;

                            BOOL InstructionsMatch;
                            BOOL FollowersMatch;
                            BOOL BranchInversion;

                            BranchInversion = FALSE;

                            if ( Instruction == 0x0F ) {
                                InstructionsMatch = ( *( NewOriginMa - 6 ) == Instruction ) && ( *( NewOriginMa - 5 ) == OldFileMapped[ FileOffset + 1 ] );

                                if ( ! InstructionsMatch ) {
                                    BranchInversion = ( *( NewOriginMa - 6 ) == Instruction ) && (( *( NewOriginMa - 5 ) & ~1 ) == ( OldFileMapped[ FileOffset + 1 ] & ~1 ));
                                    }
                                }
                            else {
                                InstructionsMatch = ( *( NewOriginMa - 5 ) == Instruction );
                                }

                            FollowersMatch = ( *NewOriginMa == OldFileMapped[ DisplacementOrigin ] );

#endif // TESTCODE

                            if (( InstructionsMatch ) &&
                                (( FollowersMatch ) || ( Instruction == 0xE9 ))) {

                                OriginFound = TRUE;
                                }

                            else {

                                if (( RiftIndexOrigin + 1 ) < RiftTable->RiftEntryCount ) {

                                    NewOriginRva = OriginRva + (LONG)( RiftTable->RiftEntryArray[ RiftIndexOrigin + 1 ].NewFileRva - RiftTable->RiftEntryArray[ RiftIndexOrigin + 1 ].OldFileRva );
                                    NewOriginMa  = NewFileMapped + ImageRvaToFileOffset( NewNtHeader, NewOriginRva );
#ifdef TESTCODE
                                    NewOriginRva2 = NewOriginRva;
                                    NewOriginMo2  = NewOriginMa - NewFileMapped;
                                    NewOriginVa2  = NewOriginRva + NewNtHeader->OptionalHeader.ImageBase;
#endif // TESTCODE

                                    if ( Instruction == 0x0F ) {
                                        InstructionsMatch = ( *( NewOriginMa - 6 ) == Instruction ) && ( *( NewOriginMa - 5 ) == OldFileMapped[ FileOffset + 1 ] );
                                        }
                                    else {
                                        InstructionsMatch = ( *( NewOriginMa - 5 ) == Instruction );
                                        }

                                    FollowersMatch = ( *NewOriginMa == OldFileMapped[ DisplacementOrigin ] );

                                    if (( InstructionsMatch ) &&
                                        (( FollowersMatch ) || ( Instruction == 0xE9 ))) {

                                        OriginFound = TRUE;
                                        OriginNext  = TRUE;
                                        }
                                    }
                                }

                            if ( OriginFound ) {

                                ULONG  RiftIndexTarget = FindRiftTableEntryForOldRva( RiftTable, TargetRva );
                                ULONG  NewTargetRva = TargetRva + (LONG)( RiftTable->RiftEntryArray[ RiftIndexTarget ].NewFileRva - RiftTable->RiftEntryArray[ RiftIndexTarget ].OldFileRva );
                                PUCHAR NewTargetMa  = NewFileMapped + ImageRvaToFileOffset( NewNtHeader, NewTargetRva );
                                PUCHAR TargetMa = OldFileMapped + ImageRvaToFileOffset( NtHeader, TargetRva );

                                if ( *NewTargetMa == *TargetMa ) {  // target instructions match
                                    TargetFound = TRUE;
                                    }

                                else {

                                    if (( RiftIndexTarget + 1 ) < RiftTable->RiftEntryCount ) {

                                        NewTargetRva = TargetRva + (LONG)( RiftTable->RiftEntryArray[ RiftIndexTarget + 1 ].NewFileRva - RiftTable->RiftEntryArray[ RiftIndexTarget + 1 ].OldFileRva );
                                        NewTargetMa  = NewFileMapped + ImageRvaToFileOffset( NewNtHeader, NewTargetRva );

                                        if ( *NewTargetMa == *TargetMa ) {  // target instructions match
                                            TargetFound = TRUE;
                                            TargetNext  = TRUE;
                                            }
                                        }
                                    }

                                if ( TargetFound ) {    // target and origin found

                                    if ( OriginNext ) {

                                        //
                                        //  Coast the rift entry at [RiftIndexOrigin+1]
                                        //  backwards to the Rva of the instruction.
                                        //

                                        LONG Delta = (LONG)( RiftTable->RiftEntryArray[ RiftIndexOrigin + 1 ].OldFileRva - OriginRva );

                                        RiftTable->RiftEntryArray[ RiftIndexOrigin + 1 ].OldFileRva -= Delta;
                                        RiftTable->RiftEntryArray[ RiftIndexOrigin + 1 ].NewFileRva -= Delta;
#ifdef TESTCODE
                                        ++CountRiftModifications;
#endif // TESTCODE
                                        ASSERT( RiftTable->RiftEntryArray[ RiftIndexOrigin ].OldFileRva <= RiftTable->RiftEntryArray[ RiftIndexOrigin + 1 ].OldFileRva );

                                        if ( RiftTable->RiftEntryArray[ RiftIndexOrigin ].OldFileRva == RiftTable->RiftEntryArray[ RiftIndexOrigin + 1 ].OldFileRva ) {
                                             RiftTable->RiftEntryArray[ RiftIndexOrigin ].NewFileRva =  RiftTable->RiftEntryArray[ RiftIndexOrigin + 1 ].NewFileRva;
#ifdef TESTCODE
                                             ++CountRiftDeletions;
#endif // TESTCODE
                                             }
                                        }

                                    if ( TargetNext ) {

                                        //
                                        //  Coast the rift entry at [RiftIndexTarget+1]
                                        //  backwards to the Rva of the target.
                                        //

                                        LONG Delta = (LONG)( RiftTable->RiftEntryArray[ RiftIndexTarget + 1 ].OldFileRva - TargetRva );

                                        RiftTable->RiftEntryArray[ RiftIndexTarget + 1 ].OldFileRva -= Delta;
                                        RiftTable->RiftEntryArray[ RiftIndexTarget + 1 ].NewFileRva -= Delta;
#ifdef TESTCODE
                                        ++CountRiftModifications;
#endif // TESTCODE
                                        ASSERT( RiftTable->RiftEntryArray[ RiftIndexTarget ].OldFileRva <= RiftTable->RiftEntryArray[ RiftIndexTarget + 1 ].OldFileRva );

                                        if ( RiftTable->RiftEntryArray[ RiftIndexTarget ].OldFileRva == RiftTable->RiftEntryArray[ RiftIndexTarget + 1 ].OldFileRva ) {
                                             RiftTable->RiftEntryArray[ RiftIndexTarget ].NewFileRva =  RiftTable->RiftEntryArray[ RiftIndexTarget + 1 ].NewFileRva;
#ifdef TESTCODE
                                             ++CountRiftDeletions;
#endif // TESTCODE
                                             }
                                        }
                                    }
                                }
#ifdef TESTCODE
                            if ( ! (( OriginFound ) && ( TargetFound ))) {

                                ++CountUnmatchedBranches;

                                switch ( Instruction ) {

                                    case 0xE8:

                                        ++CountUnmatchedE8;

                                        if ( OriginFound ) {
                                            ++CountUnmatchedE8Targets;
                                            }
                                        else if ( InstructionsMatch ) {
                                            ASSERT( ! FollowersMatch );
                                            ++CountUnmatchedE8Followers;
                                            }
                                        else {
                                            ++CountUnmatchedE8Instructions;

                                            printf( "\rUnmatched E8 at old RVA %08X (VA %08X, FO %08X)\n"
                                                      "    with either new RVA %08X (VA %08X, FO %08X)\n"
                                                      "     or backcoasted RVA %08X (VA %08X, FO %08X)\n\n",
                                                    OriginRva - 5,
                                                    ( OriginRva - 5 ) + NtHeader->OptionalHeader.ImageBase,
                                                    FileOffset,
                                                    NewOriginRva1,
                                                    NewOriginVa1,
                                                    NewOriginMo1,
                                                    NewOriginRva2,
                                                    NewOriginVa2,
                                                    NewOriginMo2
                                                  );
                                            }


                                        break;

                                    case 0xE9:

                                        ++CountUnmatchedE9;

                                        if ( OriginFound ) {
                                            ++CountUnmatchedE9Targets;
                                            }
                                        else {
                                            ++CountUnmatchedE9Instructions;
                                            }

                                        break;

                                    default:

                                        ++CountUnmatched0F;

                                        if ( OriginFound ) {
                                            ++CountUnmatched0FTargets;
                                            }
                                        else if ( InstructionsMatch ) {
                                            ASSERT( ! FollowersMatch );
                                            ++CountUnmatched0FFollowers;
                                            }
                                        else {
                                            ++CountUnmatched0FInstructions;
                                            }

                                        if ( BranchInversion ) {
                                            ++CountBranchInversions;
                                            }

                                        break;

                                    }
                                }
#endif // TESTCODE
                            }

#endif // PATCH_APPLY_CODE_ONLY

                        NewTargetRva = GetNewRvaFromRiftTable( RiftTable, TargetRva );
                        NewOriginRva = GetNewRvaFromRiftTable( RiftTable, OriginRva );

                        NewDisplacement = NewTargetRva - NewOriginRva;

                        if ( NewDisplacement != DisplacementValue ) {
                            *(UNALIGNED LONG*)( OldFileMapped + FileOffset + DisplacementOffset ) = NewDisplacement;
#ifdef TESTCODE
                            ++CountRelativeBranchChanges;
#endif // TESTCODE
                            }

                        FileOffset = DisplacementOrigin - 1;
                        }
                    }

                else if ( NtHeader->FileHeader.Machine == IMAGE_FILE_MACHINE_ALPHA ) {

                    //
                    //  Need to implement the scan for Alpha platform
                    //  relative call/jmp/jcc opcodes.
                    //

                    }
                }
            }
        }

#ifdef TESTCODE

    printf( "\r%d modified relative branches\n", CountRelativeBranchChanges );
    printf( "%d rift back-coasting modifications due to branch inspection\n", CountRiftModifications );
    printf( "%d rift deletions due to branch inspection back-coasting\n", CountRiftDeletions );
    printf( "%d total unmatched relative branches, composed of:\n", CountUnmatchedBranches );

    printf( "\t%d unmatched E8 (call)\n", CountUnmatchedE8 );
    printf( "\t\t%d unmatched E8 (call) instructions\n", CountUnmatchedE8Instructions );
    printf( "\t\t%d unmatched E8 (call) followers\n", CountUnmatchedE8Followers );
    printf( "\t\t%d unmatched E8 (call) targets\n", CountUnmatchedE8Targets );

    printf( "\t%d unmatched E9 (jmp)\n",    CountUnmatchedE9 );
    printf( "\t\t%d unmatched E9 (jmp) instructions\n", CountUnmatchedE9Instructions );
    printf( "\t\t%d unmatched E9 (jmp) targets\n", CountUnmatchedE9Targets );

    printf( "\t%d unmatched 0F 8x (jcc)\n", CountUnmatched0F );
    printf( "\t\t%d unmatched 0F 8x (jcc) instructions\n", CountUnmatched0FInstructions );
    printf( "\t\t\t%d unmatched 0F 8x (jcc) instruction inversions\n", CountBranchInversions );
    printf( "\t\t%d unmatched 0F 8x (jcc) followers\n", CountUnmatched0FFollowers );
    printf( "\t\t%d unmatched 0F 8x (jcc) targets\n", CountUnmatched0FTargets );

#endif // TESTCODE

    }


#endif // DONTCOMPILE

VOID
TransformOldFile_PE_RelativeJmps(
    IN UP_IMAGE_NT_HEADERS32 NtHeader,
    IN PVOID FileMappedImage,
    IN ULONG FileSize,
    IN PRIFT_TABLE RiftTable,
    IN PUCHAR HintMap
    )
    {
    UP_IMAGE_SECTION_HEADER SectionHeader;
    ULONG  SectionCount;
    PUCHAR SectionStart;
    PUCHAR SearchExtent;
    ULONG  SectionLength;
    ULONG  SectionOffset;
    ULONG  SectionBaseRva;
    ULONG  ImageLastRva;
    LONG   Displacement;
    LONG   NewDisplacement;
    ULONG  OffsetInSection;
    ULONG  OriginRva;
    ULONG  TargetRva;
    ULONG  NewOriginRva;
    ULONG  NewTargetRva;
    ULONG  TargetOffset;
    BOOL   Skip;
    ULONG  i;
    ULONG  j;
    PUCHAR p;

    //
    //  For each executable section, scan for opcodes that indicate
    //  relative branch instructions (different opcodes for different
    //  machine types).
    //

#ifdef TESTCODE

    ULONG CountRelativeBranchChanges = 0;

#endif // TESTCODE

    ImageLastRva  = NtHeader->OptionalHeader.SizeOfImage;
    SectionHeader = IMAGE_FIRST_SECTION( NtHeader );
    SectionCount  = NtHeader->FileHeader.NumberOfSections;

    for ( i = 0; i < SectionCount; i++ ) {

        if ( SectionHeader[ i ].Characteristics & IMAGE_SCN_MEM_EXECUTE ) {

            SectionBaseRva = SectionHeader[ i ].VirtualAddress;
            SectionLength  = MIN( SectionHeader[ i ].Misc.VirtualSize, SectionHeader[ i ].SizeOfRawData );
            SectionOffset  = SectionHeader[ i ].PointerToRawData;
            SectionStart   = (PUCHAR)FileMappedImage + SectionOffset;

            if (( SectionOffset < FileSize ) &&
                (( SectionOffset + SectionLength ) <= FileSize )) {

                if ( NtHeader->FileHeader.Machine == IMAGE_FILE_MACHINE_I386 ) {

                    SearchExtent = SectionStart + SectionLength - 5;

                    for ( p = SectionStart; p < SearchExtent; p++ ) {

                        if (( *p == 0xE9 ) ||       // jmp relative32 (E9)
                            (( *p == 0x0F ) &&      // jcc relative32 (0F 8x)
                             (( *( p + 1 ) & 0xF0 ) == 0x80 ) &&
                             ( ++p < SearchExtent ))) {

                            //
                            //  Validate that instruction and target are NOT
                            //  something we've already identified as something
                            //  else (reloc target, etc).
                            //

                            Skip = FALSE;

                            if (( *p & 0xF0 ) == 0x80 ) {
                                if ( HintMap[ SectionOffset + ( p - SectionStart ) - 1 ] & 0x01 ) {
                                    Skip = TRUE;
                                    }
                                }

                            if ( ! Skip ) {
                                for ( j = 0; j < 5; j++ ) {
                                    if ( HintMap[ SectionOffset + ( p - SectionStart ) + j ] & 0x01 ) {
                                        Skip = TRUE;
                                        break;
                                        }
                                    }
                                }

                            if ( ! Skip ) {

                                //
                                //  Relative displacement is stored as 32-bit
                                //  signed value following these opcodes.  The
                                //  displacement is relative to the NEXT
                                //  instruction, which is at (p + 5).
                                //
                                //  Also, for jmp and jcc instructions, verify that
                                //  the displacement is larger than +/- 127 because
                                //  if it wasn't, the instruction should have been
                                //  encoded as an 8-bit near branch, not a 32-bit
                                //  branch.  This prevents us from falsely matching
                                //  data that looks like:
                                //
                                //      xxE9xxxx 00000000
                                //

                                Displacement = *(UNALIGNED LONG*)( p + 1 );

                                if (( Displacement >  127 ) ||
                                    ( Displacement < -128 )) {

                                    OffsetInSection = (ULONG)(( p + 5 ) - SectionStart );
                                    OriginRva       = SectionBaseRva + OffsetInSection;
                                    TargetRva       = OriginRva + Displacement;

                                    //
                                    //  We expect a lot of false positives here because
                                    //  occurences of <E9>, and <0F><8x> will
                                    //  likely occur in other parts of the instruction
                                    //  stream so now we validate that the TargetRva
                                    //  falls within the image and within an executable
                                    //  section.
                                    //

                                    if ( TargetRva < ImageLastRva ) {

                                        TargetOffset = ImageRvaToFileOffset( NtHeader, TargetRva );

                                        if ( ! ( HintMap[ TargetOffset ] & 0x01 )) {

                                            //
                                            //  Looks like a valid TargetRva, so lookup its
                                            //  corresponding "new" RVA in the rift table.
                                            //

                                            NewTargetRva = GetNewRvaFromRiftTable( RiftTable, TargetRva );
                                            NewOriginRva = GetNewRvaFromRiftTable( RiftTable, OriginRva );

                                            NewDisplacement = NewTargetRva - NewOriginRva;

                                            if (( NewDisplacement >  127 ) ||
                                                ( NewDisplacement < -128 )) {

                                                if ( NewDisplacement != Displacement ) {

                                                    *(UNALIGNED LONG*)( p + 1 ) = NewDisplacement;
#ifdef TESTCODE
                                                    ++CountRelativeBranchChanges;
#endif // TESTCODE
                                                    }
                                                }

                                            else {

                                                //
                                                //  If new displacement is 8 bits, it would be
                                                //  encoded as an 8-bit relative instruction.
                                                //  For E9, instructions, that is EB.  For
                                                //  0F 8x instructions, that is 7x.  In both
                                                //  cases, we're shrinking the instruction stream.
                                                //  We'll leave the extra bytes alone.
                                                //

                                                if ( *p == 0xE9 ) {

                                                    *p = 0xEB;
                                                    *( p + 1 ) = (CHAR) NewDisplacement;
                                                    }

                                                else {

                                                    *( p - 1 ) = (UCHAR)(( *p & 0x0F ) | ( 0x70 ));
                                                    *p = (CHAR) NewDisplacement;
                                                    }

#ifdef TESTCODE
                                                ++CountRelativeBranchChanges;
#endif // TESTCODE

                                                }

                                            p += 4;
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }

                else if ( NtHeader->FileHeader.Machine == IMAGE_FILE_MACHINE_ALPHA ) {

                    //
                    //  Need to implement the scan for Alpha platform
                    //  relative jmp/jcc opcodes.
                    //

                    }
                }
            }
        }

#ifdef TESTCODE

    printf( "\r%9d modified relative branches\n", CountRelativeBranchChanges );

#endif // TESTCODE

    }


VOID
TransformOldFile_PE_RelativeCalls(
    IN UP_IMAGE_NT_HEADERS32 NtHeader,
    IN PVOID FileMappedImage,
    IN ULONG FileSize,
    IN PRIFT_TABLE RiftTable,
    IN PUCHAR HintMap
    )
    {
    UP_IMAGE_SECTION_HEADER SectionHeader;
    ULONG  SectionCount;
    PUCHAR SectionStart;
    PUCHAR SearchExtent;
    ULONG  SectionLength;
    ULONG  SectionOffset;
    ULONG  SectionBaseRva;
    ULONG  ImageLastRva;
    LONG   Displacement;
    LONG   NewDisplacement;
    ULONG  OffsetInSection;
    ULONG  OriginRva;
    ULONG  TargetRva;
    ULONG  NewOriginRva;
    ULONG  NewTargetRva;
    ULONG  TargetOffset;
    BOOL   Skip;
    ULONG  i;
    ULONG  j;
    PUCHAR p;

    //
    //  For each executable section, scan for opcodes that indicate
    //  relative call or branch instructions (different opcodes for
    //  different machine types).
    //

#ifdef TESTCODE

    ULONG CountRelativeCallChanges = 0;

#endif // TESTCODE

    ImageLastRva  = NtHeader->OptionalHeader.SizeOfImage;
    SectionHeader = IMAGE_FIRST_SECTION( NtHeader );
    SectionCount  = NtHeader->FileHeader.NumberOfSections;

    for ( i = 0; i < SectionCount; i++ ) {

        if ( SectionHeader[ i ].Characteristics & IMAGE_SCN_MEM_EXECUTE ) {

            SectionBaseRva = SectionHeader[ i ].VirtualAddress;
            SectionLength  = MIN( SectionHeader[ i ].Misc.VirtualSize, SectionHeader[ i ].SizeOfRawData );
            SectionOffset  = SectionHeader[ i ].PointerToRawData;
            SectionStart   = (PUCHAR)FileMappedImage + SectionOffset;

            if (( SectionOffset < FileSize ) &&
                (( SectionOffset + SectionLength ) <= FileSize )) {

                if ( NtHeader->FileHeader.Machine == IMAGE_FILE_MACHINE_I386 ) {

                    SearchExtent = SectionStart + SectionLength - 5;

                    for ( p = SectionStart; p < SearchExtent; p++ ) {

                        if ( *p == 0xE8 ) {         // call relative32

                            //
                            //  Validate that instruction and target are NOT
                            //  something we've already identified as something
                            //  else (reloc target, etc).
                            //

                            Skip = FALSE;

                            for ( j = 0; j < 5; j++ ) {
                                if ( HintMap[ SectionOffset + ( p - SectionStart ) + j ] & 0x01 ) {
                                    Skip = TRUE;
                                    break;
                                    }
                                }

                            if ( ! Skip ) {

                                //
                                //  Relative displacement is stored as 32-bit
                                //  signed value following these opcodes.  The
                                //  displacement is relative to the NEXT
                                //  instruction, which is at (p + 5).
                                //

                                Displacement    = *(UNALIGNED LONG*)( p + 1 );
                                OffsetInSection = (ULONG)(( p + 5 ) - SectionStart );
                                OriginRva       = SectionBaseRva + OffsetInSection;
                                TargetRva       = OriginRva + Displacement;

                                //
                                //  We expect a lot of false positives here because
                                //  occurences of <E8> will
                                //  likely occur in other parts of the instruction
                                //  stream so now we validate that the TargetRva
                                //  falls within the image and within an executable
                                //  section.
                                //

                                if ( TargetRva < ImageLastRva ) {

                                    TargetOffset = ImageRvaToFileOffset( NtHeader, TargetRva );

                                    if ( ! ( HintMap[ TargetOffset ] & 0x01 )) {

                                        //
                                        //  Looks like a valid TargetRva, so lookup its
                                        //  corresponding "new" RVA in the rift table.
                                        //

                                        NewTargetRva = GetNewRvaFromRiftTable( RiftTable, TargetRva );
                                        NewOriginRva = GetNewRvaFromRiftTable( RiftTable, OriginRva );

                                        NewDisplacement = NewTargetRva - NewOriginRva;

                                        if ( NewDisplacement != Displacement ) {

                                            *(UNALIGNED LONG*)( p + 1 ) = NewDisplacement;
#ifdef TESTCODE
                                            ++CountRelativeCallChanges;
#endif // TESTCODE
                                            }

                                        p += 4;
                                        }
                                    }
                                }
                            }
                        }
                    }

                else if ( NtHeader->FileHeader.Machine == IMAGE_FILE_MACHINE_ALPHA ) {

                    //
                    //  Need to implement the scan for Alpha platform
                    //  relative call/jmp/jcc opcodes.
                    //

                    }
                }
            }
        }

#ifdef TESTCODE

    printf( "\r%9d modified relative calls\n", CountRelativeCallChanges );

#endif // TESTCODE

    }


VOID
TransformOldFile_PE_MarkNonExe(
    IN UP_IMAGE_NT_HEADERS32 NtHeader,
    IN PUCHAR OldFileMapped,
    IN ULONG  OldFileSize,
    IN PUCHAR HintMap
    )
    {
    UP_IMAGE_SECTION_HEADER SectionHeader;
    ULONG SectionCount;
    ULONG Offset;
    ULONG Size;
    ULONG Rva;
    ULONG i;

    UNREFERENCED_PARAMETER( OldFileMapped );
    UNREFERENCED_PARAMETER( OldFileSize );

    //
    //  Need to mark all non-exectuble bytes in hint map:
    //
    //      Image header
    //      All PE image directories (import, export, etc)
    //      All non-executable sections
    //      All relocation targets
    //         (a reloc target can be in the middle of an instruction, but
    //          never the first byte of an instruction)
    //
    //  If we use other bits in hint map, may need to change these
    //  memsets to bitwise OR.
    //

    memset( HintMap + 0, 0x01, NtHeader->OptionalHeader.SizeOfHeaders );

    for ( i = 0; i < IMAGE_NUMBEROF_DIRECTORY_ENTRIES; i++ ) {

        Rva  = NtHeader->OptionalHeader.DataDirectory[ i ].VirtualAddress;
        Size = NtHeader->OptionalHeader.DataDirectory[ i ].Size;

        if (( Rva != 0 ) && ( Size != 0 )) {
            Offset = ImageRvaToFileOffset( NtHeader, Rva );
            memset( HintMap + Offset, 0x01, Size );
            }
        }

    SectionHeader = IMAGE_FIRST_SECTION( NtHeader );
    SectionCount  = NtHeader->FileHeader.NumberOfSections;

    for ( i = 0; i < SectionCount; i++ ) {
        if ( ! ( SectionHeader[ i ].Characteristics & IMAGE_SCN_MEM_EXECUTE )) {
            memset( HintMap + SectionHeader[ i ].PointerToRawData, 0x01, SectionHeader[ i ].SizeOfRawData );
            }
        }
    }


typedef struct _RES_RECURSION_CONTEXT {
    PRIFT_TABLE RiftTable;
    PUCHAR      ResBase;
    PUCHAR      ResEnd;
    ULONG       ResSize;
    ULONG       ResDone;
    ULONG       ResTime;
    ULONG       OldResRva;
    ULONG       NewResRva;
    } RES_RECURSION_CONTEXT, *PRES_RECURSION_CONTEXT;


VOID
TransformResourceRecursive(
    IN PRES_RECURSION_CONTEXT ResContext,
    IN UP_IMAGE_RESOURCE_DIRECTORY ResDir
    )
    {
    UP_IMAGE_RESOURCE_DIRECTORY_ENTRY ResEntry;
    UP_IMAGE_RESOURCE_DATA_ENTRY ResData;
    ULONG ResEntryCount;
    ULONG NewOffset;
    ULONG NewRva;

    if (((PUCHAR)ResDir + sizeof( IMAGE_RESOURCE_DIRECTORY )) < ResContext->ResEnd ) {

        ResContext->ResDone += sizeof( *ResDir );

        if ( ResContext->ResDone > ResContext->ResSize ) {
            return;
            }

        if ( ResDir->TimeDateStamp != ResContext->ResTime ) {
             ResDir->TimeDateStamp  = ResContext->ResTime;
             }

        ResEntryCount = ResDir->NumberOfNamedEntries + ResDir->NumberOfIdEntries;
        ResEntry = (UP_IMAGE_RESOURCE_DIRECTORY_ENTRY)( ResDir + 1 );

        while (( ResEntryCount > 0 ) && ((PUCHAR)ResEntry < ( ResContext->ResEnd - sizeof( *ResEntry )))) {

            if ( ResEntry->DataIsDirectory ) {

                TransformResourceRecursive(
                    ResContext,
                    (UP_IMAGE_RESOURCE_DIRECTORY)( ResContext->ResBase + ResEntry->OffsetToDirectory )
                    );
                }

            else {

                ResData = (UP_IMAGE_RESOURCE_DATA_ENTRY)( ResContext->ResBase + ResEntry->OffsetToData );

                if (((PUCHAR)ResData > ( ResContext->ResBase )) &&
                    ((PUCHAR)ResData < ( ResContext->ResEnd - sizeof( *ResData )))) {

                    ResContext->ResDone += ResData->Size;

                    if ( ResContext->ResDone > ResContext->ResSize ) {
                        return;
                        }

                    NewRva = GetNewRvaFromRiftTable( ResContext->RiftTable, ResData->OffsetToData );

                    if ( ResData->OffsetToData != NewRva ) {
                         ResData->OffsetToData  = NewRva;
                         }
                    }
                }

            NewOffset = GetNewRvaFromRiftTable( ResContext->RiftTable, ResContext->OldResRva + ResEntry->OffsetToDirectory ) - ResContext->NewResRva;

            if ( ResEntry->OffsetToDirectory != NewOffset ) {
                 ResEntry->OffsetToDirectory  = NewOffset;
                 }

            if ( ResEntry->NameIsString ) {

                NewOffset = GetNewRvaFromRiftTable( ResContext->RiftTable, ResContext->OldResRva + ResEntry->NameOffset ) - ResContext->NewResRva;

                if ( ResEntry->NameOffset != NewOffset ) {
                     ResEntry->NameOffset  = NewOffset;
                     }
                }

            ResContext->ResDone += sizeof( *ResEntry );

            if ( ResContext->ResDone > ResContext->ResSize ) {
                return;
                }

            ++ResEntry;
            --ResEntryCount;
            }
        }
    }


VOID
TransformOldFile_PE_Resources(
    IN UP_IMAGE_NT_HEADERS32 NtHeader,
    IN PUCHAR OldFileMapped,
    IN ULONG  OldFileSize,
    IN ULONG  NewFileResTime,
    IN PRIFT_TABLE RiftTable
    )
    {
    RES_RECURSION_CONTEXT ResContext;

    ResContext.ResBase = ImageDirectoryMappedAddress(
                             NtHeader,
                             IMAGE_DIRECTORY_ENTRY_RESOURCE,
                             &ResContext.ResSize,
                             OldFileMapped,
                             OldFileSize
                             );

    if ( ResContext.ResBase ) {

        ResContext.ResEnd    = ResContext.ResBase + ResContext.ResSize;
        ResContext.ResDone   = 0;
        ResContext.OldResRva = ImageDirectoryRvaAndSize( NtHeader, IMAGE_DIRECTORY_ENTRY_RESOURCE, NULL );
        ResContext.NewResRva = GetNewRvaFromRiftTable( RiftTable, ResContext.OldResRva );
        ResContext.ResTime   = NewFileResTime;
        ResContext.RiftTable = RiftTable;

        TransformResourceRecursive(
            &ResContext,
            (UP_IMAGE_RESOURCE_DIRECTORY) ResContext.ResBase
            );
        }
    }


BOOL
TransformCoffImage(
    IN     ULONG  TransformOptions,
    IN OUT UP_IMAGE_NT_HEADERS32 NtHeader,
    IN OUT PUCHAR OldFileMapped,
    IN     ULONG  OldFileSize,
    IN     ULONG  NewFileResTime,
    IN OUT PRIFT_TABLE RiftTable,
    IN OUT PUCHAR HintMap,
    ...
    )
    {
    PUCHAR InternalHintMap = NULL;

    //
    //  First, zero out the rift usage array
    //

    if ( RiftTable->RiftUsageArray != NULL ) {
        ZeroMemory( RiftTable->RiftUsageArray, RiftTable->RiftEntryAlloc * sizeof( RiftTable->RiftUsageArray[ 0 ] ));
        }

    //
    //  Allocated parallel "hint" mapping the same size as the old
    //  file.  Each one of the 8 bits corresponding to each byte in
    //  the old file can be used to track information about that
    //  byte during the transformations.
    //

    if ( HintMap == NULL ) {
        InternalHintMap = MyVirtualAlloc( OldFileSize );
        HintMap = InternalHintMap;
        }

    if ( HintMap != NULL ) {

        //
        //  Apply PE image transforms (each inside try/except)
        //

        __try {
            TransformOldFile_PE_MarkNonExe( NtHeader, OldFileMapped, OldFileSize, HintMap );
            }
        __except( EXCEPTION_EXECUTE_HANDLER ) {
            }

        if ( ! ( TransformOptions & PATCH_TRANSFORM_NO_RELOCS )) {
            __try {
                TransformOldFile_PE_Relocations( NtHeader, OldFileMapped, OldFileSize, RiftTable, HintMap );
                }
            __except( EXCEPTION_EXECUTE_HANDLER ) {
                }
            }

        if ( ! ( TransformOptions & PATCH_TRANSFORM_NO_IMPORTS )) {
            __try {
                TransformOldFile_PE_Imports( NtHeader, OldFileMapped, OldFileSize, RiftTable, HintMap );
                }
            __except( EXCEPTION_EXECUTE_HANDLER ) {
                }
            }

        if ( ! ( TransformOptions & PATCH_TRANSFORM_NO_EXPORTS )) {
            __try {
                TransformOldFile_PE_Exports( NtHeader, OldFileMapped, OldFileSize, RiftTable, HintMap );
                }
            __except( EXCEPTION_EXECUTE_HANDLER ) {
                }
            }

        if ( ! ( TransformOptions & PATCH_TRANSFORM_NO_RELJMPS )) {
            __try {
                TransformOldFile_PE_RelativeJmps( NtHeader, OldFileMapped, OldFileSize, RiftTable, HintMap );
                }
            __except( EXCEPTION_EXECUTE_HANDLER ) {
                }
            }

        if ( ! ( TransformOptions & PATCH_TRANSFORM_NO_RELCALLS )) {
            __try {
                TransformOldFile_PE_RelativeCalls( NtHeader, OldFileMapped, OldFileSize, RiftTable, HintMap );
                }
            __except( EXCEPTION_EXECUTE_HANDLER ) {
                }
            }

        if ( ! ( TransformOptions & PATCH_TRANSFORM_NO_RESOURCE )) {
            __try {
                TransformOldFile_PE_Resources( NtHeader, OldFileMapped, OldFileSize, NewFileResTime, RiftTable );
                }
            __except( EXCEPTION_EXECUTE_HANDLER ) {
                }
            }

        if ( InternalHintMap != NULL ) {
            MyVirtualFree( InternalHintMap );
            }
        }

    return TRUE;
    }


#ifndef PATCH_APPLY_CODE_ONLY


BOOL
AddRiftEntryToTable(
    IN PRIFT_TABLE RiftTable,
    IN ULONG       OldRva,
    IN ULONG       NewRva
    )
    {
    ULONG RiftIndex;

    if (( OldRva != 0 ) && ( NewRva != 0 )) {

        RiftIndex = RiftTable->RiftEntryCount;

        if (( RiftIndex + 1 ) < RiftTable->RiftEntryAlloc ) {
            RiftTable->RiftEntryCount = RiftIndex + 1;
            RiftTable->RiftEntryArray[ RiftIndex ].OldFileRva = OldRva;
            RiftTable->RiftEntryArray[ RiftIndex ].NewFileRva = NewRva;
            return TRUE;
            }
        }

    return FALSE;
    }


BOOL
InsertRiftEntryInSortedTable(
    IN PRIFT_TABLE RiftTable,
    IN ULONG       RiftIndex,
    IN ULONG       OldRva,
    IN ULONG       NewRva
    )
    {
    if (( OldRva != 0 ) && ( NewRva != 0 )) {

        //
        //  First scoot to the correct index in case RiftIndex is off by a few.
        //

        while (( RiftIndex > 0 ) && ( RiftTable->RiftEntryArray[ RiftIndex ].OldFileRva > OldRva )) {
            --RiftIndex;
            }

        while (( RiftIndex < RiftTable->RiftEntryCount ) && ( RiftTable->RiftEntryArray[ RiftIndex ].OldFileRva < OldRva )) {
            ++RiftIndex;
            }

        if ( RiftIndex < RiftTable->RiftEntryCount ) {

            if ( RiftTable->RiftEntryArray[ RiftIndex ].OldFileRva == OldRva ) {

                //
                //  Don't insert duplicates.  If it matches an existing OldRva,
                //  just warn if the NewRva doesn't match the rift.
                //

#ifdef TESTCODE

                if ( RiftTable->RiftEntryArray[ RiftIndex ].NewFileRva != NewRva ) {

                    printf( "\rAttempt to insert different rift at same OldRva\n"
                            "    OldRva:%08X NewRva:%08X (discarded)\n"
                            "    OldRva:%08X NewRva:%08X (kept)\n\n",
                            OldRva,
                            NewRva,
                            RiftTable->RiftEntryArray[ RiftIndex ].OldFileRva,
                            RiftTable->RiftEntryArray[ RiftIndex ].NewFileRva
                          );

                    return FALSE;
                    }

#endif /* TESTCODE */

                return TRUE;
                }
            }

        //
        //  Verify we have enough allocation to insert a new entry.
        //

        if (( RiftTable->RiftEntryCount + 1 ) < RiftTable->RiftEntryAlloc ) {

            //
            //  Slide everything from RiftIndex to make room for new
            //  entry at RiftIndex.
            //

            LONG CountToMove = RiftTable->RiftEntryCount - RiftIndex;

            if ( CountToMove > 0 ) {

                MoveMemory(
                    &RiftTable->RiftEntryArray[ RiftIndex + 1 ],
                    &RiftTable->RiftEntryArray[ RiftIndex ],
                    CountToMove * sizeof( RiftTable->RiftEntryArray[ 0 ] )
                    );

#ifdef DONTCOMPILE  // we don't use the RiftUsageArray when we're inserting

                if ( RiftTable->RiftUsageArray ) {

                    MoveMemory(
                        &RiftTable->RiftUsageArray[ RiftIndex + 1 ],
                        &RiftTable->RiftUsageArray[ RiftIndex ],
                        CountToMove * sizeof( RiftTable->RiftUsageArray[ 0 ] )
                        );
                    }

#endif // DONTCOMPILE

                }

#ifdef DONTCOMPILE  // we don't use the RiftUsageArray when we're inserting

            RiftTable->RiftUsageArray[ RiftIndex ] = 0;

#endif // DONTCOMPILE

            RiftTable->RiftEntryArray[ RiftIndex ].OldFileRva = OldRva;
            RiftTable->RiftEntryArray[ RiftIndex ].NewFileRva = NewRva;
            RiftTable->RiftEntryCount++;

            return TRUE;
            }
        }

    return FALSE;
    }


VOID
__inline
SwapRifts(
    PRIFT_ENTRY One,
    PRIFT_ENTRY Two
    )
    {
    RIFT_ENTRY Tmp;

    Tmp  = *One;
    *One = *Two;
    *Two =  Tmp;
    }


VOID
__fastcall
RiftQsort(
    PRIFT_ENTRY LowerBound,
    PRIFT_ENTRY UpperBound
    )
    {
    PRIFT_ENTRY Lower = LowerBound;
    PRIFT_ENTRY Upper = UpperBound;
    PRIFT_ENTRY Pivot = Lower + (( Upper - Lower ) / 2 );
    ULONG PivotRva = Pivot->OldFileRva;

    do  {

        while (( Lower <= Upper ) && ( Lower->OldFileRva <= PivotRva )) {
            ++Lower;
            }

        while (( Upper >= Lower ) && ( Upper->OldFileRva >= PivotRva )) {
            --Upper;
            }

        if ( Lower < Upper ) {
            SwapRifts( Lower++, Upper-- );
            }
        }

    while ( Lower <= Upper );

    if ( Lower < Pivot ) {
        SwapRifts( Lower, Pivot );
        Pivot = Lower;
        }
    else if ( Upper > Pivot ) {
        SwapRifts( Upper, Pivot );
        Pivot = Upper;
        }

    if ( LowerBound < ( Pivot - 1 )) {
        RiftQsort( LowerBound, Pivot - 1 );
        }

    if (( Pivot + 1 ) < UpperBound ) {
        RiftQsort( Pivot + 1, UpperBound );
        }
    }


VOID
RiftSortAndRemoveDuplicates(
    IN PUCHAR                OldFileMapped,
    IN ULONG                 OldFileSize,
    IN UP_IMAGE_NT_HEADERS32 OldFileNtHeader,
    IN PUCHAR                NewFileMapped,
    IN ULONG                 NewFileSize,
    IN UP_IMAGE_NT_HEADERS32 NewFileNtHeader,
    IN OUT PRIFT_TABLE       RiftTable
    )
    {
    ULONG i, n;

    if ( RiftTable->RiftEntryCount > 1 ) {

        n = RiftTable->RiftEntryCount - 1;

        RiftQsort( &RiftTable->RiftEntryArray[ 0 ], &RiftTable->RiftEntryArray[ n ] );

        for ( i = 0; i < n; i++ ) {

            while (( i < n ) &&
                   ( RiftTable->RiftEntryArray[ i     ].OldFileRva ==
                     RiftTable->RiftEntryArray[ i + 1 ].OldFileRva )) {

                if ( RiftTable->RiftEntryArray[ i     ].NewFileRva !=
                     RiftTable->RiftEntryArray[ i + 1 ].NewFileRva ) {

                    //
                    //  This is an ambiguous entry since the OldRva values
                    //  match but the NewRva values do not.  Inspect the
                    //  bytes in the old and new files and choose the one
                    //  that is correct.  If both are correct, or neither is
                    //  correct, choose the lower of the two NewRva values.
                    //

                    ULONG  ChosenNewRva;
                    PUCHAR OldFileRiftMa;
                    PUCHAR NewFileRiftMa1;
                    PUCHAR NewFileRiftMa2;

#ifdef TESTCODE
                    LPSTR Method = "lower";
#endif

                    ChosenNewRva = MIN( RiftTable->RiftEntryArray[ i     ].NewFileRva,
                                        RiftTable->RiftEntryArray[ i + 1 ].NewFileRva );

                    OldFileRiftMa = ImageRvaToMappedAddress(
                                        OldFileNtHeader,
                                        RiftTable->RiftEntryArray[ i ].OldFileRva,
                                        OldFileMapped,
                                        OldFileSize
                                        );

                    NewFileRiftMa1 = ImageRvaToMappedAddress(
                                         NewFileNtHeader,
                                         RiftTable->RiftEntryArray[ i ].NewFileRva,
                                         NewFileMapped,
                                         NewFileSize
                                         );

                    NewFileRiftMa2 = ImageRvaToMappedAddress(
                                         NewFileNtHeader,
                                         RiftTable->RiftEntryArray[ i + 1 ].NewFileRva,
                                         NewFileMapped,
                                         NewFileSize
                                         );

                    //
                    //  Use try/except to touch the mapped files.
                    //

                    __try {

                        if ( OldFileRiftMa != NULL ) {

                            if ((  NewFileRiftMa1 != NULL ) &&
                                ( *NewFileRiftMa1 == *OldFileRiftMa ) &&
                                ((  NewFileRiftMa2 == NULL ) ||
                                 ( *NewFileRiftMa2 != *OldFileRiftMa ))) {

                                ChosenNewRva = RiftTable->RiftEntryArray[ i ].NewFileRva;
#ifdef TESTCODE
                                Method = "match inspection";
#endif
                                }

                            else if ((  NewFileRiftMa2 != NULL ) &&
                                     ( *NewFileRiftMa2 == *OldFileRiftMa ) &&
                                     ((  NewFileRiftMa1 == NULL ) ||
                                      ( *NewFileRiftMa1 != *OldFileRiftMa ))) {

                                ChosenNewRva = RiftTable->RiftEntryArray[ i + 1 ].NewFileRva;
#ifdef TESTCODE
                                Method = "match inspection";
#endif
                                }
                            }
                        }

                    __except( EXCEPTION_EXECUTE_HANDLER ) {
                        }

#ifdef TESTCODE
                    printf(
                        "RiftInfo contains ambiguous entries:\n"
                        "    OldRva:%08X NewRva:%08X (discarded)\n"
                        "    OldRva:%08X NewRva:%08X (kept %s)\n\n",
                        RiftTable->RiftEntryArray[ i ].OldFileRva,
                        ( RiftTable->RiftEntryArray[ i ].NewFileRva == ChosenNewRva ) ?
                          RiftTable->RiftEntryArray[ i + 1 ].NewFileRva :
                          RiftTable->RiftEntryArray[ i ].NewFileRva,
                        RiftTable->RiftEntryArray[ i ].OldFileRva,
                        ChosenNewRva,
                        Method
                        );
#endif
                    RiftTable->RiftEntryArray[ i + 1 ].NewFileRva = ChosenNewRva;
                    }

                MoveMemory(
                    &RiftTable->RiftEntryArray[ i ],
                    &RiftTable->RiftEntryArray[ i + 1 ],
                    ( n - i ) * sizeof( RIFT_ENTRY )
                    );

                --n;

                }
            }

        RiftTable->RiftEntryCount = n + 1;
        }
    }


#ifdef _M_IX86

//
//  The x86 compiler might not optimize (a=x/y;b=x%y) into a single
//  divide instruction that provides both the quotient and the remainder.
//

#pragma warning( disable: 4035 )    // no return value

__inline
DWORDLONG
QuotientAndRemainder(
    IN ULONG Dividend,
    IN ULONG Divisor
    )
    {
    __asm {
        mov     eax, Dividend
        xor     edx, edx
        div     Divisor         ; eax <- quotient, edx <- remainder
        }
    }

#pragma warning( default: 4035 )    // no return value

#else // ! _M_IX86

__inline
DWORDLONG
QuotientAndRemainder(
    IN ULONG Dividend,
    IN ULONG Divisor
    )
    {
    ULONG Quotient  = ( Dividend / Divisor );
    ULONG Remainder = ( Dividend % Divisor );

    return (((DWORDLONG)Remainder << 32 ) | Quotient );
    }

#endif // ! _M_IX86


BOOL
IsMatchingResourceString(
    IN UP_IMAGE_RESOURCE_DIR_STRING_U OldString,
    IN UP_IMAGE_RESOURCE_DIR_STRING_U NewString
    )
    {
    USHORT Length;

    if ( OldString->Length != NewString->Length ) {
        return FALSE;
        }

    Length = OldString->Length;

    while ( Length-- ) {
        if ( OldString->NameString[ Length ] != NewString->NameString[ Length ] ) {
            return FALSE;
            }
        }

    return TRUE;
    }


VOID
GetResourceRiftInfoRecursive(
    IN UP_IMAGE_RESOURCE_DIRECTORY OldResDir,
    IN PUCHAR OldResBase,
    IN PUCHAR OldResEnd,
    IN ULONG  OldResRva,
    IN UP_IMAGE_RESOURCE_DIRECTORY NewResDir,
    IN PUCHAR NewResBase,
    IN PUCHAR NewResEnd,
    IN ULONG  NewResRva,
    IN PRIFT_TABLE RiftTable
    )
    {
    UP_IMAGE_RESOURCE_DIRECTORY_ENTRY OldResEntry;
    UP_IMAGE_RESOURCE_DIRECTORY_ENTRY NewResEntry;
    UP_IMAGE_RESOURCE_DATA_ENTRY OldResData;
    UP_IMAGE_RESOURCE_DATA_ENTRY NewResData;
    ULONG OldResEntryCount;
    ULONG NewResEntryCount;

    if ((( (PUCHAR) OldResDir + sizeof( IMAGE_RESOURCE_DIRECTORY )) < OldResEnd ) &&
        (( (PUCHAR) NewResDir + sizeof( IMAGE_RESOURCE_DIRECTORY )) < NewResEnd )) {

        OldResEntryCount = OldResDir->NumberOfNamedEntries + OldResDir->NumberOfIdEntries;
        OldResEntry = (UP_IMAGE_RESOURCE_DIRECTORY_ENTRY) ( OldResDir + 1 );

        while (( OldResEntryCount > 0 ) && ((PUCHAR)OldResEntry < OldResEnd )) {

            NewResEntryCount = NewResDir->NumberOfNamedEntries + NewResDir->NumberOfIdEntries;
            NewResEntry = (UP_IMAGE_RESOURCE_DIRECTORY_ENTRY)( NewResDir + 1 );

            while ( NewResEntryCount > 0 ) {

                if ( (PUCHAR) NewResEntry > NewResEnd ) {
                    NewResEntryCount = 0;
                    break;
                    }

                if ( !OldResEntry->NameIsString && !NewResEntry->NameIsString &&
                     ( OldResEntry->Id == NewResEntry->Id )) {
                    break;
                    }
                else if (( OldResEntry->NameIsString && NewResEntry->NameIsString ) &&
                        IsMatchingResourceString(
                            (UP_IMAGE_RESOURCE_DIR_STRING_U)( OldResBase + OldResEntry->NameOffset ),
                            (UP_IMAGE_RESOURCE_DIR_STRING_U)( NewResBase + NewResEntry->NameOffset ))) {
                    break;
                    }

                ++NewResEntry;
                --NewResEntryCount;
                }

            if ( NewResEntryCount > 0 ) {

                if ( OldResEntry->NameIsString ) {

                    AddRiftEntryToTable(
                        RiftTable,
                        OldResRva + OldResEntry->NameOffset,
                        NewResRva + NewResEntry->NameOffset
                        );
                    }

                AddRiftEntryToTable(
                    RiftTable,
                    OldResRva + OldResEntry->OffsetToDirectory,
                    NewResRva + NewResEntry->OffsetToDirectory
                    );

                if ( OldResEntry->DataIsDirectory ) {

                    GetResourceRiftInfoRecursive(
                        (UP_IMAGE_RESOURCE_DIRECTORY)( OldResBase + OldResEntry->OffsetToDirectory ),
                        OldResBase,
                        OldResEnd,
                        OldResRva,
                        (UP_IMAGE_RESOURCE_DIRECTORY)( NewResBase + NewResEntry->OffsetToDirectory ),
                        NewResBase,
                        NewResEnd,
                        NewResRva,
                        RiftTable
                        );
                    }
                else {

                    OldResData = (UP_IMAGE_RESOURCE_DATA_ENTRY)( OldResBase + OldResEntry->OffsetToData );
                    NewResData = (UP_IMAGE_RESOURCE_DATA_ENTRY)( NewResBase + NewResEntry->OffsetToData );

                    AddRiftEntryToTable(
                        RiftTable,
                        OldResData->OffsetToData,
                        NewResData->OffsetToData
                        );
                    }
                }

            ++OldResEntry;
            --OldResEntryCount;
            }
        }
    }


BOOL
GetImageNonSymbolRiftInfo(
    IN PUCHAR OldFileMapped,
    IN ULONG  OldFileSize,
    IN UP_IMAGE_NT_HEADERS32 OldFileNtHeader,
    IN PUCHAR NewFileMapped,
    IN ULONG  NewFileSize,
    IN UP_IMAGE_NT_HEADERS32 NewFileNtHeader,
    IN HANDLE SubAllocator,
    IN PRIFT_TABLE RiftTable
    )
    {

    //
    //  Create rifts for sections by section names.
    //

    {
    UP_IMAGE_SECTION_HEADER OldSectionHeader;
    UP_IMAGE_SECTION_HEADER NewSectionHeader;
    ULONG OldSectionCount;
    ULONG NewSectionCount;
    ULONG i, j;

    OldSectionHeader = IMAGE_FIRST_SECTION( OldFileNtHeader );
    OldSectionCount  = OldFileNtHeader->FileHeader.NumberOfSections;

    NewSectionHeader = IMAGE_FIRST_SECTION( NewFileNtHeader );
    NewSectionCount  = NewFileNtHeader->FileHeader.NumberOfSections;

    ASSERT( sizeof( OldSectionHeader->Name ) == sizeof( DWORDLONG ));

    for ( i = 0; i < OldSectionCount; i++ ) {

        for ( j = 0; j < NewSectionCount; j++ ) {

            if ( *(UNALIGNED DWORDLONG *)OldSectionHeader[ i ].Name ==
                 *(UNALIGNED DWORDLONG *)NewSectionHeader[ j ].Name ) {

                //
                //  Add a rift entry for this section name match.
                //
                //  Note that we create rift values here that are minus
                //  one from the actual section boundary because if a
                //  symbol exists at the start of the section, its rift
                //  entry would conflict with this section entry.
                //

                AddRiftEntryToTable(
                    RiftTable,
                    OldSectionHeader[ i ].VirtualAddress - 1,
                    NewSectionHeader[ i ].VirtualAddress - 1
                    );

                break;
                }
            }
        }
    }


    //
    //  Create rifts for image directories.
    //

    {
    ULONG i, n;

    n = MIN( OldFileNtHeader->OptionalHeader.NumberOfRvaAndSizes,
             NewFileNtHeader->OptionalHeader.NumberOfRvaAndSizes );

    for ( i = 0; i < n; i++ ) {

        if (( OldFileNtHeader->OptionalHeader.DataDirectory[ i ].VirtualAddress ) &&
            ( OldFileNtHeader->OptionalHeader.DataDirectory[ i ].Size           ) &&
            ( NewFileNtHeader->OptionalHeader.DataDirectory[ i ].VirtualAddress ) &&
            ( NewFileNtHeader->OptionalHeader.DataDirectory[ i ].Size           )) {

            AddRiftEntryToTable(
                RiftTable,
                OldFileNtHeader->OptionalHeader.DataDirectory[ i ].VirtualAddress,
                NewFileNtHeader->OptionalHeader.DataDirectory[ i ].VirtualAddress
                );
            }
        }
    }

    //
    //  Create rifts for image export directory
    //

    {
    UP_IMAGE_EXPORT_DIRECTORY OldExportDir;
    UP_IMAGE_EXPORT_DIRECTORY NewExportDir;
    ULONG   OldExportIndex;
    ULONG   NewExportIndex;
    ULONG   OldExportNameCount;
    ULONG   NewExportNameCount;
    ULONG   OldExportFunctionCount;
    ULONG   NewExportFunctionCount;
    ULONG   UNALIGNED* OldExportFunctionArray;
    ULONG   UNALIGNED* NewExportFunctionArray;
    USHORT  UNALIGNED* OldExportNameToOrdinal;
    USHORT  UNALIGNED* NewExportNameToOrdinal;
    ULONG   UNALIGNED* OldExportNameArray;
    ULONG   UNALIGNED* NewExportNameArray;
    LPSTR   OldExportName;
    LPSTR   NewExportName;
    ULONG   OldOrdinal;
    ULONG   NewOrdinal;
    LONG    OrdinalBaseNewToOld;
    PBYTE   NewExportOrdinalNameExists;
    PSYMBOL_NODE NewExportSymbolNode;
    SYMBOL_TREE  NewExportNameTree;

    OldExportDir = ImageDirectoryMappedAddress(
                       OldFileNtHeader,
                       IMAGE_DIRECTORY_ENTRY_EXPORT,
                       NULL,
                       OldFileMapped,
                       OldFileSize
                       );

    NewExportDir = ImageDirectoryMappedAddress(
                       NewFileNtHeader,
                       IMAGE_DIRECTORY_ENTRY_EXPORT,
                       NULL,
                       NewFileMapped,
                       NewFileSize
                       );

    if (( OldExportDir ) && ( NewExportDir )) {

        AddRiftEntryToTable( RiftTable, (ULONG)( OldExportDir->Name ),                  (ULONG)( NewExportDir->Name ));
        AddRiftEntryToTable( RiftTable, (ULONG)( OldExportDir->AddressOfFunctions ),    (ULONG)( NewExportDir->AddressOfFunctions ));
        AddRiftEntryToTable( RiftTable, (ULONG)( OldExportDir->AddressOfNames ),        (ULONG)( NewExportDir->AddressOfNames ));
        AddRiftEntryToTable( RiftTable, (ULONG)( OldExportDir->AddressOfNameOrdinals ), (ULONG)( NewExportDir->AddressOfNameOrdinals ));

        //
        //  Now build a tree of new export names, then walk old export names
        //  looking for matches in tree of new export names.
        //

        SymRBInitTree(
            &NewExportNameTree,
            SubAllocator
            );

        //
        //  First insert new export names.
        //

        NewExportNameCount     = NewExportDir->NumberOfNames;
        NewExportFunctionCount = NewExportDir->NumberOfFunctions;
        NewExportFunctionArray = ImageRvaToMappedAddress( NewFileNtHeader, (ULONG) NewExportDir->AddressOfFunctions,    NewFileMapped, NewFileSize );
        NewExportNameToOrdinal = ImageRvaToMappedAddress( NewFileNtHeader, (ULONG) NewExportDir->AddressOfNameOrdinals, NewFileMapped, NewFileSize );
        NewExportNameArray     = ImageRvaToMappedAddress( NewFileNtHeader, (ULONG) NewExportDir->AddressOfNames,        NewFileMapped, NewFileSize );

        if ( NewExportNameArray ) {

            for ( NewExportIndex = 0; NewExportIndex < NewExportNameCount; NewExportIndex++ ) {

                if ( NewExportNameArray[ NewExportIndex ] ) {

                    NewExportName = ImageRvaToMappedAddress( NewFileNtHeader, NewExportNameArray[ NewExportIndex ], NewFileMapped, NewFileSize );

                    if ( NewExportName ) {

                        SymRBInsert( &NewExportNameTree, NewExportName, NewExportIndex );

                        }
                    }
                }
            }

        //
        //  Walk old export names and match them up.
        //

        OldExportNameCount     = OldExportDir->NumberOfNames;
        OldExportFunctionCount = OldExportDir->NumberOfFunctions;
        OldExportFunctionArray = ImageRvaToMappedAddress( OldFileNtHeader, (ULONG) OldExportDir->AddressOfFunctions,    OldFileMapped, OldFileSize );
        OldExportNameToOrdinal = ImageRvaToMappedAddress( OldFileNtHeader, (ULONG) OldExportDir->AddressOfNameOrdinals, OldFileMapped, OldFileSize );
        OldExportNameArray     = ImageRvaToMappedAddress( OldFileNtHeader, (ULONG) OldExportDir->AddressOfNames,        OldFileMapped, OldFileSize );

        if ( OldExportNameArray ) {

            for ( OldExportIndex = 0; OldExportIndex < OldExportNameCount; OldExportIndex++ ) {

                if ( OldExportNameArray[ OldExportIndex ] ) {

                    OldExportName = ImageRvaToMappedAddress( OldFileNtHeader, OldExportNameArray[ OldExportIndex ], OldFileMapped, OldFileSize );

                    if ( OldExportName ) {

                        NewExportSymbolNode = SymRBFind( &NewExportNameTree, OldExportName );

                        if ( NewExportSymbolNode ) {

                            //
                            //  Found a name match.  The Rva field in the
                            //  symbol node contains the index into the
                            //  NewExportNameArray.
                            //
                            //  This match gives us two rift entries: one
                            //  for the locations of the names themselves,
                            //  and another for the locations of the
                            //  functions corresponding to those names.
                            //

                            NewExportIndex = NewExportSymbolNode->Rva;

                            AddRiftEntryToTable(
                                RiftTable,
                                OldExportNameArray[ OldExportIndex ],
                                NewExportNameArray[ NewExportIndex ]
                                );

                            if ( OldExportNameToOrdinal && NewExportNameToOrdinal ) {

                                OldOrdinal = OldExportNameToOrdinal[ OldExportIndex ];
                                NewOrdinal = NewExportNameToOrdinal[ NewExportIndex ];

                                if (( OldOrdinal < OldExportFunctionCount ) &&
                                    ( NewOrdinal < NewExportFunctionCount )) {

                                    AddRiftEntryToTable(
                                        RiftTable,
                                        OldExportFunctionArray[ OldOrdinal ],
                                        NewExportFunctionArray[ NewOrdinal ]
                                        );
                                    }
                                }
                            }
                        }
                    }
                }
            }

        //
        //  Now use ordinals to match any exports that don't have names.
        //  We use the NameToOrdinal table to determine if a name exists.
        //  For all ordinals that don't have a NameToOrdinal entry, we
        //  create a match.
        //

        if (( NewExportFunctionArray ) && ( NewExportNameToOrdinal )) {

            NewExportOrdinalNameExists = SubAllocate( SubAllocator, NewExportFunctionCount );

            if ( NewExportOrdinalNameExists != NULL ) {

                for ( NewExportIndex = 0; NewExportIndex < NewExportNameCount; NewExportIndex++ ) {

                    NewOrdinal = NewExportNameToOrdinal[ NewExportIndex ];

                    if ( NewOrdinal < NewExportFunctionCount ) {

                        NewExportOrdinalNameExists[ NewOrdinal ] = TRUE;

                        }
                    }

                OrdinalBaseNewToOld = (LONG)NewExportDir->Base - (LONG)OldExportDir->Base;

                for ( NewOrdinal = 0; NewOrdinal < NewExportFunctionCount; NewOrdinal++ ) {

                    if ( ! NewExportOrdinalNameExists[ NewOrdinal ] ) {

                        OldOrdinal = NewOrdinal + OrdinalBaseNewToOld;

                        if ( OldOrdinal < OldExportFunctionCount ) {

                            AddRiftEntryToTable(
                                RiftTable,
                                OldExportFunctionArray[ OldOrdinal ],
                                NewExportFunctionArray[ NewOrdinal ]
                                );
                            }
                        }
                    }
                }
            }
        }
    }

    //
    //  Create rifts for image import directory
    //

    {
    UP_IMAGE_IMPORT_DESCRIPTOR OldImportDir;
    UP_IMAGE_IMPORT_DESCRIPTOR NewImportDir;

    ULONG OldImportDirRva;
    ULONG NewImportDirRva;

    ULONG OldImportDirIndex;
    ULONG NewImportDirIndex;

    LPSTR OldImportDllName;
    LPSTR NewImportDllName;

    LPSTR OldImportDllNameLowercase;
    LPSTR NewImportDllNameLowercase;

    UP_IMAGE_THUNK_DATA32 OldImportThunk;
    UP_IMAGE_THUNK_DATA32 NewImportThunk;

    UP_IMAGE_THUNK_DATA32 OldImportOriginalThunk;
    UP_IMAGE_THUNK_DATA32 NewImportOriginalThunk;

    ULONG OldImportThunkIndex;
    ULONG NewImportThunkIndex;

    UP_IMAGE_IMPORT_BY_NAME OldImportByName;
    UP_IMAGE_IMPORT_BY_NAME NewImportByName;

    LPSTR OldImportName;
    LPSTR NewImportName;

    SYMBOL_TREE NewImportDllNameTree;
    SYMBOL_TREE NewImportFunctionNameTree;

    PSYMBOL_NODE NewImportDllSymbolNode;
    PSYMBOL_NODE NewImportFunctionSymbolNode;

    OldImportDirRva = ImageDirectoryRvaAndSize(
                          OldFileNtHeader,
                          IMAGE_DIRECTORY_ENTRY_IMPORT,
                          NULL
                          );

    NewImportDirRva = ImageDirectoryRvaAndSize(
                          NewFileNtHeader,
                          IMAGE_DIRECTORY_ENTRY_IMPORT,
                          NULL
                          );

    OldImportDir = ImageDirectoryMappedAddress(
                       OldFileNtHeader,
                       IMAGE_DIRECTORY_ENTRY_IMPORT,
                       NULL,
                       OldFileMapped,
                       OldFileSize
                       );

    NewImportDir = ImageDirectoryMappedAddress(
                       NewFileNtHeader,
                       IMAGE_DIRECTORY_ENTRY_IMPORT,
                       NULL,
                       NewFileMapped,
                       NewFileSize
                       );

    if (( OldImportDir ) && ( NewImportDir )) {

        //
        //  Now build a tree of new import names, then walk old export names
        //  looking for matches in tree of new import names.
        //

        SymRBInitTree(
            &NewImportDllNameTree,
            SubAllocator
            );

        SymRBInitTree(
            &NewImportFunctionNameTree,
            SubAllocator
            );

        for ( NewImportDirIndex = 0; NewImportDir[ NewImportDirIndex ].Characteristics; NewImportDirIndex++ ) {

            if ( NewImportDir[ NewImportDirIndex ].Name ) {

                NewImportDllName = ImageRvaToMappedAddress( NewFileNtHeader, NewImportDir[ NewImportDirIndex ].Name, NewFileMapped, NewFileSize );

                if ( NewImportDllName ) {

                    NewImportDllNameLowercase = MySubAllocStrDup( SubAllocator, NewImportDllName );

                    if ( NewImportDllNameLowercase ) {

                        MyLowercase( NewImportDllNameLowercase );

                        SymRBInsert( &NewImportDllNameTree, NewImportDllNameLowercase, NewImportDirIndex );

                        NewImportThunk = ImageRvaToMappedAddress( NewFileNtHeader, (ULONG)NewImportDir[ NewImportDirIndex ].FirstThunk, NewFileMapped, NewFileSize );

                        if ( NewImportThunk ) {

                            for ( NewImportThunkIndex = 0; NewImportThunk[ NewImportThunkIndex ].u1.Ordinal; NewImportThunkIndex++ ) {

                                if ( ! IMAGE_SNAP_BY_ORDINAL32( NewImportThunk[ NewImportThunkIndex ].u1.Ordinal )) {

                                    NewImportByName = ImageRvaToMappedAddress( NewFileNtHeader, (ULONG)NewImportThunk[ NewImportThunkIndex ].u1.AddressOfData, NewFileMapped, NewFileSize );

                                    if ( NewImportByName ) {

                                        NewImportName = MySubAllocStrDupAndCat(
                                                            SubAllocator,
                                                            NewImportDllNameLowercase,
                                                            (LPSTR)NewImportByName->Name,
                                                            '!'
                                                            );

                                        if ( NewImportName ) {

                                            SymRBInsert( &NewImportFunctionNameTree, NewImportName, NewImportThunkIndex );

                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }

        for ( OldImportDirIndex = 0; OldImportDir[ OldImportDirIndex ].Characteristics; OldImportDirIndex++ ) {

            if ( OldImportDir[ OldImportDirIndex ].Name ) {

                OldImportDllName = ImageRvaToMappedAddress( OldFileNtHeader, OldImportDir[ OldImportDirIndex ].Name, OldFileMapped, OldFileSize );

                if ( OldImportDllName ) {

                    OldImportDllNameLowercase = MySubAllocStrDup( SubAllocator, OldImportDllName );

                    if ( OldImportDllNameLowercase ) {

                        MyLowercase( OldImportDllNameLowercase );

                        NewImportDllSymbolNode = SymRBFind( &NewImportDllNameTree, OldImportDllNameLowercase );

                        if ( NewImportDllSymbolNode ) {

                            //
                            //  Found a matching dll import descriptor.
                            //  This will give us four rifts: one for the
                            //  descriptor itself, another for the
                            //  dll name referenced by the descriptor, and
                            //  the FirstThunk and OriginalFirstThunk
                            //  arrays.
                            //
                            //  The index of the new import descriptor is
                            //  stored in the Rva field of the node.
                            //

                            NewImportDirIndex = NewImportDllSymbolNode->Rva;

                            AddRiftEntryToTable(
                                RiftTable,
                                OldImportDirRva + ( OldImportDirIndex * sizeof( IMAGE_IMPORT_DESCRIPTOR )),
                                NewImportDirRva + ( NewImportDirIndex * sizeof( IMAGE_IMPORT_DESCRIPTOR ))
                                );

                            AddRiftEntryToTable(
                                RiftTable,
                                (ULONG)OldImportDir[ OldImportDirIndex ].Name,
                                (ULONG)NewImportDir[ NewImportDirIndex ].Name
                                );

                            AddRiftEntryToTable(
                                RiftTable,
                                (ULONG)OldImportDir[ OldImportDirIndex ].OriginalFirstThunk,
                                (ULONG)NewImportDir[ NewImportDirIndex ].OriginalFirstThunk
                                );

                            AddRiftEntryToTable(
                                RiftTable,
                                (ULONG)OldImportDir[ OldImportDirIndex ].FirstThunk,
                                (ULONG)NewImportDir[ NewImportDirIndex ].FirstThunk
                                );

                            OldImportThunk = ImageRvaToMappedAddress( OldFileNtHeader, (ULONG)OldImportDir[ OldImportDirIndex ].FirstThunk, OldFileMapped, OldFileSize );

                            if ( OldImportThunk ) {

                                for ( OldImportThunkIndex = 0; OldImportThunk[ OldImportThunkIndex ].u1.Ordinal; OldImportThunkIndex++ ) {

                                    if ( ! IMAGE_SNAP_BY_ORDINAL32( OldImportThunk[ OldImportThunkIndex ].u1.Ordinal )) {

                                        OldImportByName = ImageRvaToMappedAddress( OldFileNtHeader, (ULONG)OldImportThunk[ OldImportThunkIndex ].u1.AddressOfData, OldFileMapped, OldFileSize );

                                        if ( OldImportByName ) {

                                            OldImportName = MySubAllocStrDupAndCat(
                                                                SubAllocator,
                                                                OldImportDllNameLowercase,
                                                                (LPSTR)OldImportByName->Name,
                                                                '!'
                                                                );

                                            if ( OldImportName ) {

                                                NewImportFunctionSymbolNode = SymRBFind( &NewImportFunctionNameTree, OldImportName );

                                                if ( NewImportFunctionSymbolNode ) {

                                                    //
                                                    //  Found a matching import function name.
                                                    //  This will give us two rifts: one for the
                                                    //  FirstThunk arrays and another for the
                                                    //  OriginalFirstThunk arrays.
                                                    //
                                                    //  The index of the new import thunk is
                                                    //  stored in the Rva field of the node.
                                                    //

                                                    NewImportThunkIndex = NewImportFunctionSymbolNode->Rva;

                                                    NewImportThunk = ImageRvaToMappedAddress( NewFileNtHeader, (ULONG)NewImportDir[ NewImportDirIndex ].FirstThunk, NewFileMapped, NewFileSize );

                                                    if ( NewImportThunk ) {

                                                        AddRiftEntryToTable(
                                                            RiftTable,
                                                            (ULONG)OldImportThunk[ OldImportThunkIndex ].u1.AddressOfData,
                                                            (ULONG)NewImportThunk[ NewImportThunkIndex ].u1.AddressOfData
                                                            );
                                                        }

                                                    OldImportOriginalThunk = ImageRvaToMappedAddress( OldFileNtHeader, (ULONG)OldImportDir[ OldImportDirIndex ].OriginalFirstThunk, OldFileMapped, OldFileSize );
                                                    NewImportOriginalThunk = ImageRvaToMappedAddress( NewFileNtHeader, (ULONG)NewImportDir[ NewImportDirIndex ].OriginalFirstThunk, NewFileMapped, NewFileSize );

                                                    if ( OldImportOriginalThunk && NewImportOriginalThunk ) {

                                                        AddRiftEntryToTable(
                                                            RiftTable,
                                                            (ULONG)OldImportOriginalThunk[ OldImportThunkIndex ].u1.AddressOfData,
                                                            (ULONG)NewImportOriginalThunk[ NewImportThunkIndex ].u1.AddressOfData
                                                            );
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
    }

    //
    //  Create rift entries for resources
    //

    {
    PUCHAR OldResBase, NewResBase;
    ULONG  OldResSize, NewResSize;
    ULONG  OldResRva,  NewResRva;

    OldResBase = ImageDirectoryMappedAddress(
                OldFileNtHeader,
                IMAGE_DIRECTORY_ENTRY_RESOURCE,
                &OldResSize,
                OldFileMapped,
                OldFileSize
                );

    NewResBase = ImageDirectoryMappedAddress(
                NewFileNtHeader,
                IMAGE_DIRECTORY_ENTRY_RESOURCE,
                &NewResSize,
                NewFileMapped,
                NewFileSize
                );

    if ( OldResBase && NewResBase ) {

        OldResRva = ImageDirectoryRvaAndSize( OldFileNtHeader, IMAGE_DIRECTORY_ENTRY_RESOURCE, NULL );
        NewResRva = ImageDirectoryRvaAndSize( NewFileNtHeader, IMAGE_DIRECTORY_ENTRY_RESOURCE, NULL );

        GetResourceRiftInfoRecursive(
            (UP_IMAGE_RESOURCE_DIRECTORY) OldResBase,
            OldResBase,
            OldResBase + OldResSize,
            OldResRva,
            (UP_IMAGE_RESOURCE_DIRECTORY) NewResBase,
            NewResBase,
            NewResBase + NewResSize,
            NewResRva,
            RiftTable
            );
        }
    }

    //
    //  Gen rift info for other non-symbol stuff here.
    //

#ifdef TESTCODE
    printf( "\r%9d non-symbol rift entries\n", RiftTable->RiftEntryCount );
#endif

    return TRUE;
    }


VOID
MyUndecorateSymbol(
    IN  LPCSTR DecoratedSymbol,
    OUT LPSTR  UndecoratedSymbol,
    IN  DWORD  BufferSize
    )
    {
    LPCSTR d;
    LPCSTR e;
    ULONG  Len;
    ULONG  Ext;

    d = DecoratedSymbol;

    if (( d[ 0 ] == '.' ) &&
        ( d[ 1 ] == '.' ) &&
        ( d[ 2 ] == '?' )) {

        d += 2;
        }

    if ( *d == '?' ) {

        *UndecoratedSymbol = 0;   // in case UnDecorateSymbolName fails

        Imagehlp.UnDecorateSymbolName( d, UndecoratedSymbol, BufferSize, UNDNAME_NAME_ONLY );

        //
        //  UnDecorateSymbolName will strip any trailing '_nnn' (from BBT omap
        //  info), but we want to preserved it.  Check for that pattern in the
        //  original, and if found, append it to the new string.
        //

        d += strlen( d + 1 );   // point d to last character in string

        if (( *d >= '0' ) && ( *d <= '9' )) {

            do  {
                --d;
                }
            while (( *d >= '0' ) && ( *d <= '9' ));

            if ( *d == '_' ) {

                //
                //  Matches the '_nnn' pattern, append to new string.
                //

                if (( strlen( UndecoratedSymbol ) + strlen( d )) < ( BufferSize - 1 )) {
                    strcat( UndecoratedSymbol, d );
                    }
                }
            }
        }

    else {

        //
        //  Strip any preceding '_' or '@'.
        //

        if (( *d == '_' ) || ( *d == '@' )) {
            ++d;
            }

        //
        //  Find end of name as either terminator or '@nn'.
        //

        for ( e = d; ( *e ) && ( *e != '@' ); ) {
            ++e;
            }

        //
        //  Copy as much of name as will fit in the buffer.
        //

        Len = (ULONG)( e - d );

        if ( Len > ( BufferSize - 1 )) {
             Len = ( BufferSize - 1 );
             }

        memcpy( UndecoratedSymbol, d, Len );

        if ( *e == '@' ) {

            //
            //  Skip '@nn' to append remainder of symbol
            //

            do  {
                ++e;
                }
            while (( *e >= '0' ) && ( *e <= '9' ));

            d = e;

            while ( *e ) {
                ++e;
                }

            //
            //  Now 'd' points to first character after '@nn' and 'e' points
            //  to end of the string.  If the extension will fit in the buffer,
            //  append it.
            //

            Ext = (ULONG)( e - d );

            if (( Len + Ext ) < ( BufferSize - 1 )) {
                memcpy( UndecoratedSymbol + Len, d, Ext );
                }

            Len += Ext;
            }

        //
        //  Terminate the string.
        //

        UndecoratedSymbol[ Len ] = 0;
        }
    }


BOOL
UndecorateSymbolAndAddToTree(
    IN LPCSTR       SymbolName,
    IN ULONG        Rva,
    IN PSYMBOL_TREE SymbolTree
    )
    {
    ULONG SymbolNameSize  = (ULONG) strlen( SymbolName ) + 1;
    LPSTR UndecoratedName = HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, SymbolNameSize );
    PSYMBOL_NODE SymbolNode;

    if (!UndecoratedName)
        return FALSE;

    MyUndecorateSymbol(
        SymbolName,
        UndecoratedName,
        SymbolNameSize
        );

    SymbolNode = SymRBInsert(
                     SymbolTree,
                     UndecoratedName,
                     Rva
                     );

    HeapFree(GetProcessHeap(), 0, UndecoratedName);
    return ( SymbolNode != NULL );
    }


BOOL
CALLBACK
NewFileEnumSymbolsCallback(
    LPSTR     SymbolName,
    ULONG_PTR SymbolAddr,
    ULONG     SymbolSize,
    PVOID     Context
    )
    {
    PSYMBOL_CONTEXT SymbolContext = Context;
    PSYMBOL_NODE SymbolNode;
    ULONG NewRva;

    UNREFERENCED_PARAMETER( SymbolSize );

#ifdef TESTCODE

    if ( SymbolContext->OutFile != INVALID_HANDLE_VALUE ) {

        CHAR  TextBuffer[ 16 + MAX_SYMBOL_NAME_LENGTH ];
        CHAR  Discarded;
        DWORD Actual;

        Discarded = 'X';
        NewRva = SymbolAddr;

        if ( NewRva > SymbolContext->NewImageBase ) {
            NewRva -= SymbolContext->NewImageBase;
            Discarded = ' ';
            }

        sprintf( TextBuffer, "%08X %c %s\r\n", NewRva, Discarded, SymbolName );
        WriteFile( SymbolContext->OutFile, TextBuffer, strlen( TextBuffer ), &Actual, NULL );
        }

#endif // TESTCODE

    if ( SymbolAddr > SymbolContext->NewImageBase ) {

        NewRva = (ULONG)( SymbolAddr - SymbolContext->NewImageBase );

        SymbolNode = SymRBInsert(
                         &SymbolContext->NewDecoratedSymbolTree,
                         SymbolName,
                         NewRva
                         );

        return ( SymbolNode != NULL );
        }

    return TRUE;
    }


BOOL
CALLBACK
OldFileEnumSymbolsCallback(
    LPSTR     SymbolName,
    ULONG_PTR SymbolAddr,
    ULONG     SymbolSize,
    PVOID     Context
    )
    {
    PSYMBOL_CONTEXT SymbolContext = Context;
    PSYMBOL_NODE SymbolNode;
    ULONG OldRva;

    UNREFERENCED_PARAMETER( SymbolSize );

#ifdef TESTCODE

    if ( SymbolContext->OutFile != INVALID_HANDLE_VALUE ) {

        CHAR  TextBuffer[ 16 + MAX_SYMBOL_NAME_LENGTH ];
        CHAR  Discarded;
        DWORD Actual;

        Discarded = 'X';
        OldRva = SymbolAddr;

        if ( OldRva > SymbolContext->OldImageBase ) {
            OldRva -= SymbolContext->OldImageBase;
            Discarded = ' ';
            }

        sprintf( TextBuffer, "%08X %c %s\r\n", OldRva, Discarded, SymbolName );
        WriteFile( SymbolContext->OutFile, TextBuffer, strlen( TextBuffer ), &Actual, NULL );
        }

#endif // TESTCODE

    if ( SymbolAddr > SymbolContext->OldImageBase ) {

        OldRva = (ULONG)( SymbolAddr - SymbolContext->OldImageBase );

        SymbolNode = SymRBFind(
                         &SymbolContext->NewDecoratedSymbolTree,
                         SymbolName
                         );

        if ( SymbolNode ) {

            AddRiftEntryToTable( SymbolContext->RiftTable, OldRva, SymbolNode->Rva );

            SymbolNode->Hit = 1;

#ifdef TESTCODE

            CountDecoratedMatches++;

#endif // TESTCODE

            }

        else {

            //
            //  Didn't find matching new symbol.  Build a tree of unmatched
            //  old symbols with UNdecorated names.  Later we'll match up
            //  remaining unmatched new symbols to these unmatched old symbols
            //  by their undecorated names.
            //

            if ( SymbolContext->SymbolOptionFlags & PATCH_SYMBOL_UNDECORATED_TOO ) {

                return UndecorateSymbolAndAddToTree(
                           SymbolName,
                           OldRva,
                           &SymbolContext->OldUndecoratedSymbolTree
                           );
                }
            }
        }

    return TRUE;
    }


BOOL
MatchRemainingSymbolsThisNode(
    IN PSYMBOL_NODE NewDecoratedSymbolNode,
    IN PSYMBOL_TREE NewUndecoratedSymbolTree,
    IN PSYMBOL_TREE OldUndecoratedSymbolTree,
    IN PRIFT_TABLE  RiftTable
    )
    {
    if ( ! NewDecoratedSymbolNode->Hit ) {

        ULONG SymbolNameSize     = (ULONG) strlen( NewDecoratedSymbolNode->SymbolName ) + 1;
        LPSTR NewUndecoratedName = HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, SymbolNameSize );
        PSYMBOL_NODE NewUndecoratedSymbolNode;
        PSYMBOL_NODE OldUndecoratedSymbolNode;
        if (!NewUndecoratedName) {
            return FALSE;
        }

        MyUndecorateSymbol(
            NewDecoratedSymbolNode->SymbolName,
            NewUndecoratedName,
            SymbolNameSize
            );

        OldUndecoratedSymbolNode = SymRBFind(
                                       OldUndecoratedSymbolTree,
                                       NewUndecoratedName
                                       );

        if ( OldUndecoratedSymbolNode ) {

            AddRiftEntryToTable(
                RiftTable,
                OldUndecoratedSymbolNode->Rva,
                NewDecoratedSymbolNode->Rva
                );

            OldUndecoratedSymbolNode->Hit = 1;

#ifdef TESTCODE

            CountUndecoratedMatches++;

#endif // TESTCODE

            }

        else {

            //
            //  This new symbol has no match in the old symbol tree.  Build a
            //  tree of unmatched new undecorated symbols.
            //

            NewUndecoratedSymbolNode = SymRBInsert(
                                           NewUndecoratedSymbolTree,
                                           NewUndecoratedName,
                                           NewDecoratedSymbolNode->Rva
                                           );

            HeapFree(GetProcessHeap(), 0, NewUndecoratedName);
            return ( NewUndecoratedSymbolNode != NULL );
            }
        HeapFree(GetProcessHeap(), 0, NewUndecoratedName);
        }

    return TRUE;
    }


BOOL
MatchRemainingSymbolsRecursive(
    IN PSYMBOL_NODE NewDecoratedSymbolNode,
    IN PSYMBOL_TREE NewUndecoratedSymbolTree,
    IN PSYMBOL_TREE OldUndecoratedSymbolTree,
    IN PRIFT_TABLE  RiftTable
    )
    {
    if ( NewDecoratedSymbolNode == RBNIL ) {
        return TRUE;
        }

    return ( MatchRemainingSymbolsRecursive( NewDecoratedSymbolNode->Left,  NewUndecoratedSymbolTree, OldUndecoratedSymbolTree, RiftTable ) &&
             MatchRemainingSymbolsRecursive( NewDecoratedSymbolNode->Right, NewUndecoratedSymbolTree, OldUndecoratedSymbolTree, RiftTable ) &&
             MatchRemainingSymbolsThisNode(  NewDecoratedSymbolNode,        NewUndecoratedSymbolTree, OldUndecoratedSymbolTree, RiftTable ));
    }


#ifdef TESTCODE

VOID
DumpUnHitSymbolNode(
    IN PSYMBOL_NODE SymbolNode,
    IN HANDLE hFile
    )
    {
    CHAR  TextBuffer[ 16 + MAX_SYMBOL_NAME_LENGTH ];
    DWORD Actual;

    if ( ! SymbolNode->Hit ) {
        sprintf( TextBuffer, "%08X   %s\r\n", SymbolNode->Rva, SymbolNode->SymbolName );
        WriteFile( hFile, TextBuffer, strlen( TextBuffer ), &Actual, NULL );
        }
    }

VOID
DumpUnHitSymbolNodesRecursive(
    IN PSYMBOL_NODE SymbolNode,
    IN HANDLE hFile
    )
    {
    if ( SymbolNode == RBNIL ) {
        return;
        }

    //
    //  The tree is in hash order, not Rva order, so the output will appear
    //  to be in random order (easily solved with sort.exe utility).
    //

    DumpUnHitSymbolNode( SymbolNode, hFile );
    DumpUnHitSymbolNodesRecursive( SymbolNode->Left,  hFile );
    DumpUnHitSymbolNodesRecursive( SymbolNode->Right, hFile );
    }


VOID
DumpUnHitSymbolNodes(
    IN PSYMBOL_TREE SymbolTree,
    IN LPCSTR DumpFileName
    )
    {
    HANDLE hFile;

    hFile = CreateFile(
                DumpFileName,
                GENERIC_WRITE,
                FILE_SHARE_READ,
                NULL,
                CREATE_ALWAYS,
                FILE_ATTRIBUTE_NORMAL,
                NULL
                );

    if ( hFile != INVALID_HANDLE_VALUE ) {

        DumpUnHitSymbolNodesRecursive( SymbolTree->Root, hFile );

        CloseHandle( hFile );
        }
    }

#endif // TESTCODE


BOOL
MatchRemainingSymbols(
    IN PSYMBOL_TREE NewDecoratedSymbolTree,
    IN PSYMBOL_TREE NewUndecoratedSymbolTree,
    IN PSYMBOL_TREE OldUndecoratedSymbolTree,
    IN PRIFT_TABLE  RiftTable
    )
    {
    BOOL Success;

    //
    //  Walk old tree, for each unmatched symbol, undecorate it and try to
    //  find match in the undecorated new symbol tree.  If it fails to match,
    //  add it to the old undecorated tree.
    //

    Success = MatchRemainingSymbolsRecursive(
                  NewDecoratedSymbolTree->Root,
                  NewUndecoratedSymbolTree,
                  OldUndecoratedSymbolTree,
                  RiftTable
                  );

    if ( Success ) {

        //
        //  Now we have remaining unmatched undecorated symbols in the
        //  OldUndecoratedSymbolTree and NewUndecoratedSymbolTree.
        //
        //  Here is an opportunity to do soft name matching, like for
        //  BBT omap generated symbol names (have trailing '_nnn').
        //  Unfortunately, current versions of imagehlp append an '_nnn'
        //  value that is useless becaue it is not the offset from the
        //  start of the function.
        //

#ifdef TESTCODE

        DumpUnHitSymbolNodes( OldUndecoratedSymbolTree, "UnmatchedOldSymbols.out" );
        DumpUnHitSymbolNodes( NewUndecoratedSymbolTree, "UnmatchedNewSymbols.out" );

#endif // TESTCODE

        }

    return Success;
    }


BOOL
GetImageSymbolRiftInfo(
    IN HANDLE                  OldFileHandle,
    IN PUCHAR                  OldFileMapped,
    IN ULONG                   OldFileSize,
    IN UP_IMAGE_NT_HEADERS32   OldFileNtHeader,
    IN LPCSTR                  OldFileSymPath,
    IN ULONG                   OldFileOriginalChecksum,
    IN ULONG                   OldFileOriginalTimeDate,
    IN ULONG                   OldFileIndex,
    IN HANDLE                  NewFileHandle,
    IN PUCHAR                  NewFileMapped,
    IN ULONG                   NewFileSize,
    IN UP_IMAGE_NT_HEADERS32   NewFileNtHeader,
    IN LPCSTR                  NewFileSymPath,
    IN ULONG                   SymbolOptionFlags,
    IN HANDLE                  SubAllocator,
    IN PRIFT_TABLE             RiftTable,
    IN PPATCH_SYMLOAD_CALLBACK SymLoadCallback,
    IN PVOID                   SymLoadContext
    )
    {
    SYMBOL_CONTEXT SymbolContext;
    DWORD SymOptions;
    ULONG_PTR OldBase;
    ULONG_PTR NewBase;
    BOOL  Success;

#ifdef TESTCODE
    ULONG InitialRiftEntries = RiftTable->RiftEntryCount;
#endif

    UNREFERENCED_PARAMETER( OldFileNtHeader );
    UNREFERENCED_PARAMETER( OldFileMapped );
    UNREFERENCED_PARAMETER( OldFileSize );
    UNREFERENCED_PARAMETER( NewFileMapped );
    UNREFERENCED_PARAMETER( NewFileSize );

    InitImagehlpCritSect();

    EnterCriticalSection( &ImagehlpCritSect );

    Success = LoadImagehlp();

    if ( Success ) {

        __try {

            SymOptions = Imagehlp.SymGetOptions();

            SymOptions &= ~SYMOPT_CASE_INSENSITIVE;
            SymOptions &= ~SYMOPT_UNDNAME;
            SymOptions &= ~SYMOPT_DEFERRED_LOADS;

            Imagehlp.SymSetOptions( SymOptions );

            Success = Imagehlp.SymInitialize( hProc, NewFileSymPath, FALSE );

            if ( Success ) {

                __try {

                    SymRBInitTree(
                        &SymbolContext.NewDecoratedSymbolTree,
                        SubAllocator
                        );

                    SymRBInitTree(
                        &SymbolContext.NewUndecoratedSymbolTree,
                        SubAllocator
                        );

                    SymRBInitTree(
                        &SymbolContext.OldUndecoratedSymbolTree,
                        SubAllocator
                        );

                    NewBase = Imagehlp.SymLoadModule( hProc, NewFileHandle, NULL, "New", (ULONG_PTR)NewFileMapped, NewFileSize );

                    Success = ( NewBase != 0 );

                    if ( Success ) {

                        __try {

                            if ( SymLoadCallback ) {

                                ZeroMemory( &ImagehlpModuleInfo, sizeof( ImagehlpModuleInfo ));
                                ImagehlpModuleInfo.SizeOfStruct = sizeof( ImagehlpModuleInfo );

                                Success = Imagehlp.SymGetModuleInfo(
                                              hProc,
                                              NewBase,
                                              &ImagehlpModuleInfo
                                              );

                                if ( Success ) {

                                    Success = SymLoadCallback(
                                                  0,
                                                  ImagehlpModuleInfo.LoadedImageName,
                                                  ImagehlpModuleInfo.SymType,
                                                  ImagehlpModuleInfo.CheckSum,
                                                  ImagehlpModuleInfo.TimeDateStamp,
                                                  NewFileNtHeader->OptionalHeader.CheckSum,
                                                  NewFileNtHeader->FileHeader.TimeDateStamp,
                                                  SymLoadContext
                                                  );
                                    }
                                }

                            if ( Success ) {

                                SymbolContext.NewImageBase      = NewBase;
                                SymbolContext.SymbolOptionFlags = SymbolOptionFlags;
                                SymbolContext.RiftTable         = RiftTable;
#ifdef TESTCODE
                                CountDecoratedMatches   = 0;
                                CountUndecoratedMatches = 0;

                                SymbolContext.OutFile = CreateFile(
                                                            "NewSymbols.out",
                                                            GENERIC_WRITE,
                                                            FILE_SHARE_READ,
                                                            NULL,
                                                            CREATE_ALWAYS,
                                                            FILE_ATTRIBUTE_NORMAL,
                                                            NULL
                                                            );
#endif // TESTCODE

                                Success = Imagehlp.SymEnumerateSymbols( hProc, NewBase, NewFileEnumSymbolsCallback, &SymbolContext );

#ifdef TESTCODE
                                if ( SymbolContext.OutFile != INVALID_HANDLE_VALUE ) {
                                    CloseHandle( SymbolContext.OutFile );
                                    }
#endif // TESTCODE
                                }
                        }

                        __except( EXCEPTION_EXECUTE_HANDLER ) {
                            Success = FALSE;
                            }

                        Imagehlp.SymUnloadModule( hProc, NewBase );
                        }
                    }

                __except( EXCEPTION_EXECUTE_HANDLER ) {
                    Success = FALSE;
                    }

                //
                //  Must do cleanup and reinitialize Imagehlp for this
                //  process identifier.  Otherwise it thinks the old
                //  module is still hanging around.
                //

                Imagehlp.SymCleanup( hProc );

                if ( Success ) {

                    Success = Imagehlp.SymInitialize( hProc, OldFileSymPath, FALSE );

                    if ( Success ) {

                        __try {

                            OldBase = Imagehlp.SymLoadModule( hProc, OldFileHandle, NULL, "Old", (ULONG_PTR)OldFileMapped, OldFileSize );

                            Success = ( OldBase != 0 );

                            if ( Success ) {

                                __try {

                                    if ( SymLoadCallback ) {

                                        ZeroMemory( &ImagehlpModuleInfo, sizeof( ImagehlpModuleInfo ));
                                        ImagehlpModuleInfo.SizeOfStruct = sizeof( ImagehlpModuleInfo );

                                        Success = Imagehlp.SymGetModuleInfo(
                                                      hProc,
                                                      OldBase,
                                                      &ImagehlpModuleInfo
                                                      );

                                        if ( Success ) {

                                            Success = SymLoadCallback(
                                                          OldFileIndex + 1,
                                                          ImagehlpModuleInfo.LoadedImageName,
                                                          ImagehlpModuleInfo.SymType,
                                                          ImagehlpModuleInfo.CheckSum,
                                                          ImagehlpModuleInfo.TimeDateStamp,
                                                          OldFileOriginalChecksum,
                                                          OldFileOriginalTimeDate,
                                                          SymLoadContext
                                                          );
                                            }
                                        }

                                    if ( Success ) {

                                        SymbolContext.OldImageBase = OldBase;
#ifdef TESTCODE
                                        SymbolContext.OutFile = CreateFile(
                                                                    "OldSymbols.out",
                                                                    GENERIC_WRITE,
                                                                    FILE_SHARE_READ,
                                                                    NULL,
                                                                    CREATE_ALWAYS,
                                                                    FILE_ATTRIBUTE_NORMAL,
                                                                    NULL
                                                                    );
#endif // TESTCODE

                                        Success = Imagehlp.SymEnumerateSymbols( hProc, OldBase, OldFileEnumSymbolsCallback, &SymbolContext );

#ifdef TESTCODE
                                        if ( SymbolContext.OutFile != INVALID_HANDLE_VALUE ) {
                                            CloseHandle( SymbolContext.OutFile );
                                            }
#endif // TESTCODE
                                        }

                                    if ( Success ) {

                                        //
                                        //  Need to match remaining decorated new symbols in tree
                                        //  with unmatched now-undecorated old symbols in other tree.
                                        //

                                        if ( SymbolOptionFlags & PATCH_SYMBOL_UNDECORATED_TOO ) {

                                            Success = MatchRemainingSymbols(
                                                          &SymbolContext.NewDecoratedSymbolTree,
                                                          &SymbolContext.NewUndecoratedSymbolTree,
                                                          &SymbolContext.OldUndecoratedSymbolTree,
                                                          RiftTable
                                                          );
                                            }
                                        }
                                    }

                                __except( EXCEPTION_EXECUTE_HANDLER ) {
                                    Success = FALSE;
                                    }

                                Imagehlp.SymUnloadModule( hProc, OldBase );
                                }
                            }

                        __except( EXCEPTION_EXECUTE_HANDLER ) {
                            Success = FALSE;
                            }

                        Imagehlp.SymCleanup( hProc );
                        }
                    }
                }
            }

        __except( EXCEPTION_EXECUTE_HANDLER ) {
            Success = FALSE;
            }
        }

    LeaveCriticalSection( &ImagehlpCritSect );

    if ( ! Success ) {
        SetLastError( ERROR_PATCH_IMAGEHLP_FAILURE );
        }

#ifdef TESTCODE
    printf( "\r%9d decorated symbol matches\n", CountDecoratedMatches );
    printf( "\r%9d undecorated symbol matches\n", CountUndecoratedMatches );
    printf( "\r%9d rift entries from symbols\n", RiftTable->RiftEntryCount - InitialRiftEntries );
#endif

    return Success;
    }


BOOL
OptimizeImageRiftInfo(
    IN PUCHAR                OldFileMapped,
    IN ULONG                 OldFileSize,
    IN UP_IMAGE_NT_HEADERS32 OldFileNtHeader,
    IN PUCHAR                NewFileMapped,
    IN ULONG                 NewFileSize,
    IN UP_IMAGE_NT_HEADERS32 NewFileNtHeader,
    IN HANDLE                SubAllocator,
    IN PRIFT_TABLE           RiftTable
    )
    {
    UNREFERENCED_PARAMETER( OldFileMapped );
    UNREFERENCED_PARAMETER( OldFileSize );
    UNREFERENCED_PARAMETER( OldFileNtHeader );
    UNREFERENCED_PARAMETER( NewFileMapped );
    UNREFERENCED_PARAMETER( NewFileSize );
    UNREFERENCED_PARAMETER( NewFileNtHeader );
    UNREFERENCED_PARAMETER( SubAllocator );
    UNREFERENCED_PARAMETER( RiftTable );

    return TRUE;
    }

#if 0   // This is test code

BOOL
OptimizeImageRiftInfo(
    IN PUCHAR                OldFileMapped,
    IN ULONG                 OldFileSize,
    IN UP_IMAGE_NT_HEADERS32 OldFileNtHeader,
    IN PUCHAR                NewFileMapped,
    IN ULONG                 NewFileSize,
    IN UP_IMAGE_NT_HEADERS32 NewFileNtHeader,
    IN HANDLE                SubAllocator,
    IN PRIFT_TABLE           RiftTable
    )
    {
    UP_IMAGE_SECTION_HEADER SectionHeader;
    ULONG  SectionCount;
    PUCHAR SectionStart;
    PUCHAR SearchExtent;
    ULONG  SectionLength;
    ULONG  SectionOffset;
    ULONG  SectionBaseRva;
    ULONG  OldFileLastRva;
    ULONG  NewFileLastRva;
    LONG   OldDisplacement;
    LONG   NewDisplacement;
    ULONG  OffsetInSection;
    ULONG  OldOriginRva;
    ULONG  OldTargetRva;
    ULONG  TargetOffset;
    PUCHAR OldFileHintMap;
    PUCHAR NewFileHintMap;
    PUCHAR OldFileCopy;
    PUCHAR NewFileCopy;
    PVOID  OldFileCopyNtHeader;
    PVOID  NewFileCopyNtHeader;
    BOOL   Success;
    BOOL   Skip;
    ULONG  i;
    ULONG  j;
    PUCHAR p;

#ifdef TESTCODE
    ULONG CountVerifiedE8Rifts = 0;
    ULONG CountDiscoveredE8Rifts = 0;
#endif // TESTCODE

    //
    //  Stage1:
    //
    //      Trusting existing rift info, search for E8/E9/Jcc instructions in
    //      the Old file, get the corresponding rift, inspect the corresponding
    //      instruction in the New file.  If they match, great.  If they don't
    //      match, search for a correponding instruction in the new file by
    //      looking forward up to the next rift.  If find a suitable match,
    //      create a new rift entry to support it.
    //
    //      We don't have the benefit of non-exe marked bytes here.
    //

    if ( OldFileNtHeader->FileHeader.Machine != NewFileNtHeader->FileHeader.Machine ) {
        return TRUE;    // not much we can do here!
        }

    //
    //  We need the HintMap to determine which bytes in the files are not
    //  executable.  The Transform function currently provides this, but
    //  we don't want to modify our mapped file views here.  So, allocate
    //  a range of VM and make a copy of the file to Transform, perform
    //  the transformations on that copy just to produce a hint map, then
    //  free the transformed copy (do this for both old and new files).
    //

    Success = FALSE;

    OldFileHintMap = MyVirtualAlloc( OldFileSize );
    NewFileHintMap = MyVirtualAlloc( NewFileSize );

    if ( OldFileHintMap && NewFileHintMap ) {

        OldFileCopy = MyVirtualAlloc( OldFileSize );

        if ( OldFileCopy ) {

            CopyMemory( OldFileCopy, OldFileMapped, OldFileSize );

            OldFileCopyNtHeader = GetNtHeader( OldFileCopy, OldFileSize );

            Success = TransformCoffImage(
                          ( PATCH_TRANSFORM_NO_RELJMPS | PATCH_TRANSFORM_NO_RELCALLS | PATCH_TRANSFORM_NO_RESOURCE ),
                          OldFileCopyNtHeader,
                          OldFileCopy,
                          OldFileSize,
                          0,
                          RiftTable,
                          OldFileHintMap
                          );

            MyVirtualFree( OldFileCopy );
            }

        if ( Success ) {

            Success = FALSE;

            NewFileCopy = MyVirtualAlloc( NewFileSize );

            if ( NewFileCopy ) {

                CopyMemory( NewFileCopy, NewFileMapped, NewFileSize );

                NewFileCopyNtHeader = GetNtHeader( NewFileCopy, NewFileSize );

                Success = TransformCoffImage(
                              ( PATCH_TRANSFORM_NO_RELJMPS | PATCH_TRANSFORM_NO_RELCALLS | PATCH_TRANSFORM_NO_RESOURCE ),
                              NewFileCopyNtHeader,
                              NewFileCopy,
                              NewFileSize,
                              0,
                              RiftTable,
                              NewFileHintMap
                              );

                MyVirtualFree( NewFileCopy );
                }
            }
        }

    if ( Success ) {

        //
        //  We now have valid OldFileHintMap and NewFileHintMap.
        //

        OldFileLastRva = OldFileNtHeader->OptionalHeader.SizeOfImage;
        NewFileLastRva = NewFileNtHeader->OptionalHeader.SizeOfImage;

        InsertRiftEntryInSortedTable( RiftTable, RiftTable->RiftEntryCount, OldFileLastRva, NewFileLastRva );

        SectionHeader  = IMAGE_FIRST_SECTION( OldFileNtHeader );
        SectionCount   = OldFileNtHeader->FileHeader.NumberOfSections;

        for ( i = 0; i < SectionCount; i++ ) {

            if ( SectionHeader[ i ].Characteristics & IMAGE_SCN_MEM_EXECUTE ) {

                SectionBaseRva = SectionHeader[ i ].VirtualAddress;
                SectionLength  = MIN( SectionHeader[ i ].Misc.VirtualSize, SectionHeader[ i ].SizeOfRawData );
                SectionOffset  = SectionHeader[ i ].PointerToRawData;
                SectionStart   = OldFileMapped + SectionOffset;

                if ( OldFileNtHeader->FileHeader.Machine == IMAGE_FILE_MACHINE_I386 ) {

                    SearchExtent = SectionStart + SectionLength - 5;

                    for ( p = SectionStart; p < SearchExtent; p++ ) {

                        if ( *p == 0xE8 ) {         // call relative32

                            //
                            //  Validate that instruction is not something that
                            //  the HintMap indicates is not an executable
                            //  instruction.  We're looking for a relative
                            //  call instruction here, so it would not be a
                            //  reloc target.
                            //

                            Skip = FALSE;

                            for ( j = 0; j < 5; j++ ) {
                                if ( OldFileHintMap[ SectionOffset + ( p - SectionStart ) + j ] & 0x01 ) {
                                    Skip = TRUE;
                                    break;
                                    }
                                }

                            if ( Skip ) {
                                continue;
                                }

                            //
                            //  Relative displacement is stored as 32-bit
                            //  signed value following these opcodes.  The
                            //  displacement is relative to the NEXT
                            //  instruction, which is at (p + 5).
                            //

                            OldDisplacement = *(UNALIGNED LONG*)( p + 1 );
                            OffsetInSection = ( p + 5 ) - SectionStart;
                            OldOriginRva     = SectionBaseRva + OffsetInSection;
                            OldTargetRva     = OldOriginRva + OldDisplacement;

                            //
                            //  We expect a lot of false positives here because
                            //  occurences of <E8> will
                            //  likely occur in other parts of the instruction
                            //  stream so now we validate that the TargetRva
                            //  falls within the image and within an executable
                            //  section.
                            //

                            if ( OldTargetRva < OldFileLastRva ) {

                                TargetOffset = ImageRvaToFileOffset( OldFileNtHeader, OldTargetRva );

                                if ( ! ( OldFileHintMap[ TargetOffset ] & 0x01 )) {

                                    //
                                    //  Looks like a valid TargetRva, so lookup the
                                    //  corresponding "new" RVAs in the rift table.
                                    //

                                    ULONG RiftIndexOrigin = FindRiftTableEntryForOldRva( RiftTable, OldOriginRva );
                                    ULONG RiftIndexTarget = FindRiftTableEntryForOldRva( RiftTable, OldTargetRva );

                                    ULONG NewOriginRva = OldOriginRva + (LONG)( RiftTable->RiftEntryArray[ RiftIndexOrigin ].NewFileRva - RiftTable->RiftEntryArray[ RiftIndexOrigin ].OldFileRva );
                                    ULONG NewTargetRva = OldTargetRva + (LONG)( RiftTable->RiftEntryArray[ RiftIndexTarget ].NewFileRva - RiftTable->RiftEntryArray[ RiftIndexTarget ].OldFileRva );

                                    PUCHAR NewOriginMa = ImageRvaToMappedAddress( NewFileNtHeader, NewOriginRva, NewFileMapped, NewFileSize );
                                    PUCHAR NewTargetMa = ImageRvaToMappedAddress( NewFileNtHeader, NewTargetRva, NewFileMapped, NewFileSize );

                                    PUCHAR OldTargetMa = ImageRvaToMappedAddress( OldFileNtHeader, OldTargetRva, OldFileMapped, OldFileSize );
                                    PUCHAR OldOriginMa = p + 5;

                                    if (( NewOriginMa ) && ( NewTargetMa ) && ( OldTargetMa )) {

                                        PUCHAR OldInstruct = p;
                                        PUCHAR NewInstruct = NewOriginMa - 5;

                                        //
                                        //  A verified call instruction should match the
                                        //  instruction byte, the byte following the
                                        //  instruction, and the target byte, because
                                        //  they should all be executable code that is
                                        //  not modified by relocs.
                                        //
                                        //  Also verify the NewFileHintMap.
                                        //

                                        if (( *OldInstruct == *NewInstruct ) &&
                                            ( *OldOriginMa == *NewOriginMa ) &&
                                            ( *OldTargetMa == *NewTargetMa )) {

                                            ULONG NewInstructOffset = NewInstruct - NewFileMapped;
                                            ULONG NewTargetOffset   = NewTargetMa - NewFileMapped;
                                            BOOL  Skip = FALSE;

                                            for ( j = 0; j < 5; j++ ) {
                                                if ( NewFileHintMap[ NewInstructOffset + j ] & 0x01 ) {
                                                    Skip = TRUE;
                                                    break;
                                                    }
                                                }

                                            if ( NewFileHintMap[ NewTargetOffset + j ] & 0x01 ) {
                                                Skip = TRUE;
                                                }

                                            if ( ! Skip ) {

                                                //
                                                //  This is a bonafide good match.  Add a rift entry
                                                //  for both the instruction and the target.  We do
                                                //  this so that subsequent rift insertions don't get
                                                //  between the rift that coasted to these and these.
                                                //

                                                InsertRiftEntryInSortedTable( RiftTable, RiftIndexOrigin, OldOriginRva - 5, NewOriginRva - 5 );
                                                InsertRiftEntryInSortedTable( RiftTable, RiftIndexTarget, OldTargetRva, NewTargetRva );
#ifdef TESTCODE
                                                CountVerifiedE8Rifts++;
#endif // TESTCODE

                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }

                else if ( OldFileNtHeader->FileHeader.Machine == IMAGE_FILE_MACHINE_ALPHA ) {

                    //
                    //  Implement Alpha platform stuff here.
                    //

                    }
                }
            }

        for ( i = 0; i < SectionCount; i++ ) {

            if ( SectionHeader[ i ].Characteristics & IMAGE_SCN_MEM_EXECUTE ) {

                SectionBaseRva = SectionHeader[ i ].VirtualAddress;
                SectionLength  = MIN( SectionHeader[ i ].Misc.VirtualSize, SectionHeader[ i ].SizeOfRawData );
                SectionOffset  = SectionHeader[ i ].PointerToRawData;
                SectionStart   = OldFileMapped + SectionOffset;

                if ( OldFileNtHeader->FileHeader.Machine == IMAGE_FILE_MACHINE_I386 ) {

                    SearchExtent = SectionStart + SectionLength - 5;

                    for ( p = SectionStart; p < SearchExtent; p++ ) {

                        if ( *p == 0xE8 ) {         // call relative32

                            //
                            //  Validate that instruction is not something that
                            //  the HintMap indicates is not an executable
                            //  instruction.  We're looking for a relative
                            //  call instruction here, so it would not be a
                            //  reloc target.
                            //

                            Skip = FALSE;

                            for ( j = 0; j < 5; j++ ) {
                                if ( OldFileHintMap[ SectionOffset + ( p - SectionStart ) + j ] & 0x01 ) {
                                    Skip = TRUE;
                                    break;
                                    }
                                }

                            if ( Skip ) {
                                continue;
                                }

                            //
                            //  Relative displacement is stored as 32-bit
                            //  signed value following these opcodes.  The
                            //  displacement is relative to the NEXT
                            //  instruction, which is at (p + 5).
                            //

                            OldDisplacement = *(UNALIGNED LONG*)( p + 1 );
                            OffsetInSection = ( p + 5 ) - SectionStart;
                            OldOriginRva     = SectionBaseRva + OffsetInSection;
                            OldTargetRva     = OldOriginRva + OldDisplacement;

                            //
                            //  We expect a lot of false positives here because
                            //  occurences of <E8> will
                            //  likely occur in other parts of the instruction
                            //  stream so now we validate that the TargetRva
                            //  falls within the image and within an executable
                            //  section.
                            //

                            if ( OldTargetRva < OldFileLastRva ) {

                                TargetOffset = ImageRvaToFileOffset( OldFileNtHeader, OldTargetRva );

                                if ( ! ( OldFileHintMap[ TargetOffset ] & 0x01 )) {

                                    //
                                    //  Looks like a valid TargetRva, so lookup the
                                    //  corresponding "new" RVAs in the rift table.
                                    //

                                    ULONG RiftIndexOrigin = FindRiftTableEntryForOldRva( RiftTable, OldOriginRva );
                                    ULONG RiftIndexTarget = FindRiftTableEntryForOldRva( RiftTable, OldTargetRva );

                                    ULONG NewOriginRva = OldOriginRva + (LONG)( RiftTable->RiftEntryArray[ RiftIndexOrigin ].NewFileRva - RiftTable->RiftEntryArray[ RiftIndexOrigin ].OldFileRva );
                                    ULONG NewTargetRva = OldTargetRva + (LONG)( RiftTable->RiftEntryArray[ RiftIndexTarget ].NewFileRva - RiftTable->RiftEntryArray[ RiftIndexTarget ].OldFileRva );

                                    PUCHAR NewOriginMa = ImageRvaToMappedAddress( NewFileNtHeader, NewOriginRva, NewFileMapped, NewFileSize );
                                    PUCHAR NewTargetMa = ImageRvaToMappedAddress( NewFileNtHeader, NewTargetRva, NewFileMapped, NewFileSize );

                                    PUCHAR OldTargetMa = ImageRvaToMappedAddress( OldFileNtHeader, OldTargetRva, OldFileMapped, OldFileSize );
                                    PUCHAR OldOriginMa = p + 5;

                                    if (( NewOriginMa ) && ( NewTargetMa ) && ( OldTargetMa )) {

                                        PUCHAR OldInstruct = p;
                                        PUCHAR NewInstruct = NewOriginMa - 5;

                                        //
                                        //  A verified call instruction should match the
                                        //  instruction byte, the byte following the
                                        //  instruction, and the target byte, because
                                        //  they should all be executable code that is
                                        //  not modified by relocs.
                                        //
                                        //  Check NewHintMap too.
                                        //

                                        if (( *OldInstruct == *NewInstruct ) &&
                                            ( *OldOriginMa == *NewOriginMa ) &&
                                            ( *OldTargetMa == *NewTargetMa )) {

                                            ULONG NewInstructOffset = NewInstruct - NewFileMapped;
                                            ULONG NewTargetOffset   = NewTargetMa - NewFileMapped;
                                            BOOL  Skip = FALSE;

                                            for ( j = 0; j < 5; j++ ) {
                                                if ( NewFileHintMap[ NewInstructOffset + j ] & 0x01 ) {
                                                    Skip = TRUE;
                                                    break;
                                                    }
                                                }

                                            if ( NewFileHintMap[ NewTargetOffset + j ] & 0x01 ) {
                                                Skip = TRUE;
                                                }

                                            if ( ! Skip ) {

                                                //
                                                //  This is a bonafide good match.
                                                //

                                                continue;
                                                }
                                            }

                                        {

                                            //
                                            //  Instructions don't match.  Scan to find
                                            //  matching instruction in new file.  Scan
                                            //  the extent of this rift entry.
                                            //

                                            PUCHAR ScanInstruct;
                                            PUCHAR LowestMaToScan;
                                            PUCHAR HighestMaToScan;
                                            ULONG  LowestRvaToScan  = RiftTable->RiftEntryArray[ RiftIndexOrigin ].NewFileRva;
                                            ULONG  HighestRvaToScan = RiftTable->RiftEntryArray[ RiftIndexOrigin + 1 ].NewFileRva;
                                            ULONG  ExpectedTargetRva = NewTargetRva;
                                            BOOL   Found = FALSE;

                                            LowestMaToScan  = ImageRvaToMappedAddress( NewFileNtHeader, LowestRvaToScan,  NewFileMapped, NewFileSize );
                                            HighestMaToScan = ImageRvaToMappedAddress( NewFileNtHeader, HighestRvaToScan, NewFileMapped, NewFileSize );

                                            HighestMaToScan -= 5;   // size of instruction

                                            for ( ScanInstruct = NewInstruct + 1; ScanInstruct <= HighestMaToScan; ScanInstruct++ ) {

                                                if ( *ScanInstruct == 0xE8 ) {

                                                    //
                                                    //  check NewHintMap
                                                    //

                                                    NewOriginMa     = ScanInstruct + 5;
                                                    NewOriginRva    = MappedAddressToImageRva( NewFileNtHeader, NewOriginMa, NewFileMapped );
                                                    NewDisplacement = *(UNALIGNED LONG*)( ScanInstruct + 1 );
                                                    NewTargetRva    = NewOriginRva + NewDisplacement;
                                                    NewTargetMa     = ImageRvaToMappedAddress( NewFileNtHeader, NewTargetRva, NewFileMapped, NewFileSize );

                                                    if (( NewOriginRva ) && ( NewTargetMa )) {

                                                        //
                                                        //  We already know *OldInstruct == *ScanInstruct
                                                        //

                                                        if (( *OldOriginMa == *NewOriginMa ) &&
                                                            ( *OldTargetMa == *NewTargetMa ) &&
                                                            ( NewTargetRva == ExpectedTargetRva )) {

                                                            ULONG NewInstructOffset = ScanInstruct - NewFileMapped;
                                                            ULONG NewTargetOffset   = NewTargetMa  - NewFileMapped;
                                                            BOOL  Skip = FALSE;

                                                            for ( j = 0; j < 5; j++ ) {
                                                                if ( NewFileHintMap[ NewInstructOffset + j ] & 0x01 ) {
                                                                    Skip = TRUE;
                                                                    break;
                                                                    }
                                                                }

                                                            if ( NewFileHintMap[ NewTargetOffset + j ] & 0x01 ) {
                                                                Skip = TRUE;
                                                                }

                                                            if ( ! Skip ) {

                                                                InsertRiftEntryInSortedTable( RiftTable, RiftIndexOrigin, OldOriginRva - 5, NewOriginRva - 5 );
                                                                InsertRiftEntryInSortedTable( RiftTable, RiftIndexTarget, OldTargetRva, NewTargetRva );
                                                                Found = TRUE;
#ifdef TESTCODE
                                                                CountDiscoveredE8Rifts++;
#endif // TESTCODE
                                                                break;
                                                                }
                                                            }
                                                        }
                                                    }
                                                }

                                            if ( Found ) {
                                                continue;
                                                }

                                            for ( ScanInstruct = NewInstruct - 1; ScanInstruct >= LowestMaToScan; ScanInstruct-- ) {

                                                if ( *ScanInstruct == 0xE8 ) {

                                                    //
                                                    //  check NewHintMap
                                                    //

                                                    NewOriginMa     = ScanInstruct + 5;
                                                    NewOriginRva    = MappedAddressToImageRva( NewFileNtHeader, NewOriginMa, NewFileMapped );
                                                    NewDisplacement = *(UNALIGNED LONG*)( ScanInstruct + 1 );
                                                    NewTargetRva    = NewOriginRva + NewDisplacement;
                                                    NewTargetMa     = ImageRvaToMappedAddress( NewFileNtHeader, NewTargetRva, NewFileMapped, NewFileSize );

                                                    if (( NewOriginRva ) && ( NewTargetMa )) {

                                                        //
                                                        //  We already know *OldInstruct == *ScanInstruct
                                                        //

                                                        if (( *OldOriginMa == *NewOriginMa ) &&
                                                            ( *OldTargetMa == *NewTargetMa ) &&
                                                            ( NewTargetRva == ExpectedTargetRva )) {

                                                            ULONG NewInstructOffset = ScanInstruct - NewFileMapped;
                                                            ULONG NewTargetOffset   = NewTargetMa  - NewFileMapped;
                                                            BOOL  Skip = FALSE;

                                                            for ( j = 0; j < 5; j++ ) {
                                                                if ( NewFileHintMap[ NewInstructOffset + j ] & 0x01 ) {
                                                                    Skip = TRUE;
                                                                    break;
                                                                    }
                                                                }

                                                            if ( NewFileHintMap[ NewTargetOffset + j ] & 0x01 ) {
                                                                Skip = TRUE;
                                                                }

                                                            if ( ! Skip ) {

                                                                InsertRiftEntryInSortedTable( RiftTable, RiftIndexOrigin, OldOriginRva - 5, NewOriginRva - 5 );
                                                                InsertRiftEntryInSortedTable( RiftTable, RiftIndexTarget, OldTargetRva, NewTargetRva );
                                                                Found = TRUE;
#ifdef TESTCODE
                                                                CountDiscoveredE8Rifts++;
#endif // TESTCODE
                                                                break;
                                                                }
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }

                else if ( OldFileNtHeader->FileHeader.Machine == IMAGE_FILE_MACHINE_ALPHA ) {

                    //
                    //  Implement Alpha platform stuff here.
                    //

                    }
                }
            }
        }

#ifdef TESTCODE
    printf( "\r%9d verified E8 rifts\n", CountVerifiedE8Rifts );
    printf( "\r%9d discovered E8 rifts\n", CountDiscoveredE8Rifts );
#endif // TESTCODE

    if ( OldFileHintMap ) {
        MyVirtualFree( OldFileHintMap );
        }

    if ( NewFileHintMap ) {
        MyVirtualFree( NewFileHintMap );
        }

    return Success;
    }


#endif // 0 (test code)


BOOL
GenerateRiftTable(
    IN HANDLE OldFileHandle,
    IN PUCHAR OldFileMapped,
    IN ULONG  OldFileSize,
    IN ULONG  OldFileOriginalChecksum,
    IN ULONG  OldFileOriginalTimeDate,
    IN HANDLE NewFileHandle,
    IN PUCHAR NewFileMapped,
    IN ULONG  NewFileSize,
    IN ULONG  OptionFlags,
    IN PPATCH_OPTION_DATA OptionData,
    IN ULONG  OldFileIndex,
    IN PRIFT_TABLE RiftTable
    )
    {
    UP_IMAGE_NT_HEADERS32 OldFileNtHeader;
    UP_IMAGE_NT_HEADERS32 NewFileNtHeader;
    LPCSTR OldFileSymPath;
    LPCSTR NewFileSymPath;
    HANDLE SubAllocator;
    ULONG SymbolOptionFlags;
    BOOL Success = FALSE;

    UNREFERENCED_PARAMETER( OptionFlags );

    SymbolOptionFlags = 0;
    SubAllocator = NULL;

    __try {

        //
        //  See if both files are PE images.
        //

        OldFileNtHeader = GetNtHeader( OldFileMapped, OldFileSize );

        if ( OldFileNtHeader ) {

            NewFileNtHeader = GetNtHeader( NewFileMapped, NewFileSize );

            if ( NewFileNtHeader ) {

                //
                //  Both files are PE images.
                //

                SubAllocator = CreateSubAllocator( 0x100000, 0x100000 );

                if ( ! SubAllocator ) {
                    Success = FALSE;
                    __leave;
                    }

                //
                //  Before we bother with debug info, we can create initial
                //  rift data from the section headers to compensate for any
                //  section base RVA differences.  This will work even if we
                //  don't have debug symbols.
                //

                Success = GetImageNonSymbolRiftInfo(
                              OldFileMapped,
                              OldFileSize,
                              OldFileNtHeader,
                              NewFileMapped,
                              NewFileSize,
                              NewFileNtHeader,
                              SubAllocator,
                              RiftTable
                              );

                //
                //  Now get rift info from symbols
                //

                if ( Success ) {

                    if (( OptionData ) && ( OptionData->SizeOfThisStruct >= sizeof( PATCH_OPTION_DATA ))) {

                        SymbolOptionFlags = OptionData->SymbolOptionFlags;

                        if ( ! ( SymbolOptionFlags & PATCH_SYMBOL_NO_IMAGEHLP )) {

                            if ( OptionData->OldFileSymbolPathArray ) {

                                OldFileSymPath = OptionData->OldFileSymbolPathArray[ OldFileIndex ];
                                NewFileSymPath = OptionData->NewFileSymbolPath;

                                if (( OldFileSymPath ) && ( NewFileSymPath )) {

                                    Success = GetImageSymbolRiftInfo(
                                                  OldFileHandle,
                                                  OldFileMapped,
                                                  OldFileSize,
                                                  OldFileNtHeader,
                                                  OldFileSymPath,
                                                  OldFileOriginalChecksum,
                                                  OldFileOriginalTimeDate,
                                                  OldFileIndex,
                                                  NewFileHandle,
                                                  NewFileMapped,
                                                  NewFileSize,
                                                  NewFileNtHeader,
                                                  NewFileSymPath,
                                                  SymbolOptionFlags,
                                                  SubAllocator,
                                                  RiftTable,
                                                  OptionData->SymLoadCallback,
                                                  OptionData->SymLoadContext
                                                  );

                                    if ( SymbolOptionFlags & PATCH_SYMBOL_NO_FAILURES ) {
#ifdef TESTCODE
                                        if (( ! Success ) && ( GetLastError() == ERROR_PATCH_IMAGEHLP_FAILURE )) {
                                            printf( "\rWARNING: Imagehlp.Dll failure\n" );
                                            }
#endif
                                        Success = TRUE;
                                        }
                                    }
                                }
                            }
                        }
                    }

                if ( Success ) {

                    RiftSortAndRemoveDuplicates(
                        OldFileMapped,
                        OldFileSize,
                        OldFileNtHeader,
                        NewFileMapped,
                        NewFileSize,
                        NewFileNtHeader,
                        RiftTable
                        );

                    //
                    //  Now we can optimize the rift info by peeking into
                    //  the mapped files.
                    //

                    Success = OptimizeImageRiftInfo(
                                  OldFileMapped,
                                  OldFileSize,
                                  OldFileNtHeader,
                                  NewFileMapped,
                                  NewFileSize,
                                  NewFileNtHeader,
                                  SubAllocator,
                                  RiftTable
                                  );
                    }

#ifdef TESTCODE

                if ( Success ) {

                    HANDLE hFile = CreateFile(
                                       "RiftInfo.out",
                                       GENERIC_WRITE,
                                       FILE_SHARE_READ,
                                       NULL,
                                       CREATE_ALWAYS,
                                       FILE_ATTRIBUTE_NORMAL,
                                       NULL
                                       );

                    if ( hFile != INVALID_HANDLE_VALUE ) {

                        CHAR  TextBuffer[ 24 ];
                        DWORD Actual;
                        ULONG i;

                        for ( i = 0; i < RiftTable->RiftEntryCount; i++ ) {
                            sprintf( TextBuffer, "%08X %08X\r\n", RiftTable->RiftEntryArray[ i ].OldFileRva, RiftTable->RiftEntryArray[ i ].NewFileRva );
                            WriteFile( hFile, TextBuffer, 19, &Actual, NULL );
                            }

                        CloseHandle( hFile );
                        }
                    }

#endif // TESTCODE

                }
            }
        }

    __except( EXCEPTION_EXECUTE_HANDLER ) {
        SetLastError( GetExceptionCode() );
        Success = FALSE;
        }

    if ( SubAllocator ) {
        DestroySubAllocator( SubAllocator );
        }

    return Success;
    }


#endif // PATCH_APPLY_CODE_ONLY
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mspatch\api\redblack.c ===
#include <precomp.h>

/*
    redblack.c

    Implementation of red-black binary tree insertion, deletion, and search.
    This algorithm efficiently guarantees that the tree depth will never exceed
    2*Lg(N), so a one million node tree would have a worst case depth of 40.
    This insertion implementation is non-recursive and very efficient (the
    average insertion speed is less than twice the average search speed).

    Author: Tom McGuire (tommcg) 1/98

    Copyright (C) Microsoft, 1998.

    2/98, modified this version of redblack.c for debug symbol lookups.

*/

#ifndef PATCH_APPLY_CODE_ONLY

//
//  Rather than storing NULL links as NULL, we point NULL links to a special
//  "Empty" node which is always black and its children links point to itself.
//  We do this to simplify the color testing for children and grandchildren
//  such that any link can be dereferenced and even double-dereferenced without
//  explicitly checking for NULL.  The empty node must be colored black.
//

const SYMBOL_NODE SymRBEmptyNode = { RBNIL, RBNIL };


VOID
SymRBInitTree(
    IN OUT PSYMBOL_TREE Tree,
    IN HANDLE SubAllocator
    )
    {
#if defined( DEBUG ) || defined( DBG ) || defined( TESTCODE )
    Tree->CountNodes = 0;
    Tree->DeletedAny = FALSE;
#endif
    Tree->Root = RBNIL;
    Tree->SubAllocator = SubAllocator;
    }


PSYMBOL_NODE
SymRBFind(
    IN PSYMBOL_TREE Tree,
    IN LPSTR SymbolName
    )
    {
    PSYMBOL_NODE Node = Tree->Root;
    ULONG        Hash;
    int          Compare;

    Hash = HashName( SymbolName );

    while ( Node != RBNIL ) {

        if ( Hash < Node->Hash ) {
            Node =  Node->Left;
            }
        else if ( Hash > Node->Hash ) {
            Node =  Node->Right;
            }
        else {

            Compare = strcmp( SymbolName, Node->SymbolName );

            if ( Compare == 0 ) {
                return Node;
                }
            else if ( Compare < 0 ) {
                Node =  Node->Left;
                }
            else {
                Node =  Node->Right;
                }
            }
        }

    return NULL;
    }


PSYMBOL_NODE
SymRBInsert(
    IN OUT PSYMBOL_TREE Tree,
    IN     LPSTR SymbolName,
    IN     ULONG Rva
    )
    {
    PSYMBOL_NODE * Stack[ MAX_DEPTH ];
    PSYMBOL_NODE **StackPointer = Stack;
    PSYMBOL_NODE * Link;
    PSYMBOL_NODE   Node;
    PSYMBOL_NODE   Sibling;
    PSYMBOL_NODE   Parent;
    PSYMBOL_NODE   Child;
    PSYMBOL_NODE   NewNode;
    ULONG          NameLength;
    ULONG          Hash;
    int            Compare;

    ASSERT( ! Tree->DeletedAny );

    Hash = HashName( SymbolName );

    //
    //  Walk down the tree to find either an existing node with the same key
    //  (in which case we simply return) or the insertion point for the new
    //  node.  At each traversal we need to store the address of the link to
    //  the next node so we can retrace the traversal path for balancing.
    //  The speed of insertion is highly dependent on traversing the tree
    //  quickly, so all balancing operations are deferred until after the
    //  traversal is complete.
    //

    *StackPointer++ = &Tree->Root;

    Node = Tree->Root;

    while ( Node != RBNIL ) {

        if ( Hash < Node->Hash ) {
            *StackPointer++ = &Node->Left;
            Node = Node->Left;
            }
        else if ( Hash > Node->Hash ) {
            *StackPointer++ = &Node->Right;
            Node = Node->Right;
            }
        else {

            Compare = strcmp( SymbolName, Node->SymbolName );

            if ( Compare == 0 ) {

                //
                //  Found a matching symbol.
                //

                return Node;
                }

            else if ( Compare < 0 ) {
                *StackPointer++ = &Node->Left;
                Node = Node->Left;
                }
            else {
                *StackPointer++ = &Node->Right;
                Node = Node->Right;
                }
            }
        }

    //
    //  Didn't find a matching entry, so allocate a new node and add it
    //  to the tree.
    //

    NameLength = (ULONG) strlen( SymbolName ) + 1;

    NewNode = SubAllocate( Tree->SubAllocator, ( sizeof( SYMBOL_NODE ) + NameLength ));

    if ( NewNode == NULL ) {
        return NULL;
        }

#if defined( DEBUG ) || defined( DBG ) || defined( TESTCODE )
    Tree->CountNodes++;
#endif

    NewNode->Left   = RBNIL;
    NewNode->Right  = RBNIL;
    NewNode->Hash   = Hash;
    NewNode->RvaWithStatusBits = Rva | 0x80000000;  // make new node RED, not hit
    memcpy( NewNode->SymbolName, SymbolName, NameLength );

    //
    //  Insert new node under last link we traversed.  The top of the stack
    //  contains the address of the last link we traversed.
    //

    Link = *( --StackPointer );
    *Link = NewNode;

    //
    //  Now walk back up the traversal chain to see if any balancing is
    //  needed.  This terminates in one of three ways: we walk all the way
    //  up to the root (StackPointer == Stack), or find a black node that
    //  we don't need to change (no balancing needs to be done above a
    //  black node), or we perform a balancing rotation (only one necessary).
    //

    Node = NewNode;
    Child = RBNIL;

    while ( StackPointer > Stack ) {

        Link = *( --StackPointer );
        Parent = *Link;

        //
        //  Node is always red here.
        //

        if ( IS_BLACK( Parent )) {

            Sibling = ( Parent->Left == Node ) ? Parent->Right : Parent->Left;

            if ( IS_RED( Sibling )) {

                //
                //  Both Node and its Sibling are red, so change them both to
                //  black and make the Parent red.  This essentially moves the
                //  red link up the tree so balancing can be performed at a
                //  higher level.
                //
                //        Pb                     Pr
                //       /  \       ---->       /  \
                //      Cr  Sr                 Cb  Sb
                //

                MARK_BLACK( Sibling );
                MARK_BLACK( Node );
                MARK_RED( Parent );
                }

            else {

                //
                //  This is a terminal case.  The Parent is black, and it's
                //  not going to be changed to red.  If the Node's child is
                //  red, we perform an appropriate rotation to balance the
                //  tree.  If the Node's child is black, we're done.
                //

                if ( IS_RED( Child )) {

                    if ( Node->Left == Child ) {

                        if ( Parent->Left == Node ) {

                            //
                            //       Pb             Nb
                            //      /  \           /  \
                            //     Nr   Z   to    Cr  Pr
                            //    /  \                / \
                            //   Cr   Y              Y   Z
                            //

                            MARK_RED( Parent );
                            Parent->Left = Node->Right;
                            Node->Right = Parent;
                            MARK_BLACK( Node );
                            *Link = Node;
                            }

                        else {

                            //
                            //       Pb                Cb
                            //      /  \              /  \
                            //     W    Nr    to     Pr   Nr
                            //         /  \         / \   / \
                            //        Cr   Z       W   X Y   Z
                            //       /  \
                            //      X    Y
                            //

                            MARK_RED( Parent );
                            Parent->Right = Child->Left;
                            Child->Left = Parent;
                            Node->Left = Child->Right;
                            Child->Right = Node;
                            MARK_BLACK( Child );
                            *Link = Child;
                            }
                        }

                    else {

                        if ( Parent->Right == Node ) {

                            MARK_RED( Parent );
                            Parent->Right = Node->Left;
                            Node->Left = Parent;
                            MARK_BLACK( Node );
                            *Link = Node;
                            }

                        else {

                            MARK_RED( Parent );
                            Parent->Left = Child->Right;
                            Child->Right = Parent;
                            Node->Right = Child->Left;
                            Child->Left = Node;
                            MARK_BLACK( Child );
                            *Link = Child;
                            }
                        }
                    }

                return NewNode;
                }
            }

        Child = Node;
        Node = Parent;
        }

    //
    //  We bubbled red up to the root -- restore it to black.
    //

    MARK_BLACK( Tree->Root );
    return NewNode;
    }

#endif // ! PATCH_APPLY_CODE_ONLY
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mspatch\api\pestuff.h ===
#ifndef _PATCH_PESTUFF_H_
#define _PATCH_PESTUFF_H_

#ifdef __cplusplus
extern "C" {
#endif

typedef IMAGE_DOS_HEADER                UNALIGNED* UP_IMAGE_DOS_HEADER;
typedef IMAGE_NT_HEADERS32              UNALIGNED* UP_IMAGE_NT_HEADERS32;
typedef IMAGE_SECTION_HEADER            UNALIGNED* UP_IMAGE_SECTION_HEADER;
typedef IMAGE_EXPORT_DIRECTORY          UNALIGNED* UP_IMAGE_EXPORT_DIRECTORY;
typedef IMAGE_IMPORT_DESCRIPTOR         UNALIGNED* UP_IMAGE_IMPORT_DESCRIPTOR;
typedef IMAGE_IMPORT_BY_NAME            UNALIGNED* UP_IMAGE_IMPORT_BY_NAME;
typedef IMAGE_THUNK_DATA32              UNALIGNED* UP_IMAGE_THUNK_DATA32;
typedef IMAGE_RESOURCE_DIRECTORY        UNALIGNED* UP_IMAGE_RESOURCE_DIRECTORY;
typedef IMAGE_RESOURCE_DIRECTORY_ENTRY  UNALIGNED* UP_IMAGE_RESOURCE_DIRECTORY_ENTRY;
typedef IMAGE_RESOURCE_DATA_ENTRY       UNALIGNED* UP_IMAGE_RESOURCE_DATA_ENTRY;
typedef IMAGE_RESOURCE_DIR_STRING_U     UNALIGNED* UP_IMAGE_RESOURCE_DIR_STRING_U;
typedef IMAGE_LOAD_CONFIG_DIRECTORY32   UNALIGNED* UP_IMAGE_LOAD_CONFIG_DIRECTORY32;
typedef IMAGE_BASE_RELOCATION           UNALIGNED* UP_IMAGE_BASE_RELOCATION;


UP_IMAGE_NT_HEADERS32
__fastcall
GetNtHeader(
    IN PVOID MappedFile,
    IN ULONG MappedFileSize
    );

BOOL
NormalizeCoffImage(
    IN OUT UP_IMAGE_NT_HEADERS32 NtHeader,
    IN OUT PUCHAR MappedFile,
    IN     ULONG  FileSize,
    IN     ULONG  OptionFlags,
    IN     PVOID  OptionData,
    IN     ULONG  NewFileCoffBase,
    IN     ULONG  NewFileCoffTime
    );

BOOL
TransformCoffImage(
    IN     ULONG  TransformOptions,
    IN OUT UP_IMAGE_NT_HEADERS32 NtHeader,
    IN OUT PUCHAR OldFileMapped,
    IN     ULONG  OldFileSize,
    IN     ULONG  NewFileResTime,
    IN OUT PRIFT_TABLE RiftTable,
    IN OUT PUCHAR HintMap,
    ...
    );

BOOL
GenerateRiftTable(
    IN HANDLE OldFileHandle,
    IN PUCHAR OldFileMapped,
    IN ULONG  OldFileSize,
    IN ULONG  OldFileOriginalChecksum,
    IN ULONG  OldFileOriginalTimeDate,
    IN HANDLE NewFileHandle,
    IN PUCHAR NewFileMapped,
    IN ULONG  NewFileSize,
    IN ULONG  OptionFlags,
    IN PVOID  OptionData,
    IN ULONG  OldFileIndex,
    IN PVOID  RiftTable
    );

VOID
InitImagehlpCritSect(
    VOID
    );

VOID
UnloadImagehlp(
    VOID
    );

#define X86_OPCODE_NOP  0x90
#define X86_OPCODE_LOCK 0xF0

BOOL
SmashLockPrefixesInMappedImage(
    IN PUCHAR MappedFile,
    IN ULONG  FileSize,
    IN UP_IMAGE_NT_HEADERS32 NtHeader,
    IN UCHAR  NewOpCode      // X86_OPCODE_NOP or X86_OPCODE_LOCK
    );

USHORT
ChkSum(
    IN USHORT  Initial,
    IN PUSHORT Buffer,
    IN ULONG   Bytes
    );

PVOID
__fastcall
ImageDirectoryMappedAddress(
    IN  UP_IMAGE_NT_HEADERS32 NtHeader,
    IN  ULONG  DirectoryIndex,
    OUT PULONG DirectorySize,
    IN  PUCHAR MappedBase,
    IN  ULONG  MappedSize
    );


#ifdef __cplusplus
}
#endif

#endif // _PATCH_PESTUFF_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mspatch\api\src_dll.inc ===
#
#  Must set TARGETNAME and DLLBASE before including this file
#

TARGETTYPE=DYNLINK

UMTYPE=windows

TARGETLIBS=$(SDK_LIB_PATH)\kernel32.lib \
           $(SDK_LIB_PATH)\user32.lib \
           ..\..\lzx\encoder\$(O)\lzxpc.lib \
           ..\..\lzx\decoder\$(O)\lzxpd.lib

C_DEFINES=$(C_DEFINES) -DBUILDING_PATCHAPI_DLL=1

SOURCES=$(SOURCES) $(TARGETNAME).rc

!if "$(TARGET_DIRECTORY)" != "i386"
!undef NO_NTDLL
!endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mspatch\api\redblack.h ===
/*
    redblack.h

    Prototypes and node structure definition for red-black binary trees.
    See redblack.c for details and implementation.

    Author: Tom McGuire (tommcg) 1/98

    Copyright (C) Microsoft, 1998.

    2/98, modified this version of redblack.h for debug symbol lookups.

*/

#ifndef _REDBLACK_H_
#define _REDBLACK_H_

typedef struct _SYMBOL_NODE SYMBOL_NODE, *PSYMBOL_NODE;
typedef struct _SYMBOL_TREE SYMBOL_TREE, *PSYMBOL_TREE;

struct _SYMBOL_NODE {
    PSYMBOL_NODE Left;
    PSYMBOL_NODE Right;
    ULONG        Hash;
    union {
      ULONG      RvaWithStatusBits;
      struct {
        ULONG    Rva:30;
        ULONG    Hit:1;
        ULONG    Red:1;
        };
      };
    CHAR         SymbolName[ 0 ];
    };

struct _SYMBOL_TREE {
    PSYMBOL_NODE Root;
    HANDLE SubAllocator;
#if defined( DEBUG ) || defined( DBG ) || defined( TESTCODE )
    ULONG CountNodes;
    BOOL DeletedAny;
#endif
    };


#define RBNIL ((PSYMBOL_NODE)&SymRBEmptyNode)

extern const SYMBOL_NODE SymRBEmptyNode;


//
//  Although "Red" can be stored in its own 1-byte or 4-byte field, keeping the
//  nodes smaller by encoding "Red" as a one-bit field with another value
//  provides better performance (more nodes tend to stay in the cache).  To
//  provide flexibility in storage of the RED property, all references to RED
//  and BLACK are made through the following macros which can be changed as
//  necessary:
//

#define IS_RED( Node )            (   (Node)->Red )
#define IS_BLACK( Node )          ( ! (Node)->Red )
#define MARK_RED( Node )          (   (Node)->Red = 1 )
#define MARK_BLACK( Node )        (   (Node)->Red = 0 )

//
//  The maximum tree depth is 2*Lg(N).  Since we could never have more than
//  2^X nodes with X-bit pointers, we can safely say the absolute maximum
//  depth will be 2*Lg(2^X) which is 2*X.  The size of a pointer in bits is
//  its size in bytes times 8 bits, so 2*(sizeof(p)*8) is our maximum depth.
//  So for 32-bit pointers, our maximum depth is 64.
//
//  If you know the maximum possible number of nodes in advance (like the size
//  of the address space divided by the size of a node), you can tweak this
//  value a bit smaller to 2*Lg(N).  Note that it's important for this max
//  depth be evalutated to a constant value at compile time.
//
//  For this implementation, we'll assume the maximum number of nodes is
//  128 million, so the max depth is 54 (2*Lg(2^27)).  Note that no runtime
//  checks are made to ensure we don't exceed this number, but since our
//  minimum node allocation size is 32 bytes, that would be a maximum of
//  100 million nodes in a 3GB address space.
//

#define MAX_DEPTH 54


//
//  The following prototypes are the red-black tree interface.
//

VOID
SymRBInitTree(
    IN OUT PSYMBOL_TREE Tree,
    IN HANDLE SubAllocator
    );

PSYMBOL_NODE
SymRBInsert(
    IN OUT PSYMBOL_TREE Tree,
    IN     LPSTR SymbolName,
    IN     ULONG Rva
    );

PSYMBOL_NODE
SymRBFind(
    IN PSYMBOL_TREE Tree,
    IN LPSTR SymbolName
    );

PSYMBOL_NODE
SymRBFindAndDelete(
    IN OUT PSYMBOL_TREE Tree,
    IN     LPSTR SymbolName
    );


#endif // _REDBLACK_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mspatch\api\precomp.h ===
#define BUILDING_PATCHAPI 1

#pragma warning( disable: 4001 )    // single line comments
#pragma warning( disable: 4115 )    // type definition in parentheses
#pragma warning( disable: 4200 )    // zero-sized array in struct/union
#pragma warning( disable: 4201 )    // nameless struct/union
#pragma warning( disable: 4204 )    // non-constant initializer
#pragma warning( disable: 4206 )    // empty file after preprocessing
#pragma warning( disable: 4209 )    // benign redefinition
#pragma warning( disable: 4213 )    // cast on l-value
#pragma warning( disable: 4214 )    // bit field other than int
#pragma warning( disable: 4514 )    // unreferenced inline function

#ifndef WIN32_LEAN_AND_MEAN
#define WIN32_LEAN_AND_MEAN 1
#endif

#include <windows.h>
#include <wincrypt.h>
#pragma warning( disable: 4201 )
#include <imagehlp.h>
#include <stdlib.h>

//
//  For some reason, windows.h screws up the disabled warnings, so we have
//  to disable them again after including it.
//

#pragma warning( disable: 4001 )    // single line comments
#pragma warning( disable: 4115 )    // type definition in parentheses
#pragma warning( disable: 4200 )    // zero-sized array in struct/union
#pragma warning( disable: 4201 )    // nameless struct/union
#pragma warning( disable: 4204 )    // non-constant initializer
#pragma warning( disable: 4206 )    // empty file after preprocessing
#pragma warning( disable: 4209 )    // benign redefinition
#pragma warning( disable: 4213 )    // cast on l-value
#pragma warning( disable: 4214 )    // bit field other than int
#pragma warning( disable: 4514 )    // unreferenced inline function

#include "md5.h"
#include "misc.h"
#include "redblack.h"
#include "patchapi.h"
#include "patchprv.h"
#include "patchlzx.h"
#include "pestuff.h"

typedef void t_encoder_context;
typedef void t_decoder_context;

#include <encapi.h>
#include <decapi.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mspatch\api\samples\apatch\apatch.c ===
#ifndef _WIN32_WINNT
#define _WIN32_WINNT 0x0400
#endif

#ifndef WIN32
#define WIN32 0x0400
#endif

#pragma warning( disable: 4001 4035 4115 4200 4201 4204 4209 4214 4514 4699 )

#include <windows.h>

#pragma warning( disable: 4001 4035 4115 4200 4201 4204 4209 4214 4514 4699 )

#include <stdlib.h>
#include <stdio.h>

#include "patchapi.h"
#include "patchprv.h"
#include <ntverp.h>
#include <common.ver>


typedef
BOOL
PATCHAPI
FN_ApplyPatchToFileExA(
    IN  LPCSTR                   PatchFileName,
    IN  LPCSTR                   OldFileName,
    OUT LPCSTR                   NewFileName,
    IN  ULONG                    ApplyOptionFlags,
    IN  PPATCH_PROGRESS_CALLBACK ProgressCallback,
    IN  PVOID                    CallbackContext
    );

typedef FN_ApplyPatchToFileExA *PFN_ApplyPatchToFileExA;

FN_ApplyPatchToFileExA ApplyPatchToFileExA;   // assert typedef correctness



void CopyRight( void ) {
    printf(
        "\n"
        "APATCH " VER_PRODUCTVERSION_STR " Patch Application Utility\n"
        VER_LEGALCOPYRIGHT_STR
        "\n\n"
        );
    }


void Usage( void ) {
    printf(
        "Usage:  APATCH PatchFile OldFile TargetNewFile\n\n"
        );
    exit( 1 );
    }


BOOL
CALLBACK
MyProgressCallback(
    PVOID CallbackContext,
    ULONG CurrentPosition,
    ULONG MaximumPosition
    )
    {
    UNREFERENCED_PARAMETER( CallbackContext );

    if ( CurrentPosition & 0xFF000000 ) {
        CurrentPosition >>= 8;
        MaximumPosition >>= 8;
        }

    if ( MaximumPosition != 0 ) {
        fprintf( stderr, "\r%3.1f%% complete", ( CurrentPosition * 100.0 ) / MaximumPosition );
        }

    return TRUE;
    }


void __cdecl main( int argc, char *argv[] ) {

    LPSTR OldFileName   = NULL;
    LPSTR PatchFileName = NULL;
    LPSTR NewFileName   = NULL;
    LPSTR DllFileName   = NULL;
    BOOL  Success;
    LPSTR arg;
    int   i;
    CHAR  LoadedFileName[ MAX_PATH + 1 ];
    HMODULE hLib;
    PFN_ApplyPatchToFileExA pApplyPatchToFileExA = ApplyPatchToFileExA;

    SetErrorMode( SEM_FAILCRITICALERRORS );

#ifndef DEBUG
    SetErrorMode( SEM_NOALIGNMENTFAULTEXCEPT | SEM_FAILCRITICALERRORS );
#endif

    CopyRight();

    for ( i = 1; i < argc; i++ ) {

        arg = argv[ i ];

        if ( strchr( arg, '?' )) {
            Usage();
            }

        if ( _strnicmp( arg, "/dll:", 5 ) == 0 ) {
            DllFileName = arg + 5;
            }
        else if ( PatchFileName == NULL ) {
            PatchFileName = arg;
            }
        else if ( OldFileName == NULL ) {
            OldFileName = arg;
            }
        else if ( NewFileName == NULL ) {
            NewFileName = arg;
            }
        else {
            Usage();
            }
        }

    if (( OldFileName == NULL ) || ( NewFileName == NULL ) || ( PatchFileName == NULL )) {
        Usage();
        }

    if ( DllFileName != NULL ) {

        hLib = LoadLibrary( DllFileName );
        if ( hLib == NULL ) {
            printf( "Unable to load DLL '%s'\n", DllFileName );
            exit( 1 );
            }

        if ( GetModuleFileName( hLib, LoadedFileName, sizeof( LoadedFileName ))) {
            printf( "Loaded DLL '%s'\n", LoadedFileName );
            }

        pApplyPatchToFileExA = (PFN_ApplyPatchToFileExA) GetProcAddress( hLib, "ApplyPatchToFileExA" );
        if ( pApplyPatchToFileExA == NULL ) {
            printf( "Unable to import ApplyPatchToFileExA from DLL\n" );
            exit( 1 );
            }
        }

    DeleteFile( NewFileName );

    Success = pApplyPatchToFileExA(
                  PatchFileName,
                  OldFileName,
                  NewFileName,
                  0,
                  MyProgressCallback,
                  NULL
                  );

    printf( "\n\n" );

    if ( ! Success ) {

        CHAR  ErrorText[ 16 ];
        ULONG ErrorCode = GetLastError();

        sprintf( ErrorText, ( ErrorCode < 0x10000000 ) ? "%d" : "%X", ErrorCode );

        printf( "Failed to create file from patch (%s)\n", ErrorText );

        exit( 1 );
        }

    printf( "OK\n" );
    exit( 0 );

    }
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mspatch\api\sources.inc ===
TARGETPATH=obj

SOURCES=..\patchapi.c \
        ..\patchlzx.c \
        ..\pestuff.c  \
        ..\redblack.c \
        ..\misc.c     \
        ..\md5.c

INCLUDES=..;..\..\lzx\encoder;..\..\lzx\decoder

#
#  Turn off precompiled headers for now since VC6 causes a "PchSym"
#  object to wind up in the binary's .data section.  Well we don't otherwise
#  have a .data section, so this "PchSym" essentially costs a whole
#  page of address space.  If VC6 is fixed, or if using another
#  compiler, can turn precompiled headers back on.
#

# PRECOMPILED_INCLUDE=..\precomp.h
# PRECOMPILED_PCH=precomp.pch
# PRECOMPILED_OBJ=precomp.obj

#
#  Even though we're building DLLs here, we don't want to use MSVCRT.DLL
#  because that file doesn't exist on standard Win95 systems.  Instead we'll
#  use LIBCMT.LIB to drag in the few things we need from the CRT such as
#  memmove and alloca support.
#

USE_LIBCMT=1

#
#  But, if we're building test or debug versions, which need printf support,
#  we'll use MSVCRT.DLL instead.
#

!IFDEF TESTCODE
C_DEFINES=$(C_DEFINES) -DTESTCODE=$(TESTCODE)
!undef USE_LIBCMT
USE_MSVCRT=1
!ENDIF

!IFDEF DEBUG
C_DEFINES=$(C_DEFINES) -DDEBUG=$(DEBUG)
!undef USE_LIBCMT
USE_MSVCRT=1
!ENDIF

NO_NTDLL=1

MSC_WARNING_LEVEL=/W4
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mspatch\api\samples\apatch\tracing.c ===
#ifndef _WIN32_WINNT
#define _WIN32_WINNT 0x0400
#endif

#ifndef WIN32
#define WIN32 0x0400
#endif

#pragma warning( disable: 4001 4035 4115 4200 4201 4204 4209 4214 4514 4699 )

#include <windows.h>

#pragma warning( disable: 4001 4035 4115 4200 4201 4204 4209 4214 4514 4699 )

#include <stdlib.h>
#include <stdio.h>

#include "patchapi.h"

#ifdef TRACING

#define FILESIZE (3000000)

long g_OldFilePosition;
unsigned long g_cLiterals = 0;
unsigned long g_cMatches = 0;
unsigned long g_cMatchBytes = 0;

#if 0   /* distance.xls */
unsigned long cDistances[6000000] = { 0 };
#endif

#ifdef COMPOSITION  /* composition.xls */
#define BUCKET_SIZE (4096)
#define NBUCKETS (FILESIZE / BUCKET_SIZE)
enum { LITERAL, MATCH_OLD, MATCH_NEW, BUCKET_TYPES };
unsigned long cBuckets[NBUCKETS][BUCKET_TYPES] = { { 0,0,0 } };
#endif

#if 0   /* rifts */
#define NO_DISPLACEMENT (333333333)
long iDisplacement[FILESIZE];
#endif

#if 0   /* slots */
#define MAX_SLOTS 500
unsigned long cSlotUsed[MAX_SLOTS];
#endif

typedef struct
{
    unsigned long ulRegionOffset;
    unsigned long ulRegionSize;
    unsigned long ulRegionAddress;
} FILE_REGION;

#define MAX_REGIONS 50

int cRegionsOld = 0;
FILE_REGION RegionsOld[MAX_REGIONS];
int cRegionsNew = 0;
FILE_REGION RegionsNew[MAX_REGIONS];


typedef struct
{
    unsigned long ulNewOffset;
    unsigned long ulOldOffset;
    unsigned long ulMatchLength;
} MATCH_LOG_ENTRY;

#define MAX_MATCH_LOG_ENTRIES (500000)

int cMatchLogEntries = 0;
MATCH_LOG_ENTRY MatchLog[MAX_MATCH_LOG_ENTRIES];


typedef struct _a_POINTER_REMAP
{
    struct _a_POINTER_REMAP *pNext;
    unsigned long ulNewPointer;
    unsigned long ulOldPointer;
    unsigned long ulLength;
} POINTER_REMAP;

POINTER_REMAP *pPointerRemapList;


#ifdef RIFTGEN
static char isRelocEntry[FILESIZE] = { '\0' };

#ifdef RIFTGEN2   /* references */
typedef struct _a_reference
{
    struct _a_reference *pNext;
    long iDisplacement;
} REFERENCE;

static REFERENCE *pReferences[FILESIZE] = { NULL };
#endif
#endif


static int QueryRelocsInRange(unsigned long ulAddress, unsigned long ulLength)
{
    int iRegion;
    unsigned long ulFileOffset;
    int fRelocsFound = FALSE;

    for (iRegion = 0; iRegion < cRegionsOld; iRegion++)
    {
        if ((ulAddress >= RegionsOld[iRegion].ulRegionAddress) &&
            (ulAddress < (RegionsOld[iRegion].ulRegionAddress + RegionsOld[iRegion].ulRegionSize)))
        {
            break;
        }
    }

    if (iRegion != cRegionsOld)
    {
        ulFileOffset = RegionsOld[iRegion].ulRegionOffset + (ulAddress - RegionsOld[iRegion].ulRegionAddress);

        while (ulLength--)
        {
            if (isRelocEntry[ulFileOffset])
            {
                fRelocsFound = TRUE;
                break;
            }

            ulFileOffset++;
            ulAddress++;
        }
    }

    return(fRelocsFound);
}


static void DisplayMatchLog(void)
{
    int iMatchLogEntry;
    unsigned long ulNewOffset;
    unsigned long ulOldOffset;
    int iNewFileRegion;
    int iOldFileRegion;
    unsigned long ulMatchLength;
    unsigned long ulLocalLength;
    unsigned long ulNewDisplacement;
    unsigned long ulOldDisplacement;
    POINTER_REMAP *pRemap;
    POINTER_REMAP **ppBacklink;
    unsigned long ulNewPointer;
    unsigned long ulOldPointer;
    long lLastDisplacement;

    if (cMatchLogEntries == 0)
    {
        return;
    }

    pPointerRemapList = NULL;

    for (iMatchLogEntry = 0; iMatchLogEntry < cMatchLogEntries; iMatchLogEntry++)
    {
        ulNewOffset = MatchLog[iMatchLogEntry].ulNewOffset;
        ulOldOffset = MatchLog[iMatchLogEntry].ulOldOffset;
        ulMatchLength = MatchLog[iMatchLogEntry].ulMatchLength;

        while (ulMatchLength)               /* until all is done */
        {
            ulLocalLength = ulMatchLength;  /* might get clipped */

            /* locate corresponding new file region to get it's address */

            for (iNewFileRegion = 0; iNewFileRegion < cRegionsNew; iNewFileRegion++)
            {
                if ((ulNewOffset >= RegionsNew[iNewFileRegion].ulRegionOffset) &&
                    (ulNewOffset < (RegionsNew[iNewFileRegion].ulRegionOffset + RegionsNew[iNewFileRegion].ulRegionSize)))
                {
                    break;
                }
            }

            if (iNewFileRegion == cRegionsNew)
            {
                goto dontcare;
            }

            /* clip if match spans beyond this region */

            ulNewDisplacement = ulNewOffset - RegionsNew[iNewFileRegion].ulRegionOffset;
            ulNewPointer = RegionsNew[iNewFileRegion].ulRegionAddress + ulNewDisplacement;

            if (ulLocalLength > (RegionsNew[iNewFileRegion].ulRegionSize - ulNewDisplacement))
            {
                ulLocalLength = (RegionsNew[iNewFileRegion].ulRegionSize - ulNewDisplacement);
            }

            /* locate corresponding old file region to get it's address */

            for (iOldFileRegion = 0; iOldFileRegion < cRegionsOld; iOldFileRegion++)
            {
                if ((ulOldOffset >= RegionsOld[iOldFileRegion].ulRegionOffset) &&
                    (ulOldOffset < (RegionsOld[iOldFileRegion].ulRegionOffset + RegionsOld[iOldFileRegion].ulRegionSize)))
                {
                    break;
                }
            }

            if (iOldFileRegion == cRegionsOld)
            {
                goto dontcare;
            }

            /* clip if match spans beyond this region */

            ulOldDisplacement = ulOldOffset - RegionsOld[iOldFileRegion].ulRegionOffset;
            ulOldPointer = RegionsOld[iOldFileRegion].ulRegionAddress + ulOldDisplacement;

            if (ulLocalLength > (RegionsOld[iOldFileRegion].ulRegionSize - ulOldDisplacement))
            {
                ulLocalLength = (RegionsOld[iOldFileRegion].ulRegionSize - ulOldDisplacement);
            }

            /* see if any relocs in the range */

            if (QueryRelocsInRange(ulOldPointer, ulLocalLength))
            {
                /* sorted insertion of this new remap into the list */

                ppBacklink = &pPointerRemapList;

                while (*ppBacklink != NULL)
                {
                    if ((*ppBacklink)->ulOldPointer > ulOldPointer)
                    {
                        break;
                    }

                    ppBacklink = &((*ppBacklink)->pNext);
                }

                pRemap = GlobalAlloc( GMEM_FIXED, sizeof(POINTER_REMAP) );

                pRemap->ulNewPointer = ulNewPointer;
                pRemap->ulOldPointer = ulOldPointer;
                pRemap->ulLength = ulLocalLength;

                pRemap->pNext = *ppBacklink;
                *ppBacklink = pRemap;
            }

            /* move on to next match or fragment */

            ulNewOffset   += ulLocalLength;
            ulOldOffset   += ulLocalLength;
            ulMatchLength -= ulLocalLength;
        }
dontcare:
        NULL;    // entertain compiler req: label must have a statement
    }

    printf("%08X\n", RegionsOld[ 0 ].ulRegionAddress);

    lLastDisplacement = 0;

    for (pRemap = pPointerRemapList; pRemap != NULL; pRemap = pRemap->pNext)
    {
        if (lLastDisplacement != (long) (pRemap->ulNewPointer - pRemap->ulOldPointer))
        {
            lLastDisplacement = pRemap->ulNewPointer - pRemap->ulOldPointer;

            printf("%08X %08X\n", pRemap->ulOldPointer, pRemap->ulNewPointer);
        }
    }
}

#endif


void CopyRight( void ) {
    MessageBox(
        NULL,
        "\n"
        "APATCH 0.15 Patch Application Utility\n"
        "Copyright (C) Microsoft, 1997\n"
        "\n",
        "APATCH Copyright",
        MB_OK);
    }


void Usage( void ) {
    MessageBox(NULL,
        "Usage:  APATCH PatchFile OldFile TargetNewFile\n\n",
        "APATCH Usage",
        MB_OK);
    }


BOOL
CALLBACK
MyProgressCallback(
    PVOID CallbackContext,
    ULONG CurrentPosition,
    ULONG MaximumPosition
    )
    {
    UNREFERENCED_PARAMETER( CallbackContext );

    if ( CurrentPosition & 0xFF000000 ) {
        CurrentPosition >>= 8;
        MaximumPosition >>= 8;
        }

    if ( MaximumPosition != 0 ) {
// guigauge: printf( "\r%3d%% complete", ( CurrentPosition * 100 ) / MaximumPosition );
        }

    return TRUE;
    }


int StrChr( char *psz, char c )
{
    while (*psz)
    {
        if (*psz++ == c)
        {
            return(TRUE);
        }
    }

    return(FALSE);
}


int __cdecl main( int argc, char *argv[] ) {

    LPSTR OldFileName   = NULL;
    LPSTR PatchFileName = NULL;
    LPSTR NewFileName   = NULL;
    BOOL  Success;
    LPSTR arg;
    int   i;

    SetErrorMode( SEM_FAILCRITICALERRORS );

#ifndef DEBUG
    SetErrorMode( SEM_NOALIGNMENTFAULTEXCEPT | SEM_FAILCRITICALERRORS );
#endif

    // CopyRight();

    for ( i = 1; i < argc; i++ ) {

        arg = argv[ i ];

        if ( StrChr( arg, '?' )) {
            Usage();
            goto bail;
            }

        if ( PatchFileName == NULL ) {
            PatchFileName = arg;
            }
        else if ( OldFileName == NULL ) {
            OldFileName = arg;
            }
        else if ( NewFileName == NULL ) {
            NewFileName = arg;
            }
        else {
            Usage();
            goto bail;
            }
        }

    if (( OldFileName == NULL ) || ( NewFileName == NULL ) || ( PatchFileName == NULL )) {
        Usage();
        goto bail;
        }

    DeleteFile( NewFileName );

#ifdef TRACING
#if 0   /* rifts */
    {
        long filepos;

        for (filepos = 0; filepos < FILESIZE; filepos++)
        {
            iDisplacement[filepos] = NO_DISPLACEMENT;
        }
    }
#endif
#endif

    Success = ApplyPatchToFileEx(
                  PatchFileName,
                  OldFileName,
                  NewFileName,
                  0,
                  MyProgressCallback,
                  NULL
                  );

    if ( ! Success ) {

        CHAR  ErrorText[ 16 ];
        ULONG ErrorCode = GetLastError();
        CHAR  Message[100];

        wsprintf( ErrorText, ( ErrorCode < 0x10000000 ) ? "%d" : "%X", ErrorCode );

        wsprintf( Message, "Failed to create file from patch (%s)\n", ErrorText );

        MessageBox( NULL, Message, "APATCH Failed", MB_OK );

        return( 1 );
        }

#ifdef TRACING
    {
#ifdef COMPOSITION   /* composition.xls */
        {
            int iBucket;

            for (iBucket = 0; iBucket < NBUCKETS; iBucket++)
            {
                if ((cBuckets[iBucket][LITERAL] || cBuckets[iBucket][MATCH_OLD] || cBuckets[iBucket][MATCH_NEW]))
                {
                    printf("%9lu %9lu %9lu %9lu\n",
                        iBucket * BUCKET_SIZE,
                        cBuckets[iBucket][LITERAL],
                        cBuckets[iBucket][MATCH_OLD],
                        cBuckets[iBucket][MATCH_NEW]);
                }
            }
        }
#endif

#if 0
        printf("%9lu bytes from literals\n", g_cLiterals);
        printf("%9lu bytes from %lu matches\n", g_cMatchBytes, g_cMatches);
        printf("%9lu bytes total\n", g_cLiterals + g_cMatchBytes);
#endif

#if 0   /* distance.xls */
        {
            int iDistance;

            for (iDistance = 0; iDistance < (sizeof(cDistances)/sizeof(cDistances[0])); iDistance++)
            {
                if (cDistances[iDistance] != 0)
                {
                    printf("%9ld   %9ld\n", iDistance, cDistances[iDistance]);
                }
            }
        }
#endif

#if 0   /* rifts */
        {
            long filepos;
            long iLastDisplacement = NO_DISPLACEMENT;

            for (filepos = 0; filepos < FILESIZE; filepos++)
            {
                if (iDisplacement[filepos] != NO_DISPLACEMENT)
                {
                    if (iLastDisplacement != iDisplacement[filepos])
                    {
                        iLastDisplacement = iDisplacement[filepos];

                        printf("%9lu %9ld\n", filepos, iDisplacement[filepos]);
                    }
                }
            }
        }
#endif

#if 0   /* slots */
        {  
            int slot;

            for (slot = 0; slot < MAX_SLOTS; slot++)
            {
                if (cSlotUsed[slot])
                {
                    printf("%5d  %9ld\n", slot, cSlotUsed[slot]);
                }
            }
        }
#endif

#ifdef RIFTGEN2   /* generating faked references for relrifts file */
        {   
            int index;
            REFERENCE *pReference, *pKill;
            int iLast = 0;
            int cEntries = 0;
            int cEntriesHit = 0;
            int iBest;

            for (index = 0; index < FILESIZE; index++)
            {
                pReference = pReferences[index];

                if (isRelocEntry[index])
                {
                    cEntries++;
                }

                if (pReference != NULL)
                {
                    if (isRelocEntry[index])
                    {
                        cEntriesHit++;
                    }

                    if (pReference->pNext != NULL)                  /* multiple values */
                    {
                        /* knowing the number of reloc entries interested could help here */

                        /* see if the last value is one of the choices */

                        while (pReference)
                        {
                            if (pReference->iDisplacement == iLast)
                            {
                                goto found;
                            }

                            pReference = pReference->pNext;
                        }

                        /* choose the value nearest the last value */

                        pReference = pReferences[index];
                        
                        while (pReference != NULL)
                        {
                            if (abs(pReference->iDisplacement - iLast) < abs(iBest - iLast))
                            {
                                iBest = pReference->iDisplacement;
                            }

                            pReference = pReference->pNext;
                        }

                        iLast = iBest;
                        printf("%d %d\n", index, iLast);

found:                  
                        /* now free the list */

                        pReference = pReferences[index];
                        
                        while (pReference != NULL)
                        {
                            pKill = pReference;
                            pReference = pReference->pNext;
                            GlobalFree(pKill);
                        }
                    }
                    else
                    {
                        if (iLast != pReference->iDisplacement)    /* a simple rift */
                        {
                            iLast = pReference->iDisplacement;
                            printf("%d %d\n", index, iLast);
                        }

                        GlobalFree(pReference);
                    }
                }
            }

            //fprintf(stderr, "%d hit of %d total relocation targets\n", cEntriesHit, cEntries);
        }
#endif

        DisplayMatchLog();
    }
#endif

//    MessageBox( NULL, "OK\n", "APATCH Done", MB_OK );

bail:

    return( 0 );

    }

#ifdef TRACING

void TracingSetOldFilePosition(long oldpos)
{
    g_OldFilePosition = oldpos;
}


void TracingLiteral(long bufpos, byte c)
{
#ifdef COMPOSITION   /* composition.xls */
    int iBucket = bufpos / BUCKET_SIZE;

    cBuckets[iBucket][LITERAL]++;
#endif

    g_cLiterals++;

#ifdef DECO_DETAILS   /* trace */
    printf("%08lX: %02X\n", bufpos, (byte) c);
#endif
}


void TracingMatch(long bufpos,long srcpos,long window,int length,int slot)
{
    static long iLastDisplacement = -1;

    g_cMatches++;
    g_cMatchBytes += length;

#if 0   /* slots */
    if (slot < MAX_SLOTS)
    {
        cSlotUsed[slot]++;
    }
    else
    {
        printf("Slot number out of range (%d)\n", slot);
    }
#endif

    if (srcpos < g_OldFilePosition)
    {
#ifdef COMPOSITION   /* composition.xls */
        int iBucket = bufpos / BUCKET_SIZE;
        int eBucket = (bufpos + length - 1) / BUCKET_SIZE;

        if (iBucket == eBucket)
        {
            cBuckets[iBucket][MATCH_NEW] += length;
        }
        else
        {
            long length1 = (eBucket * BUCKET_SIZE) - bufpos;
            cBuckets[iBucket][MATCH_NEW] += length1;
            cBuckets[eBucket][MATCH_NEW] += (length - length1);
        }
#endif

#ifdef DECO_DETAILS   /* trace */
        {
            int iDistance = bufpos - srcpos;

            printf("%08lX..%08lX:  %08lX..%08lX  (%d,%u)\n",  /* new file refs no [...] */
                bufpos,
                bufpos + length - 1,
                srcpos,
                srcpos + length - 1,
                -iDistance,
                length);
        }
#endif

#if 0
        if (iLastDisplacement != (srcpos - bufpos))
        {
            iLastDisplacement = (srcpos - bufpos);

            printf("%9ld %9ld %9ld\n",
                bufpos,
                srcpos,
                srcpos - bufpos);
        }
#endif
    }
    else
    {
#ifdef COMPOSITION   /* composition.xls */
        int iBucket = bufpos / BUCKET_SIZE;
        int eBucket = (bufpos + length - 1) / BUCKET_SIZE;

        if (iBucket == eBucket)
        {
            cBuckets[iBucket][MATCH_OLD] += length;
        }
        else
        {
            long length1 = (eBucket * BUCKET_SIZE) - bufpos;
            cBuckets[iBucket][MATCH_OLD] += length1;
            cBuckets[eBucket][MATCH_OLD] += (length - length1);
        }
#endif

        if ((cMatchLogEntries != 0) &&
            ((MatchLog[cMatchLogEntries - 1].ulNewOffset + MatchLog[cMatchLogEntries - 1].ulMatchLength) == (unsigned long) bufpos) &&
            ((MatchLog[cMatchLogEntries - 1].ulOldOffset + MatchLog[cMatchLogEntries - 1].ulMatchLength) == (unsigned long) (srcpos - g_OldFilePosition)))
        {
            MatchLog[cMatchLogEntries - 1].ulMatchLength += length;
        }
        else if (cMatchLogEntries < MAX_MATCH_LOG_ENTRIES)
        {
            MatchLog[cMatchLogEntries].ulNewOffset = bufpos;
            MatchLog[cMatchLogEntries].ulOldOffset = srcpos - g_OldFilePosition;
            MatchLog[cMatchLogEntries].ulMatchLength = length;
            cMatchLogEntries++;
        }

#ifdef DECO_DETAILS   /* trace */
        {
            int iDistance = bufpos - srcpos + window;

            printf("%08lX..%08lX: [%08lX..%08lX] (%d,%u)\n",  /* old file refs in [...] */
                bufpos,
                bufpos + length - 1,
                srcpos - g_OldFilePosition,
                srcpos - g_OldFilePosition + length - 1,
                -iDistance,
                length);
        }
#endif

#if 0   /* rifts */
        {
            int index;

            for (index = 0; index < length; index++)
            {
                iDisplacement[bufpos + index] = bufpos - srcpos + g_OldFilePosition;
            }
        }
#endif

#if 0
        if (iLastDisplacement != (bufpos - srcpos + g_OldFilePosition))
        {
            iLastDisplacement = (bufpos - srcpos + g_OldFilePosition);

            printf("%9ld %9ld %9ld\n",
                bufpos,
                srcpos - g_OldFilePosition,
                bufpos - srcpos + g_OldFilePosition);
        }
#endif

#ifdef RIFTGEN2   /* references */
        {
            int index;
            REFERENCE *pReference;
            long iOldFilePosition;

            for (index = 0; index < length; index++)
            {
                iOldFilePosition = srcpos - g_OldFilePosition + index;

                if (isRelocEntry[iOldFilePosition])
                {
                    pReference = GlobalAlloc(GMEM_FIXED, sizeof(REFERENCE));

                    pReference->pNext = pReferences[iOldFilePosition];
                    pReferences[iOldFilePosition] = pReference;
                    pReference->iDisplacement = bufpos - srcpos + g_OldFilePosition;
                }
            }
        }
#endif
    }

#if 0   /* distance.xls */
    {
        int iDistance = bufpos - srcpos + window;

        if ((iDistance < 1) || (iDistance >= (sizeof(cDistances)/sizeof(cDistances[0]))))
        {
            printf("That's a strange distance.\n");
        }
        else
        {
            cDistances[iDistance]++;
        }
    }
#endif
}

#ifdef RIFTGEN
void TracingSetIsRelocEntry(ULONG OldFileOffset, ULONG Va)
{
//    printf("offset 0x%08X is Va 0x%08X\n", OldFileOffset, Va);
//      ie, "offset 0x00000DF9 is Va 0x703B17F9" when base=0x703B0000

    isRelocEntry[OldFileOffset] = '\1';
}
#endif


void TracingReportAddresses(int FileNumber, ULONG FileOffset, ULONG Size, ULONG Address)
{
    if ( FileNumber )
    {
        RegionsNew[cRegionsNew].ulRegionOffset = FileOffset;
        RegionsNew[cRegionsNew].ulRegionSize = Size;
        RegionsNew[cRegionsNew].ulRegionAddress = Address;
        cRegionsNew++;
    }
    else
    {
        RegionsOld[cRegionsOld].ulRegionOffset = FileOffset;
        RegionsOld[cRegionsOld].ulRegionSize = Size;
        RegionsOld[cRegionsOld].ulRegionAddress = Address;
        cRegionsOld++;
    }
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mspatch\api\samples\wpatch\wpatchid.h ===
#define DLG_PROGRESS    101
#define IDC_PROGRESS    102
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mspatch\api\samples\mpatch\mpatch.c ===
#ifndef _WIN32_WINNT
#define _WIN32_WINNT 0x0400
#endif

#ifndef WIN32
#define WIN32 0x0400
#endif

#pragma warning( disable: 4001 4035 4115 4200 4201 4204 4209 4214 4514 4699 )
#include <windows.h>
#include <wincrypt.h>
#pragma warning( disable: 4201 )
#include <imagehlp.h>
#pragma warning( disable: 4001 4035 4115 4200 4201 4204 4209 4214 4514 4699 )

#include <stdlib.h>
#include <stdio.h>
#include <ctype.h>

#include "patchapi.h"
#include "patchprv.h"
#include <ntverp.h>
#include <common.ver>


typedef
BOOL
PATCHAPI
FN_CreatePatchFileA(
    IN  LPCSTR OldFileName,
    IN  LPCSTR NewFileName,
    OUT LPCSTR PatchFileName,
    IN  ULONG  OptionFlags,
    IN  PPATCH_OPTION_DATA OptionData       // optional
    );

typedef FN_CreatePatchFileA *PFN_CreatePatchFileA;

FN_CreatePatchFileA CreatePatchFileA;  // assert typedef correctness

typedef
BOOL
PATCHAPI
FN_CreatePatchFileExA(
    IN  ULONG                    OldFileCount,          // maximum 255
    IN  PPATCH_OLD_FILE_INFO_A   OldFileInfoArray,
    IN  LPCSTR                   NewFileName,
    OUT LPCSTR                   PatchFileName,
    IN  ULONG                    OptionFlags,
    IN  PPATCH_OPTION_DATA       OptionData,            // optional
    IN  PPATCH_PROGRESS_CALLBACK ProgressCallback,
    IN  PVOID                    CallbackContext
    );

typedef FN_CreatePatchFileExA *PFN_CreatePatchFileExA;

FN_CreatePatchFileExA CreatePatchFileExA;  // assert typedef correctness


void CopyRight( void ) {
    printf(
        "\n"
        "MPATCH " VER_PRODUCTVERSION_STR " Patch Creation Utility\n"
        VER_LEGALCOPYRIGHT_STR
        "\n\n"
        );
    }


void Usage( void ) {
    printf(
"Usage:  MPATCH [options] OldFile[;OldFile2[;OldFile3]] NewFile TargetPatchFile\n"
"\n"
"        Options:\n"
"\n"
"          -NOBINDFIX   Turn off automatic compensation for bound imports in\n"
"                       the the old file.  The default is to ignore binding\n"
"                       data in the old file during patch creation which will\n"
"                       cause the application of the patch to succeed whether\n"
"                       or not the old file on the target machine is bound, not\n"
"                       bound, or even bound to different import addresses.\n"
"                       If the files are not Win32 binaries, this option is\n"
"                       ignored and has no effect.\n"
"\n"
"          -NOLOCKFIX   Turn off automatic compensation for smashed lock prefix\n"
"                       instructions.  If the files are not Win32 binaries,\n"
"                       this option is ignored and has no effect.\n"
"\n"
"          -NOREBASE    Turn off automatic internal rebasing of old file to new\n"
"                       file's image base address.  If the files are not Win32\n"
"                       binaries, this option is ignored and has no effect.\n"
"\n"
"          -NORESTIME   Turn off automatic fixup of resource section timestamps\n"
"                       (ignored if not Win32 binaries).\n"
"\n"
"          -NOSTORETIME Don't store the timestamp of the new file in the patch\n"
"                       file.  Instead, set the timestamp of the patch file to\n"
"                       the timestamp of the new file.\n"
"\n"
"          -IGNORE:Offset,Length[,FileNumber]\n"
"\n"
"                       Ignore a range of bytes in the OldFile because those\n"
"                       bytes might be different in the old file being patched\n"
"                       on the target machine.\n"
"\n"
"          -RETAIN:Offset,Length[,OffsetInNewFile[,FileNumber]]\n"
"\n"
"                       When applying the patch, preserve the range of bytes in\n"
"                       the old file and copy them to the new file at the given\n"
"                       OffsetInNewFile.\n"
"\n"
#if 0
"          -RIFTINFO:FileName[,FileNumber]\n"
"\n"
"                       Use rift table information from FileName (produced from\n"
"                       riftinfo.exe).\n"
"\n"
#endif
"          -FAILBIGGER  If patch file is bigger than simple compressed file,\n"
"                       don't create the patch file (takes longer).\n"
"\n"
"          -FAILIFSAME  If old and new files are the same (ignoring binding\n"
"                       differences, etc), don't create the patch file.\n"
"\n"
"          -NOCOMPARE   Don't compare patch compression against ordinary non-\n"
"                       patch compression (saves time).\n"
"\n"
"          -NOPROGRESS  Don't display percent complete while building patch.\n"
"\n"
"          -NEWSYMPATH:PathName[;PathName]\n"
"\n"
"                       For NewFile, search for symbol file(s) in these path\n"
"                       locations (recursive search each path until found).\n"
"                       The default is to search for symbol files(s) starting\n"
"                       in the same directory as the NewFile.\n"
"\n"
"          -OLDSYMPATH:PathName[;PathName][,FileNumber]\n"
"\n"
"                       For OldFile, search for symbol file(s) in these path\n"
"                       locations (recursive search each path until found).\n"
"                       The default is to search for symbol files(s) starting\n"
"                       in the same directory as the OldFile.\n"
"\n"
"          -UNDECORATED After matching decorated symbol names, match remaining\n"
"                       symbols using undecorated names.\n"
"\n"
"          -NOSYMS      Don't use debug symbol files when creating the patch.\n"
"\n"
"          -NOSYMFAIL   Don't fail to create patch if symbols cannot be loaded.\n"
"\n"
"          -NOSYMWARN   Don't warn if symbols can't be found or don't match the\n"
"                       corresponding file (symbol checksum mismatch).\n"
"\n"
"          -USEBADSYMS  Rather than ignoring symbols if the checksums don't\n"
"                       match the corresponding files, use the bad symbols.\n"
"\n"
"          -E8          Force E8 call translation for x86 binaries.\n"
"\n"
"          -NOE8        Force no E8 call translation for x86 binaries.\n"
"\n"
"                       If neither -E8 or -NOE8 are specified, and the files\n"
"                       are x86 binaries, the patch will be built internally\n"
"                       twice and the smaller will be chosen for output.\n"
"\n"
"          -MSPATCH194COMPAT  Assure the patch file can be used with version\n"
"                       1.94 of MSPATCH*.DLL.  May increase size of patch\n"
"                       file if old or new file is larger than 4Mb.\n"
"\n"
"          MPATCH will also look for environment variables named \"MPATCH\"\n"
"          followed by an underscore and the name of the option.  Command line\n"
"          specified options override environment variable options.  Examples:\n"
"\n"
"              MPATCH_NOCOMPARE=1\n"
"              MPATCH_NEWSYMPATH=c:\\winnt\\symbols;\\\\server\\share\\symbols\n"
"\n"
        );
    exit( 1 );
    }


BOOL bNoProgress;
BOOL bNoSymWarn;
BOOL bUseBadSyms;


DWORDLONG
GetFileSizeByName(
    IN LPCSTR FileName
    )
    {
    DWORDLONG FileSizeReturn;
    ULONG     FileSizeHigh;
    ULONG     FileSizeLow;
    HANDLE    hFile;

    FileSizeReturn = 0xFFFFFFFFFFFFFFFF;

    hFile = CreateFile(
                FileName,
                GENERIC_READ,
                FILE_SHARE_READ | FILE_SHARE_WRITE,
                NULL,
                OPEN_EXISTING,
                0,
                NULL
                );

    if ( hFile != INVALID_HANDLE_VALUE ) {

        FileSizeLow = GetFileSize( hFile, &FileSizeHigh );

        if (( FileSizeLow != 0xFFFFFFFF ) || ( GetLastError() == NO_ERROR )) {

            FileSizeReturn = ((DWORDLONG)FileSizeHigh << 32 ) | FileSizeLow;
            }

        CloseHandle( hFile );
        }

    return FileSizeReturn;
    }


BOOL
GetMpatchEnvironString(
    IN  LPCSTR VarName,
    OUT LPSTR  Buffer,
    IN  DWORD  BufferSize
    )
    {
    CHAR EnvironName[ 256 ];

    sprintf( EnvironName, "mpatch_%s", VarName );

    if ( GetEnvironmentVariable( EnvironName, Buffer, BufferSize )) {

        return TRUE;
        }

    return FALSE;
    }


BOOL
GetMpatchEnvironValue(
    IN  LPCSTR VarName
    )
    {
    CHAR LocalBuffer[ 256 ];

    if ( GetMpatchEnvironString( VarName, LocalBuffer, sizeof( LocalBuffer ))) {

        if (( *LocalBuffer == '0' ) && ( strtoul( LocalBuffer, NULL, 0 ) == 0 )) {
            return FALSE;
            }

        return TRUE;
        }

    return FALSE;
    }


BOOL
CALLBACK
MyProgressCallback(
    PVOID CallbackContext,
    ULONG CurrentPosition,
    ULONG MaximumPosition
    )
    {
    UNREFERENCED_PARAMETER( CallbackContext );

    if ( MaximumPosition != 0 ) {
        fprintf( stderr, "\r%3.1f%% complete", ( CurrentPosition * 100.0 ) / MaximumPosition );
        }

    return TRUE;
    }


BOOL
CALLBACK
MySymLoadCallback(
    IN ULONG  WhichFile,
    IN LPCSTR SymbolFileName,
    IN ULONG  SymType,
    IN ULONG  SymbolFileCheckSum,
    IN ULONG  SymbolFileTimeDate,
    IN ULONG  ImageFileCheckSum,
    IN ULONG  ImageFileTimeDate,
    IN PVOID  CallbackContext
    )
    {
    LPCSTR *FileNameArray = CallbackContext;
    LPCSTR SymTypeText;

    if (( SymType == SymNone ) || ( SymType == SymExport )) {

        //
        //  Symbols could not be found.
        //

        if ( ! bNoSymWarn ) {

            printf(
                "\n"
                "WARNING: no debug symbols for %s\n\n",
                FileNameArray[ WhichFile ]
                );
            }

        return TRUE;
        }

    //
    //  Note that the Old file checksum is the checksum AFTER normalization,
    //  so if the original .dbg file was updated with bound checksum, the
    //  old file's checksum will not match the symbol file's checksum.  But,
    //  binding a file does not change its TimeDateStamp, so that should be
    //  a valid comparison.  But, .sym files don't have a TimeDateStamp, so
    //  the SymbolFileTimeDate may be zero.  If either the checksums match
    //  or the timedate stamps match, we'll say its valid.
    //

    if (( ImageFileCheckSum == SymbolFileCheckSum ) ||
        ( ImageFileTimeDate == SymbolFileTimeDate )) {

        return TRUE;
        }

    if ( ! bNoSymWarn ) {

        switch ( SymType ) {
            case SymNone:     SymTypeText = "No";       break;
            case SymCoff:     SymTypeText = "Coff";     break;
            case SymCv:       SymTypeText = "CodeView"; break;
            case SymPdb:      SymTypeText = "Pdb";      break;
            case SymExport:   SymTypeText = "Export";   break;
            case SymDeferred: SymTypeText = "Deferred"; break;
            case SymSym:      SymTypeText = "Sym";      break;
            default:          SymTypeText = "Unknown";  break;
            }

        printf(
            "\n"
            "WARNING: %s symbols %s don't match %s:\n"
            "    symbol file checksum (%08X) does not match image (%08X), and\n"
            "    symbol file timedate (%08X) does not match image (%08X).\n\n",
            SymTypeText,
            SymbolFileName,
            FileNameArray[ WhichFile ],
            SymbolFileCheckSum,
            ImageFileCheckSum,
            SymbolFileTimeDate,
            ImageFileTimeDate
            );
        }

    return bUseBadSyms;
    }


PRIFT_TABLE RiftTableArray[ 256 ];
PATCH_OLD_FILE_INFO_A OldFileInfo[ 256 ];
LPSTR OldFileSymPathArray[ 256 ];
LPSTR NewFileSymPath;
LPSTR FileNameArray[ 257 ];

PATCH_OPTION_DATA OptionData = { sizeof( PATCH_OPTION_DATA ) };

CHAR TextBuffer[ 65000 ];

void __cdecl main( int argc, char *argv[] ) {

    LPSTR OldFileName    = NULL;
    LPSTR NewFileName    = NULL;
    LPSTR PatchFileName  = NULL;
    LPSTR DllFileName    = NULL;
    ULONG OptionFlags    = PATCH_OPTION_USE_LZX_BEST | PATCH_OPTION_USE_LZX_LARGE;
    BOOL  Success;
    LPSTR arg;
    LPSTR p, q;
    LPSTR FileName;
    int   i, j, n;
    ULONG OldOffset;
    ULONG NewOffset;
    ULONG Length;
    ULONG FileNum;
    ULONG OldFileCount;
    ULONG ErrorCode;
    ULONG NewFileSize;
    ULONG PatchFileSize;
    ULONG OldFileRva;
    ULONG NewFileRva;
    BOOL  bNoCompare = FALSE;
    FILE  *RiftFile;
    LPSTR FileNamePart;
    CHAR  LoadedFileName[ MAX_PATH + 1 ];
    HMODULE hLib;
    PFN_CreatePatchFileA   pCreatePatchFileA   = CreatePatchFileA;
    PFN_CreatePatchFileExA pCreatePatchFileExA = CreatePatchFileExA;

    SetErrorMode( SEM_FAILCRITICALERRORS );

#ifndef DEBUG
    SetErrorMode( SEM_NOALIGNMENTFAULTEXCEPT | SEM_FAILCRITICALERRORS );
#endif

#ifdef TESTCODE
    bNoCompare = TRUE;
#endif

    CopyRight();

    for ( i = 1; i < argc; i++ ) {

        arg = argv[ i ];

        if ( strchr( arg, '?' )) {
            Usage();
            }
        }

    //
    //  First get environment arguments because command-line args will
    //  override them.
    //

    if ( GetMpatchEnvironValue( "e8" )) {
        OptionFlags &= ~PATCH_OPTION_USE_LZX_A;
        }

    if ( GetMpatchEnvironValue( "noe8" )) {
        OptionFlags &= ~PATCH_OPTION_USE_LZX_B;
        }

    if ( GetMpatchEnvironValue( "mspatch194compat" )) {
        OptionFlags &= ~PATCH_OPTION_USE_LZX_LARGE;
        }

    if ( GetMpatchEnvironValue( "nobindfix" )) {
        OptionFlags |= PATCH_OPTION_NO_BINDFIX;
        }

    if ( GetMpatchEnvironValue( "nolockfix" )) {
        OptionFlags |= PATCH_OPTION_NO_LOCKFIX;
        }

    if ( GetMpatchEnvironValue( "norebase" )) {
        OptionFlags |= PATCH_OPTION_NO_REBASE;
        }

    if ( GetMpatchEnvironValue( "norestime" )) {
        OptionFlags |= PATCH_OPTION_NO_RESTIMEFIX;
        }

    if ( GetMpatchEnvironValue( "nostoretime" )) {
        OptionFlags |= PATCH_OPTION_NO_TIMESTAMP;
        }

    if ( GetMpatchEnvironValue( "failbigger" )) {
        OptionFlags |= PATCH_OPTION_FAIL_IF_BIGGER;
        }

    if ( GetMpatchEnvironValue( "failifbigger" )) {
        OptionFlags |= PATCH_OPTION_FAIL_IF_BIGGER;
        }

    if ( GetMpatchEnvironValue( "failsame" )) {
        OptionFlags |= PATCH_OPTION_FAIL_IF_SAME_FILE;
        }

    if ( GetMpatchEnvironValue( "failifsame" )) {
        OptionFlags |= PATCH_OPTION_FAIL_IF_SAME_FILE;
        }

    if ( GetMpatchEnvironValue( "nocompare" )) {
        bNoCompare = TRUE;
        }

    if ( GetMpatchEnvironValue( "noprogress" )) {
        bNoProgress = TRUE;
        }

    if ( GetMpatchEnvironValue( "undecorated" )) {
        OptionData.SymbolOptionFlags |= PATCH_SYMBOL_UNDECORATED_TOO;
        }

    if ( GetMpatchEnvironValue( "nosyms" )) {
        OptionData.SymbolOptionFlags |= PATCH_SYMBOL_NO_IMAGEHLP;
        }

    if ( GetMpatchEnvironValue( "nosymfail" )) {
        OptionData.SymbolOptionFlags |= PATCH_SYMBOL_NO_FAILURES;
        }

    if ( GetMpatchEnvironValue( "nosymwarn" )) {
        bNoSymWarn = TRUE;
        }

    if ( GetMpatchEnvironValue( "usebadsyms" )) {
        bUseBadSyms = TRUE;
        }

    if ( GetMpatchEnvironString( "ignore", TextBuffer, sizeof( TextBuffer ))) {

        p = TextBuffer;
        q = strchr( p, ',' );

        if ( q != NULL ) {

            *q = 0;

            OldOffset = strtoul( p, NULL, 0 );

            p = q + 1;
            q = strchr( p, ',' );

            if ( q ) {
                *q = 0;
                }

            Length = strtoul( p, NULL, 0 );

            FileNum = 1;

            if ( q ) {

                p = q + 1;

                FileNum = strtoul( p, NULL, 0 );

                if ( FileNum == 0 ) {
                    FileNum = 1;
                    }
                }

            if ( FileNum <= 255 ) {
                void *pv = realloc(
                            OldFileInfo[ FileNum - 1 ].IgnoreRangeArray,
                            OldFileInfo[ FileNum - 1 ].IgnoreRangeCount * sizeof( PATCH_IGNORE_RANGE ) + sizeof( PATCH_IGNORE_RANGE )
                            );

                if (pv) {
                    OldFileInfo[ FileNum - 1 ].IgnoreRangeArray = pv;
                } else {
                    printf( "Out of memory\n" );
                    exit( 1 );
                }

                OldFileInfo[ FileNum - 1 ].IgnoreRangeArray[ OldFileInfo[ FileNum - 1 ].IgnoreRangeCount ].OffsetInOldFile = OldOffset;
                OldFileInfo[ FileNum - 1 ].IgnoreRangeArray[ OldFileInfo[ FileNum - 1 ].IgnoreRangeCount ].LengthInBytes   = Length;
                OldFileInfo[ FileNum - 1 ].IgnoreRangeCount++;

                }
            }
        }

    if ( GetMpatchEnvironString( "retain", TextBuffer, sizeof( TextBuffer ))) {

        p = TextBuffer;
        q = strchr( p, ',' );

        if ( q != NULL ) {

            *q = 0;

            OldOffset = strtoul( p, NULL, 0 );

            p = q + 1;
            q = strchr( p, ',' );

            if ( q ) {
                *q = 0;
                }

            Length = strtoul( p, NULL, 0 );

            NewOffset = OldOffset;

            FileNum = 1;

            if ( q ) {

                p = q + 1;

                q = strchr( p, ',' );

                if ( q ) {
                    *q = 0;
                    }

                NewOffset = strtoul( p, NULL, 0 );

                if ( q ) {

                    p = q + 1;

                    FileNum = strtoul( p, NULL, 0 );

                    if ( FileNum == 0 ) {
                        FileNum = 1;
                        }
                    }
                }

            if ( FileNum <= 255 ) {

                void *pv = realloc(
                                   OldFileInfo[ FileNum - 1 ].RetainRangeArray,
                                   OldFileInfo[ FileNum - 1 ].RetainRangeCount * sizeof( PATCH_RETAIN_RANGE ) + sizeof( PATCH_RETAIN_RANGE )
                                   );

                if (pv) {
                    OldFileInfo[ FileNum - 1 ].RetainRangeArray = pv;
                } else {
                    printf( "Out of memory\n" );
                    exit( 1 );
                }

                OldFileInfo[ FileNum - 1 ].RetainRangeArray[ OldFileInfo[ FileNum - 1 ].RetainRangeCount ].OffsetInOldFile = OldOffset;
                OldFileInfo[ FileNum - 1 ].RetainRangeArray[ OldFileInfo[ FileNum - 1 ].RetainRangeCount ].OffsetInNewFile = NewOffset;
                OldFileInfo[ FileNum - 1 ].RetainRangeArray[ OldFileInfo[ FileNum - 1 ].RetainRangeCount ].LengthInBytes   = Length;
                OldFileInfo[ FileNum - 1 ].RetainRangeCount++;
                }
            }
        }

    if ( GetMpatchEnvironString( "riftinfo", TextBuffer, sizeof( TextBuffer ))) {

        p = TextBuffer;
        q = strchr( p, ',' );

        if ( q ) {
            *q = 0;
            }

        FileName = p;

        FileNum = 1;

        if ( q ) {

            p = q + 1;

            FileNum = strtoul( p, NULL, 0 );

            if ( FileNum == 0 ) {
                FileNum = 1;
                }
            }

        if ( FileNum <= 255 ) {

            RiftTableArray[ FileNum - 1 ] = malloc( sizeof( RIFT_TABLE ));

            if ( RiftTableArray[ FileNum - 1 ] == NULL ) {
                printf( "Out of memory\n" );
                exit( 1 );
                }

            RiftTableArray[ FileNum - 1 ]->RiftEntryCount = 0;
            RiftTableArray[ FileNum - 1 ]->RiftEntryAlloc = 0;
            RiftTableArray[ FileNum - 1 ]->RiftEntryArray = NULL;
            RiftTableArray[ FileNum - 1 ]->RiftUsageArray = NULL;

            RiftFile = fopen( FileName, "rt" );

            if ( RiftFile == NULL ) {
                printf( "Could not open %s\n", FileName );
                exit( 1 );
                }

            while ( fgets( TextBuffer, sizeof( TextBuffer ), RiftFile )) {

                //
                //  Line looks like "00001456 00002345" where each number
                //  is an RVA in hexadecimal and the first column is the
                //  OldFileRva and the second column is the NewFileRva.
                //  Any text beyond column 17 is considered a comment, and
                //  any line that does not begin with a digit is ignored.
                //

                if (( isxdigit( *TextBuffer )) && ( strlen( TextBuffer ) >= 17 )) {

                    OldFileRva = strtoul( TextBuffer,     NULL, 16 );
                    NewFileRva = strtoul( TextBuffer + 9, NULL, 16 );

                    if (( OldFileRva + NewFileRva ) != 0 ) {
                        void *pv = realloc (
                            RiftTableArray[ FileNum - 1 ]->RiftEntryArray,
                            RiftTableArray[ FileNum - 1 ]->RiftEntryCount * sizeof( RIFT_ENTRY ) + sizeof( RIFT_ENTRY )
                            );

                        if (pv) {
                            RiftTableArray[ FileNum - 1 ]->RiftEntryArray = pv;
                        } else {
                            printf( "Out of memory\n" );
                            exit( 1 );
                        }

                        RiftTableArray[ FileNum - 1 ]->RiftEntryArray[ RiftTableArray[ FileNum - 1 ]->RiftEntryCount ].OldFileRva = OldFileRva;
                        RiftTableArray[ FileNum - 1 ]->RiftEntryArray[ RiftTableArray[ FileNum - 1 ]->RiftEntryCount ].NewFileRva = NewFileRva;
                        RiftTableArray[ FileNum - 1 ]->RiftEntryCount++;

                        }
                    }
                }

            fclose( RiftFile );

            if ( RiftTableArray[ FileNum - 1 ]->RiftEntryCount ) {

                RiftTableArray[ FileNum - 1 ]->RiftEntryAlloc = RiftTableArray[ FileNum - 1 ]->RiftEntryCount;

                RiftTableArray[ FileNum - 1 ]->RiftUsageArray = malloc( RiftTableArray[ FileNum - 1 ]->RiftEntryCount );

                if ( RiftTableArray[ FileNum - 1 ]->RiftUsageArray == NULL ) {
                    printf( "Out of memory\n" );
                    exit( 1 );
                    }

                ZeroMemory( RiftTableArray[ FileNum - 1 ]->RiftUsageArray, RiftTableArray[ FileNum - 1 ]->RiftEntryCount );
                }

            OptionData.SymbolOptionFlags |= PATCH_SYMBOL_EXTERNAL_RIFT;

            }
        }

    if ( GetMpatchEnvironString( "oldsympath", TextBuffer, sizeof( TextBuffer ))) {

        p = TextBuffer;
        q = strchr( p, ',' );

        if ( q ) {
            *q = 0;
            }

        FileName = p;

        FileNum = 1;

        if ( q ) {

            p = q + 1;

            FileNum = strtoul( p, NULL, 0 );

            if ( FileNum == 0 ) {
                FileNum = 1;
                }
            }

        if ( FileNum <= 255 ) {
            OldFileSymPathArray[ FileNum - 1 ] = _strdup( FileName );
            }
        }

    if ( GetMpatchEnvironString( "newsympath", TextBuffer, sizeof( TextBuffer ))) {

        p = TextBuffer;
        q = strchr( p, ',' );

        if ( q ) {
            *q = 0;
            }

        FileName = p;

        FileNum = 1;

        if ( q ) {

            p = q + 1;

            FileNum = strtoul( p, NULL, 0 );

            if ( FileNum == 0 ) {
                FileNum = 1;
                }
            }

        if ( FileNum == 1 ) {
            NewFileSymPath = _strdup( FileName );
            }
        }

    //
    //  Now process commandline args
    //

    for ( i = 1; i < argc; i++ ) {

        arg = argv[ i ];

        if ( strchr( arg, '?' )) {
            Usage();
            }

        if (( *arg == '-' ) || ( *arg == '/' )) {

            _strlwr( ++arg );

            if ( strcmp( arg, "e8" ) == 0 ) {
                OptionFlags &= ~PATCH_OPTION_USE_LZX_A;
                }
            else if ( strcmp( arg, "noe8" ) == 0 ) {
                OptionFlags &= ~PATCH_OPTION_USE_LZX_B;
                }
            else if ( strcmp( arg, "mspatch194compat" ) == 0 ) {
                OptionFlags &= ~PATCH_OPTION_USE_LZX_LARGE;
                }
            else if ( strcmp( arg, "nobindfix" ) == 0 ) {
                OptionFlags |= PATCH_OPTION_NO_BINDFIX;
                }
            else if ( strcmp( arg, "bindfix" ) == 0 ) {
                OptionFlags &= ~PATCH_OPTION_NO_BINDFIX;
                }
            else if ( strcmp( arg, "nolockfix" ) == 0 ) {
                OptionFlags |= PATCH_OPTION_NO_LOCKFIX;
                }
            else if ( strcmp( arg, "lockfix" ) == 0 ) {
                OptionFlags &= ~PATCH_OPTION_NO_LOCKFIX;
                }
            else if ( strcmp( arg, "norebase" ) == 0 ) {
                OptionFlags |= PATCH_OPTION_NO_REBASE;
                }
            else if ( strcmp( arg, "rebase" ) == 0 ) {
                OptionFlags &= ~PATCH_OPTION_NO_REBASE;
                }
            else if ( strcmp( arg, "norestime" ) == 0 ) {
                OptionFlags |= PATCH_OPTION_NO_RESTIMEFIX;
                }
            else if ( strcmp( arg, "norestimefix" ) == 0 ) {
                OptionFlags |= PATCH_OPTION_NO_RESTIMEFIX;
                }
            else if ( strcmp( arg, "restime" ) == 0 ) {
                OptionFlags &= ~PATCH_OPTION_NO_RESTIMEFIX;
                }
            else if ( strcmp( arg, "restimefix" ) == 0 ) {
                OptionFlags &= ~PATCH_OPTION_NO_RESTIMEFIX;
                }
            else if ( strcmp( arg, "nostoretime" ) == 0 ) {
                OptionFlags |= PATCH_OPTION_NO_TIMESTAMP;
                }
            else if ( strcmp( arg, "storetime" ) == 0 ) {
                OptionFlags &= ~PATCH_OPTION_NO_TIMESTAMP;
                }
            else if ( strcmp( arg, "failbigger" ) == 0 ) {
                OptionFlags |= PATCH_OPTION_FAIL_IF_BIGGER;
                }
            else if ( strcmp( arg, "nofailbigger" ) == 0 ) {
                OptionFlags &= ~PATCH_OPTION_FAIL_IF_BIGGER;
                }
            else if ( strcmp( arg, "failifbigger" ) == 0 ) {
                OptionFlags |= PATCH_OPTION_FAIL_IF_BIGGER;
                }
            else if ( strcmp( arg, "nofailifbigger" ) == 0 ) {
                OptionFlags &= ~PATCH_OPTION_FAIL_IF_BIGGER;
                }
            else if ( strcmp( arg, "failifsame" ) == 0 ) {
                OptionFlags |= PATCH_OPTION_FAIL_IF_SAME_FILE;
                }
            else if ( strcmp( arg, "failsame" ) == 0 ) {
                OptionFlags |= PATCH_OPTION_FAIL_IF_SAME_FILE;
                }
            else if ( strcmp( arg, "nofailifsame" ) == 0 ) {
                OptionFlags &= ~PATCH_OPTION_FAIL_IF_SAME_FILE;
                }
            else if ( strcmp( arg, "nofailsame" ) == 0 ) {
                OptionFlags &= ~PATCH_OPTION_FAIL_IF_SAME_FILE;
                }
            else if ( strcmp( arg, "nocompare" ) == 0 ) {
                bNoCompare = TRUE;
                }
            else if ( strcmp( arg, "compare" ) == 0 ) {
                bNoCompare = FALSE;
                }
            else if ( strcmp( arg, "noprogress" ) == 0 ) {
                bNoProgress = TRUE;
                }
            else if ( strcmp( arg, "progress" ) == 0 ) {
                bNoProgress = FALSE;
                }
            else if ( strcmp( arg, "decorated" ) == 0 ) {
                OptionData.SymbolOptionFlags &= ~PATCH_SYMBOL_UNDECORATED_TOO;
                }
            else if ( strcmp( arg, "undecorated" ) == 0 ) {
                OptionData.SymbolOptionFlags |= PATCH_SYMBOL_UNDECORATED_TOO;
                }
            else if ( strcmp( arg, "nosyms" ) == 0 ) {
                OptionData.SymbolOptionFlags |= PATCH_SYMBOL_NO_IMAGEHLP;
                }
            else if ( strcmp( arg, "syms" ) == 0 ) {
                OptionData.SymbolOptionFlags &= ~PATCH_SYMBOL_NO_IMAGEHLP;
                }
            else if ( strcmp( arg, "nosymfail" ) == 0 ) {
                OptionData.SymbolOptionFlags |= PATCH_SYMBOL_NO_FAILURES;
                }
            else if ( strcmp( arg, "symfail" ) == 0 ) {
                OptionData.SymbolOptionFlags &= ~PATCH_SYMBOL_NO_FAILURES;
                }
            else if ( strcmp( arg, "nosymwarn" ) == 0 ) {
                bNoSymWarn = TRUE;
                }
            else if ( strcmp( arg, "symwarn" ) == 0 ) {
                bNoSymWarn = FALSE;
                }
            else if ( strcmp( arg, "usebadsyms" ) == 0 ) {
                bUseBadSyms = TRUE;
                }
            else if ( strcmp( arg, "nousebadsyms" ) == 0 ) {
                bUseBadSyms = FALSE;
                }
            else if ( strcmp( arg, "nobadsyms" ) == 0 ) {
                bUseBadSyms = FALSE;
                }
            else if ( memcmp( arg, "ignore:", 7 ) == 0 ) {

                p = strchr( arg, ':' ) + 1;
                q = strchr( p,   ',' );

                if ( q == NULL ) {
                    Usage();
                    }

                *q = 0;

                OldOffset = strtoul( p, NULL, 0 );

                p = q + 1;
                q = strchr( p, ',' );

                if ( q ) {
                    *q = 0;
                    }

                Length = strtoul( p, NULL, 0 );

                FileNum = 1;

                if ( q ) {

                    p = q + 1;

                    FileNum = strtoul( p, NULL, 0 );

                    if ( FileNum == 0 ) {
                        FileNum = 1;
                        }
                    }

                if ( FileNum > 255 ) {
                    Usage();
                    }
                {
                    void *pv = realloc(
                                       OldFileInfo[ FileNum - 1 ].IgnoreRangeArray,
                                       OldFileInfo[ FileNum - 1 ].IgnoreRangeCount * sizeof( PATCH_IGNORE_RANGE ) + sizeof( PATCH_IGNORE_RANGE )
                                       );
                    if (pv) {
                        OldFileInfo[ FileNum - 1 ].IgnoreRangeArray = pv;
                    } else {
                        printf( "Out of memory\n" );
                        exit( 1 );
                    }
                }

                OldFileInfo[ FileNum - 1 ].IgnoreRangeArray[ OldFileInfo[ FileNum - 1 ].IgnoreRangeCount ].OffsetInOldFile = OldOffset;
                OldFileInfo[ FileNum - 1 ].IgnoreRangeArray[ OldFileInfo[ FileNum - 1 ].IgnoreRangeCount ].LengthInBytes   = Length;
                OldFileInfo[ FileNum - 1 ].IgnoreRangeCount++;

                }
            else if ( memcmp( arg, "retain:", 7 ) == 0 ) {

                p = strchr( arg, ':' ) + 1;
                q = strchr( p,   ',' );

                if ( q == NULL ) {
                    Usage();
                    }

                *q = 0;

                OldOffset = strtoul( p, NULL, 0 );

                p = q + 1;
                q = strchr( p, ',' );

                if ( q ) {
                    *q = 0;
                    }

                Length = strtoul( p, NULL, 0 );

                NewOffset = OldOffset;

                FileNum = 1;

                if ( q ) {

                    p = q + 1;

                    q = strchr( p, ',' );

                    if ( q ) {
                        *q = 0;
                        }

                    NewOffset = strtoul( p, NULL, 0 );

                    if ( q ) {

                        p = q + 1;

                        FileNum = strtoul( p, NULL, 0 );

                        if ( FileNum == 0 ) {
                            FileNum = 1;
                            }
                        }
                    }

                if ( FileNum > 255 ) {
                    Usage();
                    }

                {
                    void *pv = realloc(
                                       OldFileInfo[ FileNum - 1 ].RetainRangeArray,
                                       OldFileInfo[ FileNum - 1 ].RetainRangeCount * sizeof( PATCH_RETAIN_RANGE ) + sizeof( PATCH_RETAIN_RANGE )
                                       );
                    if (pv) {
                        OldFileInfo[ FileNum - 1 ].RetainRangeArray = pv;
                    } else {
                        printf( "Out of memory\n" );
                        exit( 1 );
                    }
                }

                OldFileInfo[ FileNum - 1 ].RetainRangeArray[ OldFileInfo[ FileNum - 1 ].RetainRangeCount ].OffsetInOldFile = OldOffset;
                OldFileInfo[ FileNum - 1 ].RetainRangeArray[ OldFileInfo[ FileNum - 1 ].RetainRangeCount ].OffsetInNewFile = NewOffset;
                OldFileInfo[ FileNum - 1 ].RetainRangeArray[ OldFileInfo[ FileNum - 1 ].RetainRangeCount ].LengthInBytes   = Length;
                OldFileInfo[ FileNum - 1 ].RetainRangeCount++;

                }

            else if ( memcmp( arg, "riftinfo:", 9 ) == 0 ) {

                OptionData.SymbolOptionFlags |= PATCH_SYMBOL_EXTERNAL_RIFT;

                p = strchr( arg, ':' ) + 1;
                q = strchr( p,   ',' );

                if ( q ) {
                    *q = 0;
                    }

                FileName = p;

                FileNum = 1;

                if ( q ) {

                    p = q + 1;

                    FileNum = strtoul( p, NULL, 0 );

                    if ( FileNum == 0 ) {
                        FileNum = 1;
                        }
                    }

                if ( FileNum > 255 ) {
                    Usage();
                    }

                RiftTableArray[ FileNum - 1 ] = malloc( sizeof( RIFT_TABLE ));

                if ( RiftTableArray[ FileNum - 1 ] == NULL ) {
                    printf( "Out of memory\n" );
                    exit( 1 );
                    }

                RiftTableArray[ FileNum - 1 ]->RiftEntryCount = 0;
                RiftTableArray[ FileNum - 1 ]->RiftEntryAlloc = 0;
                RiftTableArray[ FileNum - 1 ]->RiftEntryArray = NULL;
                RiftTableArray[ FileNum - 1 ]->RiftUsageArray = NULL;

                RiftFile = fopen( FileName, "rt" );

                if ( RiftFile == NULL ) {
                    printf( "Could not open %s\n", FileName );
                    exit( 1 );
                    }

                while ( fgets( TextBuffer, sizeof( TextBuffer ), RiftFile )) {

                    //
                    //  Line looks like "00001456 00002345" where each number
                    //  is an RVA in hexadecimal and the first column is the
                    //  OldFileRva and the second column is the NewFileRva.
                    //  Any text beyond column 17 is considered a comment, and
                    //  any line that does not begin with a digit is ignored.
                    //

                    if (( isxdigit( *TextBuffer )) && ( strlen( TextBuffer ) >= 17 )) {

                        OldFileRva = strtoul( TextBuffer,     NULL, 16 );
                        NewFileRva = strtoul( TextBuffer + 9, NULL, 16 );

                        if (( OldFileRva + NewFileRva ) != 0 ) {
                            void *pv = realloc(
                                               RiftTableArray[ FileNum - 1 ]->RiftEntryArray,
                                               RiftTableArray[ FileNum - 1 ]->RiftEntryCount * sizeof( RIFT_ENTRY ) + sizeof( RIFT_ENTRY )
                                               );
                            if (pv) {
                                RiftTableArray[ FileNum - 1 ]->RiftEntryArray = pv;
                            } else {
                                printf( "Out of memory\n" );
                                exit( 1 );
                            }

                            RiftTableArray[ FileNum - 1 ]->RiftEntryArray[ RiftTableArray[ FileNum - 1 ]->RiftEntryCount ].OldFileRva = OldFileRva;
                            RiftTableArray[ FileNum - 1 ]->RiftEntryArray[ RiftTableArray[ FileNum - 1 ]->RiftEntryCount ].NewFileRva = NewFileRva;
                            RiftTableArray[ FileNum - 1 ]->RiftEntryCount++;

                            }
                        }
                    }

                fclose( RiftFile );

                if ( RiftTableArray[ FileNum - 1 ]->RiftEntryCount ) {

                    RiftTableArray[ FileNum - 1 ]->RiftEntryAlloc = RiftTableArray[ FileNum - 1 ]->RiftEntryCount;

                    RiftTableArray[ FileNum - 1 ]->RiftUsageArray = malloc( RiftTableArray[ FileNum - 1 ]->RiftEntryCount );

                    if ( RiftTableArray[ FileNum - 1 ]->RiftUsageArray == NULL ) {
                        printf( "Out of memory\n" );
                        exit( 1 );
                        }

                    ZeroMemory( RiftTableArray[ FileNum - 1 ]->RiftUsageArray, RiftTableArray[ FileNum - 1 ]->RiftEntryCount );
                    }
                }
            else if ( memcmp( arg, "oldsympath:", 11 ) == 0 ) {

                p = strchr( arg, ':' ) + 1;
                q = strchr( p,   ',' );

                if ( q ) {
                    *q = 0;
                    }

                FileName = p;

                FileNum = 1;

                if ( q ) {

                    p = q + 1;

                    FileNum = strtoul( p, NULL, 0 );

                    if ( FileNum == 0 ) {
                        FileNum = 1;
                        }
                    }

                if ( FileNum > 255 ) {
                    Usage();
                    }

                OldFileSymPathArray[ FileNum - 1 ] = _strdup( FileName );
                }
            else if ( memcmp( arg, "newsympath:", 11 ) == 0 ) {

                p = strchr( arg, ':' ) + 1;
                q = strchr( p,   ',' );

                if ( q ) {
                    *q = 0;
                    }

                FileName = p;

                FileNum = 1;

                if ( q ) {

                    p = q + 1;

                    FileNum = strtoul( p, NULL, 0 );

                    if ( FileNum == 0 ) {
                        FileNum = 1;
                        }
                    }

                if ( FileNum != 1 ) {
                    Usage();
                    }

                NewFileSymPath = _strdup( FileName );
                }
            else if ( strncmp( arg, "dll:", 4 ) == 0 ) {
                DllFileName = arg + 4;
                }
            else {
                Usage();
                }
            }

        else if ( OldFileName == NULL ) {
            OldFileName = arg;
            }
        else if ( NewFileName == NULL ) {
            NewFileName = arg;
            }
        else if ( PatchFileName == NULL ) {
            PatchFileName = arg;
            }
        else {
            Usage();
            }
        }

    if (( OldFileName == NULL ) || ( NewFileName == NULL ) || ( PatchFileName == NULL )) {
        Usage();
        }

    if ( DllFileName != NULL ) {

        hLib = LoadLibrary( DllFileName );
        if ( hLib == NULL ) {
            printf( "Unable to load DLL '%s'\n", DllFileName );
            exit( 1 );
            }

        if ( GetModuleFileName( hLib, LoadedFileName, sizeof( LoadedFileName ))) {
            printf( "Loaded DLL '%s'\n", LoadedFileName );
            }

        pCreatePatchFileA   = (PFN_CreatePatchFileA)   GetProcAddress( hLib, "CreatePatchFileA" );
        pCreatePatchFileExA = (PFN_CreatePatchFileExA) GetProcAddress( hLib, "CreatePatchFileExA" );
        if (( pCreatePatchFileExA == NULL ) || ( pCreatePatchFileExA == NULL )) {
            printf( "Unable to import CreatePatchFileA and CreatePatchFileExA from DLL\n" );
            exit( 1 );
            }
        }

    OldFileCount = 0;

    p = OldFileName;

    q = strchr( OldFileName, ';' );

    while ( q ) {

        *q = 0;

        if ( *p ) {
            OldFileInfo[ OldFileCount ].SizeOfThisStruct = sizeof( PATCH_OLD_FILE_INFO_A );
            OldFileInfo[ OldFileCount ].OldFileName = p;
            OldFileCount++;
            }

        p = q + 1;
        q = strchr( p, ';' );

        }

    if ( *p ) {
        OldFileInfo[ OldFileCount ].SizeOfThisStruct = sizeof( PATCH_OLD_FILE_INFO_A );
        OldFileInfo[ OldFileCount ].OldFileName = p;
        OldFileCount++;
        }

    //
    //  Make sure rift tables are ascending and don't contain duplicate
    //  OldRva values (ambiguous).
    //

    for ( i = 0; i < (int)OldFileCount; i++ ) {

        if (( RiftTableArray[ i ] ) && ( RiftTableArray[ i ]->RiftEntryCount > 1 )) {

            n = RiftTableArray[ i ]->RiftEntryCount - 1;

            RiftQsort( &RiftTableArray[ i ]->RiftEntryArray[ 0 ], &RiftTableArray[ i ]->RiftEntryArray[ n ] );

#ifdef TESTCODE

            for ( j = 0; j < n; j++ ) {
                if ( RiftTableArray[ i ]->RiftEntryArray[ j     ].OldFileRva >
                     RiftTableArray[ i ]->RiftEntryArray[ j + 1 ].OldFileRva ) {

                    printf( "\nRift sort failed at index %d of %d\n", j, n + 1 );

                    for ( j = 0; j <= n; j++ ) {
                        printf( "%08X\n", RiftTableArray[ i ]->RiftEntryArray[ j ].OldFileRva );
                        }

                    exit( 1 );
                    break;
                    }
                }

#endif // TESTCODE

            for ( j = 0; j < n; j++ ) {

                while (( j < n ) &&
                       ( RiftTableArray[ i ]->RiftEntryArray[ j     ].OldFileRva ==
                         RiftTableArray[ i ]->RiftEntryArray[ j + 1 ].OldFileRva )) {

                    if ( RiftTableArray[ i ]->RiftEntryArray[ j     ].NewFileRva !=
                         RiftTableArray[ i ]->RiftEntryArray[ j + 1 ].NewFileRva ) {

                        //
                        //  This is an ambiguous entry since the OldRva values
                        //  match but the NewRva values do not.  Report and
                        //  discard the former.
                        //

                        printf(
                            "RiftInfo for %s contains ambiguous entries:\n"
                            "    OldRva:%08X NewRva:%08X (discarded)\n"
                            "    OldRva:%08X NewRva:%08X (kept)\n\n",
                            OldFileInfo[ i ].OldFileName,
                            RiftTableArray[ i ]->RiftEntryArray[ j ].OldFileRva,
                            RiftTableArray[ i ]->RiftEntryArray[ j ].NewFileRva,
                            RiftTableArray[ i ]->RiftEntryArray[ j + 1 ].OldFileRva,
                            RiftTableArray[ i ]->RiftEntryArray[ j + 1 ].NewFileRva
                            );
                        }

                    else {

                        //
                        //  This is a completely duplicate entry, so just
                        //  silently remove it.
                        //

                        }

                    MoveMemory(
                        &RiftTableArray[ i ]->RiftEntryArray[ j ],
                        &RiftTableArray[ i ]->RiftEntryArray[ j + 1 ],
                        ( n - j ) * sizeof( RIFT_ENTRY )
                        );

                    --n;

                    }
                }

            RiftTableArray[ i ]->RiftEntryCount = n + 1;

            }
        }

    for ( i = 0; i < (int)OldFileCount; i++ ) {

        if ( OldFileSymPathArray[ i ] == NULL ) {

            GetFullPathName( OldFileInfo[ i ].OldFileName, sizeof( TextBuffer ), TextBuffer, &FileNamePart );

            if (( FileNamePart > TextBuffer ) && ( *( FileNamePart - 1 ) == '\\' )) {
                *( FileNamePart - 1 ) = 0;
                }

            OldFileSymPathArray[ i ] = _strdup( TextBuffer );
            }
        }

    if ( NewFileSymPath == NULL ) {

        GetFullPathName( NewFileName, sizeof( TextBuffer ), TextBuffer, &FileNamePart );

        if (( FileNamePart > TextBuffer ) && ( *( FileNamePart - 1 ) == '\\' )) {
            *( FileNamePart - 1 ) = 0;
            }

        NewFileSymPath = _strdup( TextBuffer );
        }

    OptionData.NewFileSymbolPath      = NewFileSymPath;
    OptionData.OldFileSymbolPathArray = OldFileSymPathArray;

    if ( OptionData.SymbolOptionFlags & PATCH_SYMBOL_EXTERNAL_RIFT ) {
        OptionData.OldFileSymbolPathArray = (PVOID)RiftTableArray;
        }

    OptionData.SymLoadCallback = MySymLoadCallback;
    OptionData.SymLoadContext  = FileNameArray;

    FileNameArray[ 0 ] = (LPSTR)NewFileName;

    for ( i = 0; i < (int)OldFileCount; i++ ) {
        FileNameArray[ i + 1 ] = (LPSTR)OldFileInfo[ i ].OldFileName;
        }

    Success = pCreatePatchFileExA(
                  OldFileCount,
                  OldFileInfo,
                  NewFileName,
                  PatchFileName,
                  OptionFlags,
                  &OptionData,
                  bNoProgress ? NULL : MyProgressCallback,
                  NULL
                  );

    ErrorCode = GetLastError();

    printf( "\n\n" );

    if ( ! Success ) {

        CHAR ErrorText[ 16 ];

        sprintf( ErrorText, ( ErrorCode < 0x10000000 ) ? "%d" : "%X", ErrorCode );

        printf( "Failed to create patch (%s)\n", ErrorText );

        exit( 1 );
        }

    NewFileSize   = (ULONG) GetFileSizeByName( NewFileName );
    PatchFileSize = (ULONG) GetFileSizeByName( PatchFileName );

    if (( NewFileSize != 0xFFFFFFFF ) && ( NewFileSize != 0 ) && ( PatchFileSize != 0xFFFFFFFF )) {

        printf( "%d bytes (%3.1f%% compression, %.1f:1)\n",
                PatchFileSize,
                ((((LONG)NewFileSize - (LONG)PatchFileSize ) * 100.0 ) / NewFileSize ),
                ((double)NewFileSize / PatchFileSize )
              );

        if ( ! bNoCompare ) {

            CHAR TempFile1[ MAX_PATH ];
            CHAR TempFile2[ MAX_PATH ];
            HANDLE hFile;

            GetTempPath( MAX_PATH, TempFile1 );
            GetTempPath( MAX_PATH, TempFile2 );
            strcat( TempFile1, "\\tt$$src.$$$" );
            strcat( TempFile2, "\\tt$$pat.$$$" );

            hFile = CreateFile(
                        TempFile1,
                        GENERIC_READ | GENERIC_WRITE,
                        FILE_SHARE_READ,
                        NULL,
                        CREATE_ALWAYS,
                        FILE_ATTRIBUTE_TEMPORARY,
                        NULL
                        );

            if ( hFile != INVALID_HANDLE_VALUE ) {

                CloseHandle( hFile );

                Success = pCreatePatchFileA(
                              TempFile1,
                              NewFileName,
                              TempFile2,
                              OptionFlags & ~PATCH_OPTION_FAIL_IF_BIGGER,
                              NULL
                              );

                if ( Success ) {

                    ULONG CompFileSize = (ULONG) GetFileSizeByName( TempFile2 );

                    if (( CompFileSize != 0xFFFFFFFF ) && ( CompFileSize != 0 )) {

                        if ( CompFileSize <= PatchFileSize ) {

                            printf( "\nWARNING: Simply compressing %s would be %d bytes smaller (%3.1f%%)\n",
                                    NewFileName,
                                    PatchFileSize - CompFileSize,
                                    ((((LONG)PatchFileSize - (LONG)CompFileSize ) * 100.0 ) / CompFileSize )
                                  );
                            }

                        else if ( NewFileSize != 0 ) {

                            printf( "\n%d bytes saved (%3.1f%%) over non-patching compression\n",
                                    CompFileSize - PatchFileSize,
                                    ((((LONG)CompFileSize - (LONG)PatchFileSize ) * 100.0 ) / NewFileSize )
                                  );
                            }
                        }
                    }
                }

            DeleteFile( TempFile1 );
            DeleteFile( TempFile2 );
            }
        }

    else {
        printf( "OK\n" );
        }

    exit( 0 );
    }
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mspatch\lzx\common\compdefs.h ===
/*
 * common/compdefs.h
 *
 * Definitions for both encoder and decoder
 */

/*
 * Smallest allowable match length 
 */
#define MIN_MATCH 2

/* 
 * Maximum match length 
 */
#define MAX_MATCH (MIN_MATCH+255)

/*
 * Number of uncompressed symbols 
 */
#define NUM_CHARS 256

/*
 * Number of match lengths which are correlated with match positions 
 */
#define NUM_PRIMARY_LENGTHS     7

/*
 * Primary lengths plus the extension code
 */
#define NUM_LENGTHS             (NUM_PRIMARY_LENGTHS+1)

/*
 * Equals number of different possible match lengths minus primary lengths 
 */
#define NUM_SECONDARY_LENGTHS   ((MAX_MATCH-MIN_MATCH+1)-NUM_PRIMARY_LENGTHS)

/* NL_SHIFT = log2(NUM_LENGTHS) */
#define NL_SHIFT                3

/*
 * Number of repeated offsets 
 */
#define NUM_REPEATED_OFFSETS    3

/*
 * Number of elements in the aligned offset tree
 */
#define ALIGNED_NUM_ELEMENTS 8


/*
 * Repeat codes for outputting trees
 */

/* Minimum number of repetitions of anything we're interested in */
#define TREE_ENC_REP_MIN                4

/* Maximum repetitions for "type A" repetition of zeroes */
/* (min...min+REP_ZERO_FIRST) */
#define TREE_ENC_REP_ZERO_FIRST        16

/* Maximum repetitions for "type B" repetition of zeroes */
/* (min+REP_ZERO_FIRST...min+REP_ZERO_FIRST+REP_ZERO_SECOND) */
#define TREE_ENC_REP_ZERO_SECOND       32

/* Maximum repetitions for "type C" repetition of anything */
/* (min...min_REP_SAME_FIRST) */
#define TREE_ENC_REP_SAME_FIRST         2

/* Bits required to output the above numbers */
#define TREE_ENC_REPZ_FIRST_EXTRA_BITS  4
#define TREE_ENC_REPZ_SECOND_EXTRA_BITS 5
#define TREE_ENC_REP_SAME_EXTRA_BITS    1

/* Number of cfdata frames before E8's are turned off automatically */
#define E8_CFDATA_FRAME_THRESHOLD       32768


/*
 * Block types 
 */
typedef enum
{
		BLOCKTYPE_INVALID       = 0,
		BLOCKTYPE_VERBATIM      = 1, /* normal block */
		BLOCKTYPE_ALIGNED       = 2, /* aligned offset block */
		BLOCKTYPE_UNCOMPRESSED  = 3  /* uncompressed block */
} lzx_block_type;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mspatch\lzx\common\typedefs.h ===
/*
 * typedefs.h
 *
 * Type definitions for LZX
 */
#ifndef _TYPEDEFS_H

    #define _TYPEDEFS_H

/*
 * Definitions for LZX
 */
typedef unsigned char   byte;
typedef unsigned short  ushort;
typedef unsigned long   ulong;
typedef unsigned int    uint;

typedef enum
    {
    false = 0,
    true = 1
    } bool;


/*
 * Definitions for Diamond/CAB memory allocation
 */
typedef unsigned char   BYTE;
typedef unsigned short  USHORT;
typedef unsigned long   ULONG;
typedef unsigned int    UINT;


//** Define away for 32-bit (NT/Chicago) build
#ifndef HUGE
#define HUGE
#endif

#ifndef FAR
#define FAR
#endif

#ifndef NEAR
#define NEAR
#endif

#ifndef PVOID
typedef void * PVOID;
#endif

#ifndef HANDLE
typedef PVOID HANDLE;
#endif


typedef PVOID ( __fastcall * PFNALLOC )( HANDLE hAllocator, ULONG Size );


#endif /* _TYPEDEFS_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mspatch\api\samples\wpatch\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by wpatch.rc
//

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        101
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mspatch\api\samples\wpatch\wpatch.c ===
#ifndef _WIN32_WINNT
#define _WIN32_WINNT 0x0400
#endif

#ifndef WIN32
#define WIN32 0x0400
#endif

#pragma warning( disable: 4001 4035 4100 4115 4200 4201 4204 4209 4214 4514 4699 )

#include <windows.h>

#pragma warning( disable: 4001 4035 4100 4115 4200 4201 4204 4209 4214 4514 4699 )

#include <commctrl.h>
#include "wpatchid.h"

#include <stdlib.h>
#include <string.h>
#include <stdio.h>

#include "patchapi.h"
#include "patchprv.h"

#include <ntverp.h>
#include <common.ver>

typedef struct {
    HWND hwndProgress;
    int iPercentLast;
    } CALLBACK_CONTEXT;


void Usage( void ) {
    MessageBox( NULL,
        "WPATCH " VER_PRODUCTVERSION_STR " Patch Application Utility\n"
        VER_LEGALCOPYRIGHT_STR
        "\n\n"
        "Usage:  WPATCH PatchFile OldFile TargetNewFile",
        "Patch Application Utility",
        MB_OK
        );
    }


BOOL
CALLBACK
MyProgressCallback(
    PVOID CallbackContext,
    ULONG CurrentPosition,
    ULONG MaximumPosition
    )
    {
    int iPercent;
    MSG msg;
    CALLBACK_CONTEXT *pContext = CallbackContext;

    if (pContext->hwndProgress != NULL) {

        if ( CurrentPosition & 0xFF000000 ) {
            CurrentPosition >>= 8;
            MaximumPosition >>= 8;
            }

        if ( MaximumPosition != 0 ) {

            iPercent = ( CurrentPosition * 100 ) / MaximumPosition;

            if (pContext->iPercentLast != iPercent) {

                pContext->iPercentLast = iPercent;

                SendDlgItemMessage(pContext->hwndProgress, IDC_PROGRESS, PBM_SETPOS,
                    iPercent, 0);

                while (PeekMessage(&msg, NULL, 0, 0, PM_REMOVE)) {
                        DispatchMessage(&msg);
                    }
                }
            }
        }

    return TRUE;
    }


INT_PTR CALLBACK ProgressWndProc(HWND hdlg, UINT msg, WPARAM wparam, LPARAM lparam)
{
    switch (msg)
    {
        case WM_INITDIALOG:
            SendDlgItemMessage(hdlg, IDC_PROGRESS, PBM_SETRANGE, 0, MAKELPARAM(0, 99));
            EnableMenuItem(GetSystemMenu(hdlg, FALSE), SC_CLOSE, MF_BYCOMMAND|MF_DISABLED|MF_GRAYED);
            return TRUE;
    }

    return 0;
}


int WINAPI WinMain(
        HINSTANCE hInstance,
        HINSTANCE hPrevInstance,
        LPSTR lpCmdLine,
        int nShowCmd)
{
    char *pchCommand = NULL;
    char *argv[50];
    int argc;
    enum { WHITESPACE, UNQUOTED, QUOTED } eState = WHITESPACE;
    LPSTR OldFileName   = NULL;
    LPSTR PatchFileName = NULL;
    LPSTR NewFileName   = NULL;
    BOOL  Success;
    LPSTR arg;
    int   i;
    int   rc;
    CALLBACK_CONTEXT Context;
    int   fWaitOnError = TRUE;

    SetErrorMode( SEM_FAILCRITICALERRORS );

#ifndef DEBUG
    SetErrorMode( SEM_NOALIGNMENTFAULTEXCEPT | SEM_FAILCRITICALERRORS );
#endif

    Context.hwndProgress = NULL;
    Context.iPercentLast = -1;

    pchCommand = _strdup(lpCmdLine);    /* work on a copy */
    if (!pchCommand) {
        rc = 1;
        goto bail;
    }

    argv[0] = "";                       /* no EXE name supplied */
    argc = 1;                           /* that was one */

    while (*pchCommand)                 /* walk the string */
    {
        switch (eState)
        {

        case WHITESPACE:
            if (*pchCommand <= ' ')
            {
                /* ignore it */
            }
            else if (*pchCommand == '\"')
            {
                argv[argc++] = pchCommand + 1;  /* skip quote */

                eState = QUOTED;
            }
            else
            {
                argv[argc++] = pchCommand;

                eState = UNQUOTED;
            }
            break;

        case UNQUOTED:
            if (*pchCommand <= ' ')
            {
                *pchCommand = '\0';      /* nul-terminate */

                eState = WHITESPACE;
            }
            else
            {
                /* keep moving up */
            }
            break;

        case QUOTED:
            if (*pchCommand == '\"')
            {
                *pchCommand = '\0';      /* turn quote to a nul */

                eState = WHITESPACE;
            }
            else
            {
                /* keep moving up */
            }
            break;
        }

        pchCommand++;
    }

    argv[argc] = NULL;                  /* NULL-terminate the list */

    for ( i = 1; i < argc; i++ ) {

        arg = argv[ i ];

        if ( strchr( arg, '?' )) {
            Usage();
            rc = 1;
            goto bail;
            }

        if ( _stricmp( arg, "-QUIET" ) == 0) {
            nShowCmd = SW_HIDE;
            }
        else if ( _stricmp( arg, "-NOWAIT" ) == 0) {
            fWaitOnError = FALSE;
            }
        else if ( PatchFileName == NULL ) {
            PatchFileName = arg;
            }
        else if ( OldFileName == NULL ) {
            OldFileName = arg;
            }
        else if ( NewFileName == NULL ) {
            NewFileName = arg;
            }
        else {
            Usage();
            rc = 1;
            goto bail;
            }
        }

    if (( OldFileName == NULL ) || ( NewFileName == NULL ) || ( PatchFileName == NULL )) {
        Usage();
        rc = 1;
        goto bail;
        }

    if (nShowCmd != SW_HIDE) {
        InitCommonControls();

        Context.hwndProgress = CreateDialog(hInstance,
                MAKEINTRESOURCE(DLG_PROGRESS), NULL, ProgressWndProc);

        ShowWindow( Context.hwndProgress, nShowCmd );   // might be ignored per spec
        ShowWindow( Context.hwndProgress, nShowCmd );   // won't be ignored
        }

    DeleteFile( NewFileName );

    Success = ApplyPatchToFileEx(
                  PatchFileName,
                  OldFileName,
                  NewFileName,
                  0,
                  MyProgressCallback,
                  &Context
                  );

    if (Context.hwndProgress != NULL)
    {
        DestroyWindow(Context.hwndProgress);
    }

    if ( ! Success ) {

        if (fWaitOnError) {
            CHAR  ErrorText[ 100 ];
            ULONG ErrorCode = GetLastError();

            wsprintf( ErrorText, "Failed to create file from patch (%X)", ErrorCode );

            MessageBox(NULL,
                ErrorText,
                "WPATCH Failed",
                MB_ICONERROR | MB_SYSTEMMODAL);
            }

        rc = 2;
        goto bail;
        }

    rc = 0;

bail:

    if (pchCommand)
        free(pchCommand);
    return(rc);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mspatch\lzx\decoder\decalign.c ===
/*
 * decalign.c
 *
 * Decoding aligned offset block
 */
#include "decoder.h"


static long special_decode_aligned_block(t_decoder_context *context, long bufpos, int amount_to_decode)
{
    ulong   match_pos;
    ulong   temp_pos;
    long    bufpos_end;
    int             match_length;
    int             c;
    ulong   dec_bitbuf;
    char    dec_bitcount;
    byte   *dec_input_curpos;
    byte   *dec_end_input_pos;
    byte   *dec_mem_window;
    ulong   m;

    /*
     * Store commonly used variables locally
     */
    dec_bitcount      = context->dec_bitcount;
    dec_bitbuf                = context->dec_bitbuf;
    dec_input_curpos  = context->dec_input_curpos;
    dec_end_input_pos = context->dec_end_input_pos;
    dec_mem_window    = context->dec_mem_window;

    bufpos_end = bufpos + amount_to_decode;

    while (bufpos < bufpos_end)
        {
        /*
         * Decode an item
         */
        DECODE_MAIN_TREE(c);

        if ((c -= NUM_CHARS) < 0)
            {
#ifdef TRACING
            TracingLiteral(bufpos, (byte) c);
#endif
            dec_mem_window[bufpos] = (byte) c;
            dec_mem_window[context->dec_window_size + bufpos] = (byte) c;
            bufpos++;
            }
        else
            {
            /*
             * Get match length slot
             */
            if ((match_length = c & NUM_PRIMARY_LENGTHS) == NUM_PRIMARY_LENGTHS)
                {
                DECODE_LEN_TREE_NOEOFCHECK(match_length);
                }

            /*
             * Get match position slot
             */
            m = c >> NL_SHIFT;

            if (m > 2)
                {
                if (dec_extra_bits[ m ] >= 3)
                    {
                    if (dec_extra_bits[m]-3)
                        {
                        /* no need to getbits17 */
                        GET_BITS_NOEOFCHECK(dec_extra_bits[ m ] - 3, temp_pos);
                        }
                    else
                        {
                        temp_pos = 0;
                        }

                    match_pos = MP_POS_minus2[m] + (temp_pos << 3);

                    DECODE_ALIGNED_NOEOFCHECK(temp_pos);
                    match_pos += temp_pos;
                    }
                else
                    {
                    if (dec_extra_bits[m])
                        {
                        GET_BITS_NOEOFCHECK(dec_extra_bits[ m ], match_pos);

                        match_pos += MP_POS_minus2[m];
                        }
                    else
                        {
                        match_pos = 1; // MP_POS_minus2[m==3];
                        }
                    }

                context->dec_last_matchpos_offset[2] = context->dec_last_matchpos_offset[1];
                context->dec_last_matchpos_offset[1] = context->dec_last_matchpos_offset[0];
                context->dec_last_matchpos_offset[0] = match_pos;
                }
            else
                {
                match_pos = context->dec_last_matchpos_offset[m];

                if (m)
                    {
                    context->dec_last_matchpos_offset[m] = context->dec_last_matchpos_offset[0];
                    context->dec_last_matchpos_offset[0] = match_pos;
                    }
                }

            match_length += MIN_MATCH;

#ifdef EXTRALONGMATCHES

            if ( match_length == MAX_MATCH ) {

                //
                //  Fetch extra match length in addition to MAX_MATCH, which
                //  is encoded like this:
                //
                //      0xxxxxxxx          (8-bit value)
                //      10xxxxxxxxxx       (10-bit value plus 2^8)
                //      110xxxxxxxxxxxx    (12-bit value plus 2^8 plus 2^10)
                //      111xxxxxxxxxxxxxxx (15-bit value)
                //
                //  15 bits is the largest possible because a match cannot
                //  span a 32K boundary.
                //
                //  We know we'll read at least 9 bits, so read 9 bits first
                //  and then determine how many additional to read based on
                //  the first 3 bits of that.
                //

                ULONG ExtraMatchLength;
                ULONG ExtraMatchLengthResidue;

                GET_BITS_NOEOFCHECK( 9, ExtraMatchLength );

                if ( ExtraMatchLength & ( 1 << 8 )) {
                    if ( ExtraMatchLength & ( 1 << 7 )) {
                        if ( ExtraMatchLength & ( 1 << 6 )) {

                            //
                            //  First 3 bits are '111', so that means remaining
                            //  6 bits are the first 6 bits of the 15 bit value
                            //  meaning we must read 9 more bits.
                            //

                            ExtraMatchLength = ( ExtraMatchLength & (( 1 << 6 ) - 1 )) << 9;
                            GET_BITS_NOEOFCHECK( 9, ExtraMatchLengthResidue );
                            ExtraMatchLength |= ExtraMatchLengthResidue;
                            }

                        else {

                            //
                            //  First 3 bits are '110', so that means remaining
                            //  6 bits are the first 6 bits of the 12 bit value
                            //  meaning we must read 6 more bits.  Then we add
                            //  2^8 plus 2^10 to the value.
                            //

                            ExtraMatchLength = ( ExtraMatchLength & (( 1 << 6 ) - 1 )) << 6;
                            GET_BITS_NOEOFCHECK( 6, ExtraMatchLengthResidue );
                            ExtraMatchLength |= ExtraMatchLengthResidue;
                            ExtraMatchLength += ( 1 << 8 ) + ( 1 << 10 );
                            }
                        }

                    else {

                        //
                        //  First 2 bits are '10', so that means remaining
                        //  7 bits are the first 7 bits of the 10 bit value
                        //  meaning we must read 3 more bits.  Then we add
                        //  2^8 to the value.
                        //

                        ExtraMatchLength = ( ExtraMatchLength & (( 1 << 7 ) - 1 )) << 3;
                        GET_BITS_NOEOFCHECK( 3, ExtraMatchLengthResidue );
                        ExtraMatchLength |= ExtraMatchLengthResidue;
                        ExtraMatchLength += ( 1 << 8 );
                        }
                    }

                else {

                    //
                    //  First bit is a '0', so that means remaining 8 bits are
                    //  the 8 bit value to add to the match length.  No need to
                    //  mask off the leading '0'.
                    //

                    }

                match_length += ExtraMatchLength;

                }

#endif

#ifdef TRACING
            TracingMatch(bufpos,
                         bufpos-match_pos,
                         context->dec_window_size,
                         match_length,
                         m);
#endif

            do
                {
                dec_mem_window[bufpos] = dec_mem_window[(bufpos-match_pos) & context->dec_window_mask];

                if (bufpos < MAX_MATCH)
                    dec_mem_window[context->dec_window_size+bufpos] = dec_mem_window[bufpos];

                bufpos++;
                } while (--match_length > 0);
            }
        }

    context->dec_bitcount     = dec_bitcount;
    context->dec_bitbuf               = dec_bitbuf;
    context->dec_input_curpos = dec_input_curpos;

    return bufpos;
}


#ifndef ASM_DECODE_ALIGNED_OFFSET_BLOCK
long fast_decode_aligned_offset_block(t_decoder_context *context, long bufpos, int amount_to_decode)
{
    ulong   match_pos;
    ulong   temp_pos;
    long    bufpos_end;
    long    decode_residue;
    int             match_length;
    int             c;
    ulong   dec_bitbuf;
    char    dec_bitcount;
    byte   *dec_input_curpos;
    byte   *dec_end_input_pos;
    byte   *dec_mem_window;
    ulong   match_ptr;
    ulong   m;

    /*
     * Store commonly used variables locally
     */
    dec_bitcount      = context->dec_bitcount;
    dec_bitbuf        = context->dec_bitbuf;
    dec_input_curpos  = context->dec_input_curpos;
    dec_end_input_pos = context->dec_end_input_pos;
    dec_mem_window    = context->dec_mem_window;

    bufpos_end = bufpos + amount_to_decode;

    while (bufpos < bufpos_end)
        {
        /*
         * Decode an item
         */
        DECODE_MAIN_TREE(c);

        if ((c -= NUM_CHARS) < 0)
            {

#ifdef TRACING
            TracingLiteral(bufpos, (byte) c);
#endif

            dec_mem_window[bufpos++] = (byte) c;
            }
        else
            {
            /*
             * Get match length slot
             */
            if ((match_length = c & NUM_PRIMARY_LENGTHS) == NUM_PRIMARY_LENGTHS)
                {
                DECODE_LEN_TREE_NOEOFCHECK(match_length);
                }

            /*
             * Get match position slot
             */
            m = c >> NL_SHIFT;

            if (m > 2)
                {
                if (dec_extra_bits[ m ] >= 3)
                    {
                    if (dec_extra_bits[m]-3)
                        {
                        /* no need to getbits17 */
                        GET_BITS_NOEOFCHECK(dec_extra_bits[ m ] - 3, temp_pos);
                        }
                    else
                        {
                        temp_pos = 0;
                        }

                    match_pos = MP_POS_minus2[m] + (temp_pos << 3);

                    DECODE_ALIGNED_NOEOFCHECK(temp_pos);
                    match_pos += temp_pos;
                    }
                else
                    {
                    if (dec_extra_bits[m])
                        {
                        GET_BITS_NOEOFCHECK(dec_extra_bits[ m ], match_pos);

                        match_pos += MP_POS_minus2[m];
                        }
                    else
                        {
                        match_pos = MP_POS_minus2[m];
                        }
                    }

                context->dec_last_matchpos_offset[2] = context->dec_last_matchpos_offset[1];
                context->dec_last_matchpos_offset[1] = context->dec_last_matchpos_offset[0];
                context->dec_last_matchpos_offset[0] = match_pos;
                }
            else
                {
                match_pos = context->dec_last_matchpos_offset[m];

                if (m)
                    {
                    context->dec_last_matchpos_offset[m] = context->dec_last_matchpos_offset[0];
                    context->dec_last_matchpos_offset[0] = match_pos;
                    }
                }

            match_length += MIN_MATCH;
            match_ptr = (bufpos - match_pos) & context->dec_window_mask;

#ifdef EXTRALONGMATCHES

            if ( match_length == MAX_MATCH ) {

                //
                //  See detailed explanation above.
                //

                ULONG ExtraMatchLength, ExtraMatchLengthResidue;

                GET_BITS_NOEOFCHECK( 9, ExtraMatchLength );

                if ( ExtraMatchLength & ( 1 << 8 )) {
                    if ( ExtraMatchLength & ( 1 << 7 )) {
                        if ( ExtraMatchLength & ( 1 << 6 )) {
                            ExtraMatchLength = ( ExtraMatchLength & (( 1 << 6 ) - 1 )) << 9;
                            GET_BITS_NOEOFCHECK( 9, ExtraMatchLengthResidue );
                            ExtraMatchLength |= ExtraMatchLengthResidue;
                            }
                        else {
                            ExtraMatchLength = ( ExtraMatchLength & (( 1 << 6 ) - 1 )) << 6;
                            GET_BITS_NOEOFCHECK( 6, ExtraMatchLengthResidue );
                            ExtraMatchLength |= ExtraMatchLengthResidue;
                            ExtraMatchLength += ( 1 << 8 ) + ( 1 << 10 );
                            }
                        }
                    else {
                        ExtraMatchLength = ( ExtraMatchLength & (( 1 << 7 ) - 1 )) << 3;
                        GET_BITS_NOEOFCHECK( 3, ExtraMatchLengthResidue );
                        ExtraMatchLength |= ExtraMatchLengthResidue;
                        ExtraMatchLength += ( 1 << 8 );
                        }
                    }

                match_length += ExtraMatchLength;
                }

#endif

#ifdef TRACING
            TracingMatch(bufpos,
                         bufpos - match_pos,
                         context->dec_window_size,
                         match_length,
                         m);
#endif

            do
                {
                dec_mem_window[bufpos++] = dec_mem_window[match_ptr++];
                } while (--match_length > 0);
            }
        }

    context->dec_bitcount     = dec_bitcount;
    context->dec_bitbuf       = dec_bitbuf;
    context->dec_input_curpos = dec_input_curpos;

    /* should be zero */
    decode_residue = bufpos - bufpos_end;

    bufpos &= context->dec_window_mask;
    context->dec_bufpos = bufpos;

    return decode_residue;
}
#endif


int decode_aligned_offset_block(
                               t_decoder_context * context,
                               long                BufPos,
                               int                 amount_to_decode
                               )
{
    /*
     * Special case code when BufPos is near the beginning of the window;
     * we must properly update our MAX_MATCH wrapper bytes.
     */
    if (BufPos < MAX_MATCH)
        {
        long    new_bufpos;
        long    amount_to_slowly_decode;

        amount_to_slowly_decode = min(MAX_MATCH-BufPos, amount_to_decode);

        /*
         * It's ok to end up decoding more than we wanted if we
         * restricted it to decoding only MAX_MATCH; there's
         * no guarantee a match doesn't straddle MAX_MATCH
         */
        new_bufpos = special_decode_aligned_block(
                                                 context,
                                                 BufPos,
                                                 amount_to_slowly_decode
                                                 );

        amount_to_decode -= (new_bufpos-BufPos);

        context->dec_bufpos = BufPos = new_bufpos;

        /*
         * Note: if amount_to_decode < 0 then we're in trouble
         */
        if (amount_to_decode <= 0)
            return amount_to_decode;
        }

    return fast_decode_aligned_offset_block(context, BufPos, amount_to_decode);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mspatch\lzx\decoder\decapi.h ===
/*
 * decapi.h
 *
 * Decoder API definitions
 */

bool __stdcall LZX_DecodeInit(
                  t_decoder_context **dec_context,
                  long                compression_window_size,
                  PFNALLOC            pfnma,
                  HANDLE              hAllocator
                  );

void __fastcall LZX_DecodeNewGroup(t_decoder_context *context);

int __stdcall LZX_Decode(
        t_decoder_context *context,
        long    bytes_to_decode,
        byte *  compressed_input_buffer,
        long    compressed_input_size,
        byte *  uncompressed_output_buffer,
        long    uncompressed_output_size,
        long *  bytes_decoded
        );

bool __fastcall LZX_DecodeInsertDictionary(
    t_decoder_context *context,
    const byte *       data,
    unsigned long      data_size
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mspatch\lzx\decoder\decdefs.h ===
/*
 * decdefs.h
 *
 * Structures and definitions used by the decoder
 */


typedef enum
{
	DEC_STATE_UNKNOWN,
	DEC_STATE_START_NEW_BLOCK,
	DEC_STATE_DECODING_DATA
} decoder_state;


/*
 * Size of uncompressed data chunks
 */
#define CHUNK_SIZE  32768


/*
 * Main tree decoding table parameters 
 */

/* # elements in main tree */
#define MAIN_TREE_ELEMENTS			(NUM_CHARS+(context->dec_num_position_slots<<NL_SHIFT))

/*
 * Decoding table size allows a direct lookup on the first 
 * MAIN_TREE_TABLE_BITS bits of the code (max len 16).
 * Any potential remaining bits are decoded using left/right.
 */
#define MAIN_TREE_TABLE_BITS		10 

/*
 * Secondary length tree decoding table parameters
 * Decoding table size allows a direct lookup on the first
 * SECONDARY_LEN_TREE_TABLE_BITS of the code (max len 16).
 * Any potential remaining bits are decoded using left/right.
 */
#define SECONDARY_LEN_TREE_TABLE_BITS	8 

/* 
 * Aligned offset tree decoding table parameters 
 */
#define ALIGNED_NUM_ELEMENTS	8

/*
 * Must be 7, since we do not use left/right for this tree;
 * everything is decoded in one lookup.
 */
#define ALIGNED_TABLE_BITS		7
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mspatch\lzx\decoder\decapi.c ===
/*
 * decapi.c
 *
 * API entry points.
 */

#define ALLOC_VARS
#include "decoder.h"
#include <stdio.h>

#include <memory.h>
#pragma intrinsic(memcpy)

bool __stdcall LZX_DecodeInit(
                  t_decoder_context **dec_context,
                  long                compression_window_size,
                  PFNALLOC            pfnma,
                  HANDLE              hAllocator
                  )
{
    t_decoder_context *context= pfnma( hAllocator, sizeof( t_decoder_context ));

    if ( context == NULL ) {
        return false;
        }

    *dec_context = context;

    context->dec_malloc       = pfnma;
    context->dec_mallochandle = hAllocator;

    context->dec_window_size = compression_window_size;
    context->dec_window_mask = context->dec_window_size - 1;

    /*
     * Window size must be a power of 2
     */
    if (context->dec_window_size & context->dec_window_mask)
        return false;

    if (allocate_decompression_memory(context) == false)
        return false;

    LZX_DecodeNewGroup(context);

    return true;
}


void __fastcall LZX_DecodeNewGroup(t_decoder_context *context)
{
    reset_decoder_trees(context);
    decoder_misc_init(context);
    init_decoder_translation(context);
    context->dec_num_cfdata_frames = 0;

}


int __stdcall LZX_Decode(
              t_decoder_context *context,
              long    bytes_to_decode,
              byte *  compressed_input_buffer,
              long    compressed_input_size,
              byte *  uncompressed_output_buffer,
              long    uncompressed_output_size,
              long *  bytes_decoded
              )
{
    long    result;

    context->dec_input_curpos   = compressed_input_buffer;
    context->dec_end_input_pos  = (compressed_input_buffer + compressed_input_size + 4);

    context->dec_output_buffer  = uncompressed_output_buffer;

    init_decoder_input(context);

    result = decode_data(context, bytes_to_decode);

    context->dec_num_cfdata_frames++;

    if (result < 0)
        {
        *bytes_decoded = 0;
        return 1; /* failure */
        }
    else
        {
        *bytes_decoded = result;
        context->dec_position_at_start += result;
        return 0; /* success */
        }
}


//
// Warning, this dictionary is inserted verbatim, and is not E8
// translated.  If the encoder did E8 translation on its preloaded
// dictionary, this won't work.
//

#ifdef TRACING
ulong TracingOldDataSize;
#endif

#define ROUNDUP2( x, n ) ((((ULONG)(x)) + (((ULONG)(n)) - 1 )) & ~(((ULONG)(n)) - 1 ))

bool __fastcall LZX_DecodeInsertDictionary(
                               t_decoder_context * context,
                               const byte *        data,
                               unsigned long       data_size
                               )
{
    if (data_size > context->dec_window_size)
        return false;

#ifdef TRACING
    TracingOldDataSize = context->dec_window_size + ROUNDUP2( data_size, CHUNK_SIZE );
#endif

    memcpy(
          &context->dec_mem_window[context->dec_window_size - data_size],
          data,
          data_size
          );

    return true;
}


#ifdef TRACING


void
__stdcall
TracingMatch(
    ulong BufPos,
    ulong MatchPos,
    ulong WindowSize,
    ulong MatchLength,
    ulong MatchPosSlot
    )
    {
    printf( "MATCH: At %08X, From %08X, Length %5d\n", BufPos + TracingOldDataSize, MatchPos + TracingOldDataSize, MatchLength );
    }


void
__stdcall
TracingLiteral(
    ulong BufPos,
    ulong ch
    )
    {
    printf( "LITER: At %08X, 0x%02X\n", BufPos + TracingOldDataSize, ch );
    }


#endif /* TRACING */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mspatch\lzx\decoder\decmacro.h ===
/*
 * decmacro.h
 *
 * Macros used by the decoder
 */


/*
 * decode an element from the aligned offset tree, without checking 
 * for the end of the input data
 */
#define DECODE_ALIGNED_NOEOFCHECK(j) \
	(j) = context->dec_aligned_table[dec_bitbuf >> (32-ALIGNED_TABLE_BITS)]; \
	FILL_BUF_NOEOFCHECK(context->dec_aligned_len[(j)]);


/*
 * Decode an element from the main tree
 * Check for EOF
 */
#define DECODE_MAIN_TREE(j) \
	j = context->dec_main_tree_table[dec_bitbuf >> (32-MAIN_TREE_TABLE_BITS)];	\
	if (j < 0)															\
	{																	\
        ulong mask = (1L << (32-1-MAIN_TREE_TABLE_BITS));               \
		do																\
		{																\
	 		j = -j;														\
	 		if (dec_bitbuf & mask)										\
                j = context->dec_main_tree_left_right[j*2+1];                   \
			else														\
                j = context->dec_main_tree_left_right[j*2];                     \
			mask >>= 1;													\
		} while (j < 0);												\
	}																	\
	FILL_BUF_FULLCHECK(context->dec_main_tree_len[j]);


/*
 * Decode an element from the secondary length tree
 * No checking for EOF
 */
#define DECODE_LEN_TREE_NOEOFCHECK(matchlen) \
    matchlen = context->dec_secondary_length_tree_table[dec_bitbuf >> (32-SECONDARY_LEN_TREE_TABLE_BITS)]; \
	if (matchlen < 0)                                                	\
	{                                                                	\
        ulong mask = (1L << (32-1-SECONDARY_LEN_TREE_TABLE_BITS));      \
		do                                                          	\
		{																\
	 		matchlen = -matchlen;                                      	\
	 		if (dec_bitbuf & mask)                                  	\
                matchlen = context->dec_secondary_length_tree_left_right[matchlen*2+1];\
			else                                                        \
                matchlen = context->dec_secondary_length_tree_left_right[matchlen*2];  \
			mask >>= 1;                                                 \
		} while (matchlen < 0);											\
	}																	\
    FILL_BUF_NOEOFCHECK(context->dec_secondary_length_tree_len[matchlen]);      \
	matchlen += NUM_PRIMARY_LENGTHS;


/*
 * read n bits from input stream into dest_var, but don't
 * check for EOF
 */
#define GET_BITS_NOEOFCHECK(N,DEST_VAR) \
{                                               \
   DEST_VAR = dec_bitbuf >> (32-(N));			\
   FILL_BUF_NOEOFCHECK((N));					\
}


/* same as above, but don't check for EOF */
#define GET_BITS17_NOEOFCHECK(N,DEST_VAR) \
{                                               \
   DEST_VAR = dec_bitbuf >> (32-(N));			\
   FILL_BUF17_NOEOFCHECK((N));					\
}


/*
 * Remove n bits from the input stream
 * handles 1 <= n <= 17
 *
 * FORCE an EOF check ALWAYS, whether or not we read in more
 * bytes from memory.
 *
 * This is used to ensure that we always get an EOF check often enough
 * to not overrun the extra bytes in the buffer.
 *
 * This routine is used ONLY when decoding the main tree element,
 * where we know that the code we read in will be 16 bits or less
 * in length.  Therefore we don't have to check for bitcount going
 * less than zero, twice.
 */
#define FILL_BUF_FULLCHECK(N) \
{                                    		\
	if (dec_input_curpos >= dec_end_input_pos)	\
        return -1; \
	dec_bitbuf <<= (N);            			\
	dec_bitcount -= (N);                    \
	if (dec_bitcount <= 0)      			\
	{                                 		\
        dec_bitbuf |= ((((ulong) *dec_input_curpos | (((ulong) *(dec_input_curpos+1)) << 8))) << (-dec_bitcount)); \
        dec_input_curpos += 2;              \
		dec_bitcount += 16;               	\
    }                                       \
}

/*
 * Same as above, but no EOF check 
 *
 * This is used when we know we will not run out of input
 */
#define FILL_BUF_NOEOFCHECK(N) 			\
{                                    	\
	dec_bitbuf <<= (N);            		\
	dec_bitcount -= (N);                \
	if (dec_bitcount <= 0)      		\
	{                                 	\
        dec_bitbuf |= ((((ulong) *dec_input_curpos | (((ulong) *(dec_input_curpos+1)) << 8))) << (-dec_bitcount)); \
        dec_input_curpos += 2; \
		dec_bitcount += 16;				\
	}                                   \
}

/*
 * Same as above, but handles n=17 bits
 */
#define FILL_BUF17_NOEOFCHECK(N)        \
{                                    	\
	dec_bitbuf <<= (N);            		\
	dec_bitcount -= (N);                \
	if (dec_bitcount <= 0)      		\
	{                                 	\
        dec_bitbuf |= ((((ulong) *dec_input_curpos | (((ulong) *(dec_input_curpos+1)) << 8))) << (-dec_bitcount)); \
        dec_input_curpos += 2; \
		dec_bitcount += 16;				\
		if (dec_bitcount <= 0) \
		{ \
            dec_bitbuf |= ((((ulong) *dec_input_curpos | (((ulong) *(dec_input_curpos+1)) << 8))) << (-dec_bitcount)); \
            dec_input_curpos += 2; \
			dec_bitcount += 16;         \
		} \
	}                                   \
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mspatch\lzx\decoder\decin.c ===
/*
 * decin.c
 *
 * Decoder inputting of compressed data
 */
#include "decoder.h"


/*
 * Initialises the bit buffer state
 */
void NEAR initialise_decoder_bitbuf(t_decoder_context *context)
{
    byte *p;

    /*
     * If we're decoding an uncompressed block, don't use the
     * bit buffer; we're reading directly out of the input.
     */
    if (context->dec_block_type == BLOCKTYPE_UNCOMPRESSED)
        return;

    if ((context->dec_input_curpos + sizeof(ulong)) > context->dec_end_input_pos)
        return;

    p = context->dec_input_curpos;

    context->dec_bitbuf =
    ((ulong) p[2] | (((ulong) p[3]) << 8)) |
    ((((ulong) p[0] | (((ulong) p[1]) << 8))) << 16);

    context->dec_bitcount = 16;
    context->dec_input_curpos += 4;
}


/*
 * Initialise input buffer and bitwise i/o
 */
void NEAR init_decoder_input(t_decoder_context *context)
{
    initialise_decoder_bitbuf(context);
}


void NEAR fillbuf(t_decoder_context *context, int n)
{
    context->dec_bitbuf <<= n;
    context->dec_bitcount -= (char)n;

    if (context->dec_bitcount <= 0)
        {
        if (context->dec_input_curpos >= context->dec_end_input_pos)
            {
            context->dec_error_condition = true;
            return;
            }

        context->dec_bitbuf |= ((((ulong) *context->dec_input_curpos | (((ulong) *(context->dec_input_curpos+1)) << 8))) << (-context->dec_bitcount));
        context->dec_input_curpos += 2;
        context->dec_bitcount += 16;

        if (context->dec_bitcount <= 0)
            {
            if (context->dec_input_curpos >= context->dec_end_input_pos)
                {
                context->dec_error_condition = true;
                return;
                }

            context->dec_bitbuf |= ((((ulong) *context->dec_input_curpos | (((ulong) *(context->dec_input_curpos+1)) << 8))) << (-context->dec_bitcount));
            context->dec_input_curpos += 2;
            context->dec_bitcount += 16;
            }
        }
}


ulong NEAR getbits(t_decoder_context *context, int n)
{
    ulong value;

    value = context->dec_bitbuf >> (32-(n));
    fillbuf(context, n);

    return value;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mspatch\lzx\decoder\decblk.c ===
/*
 * decblk.c
 *
 * main decoder module
 */
#include "decoder.h"

#include <memory.h>
#pragma intrinsic(memcpy)

/*
 * Decode a block type
 */
static int decode_block(
                       t_decoder_context *context,
                       lzx_block_type     block_type,
                       long               bufpos,
                       long               amount_to_decode
                       )
{
    int result;

    if (block_type == BLOCKTYPE_ALIGNED)
        result = decode_aligned_offset_block(context, bufpos, (int) amount_to_decode);
    else if (block_type == BLOCKTYPE_VERBATIM)
        result = decode_verbatim_block(context, bufpos, (int) amount_to_decode);
    else if (block_type == BLOCKTYPE_UNCOMPRESSED)
        result = decode_uncompressed_block(context, bufpos, (int) amount_to_decode);
    else /* no other block types exist */
        result = -1;

    return result;
}



/*
 * Main decode entrypoint
 */
long NEAR decode_data(t_decoder_context *context, long bytes_to_decode)
{
    ulong                   amount_can_decode;
    long                    total_decoded;

    total_decoded = 0;

    while (bytes_to_decode > 0)
        {
        if (context->dec_decoder_state == DEC_STATE_START_NEW_BLOCK)
            {
            ulong   temp1;
            ulong   temp2;
            ulong   temp3;
            bool    do_translation;

            /*
             * If this is the first time this group, then get the
             * file size for translation.
             */
            if (context->dec_first_time_this_group)
                {
                context->dec_first_time_this_group = false;

                do_translation = (bool) getbits(context, 1);

                if (do_translation)
                    {
                    ulong high, low;

                    high = getbits(context, 16);
                    low  = getbits(context, 16);
                    context->dec_current_file_size = (high<<16)|low;
                    }
                else
                    {
                    context->dec_current_file_size = 0;
                    }
                }

            /*
             * If the last block we decoded was uncompressed, then
             * we need to skip the pad byte (if it exists), and
             * initialise the decoder's bit buffer
             */
            if (context->dec_block_type == BLOCKTYPE_UNCOMPRESSED)
                {
                /*
                 * If block size was odd, a pad byte is required
                 */
                if (context->dec_original_block_size & 1)
                    {
                    if (context->dec_input_curpos < context->dec_end_input_pos)
                        context->dec_input_curpos++;
                    }

                /* so that initialise_decoder_bitbuf() will succeed */
                context->dec_block_type = BLOCKTYPE_INVALID;

                initialise_decoder_bitbuf(context);
                }

            /* get the block type */
            context->dec_block_type = (lzx_block_type) getbits(context, 3);

            /* get size of block (in uncompressed bytes) to decode */
            temp1 = getbits(context, 8);
            temp2 = getbits(context, 8);
            temp3 = getbits(context, 8);

            /*
             * How large is the block we're going to decode?
             * It can be from 0...16777215 bytes (16MB)
             */
            context->dec_block_size =
            context->dec_original_block_size = (temp1<<16) + (temp2<<8) + (temp3);

            /* if block is an aligned type, read the aligned offset tree */
            if (context->dec_block_type == BLOCKTYPE_ALIGNED)
                read_aligned_offset_tree(context);

            /* read trees */
            if (context->dec_block_type == BLOCKTYPE_VERBATIM ||
                context->dec_block_type == BLOCKTYPE_ALIGNED)
                {
                /*      backup old trees */
                memcpy(
                      context->dec_main_tree_prev_len,
                      context->dec_main_tree_len,
                      MAIN_TREE_ELEMENTS
                      );

                memcpy(
                      context->dec_secondary_length_tree_prev_len,
                      context->dec_secondary_length_tree_len,
                      NUM_SECONDARY_LENGTHS
                      );

                read_main_and_secondary_trees(context);
                }
            else if (context->dec_block_type == BLOCKTYPE_UNCOMPRESSED)
                {
                if (handle_beginning_of_uncompressed_block(context) == false)
                    return -1;
                }
            else
                {
                /* no other block types are supported at this time */
                return -1;
                }

            context->dec_decoder_state = DEC_STATE_DECODING_DATA;
            }

        /*
         * Keep decoding until the whole block has been decoded
         */
        while ((context->dec_block_size > 0) && (bytes_to_decode > 0))
            {
            int decode_residue;

            amount_can_decode = min(context->dec_block_size, bytes_to_decode);

            /* shouldn't happen */
            if (amount_can_decode == 0)
                return -1;

            decode_residue = decode_block(
                                         context,
                                         context->dec_block_type,
                                         context->dec_bufpos,
                                         amount_can_decode
                                         );

            /*
             * We should have decoded exactly the amount we wanted,
             * since the encoder makes sure that no matches span 32K
             * boundaries.
             *
             * If the data was corrupted, it's possible that we decoded
             * up to MAX_MATCH bytes more than we wanted to.
             */
            if (decode_residue != 0)
                {
                /* error, we didn't decode what we wanted! */
                return -1;
                }

            context->dec_block_size -= amount_can_decode;
            bytes_to_decode -= amount_can_decode;
            total_decoded += amount_can_decode;
            }

        if (context->dec_block_size == 0)
            {
            context->dec_decoder_state = DEC_STATE_START_NEW_BLOCK;
            }

        if (bytes_to_decode == 0)
            {
            initialise_decoder_bitbuf(context);
            }
        }

#ifdef BIT16
    copy_data_to_output(
                       context,
                       total_decoded,
                       context->dec_output_buffer
                       );
#else
    copy_data_to_output(
                       context,
                       total_decoded,
                       context->dec_bufpos ?
                       &context->dec_mem_window[context->dec_bufpos - total_decoded] :
                       &context->dec_mem_window[context->dec_window_size - total_decoded]
                       );
#endif

    return total_decoded;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mspatch\lzx\decoder\decinit.c ===
/*
 * decinit.c
 *
 * Initialisation routines for LZX decoder
 */

#include "decoder.h"

#include <memory.h>
#pragma intrinsic(memset)

/*
 * Allocate memory for decompression
 */
bool NEAR allocate_decompression_memory(t_decoder_context *context)
{
    ulong   pos_start;

    context->dec_num_position_slots = 4;
    pos_start                                               = 4;

    while (1)
        {
        pos_start += 1L << dec_extra_bits[context->dec_num_position_slots];

        context->dec_num_position_slots++;

        if (pos_start >= context->dec_window_size)
            break;
        }

    if (!(context->dec_mem_window = (byte *) context->dec_malloc( context->dec_mallochandle, context->dec_window_size+(MAX_MATCH+4))))
        return false;

    return true;
}



/*
 * Set/reset decoder trees to initial state
 */
void NEAR reset_decoder_trees(t_decoder_context *context)
{
    memset(context->dec_main_tree_len, 0, MAIN_TREE_ELEMENTS);
    memset(context->dec_main_tree_prev_len, 0, MAIN_TREE_ELEMENTS);

    memset(context->dec_secondary_length_tree_len, 0, NUM_SECONDARY_LENGTHS);
    memset(context->dec_secondary_length_tree_prev_len, 0, NUM_SECONDARY_LENGTHS);
}


/*
 * Miscellaneous state initialisations
 */
void NEAR decoder_misc_init(t_decoder_context *context)
{
    context->dec_last_matchpos_offset[0]             = 1;
    context->dec_last_matchpos_offset[1]             = 1;
    context->dec_last_matchpos_offset[2]             = 1;

    context->dec_bufpos = 0;
    context->dec_position_at_start = 0;

    context->dec_decoder_state      = DEC_STATE_START_NEW_BLOCK;
    context->dec_block_size         = 0;

    /* so that initialise_decoder_bitbuf() will succeed */
    context->dec_block_type     = BLOCKTYPE_INVALID;

    context->dec_first_time_this_group      = true;
    context->dec_current_file_size          = 0;

    context->dec_error_condition = false;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mspatch\lzx\decoder\decoder.h ===
/*
 * decoder.h
 *
 * Main decoder header file
 */

#ifndef DECODER_H
#define DECODER_H

#ifdef EXT
#       undef EXT
#endif

#ifdef ALLOC_VARS
#       define EXT
#else
#       define EXT extern
#endif

#ifdef USE_ASSEMBLY
#   define ASM_DECODE_VERBATIM_BLOCK
#   define ASM_TRANSLATE_E8
#   define ASM_MAKE_TABLE
#endif

#ifndef UNALIGNED
#ifndef NEEDS_ALIGNMENT
#define UNALIGNED
#else
#define UNALIGNED __unaligned
#endif
#endif

#include <stdlib.h>
#include <string.h>
#include "../common/typedefs.h"
#include "../common/compdefs.h"
#include "decmacro.h"
#include "decdefs.h"

#include "decvars.h"
#include "decapi.h"
#include "decproto.h"

#ifdef TRACING

#include <stdio.h>

void
__stdcall
TracingMatch(
    ulong BufPos,
    ulong MatchPos,
    ulong WindowSize,
    ulong MatchLength,
    ulong MatchPosSlot
    );

void
__stdcall
TracingLiteral(
    ulong BufPos,
    ulong ch
    );

#endif // TRACING

#endif /* DECODER_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mspatch\lzx\decoder\decout.c ===
/*
 * decout.c
 *
 * Decoder outputting
 */

#include "decoder.h"

#include <memory.h>
#pragma intrinsic(memcpy)

void copy_data_to_output(t_decoder_context *context, long amount, const byte *data)
{
    memcpy(
        context->dec_output_buffer,
        data,
        amount
    );

    /* perform jump translation */
    if ((context->dec_current_file_size != 0) && (context->dec_num_cfdata_frames < E8_CFDATA_FRAME_THRESHOLD))
    {
        decoder_translate_e8(
            context,
            context->dec_output_buffer,
            amount
        );
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mspatch\lzx\decoder\decuncmp.c ===
/*
 * decuncmp.c
 *
 * Decoding uncompressed blocks
 */
#include "decoder.h"


int decode_uncompressed_block(t_decoder_context *context, long bufpos, int amount_to_decode)
{
    long    bytes_decoded = 0;
    long    bufpos_end;
    long    decode_residue;
    ulong   bufpos_start;
    ulong   end_copy_pos;
    byte *  p;

    bufpos_start = bufpos;
    bufpos_end = bufpos + amount_to_decode;

    p = context->dec_input_curpos;

    while (bufpos < bufpos_end)
        {
        if (p >= context->dec_end_input_pos)
            return -1; // input overflow

#ifdef TRACING
        TracingLiteral(bufpos, *p);
#endif
        context->dec_mem_window[bufpos++] = *p++;
        }

    context->dec_input_curpos = p;

    /*
     * Make sure the MAX_MATCH bytes starting at window[window_size]
     * are always the same as the first MAX_MATCH bytes starting at
     * window[0].  This is for our optimisation in decverb.c and
     * decalign.c which allows us to not have to & window_mask all the
     * time.
     */
    end_copy_pos = min(MAX_MATCH, bufpos_end);

    /*
     * Keep copying until we hit MAX_MATCH or the number of bytes
     * we decoded
     */
    while (bufpos_start < end_copy_pos)
        {
        context->dec_mem_window[bufpos_start + context->dec_window_size] =
        context->dec_mem_window[bufpos_start];
        bufpos_start++;
        }

    decode_residue = bufpos - bufpos_end;

    bufpos &= context->dec_window_mask;
    context->dec_bufpos = bufpos;

    return (int) decode_residue;
}


bool handle_beginning_of_uncompressed_block(t_decoder_context *context)
{
    int     i;

    /*
     * we want to read the 16 bits already in bitbuf, so backtrack
     * the input pointer by 2 bytes.
     */
    context->dec_input_curpos -= 2;

    if (context->dec_input_curpos+4 >= context->dec_end_input_pos)
        return false;

    /*
     * update LRU repeated offset list
     */
    for (i = 0; i < NUM_REPEATED_OFFSETS; i++)
        {
        context->dec_last_matchpos_offset[i] =
        ((ulong) *(  (byte *) context->dec_input_curpos)    )        |
        ((ulong) *( ((byte *) context->dec_input_curpos) + 1) << 8)  |
        ((ulong) *( ((byte *) context->dec_input_curpos) + 2) << 16) |
        ((ulong) *( ((byte *) context->dec_input_curpos) + 3) << 24);

        context->dec_input_curpos += 4; /* increment by 4 bytes */
        }

    return true;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mspatch\lzx\decoder\decvars.h ===
/*
 * decvars.h
 *
 * Variables for the decoder
 */

/*
 * MAX_MAIN_TREE_ELEMENTS should be >= 256 + 8*num_position_slots
 * (that comes out to 256 + 8*51 right now, for a 2 MB window).
 *
 * Make divisible by 4 so things are longword aligned.
 */
#define MAX_MAIN_TREE_ELEMENTS (256 + (8 * 291))   // 32MB

typedef struct
    {
    /* 16-bit version does not have one big window pointer */
#ifndef BIT16
    /* pointer to beginning of window buffer */
    byte                    *dec_mem_window;
#endif

    /* window/decoding buffer parameters */
    ulong               dec_window_size;
    ulong                           dec_window_mask;

    /* previous match offsets */
    ulong               dec_last_matchpos_offset[NUM_REPEATED_OFFSETS];

    /* main tree table */
    short                           dec_main_tree_table[1 << MAIN_TREE_TABLE_BITS];

    /* secondary length tree table */
    short               dec_secondary_length_tree_table[1 << SECONDARY_LEN_TREE_TABLE_BITS];

    /* main tree bit lengths */
    byte                            dec_main_tree_len[MAX_MAIN_TREE_ELEMENTS];

    /* secondary tree bit lengths */
    byte                dec_secondary_length_tree_len[NUM_SECONDARY_LENGTHS];
    byte                            pad1[3]; /* NUM_SECONDARY_LENGTHS == 249 */

    /* aligned offset table */
    char                            dec_aligned_table[1 << ALIGNED_TABLE_BITS];
    byte                            dec_aligned_len[ALIGNED_NUM_ELEMENTS];

    /* left/right pointers for main tree (2*n shorts left, 2*n shorts for right) */
    short               dec_main_tree_left_right[MAX_MAIN_TREE_ELEMENTS*4];

    /* left/right pointers for secondary length tree */
    short               dec_secondary_length_tree_left_right[NUM_SECONDARY_LENGTHS*4];

    /* input (compressed) data pointers */
    byte *              dec_input_curpos;
    byte *              dec_end_input_pos;

    /* output (uncompressed) data pointer */
    byte *              dec_output_buffer;

    /* position in data stream at start of this decode call */
    long                dec_position_at_start;

    /* previous lengths */
    byte                            dec_main_tree_prev_len[MAX_MAIN_TREE_ELEMENTS];
    byte                            dec_secondary_length_tree_prev_len[NUM_SECONDARY_LENGTHS];

    /* bitwise i/o */
    ulong               dec_bitbuf;
    signed char             dec_bitcount;

    /* number of distinct position (displacement) slots */
    ulong               dec_num_position_slots;

    bool                            dec_first_time_this_group;
    bool                dec_error_condition;

    /* misc */
    long                    dec_bufpos;
    ulong                           dec_current_file_size;
    ulong                           dec_instr_pos;
    ulong               dec_num_cfdata_frames;

    /* original size of current block being decoded (in uncompressed bytes) */
    long                dec_original_block_size;

    /* remaining size of current block being decoded (in uncompressed bytes) */
    long                            dec_block_size;

    /* type of current block being decoded */
    lzx_block_type          dec_block_type;

    /* current state of decoder */
    decoder_state           dec_decoder_state;

    /* memory allocation functions */
    PFNALLOC                        dec_malloc;
    HANDLE                          dec_mallochandle;

    } t_decoder_context;


/* declare arrays? */
#ifndef ALLOC_VARS

EXT const byte NEAR     dec_extra_bits[];
EXT const long NEAR     MP_POS_minus2[];

#else

const byte NEAR dec_extra_bits[] =
{
0,0,0,0,1,1,2,2,
3,3,4,4,5,5,6,6,
7,7,8,8,9,9,10,10,
11,11,12,12,13,13,14,14,
15,15,16,16,17,17,17,17,
17,17,17,17,17,17,17,17,
17,17,17,17,17,17,17,17,
17,17,17,17,17,17,17,17,
17,17,17,17,17,17,17,17,
17,17,17,17,17,17,17,17,
17,17,17,17,17,17,17,17,
17,17,17,17,17,17,17,17,
17,17,17,17,17,17,17,17,
17,17,17,17,17,17,17,17,
17,17,17,17,17,17,17,17,
17,17,17,17,17,17,17,17,
17,17,17,17,17,17,17,17,
17,17,17,17,17,17,17,17,
17,17,17,17,17,17,17,17,
17,17,17,17,17,17,17,17,
17,17,17,17,17,17,17,17,
17,17,17,17,17,17,17,17,
17,17,17,17,17,17,17,17,
17,17,17,17,17,17,17,17,
17,17,17,17,17,17,17,17,
17,17,17,17,17,17,17,17,
17,17,17,17,17,17,17,17,
17,17,17,17,17,17,17,17,
17,17,17,17,17,17,17,17,
17,17,17,17,17,17,17,17,
17,17,17,17,17,17,17,17,
17,17,17,17,17,17,17,17,
17,17,17,17,17,17,17,17,
17,17,17,17,17,17,17,17,
17,17,17,17,17,17,17,17,
17,17,17,17,17,17,17,17,
17,17,17
};

/*
 * first (base) position covered by each slot
 * 2 subtracted for optimisation purposes (see decverb.c/decalign.c comments)
 */
const long NEAR MP_POS_minus2[sizeof(dec_extra_bits)] =
{
0-2,        1-2,        2-2,        3-2,        4-2,        6-2,        8-2,        12-2,
16-2,       24-2,       32-2,       48-2,       64-2,       96-2,       128-2,      192-2,
256-2,      384-2,      512-2,      768-2,      1024-2,     1536-2,     2048-2,     3072-2,
4096-2,     6144-2,     8192-2,     12288-2,    16384-2,    24576-2,    32768-2,    49152-2,
65536-2,    98304-2,    131072-2,   196608-2,   262144-2,   393216-2,   524288-2,   655360-2,
786432-2,   917504-2,   1048576-2,  1179648-2,  1310720-2,  1441792-2,  1572864-2,  1703936-2,
1835008-2,  1966080-2,  2097152-2,  2228224-2,  2359296-2,  2490368-2,  2621440-2,  2752512-2,
2883584-2,  3014656-2,  3145728-2,  3276800-2,  3407872-2,  3538944-2,  3670016-2,  3801088-2,
3932160-2,  4063232-2,  4194304-2,  4325376-2,  4456448-2,  4587520-2,  4718592-2,  4849664-2,
4980736-2,  5111808-2,  5242880-2,  5373952-2,  5505024-2,  5636096-2,  5767168-2,  5898240-2,
6029312-2,  6160384-2,  6291456-2,  6422528-2,  6553600-2,  6684672-2,  6815744-2,  6946816-2,
7077888-2,  7208960-2,  7340032-2,  7471104-2,  7602176-2,  7733248-2,  7864320-2,  7995392-2,
8126464-2,  8257536-2,  8388608-2,  8519680-2,  8650752-2,  8781824-2,  8912896-2,  9043968-2,
9175040-2,  9306112-2,  9437184-2,  9568256-2,  9699328-2,  9830400-2,  9961472-2,  10092544-2,
10223616-2, 10354688-2, 10485760-2, 10616832-2, 10747904-2, 10878976-2, 11010048-2, 11141120-2,
11272192-2, 11403264-2, 11534336-2, 11665408-2, 11796480-2, 11927552-2, 12058624-2, 12189696-2,
12320768-2, 12451840-2, 12582912-2, 12713984-2, 12845056-2, 12976128-2, 13107200-2, 13238272-2,
13369344-2, 13500416-2, 13631488-2, 13762560-2, 13893632-2, 14024704-2, 14155776-2, 14286848-2,
14417920-2, 14548992-2, 14680064-2, 14811136-2, 14942208-2, 15073280-2, 15204352-2, 15335424-2,
15466496-2, 15597568-2, 15728640-2, 15859712-2, 15990784-2, 16121856-2, 16252928-2, 16384000-2,
16515072-2, 16646144-2, 16777216-2, 16908288-2, 17039360-2, 17170432-2, 17301504-2, 17432576-2,
17563648-2, 17694720-2, 17825792-2, 17956864-2, 18087936-2, 18219008-2, 18350080-2, 18481152-2,
18612224-2, 18743296-2, 18874368-2, 19005440-2, 19136512-2, 19267584-2, 19398656-2, 19529728-2,
19660800-2, 19791872-2, 19922944-2, 20054016-2, 20185088-2, 20316160-2, 20447232-2, 20578304-2,
20709376-2, 20840448-2, 20971520-2, 21102592-2, 21233664-2, 21364736-2, 21495808-2, 21626880-2,
21757952-2, 21889024-2, 22020096-2, 22151168-2, 22282240-2, 22413312-2, 22544384-2, 22675456-2,
22806528-2, 22937600-2, 23068672-2, 23199744-2, 23330816-2, 23461888-2, 23592960-2, 23724032-2,
23855104-2, 23986176-2, 24117248-2, 24248320-2, 24379392-2, 24510464-2, 24641536-2, 24772608-2,
24903680-2, 25034752-2, 25165824-2, 25296896-2, 25427968-2, 25559040-2, 25690112-2, 25821184-2,
25952256-2, 26083328-2, 26214400-2, 26345472-2, 26476544-2, 26607616-2, 26738688-2, 26869760-2,
27000832-2, 27131904-2, 27262976-2, 27394048-2, 27525120-2, 27656192-2, 27787264-2, 27918336-2,
28049408-2, 28180480-2, 28311552-2, 28442624-2, 28573696-2, 28704768-2, 28835840-2, 28966912-2,
29097984-2, 29229056-2, 29360128-2, 29491200-2, 29622272-2, 29753344-2, 29884416-2, 30015488-2,
30146560-2, 30277632-2, 30408704-2, 30539776-2, 30670848-2, 30801920-2, 30932992-2, 31064064-2,
31195136-2, 31326208-2, 31457280-2, 31588352-2, 31719424-2, 31850496-2, 31981568-2, 32112640-2,
32243712-2, 32374784-2, 32505856-2, 32636928-2, 32768000-2, 32899072-2, 33030144-2, 33161216-2,
33292288-2, 33423360-2, 33554432-2
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mspatch\lzx\decoder\decproto.h ===
/*
 * decproto.h
 *
 * Decoder function prototypes
 */

/* decblk.c */
long NEAR decode_data(t_decoder_context *context, long bytes_to_decode);

/* decin.c */
void NEAR initialise_decoder_bitbuf(t_decoder_context *context);
void NEAR init_decoder_input(t_decoder_context *context);
void NEAR fillbuf(t_decoder_context *context, int n);
ulong NEAR getbits(t_decoder_context *context, int n);

/* decinit.c */
bool NEAR allocate_decompression_memory(t_decoder_context *context);
void NEAR free_decompression_memory(t_decoder_context *context);
void NEAR decoder_misc_init(t_decoder_context *context);
void NEAR reset_decoder_trees(t_decoder_context *context);

/* decout.c */
void NEAR copy_data_to_output(t_decoder_context *context, long amount, const byte *data);

/* dectree.c */
bool NEAR read_main_and_secondary_trees(t_decoder_context *context);
bool NEAR read_aligned_offset_tree(t_decoder_context *context);

/* maketbl.c */
bool NEAR __cdecl make_table(
        t_decoder_context *context,
        int                     nchar,
        const byte      *bitlen,
        byte            tablebits,
        short           *table,
        short           *leftright
);

bool NEAR make_table_8bit(t_decoder_context *context, byte *bitlen, byte *table);

/* decxlat.c */
void NEAR init_decoder_translation(t_decoder_context *context);
void NEAR decoder_translate_e8(t_decoder_context *context, byte *mem, long bytes);

/* decalign.c */
int NEAR decode_aligned_offset_block(t_decoder_context *context, long bufpos, int amount_to_decode);

/* decverb.c */
int NEAR decode_verbatim_block(t_decoder_context *context, long bufpos, int amount_to_decode);

/* decuncmp.c */
int NEAR decode_uncompressed_block(t_decoder_context *context, long bufpos, int amount_to_decode);
bool NEAR handle_beginning_of_uncompressed_block(t_decoder_context *context);


/*
 * 16-bit stuff:
 */
#ifdef BIT16
void NEAR DComp_Close(t_decoder_context *context);
int  NEAR DComp_Init(t_decoder_context *context);
void NEAR DComp_Reset(t_decoder_context *context);
void NEAR DComp_Save_Output_Pages(t_decoder_context *context, uint bytes_decoded);
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mspatch\lzx\decoder\decxlat.c ===
/*
 * xlat.c
 *
 * Translate
 */
#include "decoder.h"

#include <memory.h>
#pragma intrinsic(memcpy,memset)

void NEAR init_decoder_translation(t_decoder_context *context)
{
    context->dec_instr_pos = 0;
}


#ifdef ASM_TRANSLATE_E8
ulong __cdecl asm_decoder_translate_e8(ulong instr_pos, ulong file_size, byte *mem, long bytes);

void NEAR decoder_translate_e8(t_decoder_context *context, byte *mem, long bytes)
{
    /*
     * We don't want the ASM code to have to worry about where in the
     * context structure a particular element is
     */
    context->dec_instr_pos = asm_decoder_translate_e8(
                                                     context->dec_instr_pos,
                                                     context->dec_current_file_size,
                                                     mem,
                                                     bytes
                                                     );
}

#else /* !ASM_TRANSLATE_E8 */

void NEAR decoder_translate_e8(t_decoder_context *context, byte *mem, long bytes)
{
    ulong   end_instr_pos;
    byte    temp[6];
    byte    *mem_backup;

    if (bytes <= 6)
        {
        context->dec_instr_pos += bytes;
        return;
        }

    mem_backup = mem;

    /* backup these bytes */
    memcpy(temp, &mem[bytes-6], 6);

    /* overwrite them with 0xE8 */
    memset(&mem[bytes-6], 0xE8, 6);

    end_instr_pos = context->dec_instr_pos + bytes - 6;

    while (1)
        {
        unsigned long   absolute;

        /*
         * We are guaranteed to hit one of the 6 0xE8's we stuck at the
         * end of the buffer, even if we ran into some corrupted data
         * that resulted in our jumping over 5 bytes due to a translation
         */
        while (*mem++ != 0xE8)
            context->dec_instr_pos++;

        if (context->dec_instr_pos >= end_instr_pos)
            break;

        /*
         * There are 5 or more bytes in the buffer
         * (i.e. E8 xx xx xx xx)
         *
         * We have a complete offset available to (potentially) translate
         */

        absolute = *(UNALIGNED ulong *) mem;

        if (absolute < context->dec_current_file_size)
            {
            /* absolute >= 0 && absolute < dec_current_file_size */

            *(UNALIGNED ulong *) mem = absolute - context->dec_instr_pos;
            }
        else if ((ulong) (-(long) absolute) <= context->dec_instr_pos)
            {
            /* absolute >= -instr_pos && absolute < 0 */

            *(UNALIGNED ulong *) mem = absolute + context->dec_current_file_size;
            }

        mem += 4;
        context->dec_instr_pos += 5;
        }

    context->dec_instr_pos = end_instr_pos + 6;

    /* restore these bytes */
    memcpy(&mem_backup[bytes-6], temp, 6);
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mspatch\lzx\decoder\dectree.c ===
/*
 * dectree.c
 *
 * Decoding the encoded tree structures
 *
 * To save much code size, the fillbuf()/getbits() calls have
 * been made into functions, rather than being inlined macros.
 * The macros actually take up a lot of space.  There is no
 * performance loss from doing so here.
 */
#include "decoder.h"

/* number of elements in pre-tree */
#define NUM_DECODE_SMALL        20

/* lookup table size */
#define DS_TABLE_BITS           8

/* macro to decode a pre-tree element */
#define DECODE_SMALL(item) \
{ \
        item = small_table[context->dec_bitbuf >> (32-DS_TABLE_BITS) ]; \
        if (item < 0)                                                           \
        {                                                                                       \
      mask = (1L << (32-1-DS_TABLE_BITS));      \
      do                                                                                \
      {                                                                                 \
                        item = -item;                                           \
            if (context->dec_bitbuf & mask)     \
                                item = leftright_s[2*item+1];   \
                        else                                                            \
                                item = leftright_s[2*item];             \
                        mask >>= 1;                                                     \
                } while (item < 0);                                             \
   }                                                                                    \
   fillbuf(context, small_bitlen[item]);                \
}

/*
 * Reads a compressed tree structure
 */
static bool NEAR ReadRepTree(
                            t_decoder_context       *context,
                            int                                     num_elements,
                            byte                            *lastlen,
                            byte                            *len
                            )
{
    ulong   mask;
    int             i;
    int             consecutive;
    byte    small_bitlen[24];
    short   small_table[1 << DS_TABLE_BITS];
    short   leftright_s [2*(2 * 24 - 1)];
    short   Temp;

    /* Declare this inline to help compilers see the optimisation */
    static const byte Modulo17Lookup[] =
    {
        0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16,
        0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16
    };

    /* read pre-tree */
    for (i = 0; i < NUM_DECODE_SMALL; i++)
        {
        small_bitlen[i] = (byte) getbits(context, 4);
        }

    /* exceeded input buffer? */
    if (context->dec_error_condition)
        return false;

    /* make a table for this pre-tree */
    make_table(
              context,
              NUM_DECODE_SMALL,
              small_bitlen,
              DS_TABLE_BITS,
              small_table,
              leftright_s
              );

    for (i = 0; i < num_elements; i++)
        {
        DECODE_SMALL(Temp);

        /* exceeded input buffer? */
        if (context->dec_error_condition)
            return false;

        /* Repeat "TREE_ENC_REP_MIN...TREE_ENC_REP_MIN+(1<<TREE_ENC_REPZ_FIRST_EXTRA_BITS)-1" zeroes */
        if (Temp == 17)
            {
            /* code 17 means "a small number of repeated zeroes" */
            consecutive = (byte) getbits(context, TREE_ENC_REPZ_FIRST_EXTRA_BITS);
            consecutive += TREE_ENC_REP_MIN;

            /* boundary check */
            if (i + consecutive >= num_elements)
                consecutive = num_elements-i;

            while (consecutive-- > 0)
                len[i++] = 0;

            i--;
            }
        else if (Temp == 18)
            {
            /* code 18 means "a large number of repeated zeroes" */

            /* Repeat "TREE_ENC_REP_MIN+(1<<TREE_ENC_REPZ_FIRST_EXTRA_BITS)-1...<ditto>+(1<<TREE_ENC_REPZ_SECOND_EXTRA_BITS)-1" zeroes */
            consecutive = (byte) getbits(context, TREE_ENC_REPZ_SECOND_EXTRA_BITS);
            consecutive += (TREE_ENC_REP_MIN+TREE_ENC_REP_ZERO_FIRST);

            /* boundary check */
            if (i + consecutive >= num_elements)
                consecutive = num_elements-i;

            while (consecutive-- > 0)
                len[i++] = 0;

            i--;
            }
        else if (Temp == 19)
            {
            byte    value;

            /* code 19 means "a small number of repeated somethings" */
            /* Repeat "TREE_ENC_REP_MIN...TREE_ENC_REP_MIN+(1<<TREE_ENC_REP_SAME_EXTRA_BITS)-1" elements */
            consecutive = (byte) getbits(context, TREE_ENC_REP_SAME_EXTRA_BITS);
            consecutive += TREE_ENC_REP_MIN;

            /* boundary check */
            if (i + consecutive >= num_elements)
                consecutive = num_elements-i;

            /* get the element number to repeat */
            DECODE_SMALL(Temp);
            value = Modulo17Lookup[(lastlen[i] - Temp)+17];

            while (consecutive-- > 0)
                len[i++] = value;

            i--;
            }
        else
            {
            len[i] = Modulo17Lookup[(lastlen[i] - Temp)+17];
            }
        }

    /* exceeded input buffer? */
    if (context->dec_error_condition)
        return false;
    else
        return true;
}


bool NEAR read_main_and_secondary_trees(t_decoder_context *context)
{
    /* read first 256 elements (characters) of the main tree */
    if (false == ReadRepTree(
                            context,
                            256,
                            context->dec_main_tree_prev_len,
                            context->dec_main_tree_len))
        {
        return false;
        }

    /*
     * read remaining elements (primary match lengths * positions)
     * of the main tree
     */
    if (false == ReadRepTree(
                            context,
                            context->dec_num_position_slots*NUM_LENGTHS,
                            &context->dec_main_tree_prev_len[256],
                            &context->dec_main_tree_len[256]))
        {
        return false;
        }

    /* create lookup table for the main tree */
    if (false == make_table(
                           context,
                           MAIN_TREE_ELEMENTS,
                           context->dec_main_tree_len,
                           MAIN_TREE_TABLE_BITS,
                           context->dec_main_tree_table,
                           context->dec_main_tree_left_right))
        {
        return false;
        }

    /* read secondary length tree */
    if (false == ReadRepTree(
                            context,
                            NUM_SECONDARY_LENGTHS,
                            context->dec_secondary_length_tree_prev_len,
                            context->dec_secondary_length_tree_len))
        {
        return false;
        }

    /* create lookup table for the secondary length tree */
    if (false == make_table(
                           context,
                           NUM_SECONDARY_LENGTHS,
                           context->dec_secondary_length_tree_len,
                           SECONDARY_LEN_TREE_TABLE_BITS,
                           context->dec_secondary_length_tree_table,
                           context->dec_secondary_length_tree_left_right))
        {
        return false;
        }

    return true;
}


/* read 8 element aligned offset tree */
bool NEAR read_aligned_offset_tree(t_decoder_context *context)
{
    int             i;

    /* read bit lengths of the 8 codes */
    for (i = 0; i < 8; i++)
        {
        context->dec_aligned_len[i] = (byte) getbits(context, 3);
        }

    if (context->dec_error_condition)
        return false;

    /*
     * Make table with no left/right, and byte Table[] instead of
     * short Table[]
     */
    if (false == make_table_8bit(
                                context,
                                context->dec_aligned_len,
                                (byte *) context->dec_aligned_table))
        {
        return false;
        }

    return true;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mspatch\lzx\decoder\maketbl.c ===
/*
 * Table-building routines
 *
 * make_table() is based on ** Public Domain ** source "AR001.ZIP".
 */

#include <memory.h>
#pragma intrinsic(memset)

#include "decoder.h"


/*
 * Make a decoding table for decoding nchar possible Huffman elements
 * with bit lengths given by bitlen.
 *
 * Output the main lookup table into table[] and use leftright[] for
 * supplementary information (for bitlengths > tablebits).
 *
 * The size of table[] is tablebits elements.
 */
#ifndef ASM_MAKE_TABLE
bool NEAR __cdecl make_table(
        t_decoder_context       *context,
        int                             nchar,
        const byte                      *bitlen,
        byte                            tablebits,
        short                           *table,
        short                           *leftright
)
{
    uint    i;
        int             ch;
    short * p;
    uint    count[17], weight[17], start[18];
    int     avail;
    uint    nextcode;
    uint    k;
        byte    len;
        byte    jutbits;

        for (i = 1; i <= 16; i++)
                count[i] = 0;

        /* count the number of elements of each bit length */
    for (i = 0; i < (uint) nchar; i++)
                count[bitlen[i]]++;

        start[1] = 0;

        for (i = 1; i <= 16; i++)
                start[i + 1] = start[i] + (count[i] << (16 - i));

#ifdef BIT16
    if (start[17])
    {
        return false; /* bad table */
    }
#else
    if (start[17] != 65536)
    {
        if (start[17] == 0)
        {
            /*
             * All elements are length zero
             */
            memset(table, 0, sizeof(ushort)*(1 << tablebits));
            return true; /* success */
        }
        else
        {
            return false; /* bad table */
        }
    }
#endif

        jutbits = 16 - tablebits;

        for (i = 1; i <= tablebits; i++)
        {
                start[i] >>= jutbits;
                weight[i] = 1 << (tablebits - i);
        }

        while (i <= 16)
        {
                weight[i] = 1 << (16 - i);
                i++;
        }

        i = start[tablebits+1] >> jutbits;

#ifdef BIT16
    if (i)
#else
        if (i != 65536)
#endif
        {
                memset(
            &table[i],
            0,
            sizeof(ushort)*((1 << tablebits)-i)
        );
        }

        avail = nchar;

        for (ch = 0; ch < nchar; ch++)
        {
                if ((len = bitlen[ch]) == 0)
                        continue;

                nextcode = start[len] + weight[len];

                if (len <= tablebits)
                {
            if (nextcode > (uint) (1 << tablebits))
                return false; /* bad table */

                        for (i = start[len]; i < nextcode; i++)
                                table[i] = (short)ch;

                        start[len] = nextcode;
                }
                else
                {
                        byte bi;

                        k = start[len];
                        start[len] = nextcode;
                        p = &table[k >> jutbits];

                        bi = len - tablebits;
                        k <<= tablebits;

                        do
                        {
                                if (*p == 0)
                                {
                                        leftright[avail*2] = leftright[avail*2+1] = 0;
                                        *p = (short) -avail;
                                        avail++;
                                }

                                if ((signed short) k < 0) // if (k & 32768)
                                        p = &leftright[-(*p)*2+1];
                                else
                                        p = &leftright[-(*p)*2];

                                k <<= 1;
                                bi--;
                        } while (bi);

                        *p = (short)ch;
                }
        }

    return true;
}
#endif


/*
 * Specialised make table routine where it is known that there are
 * only 8 elements (nchar=8) and tablebits=7 (128 byte lookup table).
 *
 * Since there can be no overflow, this will be a direct lookup.
 *
 * Important difference; the lookup table returns a byte, not a ushort.
 */
bool NEAR make_table_8bit(t_decoder_context *context, byte bitlen[], byte table[])
{
        ushort count[17], weight[17], start[18];
        ushort i;
        ushort nextcode;
        byte   len;
        byte   ch;

        for (i = 1; i <= 16; i++)
                count[i] = 0;

        for (i = 0; i < 8; i++)
                count[bitlen[i]]++;

        start[1] = 0;

        for (i = 1; i <= 16; i++)
                start[i + 1] = start[i] + (count[i] << (16 - i));

        if (start[17] != 0)
        return false; /* bad table */

        for (i = 1; i <= 7; i++)
        {
                start[i] >>= 9;
                weight[i]  = 1 << (7 - i);
        }

        while (i <= 16)
        {
                weight[i] = 1 << (16 - i);
                i++;
        }

        memset(table, 0, 1<<7);

        for (ch = 0; ch < 8; ch++)
        {
                if ((len = bitlen[ch]) == 0)
                        continue;

                nextcode = start[len] + weight[len];

                if (nextcode > (1 << 7))
            return false; /* bad table */

                for (i = start[len]; i < nextcode; i++)
                        table[i] = ch;

                start[len] = nextcode;
        }

    return true;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mspatch\lzx\decoder\decverb.c ===
/*
 * decverb.c
 *
 * Decoding verbatim-bit blocks
 */
#include "decoder.h"


static long special_decode_verbatim_block(
                                         t_decoder_context   *context,
                                         long                BufPos,
                                         int                 amount_to_decode
                                         )
{
    ulong   match_pos;
    long    bufpos_end;
    int     match_length;
    int     c;
    ulong   dec_bitbuf;
    byte    *dec_input_curpos;
    byte    *dec_end_input_pos;
    byte    *dec_mem_window;
    char    dec_bitcount;
    ulong   m;

    /*
     * Store commonly used variables locally
     */
    dec_bitcount      = context->dec_bitcount;
    dec_bitbuf        = context->dec_bitbuf;
    dec_input_curpos  = context->dec_input_curpos;
    dec_end_input_pos = context->dec_end_input_pos;
    dec_mem_window    = context->dec_mem_window;

    bufpos_end = BufPos + amount_to_decode;

    /*
     * We may overflow by up to MAX_MATCH
     */
    while (BufPos < bufpos_end)
        {
        /* decode an item from the main tree */
        DECODE_MAIN_TREE(c);

        if ((c -= NUM_CHARS) < 0)
            {
            /*      it's a character */
            /* note: c - 256 == c if c is a byte */
#ifdef TRACING
            TracingLiteral(BufPos, (byte) c);
#endif
            context->dec_mem_window[BufPos] = (byte) c;

            /* we know BufPos < bufpos_end here, so no need to check for overflow */
            context->dec_mem_window[context->dec_window_size+BufPos] = (byte) c;
            BufPos++;
            }
        else
            {
            /* get match length header */
            if ((match_length = c & NUM_PRIMARY_LENGTHS) == NUM_PRIMARY_LENGTHS)
                {
                /* get match length footer if necessary */
                DECODE_LEN_TREE_NOEOFCHECK(match_length);
                }

            /* get match position slot */
            m = c >> NL_SHIFT;

            /* read any extra bits for the match position */
            if (m > 2)
                {
                if (m > 3) /* dec_extra_bits[m] != 0 */
                    {
                    GET_BITS17_NOEOFCHECK(dec_extra_bits[ m ], match_pos);
                    match_pos += MP_POS_minus2[m];
                    }
                else
                    {
                    match_pos = 1; // MP_POS_minus2[3];
                    }

                /*
                 * Add match base to "extra bits".  Our match base
                 * table has 2 subtracted from all the elements.
                 *
                 * This is because encoded positions 0,1,2 denote
                 * repeated offsets.  Encoded position 3 denotes
                 * a match 1 character away, 4 encodes 2 away, etc.
                 * Hence the subtraction of 2, which has been
                 * incorporated into the table.
                 */

                /* update LRU repeated offset list */
                context->dec_last_matchpos_offset[2] = context->dec_last_matchpos_offset[1];
                context->dec_last_matchpos_offset[1] = context->dec_last_matchpos_offset[0];
                context->dec_last_matchpos_offset[0] = match_pos;
                }
            else
                {
                /* positions 0, 1, 2 denote repeated offsets */
                match_pos = context->dec_last_matchpos_offset[m];

                if (m)
                    {
                    context->dec_last_matchpos_offset[m] = context->dec_last_matchpos_offset[0];
                    context->dec_last_matchpos_offset[0] = match_pos;
                    }
                }

            /* match lengths range from 2...257 */
            match_length += MIN_MATCH;

#ifdef EXTRALONGMATCHES

            if ( match_length == MAX_MATCH ) {

                //
                //  See detailed explanation in decalign.c
                //

                ULONG ExtraMatchLength, ExtraMatchLengthResidue;

                GET_BITS_NOEOFCHECK( 9, ExtraMatchLength );

                if ( ExtraMatchLength & ( 1 << 8 )) {
                    if ( ExtraMatchLength & ( 1 << 7 )) {
                        if ( ExtraMatchLength & ( 1 << 6 )) {
                            ExtraMatchLength = ( ExtraMatchLength & (( 1 << 6 ) - 1 )) << 9;
                            GET_BITS_NOEOFCHECK( 9, ExtraMatchLengthResidue );
                            ExtraMatchLength |= ExtraMatchLengthResidue;
                            }
                        else {
                            ExtraMatchLength = ( ExtraMatchLength & (( 1 << 6 ) - 1 )) << 6;
                            GET_BITS_NOEOFCHECK( 6, ExtraMatchLengthResidue );
                            ExtraMatchLength |= ExtraMatchLengthResidue;
                            ExtraMatchLength += ( 1 << 8 ) + ( 1 << 10 );
                            }
                        }
                    else {
                        ExtraMatchLength = ( ExtraMatchLength & (( 1 << 7 ) - 1 )) << 3;
                        GET_BITS_NOEOFCHECK( 3, ExtraMatchLengthResidue );
                        ExtraMatchLength |= ExtraMatchLengthResidue;
                        ExtraMatchLength += ( 1 << 8 );
                        }
                    }

                match_length += ExtraMatchLength;
                }

#endif

#ifdef TRACING
            TracingMatch(BufPos,
                         BufPos - match_pos,
                         context->dec_window_size,
                         match_length,
                         m);
#endif

            /* copy match data */
            do
                {
                context->dec_mem_window[BufPos] = context->dec_mem_window[(BufPos-match_pos) & context->dec_window_mask];

                /* replicate bytes */
                if (BufPos < MAX_MATCH) // what does this do?  Does it need to be more than MAX_MATCH now?
                    context->dec_mem_window[context->dec_window_size+BufPos] = context->dec_mem_window[BufPos];

                BufPos++;
                } while (--match_length > 0);
            }
        }

    context->dec_bitcount     = dec_bitcount;
    context->dec_bitbuf       = dec_bitbuf;
    context->dec_input_curpos = dec_input_curpos;

    return BufPos;
}


#ifdef ASM_DECODE_VERBATIM_BLOCK

long __cdecl fast_decode_verbatim_block(
                                       t_decoder_context   *context,
                                       long                BufPos,
                                       int                 amount_to_decode
                                       );

#else /* !ASM_DECODE_VERBATIM_BLOCK */

long fast_decode_verbatim_block(t_decoder_context *context, long BufPos, int amount_to_decode)
{
    ulong   match_pos;
    ulong   match_ptr;
    long    bufpos_end;
    long    decode_residue;
    int             match_length;
    int             c;
    ulong   dec_bitbuf;
    byte   *dec_input_curpos;
    byte   *dec_end_input_pos;
    byte    *dec_mem_window;
    char    dec_bitcount;
    ulong   m;

    /*
     * Store commonly used variables locally
     */
    dec_bitcount      = context->dec_bitcount;
    dec_bitbuf        = context->dec_bitbuf;
    dec_input_curpos  = context->dec_input_curpos;
    dec_end_input_pos = context->dec_end_input_pos;
    dec_mem_window    = context->dec_mem_window;

    bufpos_end = BufPos + amount_to_decode;

    while (BufPos < bufpos_end)
        {
        /* decode an item from the main tree */
        DECODE_MAIN_TREE(c);

        if ((c -= NUM_CHARS) < 0)
            {
            /*      it's a character */
            /* note: c - 256 == c if c is a byte */
#ifdef TRACING
            TracingLiteral(BufPos, (byte) c);
#endif
            context->dec_mem_window[BufPos++] = (byte) c;
            }
        else
            {
            /* get match length header */
            if ((match_length = c & NUM_PRIMARY_LENGTHS) == NUM_PRIMARY_LENGTHS)
                {
                /* get match length footer if necessary */
                DECODE_LEN_TREE_NOEOFCHECK(match_length);
                }

            /* get match position slot */
            m = c >> NL_SHIFT;

            /* read any extra bits for the match position */
            if (m > 2)
                {
                if (m > 3) /* dec_extra_bits[m] != 0 */
                    {
                    GET_BITS17_NOEOFCHECK(dec_extra_bits[ m ], match_pos);
                    match_pos += MP_POS_minus2[m];
                    }
                else
                    {
                    match_pos = MP_POS_minus2[3];
                    }

                /*
                 * Add match base to "extra bits".  Our match base
                 * table has 2 subtracted from all the elements.
                 *
                 * This is because encoded positions 0,1,2 denote
                 * repeated offsets.  Encoded position 3 denotes
                 * a match 1 character away, 4 encodes 2 away, etc.
                 * Hence the subtraction of 2, which has been
                 * incorporated into the table.
                 */

                /* update LRU repeated offset list */
                context->dec_last_matchpos_offset[2] = context->dec_last_matchpos_offset[1];
                context->dec_last_matchpos_offset[1] = context->dec_last_matchpos_offset[0];
                context->dec_last_matchpos_offset[0] = match_pos;
                }
            else
                {
                /* positions 0, 1, 2 denote repeated offsets */
                match_pos = context->dec_last_matchpos_offset[m];

                if (m)
                    {
                    context->dec_last_matchpos_offset[m] = context->dec_last_matchpos_offset[0];
                    context->dec_last_matchpos_offset[0] = match_pos;
                    }
                }

            /* match lengths range from 2...257 */
            match_length += MIN_MATCH;

#ifdef EXTRALONGMATCHES

            if ( match_length == MAX_MATCH ) {

                //
                //  See detailed explanation in decalign.c
                //

                ULONG ExtraMatchLength, ExtraMatchLengthResidue;

                GET_BITS_NOEOFCHECK( 9, ExtraMatchLength );

                if ( ExtraMatchLength & ( 1 << 8 )) {
                    if ( ExtraMatchLength & ( 1 << 7 )) {
                        if ( ExtraMatchLength & ( 1 << 6 )) {
                            ExtraMatchLength = ( ExtraMatchLength & (( 1 << 6 ) - 1 )) << 9;
                            GET_BITS_NOEOFCHECK( 9, ExtraMatchLengthResidue );
                            ExtraMatchLength |= ExtraMatchLengthResidue;
                            }
                        else {
                            ExtraMatchLength = ( ExtraMatchLength & (( 1 << 6 ) - 1 )) << 6;
                            GET_BITS_NOEOFCHECK( 6, ExtraMatchLengthResidue );
                            ExtraMatchLength |= ExtraMatchLengthResidue;
                            ExtraMatchLength += ( 1 << 8 ) + ( 1 << 10 );
                            }
                        }
                    else {
                        ExtraMatchLength = ( ExtraMatchLength & (( 1 << 7 ) - 1 )) << 3;
                        GET_BITS_NOEOFCHECK( 3, ExtraMatchLengthResidue );
                        ExtraMatchLength |= ExtraMatchLengthResidue;
                        ExtraMatchLength += ( 1 << 8 );
                        }
                    }

                match_length += ExtraMatchLength;
                }

#endif

            match_ptr = (BufPos - match_pos) & context->dec_window_mask;

#ifdef TRACING
            TracingMatch(BufPos,
                         BufPos - match_pos,
                         context->dec_window_size,
                         match_length,
                         m);
#endif

            /* copy match data */

            do
                {
                context->dec_mem_window[BufPos++] = context->dec_mem_window[match_ptr++];
                } while (--match_length > 0);
            }
        }

    context->dec_bitcount     = dec_bitcount;
    context->dec_bitbuf       = dec_bitbuf;
    context->dec_input_curpos = dec_input_curpos;

    /* should be zero */
    decode_residue = BufPos - bufpos_end;

    BufPos &= context->dec_window_mask;
    context->dec_bufpos = BufPos;

    return decode_residue;
}
#endif /* ASM_DECODE_VERBATIM_BLOCK */


int decode_verbatim_block(t_decoder_context *context, long BufPos, int amount_to_decode)
{
    /*
     * Special case code when BufPos is near the beginning of the window;
     * we must properly update our MAX_MATCH wrapper bytes.
     */
    if (BufPos < MAX_MATCH)
        {
        long    new_bufpos;
        long    amount_to_slowly_decode;

        amount_to_slowly_decode = min(MAX_MATCH-BufPos, amount_to_decode);

        /*
         * It's ok to end up decoding more than we wanted if we
         * restricted it to decoding only MAX_MATCH; there's
         * no guarantee a match doesn't straddle MAX_MATCH
         */
        new_bufpos = special_decode_verbatim_block(
                                                  context,
                                                  BufPos,
                                                  amount_to_slowly_decode
                                                  );

        amount_to_decode -= (new_bufpos-BufPos);

        context->dec_bufpos = BufPos = new_bufpos;

        /*
         * Note: if amount_to_decode < 0 then we're in trouble
         */
        if (amount_to_decode <= 0)
            return amount_to_decode;
        }

    return fast_decode_verbatim_block(context, BufPos, amount_to_decode);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mspatch\lzx\encoder\blkinit.c ===
/*
 * blkinit.c
 *
 * Block outputting initialisation
 */

#include "encoder.h"


/*
 * Create lookup table for MP_SLOT() macro
 */
void create_slot_lookup_table(t_encoder_context *context)
{
   int			j;
   int 			p;
   int 			elements_to_init;
   ushort       slotnum;

   context->enc_slot_table[0] = 0;
   context->enc_slot_table[1] = 1;
   context->enc_slot_table[2] = 2;
   context->enc_slot_table[3] = 3;

   elements_to_init = 2;

   slotnum = 4;
   p       = 4;

   do
   {
      for (j = elements_to_init; j > 0; j--)
         context->enc_slot_table[p++] = slotnum;

      slotnum++;

      for (j = elements_to_init; j > 0; j--)
         context->enc_slot_table[p++] = slotnum;

      slotnum++;
      elements_to_init <<= 1;

   } while (p < 1024);
}


/*
 * Create lookup table for figuring out how many
 * ones there are in a given byte.
 */
void create_ones_table(t_encoder_context *context)
{
	int			i, j;
	byte		ones;

	for (i = 0; i < 256; i++)
	{
		ones = 0;

		for (j = i; j; j >>= 1)
		{
			if (j & 1)
				ones++;
		}

		context->enc_ones[i] = ones;
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mspatch\lzx\encoder\block.c ===
/*
 * block.c
 *
 * LZX block outputting
 */

#include "encoder.h"


/*
 * Internal function definitions
 */
static void do_block_output(
                           t_encoder_context *context,
                           long literal_to_end_at,
                           long distance_to_end_at
                           );


static void do_block_output(
                           t_encoder_context *context,
                           long literal_to_end_at,
                           long distance_to_end_at
                           )
{
    ulong                   bytes_compressed;
    lzx_block_type  block_type;
    ulong                   estimated_block_size;

    /*
     * Calculate frequencies for all tree elements.
     *
     * How many uncompressed bytes does this account for?
     */
    bytes_compressed = get_block_stats(
                                      context,
                                      0,
                                      0,
                                      literal_to_end_at
                                      );

    /*
     * Determine whether we wish to output a verbatim block or an
     * aligned offset block
     */
    block_type = get_aligned_stats(context, distance_to_end_at);

    /*
     * Create trees from the frequency data
     */
    create_trees(context, true); /* we want to generate the codes too */

    /*
     * Determine whether the block should be output as uncompressed
     */
    estimated_block_size = estimate_compressed_block_size(context);

    if (estimated_block_size >= bytes_compressed)
        {
        if (context->enc_bufpos_at_last_block >= context->enc_earliest_window_data_remaining)
            block_type = BLOCKTYPE_UNCOMPRESSED;
        }

    output_bits(context, 3, (byte) block_type);

    /* output 24 bit number, number of bytes compressed here */
    output_bits(context, 8,  (bytes_compressed >> 16) & 255);
    output_bits(context, 8,  ((bytes_compressed >> 8) & 255));
    output_bits(context, 8,  (bytes_compressed & 255));

    if (block_type == BLOCKTYPE_VERBATIM)
        {
        encode_trees(context);
        encode_verbatim_block(context, literal_to_end_at);
        get_final_repeated_offset_states(context, distance_to_end_at);
        }
    else if (block_type == BLOCKTYPE_ALIGNED)
        {
        encode_aligned_tree(context);
        encode_trees(context);
        encode_aligned_block(context, literal_to_end_at);
        get_final_repeated_offset_states(context, distance_to_end_at);
        }
    else if (block_type == BLOCKTYPE_UNCOMPRESSED)
        {
        get_final_repeated_offset_states(context, distance_to_end_at);
        encode_uncompressed_block(context, context->enc_bufpos_at_last_block, bytes_compressed);
        }

    context->enc_bufpos_at_last_block += bytes_compressed;
}


/*
 * Returns the number of distances which correspond
 * to this number of literals
 */
ulong get_distances_from_literals(t_encoder_context *context, ulong literals)
{
    ulong   d = 0;
    ulong   i;

    for (i = 0; i < (literals >> 3); i++)
        d += context->enc_ones[ context->enc_ItemType[i] ];

    /*
     * Handle remaining 0...7
     */
    for (i = (literals & (~7)); i < literals; i++)
        {
        if (IsMatch(i))
            d++;
        }

    return d;
}


/*
 * Output a block
 *
 * If trees_only is true, then only the tree statistics are updated.
 */
void output_block(t_encoder_context *context)
{
    ulong   where_to_split;
    ulong   distances;

    //
    // We have now output a block.
    //
    // We set this here in case someone calls LCIFlushOutput, so that
    // we don't try to redo the first chunk of bytes in the file
    // (since we've been forced to output them)
    //
    context->enc_first_block = 0;

    split_block(
               context,
               0,
               context->enc_literals,
               context->enc_distances,
               &where_to_split,
               &distances /* distances @ literal == where_to_split */
               );

    do_block_output(context, where_to_split, distances);

    if (where_to_split == context->enc_literals)
        {
        /*
         * If we've output ALL of our literals, then clear the itemtype array
         */
        memset(context->enc_ItemType, 0, MAX_LITERAL_ITEMS/8);

        context->enc_literals   = 0;
        context->enc_distances  = 0;
        }
    else
        {
        /*
         * If we didn't output all of our literals, then move the literals
         * and distances we didn't use, to the beginning of the list
         */
        memcpy(
              &context->enc_ItemType[0],
              &context->enc_ItemType[where_to_split/8],
              &context->enc_ItemType[1+(context->enc_literals/8)] - &context->enc_ItemType[where_to_split/8]
              );

        memset(
              &context->enc_ItemType[1+(context->enc_literals-where_to_split)/8],
              0,
              &context->enc_ItemType[MAX_LITERAL_ITEMS/8] - &context->enc_ItemType[1+(context->enc_literals-where_to_split)/8]
              );

        memcpy(
              &context->enc_LitData[0],
              &context->enc_LitData[where_to_split],
              sizeof( context->enc_LitData[0] ) * ( context->enc_literals-where_to_split )
              );

#ifdef EXTRALONGMATCHES

        memcpy(
              &context->enc_ExtraLength[0],
              &context->enc_ExtraLength[where_to_split],
              sizeof( context->enc_ExtraLength[0] ) * ( context->enc_literals-where_to_split )
              );

#endif

        memcpy(
              &context->enc_DistData[0],
              &context->enc_DistData[distances],
              sizeof(ulong)*(context->enc_distances-distances)
              );

        context->enc_literals  -= where_to_split;
        context->enc_distances -= distances;
        }

    fix_tree_cost_estimates(context);
}


void flush_output_bit_buffer(t_encoder_context *context)
{
    byte temp;

    if (context->enc_bitcount < 32)
        {
        temp = context->enc_bitcount-16;

        output_bits(context, temp, 0);
        }
}


/*
 * Estimate how much it would take to output the compressed
 * data left in the buffer
 */
long estimate_buffer_contents(t_encoder_context *context)
{
    long                    estimated_block_size;

    /*
     * Use frequency data sitting around from last tree creation
     */
    create_trees(context, false); /* don't generate codes */

    estimated_block_size = estimate_compressed_block_size(context);

    /* so the optimal parser doesn't get confused */
    fix_tree_cost_estimates(context);

    return estimated_block_size;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mspatch\lzx\encoder\bsearch.c ===
/*
 * bsearch.c
 *
 * Binary search for optimal encoder
 */
#include "encoder.h"


#define left    context->enc_Left
#define right   context->enc_Right


/*
 * Define this to force checking that all search locations visited
 * are valid.
 *
 * For debugging purposes only.
 */
#ifdef _DEBUG
    #define VERIFY_SEARCHES
#endif

#define VERIFY_SEARCH_CODE(routine_name) \
{ \
        int debug_search; \
        for (debug_search = 0; debug_search < clen; debug_search++) \
        { \
            _ASSERTE( context->enc_MemWindow[ptr+debug_search] == context->enc_MemWindow[BufPos+debug_search]); \
        } \
}

#define VERIFY_MULTI_TREE_SEARCH_CODE(routine_name) \
_ASSERTE (context->enc_MemWindow[BufPos] == context->enc_MemWindow[ptr]); \
_ASSERTE (context->enc_MemWindow[BufPos+1] == context->enc_MemWindow[ptr+1]);



/*
 * Finds the closest matches of all possible lengths, MIN_MATCH <= x <= MAX_MATCH,
 * at position BufPos.
 *
 * The positions of each match location are stored in context->enc_matchpos_table[]
 *
 * Returns the longest such match length found, or zero if no matches found.
 */

#ifndef ASM_BSEARCH_FINDMATCH
long binary_search_findmatch(t_encoder_context *context, long BufPos)
{
    ulong       ptr;
    ulong       a, b;
    ulong       *small_ptr, *big_ptr;
    ulong       end_pos;
    int         val; /* must be signed */
    int         bytes_to_boundary;
    int         clen;
    int         same;
    int         match_length;
    int         small_len, big_len;
    int         i, best_repeated_offset;
    #ifdef MULTIPLE_SEARCH_TREES
    ushort      tree_to_use;

    /*
     * Retrieve root node of tree to search, and insert current node at
     * the root.
     */
    tree_to_use = *((ushort UNALIGNED *) &context->enc_MemWindow[BufPos]);

    ptr        = context->enc_tree_root[tree_to_use];
    context->enc_tree_root[tree_to_use] = BufPos;
    #else
    ptr = context->enc_single_tree_root;
    context->enc_single_tree_root = BufPos;
    #endif
    /*
     * end_pos is the furthest location back we will search for matches
     *
     * Remember that our window size is reduced by 3 bytes because of
     * our repeated offset codes.
     *
     * Since BufPos starts at context->enc_window_size when compression begins,
     * end_pos will never become negative.
     */
    end_pos = BufPos - (context->enc_window_size-4);

    /*
     * Root node is either NULL, or points to a really distant position.
     */
    if (ptr <= end_pos)
        {
        left[BufPos] = right[BufPos] = 0;
        return 0;
        }

    #ifdef MULTIPLE_SEARCH_TREES
    /*
     * confirmed length (no need to check the first clen chars in a search)
     *
     * note: clen is always equal to min(small_len, big_len)
     */
    clen            = 2;

    /*
     * current best match length
     */
    match_length    = 2;

    /*
     * longest match which is < our string
     */
    small_len       = 2;

    /*
     * longest match which is > our string
     */
    big_len         = 2;

    /*
     * record match position for match length 2
     */
    context->enc_matchpos_table[2] = BufPos - ptr + 2;

        #ifdef VERIFY_SEARCHES
    VERIFY_MULTI_TREE_SEARCH_CODE("binary_search_findmatch()");
        #endif

    #else /* !MULTIPLE_SEARCH_TREES */

    clen            = 0;
    match_length    = 0;
    small_len       = 0;
    big_len         = 0;

    #endif /* MULTIPLE_SEARCH_TREES */

    /*
     * pointers to nodes to check
     */
    small_ptr             = &left[BufPos];
    big_ptr               = &right[BufPos];

    do
        {
        /* compare bytes at current node */
        same = clen;

    #ifdef VERIFY_SEARCHES
        VERIFY_SEARCH_CODE("binary_search_findmatch()")
    #endif

        /* don't need to check first clen characters */
        a    = ptr + clen;
        b    = BufPos + clen;

        while ((val = ((int) context->enc_MemWindow[a++]) - ((int) context->enc_MemWindow[b++])) == 0)
            {
            /* don't exceed MAX_MATCH */
            if (++same >= MAX_MATCH)
                goto long_match;
            }

        if (val < 0)
            {
            if (same > big_len)
                {
                if (same > match_length)
                    {
                    long_match:
                    do
                        {
                        context->enc_matchpos_table[++match_length] = BufPos-ptr+(NUM_REPEATED_OFFSETS-1);
                        } while (match_length < same);

                    if (same >= BREAK_LENGTH)
                        {
                        *small_ptr = left[ptr];
                        *big_ptr   = right[ptr];
                        goto end_bsearch;
                        }
                    }

                big_len = same;
                clen = min(small_len, big_len);
                }

            *big_ptr = ptr;
            big_ptr  = &left[ptr];
            ptr      = *big_ptr;
            }
        else
            {
            if (same > small_len)
                {
                if (same > match_length)
                    {
                    do
                        {
                        context->enc_matchpos_table[++match_length] = BufPos-ptr+(NUM_REPEATED_OFFSETS-1);
                        } while (match_length < same);

                    if (same >= BREAK_LENGTH)
                        {
                        *small_ptr = left[ptr];
                        *big_ptr   = right[ptr];
                        goto end_bsearch;
                        }
                    }

                small_len = same;
                clen = min(small_len, big_len);
                }

            *small_ptr = ptr;
            small_ptr  = &right[ptr];
            ptr        = *small_ptr;
            }
        } while (ptr > end_pos); /* while we don't go too far backwards */

    *small_ptr = 0;
    *big_ptr   = 0;


    end_bsearch:

    /*
     * If we have multiple search trees, we are already guaranteed
     * a minimum match length of 2 when we reach here.
     *
     * If we only have one tree, then we're not guaranteed anything.
     */
    #ifndef MULTIPLE_SEARCH_TREES
    if (match_length < MIN_MATCH)
        return 0;
    #endif

    /*
     * Check to see if any of our match lengths can
     * use repeated offsets.
     */

    /*
     * repeated offset 1
     */
    for (i = 0; i < match_length; i++)
        {
        if (context->enc_MemWindow[BufPos+i] != context->enc_MemWindow[BufPos-context->enc_last_matchpos_offset[0]+i])
            break;
        }

    /*
     * the longest repeated offset
     */
    best_repeated_offset = i;

    if (i >= MIN_MATCH)
        {
        /*
         * Yes, we can do a repeated offset for some match lengths; replace
         * their positions with the repeated offset position
         */
        do
            {
            context->enc_matchpos_table[i] = 0; /* first repeated offset position */
            } while (--i >= MIN_MATCH);

        /* A speed optimization to cope with long runs of bytes */
        if (best_repeated_offset > BREAK_LENGTH)
            goto quick_return;
        }

    /*
     * repeated offset 2
     */
    for (i = 0; i < match_length; i++)
        {
        if (context->enc_MemWindow[BufPos+i] != context->enc_MemWindow[BufPos-context->enc_last_matchpos_offset[1]+i])
            break;
        }

    /*
     * Does the second repeated offset provide a longer match?
     *
     * If so, leave the first repeated offset alone, but fill out the
     * difference in match lengths in the table with repeated offset 1.
     */
    if (i > best_repeated_offset)
        {
        do
            {
            context->enc_matchpos_table[++best_repeated_offset] = 1;
            } while (best_repeated_offset < i);
        }

    /*
     * repeated offset 3
     */
    for (i = 0; i < match_length; i++)
        {
        if (context->enc_MemWindow[BufPos+i] != context->enc_MemWindow[BufPos-context->enc_last_matchpos_offset[2]+i])
            break;
        }

    /*
     * Does the third repeated offset provide a longer match?
     */
    if (i > best_repeated_offset)
        {
        do
            {
            context->enc_matchpos_table[++best_repeated_offset] = 2;
            } while (best_repeated_offset < i);
        }

    quick_return:

    /*
     * Don't let a match cross a 32K boundary
     */
    bytes_to_boundary = (CHUNK_SIZE-1) - ((int) BufPos & (CHUNK_SIZE-1));

    if (match_length > bytes_to_boundary)
        {
        match_length = bytes_to_boundary;

        if (match_length < MIN_MATCH)
            match_length = 0;
        }

    return (long) match_length;
}
#endif


/*
 * Inserts the string at the current BufPos into the tree.
 *
 * Does not record all the best match lengths or otherwise attempt
 * to search for matches
 *
 * Similar to the above function.
 */
#ifndef ASM_QUICK_INSERT_BSEARCH_FINDMATCH
void quick_insert_bsearch_findmatch(t_encoder_context *context, long BufPos, long end_pos)
{
    long        ptr;
    ulong       a,b;
    ulong       *small_ptr, *big_ptr;
    int         val;
    int         small_len, big_len;
    int         same;
    int         clen;
    #ifdef MULTIPLE_SEARCH_TREES
    ushort      tree_to_use;

    tree_to_use = *((ushort UNALIGNED *) &context->enc_MemWindow[BufPos]);
    ptr        = context->enc_tree_root[tree_to_use];
    context->enc_tree_root[tree_to_use] = BufPos;
    #else
    ptr = context->enc_single_tree_root;
    context->enc_single_tree_root = BufPos;
    #endif

    if (ptr <= end_pos)
        {
        left[BufPos] = right[BufPos] = 0;
        return;
        }

    #ifdef MULTIPLE_SEARCH_TREES
    clen            = 2;
    small_len       = 2;
    big_len         = 2;

        #ifdef VERIFY_SEARCHES
    VERIFY_MULTI_TREE_SEARCH_CODE("quick_insert_bsearch_findmatch()");
        #endif

    #else
    clen            = 0;
    small_len       = 0;
    big_len         = 0;
    #endif

    small_ptr       = &left[BufPos];
    big_ptr         = &right[BufPos];

    do
        {
        _ASSERTE ((ulong) ptr >= (ulong) (context->enc_RealLeft - context->enc_Left));

        same = clen;

        a    = ptr+clen;
        b    = BufPos+clen;

    #ifdef VERIFY_SEARCHES
        VERIFY_SEARCH_CODE("quick_insert_bsearch_findmatch()")
    #endif

        while ((val = ((int) context->enc_MemWindow[a++]) - ((int) context->enc_MemWindow[b++])) == 0)
            {
            /*
             * Here we break on BREAK_LENGTH, not MAX_MATCH
             */
            if (++same >= BREAK_LENGTH)
                break;
            }

        if (val < 0)
            {
            if (same > big_len)
                {
                if (same >= BREAK_LENGTH)
                    {
                    *small_ptr = left[ptr];
                    *big_ptr = right[ptr];
                    return;
                    }

                big_len = same;
                clen = min(small_len, big_len);
                }

            *big_ptr = ptr;
            big_ptr  = &left[ptr];
            ptr      = *big_ptr;
            }
        else
            {
            if (same > small_len)
                {
                if (same >= BREAK_LENGTH)
                    {
                    *small_ptr = left[ptr];
                    *big_ptr = right[ptr];
                    return;
                    }

                small_len = same;
                clen = min(small_len, big_len);
                }

            *small_ptr = ptr;
            small_ptr  = &right[ptr];
            ptr        = *small_ptr;
            }
        } while (ptr > end_pos);

    *small_ptr = 0;
    *big_ptr   = 0;
}
#endif


/*
 * Remove a node from the search tree; this is ONLY done for the last
 * BREAK_LENGTH symbols (see optenc.c).  This is because we will have
 * inserted strings that contain undefined data (e.g. we're at the 4th
 * last byte from the file and binary_search_findmatch() a string into
 * the tree - everything from the 4th symbol onwards is invalid, and
 * would cause problems if it remained in the tree, so we have to
 * remove it).
 */
void binary_search_remove_node(t_encoder_context *context, long BufPos, ulong end_pos)
{
    ulong   ptr;
    ulong   left_node_pos;
    ulong   right_node_pos;
    ulong   *link;
#ifdef MULTIPLE_SEARCH_TREES
    ushort  tree_to_use;

    /*
     * The root node of tree_to_use should equal BufPos, since that is
     * the most recent insertion into that tree - but if we never
     * inserted this string (because it was a near match or a long
     * string of zeroes), then we can't remove it.
     */
    tree_to_use = *((ushort UNALIGNED *) &context->enc_MemWindow[BufPos]);


    /*
     * If we never inserted this string, do not attempt to remove it
     */

    if (context->enc_tree_root[tree_to_use] != (ulong) BufPos)
        return;

    link = &context->enc_tree_root[tree_to_use];
#else
    if (context->enc_single_tree_root != (ulong) BufPos)
        return;

    link = &context->enc_single_tree_root;
#endif

    /*
     * If the last occurence was too far away
     */
    if (*link <= end_pos)
        {
        *link = 0;
        left[BufPos] = right[BufPos] = 0;
        return;
        }

    /*
     * Most recent location of these chars
     */
    ptr             = BufPos;

    /*
     * Most recent location of a string which is "less than" it
     */
    left_node_pos   = left[ptr];

    if (left_node_pos <= end_pos)
        left_node_pos = left[ptr] = 0;

    /*
     * Most recent location of a string which is "greater than" it
     */
    right_node_pos  = right[ptr];

    if (right_node_pos <= end_pos)
        right_node_pos = right[ptr] = 0;

    while (1)
        {
#ifdef VERIFY_SEARCHES
        _ASSERTE (left_node_pos < (ulong) BufPos);
        _ASSERTE (right_node_pos < (ulong) BufPos);
#endif

        /*
         * If left node position is greater than right node position
         * then follow the left node, since that is the more recent
         * insertion into the tree.  Otherwise follow the right node.
         */
        if (left_node_pos > right_node_pos)
            {
            /*
             * If it's too far away, then store that it never happened
             */
            if (left_node_pos <= end_pos)
                left_node_pos = 0;

            ptr = *link = left_node_pos;

            if (!ptr)
                break;

            left_node_pos   = right[ptr];
            link            = &right[ptr];
            }
        else
            {
            /*
             * If it's too far away, then store that it never happened
             */
            if (right_node_pos <= end_pos)
                right_node_pos = 0;

            ptr = *link = right_node_pos;

            if (!ptr)
                break;

            right_node_pos  = left[ptr];
            link            = &left[ptr];
            }
        }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mspatch\lzx\encoder\encapi.c ===
/*
 * encapi.c
 *
 * Encoder API entrypoints.
 */

#define ALLOC_VARS
#include "encoder.h"


bool
__fastcall
LZX_EncodeInit(
    t_encoder_context **  enc_context,
    long                  compression_window_size,
    long                  second_partition_size,
    PFNALLOC              pfnma,
    HANDLE                hAllocator,
    int (__stdcall * pfnlzx_output_callback)(
        void *            pfol,
        unsigned char *   compressed_data,
        long              compressed_size,
        long              uncompressed_size
        ),
    void *                fci_data
    )
{

    t_encoder_context *context = pfnma( hAllocator, sizeof( t_encoder_context ));

    if ( context == NULL ) {
        return false;
        }

    *enc_context = context;

    /* to pass back in lzx_output_callback() */
    context->enc_fci_data = fci_data;

    context->enc_window_size = compression_window_size;

    /*
     * The second partition size must be a multiple of 32K
     */
    if (second_partition_size & (CHUNK_SIZE-1))
        second_partition_size &= (~(CHUNK_SIZE-1));

    /*
     * The minimum allowed is 32K because of the way that
     * our translation works.
     */
    if (second_partition_size < CHUNK_SIZE)
        second_partition_size = CHUNK_SIZE;

    /*
     * Our window size must be at least 32K
     */
    if (compression_window_size < CHUNK_SIZE)
        return false;

    context->enc_encoder_second_partition_size = second_partition_size;
    context->enc_output_callback_function = pfnlzx_output_callback;

    context->enc_malloc       = pfnma;
    context->enc_mallochandle = hAllocator;

    /* Error allocating memory? */
    if (comp_alloc_compress_memory(context) == false)
        return false;

    LZX_EncodeNewGroup(context);

    return true;
}


/*
 * Sets up the encoder for a new group of files.
 *
 * All this does is reset the lookup table, re-initialise to the
 * default match estimation tables for the optimal parser, and
 * reset a few variables.
 */
void __fastcall LZX_EncodeNewGroup(t_encoder_context *context)
{
    init_compression_memory(context);
}


long __fastcall LZX_Encode(
               t_encoder_context *context,
               byte *             input_data,
               long               input_size,
               long *             estimated_bytes_compressed,
               long               file_size_for_translation
               )
{
    context->enc_input_ptr  = input_data;
    context->enc_input_left = input_size;

    context->enc_file_size_for_translation = file_size_for_translation;

    /* perform the encoding */
    encoder_start(context);

    if (context->enc_output_overflow)
        {
        *estimated_bytes_compressed = 0;
        return ENCODER_WRITE_FAILURE;
        }

    *estimated_bytes_compressed = estimate_buffer_contents(context);

    return ENCODER_SUCCESS;
}


bool __fastcall LZX_EncodeFlush(t_encoder_context *context)
{
    flush_all_pending_blocks(context);

    if (context->enc_output_overflow)
        return false;

    return true;
}


//
// But doesn't remove history data
//
bool __fastcall LZX_EncodeResetState(t_encoder_context *context)
{
    /*
     * Most of this copied from init.c
     */

    /*
     * Clear item array and reset literal and distance
     * counters
     */
    memset(context->enc_ItemType, 0, (MAX_LITERAL_ITEMS/8));

    context->enc_literals      = 0;
    context->enc_distances     = 0;

    /*
     * Reset encoder state
     */
    context->enc_last_matchpos_offset[0] = 1;
    context->enc_last_matchpos_offset[1] = 1;
    context->enc_last_matchpos_offset[2] = 1;

    context->enc_repeated_offset_at_literal_zero[0] = 1;
    context->enc_repeated_offset_at_literal_zero[1] = 1;
    context->enc_repeated_offset_at_literal_zero[2] = 1;

    context->enc_input_running_total = 0;

    /*
     * The last lengths are zeroed in both the encoder and decoder,
     * since our tree representation is delta format.
     */
    memset(context->enc_main_tree_prev_len, 0, MAIN_TREE_ELEMENTS);
    memset(context->enc_secondary_tree_prev_len, 0, NUM_SECONDARY_LENGTHS);

    /* reset bit buffer */
    context->enc_bitcount = 32;
    context->enc_bitbuf   = 0;
    context->enc_output_overflow = false;

    /* need to recalculate stats soon */
    context->enc_need_to_recalc_stats = true;
    context->enc_next_tree_create = TREE_CREATE_INTERVAL;

    /* pretend we just output everything up to now as a block */
    context->enc_bufpos_last_output_block = context->enc_BufPos;

    /* don't allow re-doing */
    context->enc_first_block = false;

    /* reset instruction pointer (for translation) to zero */
    reset_translation(context);

    /* so we output the file xlat header */
    context->enc_first_time_this_group = true;

    /* reset frame counter */
    context->enc_num_cfdata_frames = 0;

    /* haven't split the block */
    context->enc_num_block_splits = 0;

    return true;
}


unsigned char * __fastcall LZX_GetInputData(
                               t_encoder_context *context,
                               unsigned long *input_position,
                               unsigned long *bytes_available
                               )
{
    unsigned long filepos;

    // note that BufPos-window_size is the real position in the file
    filepos = context->enc_BufPos - context->enc_window_size;

    if (filepos < context->enc_window_size)
        {
        *input_position = 0;
        *bytes_available = filepos;
        return &context->enc_MemWindow[context->enc_window_size];
        }
    else
        {
        *input_position = filepos - context->enc_window_size;
        *bytes_available = context->enc_window_size;
        return &context->enc_MemWindow[context->enc_BufPos - context->enc_window_size];
        }
}


//
// This is used to quickly insert the old file into the history.
//

bool __fastcall LZX_EncodeInsertDictionary(
                       t_encoder_context *context,
                       byte *             input_data,
                       ulong              input_size
                       )
{
    ulong   BufPos;
    ulong   RealBufPos;
    ulong   BufPosEnd;
    ulong   BytesRead;
    ulong   i;
    ulong   end_pos;

    context->enc_input_ptr  = input_data;
    context->enc_input_left = input_size;

    context->enc_file_size_for_translation = 0;
    context->enc_first_time_this_group = false;

    RealBufPos = context->enc_BufPos - (ulong)(context->enc_RealMemWindow - context->enc_MemWindow);

    BytesRead = comp_read_input(context, RealBufPos, input_size);

    BufPos    = context->enc_BufPos;
    BufPosEnd = context->enc_BufPos + BytesRead;

    while (BufPos < BufPosEnd)
    {
        quick_insert_bsearch_findmatch(
            context,
            BufPos,
            BufPos - context->enc_window_size+4
        );

        BufPos++;
    }

    context->enc_earliest_window_data_remaining = BufPos - context->enc_window_size;

    end_pos = BufPos - (context->enc_window_size-4-BREAK_LENGTH);

    for (i = 1; (i <= BREAK_LENGTH); i++)
        binary_search_remove_node(context, BufPos-i, end_pos);

    context->enc_BufPos = BufPos;
    context->enc_bufpos_at_last_block = BufPos;

    return true;
}


#ifdef TRACING

ULONG TracingRunningTotal;
ULONG TracingPrevPos;

void
__stdcall
EncTracingMatch(
    ulong BufPos,
    ulong MatchLength,
    ulong MatchPos,
    ulong MatchOff
    )
    {

    if ( BufPos < TracingPrevPos ) {
        printf( "REWIND to %08X\n", BufPos );
        TracingRunningTotal -= ( TracingPrevPos - BufPos );
        }

    TracingPrevPos = BufPos;

    TracingRunningTotal += MatchLength;
#ifdef TRACING2
    printf(
        "MATCH: At %08X, %c%c Off %08X (%08X), Length %5d, Total %08X\n",
        BufPos,
        MatchPos < 3 ? 'R' : ' ',
        MatchPos < 3 ? MatchPos + '0' : ' ',
        MatchOff,
        BufPos - MatchOff,
        MatchLength,
        TracingRunningTotal
        );
#else
    printf(
        "MATCH: At %08X, From %08X, Length %5d\n",
        BufPos,
        BufPos - MatchOff,
        MatchLength
        );
#endif
    }


void
__stdcall
EncTracingLiteral(
    ulong BufPos,
    ulong ch
    )
    {

    if ( BufPos < TracingPrevPos ) {
        printf( "REWIND to %08X\n", BufPos );
        TracingRunningTotal -= ( TracingPrevPos - BufPos );
        }

    TracingPrevPos = BufPos;

    ++TracingRunningTotal;

#ifdef TRACING2
    printf(
        "LITER: At %08X, 0x%02X                                      Total %08X\n",
        BufPos,
        ch,
        TracingRunningTotal
        );
#else
    printf(
        "LITER: At %08X, 0x%02X\n",
        BufPos,
        ch
        );
#endif
    }

void
__stdcall
EncTracingDefineOffsets(
    unsigned long WindowSize,
    unsigned long InterFileBytes,
    unsigned long OldFileSize
    )
{
}

#endif /* TRACING */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mspatch\lzx\encoder\encdefs.h ===
/*
 * encdefs.h
 *
 * Encoder #define's and structure definitions.
 */

/*
 * NOTES:
 *
 * To maximise compression one can set both BREAK_LENGTH
 * and FAST_DECISION_THRESHOLD to 250, define
 * INSERT_NEAR_LONG_MATCHES, and crank up EXTRA_SIZE to
 * a larger value (don't get too large, otherwise we
 * might overflow our ushort cumbits[]), but the improvement
 * is really  marginal; e.g. 3600 bytes on winword.exe
 * (3.9 MB compressed).  It really hurts performance too.
 */


/*
 * See optenc.c
 *
 * EXTRA_SIZE is the amount of extra data we allocate in addition
 * to the window, and LOOK is the amount of data the optimal
 * parser will look ahead.  LOOK is dependent on EXTRA_SIZE.
 *
 * Changing EXTRA_SIZE to 8K doesn't really do anything for
 * compression.  4K is a fairly optimal value.
 *
 */
#define EXTRA_SIZE   16384
#define LOOK         (EXTRA_SIZE-MAX_MATCH-2)


/*
 * Number of search trees used (for storing root nodes)
 */
#define NUM_SEARCH_TREES 65536


/*
 * Chunk size required by FCI
 */
#define CHUNK_SIZE 32768


/*
 * The maximum amount of data we will allow in our output buffer before
 * calling lzx_output_callback() to get rid of it.  Since we do this
 * for every 32K of input data, the output buffer only has to be able
 * to contain 32K + some spillover, which won't be much, because we
 * output uncompressed blocks if we determine a block is going to be
 * too large.
 */
#define OUTPUT_BUFFER_SIZE (CHUNK_SIZE+MAX_GROWTH)


/*
 * Maximum allowable number of block splits per 32K of uncompressed
 * data; if increased, then MAX_GROWTH will have to be increased also.
 */
#define MAX_BLOCK_SPLITS    4


/*
 * Max growth is calculated as follows:
 *
 * TREE AND BLOCK INFO
 * ===================
 *
 * The very first time the encoder is run, it outputs a 32 bit
 * file translation size.
 *
 * 3 bits to output block type
 * 24 bits for block size in uncompressed bytes.
 *
 * Max size of a tree of n elements is 20*4 + 5*n bits
 *
 * There is a main tree of max 700 elements which is really encoded
 * as two separate trees of 256 and 444(max).  There is also a
 * secondary length tree of 249 elements.
 *
 * That is 1360 bits, plus 2300 bits, plus 1325 bits.
 *
 * There may also be an aligned offset tree, which is 24 bits.
 *
 * Flushing output bit buffer; max 16 bits.
 *
 * Grand total: 5084 bits/block.
 *
 *
 * PARSER INFO
 * ===========
 *
 * Parser worst case scenario is with 2 MB buffer (50 position slots),
 * all matches of length 2, distributed over slots 32 and 33 (since
 * matches of length 2 further away than 128K are prohibited).  These
 * slots have 15 verbatim bits.  Maximum size per code is then
 * 2 bits to say which slot (taking into account that there will be
 * at least another code in the tree) plus 15 verbatim bits, for a
 * total of 17 bits.  Max growth on 32K of input data is therefore
 * 1/16 * 32K, or 2K bytes.
 *
 * Alternatively, if there is only one match and everything else
 * is a character, then 255 characters will be length 8, and one
 * character and the match will be length 9.  Assume the true
 * frequency of the demoted character is almost a 1 in 2^7
 * probability (it got remoted from a 2^8, but it was fairly
 * close to being 2^7).  If there are 32768/256, or 128, occurrences
 * of each character, but, say, almost 256 for the demoted character,
 * then the demoted character will expand the data by less than
 * 1 bit * 256, or 256 bits.  The match will take a little to
 * output, but max growth for "all characters" is about 256 bits.
 *
 *
 * END RESULT
 * ==========
 *
 * The maximum number of blocks which can be output is limited to
 * 4 per 32K of uncompressed data.
 *
 * Therefore, max growth is 4*5084 bits, plus 2K bytes, or 4590
 * bytes.
 */
#define     MAX_GROWTH          6144

/*
 * Don't allow match length 2's which are further away than this
 * (see above)
 */
#define     MAX_LENGTH_TWO_OFFSET (128*1024)


/*
 * When we find a match which is at least this long, prematurely
 * exit the binary search.
 *
 * This avoids us inserting huge match lengths of 257 zeroes, for
 * example.  Compression will improve very *very* marginally by
 * increasing this figure, but it will seriously impact
 * performance.
 *
 * Don't make this number >= (MAX_MATCH-2); see bsearch.c.
 */
#define BREAK_LENGTH 100


/*
 * If this option is defined, the parser will insert all bytes of
 * matches with lengths >= 16 with a distance of 1; this is a bad
 * idea, since matches like that are generally zeroes, which we
 * want to avoid inserting into the search tree.
 */

//#define INSERT_NEAR_LONG_MATCHES


/*
 * If the optimal parser finds a match which is this long or
 * longer, it will take it automatically.  The compression
 * penalty is basically zero, and it helps performance.
 */
#define FAST_DECISION_THRESHOLD 100


/*
 * Every TREE_CREATE_INTERVAL items, recreate the trees from
 * the literals we've encountered so far, to update our cost
 * estimations.
 *
 * 4K seems pretty optimal.
 */
#define TREE_CREATE_INTERVAL 4096


/*
 * When we're forced to break in our parsing (we exceed
 * our span), don't output a match length 2 if it is
 * further away than this.
 *
 * Could make this a variable rather than a constant
 *
 * On a bad binary file, two chars    = 18 bits
 * On a good text file, two chars     = 12 bits
 *
 * But match length two's are very uncommon on text files.
 */
#define BREAK_MAX_LENGTH_TWO_OFFSET 2048


/*
 * When MatchPos >= MPSLOT3_CUTOFF, extra_bits[MP_SLOT(MatchPos)] >= 3
 *
 * matchpos:  0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16
 * extrabits: 0,0,0,0,1,1,1,1,2,2, 2, 2, 2, 2, 2, 2, 3, ...
 *
 * Used for aligned offset blocks and statistics.
 */
#define MPSLOT3_CUTOFF 16


/*
 * Number of elements in the main tree
 */
#define MAIN_TREE_ELEMENTS                      (NUM_CHARS+(((long) context->enc_num_position_slots) << NL_SHIFT))


/*
 * Max number of literals to hold.
 *
 * Memory required is MAX_LITERAL_ITEMS for enc_LitData[] array,
 * plus MAX_LITERAL_ITEMS/8 for enc_ItemType[] array.
 *
 * Must not exceed 64K, since that will cause our ushort
 * frequencies to overflow.
 */
#define MAX_LITERAL_ITEMS  65536


/*
 * Max number of distances to hold
 *
 * Memory required is MAX_DIST_ITEMS*4 for enc_DistData[] array
 *
 * MAX_DIST_ITEMS should never be greater than MAX_LITERAL_ITEMS,
 * since that just wastes space.
 *
 * However, it's extremely unlikely that one will get 65536 match
 * length 2's!  In any case, the literal and distance buffers
 * are checked independently, and a block is output if either
 * overflows.
 *
 * Bitmaps are highly redundant, though; lots of matches.
 */
#define MAX_DIST_ITEMS     32768
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mspatch\lzx\encoder\encmacro.h ===
/*
 * encmacro.h
 *
 * Encoder macros
 */


/*
 * Returns the slot number of a match position (uses table lookup) 
 */
#define MP_SLOT(matchpos) \
   ((matchpos) < 1024 ?										\
		context->enc_slot_table[(matchpos)] :					\
			( (matchpos) < 524288L ?						\
				(18 + context->enc_slot_table[(matchpos) >> 9]) :   \
				(34 + ((matchpos) >> 17))		\
		)													\
   )


/*
 * Is a given literal a match or an unmatched symbol?
 */
#define IsMatch(literal) (context->enc_ItemType[(literal) >> 3] & (1 << ((literal) & 7)))
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mspatch\lzx\encoder\encoder.h ===
/*
 * encoder.h
 *
 * Main header file; includes everything else
 */

#ifndef ENCODER_H
#define ENCODER_H


#ifdef USE_ASSEMBLY
#   define ASM_BSEARCH_FINDMATCH
//#   define ASM_QUICK_INSERT_BSEARCH_FINDMATCH
#endif

#ifndef UNALIGNED
#ifndef NEEDS_ALIGNMENT
#define UNALIGNED
#else
#define UNALIGNED __unaligned
#endif
#endif

#include <stdlib.h>
#include <string.h>

#ifndef ASSERT

    #if defined( DEBUG ) || defined( DBG ) || defined( TESTCODE )

        int
        __stdcall
        Assert(
            const char *szText,
            const char *szFile,
            unsigned    uLine
            );

        #define ASSERT( a ) (( a ) ? 1 : Assert( #a, __FILE__, __LINE__ ))

    #else

        #define ASSERT( a )

    #endif

#endif // ASSERT

#ifndef _ASSERTE

    #define _ASSERTE( a ) ASSERT( a )

#endif

#include "../common/typedefs.h"
#include "../common/compdefs.h"
#include "encdefs.h"
#include "encvars.h"
#include "encmacro.h"
#include "encapi.h"
#include "encproto.h"

#endif  /* ENCODER_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mspatch\lzx\encoder\encapi.h ===
/*
 * encapi.h
 *
 * Definitions for calling LZX apis (encapi.c)
 */

/*
 * Return codes for LZX_Encode()
 */
#define ENCODER_SUCCESS         0
#define ENCODER_READ_FAILURE    1
#define ENCODER_WRITE_FAILURE   2
#define ENCODER_CONSOLE_FAILURE 3

bool
__fastcall
LZX_EncodeInit(
    t_encoder_context **  enc_context,
    long                  compression_window_size,
    long                  second_partition_size,
    PFNALLOC              pfnma,
    HANDLE                hAllocator,
    int (__stdcall * pfnlzx_output_callback)(
        void *            pfol,
        unsigned char *   compressed_data,
        long              compressed_size,
        long              uncompressed_size
        ),
    void *                fci_data
    );

void __fastcall LZX_EncodeNewGroup(t_encoder_context *context);

long __fastcall LZX_Encode(
        t_encoder_context *     context,
        byte *                  input_data,
        long                    input_size,
        long *                  bytes_compressed,
        long                    file_size_for_translation
);

bool __fastcall LZX_EncodeFlush(t_encoder_context *context);

bool __fastcall LZX_EncodeResetState(t_encoder_context *context);

unsigned char * __fastcall LZX_GetInputData(
    t_encoder_context *context,
    unsigned long *input_position,
    unsigned long *bytes_available
);

bool __fastcall LZX_EncodeInsertDictionary(
                       t_encoder_context *context,
                       byte *             input_data,
                       unsigned long      input_size
                       );


#ifdef TRACING

#include <stdio.h>

void
__stdcall
EncTracingMatch(
    unsigned long BufPos,
    unsigned long MatchLength,
    unsigned long MatchPos,
    unsigned long MatchOff
    );

void
__stdcall
EncTracingLiteral(
    unsigned long BufPos,
    unsigned long ch
    );

void
__stdcall
EncTracingDefineOffsets(
    unsigned long WindowSize,
    unsigned long InterFileBytes,
    unsigned long OldFileSize
    );

#endif /* TRACING */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mspatch\lzx\encoder\encdata.c ===
/*
 * encdata.c
 *
 * Encode a block into the output stream
 */

#include "encoder.h"

/*
 * Macro to output bits into the encoding stream
 */

#define OUTPUT_BITS(N,X) output_bits( context, (N), (X))

void output_bits( t_encoder_context *context, ulong numbits, ulong value ) {

    context->enc_bitbuf   |= ( value << ( context->enc_bitcount - numbits ));
    context->enc_bitcount -= (char)numbits;

    while ( context->enc_bitcount <= 16 ) {

        if ( context->enc_output_buffer_curpos >= context->enc_output_buffer_end ) {
             context->enc_output_buffer_curpos = context->enc_output_buffer_start;
             context->enc_output_overflow = true;
             }

        *context->enc_output_buffer_curpos++ = (byte)( context->enc_bitbuf >> 16 );
        *context->enc_output_buffer_curpos++ = (byte)( context->enc_bitbuf >> 24 );

        context->enc_bitbuf  <<= 16;
        context->enc_bitcount += 16;
        }
    }


#ifdef EXTRALONGMATCHES

#define OUTPUT_EXTRA_LENGTH(X) output_extra_length( context, (X))

void output_extra_length( t_encoder_context *context, ulong ExtraLength ) {

    //
    //  Extra match length is encoded like this:
    //
    //      0xxxxxxxx          (8-bit value)
    //      10xxxxxxxxxx       (10-bit value plus 2^8)
    //      110xxxxxxxxxxxx    (12-bit value plus 2^8 plus 2^10)
    //      111xxxxxxxxxxxxxxx (15-bit value)
    //
    //  15 bits is the largest possible because a match cannot
    //  span a 32K boundary.
    //

    ulong EncodingValue = ExtraLength;

    ASSERT( ExtraLength < 32768 );

    if ( EncodingValue < ( 1 << 8 )) {
        OUTPUT_BITS( 9, EncodingValue );
        }
    else {

        EncodingValue -= ( 1 << 8 );

        if ( EncodingValue < ( 1 << 10 )) {
            OUTPUT_BITS( 12, (( 1 << 11 ) | EncodingValue ));
            }

        else {

            EncodingValue -= ( 1 << 10 );

            if ( EncodingValue < ( 1 << 12 )) {
                OUTPUT_BITS( 15, (( 1 << 14 ) | ( 1 << 13 ) | EncodingValue ));
                }

            else {
                OUTPUT_BITS( 3, 7 );    // can't OUTPUT_BITS more than 16 per call
                OUTPUT_BITS( 15, ExtraLength );
                }
            }
        }
    }

#endif /* EXTRALONGMATCHES */


/*
 * Given the initial state of the repeated offset buffers at
 * the beginning of this block, calculate the final state of the
 * repeated offset buffers after outputting this block as if it
 * were compressed data.
 *
 * First try to do it the quick way, by starting at the last
 * match and working backwards, to find three consecutive matches
 * which don't use repeated offsets.  If this fails, we'll have
 * to take the initial state of the three offsets at the beginning
 * of the block, and evolve them to the end of the block.
 */
void get_final_repeated_offset_states(t_encoder_context *context, ulong distances)
{
    ulong                   MatchPos;
    signed long             d; /* must be signed */
    byte                    consecutive;

    consecutive = 0;

    for (d = distances-1; d >= 0; d--)
        {
        if (context->enc_DistData[d] > 2)
            {
            /* NOT a repeated offset */
            consecutive++;

            /* do we have three consecutive non-repeated-offsets? */
            if (consecutive >= 3)
                break;
            }
        else
            {
            consecutive = 0;
            }
        }

    /*
     * If we didn't find three consecutive matches which
     * don't use repeated offsets, then we have to start
     * from the beginning and evolve the repeated offsets.
     *
     * Otherwise, we start at the first of the consecutive
     * matches.
     */
    if (consecutive < 3)
        {
        d = 0;
        }

    for (; d < (signed long) distances; d++)
        {
        MatchPos = context->enc_DistData[d];

        if (MatchPos == 0)
            {
            }
        else if (MatchPos <= 2)
            {
            ulong   temp;

            temp = context->enc_repeated_offset_at_literal_zero[MatchPos];
            context->enc_repeated_offset_at_literal_zero[MatchPos] = context->enc_repeated_offset_at_literal_zero[0];
            context->enc_repeated_offset_at_literal_zero[0] = temp;
            }
        else
            {
            context->enc_repeated_offset_at_literal_zero[2] = context->enc_repeated_offset_at_literal_zero[1];
            context->enc_repeated_offset_at_literal_zero[1] = context->enc_repeated_offset_at_literal_zero[0];
            context->enc_repeated_offset_at_literal_zero[0] = MatchPos-2;
            }
        }
}


/*
 * Encode a block with no compression
 *
 * bufpos is the position in the file from which the first
 * literal in this block starts.  To reference memory, we will
 * use enc_MemWindow[bufpos] (remember that enc_MemWindow is
 * moved backwards every time we copymem).
 *
 * Since this data was originally matched into the compressor,
 * our recent match offsets will have been changed; however,
 * since this is an uncompressed block, the decoder won't be
 * updating them.  Therefore, we need to tell the decoder
 * the state of the match offsets after it has finished
 * decoding the uncompressed data - we store these in this
 * block.
 */
void encode_uncompressed_block(t_encoder_context *context, ulong bufpos, ulong block_size)
{
    int     i;
    int     j;
    bool    block_size_odd;
    ulong   val;

    /*
     * Align on a byte boundary
     */
    output_bits(context, context->enc_bitcount-16, 0);

    /*
     * Now output the contents of the repeated offset
     * buffers, since we need to preserve the state of
     * the encoder
     */
    for (i = 0; i < NUM_REPEATED_OFFSETS; i++)
        {
        val = context->enc_repeated_offset_at_literal_zero[i];

        for (j = 0; j < sizeof(long); j++)
            {
            *context->enc_output_buffer_curpos++ = (byte) val;
            val >>= 8;
            }
        }

    block_size_odd = block_size & 1;

    /*
     * Write out uncompressed data
     */
    while (block_size > 0)
        {
        *context->enc_output_buffer_curpos++ = context->enc_MemWindow[bufpos];

        bufpos++;
        block_size--;
        context->enc_input_running_total++;

        if (context->enc_input_running_total == CHUNK_SIZE)
            {
            perform_flush_output_callback(context);
            context->enc_num_block_splits = 0;
            }
        }

    /*
     * Add pad byte to keep the output word-aligned
     */
    if (block_size_odd)
        {
        *context->enc_output_buffer_curpos++ = 0;
        }

    context->enc_bitcount   = 32;
    context->enc_bitbuf     = 0;
}


/*
 * Estimate the size of the data in the buffer, in bytes
 */
ulong estimate_compressed_block_size(t_encoder_context *context)
{
    ulong                   block_size = 0; /* output size in bits */
    ulong                   i;
    ulong                   mpslot;

    /* Estimation of tree size */
    block_size = 150*8;

    /* Tally bits to output characters */
    for (i = 0; i < NUM_CHARS; i++)
        block_size += (context->enc_main_tree_len[i]*context->enc_main_tree_freq[i]);

    /* Tally bits to output matches */
    for (mpslot = 0; mpslot < context->enc_num_position_slots; mpslot++)
        {
        long    element;
        int             primary;

        element = NUM_CHARS + (mpslot << NL_SHIFT);

        /* For primary == NUM_PRIMARY_LENGTHS we have secondary lengths */
        for (primary = 0; primary <= NUM_PRIMARY_LENGTHS; primary++)
            {
            block_size += ((context->enc_main_tree_len[element] + enc_extra_bits[mpslot]) *
                           context->enc_main_tree_freq[element]);
            element++;
            }
        }

    for (i = 0; i < NUM_SECONDARY_LENGTHS; i++)
        block_size += (context->enc_secondary_tree_freq[i] * context->enc_secondary_tree_len[i]);

    /* round up */
    return (block_size+7) >> 3;
}

/*
 * Encode block with NO special encoding of the lower 3
 * position bits
 */
void encode_verbatim_block(t_encoder_context *context, ulong literal_to_end_at)
{
    ulong           MatchPos;
    ulong           d = 0;
    ulong           l = 0;
    ulong           MatchLength;
    byte            c;
    ulong           mpSlot;

    for ( l = 0; l < literal_to_end_at; l++ ) {

        if (!IsMatch(l))
            {
            c = context->enc_LitData[l];
            OUTPUT_BITS(context->enc_main_tree_len[c], context->enc_main_tree_code[c]);
            context->enc_input_running_total++;
            }
        else
            {
            /* Note, 0 means MatchLen=3, 1 means MatchLen=4, ... */
            MatchLength = context->enc_LitData[l];

            /* Delta match pos */
            MatchPos = context->enc_DistData[d++];

            mpSlot = MP_SLOT(MatchPos);

            if (MatchLength < NUM_PRIMARY_LENGTHS)
                {
                OUTPUT_BITS(
                           context->enc_main_tree_len[ NUM_CHARS+(mpSlot<<NL_SHIFT)+MatchLength],
                           context->enc_main_tree_code[NUM_CHARS+(mpSlot<<NL_SHIFT)+MatchLength]
                           );
                }
            else
                {
                OUTPUT_BITS(
                           context->enc_main_tree_len [(NUM_CHARS+NUM_PRIMARY_LENGTHS)+(mpSlot<<NL_SHIFT)],
                           context->enc_main_tree_code[(NUM_CHARS+NUM_PRIMARY_LENGTHS)+(mpSlot<<NL_SHIFT)]
                           );

                OUTPUT_BITS(
                           context->enc_secondary_tree_len[ MatchLength - NUM_PRIMARY_LENGTHS],
                           context->enc_secondary_tree_code[MatchLength - NUM_PRIMARY_LENGTHS]
                           );
                }

            if (enc_extra_bits[ mpSlot ])
                {
                OUTPUT_BITS(
                           enc_extra_bits[mpSlot],
                           MatchPos & enc_slot_mask[mpSlot]
                           );
                }

#ifdef EXTRALONGMATCHES

            if ( MatchLength == ( MAX_MATCH - MIN_MATCH )) {
                MatchLength += context->enc_ExtraLength[ l ];
                OUTPUT_EXTRA_LENGTH( context->enc_ExtraLength[ l ] );
                }
#endif

            context->enc_input_running_total += (MatchLength+MIN_MATCH);
            }

        _ASSERTE (context->enc_input_running_total <= CHUNK_SIZE);

        if (context->enc_input_running_total == CHUNK_SIZE)
            {
            perform_flush_output_callback(context);
            context->enc_num_block_splits = 0;
            }

        _ASSERTE (context->enc_input_running_total < CHUNK_SIZE);
        }
}


/*
 * aligned block encoding
 */
void encode_aligned_block(t_encoder_context *context, ulong literal_to_end_at)
{
    ulong   MatchPos;
    ulong   MatchLength;
    byte    c;
    ulong   mpSlot;
    byte    Lower;
    ulong   l = 0;
    ulong   d = 0;

    for ( l = 0; l < literal_to_end_at; l++ ) {

        if (!IsMatch(l))
            {
            c = context->enc_LitData[l];
            OUTPUT_BITS(context->enc_main_tree_len[c], context->enc_main_tree_code[c]);
            context->enc_input_running_total++;
            }
        else
            {
            /* Note, 0 means MatchLen=3, 1 means MatchLen=4, ... */
            MatchLength = context->enc_LitData[l];

            /* Delta match pos */
            MatchPos = context->enc_DistData[d++];

            mpSlot = MP_SLOT(MatchPos);

            if (MatchLength < NUM_PRIMARY_LENGTHS)
                {
                OUTPUT_BITS(
                           context->enc_main_tree_len[ NUM_CHARS+(mpSlot<<NL_SHIFT)+MatchLength],
                           context->enc_main_tree_code[NUM_CHARS+(mpSlot<<NL_SHIFT)+MatchLength]
                           );
                }
            else
                {
                OUTPUT_BITS(
                           context->enc_main_tree_len[ (NUM_CHARS+NUM_PRIMARY_LENGTHS)+(mpSlot<<NL_SHIFT)],
                           context->enc_main_tree_code[(NUM_CHARS+NUM_PRIMARY_LENGTHS)+(mpSlot<<NL_SHIFT)]
                           );

                OUTPUT_BITS(
                           context->enc_secondary_tree_len[ MatchLength - NUM_PRIMARY_LENGTHS],
                           context->enc_secondary_tree_code[MatchLength - NUM_PRIMARY_LENGTHS]
                           );
                }

            if (enc_extra_bits[ mpSlot ] >= 3)
                {
                if (enc_extra_bits[ mpSlot ] > 3)
                    {
                    OUTPUT_BITS(
                               enc_extra_bits[mpSlot] - 3,
                               (MatchPos >> 3) & ( (1 << (enc_extra_bits[mpSlot]-3)) -1)
                               );
                    }

                Lower = (byte) (MatchPos & 7);

                OUTPUT_BITS(
                           context->enc_aligned_tree_len[Lower],
                           context->enc_aligned_tree_code[Lower]
                           );
                }
            else if (enc_extra_bits[ mpSlot ])
                {
                OUTPUT_BITS(
                           enc_extra_bits[mpSlot],
                           MatchPos & enc_slot_mask[ mpSlot ]
                           );
                }

#ifdef EXTRALONGMATCHES

            if ( MatchLength == ( MAX_MATCH - MIN_MATCH )) {
                MatchLength += context->enc_ExtraLength[ l ];
                OUTPUT_EXTRA_LENGTH( context->enc_ExtraLength[ l ] );
                }
#endif

            context->enc_input_running_total += (MatchLength+MIN_MATCH);
            }

        _ASSERTE (context->enc_input_running_total <= CHUNK_SIZE);

        if (context->enc_input_running_total == CHUNK_SIZE)
            {
            perform_flush_output_callback(context);
            context->enc_num_block_splits = 0;
            }

        _ASSERTE (context->enc_input_running_total < CHUNK_SIZE);
        }
}


void perform_flush_output_callback(t_encoder_context *context)
{
    long    output_size;

    /*
     * Do this only if there is any input to account for, so we don't
     * end up outputting blocks where comp_size > 0 and uncmp_size = 0.
     */
    if (context->enc_input_running_total > 0)
        {
        flush_output_bit_buffer(context);

        output_size = (ulong)(context->enc_output_buffer_curpos - context->enc_output_buffer_start);

        if (output_size > 0)
            {
            (*context->enc_output_callback_function)(
                                                    context->enc_fci_data,
                                                    context->enc_output_buffer_start,
                                                    (ulong)(context->enc_output_buffer_curpos - context->enc_output_buffer_start),
                                                    context->enc_input_running_total
                                                    );
            }
        }

    context->enc_input_running_total = 0;
    context->enc_output_buffer_curpos = context->enc_output_buffer_start;

    /* initialise bit buffer */
    context->enc_bitcount = 32;
    context->enc_bitbuf   = 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mspatch\lzx\encoder\encproto.h ===
/*
 * encproto.h
 *
 * Encoder function prototypes
 */

/* blkinit.c */
void create_slot_lookup_table(t_encoder_context *context);
void create_ones_table(t_encoder_context *context);

/* block.c */
void output_block(t_encoder_context *context);
void flush_output_bit_buffer(t_encoder_context *context);
long estimate_buffer_contents(t_encoder_context *context);
ulong get_distances_from_literals(t_encoder_context *context, ulong literals);

/* bsearch.c */
long binary_search_findmatch(t_encoder_context *context, long BufPos);
void quick_insert_bsearch_findmatch(t_encoder_context *context, long BufPos, long endpos);
void binary_search_remove_node(t_encoder_context *context, long BufPos, ulong end_pos);

/* encdata.c */
void output_bits( t_encoder_context *context, ulong numbits, ulong value );
void encode_verbatim_block(t_encoder_context *context, ulong literal_to_end_at);
void encode_aligned_block(t_encoder_context *context, ulong literal_to_end_at);
void encode_uncompressed_block(t_encoder_context *context, ulong bufpos, ulong block_size);
void perform_flush_output_callback(t_encoder_context *context);
ulong estimate_compressed_block_size(t_encoder_context *context);
void get_final_repeated_offset_states(t_encoder_context *context, ulong distances);

/* encstats.c */
lzx_block_type get_aligned_stats(t_encoder_context *context, ulong dist_to_end_at);

ulong get_block_stats(
        t_encoder_context *context,
        ulong literal_to_start_at,
        ulong distance_to_start_at,
        ulong literal_to_end_at
);

ulong update_cumulative_block_stats(
        t_encoder_context *context,
        ulong literal_to_start_at,
        ulong distance_to_start_at,
        ulong literal_to_end_at
);

bool split_block(
        t_encoder_context *context,
        ulong literal_to_start_at,
        ulong literal_to_end_at,
        ulong distance_to_end_at,
        ulong *split_at_literal,
        ulong *split_at_distance
);

/* enctree.c */
void create_trees(t_encoder_context *context, bool generate_codes);
void fix_tree_cost_estimates(t_encoder_context *context);
void encode_trees(t_encoder_context *context);
void encode_aligned_tree(t_encoder_context *context);
void prevent_far_matches(t_encoder_context *context);

/* init.c */
void init_compression_memory(t_encoder_context *context);
bool comp_alloc_compress_memory(t_encoder_context *context);

/* io.c */
bool init_compressed_output_buffer(t_encoder_context *context);
void flush_compressed_output_buffer(t_encoder_context *context);
void reset_translation(t_encoder_context *context);
long comp_read_input(t_encoder_context *context, ulong BufPos, long Size);

/* optenc.c */
void opt_encode_top(t_encoder_context *context, long BytesRead);
void reset_encoder_variables(t_encoder_context *context);
void flush_all_pending_blocks(t_encoder_context *context);
void encoder_start(t_encoder_context *context);

void make_tree(
        t_encoder_context *context,
        int             nparm,
        ushort  *freqparm,
        byte    *lenparm,
        ushort  *codeparm,
        bool    make_codes
);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mspatch\lzx\encoder\encstats.c ===
/*
 * encstats.c
 *
 * Routines for calculating statistics on a block of data which
 * has been compressed, but not yet output.
 *
 * These routines are used to determine which encoding method to use
 * to output the block.
 */

#include "encoder.h"



static void tally_aligned_bits(t_encoder_context *context, ulong dist_to_end_at)
{
        ulong   *dist_ptr;
        ulong   i;
        ulong   match_pos;

        /*
     * Tally the lower 3 bits
     */
        dist_ptr = context->enc_DistData;

        for (i = dist_to_end_at; i > 0; i--)
        {
                match_pos = *dist_ptr++;

                /*
                 * Only for matches which have >= 3 extra bits
                 */
                if (match_pos >= MPSLOT3_CUTOFF)
                        context->enc_aligned_tree_freq[match_pos & 7]++;
        }
}


/*
 * Determine whether it is advantageous to use aligned block
 * encoding on the block.
 */
lzx_block_type get_aligned_stats(t_encoder_context *context, ulong dist_to_end_at)
{
        byte            i;
        ulong           total_L3 = 0;
        ulong           largest_L3 = 0;

        memset(
                context->enc_aligned_tree_freq,
                0,
                ALIGNED_NUM_ELEMENTS * sizeof(context->enc_aligned_tree_freq[0])
        );

        tally_aligned_bits(context, dist_to_end_at);

        for (i = 0; i < ALIGNED_NUM_ELEMENTS; i++)
        {
                if (context->enc_aligned_tree_freq[i] > largest_L3)
                        largest_L3 = context->enc_aligned_tree_freq[i];

                total_L3 += context->enc_aligned_tree_freq[i];
        }

        /*
         * Do aligned offsets if the largest frequency accounts for 20%
         * or more (as opposed to 12.5% for non-aligned offset blocks).
         *
         * Not worthwhile to do aligned offsets if we have < 100 matches
         */
        if ((largest_L3 > total_L3/5) && dist_to_end_at >= 100)
                return BLOCKTYPE_ALIGNED;
        else
                return BLOCKTYPE_VERBATIM;
}


/*
 * Calculates the frequency of each literal, and returns the total
 * number of uncompressed bytes compressed in the block.
 */
static ulong tally_frequency(
        t_encoder_context *context,
        ulong literal_to_start_at,
        ulong distance_to_start_at,
        ulong literal_to_end_at
)
{
        ulong   i;
        ulong   d;
        ulong   compressed_bytes = 0;

        d = distance_to_start_at;

        for (i = literal_to_start_at; i < literal_to_end_at; i++)
        {
                if (!IsMatch(i))
                {
                        /* Uncompressed symbol */
                        context->enc_main_tree_freq[context->enc_LitData[i]]++;
                        compressed_bytes++;
                }
                else
                {
                        /* Match */
                        if (context->enc_LitData[i] < NUM_PRIMARY_LENGTHS)
                        {
                                context->enc_main_tree_freq[ NUM_CHARS + (MP_SLOT(context->enc_DistData[d])<<NL_SHIFT) + context->enc_LitData[i]] ++;
                        }
                        else
                        {
                                context->enc_main_tree_freq[ (NUM_CHARS + NUM_PRIMARY_LENGTHS) + (MP_SLOT(context->enc_DistData[d])<<NL_SHIFT)] ++;
                                context->enc_secondary_tree_freq[context->enc_LitData[i] - NUM_PRIMARY_LENGTHS] ++;
                        }

                        compressed_bytes += context->enc_LitData[i]+MIN_MATCH;

#ifdef EXTRALONGMATCHES
                        if (( context->enc_LitData[ i ] + MIN_MATCH ) == MAX_MATCH ) {
                            compressed_bytes += context->enc_ExtraLength[ i ];
                            }
#endif

                        d++;
                }
        }

        return compressed_bytes;
}


/*
 * Get statistics
 */
ulong get_block_stats(
        t_encoder_context *context,
        ulong literal_to_start_at,
        ulong distance_to_start_at,
        ulong literal_to_end_at
)
{
        memset(
                context->enc_main_tree_freq,
                0,
                MAIN_TREE_ELEMENTS * sizeof(context->enc_main_tree_freq[0])
        );

        memset(
                context->enc_secondary_tree_freq,
                0,
                NUM_SECONDARY_LENGTHS * sizeof(context->enc_secondary_tree_freq[0])
        );

        return tally_frequency(
                context,
                literal_to_start_at,
                distance_to_start_at,
                literal_to_end_at
        );
}


/*
 * Update cumulative statistics
 */
ulong update_cumulative_block_stats(
        t_encoder_context *context,
        ulong literal_to_start_at,
        ulong distance_to_start_at,
        ulong literal_to_end_at
)
{
        return tally_frequency(
                context,
                literal_to_start_at,
                distance_to_start_at,
                literal_to_end_at
        );
}



/*
 * Used in block splitting
 *
 * This routine calculates the "difference in composition" between
 * two different sections of compressed data.
 *
 * Resolution must be evenly divisible by STEP_SIZE, and must be
 * a power of 2.
 */
#define RESOLUTION                              1024

/*
 * Threshold for determining if two blocks are different
 *
 * If enough consecutive blocks are this different, the block
 * splitter will start investigating, narrowing down the
 * area where the change occurs.
 *
 * It will then look for two areas which are
 * EARLY_BREAK_THRESHOLD (or more) different.
 *
 * If THRESHOLD is too small, it will force examination
 * of a lot of blocks, slowing down the compressor.
 *
 * The EARLY_BREAK_THRESHOLD is the more important value.
 */
#define THRESHOLD                               1400

/*
 * Threshold for determining if two blocks are REALLY different
 */
#define EARLY_BREAK_THRESHOLD   1700

/*
 * Must be >= 8 because ItemType[] array is in bits
 *
 * Must be a power of 2.
 *
 * This is the step size used to narrow down the exact
 * best point to split the block.
 */
#define STEP_SIZE               64

/*
 * Minimum # literals required to perform block
 * splitting at all.
 */
#define MIN_LITERALS_REQUIRED   6144

/*
 * Minimum # literals we will allow to be its own block.
 *
 * We don't want to create blocks with too small numbers
 * of literals, otherwise the static tree output will
 * take up too much space.
 */
#define MIN_LITERALS_IN_BLOCK   4096


static const long square_table[17] =
{
        0,1,4,9,16,25,36,49,64,81,100,121,144,169,196,225,256
};


/*
 * log2(x) = x < 256 ? log2_table[x] : 8 + log2_table[(x >> 8)]
 *
 * log2(0)   = 0
 * log2(1)   = 1
 * log2(2)   = 2
 * log2(3)   = 2
 * log2(4)   = 3
 * log2(255) = 8
 * log2(256) = 9
 * log2(511) = 9
 * log2(512) = 10
 *
 * It's not a real log2; it's off by one because we have
 * log2(0) = 0.
 */
static const byte log2_table[256] =
{
        0,1,2,2,3,3,3,3,
        4,4,4,4,4,4,4,4,
        5,5,5,5,5,5,5,5,
        5,5,5,5,5,5,5,5,
        6,6,6,6,6,6,6,6,
        6,6,6,6,6,6,6,6,
        6,6,6,6,6,6,6,6,
        6,6,6,6,6,6,6,6,
        7,7,7,7,7,7,7,7,
        7,7,7,7,7,7,7,7,
        7,7,7,7,7,7,7,7,
        7,7,7,7,7,7,7,7,
        7,7,7,7,7,7,7,7,
        7,7,7,7,7,7,7,7,
        7,7,7,7,7,7,7,7,
        7,7,7,7,7,7,7,7,
        8,8,8,8,8,8,8,8,
        8,8,8,8,8,8,8,8,
        8,8,8,8,8,8,8,8,
        8,8,8,8,8,8,8,8,
        8,8,8,8,8,8,8,8,
        8,8,8,8,8,8,8,8,
        8,8,8,8,8,8,8,8,
        8,8,8,8,8,8,8,8,
        8,8,8,8,8,8,8,8,
        8,8,8,8,8,8,8,8,
        8,8,8,8,8,8,8,8,
        8,8,8,8,8,8,8,8,
        8,8,8,8,8,8,8,8,
        8,8,8,8,8,8,8,8,
        8,8,8,8,8,8,8,8,
        8,8,8,8,8,8,8,8
};


/*
 * Return the difference between two sets of matches/distances
 */
static ulong return_difference(
        t_encoder_context *context,
        ulong item_start1,
        ulong item_start2,
        ulong dist_at_1,
        ulong dist_at_2,
        ulong size
)
{
        ushort  freq1[800];
        ushort  freq2[800];
        ulong   i;
        ulong   cum_diff;
        int             element;

        /*
         * Error!  Too many main tree elements
         */
        if (MAIN_TREE_ELEMENTS >= (sizeof(freq1)/sizeof(freq1[0])))
                return 0;

        memset(freq1, 0, sizeof(freq1[0])*MAIN_TREE_ELEMENTS);
        memset(freq2, 0, sizeof(freq2[0])*MAIN_TREE_ELEMENTS);

        for (i = 0; i < size; i++)
        {
                if (!IsMatch(item_start1))
                {
                        element = context->enc_LitData[item_start1];
                }
                else
                {
                        if (context->enc_LitData[item_start1] < NUM_PRIMARY_LENGTHS)
                                element = NUM_CHARS + (MP_SLOT(context->enc_DistData[dist_at_1])<<NL_SHIFT) + context->enc_LitData[item_start1];
                        else
                                element = (NUM_CHARS + NUM_PRIMARY_LENGTHS) + (MP_SLOT(context->enc_DistData[dist_at_1]) << NL_SHIFT);

                        dist_at_1++;
                }

                item_start1++;
                freq1[element]++;

                if (!IsMatch(item_start2))
                {
                        element = context->enc_LitData[item_start2];
                }
                else
                {
                        if (context->enc_LitData[item_start2] < NUM_PRIMARY_LENGTHS)
                                element = NUM_CHARS + (MP_SLOT(context->enc_DistData[dist_at_2])<<NL_SHIFT) + context->enc_LitData[item_start2];
                        else
                                element = (NUM_CHARS + NUM_PRIMARY_LENGTHS) + (MP_SLOT(context->enc_DistData[dist_at_2]) << NL_SHIFT);

                        dist_at_2++;
                }

                item_start2++;
                freq2[element]++;
        }

        cum_diff = 0;

        for (i = 0; i < (ulong) MAIN_TREE_ELEMENTS; i++)
        {
                ulong log2a, log2b, diff;

#define log2(x) ((x) < 256 ? log2_table[(x)] : 8+log2_table[(x) >> 8])

                log2a = (ulong) log2(freq1[i]);
                log2b = (ulong) log2(freq2[i]);

                /* diff = (log2a*log2a) - (log2b*log2b); */
                diff = square_table[log2a] - square_table[log2b];

                cum_diff += abs(diff);
        }

        return cum_diff;
}


/*
 * Calculates where and if a block of compressed data should be split.
 *
 * For example, if we have just compressed text data, audio data, and
 * more text data, then the composition of matches and unmatched
 * symbols will be different between the text data and audio data.
 * Therefore we force an end of block whenever the compressed data
 * looks like it's changing in composition.
 *
 * This routine currently cannot tell the difference between blocks
 * which should use aligned offsets, and blocks which should not.
 * However, there is little to be gained from looking for this change,
 * since it the match finder doesn't make an effort to look for
 * aligned offsets either.
 *
 * Returns whether we split the block or not.
 */
bool split_block(
        t_encoder_context *context,
        ulong literal_to_start_at,
        ulong literal_to_end_at,
        ulong distance_to_end_at,       /* corresponds to # distances at literal_to_end_at */
        ulong *split_at_literal,
        ulong *split_at_distance        /* optional parameter (may be NULL) */
)
{
        ulong   i, j, d;
        int             nd;

        /*
         * num_dist_at_item[n] equals the cumulative number of matches
         * at literal "n / STEP_SIZE".
         */
        ushort  num_dist_at_item[(MAX_LITERAL_ITEMS/STEP_SIZE)+8]; /* +8 is slop */

        /*
         * default return
         */
        *split_at_literal       = literal_to_end_at;

        if (split_at_distance)
                *split_at_distance      = distance_to_end_at;

        /* Not worth doing if we don't have many literals */
        if (literal_to_end_at - literal_to_start_at < MIN_LITERALS_REQUIRED)
                return false;

    /* Not allowed to split blocks any more, so we don't overflow MAX_GROWTH? */
    if (context->enc_num_block_splits >= MAX_BLOCK_SPLITS)
        return false;

        /*
         * Keep track of the number of distances (matches) we've had,
         * at each step of STEP_SIZE literals.
         *
         * Look at 8 items at a time, and ignore the last
         * 0..7 items if they exist.
         */
        nd = 0;
        d = 0;

        for (i = 0; i < (literal_to_end_at >> 3); i++)
        {
                /*
                 * if (i % (STEP_SIZE >> 3)) == 0
                 */
                if ((i & ((STEP_SIZE >> 3)-1)) == 0)
                        num_dist_at_item[nd++] = (ushort) d;

                d += context->enc_ones[ context->enc_ItemType[i] ];
        }

        /*
         * Must be a multiple of STEP_SIZE
         */
        literal_to_start_at = (literal_to_start_at + (STEP_SIZE-1)) & (~(STEP_SIZE-1));

        /*
         * See where the change in composition occurs
         */
        for (   i = literal_to_start_at + 2*RESOLUTION;
                        i < literal_to_end_at - 4*RESOLUTION;
                        i += RESOLUTION)
        {
                /*
                 * If there appears to be a significant variance in composition
                 * between
                 *                    ___________
                 *                   /           \
                 *                A  B  i     X  Y  Z
                 *                \      \___/      /
                 *                 \_______________/
                 */
                if (
                        return_difference(
                                context,
                                i,
                                i+1*RESOLUTION,
                                (ulong) num_dist_at_item[i/STEP_SIZE],
                                (ulong) num_dist_at_item[(i+1*RESOLUTION)/STEP_SIZE],
                                RESOLUTION) > THRESHOLD
                        &&

                        return_difference(
                                context,
                                i-RESOLUTION,
                                i+2*RESOLUTION,
                                (ulong) num_dist_at_item[(i-RESOLUTION)/STEP_SIZE],
                                (ulong) num_dist_at_item[(i+2*RESOLUTION)/STEP_SIZE],
                                RESOLUTION) > THRESHOLD

                        &&

                        return_difference(
                                context,
                                i-2*RESOLUTION,
                                i+3*RESOLUTION,
                                (ulong) num_dist_at_item[(i-2*RESOLUTION)/STEP_SIZE],
                                (ulong) num_dist_at_item[(i+3*RESOLUTION)/STEP_SIZE],
                                RESOLUTION) > THRESHOLD
                        )
                {
                        ulong max_diff = 0;
                        ulong literal_split = 0;

                        /*
                         * Narrow down the best place to split block
                         *
                         * This really could be done much better; we could end up
                         * doing a lot of stepping;
                         *
                         * basically ((5/2 - 1/2) * RESOLUTION) / STEP_SIZE
                         *
                         * which is (2 * RESOLUTION) / STEP_SIZE,
                         * which with RESOLUTION = 1024 and STEP_SIZE = 32,
                         * equals 2048/32 = 64 steps.
                         */
                        for (j = i+RESOLUTION/2; j<i+(5*RESOLUTION)/2; j += STEP_SIZE)
                        {
                                ulong   diff;

                                diff = return_difference(
                                        context,
                                        j - RESOLUTION,
                                        j,
                                        (ulong) num_dist_at_item[(j-RESOLUTION)/STEP_SIZE],
                                        (ulong) num_dist_at_item[j/STEP_SIZE],
                                        RESOLUTION
                                );

                                /* Get largest difference */
                                if (diff > max_diff)
                                {
                                        /*
                                         * j should not be too small, otherwise we'll be outputting
                                         * a very small block
                                         */
                                        max_diff = diff;
                                        literal_split = j;
                                }
                        }

                        /*
                         * There could be multiple changes in the data in our literals,
                         * so if we find something really weird, make sure we break the
                         * block now, and not on some later change.
                         */
                        if (max_diff >= EARLY_BREAK_THRESHOLD &&
                                (literal_split-literal_to_start_at) >= MIN_LITERALS_IN_BLOCK)
                        {
                context->enc_num_block_splits++;

                                *split_at_literal = literal_split;

                                /*
                                 * Return the associated # distances, if required.
                                 * Since we split on a literal which is % STEP_SIZE, we
                                 * can read the # distances right off
                                 */
                                if (split_at_distance)
                                        *split_at_distance = num_dist_at_item[literal_split/STEP_SIZE];

                                return true;
                        }
                }
        }

        /*
         * No good place found to split
         */
        return false;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mspatch\lzx\encoder\enctree.c ===
/*
 * enctree.c
 *
 * Encode trees into output data
 */

#define EXT extern
#include "encoder.h"

/*
 * Encode a tree
 */
static void WriteRepTree(
	t_encoder_context *context,
	byte    *pLen,
	byte    *pLastLen, 
	int		Num
)
{
	int			i;
	int			j;
	int			Same;
	ushort		SmallFreq[2*24];
	ushort		MiniCode[24];
	char		MiniLen[24];
	char		k;
	byte		temp_store;
    byte * z=context->enc_output_buffer_curpos;

	static const byte Modulo17Lookup[] =
	{
		0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16,
		0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16
	};

	memset(SmallFreq, 0, sizeof(SmallFreq));

	temp_store	= pLen[Num];
	pLen[Num]	= 123; 

	for (i = 0; i < Num; i++)
	{
		Same = 0;

		/* Count the number of consecutive elements which have the same length */
		/* No need to check against array boundary, because the last element has */
		/* a nonsense value */
		for (j = i+1; pLen[j] == pLen[i]; j++)
	 		Same++;

		/* If more than 3, compress this information */
		if (Same >= TREE_ENC_REP_MIN)
		{
	 		/* Special case if they're zeroes */
	 		if (!pLen[i])
	 		{
	    		if (Same > TREE_ENC_REP_MIN + TREE_ENC_REP_ZERO_FIRST + TREE_ENC_REP_ZERO_SECOND - 1)
	       		Same = TREE_ENC_REP_MIN + TREE_ENC_REP_ZERO_FIRST + TREE_ENC_REP_ZERO_SECOND - 1;

	    		if (Same <= TREE_ENC_REP_MIN + TREE_ENC_REP_ZERO_FIRST - 1)
	       			SmallFreq[17]++;
	    		else
	       			SmallFreq[18]++;
	 		}
		 	else
	 		{
	    		if (Same > TREE_ENC_REP_MIN + TREE_ENC_REP_SAME_FIRST - 1)
	       			Same = TREE_ENC_REP_MIN + TREE_ENC_REP_SAME_FIRST - 1;

				SmallFreq[ Modulo17Lookup[ pLastLen[i]-pLen[i]+17 ] ]++;
	    		SmallFreq[19]++;
	 		}

	 		i += Same-1;
      }
      else
			SmallFreq[ Modulo17Lookup[ pLastLen[i]-pLen[i]+17 ] ]++;
	}

	make_tree(
		context,
		20, 
		SmallFreq, 
		(byte *) MiniLen, 
		MiniCode, 
		true
	);

	/* max 10 byte output overrun */
	for (i = 0; i < 20; i++)
	{
		output_bits(context, 4, MiniLen[i]);
	}

	/* Output original tree with new code */
	for (i = 0; i < Num; i++)
	{
		Same = 0;

		/* Count the number of consecutive elements which have the same length */
		/* No need to check against array boundary, because the last element has */
		/* a nonsense value */
		for (j = i+1; pLen[j] == pLen[i]; j++)
	 		Same++;

		/* If more than 3, we can do something */
		if (Same >= TREE_ENC_REP_MIN)
		{
	 		if (!pLen[i]) /* Zeroes */
	 		{
	    		if (Same > TREE_ENC_REP_MIN + TREE_ENC_REP_ZERO_FIRST + TREE_ENC_REP_ZERO_SECOND - 1)
		       		Same = TREE_ENC_REP_MIN + TREE_ENC_REP_ZERO_FIRST + TREE_ENC_REP_ZERO_SECOND - 1;

	    		if (Same <= TREE_ENC_REP_MIN + TREE_ENC_REP_ZERO_FIRST - 1)
	       			k = 17;
	    		else
		       		k = 18;
	 		}
	 		else
	 		{
	    		if (Same > TREE_ENC_REP_MIN + TREE_ENC_REP_SAME_FIRST - 1)
			   		Same = TREE_ENC_REP_MIN + TREE_ENC_REP_SAME_FIRST - 1;

	    		k = 19;
	 		}
		}
		else
	 		k = Modulo17Lookup[ pLastLen[i]-pLen[i]+17 ];

		output_bits(context, MiniLen[k], MiniCode[k]);

		if (k == 17)
		{
	 		output_bits(context, TREE_ENC_REPZ_FIRST_EXTRA_BITS, Same-TREE_ENC_REP_MIN);
	 		i += Same-1;
		}
		else if (k == 18)
		{
	 		output_bits(context, TREE_ENC_REPZ_SECOND_EXTRA_BITS, Same-(TREE_ENC_REP_MIN+TREE_ENC_REP_ZERO_FIRST));
	 		i += Same-1;
		}
		else if (k == 19)
		{
	 		output_bits(context, TREE_ENC_REP_SAME_EXTRA_BITS, Same-TREE_ENC_REP_MIN);

	 		k = Modulo17Lookup[ pLastLen[i]-pLen[i]+17 ];
			output_bits(context, MiniLen[k], MiniCode[k]);

	 		i += Same-1;
		}
	}

	pLen[Num] = temp_store;

	memcpy(pLastLen, pLen, Num);
}


void create_trees(t_encoder_context *context, bool generate_codes)
{
	/*
	 * Assumption: We can trash PtrLen[NUM_CHARS+(NUM_POSITION_SLOTS*NUM_LENGTHS))], since
	 *             we allocated space for it earlier
	 */
	make_tree(
		context,
		NUM_CHARS+(context->enc_num_position_slots*(NUM_PRIMARY_LENGTHS+1)),
		context->enc_main_tree_freq, 
		context->enc_main_tree_len,  
		context->enc_main_tree_code,
		generate_codes
	);

	make_tree(
		context,
		NUM_SECONDARY_LENGTHS, 
		context->enc_secondary_tree_freq,
		context->enc_secondary_tree_len,
		context->enc_secondary_tree_code,
		generate_codes
	);

	make_tree(
		context,
		ALIGNED_NUM_ELEMENTS, 
		context->enc_aligned_tree_freq, 
		context->enc_aligned_tree_len, 
		context->enc_aligned_tree_code, 
		true
	);
}


void fix_tree_cost_estimates(t_encoder_context *context)
{
	/*
	 *  We're only creating trees for estimation purposes and we do not 
	 *  want to encode the tree.  However, the following loops will set
	 *  the frequency zero tree element lengths to values other than 
	 *  zero, so that the optimal encoder won't get confused when it
	 *  tries to estimate the number of bits it would take to output an
	 *  element.
     *
     *  We also set the bit lengths of match length 2's further away
     *  than MAX_LENGTH_TWO_OFFSET to a large number, so that the
     *  optimal parser will never select such matches.
	 */
	ulong  i;

	/* Set zero lengths to some value */
	for (i = 0; i< NUM_CHARS; i++)
	{
		if (context->enc_main_tree_len[i] == 0)
			context->enc_main_tree_len[i] = 11;
	}

	for (; i < NUM_CHARS+(context->enc_num_position_slots*(NUM_PRIMARY_LENGTHS+1)); i++)
	{
		if (context->enc_main_tree_len[i] == 0)
			context->enc_main_tree_len[i] = 12;
	}		

	for (i = 0; i < NUM_SECONDARY_LENGTHS; i++)
	{
		if (context->enc_secondary_tree_len[i] == 0)
			context->enc_secondary_tree_len[i] = 8; 
	}

    prevent_far_matches(context);
}


void prevent_far_matches(t_encoder_context *context)
{
    ulong i;

    /*
     * Set far match length 2's to a high value so they will never
     * be chosen.
     *
     * See description of MAX_GROWTH in encdefs.h
     */
    for (   i = MP_SLOT(MAX_LENGTH_TWO_OFFSET);
            i < context->enc_num_position_slots;
            i++
        )
	{
        context->enc_main_tree_len[NUM_CHARS + (i << NL_SHIFT)] = 100;
	}		
}


/*
 * Encode the trees
 *
 * Assumes trees have already been created with create_trees().
 *
 * Warning, do not call update_tree_cost_estimates() before encoding
 * the trees, since that routine trashes some of the tree elements.
 */
void encode_trees(t_encoder_context *context)
{
	WriteRepTree(
		context,
		context->enc_main_tree_len, 
		context->enc_main_tree_prev_len,
		NUM_CHARS
	);

	WriteRepTree(
		context,
		&context->enc_main_tree_len[NUM_CHARS], 
		&context->enc_main_tree_prev_len[NUM_CHARS], 
		context->enc_num_position_slots * (NUM_PRIMARY_LENGTHS+1)
	);

	WriteRepTree(
		context,
		context->enc_secondary_tree_len,
		context->enc_secondary_tree_prev_len,
		NUM_SECONDARY_LENGTHS
	);
}


void encode_aligned_tree(t_encoder_context *context)
{
	int i;

	make_tree(
		context,
		ALIGNED_NUM_ELEMENTS, 
		context->enc_aligned_tree_freq, 
		context->enc_aligned_tree_len, 
		context->enc_aligned_tree_code, 
		true
	);

	/* Output original tree with new code */
	for (i = 0; i < 8; i++)
	{
		output_bits(context, 3, context->enc_aligned_tree_len[i]);
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mspatch\lzx\encoder\encvars.h ===
/*
 * encvars.h
 *
 * Variables for the compressor
 */

#ifdef ALLOC_VARS
    #undef EXT
    #define EXT
#else
    #undef EXT
    #define EXT extern
#endif


/*
 * For the optimal parser
 *
 * Uses less memory if it's ushort, but then we're forcing the CPU
 * to do 16 bit operations.
 *
 * Change this to ulong if you don't mind a small memory hit.
 * Also, if you make LOOK too large, this number may cause the
 * cost estimation to overflow; e.g. 10000 uncompressed symbols
 * @ 8 bits each > 65535 bits.
 */
typedef ulong           numbits_t;


/*
 * For the optimal parser
 */
typedef struct
    {
    ulong                   link;
    ulong                   path;
    ulong                   repeated_offset[NUM_REPEATED_OFFSETS];
    numbits_t               numbits;
#ifdef TRACING
    ulong                   matchoff;
#endif
    } decision_node;


/*
 * 256 + 8 * max_position_slots
 */
#define MAX_MAIN_TREE_ELEMENTS (256 + (8 * 291))   // 32MB

typedef struct
    {
    /* "fake" window pointer, based on enc_RealMemWindow */
    byte                            *enc_MemWindow;

    ulong                           enc_window_size;

#ifdef MULTIPLE_SEARCH_TREES
    /* root node pointers for our search trees */
    ulong                           *enc_tree_root;
#else /* !MULTIPLE_SEARCH_TREES */
    ulong                            enc_single_tree_root;
#endif /* MULTIPLE_SEARCH_TREES */

    /* "fake" start of left nodes */
    ulong                           *enc_Left;

    /* "fake" start of right nodes */
    ulong                           *enc_Right;

    /* bitwise outputting */
    ulong               enc_bitbuf;
    signed char                     enc_bitcount;
    bool                enc_output_overflow;
    char                pad1[2];

    /* used to record literals and displacements */
    ulong               enc_literals;    /* current number of literals */
    ulong               enc_distances;   /* current number of displacements */
    ulong              *enc_DistData;               /* match displacement array */
    byte               *enc_LitData;     /* contains a character or a matchlength */

#ifdef EXTRALONGMATCHES
    ushort             *enc_ExtraLength;    /* parallel to enc_LitData */
#endif

    byte               *enc_ItemType;  /* bitmap for whether it's a character or matchlength */
    ulong                           enc_repeated_offset_at_literal_zero[NUM_REPEATED_OFFSETS];

    /*
     * the last three match offsets (displacements) encoded, the most recent
     * one being enc_last_matchpos_offset[0].
     */
    ulong                           enc_last_matchpos_offset[NUM_REPEATED_OFFSETS];

    /* used for optimal parsing */
    ulong               enc_matchpos_table[MAX_MATCH+1];

    /* current encoding position in data */
    ulong                           enc_BufPos;

    /* lookup table for converting a match position into a slot */
    ushort              enc_slot_table[1024];

    /* buffering the output data */
    byte                *enc_output_buffer_start;
    byte                *enc_output_buffer_curpos;
    byte                *enc_output_buffer_end;
    ulong                           enc_input_running_total;
    ulong                           enc_bufpos_last_output_block;

    /* number of distinct position slots */
    ulong               enc_num_position_slots;

    /* misc */
    ulong               enc_file_size_for_translation;

    /* number of block splits for this 32K of uncompressed data */
    byte                enc_num_block_splits;

    /* the number of 1 bits in any given integer */
    byte                            enc_ones[256];

    /* compression parameters */
    byte                            enc_first_block;
    bool                            enc_need_to_recalc_stats;
    bool                            enc_first_time_this_group;
    ulong                           enc_encoder_second_partition_size;
    ulong                           enc_earliest_window_data_remaining;
    ulong                           enc_bufpos_at_last_block;
    byte                            *enc_input_ptr;
    long                            enc_input_left;
    ulong                           enc_instr_pos;

    /* for tree.c */
    ushort                          *enc_tree_freq;
    ushort                          *enc_tree_sortptr;
    byte                            *enc_len;
    short                           enc_tree_heap[MAX_MAIN_TREE_ELEMENTS + 2];
    ushort                          enc_tree_leftright[2*(2*MAX_MAIN_TREE_ELEMENTS-1)];
    ushort                          enc_tree_len_cnt[17];
    int                                     enc_tree_n;
    short                           enc_tree_heapsize;
    char                            enc_depth;

    ulong                           enc_next_tree_create;
    ulong                           enc_last_literals;
    ulong                           enc_last_distances;
    decision_node           *enc_decision_node;

    /* trees */
    byte                            enc_main_tree_len[MAX_MAIN_TREE_ELEMENTS+1];
    byte                            enc_secondary_tree_len[NUM_SECONDARY_LENGTHS+1];

    ushort                          enc_main_tree_freq[MAX_MAIN_TREE_ELEMENTS*2];
    ushort                          enc_main_tree_code[MAX_MAIN_TREE_ELEMENTS];
    byte                            enc_main_tree_prev_len[MAX_MAIN_TREE_ELEMENTS+1];

    ushort                          enc_secondary_tree_freq[NUM_SECONDARY_LENGTHS*2];
    ushort                          enc_secondary_tree_code[NUM_SECONDARY_LENGTHS];
    byte                            enc_secondary_tree_prev_len[NUM_SECONDARY_LENGTHS+1];

    ushort                          enc_aligned_tree_freq[ALIGNED_NUM_ELEMENTS*2];
    ushort                          enc_aligned_tree_code[ALIGNED_NUM_ELEMENTS];
    byte                            enc_aligned_tree_len[ALIGNED_NUM_ELEMENTS];
    byte                            enc_aligned_tree_prev_len[ALIGNED_NUM_ELEMENTS];

    /* start of allocated window memory */
    byte                            *enc_RealMemWindow;

    /* start of allocated left nodes */
    ulong                           *enc_RealLeft;

    /* start of allocated right nodes */
    ulong                           *enc_RealRight;

    /* # cfdata frames this folder */
    ulong               enc_num_cfdata_frames;

    /* misc */
    void                *enc_fci_data;

    PFNALLOC                        enc_malloc;
    HANDLE                          enc_mallochandle;

    int (__stdcall *enc_output_callback_function)(
                                                 void *          pfol,
                                                 unsigned char * compressed_data,
                                                 long            compressed_size,
                                                 long            uncompressed_size
                                                 );


    } t_encoder_context;


/*
 * Declare arrays?
 */

#ifdef ALLOC_VARS

/*
 * (1 << extra_bits[n])-1
 */
const ulong enc_slot_mask[] =
{
0,      0,      0,      0,     1,       1,      3,      3,
7,      7,     15,     15,    31,      31,     63,     63,
127,    127,    255,    255,   511,     511,   1023,   1023,
2047,   2047,   4095,   4095,  8191,    8191,  16383,  16383,
32767,  32767,  65535,  65535, 131071, 131071, 131071, 131071,
131071, 131071, 131071, 131071, 131071, 131071, 131071, 131071,
131071, 131071, 131071, 131071, 131071, 131071, 131071, 131071,
131071, 131071, 131071, 131071, 131071, 131071, 131071, 131071,
131071, 131071, 131071, 131071, 131071, 131071, 131071, 131071,
131071, 131071, 131071, 131071, 131071, 131071, 131071, 131071,
131071, 131071, 131071, 131071, 131071, 131071, 131071, 131071,
131071, 131071, 131071, 131071, 131071, 131071, 131071, 131071,
131071, 131071, 131071, 131071, 131071, 131071, 131071, 131071,
131071, 131071, 131071, 131071, 131071, 131071, 131071, 131071,
131071, 131071, 131071, 131071, 131071, 131071, 131071, 131071,
131071, 131071, 131071, 131071, 131071, 131071, 131071, 131071,
131071, 131071, 131071, 131071, 131071, 131071, 131071, 131071,
131071, 131071, 131071, 131071, 131071, 131071, 131071, 131071,
131071, 131071, 131071, 131071, 131071, 131071, 131071, 131071,
131071, 131071, 131071, 131071, 131071, 131071, 131071, 131071,
131071, 131071, 131071, 131071, 131071, 131071, 131071, 131071,
131071, 131071, 131071, 131071, 131071, 131071, 131071, 131071,
131071, 131071, 131071, 131071, 131071, 131071, 131071, 131071,
131071, 131071, 131071, 131071, 131071, 131071, 131071, 131071,
131071, 131071, 131071, 131071, 131071, 131071, 131071, 131071,
131071, 131071, 131071, 131071, 131071, 131071, 131071, 131071,
131071, 131071, 131071, 131071, 131071, 131071, 131071, 131071,
131071, 131071, 131071, 131071, 131071, 131071, 131071, 131071,
131071, 131071, 131071, 131071, 131071, 131071, 131071, 131071,
131071, 131071, 131071, 131071, 131071, 131071, 131071, 131071,
131071, 131071, 131071, 131071, 131071, 131071, 131071, 131071,
131071, 131071, 131071, 131071, 131071, 131071, 131071, 131071,
131071, 131071, 131071, 131071, 131071, 131071, 131071, 131071,
131071, 131071, 131071, 131071, 131071, 131071, 131071, 131071,
131071, 131071, 131071, 131071, 131071, 131071, 131071, 131071,
131071, 131071, 131071, 131071, 131071, 131071, 131071, 131071,
131071, 131071, 131071
};

const byte enc_extra_bits[] =
{
0,0,0,0,1,1,2,2,
3,3,4,4,5,5,6,6,
7,7,8,8,9,9,10,10,
11,11,12,12,13,13,14,14,
15,15,16,16,17,17,17,17,
17,17,17,17,17,17,17,17,
17,17,17,17,17,17,17,17,
17,17,17,17,17,17,17,17,
17,17,17,17,17,17,17,17,
17,17,17,17,17,17,17,17,
17,17,17,17,17,17,17,17,
17,17,17,17,17,17,17,17,
17,17,17,17,17,17,17,17,
17,17,17,17,17,17,17,17,
17,17,17,17,17,17,17,17,
17,17,17,17,17,17,17,17,
17,17,17,17,17,17,17,17,
17,17,17,17,17,17,17,17,
17,17,17,17,17,17,17,17,
17,17,17,17,17,17,17,17,
17,17,17,17,17,17,17,17,
17,17,17,17,17,17,17,17,
17,17,17,17,17,17,17,17,
17,17,17,17,17,17,17,17,
17,17,17,17,17,17,17,17,
17,17,17,17,17,17,17,17,
17,17,17,17,17,17,17,17,
17,17,17,17,17,17,17,17,
17,17,17,17,17,17,17,17,
17,17,17,17,17,17,17,17,
17,17,17,17,17,17,17,17,
17,17,17,17,17,17,17,17,
17,17,17,17,17,17,17,17,
17,17,17,17,17,17,17,17,
17,17,17,17,17,17,17,17,
17,17,17,17,17,17,17,17,
17,17,17
};

#else

extern const ulong enc_slot_mask[];
extern const byte enc_extra_bits[];

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mspatch\lzx\encoder\init.c ===
/*
 * init.c
 *
 * Initialise encoder
 */
#include "encoder.h"


#define MEM_WINDOW_ALLOC_SIZE   \
        (context->enc_window_size+(MAX_MATCH+EXTRA_SIZE)+context->enc_encoder_second_partition_size)

/*
 * Initialise encoder
 */
void init_compression_memory(t_encoder_context *context)
{
    /* set all root pointers to NULL */
#ifdef MULTIPLE_SEARCH_TREES
    memset(
          context->enc_tree_root,
          0,
          NUM_SEARCH_TREES * sizeof(context->enc_tree_root[0])
          );
#else
    context->enc_single_tree_root = 0;
#endif

    context->enc_MemWindow  = context->enc_RealMemWindow - context->enc_window_size;
    context->enc_Left               = context->enc_RealLeft          - context->enc_window_size;
    context->enc_Right              = context->enc_RealRight         - context->enc_window_size;
    context->enc_BufPos             = context->enc_window_size;

    /*
     * Set initial state of repeated match offsets
     */
    context->enc_last_matchpos_offset[0] = 1;
    context->enc_last_matchpos_offset[1] = 1;
    context->enc_last_matchpos_offset[2] = 1;

    /*
     * repeated offset states the last time we output a block
     * see block.c/encdata.c
     */
    context->enc_repeated_offset_at_literal_zero[0] = 1;
    context->enc_repeated_offset_at_literal_zero[1] = 1;
    context->enc_repeated_offset_at_literal_zero[2] = 1;

    /* this is the first compressed block in the file */
    context->enc_first_block = true;

    /* we don't have any cumulative stats yet */
    context->enc_need_to_recalc_stats = true;

    /* bufpos @ last time we output a block */
    context->enc_bufpos_last_output_block = context->enc_BufPos;

    /* initialise bit buffer */
    context->enc_bitcount = 32;
    context->enc_bitbuf   = 0;
    context->enc_output_overflow = false;

    /*
     * The last lengths are zeroed in both the encoder and decoder,
     * since our tree representation is delta format.
     */
    memset(context->enc_main_tree_prev_len, 0, MAIN_TREE_ELEMENTS);
    memset(context->enc_secondary_tree_prev_len, 0, NUM_SECONDARY_LENGTHS);

    /*
     * Set the default last tree lengths for cost estimation
     */
    memset(context->enc_main_tree_len, 8, NUM_CHARS);
    memset(&context->enc_main_tree_len[NUM_CHARS], 9, MAIN_TREE_ELEMENTS-NUM_CHARS);
    memset(context->enc_secondary_tree_len, 6, NUM_SECONDARY_LENGTHS);
    memset(context->enc_aligned_tree_len, 3, ALIGNED_NUM_ELEMENTS);
    prevent_far_matches(context); /* prevent far match 2's from being taken */

    context->enc_bufpos_at_last_block                       = context->enc_BufPos;
    context->enc_earliest_window_data_remaining     = context->enc_BufPos;
    context->enc_input_running_total                        = 0;
    context->enc_first_time_this_group                      = true;

    /* Clear the literal types array */
    memset(context->enc_ItemType, 0, MAX_LITERAL_ITEMS/8);

    /* No literals or distances encoded yet */
    context->enc_literals      = 0;
    context->enc_distances     = 0;

    /* No block splits yet */
    context->enc_num_block_splits = 0;

    context->enc_repeated_offset_at_literal_zero[0] = 1;
    context->enc_repeated_offset_at_literal_zero[1] = 1;
    context->enc_repeated_offset_at_literal_zero[2] = 1;

    /* reset instruction pointer (for translation) to zero */
    reset_translation(context);

    context->enc_num_cfdata_frames = 0;
}


/*
 * Allocate memory for the compressor
 *
 * Returns true if successful, false otherwise
 */
bool comp_alloc_compress_memory(t_encoder_context *context)
{
    ulong   pos_start;

#ifdef MULTIPLE_SEARCH_TREES
    context->enc_tree_root          = NULL;
#endif
    context->enc_RealLeft           = NULL;
    context->enc_RealRight          = NULL;
    context->enc_MemWindow          = NULL;
    context->enc_decision_node      = NULL;
    context->enc_LitData            = NULL;
#ifdef EXTRALONGMATCHES
    context->enc_ExtraLength        = NULL;
#endif
    context->enc_DistData           = NULL;
    context->enc_ItemType           = NULL;
    context->enc_output_buffer_start = NULL;

    /* ALSO NULLIFY BUFFERS! */

    /*
     * Determine the number of position slots in the main tree
     */
    context->enc_num_position_slots = 4;
    pos_start                               = 4;

    while (1)
        {
        pos_start += 1 << enc_extra_bits[context->enc_num_position_slots];

        context->enc_num_position_slots++;

        if (pos_start >= context->enc_window_size)
            break;
        }

#ifdef MULTIPLE_SEARCH_TREES
    context->enc_tree_root = (ulong *) context->enc_malloc(
                                                          context->enc_mallochandle,
                                                          sizeof(context->enc_tree_root[0]) * NUM_SEARCH_TREES
                                                          );

    if (context->enc_tree_root == NULL)
        {
        return false;
        }
#endif

    context->enc_RealLeft = (ulong *) context->enc_malloc(
                                                         context->enc_mallochandle,
                                                         sizeof(ulong) * MEM_WINDOW_ALLOC_SIZE
                                                         );

    if (context->enc_RealLeft == NULL)
        {
        return false;
        }

    context->enc_RealRight = (ulong *) context->enc_malloc(
                                                          context->enc_mallochandle,
                                                          sizeof(ulong) * MEM_WINDOW_ALLOC_SIZE
                                                          );

    if (context->enc_RealRight == NULL)
        {
        return false;
        }

    context->enc_RealMemWindow = (byte *) context->enc_malloc(
                                                             context->enc_mallochandle,
                                                             MEM_WINDOW_ALLOC_SIZE
                                                             );

    if (context->enc_RealMemWindow == NULL)
        {
        return false;
        }

    context->enc_MemWindow = context->enc_RealMemWindow;

    context->enc_LitData = (byte *) context->enc_malloc(
                                                       context->enc_mallochandle,
                                                       MAX_LITERAL_ITEMS * sizeof(*context->enc_LitData)
                                                       );

    if (context->enc_LitData == NULL)
        {
        return false;
        }

#ifdef EXTRALONGMATCHES

    context->enc_ExtraLength = (ushort *) context->enc_malloc(
                                                             context->enc_mallochandle,
                                                             MAX_LITERAL_ITEMS * sizeof(*context->enc_ExtraLength)
                                                             );

    if (context->enc_ExtraLength == NULL)
        {
        return false;
        }

#endif

    context->enc_DistData = (ulong *) context->enc_malloc(
                                                         context->enc_mallochandle,
                                                         MAX_DIST_ITEMS * sizeof(*context->enc_DistData)
                                                         );

    if (context->enc_DistData == NULL)
        {
        return false;
        }

    context->enc_ItemType = (byte *) context->enc_malloc(
                                                        context->enc_mallochandle,
                                                        MAX_LITERAL_ITEMS/8
                                                        );

    if (context->enc_ItemType == NULL)
        {
        return false;
        }

    create_slot_lookup_table(context);
    create_ones_table(context);

    if (init_compressed_output_buffer(context) == false)
        {
        return false;
        }

    context->enc_decision_node = context->enc_malloc(
                                                    context->enc_mallochandle,
                                                    sizeof(decision_node) * (LOOK+MAX_MATCH+16)
                                                    );

    if (context->enc_decision_node == NULL)
        {
        return false;
        }

    /* success */
    return true;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mspatch\lzx\encoder\optenc.c ===
/*
 * optenc.c
 *
 * Encoder for optimal parser
 *
 *
 * Future Improvements:
 *
 * When two estimations are equal, for example, "should I output a
 * character or a match?" there should be some way of deciding
 * which to take.  Right now we force it to output a match, but
 * for text files, outputting a character results in a small
 * savings.  Even when comparing two matches, we might want to
 * force it to take one type of match over another.
 */

#include "encoder.h"

#define copymem(src,dst,size) memcpy(dst,src,size)


static bool redo_first_block(t_encoder_context *context, long *bufpos_ptr);
static void block_end(t_encoder_context *context, long BufPos);


/*
 * encode a match of length <len> (where <len> >=2), and position <pos>
 */

#ifdef EXTRALONGMATCHES

#define OUT_MATCH(len,pos) \
{ \
   ULONG enclen = (len);                                                                        \
   ULONG extlen = 0;                                                                            \
   if ( enclen > MAX_MATCH ) {                                                                  \
        extlen = enclen - MAX_MATCH;                                                            \
        enclen = MAX_MATCH;                                                                     \
        }                                                                                       \
   context->enc_ItemType   [context->enc_literals >> 3] |= (1 << (context->enc_literals & 7));  \
   context->enc_LitData    [context->enc_literals     ]  = (byte)(enclen-MIN_MATCH);            \
   context->enc_ExtraLength[context->enc_literals++   ]  = (ushort)(extlen);                    \
   context->enc_DistData   [context->enc_distances++  ]  = (pos);                               \
}

#else

#define OUT_MATCH(len,pos) \
{ \
   context->enc_ItemType[(context->enc_literals >> 3)] |= (1 << (context->enc_literals & 7));   \
   context->enc_LitData [context->enc_literals++]  = (byte)(len-2);                             \
   context->enc_DistData[context->enc_distances++] = pos;                                       \
}

#endif

/* encode a character */
#define OUT_CHAR(ch) \
        context->enc_LitData [context->enc_literals++] = ch;


#define TREE_CREATE_CHECK()                                             \
if (context->enc_literals >= context->enc_next_tree_create)                     \
{                                                                                               \
        update_tree_estimates(context);\
        context->enc_next_tree_create += TREE_CREATE_INTERVAL;  \
}


/*
 * Returns an estimation of how many bits it would take to output
 * a given character
 */
#define CHAR_EST(c) (numbits_t) (context->enc_main_tree_len[(c)])


/*
 * Returns an estimation of how many bits it would take to output
 * a given match.
 *
 * <ml> is the match length, where ml >= 2
 * <mp> is the match position
 *
 * The result is stored in <result>
 */
#define MATCH_EST(ml,mp,result) \
{ \
        ulong mp_slot;                                                                                                           \
        mp_slot = MP_SLOT(mp);                                                                           \
        if (ml < (NUM_PRIMARY_LENGTHS+2))                                                                       \
        {                                                                                                                                       \
                result = (numbits_t)                                                                                    \
                        (context->enc_main_tree_len[(NUM_CHARS-2)+(mp_slot<<NL_SHIFT)+ml] +     \
                        enc_extra_bits[mp_slot]);                                                                       \
        }                                                                                                                                       \
        else                                                                                                                            \
        {                                                                                                                                       \
                result = (numbits_t)                                                                                    \
                        (context->enc_main_tree_len[(NUM_CHARS+NUM_PRIMARY_LENGTHS)+(mp_slot<<NL_SHIFT)] + \
                        context->enc_secondary_tree_len[ml-(NUM_PRIMARY_LENGTHS+2)] +   \
                        enc_extra_bits[mp_slot]);                                                                       \
        }                                                                                                                                       \
}


#ifdef _DEBUG
static void VERIFY_MATCH(
                        t_encoder_context   *context,
                        long                bufpos,
                        int                 largest_match_len
                        )
{
    int     i, j;
    ulong   match_pos;

    /*
     * Ensure match does not cross boundary
     */
    _ASSERTE(
            largest_match_len <=
            (CHUNK_SIZE-1) - (bufpos & (CHUNK_SIZE-1))
            );

    for (i = MIN_MATCH; i <= largest_match_len; i++)
        {
        match_pos = context->enc_matchpos_table[i];

        if (match_pos < NUM_REPEATED_OFFSETS)
            match_pos = context->enc_last_matchpos_offset[match_pos];
        else
            match_pos -= (NUM_REPEATED_OFFSETS-1);

        _ASSERTE (match_pos <= context->enc_window_size-4);

        for (j = 0; j < i; j++)
            {
            _ASSERTE (
                     context->enc_MemWindow[bufpos+j] ==
                     context->enc_MemWindow[bufpos-match_pos+j]
                     );
            }
        }
}
#else
    #define VERIFY_MATCH(a,b,c) ;
#endif


void flush_all_pending_blocks(t_encoder_context *context)
{
    /*
     * Force all blocks to be output
     */
    while (context->enc_literals > 0)
        output_block(context);

    /*
     * Flush compressed data out to the caller
     */
    perform_flush_output_callback(context);
}


void encoder_start(t_encoder_context *context)
{
    long BytesRead, RealBufPos;

    /*
     * RealBufPos is our position in the window,
     * and equals [0...window_size + second_partition_size - 1]
     */
    RealBufPos = context->enc_BufPos - (ulong)(context->enc_RealMemWindow - context->enc_MemWindow);

    BytesRead = comp_read_input(context, RealBufPos, CHUNK_SIZE);

    if (BytesRead > 0)
        opt_encode_top(context, BytesRead);
}


static void update_tree_estimates(t_encoder_context *context)
{
    if (context->enc_literals)
        {
        /*
         * Get stats on literals from 0...context->enc_literals
         */
        if (context->enc_need_to_recalc_stats)
            {
            /*
             * Cumulative total was destroyed, so need to
             * recalculate
             */
            get_block_stats(
                           context,
                           0,
                           0,
                           context->enc_literals
                           );

            context->enc_need_to_recalc_stats = false;
            }
        else
            {
            /*
             * Add stats from last_literals...context->enc_literals
             * to cumulative total
             */
            update_cumulative_block_stats(
                                         context,
                                         context->enc_last_literals,
                                         context->enc_last_distances,
                                         context->enc_literals
                                         );
            }

        create_trees(context, false); /* don't generate codes */

        fix_tree_cost_estimates(context);

        /*
         * For cumulative total
         */
        context->enc_last_literals = context->enc_literals;
        context->enc_last_distances = context->enc_distances;
        }
}


void opt_encode_top(t_encoder_context *context, long BytesRead)
{
    ulong   BufPos;
    ulong   RealBufPos;
    ulong   BufPosEnd;
    ulong   BufPosEndThisChunk;
    ulong   MatchPos;
    ulong   i;
    ulong   end_pos;
    long    EncMatchLength;  /* must be a signed number */
    long    ExMatchOff = -1; /* initialize to prevent compiler warning */

    /*
     * Current position in encoding window
     */
    BufPos          = context->enc_BufPos;

    /*
     * Stop encoding when we reach here
     */
    BufPosEnd       = context->enc_BufPos + BytesRead;

    /*
     * If this is our first time in here (since a new group), then
     * when we reach this many literals, update our tree cost
     * estimates.
     *
     * Also, output the file size we're using for translation
     * (0 means no translation at all, which will speed things up
     * for the decoder).
     */
    if (context->enc_first_time_this_group)
        {
        context->enc_first_time_this_group = false;

        /*
         * Recreate trees when we reach this many literals
         */
        context->enc_next_tree_create = 10000;

        if (context->enc_file_size_for_translation)
            {
            output_bits(context, 1, 1); /* translation */

            output_bits(context, 16, context->enc_file_size_for_translation >> 16);
            output_bits(context, 16, context->enc_file_size_for_translation & 65535);
            }
        else
            {
            output_bits(context, 1, 0); /* no translation */
            }
        }
    else
        {
        /*
         * If this is our second or later time in here, then add in the
         * strings we removed last time.
         *
 * We have to be careful here, though, because end_pos is
 * equal to our current BufPos - window_size, not
 * BufPos - i - window_size; we don't have that much history
 * around.
         */
        for (i = BREAK_LENGTH; i > 0; i--)
            quick_insert_bsearch_findmatch(
                                          context,
                                          BufPos - (long) i,
                                          BufPos - context->enc_window_size+4
                                          );
        }

    while (1)
        {

        top_of_main_loop:

        /*
         * While we haven't reached the end of the data
         */
        while (BufPos < BufPosEnd)
            {

            BufPosEndThisChunk = ( BufPos + CHUNK_SIZE ) & ~( CHUNK_SIZE - 1 );

            if ( BufPosEndThisChunk > BufPosEnd ) {
                 BufPosEndThisChunk = BufPosEnd;
                 }

            /*
             * Search for matches of all different possible lengths, at BufPos
             */
            EncMatchLength = binary_search_findmatch(context, BufPos);

            if (EncMatchLength < MIN_MATCH)
                {

                output_literal:

                /*
                 * No match longer than 1 character exists in the history
                 * window, so output the character at BufPos as a symbol.
                 */
                OUT_CHAR(context->enc_MemWindow[BufPos]);

#ifdef TRACING
                EncTracingLiteral( BufPos, context->enc_MemWindow[BufPos] );
#endif
                BufPos++;

                /*
                 * Check for exceeding literal buffer
                 */
                if (context->enc_literals >= (MAX_LITERAL_ITEMS-8))
                    block_end(context, BufPos);

                continue;
                }

            /*
             * Found a match.
             *
             * Make sure it cannot exceed the end of the buffer.
             */
            if ( EncMatchLength > (long)( BufPosEndThisChunk - BufPos ))
                {
                EncMatchLength = (long)( BufPosEndThisChunk - BufPos );

                /*
                 * Oops, not enough for even a small match, so we
                 * have to output a literal
                 */
                if (EncMatchLength < MIN_MATCH)
                    goto output_literal;
                }

            VERIFY_MATCH(context, BufPos, EncMatchLength);

            if (EncMatchLength < FAST_DECISION_THRESHOLD)
                {
                /*
                 *  A match has been found that is between MIN_MATCH and
                 *  FAST_DECISION_THRESHOLD bytes in length.  The following
                 *  algorithm is the optimal encoder that will determine the
                 *  most efficient order of matches and unmatched characters
                 *  over a span area defined by LOOK.
                 *
                 *  The code is essentially a shortest path determination
                 *  algorithm.  A stream of data can be encoded in a vast number
                 *  of different ways depending on the match lengths and offsets
                 *  chosen.  The key to good compression ratios is to chose the
                 *  least expensive path.
                 */
                ulong           span;
                ulong           epos, bpos, NextPrevPos;
                decision_node *decision_node_ptr;
                long            iterations;

                /*
                 * Points to the end of the area covered by this match; the span
                 * will continually be extended whenever we find more matches
                 * later on.  It will stop being extended when we reach a spot
                 * where there are no matches, which is when we decide which
                 * path to take to output the matches.
                 */
                span = BufPos + EncMatchLength;

                /*
                 * The furthest position into which we will do our lookahead parsing
                 */
                epos = BufPos + LOOK;

                /*
                 * Temporary BufPos variable
                 */
                bpos = BufPos;


                /*
                 * Calculate the path to the next character if we output
                 * an unmatched symbol.
                 */

                /* bits required to get here */
                context->enc_decision_node[1].numbits = CHAR_EST(context->enc_MemWindow[BufPos]);

                /* where we came from */
                context->enc_decision_node[1].path    = BufPos;


                /*
                 * For the match found, estimate the cost of encoding the match
                 * for each possible match length, shortest offset combination.
                 *
                 * The cost, path and offset is stored at BufPos + Length.
                 */
                for (i = MIN_MATCH; i <= (ulong)EncMatchLength; i++)
                    {
                    /*
                     * Get estimation of match cost given match length = i,
                     * match position = context->enc_matchpos_table[i], and store
                     * the result in context->enc_numbits[i]
                     */
                    MATCH_EST(i, context->enc_matchpos_table[i], context->enc_decision_node[i].numbits);

                    /*
                     * Where we came from
                     */
                    context->enc_decision_node[i].path = BufPos;

                    /*
                     * Associated match position with this path
                     */
                    context->enc_decision_node[i].link = context->enc_matchpos_table[i];

#ifdef TRACING
                        {
                        ULONG TrMatchPos = context->enc_matchpos_table[i];
                        ULONG TrMatchOff;

                        if ( TrMatchPos < NUM_REPEATED_OFFSETS ) {
                            TrMatchOff = context->enc_last_matchpos_offset[ TrMatchPos ];
                            }
                        else {
                            TrMatchOff = TrMatchPos - ( NUM_REPEATED_OFFSETS - 1 );
                            }

                        context->enc_decision_node[i].matchoff = TrMatchOff;
                        }
#endif
                    }

                /*
                 * Set bit counter to zero at the start
                 */
                context->enc_decision_node[0].numbits = 0;

                /*
                 * Initialise relative match position tables
                 *
                 * Really context->enc_repeated_offset_table[BufPos-bpos][x], but here
                 * BufPos == bpos
                 */
                context->enc_decision_node[0].repeated_offset[0] = context->enc_last_matchpos_offset[0];
                context->enc_decision_node[0].repeated_offset[1] = context->enc_last_matchpos_offset[1];
                context->enc_decision_node[0].repeated_offset[2] = context->enc_last_matchpos_offset[2];

                decision_node_ptr = &context->enc_decision_node[-(long) bpos];

#define rpt_offset_ptr(where,which_offset) decision_node_ptr[(where)].repeated_offset[(which_offset)]

                while (1)
                    {
                    numbits_t est, cum_numbits;

                    BufPos++;


                    /*
                     *  Set the proper repeated offset locations depending on the
                     *  shortest path to the location prior to searching for a
                     *  match.
                     */


                    /*
                     * If this is a match (i.e. path skips over more
                     * than one character).
                     */
                    if (decision_node_ptr[BufPos].path != (ulong) (BufPos-1))
                        {
                        ulong LastPos = decision_node_ptr[BufPos].path;

                        /*
                         * link_ptr[BufPos] is the match position for this
                         * location
                         */
                        if (decision_node_ptr[BufPos].link >= NUM_REPEATED_OFFSETS)
                            {
                            context->enc_last_matchpos_offset[0] = decision_node_ptr[BufPos].link-(NUM_REPEATED_OFFSETS-1);
                            context->enc_last_matchpos_offset[1] = rpt_offset_ptr(LastPos,0);
                            context->enc_last_matchpos_offset[2] = rpt_offset_ptr(LastPos,1);
                            }
                        else if (decision_node_ptr[BufPos].link == 0)
                            {
                            context->enc_last_matchpos_offset[0] = rpt_offset_ptr(LastPos,0);
                            context->enc_last_matchpos_offset[1] = rpt_offset_ptr(LastPos,1);
                            context->enc_last_matchpos_offset[2] = rpt_offset_ptr(LastPos,2);
                            }
                        else if (decision_node_ptr[BufPos].link == 1)
                            {
                            context->enc_last_matchpos_offset[0] = rpt_offset_ptr(LastPos,1);
                            context->enc_last_matchpos_offset[1] = rpt_offset_ptr(LastPos,0);
                            context->enc_last_matchpos_offset[2] = rpt_offset_ptr(LastPos,2);
                            }
                        else /* == 2 */
                            {
                            context->enc_last_matchpos_offset[0] = rpt_offset_ptr(LastPos,2);
                            context->enc_last_matchpos_offset[1] = rpt_offset_ptr(LastPos,1);
                            context->enc_last_matchpos_offset[2] = rpt_offset_ptr(LastPos,0);
                            }
                        }

                    rpt_offset_ptr(BufPos,0) = context->enc_last_matchpos_offset[0];
                    rpt_offset_ptr(BufPos,1) = context->enc_last_matchpos_offset[1];
                    rpt_offset_ptr(BufPos,2) = context->enc_last_matchpos_offset[2];

                    /*
                     * The following is one of the two possible break points from
                     * the inner encoding loop.  This break will exit the loop if
                     * a point is reached that no match can incorporate; i.e. a
                     * character that does not match back to anything is a point
                     * where all possible paths will converge and the longest one
                     * can be chosen.
                     */
                    if (span == BufPos)
                        break;

                    /*
                     * Search for matches at BufPos
                     */
                    EncMatchLength = binary_search_findmatch(context, BufPos);

                    /*
                     * Make sure that the match does not exceed the stop point
                     */
                    if ((ulong) EncMatchLength + BufPos > BufPosEndThisChunk)
                        {
                        EncMatchLength = BufPosEndThisChunk - BufPos;

                        if (EncMatchLength < MIN_MATCH)
                            EncMatchLength = 0;
                        }

                    VERIFY_MATCH(context, BufPos, EncMatchLength);

                    /*
                     * If the match is very long or it exceeds epos (either
                     * surpassing the LOOK area, or exceeding past the end of the
                     * input buffer), then break the loop and output the path.
                     */
                    if (EncMatchLength > FAST_DECISION_THRESHOLD ||
                        BufPos + (ulong) EncMatchLength >= epos)
                        {
                        MatchPos = context->enc_matchpos_table[EncMatchLength];

#ifdef EXTRALONGMATCHES
                        if ( EncMatchLength == MAX_MATCH ) {
                            if ( MatchPos < NUM_REPEATED_OFFSETS ) {
                                ExMatchOff = context->enc_last_matchpos_offset[ MatchPos ];
                                }
                            else {
                                ExMatchOff = MatchPos - ( NUM_REPEATED_OFFSETS - 1 );
                                }
                            }
#endif

#ifdef TRACING
                            {
                            ULONG TrMatchOff;

                            if ( MatchPos < NUM_REPEATED_OFFSETS ) {
                                TrMatchOff = context->enc_last_matchpos_offset[ MatchPos ];
                                }
                            else {
                                TrMatchOff = MatchPos - ( NUM_REPEATED_OFFSETS - 1 );
                                }

                            decision_node_ptr[BufPos+EncMatchLength].matchoff = TrMatchOff;
                            }
#endif

                        decision_node_ptr[BufPos+EncMatchLength].link = MatchPos;
                        decision_node_ptr[BufPos+EncMatchLength].path = BufPos;

                        /*
                         * Quickly insert data into the search tree without
                         * returning match positions/lengths
                         */
#ifndef INSERT_NEAR_LONG_MATCHES
                        if (MatchPos == 3 && EncMatchLength > 16)
                            {
                            /*
                             * If we found a match 1 character away and it's
                             * length 16 or more, it's probably a string of
                             * zeroes, so don't insert that into the search
                             * engine, since doing so can slow things down
                             * significantly!
                             */
                            quick_insert_bsearch_findmatch(
                                                          context,
                                                          BufPos + 1,
                                                          BufPos - context->enc_window_size + (1 + 4) /* bp+1 -(ws-4) */
                                                          );
                            }
                        else
#endif
                            {
                            for (i = 1; i < (ulong) EncMatchLength; i++)
                                quick_insert_bsearch_findmatch(
                                                              context,
                                                              BufPos + i,
                                                              BufPos + i - context->enc_window_size + 4
                                                              );
                            }

                        BufPos += EncMatchLength;

                        /*
                         * Update the relative match positions
                         */
                        if (MatchPos >= NUM_REPEATED_OFFSETS)
                            {
                            context->enc_last_matchpos_offset[2] = context->enc_last_matchpos_offset[1];
                            context->enc_last_matchpos_offset[1] = context->enc_last_matchpos_offset[0];
                            context->enc_last_matchpos_offset[0] = MatchPos-(NUM_REPEATED_OFFSETS-1);
                            }
                        else if (MatchPos)
                            {
                            ulong t = context->enc_last_matchpos_offset[0];
                            context->enc_last_matchpos_offset[0] = context->enc_last_matchpos_offset[MatchPos];
                            context->enc_last_matchpos_offset[MatchPos] = t;
                            }

                        break;
                        }


                    /*
                     * The following code will extend the area spanned by the
                     * set of matches if the current match surpasses the end of
                     * the span.  A match of length two that is far is not
                     * accepted, since it would normally be encoded as characters,
                     * thus allowing the paths to converge.
                     */
                    if (EncMatchLength > 2 ||
                        (EncMatchLength == 2 && context->enc_matchpos_table[2] < BREAK_MAX_LENGTH_TWO_OFFSET))
                        {
                        if (span < (ulong) (BufPos + EncMatchLength))
                            {
                            long end;
                            long _i;

                            end = min(BufPos+EncMatchLength-bpos, LOOK-1);

                            /*
                             * These new positions are undefined for now, since we haven't
                             * gone there yet, so put in the costliest value
                             */
                            for (_i = span-bpos+1; _i <= end; _i++)
                                context->enc_decision_node[_i].numbits = (numbits_t) -1;

                            span = BufPos + EncMatchLength;
                            }
                        }


                    /*
                     *  The following code will iterate through all combinations
                     *  of match lengths for the current match.  It will estimate
                     *  the cost of the path from the beginning of LOOK to
                     *  BufPos and to every locations spanned by the current
                     *  match.  If the path through BufPos with the found matches
                     *  is estimated to take fewer number of bits to encode than
                     *  the previously found match, then the path to the location
                     *  is altered.
                     *
                     *  The code relies on accurate estimation of the cost of
                     *  encoding a character or a match.  Furthermore, it requires
                     *  a search engine that will store the smallest match offset
                     *  of each possible match length.
                     *
                     *  A match of length one is simply treated as an unmatched
                     *  character.
                     */

                    /*
                     *  Get the estimated number of bits required to encode the
                     *  path leading up to BufPos.
                     */
                    cum_numbits = decision_node_ptr[BufPos].numbits;


                    /*
                     *  Calculate the estimated cost of outputting the path through
                     *  BufPos and outputting the next character as an unmatched byte
                     */
                    est = cum_numbits + CHAR_EST(context->enc_MemWindow[BufPos]);


                    /*
                     *  Check if it is more efficient to encode the next character
                     *  as an unmatched character rather than the previously found
                     *  match.  If so, then update the cheapest path to BufPos + 1.
                     *
                     *  What happens if est == numbits[BufPos-bpos+1]; i.e. it
                     *  works out as well to output a character as to output a
                     *  match?  It's a tough call; however, we will push the
                     *  encoder to use matches where possible.
                     */
                    if (est < decision_node_ptr[BufPos+1].numbits)
                        {
                        decision_node_ptr[BufPos+1].numbits = est;
                        decision_node_ptr[BufPos+1].path    = BufPos;
                        }


                    /*
                     *      Now, iterate through the remaining match lengths and
                     *  compare the new path to the existing.  Change the path
                     *  if it is found to be more cost effective to go through
                     *  BufPos.
                     */
                    for (i = MIN_MATCH; i <= (ulong) EncMatchLength; i++)
                        {
                        MATCH_EST(i, context->enc_matchpos_table[i], est);
                        est += cum_numbits;

                        /*
                         * If est == numbits[BufPos+i] we want to leave things
                         * alone, since this will tend to force the matches
                         * to be smaller in size, which is beneficial for most
                         * data.
                         */
                        if (est < decision_node_ptr[BufPos+i].numbits)
                            {
                            decision_node_ptr[BufPos+i].numbits     = est;
                            decision_node_ptr[BufPos+i].path        = BufPos;
                            decision_node_ptr[BufPos+i].link        = context->enc_matchpos_table[i];

#ifdef TRACING
                                {
                                ULONG TrMatchPos = context->enc_matchpos_table[i];
                                ULONG TrMatchOff;

                                if ( TrMatchPos < NUM_REPEATED_OFFSETS ) {
                                    TrMatchOff = context->enc_last_matchpos_offset[ TrMatchPos ];
                                    }
                                else {
                                    TrMatchOff = TrMatchPos - ( NUM_REPEATED_OFFSETS - 1 );
                                    }

                                decision_node_ptr[BufPos+i].matchoff = TrMatchOff;
                                }
#endif
                            }
                        }
                    } /* continue to loop through span of matches */


                /*
                 *  Here BufPos == span, ie. a non-matchable character found.  The
                 *  following code will output the path properly.
                 */


                /*
                 *  Unfortunately the path is stored in reverse; how to get from
                 *  where we are now, to get back to where it all started.
                 *
                 *  Traverse the path back to the original starting position
                 *  of the LOOK span.  Invert the path pointers in order to be
                 *  able to traverse back to the current position from the start.
                 */

                /*
                 * Count the number of iterations we did, so when we go forwards
                 * we'll do the same amount
                 */
                iterations = 0;

                NextPrevPos = decision_node_ptr[BufPos].path;

                do
                    {
                    ulong   PrevPos;

                    PrevPos = NextPrevPos;

                    NextPrevPos = decision_node_ptr[PrevPos].path;
                    decision_node_ptr[PrevPos].path = BufPos;

                    BufPos = PrevPos;

                    iterations++;
                    } while (BufPos != bpos);


                if (context->enc_literals + iterations >= (MAX_LITERAL_ITEMS-8) ||
                    context->enc_distances + iterations >= (MAX_DIST_ITEMS-8))
                    {
                    block_end(context, BufPos);
                    }

                /*
                 * Traverse from the beginning of the LOOK span to the end of
                 * the span along the stored path, outputting matches and
                 * characters appropriately.
                 */
                do
                    {
                    if (decision_node_ptr[BufPos].path > BufPos+1)
                        {
                        /*
                         * Path skips over more than 1 character; therefore it's a match
                         */

#ifdef EXTRALONGMATCHES

                        //
                        //  If the match length to output here is MAX_MATCH,
                        //  this must be the last entry in the decision chain,
                        //  and we can extend the match as far as it will go.
                        //

                        long ExMatchPos    = decision_node_ptr[ decision_node_ptr[BufPos].path ].link;
                        long ExMatchLength = decision_node_ptr[BufPos].path - BufPos;

                        if ( ExMatchLength == MAX_MATCH ) {

                            ulong ExBufPtr = BufPos + MAX_MATCH;

#ifdef TRACING
                            ASSERT( ExMatchOff == (long)decision_node_ptr[ decision_node_ptr[BufPos].path ].matchoff );
#endif /* TRACING */

                            while (( ExBufPtr < BufPosEndThisChunk ) &&
                                   ( context->enc_MemWindow[ ExBufPtr ] == context->enc_MemWindow[ ExBufPtr - ExMatchOff ] )) {

                                ++ExBufPtr;
                                ++ExMatchLength;
                                }
                            }

                        OUT_MATCH( ExMatchLength, ExMatchPos );

#ifdef TRACING

                        EncTracingMatch(
                            BufPos,
                            ExMatchLength,
                            ExMatchPos,
                            decision_node_ptr[ decision_node_ptr[BufPos].path ].matchoff
                            );
#endif // TRACING

                        BufPos += ExMatchLength;

#else  /* ! EXTRALONGMATCHES */

                        OUT_MATCH(
                                 decision_node_ptr[BufPos].path - BufPos,
                                 decision_node_ptr[ decision_node_ptr[BufPos].path ].link
                                 );

#ifdef TRACING

                        EncTracingMatch(
                            BufPos,
                            decision_node_ptr[BufPos].path - BufPos,
                            decision_node_ptr[ decision_node_ptr[BufPos].path ].link,
                            decision_node_ptr[ decision_node_ptr[BufPos].path ].matchpos
                            );
#endif // TRACING

                        BufPos = decision_node_ptr[BufPos].path;

#endif /* ! EXTRALONGMATCHES */

                        }
                    else
                        {
                        /*
                         * Path goes to the next character; therefore it's a symbol
                         */
                        OUT_CHAR(context->enc_MemWindow[BufPos]);

#ifdef TRACING
                        EncTracingLiteral( BufPos, context->enc_MemWindow[BufPos] );
#endif

                        BufPos++;
                        }
                    } while (--iterations != 0);

                TREE_CREATE_CHECK();

                /*
                 * If we're filling up, and are close to outputting a block,
                 * and it's the first block, then recompress the first N
                 * literals using our accumulated stats.
                 */
                if (context->enc_first_block &&
                    (context->enc_literals >= (MAX_LITERAL_ITEMS-512)
                     || context->enc_distances >= (MAX_DIST_ITEMS-512)))
                    {
                    if (redo_first_block(context, &BufPos))
                        goto top_of_main_loop;

                    /*
                     * Unable to redo, so output the block
                     */
                    block_end(context, BufPos);
                    }
                }
            else  /* EncMatchLength >= FAST_DECISION_THRESHOLD */
                {
                /*
                 *  This code reflects a speed optimization that will always take
                 *  a match of length >= FAST_DECISION_THRESHOLD characters.
                 */

                /*
                 * The position associated with the match we found
                 */

                MatchPos = context->enc_matchpos_table[EncMatchLength];

#ifdef EXTRALONGMATCHES

                if ( EncMatchLength == MAX_MATCH ) {

                    //
                    //  Extend the match length up to end of input buffer
                    //  or the current position in the history buffer.
                    //

                    ulong BufPtr = BufPos + MAX_MATCH;
                    long MatchOff;

                    if ( MatchPos < NUM_REPEATED_OFFSETS ) {
                        MatchOff = context->enc_last_matchpos_offset[ MatchPos ];
                        }
                    else {
                        MatchOff = MatchPos - ( NUM_REPEATED_OFFSETS - 1 );
                        }

                    while (( BufPtr < BufPosEndThisChunk ) &&
                           ( context->enc_MemWindow[ BufPtr ] == context->enc_MemWindow[ BufPtr - MatchOff ] )) {

                        ++BufPtr;
                        ++EncMatchLength;
                        }
                    }

#endif

                /*
                 * Quickly insert match substrings into search tree
                 * (don't look for new matches; just insert the strings)
                 */
#ifndef INSERT_NEAR_LONG_MATCHES
                if (MatchPos == 3 && EncMatchLength > 16)
                    {
                    quick_insert_bsearch_findmatch(
                                                  context,
                                                  BufPos + 1,
                                                  BufPos - context->enc_window_size + 5 /* bp+1 -(ws-4) */
                                                  );
                    }
                else
#endif
                    {
                    for (i = 1; i < (ulong) EncMatchLength; i++)
                        quick_insert_bsearch_findmatch(
                                                      context,
                                                      BufPos + i,
                                                      BufPos + i - context->enc_window_size + 4
                                                      );
                    }

                /*
                 * Output the match
                 */
                OUT_MATCH(EncMatchLength, MatchPos);

#ifdef TRACING

                {
                ULONG TrMatchOff;

                if ( MatchPos < NUM_REPEATED_OFFSETS ) {
                    TrMatchOff = context->enc_last_matchpos_offset[ MatchPos ];
                    }
                else {
                    TrMatchOff = MatchPos - ( NUM_REPEATED_OFFSETS - 1 );
                    }

                EncTracingMatch(
                    BufPos,
                    EncMatchLength,
                    MatchPos,
                    TrMatchOff
                    );
                }

#endif // TRACING


                /*
                 * Advance our position in the window
                 */
                BufPos += EncMatchLength;

                if (MatchPos >= NUM_REPEATED_OFFSETS)
                    {
                    context->enc_last_matchpos_offset[2] = context->enc_last_matchpos_offset[1];
                    context->enc_last_matchpos_offset[1] = context->enc_last_matchpos_offset[0];
                    context->enc_last_matchpos_offset[0] = MatchPos-(NUM_REPEATED_OFFSETS-1);
                    }
                else if (MatchPos)
                    {
                    ulong t = context->enc_last_matchpos_offset[0];
                    context->enc_last_matchpos_offset[0] = context->enc_last_matchpos_offset[MatchPos];
                    context->enc_last_matchpos_offset[MatchPos] = t;
                    }

                /*
                 * Check to see if we're close to overflowing our output arrays, and
                 * output a block if this is the case
                 */
                if (context->enc_literals >= (MAX_LITERAL_ITEMS-8) ||
                    context->enc_distances >= (MAX_DIST_ITEMS-8))
                    block_end(context, BufPos);

                }  /* EncMatchLength >= FAST_DECISION_THRESHOLD */

            } /* end while ... BufPos < BufPosEnd */

        /*
 * Value of BufPos corresponding to earliest window data
         */
        context->enc_earliest_window_data_remaining = BufPos - context->enc_window_size;

        /*
         * We didn't read 32K, so we know for sure that
         * this was our last block of data.
         */
        if (BytesRead < CHUNK_SIZE)
            {
            /*
             * If we have never output a block, and we haven't
             * recalculated the stats already, then recalculate
             * the stats and recompress.
             */
            if (context->enc_first_block)
                {
                if (redo_first_block(context, &BufPos))
                    goto top_of_main_loop;
                }

            break;
            }

        /*
         * Remove the last BREAK_LENGTH nodes from the binary search tree,
         * since we have been inserting strings which contain undefined
         * data at the end.
         */
        end_pos = BufPos - (context->enc_window_size-4-BREAK_LENGTH);

        for (i = 1; (i <= BREAK_LENGTH); i++)
            binary_search_remove_node(context, BufPos-i, end_pos);

        /*
         * If we're still in the first window_size + second partition size
         * bytes in the file then we don't need to copymem() yet.
         *
         * RealBufPos is the real position in the file.
         */
        RealBufPos = BufPos - (ulong)(context->enc_RealMemWindow - context->enc_MemWindow);

        if (RealBufPos < context->enc_window_size + context->enc_encoder_second_partition_size)
            break;

        /*
         * We're about to trash a whole bunch of history with our copymem,
         * so we'd better redo the first block now if we are ever going to.
         */
        if (context->enc_first_block)
            {
            if (redo_first_block(context, &BufPos))
                goto top_of_main_loop;
            }

        /*
         *  We're about to remove a large number of symbols from the window.
         *  Test to see whether, if we were to output a block now, our compressed
         *  output size would be larger than our uncompressed data.  If so, then
         *  we will output an uncompressed block.
         *
         *  The reason we have to do this check here, is that data in the
         *  window is about to be destroyed.  We can't simply put this check in
         *  the block outputting code, since there is no guarantee that the
         *  memory window contents corresponding to everything in that block,
         *  are still around - all we'd have would be a set of literals and
         *  distances, when we need all the uncompressed literals to output
         *  an uncompressed block.
         */

        /*
         *  What value of bufpos corresponds to the oldest data we have in the
         *  buffer?
         *
         *  After the memory copy, that will be the current buffer position,
         *  minus window_size.
         */

        /*
         * The end of the data buffer is reached, more data needs to be read
         * and the existing data must be shifted into the history window.
         *
         * MSVC 4.x generates code which does REP MOVSD so no need to
         * write this in assembly.
         */
        copymem(
               &context->enc_RealMemWindow[context->enc_encoder_second_partition_size],
               &context->enc_RealMemWindow[0],
               context->enc_window_size
               );

        copymem(
               &context->enc_RealLeft[context->enc_encoder_second_partition_size],
               &context->enc_RealLeft[0],
               sizeof(ulong)*context->enc_window_size
               );

        copymem(
               &context->enc_RealRight[context->enc_encoder_second_partition_size],
               &context->enc_RealRight[0],
               sizeof(ulong)*context->enc_window_size
               );

        context->enc_earliest_window_data_remaining = BufPos - context->enc_window_size;

        /*
         *   The following bit of code is CRUCIAL yet unorthodox in function
         *   and serves as a speed and syntax optimization and makes the code
         *   easier to understand once grasped.
         *
         *   The three main buffers, context->enc_MemWindow, context->enc_Left and context->enc_Right,
         *   are referensed by BufPos and SearchPos relative to the current
         *   compression window locations.  When the encoder reaches the end
         *   of its block of input memory, the data in the input buffer is
         *   shifted into the compression history window and the new input
         *   stream is loaded.  Typically the BufPos pointer would be reduced
         *   to signify the replaced data.  However, this code reduces the
         *   base pointers to reflect the shift of data, and leaves the BufPos
         *   pointer in its current state.  Therefore, the BufPos pointer is
         *   an absolute pointer reflecting the position in the input stream,
         *   and NOT the position in the buffer.  The base pointers will point
         *   to invalid memory locations with addresses smaller than the
         *   actual array base pointers.  However, when the two pointers are
         *   added together, &(context->enc_MemWindow+BufPos), it will point to the
         *   correct and valid position in the buffer.
         */

        context->enc_MemWindow -= context->enc_encoder_second_partition_size;
        context->enc_Left      -= context->enc_encoder_second_partition_size;
        context->enc_Right     -= context->enc_encoder_second_partition_size;

        break;
        }

    /*
     * Store BufPos in global variable
     */
    context->enc_BufPos = BufPos;
}


static void block_end(t_encoder_context *context, long BufPos)
{
    context->enc_first_block                        = false;
    context->enc_need_to_recalc_stats       = true;

    output_block(context);

    if (context->enc_literals < TREE_CREATE_INTERVAL)
        {
        context->enc_next_tree_create = TREE_CREATE_INTERVAL;
        }
    else
        {
        context->enc_next_tree_create = context->enc_literals + TREE_CREATE_INTERVAL; /* recreate right away */
        }

    context->enc_bufpos_last_output_block = BufPos;
}


static bool redo_first_block(t_encoder_context *context, long *bufpos_ptr)
{
    long    start_at;
    long    earliest_can_start_at;
    long    pos_in_file;
    long    history_needed;
    long    history_avail;
    long    BufPos;
    long    split_at_literal;

    context->enc_first_block = false;

    BufPos = *bufpos_ptr;

    /*
     * For the first context->enc_window size bytes in the file, we don't
     * need to have context->enc_window size bytes around.
     *
     * For anything after that, though, we do need to have window_size
     * previous bytes to look into.
     */

    /*
     * How many bytes are we into the file?
     */
    pos_in_file = BufPos - context->enc_window_size;

    /*
     * First let's figure out the total history required from
     * BufPos backwards.  For starters, we need all the bytes
     * we're going to recompress.  We get that by seeing the
     * last time we output a block.
     */
    history_needed = BufPos - context->enc_bufpos_last_output_block;

    /*
     * Plus we will need window_size bytes before that (for matching
     * into) unless we're looking within the first window_size
     * bytes of the file.
     */
    if (context->enc_bufpos_last_output_block-context->enc_window_size < context->enc_window_size)
        history_needed += context->enc_bufpos_last_output_block - context->enc_window_size;
    else
        history_needed += context->enc_window_size;

    history_avail = (ulong)(&context->enc_MemWindow[BufPos] - &context->enc_RealMemWindow[0]);

    if (history_needed <= history_avail)
        {
        earliest_can_start_at = context->enc_bufpos_last_output_block;
        }
    else
        {
        /*
         * Not enough history available
         */
        return false;
        }

    start_at = earliest_can_start_at;

    split_block(
               context,
               0,
               context->enc_literals,
               context->enc_distances,
               &split_at_literal,
               NULL /* don't need # distances returned */
               );

    get_block_stats(
                   context,
                   0,
                   0,
                   split_at_literal
                   );

    create_trees(context, false); /* don't generate codes */
    fix_tree_cost_estimates(context);

#ifdef MULTIPLE_SEARCH_TREES
    /*
     * Now set all the tree root pointers to NULL
     * (don't need to reset the left/right pointers).
     */
    memset(context->enc_tree_root, 0, NUM_SEARCH_TREES * sizeof(ulong));
#else
    context->enc_single_tree_root = 0;
#endif

    /*
     * Clear item array and reset literal and distance
     * counters
     */
    memset(context->enc_ItemType, 0, (MAX_LITERAL_ITEMS/8));

    /*
     * Reset encoder state
     */
    context->enc_last_matchpos_offset[0] = 1;
    context->enc_last_matchpos_offset[1] = 1;
    context->enc_last_matchpos_offset[2] = 1;

    context->enc_repeated_offset_at_literal_zero[0] = 1;
    context->enc_repeated_offset_at_literal_zero[1] = 1;
    context->enc_repeated_offset_at_literal_zero[2] = 1;

    context->enc_input_running_total = 0;

    context->enc_literals      = 0;
    context->enc_distances     = 0;

    context->enc_need_to_recalc_stats = true;

    context->enc_next_tree_create = split_at_literal;

    *bufpos_ptr = start_at;

    return true;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mspatch\lzx\encoder\tree.c ===
/*
 * tree.c
 *
 * Tree building routines.
 *
 * These routines are originally from the Public Domain source "AR001".
 *
 * However, they have been modified for use in LZX.
 */

#include "encoder.h"


/* Function prototypes */
static void downheap(t_encoder_context *context, short i);
static void make_tree2(t_encoder_context *context, short avail, ushort freqparm[], ushort codeparm[]);
static void make_len(t_encoder_context *context, short root);
static void make_code(t_encoder_context *context, int n, char len[], ushort code[]);


static void count_len(t_encoder_context *context, short i)  /* call with i = root */
{
	if (i < context->enc_tree_n)
		context->enc_tree_len_cnt[(context->enc_depth < 16) ? context->enc_depth : 16]++; /* NOTE: 16 is max len allowed */
	else
	{
		context->enc_depth++;
		count_len(context, context->enc_tree_leftright[i*2]);
		count_len(context, context->enc_tree_leftright[i*2+1]);
		context->enc_depth--;
	}
}


static void make_len(t_encoder_context *context, short root)
{
	signed short	k;
	ushort			cum;
	byte			i;

	for (i = 0; i <= 16; i++)
		context->enc_tree_len_cnt[i] = 0;

	count_len(context, root);

	cum = 0;

	for (i = 16; i > 0; i--)
		cum += (ushort) (context->enc_tree_len_cnt[i] << (16 - i));

	/* cum should equal 1<<16, which is 0 since cum is a ushort */
	while (cum)
	{
		context->enc_tree_len_cnt[16]--;

		for (i = 15; i > 0; i--)
		{
			if (context->enc_tree_len_cnt[i])
			{
				context->enc_tree_len_cnt[i]--;
				context->enc_tree_len_cnt[i+1] += 2;
				break;
			}
		}

		cum--;
	}

	for (i = 16; i > 0; i--)
	{
		k = context->enc_tree_len_cnt[i];

		while (--k >= 0)
			context->enc_len[*context->enc_tree_sortptr++] = (byte) i;
	}
}


static void __inline downheap(t_encoder_context *context, short i)
	/* priority queue; send i-th entry down heap */
{
	short  j, k;

	k = context->enc_tree_heap[i];

	while ((j = (i<<1)) <= context->enc_tree_heapsize)
	{
		if (j < context->enc_tree_heapsize && 
			context->enc_tree_freq[context->enc_tree_heap[j]] > context->enc_tree_freq[context->enc_tree_heap[j + 1]])
		 	j++;

		if (context->enc_tree_freq[k] <= context->enc_tree_freq[context->enc_tree_heap[j]])
			break;

		context->enc_tree_heap[i] = context->enc_tree_heap[j];
		i = j;
	}

	context->enc_tree_heap[i] = k;
}


static void make_code(t_encoder_context *context, int n, char len[], ushort code[])
{
    int    i;
	ushort start[18];

	start[1] = 0;

	for (i = 1; i <= 16; i++)
		start[i + 1] = (start[i] + context->enc_tree_len_cnt[i]) << 1;

	for (i = 0; i < n; i++)
	{
		code[i] = start[len[i]]++;
	}
}


void make_tree(
	t_encoder_context *context,
	int		nparm, 
	ushort	*freqparm, 
	byte	*lenparm, 
	ushort	*codeparm,
	bool	make_codes	/* for estimations, we only want the lengths */
)
{
	short i, avail;

REDO_TREE:
	context->enc_tree_n			= nparm;
	context->enc_tree_freq		= freqparm;
	context->enc_len				= lenparm;
	avail				= (short)context->enc_tree_n;
    context->enc_depth          = 0;
	context->enc_tree_heapsize	= 0;
	context->enc_tree_heap[1]	= 0;

	for (i = 0; i < nparm; i++)
	{
		context->enc_len[i] = 0;

		if (freqparm[i])
         context->enc_tree_heap[++context->enc_tree_heapsize] = i;
	}

	if (context->enc_tree_heapsize < 2)
	{
		if (!context->enc_tree_heapsize)
		{
			codeparm[context->enc_tree_heap[1]] = 0;
			return;
		}

		if (!context->enc_tree_heap[1])
			freqparm[1] = 1;
		else
			freqparm[0] = 1;

		goto REDO_TREE;
	}

	make_tree2(context, avail, freqparm, codeparm);

	if (make_codes)
		make_code(context, nparm, lenparm, codeparm);
}


static void make_tree2(
	t_encoder_context *context,
	short avail, 
	ushort freqparm[], 
	ushort codeparm[]
)
{
	short i, j, k;

	for (i = context->enc_tree_heapsize >> 1; i >= 1; i--)
		downheap(context, i);  /* make priority queue */

	context->enc_tree_sortptr = codeparm;

	do
	{	/* while queue has at least two entries */
		i = context->enc_tree_heap[1];  /* take out least-freq entry */

		if (i < context->enc_tree_n)
			*context->enc_tree_sortptr++ = i;

		context->enc_tree_heap[1] = context->enc_tree_heap[context->enc_tree_heapsize--];
		downheap(context, 1);

		j = context->enc_tree_heap[1];  /* next least-freq entry */

		if (j < context->enc_tree_n)
			*context->enc_tree_sortptr++ = j;

		k = avail++;  /* generate new node */

		freqparm[k] = freqparm[i] + freqparm[j];
		context->enc_tree_heap[1] = k;
		downheap(context, 1);  /* put into queue */

		context->enc_tree_leftright[k*2] = i;
		context->enc_tree_leftright[k*2+1] = j;

	} while (context->enc_tree_heapsize > 1);

	context->enc_tree_sortptr = codeparm;
	make_len(context, k);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mspatch\lzx\encoder\io.c ===
/*
 * io.c
 */
#include "encoder.h"

/*
 * Similar to the optimisation we have for the decoder.
 *
 * Allow the encoder to "overrun" output buffer by up to X bytes
 * so that we don't have to check for the end of the buffer every
 * single time we call outbits() in encdata.c
 */

#define OUTPUT_EXTRA_BYTES 64


static void encoder_translate_e8(t_encoder_context *context, byte *mem, long bytes);


/*
 * Initialises output buffering
 */
bool init_compressed_output_buffer(t_encoder_context *context)
{
        if (!(context->enc_output_buffer_start = (byte *) context->enc_malloc(
                                                                             context->enc_mallochandle,
                                                                             OUTPUT_BUFFER_SIZE)
                                                                             ))
            {
            return false;
            }

        context->enc_output_buffer_curpos = context->enc_output_buffer_start;

        context->enc_output_buffer_end =
                context->enc_output_buffer_start+(OUTPUT_BUFFER_SIZE-OUTPUT_EXTRA_BYTES);

        return true;
}


void reset_translation(t_encoder_context *context)
{
        context->enc_instr_pos = 0;
}


static long read_input_data(t_encoder_context *context, byte *mem, long amount)
{
        if (amount <= context->enc_input_left)
        {
                memcpy(mem, context->enc_input_ptr, amount);
                context->enc_input_left -= amount;
                context->enc_input_ptr += amount;

                return amount;
        }
        else
        {
                long bytes_read;

                if (context->enc_input_left <= 0)
                        return 0;

                bytes_read = context->enc_input_left;

                memcpy(mem, context->enc_input_ptr, context->enc_input_left);
                context->enc_input_ptr += context->enc_input_left;
                context->enc_input_left = 0;

                return bytes_read;
        }
}


long comp_read_input(t_encoder_context *context, ulong BufPos, long Size)
{
        long    bytes_read;

        if (Size <= 0)
                return 0;

        bytes_read = read_input_data(
                context,
                &context->enc_RealMemWindow[BufPos],
                Size
        );

        if (bytes_read < 0)
        return 0;

        /*
         * If no translation being performed for this file
         */
    if (context->enc_file_size_for_translation == 0 ||
        context->enc_num_cfdata_frames >= E8_CFDATA_FRAME_THRESHOLD)
    {
        context->enc_num_cfdata_frames++;
                return bytes_read;
    }

        encoder_translate_e8(
                context,
                &context->enc_RealMemWindow[BufPos],
                bytes_read
        );

    context->enc_num_cfdata_frames++;

        return bytes_read;
}


static void encoder_translate_e8(t_encoder_context *context, byte *mem, long bytes)
{
        long    offset;
        long    absolute;
        ulong   end_instr_pos;
        byte    temp[6];
        byte    *mem_backup;

        if (bytes <= 6)
        {
                context->enc_instr_pos += bytes;
                return;
        }

        mem_backup = mem;

        /* backup these bytes */
        memcpy(temp, &mem[bytes-6], 6);

        /* overwrite them with 0xE8 */
        memset(&mem[bytes-6], 0xE8, 6);

        end_instr_pos = context->enc_instr_pos + bytes - 6;

        while (1)
        {
                while (*mem++ != 0xE8)
                        context->enc_instr_pos++;

                if (context->enc_instr_pos >= end_instr_pos)
                        break;

                offset = *(UNALIGNED long *) mem;

                absolute = context->enc_instr_pos + offset;

                if (absolute >= 0)
                {
                        if ((ulong) absolute < context->enc_file_size_for_translation+context->enc_instr_pos)
                        {
                                if ((ulong) absolute >= context->enc_file_size_for_translation)
                                        absolute = offset - context->enc_file_size_for_translation;

                                *(UNALIGNED ulong *) mem = (ulong) absolute;
                        }
                }

                mem += 4;
                context->enc_instr_pos += 5;
        }

        /* restore the bytes */
        memcpy(&mem_backup[bytes-6], temp, 6);

        context->enc_instr_pos = end_instr_pos + 6;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\bin86\sources.inc ===
TARGETNAME=
TARGETTYPE=NOTARGET
TARGETPATH=
SOURCES=


SOURCES_USED=..\sources.inc

!if "$(ALT_PROJECT)" == "JPN" || "$(ALT_PROJECT)" == "CHT" || "$(ALT_PROJECT)" == "CHS" \
    || "$(ALT_PROJECT)" == "KOR" || "$(ALT_PROJECT)" == "CHP" 
BINPLACE_FLAGS = $(BINPLACE_FLAGS)
!endif

MISCFILES = \
    ..\autoexec.nt \
!if "$(ALT_PROJECT)" != "JPN" && "$(ALT_PROJECT)" != "KOR"
    ..\config.nt   \
    ..\ver.dll     \
!endif
    ..\ctl3dv2.dll \
    ..\ctl3dv2.map \
    ..\ctl3dv2.sym \
!if "$(ALT_PROJECT)" != "JPN" && "$(ALT_PROJECT)" != "CHT" && "$(ALT_PROJECT)" != "CHS" && "$(ALT_PROJECT)" != "CHP" 
    ..\netapi.dll	\
!endif
!if "$(ALT_PROJECT)" != "JPN"
    ..\lanman.drv 	\
    ..\lzexpand.dll \
    ..\pmspl.dll	\
!endif
    ..\$(TARGET_DIRECTORY)\win87em.dll \
!if "$(ALT_PROJECT)" != "JPN" && "$(ALT_PROJECT)" != "CHT" && "$(ALT_PROJECT)" != "CHS" && "$(ALT_PROJECT)" != "KOR" && "$(ALT_PROJECT)" != "CHP" 
    ..\sysedit.exe \
    ..\system.ini \
    ..\olecli.dll \
    ..\winhelp.exe \
    ..\write16.exe \
    ..\write16.map \
    ..\write16.sym \
!else
    ..\$(ALT_PROJECT_TARGET)\sysedit.exe \
    ..\$(ALT_PROJECT_TARGET)\system.ini \
    ..\$(ALT_PROJECT_TARGET)\winhelp.exe \
    ..\$(ALT_PROJECT_TARGET)\write16.exe \
    ..\$(ALT_PROJECT_TARGET)\write16.map \
    ..\$(ALT_PROJECT_TARGET)\write16.sym \
!endif
!if "$(ALT_PROJECT)" == "JPN" 
    ..\$(ALT_PROJECT_TARGET)\_disp.sys \
    ..\$(ALT_PROJECT_TARGET)\_ias.sys \
    ..\$(ALT_PROJECT_TARGET)\_prnescp.sys \
    ..\$(ALT_PROJECT_TARGET)\adddrv.exe \
    ..\$(ALT_PROJECT_TARGET)\appsicon.dll \
    ..\$(ALT_PROJECT_TARGET)\config.nt \
    ..\$(ALT_PROJECT_TARGET)\config.us \
    ..\$(ALT_PROJECT_TARGET)\config.wow \
    ..\$(ALT_PROJECT_TARGET)\deldrv.exe \
    ..\$(ALT_PROJECT_TARGET)\gaijiedt.exe \
    ..\$(ALT_PROJECT_TARGET)\jp.bat \
    ..\$(ALT_PROJECT_TARGET)\kkcfunc.sys \
    ..\$(ALT_PROJECT_TARGET)\lanman.drv \
    ..\$(ALT_PROJECT_TARGET)\lzexpand.dll \
    ..\$(ALT_PROJECT_TARGET)\msime.dic \
    ..\$(ALT_PROJECT_TARGET)\msime.sys \
    ..\$(ALT_PROJECT_TARGET)\msimed.sys \
    ..\$(ALT_PROJECT_TARGET)\msimei.sys \
    ..\$(ALT_PROJECT_TARGET)\msimek.sys \
    ..\$(ALT_PROJECT_TARGET)\msimekey.exe \
    ..\$(ALT_PROJECT_TARGET)\msimelst.exe \
    ..\$(ALT_PROJECT_TARGET)\msimer.dic \
    ..\$(ALT_PROJECT_TARGET)\msimergn.exe \
    ..\$(ALT_PROJECT_TARGET)\msimeset.exe \
    ..\$(ALT_PROJECT_TARGET)\netapi.dll \
    ..\$(ALT_PROJECT_TARGET)\olecli.dll \
    ..\$(ALT_PROJECT_TARGET)\pmspl.dll \
    ..\$(ALT_PROJECT_TARGET)\us.bat \
    ..\$(ALT_PROJECT_TARGET)\ver.dll \
!endif
!if "$(ALT_PROJECT)" == "KOR" 
    ..\$(ALT_PROJECT_TARGET)\config.nt \
    ..\$(ALT_PROJECT_TARGET)\edit.com \
    ..\$(ALT_PROJECT_TARGET)\edit.exe \
    ..\$(ALT_PROJECT_TARGET)\edit.hlp \
    ..\$(ALT_PROJECT_TARGET)\edit2.hlp \
    ..\$(ALT_PROJECT_TARGET)\qbasic.com \
    ..\$(ALT_PROJECT_TARGET)\qbasic.exe \
    ..\$(ALT_PROJECT_TARGET)\qbasic.hlp \
    ..\$(ALT_PROJECT_TARGET)\qbasic2.exe \
    ..\$(ALT_PROJECT_TARGET)\qbasic2.hlp \
    ..\$(ALT_PROJECT_TARGET)\ver.dll \
    ..\$(ALT_PROJECT_TARGET)\olecli.dll \
!endif
!if "$(ALT_PROJECT)" == "CHS" || "$(ALT_PROJECT)" == "CHT" || "$(ALT_PROJECT)" == "CHP"
    ..\$(ALT_PROJECT_TARGET)\country.sys \
    ..\$(ALT_PROJECT_TARGET)\netapi.dll \
    ..\$(ALT_PROJECT_TARGET)\olecli.dll \
!endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dbg\dbg.c ===
/*
 *  dbg.c - Main Module of DBG DLL.
 *
 *  BobDay 13-Jan-1992 Created
 *  Neilsa 13-Mar-1997 Moved guts to dbgdll
 *
 */

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <stdio.h>
#include <string.h>
#include <mvdm.h>
#include <bop.h>
#include <softpc.h>
#include <dbgexp.h>
#include <dbgsvc.h>
#include <vdmdbg.h>
#include <dbginfo.h>
#include <vdm.h>
#include <host_def.h>

BOOL (WINAPI *pfnDbgInit)(ULONG, ULONG, PVOID);
BOOL (WINAPI *pfnDbgIsDebuggee)(VOID);
VOID (WINAPI *pfnDbgDispatch)(VOID);
VOID (WINAPI *pfnDbgDosAppStart)(WORD, WORD);
VOID (WINAPI *pfnDbgSegmentNotice)(WORD, WORD, WORD, WORD, LPSTR, LPSTR, DWORD);
VOID (WINAPI *pfnDbgTraceEvent)(PVDM_TRACEINFO, WORD, WORD, DWORD);
BOOL (WINAPI *pfnDbgFault)(ULONG);
BOOL (WINAPI *pfnDbgBPInt)(VOID);
BOOL (WINAPI *pfnDbgTraceInt)(VOID);
VOID (WINAPI *pfnDbgNotifyNewTask)(LPVOID, UINT);
VOID (WINAPI *pfnDbgNotifyRemoteThreadAddress)(LPVOID, DWORD);
VOID (WINAPI *pfnDbgNotifyDebugged)(BOOL);

#ifdef i386
BYTE nt_cpu_info;
#else
extern ULONG Start_of_M_area;
extern BYTE nt_cpu_info;
#define IntelBase Start_of_M_area
//
// This field is used to hold values destined for NTVDMSTATE (at 714)
// Initially, we set it to INITIAL_VDM_TIB_FLAGS just for clarity, since it
// will really only be turned on or off once we look to see if a debugger
// is attached. This way, if you examine it when you first attach with a
// debugger, it will be consistent with the default.
//
ULONG InitialVdmTibFlags = INITIAL_VDM_TIB_FLAGS;

VDM_TRACEINFO TraceInfo;
PVDM_TRACEINFO pVdmTraceInfo = &TraceInfo;
#endif

BOOL bDbgInitCalled = FALSE;
BOOL bDbgDebuggerLoaded = FALSE;

ULONG InitialVdmDbgFlags = 0;

/* DBGInit - DBG Initialiazation routine.
 *
 * This routine is called during ntvdm initialization from host\src.
 * It is responsible for loading ntvdmd.dll, if vdm debugging is required.
 */

BOOL DBGInit (VOID)
{
    HANDLE  hmodDBG;
    DWORD   dwLen;

    // Indicate to VdmDbgAttach that we have gotten far enough into
    // the ntvdm boot that memory layout is valid.
    bDbgInitCalled = TRUE;

    //LATER Decide to load this on a registry switch
    if (!bDbgDebuggerLoaded) {
       hmodDBG = LoadSystem32Library(L"NTVDMD.DLL");

        if ( hmodDBG == (HANDLE)NULL ) {
#if DBG
            OutputDebugString("NTVDM: error loading ntvdmd.dll\n");
#endif
            return FALSE;
        } else {
            //
            // pfnDbgDispatch is special in that we always want to call it
            // even if no debugger is attached.
            //
            pfnDbgDispatch      = (VOID (WINAPI *)(VOID)) GetProcAddress( hmodDBG, "xxxDbgDispatch" );
        }
    }
    return TRUE;
}


/* VdmDbgAttach
 *
 * This routine is called from NTVDMD.DLL. It is potentially called
 * at any time, but specifically we are looking to run some code when:

 *  1) the ntvdm has "matured", and
 *  2) a debugger is attached
 *
 * The ntvdm has "matured" when it is initialized sufficiently to determine
 * for example where the start of VDM memory is (on risc platforms).
 *
 */
VOID
VdmDbgAttach(
    VOID
    )
{
    if (bDbgInitCalled) {
        HANDLE  hmodDBG;
        hmodDBG = GetModuleHandle("NTVDMD.DLL");

        if ( hmodDBG == (HANDLE)NULL ) {
            return;
        }

        pfnDbgInit          = (BOOL (WINAPI *)(ULONG, ULONG, PVOID)) GetProcAddress( hmodDBG, "xxxDbgInit" );
        pfnDbgIsDebuggee    = (BOOL (WINAPI *)(VOID)) GetProcAddress( hmodDBG, "xxxDbgIsDebuggee" );
        pfnDbgDosAppStart   = (VOID (WINAPI *)(WORD, WORD)) GetProcAddress( hmodDBG, "xxxDbgDosAppStart" );
        pfnDbgSegmentNotice = (VOID (WINAPI *)(WORD, WORD, WORD, WORD, LPSTR, LPSTR, DWORD)) GetProcAddress( hmodDBG, "xxxDbgSegmentNotice" );
        pfnDbgTraceEvent    = (VOID (WINAPI *)(PVDM_TRACEINFO, WORD, WORD, DWORD)) GetProcAddress( hmodDBG, "xxxDbgTraceEvent" );
        pfnDbgFault         = (BOOL (WINAPI *)(ULONG)) GetProcAddress( hmodDBG, "xxxDbgFault" );
        pfnDbgBPInt         = (BOOL (WINAPI *)(VOID)) GetProcAddress( hmodDBG, "xxxDbgBPInt" );
        pfnDbgTraceInt      = (BOOL (WINAPI *)(VOID)) GetProcAddress( hmodDBG, "xxxDbgTraceInt" );
        pfnDbgNotifyNewTask = (VOID (WINAPI *)(LPVOID, UINT)) GetProcAddress( hmodDBG, "xxxDbgNotifyNewTask" );
        pfnDbgNotifyRemoteThreadAddress = (VOID (WINAPI *)(LPVOID, DWORD)) GetProcAddress( hmodDBG, "xxxDbgNotifyRemoteThreadAddress" );
        pfnDbgNotifyDebugged= (VOID (WINAPI *)(BOOL)) GetProcAddress( hmodDBG, "xxxDbgNotifyDebugged" );
        //
        // DBGinit has already been called. Do an init, and send
        // symbol notifications
        //
        if (pfnDbgInit &&
            (bDbgDebuggerLoaded = (*pfnDbgInit)(IntelBase + FIXED_NTVDMSTATE_LINEAR,
                                                InitialVdmDbgFlags,
                                                &nt_cpu_info))) {
            //LATER: send symbol notifications
        }
    }
}


VOID
DBGNotifyNewTask(
    LPVOID  lpvNTFrame,
    UINT    uFrameSize
    )
{
    if (pfnDbgNotifyNewTask) {
        (*pfnDbgNotifyNewTask)(lpvNTFrame, uFrameSize);
    }
}


VOID
DBGNotifyRemoteThreadAddress(
    LPVOID  lpAddress,
    DWORD   lpBlock
    )
{
    if (pfnDbgNotifyRemoteThreadAddress) {
        (*pfnDbgNotifyRemoteThreadAddress)(lpAddress, lpBlock);
    }
}

VOID DBGNotifyDebugged(
    BOOL    fNewDebugged
    )
{
    if (pfnDbgNotifyDebugged) {
        (*pfnDbgNotifyDebugged)(fNewDebugged);
    }
}

BOOL DbgTraceInt(VOID)
{
    BOOL bRet = FALSE;
    if (pfnDbgTraceInt) {
        bRet = (*pfnDbgTraceInt)();
    }
    return bRet;
}

BOOL DbgFault(ULONG value)
{
    BOOL bRet = FALSE;
    if (pfnDbgFault) {
        bRet = (*pfnDbgFault)(value);
    }
    return bRet;
}

BOOL
DbgIsDebuggee(
    void
    )
{
    if (pfnDbgIsDebuggee) {
        return (*pfnDbgIsDebuggee)();
    }
    return FALSE;
}

VOID
DbgSegmentNotice(
    WORD  wType,
    WORD  wModuleSeg,
    WORD  wLoadSeg,
    WORD  wNewSeg,
    LPSTR lpModuleName,
    LPSTR lpModulePath,
    DWORD dwImageLen
    )
{
    if (pfnDbgSegmentNotice) {
        (*pfnDbgSegmentNotice)(wType, wModuleSeg, wLoadSeg, wNewSeg,
                               lpModuleName, lpModulePath, dwImageLen);
    }
}

VOID
DbgDosAppStart(
    WORD wCS,
    WORD wIP
    )
{
    if (pfnDbgDosAppStart) {
        (*pfnDbgDosAppStart)(wCS, wIP);
    }
}

void DBGDispatch()
{
    if (pfnDbgDispatch) {
        (*pfnDbgDispatch)();
    }
}

BOOL DbgBPInt()
{
    BOOL bRet = FALSE;
    if (pfnDbgBPInt) {
        bRet = (*pfnDbgBPInt)();
    }
    return bRet;
}


VOID
VdmTraceEvent(
    USHORT Type,
    USHORT wData,
    ULONG  lData
    )
{

    if (pfnDbgTraceEvent &&
        (*(ULONG *)(IntelBase+FIXED_NTVDMSTATE_LINEAR) & VDM_TRACE_HISTORY)) {

        PVDM_TIB VdmTib = NtCurrentTeb()->Vdm;

        (*pfnDbgTraceEvent)(&((*VdmTib).TraceInfo), Type, wData, lData);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dbgdll\data.c ===
/*
 *  data.c - Main data of DBG DLL.
 *
 */
#include <precomp.h>
#pragma hdrstop

#ifdef i386
PX86CONTEXT     px86;
#endif

DWORD IntelMemoryBase;

DWORD VdmDbgTraceFlags = 0;

BOOL  fDebugged = FALSE;

VDMCONTEXT vcContext;
WORD EventFlags;                // flags defined in VDMDBG.H
VDMINTERNALINFO viInfo;
DWORD EventParams[4];
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dbg\sources.inc ===
!IF 0

Copyright (c) 1989-1991 Microsoft Corporation

Module Name:

    sources.

Abstract:

    This file specifies the target component being built and the list of
    sources files needed to build that component.  Also specifies optional
    compiler switches and libraries that are unique for the component being
    built.

!ENDIF

MAJORCOMP=mvdm
MINORCOMP=dbg

TARGETNAME=dbg
TARGETPATH=obj
TARGETTYPE=LIBRARY

INCLUDES=..\..\inc;..\..\softpc.new\host\inc

SOURCES=..\dbg.c

C_DEFINES=-DWIN_32 -DDEBUG

UMTYPE=console
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dbgdll\brkpt.c ===
/*
 *  brkpt.c - Breakpoint functions of DBG DLL.
 *
 */
#include <precomp.h>
#pragma hdrstop

BOOL bWantsTraceInteractive = FALSE;

VDM_BREAKPOINT VdmBreakPoints[MAX_VDM_BREAKPOINTS] = {0};

#define X86_BP_OPCODE 0xCC


void
DbgSetTemporaryBP(
    WORD Seg,
    DWORD Offset,
    BOOL mode
    )
/*
    This routine writes a 'CC' to the specified location, and sets up
    the breakpoint structure so that we handle it correctly in DbgBPInt().
*/

{
    PBYTE lpInst;

    if (VdmBreakPoints[VDM_TEMPBP].Flags & VDMBP_SET) {

        // remove previous bp

        lpInst = VdmMapFlat(VdmBreakPoints[VDM_TEMPBP].Seg,
                            VdmBreakPoints[VDM_TEMPBP].Offset,
                          ((VdmBreakPoints[VDM_TEMPBP].Flags & VDMBP_V86)==0) ? VDM_PM : VDM_V86 );

        if (lpInst && (*lpInst == X86_BP_OPCODE)) {

            *lpInst = VdmBreakPoints[VDM_TEMPBP].Opcode;

            Sim32FlushVDMPointer(
                    ((ULONG)VdmBreakPoints[VDM_TEMPBP].Seg << 16) +
                            VdmBreakPoints[VDM_TEMPBP].Offset,
                    1,
                    NULL,
                    (BOOL)((VdmBreakPoints[VDM_TEMPBP].Flags & VDMBP_V86)==0) );

        }
    }

    lpInst = VdmMapFlat(Seg, Offset, mode ? VDM_PM : VDM_V86);

    if (lpInst) {

        VdmBreakPoints[VDM_TEMPBP].Seg = Seg;
        VdmBreakPoints[VDM_TEMPBP].Offset = Offset;
        VdmBreakPoints[VDM_TEMPBP].Flags = VDMBP_SET | VDMBP_ENABLED;
        VdmBreakPoints[VDM_TEMPBP].Flags |= (mode ? 0 : VDMBP_V86);
        VdmBreakPoints[VDM_TEMPBP].Opcode = *lpInst;

        *lpInst = X86_BP_OPCODE;

        Sim32FlushVDMPointer(((ULONG)Seg << 16) + Offset, 1, NULL, mode);

    } else {
        VdmBreakPoints[VDM_TEMPBP].Flags = 0;
    }

}




BOOL
xxxDbgBPInt(
    )

/*
 * DbgBPInt
 *
 * Handles an INT 3
 *
 * Exit
 *      Returns TRUE if the event was handled
 *              FALSE if it should be reflected
 */
{
    BOOL            bEventHandled = FALSE;
    ULONG           vdmEip;
    int             i;
    PBYTE           lpInst;


    if ( fDebugged ) {

        DbgGetContext();
        if ((getMSW() & MSW_PE) && SEGMENT_IS_BIG(vcContext.SegCs)) {
            vdmEip = vcContext.Eip;
        } else {
            vdmEip = (ULONG)LOWORD(vcContext.Eip);
        }

        for (i=0; i<MAX_VDM_BREAKPOINTS; i++) {

            if ((VdmBreakPoints[i].Flags & VDMBP_ENABLED) &&
                (VdmBreakPoints[i].Flags & VDMBP_SET) &&
                (vcContext.SegCs == VdmBreakPoints[i].Seg) &&
                (vdmEip == VdmBreakPoints[i].Offset+1)  &&
                (!!(getMSW() & MSW_PE) == !(VdmBreakPoints[i].Flags & VDMBP_V86)) ){

                // We must have hit this breakpoint. Back up the eip and
                // restore the original data
                setEIP(getEIP()-1);
                vcContext.Eip--;

                lpInst = VdmMapFlat(VdmBreakPoints[i].Seg, 
                                    VdmBreakPoints[i].Offset,
                                   ((VdmBreakPoints[i].Flags & VDMBP_V86)==0) ? VDM_PM : VDM_V86 );

                if (lpInst && (*lpInst == X86_BP_OPCODE)) {
                    *lpInst = VdmBreakPoints[i].Opcode;

                    Sim32FlushVDMPointer(
                                ((ULONG)VdmBreakPoints[i].Seg << 16) +
                                        VdmBreakPoints[i].Offset,
                                1,
                                NULL,
                                (BOOL)((VdmBreakPoints[i].Flags & VDMBP_V86)==0) );

                    VdmBreakPoints[i].Flags |= VDMBP_PENDING;
                    VdmBreakPoints[i].Flags &= ~VDMBP_FLUSH;
                    if (i == VDM_TEMPBP) {
                        // non-persistent breakpoint
                        VdmBreakPoints[i].Flags &= ~VDMBP_SET;
                    }
                }

                SendVDMEvent( DBG_BREAK );

                bEventHandled = TRUE;

                bWantsTraceInteractive = (BOOL) (vcContext.EFlags & V86FLAGS_TRACE);

                if (bWantsTraceInteractive || (i != VDM_TEMPBP)) {
                    vcContext.EFlags |= V86FLAGS_TRACE;
                }
                RestoreVDMContext(&vcContext);

                break;

            }
        }

        if (!bEventHandled) {
            OutputDebugString("VDM: Unexpected breakpoint hit\n");
            SendVDMEvent( DBG_BREAK );
            bWantsTraceInteractive = (BOOL) (vcContext.EFlags & V86FLAGS_TRACE);
            RestoreVDMContext(&vcContext);
        }

        bEventHandled = TRUE;

    }

    return bEventHandled;
}



BOOL
xxxDbgTraceInt(
    )

/*
 * DbgTraceInt
 *
 * Handles an INT 1 fault
 *
 * Exit
 *      Returns TRUE if the event was handled
 *              FALSE if it should be reflected
 */
{
    BOOL            bEventHandled = FALSE;
    int             i;
    PBYTE           lpInst;


    if ( fDebugged ) {

        DbgGetContext();
        setEFLAGS(vcContext.EFlags & ~V86FLAGS_TRACE);

        for (i=0; i<MAX_VDM_BREAKPOINTS; i++) {

            if ((VdmBreakPoints[i].Flags & VDMBP_ENABLED) &&
                (VdmBreakPoints[i].Flags & VDMBP_SET) &&
                (VdmBreakPoints[i].Flags & VDMBP_PENDING)) {


                lpInst = VdmMapFlat(VdmBreakPoints[i].Seg, 
                                    VdmBreakPoints[i].Offset,
                                   ((VdmBreakPoints[i].Flags & VDMBP_V86)==0) ? VDM_PM : VDM_V86 );

                if (lpInst) {
                    *lpInst = X86_BP_OPCODE;
                }

                Sim32FlushVDMPointer(
                            ((ULONG)VdmBreakPoints[i].Seg << 16) +
                                    VdmBreakPoints[i].Offset,
                            1,
                            NULL,
                            (BOOL)((VdmBreakPoints[i].Flags & VDMBP_V86)==0) );

                VdmBreakPoints[i].Flags &= ~(VDMBP_PENDING | VDMBP_FLUSH);

                bEventHandled = TRUE;
            }

        }

        if (bWantsTraceInteractive) {

            SendVDMEvent( DBG_BREAK );
            RestoreVDMContext(&vcContext);
            bWantsTraceInteractive = (BOOL) (vcContext.EFlags & V86FLAGS_TRACE);

        } else if (!bEventHandled) {

            OutputDebugString("VDM: Unexpected trace interrupt\n");
            SendVDMEvent( DBG_BREAK );
            bWantsTraceInteractive = (BOOL) (vcContext.EFlags & V86FLAGS_TRACE);
            RestoreVDMContext(&vcContext);

        }

        bEventHandled = TRUE;

    }

    return bEventHandled;
}


VOID
FlushVdmBreakPoints(
    )
{
    int i;

    for (i=0; i<MAX_VDM_BREAKPOINTS; i++) {

        if (VdmBreakPoints[i].Flags & VDMBP_FLUSH) {

            Sim32FlushVDMPointer(
                    ((ULONG)VdmBreakPoints[i].Seg << 16) +
                            VdmBreakPoints[i].Offset,
                    1,
                    NULL,
                    (BOOL)((VdmBreakPoints[i].Flags & VDMBP_V86)==0) );

            VdmBreakPoints[i].Flags &= ~VDMBP_FLUSH;

        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dbgdll\dbgdll.h ===
/*
 *  dbgdll.h - Main header file of DBG DLL.
 *
 */


#ifdef i386
extern PX86CONTEXT     px86;
#endif

extern DECLSPEC_IMPORT VDMLDT_ENTRY *ExpLdt;
#define SEGMENT_IS_BIG(sel) (ExpLdt[(sel & ~0x7)/sizeof(VDMLDT_ENTRY)].HighWord.Bits.Default_Big)

extern DWORD IntelMemoryBase;
extern DWORD VdmDbgTraceFlags;
extern BOOL  fDebugged;

extern VDMCONTEXT vcContext;
extern WORD EventFlags;
extern VDMINTERNALINFO viInfo;
extern DWORD EventParams[4];

extern VDM_BREAKPOINT VdmBreakPoints[MAX_VDM_BREAKPOINTS];


#define MAX_MODULE  64
#define MAX_DBG_FRAME   10

typedef struct _trapframe {
    WORD    wCode;          /* Noise from DbgDispatchBop */
    WORD    wAX;            /* AX at time of fault */
    WORD    wDS;            /* DS at time of fault */
    WORD    wRetIP;         /* Noise from DPMI */
    WORD    wRetCS;         /* Noise from DPMI */
    WORD    wErrCode;       /* Noise from 16-bit kernel */
    WORD    wIP;            /* IP at time of fault */
    WORD    wCS;            /* CS at time of fault */
    WORD    wFlags;         /* Flags at time of fault */
    WORD    wSP;            /* SS at time of fault */
    WORD    wSS;            /* SP at time of fault */
} TFRAME16;
typedef TFRAME16 UNALIGNED *PTFRAME16;

typedef struct _faultframe {
    WORD    wES;            /* ES at time of fault */
    WORD    wDS;            /* DS at time of fault */
    WORD    wDI;            /* DI at time of fault */
    WORD    wSI;            /* SI at time of fault */
    WORD    wTempBP;        /* Noise from 16-bit kernel stack frame */
    WORD    wTempSP;        /* Noise from 16-bit kernel stack frame */
    WORD    wBX;            /* BX at time of fault */
    WORD    wDX;            /* DX at time of fault */
    WORD    wCX;            /* CX at time of fault */
    WORD    wAX;            /* AX at time of fault */
    WORD    wBP;            /* BP at time of fault */
    WORD    npszMsg;        /* Noise from 16-bit kernel */
    WORD    wPrevIP;        /* Noise from DPMI */
    WORD    wPrevCS;        /* Noise from DPMI */
    WORD    wRetIP;         /* Noise from DPMI */
    WORD    wRetCS;         /* Noise from DPMI */
    WORD    wErrCode;       /* Noise from 16-bit kernel */
    WORD    wIP;            /* IP at time of fault */
    WORD    wCS;            /* CS at time of fault */
    WORD    wFlags;         /* Flags at time of fault */
    WORD    wSP;            /* SS at time of fault */
    WORD    wSS;            /* SP at time of fault */
} FFRAME16;
typedef FFRAME16 UNALIGNED *PFFRAME16;

typedef struct _newtaskframe {
    DWORD   dwNoise;            /* Noise from InitTask         */
    DWORD   dwModulePath;       /* Module path address         */
    DWORD   dwModuleName;       /* Module name address         */
    WORD    hModule;            /* 16-bit Module handle        */
    WORD    hTask;              /* 16-bit Task handle          */
    WORD    wFlags;             /* Flags at time to task start */
    WORD    wDX;                /* DX at time of task start    */
    WORD    wBX;                /* BX at time of task start    */
    WORD    wES;                /* ES at time of task start    */
    WORD    wCX;                /* CX at time of task start    */
    WORD    wAX;                /* AX at time of task start    */
    WORD    wDI;                /* DI at time of task start    */
    WORD    wSI;                /* SI at time of task start    */
    WORD    wDS;                /* DS at time of task start    */
    WORD    wBP;                /* BP at time of task start    */
    WORD    wIP;                /* IP for task start           */
    WORD    wCS;                /* CS for task start           */
} NTFRAME16;
typedef NTFRAME16 UNALIGNED *PNTFRAME16;

#pragma pack(2)

typedef struct _stoptaskframe {
    WORD    wCode;              /* Noise from BOP Dispatcher  */
    DWORD   dwModulePath;       /* Module path address        */
    DWORD   dwModuleName;       /* Module name address        */
    WORD    hModule;            /* 16-bit Module handle       */
    WORD    hTask;              /* 16-bit Task handle         */
} STFRAME16;
typedef STFRAME16 UNALIGNED *PSTFRAME16;

typedef struct _newdllframe {
    WORD    wCode;              /* Noise from DbgDispatchBop  */
    DWORD   dwModulePath;       /* Module path address        */
    DWORD   dwModuleName;       /* Module name address        */
    WORD    hModule;            /* 16-bit Module handle       */
    WORD    hTask;              /* 16-bit Task handle         */
    WORD    wDS;                /* DS at time of dll start    */
    WORD    wAX;                /* AX at time of dll start    */
    WORD    wIP;                /* IP at time of dll start    */
    WORD    wCS;                /* CS at time of dll start    */
    WORD    wFlags;             /* Flags at time of dll start */
} NDFRAME16;
typedef NDFRAME16 UNALIGNED *PNDFRAME16;

#pragma pack()

VOID
DbgAttach(
    VOID
    );

VOID
FlushVdmBreakPoints(
    VOID
    );

BOOL
SendVDMEvent(
    WORD wEventType
    );

VOID
DbgGetContext(
    VOID
    );

void
DbgSetTemporaryBP(
    WORD Seg,
    DWORD Offset,
    BOOL mode
    );

void SegmentLoad(
    LPSTR   lpModuleName,
    LPSTR   lpPathName,
    WORD    Selector,
    WORD    Segment,
    BOOL    fData
    );

void SegmentMove(
    WORD    OldSelector,
    WORD    NewSelector
    );

void SegmentFree(
    WORD    Selector,
    BOOL    fBPRelease
    );

void ModuleLoad(
    LPSTR   lpModuleName,
    LPSTR   lpPathName,
    WORD    Segment,
    DWORD   Length
    );

void ModuleSegmentMove(
    LPSTR   lpModuleName,
    LPSTR   lpPathName,
    WORD    ModuleSegment,
    WORD    OldSelector,
    WORD    NewSelector,
    DWORD   Length
    );

void ModuleFree(
    LPSTR   lpModuleName,
    LPSTR   lpPathName
    );

BOOL DbgGPFault2(
    PFFRAME16   pFFrame
    );

BOOL DbgDivOverflow2(
    PTFRAME16   pTFrame
    );

VOID
RestoreVDMContext(
    VDMCONTEXT *vcContext
    );

VOID
DbgDosAppStart(
    WORD wCS,
    WORD wIP
    );

BOOL
DbgDllStart(
    PNDFRAME16  pNDFrame
    );

BOOL
DbgTaskStop(
    PSTFRAME16  pSTFrame
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dbgdll\excptn.c ===
/*
 *  excptn.c - Exception functions of DBG DLL.
 *
 */
#include <precomp.h>
#pragma hdrstop



BOOL DbgGPFault2(
    PFFRAME16   pFFrame
    )
/*
    2nd chance GPFault handler (called via BOP)
*/
{
    BOOL            fResult;

    fResult = FALSE;        // Default to Event not handled

    DbgGetContext();

    vcContext.SegEs = (ULONG)pFFrame->wES;
    vcContext.SegDs = (ULONG)pFFrame->wDS;
    vcContext.SegCs = (ULONG)pFFrame->wCS;
    vcContext.SegSs = (ULONG)pFFrame->wSS;

#ifdef i386
    //
    // On x86 systems, we really might have some data in the high words
    // of these registers.  Hopefully DOSX.EXE and KRNL286.EXE don't
    // blow them away.  Here is where we attempt to recover them.
    //
    vcContext.Edi    = MAKELONG(pFFrame->wDI,   HIWORD(px86->Edi   ));
    vcContext.Esi    = MAKELONG(pFFrame->wSI,   HIWORD(px86->Esi   ));
    vcContext.Ebx    = MAKELONG(pFFrame->wBX,   HIWORD(px86->Ebx   ));
    vcContext.Edx    = MAKELONG(pFFrame->wDX,   HIWORD(px86->Edx   ));
    vcContext.Ecx    = MAKELONG(pFFrame->wCX,   HIWORD(px86->Ecx   ));
    vcContext.Eax    = MAKELONG(pFFrame->wAX,   HIWORD(px86->Eax   ));

    vcContext.Ebp    = MAKELONG(pFFrame->wBP,   HIWORD(px86->Ebp   ));
    vcContext.Eip    = MAKELONG(pFFrame->wIP,   HIWORD(px86->Eip   ));
    vcContext.Esp    = MAKELONG(pFFrame->wSP,   HIWORD(px86->Esp   ));
    vcContext.EFlags = MAKELONG(pFFrame->wFlags,HIWORD(px86->EFlags));
#else
    vcContext.Edi    = (ULONG)pFFrame->wDI;
    vcContext.Esi    = (ULONG)pFFrame->wSI;
    vcContext.Ebx    = (ULONG)pFFrame->wBX;
    vcContext.Edx    = (ULONG)pFFrame->wDX;
    vcContext.Ecx    = (ULONG)pFFrame->wCX;
    vcContext.Eax    = (ULONG)pFFrame->wAX;

    vcContext.Ebp    = (ULONG)pFFrame->wBP;
    vcContext.Eip    = (ULONG)pFFrame->wIP;
    vcContext.Esp    = (ULONG)pFFrame->wSP;
    vcContext.EFlags = (ULONG)pFFrame->wFlags;

#endif

    if ( fDebugged ) {
        fResult = SendVDMEvent(DBG_GPFAULT2);

        if ( !fResult ) {
            DWORD dw;

            dw = SetErrorMode(0);
            try {
                RaiseException((DWORD)DBG_CONTROL_BREAK, 0, 0, (LPDWORD)0);
                fResult = TRUE;
            } except (EXCEPTION_EXECUTE_HANDLER) {
                fResult = FALSE;
            }
            SetErrorMode(dw);
        }

    } else {
        char    text[100];

        // Dump a simulated context

        OutputDebugString("NTVDM:GP Fault detected, register dump follows:\n");

        wsprintf(text,"eax=%08lx ebx=%08lx ecx=%08lx edx=%08lx esi=%08lx edi=%08lx\n",
            vcContext.Eax,
            vcContext.Ebx,
            vcContext.Ecx,
            vcContext.Edx,
            vcContext.Esi,
            vcContext.Edi  );
        OutputDebugString(text);

        wsprintf(text,"eip=%08lx esp=%08lx ebp=%08lx iopl=%d         %s %s %s %s %s %s %s %s\n",
            vcContext.Eip,
            vcContext.Esp,
            vcContext.Ebp,
            (vcContext.EFlags & V86FLAGS_IOPL) >> V86FLAGS_IOPL_BITS,
            (vcContext.EFlags & V86FLAGS_OVERFLOW ) ? "ov" : "nv",
            (vcContext.EFlags & V86FLAGS_DIRECTION) ? "dn" : "up",
            (vcContext.EFlags & V86FLAGS_INTERRUPT) ? "ei" : "di",
            (vcContext.EFlags & V86FLAGS_SIGN     ) ? "ng" : "pl",
            (vcContext.EFlags & V86FLAGS_ZERO     ) ? "zr" : "nz",
            (vcContext.EFlags & V86FLAGS_AUXCARRY ) ? "ac" : "na",
            (vcContext.EFlags & V86FLAGS_PARITY   ) ? "po" : "pe",
            (vcContext.EFlags & V86FLAGS_CARRY    ) ? "cy" : "nc" );
        OutputDebugString(text);

        wsprintf(text,"cs=%04x  ss=%04x  ds=%04x  es=%04x  fs=%04x  gs=%04x             efl=%08lx\n",
            (WORD)vcContext.SegCs,
            (WORD)vcContext.SegSs,
            (WORD)vcContext.SegDs,
            (WORD)vcContext.SegEs,
            (WORD)vcContext.SegFs,
            (WORD)vcContext.SegGs,
            vcContext.EFlags );
        OutputDebugString(text);
    }

#ifdef i386
    //
    // On x86 systems, we really might have some data in the FS and GS
    // registers.  Hopefully DOSX.EXE and KRNL286.EXE don't
    // blow them away.  Here is where we attempt to restore them.
    //
    px86->SegGs = (WORD)vcContext.SegGs;
    px86->SegFs = (WORD)vcContext.SegFs;
#else
    // No need to set FS,GS, they don't exist
#endif

    pFFrame->wES = (WORD)vcContext.SegEs;
    pFFrame->wDS = (WORD)vcContext.SegDs;
    pFFrame->wCS = (WORD)vcContext.SegCs;
    pFFrame->wSS = (WORD)vcContext.SegSs;

#ifdef i386
    //
    // On x86 systems, we really might have some data in the high words
    // of these registers.  Hopefully DOSX.EXE and KRNL286.EXE don't
    // blow them away.  Here is where we attempt to restore them.
    //
    pFFrame->wDI = LOWORD(vcContext.Edi);
    px86->Edi = MAKELONG(LOWORD(px86->Edi),HIWORD(vcContext.Edi));

    pFFrame->wSI = LOWORD(vcContext.Esi);
    px86->Esi = MAKELONG(LOWORD(px86->Esi),HIWORD(vcContext.Esi));

    pFFrame->wBX = LOWORD(vcContext.Ebx);
    px86->Ebx = MAKELONG(LOWORD(px86->Ebx),HIWORD(vcContext.Ebx));

    pFFrame->wDX = LOWORD(vcContext.Edx);
    px86->Edx = MAKELONG(LOWORD(px86->Edx),HIWORD(vcContext.Edx));

    pFFrame->wCX = LOWORD(vcContext.Ecx);
    px86->Ecx = MAKELONG(LOWORD(px86->Ecx),HIWORD(vcContext.Ecx));

    pFFrame->wAX = LOWORD(vcContext.Eax);
    px86->Eax = MAKELONG(LOWORD(px86->Eax),HIWORD(vcContext.Eax));

    pFFrame->wBP = LOWORD(vcContext.Ebp);
    px86->Ebp = MAKELONG(LOWORD(px86->Ebp),HIWORD(vcContext.Ebp));

    pFFrame->wIP = LOWORD(vcContext.Eip);
    px86->Eip = MAKELONG(LOWORD(px86->Eip),HIWORD(vcContext.Eip));

    pFFrame->wFlags = LOWORD(vcContext.EFlags);
    px86->EFlags = MAKELONG(LOWORD(px86->EFlags),HIWORD(vcContext.EFlags));

    pFFrame->wSP = LOWORD(vcContext.Esp);
    px86->Esp = MAKELONG(LOWORD(px86->Esp),HIWORD(vcContext.Esp));
#else
    pFFrame->wDI = (WORD)vcContext.Edi;
    pFFrame->wSI = (WORD)vcContext.Esi;
    pFFrame->wBX = (WORD)vcContext.Ebx;
    pFFrame->wDX = (WORD)vcContext.Edx;
    pFFrame->wCX = (WORD)vcContext.Ecx;
    pFFrame->wAX = (WORD)vcContext.Eax;


    pFFrame->wBP = (WORD)vcContext.Ebp;
    pFFrame->wIP = (WORD)vcContext.Eip;
    pFFrame->wFlags = (WORD)vcContext.EFlags;
    pFFrame->wSP = (WORD)vcContext.Esp;
#endif

    return( fResult );
}

BOOL DbgDivOverflow2(
    PTFRAME16   pTFrame
    )
/*
    2nd chance divide exception handler
*/
{
    BOOL        fResult;

    fResult = FALSE;        // Default to Event not handled

    if ( fDebugged ) {

        DbgGetContext();

        vcContext.SegDs = (ULONG)pTFrame->wDS;
        vcContext.SegCs = (ULONG)pTFrame->wCS;
        vcContext.SegSs = (ULONG)pTFrame->wSS;

#ifdef i386
        //
        // On x86 systems, we really might have some data in the high words
        // of these registers.  Hopefully DOSX.EXE and KRNL286.EXE don't
        // blow them away.  Here is where we attempt to recover them.
        //
        vcContext.Eax    = MAKELONG(pTFrame->wAX,   HIWORD(px86->Eax   ));
        vcContext.Eip    = MAKELONG(pTFrame->wIP,   HIWORD(px86->Eip   ));
        vcContext.Esp    = MAKELONG(pTFrame->wSP,   HIWORD(px86->Esp   ));
        vcContext.EFlags = MAKELONG(pTFrame->wFlags,HIWORD(px86->EFlags));
#else
        vcContext.Eax    = (ULONG)pTFrame->wAX;

        vcContext.Eip    = (ULONG)pTFrame->wIP;
        vcContext.Esp    = (ULONG)pTFrame->wSP;
        vcContext.EFlags = (ULONG)pTFrame->wFlags;

#endif

        fResult = SendVDMEvent(DBG_DIVOVERFLOW);

#ifdef i386
        //
        // On x86 systems, we really might have some data in the FS and GS
        // registers.  Hopefully DOSX.EXE and KRNL286.EXE don't
        // blow them away.  Here is where we attempt to restore them.
        //
        px86->SegGs = vcContext.SegGs;
        px86->SegFs = vcContext.SegFs;
#else
        // No need to set FS,GS, they don't exist
#endif

        setES( (WORD)vcContext.SegEs );
        pTFrame->wDS = (WORD)vcContext.SegDs;
        pTFrame->wCS = (WORD)vcContext.SegCs;
        pTFrame->wSS = (WORD)vcContext.SegSs;

#ifdef i386
        //
        // On x86 systems, we really might have some data in the high words
        // of these registers.  Hopefully DOSX.EXE and KRNL286.EXE don't
        // blow them away.  Here is where we attempt to restore them.
        //
        setEDI( vcContext.Edi );
        setESI( vcContext.Esi );
        setEBX( vcContext.Ebx );
        setEDX( vcContext.Edx );
        setECX( vcContext.Ecx );

        pTFrame->wAX = LOWORD(vcContext.Eax);
        px86->Eax = MAKELONG(LOWORD(px86->Eax),HIWORD(vcContext.Eax));

        setEBP( vcContext.Ebp );

        pTFrame->wIP = LOWORD(vcContext.Eip);
        px86->Eip = MAKELONG(LOWORD(px86->Eip),HIWORD(vcContext.Eip));

        pTFrame->wFlags = LOWORD(vcContext.EFlags);
        px86->EFlags = MAKELONG(LOWORD(px86->EFlags),HIWORD(vcContext.EFlags));

        pTFrame->wSP = LOWORD(vcContext.Esp);
        px86->Esp = MAKELONG(LOWORD(px86->Esp),HIWORD(vcContext.Esp));
#else
        setDI( (WORD)vcContext.Edi );
        setSI( (WORD)vcContext.Esi );
        setBX( (WORD)vcContext.Ebx );
        setDX( (WORD)vcContext.Edx );
        setCX( (WORD)vcContext.Ecx );
        pTFrame->wAX = (WORD)vcContext.Eax;


        setBP( (WORD)vcContext.Ebp );
        pTFrame->wIP    = (WORD)vcContext.Eip;
        pTFrame->wFlags = (WORD)vcContext.EFlags;
        pTFrame->wSP    = (WORD)vcContext.Esp;
#endif


    }

    return( fResult );
}



BOOL
xxxDbgFault(
    ULONG IntNumber
    )
/*
    This is the first chance exception handler. It is called by dpmi32
*/

{
    ULONG           vdmEip;
    int             i;
    PBYTE           lpInst;
    BOOL            fResult = FALSE;


    if ( fDebugged ) {

        switch(IntNumber) {
        case 6:
            //BUGBUG: We *could* handle these, but people might be confused by
            // the fact that krnl386 does an intentional opcode exception.
//            GetNormalContext( &vcContext, &viInfo, EventParams, DBG_INSTRFAULT, PX86 );
            break;

        case 12:
            if (*(ULONG *)(IntelMemoryBase+FIXED_NTVDMSTATE_LINEAR) & VDM_BREAK_EXCEPTIONS) {
                DbgGetContext();
                fResult = SendVDMEvent(DBG_STACKFAULT);
            }
            break;

        case 13:
            if (*(ULONG *)(IntelMemoryBase+FIXED_NTVDMSTATE_LINEAR) & VDM_BREAK_EXCEPTIONS) {
                DbgGetContext();
                fResult = SendVDMEvent(DBG_GPFAULT);
            }
            break;

        default:
            return FALSE;
        }
    }

    return fResult;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dbgdll\dbgdll.c ===
/*++
 *  Main module of DBG DLL.
 *
 *  Copyright (c) 1997, Microsoft Corporation
 *
 *  This code runs in the debuggee's process.
 *
--*/
#include <precomp.h>
#pragma hdrstop


BOOL InVdmDebugger = FALSE;
BOOL bWantsNtsdPrompt = FALSE;

ULONG   ulTHHOOK = 0L;          // Address registered from 16-bit world
LPVOID  lpRemoteAddress = NULL; // Address registered from WOW32
DWORD   lpRemoteBlock   = 0;    // Address registered from WOW32
BOOL    f386;
DWORD VdmDbgEFLAGS;

WORD DbgWowhExeHead = 0;
WORD DbgWowhGlobalHeap = 0;
PDWORD lpVdmState = NULL;
PBYTE lpNtCpuInfo = NULL;

UCHAR DbgTimerMode = VDMTI_TIMER_TICK;
BOOL DbgTimerInitialized = FALSE;
VOID VdmDbgAttach(VOID);


BOOLEAN
DbgDllInitialize(
    IN PVOID DllHandle,
    IN ULONG Reason,
    IN PCONTEXT Context OPTIONAL
    )
/*
 * DBGDllInitialize - DBG Initialiazation routine.
 *
 */

{
    HANDLE      MyDebugPort;
    DWORD       st;
    BOOL        fAlreadyDebugged;

    UNREFERENCED_PARAMETER(Context);

    switch ( Reason ) {

    case DLL_PROCESS_ATTACH:

#ifdef i386
        // X86 Only, get pointer to Register Context Block
        px86 = getIntelRegistersPointer();
#endif

        st = NtQueryInformationProcess(
                    NtCurrentProcess(),
                    ProcessDebugPort,
                    (PVOID)&MyDebugPort,
                    sizeof(MyDebugPort),
                    NULL );
        if ( NT_SUCCESS(st) ) {
            fDebugged = (MyDebugPort != NULL);
        } else {
            fDebugged = FALSE;
        }

        if (fDebugged) {
            DbgAttach();
        }
        break;

    case DLL_THREAD_ATTACH:
        //
        // See if the debugger is attaching. If it is, then turn on the
        // default of breaking into the debugger.
        //
        fAlreadyDebugged = fDebugged;

        st = NtQueryInformationProcess(
                    NtCurrentProcess(),
                    ProcessDebugPort,
                    (PVOID)&MyDebugPort,
                    sizeof(MyDebugPort),
                    NULL );
        if ( NT_SUCCESS(st) ) {
            fDebugged = (MyDebugPort != NULL);
        } else {
            fDebugged = FALSE;
        }

        if (fDebugged && !fAlreadyDebugged) {
            DbgAttach();
        }
        break;

    case DLL_THREAD_DETACH:
        break;

    case DLL_PROCESS_DETACH:
        break;

    default:
        break;
    }
    return( TRUE );
}

void
DbgAttach(
    void
    )
/*
 *  DbgAttach
 *
 *  Called to initiate the communication with a debugger
 *
 */
{
    //
    // Send DBG_ATTACH notification
    //
    DbgGetContext();
    SendVDMEvent(DBG_ATTACH);

    //
    // This call tells ntvdm to resync with us
    //
    VdmDbgAttach();
}

BOOL
WINAPI
xxxDbgInit(
    PVOID pState,
    ULONG InitialVdmDbgFlags,
    PVOID pCpuInfo
    )
/*
 *  DbgInit
 *
 *  Called once ntvdm has completed it's initialization. Now it
 *  is possible to compute for example the IntelMemoryBase.
 *
 */
{

    VdmDbgTraceFlags = InitialVdmDbgFlags;
    lpVdmState = pState;
    IntelMemoryBase = (ULONG)VdmMapFlat(0, 0, VDM_V86);
    lpNtCpuInfo = pCpuInfo;

    //
    // turn on default debugging bits in ntvdmstate
    //
    *lpVdmState |= VDM_BREAK_DEBUGGER;
#if DBG
    *lpVdmState |= VDM_TRACE_HISTORY;
#endif

    if (fDebugged) {
        DbgGetContext();
        SendVDMEvent(DBG_INIT);
    }
    return TRUE;
}

BOOL
WINAPI
xxxDbgIsDebuggee(
    void
    )
/*
 * DbgIsDebuggee
 *
 * Determines if we are being debugged
 *
 * Entry: void
 *
 * Exit:  BOOL bRet - TRUE we are being debugged
 *
 */
{
   return fDebugged;
}

BOOL
SendVDMEvent(
    WORD wEventType
    )

/* SendVDMEvent
 *
 * Sends a VDM event notification to the debugger
 *
 * Entry:
 *
 * Exit:  BOOL bRet
 *        Returns TRUE if exception was handled, FALSE otherwise
 *
 */
{
    BOOL    fResult;

    EventParams[0] = MAKELONG( wEventType, EventFlags );
    EventParams[3] = (DWORD)&viInfo;

    InVdmDebugger = TRUE;

    do {

        bWantsNtsdPrompt = FALSE;


        // Slimyness to determine whether the exception was handled or not.

        try {
            RaiseException( STATUS_VDM_EVENT,
                            0,
                            4,
                            EventParams );
            fResult = TRUE;
        } except(EXCEPTION_EXECUTE_HANDLER) {
            fResult = FALSE;
        }

        //
        // bWantsNtsdPrompt may be changed by vdmexts
        //
        if (bWantsNtsdPrompt) {
            DbgBreakPoint();
        }

    } while (bWantsNtsdPrompt);


    InVdmDebugger = FALSE;
    FlushVdmBreakPoints();

    return( fResult );
}


VOID
DbgGetContext(
    VOID
    )

/* DbgGetContext() - Get the VDM's current context
 *
 * Most of the routines that send VDMEvents need to have a context record
 * associated with them.  This routine is a quick way to get most of the
 * general registers.  Redundant work is being done because AX for example
 * is often on the stack and as such must really be pulled from the frame.
 * Hopefully this is OK because it is fast.
 */

{
    //
    // Everything defaults to 0.
    //
    RtlFillMemory( &vcContext, sizeof(VDMCONTEXT), (UCHAR)0 );
    RtlFillMemory( &viInfo, sizeof(VDMINTERNALINFO), (UCHAR)0 );

    //
    // Fill in the internal info structure
    //
    viInfo.dwLdtBase       = (DWORD)ExpLdt;
    viInfo.dwIntelBase     = IntelMemoryBase;
    viInfo.wKernelSeg      = HIWORD(ulTHHOOK);
    viInfo.dwOffsetTHHOOK  = (DWORD)(LOWORD(ulTHHOOK));
    viInfo.vdmContext      = &vcContext;
    viInfo.lpRemoteAddress = lpRemoteAddress;
    viInfo.lpRemoteBlock   = lpRemoteBlock;
    viInfo.f386            = f386;
    viInfo.lpNtvdmState    = lpVdmState;
    viInfo.lpVdmDbgFlags   = &VdmDbgTraceFlags;
    viInfo.lpNtCpuInfo     = lpNtCpuInfo;
    viInfo.lpVdmBreakPoints= &VdmBreakPoints;
   
    EventFlags = 0;                                                           
    if(NtCurrentTeb()->Vdm) {
       //                                                                        
       // Fill in the context structure                                          
       //                                                                        
       vcContext.SegEs = (ULONG)getES();                                         
       vcContext.SegDs = (ULONG)getDS();                                         
       vcContext.SegCs = (ULONG)getCS();                                         
       vcContext.SegSs = (ULONG)getSS();                                         
       vcContext.SegFs = (ULONG)getFS();                                         
       vcContext.SegGs = (ULONG)getGS();                                         
                                                                                 
       vcContext.EFlags = getEFLAGS();                                           
       VdmDbgEFLAGS = vcContext.EFlags;            // save for vdmexts           
                                                                                 
       vcContext.Edi = getEDI();                                                 
       vcContext.Esi = getESI();                                                 
       vcContext.Ebx = getEBX();                                                 
       vcContext.Edx = getEDX();                                                 
       vcContext.Ecx = getECX();                                                 
       vcContext.Eax = getEAX();                                                 
                                                                                 
       vcContext.Ebp = getEBP();                                                 
       vcContext.Eip = getEIP();                                                 
       vcContext.Esp = getESP();                                                 
                                                                                 
       //                                                                        
       // Put in special flags in event field                                    
       //                                                                        
                                                                                        
       if (!(getMSW() & MSW_PE) || (getEFLAGS() & V86FLAGS_V86)) {               
           EventFlags |= VDMEVENT_V86;  // emulator is in real or v86 mode       
       } else {                                                                  
           EventFlags |= VDMEVENT_PE;                                            
                                                                                 
           if ((getMSW() & MSW_PE) && !SEGMENT_IS_BIG(vcContext.SegCs)) {        
               EventFlags |= VDMEVENT_PM16;  // emulator is in real or v86 mode  
           }                                                                     
       }                                                                         
    }
}

void
WINAPI
xxxDbgDispatch()
{
    UNALIGNED WORD  *stack;
    WORD            mode;
    WORD            selector;
    WORD            segment;
    WORD            new_selector;
    BOOL            fBPRelease;
    BOOL            fData;
    LPSTR           lpModuleName;
    LPSTR           lpPathName;
    UCHAR           fPE;
    PFFRAME16       pFFrame;
    PTFRAME16       pTFrame;
    PNDFRAME16      pNDFrame;
    PSTFRAME16      pSTFrame;
    WORD            wFrame;

    fPE = ISPESET;

    stack = (UNALIGNED WORD *)Sim32GetVDMPointer(
                        ((ULONG)getSS() << 16) + (ULONG)getSP(),
                        MAX_DBG_FRAME, fPE );

    mode = *stack++;

    //
    // If there is no debugger, then only handle DBG_WOWINIT
    //
    if (!fDebugged && (mode != DBG_WOWINIT)) {
        return;
    }

    switch( mode ) {
        case DBG_SEGLOAD:
            selector = *stack++;
            segment  = *stack++;
            lpModuleName = (LPSTR)Sim32GetVDMPointer(
                                    (ULONG)*stack + ((ULONG)(*(stack+1)) << 16),
                                    0, fPE );
            stack += 2;
            lpPathName = (LPSTR)Sim32GetVDMPointer(
                                    (ULONG)*stack + ((ULONG)(*(stack+1)) << 16),
                                    0, fPE );
            if ( lpPathName == NULL ) {
                lpPathName = "";
            }

            stack += 2;
            fData = (BOOL)(*stack++);
            SegmentLoad( lpModuleName, lpPathName, selector, segment, fData );
            break;

        case DBG_SEGMOVE:
            selector = *stack++;
            new_selector = *stack++;
            SegmentMove( selector, new_selector );
            break;

        case DBG_SEGFREE:
            fBPRelease = (BOOL)*stack++;
            selector = *stack++;
            SegmentFree( selector, fBPRelease );
            break;

        case DBG_MODFREE:
            lpModuleName = (LPSTR)Sim32GetVDMPointer(
                                    (ULONG)*stack + ((ULONG)(*(stack+1)) << 16),
                                    0, fPE );
            stack += 2;
            lpPathName = (LPSTR)Sim32GetVDMPointer(
                                    (ULONG)*stack + ((ULONG)(*(stack+1)) << 16),
                                    0, fPE );
            if ( lpPathName == NULL ) {
                lpPathName = "";
            }
            ModuleFree( lpModuleName, lpPathName );
            break;

        case DBG_GPFAULT2:
            wFrame = getBP() - (WORD)(FIELD_OFFSET(FFRAME16,wBP));

            pFFrame = (PFFRAME16)Sim32GetVDMPointer(
                        ((ULONG)getSS() << 16) + (ULONG)wFrame,
                        MAX_DBG_FRAME, fPE );


            fData = DbgGPFault2( pFFrame );

            setAX((WORD)fData);
            break;

        case DBG_DIVOVERFLOW:
            pTFrame = (PTFRAME16)Sim32GetVDMPointer(
                        (ULONG)((ULONG)getSS() << 16) + (ULONG)getSP(),
                        MAX_DBG_FRAME, fPE );


            fData = DbgDivOverflow2( pTFrame );

            setAX((WORD)fData);
            break;

        case DBG_DLLSTART:
            pNDFrame = (PNDFRAME16)Sim32GetVDMPointer(
                        (ULONG)((ULONG)getSS() << 16) + (ULONG)getSP(),
                        MAX_DBG_FRAME, fPE );


            fData = DbgDllStart( pNDFrame );

            setAX((WORD)fData);
            break;

        case DBG_TASKSTOP:
            pSTFrame = (PSTFRAME16)Sim32GetVDMPointer(
                        (ULONG)((ULONG)getSS() << 16) + (ULONG)getSP(),
                        MAX_DBG_FRAME, fPE );

            fData = DbgTaskStop( pSTFrame );
            break;

        case DBG_ATTACH:
            break;

        case DBG_TOOLHELP:
            ulTHHOOK = (ULONG)*stack + ((ULONG)(*(stack+1)) << 16);
            stack += 2;
            f386 = (BOOL)*stack;
            break;

        case DBG_WOWINIT:
            //
            // Pass in some data from KRNL386 so that VDMEXTS can get a
            // hold of them.
            //
            DbgWowhExeHead = getDX();
            DbgWowhGlobalHeap = getCX();
            break;

        default:
            setAX(0);       // Event not handled
            break;
    }
}



VOID
xxxDbgNotifyRemoteThreadAddress(
    LPVOID  lpAddress,
    DWORD   lpBlock
) {
    lpRemoteAddress = lpAddress;
    lpRemoteBlock   = lpBlock;
}

VOID
xxxDbgNotifyDebugged(
    BOOL    fNewDebugged
) {
    fDebugged = fNewDebugged;
}



VOID
RestoreVDMContext(
    VDMCONTEXT *vcContext
    )
{

    setEAX(vcContext->Eax);
    setEBX(vcContext->Ebx);
    setECX(vcContext->Ecx);
    setEDX(vcContext->Edx);
    setEIP(vcContext->Eip);
    setESP(vcContext->Esp);
    setEBP(vcContext->Ebp);
    setEFLAGS(vcContext->EFlags);

}

ULONG
DbgEventTime(
    PVDM_TRACEINFO pVdmTraceInfo
    )
{
    ULONG TickCount = 0;
    USHORT id;
    ULONG CurTick;
    LARGE_INTEGER CurTime;
    LARGE_INTEGER DiffTime;
#ifdef _X86_
    ULONG CurHigh, CurLow;
#endif

    if (!DbgTimerInitialized) {

#ifdef _X86_
        ULONG CpuidHigh;
        _asm pushad
        _asm mov eax, 1
        _asm _emit 0fh
        _asm _emit 0a2h         // CPUID
        _asm mov CpuidHigh, edx
        _asm popad
        if (CpuidHigh & 0x10) {
            // cpu has time stamp counter
            DbgTimerMode = VDMTI_TIMER_PENTIUM;
        }
#endif


        switch(DbgTimerMode & VDMTI_TIMER_MODE) {

        case VDMTI_TIMER_TICK:
            pVdmTraceInfo->TimeStamp.LowPart = GetTickCount();
            DbgTimerInitialized = TRUE;
            break;

#ifdef _X86_
        case VDMTI_TIMER_PENTIUM:
            _asm push eax
            _asm push edx
            _asm _emit 0fh
            _asm _emit 031h     // RDTSC
            _asm mov CurLow, eax
            _asm mov CurHigh, edx
            _asm pop edx
            _asm pop eax

            pVdmTraceInfo->TimeStamp.LowPart = CurLow;
            pVdmTraceInfo->TimeStamp.HighPart = CurHigh;
            DbgTimerInitialized = TRUE;
            break;
#endif
        }
    }


    if (DbgTimerInitialized) {

        pVdmTraceInfo->Flags = (pVdmTraceInfo->Flags & ~VDMTI_TIMER_MODE) +
                                  (DbgTimerMode & VDMTI_TIMER_MODE);

        switch(pVdmTraceInfo->Flags & VDMTI_TIMER_MODE) {

        case VDMTI_TIMER_TICK:
            CurTick = GetTickCount();

            if (CurTick > pVdmTraceInfo->TimeStamp.LowPart) {
                TickCount = CurTick - pVdmTraceInfo->TimeStamp.LowPart;
                pVdmTraceInfo->TimeStamp.LowPart = CurTick;
            } else {
                TickCount = 0;
            }

            break;

#ifdef _X86_
        case VDMTI_TIMER_PENTIUM: {
            _asm push eax
            _asm push edx
            _asm _emit 0fh
            _asm _emit 031h     // RDTSC
            _asm mov CurLow, eax
            _asm mov CurHigh, edx
            _asm pop edx
            _asm pop eax
            CurTime.LowPart = CurLow;
            CurTime.HighPart = CurHigh;

            DiffTime.QuadPart = CurTime.QuadPart - pVdmTraceInfo->TimeStamp.QuadPart;
            pVdmTraceInfo->TimeStamp.QuadPart = CurTime.QuadPart;
            TickCount = DiffTime.LowPart;

            //if (DiffTime.HighPart) {
            //    TickCount = 0xffffffff;
            //}
            break;
            }
#endif
        }
    }

    return (TickCount);
}

#define NUM_VDM_TRACE_PAGES 8

VOID
WINAPI
xxxDbgTraceEvent(
    PVDM_TRACEINFO pVdmTraceInfo,
    USHORT Type,
    USHORT wData,
    ULONG  lData
    )
{
    PVDM_TRACEENTRY pEntry;

    if (!(*(ULONG *)(IntelMemoryBase+FIXED_NTVDMSTATE_LINEAR) & VDM_TRACE_HISTORY)) {
        return;
    }

    if (!pVdmTraceInfo->pTraceTable) {
        pVdmTraceInfo->pTraceTable = (PVDM_TRACEENTRY) VirtualAlloc(NULL,
                                                4096*NUM_VDM_TRACE_PAGES,
                                                MEM_COMMIT,
                                                PAGE_READWRITE);

        if (!pVdmTraceInfo->pTraceTable) {
            // couldn't allocate memory
            return;
        }

        pVdmTraceInfo->CurrentEntry = 0;
        pVdmTraceInfo->NumPages = NUM_VDM_TRACE_PAGES;
        pVdmTraceInfo->Flags = 0;
    }

    pEntry = &pVdmTraceInfo->pTraceTable[pVdmTraceInfo->CurrentEntry];

    pEntry->Type = Type;
    pEntry->wData = wData;
    pEntry->lData = lData;
    pEntry->Time = DbgEventTime(pVdmTraceInfo);

    pEntry->eax = getEAX();
    pEntry->ebx = getEBX();
    pEntry->ecx = getECX();
    pEntry->edx = getEDX();
    pEntry->esi = getESI();
    pEntry->edi = getEDI();
    pEntry->ebp = getEBP();
    pEntry->esp = getESP();
    pEntry->eip = getEIP();
    pEntry->eflags = getEFLAGS();

    pEntry->cs = getCS();
    pEntry->ds = getDS();
    pEntry->es = getES();
    pEntry->fs = getFS();
    pEntry->gs = getGS();
    pEntry->ss = getSS();

    if (++pVdmTraceInfo->CurrentEntry >=
        (pVdmTraceInfo->NumPages*4096/sizeof(VDM_TRACEENTRY))) {
        pVdmTraceInfo->CurrentEntry = 0;
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dos\command\cmd.c ===
/*
 *  cmd.c - Main Module of Command.lib
 *
 *  Sudeepb 09-Apr-1991 Craeted
 */

#include "cmd.h"
#include "cmdsvc.h"
#include "host_def.h"


/* CmdInit - Command Initialiazation routine.
 *
 * Entry
 *          None
 * Exit
 *          None
 *
 */

VOID CMDInit (VOID)
{
	cmdHomeDirectory[0] = *pszSystem32Path;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dbgdll\module.c ===
/*
 *  module.c - Module functions of DBG DLL.
 *
 *
 */
#include <precomp.h>
#pragma hdrstop


VOID
WINAPI
xxxDbgDosAppStart(
    WORD wCS,
    WORD wIP
    )
{
    if ( fDebugged ) {
        if (VdmDbgTraceFlags & VDMDBG_BREAK_DOSTASK) {
            DbgSetTemporaryBP(wCS, wIP, FALSE);
        }
    }
}

BOOL
DbgDllStart(
    PNDFRAME16  pNDFrame
) {
    BOOL        fResult;

    fResult = FALSE;        // Default to Event not handled

    if ( fDebugged ) {
        LPSTR           lpModuleName;
        LPSTR           lpModulePath;
        UINT            length;
        UCHAR           fPE;
        IMAGE_NOTE      im;

        DbgGetContext();

        EventParams[2] = (DWORD)&im;

        // Get the module's path and name

        fPE = ISPESET;

        lpModuleName = (LPSTR)Sim32GetVDMPointer(
                            (ULONG)pNDFrame->dwModuleName,
                            MAX_MODULE,
                            fPE );

        lpModulePath = (LPSTR)Sim32GetVDMPointer(
                            (ULONG)pNDFrame->dwModulePath,
                            MAX_PATH,
                            fPE );

        length = (UINT)((UCHAR)*lpModuleName++);

        strncpy( im.Module, lpModuleName, length );
        im.Module[length] = '\0';

        length = (UINT)((UCHAR)*lpModulePath);
        lpModulePath += 8;
        length -= 8;

        strncpy( im.FileName, lpModulePath, length );
        im.FileName[length] = '\0';

        im.hModule = pNDFrame->hModule;
        im.hTask   = pNDFrame->hTask;

        fResult = SendVDMEvent(DBG_DLLSTART);

        if (VdmDbgTraceFlags & VDMDBG_BREAK_LOADDLL) {
            DbgSetTemporaryBP(pNDFrame->wCS, pNDFrame->wIP, (BOOL)(getMSW() & MSW_PE));
        }

    }

    return( fResult );
}


BOOL
DbgTaskStop(
    PSTFRAME16  pSTFrame
) {
    BOOL        fResult;

    fResult = FALSE;        // Default to Event not handled

    if ( fDebugged ) {
        LPSTR           lpModuleName;
        LPSTR           lpModulePath;
        UINT            length;
        UCHAR           fPE;
        IMAGE_NOTE      im;

        DbgGetContext();

        EventParams[2] = (DWORD)&im;

        // The code in TASK.ASM pops the frame off the stack before it IRETs
        vcContext.Esp += sizeof(STFRAME16);

        // Get the module's path and name

        fPE = ISPESET;

        lpModuleName = (LPSTR)Sim32GetVDMPointer(
                            (ULONG)pSTFrame->dwModuleName,
                            MAX_MODULE,
                            fPE );

        lpModulePath = (LPSTR)Sim32GetVDMPointer(
                            (ULONG)pSTFrame->dwModulePath,
                            MAX_PATH,
                            fPE );

        length = (UINT)((UCHAR)*lpModuleName++);

        strncpy( im.Module, lpModuleName, length );
        im.Module[length] = '\0';

        length = (UINT)((UCHAR)*lpModulePath);
        lpModulePath += 8;
        length -= 8;

        strncpy( im.FileName, lpModulePath, length );
        im.FileName[length] = '\0';

        im.hModule = pSTFrame->hModule;
        im.hTask   = pSTFrame->hTask;

        fResult = SendVDMEvent(DBG_TASKSTOP);

        // See comment about what the code does above
        vcContext.Esp -= sizeof(STFRAME16);
    }

    return( fResult );
}




VOID
xxxDbgNotifyNewTask(
    LPVOID  lpvNTFrame,
    UINT    uFrameSize
) {
    BOOL        fResult;
    PNTFRAME16  pNTFrame;

    pNTFrame = (PNTFRAME16)lpvNTFrame;

    if ( fDebugged ) {
        LPSTR           lpModuleName;
        LPSTR           lpModulePath;
        UINT            length;
        UCHAR           fPE;
        IMAGE_NOTE      im;

        DbgGetContext();

        EventParams[2] = (DWORD)&im;

        // Get the module's path and name

        fPE = ISPESET;

        lpModuleName = (LPSTR)Sim32GetVDMPointer(
                            (ULONG)pNTFrame->dwModuleName,
                            MAX_MODULE,
                            fPE );

        lpModulePath = (LPSTR)Sim32GetVDMPointer(
                            (ULONG)pNTFrame->dwModulePath,
                            MAX_PATH,
                            fPE );

        length = (UINT)((UCHAR)*lpModuleName++);

        strncpy( im.Module, lpModuleName, length );
        im.Module[length] = '\0';

        length = (UINT)((UCHAR)*lpModulePath);
        lpModulePath += 8;
        length -= 8;

        strncpy( im.FileName, lpModulePath, length );
        im.FileName[length] = '\0';

        im.hModule = pNTFrame->hModule;
        im.hTask   = pNTFrame->hTask;

        fResult = SendVDMEvent(DBG_TASKSTART);

        if (VdmDbgTraceFlags & VDMDBG_BREAK_WOWTASK) {
            DbgSetTemporaryBP(pNTFrame->wCS, pNTFrame->wIP, (BOOL)(getMSW() & MSW_PE));
        }

    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dbgdll\precomp.h ===
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <stdio.h>
#include <string.h>
#include <mvdm.h>
#include <bop.h>
#include <softpc.h>
#include <dbgexp.h>
#include <dbgsvc.h>
#include <vdmdbg.h>
#include <dbginfo.h>
#include <vdm.h>
#include <nt_vdd.h>
#include <dbgdll.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dbgdll\segment.c ===
/*
 *  segment.c - Segment functions of DBG DLL.
 *
 */
#include <precomp.h>
#pragma hdrstop

void
SegmentLoad(
    LPSTR   lpModuleName,
    LPSTR   lpPathName,
    WORD    Selector,
    WORD    Segment,
    BOOL    fData
    )
{

    if ( fDebugged ) {
        SEGMENT_NOTE    se;

        DbgGetContext();

        RtlFillMemory( &se, sizeof(se), (UCHAR)0 );

        se.Selector1 = Selector;
        se.Segment   = Segment+1;       // make it one-based
        se.Type      = fData ? SN_DATA : SN_CODE;

        strncpy(se.FileName, lpPathName,
                min(strlen(lpPathName), MAX_PATH16-1) );

        strncpy(se.Module, lpModuleName,
                min(strlen(lpModuleName), MAX_MODULE-1) );

        EventParams[2] = (DWORD)&se;

        SendVDMEvent(DBG_SEGLOAD);
    }
}

void
SegmentMove(
    WORD    OldSelector,
    WORD    NewSelector
    )
{

    if ( fDebugged ) {
        SEGMENT_NOTE    se;

        DbgGetContext();

        RtlFillMemory( &se, sizeof(se), (UCHAR)0 );

        se.Selector1   = OldSelector;
        se.Selector2   = NewSelector;

        EventParams[2] = (DWORD)&se;

        SendVDMEvent(DBG_SEGMOVE);
    }
}

void
SegmentFree(
    WORD    Selector,
    BOOL    fBPRelease
    )
{

    if ( fDebugged ) {
        SEGMENT_NOTE    se;

        DbgGetContext();

        RtlFillMemory( &se, sizeof(se), (UCHAR)0 );

        se.Selector1   = Selector;
        se.Type        = (WORD)fBPRelease;

        EventParams[2] = (DWORD)&se;

        SendVDMEvent(DBG_SEGFREE);
    }
}

void
ModuleLoad(
    LPSTR   lpModuleName,
    LPSTR   lpPathName,
    WORD    Segment,
    DWORD   Length
    )
{

    if ( fDebugged ) {
        SEGMENT_NOTE    se;

        DbgGetContext();

        RtlFillMemory( &se, sizeof(se), (UCHAR)0 );

        se.Selector1 = Segment;
        se.Length  = Length;

        strncpy(se.FileName, lpPathName,
                min(strlen(lpPathName), MAX_PATH16-1) );

        strncpy(se.Module, lpModuleName,
                min(strlen(lpModuleName), MAX_MODULE-1) );

        EventParams[2] = (DWORD)&se;

        SendVDMEvent(DBG_MODLOAD);
    }
}

void
ModuleSegmentMove(
    LPSTR   lpModuleName,
    LPSTR   lpPathName,
    WORD    ModuleSegment,
    WORD    OldSelector,
    WORD    NewSelector,
    DWORD   Length
    )
{

    if ( fDebugged ) {
        SEGMENT_NOTE    se;

        DbgGetContext();

        RtlFillMemory( &se, sizeof(se), (UCHAR)0 );

        se.Segment     = ModuleSegment;
        se.Selector1   = OldSelector;
        se.Selector2   = NewSelector;
        se.Type        = SN_V86;
        se.Length      = Length;

        strncpy(se.FileName, lpPathName,
                min(strlen(lpPathName), MAX_PATH16-1) );

        strncpy(se.Module, lpModuleName,
                min(strlen(lpModuleName), MAX_MODULE-1) );

        EventParams[2] = (DWORD)&se;

        SendVDMEvent(DBG_SEGMOVE);
    }
}

void
ModuleFree(
    LPSTR   lpModuleName,
    LPSTR   lpPathName
    )
{

    if ( fDebugged ) {
        SEGMENT_NOTE    se;

        DbgGetContext();

        RtlFillMemory( &se, sizeof(se), (UCHAR)0 );

        strncpy(se.FileName, lpPathName,
                min(strlen(lpPathName), MAX_PATH16-1) );

        strncpy(se.Module, lpModuleName,
                min(strlen(lpModuleName), MAX_MODULE-1) );

        EventParams[2] = (DWORD)&se;

        SendVDMEvent(DBG_MODFREE);
    }
}

void
xxxDbgSegmentNotice(
    WORD wType,
    WORD  wModuleSeg,
    WORD  wLoadSeg,
    WORD  wNewSeg,
    LPSTR lpModuleName,
    LPSTR lpModulePath,
    DWORD dwImageLen )

/* DbgSegmentNotice
 *
 * packs up the data and raises STATUS_SEGMENT_NOTIFICATION
 *
 * Entry - WORD  wType     - DBG_MODLOAD, DBG_MODFREE
 *         WORD  wModuleSeg- segment number within module (1 based)
 *         WORD  wLoadSeg  - Starting Segment (reloc factor)
 *         LPSTR lpName    - ptr to Name of Image
 *         DWORD dwModLen  - Length of module
 *
 *
 *         if wType ==DBG_MODLOAD wOldLoadSeg is unused
 *         if wType ==DBG_MODFREE wLoadSeg,dwImageLen,wOldLoadSeg are unused
 *
 *         Use 0 or NULL for unused parameters
 *
 * Exit  - void
 *
 */

{
    if (!fDebugged) {
         return;
         }

    if (wType == DBG_MODLOAD) {
        ModuleLoad(lpModuleName, lpModulePath, wLoadSeg, dwImageLen);
    } else if (wType == DBG_MODFREE) {
        ModuleFree(lpModuleName, lpModulePath);
    } else if (wType == DBG_SEGMOVE) {
        ModuleSegmentMove(lpModuleName, lpModulePath, wModuleSeg, wLoadSeg, wNewSeg, dwImageLen);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dos\command\cmd.h ===
/* cmd.h - main include file for command.lib
 *
 * Modification History
 *
 * Sudeepb 17-Sep-1991 Created
 */

/*
#define WIN
#define FLAT_32
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>

#define _WINDOWS
#include <windows.h>

*/

#ifdef DOS
#define SIGNALS
#endif

#ifdef OS2_16
#define OS2
#define SIGNALS
#endif

#ifdef OS2_32
#define OS2
#define FLAT_32
#endif

#include <stdarg.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <malloc.h>
#include <process.h>

#ifdef WIN_16
#define WIN
#define API16
#endif

#ifdef WIN_32
#define WIN
#define FLAT_32
#define TRUE_IF_WIN32   1
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#else
#define TRUE_IF_WIN32   0
#endif

#ifdef FLAT_32
#ifndef i386
#define ALIGN_32
#else
#define NOALIGN_32
#endif
#endif

#ifdef WIN
#define _WINDOWS
#include <windows.h>
#endif

#ifdef SIGNALS
#include <conio.h>
#include <signal.h>
#endif

#ifdef OS2_32
#include <excpt.h>
#define XCPT_SIGNAL     0xC0010003
#endif

#include <vdmapi.h>
#include "dpmtbls.h"

#define COPY_STD_OUT 1
#define COPY_STD_ERR 2

#define CLOSE_ALL_HANDLES   1
#define CLOSE_STD_OUT       2
#define CLOSE_STD_ERR       4

#define DEFAULT_REDIRECTION_SIZE 1024
#define MAX_SHORTCUT_SIZE        128
#define STDIN_BUF_SIZE           512

/** Command Macros **/

/** Command Basic Typedefs **/

typedef VOID (*PFNSVC)(VOID);

#pragma pack(1)

typedef struct _PARAMBLOCK {
    USHORT  SegEnv;
    USHORT  OffCmdTail;
    USHORT  SegCmdTail;
    ULONG   pFCB1;
    ULONG   pFCB2;
} PARAMBLOCK,*PPARAMBLOCK;

typedef struct _SCSINFO {
    CHAR    SCS_ComSpec [64];
    CHAR    SCS_CmdTail [128];
    PARAMBLOCK SCS_ParamBlock;
    CHAR    SCS_ToSync;
} SCSINFO, *PSCSINFO;

typedef struct _STD_HANDLES {
    ULONG   hStdErr;
    ULONG   hStdOut;
    ULONG   hStdIn;
} STD_HANDLES, *PSTD_HANDLES;

#define PIPE_INPUT_BUFFER_SIZE  512
#define PIPE_OUTPUT_BUFFER_SIZE PIPE_INPUT_BUFFER_SIZE
#define PIPE_INPUT_TIMEOUT              55
#define PIPE_OUTPUT_TIMEOUT     PIPE_INPUT_TIMEOUT

typedef struct  _PIPE_INPUT{
    struct _PIPE_INPUT  *Next;
    HANDLE              hFileRead;
    HANDLE              hFileWrite;
    HANDLE              hPipe;
    HANDLE              hDataEvent;
    HANDLE              hThread;
    CHAR                *pFileName;
    DWORD               BufferSize;
    BOOL                fEOF;
    BOOL                WaitData;
    BYTE                *Buffer;
    CRITICAL_SECTION    CriticalSection;
} PIPE_INPUT, *PPIPE_INPUT;

typedef struct  _PIPE_OUTPUT {
    HANDLE              hFile;
    HANDLE              hPipe;
    HANDLE              hExitEvent;
    CHAR                *pFileName;
    DWORD               BufferSize;
    BYTE                *Buffer;
} PIPE_OUTPUT, *PPIPE_OUTPUT;

typedef struct _RedirComplete_Info {
    HANDLE  ri_hStdErr;
    HANDLE  ri_hStdOut;
    HANDLE  ri_hStdIn;
    HANDLE  ri_hStdErrFile;
    HANDLE  ri_hStdOutFile;
    HANDLE  ri_hStdInFile;
    HANDLE  ri_hStdOutThread;
    HANDLE  ri_hStdErrThread;
    PPIPE_INPUT ri_pPipeStdIn;
    PPIPE_OUTPUT ri_pPipeStdOut;
    PPIPE_OUTPUT ri_pPipeStdErr;

} REDIRCOMPLETE_INFO, *PREDIRCOMPLETE_INFO;

typedef struct  _VDMENVBLK {
    DWORD       cchEnv;
    DWORD       cchRemain;
    CHAR        *lpszzEnv;
} VDMENVBLK, *PVDMENVBLK;

#pragma pack()

/** Command Function Prototypes */


VOID   cmdComSpec                   (VOID);
VOID   cmdGetEnv                    (VOID);
VOID   cmdGetNextCmd                (VOID);
VOID   cmdGetNextCmdForSeparateWow  (VOID);
VOID   cmdGetStdHandle              (VOID);
VOID   cmdExec                      (VOID);
VOID   cmdExecComspec32             (VOID);
VOID   cmdExitVDM                   (VOID);
VOID   cmdReturnExitCode            (VOID);
VOID   cmdSaveWorld                 (VOID);
VOID   cmdSetInfo                   (VOID);
VOID   cmdGetCurrentDir             (VOID);
VOID   cmdSetDirectories            (PCHAR,VDMINFO *);
VOID   CheckDotExeForWOW            (LPSTR);
BOOL   cmdCheckCopyForRedirection   (PREDIRCOMPLETE_INFO, BOOL);
BOOL   cmdCreateTempFile            (PHANDLE,PCHAR *);
VOID   cmdCheckBinary               (VOID);
VOID   cmdInitConsole               (VOID);
VOID   nt_init_event_thread         (VOID);
VOID   cmdExec32                    (PCHAR,PCHAR);
VOID   cmdCreateProcess             (PSTD_HANDLES pStdHandles);
USHORT cmdMapCodePage               (ULONG);
VOID    cmdCheckForPIF              (PVDMINFO);
VOID   cmdGetConfigSys              (VOID);
VOID   cmdGetAutoexecBat            (VOID);
VOID   DeleteConfigFiles            (VOID);
VOID   cmdGetKbdLayout              (VOID);
BOOL   cmdXformEnvironment          (PCHAR, PANSI_STRING);
VOID   cmdGetInitEnvironment        (VOID);
VOID   cmdUpdateCurrentDirectories  (BYTE);
BOOL   cmdCreateVDMEnvironment      (PVDMENVBLK);
DWORD  cmdGetEnvironmentVariable    (PVDMENVBLK, PCHAR, PCHAR, DWORD);
BOOL   cmdSetEnvironmentVariable    (PVDMENVBLK, PCHAR, PCHAR);
DWORD  cmdExpandEnvironmentStrings  (PVDMENVBLK, PCHAR, PCHAR, DWORD);
PREDIRCOMPLETE_INFO  cmdCheckStandardHandles      (PVDMINFO,USHORT UNALIGNED *);
VOID   cmdGetStartInfo              (VOID);
BOOL   cmdHandleStdinWithPipe       (PREDIRCOMPLETE_INFO);
BOOL   cmdHandleStdOutErrWithPipe   (PREDIRCOMPLETE_INFO, USHORT);
LPSTR  cmdSkipOverPathName          (LPSTR);
BOOL   cmdPipeFileDataEOF           (HANDLE, BOOL *);
BOOL   cmdPipeFileEOF               (HANDLE);
VOID   cmdPipeInThread              (LPVOID);
VOID   cmdPipeOutThread             (LPVOID);
VOID   cmdSetWinTitle               (VOID);
BOOL   cmdIllegalFunc(VOID);
VOID   cmdGetCursorPos(VOID);

/** Command Externs **/

extern USHORT   nDrives;
extern BOOL     IsFirstVDMInSystem;
extern BOOL     VDMForWOW;
extern CHAR     lpszComSpec[];
extern USHORT   cbComSpec;
extern BOOL     IsFirstCall;
extern BOOL     IsRepeatCall;
extern BOOL     IsFirstWOWCheckBinary;
extern BOOL     IsFirstVDMInSystem;
extern BOOL     SaveWorldCreated;
extern PCHAR    pSCS_ToSync;
extern BOOL     fBlock;
extern PCHAR    pCommand32;
extern PCHAR    pEnv32;
extern DWORD    dwExitCode32;
extern PSCSINFO pSCSInfo;
extern HANDLE   hFileStdOut;
extern HANDLE   hFileStdOutDup;
extern HANDLE   hFileStdErr;
extern HANDLE   hFileStdErrDup;
extern VDMINFO  VDMInfo;
extern PSZ      pszFileStdOut;
extern PSZ      pszFileStdErr;
extern CHAR     cmdHomeDirectory[];
extern HANDLE   SCS_hStdIn;
extern HANDLE   SCS_hStdOut;
extern HANDLE   SCS_hStdErr;
extern CHAR     chDefaultDrive;
extern BOOL     DontCheckDosBinaryType;
extern WORD     Exe32ActiveCount;
extern BOOL     fSoftpcRedirection;
extern BOOL     fSoftpcRedirectionOnShellOut;
extern VOID     nt_std_handle_notification (BOOL);
extern VOID     cmdPushExitInConsoleBuffer (VOID);


// control handler state, defined in nt_event.h, nt_event.c
extern  ULONG CntrlHandlerState;
#define CNTRL_SHELLCOUNT         0x0FFFF  // The LOWORD is used for shell count
#define CNTRL_PIFALLOWCLOSE      0x10000
#define CNTRL_VDMBLOCKED         0x20000
#define CNTRL_SYSTEMROOTCONSOLE  0x40000
#define CNTRL_PUSHEXIT           0x80000


// Temporary variable till we standardized on wowexec
extern ULONG    iWOWTaskId;
extern CHAR     comspec[];
extern CHAR     ShortCutInfo[];

extern VOID     nt_pif_callout (LPVOID);
extern CHAR     *lpszzInitEnvironment;
extern WORD     cchInitEnvironment;
extern CHAR     *lpszzCurrentDirectories;
extern DWORD    cchCurrentDirectories;
extern BYTE     * pIsDosBinary;
extern WORD     * pFDAccess;
extern CHAR     *lpszzcmdEnv16;
extern BOOL     DosEnvCreated;
extern BOOL     IsFirstVDM;
extern VDMENVBLK cmdVDMEnvBlk;
extern CHAR     *lpszzVDMEnv32;
extern DWORD    cchVDMEnv32;
extern UINT     VdmExitCode;
extern DWORD    dwDosCompatFlags;
extern PCMDLNPARMS pCmdLnParms;
extern int      cCmdLnParmStructs;
extern PFAMILY_TABLE *pgDpmDosFamTbls;

// application path name extention type.
#define EXTENTION_STRING_LEN    4
#define BAT_EXTENTION_STRING    ".BAT"
#define EXE_EXTENTION_STRING    ".EXE"
#define COM_EXTENTION_STRING    ".COM"

#ifdef DBCS // MUST fix for FE NT
#define FIX_375051_NOW
#endif

#ifdef FIX_375051_NOW

#define WOW32_strupr(psz)    CharUpperA(psz)

#else

#define WOW32_strupr(psz)    _strupr(psz)

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dos\command\cmddata.c ===
/*  cmddata.c - Misc. SCS global data
 *
 *
 *  Modification History:
 *
 *  Sudeepb 22-Apr-1992 Created
 */

#include "cmd.h"
#include <mvdm.h>

CHAR	 lpszComSpec[64+8];
USHORT	 cbComSpec=0;
BOOL	 IsFirstCall = TRUE;
BOOL	 IsRepeatCall = FALSE;
BOOL	 IsFirstWOWCheckBinary = TRUE;
BOOL	 IsFirstVDMInSystem = FALSE;
BOOL	 SaveWorldCreated;
PCHAR	 pSCS_ToSync;
PSCSINFO pSCSInfo;
BOOL	 fBlock = FALSE;
PCHAR	 pCommand32;
PCHAR	 pEnv32;
DWORD	 dwExitCode32;
CHAR     cmdHomeDirectory [] = "C:\\";
CHAR	 chDefaultDrive;
CHAR	 comspec[]="COMSPEC=";
BOOL     fSoftpcRedirection;
BOOL     fSoftpcRedirectionOnShellOut;
CHAR     ShortCutInfo[MAX_SHORTCUT_SIZE];
BOOL	 DosEnvCreated = FALSE;

// Top secret app compat flags for DOS apps!
DWORD    dwDosCompatFlags = 0;
int      cCmdLnParmStructs = 0;

// For Dynamic Patch Module support
PCMDLNPARMS     pCmdLnParms;             // an array of these structs
PFAMILY_TABLE  *pgDpmDosFamTbls = NULL;  // the global DPM tables for DOS

BOOL	 IsFirstVDM = TRUE;
// FORCEDOS.EXE supported
BOOL	 DontCheckDosBinaryType = FALSE;
WORD	 Exe32ActiveCount = 0;



// Redirection Support variables

VDMINFO  VDMInfo;
CHAR	 *lpszzInitEnvironment = NULL;
WORD	 cchInitEnvironment = 0;
CHAR	 *lpszzCurrentDirectories = NULL;
DWORD	 cchCurrentDirectories = 0;
BYTE	 * pIsDosBinary;
CHAR	 *lpszzcmdEnv16 = NULL;
CHAR	 *lpszzVDMEnv32 = NULL;
DWORD	 cchVDMEnv32;
VDMENVBLK cmdVDMEnvBlk;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dos\command\cmddisp.c ===
/*
 *  cmddisp.c - SVC dispatch module of command
 *
 *  Modification History:
 *
 *  Sudeepb 17-Sep-1991 Created
 */

#include "cmd.h"

#include <cmdsvc.h>
#include <softpc.h>

//'cmdSetWinTitle' and 'cmdGetCursorPos' are not available in NON-DBCS builds. 
#ifndef DBCS
#define cmdSetWinTitle cmdIllegalFunc
#endif
#ifndef NEC_98
#define cmdGetCursorPos cmdIllegalFunc
#endif

PFNSVC	apfnSVCCmd [] = {
     cmdExitVDM,		//SVC_CMDEXITVDM
     cmdGetNextCmd,		//SVC_CMDGETNEXTCMD
     cmdComSpec,		//SVC_CMDCOMSPEC
     cmdIllegalFunc,		//SVC_CMDSAVEWORLD was removed
     cmdGetCurrentDir,		//SVC_CMDGETCURDIR
     cmdSetInfo,		//SVC_CMDSETINFO
     cmdGetStdHandle,		//SVC_GETSTDHANDLE
     cmdCheckBinary,		//SVC_CMDCHECKBINARY
     cmdExec,			//SVC_CMDEXEC
     cmdInitConsole,		//SVC_CMDINITCONSOLE
     cmdExecComspec32,		//SVC_EXECCOMSPEC32
     cmdReturnExitCode,         //SVC_RETURNEXITCODE
     cmdGetConfigSys,           //SVC_GETCONFIGSYS
     cmdGetAutoexecBat,		//SVC_GETAUTOEXECBAT
     cmdGetKbdLayout,		//SVC_GETKBDLAYOUT
     cmdGetInitEnvironment,     //SVC_GETINITENVIRONMENT
     cmdGetStartInfo,            //SVC_GETSTARTINFO
     cmdSetWinTitle,		//SVC_CHANGEWINTITLE
     cmdIllegalFunc,            // 18 
     cmdIllegalFunc,            // 19 
     cmdIllegalFunc,            // 20 
     cmdIllegalFunc,            // 21 
     cmdIllegalFunc,            // 22 
     cmdIllegalFunc,            // 23 
     cmdIllegalFunc,            // 24 
     cmdIllegalFunc,            // 25 
     cmdIllegalFunc,            // 26 
     cmdIllegalFunc,            // 27 
     cmdIllegalFunc,            // 28 
     cmdIllegalFunc,            // 29 
     cmdGetCursorPos            //SVC_GETCURSORPOS 
};


/* cmdDispatch - Dispatch SVC call to right command handler.
 *
 * Entry - iSvc (SVC byte following SVCop)
 *
 * Exit  - None
 *
 */

BOOL CmdDispatch (ULONG iSvc)
{
#if DBG
    if (iSvc >= SVC_CMDLASTSVC){
	DbgPrint("Unimplemented SVC index for COMMAND %x\n",iSvc);
	setCF(1);
	return FALSE;
    }
#endif
    (apfnSVCCmd [iSvc])();

    return TRUE;
}


BOOL cmdIllegalFunc ()                                 
{                                                                
#if DBG                                                       
    DbgPrint("Unimplemented SVC index for COMMAND\n");       
#endif                                                         
    setCF(1);                                                 
    return FALSE;                                            
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dos\command\cmdconf.c ===
/*  cmdconf.c - handles pre-processing of config.sys\autoexec.bat
 *
 *  Modification History:
 *
 *  21-Nov-1992 Jonle , Created
 */

#include "cmd.h"
#include <cmdsvc.h>
#include <demexp.h>
#include <softpc.h>
#include <mvdm.h>
#include <ctype.h>
#include <oemuni.h>

//
// local stuff
//
CHAR *pchTmpConfigFile;
CHAR *pchTmpAutoexecFile;
CHAR achSYSROOT[] = "%SystemRoot%";
CHAR achCOMMAND[] = "\\System32\\command.com";
CHAR achSHELL[]   = "shell";
CHAR achCOUNTRY[] = "country";
CHAR achREM[]     = "rem";
CHAR achENV[]     = "/e:";
CHAR achEOL[]     = "\r\n";
CHAR achSET[]     = "SET";
CHAR achPROMPT[]  = "PROMPT";
CHAR achPATH[]    = "PATH";
#ifdef JAPAN
// device=...\$disp.sys /hs=%HardwareScroll%
CHAR  achHARDWARESCROLL[] = "%HardwareScroll%";
DWORD dwLenHardwareScroll;
CHAR  achHardwareScroll[64];
#endif // JAPAN
#if defined(KOREA)
// device=...\hbios.sys /k:#
CHAR  achHBIOS[] = "hbios.sys";
CHAR  achFontSys[] = "font_win.sys";
CHAR  achDispSys[] = "disp_win.sys";
DWORD dwLenHotkeyOption;
CHAR  achHotkeyOption[80];
BOOLEAN fKoreanCP;

#define KOREAN_WANSUNG_CP 949
#endif // KOREA

DWORD dwLenSysRoot;
CHAR  achSysRoot[64];



void  ExpandConfigFiles(BOOLEAN bConfig);
DWORD WriteExpanded(HANDLE hFile,  CHAR *pch, DWORD dwBytes);
void  WriteFileAssert(HANDLE hFile, CHAR *pBuff, DWORD dwBytes);
#define ISEOL(ch) ( !(ch) || ((ch) == '\n') || ((ch) == '\r'))
#ifdef JAPAN
DWORD GetHardwareScroll( PCHAR achHardwareScroll, int size );
#endif // JAPAN
#if defined(KOREA)
DWORD GetHotkeyOption( PCHAR achHotkeyOption, UINT size );
#endif // KOREA


/** There are still many items we don't supprot for long path name
     (1). device, install in config.sys
     (2). Third-party shell
     (3). lh, loadhigh and any other commands in autoexec.bat

**/

/* cmdGetConfigSys - Creates a temp file to replace c:\config.sys
 *
 *  Entry - Client (DS:DX)  pointer to receive file name
 *
 *  EXIT  - This routine will Terminate the vdm if it fails
 *          And will not return
 *
 *  The buffer to receive the file name must be at least 64 bytes
 */
VOID cmdGetConfigSys (VOID)
{
     UNICODE_STRING Unicode;
     OEM_STRING     OemString;
     ANSI_STRING    AnsiString;

     ExpandConfigFiles(TRUE);

     RtlInitAnsiString(&AnsiString, pchTmpConfigFile);
     if (!NT_SUCCESS(RtlAnsiStringToUnicodeString(&Unicode, &AnsiString, TRUE)) )
         goto ErrExit;

     OemString.Buffer = (char *)GetVDMAddr(getDS(),getDX());
     OemString.MaximumLength = 64;
     if ( !NT_SUCCESS(RtlUnicodeStringToOemString(&OemString,&Unicode,FALSE)) )
         goto ErrExit;

     RtlFreeUnicodeString(&Unicode);
     return;

ErrExit:
     RcErrorDialogBox(ED_INITMEMERR, pchTmpConfigFile, NULL);
     TerminateVDM();
}



/* cmdGetAutoexecBat - Creates a temp file to replace c:\autoexec.bat
 *
 *  Entry - Client  (DS:DX)  pointer to receive file name
 *
 *  EXIT  - This routine will Terminate the vdm if it fails
 *          And will not return
 *
 *
 *  The buffer to receive the file name must be at least 64 bytes
 */
VOID cmdGetAutoexecBat (VOID)
{
     UNICODE_STRING Unicode;
     OEM_STRING     OemString;
     ANSI_STRING    AnsiString;

     ExpandConfigFiles(FALSE);

#if defined(JAPAN) || defined(KOREA)
    // fixed: change code page problem
    {
        extern int BOPFromDispFlag;

        if ( !VDMForWOW && !BOPFromDispFlag ) { // mskkbug#2756 10/15/93 yasuho
            SetConsoleCP( 437 );
            SetConsoleOutputCP( 437 );
        }
    }
#endif // JAPAN || KOREA
     RtlInitAnsiString(&AnsiString, pchTmpAutoexecFile);
     if (!NT_SUCCESS(RtlAnsiStringToUnicodeString(&Unicode,&AnsiString,TRUE)) )
         goto ErrExit;

     OemString.Buffer = (char *)GetVDMAddr(getDS(),getDX());
     OemString.MaximumLength = 64;
     if (!NT_SUCCESS(RtlUnicodeStringToOemString(&OemString,&Unicode,FALSE)) )
         goto ErrExit;

     RtlFreeUnicodeString(&Unicode);

     return;

ErrExit:
     RcErrorDialogBox(ED_INITMEMERR, pchTmpConfigFile, NULL);
     TerminateVDM();  // skip cleanup since I insist that we exit!
}



/*
 *  DeleteConfigFiles - Deletes the temporray config files created
 *                      by cmdGetAutoexecBat and cmdGetConfigSys
 */
VOID DeleteConfigFiles(VOID)
{
    if (pchTmpConfigFile)  {
#if DBG
      if (!(fShowSVCMsg & KEEPBOOTFILES))
#endif
        DeleteFile(pchTmpConfigFile);

        free(pchTmpConfigFile);
        pchTmpConfigFile = NULL;
        }

    if (pchTmpAutoexecFile) {
#if DBG
      if (!(fShowSVCMsg & KEEPBOOTFILES))
#endif
        DeleteFile(pchTmpAutoexecFile);

        free(pchTmpAutoexecFile);
        pchTmpAutoexecFile = NULL;
        }

    return;
}



// if it is a config command
//    returns pointer to character immediatly following the equal sign
// else
//    returns NULL

PCHAR IsConfigCommand(PCHAR pConfigCommand, int CmdLen, PCHAR pLine)
{
      PCHAR pch;

      if (!_strnicmp(pLine, pConfigCommand, CmdLen)) {
           pch = pLine + CmdLen;
           while (!isgraph(*pch) && !ISEOL(*pch))      // skip to "="
                  pch++;

           if (*pch++ == '=') {
               return pch;
               }
           }

       return NULL;
}

#if defined(KOREA)
// if it is a HBIOS related config command
//    returns TRUE
// else
//    returns FALSE

BOOLEAN IsHBIOSConfig(PCHAR pCommand, int CmdLen, PCHAR pLine)
{
  CHAR  *pch = pLine;
  CHAR  achDevice[] = "Device";
  CHAR  achRem[] = "REM";

  while (*pch && !ISEOL(*pch)) {
        if (!_strnicmp(pch, achRem, sizeof(achRem)-sizeof(CHAR)))
            return (FALSE);

        if (!_strnicmp(pch, achDevice, sizeof(achDevice)-sizeof(CHAR))) {
            while (*pch && !ISEOL(*pch)) {
                  if (!_strnicmp(pch, pCommand, CmdLen))
                     return (TRUE);
                  pch++;
            }
            return FALSE;
        }
        pch++;
  }
  return (FALSE);

}
#endif





/*
 *  Preprocesses the specfied config file (config.sys\autoexec.bat)
 *  into a temporary file.
 *
 *  - expands %SystemRoot%
#ifdef JAPAN
 *  - expands %HardwareScroll%
#endif // JAPAN
#if defined(KOREA)
 *  - expands HotkeyOption
#endif // KOREA
*  - adds SHELL line for config.sys
 *
 *  entry: BOOLEAN bConfig : TRUE  - config.sys
 *                           FALSE - autoexec.bat
 */
void ExpandConfigFiles(BOOLEAN bConfig)
{
   DWORD  dw, dwRawFileSize;

   HANDLE hRawFile;
   HANDLE hTmpFile;
   CHAR **ppTmpFile;
   CHAR *pRawBuffer;
   CHAR *pLine;
   CHAR *pTmp;
   CHAR *pEnvParam= NULL;
   CHAR *pPartyShell=NULL;
   CHAR achRawFile[MAX_PATH+12];
   CHAR *lpszzEnv, *lpszName;
   int  cchEnv;

#ifdef JAPAN
   dwLenHardwareScroll = GetHardwareScroll( achHardwareScroll, sizeof(achHardwareScroll) );
#endif // JAPAN
#if defined(KOREA)
   // HBIOS.SYS is only support WanSung Codepage.
   fKoreanCP = (GetConsoleCP() ==  KOREAN_WANSUNG_CP) ? TRUE : FALSE;
   dwLenHotkeyOption = GetHotkeyOption( achHotkeyOption, sizeof(achHotkeyOption) );
#endif // KOREA
   dw = GetSystemWindowsDirectory(achRawFile, sizeof(achRawFile));
   dwLenSysRoot = GetShortPathNameA(achRawFile, achSysRoot, sizeof(achSysRoot));
   if (dwLenSysRoot >= sizeof(achSysRoot)) {
        dwLenSysRoot = 0;
        achSysRoot[0] = '\0';
        }

   GetPIFConfigFiles(bConfig, achRawFile, FALSE);

   ppTmpFile = bConfig ? &pchTmpConfigFile : &pchTmpAutoexecFile;


   hRawFile = CreateFile(achRawFile,
                         GENERIC_READ,
                         FILE_SHARE_READ,
                         NULL,
                         OPEN_EXISTING,
                         FILE_ATTRIBUTE_NORMAL,
                         NULL );

   if (hRawFile == (HANDLE)0xFFFFFFFF
       || !dwLenSysRoot
       || dwLenSysRoot >= sizeof(achSysRoot)
       || !(dwRawFileSize = GetFileSize(hRawFile, NULL))
       || dwRawFileSize == 0xFFFFFFFF   )
      {
       RcErrorDialogBox(ED_BADSYSFILE, achRawFile, NULL);
       TerminateVDM();  // skip cleanup since I insist that we exit!
       }

   pRawBuffer = malloc(dwRawFileSize+1);
   // allocate buffer to save environment settings in autoexec.nt
   // I know this is bad to allocate this amount of memory at this
   // moment as we dont know if there are anything we want to keep
   // at all. This allocation simply provides the following error
   // handling easily.
   if(!bConfig) {
        lpszzEnv = lpszzcmdEnv16 = (PCHAR)malloc(dwRawFileSize);
        cchEnv = 0;
   }
   if (!pRawBuffer || (!bConfig && lpszzcmdEnv16 == NULL)) {
       RcErrorDialogBox(ED_INITMEMERR, achRawFile, NULL);
       TerminateVDM();  // skip cleanup since I insist that we exit!
       }

   if (!cmdCreateTempFile(&hTmpFile,ppTmpFile)
       || !ReadFile(hRawFile, pRawBuffer, dwRawFileSize, &dw, NULL)
       || dw != dwRawFileSize )
      {
       GetTempPath(MAX_PATH, achRawFile);
       achRawFile[63] = '\0';
       RcErrorDialogBox(ED_INITTMPFILE, achRawFile, NULL);
       TerminateVDM();  // skip cleanup since I insist that we exit!
       }
    // CHANGE HERE WHEN YOU CHANGE cmdCreateTempFile !!!!!!!!!!
    // we depend on the buffer size allocated for the file name
    dw = GetShortPathNameA(*ppTmpFile, *ppTmpFile, MAX_PATH +13);
    if (dw == 0 || dw > 63)
      {
       GetTempPath(MAX_PATH, achRawFile);
       achRawFile[63] = '\0';
       RcErrorDialogBox(ED_INITTMPFILE, achRawFile, NULL);
       TerminateVDM();  // skip cleanup since I insist that we exit!
       }


      // null terminate the buffer so we can use CRT string functions
    *(pRawBuffer+dwRawFileSize) = '\0';

      // ensure no trailing backslash in System Directory
    if (*(achSysRoot+dwLenSysRoot-1) == '\\') {
        *(achSysRoot + --dwLenSysRoot) = '\0';
        }

    pLine = pRawBuffer;
    while (dwRawFileSize) {
               // skip leading white space
       while (dwRawFileSize && !isgraph(*pLine)) {
            pLine++;
            dwRawFileSize -= sizeof(CHAR);
            }
       if (!dwRawFileSize)  // anything left to do ?
           break;

       //
       // filter out REM comment lines
       //

       if (!_strnicmp(pLine, achREM, sizeof(achREM) - sizeof(CHAR)) &&
           !isgraph(pLine[sizeof(achREM) - sizeof(CHAR)]))
          {
           while (dwRawFileSize && !ISEOL(*pLine)) {
                  pLine++;
                  dwRawFileSize -= sizeof(CHAR);
                  }
           continue;
           }

       if (bConfig)  {
           //
           // filter out country= setting we will create our own based
           // on current country ID and codepage.
           //
           pTmp = IsConfigCommand(achCOUNTRY, sizeof(achCOUNTRY) - sizeof(CHAR), pLine);
           if (pTmp) {
               while (dwRawFileSize && !ISEOL(*pLine)) {
                      pLine++;
                      dwRawFileSize -= sizeof(CHAR);
                      }
               continue;
               }

           // filter out shell= command, saving /E:nn parameter
           pTmp = IsConfigCommand(achSHELL, sizeof(achSHELL) - sizeof(CHAR),pLine);
           if (pTmp) {
                       // skip leading white space
               while (!isgraph(*pTmp) && !ISEOL(*pTmp)) {
                      dwRawFileSize -= sizeof(CHAR);
                      pTmp++;
                      }

                  /*  if for a third party shell (not SCS command.com)
                   *     append the whole thing thru /c parameter
                   *  else
                   *     append user specifed /e: parameter
                   */
               if (!_strnicmp(achSYSROOT,pTmp,sizeof(achSYSROOT)-sizeof(CHAR)))
                  {
                   dw = sizeof(achSYSROOT) - sizeof(CHAR);
                   }
               else if (!_strnicmp(achSysRoot,pTmp, strlen(achSysRoot)))
                  {
                   dw = strlen(achSysRoot);
                   }
               else  {
                   dw = 0;
                   }

               if (!dw ||
                   _strnicmp(achCOMMAND,pTmp+dw,sizeof(achCOMMAND)-sizeof(CHAR)) )
                  {
                   pPartyShell = pTmp;
                   }
               else {
                   do {
                      while (*pTmp != '/' && !ISEOL(*pTmp))  // save "/e:"
                             pTmp++;

                      if(ISEOL(*pTmp))
                          break;

                      if (!_strnicmp(pTmp,achENV,sizeof(achENV)-sizeof(CHAR)))
                          pEnvParam = pTmp;

                      pTmp++;

                      } while(1);        // was: while (!ISEOL(*pTmp));
                                         // we have break form this loop now,
                                         // and don't need in additional macro..

                   }

                       // skip the "shell=" line
               while (dwRawFileSize && !ISEOL(*pLine)) {
                      pLine++;
                      dwRawFileSize -= sizeof(CHAR);
                      }
               continue;

               }  // END, really is "shell=" line!
           }

#if defined(KOREA)

           // If current Code page is 437(US), system won't load HBIOS related modules.

           if (!fKoreanCP) {
               if (IsHBIOSConfig(achFontSys, sizeof(achFontSys)-sizeof(CHAR), pLine)) {
                    while (dwRawFileSize && !ISEOL(*pLine)) {
                           pLine++;
                           dwRawFileSize -= sizeof(CHAR);
                    }
                    continue;
               }
               if (IsHBIOSConfig(achHBIOS, sizeof(achHBIOS)-sizeof(CHAR), pLine)) {
                    while (dwRawFileSize && !ISEOL(*pLine)) {
                           pLine++;
                           dwRawFileSize -= sizeof(CHAR);
                    }
                    continue;
               }
               if (IsHBIOSConfig(achDispSys, sizeof(achDispSys)-sizeof(CHAR), pLine)) {
                    while (dwRawFileSize && !ISEOL(*pLine)) {
                           pLine++;
                           dwRawFileSize -= sizeof(CHAR);
                    }
                    continue;
               }
           }
#endif // KOREA

       /** Filter out PROMPT, SET and PATH from autoexec.nt
           for environment merging. The output we prepare here is
           a multiple strings buffer which has the format as :
           "EnvName_1 NULL EnvValue_1 NULL[EnvName_n NULL EnvValue_n NULL] NULL
           We don't take them out from the file because command.com needs
           them.
        **/
       if (!bConfig)
            if (!_strnicmp(pLine, achPROMPT, sizeof(achPROMPT) - 1)){
                // prompt command found.
                // the syntax of prompt can be eithe
                // prompt xxyyzz        or
                // prompt=xxyyzz
                //
                strcpy(lpszzEnv, achPROMPT);    // get the name
                lpszzEnv += sizeof(achPROMPT);
                cchEnv += sizeof(achPROMPT);
                pTmp = pLine + sizeof(achPROMPT) - 1;
                // skip possible white chars
                while (!isgraph(*pTmp) && !ISEOL(*pTmp))
                pTmp++;
                if (*pTmp == '=') {
                    pTmp++;
                    while(!isgraph(*pTmp) && !ISEOL(*pTmp))
                        pTmp++;
                }
                while(!ISEOL(*pTmp)){
                    *lpszzEnv++ = *pTmp++;
                    cchEnv++;
                }
                // null terminate this
                // it may be "prompt NULL NULL" for delete
                // or "prompt NULL something NULL"
                *lpszzEnv++ = '\0';
                cchEnv++;
            }
            else if (!_strnicmp(pLine, achPATH, sizeof(achPATH) - 1)) {
                    // PATH was found, it has the same syntax as
                    // PROMPT
                    strcpy(lpszzEnv, achPATH);
                    lpszzEnv += sizeof(achPATH);
                    cchEnv += sizeof(achPATH);
                    pTmp = pLine + sizeof(achPATH) - 1;
                    while (!isgraph(*pTmp) && !ISEOL(*pTmp))
                        pTmp++;
                    if (*pTmp == '=') {
                        pTmp++;
                        while(!isgraph(*pTmp) && !ISEOL(*pTmp))
                            pTmp++;
                    }
                    while(!ISEOL(*pTmp)) {
                        *lpszzEnv++ = *pTmp++;
                        cchEnv++;
                    }
                    *lpszzEnv++ = '\0';
                    cchEnv++;
                 }
                 else if(!_strnicmp(pLine, achSET, sizeof(achSET) -1 )) {
                        // SET was found, first search for name
                        pTmp = pLine + sizeof(achSET) - 1;
                        while(!isgraph(*pTmp) && !ISEOL(*pTmp))
                             pTmp ++;
                        // get the name
                        lpszName = pTmp;
                        // looking for the '='
                        // note that the name can have white characters
                        while (!ISEOL(*lpszName) && *lpszName != '=')
                            lpszName++;
                        if (!ISEOL(*lpszName)) {
                            // copy the name
                            while (pTmp < lpszName) {
                                *lpszzEnv++ = *pTmp++;
                                cchEnv++;
                            }
                            *lpszzEnv++ = '\0';
                            cchEnv++;
                            // discard the '='
                            pTmp++;
                            // grab the value(may be nothing
                            while (!ISEOL(*pTmp)) {
                                *lpszzEnv++ = *pTmp++;
                                cchEnv++;
                            }
                            *lpszzEnv++ = '\0';
                            cchEnv++;
                        }
                      }


       dw = WriteExpanded(hTmpFile, pLine, dwRawFileSize);
       pLine += dw;
       dwRawFileSize -=dw;

       WriteFileAssert(hTmpFile,achEOL,sizeof(achEOL) - sizeof(CHAR));

       }  // END, while (dwRawFileSize)



    if (bConfig)  {
        UINT OemCP;
#if defined(JAPAN) || defined(KOREA)
        UINT ConsoleCP;
#endif // JAPAN || KOREA
        UINT CtryId;
        CHAR szCtryId[64]; // expect "nnn" only

         /*  Ensure that the country settings are in sync with NT This is
          *  especially important for DosKrnl file UPCASE tables. The
          *  doskrnl default is "CTRY_UNITED_STATES, 437". But we add the
          *  country= line to config.sys, even if is US,437, so that the DOS
          *  will know where the default country.sys is.
          */
        if (GetLocaleInfo(LOCALE_USER_DEFAULT, LOCALE_IDEFAULTCOUNTRY,
                          szCtryId, sizeof(szCtryId) - 1) )
          {
           CtryId = strtoul(szCtryId,NULL,10);
           }
        else {
           CtryId = CTRY_UNITED_STATES;
           }

        OemCP = GetOEMCP();
#if defined(JAPAN) || defined(KOREA)
        ConsoleCP = GetConsoleOutputCP();
        if (OemCP != ConsoleCP)
            OemCP = ConsoleCP;
#endif // JAPAN || KOREA

        sprintf(achRawFile,
                "%s=%3.3u,%3.3u,%s\\system32\\%s.sys%s",
                achCOUNTRY, CtryId, OemCP, achSysRoot, achCOUNTRY, achEOL);
        WriteFileAssert(hTmpFile,achRawFile,strlen(achRawFile));



         /*  We cannot allow the user to set an incorrect shell= command
          *  so we will contruct the correct shell= command appending
          *  either (in order of precedence):
          *    1.    /c ThirdPartyShell
          *    2.    /e:NNNN
          *    3.    nothing
          *
          *  If there is a third party shell then we must turn the console
          *  on now since we no longer have control once system32\command.com
          *  spawns the third party shell.
          */

           // write shell=....
        sprintf(achRawFile,
                "%s=%s%s /p %s\\system32",
                achSHELL,achSysRoot, achCOMMAND, achSysRoot);
        WriteFileAssert(hTmpFile,achRawFile,strlen(achRawFile));

           // write extra string (/c ... or /e:nnn)
        if (pPartyShell && isgraph(*pPartyShell)) {
            pTmp = pPartyShell;
            while (!ISEOL(*pTmp))
                   pTmp++;
            }
        else if (pEnvParam && isgraph(*pEnvParam))  {
            pTmp = pEnvParam;
            while (isgraph(*pTmp))
                  pTmp++;
            }
        else {
            pTmp = NULL;
            }

        if (pTmp) {
            *pTmp = '\0';
            if (pPartyShell)  {
                cmdInitConsole();
                strcpy(achRawFile, " /c ");
                strncat(achRawFile, pPartyShell,sizeof(achRawFile)-3);
                }
            else if (pEnvParam) {
                strcpy(achRawFile, " ");
                strncat(achRawFile, pEnvParam,sizeof(achRawFile)-1);
                }

            achRawFile[sizeof(achRawFile)-1] = 0;
            WriteExpanded(hTmpFile, achRawFile, strlen(achRawFile));
            }

        WriteFileAssert(hTmpFile,achEOL,sizeof(achEOL) - sizeof(CHAR));
        }

    SetEndOfFile(hTmpFile);
    CloseHandle(hTmpFile);
    CloseHandle(hRawFile);
    free(pRawBuffer);
    if (!bConfig) {
        // shrink(or free) the memory
        if (cchEnv && lpszzcmdEnv16) {
            // doubld null terminate it
            lpszzcmdEnv16[cchEnv++] = '\0';
            // shrink the memory. If it fails, simple keep
            // it as is
            lpszzEnv = realloc(lpszzcmdEnv16, cchEnv);
            if (lpszzEnv != NULL)
                lpszzcmdEnv16 = lpszzEnv;
        }
        else {
            free(lpszzcmdEnv16);
            lpszzcmdEnv16 = NULL;
        }
    }

}




/*
 *  WriteExpanded - writes up to dwChars or EOL, expanding %SystemRoot%
 *                  returns number of CHARs processed in buffer
 *                          (not number of bytes actually written)
 */
DWORD WriteExpanded(HANDLE hFile,  CHAR *pch, DWORD dwChars)
{
  DWORD dw;
  DWORD dwSave = dwChars;
  CHAR  *pSave = pch;


  while (dwChars && !ISEOL(*pch)) {
        if (*pch == '%' &&
            !_strnicmp(pch, achSYSROOT, sizeof(achSYSROOT)-sizeof(CHAR)) )
           {
            dw = pch - pSave;
            if (dw)  {
                WriteFileAssert(hFile, pSave, dw);
                }

            WriteFileAssert(hFile, achSysRoot, dwLenSysRoot);

            pch     += sizeof(achSYSROOT)-sizeof(CHAR);
            pSave    = pch;
            dwChars -= sizeof(achSYSROOT)-sizeof(CHAR);
            }
#ifdef JAPAN
        // device=...\$disp.sys /hs=%HardwareScroll%
        else if (*pch == '%' &&
            !_strnicmp(pch, achHARDWARESCROLL, sizeof(achHARDWARESCROLL)-sizeof(CHAR)) )
           {
            dw = pch - pSave;
            if (dw)  {
                WriteFileAssert(hFile, pSave, dw);
                }

            WriteFileAssert(hFile, achHardwareScroll, dwLenHardwareScroll);

            pch     += sizeof(achHARDWARESCROLL)-sizeof(CHAR);
            pSave    = pch;
            dwChars -= sizeof(achHARDWARESCROLL)-sizeof(CHAR);
            }
#endif // JAPAN
#if defined(KOREA) // looking for hbios.sys
        else if (fKoreanCP && *pch  == 'h' &&
            !_strnicmp(pch, achHBIOS, sizeof(achHBIOS)-sizeof(CHAR)) )
           {
            dw = pch - pSave;
            if (dw)  {
                WriteFileAssert(hFile, pSave, dw);
                }

            WriteFileAssert(hFile, achHotkeyOption, dwLenHotkeyOption);

            pch     += sizeof(achHBIOS)-sizeof(CHAR);
            pSave    = pch;
            dwChars -= sizeof(achHBIOS)-sizeof(CHAR);
        }
#endif // KOREA
        else {
            pch++;
            dwChars -= sizeof(CHAR);
            }
        }

  dw = pch - pSave;
  if (dw) {
      WriteFileAssert(hFile, pSave, dw);
      }

  return (dwSave - dwChars);
}




/*
 *  WriteFileAssert
 *
 *  Cecks for error in wrtiting the temp boot file,
 *  If one occurs displays warning popup and terminates the vdm.
 *
 */
void WriteFileAssert(HANDLE hFile, CHAR *pBuff, DWORD dwBytes)
{
  DWORD dw;
  CHAR  ach[MAX_PATH];

  if (!WriteFile(hFile, pBuff, dwBytes, &dw, NULL) ||
       dw  != dwBytes)
     {

      GetTempPath(MAX_PATH, ach);
      ach[63] = '\0';
      RcErrorDialogBox(ED_INITTMPFILE, ach, NULL);
      TerminateVDM();  // skip cleanup since I insist that we exit!
      }
}
#ifdef JAPAN
//
// MSKK 8/26/1993 V-KazuyS
// Get HardwareScroll type from registry
// this parameter also use console.
//
DWORD GetHardwareScroll( PCHAR achHardwareScroll, int size )
{
    HKEY  hKey;
    DWORD dwType;
    DWORD retCode;
    CHAR  szBuf[256];
    DWORD cbData=256L;
    DWORD num;
    PCHAR psz;

// Get HardwareScroll type ( ON, LC or OFF ) from REGISTRY file.

  // OPEN THE KEY.

    retCode = RegOpenKeyEx (
                      HKEY_LOCAL_MACHINE,         // Key handle at root level.
                      "HARDWARE\\DEVICEMAP\\VIDEO", // Path name of child key.
                      0,                            // Reserved.
                      KEY_EXECUTE,                  // Requesting read access.
                      &hKey );               // Address of key to be returned.

// If retCode != 0 then we cannot find section in Register file
    if ( retCode ) {
#ifdef JAPAN_DBG
        DbgPrint( "NTVDM: RegOpenKeyEx failed %xh\n", retCode );
#endif
        strcpy( achHardwareScroll, "off");
        return ( strlen("off") );
    }

    dwType = REG_SZ;

// Query for line from REGISTER file
    retCode = RegQueryValueEx(  hKey,
                                "\\Device\\Video0",
                                NULL,
                                &dwType,
                                szBuf,
                                &cbData);

    szBuf[sizeof(szBuf)-1] = '\0';

    if ( retCode ) {
#ifdef JAPAN_DBG
        DbgPrint( "NTVDM: RegQueryValueEx failed %xh\n", retCode );
#endif
        strcpy( achHardwareScroll, "off");
        return ( strlen("off") );
    }

    RegCloseKey(hKey);

#ifdef JAPAN_DBG
    DbgPrint( "NTVDM: Get \\Device\\Video0=[%s]\n", szBuf );
#endif
    psz = strchr( (szBuf+1), '\\' ); // skip \\REGISTRY\\   *
#ifdef JAPAN_DBG
    DbgPrint( "NTVDM: skip \\registry\\ [%s]\n", psz );
#endif
    if ( psz != NULL )
        psz = strchr( (psz+1), '\\' ); // skip Machine\\    *

    if ( psz == NULL ) {
#ifdef JAPAN_DBG
        DbgPrint( "NTVDM: Illegal value[%s]h\n", szBuf );
#endif
        strcpy( achHardwareScroll, "off" );
        return ( strlen("off") );
    }

    psz++;

#ifdef JAPAN_DBG
    DbgPrint( "NTVDM: Open 2nd Key=[%s]\n", psz );
#endif

    retCode = RegOpenKeyEx (
                      HKEY_LOCAL_MACHINE,         // Key handle at root level.
                      psz,                      // Path name of child key.
                      0,                            // Reserved.
                      KEY_EXECUTE,                  // Requesting read access.
                      &hKey );               // Address of key to be returned.

// If retCode != 0 then we cannot find section in Register file
    if ( retCode ) {
#ifdef JAPAN_DBG
        DbgPrint( "NTVDM: RegOpenKeyEx failed %xh\n", retCode );
#endif
        strcpy( achHardwareScroll, "off" );
        return ( strlen("off") );
    }

    dwType = REG_SZ;

// Query for line from REGISTER file
    retCode = RegQueryValueEx(  hKey,
                                "ConsoleFullScreen.HardwareScroll",
                                NULL,
                                &dwType,
                                szBuf,
                                &cbData);

    if ( retCode ) {
#ifdef JAPAN_DBG
        DbgPrint( "NTVDM: RegQueryValueEx failed %xh\n", retCode );
#endif
        strcpy( achHardwareScroll, "off" );
        return ( strlen("off") );
    }

    RegCloseKey(hKey);

#ifdef JAPAN_DBG
    DbgPrint( "NTVDM: Get FullScreenHardwareScroll=[%s]\n", szBuf );
#endif

    num = ( lstrlen(szBuf)+1 > size ) ? size : lstrlen(szBuf)+1;
    RtlCopyMemory( achHardwareScroll, szBuf, num );
    achHardwareScroll[num] = '\0';

#ifdef JAPAN_DBG
    DbgPrint( "NTVDM: Set %HardwareScroll%=[%s]\n", achHardwareScroll );
#endif

    return num;
}
#endif // JAPAN

#if defined(KOREA)
/*
 * 8/05/1996 bklee
 * Get keyboard layout from system and set hotkey option for hbios.sys
 * Here are hotkey options for HBIOS.SYS.
 *
 *      Keyboard Type    Hangul          Hanja
 * 1        101a         r + alt         r + ctrl     : default
 * 2        101b         r + ctrl        r + alt
 * 3        103          Hangul          Hanja
 * 4        84           alt + shift     ctrl + shift
 * 5        86           Hangul          Hanja
 * 6        101c         l shift + space l ctrl + space
 * 7        64                                        : N/A. map to default
 */

DWORD GetHotkeyOption( PCHAR achHotkeyOption, UINT size )
{
      // GetKeyboardType(1) return 1 to 6 as sub-keyboard type.
      // No 7 sub-keyboard type will be returned.
      UINT HotkeyIndex[6] = { 4, 5, 1, 2, 6, 3 };
      UINT SubKeyType, HotkeyOption;

      if ( GetKeyboardType(0) == 8 )  { // KOREAN Keyboard layout

           SubKeyType = GetKeyboardType(1);

           if ( SubKeyType > 0 && SubKeyType < 7 )
                HotkeyOption = HotkeyIndex[SubKeyType - 1];
           else
                HotkeyOption = 1; // Set to default.

           wsprintf(achHotkeyOption, "hbios.sys /K:%d", HotkeyOption);
      }
      else
           strcpy(achHotkeyOption, "hbios.sys");
      return(strlen(achHotkeyOption));
}
#endif // KOREA
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dos\command\cmdexit.c ===
/*  cmdexit.c - Exit related SVC routines
 *
 *  cmdExit
 *
 *  Modification History:
 *
 *  Sudeepb 05-Jul-1991 Created
 */

#include "cmd.h"

#include <cmdsvc.h>
#include <softpc.h>
#include <winbase.h>

/* cmdExitVDM - Terminate the VDM
 *
 *
 * Entry - None
 *
 * Exit  - None
 *
 *
 *
 */

VOID cmdExitVDM (VOID)
{
    // Kill the VDM process
    TerminateVDM();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dos\command\cmdkeyb.c ===
/*  cmdkeyb.c - Keyboard layout support routines
 *
 *
 *  Modification History:
 *
 *  YST 14-Jan_1993 Created
 *
 *  08-Sept-1998, williamh, add third-party KDF support.
 */

#include "cmd.h"
#include <winconp.h>
#include <cmdsvc.h>
#include <softpc.h>
#include <mvdm.h>
#include <ctype.h>
#include <string.H>
#include "cmdkeyb.h"
#include <winnls.h>
#include "host_def.h"

CHAR szPrev[5] = "US";
INT  iPrevCP = 437;
CHAR szPrevKbdID[8] = "";

extern BOOL bPifFastPaste;

/************************************************************************\
*
*  FUNCTION:	VOID cmdGetKbdLayout( VOID )
*
*  Input	Client (DX) = 0 - Keyb.com not installed
*			      1 - Keyb.com installed
*		Client (DS:SI) = pointer where exe name has to be placed
*		Client (DS:CX) = pointer where command options are placed
*
*  Output
*	Success (DX = 1 )
*		Client (DS:SI) = Keyb.com execuatable string
*		Client (DS:CX) = command options
*
*	Failure (DX = 0)
*
*  COMMENTS:    This function check KEYBOARD ID for Win session
*		and if ID != US then return lines with
*               filename and options to COMMAND.COM
*
*               If bPifFastPaste is FALSE, then we always run kb16
*               for all keyboard ID including US, to give us a more
*               bios compatible Int 9 handler. 10-Jun-1993 Jonle
*
*
*  HISTORY:     01/05/93 YSt Created.
*
\************************************************************************/

VOID cmdGetKbdLayout( VOID )
{
  INT  iSize;
  CHAR szKeybCode[12];
  CHAR szDir[MAX_PATH+15];
  CHAR szBuf[5];
  CHAR szNewKbdID[8];
  CHAR szAutoLine[MAX_PATH+40];
  CHAR szKDF[MAX_PATH];
  PCHAR pVDMKeyb;
  INT  iKeyb;
  HKEY	 hKey;
  HKEY	 hKeyLayout;
  DWORD  dwType;
  DWORD  retCode;
  INT	 iNewCP;
  DWORD  cbData;
  WORD	 KeybID;
  OFSTRUCT  ofstr;
  LANGID LcId = GetSystemDefaultLangID();
  int	 keytype;


// Get information about 16 bit KEYB.COM from VDM
   iKeyb = getDX();


// The whole logic here is to decide:
// (1). if we have to run kb16.com at all.
// (2). if we have to run kb16.com, what parameters we should pass along,
//	such as keyboard id, language id, code page id and kdf file name.
// We do not load kb16.com at all if one of the following
// conditions is met:
// (1). We can not find the console keyboard layout id.
// (2). The console keyvoard layout id is US and kb16.com is not loaded
//	and fast paste is disabled.
// (3). We can not get the dos keyboard id/dos key code.
// (4). The new (language id, keyboard id, code page id) is the same
//	as the one we loaded previously.
// (5). we can not find kb16.com.
// (6). we can not find the kdf file that supports the
//	(language id, keyboard id, code page id) combination.
//
// If everything goes as planned, we end up with a command
// contains kb16.com fully qualified name and a command line contains
// appropriate parameters to kb16.com
//

    if (LcId == MAKELANGID(LANG_JAPANESE,SUBLANG_DEFAULT)) {
        // JAPAN build. Language id is always "JP" and code page is either 932
        // or 437 depends on keyboard type.
            iNewCP = 437;
            if (7 == GetKeyboardType(0))
            {
	        keytype = GetKeyboardType(1);
                if (keytype == 1 || keytype == 2 || keytype == 3 || (keytype & 0xff00) == 0x1200)
	            iNewCP = 932;
            }
            szBuf[0] = 'J';
            szBuf[1] = 'P';
            szBuf[2] = '\0';
            // no keyboard id available.
            szNewKbdID[0] = '\0';
    }
    else {
//
// check point #1: see if we can get the console keyboard layout id
//
        if (!GetConsoleKeyboardLayoutName(szKeybCode))
	    goto NoInstallkb16;
//
// check point #2: see if the layout is US and kb16.com is loaded and
//		   fast paste is disabled.
//		   If kb16.com is loaded, we need to run it again
//		   so that it will load the correct layout.
//		   If fast paste is disable, we load kb16.com which
//		   definitely will slow down keys delivery.
//
        if( bPifFastPaste && !strcmp(szKeybCode, US_CODE) && !iKeyb)
	    goto NoInstallkb16;
//
// check point #3: see if we can get the language id and keyboard id(if any)
//

  // OPEN THE KEY.
        sprintf(szAutoLine, "%s%s", KBDLAYOUT_PATH, DOSCODES_PATH);
        if (ERROR_SUCCESS != RegOpenKeyEx (HKEY_LOCAL_MACHINE, // Key handle at root level.
			      szAutoLine, // Path name of child key.
                              0,           // Reserved.
                              KEY_EXECUTE, // Requesting read access.
			      &hKey))      // Address of key to be returned.
	    goto NoInstallkb16;


        cbData  = sizeof(szBuf);
        // Query for line from REGISTER file
        retCode = RegQueryValueEx(hKey, szKeybCode, NULL, &dwType, szBuf, &cbData);

        RegCloseKey(hKey);
        if (ERROR_SUCCESS != retCode || REG_SZ != dwType || !cbData)
	    goto NoInstallkb16;
        //
        // szBuf now contains language id('SP' for spanish, for example).
        //
        // look for keyboard id number. For Daytona, Turkish and Italian both
        // have one key code and two layouts.
        szNewKbdID[0] = '\0';
        cbData = sizeof(szNewKbdID);
        sprintf(szAutoLine, "%s%s", KBDLAYOUT_PATH, DOSIDS_PATH);
        if (RegOpenKeyEx(HKEY_LOCAL_MACHINE,
		          szAutoLine,
		          0,
		          KEY_EXECUTE,
		          &hKey
		          ) == ERROR_SUCCESS)
        {
	    retCode = RegQueryValueEx(hKey, szKeybCode, NULL, &dwType, szNewKbdID, &cbData);
	    if (ERROR_SUCCESS != retCode || REG_SZ != dwType || !cbData)
	        szNewKbdID[0] = '\0';

	    RegCloseKey(hKey);
        }

        iNewCP = GetConsoleCP();

    }

//
// check point #4: see if there are any changes in ids
//

// see if there are changes in language id, keyboard id and code page id.

    if(bPifFastPaste && iNewCP == iPrevCP &&
       !_stricmp(szBuf, szPrev) &&
       !_stricmp(szNewKbdID, szPrevKbdID))
    {
	goto NoInstallkb16;
    }

//
// Check point #5: see if kb16.com can be found.
//
// kb16.com should be found in GetSystemDirectory()\system32 subdirectory.
//

    // convert the system directory to short name
    cbData = GetShortPathName(pszSystem32Path, szDir, MAX_PATH);
    if (!cbData || cbData >= MAX_PATH)
	goto NoInstallkb16;

    sprintf(szAutoLine, "%s%s",
        szDir,              // System directory
        KEYB_COM            // keyb.com
	);
    // if the fully qualified path name to kb16.com is too long
    // we must fail because Dos can not swallow a long path name.
    if (strlen(szAutoLine) > 128)
	goto NoInstallkb16;

    dwType = GetFileAttributes(szAutoLine);
    if (dwType == 0xFFFFFFFF || (dwType & FILE_ATTRIBUTE_DIRECTORY) != 0)
    {
	goto NoInstallkb16;
    }

//
// Check point #6: see if we can find kdf file that support the
//		   (language id, keyboard id, code page id) combination
//

    //
    // first, convert keyboard id from string to binary if we have one.
    //
    KeybID = (szNewKbdID[0]) ? (WORD)strtoul(szNewKbdID, NULL, 10) : 0;
    cbData = sizeof(szKDF) / sizeof(CHAR);

    // locate the kdf file.
    if (!LocateKDF(szBuf, KeybID, (WORD)iNewCP, szKDF, &cbData))
    {
	goto NoInstallkb16;
    }
    // convert the kdf name to short name
    cbData = GetShortPathName(szKDF, szKDF, sizeof(szKDF)/ sizeof(CHAR));
    if (!cbData || cbData >= sizeof(szKDF) / sizeof(CHAR))
    {
	goto NoInstallkb16;
    }
    //
    // everything is checked and in place. Now compose the command
    // line to execute kb16.com

    // first, the command
    pVDMKeyb = (PCHAR) GetVDMAddr((USHORT) getDS(), (USHORT) getSI());
    strcpy(pVDMKeyb, szAutoLine);
    // then the parameters
    // The format is: XX,YYY, <kdf file>, where XXX is the language id
    // and YYY is the code page id.
    pVDMKeyb = (PCHAR) GetVDMAddr((USHORT) getDS(), (USHORT) getCX());
    // The first byte is resevered for the length of the string.
    sprintf(szAutoLine, " %s,%d,%s",
	szBuf,		    // keyboard code
	iNewCP, 	    // new code page
	szKDF		    // keyboard.sys
	);
    // if we have a keyboard id, pass it also
    if (szNewKbdID[0])
    {
	strcat(szAutoLine, " /id:");
	strcat(szAutoLine, szNewKbdID);
    }
    // standard parameter line has the format:
    // <length><line text><\0xd>, <length> is the length of <line text>
    //
    iSize = strlen(szAutoLine);
    szAutoLine[iSize] = 0xd;
    // Move the line to 16bits, including the terminated cr char
    RtlMoveMemory(pVDMKeyb + 1, szAutoLine, iSize + 1);
    *pVDMKeyb = (CHAR)iSize;
// Save new layout ID  and code page for next call
    strcpy(szPrev, szBuf);
    strcpy(szPrevKbdID, szNewKbdID);
    iPrevCP = iNewCP;

    setDX(1);
    return;

NoInstallkb16:
    setDX(0);
    cmdInitConsole();      // make sure conoutput is on
    return;
}

//
// This function locates the appropriate keyboard definition file from
// the given language, keyboard and code page id. It searches the registry
// for third-party installed KDF files first and then falls back to
// the system default, %systemroot%\system32\keyboard.sys.
//
// INPUT:
//	LanguageID	-- the language id
//	KeyboardID	-- the optional keyboard id, 0 means do not care
//	CodePageID	-- the code page id
//	Buffer		-- the buffer to receive fully qualified kdf file name
//	BufferSize	-- the size of Buffer in bytes
//
// OUTPUT:
//	TRUE -- Buffer is filled with the kdf fully qualified file name and
//		*BufferSize is set with the size of the file name, not including
//		the null terminated char. If no kdf file can be found,
//		the Buffer is terminated with NULL and *BufferSize if set to 0.
//	FALSE -- error. GetLastError() should return the error code
//		 If the error occurs because the provided buffer is too small
//		*BufferSize will set to the required size(excluding null
//		terminated char) and error code will be set to
//		ERROR_INSUFFICIENT_BUFFER
//
BOOL
LocateKDF(
    CHAR*   LanguageID,
    WORD    KeyboardID,
    WORD    CodePageID,
    LPSTR   Buffer,
    DWORD*   BufferSize
    )
{
    HKEY  hKeyWow;
    BOOL  Result;
    DWORD dw, Type;
    DWORD Attributes;
    DWORD ErrorCode;
    CHAR* KDFName;
    CHAR* LocalBuffer;
    CHAR* FinalKDFName;
    CHAR  FullName[MAX_PATH*2];

    // validate buffer parameter first
    if (!CodePageID || !LanguageID || !BufferSize || (*BufferSize && !Buffer))
    {
	SetLastError(ERROR_INVALID_PARAMETER);
	return FALSE;
    }
    // Open the registry to see if we have alternative kdf files avaialble.
    // We seach the file from atlternative file list in the registry first.
    // The first KDF in the list has the highest rank and the last one has
    // the lowest. The search starts from highest rank and then goes
    // on toward the lower ones. As soon as a KDF file is found, the search
    // stops. If no appropriate KDF can be found in the alternative list,
    // the default kdf, keyboard.sys, will be used.
    //
    // FinalKDFName serves as an indicator. If it is NULL,
    // we do not find any file that satisfies the request.
    FinalKDFName = NULL;
    LocalBuffer = NULL;
    if (RegOpenKeyEx(HKEY_LOCAL_MACHINE,
		     REG_STR_WOW,
		     0,
		     KEY_EXECUTE,
		     &hKeyWow
		     ) == ERROR_SUCCESS)
    {
	// first probe for size
	dw = 0;
	RegQueryValueEx(hKeyWow, REG_STR_ALTKDF_FILES, NULL, &Type, NULL, &dw);
	if (dw && (REG_MULTI_SZ == Type))
	{
	    // we have something in the registry. Allocate a buffer to reteive
	    // it. We want the value to be double null terminated,
	    // so we add one more char in case it is a REG_SZ.
	    // The returned size from RegQueryValueEx includes the
	    // null terminated char(and the double null chars for
	    // REG_MULTI_SZ. By adding one more char, we are in
	    // good shape.

	    ASSERT(!LocalBuffer);
	    LocalBuffer = malloc((dw + 1)* sizeof(CHAR));
	    if (LocalBuffer)
	    {
		LocalBuffer[0] = '\0';
		if (RegQueryValueEx(hKeyWow, REG_STR_ALTKDF_FILES, NULL, &Type,
				LocalBuffer, &dw) == ERROR_SUCCESS && dw)
		{
		    KDFName = LocalBuffer;
		    while ('\0' != *KDFName)
		    {
			// See if we can find the file first.
			Attributes = GetFileAttributesA(KDFName);
			if (0xFFFFFFFF == Attributes)
			{
			    // file not found, do a search
			    if (SearchPathA(NULL,	// no path
					    KDFName,
					    NULL,	// no extension
					    sizeof(FullName) / sizeof(CHAR),
					    FullName,
					    NULL
					    ))
			    {
				FinalKDFName = FullName;
			    }
			}
			else
			{
			    FinalKDFName = KDFName;
			}
			if (MatchKDF(LanguageID, KeyboardID, CodePageID, FinalKDFName))
				break;
			KDFName += strlen(KDFName) + 1;
			FinalKDFName = NULL;
		    }
		}
	    }
	    else
	    {
		// not enough memory
		RcMessageBox(EG_MALLOC_FAILURE, NULL, NULL,
			     RMB_ICON_BANG | RMB_ABORT);
		 TerminateVDM();
	    }
	}
	if (!FinalKDFName)
	{
	    // either no alternative kdf files are specified in the registry
	    // or none of them contains the required specification,
	    // use the default kdf file
	    FullName[0] = '\0';
	    GetSystemDirectory(FullName, sizeof(FullName) / sizeof(CHAR));

            if (!_stricmp(LanguageID, "JP") &&
	        7 == GetKeyboardType(0)
               ) {
	        // For Japanese language ID, different keyboard types have different
	        // default kdf.

                int Keytype;

                Keytype = GetKeyboardType(1);
                if (Keytype == 1)
                    strcat(FullName, KDF_AX);
                else if (Keytype == 2)
                    strcat(FullName, KDF_106);
                else if (Keytype == 3)
                    strcat(FullName, KDF_IBM5576_02_03);
                else if ((Keytype & 0xFF00) == 0x1200)
                    strcat(FullName, KDF_TOSHIBA_J3100);
                else
                    strcat(FullName, KEYBOARD_SYS);
            }
            else
	        strcat(FullName, KEYBOARD_SYS);

	    FinalKDFName = FullName;
	}
	RegCloseKey(hKeyWow);
    }
    if (FinalKDFName)
    {
	dw = strlen(FinalKDFName);
	if (dw && dw < *BufferSize)
	{
	    strcpy(Buffer, FinalKDFName);
	    *BufferSize = dw;
	    Result = TRUE;
	}
	else
	{
	    *BufferSize = dw;
	    SetLastError(ERROR_INSUFFICIENT_BUFFER);
	    Result = FALSE;
	}
    }
    else
    {
	Result = FALSE;
	*BufferSize = 0;
	SetLastError(ERROR_FILE_NOT_FOUND);
    }
    //
    // finally, free the buffer we allocated
    //
    if (LocalBuffer)
	free(LocalBuffer);
    return Result;
}

//
// This function determines if the given kdf supports the given
// (language id, keyboard id, code page id) combination
//
// INPUT:
//	LanguageID	-- the language.
//	KeyboardID	-- optional keyboard id. 0 if do not care
//	CodePageID	-- code page id
//	KDFPath		-- fully qualified kdf file
// OUTPUT:
//	TRUE  -- The kdf contains the given combination
//	FALSE -- either the kdf does not contain the combination or
//		 can not determine.
//
BOOL
MatchKDF(
    CHAR* LanguageID,
    WORD KeyboardID,
    WORD CodePageID,
    LPCSTR KDFPath
    )
{
    HANDLE hKDF;
    KDF_HEADER	Header;
    KDF_LANGID_ENTRY	  LangIdEntry;
    DWORD BytesRead, BufferSize;
    WORD  Index;
    DWORD LangIdEntryOffset;
    PKDF_CODEPAGEID_OFFSET pCodePageIdOffset;
    BOOL Matched;

    if (!KDFPath || !LanguageID || !CodePageID)
    {
	SetLastError(ERROR_INVALID_PARAMETER);
	return FALSE;
    }
    Matched = FALSE;

    LangIdEntryOffset = 0;
    // open the kdf file.
    hKDF = CreateFile(KDFPath, GENERIC_READ, FILE_SHARE_READ | FILE_SHARE_WRITE,
			  NULL, OPEN_EXISTING, 0, NULL);
    if (INVALID_HANDLE_VALUE != hKDF &&
	ReadFile(hKDF, &Header, sizeof(Header),&BytesRead, NULL) &&
	BytesRead == sizeof(Header) && Header.TotalLangIDs &&
	Header.TotalKeybIDs &&
	!strncmp(Header.Signature, KDF_SIGNATURE, sizeof(Header.Signature))
	)
    {
	// The file header is loaded, the signature checked and sanity check
	// on language and keyboard id counts is also done.
	// We are now ready to verfiy if the given language id, keyboard id
	// and code page id is supported in this file.
	// A KDF has two sets of offset table. One is based on language ID
	// while the other one is based on keyboard id. Since a language ID
	// may contain multiple keyboard id, the keyboard id set is always
	// encompass the language id table.
	// If the caller gives us a keyboard id, we use the id as the
	// key for search and verify language id when we found the keyboard
	// id. If no keyboard id is provided, we use the language id as the
	// key.
	if (KeyboardID)
	{
	    // move the file pointer to the keyboard id offset array
	    BufferSize = sizeof(KDF_LANGID_OFFSET) * Header.TotalLangIDs;
	    BufferSize = SetFilePointer(hKDF, BufferSize, NULL, FILE_CURRENT);
	    if (0xFFFFFFFF != BufferSize)
	    {
		PKDF_KEYBOARDID_OFFSET pKeybIdOffset;
		BufferSize = sizeof(KDF_KEYBOARDID_OFFSET) * Header.TotalKeybIDs;
		pKeybIdOffset = (PKDF_KEYBOARDID_OFFSET)malloc(BufferSize);
		if (!pKeybIdOffset)
		{
		    // not enough memory
		    RcMessageBox(EG_MALLOC_FAILURE, NULL, NULL,
				 RMB_ICON_BANG | RMB_ABORT);
		     TerminateVDM();
		}
		if (ReadFile(hKDF, pKeybIdOffset, BufferSize, &BytesRead, NULL) &&
		    BytesRead == BufferSize)
		{
		    // loop though each KDF_KEYBOARDID_OFFSET to see
		    // if the keyboard id matches.
		    for (Index = 0; Index < Header.TotalKeybIDs; Index++)
		    {
			if (pKeybIdOffset[Index].ID == KeyboardID)
			{
			    // got it. Remeber the file offset to
			    // the KDF_LANGID_ENTRY
			    LangIdEntryOffset = pKeybIdOffset[Index].DataOffset;
			    break;
			}
		    }
		}
		free(pKeybIdOffset);
	    }
	}
	else
	{
	    PKDF_LANGID_OFFSET	pLangIdOffset;
	    BufferSize = sizeof(KDF_LANGID_OFFSET) * Header.TotalLangIDs;
	    pLangIdOffset = (PKDF_LANGID_OFFSET)malloc(BufferSize);
	    if (!pLangIdOffset)
	    {
		// not enough memory
		RcMessageBox(EG_MALLOC_FAILURE, NULL, NULL,
			     RMB_ICON_BANG | RMB_ABORT);
		TerminateVDM();
	    }
	    if (ReadFile(hKDF, pLangIdOffset, BufferSize, &BytesRead, NULL) &&
		BytesRead == BufferSize)
	    {
		// loop through each KDF_LANGID_OFFSET to see if
		// language id matches
		for (Index = 0; Index < Header.TotalLangIDs; Index++)
		{
		    if (IS_LANGID_EQUAL(pLangIdOffset[Index].ID, LanguageID))
		    {
			LangIdEntryOffset = pLangIdOffset[Index].DataOffset;
			break;
		    }
		}
	    }
	    free(pLangIdOffset);
	}
	if (LangIdEntryOffset)
	{
	    BufferSize = SetFilePointer(hKDF, LangIdEntryOffset, NULL, FILE_BEGIN);
	    if (0xFFFFFFFF != BufferSize &&
		ReadFile(hKDF, &LangIdEntry, sizeof(LangIdEntry), &BytesRead, NULL) &&
		BytesRead == sizeof(LangIdEntry))
	    {
		// sanity checks
		if (IS_LANGID_EQUAL(LangIdEntry.ID, LanguageID) &&
		    LangIdEntry.TotalCodePageIDs)
		{
		    // the KDF_LANGID_ENTRY looks fine. Now retrieve
		    // its code page offset table and search the given
		    // code page id

		    BufferSize = LangIdEntry.TotalCodePageIDs * sizeof(KDF_CODEPAGEID_OFFSET);
		    pCodePageIdOffset = (PKDF_CODEPAGEID_OFFSET)malloc(BufferSize);
		    if (!pCodePageIdOffset)
		    {
			// not enough memory
			RcMessageBox(EG_MALLOC_FAILURE, NULL, NULL,
				     RMB_ICON_BANG | RMB_ABORT);
			TerminateVDM();
		    }
		    if (ReadFile(hKDF, pCodePageIdOffset, BufferSize, &BytesRead, NULL) &&
			BytesRead == BufferSize)
		    {
			for (Index = 0; Index < LangIdEntry.TotalCodePageIDs; Index++)
			{
			    if (CodePageID == pCodePageIdOffset[Index].ID)
			    {
				Matched = TRUE;
				break;
			    }
			}
		    }
		    free(pCodePageIdOffset);
		}
	    }
	}
	CloseHandle(hKDF);
    }
    return Matched;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dos\command\cmdenv.c ===
/*  cmdenv.c - Environment supporting functions for command.lib
 *
 *
 *  Modification History:
 *
 *  williamh 13-May-1993 Created
 */

#include "cmd.h"

#include <cmdsvc.h>
#include <demexp.h>
#include <softpc.h>
#include <mvdm.h>
#include <ctype.h>
#include <memory.h>
#include <oemuni.h>

#include <userenv.h>
#include <userenvp.h>

#define VDM_ENV_INC_SIZE    512

CHAR windir[] = "windir";

extern BOOL fSeparateWow;

// These two functions are temp var filtering instruments
//
//

VOID cmdCheckTempInit(VOID);
LPSTR cmdCheckTemp(LPSTR lpszzEnv);

// Transform the given DOS environment to 32bits environment.
// WARNING!! The environment block we passed to 32bits must be in sort order.
//           Therefore, we call RtlSetEnvironmentVariable to do the work
// The result string must be in ANSI character set.
BOOL    cmdXformEnvironment(PCHAR pEnv16, PANSI_STRING Env_A)
{
    UNICODE_STRING  Name_U, Value_U, Temp_U;
    STRING          String;
    PWCHAR          pwch, NewEnv, CurEnv, CurEnvCopy, pTmp;
    NTSTATUS        Status;
    BOOL            fFoundComSpec;
    USHORT          NewEnvLen;
    PCHAR           pEnv;
    DWORD           Length;

    if (pEnv16 == NULL)
        return FALSE;

    // flag true if we alread found comspec envirnment
    // !!!! Do we allow two or more comspec in environment????????
    fFoundComSpec = FALSE;

    CurEnv = GetEnvironmentStringsW();
    pwch = CurEnv;
    // figure how long the environment strings is
    while (*pwch != UNICODE_NULL || *(pwch + 1) != UNICODE_NULL)
        pwch++;

    // plus 2  to include the last two NULL chars
    CurEnvCopy = malloc((pwch - CurEnv + 2) * sizeof(WCHAR));
    if (!CurEnvCopy)
        return FALSE;

    // make a copy of current process environment so we can walk through
    // it. The environment can be changed by any threads in the process
    // thus is not safe to walk through without a local copy
    RtlMoveMemory(CurEnvCopy, CurEnv, (pwch - CurEnv + 2) * sizeof(WCHAR));

    // create a new environment block. We don't want to change
    // any currnt process environment variables, instead, we are
    // preparing a new one for the new process.
    Status = RtlCreateEnvironment(FALSE, (PVOID *)&NewEnv);
    if (!NT_SUCCESS(Status)) {
        free(CurEnvCopy);
        return FALSE;
    }
    NewEnvLen = 0;
    // now pick up environment we want from the current environment
    // and set it to the new environment block
    // the variables we want:
    // (1). comspec
    // (2). current directories settings

    pwch = CurEnvCopy;

    while (*pwch != UNICODE_NULL) {
        if (*pwch == L'=') {
            // variable names started with L'=' are current directroy settings
            pTmp = wcschr(pwch + 1, L'=');
            if (pTmp) {
                Name_U.Buffer = pwch;
                Name_U.Length = (pTmp - pwch) * sizeof(WCHAR);
                RtlInitUnicodeString(&Value_U, pTmp + 1);
                Status = RtlSetEnvironmentVariable(&NewEnv, &Name_U, &Value_U);
                if (!NT_SUCCESS(Status)) {
                    RtlDestroyEnvironment(NewEnv);
                    free(CurEnvCopy);
                    return FALSE;
                }
                // <name> + <'='> + <value> + <'\0'>
                NewEnvLen += Name_U.Length + Value_U.Length + 2 * sizeof(WCHAR);
            }
        }
        else if (!fFoundComSpec) {
                fFoundComSpec = !_wcsnicmp(pwch, L"COMSPEC=", 8);
                if (fFoundComSpec) {
                    Name_U.Buffer = pwch;
                    Name_U.Length = 7 * sizeof(WCHAR);
                    RtlInitUnicodeString(&Value_U, pwch + 8);
                    Status = RtlSetEnvironmentVariable(&NewEnv,
                                                       &Name_U,
                                                       &Value_U
                                                       );
                    if (!NT_SUCCESS(Status)) {
                        RtlDestroyEnvironment(NewEnv);
                        free(CurEnvCopy);
                        return FALSE;
                    }
                    NewEnvLen += Name_U.Length + Value_U.Length + 2 * sizeof(WCHAR);
                }
        }
        pwch += wcslen(pwch) + 1;
    }
    // we are done with current process environment.
    free(CurEnvCopy);

    cmdCheckTempInit();

    // now deal with 16bits settings passed from dos.
    // characters in 16bits environment are in OEM character set

    // 16bit comspec environment variable
    fFoundComSpec = FALSE;
    while (*pEnv16 != '\0') {

        if (NULL != (pEnv = cmdCheckTemp(pEnv16))) {
           RtlInitString(&String, pEnv);
           Length = strlen(pEnv16);
        }
        else {
           RtlInitString(&String, pEnv16);
           Length = String.Length;
        }

        // discard 16bits comspec
        if (!fFoundComSpec) {
            fFoundComSpec = !_strnicmp(pEnv16, comspec, 8);
            if (fFoundComSpec) {
                // ignore 16bits comspec environment
                pEnv16 += Length + 1;
                continue;
            }
        }
        Status = RtlOemStringToUnicodeString(&Temp_U, &String, TRUE);
        if (!NT_SUCCESS(Status)) {
            RtlDestroyEnvironment(NewEnv);
            return FALSE;
        }
        pwch = wcschr(Temp_U.Buffer, L'=');
        if (pwch) {
            Name_U.Buffer = Temp_U.Buffer;
            Name_U.Length = (pwch - Temp_U.Buffer) * sizeof(WCHAR);
            RtlInitUnicodeString(&Value_U, pwch + 1);
            Status = RtlSetEnvironmentVariable( &NewEnv, &Name_U, &Value_U);
            RtlFreeUnicodeString(&Temp_U);
            if (!NT_SUCCESS(Status)) {
                RtlDestroyEnvironment(NewEnv);
                return FALSE;
            }
            NewEnvLen += Name_U.Length + Value_U.Length + 2 * sizeof(WCHAR);
        }
        pEnv16 += Length + 1;
    }
    // count the last terminated null char
    Temp_U.Length = NewEnvLen + sizeof(WCHAR);
    Temp_U.Buffer = NewEnv;
    Status = RtlUnicodeStringToAnsiString(Env_A, &Temp_U, TRUE);
    RtlDestroyEnvironment(NewEnv);      /* don't need it anymore */
    return(NT_SUCCESS(Status));
}


CHAR* cmdFilterTempEnvironmentVariables(CHAR* lpzzEnv, DWORD cchInit)
{
   PCHAR pTmp;
   PCHAR lpzzEnv32;
   PCHAR lpzzTemp;
   DWORD cchRemain = cchInit;
   DWORD cchIncrement = MAX_PATH;
   DWORD Len, LenTmp;
   DWORD Offset = 0;

   lpzzEnv32 = (PCHAR)malloc(cchInit);
   if (NULL == lpzzEnv32) {
      return(NULL);
   }

   cmdCheckTempInit();

   while('\0' != *lpzzEnv) {
      LenTmp = Len = strlen(lpzzEnv) + 1;

      // now copy the string
      if (NULL != (pTmp = cmdCheckTemp(lpzzEnv))) {
         LenTmp = strlen(pTmp) + 1;
      }
      else {
         pTmp = lpzzEnv;
      }

      if (cchRemain < (LenTmp + 1)) {
         if (cchIncrement < LenTmp) {
            cchIncrement = LenTmp;
         }

         lpzzTemp = (PCHAR)realloc(lpzzEnv32, cchInit + cchIncrement);
         if (NULL == lpzzTemp) {
            free(lpzzEnv32);
            return(NULL);
         }
         lpzzEnv32 = lpzzTemp;

         cchInit += cchIncrement;
         cchRemain += cchIncrement;
      }

      strcpy(lpzzEnv32 + Offset, pTmp);

      Offset += LenTmp;
      cchRemain -= LenTmp;
      lpzzEnv += Len;
   }

   *(lpzzEnv32 + Offset) = '\0';
   return(lpzzEnv32);

}



/* get ntvdm initial environment. This initial environment is necessary
 * for the first instance of command.com before it processing autoexec.bat
 * this function strips off an environment headed with "=" and
 * replace the comspec with 16bits comspec and upper case all environment vars.
 *
 * Entry: Client (ES:0) = buffer to receive the environment
 *        Client (BX) = size in paragraphs of the given buffer
 *
 * Exit:  (BX) = 0 if nothing to copy
 *        (BX)  <= the given size, function okay
 *        (BX) > given size, (BX) has the required size
 */

VOID cmdGetInitEnvironment(VOID)
{
    CHAR *lpszzEnvBuffer, *lpszEnv;
    WORD cchEnvBuffer;
    CHAR *lpszzEnvStrings, * lpszz;
    WORD cchString;
    WORD cchRemain;
    WORD cchIncrement = MAX_PATH;
    BOOL fFoundComSpec = FALSE;
    BOOL fFoundWindir = FALSE;
    BOOL fVarIsWindir = FALSE;

    // if not during the initialization return nothing
    if (!IsFirstCall) {
        setBX(0);
        return;
    }
    if (cchInitEnvironment == 0) {
        //
        // If the PROMPT variable is not set, add it as $P$G. This is to
        // keep the command.com shell consistent with SCS cmd.exe(which
        // always does this) when we don't have a top level cmd shell.
        //
        {
           CHAR *pPromptStr = "PROMPT";
           char ach[2];

           if (!GetEnvironmentVariable(pPromptStr,ach,1)) {
                SetEnvironmentVariable(pPromptStr, "$P$G");
           }
        }

        cchRemain = 0;
        fFoundComSpec = FALSE;
        lpszEnv =
        lpszzEnvStrings = GetEnvironmentStrings();
   if (!lpszzEnvStrings)
   {
       // not enough memory
       RcMessageBox(EG_MALLOC_FAILURE, NULL, NULL,
          RMB_ICON_BANG | RMB_ABORT);
       TerminateVDM();
   }
        while (*lpszEnv) {
            cchString = strlen(lpszEnv) + 1;
            cchVDMEnv32 += cchString;
            lpszEnv += cchString;
        }
        lpszz = lpszzEnvStrings;

        if (lpszzVDMEnv32 != NULL)
            free(lpszzVDMEnv32);

        ++cchVDMEnv32;
        lpszzVDMEnv32 = cmdFilterTempEnvironmentVariables(lpszzEnvStrings, cchVDMEnv32);
        if (lpszzVDMEnv32 == NULL) {
            RcMessageBox(EG_MALLOC_FAILURE, NULL, NULL,
                         RMB_ICON_BANG | RMB_ABORT);
            TerminateVDM();
        }

        lpszz = lpszzVDMEnv32; // we iterate through our copy


        // we have to form a presentable 32-bit environment
        // since we make our own copy -- deal with temp issues now


        // RtlMoveMemory(lpszzVDMEnv32, lpszzEnvStrings, cchVDMEnv32);

        while (*lpszz != '\0') {
            cchString = strlen(lpszz) + 1;
            if (*lpszz != '=') {

                if (!fFoundComSpec && !_strnicmp(lpszz, comspec, 8)){
                    fFoundComSpec = TRUE;
                    lpszz += cchString;
                    continue;
                }

                if (!fFoundWindir && !_strnicmp(lpszz, windir, 6)) {
                    fFoundWindir = TRUE;
                    if (fSeparateWow) {
                        // starting a separate WOW box - flag this one so its
                        // name won't be converted to uppercase later.
                        fVarIsWindir = TRUE;
                    } else {
                        // starting a DOS app, so remove "windir" to make sure
                        // they don't think they are running under Windows.
                        lpszz += cchString;
                        continue;
                    }
                }

                ///////////////////////// TEMP Var filtering ///////////////

                if (cchRemain < cchString) {
                    if (cchIncrement < cchString)
                        cchIncrement = cchString;
                    lpszzEnvBuffer =
                    (CHAR *)realloc(lpszzInitEnvironment,
                                    cchInitEnvironment + cchRemain + cchIncrement
                                    );
                    if (lpszzEnvBuffer == NULL) {
                        if (lpszzInitEnvironment != NULL) {
                            free(lpszzInitEnvironment);
                            lpszzInitEnvironment = NULL;
                        }
                        cchInitEnvironment = 0;
                        break;
                    }
                    lpszzInitEnvironment = lpszzEnvBuffer;
                    lpszzEnvBuffer += cchInitEnvironment;
                    cchRemain += cchIncrement;
                }
                // the environment strings from base is in ANSI and dos needs OEM
                AnsiToOemBuff(lpszz, lpszzEnvBuffer, cchString);
                // convert the name to upper case -- ONLY THE NAME, NOT VALUE.
                if (!fVarIsWindir && (lpszEnv = strchr(lpszzEnvBuffer, '=')) != NULL){
                    *lpszEnv = '\0';
                    _strupr(lpszzEnvBuffer);
                    *lpszEnv = '=';
                } else {
                    fVarIsWindir = FALSE;
                }
                cchRemain -= cchString;
                cchInitEnvironment += cchString ;
                lpszzEnvBuffer += cchString;
            }
            lpszz += cchString;
        }
        FreeEnvironmentStrings(lpszzEnvStrings);

        lpszzEnvBuffer = (CHAR *) realloc(lpszzInitEnvironment,
                                          cchInitEnvironment + 1
                                          );
        if (lpszzEnvBuffer != NULL ) {
            lpszzInitEnvironment = lpszzEnvBuffer;
            lpszzInitEnvironment[cchInitEnvironment++] = '\0';
        }
        else {
            if (lpszzInitEnvironment != NULL) {
                free(lpszzInitEnvironment);
                lpszzInitEnvironment = NULL;
            }
            cchInitEnvironment = 0;
        }
    }
    lpszzEnvBuffer = (CHAR *) GetVDMAddr(getES(), 0);
    cchEnvBuffer =  (WORD)getBX() << 4;
    if (cchEnvBuffer < cchInitEnvironment + cbComSpec) {
        setBX((USHORT)((cchInitEnvironment + cbComSpec + 15) >> 4));
        return;
    }
    else {
        strncpy(lpszzEnvBuffer, lpszComSpec, cbComSpec);
        lpszzEnvBuffer += cbComSpec;
    }
    if (lpszzInitEnvironment != NULL) {
        setBX((USHORT)((cchInitEnvironment + cbComSpec + 15) >> 4));
        memcpy(lpszzEnvBuffer, lpszzInitEnvironment, cchInitEnvironment);
        free(lpszzInitEnvironment);
        lpszzInitEnvironment = NULL;
        cchInitEnvironment = 0;

    }
    else
        setBX(0);

    return;
}

CHAR szHKTSTemp[] = "Software\\Microsoft\\Windows NT\\CurrentVersion\\Terminal Server";
CHAR szTSTempVal[] = "RootDrive";


#define MAX_DOS_TEMPVAR_LENGTH 11


//
// this function is located in dem/demlfn.c
//
extern BOOL demIsShortPathName(LPSTR pszPath, BOOL fAllowWildCardName);


typedef enum tageSysRootType {
   _SYSTEMROOT,        // from systemroot env var
   _SYSTEMDRIVE,       // from systemdrive env var
   _ROOTDRIVE          // as specified in the buffer

}  SYSROOTTYPE;


BOOL cmdGetSystemrootTemp(LPSTR lpszBuffer, DWORD Length, SYSROOTTYPE SysRoot)
{
   CHAR *szTemp = "\\temp";
   CHAR *szSystemRoot  = "SystemRoot";
   CHAR *szSystemDrive = "SystemDrive";
   CHAR *szSystemVar;
   DWORD len = 0;
   DWORD dwAttributes = 0xffffffff;
   DWORD dwError = ERROR_SUCCESS;
   BOOL fRet = FALSE;

   if (_SYSTEMROOT == SysRoot || _SYSTEMDRIVE == SysRoot) {
      szSystemVar = _SYSTEMROOT == SysRoot ? szSystemRoot : szSystemDrive;

      len = GetEnvironmentVariable(szSystemVar, lpszBuffer, Length);
  }
   else if (_ROOTDRIVE == SysRoot) {
      // so we have to look up the registry and see
      HKEY hkey;
      LONG lError;
      DWORD dwType;

      lError = RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                            szHKTSTemp,
                            0,
                            KEY_QUERY_VALUE,
                            &hkey);
      if (ERROR_SUCCESS == lError) {
         len = Length;
         lError = RegQueryValueEx(hkey,
                                  szTSTempVal,
                                  NULL,
                                  &dwType,
                                  lpszBuffer,
                                  &len);
         RegCloseKey(hkey);
         if (ERROR_SUCCESS != lError || REG_SZ != dwType) {
            return(FALSE);
         }
         --len; // length not to include terminating 0
      }

   }

   if (!len || len >= Length || (len + strlen(szTemp)) >= Length) {
      return(FALSE);
   }

   if (*(lpszBuffer + len - 1) == '\\') {
       ++szTemp;
   }


   strcat(lpszBuffer, szTemp);

   len = GetShortPathName(lpszBuffer, lpszBuffer, Length);
   if (len > 0 && len < Length) {
      dwAttributes = GetFileAttributes(lpszBuffer);
   }

   if (0xffffffff == dwAttributes) {
      dwError = GetLastError();
      if (ERROR_PATH_NOT_FOUND == dwError || ERROR_FILE_NOT_FOUND == dwError) {
         // we create this temp
         fRet = CreateDirectory(lpszBuffer, NULL);
         if (fRet) {
            dwAttributes = GetFileAttributes(lpszBuffer);
         }
      }
   }

   if (0xffffffff != dwAttributes) {
      fRet = !!(dwAttributes & FILE_ATTRIBUTE_DIRECTORY);
   }

   return(fRet);
}

#define SYS_ENVVARS "System\\CurrentControlSet\\Control\\Session Manager\\Environment"

//*************************************************************
//
//  GetSystemTempDir()
//
//  Purpose:    Gets the system temp directory in short form
//
//  Parameters: lpDir     - Receives the directory
//              lpcchSize - Size of the lpDir buffer
//
//
//  Return:     TRUE if successful
//              FALSE if an error occurs
//
//*************************************************************

BOOL GetSystemTempDir(LPSTR lpDir, LPDWORD lpcchSize)
{
    CHAR   szTemp[MAX_PATH];    
    CHAR   szDirectory[MAX_PATH];
    DWORD  dwLength;
    HKEY   hKey;
    LONG   lResult;
    DWORD  dwSize, dwType;    
    WIN32_FILE_ATTRIBUTE_DATA fad;
    BOOL   bRetVal = FALSE;    

    szTemp[0] = '\0';
    szDirectory[0] = '\0';

    //
    // Look in the system environment variables
    //

    if (RegOpenKeyEx (HKEY_LOCAL_MACHINE, SYS_ENVVARS, 0,
                      KEY_READ, &hKey) == ERROR_SUCCESS) {

        //
        // Check for TEMP
        //

        dwSize = sizeof(szTemp);

        if (RegQueryValueEx (hKey, "TEMP", NULL, &dwType,
                             (LPBYTE) szTemp, &dwSize) == ERROR_SUCCESS) {
            RegCloseKey (hKey);
            goto FoundTemp;
        }


        //
        // Check for TMP
        //

        dwSize = sizeof(szTemp);

        if (RegQueryValueEx (hKey, "TMP", NULL, &dwType,
                             (LPBYTE) szTemp, &dwSize) == ERROR_SUCCESS) {
            RegCloseKey (hKey);
            goto FoundTemp;
        }


        RegCloseKey (hKey);
    }


    //
    // Check if %SystemRoot%\Temp exists
    //

    lstrcpy (szDirectory, "%SystemRoot%\\Temp");
    ExpandEnvironmentStrings (szDirectory, szTemp, sizeof(szTemp));

    if (GetFileAttributesEx (szTemp, GetFileExInfoStandard, &fad) &&
        fad.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) {

        goto FoundTemp;
    }


    //
    // Check if %SystemDrive%\Temp exists
    //

    lstrcpy (szDirectory, "%SystemDrive%\\Temp");
    ExpandEnvironmentStrings (szDirectory, szTemp, sizeof(szTemp));

    if (GetFileAttributesEx (szTemp, GetFileExInfoStandard, &fad) &&
        fad.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) {

        goto FoundTemp;
    }


    //
    // Last resort is %SystemRoot%
    //

    lstrcpy (szTemp, "%SystemRoot%");



FoundTemp:

    ExpandEnvironmentStrings (szTemp, szDirectory, sizeof (szDirectory));
    GetShortPathName (szDirectory, szTemp, sizeof(szTemp));

    dwLength = lstrlen(szTemp) + 1;

    if (lpDir) {

        if (*lpcchSize >= dwLength) {
            lstrcpy (lpDir, szTemp);
            bRetVal = TRUE;

        } else {
            SetLastError(ERROR_INSUFFICIENT_BUFFER);
        }
    } else {
        SetLastError(ERROR_INSUFFICIENT_BUFFER);
    }


    *lpcchSize = dwLength;

    return bRetVal;
}


#define FOUND_TMP  0x01
#define FOUND_TEMP 0x02

#define GETSYSTEMTEMPDIRECTORYAORD 125
#define GETSYSTEMTEMPDIRECTORYWORD 126

DWORD gfFoundTmp = 0;
CHAR  gszTempDir[MAX_PATH]; 

BOOL cmdCreateTempEnvironmentVar(
LPSTR lpszTmpVar,  // temp variable (or just it's name)
DWORD Length,      // the length of TmpVar or 0
LPSTR lpszBuffer,  // buffer containing
DWORD LengthBuffer
)
{
   PCHAR pch;      
   BOOL fSysTemp = FALSE;
   DWORD LengthTemp;

   if (NULL != (pch = strchr(lpszTmpVar, '='))) {
      // we have a var to check

      LengthTemp = (DWORD)(pch - lpszTmpVar);

      ++pch;
      if (!Length) { // no length supplied
         Length = strlen(pch);
      }
      else {
         Length -= (DWORD)(pch - lpszTmpVar);
      }


      // pch points to a variable that is to be checked for being dos-compliant
      if (strlen(pch) <= MAX_DOS_TEMPVAR_LENGTH && demIsShortPathName(pch, FALSE)) {
         return(FALSE); // no need to create anything
      }
   }
   else {
      LengthTemp = strlen(lpszTmpVar);
   }

   LengthTemp = LengthTemp < LengthBuffer-1 ? LengthTemp : LengthBuffer-2;

   strncpy(lpszBuffer, lpszTmpVar, LengthTemp);
   *(lpszBuffer + LengthTemp) =  '=';
   lpszBuffer += LengthTemp+1; // past =
   LengthBuffer -= LengthTemp+1;


   if (gszTempDir[0]) {
      fSysTemp = TRUE;
      strncpy(lpszBuffer,gszTempDir,LengthBuffer);
      lpszBuffer[LengthBuffer-1] = '\0';
   }
   else {
       pch = lpszBuffer;
       // see if there is a registry override, used for Terminal Server           
       fSysTemp = cmdGetSystemrootTemp(lpszBuffer, LengthBuffer, _ROOTDRIVE);     
       if (fSysTemp && strlen(lpszBuffer) <= MAX_DOS_TEMPVAR_LENGTH) {            
          return(fSysTemp);                                                       
       }                                                                          
                                                                                  
       fSysTemp = GetSystemTempDir(lpszBuffer, &LengthBuffer);                      
       if (fSysTemp) {                                                            
           fSysTemp = demIsShortPathName(lpszBuffer, FALSE);                      
       }                                                                          
                                                                                  
                                                                                  
       if (!fSysTemp) {                                                           
           fSysTemp = cmdGetSystemrootTemp(lpszBuffer, LengthBuffer, _SYSTEMROOT);
       }                                                                          
       if (fSysTemp) {
           strncpy(gszTempDir,pch,sizeof(gszTempDir));
           gszTempDir[sizeof(gszTempDir)-1] = '\0';
       }
   }

   return(fSysTemp);

}

VOID cmdCheckTempInit(VOID)
{
   gfFoundTmp = 0;
}

CHAR*rgpszLongPathNames[] = {
   "ALLUSERSPROFILE",
   "APPDATA",
   "COMMONPROGRAMFILES",
   "COMMONPROGRAMFILES(x86)",
   "PROGRAMFILES",
   "PROGRAMFILES(X86)",
   "SYSTEMROOT",
   "USERPROFILE",
   //build environment vars   
   "_NTTREE",
   "_NTX86TREE",
   "_NTPOSTBLD",
   "BINPLACE_EXCLUDE_FILE",
   "BINPLACE_LOG",
   "CLUSTERLOG",
   "INIT",
   "NTMAKEENV",
   "MSWNET",
   "PREFAST_ROOT",
   "RAZZLETOOLPATH",
   "SDXROOT"   
   };


BOOL cmdMakeShortEnvVar(LPSTR lpvarName, LPSTR lpvarValue, LPSTR lpszBuffer, DWORD Length)
{
   DWORD lName, lValue;

   lName = strlen(lpvarName);
   if (lName + 2 > Length ) {
      return(FALSE);
   }

   strcpy(lpszBuffer, lpvarName);
   *(lpszBuffer + lName) = '=';
   lpszBuffer += lName + 1;
   Length -= lName + 1;

   lValue = GetShortPathNameOem(lpvarValue, lpszBuffer, Length);
   return (0 != lValue && lValue <= Length);
}



LPSTR cmdCheckTemp(LPSTR lpszzEnv)
{
   CHAR *szTemp = "Temp";
   CHAR *szTmp  = "Tmp";
   static CHAR szTmpVarBuffer[MAX_PATH+1];
   LPSTR pszTmpVar = NULL;
   BOOL fSubst = FALSE;
   CHAR *peq;
   DWORD i;


   peq = strchr(lpszzEnv, '=');
   if (NULL == peq) {
      return(NULL);
   }

   for (i = 0; i < sizeof(rgpszLongPathNames)/sizeof(rgpszLongPathNames[0]);++i) {
      INT llpn = strlen(rgpszLongPathNames[i]);
      if (!_strnicmp(lpszzEnv, rgpszLongPathNames[i], llpn) &&
          (llpn == (INT)(peq - lpszzEnv))) {
             // found a candidate to subst
          if (cmdMakeShortEnvVar(rgpszLongPathNames[i],
                                 peq+1,
                                 szTmpVarBuffer,
                                 sizeof(szTmpVarBuffer)/sizeof(szTmpVarBuffer[0]))) {
              pszTmpVar = szTmpVarBuffer;
          }
          return(pszTmpVar);
      }
   }

   if (!(gfFoundTmp & FOUND_TMP) || !(gfFoundTmp & FOUND_TEMP)) {

      if (!(gfFoundTmp & FOUND_TEMP) &&
          !_strnicmp(lpszzEnv, szTemp, 4) &&
          (4 == (int)(peq - lpszzEnv))) {
          // this is Temp env variable -- make a new one
         fSubst = TRUE;
         gfFoundTmp |= FOUND_TEMP;
      }
      else {
         if (!(gfFoundTmp & FOUND_TMP) &&
             !_strnicmp(lpszzEnv, szTmp, 3) &&
             (3 ==  (int)(peq - lpszzEnv))) {
             // this is tmp variable

            fSubst = TRUE;
            gfFoundTmp |= FOUND_TMP;
         }
      }

      if (fSubst) {
         // we have a candidate for substitution
         if (cmdCreateTempEnvironmentVar(lpszzEnv,
                                         0,
                                         szTmpVarBuffer,
                                         sizeof(szTmpVarBuffer)/sizeof(szTmpVarBuffer[0]))) {
            pszTmpVar = szTmpVarBuffer;
         }
      }

   }

   return(pszTmpVar);
}




/** create a DOS environment for DOS.
    This is to get 32bits environment(comes with the dos executanle)
    and merge it with the environment settings in autoexec.nt so that
    COMMAND.COM gets the expected environment. We already created a
    double-null terminated string during autoexec.nt parsing. The string
    has mutltiple substring:
    "EnvName_1 NULL EnvValue_1 NULL[EnvName_n NULL EnvValue_n NULL] NULL"
    When name conflicts happened(a environment name was found in both
    16 bits and 32 bits), we do the merging based on the rules:
    get 16bits value, expands any environment variables in the string
    by using the current environment.

WARINING !!! The changes made by applications through directly manipulation
             in command.com environment segment will be lost.

**/
BOOL cmdCreateVDMEnvironment(
PVDMENVBLK  pVDMEnvBlk
)
{
PCHAR   p1, p2;
BOOL    fFoundComSpec;
BOOL    fFoundWindir;
BOOL    fVarIsWindir;
DWORD   Length, EnvStrLength;
PCHAR   lpszzVDMEnv, lpszzEnv, lpStrEnv;
CHAR    achBuffer[MAX_PATH + 1];

    pVDMEnvBlk->lpszzEnv = malloc(cchVDMEnv32 + cbComSpec + 1);
    if ((lpszzVDMEnv = pVDMEnvBlk->lpszzEnv) == NULL)
        return FALSE;

    pVDMEnvBlk->cchRemain = cchVDMEnv32 + cbComSpec + 1;
    pVDMEnvBlk->cchEnv = 0;

    // grab the 16bits comspec first
    if (cbComSpec && lpszComSpec && *lpszComSpec) {
        RtlCopyMemory(lpszzVDMEnv, lpszComSpec, cbComSpec);
        pVDMEnvBlk->cchEnv += cbComSpec;
        pVDMEnvBlk->cchRemain -= cbComSpec;
        lpszzVDMEnv += cbComSpec;
    }
    if (lpszzVDMEnv32) {

        // go through the given 32bits environmnet and take what we want:
        // everything except:
        // (1). variable name begin with '='
        // (2). compsec
        // (3). string without a '=' -- malformatted environment variable
        // (4). windir, so DOS apps don't think they're running under Windows
        // Note that strings pointed by lpszzVDMEnv32 are in ANSI character set


        fFoundComSpec = FALSE;
        fFoundWindir = FALSE;
        fVarIsWindir = FALSE;
        lpszzEnv = lpszzVDMEnv32;

        cmdCheckTempInit();

        while (*lpszzEnv) {
            Length = strlen(lpszzEnv) + 1;
            if (*lpszzEnv != '=' &&
                (p1 = strchr(lpszzEnv, '=')) != NULL &&
                (fFoundComSpec || !(fFoundComSpec = _strnicmp(lpszzEnv,
                                                             comspec,
                                                             8
                                                            ) == 0)) ){
                if (!fFoundWindir) {
                    fFoundWindir = (_strnicmp(lpszzEnv,
                                                            windir,
                                                            6) == 0);
                    fVarIsWindir = fFoundWindir;
                }

                // subst temp variables

                lpStrEnv = cmdCheckTemp(lpszzEnv);
                if (NULL == lpStrEnv) {
                   lpStrEnv = lpszzEnv;
                   EnvStrLength = Length;
                }
                else {
                   EnvStrLength = strlen(lpStrEnv) + 1;
                }

                if (!fVarIsWindir || fSeparateWow) {
                    if (EnvStrLength >= pVDMEnvBlk->cchRemain) {
                        lpszzVDMEnv = realloc(pVDMEnvBlk->lpszzEnv,
                                              pVDMEnvBlk->cchEnv +
                                              pVDMEnvBlk->cchRemain +
                                              VDM_ENV_INC_SIZE
                                             );
                        if (lpszzVDMEnv == NULL){
                            free(pVDMEnvBlk->lpszzEnv);
                            return FALSE;
                        }
                        pVDMEnvBlk->cchRemain += VDM_ENV_INC_SIZE;
                        pVDMEnvBlk->lpszzEnv = lpszzVDMEnv;
                        lpszzVDMEnv += pVDMEnvBlk->cchEnv;
                    }
                    AnsiToOemBuff(lpStrEnv, lpszzVDMEnv, EnvStrLength);
                    if (!fVarIsWindir) {
                        *(lpszzVDMEnv + (DWORD)(p1 - lpszzEnv)) = '\0';
                        _strupr(lpszzVDMEnv);
                        *(lpszzVDMEnv + (DWORD)(p1 - lpszzEnv)) = '=';
                    } else {
                        fVarIsWindir = FALSE;
                    }
                    pVDMEnvBlk->cchEnv += EnvStrLength;
                    pVDMEnvBlk->cchRemain -= EnvStrLength;
                    lpszzVDMEnv += EnvStrLength;
                }
                else
                    fVarIsWindir = FALSE;
            }
            lpszzEnv += Length;
        }
    }
    *lpszzVDMEnv = '\0';
    pVDMEnvBlk->cchEnv++;
    pVDMEnvBlk->cchRemain--;

    if (lpszzcmdEnv16 != NULL) {
        lpszzEnv = lpszzcmdEnv16;

        while (*lpszzEnv) {
            p1 = lpszzEnv + strlen(lpszzEnv) + 1;
            p2 = NULL;
            if (*p1) {
                p2 = achBuffer;
                // expand the strings pointed by p1
                Length = cmdExpandEnvironmentStrings(pVDMEnvBlk,
                                                     p1,
                                                     p2,
                                                     MAX_PATH + 1
                                                     );
                if (Length && Length > MAX_PATH) {
                    p2 =  (PCHAR) malloc(Length);
                    if (p2 == NULL) {
                        free(pVDMEnvBlk->lpszzEnv);
                        return FALSE;
                    }
                    cmdExpandEnvironmentStrings(pVDMEnvBlk,
                                                p1,
                                                p2,
                                                Length
                                               );
                }
            }
            if (!cmdSetEnvironmentVariable(pVDMEnvBlk,
                                           lpszzEnv,
                                           p2
                                           )){
                if (p2 && p2 != achBuffer)
                    free(p2);
                free(pVDMEnvBlk->lpszzEnv);
                return FALSE;
            }
            lpszzEnv = p1 + strlen(p1) + 1;
        }
    }
    lpszzVDMEnv = realloc(pVDMEnvBlk->lpszzEnv, pVDMEnvBlk->cchEnv);
    if (lpszzVDMEnv != NULL) {
        pVDMEnvBlk->lpszzEnv = lpszzVDMEnv;
        pVDMEnvBlk->cchRemain = 0;
    }
    return TRUE;
}


BOOL  cmdSetEnvironmentVariable(
PVDMENVBLK  pVDMEnvBlk,
PCHAR   lpszName,
PCHAR   lpszValue
)
{
    PCHAR   p, p1, pEnd;
    DWORD   ExtraLength, Length, cchValue, cchOldValue;

    pVDMEnvBlk = (pVDMEnvBlk) ? pVDMEnvBlk : &cmdVDMEnvBlk;

    if (pVDMEnvBlk == NULL || lpszName == NULL)
        return FALSE;
    if (!(p = pVDMEnvBlk->lpszzEnv))
        return FALSE;
    pEnd = p + pVDMEnvBlk->cchEnv - 1;

    cchValue = (lpszValue) ? strlen(lpszValue) : 0;

    Length = strlen(lpszName);
    while (*p && ((p1 = strchr(p, '=')) == NULL ||
                  (DWORD)(p1 - p) != Length ||
                  _strnicmp(p, lpszName, Length)))
        p += strlen(p) + 1;

    if (*p) {
        // name was found in the base environment, replace it
        p1++;
        cchOldValue = strlen(p1);
        if (cchValue <= cchOldValue) {
            if (!cchValue) {
                RtlMoveMemory(p,
                              p1 + cchOldValue + 1,
                              (DWORD)(pEnd - p) - cchOldValue
                             );
                pVDMEnvBlk->cchRemain += Length + cchOldValue + 2;
                pVDMEnvBlk->cchEnv -=  Length + cchOldValue + 2;
            }
            else {
                RtlCopyMemory(p1,
                              lpszValue,
                              cchValue
                             );
                if (cchValue != cchOldValue) {
                    RtlMoveMemory(p1 + cchValue,
                                  p1 + cchOldValue,
                                  (DWORD)(pEnd - p1) - cchOldValue + 1
                                  );
                    pVDMEnvBlk->cchEnv -= cchOldValue - cchValue;
                    pVDMEnvBlk->cchRemain += cchOldValue - cchValue;
                }
            }
            return TRUE;
        }
        else {
            // need more space for the new value
            // we delete it from here and fall through
            RtlMoveMemory(p,
                          p1 + cchOldValue + 1,
                          (DWORD)(pEnd - p1) - cchOldValue
                         );
            pVDMEnvBlk->cchRemain += Length + 1 + cchOldValue + 1;
            pVDMEnvBlk->cchEnv -= Length + 1 + cchOldValue + 1;
        }
    }
    if (cchValue) {
        ExtraLength = Length + 1 + cchValue + 1;
        if (pVDMEnvBlk->cchRemain  < ExtraLength) {
            p = realloc(pVDMEnvBlk->lpszzEnv,
                        pVDMEnvBlk->cchEnv + pVDMEnvBlk->cchRemain + ExtraLength
                       );
            if (p == NULL)
                return FALSE;
            pVDMEnvBlk->lpszzEnv = p;
            pVDMEnvBlk->cchRemain += ExtraLength;
        }
        p = pVDMEnvBlk->lpszzEnv + pVDMEnvBlk->cchEnv - 1;
        RtlCopyMemory(p, lpszName, Length + 1);
        _strupr(p);
        p += Length;
        *p++ = '=';
        RtlCopyMemory(p, lpszValue, cchValue + 1);
        *(p + cchValue + 1) = '\0';
        pVDMEnvBlk->cchEnv += ExtraLength;
        pVDMEnvBlk->cchRemain -= ExtraLength;
        return TRUE;
    }
    return FALSE;

}


DWORD cmdExpandEnvironmentStrings(
PVDMENVBLK  pVDMEnvBlk,
PCHAR   lpszSrc,
PCHAR   lpszDst,
DWORD   cchDst
)
{


    DWORD   RequiredLength, RemainLength, Length;
    PCHAR   p1;

    RequiredLength = 0;
    RemainLength = (lpszDst) ? cchDst : 0;
    pVDMEnvBlk = (pVDMEnvBlk) ? pVDMEnvBlk : &cmdVDMEnvBlk;
    if (pVDMEnvBlk == NULL || lpszSrc == NULL)
        return 0;

    while(*lpszSrc) {
        if (*lpszSrc == '%') {
            p1 = strchr(lpszSrc + 1, '%');
            if (p1 != NULL) {
                if (p1 == lpszSrc + 1) {        // a "%%"
                    lpszSrc += 2;
                    continue;
                }
                *p1 = '\0';
                Length = cmdGetEnvironmentVariable(pVDMEnvBlk,
                                                   lpszSrc + 1,
                                                   lpszDst,
                                                   RemainLength
                                                  );
                *p1 = '%';
                lpszSrc = p1 + 1;
                if (Length) {
                    if (Length < RemainLength) {
                        RemainLength -= Length;
                        lpszDst += Length;
                    }
                    else {
                        RemainLength = 0;
                        Length --;
                    }
                    RequiredLength += Length;
                }
                continue;
            }
            else {
                 RequiredLength++;
                 if (RemainLength) {
                    *lpszDst++ = *lpszSrc;
                    RemainLength--;
                 }
                 lpszSrc++;
                 continue;
            }
        }
        else {
            RequiredLength++;
            if (RemainLength) {
                *lpszDst++ = *lpszSrc;
                RemainLength--;
            }
            lpszSrc++;
        }
    }   // while(*lpszSrc)
    RequiredLength++;
    if (RemainLength)
        *lpszDst = '\0';
    return RequiredLength;
}


DWORD cmdGetEnvironmentVariable(
PVDMENVBLK pVDMEnvBlk,
PCHAR   lpszName,
PCHAR   lpszValue,
DWORD   cchValue
)
{

    DWORD   RequiredLength, Length;
    PCHAR   p, p1;

    pVDMEnvBlk = (pVDMEnvBlk) ? pVDMEnvBlk : &cmdVDMEnvBlk;
    if (pVDMEnvBlk == NULL || lpszName == NULL)
        return 0;

    RequiredLength = 0;
    Length = strlen(lpszName);

    // if the name is "windir", get its value from ntvdm process's environment
    // for DOS because we took it out of the environment block the application
    // will see.
    if (Length == 6 && !fSeparateWow && !_strnicmp(lpszName, windir, 6)) {
        return(GetEnvironmentVariableOem(lpszName, lpszValue, cchValue));
    }

    if (p = pVDMEnvBlk->lpszzEnv) {
       while (*p && ((p1 = strchr(p, '=')) == NULL ||
                     (DWORD)(p1 - p) != Length ||
                     _strnicmp(lpszName, p, Length)))
            p += strlen(p) + 1;
       if (*p) {
            RequiredLength = strlen(p1 + 1);
            if (cchValue > RequiredLength && lpszValue)
                RtlCopyMemory(lpszValue, p1 + 1, RequiredLength + 1);
            else
                RequiredLength++;
       }
    }
    return RequiredLength;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dos\command\cmdexec.c ===
/*  cmdexec.c - Misc SCS routines for non-dos exec and re-entering
 *              the DOS.
 *
 *
 *  Modification History:
 *
 *  Sudeepb 22-Apr-1992 Created
 */

#include "cmd.h"

#include <cmdsvc.h>
#include <softpc.h>
#include <mvdm.h>
#include <ctype.h>
#include <oemuni.h>
#include <wowcmpat.h>

//*****************************************************************************
// IsWowAppRunnable
//
//    Returns FALSE if the WOW-specific compatibility flags for the specified
//    task include the bit WOWCF_NOTDOSSPAWNABLE. This is done mostly for
//    "dual mode" executables, e.g., Windows apps that have a real program
//    as a DOS stub. Certain apps that are started via a DOS command shell,
//    for example PWB, really do expect to be started as a DOS app, not a WOW
//    app. For these apps, the compatibility bit should be set in the
//    registry.
//
//*****************************************************************************

BOOL IsWowAppRunnable(LPSTR lpAppName)
{
    BOOL Result = TRUE;
    LONG lError;
    HKEY hKey = 0;
    char szModName[9];
    char szHexAsciiFlags[12];
    DWORD dwType = REG_SZ;
    DWORD cbData = sizeof(szHexAsciiFlags);
    ULONG ul = 0;
    LPSTR pStrt, pEnd;
    SHORT len;

    lError = RegOpenKeyEx(  HKEY_LOCAL_MACHINE,
                            "Software\\Microsoft\\Windows NT\\CurrentVersion\\WOW\\Compatibility",
                            0,
                            KEY_QUERY_VALUE,
                            &hKey
                            );

    if (ERROR_SUCCESS != lError) {
        goto Cleanup;
    }

    //
    // The following code strips the file name (<9 chars) out of a dos
    // path name.
    //

    pStrt = strrchr (lpAppName, '\\');

    if (pStrt==NULL)
        pStrt = lpAppName;
    else
        pStrt++;

    if ( (pEnd = strchr (pStrt, '.')) == NULL) {
        strncpy (szModName, pStrt, 9);
        szModName[8] = '\0';
    }
    else {
        len = (SHORT) (pEnd - pStrt);
        if (len>8) goto Cleanup;
        strncpy (szModName, pStrt, len);
        szModName[len] = '\0';
    }


    //
    // Look for the file name in the registry
    //

    lError = RegQueryValueEx( hKey,
                              szModName,
                              0,
                              &dwType,
                              szHexAsciiFlags,
                              &cbData
                              );

    if (ERROR_SUCCESS != lError) {
        goto Cleanup;
    }

    if (REG_SZ != dwType) {
        goto Cleanup;
    }

    //
    // Force the string to lowercase for the convenience of sscanf.
    //

    _strlwr(szHexAsciiFlags);

    //
    // sscanf() returns the number of fields converted.
    //

    if (1 != sscanf(szHexAsciiFlags, "0x%lx", &ul)) {
        goto Cleanup;
    }

    if ((ul & WOWCF_NOTDOSSPAWNABLE) != 0)
        Result = FALSE;

Cleanup:
    if (hKey) {
        RegCloseKey(hKey);
    }

    return Result;
}

/* cmdCheckBinary - check that the supplied binary name is a 32bit binary
 *
 *
 *  Entry - Client (DS:DX) - pointer to pathname for the executable to be tested
 *          Client (ES:BX) - pointer to parameter block
 *
 *  EXIT  - SUCCESS Client (CY) clear
 *          FAILURE Client (CY) set
 *                  Client (AX) - error_not_enough_memory if command tail
 *                                cannot accomodate /z
 *                              - error_file_not_found if patname not found
 */

VOID cmdCheckBinary (VOID)
{

    LPSTR  lpAppName;
    ULONG  BinaryType = SCS_DOS_BINARY;
    PPARAMBLOCK lpParamBlock;
    PCHAR  lpCommandTail,lpTemp;
    ULONG  AppNameLen,CommandTailLen = 0;
    USHORT CommandTailOff,CommandTailSeg,usTemp;
    NTSTATUS       Status;
    UNICODE_STRING Unicode;
    OEM_STRING     OemString;
    ANSI_STRING    AnsiString;


    if(DontCheckDosBinaryType){
        setCF(0);
        return;         // DOS Exe
    }

    lpAppName = (LPSTR) GetVDMAddr (getDS(),getDX());

    Unicode.Buffer = NULL;
    AnsiString.Buffer = NULL;
    RtlInitString((PSTRING)&OemString, lpAppName);
    Status = RtlOemStringToUnicodeString(&Unicode,&OemString,TRUE);
    if ( NT_SUCCESS(Status) ) {
        Status = RtlUnicodeStringToAnsiString(&AnsiString, &Unicode, TRUE);
        }
    if ( !NT_SUCCESS(Status) ) {
        Status = RtlNtStatusToDosError(Status);
        }
    else if (GetBinaryType (AnsiString.Buffer,(LPLONG)&BinaryType) == FALSE)
       {
        Status =  GetLastError();
        }

    if (Unicode.Buffer != NULL) {
        RtlFreeUnicodeString( &Unicode );
        }
    if (AnsiString.Buffer != NULL) {
        RtlFreeAnsiString( &AnsiString);
        }

    if (Status){
        setCF(1);
        setAX((USHORT)Status);
        return;         // Invalid path
    }


    if (BinaryType == SCS_DOS_BINARY) {
        setCF(0);
        return;         // DOS Exe
    }
                        // Prevent certain WOW apps from being spawned by DOS exe's
                        // This is for win31 compatibility
    else if (BinaryType == SCS_WOW_BINARY) {
        if (!IsWowAppRunnable(lpAppName)) {
            setCF(0);
            return;     // Run as DOS Exe
        }
    }


    if (VDMForWOW && BinaryType == SCS_WOW_BINARY && IsFirstWOWCheckBinary) {
        IsFirstWOWCheckBinary = FALSE;
        setCF(0);
        return;         // Special Hack for krnl286.exe
    }

    // dont allow running 32bit binaries from autoexec.nt. Reason is that
    // running non-dos binary requires that we should have read the actual
    // command from GetNextVDMCommand. Otherwise the whole design gets into
    // synchronization problems.

    if (IsFirstCall) {
        setCF(1);
        setAX((USHORT)ERROR_FILE_NOT_FOUND);
        return;
    }

    // Its a 32bit exe, replace the command with "command.com /z" and add the
    // original binary name to command tail.

    AppNameLen = strlen (lpAppName);

    lpParamBlock = (PPARAMBLOCK) GetVDMAddr (getES(),getBX());

    if (lpParamBlock) {
        CommandTailOff = FETCHWORD(lpParamBlock->OffCmdTail);
        CommandTailSeg = FETCHWORD(lpParamBlock->SegCmdTail);

        lpCommandTail = (PCHAR) GetVDMAddr (CommandTailSeg,CommandTailOff);

        if (lpCommandTail){
            CommandTailLen = *(PCHAR)lpCommandTail;
            lpCommandTail++;        // point to the actual command tail
            if (CommandTailLen)
                CommandTailLen++;   // For CR
        }

        // We are adding 3 below for "/z<space>" and anothre space between
        // AppName and CommandTail.

        if ((3 + AppNameLen + CommandTailLen ) > 128){
            setCF(1);
            setAX((USHORT)ERROR_NOT_ENOUGH_MEMORY);
            return;
        }
    }

    // copy the stub command.com name
    strcpy ((PCHAR)&pSCSInfo->SCS_ComSpec,lpszComSpec+8);
    lpTemp = (PCHAR) &pSCSInfo->SCS_ComSpec;
    lpTemp = (PCHAR)((ULONG)lpTemp - (ULONG)GetVDMAddr(0,0));
    usTemp = (USHORT)((ULONG)lpTemp >> 4);
    setDS(usTemp);
    usTemp = (USHORT)((ULONG)lpTemp & 0x0f);
    setDX((usTemp));

    // Form the command tail, first "3" is for "/z "
    pSCSInfo->SCS_CmdTail [0] = (UCHAR)(3 +
                                        AppNameLen +
                                        CommandTailLen);
    RtlCopyMemory ((PCHAR)&pSCSInfo->SCS_CmdTail[1],"/z ",3);
    strncpy ((PCHAR)&pSCSInfo->SCS_CmdTail[4],lpAppName,124);
    pSCSInfo->SCS_CmdTail[127] = '\0';

    if (CommandTailLen) {
        pSCSInfo->SCS_CmdTail[4+AppNameLen] = ' ';
        RtlCopyMemory ((PCHAR)((ULONG)&pSCSInfo->SCS_CmdTail[4]+AppNameLen+1),
                lpCommandTail,
                CommandTailLen);
    }
    else {
        pSCSInfo->SCS_CmdTail[4+AppNameLen] = 0xd;
    }

    // Set the parameter Block
    if (lpParamBlock) {
        STOREWORD(pSCSInfo->SCS_ParamBlock.SegEnv,lpParamBlock->SegEnv);
        STOREDWORD(pSCSInfo->SCS_ParamBlock.pFCB1,lpParamBlock->pFCB1);
        STOREDWORD(pSCSInfo->SCS_ParamBlock.pFCB2,lpParamBlock->pFCB2);
    }
    else {
        STOREWORD(pSCSInfo->SCS_ParamBlock.SegEnv,0);
        STOREDWORD(pSCSInfo->SCS_ParamBlock.pFCB1,0);
        STOREDWORD(pSCSInfo->SCS_ParamBlock.pFCB2,0);
    }

    lpTemp = (PCHAR) &pSCSInfo->SCS_CmdTail;
    lpTemp = (PCHAR)((ULONG)lpTemp - (ULONG)GetVDMAddr(0,0));
    usTemp = (USHORT)((ULONG)lpTemp & 0x0f);
    STOREWORD(pSCSInfo->SCS_ParamBlock.OffCmdTail,usTemp);
    usTemp = (USHORT)((ULONG)lpTemp >> 4);
    STOREWORD(pSCSInfo->SCS_ParamBlock.SegCmdTail,usTemp);

    lpTemp = (PCHAR) &pSCSInfo->SCS_ParamBlock;
    lpTemp = (PCHAR)((ULONG)lpTemp - (ULONG)GetVDMAddr(0,0));
    usTemp = (USHORT)((ULONG)lpTemp >> 4);
    setES (usTemp);
    usTemp = (USHORT)((ULONG)lpTemp & 0x0f);
    setBX (usTemp);

    setCF(0);
    return;
}

#define MAX_DIR 68

VOID cmdCreateProcess ( PSTD_HANDLES pStdHandles )
{

    VDMINFO VDMInfoForCount;
    STARTUPINFO StartupInfo;
    PROCESS_INFORMATION ProcessInformation;
    HANDLE hStd16In,hStd16Out,hStd16Err;
    CHAR CurDirVar [] = "=?:";
    CHAR Buffer [MAX_DIR];
    CHAR *CurDir = Buffer;
    DWORD dwRet;
    BOOL  Status;
    NTSTATUS NtStatus;
    UNICODE_STRING Unicode;
    OEM_STRING     OemString;
    LPVOID lpNewEnv=NULL;
    ANSI_STRING Env_A;

    // we have one more 32 executable active
    Exe32ActiveCount++;

    // Increment the Re-enterancy count for the VDM
    VDMInfoForCount.VDMState = INCREMENT_REENTER_COUNT;
    GetNextVDMCommand (&VDMInfoForCount);

    RtlZeroMemory((PVOID)&StartupInfo,sizeof(STARTUPINFO));
    StartupInfo.cb = sizeof(STARTUPINFO);

    CurDirVar [1] = chDefaultDrive;

    dwRet = GetEnvironmentVariable (CurDirVar,Buffer,MAX_DIR);

    if (dwRet == 0 || dwRet == MAX_DIR)
        CurDir = NULL;

    if ((hStd16In = (HANDLE) FETCHDWORD(pStdHandles->hStdIn)) != (HANDLE)-1)
        SetStdHandle (STD_INPUT_HANDLE, hStd16In);

    if ((hStd16Out = (HANDLE) FETCHDWORD(pStdHandles->hStdOut)) != (HANDLE)-1)
        SetStdHandle (STD_OUTPUT_HANDLE, hStd16Out);

    if ((hStd16Err = (HANDLE) FETCHDWORD(pStdHandles->hStdErr)) != (HANDLE)-1)
        SetStdHandle (STD_ERROR_HANDLE, hStd16Err);

    /*
     *  Warning, pEnv32 currently points to an ansi environment.
     *  The DOS is using an ANSI env which isn't quite correct.
     *  If the DOS is changed to use an OEM env then we will
     *  have to convert the env back to ansi before spawning
     *  non-dos exes ?!?
     *  16-Jan-1993 Jonle
     */

    Env_A.Buffer = NULL;

    RtlInitString((PSTRING)&OemString, pCommand32);
    NtStatus = RtlOemStringToUnicodeString(&Unicode,&OemString,TRUE);
    if (NT_SUCCESS(NtStatus)) {
        NtStatus = RtlUnicodeStringToAnsiString((PANSI_STRING)&OemString, &Unicode, FALSE);
        RtlFreeUnicodeString( &Unicode );
        }
    if (!NT_SUCCESS(NtStatus)) {
        SetLastError(RtlNtStatusToDosError(NtStatus));
        Status = FALSE;
        }
    else {
        if (pEnv32 != NULL && !cmdXformEnvironment (pEnv32, &Env_A)) {
            SetLastError(ERROR_NOT_ENOUGH_MEMORY);
            Status = FALSE;
        }
        else {
            Status = CreateProcess (
                           NULL,
                           (LPTSTR)pCommand32,
                           NULL,
                           NULL,
                           TRUE,
                           CREATE_SUSPENDED | CREATE_DEFAULT_ERROR_MODE,
                           Env_A.Buffer,
                           (LPTSTR)CurDir,
                           &StartupInfo,
                           &ProcessInformation);
        }
    }

    if (Status == FALSE)
        dwExitCode32 = GetLastError ();

    if (hStd16In != (HANDLE)-1)
        SetStdHandle (STD_INPUT_HANDLE, SCS_hStdIn);

    if (hStd16Out != (HANDLE)-1)
        SetStdHandle (STD_OUTPUT_HANDLE, SCS_hStdOut);

    if (hStd16Err != (HANDLE)-1)
        SetStdHandle (STD_ERROR_HANDLE, SCS_hStdErr);

    if (Status) {
        ResumeThread (ProcessInformation.hThread);
        WaitForSingleObject(ProcessInformation.hProcess, (DWORD)-1);
        GetExitCodeProcess (ProcessInformation.hProcess, &dwExitCode32);
        CloseHandle (ProcessInformation.hProcess);
        CloseHandle (ProcessInformation.hThread);
    }

    if (Env_A.Buffer)
        RtlFreeAnsiString(&Env_A);

    // Decrement the Re-enterancy count for the VDM
    VDMInfoForCount.VDMState = DECREMENT_REENTER_COUNT;
    GetNextVDMCommand (&VDMInfoForCount);

    // one less 32 executable active
    Exe32ActiveCount--;

    // Kill this thread
    ExitThread (0);
}


VOID cmdExec32 (PCHAR pCmd32, PCHAR pEnv)
{

    DWORD dwThreadId;
    HANDLE hThread;
    PSTD_HANDLES pStdHandles;

    pCommand32 = pCmd32;
    pEnv32 = pEnv;

    CntrlHandlerState = (CntrlHandlerState & ~CNTRL_SHELLCOUNT) |
                         (((WORD)(CntrlHandlerState & CNTRL_SHELLCOUNT))+1);

    nt_block_event_thread(0);
    fSoftpcRedirectionOnShellOut = fSoftpcRedirection;
    fBlock = TRUE;


    pStdHandles = (PSTD_HANDLES) GetVDMAddr (getSS(), getBP());
    if((hThread = CreateThread (NULL,
                     0,
                     (LPTHREAD_START_ROUTINE)cmdCreateProcess,
                     pStdHandles,
                     0,
                     &dwThreadId)) == FALSE) {
        setCF(0);
        setAL((UCHAR)GetLastError());
        nt_resume_event_thread();
        nt_std_handle_notification(fSoftpcRedirectionOnShellOut);
        fBlock = FALSE;
        CntrlHandlerState = (CntrlHandlerState & ~CNTRL_SHELLCOUNT) |
                         (((WORD)(CntrlHandlerState & CNTRL_SHELLCOUNT))-1);
        return;
    }
    else
        CloseHandle (hThread);

    // Wait for next command to be re-entered
    RtlZeroMemory(&VDMInfo, sizeof(VDMINFO));
    VDMInfo.VDMState = NO_PARENT_TO_WAKE | RETURN_ON_NO_COMMAND;
    GetNextVDMCommand (&VDMInfo);
    if (VDMInfo.CmdSize > 0){
        setCF(1);
        IsRepeatCall = TRUE;
    }
    else {
        setCF(0);
        setAL((UCHAR)dwExitCode32);
        nt_resume_event_thread();
        nt_std_handle_notification(fSoftpcRedirectionOnShellOut);
        fBlock = FALSE;
    }


    CntrlHandlerState = (CntrlHandlerState & ~CNTRL_SHELLCOUNT) |
                         (((WORD)(CntrlHandlerState & CNTRL_SHELLCOUNT))-1);
    return;
}

/* cmdExecComspec32 - Exec 32bit COMSPEC
 *
 *
 *  Entry - Client (ES) - environment segment
 *          Client (AL) - default drive
 *
 *  EXIT  - SUCCESS Client (CY) Clear - AL has return error code
 *          FAILURE Client (CY) set - means DOS is being re-entered
 */

VOID cmdExecComspec32 (VOID)
{

    CHAR Buffer[MAX_PATH];
    DWORD dwRet;
    PCHAR   pEnv;

    dwRet = GetEnvironmentVariable ("COMSPEC",Buffer,MAX_PATH);

    if (dwRet == 0 || dwRet >= MAX_PATH){
        setCF(0);
        setAL((UCHAR)ERROR_BAD_ENVIRONMENT);
        return;
    }

    pEnv = (PCHAR) GetVDMAddr ((USHORT)getES(),0);

    chDefaultDrive = (CHAR)(getAL() + 'A');

    cmdExec32 (Buffer,pEnv);

    return;
}

/* cmdExec - Exec a non-dos binary
 *
 *
 *  Entry - Client (DS:SI) - command to execute
 *          Client (AL) - default drive
 *          Client (ES) - environment segment
 *          Client (SS:BP) - Pointer to STD_HANDLES
 *          Client (AH) - if 1 means do "cmd /c command" else "command"
 *
 *  EXIT  - SUCCESS Client (CY) Clear - AL has return error code
 *          FAILURE Client (CY) set - means DOS is being re-entered
 */

VOID cmdExec (VOID)
{

    DWORD   i;
    DWORD   dwRet;
    PCHAR   pCommandTail;
    PCHAR   pEnv;
    CHAR Buffer[MAX_PATH];

    pCommandTail = (PCHAR) GetVDMAddr ((USHORT)getDS(),(USHORT)getSI());
    pEnv = (PCHAR) GetVDMAddr ((USHORT)getES(),0);
    for (i=0 ; i<124 ; i++) {
        if (pCommandTail[i] == 0x0d){
            pCommandTail[i] = 0;
            break;
        }
    }

    if (i == 124){
        setCF(0);
        setAL((UCHAR)ERROR_BAD_FORMAT);
        return;
    }

    chDefaultDrive = (CHAR)(getAL() + 'A');

    if (getAH() == 0) {
        cmdExec32 (pCommandTail,pEnv);
    }
    else {
        dwRet = GetEnvironmentVariable ("COMSPEC",Buffer,MAX_PATH);

        if (dwRet == 0 || dwRet >= MAX_PATH){
            setCF(0);
            setAL((UCHAR)ERROR_BAD_ENVIRONMENT);
            return;
        }

        if ((dwRet + 4 + strlen(pCommandTail)) > MAX_PATH) {
            setCF(0);
            setAL((UCHAR)ERROR_BAD_ENVIRONMENT);
            return;
        }

        strcat (Buffer, " /c ");
        strcat (Buffer, pCommandTail);
        cmdExec32 (Buffer,pEnv);
    }

    return;
}

/* cmdReturnExitCode - command.com has run a dos binary and returing
 *                     the exit code.
 *
 * Entry - Client (DX) - exit code
 *         Client (AL) - current drive
 *         Client (BX:CX) - RdrInfo address
 *
 * Exit
 *         Client Carry Set - Reenter i.e. a new DOS binary to execute.
 *         Client Carry Clear - This shelled out session is over.
 */

VOID cmdReturnExitCode (VOID)
{
VDMINFO MyVDMInfo;
PREDIRCOMPLETE_INFO pRdrInfo;

    RtlZeroMemory(&MyVDMInfo, sizeof(VDMINFO));
    MyVDMInfo.VDMState = RETURN_ON_NO_COMMAND;
    MyVDMInfo.ErrorCode = (ULONG)getDX();

    CntrlHandlerState = (CntrlHandlerState & ~CNTRL_SHELLCOUNT) |
                         (((WORD)(CntrlHandlerState & CNTRL_SHELLCOUNT))+1);

    nt_block_event_thread(0);
    fBlock = TRUE;

    // a dos program just terminate, inherit its current directories
    // and tell base too.
    cmdUpdateCurrentDirectories((BYTE)getAL());

    // Check for any copying needed for redirection
    pRdrInfo = (PREDIRCOMPLETE_INFO) (((ULONG)getBX() << 16) + (ULONG)getCX());

    if (!cmdCheckCopyForRedirection (pRdrInfo, FALSE))
            MyVDMInfo.ErrorCode = ERROR_NOT_ENOUGH_MEMORY;

    GetNextVDMCommand (&MyVDMInfo);
    if (MyVDMInfo.CmdSize > 0){
        setCF(1);
        IsRepeatCall = TRUE;
    }
    else {
        setCF(0);
        setAL((UCHAR)dwExitCode32);
        nt_resume_event_thread();
        nt_std_handle_notification(fSoftpcRedirectionOnShellOut);
        fBlock = FALSE;
    }

    CntrlHandlerState = (CntrlHandlerState & ~CNTRL_SHELLCOUNT) |
                         (((WORD)(CntrlHandlerState & CNTRL_SHELLCOUNT))-1);

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dos\command\cmdpif.h ===
/*================================================================
Structure used to hold the data that CONFIG will need from the PIF
file. This is gleaned from both the main data block and from the
file extensions for Windows 286 and 386.
================================================================*/


/* WARNING !!!!!!
   This structure is copied from NT_PIF.H in insiginia
   hsot\inc\nt_pif.h. Make sure you keep them synchronized
   when you make changes.
*/
#pragma pack()
typedef struct
   {
   char *WinTitle;		    /* caption text(Max. 30 chars) + NULL */
   char *CmdLine;		    /* command line (max 63 hars) + NULL */
   char *StartDir;		    /* program file name (max 63 chars + NULL */
   char *StartFile;
   WORD fullorwin;
   WORD graphicsortext;
   WORD memreq;
   WORD memdes;
   WORD emsreq;
   WORD emsdes;
   WORD xmsreq;
   WORD xmsdes;
   char menuclose;
   char reskey;
   WORD ShortMod;
   WORD ShortScan;
   char idledetect;
   char fgprio;
   char CloseOnExit;
   char AppHasPIFFile;
   char IgnoreTitleInPIF;
   char IgnoreStartDirInPIF;
   char IgnoreShortKeyInPIF;
   char IgnoreCmdLineInPIF;
   char IgnoreConfigAutoexec;
   char SubSysId;
   } PIF_DATA;

extern PIF_DATA pfdata;
BOOL   GetPIFData(PIF_DATA *, char *);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dos\command\cmdkeyb.h ===
/*  cmdkeyb.h - Keyboard layout support routines
 *  include file for CMDKEYB.C
 *
 *  Modification History:
 *
 *  YST 14-Jan_1993 Created
 */


#define DOSKEYBCODES	"DOSKeybCodes"	      // section name in layout.inf
#define LAYOUT_FILE     "\\LAYOUT.INF"        // INF file name
#define DEFAULT_KB_ID   "US"                  // Default keyboard ID
#define KEYBOARD_SYS    "\\KEYBOARD.SYS"      // Data file for KEYB.COM
#define US_CODE         "00000409"            // Code for US keyboard in REGISTER.INI
#define KEYB_COM        "\\KB16.COM"          // File name for keyboard program
#define KBDLAYOUT_PATH	"System\\CurrentControlSet\\Control\\Keyboard Layout\\"
#define DOSCODES_PATH	"DosKeybCodes"
#define DOSIDS_PATH	"DosKeybIDs"
#define REG_STR_ALTKDF_FILES	"AlternativeKDFs"
#define REG_STR_WOW	"SYSTEM\\CurrentControlSet\\Control\\Wow"
#define KDF_SIGNATURE	"\xFFKEYB   "
#define LANGID_BUFFER_SIZE	20
#define KEYBOARDID_BUFFER_SIZE	20
#define KDF_AX		    "\\KEYAX.SYS"     // AX standard keyboard
#define KDF_106 	    "\\KEY01.SYS"     // 106 keys
#define KDF_IBM5576_02_03   "\\KEY02.SYS"     // IBM 5576 002/003 keyboard
#define KDF_TOSHIBA_J3100   "\\KEYJ31.SYS"    // Toshiba J3100 keyboard


//
// Dos KDF(Keyboard Definition File) format description:
//
// The file starts with a header(KDF_HEADER), followed
// by an array of KDF_LANGID_OFFSET and then by an array of
// KDF_KEYBOARDID_OFFSET. The KDF_LANGID_OFFSET array size is
// determined by KDF_HEADER.TotalLangIDs while the KDF_KEYBOARDID_OFFSET
// array size is determined by KDF_HEADER.TotalKeybIDs
//
// Each KDF_LANGID_OFFSET contains a file offset to its KDF_LANGID_ENTRY.
// Each KDF_LANGID_ENTRY is followed by an array of KDF_CODEPAGEID_OFFSET.
// The KDF_CODEPAGEID_OFFSET array size is determined by its assocated
// KDF_LANGID_ENTRY's TotalCodePageIDs.
//
// For a language ID with multiple keyboard IDs, Only one entry
// will be in the KDF_LANGID_OFFSET table. The rest of them are
// stored in the KDF_KEYBOARDID_OFFSET table.
//
// Each KDF_LANGID_ENTRY plus its code page table is enough
// to determine if a (language id, keyboard id, code page id) is
// support by the kdf file.
//
// KDF file header
//

// must pack the structures
#pragma pack(1)

typedef struct tagKDFHeader
{
    CHAR    Signature[8];   // signature, must be 0xFF"KEYB    "
    CHAR    Reserved1[8];
    WORD    MaxCommXlatSize;	// maximum common xlat section size
    WORD    MaxSpecialXlatSize; // maximum special xlat section size
    WORD    MaxStateLogicSize;	// maximum state logic section size
    WORD    Reserved2;
    WORD    TotalKeybIDs;	// total keyboard ids defined in this file
    WORD    TotalLangIDs;	// total language ids defined in this file
}KDF_HEADER, *PKDF_HEADER;

#define IS_LANGID_EQUAL(src, dst)   (toupper(src[0]) == toupper(dst[0])  && \
				     toupper(src[1]) == toupper(dst[1]) )
//
//
//
typedef struct tagKDFLangIdOffset
{
    CHAR    ID[2];			    // the id, "us" for U.S.A
    DWORD   DataOffset; 		    // file offset to its KDF_LANGID_ENTRY
}KDF_LANGID_OFFSET, *PKDF_LANGID_OFFSET;

typedef struct tagKDFKeyboardIdOffset
{
    WORD    ID;				    // the id
    DWORD   DataOffset; 		    // file offset to its KDF_LANGID_ENTRY
}KDF_KEYBOARDID_OFFSET, *PKDF_KEYBOARDID_OFFSET;


// A single lang id may associate with multiple keyboard ids and for each
// keyboard id, there is one KDF_LANGID_ENTRY allocated for it.
// The TotalKaybordIDs is tricky. Suppose the language id has <n> different
// keyboard ids, the <i>th KDF_LANGID_ENTRY's TotalKeyboardIDs contains
// the value of <n - i + 1>. As far as we are only interested in if
// the kdf supports a given (language id, keyboard id, code page id> combination
// we donot care how the value is set by simply following these steps:
// (1). Read the KDF_LANGID_OFFSET table and for each KDF_LANGID_OFFSET,
//	compare the language id. If it matches, go get its KDF_LANGID_ENTRY
//	and compare the primary keyboard id and all its code page. If
//	the combination matches, we are done, otherwise, go to step 2.
// (2). Read KDF_KEYBOARDID_OFFSET table and for each KDF_KEYBOARDID_OFFSET,
//	compare the keyboard id. If the keyboard id matches, go get its
//	KDF_LANGID_ENTRY and compare the language id and code page against
//	the KDF_LANGID_ENTRY. If both the language id and the code page id
//	match, we are done, otherwise, goto step 3.
// (3). We conclude that this kdf does not meet the requirement.
//
typedef struct tagLangEntry
{
    CHAR    ID[2];			    // the id
    WORD    PrimaryKeybId;		    // primary keyboard id
    DWORD   DataOffset; 		    // file offset to state logic section
    BYTE    TotalKeyboardIDs;		    // total keyboard ids
    BYTE    TotalCodePageIDs;		    // total code pages
}KDF_LANGID_ENTRY, *PKDF_LANGID_ENTRY;
//
// An array of supported KDF_CODEPAGEID_OFFSET immediately follow its
// KDF_LANGID_ENTRY. The size of the array is determined by
// KDF_LANGID_ENTRY.TotalCodePageIDs
typedef struct tagCodePageIdOffset
{
    WORD    ID; 			    // the id
    DWORD   DataOffset; 		    // file offset to the xlat section
}KDF_CODEPAGEID_OFFSET, *PKDF_CODEPAGEID_OFFSET;

#pragma pack()

BOOL
LocateKDF(
    CHAR* LanguageID,
    WORD  KeyboardID,
    WORD  CodePageID,
    LPSTR Buffer,
    DWORD* BufferSize
    );

BOOL
MatchKDF(
    CHAR* LanguageID,
    WORD  KeyboardID,
    WORD  CodePageID,
    LPCSTR KDFPath
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dos\command\cmdpif.c ===
/*  cmdpif.c - PIF Handling Routines For SCS
 *
 *
 *  Modification History:
 *
 *  Sudeepb 19-Aug-1992 Created
 *  williamh 10-Nov-1992 (1). get params from w386 extention if exist
 *			 (2). null terminate caption
 *  williamh 27-May-1993 almost rewrote for better pif support
 */

#include "cmd.h"
#include <ctype.h>
#include <pif.h>
#include <cmdsvc.h>
#include <softpc.h>
#include <mvdm.h>
#include <oemuni.h>
#include "nt_pif.h"

VOID cmdCheckForPIF (PVDMINFO pvi)
{
PCHAR   pCmdLine = pvi->CmdLine;
PCHAR   pDot;
ULONG   size;
UCHAR   ch;
DWORD   dw;
CHAR	lpszEnvDir [] = "=?:";
CHAR	FullPathName[MAX_PATH + 1];
CHAR	* pFilePart;
BOOL	IsPIFFile, IsFromForceDos;
CHAR	AppFullPathName[MAX_PATH + 1];

    //
    // Advance CmdLine pointer to beg of command tail
    //
    while (*pCmdLine && !isgraph(*pCmdLine)) { // skip to first nonwhite
        pCmdLine++;
        }

    pDot = strrchr(pvi->AppName, '.');
    if (pDot)
	IsPIFFile = pDot && !_strnicmp(pDot, ".pif", 4);
    else
       IsPIFFile = FALSE;


    // if the command is not a pif file and it is not
    // running on a new console
    if (!IsPIFFile && !DosSessionId)
	goto CleanUpAndReturn;

    if (IsPIFFile) {
	if (!IsFirstVDM) {
            //
            // Get the pif data. If no pif data, or not from forcedos
            // just return -- command.com will receive the pif file
            // name and fail.
            //
            pfdata.AppHasPIFFile =
	    pfdata.IgnoreStartDirInPIF =
	    pfdata.IgnoreTitleInPIF =
	    pfdata.IgnoreCmdLineInPIF =
	    pfdata.IgnoreConfigAutoexec = 1;
            if (!GetPIFData(&pfdata, pvi->AppName))
		goto CleanUpAndReturn;
        }

	// we only run a pif file on two occasions:
	// (1). it is from a new console
	// (2). it is from forcedos.
        if (!DosSessionId && pfdata.SubSysId != SUBSYS_DOS)
            goto CleanUpAndReturn;

    }
    if (IsFirstVDM) {
	// if this is the first vdm, take cmdline, startupdir and title
	// if they are there
	if (pfdata.StartDir){
	    dw = cmdExpandEnvironmentStrings(NULL,
					     pfdata.StartDir,
					     FullPathName,
					     MAX_PATH + 1
					     );
            if (dw != 0 &&      dw <= MAX_PATH) {
		dw = GetFullPathNameOemSys(FullPathName,
					MAX_PATH + 1,
					pfdata.StartDir,
					&pFilePart,
                    TRUE
                                        );
            }

	    if (dw != 0 && dw <= MAX_PATH)
		dw = GetFileAttributesOemSys(pfdata.StartDir, TRUE);
	    else
                dw = 0;

	    if (dw == 0 || dw == 0xFFFFFFFF || !(dw & FILE_ATTRIBUTE_DIRECTORY))
		{
		RcMessageBox(EG_PIF_STARTDIR_ERR,
			     NULL,
			     NULL,
			     RMB_ICON_BANG | RMB_ABORT);
		goto CleanUpAndReturn;
            }

            dw = GetShortPathNameOem(pfdata.StartDir,
                                     pfdata.StartDir,
                                     MAX_PATH + 1
                                     );
	    if (dw == 0 || dw > MAX_PATH || dw > 64) {
		RcMessageBox(EG_PIF_STARTDIR_ERR,
			     NULL,
			     NULL,
			     RMB_ICON_BANG | RMB_ABORT);
		goto CleanUpAndReturn;
            }

	    lpszEnvDir[1] = pfdata.StartDir[0];
	    SetEnvironmentVariableOem(lpszEnvDir, pfdata.StartDir);
	    SetCurrentDirectoryOem(pfdata.StartDir);
	    pvi->CurDrive = toupper(pfdata.StartDir[0]) - 'A';
        }

	if (pfdata.WinTitle) {
	    strncpy(FullPathName, pfdata.WinTitle,sizeof(FullPathName));
        FullPathName[sizeof(FullPathName)-1] = '\0';
	    dw = cmdExpandEnvironmentStrings(NULL,
					     FullPathName,
					     pfdata.WinTitle,
					     MAX_PATH + 1
					     );
	    pfdata.WinTitle[MAX_PATH] = '\0';
        }

        if (!*pCmdLine && pfdata.CmdLine) {

	    // if the optinal parameter is '?'
	    // prompt the user
	    pDot = pfdata.CmdLine;
	    while (*pDot && *pDot <= ' ')
                pDot++;

	    if (*pDot == '?') {
		pfdata.CmdLine[0] = '\0';
		RcMessageBox(EG_PIF_ASK_CMDLINE,
			     NULL,
			     pfdata.CmdLine,
			     RMB_EDIT | RMB_ICON_INFO | (128 << 16)
			     );
            }

	    if (*pfdata.CmdLine) {
		strncpy(FullPathName, pfdata.CmdLine,sizeof(FullPathName));
        FullPathName[sizeof(FullPathName)-1] = '\0';
		dw = cmdExpandEnvironmentStrings(NULL,
						 FullPathName,
						 pfdata.CmdLine,
						 MAX_PATH + 1
						);
	    }
	}
    }


    if(IsPIFFile) {
        dw = cmdExpandEnvironmentStrings(NULL,
                                         pfdata.StartFile,
					 FullPathName,
                                         MAX_PATH + 1
                                        );
        if (!dw || dw > MAX_PATH) {
            RcMessageBox(EG_PIF_STARTFILE_ERR,
                         NULL, NULL, RMB_ICON_BANG | RMB_ABORT);
            goto CleanUpAndReturn;
        }



        // search from the current directory
        // note that the startup directory specified in
        // the pif file has been set as our current directory
        // when we got here
        dw = SearchPathOem(".",
                           FullPathName,
                           NULL,
                           MAX_PATH + 1,
			   AppFullPathName,
                           &pFilePart
                           );
        // if couldn't find the file from the current dir
        // ask win32api help
        if (dw == 0 || dw > MAX_PATH) {
            dw = SearchPathOem(NULL,
                               FullPathName,
                               NULL,
                               MAX_PATH + 1,
			       AppFullPathName,
                               &pFilePart
                               );
        }

        // couldn't find the file, give up
        if (dw == 0 || dw > MAX_PATH) {
            RcMessageBox(EG_PIF_STARTFILE_ERR,
                         NULL, NULL, RMB_ICON_BANG | RMB_ABORT);
            goto CleanUpAndReturn;
        }

	dw = GetFileAttributesOemSys(AppFullPathName, TRUE);
        if (dw == (DWORD)(-1) || (dw & FILE_ATTRIBUTE_DIRECTORY)) {
            RcMessageBox(EG_PIF_STARTFILE_ERR, NULL, NULL,
                         RMB_ICON_BANG | RMB_ABORT
                         );
            goto CleanUpAndReturn;
        }

        // convert to shortfilename
	dw = GetShortPathNameOem(AppFullPathName, pvi->AppName,
                                 MAX_PATH + 1);
        if (dw == 0 || dw > MAX_PATH) {

            RcMessageBox(EG_PIF_STARTFILE_ERR, NULL, NULL,
                         RMB_ICON_BANG | RMB_ABORT
                         );
            goto CleanUpAndReturn;
        }
	// update the application path name length(including the terminate NULL)
	pvi->AppLen = strlen(pvi->AppName) + 1;

	// pvi->AppName contains the application short name.
	// verify that it has the correct extension(.EXE, .COM or .BAT).
	pDot = (PCHAR)pvi->AppName + pvi->AppLen - 5;
	if (pvi->AppLen < 5 ||
	    (_strnicmp(pDot, EXE_EXTENTION_STRING, EXTENTION_STRING_LEN) &&
	     _strnicmp(pDot, COM_EXTENTION_STRING, EXTENTION_STRING_LEN) &&
	     _strnicmp(pDot, BAT_EXTENTION_STRING, EXTENTION_STRING_LEN)))
	{

	    RcMessageBox(EG_DOS_PROG_EXTENSION,AppFullPathName, NULL, RMB_ICON_BANG | RMB_ABORT);
	    goto CleanUpAndReturn;

	}
    }


    //
    // Copy in pif command tail if original command tail is empty
    //
    if (!*pCmdLine && pfdata.CmdLine) {
        strncpy(FullPathName, pfdata.CmdLine, sizeof(FullPathName)-sizeof("\x0d\x0a"));
        FullPathName[sizeof(FullPathName)-sizeof("\x0d\x0a")-1] = '\0';
        strcat(FullPathName, "\x0d\x0a");
        if (strlen(FullPathName) >= 128 - 13) {
	    // too bad, the command line is too long
            RcMessageBox(EG_PIF_CMDLINE_ERR,NULL,NULL,RMB_ICON_BANG | RMB_ABORT);
	    goto CleanUpAndReturn;

	}
	strcpy(pvi->CmdLine, FullPathName);
	pvi->CmdSize = strlen(FullPathName) + 1;
    }

    if (IsPIFFile)
	// we don't know the binary type at this point.
	*pIsDosBinary = 0;

    if (pfdata.WinTitle)
	SetConsoleTitle(pfdata.WinTitle);

    DontCheckDosBinaryType = (pfdata.SubSysId == SUBSYS_DOS);

CleanUpAndReturn:
    if (pfdata.CmdLine) {
	free(pfdata.CmdLine);
	pfdata.CmdLine = NULL;
    }
    if (pfdata.StartDir) {
	free(pfdata.StartDir);
	pfdata.StartDir = NULL;
    }
    if (pfdata.StartFile) {
	free(pfdata.StartFile);
	pfdata.StartFile = NULL;
    }
    if (pfdata.WinTitle) {
	free(pfdata.WinTitle);
	pfdata.WinTitle = NULL;
    }
    return;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dos\command\cmdmisc.c ===
/*  cmdmisc.c - Misc. SVC routines of Command.lib
 *
 *
 *  Modification History:
 *
 *  Sudeepb 17-Sep-1991 Created
 */

#include "cmd.h"

#include <cmdsvc.h>
#include <demexp.h>
#include <softpc.h>
#include <mvdm.h>
#include <ctype.h>
#include <memory.h>
#include "host_def.h"
#include "oemuni.h"
#include "nt_pif.h"
#include "nt_uis.h"       // For resource id
#include "dpmtbls.h"      // Dynamic Patch Module support
#include "wowcmpat.h"

VOID GetWowKernelCmdLine(VOID);
extern ULONG fSeparateWow;
#if defined(KOREA)
//To fix HaNa spread sheet IME hot key problem
//09/20/96 bklee. See mvdm\v86\monitor\i386\monitor.c
BOOL bIgnoreExtraKbdDisable = FALSE;
#endif

extern PFAMILY_TABLE  *pgDpmVdmFamTbls;

VOID cmdGetNextCmd (VOID)
{
LPSTR   lpszCmd;
PCMDINFO pCMDInfo;
ULONG   cb;
PREDIRCOMPLETE_INFO pRdrInfo;
VDMINFO MyVDMInfo;

char    *pSrc, *pDst;
char    achCurDirectory[MAXIMUM_VDM_CURRENT_DIR + 4];
char    CmdLine[MAX_PATH];

    //
    // This routine is called once for WOW VDMs, to retrieve the
    // "krnl386" command line.
    //                                         5
    if (VDMForWOW) {
        GetWowKernelCmdLine();
        return;
    }

    VDMInfo.VDMState = 0;
    pCMDInfo = (LPVOID) GetVDMAddr ((USHORT)getDS(),(USHORT)getDX());

    VDMInfo.ErrorCode = FETCHWORD(pCMDInfo->ReturnCode);
    VDMInfo.CmdSize = sizeof(CmdLine);
    VDMInfo.CmdLine = CmdLine;
    VDMInfo.AppName = (PVOID)GetVDMAddr(FETCHWORD(pCMDInfo->ExecPathSeg),
                                        FETCHWORD(pCMDInfo->ExecPathOff));
    VDMInfo.AppLen = FETCHWORD(pCMDInfo->ExecPathSize);
    VDMInfo.PifLen = 0;
    VDMInfo.EnviornmentSize = 0;
    VDMInfo.Enviornment = NULL;
    VDMInfo.CurDrive = 0;
    VDMInfo.TitleLen = 0;
    VDMInfo.ReservedLen = 0;
    VDMInfo.DesktopLen = 0;
    VDMInfo.CurDirectoryLen = MAX_PATH + 1;
    VDMInfo.CurDirectory = achCurDirectory;

    if(IsFirstCall){
        VDMInfo.VDMState = ASKING_FOR_FIRST_COMMAND;
        VDMInfo.ErrorCode = 0;

        DeleteConfigFiles();   // get rid of the temp boot files

        // When COMMAND.COM issues first cmdGetNextCmd, it has
        // a completed environment already(cmdGetInitEnvironment),
        // Therefore, we don't have to ask environment from BASE
        cmdVDMEnvBlk.lpszzEnv = (PVOID)GetVDMAddr(FETCHWORD(pCMDInfo->EnvSeg),0);
        cmdVDMEnvBlk.cchEnv = FETCHWORD(pCMDInfo->EnvSize);

        // Check BLASTER environment variable to determine if Sound Blaster
        // emulation should be disabled.
        cb = cmdGetEnvironmentVariable(NULL, "BLASTER", CmdLine, MAX_PATH);
        if (cb !=0 && cb <= MAX_PATH) {
            SbReinitialize(CmdLine, MAX_PATH);
        }
        //clear bits that track printer flushing
        host_lpt_flush_initialize();

        // save ptr to global DPM tables for DOS
        pgDpmDosFamTbls = DPMFAMTBLS();
        InitGlobalDpmTables(pgDpmVdmFamTbls, NUM_VDM_FAMILIES_HOOKED);
    }
    else {

        // Get rid of all the SDB command line parameter stuff associated with
        // the app compat flags.
        if((cCmdLnParmStructs > 0) || dwDosCompatFlags) {

            // Get rid of the Dynamic Patch tables for this task.
            if(dwDosCompatFlags & WOWCF2_DPM_PATCHES) {

                FreeTaskDpmSupport(DPMFAMTBLS(),
                                   NUM_VDM_FAMILIES_HOOKED,
                                   pgDpmDosFamTbls);
            }

            FreeCmdLnParmStructs(pCmdLnParms, cCmdLnParmStructs);

            cCmdLnParmStructs = 0;
            dwDosCompatFlags  = 0;
        }

        // program has terminated. If the termiation was issued from
        // second(or later) instance of command.com(cmd.exe), don't
        // reset the flag.
        if (Exe32ActiveCount == 0)
            DontCheckDosBinaryType = FALSE;

        // tell the base our new current directories (in ANSI)
        // we don't do it on repeat call(the shell out case is handled in
        // return exit code
        if (!IsRepeatCall) {
            cmdUpdateCurrentDirectories((BYTE)pCMDInfo->CurDrive);
        }


        VDMInfo.VDMState = 0;
        if(!IsRepeatCall){
            demCloseAllPSPRecords ();

            if (!pfdata.CloseOnExit && DosSessionId)
                nt_block_event_thread(1);
            else
                nt_block_event_thread(0);

            if (DosSessionId) {
                pRdrInfo = (PREDIRCOMPLETE_INFO) FETCHDWORD(pCMDInfo->pRdrInfo);
                if (!pfdata.CloseOnExit){
                    char  achTitle[MAX_PATH];
                    char  achInactive[60];     //should be plenty for 'inactive'
                    strcpy (achTitle, "[");
                    if (!LoadString(GetModuleHandle(NULL), EXIT_NO_CLOSE,
                                                              achInactive, 60))
                        strcat (achTitle, "Inactive ");
                    else
                        strcat(achTitle, achInactive);
                    cb = strlen(achTitle);
                    // GetConsoleTitleA and SetConsoleTitleA
                    // are working on OEM character set.
                    GetConsoleTitleA(achTitle + cb, MAX_PATH - cb - 1);
                    cb = strlen(achTitle);
                    achTitle[cb] = ']';
                    achTitle[cb + 1] = '\0';
                    SetConsoleTitleA(achTitle);
                    // finish touch on redirection stuff
                    cmdCheckCopyForRedirection (pRdrInfo, FALSE);
                    Sleep(INFINITE);
                }
                else {
                    // finish touch on redirection stuff
                    // this will wait on the output thread if there
                    // are any.
                    cmdCheckCopyForRedirection (pRdrInfo, TRUE);
                    VdmExitCode = VDMInfo.ErrorCode;
                    TerminateVDM();
                }
            }
            fBlock = TRUE;
        }
    }

    if(IsRepeatCall) {
        VDMInfo.VDMState |= ASKING_FOR_SECOND_TIME;
        if( VDMInfo.ErrorCode != 0 )
            IsRepeatCall = FALSE;
    }

    VDMInfo.VDMState |= ASKING_FOR_DOS_BINARY;

    if (!IsFirstCall && !(VDMInfo.VDMState & ASKING_FOR_SECOND_TIME)) {
        pRdrInfo = (PREDIRCOMPLETE_INFO) FETCHDWORD(pCMDInfo->pRdrInfo);
        if (!cmdCheckCopyForRedirection (pRdrInfo, FALSE))
            VDMInfo.ErrorCode = ERROR_NOT_ENOUGH_MEMORY;
    }

    // Leave the current directory in a safe place, so that other 32bit
    // apps etc. can delnode this directory (and other such operations) later.
    if ( IsFirstCall == FALSE && IsRepeatCall == FALSE )
        SetCurrentDirectory (cmdHomeDirectory);

    // TSRExit will be set to 1, only if we are coming from command.com's
    // prompt and user typed an exit. We need to kill our parent also, so we
    // should write an exit in the console buffer.
    if (FETCHWORD(pCMDInfo->fTSRExit)) {
        cmdPushExitInConsoleBuffer ();
    }

    /**
        Merging environment is required if
        (1). Not the first comamnd &&
        (2). NTVDM is running on an existing console ||
             NTVDM has been shelled out.
        Note that WOW doesn't need enviornment merging.
    **/
    if (!DosEnvCreated && !IsFirstCall && (!DosSessionId || Exe32ActiveCount)) {
        RtlZeroMemory(&MyVDMInfo, sizeof(VDMINFO));
        MyVDMInfo.VDMState = ASKING_FOR_ENVIRONMENT | ASKING_FOR_DOS_BINARY;
        if (IsRepeatCall) {
            MyVDMInfo.VDMState |= ASKING_FOR_SECOND_TIME;
            MyVDMInfo.ErrorCode = 0;
        }
        else
            MyVDMInfo.ErrorCode = VDMInfo.ErrorCode;
        MyVDMInfo.Enviornment = lpszzVDMEnv32;
        MyVDMInfo.EnviornmentSize = (USHORT) cchVDMEnv32;
        if (!GetNextVDMCommand(&MyVDMInfo) && MyVDMInfo.EnviornmentSize > cchVDMEnv32) {
            MyVDMInfo.Enviornment = realloc(lpszzVDMEnv32, MyVDMInfo.EnviornmentSize);
            if (MyVDMInfo.Enviornment == NULL) {
                RcErrorDialogBox(EG_MALLOC_FAILURE, NULL, NULL);
                TerminateVDM();
            }
            lpszzVDMEnv32 = MyVDMInfo.Enviornment;
            cchVDMEnv32 = MyVDMInfo.EnviornmentSize;
            MyVDMInfo.VDMState = ASKING_FOR_DOS_BINARY | ASKING_FOR_ENVIRONMENT |
                                 ASKING_FOR_SECOND_TIME;

            MyVDMInfo.TitleLen =
            MyVDMInfo.DesktopLen =
            MyVDMInfo.ReservedLen =
            MyVDMInfo.CmdSize =
            MyVDMInfo.AppLen =
            MyVDMInfo.PifLen =
            MyVDMInfo.CurDirectoryLen = 0;
            MyVDMInfo.ErrorCode = 0;
            if (!GetNextVDMCommand(&MyVDMInfo)) {
                RcErrorDialogBox(EG_ENVIRONMENT_ERR, NULL, NULL);
                TerminateVDM();
            }
        }
        if (!cmdCreateVDMEnvironment(&cmdVDMEnvBlk)) {
            RcErrorDialogBox(EG_ENVIRONMENT_ERR, NULL, NULL);
            TerminateVDM();
        }
        DosEnvCreated = TRUE;
        VDMInfo.ErrorCode = 0;
    }
    if (cmdVDMEnvBlk.cchEnv > FETCHWORD(pCMDInfo->EnvSize)) {
        setAX((USHORT)cmdVDMEnvBlk.cchEnv);
        setCF(1);
        IsFirstCall = FALSE;
        IsRepeatCall = TRUE;
        return;
    }
    if (DosEnvCreated)
        VDMInfo.VDMState |= ASKING_FOR_SECOND_TIME;

    if(!GetNextVDMCommand(&VDMInfo)){
       RcErrorDialogBox(EG_ENVIRONMENT_ERR, NULL, NULL);
       TerminateVDM();
    }


    IsRepeatCall = FALSE;
    IsFirstCall = FALSE;

    if(fBlock){
         nt_resume_event_thread();
         fBlock = FALSE;
    }

    // Sync VDMs enviornment variables for current directories
    cmdSetDirectories (lpszzVDMEnv32, &VDMInfo);

    // tell DOS that this is a dos executable and no further checking is
    // necessary
    *pIsDosBinary = 1;


    // Check for PIF files. If a pif file is being executed extract the
    // executable name, command line, current directory and title from the pif
    // file and place the stuff appropriately in VDMInfo. Note, if pif file
    // is invalid, we dont do any thing to vdminfo. In such a case we
    // pass the pif as it is to scs to execute which we know will fail and
    // will come back to cmdGettNextCmd with proper error code.

    cmdCheckForPIF (&VDMInfo);

    //
    // if forcedos, then don't check binary type on int 21 exec process,
    // so that child spawns stay in dos land. Begining with NT 4.0 forcedos.exe
    // no longer uses pif files to force execution of a binary as a dos exe.
    // It now uses a bit in CreateProcess (dwCreationFlags).
    //

    DontCheckDosBinaryType = (VDMInfo.dwCreationFlags & CREATE_FORCEDOS) != 0;

    // convert exec path name to upper case. This is what command.com expect
    if(WOW32_strupr(VDMInfo.AppName) == NULL) {
       pSrc = VDMInfo.AppName;
       while( *pSrc)
              *pSrc++ = (char)toupper((int)*pSrc);
    }

    // figure out the extention type
    // at least one char for the base name plus
    // EXTENTION_STRING_LEN for the extention
    // plus the NULL char
    if (VDMInfo.AppLen > 1 + EXTENTION_STRING_LEN  + 1) {
        pSrc = (PCHAR)VDMInfo.AppName + VDMInfo.AppLen - 5;
        if (!strncmp(pSrc, EXE_EXTENTION_STRING, EXTENTION_STRING_LEN))
            STOREWORD(pCMDInfo->ExecExtType, EXE_EXTENTION);
        else if (!strncmp(pSrc, COM_EXTENTION_STRING, EXTENTION_STRING_LEN))
            STOREWORD(pCMDInfo->ExecExtType, COM_EXTENTION);
        else if (!strncmp(pSrc, BAT_EXTENTION_STRING, EXTENTION_STRING_LEN))
            STOREWORD(pCMDInfo->ExecExtType, BAT_EXTENTION);
        else
            STOREWORD(pCMDInfo->ExecExtType, UNKNOWN_EXTENTION);
    }
    else
        STOREWORD(pCMDInfo->ExecExtType, UNKNOWN_EXTENTION);

    // tell command.com the length of the app full path name.
    STOREWORD(pCMDInfo->ExecPathSize, VDMInfo.AppLen);

    //
    // Prepare ccom's UCOMBUF
    //
    lpszCmd = (PVOID)GetVDMAddr(FETCHWORD(pCMDInfo->CmdLineSeg),
                                FETCHWORD(pCMDInfo->CmdLineOff));

    // Copy filepart of AppName excluding extension to ccom's buffer
    pSrc = strrchr(VDMInfo.AppName, '\\');

#if defined(KOREA)
    // To fix HaNa spread sheet IME hotkey problem.
    {
    LPSTR pStrt, pEnd;
    char  szModName[9];
    SHORT len;

    pStrt = pSrc;

    if (pStrt==NULL)
        pStrt = VDMInfo.AppName;
    else
        pStrt++;

    if ( (pEnd = strchr (pStrt, '.')) == NULL) {
        strncpy (szModName, pStrt, 9);
        szModName[8] = '\0';
    }
    else {
        len = (SHORT) (pEnd - pStrt);
        if (len<=8) {
            strncpy (szModName, pStrt, len);
            szModName[len] = '\0';
        }
    }

    bIgnoreExtraKbdDisable = !(strcmp("HANASP", szModName));

    }
#endif
    if (!pSrc) {
         pSrc = VDMInfo.AppName;
        }
    else {
         pSrc++;
        }
    pDst = lpszCmd + 2;
    while (*pSrc && *pSrc != '.') {
         *pDst++ = *pSrc++;
         }
    cb = strlen(CmdLine);

    // cmd line must be terminated with "\0xd\0xa\0". This is either done
    // by BASE or cmdCheckForPif function(cmdpif.c).

    ASSERT((cb >= 2) && (0xd == CmdLine[cb - 2]) && (0xa == CmdLine[cb - 1]));

    // if cmd line is not blank, separate program base name and
    // cmd line with a SPACE. If it IS blank, do not insert any white chars
    // or we end up passing white chars to the applications as cmd line
    // and some applications just can not live with that.
    // We do not strip leading white characters in the passed command line
    // so the application sees the original data.
    if (cb > 2)
        *pDst++ = ' ';

    // append the command tail(at least, "\0xd\0xa")
    strncpy(pDst, CmdLine, cb + 1);

    // set the count
    // cb has the cmd line length including the terminated 0xd and 0xa
    // It does NOT count the terminated NULL char.
    ASSERT((cb + pDst - lpszCmd - 2) <= 127);

    // minus 2 because the real data in lpszCmd start from lpszCmd[2]
    lpszCmd[1] = (CHAR)(cb + pDst - lpszCmd - 2);



    if (DosEnvCreated) {
        VDMInfo.Enviornment = (PVOID)GetVDMAddr(FETCHWORD(pCMDInfo->EnvSeg),0);
        RtlMoveMemory(VDMInfo.Enviornment,
                      cmdVDMEnvBlk.lpszzEnv,
                      cmdVDMEnvBlk.cchEnv
                     );
        STOREWORD(pCMDInfo->EnvSize,cmdVDMEnvBlk.cchEnv);
        free(cmdVDMEnvBlk.lpszzEnv);
        DosEnvCreated = FALSE;
    }

    STOREWORD(pCMDInfo->fBatStatus,(USHORT)VDMInfo.fComingFromBat);
    STOREWORD(pCMDInfo->CurDrive,VDMInfo.CurDrive);
    STOREWORD(pCMDInfo->NumDrives,nDrives);
    VDMInfo.CodePage = (ULONG) cmdMapCodePage (VDMInfo.CodePage);
    STOREWORD(pCMDInfo->CodePage,(USHORT)VDMInfo.CodePage);

    cmdVDMEnvBlk.lpszzEnv = NULL;
    cmdVDMEnvBlk.cchEnv = 0;

    IsFirstVDM = FALSE;

    // Handle Standard IO redirection
    pRdrInfo = cmdCheckStandardHandles (&VDMInfo,&pCMDInfo->bStdHandles);
    STOREDWORD(pCMDInfo->pRdrInfo,(ULONG)pRdrInfo);

    // Tell DOS that it has to invalidate the CDSs
    *pSCS_ToSync = (CHAR)0xff;
    setCF(0);

    // Get the app comapt flags & associated command line parameters from the
    // app compat SDB for this app.
    pCmdLnParms = InitVdmSdbInfo((LPCSTR)VDMInfo.AppName,
                                 &dwDosCompatFlags,
                                 &cCmdLnParmStructs);

    return;
}



VOID GetWowKernelCmdLine(VOID)
{
CMDINFO UNALIGNED *pCMDInfo;
PCHAR    pch;
CHAR     szKrnl386[]="krnl386.exe";
CHAR     szPath[MAX_PATH+1];

    DeleteConfigFiles();   // get rid of the temp boot files
    host_lpt_flush_initialize();

    //
    // Only a few things need be set for WOW.
    //   1. NumDrives
    //   2. Kernel CmdLine (get from ntvdm command tail)
    //   3. Current drive
    //
    //  Command.com has setup correct enviroment block at
    //  this moment, so don't bother to mess with environment stuff.

    pCMDInfo = (LPVOID) GetVDMAddr ((USHORT)getDS(),(USHORT)getDX());
    pCMDInfo->NumDrives = nDrives;

    //
    // We used to get the info from a command line parameter, which
    // consisted of a fully qualified short path file name:
    // "-a %SystemRoot%\system32\krnl386.exe".
    //
    // We now remove that parameter and simply assume that for
    // wow we will use %SystemRoot%\system32\krnl386.exe
    //

    //
    // Make sure we have enough space for the two strings concatenated.
    // ulSystem32PathLen does not include the terminator, but
    // sizeof( szKrnl386 ) does, so we only need one more for the '\'.
    //
    if (ulSystem32PathLen + 1 + sizeof (szKrnl386) > FETCHWORD(pCMDInfo->ExecPathSize)) {
        RcErrorDialogBox(EG_ENVIRONMENT_ERR, NULL, NULL);
        TerminateVDM();
    }

    pch = (PCHAR)GetVDMAddr(FETCHWORD(pCMDInfo->ExecPathSeg),
                            FETCHWORD(pCMDInfo->ExecPathOff));

    memcpy(pch, pszSystem32Path, ulSystem32PathLen);
    *(pch + ulSystem32PathLen) = '\\';
    memcpy(pch + ulSystem32PathLen + 1, szKrnl386, sizeof(szKrnl386));

    pCMDInfo->ExecPathSize = (WORD)(ulSystem32PathLen + 1 + sizeof(szKrnl386));
    pCMDInfo->ExecExtType = EXE_EXTENTION; // for WOW, use EXE extention

    //
    // Copy filepart of first token and rest to CmdLine buffer
    //
    pch = (PVOID)GetVDMAddr(FETCHWORD(pCMDInfo->CmdLineSeg),
                            FETCHWORD(pCMDInfo->CmdLineOff));

    if (FETCHWORD(pCMDInfo->CmdLineSize)<sizeof(szKrnl386)+2) {
        RcErrorDialogBox(EG_ENVIRONMENT_ERR, NULL, NULL);
        TerminateVDM();
    }

    memcpy(pch, szKrnl386, sizeof(szKrnl386)-1);
    memcpy(pch+sizeof(szKrnl386)-1, "\x0d\x0a\0", 3);

    *pIsDosBinary = 1;
    IsRepeatCall = FALSE;
    IsFirstCall = FALSE;

    // Tell DOS that it has to invalidate the CDSs
    *pSCS_ToSync = (CHAR)0xff;
    setCF(0);

    return;
}


/* cmdGetCurrentDir - Return the current directory for a drive.
 *
 *
 *  Entry - Client (DS:SI) - buffer to return the directory
 *          Client (AL)   - drive being queried (0 = A)
 *
 *  EXIT  - SUCCESS Client (CY) clear
 *          FAILURE Client (CY) set
 *                         (AX) = 0 (Directory was bigger than 64)
 *                         (AX) = 1 (the drive is not valid)
 *
 */

VOID cmdGetCurrentDir (VOID)
{
PCHAR lpszCurDir;
UCHAR chDrive;
CHAR  EnvVar[] = "=?:";
CHAR  RootName[] = "?:\\";
DWORD EnvVarLen;
UINT  DriveType;


    lpszCurDir = (PCHAR) GetVDMAddr ((USHORT)getDS(),(USHORT)getSI());
    chDrive = getAL();
    EnvVar[1] = chDrive + 'A';
    RootName[0] = chDrive + 'A';

    // if the drive doesn't exist, blindly clear the environment var
    // and return error
    DriveType = demGetPhysicalDriveType(chDrive);
    if (DriveType == DRIVE_UNKNOWN) {
        DriveType = GetDriveTypeOem(RootName);
        }

    if (DriveType == DRIVE_UNKNOWN || DriveType == DRIVE_NO_ROOT_DIR){
        SetEnvironmentVariableOem(EnvVar, NULL);
        setCF(1);
        setAX(0);
        return;
    }

    if((EnvVarLen = GetEnvironmentVariableOem (EnvVar,lpszCurDir,
                                            MAXIMUM_VDM_CURRENT_DIR+3)) == 0){

        // if its not in env then and drive exist then we have'nt
        // yet touched it.
        strcpy(lpszCurDir, RootName);
        SetEnvironmentVariableOem (EnvVar,RootName);
        setCF(0);
        return;
    }
    if (EnvVarLen > MAXIMUM_VDM_CURRENT_DIR+3) {
        setCF(1);
        setAX(0);
    }
    else {
        setCF(0);
    }
    return;
}

/* cmdSetInfo -     Set the address of SCS_ToSync variable in DOSDATA.
 *                  This variable is set whenever SCS dispatches a new
 *                  command to command.com. Setting of this variable
 *                  indicates to dos to validate all the CDS structures
 *                  for local drives.
 *
 *
 *  Entry - Client (DS:DX) - pointer to SCSINFO
 *          Client (DS:BX) - pointer to SCS_Is_Dos_Binary
 *          Client (DS:CX) - pointer to SCS_FDACCESS
 *
 *  EXIT  - None
 */

VOID cmdSetInfo (VOID)
{

    pSCSInfo = (PSCSINFO) GetVDMAddr (getDS(),getDX());

    pSCS_ToSync  =  (PCHAR) &pSCSInfo->SCS_ToSync;

    pIsDosBinary = (BYTE *) GetVDMAddr(getDS(), getBX());

    pFDAccess = (WORD *) GetVDMAddr(getDS(), getCX());
    return;
}


VOID cmdSetDirectories (PCHAR lpszzEnv, VDMINFO * pVdmInfo)
{
LPSTR   lpszVal;
CHAR    ch, chDrive, achEnvDrive[] = "=?:";

    ch = pVdmInfo->CurDrive + 'A';
    if (pVdmInfo->CurDirectoryLen != 0){
        SetCurrentDirectory(pVdmInfo->CurDirectory);
        achEnvDrive[1] = ch;
        SetEnvironmentVariable(achEnvDrive, pVdmInfo->CurDirectory);
    }
    if (lpszzEnv) {
        while(*lpszzEnv) {
            if(*lpszzEnv == '=' &&
                    (chDrive = (CHAR)toupper(*(lpszzEnv+1))) >= 'A' &&
                    chDrive <= 'Z' &&
                    (*(PCHAR)((ULONG)lpszzEnv+2) == ':') &&
                    chDrive != ch) {
                    lpszVal = (PCHAR)((ULONG)lpszzEnv + 4);
                    achEnvDrive[1] = chDrive;
                    SetEnvironmentVariable (achEnvDrive,lpszVal);
            }
            lpszzEnv = strchr(lpszzEnv,'\0');
            lpszzEnv++;
        }
    }
}

static BOOL fConOutput = FALSE;

VOID cmdComSpec (VOID)
{
LPSTR   lpszCS;


    if(IsFirstCall == FALSE)
        return;

    lpszCS =    (LPVOID) GetVDMAddr ((USHORT)getDS(),(USHORT)getDX());
    strcpy(lpszComSpec,"COMSPEC=");
    strcpy(lpszComSpec+8,lpszCS);
    cbComSpec = strlen(lpszComSpec) +1;

    setAL((BYTE)(!fConOutput || VDMForWOW));

    return;
}



/* cmdInitConsole - Let Video VDD know that it can start console output
 *                  operations.
 *
 *
 *  Entry - None
 *
 *
 *  EXIT  - None
 *
 */

VOID cmdInitConsole (VOID)
{
    if (fConOutput == FALSE) {
        fConOutput = TRUE;
        nt_init_event_thread ();
        }
    return;
}


/* cmdMapCodePage - Map the Win32 Code page to DOS code page
 */

USHORT cmdMapCodePage (ULONG CodePage)
{
    // Currently We understand US code page only
    if (CodePage == 1252)
        return 437;
    else
        return ((USHORT)CodePage);
}


VOID cmdUpdateCurrentDirectories(BYTE CurDrive)
{
    DWORD cchRemain, cchCurDir;
    CHAR *lpszCurDir;
    BYTE Drive;
    DWORD DriveType;
    CHAR achName[] = "=?:";
    CHAR RootName[] = "?:\\";


    // allocate new space for the new current directories
    lpszzCurrentDirectories = (CHAR*) malloc(MAX_PATH);
    cchCurrentDirectories = 0;
    cchRemain = MAX_PATH;
    lpszCurDir = lpszzCurrentDirectories;
    if (lpszCurDir != NULL) {
        Drive = 0;
        // current directory is the first entry
        achName[1] = CurDrive + 'A';
        cchCurrentDirectories = GetEnvironmentVariable(
                                                        achName,
                                                        lpszCurDir,
                                                        cchRemain
                                                      );

        if (cchCurrentDirectories == 0 || cchCurrentDirectories > MAX_PATH) {
            free(lpszzCurrentDirectories);
            lpszzCurrentDirectories = NULL;
            cchCurrentDirectories = 0;
            return;
        }

        cchRemain -= ++cchCurrentDirectories;
        // we got current directory already. Keep the drive number
        lpszCurDir += cchCurrentDirectories;

        while (Drive < 26) {

            // ignore invalid drives and current drive
            if (Drive != CurDrive) {
                DriveType = demGetPhysicalDriveType(Drive);
                if (DriveType == DRIVE_UNKNOWN) {
                    RootName[0] = (CHAR)('A' + Drive);
                    DriveType = GetDriveTypeOem(RootName);
                }

                if (DriveType != DRIVE_UNKNOWN &&
                    DriveType != DRIVE_NO_ROOT_DIR )
                 {
                    achName[1] = Drive + 'A';
                    cchCurDir = GetEnvironmentVariable(
                                                       achName,
                                                       lpszCurDir,
                                                       cchRemain
                                                       );
                    if(cchCurDir > cchRemain) {
                        lpszCurDir = (CHAR *)realloc(lpszzCurrentDirectories,
                                                     cchRemain + MAX_PATH + cchCurrentDirectories
                                                     );
                        if (lpszCurDir == NULL) {
                            free(lpszzCurrentDirectories);
                            lpszzCurrentDirectories = NULL;
                            cchCurrentDirectories = 0;
                            return;
                        }
                        lpszzCurrentDirectories = lpszCurDir;
                        lpszCurDir += cchCurrentDirectories;
                        cchRemain += MAX_PATH;
                        cchCurDir = GetEnvironmentVariable(
                                                           achName,
                                                           lpszCurDir,
                                                           cchRemain
                                                           );
                    }
                    if (cchCurDir != 0) {
                        // GetEnvironmentVariable doesn't count the NULL char
                        lpszCurDir += ++cchCurDir;
                        cchRemain -= cchCurDir;
                        cchCurrentDirectories += cchCurDir;
                    }
                }
            }
            // next drive
            Drive++;
        }


        lpszCurDir = lpszzCurrentDirectories;
        // need space for the ending NULL and shrink the space if necessary
        lpszzCurrentDirectories = (CHAR *) realloc(lpszCurDir, cchCurrentDirectories + 1);
        if (lpszzCurrentDirectories != NULL && cchCurrentDirectories != 0){
            lpszzCurrentDirectories[cchCurrentDirectories++] = '\0';
            SetVDMCurrentDirectories(cchCurrentDirectories, lpszzCurrentDirectories);
            free(lpszzCurrentDirectories);
            lpszzCurrentDirectories = NULL;
            cchCurrentDirectories = 0;
        }
        else {
            free(lpszCurDir);
            cchCurrentDirectories = 0;
        }

    }
}

/* This SVC function tells command.com, if the VDM was started without an
 * existing console. If so, on finding a TSR, command.com will return
 * back to GetNextVDMCommand, rather than putting its own popup.
 *
 * Entry - None
 *
 * Exit  - Client (AL) = 0 if started with an existing console
 *         Client (AL) = 1 if started with new console
 */

VOID cmdGetStartInfo (VOID)
{
    setAL((BYTE) (DosSessionId ? 1 : 0));
    return;
}

#ifdef DBCS     // this should go to US build also
/* This SVC function changes the window title. This function get called
 * from command.com when TSRs are installed and scs_cmdprompt is off
 * (command.com does its prompt).
 *
 * Entry - Client (AL) = 0, restore bare title
 *         Client (AL) != 1, set new program title,
 *                           DS:SI point to a CRLF terminated program name
 *
 * Exit  - none
 *
 */

 VOID cmdSetWinTitle(VOID)
 {
    static CHAR achCommandPrompt[64] = {'\0'};

    CHAR    achBuf[256], *pch, *pch1;

    if (achCommandPrompt[0] == '\0') {
        if (!LoadString(GetModuleHandle(NULL),
                        IDS_PROMPT,
                        achCommandPrompt,
                        64
                       ))
            strcpy(achCommandPrompt, "Command Prompt");

    }
    if (getAL() == 0)
        SetConsoleTitleA(achCommandPrompt);
    else {
        pch = (CHAR *)GetVDMAddr(getDS(), getSI());
        pch1 = strchr(pch, 0x0d);
        if (pch1 == NULL)
            SetConsoleTitleA(achCommandPrompt);
        else {
            *pch1 = '\0';
            strcpy(achBuf, achCommandPrompt);
            strcat(achBuf, " - ");
            strncat(achBuf, pch,sizeof(achBuf) - strlen(achBuf));
            achBuf[sizeof(achBuf)-1] = 0;
            *pch1 = 0x0d;
            SetConsoleTitleA(achBuf);
        }
    }
 }
#endif // DBCS
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dos\dem\dem.c ===
/*
 *  dem.c - Main Module of DOS Emulation DLL.
 *
 *  Sudeepb 09-Apr-1991 Craeted
 */

#include "io.h"
#include "dem.h"

/* DemInit - DEM Initialiazation routine. (This name may change when DEM is
 *           converted to DLL).
 *
 * Entry
 *      None
 *
 * Exit
 *      None
 */

extern VOID     dempInitLFNSupport(VOID);


CHAR demDebugBuffer [256];

#if DBG
BOOL ToDebugOnF11 = FALSE;
#endif

VOID DemInit (VOID)
{
    DWORD dw;

    // Modify default hard error handling
    // - turn off all file io related popups
    // - keep GP fault popups from system
    //
    SetErrorMode (SEM_FAILCRITICALERRORS | SEM_NOOPENFILEERRORBOX);

    dempInitLFNSupport();

#if DBG
    if (!VDMForWOW) {

#ifndef i386
        if( getenv( "YODA" ) != 0 )
#else
        if( getenv( "DEBUGDOS" ) != 0 )
#endif
            ToDebugOnF11 = TRUE;
    }

#endif
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dos\command\sources.inc ===
!IF 0

Copyright (c) 1989-1991 Microsoft Corporation

Module Name:

    sources.

Abstract:

    This file specifies the target component being built and the list of
    sources files needed to build that component.  Also specifies optional
    compiler switches and libraries that are unique for the component being
    built.

!ENDIF

TARGETNAME=command
TARGETPATH=obj
TARGETTYPE=LIBRARY

SOFTPC_TREE=$(PROJECT_ROOT)\mvdm\softpc.new

INCLUDES=\
    ..\..\..\inc;\
    $(WINDOWS_INC_PATH);\
    $(DS_INC_PATH);\
    $(SOFTPC_TREE)\base\inc;\
    $(SOFTPC_TREE)\host\inc

SOURCES=..\cmd.c      \
        ..\cmddata.c  \
        ..\cmddisp.c  \
        ..\cmdexec.c  \
        ..\cmdexit.c  \
        ..\cmdmisc.c  \
        ..\cmdpif.c   \
        ..\cmdredir.c \
        ..\cmdconf.c  \
        ..\cmdkeyb.c  \
        ..\cmdenv.c

C_DEFINES=-DWIN_32

UMTYPE=console
SOURCES_USED=..\sources.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dos\dem\demdata.c ===
/* demdata.c - All the VDM instance Data.
 *
 * Sudeepb 06-Apr-1991 Created
 */

#include "dem.h"

/** VDM's DTA Address **/
ULONG  UNALIGNED *pulDTALocation; // Address in ntdos where DTA address is kept.


/** VDM's Current PDB **/

PUSHORT pusCurrentPDB;

/** SFT Chain Head **/

PDOSSF pSFTHead = NULL;

//
// address of extended error information in DOS data segment
//

PDEMEXTERR pExtendedError;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dos\dem\dem.h ===
/* dem.h - main include file for dem
 *
 * Modification History
 *
 * Sudeepb 31-Mar-1991 Created
 */

#ifndef _DEMINCLUDED_
#define _DEMINCLUDED_

/*
#define WIN
#define FLAT_32
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>

#define _WINDOWS
#include <windows.h>

*/

#ifdef DOS
#define SIGNALS
#endif

#ifdef OS2_16
#define OS2
#define SIGNALS
#endif

#ifdef OS2_32
#define OS2
#define FLAT_32
#endif

#include <stdarg.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <malloc.h>
#include <process.h>

#ifdef WIN_16
#define WIN
#define API16
#endif

#ifdef WIN_32
#define WIN
#define FLAT_32
#define TRUE_IF_WIN32   1
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <ntdddisk.h>
#else
#define TRUE_IF_WIN32   0
#endif

#ifdef FLAT_32
#ifndef i386
#define ALIGN_32
#else
#define NOALIGN_32
#endif
#endif

#ifdef WIN
#define _WINDOWS
#include <windows.h>
#endif

#ifdef SIGNALS
#include <conio.h>
#include <signal.h>
#endif

#ifdef OS2_32
#include <excpt.h>
#define XCPT_SIGNAL 0xC0010003
#endif
#define SIGHIT(flChk)   ((iSigCheck++ & 0x7FF)?(flSignals & (flChk)):(kbhit(),(flSignals & (flChk))))

#include <oemuni.h>




/** Basic Typedefs of DEM **/

typedef VOID (*PFNSVC)(VOID);

typedef struct _SAVEDEMWORLD {
    USHORT  ax;
    USHORT  bx;
    USHORT  cx;
    USHORT  dx;
    USHORT  ds;
    USHORT  es;
    USHORT  si;
    USHORT  di;
    USHORT  bp;
    ULONG   iSVC;
} SAVEDEMWORLD, *PSAVEDEMWORLD;


typedef struct _DISKINFO {
    WORD   wSectorsPerCluster;
    WORD   wBytesPerSector;
    WORD   wFreeClusters;
    WORD   wTotalClusters;
} DISKINFO, *PDISKINFO;

#include "dosdef.h"
#include "dossvc.h"



/** DEM Externs **/

extern ULONG  UNALIGNED *pulDTALocation;
extern BOOL   VDMForWOW;
extern PVHE   pHardErrPacket;
extern ULONG  CurrentISVC;
extern PCHAR  aSVCNames[];
extern PFNSVC apfnSVC[];
extern USHORT nDrives;
extern PUSHORT pusCurrentPDB;
extern PDEMEXTERR pExtendedError;


#include "demexp.h"
#if DEVL
extern CHAR demDebugBuffer [];
#endif




/** DEM Macros **/

#define GETULONG(hi,lo)     (DWORD)((((int) hi) << 16) + ((int) lo))
#define GETHANDLE(hi,lo)    (HANDLE)(GETULONG(hi,lo))
#define IS_ASCII_PATH_SEPARATOR(ch)     (((ch) == '/') || ((ch) == '\\'))


/** Function Prototypes */

VOID demChgFilePtr      (VOID);
VOID demChMod           (VOID);
VOID demClose           (VOID);
VOID demCloseFCB        (VOID);
VOID demCreate          (VOID);
VOID demCreateFCB       (VOID);
VOID demCreateDir       (VOID);
VOID demCreateNew       (VOID);
VOID demDate16          (VOID);
VOID demDelete          (VOID);
VOID demDeleteDir       (VOID);
VOID demDeleteFCB       (VOID);
VOID demFCBIO           (VOID);
VOID demFileTimes       (VOID);
VOID demFindFirst       (VOID);
VOID demFindFirstFCB    (VOID);
VOID demFindNext        (VOID);
VOID demFindNextFCB     (VOID);
VOID demGetBootDrive    (VOID);
VOID demGetDriveFreeSpace   (VOID);
VOID demGetDrives       (VOID);
VOID demGetFileInfo     (VOID);
VOID demGSetMediaID     (VOID);
VOID demIOCTL           (VOID);
VOID demLoadDos         (VOID);
VOID demLockOper        (VOID);
VOID demOpen            (VOID);
VOID demOpenFCB         (VOID);
VOID demQueryCurrentDir (VOID);
VOID demQueryDate       (VOID);
VOID demQueryTime       (VOID);
VOID demRead            (VOID);
VOID demRename          (VOID);
VOID demRenameFCB       (VOID);
VOID demRetry           (VOID);
VOID demSetCurrentDir   (VOID);
VOID demSetDate         (VOID);
VOID demSetDefaultDrive (VOID);
VOID demSetDTALocation  (VOID);
VOID demSetHardErrorInfo(VOID);
VOID demSetTime         (VOID);
VOID demSetV86KernelAddr(VOID);
VOID demWrite           (VOID);
VOID demGetDriveInfo    (VOID);
VOID demDiskReset       (VOID);
VOID demLoadDosAppSym   (VOID);
VOID demFreeDosAppSym   (VOID);
VOID demEntryDosApp     (VOID);
VOID demDOSDispCall     (VOID);
VOID demDOSDispRet      (VOID);
VOID demOutputString    (VOID);
VOID demInputString     (VOID);
VOID demIsDebug         (VOID);
VOID demTerminatePDB    (VOID);
VOID demExitVDM         (VOID);
VOID demWOWFiles        (VOID);
VOID demGetComputerName (VOID);
VOID demCheckPath       (VOID);
VOID demSystemSymbolOp  (VOID);
VOID demCommit          (VOID);
VOID demClientError         (HANDLE,CHAR);
ULONG demClientErrorEx      (HANDLE,CHAR,BOOL);
VOID demCreateCommon        (ULONG);
BOOL demGetMiscInfo         (HANDLE, LPWORD, LPWORD, LPDWORD);
VOID demFCBCommon           (ULONG);

VOID demIoctlChangeable     (VOID);
VOID demIoctlInvalid        (VOID);
VOID demSaveHardErrInfo     (VOID);
VOID demRestoreHardErrInfo  (VOID);
VOID demAbsRead             (VOID);
VOID demAbsWrite            (VOID);
VOID demIoctlDiskGeneric    (VOID);
VOID demIoctlDiskQuery      (VOID);
VOID demGetDPB              (VOID);
VOID demGetDPBList          (VOID);
VOID demNotYetImplemented   (VOID);
BOOL GetDiskSpaceInformation(CHAR chDrive, PDISKINFO pDiskInfo);
BOOL demGetDiskFreeSpace(BYTE Drive, WORD * BytesPerSector,
                         WORD * SectorsPerCluster, WORD * TotalClusters,
                         WORD * FreeClusters);
BOOL IsCdRomFile            (PSTR pszPath);

BOOL GetMediaId( CHAR DriveNum, PVOLINFO pVolInfo);
VOID demPipeFileDataEOF     (VOID);
VOID demPipeFileEOF         (VOID);
VOID demLFNEntry            (VOID);

VOID demSetDosVarLocation   (VOID);
#ifdef FE_SB /* ConvNwPathToDosPath() */
VOID ConvNwPathToDosPath   (CHAR *,CHAR *,ULONG);
#endif /* FE_SB */

/** Debug Function Prototypes */

#if DBG

VOID demPrintMsg (ULONG iMsg);

#else

#define demPrintMsg(x)

#endif

/* Label functions and constants */
USHORT demDeleteLabel(BYTE Drive);
USHORT demCreateLabel(BYTE Drive, LPSTR szName);
#define DRIVEBYTE   0
#define LABELOFF    3

extern  BOOL cmdPipeFileDataEOF (HANDLE,BOOL *);
extern  BOOL cmdPipeFileEOF(HANDLE);


#endif /* _DEMINCLUDED_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dos\dem\demdasd.c ===
/*
 *  demdasd.c - module for direct disk access related support functions
 *
 *  Williamh 09-Dec-1992 Created
 *  Revision 24-Mar-1993 added fdisk support
 */

#include "io.h"
#include "dem.h"
#include "stdio.h"
#include "windows.h"
#include "demdasd.h"
#include "softpc.h"

PBDS    demBDS;
BYTE    NumberOfFloppy;
BYTE    NumberOfFdisk;


extern  WORD int13h_vector_off, int13h_vector_seg;
extern  WORD int13h_caller_off, int13h_caller_seg;

BPB     StdBpb[MAX_FLOPPY_TYPE] = {
            {512, 2, 1, 2, 112, 2*9*40,  0xFD, 2, 9,  2, 0, 0}, // 360KB
            {512, 1, 1, 2, 224, 2*15*80, 0xF9, 7, 15, 2, 0, 0}, // 1.2MB
            {512, 2, 1, 2, 112, 2*9*80,  0xF9, 3, 9,  2, 0, 0}, // 720KB
            {512, 1, 1, 2, 224, 2*18*80, 0xF0, 9, 18, 2, 0, 0}, // 1.44MB
            {512, 2, 1, 2, 240, 2*36*80, 0xF0, 9, 36, 2, 0, 0}  // 2.88MB
        };

BYTE    FormFactorTable[MAX_FLOPPY_TYPE] = {
                                            FF_360,
                                            FF_120,
                                            FF_720,
                                            FF_144,
                                            FF_288
        };

/* demDasdInit - dem diskette system Initialiazation
 *
 * Entry
 *      none
 *
 *
 * Exit
 *      None
 */
VOID demDasdInit(VOID)
{
    demBDS = NULL;
    NumberOfFloppy = NumberOfFdisk = 0;
    demFloppyInit();
    demFdiskInit();
}
/* demAbsRead - int 25, absolute read
 *
 * Entry
 *      Client (AL) = drive number (0 based)
 *             (DS:BX) = pointer to the buffer to receive the read data
 *                       or pointer to the DISKIO structure
 *             (CX)    = number of sectors to read
 *                      if (0FFFFh) then DS:DX points to DISKIO
 *                          DX contents are discarded
 *             (DX)    = starting sector number
 *
 *
 * Exit
 *      Client (CY) = 0 if operation succeed
 *             (AX) = 0
 *
 *             (CY) = 1 if operation failed
 *             (AX) = error code
 */

VOID demAbsRead (VOID)
{
#if DBG
    if (fShowSVCMsg & DEM_ABSDRD)
        OutputDebugStringOem("DEM: INT 25 Called \n");
#endif
    demAbsReadWrite(FALSE);
}




/* demAbsWrite - int 26, absolute read
 *
 *
 * Entry
 *      Client (AL) = drive number (0 based)
 *             (DS:BX) = pointer to the buffer to receive the read data
 *                       or pointer to the DISKIO structure
 *             (CX)    = number of sectors to read
 *                      if (0FFFFh) then DS:DX points to DISKIO
 *                          DX contents are discarded
 *             (DX)    = starting sector number
 *
 *
 * Exit
 *      Client (CY) = 0 if operation succeed
 *             (AX) = 0
 *
 *             (CY) = 1 if operation failed
 *             (AX) = error code
 */

VOID demAbsWrite(VOID)
{
#if DBG
    if (fShowSVCMsg & DEM_ABSWRT)
        OutputDebugStringOem("DEM: INT 26 Called \n");
#endif
    demAbsReadWrite(TRUE);
}

extern BOOL (*DosWowDoDirectHDPopup)(VOID); // defined in demlfn.c

VOID demAbsReadWrite(BOOL IsWrite)
{
    BYTE    Drive;
    DWORD   LastError;
    DWORD    Sectors;
    DWORD    StartSector;
    PDISKIO DiskIo;
    DWORD    SectorsReturned;
    PBDS    pBDS;
    WORD    BufferOff, BufferSeg;

    Drive = getAL();
    if ((Sectors = getCX()) == 0xFFFF) {
        DiskIo = (PDISKIO) GetVDMAddr(getDS(), getBX());
        Sectors = DiskIo->Sectors;
        StartSector = DiskIo->StartSector;
        BufferOff = DiskIo->BufferOff;
        BufferSeg = DiskIo->BufferSeg;
    }
    else {
        StartSector =   getDX();
        BufferOff = getBX();
        BufferSeg = getDS();
    }
    if ((pBDS = demGetBDS(Drive)) == NULL) {
        if (!demIsDriveFloppy(Drive) && Drive < 26) {
           if (NULL == DosWowDoDirectHDPopup || (*DosWowDoDirectHDPopup)()) {
              host_direct_access_error(NOSUPPORT_HARDDISK);
           }
        }
        setAX(DOS_DRIVE_NOT_READY);
        setCF(1);
        return;
    }
#if DBG
    if (fShowSVCMsg & (DEM_ABSDRD | DEM_ABSWRT)) {
        sprintf(demDebugBuffer, "Drive Number: %d\n", Drive);
        OutputDebugStringOem(demDebugBuffer);
        sprintf(demDebugBuffer, "StartSector: %d\n", StartSector);
        OutputDebugStringOem(demDebugBuffer);
        sprintf(demDebugBuffer, "Total Sectors: %d\n", Sectors);
        OutputDebugStringOem(demDebugBuffer);
        sprintf(demDebugBuffer, "Buffer: %x:%x\n", BufferSeg, BufferOff);
    }
#endif

    if (IsWrite)
        SectorsReturned = demDasdWrite(pBDS,
                                       StartSector,
                                       Sectors,
                                       BufferOff,
                                       BufferSeg
                                       );
    else
        SectorsReturned = demDasdRead(pBDS,
                                      StartSector,
                                      Sectors,
                                      BufferOff,
                                      BufferSeg
                                      );
   if (SectorsReturned != Sectors) {
        LastError = GetLastError();
#if DBG
        if (fShowSVCMsg & (DEM_ABSDRD | DEM_ABSWRT)) {
            sprintf(demDebugBuffer, "dem: AbsRDWR Failed, error=%lx\n", LastError);
            OutputDebugStringOem(demDebugBuffer);
        }
#endif
        setAX(demWinErrorToDosError(LastError));
        setCF(1);
        return;
    }
    setCF(0);
    return;
}

DWORD demDasdRead(
    PBDS pbds,
    DWORD StartSector,
    DWORD Sectors,
    WORD  BufferOff,
    WORD  BufferSeg
)

{

    ULONG   SizeReturned;
    LARGE_INTEGER LargeInteger;
    DWORD   Size;
    DWORD   SectorSize;
    WORD    CurBiosDiskIoOff, CurBiosDiskIoSeg;
    PBYTE   Buffer;

    // if this is the first time we access the BDS or
    // the media has been changed, build the bds -- floppy
    if (!(pbds->Flags & NON_REMOVABLE) &&
        ((pbds->Flags & UNFORMATTED_MEDIA) ||
         !nt_floppy_media_check(pbds->DrivePhys))) {
        if (!demGetBPB(pbds))
            return 0;
    }
    if (StartSector >= pbds->TotalSectors ||
        StartSector + Sectors > pbds->TotalSectors) {
        SetLastError(ERROR_SECTOR_NOT_FOUND);
        return 0 ;
    }
    SectorSize = pbds->bpb.SectorSize;
    LargeInteger.QuadPart = Int32x32To64(Sectors, SectorSize);
    // size must fit in ulong
    if (LargeInteger.HighPart != 0) {
        SetLastError(ERROR_SECTOR_NOT_FOUND);
        return 0;
    }
    Size = LargeInteger.LowPart;

    Buffer = (PBYTE) GetVDMAddr(BufferSeg, BufferOff);

    if (pbds->Flags & NON_REMOVABLE) {
        LargeInteger.QuadPart  = Int32x32To64(StartSector, SectorSize);
        SizeReturned = nt_fdisk_read(
                                    pbds->DrivePhys,
                                    &LargeInteger,
                                    Size,
                                    Buffer
                                    );
    }
    else {
    // floppy need special care beacuse application may hook
    // bios disk interrupt. We dont' do this for hard disks because
    // we don't allow int13 to them
        sas_loadw(0x13*4, &CurBiosDiskIoOff);
        sas_loadw(0x13* 4 + 2, &CurBiosDiskIoSeg);

        if (int13h_vector_off == CurBiosDiskIoOff &&
            int13h_vector_seg == CurBiosDiskIoSeg)

            SizeReturned = nt_floppy_read(
                                          pbds->DrivePhys,
                                          StartSector * SectorSize,
                                          Size,
                                          Buffer
                                          );
        else
            return (demBiosDiskIoRW(pbds,
                                    StartSector,
                                    Sectors,
                                    BufferOff,
                                    BufferSeg,
                                    FALSE
                                    ));
    }
    if (SizeReturned == Size)
        return Sectors;
    else
        return SizeReturned / SectorSize;

}

DWORD demDasdWrite(
    PBDS pbds,
    DWORD StartSector,
    DWORD Sectors,
    WORD  BufferOff,
    WORD  BufferSeg
)


{
    ULONG   SizeReturned;
    LARGE_INTEGER LargeInteger;
    DWORD   Size;
    DWORD   SectorSize;
    WORD    CurBiosDiskIoOff, CurBiosDiskIoSeg;
    PBYTE   Buffer;

    // if this is the first time we access the BDS or
    // the media has been changed, build the bds
    if (!(pbds->Flags & NON_REMOVABLE) &&
        ((pbds->Flags & UNFORMATTED_MEDIA) ||
         !nt_floppy_media_check(pbds->DrivePhys))) {
        if (!demGetBPB(pbds))
            return 0;
    }
    if (StartSector >= pbds->TotalSectors ||
        StartSector + Sectors > pbds->TotalSectors) {
        SetLastError(ERROR_SECTOR_NOT_FOUND);
        return 0 ;
    }
    SectorSize = pbds->bpb.SectorSize;
    LargeInteger.QuadPart  = Int32x32To64(Sectors, SectorSize);
    // size must fit in ulong
    if (LargeInteger.HighPart != 0) {
        SetLastError(ERROR_SECTOR_NOT_FOUND);
        return 0;
    }
    Size = LargeInteger.LowPart;
    Buffer = (PBYTE) GetVDMAddr(BufferSeg, BufferOff);


    if (pbds->Flags & NON_REMOVABLE) {
        LargeInteger.QuadPart  = Int32x32To64(StartSector, SectorSize);
        SizeReturned = nt_fdisk_write(
                                      pbds->DrivePhys,
                                      &LargeInteger,
                                      Size,
                                      Buffer
                                      );
    }
    else {
    // floppy need special care beacuse application may hook
    // bios disk interrupt. We dont' do this for hard disks because
    // we don't allow int13 to them
        sas_loadw(0x13*4, &CurBiosDiskIoOff);
        sas_loadw(0x13* 4 + 2, &CurBiosDiskIoSeg);
        if (int13h_vector_off == CurBiosDiskIoOff &&
            int13h_vector_seg == CurBiosDiskIoSeg)

            SizeReturned = nt_floppy_write(
                                           pbds->DrivePhys,
                                           StartSector * SectorSize,
                                           Size,
                                           Buffer
                                           );
        else
            return(demBiosDiskIoRW(pbds,
                                   StartSector,
                                   Sectors,
                                   BufferOff,
                                   BufferSeg,
                                   TRUE
                                   ));
    }

    if (Size == SizeReturned)
        return Sectors;
    else
        return SizeReturned / SectorSize;


}

BOOL demDasdFormat(PBDS pbds, DWORD Head, DWORD Cylinder, MEDIA_TYPE * Media)
{
    BOOL    Result;

    if (pbds->Flags & NON_REMOVABLE)
        Result = demDasdVerify(pbds, Head, Cylinder);
    else {

       if (*Media == Unknown) {
            *Media = nt_floppy_get_media_type(pbds->DrivePhys,
                                              pbds->Cylinders,
                                              pbds->bpb.TrackSize,
                                              pbds->bpb.Heads
                                              );
            return TRUE;
        }
        else {
            Result = nt_floppy_format(pbds->DrivePhys,
                                      (WORD)Cylinder,
                                      (WORD)Head,
                                      *Media
                                      );
        }
    }
    return (Result);
}


BOOL demDasdVerify(PBDS pbds, DWORD Head, DWORD Cylinder)
{
    DWORD   Size, StartSector;
    LARGE_INTEGER LargeInteger;

    // if floppy, make sure we have up-to-date BPB and a valid media is in
    if (!(pbds->Flags & NON_REMOVABLE)) {
        if (!demGetBPB(pbds))
            return FALSE;
        Size = pbds->bpb.TrackSize * pbds->bpb.SectorSize;
        StartSector = pbds->bpb.TrackSize * (Cylinder * pbds->bpb.Heads + Head) + 1;
        return (nt_floppy_verify(pbds->DrivePhys,
                                 StartSector * pbds->bpb.SectorSize,
                                 Size));
    }
    // hard disk needs special care because of their size
    Size = pbds->bpb.TrackSize * pbds->bpb.SectorSize;
    StartSector = pbds->bpb.TrackSize * (Cylinder *  pbds->bpb.Heads + Head) + 1;
    LargeInteger.QuadPart  = Int32x32To64(StartSector, pbds->bpb.SectorSize);
    return (nt_fdisk_verify(pbds->DrivePhys,
                            &LargeInteger,
                                Size
                                ));
}

PBDS demGetBDS(BYTE DriveLog)
{
    PBDS    pbds;
    pbds = demBDS;
    while (pbds != NULL && pbds->DriveLog != DriveLog)
        pbds = pbds->Next;
    return pbds;
}

BOOL demGetBPB(PBDS pbds)
{
    PBOOTSECTOR pbs;
    BYTE    SectorBuffer[BYTES_PER_SECTOR];

    // when RETURN_FAKE_BPB is set(set by Set Device Parameter IOCTL,
    // the appplication has set a new BPB, we simply return it
    if (!(pbds->Flags & RETURN_FAKE_BPB) &&
        !(pbds->Flags & NON_REMOVABLE) &&
        ((pbds->Flags & UNFORMATTED_MEDIA) || !nt_floppy_media_check(pbds->DrivePhys))
       ) {
        pbds->Flags &= ~(UNFORMATTED_MEDIA);
        nt_floppy_close(pbds->DrivePhys);
        if (nt_floppy_read(pbds->DrivePhys,
                           0,
                           BYTES_PER_SECTOR,
                           SectorBuffer
                           ) != BYTES_PER_SECTOR)
            return FALSE;
        pbs = (PBOOTSECTOR)SectorBuffer;
        if ((pbs->Jump == 0x69 || pbs->Jump == 0xE9 ||
            (pbs->Jump == 0xEB && pbs->Target[1] == 0x90)) &&
            (pbs->bpb.MediaID & 0xF0) == 0xF0) {
            pbds->bpb = pbs->bpb;
            pbds->TotalSectors = (pbs->bpb.Sectors) ? pbs->bpb.Sectors :
                                                      pbs->bpb.BigSectors;
            return TRUE;
        }
        // an unknown media found
        else {
            pbds->Flags |= UNFORMATTED_MEDIA;
            // What should we do here? The diskette has strange boot sector
            // should we guess it or what?
            //
#if DEVL
            if (fShowSVCMsg & (DEM_ABSDRD | DEM_ABSWRT)) {
                sprintf(demDebugBuffer, "Invalid Boot Sector Found\n");
                OutputDebugStringOem(demDebugBuffer);
            }
#endif
            host_direct_access_error(NOSUPPORT_FLOPPY);
            return FALSE;
        }
    }
    return TRUE;
}

DWORD demBiosDiskIoRW(
    PBDS    pbds,
    DWORD   StartSector,
    DWORD   Sectors,
    WORD    BufferOff,
    WORD    BufferSeg,
    BOOL    IsWrite
)
{
    BYTE    CurHead, CurSector, BiosErrorCode;
    WORD    CurTrack, TrackSize, Heads, SectorTrack;
    WORD    AX, BX, CX, DX, ES, CS, IP;
    BYTE    SectorsRead, SectorsToRead;
    WORD    wRetry = 3;

    AX = getAX();
    BX = getBX();
    CX = getCX();
    DX = getDX();
    ES = getES();
    CS = getCS();
    IP = getIP();

    TrackSize = pbds->bpb.TrackSize;
    Heads = pbds->bpb.Heads;
    SectorsRead = 0;
    CurSector = (BYTE) ((StartSector % TrackSize) + 1);
    CurTrack  = (WORD) (StartSector / TrackSize);
    CurHead   = CurTrack  % Heads;
    CurTrack /= Heads;
    SectorsToRead = TrackSize - CurSector + 1;
    while (Sectors != 0) {
        if (Sectors < SectorsToRead)
            SectorsToRead = (BYTE) Sectors;
        // low byte:  bit 6 and 7 are high bits of track,
        //            bit 0 - 5 are sector number
        // high byte: bit 0 - bit 7 ->track lower 8 bits
        SectorTrack = ((CurTrack & 0x300) >> 2) | (CurSector & 0x3f) |
                      ((CurTrack &0xFF) << 8);
        wRetry = 3;
BiosRetry:
        setAH((BYTE) ((IsWrite) ? DISKIO_WRITE : DISKIO_READ));
        setAL(SectorsToRead);
        setBX(BufferOff);
        setES(BufferSeg);
        setDH(CurHead);
        setDL(pbds->DrivePhys);
        setCX(SectorTrack);
        setCS(int13h_caller_seg);
        setIP(int13h_caller_off);
        host_simulate();
        if (getCF() == 0) {
            SectorsRead += SectorsToRead;
            if ((Sectors -= SectorsToRead) == 0)
                break;
            CurSector = 1;
            if (++CurHead == Heads) {
                CurHead = 0;
                CurTrack++;
            }
            SectorsToRead = (BYTE) TrackSize;
        }
        else {
            BiosErrorCode = getAH();
            // reset the disk
            setAH(DISKIO_RESET);
            setDL(pbds->DrivePhys);
            setCS(int13h_caller_seg);
            setIP(int13h_caller_off);
            host_simulate();
            // NOTE that we dont' handle DMA boundary here
            // because it shouldn't happen.  -- the NT disk DD
            // will take care of that.
            if (BiosErrorCode & BIOS_TIME_OUT) {
                SetLastError(ERROR_NO_MEDIA_IN_DRIVE);
                break;
            }
            if (wRetry--)
                goto BiosRetry;
            SetLastError(BiosErrorToNTError(BiosErrorCode));
            break;
        }

    }
    setAX(AX);
    setBX(BX);
    setCX(CX);
    setDX(DX);
    setES(ES);
    setCS(CS);
    setIP(IP);
    return SectorsRead;

}

DWORD   BiosErrorToNTError(BYTE BiosErrorCode)
{
    DWORD NtErrorCode;

    switch (BiosErrorCode) {
        case BIOS_INVALID_FUNCTION:
                NtErrorCode = ERROR_BAD_COMMAND;
                break;
        case BIOS_BAD_ADDRESS_MARK:
                NtErrorCode = ERROR_FLOPPY_ID_MARK_NOT_FOUND;
                break;
        case BIOS_WRITE_PROTECTED:
                NtErrorCode = ERROR_WRITE_PROTECT;
                break;
        case BIOS_BAD_SECTOR:
        case BIOS_CRC_ERROR:
                NtErrorCode = ERROR_SECTOR_NOT_FOUND;
                break;
        case BIOS_DISK_CHANGED:
                NtErrorCode = ERROR_DISK_CHANGE;
                break;
        case BIOS_NO_MEDIA:
                NtErrorCode = ERROR_NO_MEDIA_IN_DRIVE;
                break;
        case BIOS_SEEK_ERROR:
                NtErrorCode = ERROR_SEEK;
                break;
        default:
                NtErrorCode = ERROR_FLOPPY_UNKNOWN_ERROR;
    }
    return NtErrorCode;


}


WORD demWinErrorToDosError(DWORD LastError)
{
    WORD    DosError;

    switch(LastError) {
        case ERROR_SEEK:
                DosError = DOS_SEEK_ERROR;
                break;
        case ERROR_BAD_UNIT:
                DosError = DOS_UNKNOWN_UNIT;
                break;
        case ERROR_NO_MEDIA_IN_DRIVE:
        case ERROR_NOT_READY:
                DosError = DOS_DRIVE_NOT_READY;
                break;
        case ERROR_NOT_DOS_DISK:
                DosError = DOS_UNKNOWN_MEDIA;
                break;
        case ERROR_SECTOR_NOT_FOUND:
        case ERROR_FLOPPY_WRONG_CYLINDER:
                DosError = DOS_SECTOR_NOT_FOUND;
                break;
        case ERROR_READ_FAULT:
                DosError = DOS_READ_FAULT;
                break;
        case ERROR_WRITE_FAULT:
                DosError = DOS_WRITE_FAULT;
                break;
        case ERROR_WRONG_DISK:
        case ERROR_DISK_CHANGE:
        case ERROR_MEDIA_CHANGED:
                DosError = DOS_INVALID_MEDIA_CHANGE;
                break;
        case ERROR_WRITE_PROTECT:
                DosError = DOS_WRITE_PROTECTION;
                break;
        default:
                DosError = DOS_GEN_FAILURE;

    }
    return (DosError);
}


VOID demFdiskInit(VOID)
{
    PBDS    pbds;
    UCHAR   Drive;
    DISK_GEOMETRY  DiskGeometry;
    BPB    bpb;

    Drive = 0;
    do {
          // first, the drive must be valid
          // second, the drive must be a hard disk(fixed)
          // third, the drive must be a FAT
      if (demGetPhysicalDriveType(Drive) == DRIVE_FIXED &&
          nt_fdisk_init(Drive, &bpb, &DiskGeometry)) {
          pbds = (PBDS) malloc(sizeof(BDS));
          if (pbds != NULL) {
              pbds->bpb = bpb;
              pbds->rbpb = bpb;
              pbds->DrivePhys = NumberOfFdisk++;
              pbds->DriveLog = Drive;
              pbds->DriveType = DRIVETYPE_FDISK;
              pbds->FormFactor = FF_FDISK;
              pbds->TotalSectors = (bpb.Sectors) ?
                                        bpb.Sectors :
                                        bpb.BigSectors;
              pbds->Cylinders = (WORD) DiskGeometry.Cylinders.LowPart;
              pbds->Next = demBDS;
              pbds->Flags = NON_REMOVABLE | PHYS_OWNER;
              demBDS = pbds;
           }
      }

   } while (++Drive < 26);

}

VOID demFloppyInit(VOID)
{

    WORD    AX, BX, CX, DX, DI, ES;
    BYTE    i, MyNumberOfFloppy;
    PBDS    pbds;
    BYTE    DriveType;

    AX = getAX();
    BX = getBX();
    CX = getCX();
    DX = getDX();
    DI = getDI();
    ES = getES();


    // reset the floppy system
    setDL(0);
    setAH(DISKIO_RESET);
    diskette_io();

    setDL(0);
    setAH(DISKIO_GETPARAMS);
    diskette_io();
    if (getCF() == 0 && (MyNumberOfFloppy = getDL()) != 0) {
       for(i = 0;  i < MyNumberOfFloppy; i++) {
                setDL(i);
                setAH(DISKIO_GETPARAMS);
                diskette_io();
        if (getCF() == 0) {
                pbds = (PBDS) malloc(sizeof(BDS));
                if (pbds == NULL) {
                    OutputDebugStringOem("dem: not enough memory for BDS\n");
                break;
                }
           pbds->DrivePhys = pbds->DriveLog = i;
           pbds->DriveType = DriveType = getBL() & 0x0F;
           pbds->fd = NULL;
           pbds->Cylinders = getCH() + 1;
           pbds->Sectors = getCL();
           pbds->rbpb = StdBpb[DriveType - 1];
           pbds->TotalSectors = 0;
           pbds->Next = demBDS;
           pbds->FormFactor = FormFactorTable[DriveType - 1];
           demBDS = pbds;
           pbds->Flags = UNFORMATTED_MEDIA | PHYS_OWNER;
           setAH(DISKIO_DRIVETYPE);
           setDL(i);
           diskette_io();
           if (getAH() == 2 )
              pbds->Flags |= HAS_CHANGELINE;
               }
          }
        }


    setAX(AX);
    setBX(BX);
    setCX(CX);
    setDX(DX);
    setDI(DI);
    setES(ES);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dos\dem\demdasd.h ===
#pragma pack(1)

#if defined(NEC_98) 
#define MAX_FLOPPY_TYPE     7
#else  // !NEC_98
#define MAX_FLOPPY_TYPE     5
#endif // !NEC_98
typedef struct A_DISKIO {
    DWORD   StartSector;
    WORD    Sectors;
    WORD    BufferOff;
    WORD    BufferSeg;
} DISKIO, * PDISKIO;

// Bios Parameter Block  (BPB)
typedef struct	A_BPB {
WORD	    SectorSize; 		// sector size in bytes
BYTE	    ClusterSize;		// cluster size in sectors
WORD	    ReservedSectors;		// number of reserved sectors
BYTE	    FATs;			// number of FATs
WORD	    RootDirs;			// number of root directory entries
WORD	    Sectors;			// number of sectors
BYTE	    MediaID;			// media descriptor
WORD	    FATSize;			// FAT size in sectors
WORD	    TrackSize;			// track size in sectors;
WORD	    Heads;			// number of heads
DWORD	    HiddenSectors;		// number of hidden sectors
DWORD	    BigSectors; 		// number of sectors for big media
} BPB, *PBPB;

typedef struct A_DPB {

BYTE	    DriveNum;			// driver numer, 0 - A, 1 -B and so on
BYTE	    Unit;			// unit number of DPB in the driver
WORD	    SectorSize; 		// sector size in bytes
BYTE	    ClusterMask;		// cluster mask
BYTE	    ClusterShift;		// cluster shift count
WORD	    FATSector;			// starting sector of FAT
BYTE	    FATs;			// number of FAT
WORD	    RootDirs;			// number of root directory entries
WORD	    FirstDataSector;		// first sector for the first cluster
WORD	    MaxCluster; 		// number of cluster + 1
WORD	    FATSize;			// FAT size in sectors
WORD	    DirSector;			// starting sector of directory
DWORD	    DriveAddr;			// address of the corresponding driver
BYTE	    MediaID;			// media ID
BYTE	    FirstAccess;		// 0xFF if this DPB is first accessed
struct A_DPB * Next;			// next DPB
WORD	    FreeCluster;		// cluster # of the last allocated
WORD	    FreeClusters;		// number of free clusters, 0xFFFF
					// if unknown
} DPB, * PDPB;


typedef struct A_DEVICEPARAMETERS {
BYTE	    Functions;
BYTE	    DeviceType;
WORD	    DeviceAttrs;
WORD	    Cylinders;
BYTE	    MediaType;
BPB	    bpb;
} DEVICEPARAMETERS, *PDEVICE_PARAMETERS;

#define LABEL_LENGTH		11
#define FILESYSTYPE_LENGTH	8


typedef struct	_DISK_LABEL {
CHAR	    Name[LABEL_LENGTH];
} DISK_LABEL, *PDISK_LABEL;

typedef struct _FILESYSTYPE {
CHAR	    Name[FILESYSTYPE_LENGTH];
} FILESYSTYPE, * PFILESYSTYPE;

// Functions for Get Device Parameters
#define BUILD_DEVICE_BPB		    0x01

// Functions for Set Device Parameters
#define INSTALL_FAKE_BPB	    0x01
#define ONLY_SET_TRACKLAYOUT	    0x02
#define TRACK_LAYOUT_IS_GOOD	    0x04
// Functions for Format Track
#define STATUS_FOR_FORMAT	    0x01
// error code from format status call
#define FORMAT_NO_ROM_SUPPORTED     0x01
#define FORMAT_COMB_NOT_SUPPORTED   0x02


// read and write block
typedef struct _RWBLOCK {
BYTE	Functions;
WORD	Head;
WORD	Cylinder;
WORD	StartSector;
WORD	Sectors;
WORD	BufferOff;
WORD	BufferSeg;
} RW_BLOCK, *PRW_BLOCK;

// format and verify track block
typedef struct _FMT_BLOCK{
BYTE	Functions;
WORD	Head;
WORD	Cylinder;
} FMT_BLOCK, *PFMT_BLOCK;

// media id block
typedef struct _MID {
WORD	    InfoLevel;
DWORD	    SerialNum;
DISK_LABEL  Label;
FILESYSTYPE FileSysType;
} MID, *PMID;

// access flage
typedef struct _ACCESSCTRL {
BYTE	    Functions;
BYTE	    AccessFlag;
} ACCESSCTRL, * PACCESSCTRL;

// bit definitions for flags

// definitions for misc flags
#define NON_REMOVABLE		0x01
#define HAS_CHANGELINE		0x02
#define RETURN_FAKE_BPB		0x04
#define GOOD_TRACKLAYOUT	0x08
#define MULTI_OWNER		0x10
#define PHYS_OWNER		0x20
#define MEDIA_CHANGED		0x40
#define CHANGED_BY_FORMAT	0x100
#define UNFORMATTED_MEDIA	0x200
#define FIRSTACCESS		0x8000

#define EXT_BOOTSECT_SIG	0x29

typedef struct	_BOOTSECTOR {
    BYTE    Jump;
    BYTE    Target[2];
    BYTE    OemName[8];
    BPB     bpb;
    BYTE    DriveNum;
    BYTE    Reserved;
    BYTE    ExtBootSig;
    DWORD   SerialNum;
    DISK_LABEL Label;
    FILESYSTYPE	FileSysType;
} BOOTSECTOR, * PBOOTSECTOR;

// Bios Data Structure	 (BDS)
typedef struct A_BDS {
struct	A_BDS  *Next;			//pointer to next bds
BYTE		DrivePhys;		//physical drive number, 0 based
BYTE		DriveLog;		//logical drive number, 0 based
BPB		bpb;
BYTE		FatSize;
WORD		OpenCount;
BYTE		MediaType;
WORD		Flags;
WORD		Cylinders;
BPB		rbpb;
BYTE		LastTrack;
DWORD		Time;
DWORD		SerialNum;
DISK_LABEL	Label;
FILESYSTYPE	FileSysType;
BYTE		FormFactor;
// the fllowing fields are dedicated for the drive itself
WORD		DriveType;
WORD		Sectors;
HANDLE		fd;
DWORD		TotalSectors;
} BDS, *PBDS;

#pragma pack()

// drive type
#define DRIVETYPE_NULL		0
#define DRIVETYPE_360		1
#define DRIVETYPE_12M		2
#define DRIVETYPE_720		3
#define DRIVETYPE_144		4
#define DRIVETYPE_288		5
#define DRIVETYPE_FDISK 	0xff
// FORM FACTOR

#define     FF_360		0
#define     FF_120		1
#define     FF_720		2
#define     FF_FDISK		5
#define     FF_144		7
#define     FF_288		9
#if defined(NEC_98) 
#define     FF_125              4                    
#define     FF_640              2                    
#endif // NEC_98
#define DOS_DIR_ENTRY_LENGTH		   32
#define DOS_DIR_ENTRY_LENGTH_SHIFT_COUNT    5

// bios diskette i/o functions
#define DISKIO_RESET		0
#define DISKIO_GETSTATUS	1
#define DISKIO_READ		2
#define DISKIO_WRITE		3
#define DISKIO_VERIFY		4
#define DISKIO_FORMAT		5
#define DISKIO_GETPARAMS	8
#define DISKIO_DRIVETYPE	0x15
#define DISKIO_DISKCHANGE	0x16
#define DISKIO_SETTYPE		0x17
#define DISKIO_SETMEDIA 	0x18
#define DISKIO_INVALID		0xff

// Block device generic IOCTL(RAWIO) subfunction code

#define IOCTL_SETDPM	    0x40
#define IOCTL_WRITETRACK    0x41
#define IOCTL_FORMATTRACK   0x42
#define IOCTL_SETMEDIA	    0x46
#define IOCTL_SETACCESS     0x47
#define IOCTL_GETDPM	    0x60
#define IOCTL_READTRACK     0x61
#define IOCTL_VERIFYTRACK   0x62
#define IOCTL_GETMEDIA	    0x66
#define IOCTL_GETACCESS	    0x67
#define IOCTL_SENSEMEDIA    0x68

#define IOCTL_GENERIC_MIN   IOCTL_SETDPM
#define IOCTL_GENERIC_MAX   IOCTL_SENSEMEDIA


// dos error code

#define DOS_WRITE_PROTECTION	0
#define DOS_UNKNOWN_UNIT	1
#define DOS_DRIVE_NOT_READY	2
#define DOS_CRC_ERROR		4
#define DOS_SEEK_ERROR		6
#define DOS_UNKNOWN_MEDIA	7
#define DOS_SECTOR_NOT_FOUND	8
#define DOS_WRITE_FAULT 	10
#define DOS_READ_FAULT		11
#define DOS_GEN_FAILURE 	12
#define DOS_INVALID_MEDIA_CHANGE 15

//BIOS disk io error code
#define BIOS_INVALID_FUNCTION	0x01
#define BIOS_BAD_ADDRESS_MARK	0x02
#define BIOS_WRITE_PROTECTED	0x03
#define BIOS_BAD_SECTOR 	0x04
#define BIOS_DISK_CHANGED	0x05
#define BIOS_DMA_OVERRUN	0x06
#define BIOS_DMA_BOUNDARY	0x08
#define BIOS_NO_MEDIA		0x0C
#define BIOS_CRC_ERROR		0x10
#define BIOS_FDC_ERROR		0x20
#define BIOS_SEEK_ERROR 	0x40
#define BIOS_TIME_OUT		0x80

// dos disk generic io control error code
#define DOS_INVALID_FUNCTION	1
#define DOS_FILE_NOT_FOUND	2
#define DOS_ACCESS_DENIED	5

#define BIOS_DISKCHANGED	6

#if defined(NEC_98) 
#define BYTES_PER_SECTOR       1024                
#else  // !NEC_98
#define BYTES_PER_SECTOR	512
#endif // !NEC_98

VOID demDasdInit(VOID);
VOID demFloppyInit(VOID);
VOID demFdiskInit(VOID);
VOID demAbsReadWrite(BOOL IsWrite);
DWORD demDasdRead(PBDS pbds, DWORD StartSector, DWORD Sectors,
		  WORD BufferOff, WORD BufferSeg);
DWORD demDasdWrite(PBDS pbds, DWORD StartSector, DWORD Sectors,
		   WORD BufferOff, WORD BufferSeg);
BOOL demDasdFormat(PBDS pbds, DWORD Head, DWORD Cylinder, MEDIA_TYPE * Media);
BOOL demDasdVerify(PBDS pbds, DWORD Cylinder, DWORD Head);
PBDS demGetBDS(BYTE Drive);
BOOL demGetBPB(PBDS pbds);
WORD demWinErrorToDosError(DWORD LastError);
VOID diskette_io(VOID);

DWORD BiosErrorToNTError(BYTE BiosError);
DWORD demBiosDiskIoRW(PBDS pbds, DWORD StartSector, DWORD Sectors,
		      WORD BufferOff, WORD BufferSeg, BOOL IsWrite);
VOID	sas_loadw(DWORD, WORD *);

// imported from host floppy support module
BOOL   nt_floppy_close(BYTE drive);
ULONG  nt_floppy_read(BYTE drive, ULONG offset, ULONG size, PBYTE buffer);
ULONG  nt_floppy_write(BYTE drive, ULONG offset, ULONG size, PBYTE buffer);
ULONG  nt_floppy_format(BYTE drive, WORD cylinder, WORD head, MEDIA_TYPE media);
BOOL   nt_floppy_media_check(BYTE drive);
MEDIA_TYPE nt_floppy_get_media_type(BYTE Drive, WORD Cylinders, WORD Sectors, WORD Heads);
BOOL   nt_floppy_verify(BYTE drive, DWORD offset, DWORD size);

BOOL   nt_fdisk_init(BYTE drive, PBPB bpb, PDISK_GEOMETRY disk_geometry);
ULONG  nt_fdisk_read(BYTE drive, PLARGE_INTEGER offset, ULONG size, PBYTE buffer);
ULONG  nt_fdisk_write(BYTE drive,PLARGE_INTEGER offset, ULONG size, PBYTE buffer);
BOOL   nt_fdisk_verify(BYTE drive, PLARGE_INTEGER offset, ULONG size);
BOOL   nt_fdisk_close(BYTE drive);
extern PBDS	demBDS;
extern BYTE	NumberOfFloppy, NumberOfFdisk;

#if defined(NEC_98) 
BOOL demIsDriveFloppy(BYTE DriveLog); // defined in demdasd.c
#else  // !NEC_98
#define demIsDriveFloppy(DriveLog)  (DriveLog < NumberOfFloppy)
#endif // !NEC_98
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\dos\command\cmdredir.c ===
/*  cmdredir.c - SCS routines for redirection
 *
 *
 *  Modification History:
 *
 *  Sudeepb 22-Apr-1992 Created
 */

#include "cmd.h"

#include <cmdsvc.h>
#include <softpc.h>
#include <mvdm.h>
#include <ctype.h>

#define CMDREDIR_DEBUG  1

PPIPE_INPUT   cmdPipeList = NULL;

BOOL cmdCheckCopyForRedirection (pRdrInfo, bIsNTVDMDying)
PREDIRCOMPLETE_INFO pRdrInfo;
BOOL                bIsNTVDMDying;
{
PPIPE_INPUT  pPipe, pPipePrev;
PPIPE_OUTPUT pPipeOut;

    if (pRdrInfo == NULL)
        return TRUE;
    if (pRdrInfo->ri_pPipeStdIn != NULL) {

        //Piping and Pipe list is empty?
        ASSERT(cmdPipeList != NULL);

        // in most cases, we have only one pipe for stdin
        if (pRdrInfo->ri_pPipeStdIn == cmdPipeList){
            pPipe = pRdrInfo->ri_pPipeStdIn;
            cmdPipeList = pPipe->Next;
        }
        // multiple piping
        // search for the right one
        else {
            pPipe = pPipePrev = cmdPipeList;
            while (pPipe != NULL && pPipe != pRdrInfo->ri_pPipeStdIn){
                pPipePrev = pPipe;
                pPipe = pPipe->Next;
            }
            if (pPipe != NULL)
                // remove it from the list
                pPipePrev->Next = pPipe->Next;
        }
        if (pPipe != NULL) {
            // grab the critical section. As soon as we have a
            // a hold on the critical section, it is safe to kill
            // the piping thread because it is in dormant unless
            // it has terminated which is also safe for us.
            EnterCriticalSection(&pPipe->CriticalSection);
            // if the thread is till running, kill it
            if (WaitForSingleObject(pPipe->hThread, 0)) {
                TerminateThread(pPipe->hThread, 0);
                WaitForSingleObject(pPipe->hThread, INFINITE);
            }
            LeaveCriticalSection(&pPipe->CriticalSection);
            CloseHandle(pPipe->hFileWrite);
            CloseHandle(pPipe->hPipe);
            CloseHandle(pPipe->hDataEvent);
            CloseHandle(pPipe->hThread);
            DeleteCriticalSection(&pPipe->CriticalSection);
            DeleteFile(pPipe->pFileName);
            free(pPipe->pFileName);
            free (pPipe);
        }
    }
    // the application is terminating, let the output thread knows
    // about it so it can exit appropriately.
    // the output thread is responsible for clean up
    if (pRdrInfo->ri_pPipeStdOut) {
        // The output thread must wait for the event before
        // it can exit.
        SetEvent((pRdrInfo->ri_pPipeStdOut)->hExitEvent);
        // If NTVDM is terminating, we have to wait for
        // the output thread until it is done, otherwise, the
        // thread may be killed while it still has some
        // output to do.
        // if NTVDM is not terminating, we can not wait for
        // the output thread to exit because a scenario like
        // "dosapp1 | dosapp2"  would deadlock. Also
        // we can not return immediately because
        // our parent process may put up its prompt before our sibling
        // process has a chance to completely display data on
        // its display surface, for example:
        // <cmd> "dosapp | cat32"
        // <cmd>
        // so here, we wait for 1 second to give the output
        // thread a chance to flush all its output.
        WaitForSingleObject(pRdrInfo->ri_hStdOutThread,
                            bIsNTVDMDying ? INFINITE : 1000);
        CloseHandle(pRdrInfo->ri_hStdOutThread);
    }
    if (pRdrInfo->ri_pPipeStdErr) {
        SetEvent((pRdrInfo->ri_pPipeStdErr)->hExitEvent);
        WaitForSingleObject(pRdrInfo->ri_hStdErrThread,
                            bIsNTVDMDying ? INFINITE : 1000);
        CloseHandle(pRdrInfo->ri_hStdErrThread);
    }
    free (pRdrInfo);

    return TRUE;
}


// this function is in cmdenv.c and is used to retrieve temp directory for
// 16-bit apps
BOOL cmdCreateTempEnvironmentVar(
     LPSTR lpszTmpVar,  // temp variable (or just it's name)
     DWORD Length,      // the length of TmpVar or 0
     LPSTR lpszBuffer,  // buffer containing
     DWORD LengthBuffer
);

DWORD cmdGetTempPathConfig(
     DWORD Length,
     LPSTR lpszPath)
{
   CHAR szTempPath[MAX_PATH+4];
   PCHAR pchPath;
   DWORD PathSize = 0;
   BOOL fOk;

   fOk = cmdCreateTempEnvironmentVar("",
                                      0,
                                      szTempPath,
                                      sizeof(szTempPath)/sizeof(szTempPath[0]));
   if (fOk) {
      pchPath = &szTempPath[1]; // the very first char is '='
      PathSize = strlen(pchPath);
      if ((PathSize + 1) < Length) {
         strcpy(lpszPath, pchPath);
      }
   }
   return(PathSize);
}


BOOL cmdCreateTempFile (phTempFile,ppszTempFile)
PHANDLE phTempFile;
PCHAR   *ppszTempFile;
{

PCHAR pszTempPath = NULL;
DWORD TempPathSize;
PCHAR pszTempFileName;
HANDLE hTempFile;
SECURITY_ATTRIBUTES sa;

    pszTempPath = malloc(MAX_PATH + 12);

    if (pszTempPath == NULL)
        return FALSE;

    TempPathSize = cmdGetTempPathConfig(MAX_PATH, pszTempPath);
    if (0 == TempPathSize || MAX_PATH <= TempPathSize) {
       free(pszTempPath);
       return(FALSE);
    }

    // CMDCONF.C depends on the size of this buffer
    if ((pszTempFileName = malloc