h()"
			// AUTOGENERATED
			instrTrace("push NumberBvr ArrayBvr.length()");
			METHOD_CALL_1(
				(IDAArray*)USE_COM(1),
				Length,
				(IDANumber**)RET_COM_ADDR
			);
			FREE_COM;
			PUSH_COM(RET_COM);
			break;
			
		case 250:
			// Execute: "push Behavior TupleBvr.nth(int)"
			// AUTOGENERATED
			instrTrace("push Behavior TupleBvr.nth(int)");
			METHOD_CALL_2(
				(IDATuple*)USE_COM(1),
				Nth,
				USE_LONG(1),
				(IDABehavior**)RET_COM_ADDR
			);
			FREE_LONG(1);
			FREE_COM;
			PUSH_COM(RET_COM);
			break;
			
		case 251:
			// Execute: "push int TupleBvr.length()"
			// AUTOGENERATED
			instrTrace("push int TupleBvr.length()");
			METHOD_CALL_1(
				(IDATuple*)USE_COM(1),
				get_Length,
				RET_LONG_ADDR
			);
			FREE_COM;
			PUSH_LONG(RET_LONG);
			break;
			
		case 252:
			// Execute: "push DXMEvent DXMEvent.snapshotEvent(Behavior)"
			// AUTOGENERATED
			instrTrace("push DXMEvent DXMEvent.snapshotEvent(Behavior)");
			METHOD_CALL_2(
				(IDAEvent*)USE_COM(1),
				Snapshot,
				(IDABehavior*)USE_COM(2),
				(IDAEvent**)RET_COM_ADDR
			);
			FREE_COM;
			FREE_COM;
			PUSH_COM(RET_COM);
			break;
			
		case 253:
			// Execute: "push FontStyleBvr FontStyleBvr.color(ColorBvr)"
			// AUTOGENERATED
			instrTrace("push FontStyleBvr FontStyleBvr.color(ColorBvr)");
			METHOD_CALL_2(
				(IDAFontStyle*)USE_COM(1),
				Color,
				(IDAColor*)USE_COM(2),
				(IDAFontStyle**)RET_COM_ADDR
			);
			FREE_COM;
			FREE_COM;
			PUSH_COM(RET_COM);
			break;
			
		case 255:
			// Switch for 255
			 if (!SUCCEEDED(status = codeStream->readByte(&command))) 
				continue; 
			switch (command)
			{
			case 0:
				// Execute: "push FontStyleBvr FontStyleBvr.size(NumberBvr)"
				// AUTOGENERATED
				instrTrace("push FontStyleBvr FontStyleBvr.size(NumberBvr)");
				METHOD_CALL_2(
					(IDAFontStyle*)USE_COM(1),
					SizeAnim,
					(IDANumber*)USE_COM(2),
					(IDAFontStyle**)RET_COM_ADDR
				);
				FREE_COM;
				FREE_COM;
				PUSH_COM(RET_COM);
				break;
				
			case 1:
				// Execute: "push FontStyleBvr FontStyleBvr.size(double)"
				// AUTOGENERATED
				instrTrace("push FontStyleBvr FontStyleBvr.size(double)");
				METHOD_CALL_2(
					(IDAFontStyle*)USE_COM(1),
					Size,
					USE_DOUBLE(1),
					(IDAFontStyle**)RET_COM_ADDR
				);
				FREE_DOUBLE(1);
				FREE_COM;
				PUSH_COM(RET_COM);
				break;
				
			case 2:
				// Execute: "push FontStyleBvr FontStyleBvr.italic()"
				// AUTOGENERATED
				instrTrace("push FontStyleBvr FontStyleBvr.italic()");
				METHOD_CALL_1(
					(IDAFontStyle*)USE_COM(1),
					Italic,
					(IDAFontStyle**)RET_COM_ADDR
				);
				FREE_COM;
				PUSH_COM(RET_COM);
				break;
				
			case 3:
				// Execute: "push FontStyleBvr FontStyleBvr.bold()"
				// AUTOGENERATED
				instrTrace("push FontStyleBvr FontStyleBvr.bold()");
				METHOD_CALL_1(
					(IDAFontStyle*)USE_COM(1),
					Bold,
					(IDAFontStyle**)RET_COM_ADDR
				);
				FREE_COM;
				PUSH_COM(RET_COM);
				break;
				
			case 4:
				// Execute: "push Vector2Bvr Statics.vector2PolarDegrees(double, double)"
				// AUTOGENERATED
				instrTrace("push Vector2Bvr Statics.vector2PolarDegrees(double, double)");
				METHOD_CALL_3(
					staticStatics,
					Vector2PolarDegrees,
					USE_DOUBLE(1),
					USE_DOUBLE(2),
					(IDAVector2**)RET_COM_ADDR
				);
				FREE_DOUBLE(2);
				PUSH_COM(RET_COM);
				break;
				
			case 5:
				// Execute: "push Transform2Bvr Statics.compose2Array(Transform2Bvr[])"
				// AUTOGENERATED
				instrTrace("push Transform2Bvr Statics.compose2Array(Transform2Bvr[])");
				METHOD_CALL_3(
					staticStatics,
					Compose2ArrayEx,
					USE_COM_ARRAY_LENGTH(1),
					(IDATransform2**)USE_COM_ARRAY(1),
					(IDATransform2**)RET_COM_ADDR
				);
				FREE_COM_ARRAY;
				PUSH_COM(RET_COM);
				break;
				
			case 6:
				// Execute: "push Path2Bvr Statics.arc(double, double, double, double)"
				// AUTOGENERATED
				instrTrace("push Path2Bvr Statics.arc(double, double, double, double)");
				METHOD_CALL_5(
					staticStatics,
					ArcRadians,
					USE_DOUBLE(1),
					USE_DOUBLE(2),
					USE_DOUBLE(3),
					USE_DOUBLE(4),
					(IDAPath2**)RET_COM_ADDR
				);
				FREE_DOUBLE(4);
				PUSH_COM(RET_COM);
				break;
				
			case 7:
				// Execute: "push Path2Bvr Statics.arc(NumberBvr, NumberBvr, NumberBvr, NumberBvr)"
				// AUTOGENERATED
				instrTrace("push Path2Bvr Statics.arc(NumberBvr, NumberBvr, NumberBvr, NumberBvr)");
				METHOD_CALL_5(
					staticStatics,
					ArcRadiansAnim,
					(IDANumber*)USE_COM(1),
					(IDANumber*)USE_COM(2),
					(IDANumber*)USE_COM(3),
					(IDANumber*)USE_COM(4),
					(IDAPath2**)RET_COM_ADDR
				);
				FREE_COM;
				FREE_COM;
				FREE_COM;
				FREE_COM;
				PUSH_COM(RET_COM);
				break;
				
			case 8:
				// Execute: "push Path2Bvr Statics.arcDegrees(double, double, double, double)"
				// AUTOGENERATED
				instrTrace("push Path2Bvr Statics.arcDegrees(double, double, double, double)");
				METHOD_CALL_5(
					staticStatics,
					ArcDegrees,
					USE_DOUBLE(1),
					USE_DOUBLE(2),
					USE_DOUBLE(3),
					USE_DOUBLE(4),
					(IDAPath2**)RET_COM_ADDR
				);
				FREE_DOUBLE(4);
				PUSH_COM(RET_COM);
				break;
				
			case 9:
				// Execute: "push Path2Bvr Statics.concatArray(Path2Bvr[])"
				// AUTOGENERATED
				instrTrace("push Path2Bvr Statics.concatArray(Path2Bvr[])");
				METHOD_CALL_3(
					staticStatics,
					ConcatArrayEx,
					USE_COM_ARRAY_LENGTH(1),
					(IDAPath2**)USE_COM_ARRAY(1),
					(IDAPath2**)RET_COM_ADDR
				);
				FREE_COM_ARRAY;
				PUSH_COM(RET_COM);
				break;
				
			case 10:
				// Execute: "push NumberBvr Statics.slowInSlowOut(NumberBvr, NumberBvr, NumberBvr, NumberBvr)"
				// AUTOGENERATED
				instrTrace("push NumberBvr Statics.slowInSlowOut(NumberBvr, NumberBvr, NumberBvr, NumberBvr)");
				METHOD_CALL_5(
					staticStatics,
					SlowInSlowOutAnim,
					(IDANumber*)USE_COM(1),
					(IDANumber*)USE_COM(2),
					(IDANumber*)USE_COM(3),
					(IDANumber*)USE_COM(4),
					(IDANumber**)RET_COM_ADDR
				);
				FREE_COM;
				FREE_COM;
				FREE_COM;
				FREE_COM;
				PUSH_COM(RET_COM);
				break;
				
			case 11:
				// Execute: "push NumberBvr Statics.slowInSlowOut(double, double, double, double)"
				// AUTOGENERATED
				instrTrace("push NumberBvr Statics.slowInSlowOut(double, double, double, double)");
				METHOD_CALL_5(
					staticStatics,
					SlowInSlowOut,
					USE_DOUBLE(1),
					USE_DOUBLE(2),
					USE_DOUBLE(3),
					USE_DOUBLE(4),
					(IDANumber**)RET_COM_ADDR
				);
				FREE_DOUBLE(4);
				PUSH_COM(RET_COM);
				break;
				
			case 12:
				// Execute: "push Path2Bvr Statics.pie(double, double, double, double)"
				// AUTOGENERATED
				instrTrace("push Path2Bvr Statics.pie(double, double, double, double)");
				METHOD_CALL_5(
					staticStatics,
					PieRadians,
					USE_DOUBLE(1),
					USE_DOUBLE(2),
					USE_DOUBLE(3),
					USE_DOUBLE(4),
					(IDAPath2**)RET_COM_ADDR
				);
				FREE_DOUBLE(4);
				PUSH_COM(RET_COM);
				break;
				
			case 13:
				// Execute: "push Path2Bvr Statics.pie(NumberBvr, NumberBvr, NumberBvr, NumberBvr)"
				// AUTOGENERATED
				instrTrace("push Path2Bvr Statics.pie(NumberBvr, NumberBvr, NumberBvr, NumberBvr)");
				METHOD_CALL_5(
					staticStatics,
					PieRadiansAnim,
					(IDANumber*)USE_COM(1),
					(IDANumber*)USE_COM(2),
					(IDANumber*)USE_COM(3),
					(IDANumber*)USE_COM(4),
					(IDAPath2**)RET_COM_ADDR
				);
				FREE_COM;
				FREE_COM;
				FREE_COM;
				FREE_COM;
				PUSH_COM(RET_COM);
				break;
				
			case 14:
				// Execute: "push Path2Bvr Statics.ray(Point2Bvr)"
				// AUTOGENERATED
				instrTrace("push Path2Bvr Statics.ray(Point2Bvr)");
				METHOD_CALL_2(
					staticStatics,
					Ray,
					(IDAPoint2*)USE_COM(1),
					(IDAPath2**)RET_COM_ADDR
				);
				FREE_COM;
				PUSH_COM(RET_COM);
				break;
				
			case 15:
				// Execute: "push Transform2Bvr Statics.followPathAngleUpright(Path2Bvr, NumberBvr)"
				// AUTOGENERATED
				instrTrace("push Transform2Bvr Statics.followPathAngleUpright(Path2Bvr, NumberBvr)");
				METHOD_CALL_3(
					staticStatics,
					FollowPathAngleUprightEval,
					(IDAPath2*)USE_COM(1),
					(IDANumber*)USE_COM(2),
					(IDATransform2**)RET_COM_ADDR
				);
				FREE_COM;
				FREE_COM;
				PUSH_COM(RET_COM);
				break;
				
			case 16:
				// Execute: "push Transform2Bvr Statics.followPath(Path2Bvr, double)"
				// AUTOGENERATED
				instrTrace("push Transform2Bvr Statics.followPath(Path2Bvr, double)");
				METHOD_CALL_3(
					staticStatics,
					FollowPath,
					(IDAPath2*)USE_COM(1),
					USE_DOUBLE(1),
					(IDATransform2**)RET_COM_ADDR
				);
				FREE_DOUBLE(1);
				FREE_COM;
				PUSH_COM(RET_COM);
				break;
				
			case 17:
				// Execute: "push Transform2Bvr Statics.followPath(Path2Bvr, NumberBvr)"
				// AUTOGENERATED
				instrTrace("push Transform2Bvr Statics.followPath(Path2Bvr, NumberBvr)");
				METHOD_CALL_3(
					staticStatics,
					FollowPathEval,
					(IDAPath2*)USE_COM(1),
					(IDANumber*)USE_COM(2),
					(IDATransform2**)RET_COM_ADDR
				);
				FREE_COM;
				FREE_COM;
				PUSH_COM(RET_COM);
				break;
				
			case 18:
				// Execute: "push ImageBvr Statics.gradientPolygon(Point2Bvr[], ColorBvr[])"
				// AUTOGENERATED
				instrTrace("push ImageBvr Statics.gradientPolygon(Point2Bvr[], ColorBvr[])");
				METHOD_CALL_5(
					staticStatics,
					GradientPolygonEx,
					USE_COM_ARRAY_LENGTH(1),
					(IDAPoint2**)USE_COM_ARRAY(1),
					USE_COM_ARRAY_LENGTH(2),
					(IDAColor**)USE_COM_ARRAY(2),
					(IDAImage**)RET_COM_ADDR
				);
				FREE_COM_ARRAY;
				FREE_COM_ARRAY;
				PUSH_COM(RET_COM);
				break;
				
			case 19:
				// Execute: "push StringBvr Statics.toBvr(java.lang.String)"
				// AUTOGENERATED
				instrTrace("push StringBvr Statics.toBvr(java.lang.String)");
				METHOD_CALL_2(
					staticStatics,
					DAString,
					USE_STRING(1),
					(IDAString**)RET_COM_ADDR
				);
				FREE_STRING;
				PUSH_COM(RET_COM);
				break;
				
			case 20:
				// Execute: "push Path2Bvr Statics.cubicBSplinePath(Point2Bvr[], NumberBvr[])"
				// AUTOGENERATED
				instrTrace("push Path2Bvr Statics.cubicBSplinePath(Point2Bvr[], NumberBvr[])");
				METHOD_CALL_5(
					staticStatics,
					CubicBSplinePathEx,
					USE_COM_ARRAY_LENGTH(1),
					(IDAPoint2**)USE_COM_ARRAY(1),
					USE_COM_ARRAY_LENGTH(2),
					(IDANumber**)USE_COM_ARRAY(2),
					(IDAPath2**)RET_COM_ADDR
				);
				FREE_COM_ARRAY;
				FREE_COM_ARRAY;
				PUSH_COM(RET_COM);
				break;
				
			case 21:
				// Execute: "push ImageBvr Statics.stringImage(StringBvr, FontStyleBvr)"
				// AUTOGENERATED
				instrTrace("push ImageBvr Statics.stringImage(StringBvr, FontStyleBvr)");
				METHOD_CALL_3(
					staticStatics,
					StringImageAnim,
					(IDAString*)USE_COM(1),
					(IDAFontStyle*)USE_COM(2),
					(IDAImage**)RET_COM_ADDR
				);
				FREE_COM;
				FREE_COM;
				PUSH_COM(RET_COM);
				break;
				
			case 22:
				// Execute: "push ImageBvr Statics.stringImage(java.lang.String, FontStyleBvr)"
				// AUTOGENERATED
				instrTrace("push ImageBvr Statics.stringImage(java.lang.String, FontStyleBvr)");
				METHOD_CALL_3(
					staticStatics,
					StringImage,
					USE_STRING(1),
					(IDAFontStyle*)USE_COM(1),
					(IDAImage**)RET_COM_ADDR
				);
				FREE_STRING;
				FREE_COM;
				PUSH_COM(RET_COM);
				break;
				
			case 23:
				// Execute: "push Path2Bvr Statics.pieDegrees(double, double, double, double)"
				// AUTOGENERATED
				instrTrace("push Path2Bvr Statics.pieDegrees(double, double, double, double)");
				METHOD_CALL_5(
					staticStatics,
					PieDegrees,
					USE_DOUBLE(1),
					USE_DOUBLE(2),
					USE_DOUBLE(3),
					USE_DOUBLE(4),
					(IDAPath2**)RET_COM_ADDR
				);
				FREE_DOUBLE(4);
				PUSH_COM(RET_COM);
				break;
				
			case 24:
				// Execute: "push ImageBvr Statics.gradientHorizontal(ColorBvr, ColorBvr, double)"
				// AUTOGENERATED
				instrTrace("push ImageBvr Statics.gradientHorizontal(ColorBvr, ColorBvr, double)");
				METHOD_CALL_4(
					staticStatics,
					GradientHorizontal,
					(IDAColor*)USE_COM(1),
					(IDAColor*)USE_COM(2),
					USE_DOUBLE(1),
					(IDAImage**)RET_COM_ADDR
				);
				FREE_DOUBLE(1);
				FREE_COM;
				FREE_COM;
				PUSH_COM(RET_COM);
				break;
				
			case 25:
				// Execute: "push ImageBvr Statics.gradientHorizontal(ColorBvr, ColorBvr, NumberBvr)"
				// AUTOGENERATED
				instrTrace("push ImageBvr Statics.gradientHorizontal(ColorBvr, ColorBvr, NumberBvr)");
				METHOD_CALL_4(
					staticStatics,
					GradientHorizontalAnim,
					(IDAColor*)USE_COM(1),
					(IDAColor*)USE_COM(2),
					(IDANumber*)USE_COM(3),
					(IDAImage**)RET_COM_ADDR
				);
				FREE_COM;
				FREE_COM;
				FREE_COM;
				PUSH_COM(RET_COM);
				break;
				
			case 26:
				// Execute: "push ImageBvr Statics.hatchHorizontal(ColorBvr, double)"
				// AUTOGENERATED
				instrTrace("push ImageBvr Statics.hatchHorizontal(ColorBvr, double)");
				METHOD_CALL_3(
					staticStatics,
					HatchHorizontal,
					(IDAColor*)USE_COM(1),
					USE_DOUBLE(1),
					(IDAImage**)RET_COM_ADDR
				);
				FREE_DOUBLE(1);
				FREE_COM;
				PUSH_COM(RET_COM);
				break;
				
			case 27:
				// Execute: "push ImageBvr Statics.hatchHorizontal(ColorBvr, NumberBvr)"
				// AUTOGENERATED
				instrTrace("push ImageBvr Statics.hatchHorizontal(ColorBvr, NumberBvr)");
				METHOD_CALL_3(
					staticStatics,
					HatchHorizontalAnim,
					(IDAColor*)USE_COM(1),
					(IDANumber*)USE_COM(2),
					(IDAImage**)RET_COM_ADDR
				);
				FREE_COM;
				FREE_COM;
				PUSH_COM(RET_COM);
				break;
				
			case 28:
				// Execute: "push FontStyleBvr Statics.font(StringBvr, NumberBvr, ColorBvr)"
				// AUTOGENERATED
				instrTrace("push FontStyleBvr Statics.font(StringBvr, NumberBvr, ColorBvr)");
				METHOD_CALL_4(
					staticStatics,
					FontAnim,
					(IDAString*)USE_COM(1),
					(IDANumber*)USE_COM(2),
					(IDAColor*)USE_COM(3),
					(IDAFontStyle**)RET_COM_ADDR
				);
				FREE_COM;
				FREE_COM;
				FREE_COM;
				PUSH_COM(RET_COM);
				break;
				
			case 29:
				// Execute: "push FontStyleBvr Statics.font(java.lang.String, double, ColorBvr)"
				// AUTOGENERATED
				instrTrace("push FontStyleBvr Statics.font(java.lang.String, double, ColorBvr)");
				METHOD_CALL_4(
					staticStatics,
					Font,
					USE_STRING(1),
					USE_DOUBLE(1),
					(IDAColor*)USE_COM(1),
					(IDAFontStyle**)RET_COM_ADDR
				);
				FREE_DOUBLE(1);
				FREE_STRING;
				FREE_COM;
				PUSH_COM(RET_COM);
				break;
				
			case 30:
				// Execute: "push Transform3Bvr Statics.translateRate(double, double, double)"
				// AUTOGENERATED
				instrTrace("push Transform3Bvr Statics.translateRate(double, double, double)");
				METHOD_CALL_4(
					staticStatics,
					Translate3Rate,
					USE_DOUBLE(1),
					USE_DOUBLE(2),
					USE_DOUBLE(3),
					(IDATransform3**)RET_COM_ADDR
				);
				FREE_DOUBLE(3);
				PUSH_COM(RET_COM);
				break;
				
			case 31:
				// Execute: "push Transform3Bvr Statics.scaleRate(double, double, double)"
				// AUTOGENERATED
				instrTrace("push Transform3Bvr Statics.scaleRate(double, double, double)");
				METHOD_CALL_4(
					staticStatics,
					Scale3Rate,
					USE_DOUBLE(1),
					USE_DOUBLE(2),
					USE_DOUBLE(3),
					(IDATransform3**)RET_COM_ADDR
				);
				FREE_DOUBLE(3);
				PUSH_COM(RET_COM);
				break;
				
			case 32:
				// Execute: "push Transform3Bvr Statics.rotateRate(Vector3Bvr, double)"
				// AUTOGENERATED
				instrTrace("push Transform3Bvr Statics.rotateRate(Vector3Bvr, double)");
				METHOD_CALL_3(
					staticStatics,
					Rotate3,
					(IDAVector3*)USE_COM(1),
					USE_DOUBLE(1),
					(IDATransform3**)RET_COM_ADDR
				);
				FREE_DOUBLE(1);
				FREE_COM;
				PUSH_COM(RET_COM);
				break;
				
			case 33:
				// Execute: "push Transform2Bvr Statics.translateRate(double, double)"
				// AUTOGENERATED
				instrTrace("push Transform2Bvr Statics.translateRate(double, double)");
				METHOD_CALL_3(
					staticStatics,
					Translate2Rate,
					USE_DOUBLE(1),
					USE_DOUBLE(2),
					(IDATransform2**)RET_COM_ADDR
				);
				FREE_DOUBLE(2);
				PUSH_COM(RET_COM);
				break;
				
			case 34:
				// Execute: "push Transform2Bvr Statics.scaleRate(double, double)"
				// AUTOGENERATED
				instrTrace("push Transform2Bvr Statics.scaleRate(double, double)");
				METHOD_CALL_3(
					staticStatics,
					Scale2Rate,
					USE_DOUBLE(1),
					USE_DOUBLE(2),
					(IDATransform2**)RET_COM_ADDR
				);
				FREE_DOUBLE(2);
				PUSH_COM(RET_COM);
				break;
				
			case 35:
				// Execute: "push Transform2Bvr Statics.rotateRate(double)"
				// AUTOGENERATED
				instrTrace("push Transform2Bvr Statics.rotateRate(double)");
				METHOD_CALL_2(
					staticStatics,
					Rotate2Rate,
					USE_DOUBLE(1),
					(IDATransform2**)RET_COM_ADDR
				);
				FREE_DOUBLE(1);
				PUSH_COM(RET_COM);
				break;
				
			case 36:
				// Execute: "push GeometryBvr Statics.soundSource(SoundBvr)"
				// AUTOGENERATED
				instrTrace("push GeometryBvr Statics.soundSource(SoundBvr)");
				METHOD_CALL_2(
					staticStatics,
					SoundSource,
					(IDASound*)USE_COM(1),
					(IDAGeometry**)RET_COM_ADDR
				);
				FREE_COM;
				PUSH_COM(RET_COM);
				break;
				
			case 37:
				// Execute: "push GeometryBvr Statics.spotLight(NumberBvr, NumberBvr)"
				// AUTOGENERATED
				instrTrace("push GeometryBvr Statics.spotLight(NumberBvr, NumberBvr)");
				METHOD_CALL_3(
					staticStatics,
					SpotLightAnim,
					(IDANumber*)USE_COM(1),
					(IDANumber*)USE_COM(2),
					(IDAGeometry**)RET_COM_ADDR
				);
				FREE_COM;
				FREE_COM;
				PUSH_COM(RET_COM);
				break;
				
			case 38:
				// Execute: "push GeometryBvr Statics.spotLight(NumberBvr, double)"
				// AUTOGENERATED
				instrTrace("push GeometryBvr Statics.spotLight(NumberBvr, double)");
				METHOD_CALL_3(
					staticStatics,
					SpotLight,
					(IDANumber*)USE_COM(1),
					USE_DOUBLE(1),
					(IDAGeometry**)RET_COM_ADDR
				);
				FREE_DOUBLE(1);
				FREE_COM;
				PUSH_COM(RET_COM);
				break;
				
			case 39:
				// Execute: "push Transform3Bvr Statics.compose3Array(Transform3Bvr[])"
				// AUTOGENERATED
				instrTrace("push Transform3Bvr Statics.compose3Array(Transform3Bvr[])");
				METHOD_CALL_3(
					staticStatics,
					Compose3ArrayEx,
					USE_COM_ARRAY_LENGTH(1),
					(IDATransform3**)USE_COM_ARRAY(1),
					(IDATransform3**)RET_COM_ADDR
				);
				FREE_COM_ARRAY;
				PUSH_COM(RET_COM);
				break;
				
			case 40:
				// Execute: "push Path2Bvr Statics.concat(Path2Bvr, Path2Bvr)"
				// AUTOGENERATED
				instrTrace("push Path2Bvr Statics.concat(Path2Bvr, Path2Bvr)");
				METHOD_CALL_3(
					staticStatics,
					Concat,
					(IDAPath2*)USE_COM(1),
					(IDAPath2*)USE_COM(2),
					(IDAPath2**)RET_COM_ADDR
				);
				FREE_COM;
				FREE_COM;
				PUSH_COM(RET_COM);
				break;
				
			case 41:
				// Execute: "push MontageBvr Statics.imageMontage(ImageBvr, double)"
				// AUTOGENERATED
				instrTrace("push MontageBvr Statics.imageMontage(ImageBvr, double)");
				METHOD_CALL_3(
					staticStatics,
					ImageMontage,
					(IDAImage*)USE_COM(1),
					USE_DOUBLE(1),
					(IDAMontage**)RET_COM_ADDR
				);
				FREE_DOUBLE(1);
				FREE_COM;
				PUSH_COM(RET_COM);
				break;
				
			case 42:
				// Execute: "push MontageBvr Statics.imageMontage(ImageBvr, NumberBvr)"
				// AUTOGENERATED
				instrTrace("push MontageBvr Statics.imageMontage(ImageBvr, NumberBvr)");
				METHOD_CALL_3(
					staticStatics,
					ImageMontageAnim,
					(IDAImage*)USE_COM(1),
					(IDANumber*)USE_COM(2),
					(IDAMontage**)RET_COM_ADDR
				);
				FREE_COM;
				FREE_COM;
				PUSH_COM(RET_COM);
				break;
				
			case 43:
				// Execute: "push ImageBvr ImageBvr.clip(MatteBvr)"
				// AUTOGENERATED
				instrTrace("push ImageBvr ImageBvr.clip(MatteBvr)");
				METHOD_CALL_2(
					(IDAImage*)USE_COM(1),
					Clip,
					(IDAMatte*)USE_COM(2),
					(IDAImage**)RET_COM_ADDR
				);
				FREE_COM;
				FREE_COM;
				PUSH_COM(RET_COM);
				break;
				
			case 44:
				// Execute: "push NumberBvr Statics.distanceSquared(Point2Bvr, Point2Bvr)"
				// AUTOGENERATED
				instrTrace("push NumberBvr Statics.distanceSquared(Point2Bvr, Point2Bvr)");
				METHOD_CALL_3(
					staticStatics,
					DistanceSquaredPoint2,
					(IDAPoint2*)USE_COM(1),
					(IDAPoint2*)USE_COM(2),
					(IDANumber**)RET_COM_ADDR
				);
				FREE_COM;
				FREE_COM;
				PUSH_COM(RET_COM);
				break;
				
			case 45:
				// Execute: "push NumberBvr Statics.distanceSquared(Point3Bvr, Point3Bvr)"
				// AUTOGENERATED
				instrTrace("push NumberBvr Statics.distanceSquared(Point3Bvr, Point3Bvr)");
				METHOD_CALL_3(
					staticStatics,
					DistanceSquaredPoint3,
					(IDAPoint3*)USE_COM(1),
					(IDAPoint3*)USE_COM(2),
					(IDANumber**)RET_COM_ADDR
				);
				FREE_COM;
				FREE_COM;
				PUSH_COM(RET_COM);
				break;
				
			case 46:
				// Execute: "push Transform3Bvr Statics.xShearRate(double, double)"
				// AUTOGENERATED
				instrTrace("push Transform3Bvr Statics.xShearRate(double, double)");
				METHOD_CALL_3(
					staticStatics,
					XShear3Rate,
					USE_DOUBLE(1),
					USE_DOUBLE(2),
					(IDATransform3**)RET_COM_ADDR
				);
				FREE_DOUBLE(2);
				PUSH_COM(RET_COM);
				break;
				
			case 47:
				// Execute: "push Transform3Bvr Statics.zShearRate(double, double)"
				// AUTOGENERATED
				instrTrace("push Transform3Bvr Statics.zShearRate(double, double)");
				METHOD_CALL_3(
					staticStatics,
					ZShear3Rate,
					USE_DOUBLE(1),
					USE_DOUBLE(2),
					(IDATransform3**)RET_COM_ADDR
				);
				FREE_DOUBLE(2);
				PUSH_COM(RET_COM);
				break;
				
			case 48:
				// Execute: "push Transform2Bvr Statics.xShearRate(double)"
				// AUTOGENERATED
				instrTrace("push Transform2Bvr Statics.xShearRate(double)");
				METHOD_CALL_2(
					staticStatics,
					XShear2Rate,
					USE_DOUBLE(1),
					(IDATransform2**)RET_COM_ADDR
				);
				FREE_DOUBLE(1);
				PUSH_COM(RET_COM);
				break;
				
			case 49:
				// Execute: "push BooleanBvr Statics.eq(NumberBvr, NumberBvr)"
				// AUTOGENERATED
				instrTrace("push BooleanBvr Statics.eq(NumberBvr, NumberBvr)");
				METHOD_CALL_3(
					staticStatics,
					EQ,
					(IDANumber*)USE_COM(1),
					(IDANumber*)USE_COM(2),
					(IDABoolean**)RET_COM_ADDR
				);
				FREE_COM;
				FREE_COM;
				PUSH_COM(RET_COM);
				break;
				
			case 50:
				// Execute: "push Transform3Bvr Statics.rotateDegrees(Vector3Bvr, double)"
				// AUTOGENERATED
				instrTrace("push Transform3Bvr Statics.rotateDegrees(Vector3Bvr, double)");
				METHOD_CALL_3(
					staticStatics,
					Rotate3Degrees,
					(IDAVector3*)USE_COM(1),
					USE_DOUBLE(1),
					(IDATransform3**)RET_COM_ADDR
				);
				FREE_DOUBLE(1);
				FREE_COM;
				PUSH_COM(RET_COM);
				break;
				
			case 51:
				// Execute: "push Transform3Bvr Statics.rotateRateDegrees(Vector3Bvr, double)"
				// AUTOGENERATED
				instrTrace("push Transform3Bvr Statics.rotateRateDegrees(Vector3Bvr, double)");
				METHOD_CALL_3(
					staticStatics,
					Rotate3RateDegrees,
					(IDAVector3*)USE_COM(1),
					USE_DOUBLE(1),
					(IDATransform3**)RET_COM_ADDR
				);
				FREE_DOUBLE(1);
				FREE_COM;
				PUSH_COM(RET_COM);
				break;
				
			case 52:
				// Execute: "push Transform2Bvr Statics.rotateDegrees(double)"
				// AUTOGENERATED
				instrTrace("push Transform2Bvr Statics.rotateDegrees(double)");
				METHOD_CALL_2(
					staticStatics,
					Rotate2Degrees,
					USE_DOUBLE(1),
					(IDATransform2**)RET_COM_ADDR
				);
				FREE_DOUBLE(1);
				PUSH_COM(RET_COM);
				break;
				
			case 53:
				// Execute: "push Transform2Bvr Statics.rotateRateDegrees(double)"
				// AUTOGENERATED
				instrTrace("push Transform2Bvr Statics.rotateRateDegrees(double)");
				METHOD_CALL_2(
					staticStatics,
					Rotate2RateDegrees,
					USE_DOUBLE(1),
					(IDATransform2**)RET_COM_ADDR
				);
				FREE_DOUBLE(1);
				PUSH_COM(RET_COM);
				break;
				
			case 54:
				// Execute: "push Path2Bvr Statics.rect(double, double)"
				// AUTOGENERATED
				instrTrace("push Path2Bvr Statics.rect(double, double)");
				METHOD_CALL_3(
					staticStatics,
					Rect,
					USE_DOUBLE(1),
					USE_DOUBLE(2),
					(IDAPath2**)RET_COM_ADDR
				);
				FREE_DOUBLE(2);
				PUSH_COM(RET_COM);
				break;
				
			case 55:
				// Execute: "push Path2Bvr Statics.rect(NumberBvr, NumberBvr)"
				// AUTOGENERATED
				instrTrace("push Path2Bvr Statics.rect(NumberBvr, NumberBvr)");
				METHOD_CALL_3(
					staticStatics,
					RectAnim,
					(IDANumber*)USE_COM(1),
					(IDANumber*)USE_COM(2),
					(IDAPath2**)RET_COM_ADDR
				);
				FREE_COM;
				FREE_COM;
				PUSH_COM(RET_COM);
				break;
				
			case 56:
				// Execute: "push ImageBvr Statics.radialGradientRegularPoly(ColorBvr, ColorBvr, double, double)"
				// AUTOGENERATED
				instrTrace("push ImageBvr Statics.radialGradientRegularPoly(ColorBvr, ColorBvr, double, double)");
				METHOD_CALL_5(
					staticStatics,
					RadialGradientRegularPoly,
					(IDAColor*)USE_COM(1),
					(IDAColor*)USE_COM(2),
					USE_DOUBLE(1),
					USE_DOUBLE(2),
					(IDAImage**)RET_COM_ADDR
				);
				FREE_DOUBLE(2);
				FREE_COM;
				FREE_COM;
				PUSH_COM(RET_COM);
				break;
				
			case 57:
				// Execute: "push ImageBvr Statics.radialGradientRegularPoly(ColorBvr, ColorBvr, NumberBvr, NumberBvr)"
				// AUTOGENERATED
				instrTrace("push ImageBvr Statics.radialGradientRegularPoly(ColorBvr, ColorBvr, NumberBvr, NumberBvr)");
				METHOD_CALL_5(
					staticStatics,
					RadialGradientRegularPolyAnim,
					(IDAColor*)USE_COM(1),
					(IDAColor*)USE_COM(2),
					(IDANumber*)USE_COM(3),
					(IDANumber*)USE_COM(4),
					(IDAImage**)RET_COM_ADDR
				);
				FREE_COM;
				FREE_COM;
				FREE_COM;
				FREE_COM;
				PUSH_COM(RET_COM);
				break;
				
			case 58:
				// Execute: "push MatteBvr Statics.intersect(MatteBvr, MatteBvr)"
				// AUTOGENERATED
				instrTrace("push MatteBvr Statics.intersect(MatteBvr, MatteBvr)");
				METHOD_CALL_3(
					staticStatics,
					IntersectMatte,
					(IDAMatte*)USE_COM(1),
					(IDAMatte*)USE_COM(2),
					(IDAMatte**)RET_COM_ADDR
				);
				FREE_COM;
				FREE_COM;
				PUSH_COM(RET_COM);
				break;
				
			case 59:
				// Execute: "push Path2Bvr Statics.roundRect(double, double, double, double)"
				// AUTOGENERATED
				instrTrace("push Path2Bvr Statics.roundRect(double, double, double, double)");
				METHOD_CALL_5(
					staticStatics,
					RoundRect,
					USE_DOUBLE(1),
					USE_DOUBLE(2),
					USE_DOUBLE(3),
					USE_DOUBLE(4),
					(IDAPath2**)RET_COM_ADDR
				);
				FREE_DOUBLE(4);
				PUSH_COM(RET_COM);
				break;
				
			case 60:
				// Execute: "push Path2Bvr Statics.roundRect(NumberBvr, NumberBvr, NumberBvr, NumberBvr)"
				// AUTOGENERATED
				instrTrace("push Path2Bvr Statics.roundRect(NumberBvr, NumberBvr, NumberBvr, NumberBvr)");
				METHOD_CALL_5(
					staticStatics,
					RoundRectAnim,
					(IDANumber*)USE_COM(1),
					(IDANumber*)USE_COM(2),
					(IDANumber*)USE_COM(3),
					(IDANumber*)USE_COM(4),
					(IDAPath2**)RET_COM_ADDR
				);
				FREE_COM;
				FREE_COM;
				FREE_COM;
				FREE_COM;
				PUSH_COM(RET_COM);
				break;
				
			case 61:
				// Execute: "push Transform2Bvr Statics.followPathAngle(Path2Bvr, double)"
				// AUTOGENERATED
				instrTrace("push Transform2Bvr Statics.followPathAngle(Path2Bvr, double)");
				METHOD_CALL_3(
					staticStatics,
					FollowPathAngle,
					(IDAPath2*)USE_COM(1),
					USE_DOUBLE(1),
					(IDATransform2**)RET_COM_ADDR
				);
				FREE_DOUBLE(1);
				FREE_COM;
				PUSH_COM(RET_COM);
				break;
				
			case 62:
				// Execute: "push MatteBvr Statics.textMatte(StringBvr, FontStyleBvr)"
				// AUTOGENERATED
				instrTrace("push MatteBvr Statics.textMatte(StringBvr, FontStyleBvr)");
				METHOD_CALL_3(
					staticStatics,
					TextMatte,
					(IDAString*)USE_COM(1),
					(IDAFontStyle*)USE_COM(2),
					(IDAMatte**)RET_COM_ADDR
				);
				FREE_COM;
				FREE_COM;
				PUSH_COM(RET_COM);
				break;
				
			case 63:
				// Execute: "push Path2Bvr Statics.stringPath(StringBvr, FontStyleBvr)"
				// AUTOGENERATED
				instrTrace("push Path2Bvr Statics.stringPath(StringBvr, FontStyleBvr)");
				METHOD_CALL_3(
					staticStatics,
					StringPathAnim,
					(IDAString*)USE_COM(1),
					(IDAFontStyle*)USE_COM(2),
					(IDAPath2**)RET_COM_ADDR
				);
				FREE_COM;
				FREE_COM;
				PUSH_COM(RET_COM);
				break;
				
			case 64:
				// Execute: "push Path2Bvr Statics.stringPath(java.lang.String, FontStyleBvr)"
				// AUTOGENERATED
				instrTrace("push Path2Bvr Statics.stringPath(java.lang.String, FontStyleBvr)");
				METHOD_CALL_3(
					staticStatics,
					StringPath,
					USE_STRING(1),
					(IDAFontStyle*)USE_COM(1),
					(IDAPath2**)RET_COM_ADDR
				);
				FREE_STRING;
				FREE_COM;
				PUSH_COM(RET_COM);
				break;
				
			case 65:
				// Execute: "push NumberBvr Statics.interpolate(NumberBvr, NumberBvr, NumberBvr)"
				// AUTOGENERATED
				instrTrace("push NumberBvr Statics.interpolate(NumberBvr, NumberBvr, NumberBvr)");
				METHOD_CALL_4(
					staticStatics,
					InterpolateAnim,
					(IDANumber*)USE_COM(1),
					(IDANumber*)USE_COM(2),
					(IDANumber*)USE_COM(3),
					(IDANumber**)RET_COM_ADDR
				);
				FREE_COM;
				FREE_COM;
				FREE_COM;
				PUSH_COM(RET_COM);
				break;
				
			case 66:
				// Execute: "push NumberBvr Statics.interpolate(double, double, double)"
				// AUTOGENERATED
				instrTrace("push NumberBvr Statics.interpolate(double, double, double)");
				METHOD_CALL_4(
					staticStatics,
					Interpolate,
					USE_DOUBLE(1),
					USE_DOUBLE(2),
					USE_DOUBLE(3),
					(IDANumber**)RET_COM_ADDR
				);
				FREE_DOUBLE(3);
				PUSH_COM(RET_COM);
				break;
				
			case 67:
				// Execute: "push NumberBvr Statics.atan2(NumberBvr, NumberBvr)"
				// AUTOGENERATED
				instrTrace("push NumberBvr Statics.atan2(NumberBvr, NumberBvr)");
				METHOD_CALL_3(
					staticStatics,
					Atan2,
					(IDANumber*)USE_COM(1),
					(IDANumber*)USE_COM(2),
					(IDANumber**)RET_COM_ADDR
				);
				FREE_COM;
				FREE_COM;
				PUSH_COM(RET_COM);
				break;
				
			case 68:
				// Execute: "push ImageBvr ImageBvr.tile()"
				// AUTOGENERATED
				instrTrace("push ImageBvr ImageBvr.tile()");
				METHOD_CALL_1(
					(IDAImage*)USE_COM(1),
					Tile,
					(IDAImage**)RET_COM_ADDR
				);
				FREE_COM;
				PUSH_COM(RET_COM);
				break;
				
			case 69:
				// Execute: "push Transform3Bvr Statics.transform4x4(NumberBvr[])"
				// AUTOGENERATED
				instrTrace("push Transform3Bvr Statics.transform4x4(NumberBvr[])");
				METHOD_CALL_3(
					staticStatics,
					Transform4x4AnimEx,
					USE_COM_ARRAY_LENGTH(1),
					(IDANumber**)USE_COM_ARRAY(1),
					(IDATransform3**)RET_COM_ADDR
				);
				FREE_COM_ARRAY;
				PUSH_COM(RET_COM);
				break;
				
			case 70:
				// Execute: "push NumberBvr Statics.log10(NumberBvr)"
				// AUTOGENERATED
				instrTrace("push NumberBvr Statics.log10(NumberBvr)");
				METHOD_CALL_2(
					staticStatics,
					Log10,
					(IDANumber*)USE_COM(1),
					(IDANumber**)RET_COM_ADDR
				);
				FREE_COM;
				PUSH_COM(RET_COM);
				break;
				
			case 71:
				// Execute: "push Vector3Bvr Statics.vector3Spherical(NumberBvr, NumberBvr, NumberBvr)"
				// AUTOGENERATED
				instrTrace("push Vector3Bvr Statics.vector3Spherical(NumberBvr, NumberBvr, NumberBvr)");
				METHOD_CALL_4(
					staticStatics,
					Vector3SphericalAnim,
					(IDANumber*)USE_COM(1),
					(IDANumber*)USE_COM(2),
					(IDANumber*)USE_COM(3),
					(IDAVector3**)RET_COM_ADDR
				);
				FREE_COM;
				FREE_COM;
				FREE_COM;
				PUSH_COM(RET_COM);
				break;
				
			case 72:
				// Execute: "push Vector3Bvr Statics.vector3Spherical(double, double, double)"
				// AUTOGENERATED
				instrTrace("push Vector3Bvr Statics.vector3Spherical(double, double, double)");
				METHOD_CALL_4(
					staticStatics,
					Vector3Spherical,
					USE_DOUBLE(1),
					USE_DOUBLE(2),
					USE_DOUBLE(3),
					(IDAVector3**)RET_COM_ADDR
				);
				FREE_DOUBLE(3);
				PUSH_COM(RET_COM);
				break;
				
			case 73:
				// Execute: "push ImageBvr Statics.gradientSquare(ColorBvr, ColorBvr, ColorBvr, ColorBvr)"
				// AUTOGENERATED
				instrTrace("push ImageBvr Statics.gradientSquare(ColorBvr, ColorBvr, ColorBvr, ColorBvr)");
				METHOD_CALL_5(
					staticStatics,
					GradientSquare,
					(IDAColor*)USE_COM(1),
					(IDAColor*)USE_COM(2),
					(IDAColor*)USE_COM(3),
					(IDAColor*)USE_COM(4),
					(IDAImage**)RET_COM_ADDR
				);
				FREE_COM;
				FREE_COM;
				FREE_COM;
				FREE_COM;
				PUSH_COM(RET_COM);
				break;
				
			case 74:
				// Execute: "push ImageBvr Statics.radialGradientSquare(ColorBvr, ColorBvr, double)"
				// AUTOGENERATED
				instrTrace("push ImageBvr Statics.radialGradientSquare(ColorBvr, ColorBvr, double)");
				METHOD_CALL_4(
					staticStatics,
					RadialGradientSquare,
					(IDAColor*)USE_COM(1),
					(IDAColor*)USE_COM(2),
					USE_DOUBLE(1),
					(IDAImage**)RET_COM_ADDR
				);
				FREE_DOUBLE(1);
				FREE_COM;
				FREE_COM;
				PUSH_COM(RET_COM);
				break;
				
			case 75:
				// Execute: "push ImageBvr Statics.radialGradientSquare(ColorBvr, ColorBvr, NumberBvr)"
				// AUTOGENERATED
				instrTrace("push ImageBvr Statics.radialGradientSquare(ColorBvr, ColorBvr, NumberBvr)");
				METHOD_CALL_4(
					staticStatics,
					RadialGradientSquareAnim,
					(IDAColor*)USE_COM(1),
					(IDAColor*)USE_COM(2),
					(IDANumber*)USE_COM(3),
					(IDAImage**)RET_COM_ADDR
				);
				FREE_COM;
				FREE_COM;
				FREE_COM;
				PUSH_COM(RET_COM);
				break;
				
			case 76:
				// Execute: "push Transform2Bvr Statics.followPathAngle(Path2Bvr, NumberBvr)"
				// AUTOGENERATED
				instrTrace("push Transform2Bvr Statics.followPathAngle(Path2Bvr, NumberBvr)");
				METHOD_CALL_3(
					staticStatics,
					FollowPathAngleEval,
					(IDAPath2*)USE_COM(1),
					(IDANumber*)USE_COM(2),
					(IDATransform2**)RET_COM_ADDR
				);
				FREE_COM;
				FREE_COM;
				PUSH_COM(RET_COM);
				break;
				
			case 77:
				// Execute: "push ImageBvr Statics.overlayArray(ImageBvr[])"
				// AUTOGENERATED
				instrTrace("push ImageBvr Statics.overlayArray(ImageBvr[])");
				METHOD_CALL_3(
					staticStatics,
					OverlayArrayEx,
					USE_COM_ARRAY_LENGTH(1),
					(IDAImage**)USE_COM_ARRAY(1),
					(IDAImage**)RET_COM_ADDR
				);
				FREE_COM_ARRAY;
				PUSH_COM(RET_COM);
				break;
				
			case 78:
				// Execute: "push SoundBvr Statics.mixArray(SoundBvr[])"
				// AUTOGENERATED
				instrTrace("push SoundBvr Statics.mixArray(SoundBvr[])");
				METHOD_CALL_3(
					staticStatics,
					MixArrayEx,
					USE_COM_ARRAY_LENGTH(1),
					(IDASound**)USE_COM_ARRAY(1),
					(IDASound**)RET_COM_ADDR
				);
				FREE_COM_ARRAY;
				PUSH_COM(RET_COM);
				break;
				
			case 79:
				// Execute: "push NumberBvr Statics.pow(NumberBvr, NumberBvr)"
				// AUTOGENERATED
				instrTrace("push NumberBvr Statics.pow(NumberBvr, NumberBvr)");
				METHOD_CALL_3(
					staticStatics,
					Pow,
					(IDANumber*)USE_COM(1),
					(IDANumber*)USE_COM(2),
					(IDANumber**)RET_COM_ADDR
				);
				FREE_COM;
				FREE_COM;
				PUSH_COM(RET_COM);
				break;
				
			case 80:
				// Execute: "push NumberBvr Statics.seededRandom(double)"
				// AUTOGENERATED
				instrTrace("push NumberBvr Statics.seededRandom(double)");
				METHOD_CALL_2(
					staticStatics,
					SeededRandom,
					USE_DOUBLE(1),
					(IDANumber**)RET_COM_ADDR
				);
				FREE_DOUBLE(1);
				PUSH_COM(RET_COM);
				break;
				
			case 81:
				// Execute: "push Transform3Bvr Statics.lookAtFrom(Point3Bvr, Point3Bvr, Vector3Bvr)"
				// AUTOGENERATED
				instrTrace("push Transform3Bvr Statics.lookAtFrom(Point3Bvr, Point3Bvr, Vector3Bvr)");
				METHOD_CALL_4(
					staticStatics,
					LookAtFrom,
					(IDAPoint3*)USE_COM(1),
					(IDAPoint3*)USE_COM(2),
					(IDAVector3*)USE_COM(3),
					(IDATransform3**)RET_COM_ADDR
				);
				FREE_COM;
				FREE_COM;
				FREE_COM;
				PUSH_COM(RET_COM);
				break;
				
			case 82:
				// Execute: "push NumberBvr Statics.asin(NumberBvr)"
				// AUTOGENERATED
				instrTrace("push NumberBvr Statics.asin(NumberBvr)");
				METHOD_CALL_2(
					staticStatics,
					Asin,
					(IDANumber*)USE_COM(1),
					(IDANumber**)RET_COM_ADDR
				);
				FREE_COM;
				PUSH_COM(RET_COM);
				break;
				
			case 83:
				// Execute: "push NumberBvr Statics.integral(NumberBvr)"
				// AUTOGENERATED
				instrTrace("push NumberBvr Statics.integral(NumberBvr)");
				METHOD_CALL_2(
					staticStatics,
					Integral,
					(IDANumber*)USE_COM(1),
					(IDANumber**)RET_COM_ADDR
				);
				FREE_COM;
				PUSH_COM(RET_COM);
				break;
				
			case 84:
				// Execute: "push Vector2Bvr Statics.integral(Vector2Bvr)"
				// AUTOGENERATED
				instrTrace("push Vector2Bvr Statics.integral(Vector2Bvr)");
				METHOD_CALL_2(
					staticStatics,
					IntegralVector2,
					(IDAVector2*)USE_COM(1),
					(IDAVector2**)RET_COM_ADDR
				);
				FREE_COM;
				PUSH_COM(RET_COM);
				break;
				
			case 85:
				// Execute: "push Vector3Bvr Statics.integral(Vector3Bvr)"
				// AUTOGENERATED
				instrTrace("push Vector3Bvr Statics.integral(Vector3Bvr)");
				METHOD_CALL_2(
					staticStatics,
					IntegralVector3,
					(IDAVector3*)USE_COM(1),
					(IDAVector3**)RET_COM_ADDR
				);
				FREE_COM;
				PUSH_COM(RET_COM);
				break;
				
			case 86:
				// Execute: "push StringBvr Statics.concat(StringBvr, StringBvr)"
				// AUTOGENERATED
				instrTrace("push StringBvr Statics.concat(StringBvr, StringBvr)");
				METHOD_CALL_3(
					staticStatics,
					ConcatString,
					(IDAString*)USE_COM(1),
					(IDAString*)USE_COM(2),
					(IDAString**)RET_COM_ADDR
				);
				FREE_COM;
				FREE_COM;
				PUSH_COM(RET_COM);
				break;
				
			case 87:
				// Execute: "push Transform3Bvr Statics.scale3Rate(double)"
				// AUTOGENERATED
				instrTrace("push Transform3Bvr Statics.scale3Rate(double)");
				METHOD_CALL_2(
					staticStatics,
					Scale3UniformRate,
					USE_DOUBLE(1),
					(IDATransform3**)RET_COM_ADDR
				);
				FREE_DOUBLE(1);
				PUSH_COM(RET_COM);
				break;
				
			case 88:
				// Execute: "push Transform3Bvr Statics.yShearRate(double, double)"
				// AUTOGENERATED
				instrTrace("push Transform3Bvr Statics.yShearRate(double, double)");
				METHOD_CALL_3(
					staticStatics,
					YShear3Rate,
					USE_DOUBLE(1),
					USE_DOUBLE(2),
					(IDATransform3**)RET_COM_ADDR
				);
				FREE_DOUBLE(2);
				PUSH_COM(RET_COM);
				break;
				
			case 89:
				// Execute: "push Transform2Bvr Statics.yShearRate(double)"
				// AUTOGENERATED
				instrTrace("push Transform2Bvr Statics.yShearRate(double)");
				METHOD_CALL_2(
					staticStatics,
					YShear2Rate,
					USE_DOUBLE(1),
					(IDATransform2**)RET_COM_ADDR
				);
				FREE_DOUBLE(1);
				PUSH_COM(RET_COM);
				break;
				
			case 90:
				// Execute: "push MatteBvr Statics.difference(MatteBvr, MatteBvr)"
				// AUTOGENERATED
				instrTrace("push MatteBvr Statics.difference(MatteBvr, MatteBvr)");
				METHOD_CALL_3(
					staticStatics,
					DifferenceMatte,
					(IDAMatte*)USE_COM(1),
					(IDAMatte*)USE_COM(2),
					(IDAMatte**)RET_COM_ADDR
				);
				FREE_COM;
				FREE_COM;
				PUSH_COM(RET_COM);
				break;
				
			case 91:
				// Execute: "push Transform2Bvr Statics.transform3x2(NumberBvr[])"
				// AUTOGENERATED
				instrTrace("push Transform2Bvr Statics.transform3x2(NumberBvr[])");
				METHOD_CALL_3(
					staticStatics,
					Transform3x2AnimEx,
					USE_COM_ARRAY_LENGTH(1),
					(IDANumber**)USE_COM_ARRAY(1),
					(IDATransform2**)RET_COM_ADDR
				);
				FREE_COM_ARRAY;
				PUSH_COM(RET_COM);
				break;
				
			case 92:
				// Execute: "push Path2Bvr Statics.polyline(Point2Bvr[])"
				// AUTOGENERATED
				instrTrace("push Path2Bvr Statics.polyline(Point2Bvr[])");
				METHOD_CALL_3(
					staticStatics,
					PolylineEx,
					USE_COM_ARRAY_LENGTH(1),
					(IDAPoint2**)USE_COM_ARRAY(1),
					(IDAPath2**)RET_COM_ADDR
				);
				FREE_COM_ARRAY;
				PUSH_COM(RET_COM);
				break;
				
			case 93:
				// Execute: "push ImageBvr Statics.hatchVertical(ColorBvr, double)"
				// AUTOGENERATED
				instrTrace("push ImageBvr Statics.hatchVertical(ColorBvr, double)");
				METHOD_CALL_3(
					staticStatics,
					HatchVertical,
					(IDAColor*)USE_COM(1),
					USE_DOUBLE(1),
					(IDAImage**)RET_COM_ADDR
				);
				FREE_DOUBLE(1);
				FREE_COM;
				PUSH_COM(RET_COM);
				break;
				
			case 94:
				// Execute: "push ImageBvr Statics.hatchVertical(ColorBvr, NumberBvr)"
				// AUTOGENERATED
				instrTrace("push ImageBvr Statics.hatchVertical(ColorBvr, NumberBvr)");
				METHOD_CALL_3(
					staticStatics,
					HatchVerticalAnim,
					(IDAColor*)USE_COM(1),
					(IDANumber*)USE_COM(2),
					(IDAImage**)RET_COM_ADDR
				);
				FREE_COM;
				FREE_COM;
				PUSH_COM(RET_COM);
				break;
				
			case 95:
				// Execute: "push Point3Bvr Statics.point3Spherical(NumberBvr, NumberBvr, NumberBvr)"
				// AUTOGENERATED
				instrTrace("push Point3Bvr Statics.point3Spherical(NumberBvr, NumberBvr, NumberBvr)");
				METHOD_CALL_4(
					staticStatics,
					Point3SphericalAnim,
					(IDANumber*)USE_COM(1),
					(IDANumber*)USE_COM(2),
					(IDANumber*)USE_COM(3),
					(IDAPoint3**)RET_COM_ADDR
				);
				FREE_COM;
				FREE_COM;
				FREE_COM;
				PUSH_COM(RET_COM);
				break;
				
			case 96:
				// Execute: "push Point3Bvr Statics.point3Spherical(double, double, double)"
				// AUTOGENERATED
				instrTrace("push Point3Bvr Statics.point3Spherical(double, double, double)");
				METHOD_CALL_4(
					staticStatics,
					Point3Spherical,
					USE_DOUBLE(1),
					USE_DOUBLE(2),
					USE_DOUBLE(3),
					(IDAPoint3**)RET_COM_ADDR
				);
				FREE_DOUBLE(3);
				PUSH_COM(RET_COM);
				break;
				
			case 97:
				// Execute: "push BooleanBvr Statics.gt(NumberBvr, NumberBvr)"
				// AUTOGENERATED
				instrTrace("push BooleanBvr Statics.gt(NumberBvr, NumberBvr)");
				METHOD_CALL_3(
					staticStatics,
					GT,
					(IDANumber*)USE_COM(1),
					(IDANumber*)USE_COM(2),
					(IDABoolean**)RET_COM_ADDR
				);
				FREE_COM;
				FREE_COM;
				PUSH_COM(RET_COM);
				break;
				
			case 98:
				// Execute: "push ImageBvr Statics.hatchForwardDiagonal(ColorBvr, double)"
				// AUTOGENERATED
				instrTrace("push ImageBvr Statics.hatchForwardDiagonal(ColorBvr, double)");
				METHOD_CALL_3(
					staticStatics,
					HatchForwardDiagonal,
					(IDAColor*)USE_COM(1),
					USE_DOUBLE(1),
					(IDAImage**)RET_COM_ADDR
				);
				FREE_DOUBLE(1);
				FREE_COM;
				PUSH_COM(RET_COM);
				break;
				
			case 99:
				// Execute: "push ImageBvr Statics.hatchForwardDiagonal(ColorBvr, NumberBvr)"
				// AUTOGENERATED
				instrTrace("push ImageBvr Statics.hatchForwardDiagonal(ColorBvr, NumberBvr)");
				METHOD_CALL_3(
					staticStatics,
					HatchForwardDiagonalAnim,
					(IDAColor*)USE_COM(1),
					(IDANumber*)USE_COM(2),
					(IDAImage**)RET_COM_ADDR
				);
				FREE_COM;
				FREE_COM;
				PUSH_COM(RET_COM);
				break;
				
			case 100:
				// Execute: "push ImageBvr Statics.hatchBackwardDiagonal(ColorBvr, double)"
				// AUTOGENERATED
				instrTrace("push ImageBvr Statics.hatchBackwardDiagonal(ColorBvr, double)");
				METHOD_CALL_3(
					staticStatics,
					HatchBackwardDiagonal,
					(IDAColor*)USE_COM(1),
					USE_DOUBLE(1),
					(IDAImage**)RET_COM_ADDR
				);
				FREE_DOUBLE(1);
				FREE_COM;
				PUSH_COM(RET_COM);
				break;
				
			case 101:
				// Execute: "push ImageBvr Statics.hatchBackwardDiagonal(ColorBvr, NumberBvr)"
				// AUTOGENERATED
				instrTrace("push ImageBvr Statics.hatchBackwardDiagonal(ColorBvr, NumberBvr)");
				METHOD_CALL_3(
					staticStatics,
					HatchBackwardDiagonalAnim,
					(IDAColor*)USE_COM(1),
					(IDANumber*)USE_COM(2),
					(IDAImage**)RET_COM_ADDR
				);
				FREE_COM;
				FREE_COM;
				PUSH_COM(RET_COM);
				break;
				
			case 102:
				// Execute: "push NumberBvr Statics.atan(NumberBvr)"
				// AUTOGENERATED
				instrTrace("push NumberBvr Statics.atan(NumberBvr)");
				METHOD_CALL_2(
					staticStatics,
					Atan,
					(IDANumber*)USE_COM(1),
					(IDANumber**)RET_COM_ADDR
				);
				FREE_COM;
				PUSH_COM(RET_COM);
				break;
				
			case 103:
				// Execute: "push Vector2Bvr Statics.vector2Polar(NumberBvr, NumberBvr)"
				// AUTOGENERATED
				instrTrace("push Vector2Bvr Statics.vector2Polar(NumberBvr, NumberBvr)");
				METHOD_CALL_3(
					staticStatics,
					Vector2PolarAnim,
					(IDANumber*)USE_COM(1),
					(IDANumber*)USE_COM(2),
					(IDAVector2**)RET_COM_ADDR
				);
				FREE_COM;
				FREE_COM;
				PUSH_COM(RET_COM);
				break;
				
			case 104:
				// Execute: "push Vector2Bvr Statics.vector2Polar(double, double)"
				// AUTOGENERATED
				instrTrace("push Vector2Bvr Statics.vector2Polar(double, double)");
				METHOD_CALL_3(
					staticStatics,
					Vector2Polar,
					USE_DOUBLE(1),
					USE_DOUBLE(2),
					(IDAVector2**)RET_COM_ADDR
				);
				FREE_DOUBLE(2);
				PUSH_COM(RET_COM);
				break;
				
			case 105:
				// Execute: "push ImageBvr Statics.hatchCross(ColorBvr, double)"
				// AUTOGENERATED
				instrTrace("push ImageBvr Statics.hatchCross(ColorBvr, double)");
				METHOD_CALL_3(
					staticStatics,
					HatchCross,
					(IDAColor*)USE_COM(1),
					USE_DOUBLE(1),
					(IDAImage**)RET_COM_ADDR
				);
				FREE_DOUBLE(1);
				FREE_COM;
				PUSH_COM(RET_COM);
				break;
				
			case 106:
				// Execute: "push ImageBvr Statics.hatchCross(ColorBvr, NumberBvr)"
				// AUTOGENERATED
				instrTrace("push ImageBvr Statics.hatchCross(ColorBvr, NumberBvr)");
				METHOD_CALL_3(
					staticStatics,
					HatchCrossAnim,
					(IDAColor*)USE_COM(1),
					(IDANumber*)USE_COM(2),
					(IDAImage**)RET_COM_ADDR
				);
				FREE_COM;
				FREE_COM;
				PUSH_COM(RET_COM);
				break;
				
			case 107:
				// Execute: "push ImageBvr Statics.hatchDiagonalCross(ColorBvr, double)"
				// AUTOGENERATED
				instrTrace("push ImageBvr Statics.hatchDiagonalCross(ColorBvr, double)");
				METHOD_CALL_3(
					staticStatics,
					HatchDiagonalCross,
					(IDAColor*)USE_COM(1),
					USE_DOUBLE(1),
					(IDAImage**)RET_COM_ADDR
				);
				FREE_DOUBLE(1);
				FREE_COM;
				PUSH_COM(RET_COM);
				break;
				
			case 108:
				// Execute: "push ImageBvr Statics.hatchDiagonalCross(ColorBvr, NumberBvr)"
				// AUTOGENERATED
				instrTrace("push ImageBvr Statics.hatchDiagonalCross(ColorBvr, NumberBvr)");
				METHOD_CALL_3(
					staticStatics,
					HatchDiagonalCrossAnim,
					(IDAColor*)USE_COM(1),
					(IDANumber*)USE_COM(2),
					(IDAImage**)RET_COM_ADDR
				);
				FREE_COM;
				FREE_COM;
				PUSH_COM(RET_COM);
				break;
				
			case 109:
				// Execute: "push NumberBvr Statics.acos(NumberBvr)"
				// AUTOGENERATED
				instrTrace("push NumberBvr Statics.acos(NumberBvr)");
				METHOD_CALL_2(
					staticStatics,
					Acos,
					(IDANumber*)USE_COM(1),
					(IDANumber**)RET_COM_ADDR
				);
				FREE_COM;
				PUSH_COM(RET_COM);
				break;
				
			case 110:
				// Execute: "push Transform2Bvr Statics.scale2Rate(double)"
				// AUTOGENERATED
				instrTrace("push Transform2Bvr Statics.scale2Rate(double)");
				METHOD_CALL_2(
					staticStatics,
					Scale2UniformRate,
					USE_DOUBLE(1),
					(IDATransform2**)RET_COM_ADDR
				);
				FREE_DOUBLE(1);
				PUSH_COM(RET_COM);
				break;
				
			case 111:
				// Execute: "push BooleanBvr Statics.ne(NumberBvr, NumberBvr)"
				// AUTOGENERATED
				instrTrace("push BooleanBvr Statics.ne(NumberBvr, NumberBvr)");
				METHOD_CALL_3(
					staticStatics,
					NE,
					(IDANumber*)USE_COM(1),
					(IDANumber*)USE_COM(2),
					(IDABoolean**)RET_COM_ADDR
				);
				FREE_COM;
				FREE_COM;
				PUSH_COM(RET_COM);
				break;
				
			case 112:
				// Execute: "push BooleanBvr Statics.lte(NumberBvr, NumberBvr)"
				// AUTOGENERATED
				instrTrace("push BooleanBvr Statics.lte(NumberBvr, NumberBvr)");
				METHOD_CALL_3(
					staticStatics,
					LTE,
					(IDANumber*)USE_COM(1),
					(IDANumber*)USE_COM(2),
					(IDABoolean**)RET_COM_ADDR
				);
				FREE_COM;
				FREE_COM;
				PUSH_COM(RET_COM);
				break;
				
			case 113:
				// Execute: "push NumberBvr Statics.tan(NumberBvr)"
				// AUTOGENERATED
				instrTrace("push NumberBvr Statics.tan(NumberBvr)");
				METHOD_CALL_2(
					staticStatics,
					Tan,
					(IDANumber*)USE_COM(1),
					(IDANumber**)RET_COM_ADDR
				);
				FREE_COM;
				PUSH_COM(RET_COM);
				break;
				
			case 114:
				// Execute: "push Path2Bvr Statics.oval(double, double)"
				// AUTOGENERATED
				instrTrace("push Path2Bvr Statics.oval(double, double)");
				METHOD_CALL_3(
					staticStatics,
					Oval,
					USE_DOUBLE(1),
					USE_DOUBLE(2),
					(IDAPath2**)RET_COM_ADDR
				);
				FREE_DOUBLE(2);
				PUSH_COM(RET_COM);
				break;
				
			case 115:
				// Execute: "push Path2Bvr Statics.oval(NumberBvr, NumberBvr)"
				// AUTOGENERATED
				instrTrace("push Path2Bvr Statics.oval(NumberBvr, NumberBvr)");
				METHOD_CALL_3(
					staticStatics,
					OvalAnim,
					(IDANumber*)USE_COM(1),
					(IDANumber*)USE_COM(2),
					(IDAPath2**)RET_COM_ADDR
				);
				FREE_COM;
				FREE_COM;
				PUSH_COM(RET_COM);
				break;
				
			case 116:
				// Execute: "push Point2Bvr Statics.point2Polar(NumberBvr, NumberBvr)"
				// AUTOGENERATED
				instrTrace("push Point2Bvr Statics.point2Polar(NumberBvr, NumberBvr)");
				METHOD_CALL_3(
					staticStatics,
					Point2PolarAnim,
					(IDANumber*)USE_COM(1),
					(IDANumber*)USE_COM(2),
					(IDAPoint2**)RET_COM_ADDR
				);
				FREE_COM;
				FREE_COM;
				PUSH_COM(RET_COM);
				break;
				
			case 117:
				// Execute: "push Point2Bvr Statics.point2Polar(double, double)"
				// AUTOGENERATED
				instrTrace("push Point2Bvr Statics.point2Polar(double, double)");
				METHOD_CALL_3(
					staticStatics,
					Point2Polar,
					USE_DOUBLE(1),
					USE_DOUBLE(2),
					(IDAPoint2**)RET_COM_ADDR
				);
				FREE_DOUBLE(2);
				PUSH_COM(RET_COM);
				break;
				
			case 118:
				// Execute: "push Vector2Bvr Statics.derivative(Vector2Bvr)"
				// AUTOGENERATED
				instrTrace("push Vector2Bvr Statics.derivative(Vector2Bvr)");
				METHOD_CALL_2(
					staticStatics,
					DerivativeVector2,
					(IDAVector2*)USE_COM(1),
					(IDAVector2**)RET_COM_ADDR
				);
				FREE_COM;
				PUSH_COM(RET_COM);
				break;
				
			case 119:
				// Execute: "push Vector3Bvr Statics.derivative(Vector3Bvr)"
				// AUTOGENERATED
				instrTrace("push Vector3Bvr Statics.derivative(Vector3Bvr)");
				METHOD_CALL_2(
					staticStatics,
					DerivativeVector3,
					(IDAVector3*)USE_COM(1),
					(IDAVector3**)RET_COM_ADDR
				);
				FREE_COM;
				PUSH_COM(RET_COM);
				break;
				
			case 120:
				// Execute: "push Vector2Bvr Statics.derivative(Point2Bvr)"
				// AUTOGENERATED
				instrTrace("push Vector2Bvr Statics.derivative(Point2Bvr)");
				METHOD_CALL_2(
					staticStatics,
					DerivativePoint2,
					(IDAPoint2*)USE_COM(1),
					(IDAVector2**)RET_COM_ADDR
				);
				FREE_COM;
				PUSH_COM(RET_COM);
				break;
				
			case 121:
				// Execute: "push Vector3Bvr Statics.derivative(Point3Bvr)"
				// AUTOGENERATED
				instrTrace("push Vector3Bvr Statics.derivative(Point3Bvr)");
				METHOD_CALL_2(
					staticStatics,
					DerivativePoint3,
					(IDAPoint3*)USE_COM(1),
					(IDAVector3**)RET_COM_ADDR
				);
				FREE_COM;
				PUSH_COM(RET_COM);
				break;
				
			case 122:
				// Execute: "push NumberBvr Statics.derivative(NumberBvr)"
				// AUTOGENERATED
				instrTrace("push NumberBvr Statics.derivative(NumberBvr)");
				METHOD_CALL_2(
					staticStatics,
					Derivative,
					(IDANumber*)USE_COM(1),
					(IDANumber**)RET_COM_ADDR
				);
				FREE_COM;
				PUSH_COM(RET_COM);
				break;
				
			case 123:
				// Execute: "push ImageBvr Statics.radialGradientPolygon(ColorBvr, ColorBvr, Point2Bvr[], double)"
				// AUTOGENERATED
				instrTrace("push ImageBvr Statics.radialGradientPolygon(ColorBvr, ColorBvr, Point2Bvr[], double)");
				METHOD_CALL_6(
					staticStatics,
					RadialGradientPolygonEx,
					(IDAColor*)USE_COM(1),
					(IDAColor*)USE_COM(2),
					USE_COM_ARRAY_LENGTH(1),
					(IDAPoint2**)USE_COM_ARRAY(1),
					USE_DOUBLE(1),
					(IDAImage**)RET_COM_ADDR
				);
				FREE_DOUBLE(1);
				FREE_COM;
				FREE_COM;
				FREE_COM_ARRAY;
				PUSH_COM(RET_COM);
				break;
				
			case 124:
				// Execute: "push ImageBvr Statics.radialGradientPolygon(ColorBvr, ColorBvr, Point2Bvr[], NumberBvr)"
				// AUTOGENERATED
				instrTrace("push ImageBvr Statics.radialGradientPolygon(ColorBvr, ColorBvr, Point2Bvr[], NumberBvr)");
				METHOD_CALL_6(
					staticStatics,
					RadialGradientPolygonAnimEx,
					(IDAColor*)USE_COM(1),
					(IDAColor*)USE_COM(2),
					USE_COM_ARRAY_LENGTH(1),
					(IDAPoint2**)USE_COM_ARRAY(1),
					(IDANumber*)USE_COM(3),
					(IDAImage**)RET_COM_ADDR
				);
				FREE_COM;
				FREE_COM;
				FREE_COM;
				FREE_COM_ARRAY;
				PUSH_COM(RET_COM);
				break;
				
			case 125:
				// Execute: "push NumberBvr Statics.exp(NumberBvr)"
				// AUTOGENERATED
				instrTrace("push NumberBvr Statics.exp(NumberBvr)");
				METHOD_CALL_2(
					staticStatics,
					Exp,
					(IDANumber*)USE_COM(1),
					(IDANumber**)RET_COM_ADDR
				);
				FREE_COM;
				PUSH_COM(RET_COM);
				break;
				
			case 126:
				// Execute: "push CameraBvr Statics.perspectiveCamera(double, double)"
				// AUTOGENERATED
				instrTrace("push CameraBvr Statics.perspectiveCamera(double, double)");
				METHOD_CALL_3(
					staticStatics,
					PerspectiveCamera,
					USE_DOUBLE(1),
					USE_DOUBLE(2),
					(IDACamera**)RET_COM_ADDR
				);
				FREE_DOUBLE(2);
				PUSH_COM(RET_COM);
				break;
				
			case 127:
				// Execute: "push CameraBvr Statics.perspectiveCamera(NumberBvr, NumberBvr)"
				// AUTOGENERATED
				instrTrace("push CameraBvr Statics.perspectiveCamera(NumberBvr, NumberBvr)");
				METHOD_CALL_3(
					staticStatics,
					PerspectiveCameraAnim,
					(IDANumber*)USE_COM(1),
					(IDANumber*)USE_COM(2),
					(IDACamera**)RET_COM_ADDR
				);
				FREE_COM;
				FREE_COM;
				PUSH_COM(RET_COM);
				break;
				
			case 128:
				// Execute: "push CameraBvr Statics.parallelCamera(double)"
				// AUTOGENERATED
				instrTrace("push CameraBvr Statics.parallelCamera(double)");
				METHOD_CALL_2(
					staticStatics,
					ParallelCamera,
					USE_DOUBLE(1),
					(IDACamera**)RET_COM_ADDR
				);
				FREE_DOUBLE(1);
				PUSH_COM(RET_COM);
				break;
				
			case 129:
				// Execute: "push CameraBvr Statics.parallelCamera(NumberBvr)"
				// AUTOGENERATED
				instrTrace("push CameraBvr Statics.parallelCamera(NumberBvr)");
				METHOD_CALL_2(
					staticStatics,
					ParallelCameraAnim,
					(IDANumber*)USE_COM(1),
					(IDACamera**)RET_COM_ADDR
				);
				FREE_COM;
				PUSH_COM(RET_COM);
				break;
				
			case 130:
				// Execute: "push Transform2Bvr Statics.followPathAngleUpright(Path2Bvr, double)"
				// AUTOGENERATED
				instrTrace("push Transform2Bvr Statics.followPathAngleUpright(Path2Bvr, double)");
				METHOD_CALL_3(
					staticStatics,
					FollowPathAngleUpright,
					(IDAPath2*)USE_COM(1),
					USE_DOUBLE(1),
					(IDATransform2**)RET_COM_ADDR
				);
				FREE_DOUBLE(1);
				FREE_COM;
				PUSH_COM(RET_COM);
				break;
				
			case 131:
				// Execute: "push GeometryBvr Statics.importGeometry(java.lang.String)"
				// AUTOGENERATED
				instrTrace("push GeometryBvr Statics.importGeometry(java.lang.String)");
				IMPORT_METHOD_CALL_2(
					staticStatics,
					ImportGeometry,
					USE_STRING(1),
					(IDAGeometry**)RET_COM_ADDR
				);
				FREE_STRING;
				PUSH_COM(RET_COM);
				break;
				
			case 132:
				// Execute: "push Behavior Statics.modifiableBehavior(Behavior)"
				// AUTOGENERATED
				instrTrace("push Behavior Statics.modifiableBehavior(Behavior)");
				METHOD_CALL_2(
					staticStatics,
					ModifiableBehavior,
					(IDABehavior*)USE_COM(1),
					(IDABehavior**)RET_COM_ADDR
				);
				FREE_COM;
				PUSH_COM(RET_COM);
				break;
				
			case 133:
				// Execute: "call Behavior.switchTo(Behavior)"
				// AUTOGENERATED
				instrTrace("call Behavior.switchTo(Behavior)");
				METHOD_CALL_1(
					(IDABehavior*)USE_COM(1),
					SwitchTo,
					(IDABehavior*)USE_COM(2)
				);
				FREE_COM;
				FREE_COM;
				break;
				
			case 134:
				// Execute: "call Behavior.switchTo(double)"
				// AUTOGENERATED
				instrTrace("call Behavior.switchTo(double)");
				METHOD_CALL_1(
					(IDABehavior*)USE_COM(1),
					SwitchToNumber,
					USE_DOUBLE(1)
				);
				FREE_DOUBLE(1);
				FREE_COM;
				break;
				
			case 135:
				// Execute: "call Behavior.switchTo(java.lang.String)"
				// AUTOGENERATED
				instrTrace("call Behavior.switchTo(java.lang.String)");
				METHOD_CALL_1(
					(IDABehavior*)USE_COM(1),
					SwitchToString,
					USE_STRING(1)
				);
				FREE_STRING;
				FREE_COM;
				break;
				
			case 136:
				// Execute: "push Behavior Behavior.repeat(int)"
				// AUTOGENERATED
				instrTrace("push Behavior Behavior.repeat(int)");
				METHOD_CALL_2(
					(IDABehavior*)USE_COM(1),
					Repeat,
					USE_LONG(1),
					(IDABehavior**)RET_COM_ADDR
				);
				FREE_LONG(1);
				FREE_COM;
				PUSH_COM(RET_COM);
				break;
				
			case 137:
				// Execute: "push Behavior Behavior.repeatForever()"
				// AUTOGENERATED
				instrTrace("push Behavior Behavior.repeatForever()");
				METHOD_CALL_1(
					(IDABehavior*)USE_COM(1),
					RepeatForever,
					(IDABehavior**)RET_COM_ADDR
				);
				FREE_COM;
				PUSH_COM(RET_COM);
				break;
				
			case 138:
				// Execute: "push Behavior Behavior.importance(double)"
				// AUTOGENERATED
				instrTrace("push Behavior Behavior.importance(double)");
				METHOD_CALL_2(
					(IDABehavior*)USE_COM(1),
					Importance,
					USE_DOUBLE(1),
					(IDABehavior**)RET_COM_ADDR
				);
				FREE_DOUBLE(1);
				FREE_COM;
				PUSH_COM(RET_COM);
				break;
				
			case 139:
				// Execute: "push Behavior Behavior.runOnce()"
				// AUTOGENERATED
				instrTrace("push Behavior Behavior.runOnce()");
				METHOD_CALL_1(
					(IDABehavior*)USE_COM(1),
					RunOnce,
					(IDABehavior**)RET_COM_ADDR
				);
				FREE_COM;
				PUSH_COM(RET_COM);
				break;
				
			case 140:
				// Execute: "push TupleBvr Statics.tuple(Behavior[])"
				// AUTOGENERATED
				instrTrace("push TupleBvr Statics.tuple(Behavior[])");
				METHOD_CALL_3(
					staticStatics,
					DATupleEx,
					USE_COM_ARRAY_LENGTH(1),
					(IDABehavior**)USE_COM_ARRAY(1),
					(IDATuple**)RET_COM_ADDR
				);
				FREE_COM_ARRAY;
				PUSH_COM(RET_COM);
				break;
				
			case 141:
				// Execute: "push TupleBvr Statics.uninitializedTuple(TupleBvr)"
				// AUTOGENERATED
				instrTrace("push TupleBvr Statics.uninitializedTuple(TupleBvr)");
				METHOD_CALL_2(
					staticStatics,
					UninitializedTuple,
					(IDATuple*)USE_COM(1),
					(IDATuple**)RET_COM_ADDR
				);
				FREE_COM;
				PUSH_COM(RET_COM);
				break;
				
			case 142:
				// Execute: "push ArrayBvr Statics.array(Behavior[])"
				// AUTOGENERATED
				instrTrace("push ArrayBvr Statics.array(Behavior[])");
				METHOD_CALL_3(
					staticStatics,
					DAArrayEx,
					USE_COM_ARRAY_LENGTH(1),
					(IDABehavior**)USE_COM_ARRAY(1),
					(IDAArray**)RET_COM_ADDR
				);
				FREE_COM_ARRAY;
				PUSH_COM(RET_COM);
				break;
				
			case 143:
				// Execute: "push ArrayBvr Statics.uninitializedArray(ArrayBvr)"
				// AUTOGENERATED
				instrTrace("push ArrayBvr Statics.uninitializedArray(ArrayBvr)");
				METHOD_CALL_2(
					staticStatics,
					UninitializedArray,
					(IDAArray*)USE_COM(1),
					(IDAArray**)RET_COM_ADDR
				);
				FREE_COM;
				PUSH_COM(RET_COM);
				break;
				
			case 144:
				// Execute: "push DXMEvent DXMEvent.attachData(Behavior)"
				// AUTOGENERATED
				instrTrace("push DXMEvent DXMEvent.attachData(Behavior)");
				METHOD_CALL_2(
					(IDAEvent*)USE_COM(1),
					AttachData,
					(IDABehavior*)USE_COM(2),
					(IDAEvent**)RET_COM_ADDR
				);
				FREE_COM;
				FREE_COM;
				PUSH_COM(RET_COM);
				break;
				
			case 145:
				// Execute: "push DXMEvent DXMEvent.scriptCallback(java.lang.String, java.lang.String)"
				// AUTOGENERATED
				instrTrace("push DXMEvent DXMEvent.scriptCallback(java.lang.String, java.lang.String)");
				METHOD_CALL_3(
					(IDAEvent*)USE_COM(1),
					ScriptCallback,
					USE_STRING(1),
					USE_STRING(2),
					(IDAEvent**)RET_COM_ADDR
				);
				FREE_STRING;
				FREE_STRING;
				FREE_COM;
				PUSH_COM(RET_COM);
				break;
				
			case 146:
				// Execute: "push LineStyleBvr LineStyleBvr.join(JoinStyleBvr)"
				// AUTOGENERATED
				instrTrace("push LineStyleBvr LineStyleBvr.join(JoinStyleBvr)");
				METHOD_CALL_2(
					(IDALineStyle*)USE_COM(1),
					Join,
					(IDAJoinStyle*)USE_COM(2),
					(IDALineStyle**)RET_COM_ADDR
				);
				FREE_COM;
				FREE_COM;
				PUSH_COM(RET_COM);
				break;
				
			case 147:
				// Execute: "push LineStyleBvr LineStyleBvr.end(EndStyleBvr)"
				// AUTOGENERATED
				instrTrace("push LineStyleBvr LineStyleBvr.end(EndStyleBvr)");
				METHOD_CALL_2(
					(IDALineStyle*)USE_COM(1),
					End,
					(IDAEndStyle*)USE_COM(2),
					(IDALineStyle**)RET_COM_ADDR
				);
				FREE_COM;
				FREE_COM;
				PUSH_COM(RET_COM);
				break;
				
			case 148:
				// Execute: "push LineStyleBvr LineStyleBvr.detail()"
				// AUTOGENERATED
				instrTrace("push LineStyleBvr LineStyleBvr.detail()");
				METHOD_CALL_1(
					(IDALineStyle*)USE_COM(1),
					Detail,
					(IDALineStyle**)RET_COM_ADDR
				);
				FREE_COM;
				PUSH_COM(RET_COM);
				break;
				
			case 149:
				// Execute: "push LineStyleBvr LineStyleBvr.color(ColorBvr)"
				// AUTOGENERATED
				instrTrace("push LineStyleBvr LineStyleBvr.color(ColorBvr)");
				METHOD_CALL_2(
					(IDALineStyle*)USE_COM(1),
					Color,
					(IDAColor*)USE_COM(2),
					(IDALineStyle**)RET_COM_ADDR
				);
				FREE_COM;
				FREE_COM;
				PUSH_COM(RET_COM);
				break;
				
			case 150:
				// Execute: "push LineStyleBvr LineStyleBvr.width(NumberBvr)"
				// AUTOGENERATED
				instrTrace("push LineStyleBvr LineStyleBvr.width(NumberBvr)");
				METHOD_CALL_2(
					(IDALineStyle*)USE_COM(1),
					WidthAnim,
					(IDANumber*)USE_COM(2),
					(IDALineStyle**)RET_COM_ADDR
				);
				FREE_COM;
				FREE_COM;
				PUSH_COM(RET_COM);
				break;
				
			case 151:
				// Execute: "push LineStyleBvr LineStyleBvr.width(double)"
				// AUTOGENERATED
				instrTrace("push LineStyleBvr LineStyleBvr.width(double)");
				METHOD_CALL_2(
					(IDALineStyle*)USE_COM(1),
					width,
					USE_DOUBLE(1),
					(IDALineStyle**)RET_COM_ADDR
				);
				FREE_DOUBLE(1);
				FREE_COM;
				PUSH_COM(RET_COM);
				break;
				
			case 152:
				// Execute: "push LineStyleBvr LineStyleBvr.dash(DashStyleBvr)"
				// AUTOGENERATED
				instrTrace("push LineStyleBvr LineStyleBvr.dash(DashStyleBvr)");
				METHOD_CALL_2(
					(IDALineStyle*)USE_COM(1),
					Dash,
					(IDADashStyle*)USE_COM(2),
					(IDALineStyle**)RET_COM_ADDR
				);
				FREE_COM;
				FREE_COM;
				PUSH_COM(RET_COM);
				break;
				
			case 153:
				// Execute: "push LineStyleBvr LineStyleBvr.lineAntialiasing(double)"
				// AUTOGENERATED
				instrTrace("push LineStyleBvr LineStyleBvr.lineAntialiasing(double)");
				METHOD_CALL_2(
					(IDALineStyle*)USE_COM(1),
					AntiAliasing,
					USE_DOUBLE(1),
					(IDALineStyle**)RET_COM_ADDR
				);
				FREE_DOUBLE(1);
				FREE_COM;
				PUSH_COM(RET_COM);
				break;
				
			case 154:
				// Execute: "push FontStyleBvr FontStyleBvr.family(StringBvr)"
				// AUTOGENERATED
				instrTrace("push FontStyleBvr FontStyleBvr.family(StringBvr)");
				METHOD_CALL_2(
					(IDAFontStyle*)USE_COM(1),
					FamilyAnim,
					(IDAString*)USE_COM(2),
					(IDAFontStyle**)RET_COM_ADDR
				);
				FREE_COM;
				FREE_COM;
				PUSH_COM(RET_COM);
				break;
				
			case 155:
				// Execute: "push FontStyleBvr FontStyleBvr.family(java.lang.String)"
				// AUTOGENERATED
				instrTrace("push FontStyleBvr FontStyleBvr.family(java.lang.String)");
				METHOD_CALL_2(
					(IDAFontStyle*)USE_COM(1),
					Family,
					USE_STRING(1),
					(IDAFontStyle**)RET_COM_ADDR
				);
				FREE_STRING;
				FREE_COM;
				PUSH_COM(RET_COM);
				break;
				
			case 156:
				// Execute: "push FontStyleBvr FontStyleBvr.textAntialiasing(double)"
				// AUTOGENERATED
				instrTrace("push FontStyleBvr FontStyleBvr.textAntialiasing(double)");
				METHOD_CALL_2(
					(IDAFontStyle*)USE_COM(1),
					AntiAliasing,
					USE_DOUBLE(1),
					(IDAFontStyle**)RET_COM_ADDR
				);
				FREE_DOUBLE(1);
				FREE_COM;
				PUSH_COM(RET_COM);
				break;
				
			case 157:
				// Execute: "push FontStyleBvr FontStyleBvr.weight(double)"
				// AUTOGENERATED
				instrTrace("push FontStyleBvr FontStyleBvr.weight(double)");
				METHOD_CALL_2(
					(IDAFontStyle*)USE_COM(1),
					Weight,
					USE_DOUBLE(1),
					(IDAFontStyle**)RET_COM_ADDR
				);
				FREE_DOUBLE(1);
				FREE_COM;
				PUSH_COM(RET_COM);
				break;
				
			case 158:
				// Execute: "push FontStyleBvr FontStyleBvr.weight(NumberBvr)"
				// AUTOGENERATED
				instrTrace("push FontStyleBvr FontStyleBvr.weight(NumberBvr)");
				METHOD_CALL_2(
					(IDAFontStyle*)USE_COM(1),
					WeightAnim,
					(IDANumber*)USE_COM(2),
					(IDAFontStyle**)RET_COM_ADDR
				);
				FREE_COM;
				FREE_COM;
				PUSH_COM(RET_COM);
				break;
				
			case 159:
				// Execute: "push FontStyleBvr FontStyleBvr.underline()"
				// AUTOGENERATED
				instrTrace("push FontStyleBvr FontStyleBvr.underline()");
				METHOD_CALL_1(
					(IDAFontStyle*)USE_COM(1),
					Underline,
					(IDAFontStyle**)RET_COM_ADDR
				);
				FREE_COM;
				PUSH_COM(RET_COM);
				break;
				
			case 160:
				// Execute: "push FontStyleBvr FontStyleBvr.strikethrough()"
				// AUTOGENERATED
				instrTrace("push FontStyleBvr FontStyleBvr.strikethrough()");
				METHOD_CALL_1(
					(IDAFontStyle*)USE_COM(1),
					Strikethrough,
					(IDAFontStyle**)RET_COM_ADDR
				);
				FREE_COM;
				PUSH_COM(RET_COM);
				break;
				
			case 161:
				// Execute: "push NumberBvr Vector3Bvr.getSphericalCoordLength()"
				// AUTOGENERATED
				instrTrace("push NumberBvr Vector3Bvr.getSphericalCoordLength()");
				METHOD_CALL_1(
					(IDAVector3*)USE_COM(1),
					get_SphericalCoordLength,
					(IDANumber**)RET_COM_ADDR
				);
				FREE_COM;
				PUSH_COM(RET_COM);
				break;
				
			case 162:
				// Execute: "push NumberBvr Vector3Bvr.getSphericalCoordXYAngle()"
				// AUTOGENERATED
				instrTrace("push NumberBvr Vector3Bvr.getSphericalCoordXYAngle()");
				METHOD_CALL_1(
					(IDAVector3*)USE_COM(1),
					get_SphericalCoordXYAngle,
					(IDANumber**)RET_COM_ADDR
				);
				FREE_COM;
				PUSH_COM(RET_COM);
				break;
				
			case 163:
				// Execute: "push NumberBvr Vector3Bvr.getSphericalCoordYZAngle()"
				// AUTOGENERATED
				instrTrace("push NumberBvr Vector3Bvr.getSphericalCoordYZAngle()");
				METHOD_CALL_1(
					(IDAVector3*)USE_COM(1),
					get_SphericalCoordYZAngle,
					(IDANumber**)RET_COM_ADDR
				);
				FREE_COM;
				PUSH_COM(RET_COM);
				break;
				
			case 164:
				// Execute: "push NumberBvr Vector2Bvr.getPolarCoordAngle()"
				// AUTOGENERATED
				instrTrace("push NumberBvr Vector2Bvr.getPolarCoordAngle()");
				METHOD_CALL_1(
					(IDAVector2*)USE_COM(1),
					get_PolarCoordAngle,
					(IDANumber**)RET_COM_ADDR
				);
				FREE_COM;
				PUSH_COM(RET_COM);
				break;
				
			case 165:
				// Execute: "push NumberBvr Vector2Bvr.getPolarCoordLength()"
				// AUTOGENERATED
				instrTrace("push NumberBvr Vector2Bvr.getPolarCoordLength()");
				METHOD_CALL_1(
					(IDAVector2*)USE_COM(1),
					get_PolarCoordLength,
					(IDANumber**)RET_COM_ADDR
				);
				FREE_COM;
				PUSH_COM(RET_COM);
				break;
				
			case 166:
				// Execute: "push Transform3Bvr Transform3Bvr.inverse()"
				// AUTOGENERATED
				instrTrace("push Transform3Bvr Transform3Bvr.inverse()");
				METHOD_CALL_1(
					(IDATransform3*)USE_COM(1),
					Inverse,
					(IDATransform3**)RET_COM_ADDR
				);
				FREE_COM;
				PUSH_COM(RET_COM);
				break;
				
			case 167:
				// Execute: "push BooleanBvr Transform3Bvr.isSingular()"
				// AUTOGENERATED
				instrTrace("push BooleanBvr Transform3Bvr.isSingular()");
				METHOD_CALL_1(
					(IDATransform3*)USE_COM(1),
					get_IsSingular,
					(IDABoolean**)RET_COM_ADDR
				);
				FREE_COM;
				PUSH_COM(RET_COM);
				break;
				
			case 168:
				// Execute: "push Transform2Bvr Transform3Bvr.parallelTransform2()"
				// AUTOGENERATED
				instrTrace("push Transform2Bvr Transform3Bvr.parallelTransform2()");
				METHOD_CALL_1(
					(IDATransform3*)USE_COM(1),
					ParallelTransform2,
					(IDATransform2**)RET_COM_ADDR
				);
				FREE_COM;
				PUSH_COM(RET_COM);
				break;
				
			case 169:
				// Execute: "push Transform2Bvr Transform2Bvr.inverse()"
				// AUTOGENERATED
				instrTrace("push Transform2Bvr Transform2Bvr.inverse()");
				METHOD_CALL_1(
					(IDATransform2*)USE_COM(1),
					Inverse,
					(IDATransform2**)RET_COM_ADDR
				);
				FREE_COM;
				PUSH_COM(RET_COM);
				break;
				
			case 170:
				// Execute: "push BooleanBvr Transform2Bvr.isSingular()"
				// AUTOGENERATED
				instrTrace("push BooleanBvr Transform2Bvr.isSingular()");
				METHOD_CALL_1(
					(IDATransform2*)USE_COM(1),
					get_IsSingular,
					(IDABoolean**)RET_COM_ADDR
				);
				FREE_COM;
				PUSH_COM(RET_COM);
				break;
				
			case 171:
				// Execute: "push SoundBvr SoundBvr.rate(NumberBvr)"
				// AUTOGENERATED
				instrTrace("push SoundBvr SoundBvr.rate(NumberBvr)");
				METHOD_CALL_2(
					(IDASound*)USE_COM(1),
					RateAnim,
					(IDANumber*)USE_COM(2),
					(IDASound**)RET_COM_ADDR
				);
				FREE_COM;
				FREE_COM;
				PUSH_COM(RET_COM);
				break;
				
			case 172:
				// Execute: "push SoundBvr SoundBvr.rate(double)"
				// AUTOGENERATED
				instrTrace("push SoundBvr SoundBvr.rate(double)");
				METHOD_CALL_2(
					(IDASound*)USE_COM(1),
					Rate,
					USE_DOUBLE(1),
					(IDASound**)RET_COM_ADDR
				);
				FREE_DOUBLE(1);
				FREE_COM;
				PUSH_COM(RET_COM);
				break;
				
			case 173:
				// Execute: "push SoundBvr SoundBvr.loop()"
				// AUTOGENERATED
				instrTrace("push SoundBvr SoundBvr.loop()");
				METHOD_CALL_1(
					(IDASound*)USE_COM(1),
					Loop,
					(IDASound**)RET_COM_ADDR
				);
				FREE_COM;
				PUSH_COM(RET_COM);
				break;
				
			case 174:
				// Execute: "push SoundBvr SoundBvr.phase(NumberBvr)"
				// AUTOGENERATED
				instrTrace("push SoundBvr SoundBvr.phase(NumberBvr)");
				METHOD_CALL_2(
					(IDASound*)USE_COM(1),
					PhaseAnim,
					(IDANumber*)USE_COM(2),
					(IDASound**)RET_COM_ADDR
				);
				FREE_COM;
				FREE_COM;
				PUSH_COM(RET_COM);
				break;
				
			case 175:
				// Execute: "push SoundBvr SoundBvr.phase(double)"
				// AUTOGENERATED
				instrTrace("push SoundBvr SoundBvr.phase(double)");
				METHOD_CALL_2(
					(IDASound*)USE_COM(1),
					Phase,
					USE_DOUBLE(1),
					(IDASound**)RET_COM_ADDR
				);
				FREE_DOUBLE(1);
				FREE_COM;
				PUSH_COM(RET_COM);
				break;
				
			case 176:
				// Execute: "push SoundBvr SoundBvr.pan(NumberBvr)"
				// AUTOGENERATED
				instrTrace("push SoundBvr SoundBvr.pan(NumberBvr)");
				METHOD_CALL_2(
					(IDASound*)USE_COM(1),
					PanAnim,
					(IDANumber*)USE_COM(2),
					(IDASound**)RET_COM_ADDR
				);
				FREE_COM;
				FREE_COM;
				PUSH_COM(RET_COM);
				break;
				
			case 177:
				// Execute: "push SoundBvr SoundBvr.pan(double)"
				// AUTOGENERATED
				instrTrace("push SoundBvr SoundBvr.pan(double)");
				METHOD_CALL_2(
					(IDASound*)USE_COM(1),
					Pan,
					USE_DOUBLE(1),
					(IDASound**)RET_COM_ADDR
				);
				FREE_DOUBLE(1);
				FREE_COM;
				PUSH_COM(RET_COM);
				break;
				
			case 178:
				// Execute: "push SoundBvr SoundBvr.gain(NumberBvr)"
				// AUTOGENERATED
				instrTrace("push SoundBvr SoundBvr.gain(NumberBvr)");
				METHOD_CALL_2(
					(IDASound*)USE_COM(1),
					GainAnim,
					(IDANumber*)USE_COM(2),
					(IDASound**)RET_COM_ADDR
				);
				FREE_COM;
				FREE_COM;
				PUSH_COM(RET_COM);
				break;
				
			case 179:
				// Execute: "push SoundBvr SoundBvr.gain(double)"
				// AUTOGENERATED
				instrTrace("push SoundBvr SoundBvr.gain(double)");
				METHOD_CALL_2(
					(IDASound*)USE_COM(1),
					Gain,
					USE_DOUBLE(1),
					(IDASound**)RET_COM_ADDR
				);
				FREE_DOUBLE(1);
				FREE_COM;
				PUSH_COM(RET_COM);
				break;
				
			case 180:
				// Execute: "push Point2Bvr Point3Bvr.project(CameraBvr)"
				// AUTOGENERATED
				instrTrace("push Point2Bvr Point3Bvr.project(CameraBvr)");
				METHOD_CALL_2(
					(IDAPoint3*)USE_COM(1),
					Project,
					(IDACamera*)USE_COM(2),
					(IDAPoint2**)RET_COM_ADDR
				);
				FREE_COM;
				FREE_COM;
				PUSH_COM(RET_COM);
				break;
				
			case 181:
				// Execute: "push NumberBvr Point3Bvr.getSphericalCoordLength()"
				// AUTOGENERATED
				instrTrace("push NumberBvr Point3Bvr.getSphericalCoordLength()");
				METHOD_CALL_1(
					(IDAPoint3*)USE_COM(1),
					get_SphericalCoordLength,
					(IDANumber**)RET_COM_ADDR
				);
				FREE_COM;
				PUSH_COM(RET_COM);
				break;
				
			case 182:
				// Execute: "push NumberBvr Point3Bvr.getSphericalCoordXYAngle()"
				// AUTOGENERATED
				instrTrace("push NumberBvr Point3Bvr.getSphericalCoordXYAngle()");
				METHOD_CALL_1(
					(IDAPoint3*)USE_COM(1),
					get_SphericalCoordXYAngle,
					(IDANumber**)RET_COM_ADDR
				);
				FREE_COM;
				PUSH_COM(RET_COM);
				break;
				
			case 183:
				// Execute: "push NumberBvr Point3Bvr.getSphericalCoordYZAngle()"
				// AUTOGENERATED
				instrTrace("push NumberBvr Point3Bvr.getSphericalCoordYZAngle()");
				METHOD_CALL_1(
					(IDAPoint3*)USE_COM(1),
					get_SphericalCoordYZAngle,
					(IDANumber**)RET_COM_ADDR
				);
				FREE_COM;
				PUSH_COM(RET_COM);
				break;
				
			case 184:
				// Execute: "push NumberBvr Point2Bvr.getPolarCoordLength()"
				// AUTOGENERATED
				instrTrace("push NumberBvr Point2Bvr.getPolarCoordLength()");
				METHOD_CALL_1(
					(IDAPoint2*)USE_COM(1),
					get_PolarCoordLength,
					(IDANumber**)RET_COM_ADDR
				);
				FREE_COM;
				PUSH_COM(RET_COM);
				break;
				
			case 185:
				// Execute: "push NumberBvr Point2Bvr.getPolarCoordAngle()"
				// AUTOGENERATED
				instrTrace("push NumberBvr Point2Bvr.getPolarCoordAngle()");
				METHOD_CALL_1(
					(IDAPoint2*)USE_COM(1),
					get_PolarCoordAngle,
					(IDANumber**)RET_COM_ADDR
				);
				FREE_COM;
				PUSH_COM(RET_COM);
				break;
				
			case 186:
				// Execute: "push StringBvr NumberBvr.toString(NumberBvr)"
				// AUTOGENERATED
				instrTrace("push StringBvr NumberBvr.toString(NumberBvr)");
				METHOD_CALL_2(
					(IDANumber*)USE_COM(1),
					ToStringAnim,
					(IDANumber*)USE_COM(2),
					(IDAString**)RET_COM_ADDR
				);
				FREE_COM;
				FREE_COM;
				PUSH_COM(RET_COM);
				break;
				
			case 187:
				// Execute: "push StringBvr NumberBvr.toString(double)"
				// AUTOGENERATED
				instrTrace("push StringBvr NumberBvr.toString(double)");
				METHOD_CALL_2(
					(IDANumber*)USE_COM(1),
					ToString,
					USE_DOUBLE(1),
					(IDAString**)RET_COM_ADDR
				);
				FREE_DOUBLE(1);
				FREE_COM;
				PUSH_COM(RET_COM);
				break;
				
			case 188:
				// Execute: "push ImageBvr MontageBvr.render()"
				// AUTOGENERATED
				instrTrace("push ImageBvr MontageBvr.render()");
				METHOD_CALL_1(
					(IDAMontage*)USE_COM(1),
					Render,
					(IDAImage**)RET_COM_ADDR
				);
				FREE_COM;
				PUSH_COM(RET_COM);
				break;
				
			case 189:
				// Execute: "push MicrophoneBvr MicrophoneBvr.transform(Transform3Bvr)"
				// AUTOGENERATED
				instrTrace("push MicrophoneBvr MicrophoneBvr.transform(Transform3Bvr)");
				METHOD_CALL_2(
					(IDAMicrophone*)USE_COM(1),
					Transform,
					(IDATransform3*)USE_COM(2),
					(IDAMicrophone**)RET_COM_ADDR
				);
				FREE_COM;
				FREE_COM;
				PUSH_COM(RET_COM);
				break;
				
			case 190:
				// Execute: "push SoundBvr GeometryBvr.render(MicrophoneBvr)"
				// AUTOGENERATED
				instrTrace("push SoundBvr GeometryBvr.render(MicrophoneBvr)");
				METHOD_CALL_2(
					(IDAGeometry*)USE_COM(1),
					RenderSound,
					(IDAMicrophone*)USE_COM(2),
					(IDASound**)RET_COM_ADDR
				);
				FREE_COM;
				FREE_COM;
				PUSH_COM(RET_COM);
				break;
				
			case 191:
				// Execute: "push GeometryBvr GeometryBvr.transform(Transform3Bvr)"
				// AUTOGENERATED
				instrTrace("push GeometryBvr GeometryBvr.transform(Transform3Bvr)");
				METHOD_CALL_2(
					(IDAGeometry*)USE_COM(1),
					Transform,
					(IDATransform3*)USE_COM(2),
					(IDAGeometry**)RET_COM_ADDR
				);
				FREE_COM;
				FREE_COM;
				PUSH_COM(RET_COM);
				break;
				
			case 192:
				// Execute: "push ImageBvr GeometryBvr.render(CameraBvr)"
				// AUTOGENERATED
				instrTrace("push ImageBvr GeometryBvr.render(CameraBvr)");
				METHOD_CALL_2(
					(IDAGeometry*)USE_COM(1),
					Render,
					(IDACamera*)USE_COM(2),
					(IDAImage**)RET_COM_ADDR
				);
				FREE_COM;
				FREE_COM;
				PUSH_COM(RET_COM);
				break;
				
			case 193:
				// Execute: "push Bbox3Bvr GeometryBvr.boundingBox()"
				// AUTOGENERATED
				instrTrace("push Bbox3Bvr GeometryBvr.boundingBox()");
				METHOD_CALL_1(
					(IDAGeometry*)USE_COM(1),
					get_BoundingBox,
					(IDABbox3**)RET_COM_ADDR
				);
				FREE_COM;
				PUSH_COM(RET_COM);
				break;
				
			case 194:
				// Execute: "push GeometryBvr GeometryBvr.undetectable()"
				// AUTOGENERATED
				instrTrace("push GeometryBvr GeometryBvr.undetectable()");
				METHOD_CALL_1(
					(IDAGeometry*)USE_COM(1),
					Undetectable,
					(IDAGeometry**)RET_COM_ADDR
				);
				FREE_COM;
				PUSH_COM(RET_COM);
				break;
				
			case 195:
				// Execute: "push NumberBvr ColorBvr.getRed()"
				// AUTOGENERATED
				instrTrace("push NumberBvr ColorBvr.getRed()");
				METHOD_CALL_1(
					(IDAColor*)USE_COM(1),
					get_Red,
					(IDANumber**)RET_COM_ADDR
				);
				FREE_COM;
				PUSH_COM(RET_COM);
				break;
				
			case 196:
				// Execute: "push NumberBvr ColorBvr.getSaturation()"
				// AUTOGENERATED
				instrTrace("push NumberBvr ColorBvr.getSaturation()");
				METHOD_CALL_1(
					(IDAColor*)USE_COM(1),
					get_Saturation,
					(IDANumber**)RET_COM_ADDR
				);
				FREE_COM;
				PUSH_COM(RET_COM);
				break;
				
			case 197:
				// Execute: "push NumberBvr ColorBvr.getHue()"
				// AUTOGENERATED
				instrTrace("push NumberBvr ColorBvr.getHue()");
				METHOD_CALL_1(
					(IDAColor*)USE_COM(1),
					get_Hue,
					(IDANumber**)RET_COM_ADDR
				);
				FREE_COM;
				PUSH_COM(RET_COM);
				break;
				
			case 198:
				// Execute: "push NumberBvr ColorBvr.getBlue()"
				// AUTOGENERATED
				instrTrace("push NumberBvr ColorBvr.getBlue()");
				METHOD_CALL_1(
					(IDAColor*)USE_COM(1),
					get_Blue,
					(IDANumber**)RET_COM_ADDR
				);
				FREE_COM;
				PUSH_COM(RET_COM);
				break;
				
			case 199:
				// Execute: "push NumberBvr ColorBvr.getGreen()"
				// AUTOGENERATED
				instrTrace("push NumberBvr ColorBvr.getGreen()");
				METHOD_CALL_1(
					(IDAColor*)USE_COM(1),
					get_Green,
					(IDANumber**)RET_COM_ADDR
				);
				FREE_COM;
				PUSH_COM(RET_COM);
				break;
				
			case 200:
				// Execute: "push NumberBvr ColorBvr.getLightness()"
				// AUTOGENERATED
				instrTrace("push NumberBvr ColorBvr.getLightness()");
				METHOD_CALL_1(
					(IDAColor*)USE_COM(1),
					get_Lightness,
					(IDANumber**)RET_COM_ADDR
				);
				FREE_COM;
				PUSH_COM(RET_COM);
				break;
				
			case 201:
				// Execute: "push CameraBvr CameraBvr.depthResolution(double)"
				// AUTOGENERATED
				instrTrace("push CameraBvr CameraBvr.depthResolution(double)");
				METHOD_CALL_2(
					(IDACamera*)USE_COM(1),
					DepthResolution,
					USE_DOUBLE(1),
					(IDACamera**)RET_COM_ADDR
				);
				FREE_DOUBLE(1);
				FREE_COM;
				PUSH_COM(RET_COM);
				break;
				
			case 202:
				// Execute: "push CameraBvr CameraBvr.depthResolution(NumberBvr)"
				// AUTOGENERATED
				instrTrace("push CameraBvr CameraBvr.depthResolution(NumberBvr)");
				METHOD_CALL_2(
					(IDACamera*)USE_COM(1),
					DepthResolutionAnim,
					(IDANumber*)USE_COM(2),
					(IDACamera**)RET_COM_ADDR
				);
				FREE_COM;
				FREE_COM;
				PUSH_COM(RET_COM);
				break;
				
			case 203:
				// Execute: "push CameraBvr CameraBvr.transform(Transform3Bvr)"
				// AUTOGENERATED
				instrTrace("push CameraBvr CameraBvr.transform(Transform3Bvr)");
				METHOD_CALL_2(
					(IDACamera*)USE_COM(1),
					Transform,
					(IDATransform3*)USE_COM(2),
					(IDACamera**)RET_COM_ADDR
				);
				FREE_COM;
				FREE_COM;
				PUSH_COM(RET_COM);
				break;
				
			case 204:
				// Execute: "push CameraBvr CameraBvr.depth(double)"
				// AUTOGENERATED
				instrTrace("push CameraBvr CameraBvr.depth(double)");
				METHOD_CALL_2(
					(IDACamera*)USE_COM(1),
					Depth,
					USE_DOUBLE(1),
					(IDACamera**)RET_COM_ADDR
				);
				FREE_DOUBLE(1);
				FREE_COM;
				PUSH_COM(RET_COM);
				break;
				
			case 205:
				// Execute: "push CameraBvr CameraBvr.depth(NumberBvr)"
				// AUTOGENERATED
				instrTrace("push CameraBvr CameraBvr.depth(NumberBvr)");
				METHOD_CALL_2(
					(IDACamera*)USE_COM(1),
					DepthAnim,
					(IDANumber*)USE_COM(2),
					(IDACamera**)RET_COM_ADDR
				);
				FREE_COM;
				FREE_COM;
				PUSH_COM(RET_COM);
				break;
				
			case 206:
				// Execute: "push Statics.aqua"
				// AUTOGENERATED
				instrTrace("push Statics.aqua");
				METHOD_CALL_1(
					staticStatics,
					get_Aqua,
					(IDAColor**)PUSH_COM_ADDR
				);
				break;
				
			case 207:
				// Execute: "push Statics.fuchsia"
				// AUTOGENERATED
				instrTrace("push Statics.fuchsia");
				METHOD_CALL_1(
					staticStatics,
					get_Fuchsia,
					(IDAColor**)PUSH_COM_ADDR
				);
				break;
				
			case 208:
				// Execute: "push Statics.gray"
				// AUTOGENERATED
				instrTrace("push Statics.gray");
				METHOD_CALL_1(
					staticStatics,
					get_Gray,
					(IDAColor**)PUSH_COM_ADDR
				);
				break;
				
			case 209:
				// Execute: "push Statics.lime"
				// AUTOGENERATED
				instrTrace("push Statics.lime");
				METHOD_CALL_1(
					staticStatics,
					get_Lime,
					(IDAColor**)PUSH_COM_ADDR
				);
				break;
				
			case 210:
				// Execute: "push Statics.maroon"
				// AUTOGENERATED
				instrTrace("push Statics.maroon");
				METHOD_CALL_1(
					staticStatics,
					get_Maroon,
					(IDAColor**)PUSH_COM_ADDR
				);
				break;
				
			case 211:
				// Execute: "push Statics.navy"
				// AUTOGENERATED
				instrTrace("push Statics.navy");
				METHOD_CALL_1(
					staticStatics,
					get_Navy,
					(IDAColor**)PUSH_COM_ADDR
				);
				break;
				
			case 212:
				// Execute: "push Statics.olive"
				// AUTOGENERATED
				instrTrace("push Statics.olive");
				METHOD_CALL_1(
					staticStatics,
					get_Olive,
					(IDAColor**)PUSH_COM_ADDR
				);
				break;
				
			case 213:
				// Execute: "push Statics.purple"
				// AUTOGENERATED
				instrTrace("push Statics.purple");
				METHOD_CALL_1(
					staticStatics,
					get_Purple,
					(IDAColor**)PUSH_COM_ADDR
				);
				break;
				
			case 214:
				// Execute: "push Statics.silver"
				// AUTOGENERATED
				instrTrace("push Statics.silver");
				METHOD_CALL_1(
					staticStatics,
					get_Silver,
					(IDAColor**)PUSH_COM_ADDR
				);
				break;
				
			case 215:
				// Execute: "push Statics.teal"
				// AUTOGENERATED
				instrTrace("push Statics.teal");
				METHOD_CALL_1(
					staticStatics,
					get_Teal,
					(IDAColor**)PUSH_COM_ADDR
				);
				break;
				
			case 216:
				// Execute: "push NumberBvr StaticsBase.seededRandom(double)"
				// AUTOGENERATED
				instrTrace("push NumberBvr StaticsBase.seededRandom(double)");
				METHOD_CALL_2(
					staticStatics,
					SeededRandom,
					USE_DOUBLE(1),
					(IDANumber**)RET_COM_ADDR
				);
				FREE_DOUBLE(1);
				PUSH_COM(RET_COM);
				break;
				
			case 217:
				// Execute: "push Behavior StaticsBase.cond(BooleanBvr, Behavior, Behavior)"
				// AUTOGENERATED
				instrTrace("push Behavior StaticsBase.cond(BooleanBvr, Behavior, Behavior)");
				METHOD_CALL_4(
					staticStatics,
					Cond,
					(IDABoolean*)USE_COM(1),
					(IDABehavior*)USE_COM(2),
					(IDABehavior*)USE_COM(3),
					(IDABehavior**)RET_COM_ADDR
				);
				FREE_COM;
				FREE_COM;
				FREE_COM;
				PUSH_COM(RET_COM);
				break;
				
			case 218:
				// Execute: "push ImageBvr Statics.importImage(java.lang.String)"
				// AUTOGENERATED
				instrTrace("push ImageBvr Statics.importImage(java.lang.String)");
				IMPORT_METHOD_CALL_2(
					staticStatics,
					ImportImage,
					USE_STRING(1),
					(IDAImage**)RET_COM_ADDR
				);
				FREE_STRING;
				PUSH_COM(RET_COM);
				break;
				
			case 219:
				// Execute: "push BooleanBvr Statics.keyState(NumberBvr)"
				// AUTOGENERATED
				instrTrace("push BooleanBvr Statics.keyState(NumberBvr)");
				METHOD_CALL_2(
					staticStatics,
					KeyState,
					(IDANumber*)USE_COM(1),
					(IDABoolean**)RET_COM_ADDR
				);
				FREE_COM;
				PUSH_COM(RET_COM);
				break;
				
			case 220:
				// Execute: "push NumberBvr StaticsBase.bSpline(int, NumberBvr[], NumberBvr[], NumberBvr[], NumberBvr)"
				// AUTOGENERATED
				instrTrace("push NumberBvr StaticsBase.bSpline(int, NumberBvr[], NumberBvr[], NumberBvr[], NumberBvr)");
				METHOD_CALL_9(
					staticStatics,
					NumberBSplineEx,
					USE_LONG(1),
					USE_COM_ARRAY_LENGTH(1),
					(IDANumber**)USE_COM_ARRAY(1),
					USE_COM_ARRAY_LENGTH(2),
					(IDANumber**)USE_COM_ARRAY(2),
					USE_COM_ARRAY_LENGTH(3),
					(IDANumber**)USE_COM_ARRAY(3),
					(IDANumber*)USE_COM(1),
					(IDANumber**)RET_COM_ADDR
				);
				FREE_LONG(1);
				FREE_COM;
				FREE_COM_ARRAY;
				FREE_COM_ARRAY;
				FREE_COM_ARRAY;
				PUSH_COM(RET_COM);
				break;
				
			case 221:
				// Execute: "push Point2Bvr StaticsBase.bSpline(int, NumberBvr[], Point2Bvr[], NumberBvr[], NumberBvr)"
				// AUTOGENERATED
				instrTrace("push Point2Bvr StaticsBase.bSpline(int, NumberBvr[], Point2Bvr[], NumberBvr[], NumberBvr)");
				METHOD_CALL_9(
					staticStatics,
					Point2BSplineEx,
					USE_LONG(1),
					USE_COM_ARRAY_LENGTH(1),
					(IDANumber**)USE_COM_ARRAY(1),
					USE_COM_ARRAY_LENGTH(2),
					(IDAPoint2**)USE_COM_ARRAY(2),
					USE_COM_ARRAY_LENGTH(3),
					(IDANumber**)USE_COM_ARRAY(3),
					(IDANumber*)USE_COM(1),
					(IDAPoint2**)RET_COM_ADDR
				);
				FREE_LONG(1);
				FREE_COM;
				FREE_COM_ARRAY;
				FREE_COM_ARRAY;
				FREE_COM_ARRAY;
				PUSH_COM(RET_COM);
				break;
				
			case 222:
				// Execute: "push Point3Bvr StaticsBase.bSpline(int, NumberBvr[], Point3Bvr[], NumberBvr[], NumberBvr)"
				// AUTOGENERATED
				instrTrace("push Point3Bvr StaticsBase.bSpline(int, NumberBvr[], Point3Bvr[], NumberBvr[], NumberBvr)");
				METHOD_CALL_9(
					staticStatics,
					Point3BSplineEx,
					USE_LONG(1),
					USE_COM_ARRAY_LENGTH(1),
					(IDANumber**)USE_COM_ARRAY(1),
					USE_COM_ARRAY_LENGTH(2),
					(IDAPoint3**)USE_COM_ARRAY(2),
					USE_COM_ARRAY_LENGTH(3),
					(IDANumber**)USE_COM_ARRAY(3),
					(IDANumber*)USE_COM(1),
					(IDAPoint3**)RET_COM_ADDR
				);
				FREE_LONG(1);
				FREE_COM;
				FREE_COM_ARRAY;
				FREE_COM_ARRAY;
				FREE_COM_ARRAY;
				PUSH_COM(RET_COM);
				break;
				
			case 223:
				// Execute: "push Vector2Bvr StaticsBase.bSpline(int, NumberBvr[], Vector2Bvr[], NumberBvr[], NumberBvr)"
				// AUTOGENERATED
				instrTrace("push Vector2Bvr StaticsBase.bSpline(int, NumberBvr[], Vector2Bvr[], NumberBvr[], NumberBvr)");
				METHOD_CALL_9(
					staticStatics,
					Vector2BSplineEx,
					USE_LONG(1),
					USE_COM_ARRAY_LENGTH(1),
					(IDANumber**)USE_COM_ARRAY(1),
					USE_COM_ARRAY_LENGTH(2),
					(IDAVector2**)USE_COM_ARRAY(2),
					USE_COM_ARRAY_LENGTH(3),
					(IDANumber**)USE_COM_ARRAY(3),
					(IDANumber*)USE_COM(1),
					(IDAVector2**)RET_COM_ADDR
				);
				FREE_LONG(1);
				FREE_COM;
				FREE_COM_ARRAY;
				FREE_COM_ARRAY;
				FREE_COM_ARRAY;
				PUSH_COM(RET_COM);
				break;
				
			case 224:
				// Execute: "push Vector3Bvr StaticsBase.bSpline(int, NumberBvr[], Vector3Bvr[], NumberBvr[], NumberBvr)"
				// AUTOGENERATED
				instrTrace("push Vector3Bvr StaticsBase.bSpline(int, NumberBvr[], Vector3Bvr[], NumberBvr[], NumberBvr)");
				METHOD_CALL_9(
					staticStatics,
					Vector3BSplineEx,
					USE_LONG(1),
					USE_COM_ARRAY_LENGTH(1),
					(IDANumber**)USE_COM_ARRAY(1),
					USE_COM_ARRAY_LENGTH(2),
					(IDAVector3**)USE_COM_ARRAY(2),
					USE_COM_ARRAY_LENGTH(3),
					(IDANumber**)USE_COM_ARRAY(3),
					(IDANumber*)USE_COM(1),
					(IDAVector3**)RET_COM_ADDR
				);
				FREE_LONG(1);
				FREE_COM;
				FREE_COM_ARRAY;
				FREE_COM_ARRAY;
				FREE_COM_ARRAY;
				PUSH_COM(RET_COM);
				break;
				
			case 225:
				// Execute: "push DXMEvent DXMEvent.newUninitBvr()"
				// AUTOGENERATED
				instrTrace("push DXMEvent DXMEvent.newUninitBvr()");
				COM_CREATE(
					CLSID_DAEvent, 
					IID_IDAEvent, 
					PUSH_COM_ADDR
				);
				break;
				
			case 226:
				// Execute: "push Bbox3Bvr Bbox3Bvr.newUninitBvr()"
				// AUTOGENERATED
				instrTrace("push Bbox3Bvr Bbox3Bvr.newUninitBvr()");
				COM_CREATE(
					CLSID_DABbox3, 
					IID_IDABbox3, 
					PUSH_COM_ADDR
				);
				break;
				
			case 227:
				// Execute: "push Bbox2Bvr Bbox2Bvr.newUninitBvr()"
				// AUTOGENERATED
				instrTrace("push Bbox2Bvr Bbox2Bvr.newUninitBvr()");
				COM_CREATE(
					CLSID_DABbox2, 
					IID_IDABbox2, 
					PUSH_COM_ADDR
				);
				break;
				
			case 228:
				// Execute: "push DashStyleBvr DashStyleBvr.newUninitBvr()"
				// AUTOGENERATED
				instrTrace("push DashStyleBvr DashStyleBvr.newUninitBvr()");
				COM_CREATE(
					CLSID_DADashStyle, 
					IID_IDADashStyle, 
					PUSH_COM_ADDR
				);
				break;
				
			case 229:
				// Execute: "push JoinStyleBvr JoinStyleBvr.newUninitBvr()"
				// AUTOGENERATED
				instrTrace("push JoinStyleBvr JoinStyleBvr.newUninitBvr()");
				COM_CREATE(
					CLSID_DAJoinStyle, 
					IID_IDAJoinStyle, 
					PUSH_COM_ADDR
				);
				break;
				
			case 230:
				// Execute: "push EndStyleBvr EndStyleBvr.newUninitBvr()"
				// AUTOGENERATED
				instrTrace("push EndStyleBvr EndStyleBvr.newUninitBvr()");
				COM_CREATE(
					CLSID_DAEndStyle, 
					IID_IDAEndStyle, 
					PUSH_COM_ADDR
				);
				break;
				
			case 231:
				// Execute: "push LineStyleBvr LineStyleBvr.newUninitBvr()"
				// AUTOGENERATED
				instrTrace("push LineStyleBvr LineStyleBvr.newUninitBvr()");
				COM_CREATE(
					CLSID_DALineStyle, 
					IID_IDALineStyle, 
					PUSH_COM_ADDR
				);
				break;
				
			case 232:
				// Execute: "push FontStyleBvr FontStyleBvr.newUninitBvr()"
				// AUTOGENERATED
				instrTrace("push FontStyleBvr FontStyleBvr.newUninitBvr()");
				COM_CREATE(
					CLSID_DAFontStyle, 
					IID_IDAFontStyle, 
					PUSH_COM_ADDR
				);
				break;
				
			case 233:
				// Execute: "push Vector3Bvr Vector3Bvr.newUninitBvr()"
				// AUTOGENERATED
				instrTrace("push Vector3Bvr Vector3Bvr.newUninitBvr()");
				COM_CREATE(
					CLSID_DAVector3, 
					IID_IDAVector3, 
					PUSH_COM_ADDR
				);
				break;
				
			case 234:
				// Execute: "push Vector2Bvr Vector2Bvr.newUninitBvr()"
				// AUTOGENERATED
				instrTrace("push Vector2Bvr Vector2Bvr.newUninitBvr()");
				COM_CREATE(
					CLSID_DAVector2, 
					IID_IDAVector2, 
					PUSH_COM_ADDR
				);
				break;
				
			case 235:
				// Execute: "push Transform3Bvr Transform3Bvr.newUninitBvr()"
				// AUTOGENERATED
				instrTrace("push Transform3Bvr Transform3Bvr.newUninitBvr()");
				COM_CREATE(
					CLSID_DATransform3, 
					IID_IDATransform3, 
					PUSH_COM_ADDR
				);
				break;
				
			case 236:
				// Execute: "push Transform2Bvr Transform2Bvr.newUninitBvr()"
				// AUTOGENERATED
				instrTrace("push Transform2Bvr Transform2Bvr.newUninitBvr()");
				COM_CREATE(
					CLSID_DATransform2, 
					IID_IDATransform2, 
					PUSH_COM_ADDR
				);
				break;
				
			case 237:
				// Execute: "push StringBvr StringBvr.newUninitBvr()"
				// AUTOGENERATED
				instrTrace("push StringBvr StringBvr.newUninitBvr()");
				COM_CREATE(
					CLSID_DAString, 
					IID_IDAString, 
					PUSH_COM_ADDR
				);
				break;
				
			case 238:
				// Execute: "push SoundBvr SoundBvr.newUninitBvr()"
				// AUTOGENERATED
				instrTrace("push SoundBvr SoundBvr.newUninitBvr()");
				COM_CREATE(
					CLSID_DASound, 
					IID_IDASound, 
					PUSH_COM_ADDR
				);
				break;
				
			case 239:
				// Execute: "push Point3Bvr Point3Bvr.newUninitBvr()"
				// AUTOGENERATED
				instrTrace("push Point3Bvr Point3Bvr.newUninitBvr()");
				COM_CREATE(
					CLSID_DAPoint3, 
					IID_IDAPoint3, 
					PUSH_COM_ADDR
				);
				break;
				
			case 240:
				// Execute: "push Point2Bvr Point2Bvr.newUninitBvr()"
				// AUTOGENERATED
				instrTrace("push Point2Bvr Point2Bvr.newUninitBvr()");
				COM_CREATE(
					CLSID_DAPoint2, 
					IID_IDAPoint2, 
					PUSH_COM_ADDR
				);
				break;
				
			case 241:
				// Execute: "push Path2Bvr Path2Bvr.newUninitBvr()"
				// AUTOGENERATED
				instrTrace("push Path2Bvr Path2Bvr.newUninitBvr()");
				COM_CREATE(
					CLSID_DAPath2, 
					IID_IDAPath2, 
					PUSH_COM_ADDR
				);
				break;
				
			case 242:
				// Execute: "push NumberBvr NumberBvr.newUninitBvr()"
				// AUTOGENERATED
				instrTrace("push NumberBvr NumberBvr.newUninitBvr()");
				COM_CREATE(
					CLSID_DANumber, 
					IID_IDANumber, 
					PUSH_COM_ADDR
				);
				break;
				
			case 243:
				// Execute: "push MontageBvr MontageBvr.newUninitBvr()"
				// AUTOGENERATED
				instrTrace("push MontageBvr MontageBvr.newUninitBvr()");
				COM_CREATE(
					CLSID_DAMontage, 
					IID_IDAMontage, 
					PUSH_COM_ADDR
				);
				break;
				
			case 244:
				// Execute: "push MicrophoneBvr MicrophoneBvr.newUninitBvr()"
				// AUTOGENERATED
				instrTrace("push MicrophoneBvr MicrophoneBvr.newUninitBvr()");
				COM_CREATE(
					CLSID_DAMicrophone, 
					IID_IDAMicrophone, 
					PUSH_COM_ADDR
				);
				break;
				
			case 245:
				// Execute: "push MatteBvr MatteBvr.newUninitBvr()"
				// AUTOGENERATED
				instrTrace("push MatteBvr MatteBvr.newUninitBvr()");
				COM_CREATE(
					CLSID_DAMatte, 
					IID_IDAMatte, 
					PUSH_COM_ADDR
				);
				break;
				
			case 246:
				// Execute: "push ImageBvr ImageBvr.newUninitBvr()"
				// AUTOGENERATED
				instrTrace("push ImageBvr ImageBvr.newUninitBvr()");
				COM_CREATE(
					CLSID_DAImage, 
					IID_IDAImage, 
					PUSH_COM_ADDR
				);
				break;
				
			case 247:
				// Execute: "push GeometryBvr GeometryBvr.newUninitBvr()"
				// AUTOGENERATED
				instrTrace("push GeometryBvr GeometryBvr.newUninitBvr()");
				COM_CREATE(
					CLSID_DAGeometry, 
					IID_IDAGeometry, 
					PUSH_COM_ADDR
				);
				break;
				
			case 248:
				// Execute: "push ColorBvr ColorBvr.newUninitBvr()"
				// AUTOGENERATED
				instrTrace("push ColorBvr ColorBvr.newUninitBvr()");
				COM_CREATE(
					CLSID_DAColor, 
					IID_IDAColor, 
					PUSH_COM_ADDR
				);
				break;
				
			case 249:
				// Execute: "push CameraBvr CameraBvr.newUninitBvr()"
				// AUTOGENERATED
				instrTrace("push CameraBvr CameraBvr.newUninitBvr()");
				COM_CREATE(
					CLSID_DACamera, 
					IID_IDACamera, 
					PUSH_COM_ADDR
				);
				break;
				
			case 250:
				// Execute: "push BooleanBvr BooleanBvr.newUninitBvr()"
				// AUTOGENERATED
				instrTrace("push BooleanBvr BooleanBvr.newUninitBvr()");
				COM_CREATE(
					CLSID_DABoolean, 
					IID_IDABoolean, 
					PUSH_COM_ADDR
				);
				break;
				
			case 251:
				// Execute: "call Engine.navigate(java.lang.String, java.lang.String, java.lang.String, int)"
				// USER GENERATED
				instrTrace("call Engine.navigate(java.lang.String, java.lang.String, java.lang.String, int)");
				
				//if the version of da that we are using is not the ie40 version
				if( getDAVersionAsDouble() != 501150828 )
				{
					status = navigate(
						USE_STRING(1),
						USE_STRING(2),
						USE_STRING(3),
						USE_LONG(1)
						);
					FREE_LONG(1);
					FREE_STRING;
					FREE_STRING;
					FREE_STRING;
				} else { //we are running the ie40 version of da
					//in this case the byte code has assumed that this is an old LMRT and is using
					// the 3 argument version of navigate, we need to translate
					
					bstrTmp1 = SysAllocString( L"_top" );
					status = navigate(
									  USE_STRING(1),
									  USE_STRING(2),
									  bstrTmp1,
									  USE_LONG(1)
									  );
					SysFreeString( bstrTmp1 );
					FREE_LONG(1);
					FREE_STRING;
					FREE_STRING;
					
				
				}
				
				status = S_OK;
				break;
				
			case 252:
				// Execute: "call Engine.exportBvr(java.lang.String, Behavior)"
				// USER GENERATED
				{
					IDABehavior *pBvr;
					status = USE_COM(1)->QueryInterface( IID_IDABehavior, (void**)&pBvr );
					if( SUCCEEDED( status ) )
					{
						status = ExportBehavior( USE_STRING(1), pBvr );
						pBvr->Release();
					}
				}
				FREE_STRING;
				FREE_COM;
				break;
				
			case 253:
				// Execute: "push ViewerControl Engine.getViewerControl(java.lang.String)"
				// USER GENERATED
				instrTrace("push ViewerControl Engine.getViewerControl(java.lang.String)");
				status = getDAViewerOnPage(
					USE_STRING(1),
					(IDAViewerControl**)RET_COM_ADDR
				);
				FREE_STRING;
				PUSH_COM(RET_COM);
				break;
				
			case 254:
				// Execute: "call ViewerControl.setBackgroundImage(ImageBvr)"
				// AUTOGENERATED
				instrTrace("call ViewerControl.setBackgroundImage(ImageBvr)");
				METHOD_CALL_1(
					(IDAViewerControl*)USE_COM(1),
					put_BackgroundImage,
					(IDAImage*)USE_COM(2)
				);
				FREE_COM;
				FREE_COM;
				break;
				
			case 255:
				// Execute: "call ViewerControl.setOpaqueForHitDetect(boolean)"
				// AUTOGENERATED
				instrTrace("call ViewerControl.setOpaqueForHitDetect(boolean)");
				METHOD_CALL_1(
					(IDAViewerControl*)USE_COM(1),
					put_OpaqueForHitDetect,
					USE_LONG_AS_BOOL(1)
				);
				FREE_LONG(1);
				FREE_COM;
				break;
				
			default:
				status = E_INVALIDARG;
				break;
			}
			break;
		
		case 254:
			// Switch for 254
			 if (!SUCCEEDED(status = codeStream->readByte(&command))) 
				continue; 
			switch (command)
			{
			case 0:
				// Execute: "call ViewerControl.addBehaviorToRun(Behavior)"
				// AUTOGENERATED
				instrTrace("call ViewerControl.addBehaviorToRun(Behavior)");
				METHOD_CALL_1(
					(IDAViewerControl*)USE_COM(1),
					AddBehaviorToRun,
					(IDABehavior*)USE_COM(2)
				);
				FREE_COM;
				FREE_COM;
				break;
				
			case 1:
				// Execute: "call ViewerControl.start()"
				// AUTOGENERATED
				instrTrace("call ViewerControl.start()");
				METHOD_CALL_0(
					(IDAViewerControl*)USE_COM(1),
					Start
				);
				FREE_COM;
				break;
				
			case 2:
				// Execute: "call ViewerControl.setImage(ImageBvr)"
				// USER GENERATED
				instrTrace("call ViewerControl.setImage(ImageBvr)");
				{
					IDAImage *rootImage = (IDAImage*)USE_COM(2);
					IDAImage *finalImage = NULL;

					if( m_bEnableAutoAntialias )
					{
						CComQIPtr<IDA2Image, &IID_IDA2Image> root2Image(rootImage);
						
						if( root2Image != NULL )
						{
							if( FAILED( root2Image->ImageQuality( DAQUAL_AA_LINES_ON | DAQUAL_AA_SOLIDS_ON | DAQUAL_AA_TEXT_ON, 
																  &finalImage ) ) )
							{
								finalImage = rootImage;
							}
							if( finalImage == NULL )
							{
								finalImage = rootImage;
							}
						} 
						else
						{
							finalImage = rootImage;
						}
					}else { //AutoAntiAlias is disabled.
						//use the root Image we were passed
						finalImage = rootImage;
					}
				
					METHOD_CALL_1(
						(IDAViewerControl*)USE_COM(1),
						put_Image,
						//(IDAImage*)USE_COM(2)
						finalImage
					);
					if( finalImage != rootImage )
						finalImage->Release();
					FREE_COM;
					FREE_COM;
				}
				break;
				
			case 3:
				// Execute: "call ViewerControl.setSound(SoundBvr)"
				// AUTOGENERATED
				instrTrace("call ViewerControl.setSound(SoundBvr)");
				METHOD_CALL_1(
					(IDAViewerControl*)USE_COM(1),
					put_Sound,
					(IDASound*)USE_COM(2)
				);
				FREE_COM;
				FREE_COM;
				break;
				
			case 4:
				// Execute: "call ViewerControl.setUpdateInterval(double)"
				// AUTOGENERATED
				instrTrace("call ViewerControl.setUpdateInterval(double)");
				METHOD_CALL_1(
					(IDAViewerControl*)USE_COM(1),
					put_UpdateInterval,
					USE_DOUBLE(1)
				);
				FREE_DOUBLE(1);
				FREE_COM;
				break;
				
			case 5:
				// Execute: "push Behavior PairBvr.getFirst()"
				// AUTOGENERATED
				instrTrace("push Behavior PairBvr.getFirst()");
				METHOD_CALL_1(
					(IDAPair*)USE_COM(1),
					get_First,
					(IDABehavior**)RET_COM_ADDR
				);
				FREE_COM;
				PUSH_COM(RET_COM);
				break;
				
			case 6:
				// Execute: "push Behavior PairBvr.getSecond()"
				// AUTOGENERATED
				instrTrace("push Behavior PairBvr.getSecond()");
				METHOD_CALL_1(
					(IDAPair*)USE_COM(1),
					get_Second,
					(IDABehavior**)RET_COM_ADDR
				);
				FREE_COM;
				PUSH_COM(RET_COM);
				break;
				
			case 7:
				// Execute: "push StringBvr StringBvr.animateProperty(java.lang.String, java.lang.String, boolean, double)"
				// AUTOGENERATED
				instrTrace("push StringBvr StringBvr.animateProperty(java.lang.String, java.lang.String, boolean, double)");
				METHOD_CALL_5(
					(IDAString*)USE_COM(1),
					AnimateProperty,
					USE_STRING(1),
					USE_STRING(2),
					USE_LONG_AS_BOOL(1),
					USE_DOUBLE(1),
					(IDAString**)RET_COM_ADDR
				);
				FREE_LONG(1);
				FREE_DOUBLE(1);
				FREE_STRING;
				FREE_STRING;
				FREE_COM;
				PUSH_COM(RET_COM);
				break;
				
			case 8:
				// Execute: "push Point2Bvr Point2Bvr.animateControlPositionPixel(java.lang.String, java.lang.String, boolean, double)"
				// AUTOGENERATED
				instrTrace("push Point2Bvr Point2Bvr.animateControlPositionPixel(java.lang.String, java.lang.String, boolean, double)");
				METHOD_CALL_5(
					(IDAPoint2*)USE_COM(1),
					AnimateControlPositionPixel,
					USE_STRING(1),
					USE_STRING(2),
					USE_LONG_AS_BOOL(1),
					USE_DOUBLE(1),
					(IDAPoint2**)RET_COM_ADDR
				);
				FREE_LONG(1);
				FREE_DOUBLE(1);
				FREE_STRING;
				FREE_STRING;
				FREE_COM;
				PUSH_COM(RET_COM);
				break;
				
			case 9:
				// Execute: "push Point2Bvr Point2Bvr.animateControlPosition(java.lang.String, java.lang.String, boolean, double)"
				// AUTOGENERATED
				instrTrace("push Point2Bvr Point2Bvr.animateControlPosition(java.lang.String, java.lang.String, boolean, double)");
				METHOD_CALL_5(
					(IDAPoint2*)USE_COM(1),
					AnimateControlPosition,
					USE_STRING(1),
					USE_STRING(2),
					USE_LONG_AS_BOOL(1),
					USE_DOUBLE(1),
					(IDAPoint2**)RET_COM_ADDR
				);
				FREE_LONG(1);
				FREE_DOUBLE(1);
				FREE_STRING;
				FREE_STRING;
				FREE_COM;
				PUSH_COM(RET_COM);
				break;
				
			case 10:
				// Execute: "push NumberBvr NumberBvr.animateProperty(java.lang.String, java.lang.String, boolean, double)"
				// AUTOGENERATED
				instrTrace("push NumberBvr NumberBvr.animateProperty(java.lang.String, java.lang.String, boolean, double)");
				METHOD_CALL_5(
					(IDANumber*)USE_COM(1),
					AnimateProperty,
					USE_STRING(1),
					USE_STRING(2),
					USE_LONG_AS_BOOL(1),
					USE_DOUBLE(1),
					(IDANumber**)RET_COM_ADDR
				);
				FREE_LONG(1);
				FREE_DOUBLE(1);
				FREE_STRING;
				FREE_STRING;
				FREE_COM;
				PUSH_COM(RET_COM);
				break;
				
			case 11:
				// Execute: "call Engine.showStatusLine(java.lang.String)"
				// USER GENERATED
				SetStatusText(
					USE_STRING(1)
				);
				FREE_STRING;
				break;
				
			case 12:
				// Execute: "push DXMEvent ImportationResult.getCompletionEvent()"
				// AUTOGENERATED
				instrTrace("push DXMEvent ImportationResult.getCompletionEvent()");
				METHOD_CALL_1(
					(IDAImportationResult*)USE_COM(1),
					get_CompletionEvent,
					(IDAEvent**)RET_COM_ADDR
				);
				FREE_COM;
				PUSH_COM(RET_COM);
				break;
				
			case 13:
				// Execute: "push GeometryBvr ImportationResult.getGeometry()"
				// AUTOGENERATED
				instrTrace("push GeometryBvr ImportationResult.getGeometry()");
				METHOD_CALL_1(
					(IDAImportationResult*)USE_COM(1),
					get_Geometry,
					(IDAGeometry**)RET_COM_ADDR
				);
				FREE_COM;
				PUSH_COM(RET_COM);
				break;
				
			case 14:
				// Execute: "push NumberBvr ImportationResult.getProgress()"
				// AUTOGENERATED
				instrTrace("push NumberBvr ImportationResult.getProgress()");
				METHOD_CALL_1(
					(IDAImportationResult*)USE_COM(1),
					get_Progress,
					(IDANumber**)RET_COM_ADDR
				);
				FREE_COM;
				PUSH_COM(RET_COM);
				break;
				
			case 15:
				// Execute: "push ImageBvr ImportationResult.getImage()"
				// AUTOGENERATED
				instrTrace("push ImageBvr ImportationResult.getImage()");
				METHOD_CALL_1(
					(IDAImportationResult*)USE_COM(1),
					get_Image,
					(IDAImage**)RET_COM_ADDR
				);
				FREE_COM;
				PUSH_COM(RET_COM);
				break;
				
			case 16:
				// Execute: "push NumberBvr ImportationResult.getSize()"
				// AUTOGENERATED
				instrTrace("push NumberBvr ImportationResult.getSize()");
				METHOD_CALL_1(
					(IDAImportationResult*)USE_COM(1),
					get_Size,
					(IDANumber**)RET_COM_ADDR
				);
				FREE_COM;
				PUSH_COM(RET_COM);
				break;
				
			case 17:
				// Execute: "push SoundBvr ImportationResult.getSound()"
				// AUTOGENERATED
				instrTrace("push SoundBvr ImportationResult.getSound()");
				METHOD_CALL_1(
					(IDAImportationResult*)USE_COM(1),
					get_Sound,
					(IDASound**)RET_COM_ADDR
				);
				FREE_COM;
				PUSH_COM(RET_COM);
				break;
				
			case 18:
				// Execute: "push NumberBvr ImportationResult.getDuration()"
				// AUTOGENERATED
				instrTrace("push NumberBvr ImportationResult.getDuration()");
				METHOD_CALL_1(
					(IDAImportationResult*)USE_COM(1),
					get_Duration,
					(IDANumber**)RET_COM_ADDR
				);
				FREE_COM;
				PUSH_COM(RET_COM);
				break;
				
			case 19:
				// Execute: "push ImportationResult Statics.importMovie(java.lang.String)"
				// AUTOGENERATED
				instrTrace("push ImportationResult Statics.importMovie(java.lang.String)");
				IMPORT_METHOD_CALL_2(
					staticStatics,
					ImportMovie,
					USE_STRING(1),
					(IDAImportationResult**)RET_COM_ADDR
				);
				FREE_STRING;
				PUSH_COM(RET_COM);
				break;
				
			case 20:
				// Execute: "push ImportationResult Statics.importMovie(java.lang.String, ImageBvr, SoundBvr)"
				// AUTOGENERATED
				instrTrace("push ImportationResult Statics.importMovie(java.lang.String, ImageBvr, SoundBvr)");
				IMPORT_METHOD_CALL_4(
					staticStatics,
					ImportMovieAsync,
					USE_STRING(1),
					(IDAImage*)USE_COM(1),
					(IDASound*)USE_COM(2),
					(IDAImportationResult**)RET_COM_ADDR
				);
				FREE_STRING;
				FREE_COM;
				FREE_COM;
				PUSH_COM(RET_COM);
				break;
				
			case 21:
				// Execute: "push ImportationResult Statics.importGeometry(java.lang.String, GeometryBvr)"
				// AUTOGENERATED
				instrTrace("push ImportationResult Statics.importGeometry(java.lang.String, GeometryBvr)");
				IMPORT_METHOD_CALL_3(
					staticStatics,
					ImportGeometryAsync,
					USE_STRING(1),
					(IDAGeometry*)USE_COM(1),
					(IDAImportationResult**)RET_COM_ADDR
				);
				FREE_STRING;
				FREE_COM;
				PUSH_COM(RET_COM);
				break;
				
			case 22:
				// Execute: "push ImportationResult Statics.importImage(java.lang.String, ImageBvr)"
				// AUTOGENERATED
				instrTrace("push ImportationResult Statics.importImage(java.lang.String, ImageBvr)");
				IMPORT_METHOD_CALL_3(
					staticStatics,
					ImportImageAsync,
					USE_STRING(1),
					(IDAImage*)USE_COM(1),
					(IDAImportationResult**)RET_COM_ADDR
				);
				FREE_STRING;
				FREE_COM;
				PUSH_COM(RET_COM);
				break;
				
			case 23:
				// Execute: "push ImportationResult Statics.importSound(java.lang.String)"
				// AUTOGENERATED
				instrTrace("push ImportationResult Statics.importSound(java.lang.String)");
				IMPORT_METHOD_CALL_2(
					staticStatics,
					ImportSound,
					USE_STRING(1),
					(IDAImportationResult**)RET_COM_ADDR
				);
				FREE_STRING;
				PUSH_COM(RET_COM);
				break;
				
			case 24:
				// Execute: "push ImportationResult Statics.importSound(java.lang.String, SoundBvr)"
				// AUTOGENERATED
				instrTrace("push ImportationResult Statics.importSound(java.lang.String, SoundBvr)");
				IMPORT_METHOD_CALL_3(
					staticStatics,
					ImportSoundAsync,
					USE_STRING(1),
					(IDASound*)USE_COM(1),
					(IDAImportationResult**)RET_COM_ADDR
				);
				FREE_STRING;
				FREE_COM;
				PUSH_COM(RET_COM);
				break;
				
			case 25:
				// Execute: "push Engine Engine.run(java.lang.String)"
				// USER GENERATED
				instrTrace("push Engine Engine.run(java.lang.String)")
				status = m_pReader->execute(
					USE_STRING(1),
					(ILMEngine**)RET_COM_ADDR
				);
				FREE_STRING;
				PUSH_COM(RET_COM);
				break;
				
			case 26:
				// Execute: "call Engine.exportsAreDone()"
				// USER GENERATED
				instrTrace("call Engine.exportsAreDone()");
				break;
				
			case 27:
				// Execute: "ensure long stack size"
				// USER GENERATED
				{
					instrTrace("ensure long stack size");
					// Load the size from the instruction stream
					LONG newSize;
					if (SUCCEEDED(status = readLong(&newSize))) {
						if (newSize > longStackSize) {
							// Allocate new stack
							LONG *newStack = new LONG[newSize];
							if (newStack != 0) {
								// Remember old stack
								LONG *oldStack = longStack;
								// Do the copy
								LONG *newTop = newStack;
								while (longStack != longTop)
									*newTop++ = *longStack++;
								// Clean up
								longStack = newStack;
								longTop = newTop;
								longStackSize = newSize;
								// Delete old stack
								delete[] oldStack;
							} else {
								status = E_OUTOFMEMORY;
							}
						}
					} 
				}
				break;
				
			case 28:
				// Execute: "ensure double stack size"
				// USER GENERATED
				{
					instrTrace("ensure double stack size");
					// Load the size from the instruction stream
					LONG newSize;
					if (SUCCEEDED(status = readLong(&newSize))) {
						if (newSize > doubleStackSize) {
							// Allocate new stack
							double *newStack = new double[newSize];
							if (newStack != 0) {
								// Remember old stack
								double *oldStack = doubleStack;
								// Do the copy
								double *newTop = newStack;
								while (doubleStack != doubleTop)
									*newTop++ = *doubleStack++;
								// Clean up
								doubleStack = newStack;
								doubleTop = newTop;
								doubleStackSize = newSize;
								// Delete old stack
								delete[] oldStack;
							} else {
								status = E_OUTOFMEMORY;
							}
						}
					}
				}
				break;
				
			case 29:
				// Execute: "ensure string stack size"
				// USER GENERATED
				{
					instrTrace("ensure string stack size");
					// Load the size from the instruction stream
					LONG newSize;
					if (SUCCEEDED(status = readLong(&newSize))) {
						if (newSize > stringStackSize) {
							// Allocate new stack
							BSTR *newStack = new BSTR[newSize];
							if (newStack != 0) {
								// Remember old stack
								BSTR *oldStack = stringStack;
								// Do the copy
								BSTR *newTop = newStack;
								while (stringStack != stringTop)
									*newTop++ = *stringStack++;
								// Clean up
								stringStack = newStack;
								stringTop = newTop;
								stringStackSize = newSize;
								// Delete old stack
								delete[] oldStack;
							} else {
								status = E_OUTOFMEMORY;
							}
						}
					}
				}
				break;
				
			case 30:
				// Execute: "ensure com stack size"
				// USER GENERATED
				{
					instrTrace("ensure com stack size");
					// Load the size from the instruction stream
					LONG newSize;
					if (SUCCEEDED(status = readLong(&newSize))) {
						if (newSize > comStackSize) {
							// Allocate new stack
							IUnknown **newStack = new IUnknown*[newSize];
							if (newStack != 0) {
								// Remember old stack
								IUnknown **oldStack = comStack;
								// Do the copy
								IUnknown **newTop = newStack;
								while (comStack != comTop)
									*newTop++ = *comStack++;
								// Clean up
								comStack = newStack;
								comTop = newTop;
								comStackSize = newSize;
								// Delete old stack
								delete[] oldStack;
							} else {
								status = E_OUTOFMEMORY;
							}
						}
					}
				}
				break;
				
			case 31:
				// Execute: "ensure com array stack size"
				// USER GENERATED
				{
					instrTrace("ensure com array stack size");
					// Load the size from the instruction stream
					LONG newSize;
					if (SUCCEEDED(status = readLong(&newSize))) {
						if (newSize > comArrayStackSize) {
							// Allocate new stack
							IUnknown ***newStack = new IUnknown**[newSize];
							long *newLenStack = new long[newSize];
							if (newStack != 0 && newLenStack != 0) {
								// Remember old stack
								IUnknown ***oldStack = comArrayStack;
								long *oldLenStack = comArrayLenStack;
								// Do the copy
								IUnknown ***newTop = newStack;
								long *newLenTop = newLenStack;
								while (comArrayStack != comArrayTop) {
									*newTop++ = *comArrayStack++;
									*newLenTop++ = *comArrayLenStack++;
								}
								// Clean up
								comArrayStack = newStack;
								comArrayTop = newTop;
								comArrayStackSize = newSize;
								
								comArrayLenStack = newLenStack;
								comArrayLenTop = newLenTop;
								// Delete old stack
								delete[] oldStack;
								delete[] oldLenStack;
							} else {
								status = E_OUTOFMEMORY;
							}
						}
					}
				}
				break;
				
			case 32:
				// Execute: "ensure com store size"
				// USER GENERATED
				{
					instrTrace("ensure com store size");
					// Load the size from the instruction stream
					LONG newSize;
					if (SUCCEEDED(status = readLong(&newSize))) {
						if (newSize > comStoreSize) {
							// Allocate new store
							IUnknown **newStore = new IUnknown*[newSize];
							if (newStore != 0) {
								// Initialize it to 0, so we can release it at the end
								for (int i=0; i<newSize; i++)
									newStore[i] = 0;
								// Remember old store
								IUnknown **oldStore = comStore;
								// Do the copy
								IUnknown **newTop = newStore;
								while (comStoreSize--)
									*newTop++ = *comStore++;
								// Clean up
								comStore = newStore;
								comStoreSize = newSize;
								// Delete old store
								delete[] oldStore;
							} else {
								status = E_OUTOFMEMORY;
							}
						}
					}
				}
				break;
				
			case 33:
				// Execute: "call Engine.setImage(ImageBvr)"
				// USER GENERATED
				instrTrace("call Engine.setImage(ImageBvr)");
				if (m_pImage)
					m_pImage->SwitchTo((IDAImage*)USE_COM(1));
				else {
					m_pImage = (IDAImage *)USE_COM(1);
					m_pImage->AddRef();
				}
				FREE_COM;
				break;
				
			case 34:
				// Execute: "push DXMEvent DXMEvent.notifyEvent(UntilNotifier)"
				// AUTOGENERATED
				instrTrace("push DXMEvent DXMEvent.notifyEvent(UntilNotifier)");
				METHOD_CALL_2(
					(IDAEvent*)USE_COM(1),
					Notify,
					(IDAUntilNotifier*)USE_COM(2),
					(IDAEvent**)RET_COM_ADDR
				);
				FREE_COM;
				FREE_COM;
				PUSH_COM(RET_COM);
				break;
				
			case 35:
				// Execute: "push Behavior Statics.untilNotify(Behavior, DXMEvent, UntilNotifier)"
				// AUTOGENERATED
				instrTrace("push Behavior Statics.untilNotify(Behavior, DXMEvent, UntilNotifier)");
				METHOD_CALL_4(
					staticStatics,
					UntilNotify,
					(IDABehavior*)USE_COM(1),
					(IDAEvent*)USE_COM(2),
					(IDAUntilNotifier*)USE_COM(3),
					(IDABehavior**)RET_COM_ADDR
				);
				FREE_COM;
				FREE_COM;
				FREE_COM;
				PUSH_COM(RET_COM);
				break;
				
			case 36:
				// Execute: "push untilnotifier"
				// USER GENERATED
				instrTrace("push untilnotifier");
				{
					// Get number of bytes in method code
					if (SUCCEEDED(status = readLong(&longTmp1))) {
						// Create an array of this size to read the bytes into
						BYTE *buffer = new BYTE[longTmp1];
						// A new engine for executing the method call
						ILMEngine *engine;
						// An IDANotifier created from the engine
						IDAUntilNotifier *notifier;
						
						if (buffer != 0) {
							if (SUCCEEDED(status = codeStream->readBytes(buffer, longTmp1, NULL))) {
								if (SUCCEEDED(status = m_pReader->createEngine(&engine))) {
									if (SUCCEEDED(status = engine->initNotify(buffer, longTmp1, &notifier)))
									{
										CComQIPtr<ILMEngine2, &IID_ILMEngine2> engine2(engine);
										if( engine2 != NULL )
											engine2->setParentEngine( this );
										PUSH_COM(notifier);
									} else {
										// initNotify !SUCCEEDED
										engine->Release();
										engine = NULL;
										delete [] buffer;
									}
								} else {
									// Engine create !SUCCEEDED
									delete [] buffer;
								}
							} else {
								// Read !SUCCEEDED
								delete [] buffer;
							}
						} else {
							status = E_OUTOFMEMORY;
						}
					}
				}
				break;
				
			case 37:
				// Execute: "call Statics.triggerEvent(DXMEvent, Behavior)"
				// AUTOGENERATED
				instrTrace("call Statics.triggerEvent(DXMEvent, Behavior)");
				METHOD_CALL_2(
					staticStatics,
					TriggerEvent,
					(IDAEvent*)USE_COM(1),
					(IDABehavior*)USE_COM(2)
				);
				FREE_COM;
				FREE_COM;
				break;
				
			case 38:
				// Execute: "push DXMEvent Statics.appTriggeredEvent()"
				// AUTOGENERATED
				instrTrace("push DXMEvent Statics.appTriggeredEvent()");
				METHOD_CALL_1(
					staticStatics,
					AppTriggeredEvent,
					(IDAEvent**)RET_COM_ADDR
				);
				PUSH_COM(RET_COM);
				break;
				
			case 39:
				// Execute: "call Engine.callScript(java.lang.String, java.lang.String)"
				// USER GENERATED
				instrTrace("call Engine.callScript(java.lang.String, java.lang.String)");
				
				// Call script synchronously
				status = callScriptOnPage(
					USE_STRING(1),
					USE_STRING(2)
					);
				FREE_STRING;
				FREE_STRING;
				
				status = S_OK;
				break;
				
			case 40:
				// Execute: "push ImageBvr ImageBvr.applyBitmapEffect(IUnknown, DXMEvent)"
				// AUTOGENERATED
				instrTrace("push ImageBvr ImageBvr.applyBitmapEffect(IUnknown, DXMEvent)");
				METHOD_CALL_3(
					(IDAImage*)USE_COM(1),
					ApplyBitmapEffect,
					(IUnknown*)USE_COM(2),
					(IDAEvent*)USE_COM(3),
					(IDAImage**)RET_COM_ADDR
				);
				FREE_COM;
				FREE_COM;
				FREE_COM;
				PUSH_COM(RET_COM);
				break;
				
			case 41:
				// Execute: "push IUnknown Engine.getElement(java.lang.String)"
				// USER GENERATED
				instrTrace("push IUnknown Engine.getElement(java.lang.String)");
				status = getElementOnPage(
					USE_STRING(1),
					(IUnknown**)RET_COM_ADDR
				);
				FREE_STRING;
				PUSH_COM(RET_COM);
				break;
				
			case 42:
				// Execute: "push GeometryBvr Statics.unionArray(GeometryBvr[])"
				// AUTOGENERATED
				instrTrace("push GeometryBvr Statics.unionArray(GeometryBvr[])");
				METHOD_CALL_3(
					staticStatics,
					UnionGeometryArrayEx,
					USE_COM_ARRAY_LENGTH(1),
					(IDAGeometry**)USE_COM_ARRAY(1),
					(IDAGeometry**)RET_COM_ADDR
				);
				FREE_COM_ARRAY;
				PUSH_COM(RET_COM);
				break;
				
			case 43:
				// Execute: "push Path2Bvr Statics.polydrawPath(Point2Bvr[], NumberBvr[])"
				// AUTOGENERATED
				instrTrace("push Path2Bvr Statics.polydrawPath(Point2Bvr[], NumberBvr[])");
				METHOD_CALL_5(
					staticStatics,
					PolydrawPathEx,
					USE_COM_ARRAY_LENGTH(1),
					(IDAPoint2**)USE_COM_ARRAY(1),
					USE_COM_ARRAY_LENGTH(2),
					(IDANumber**)USE_COM_ARRAY(2),
					(IDAPath2**)RET_COM_ADDR
				);
				FREE_COM_ARRAY;
				FREE_COM_ARRAY;
				PUSH_COM(RET_COM);
				break;
				
			case 44:
				// Execute: "push ImageBvr Statics.textImage(StringBvr, FontStyleBvr)"
				// AUTOGENERATED
				instrTrace("push ImageBvr Statics.textImage(StringBvr, FontStyleBvr)");
				METHOD_CALL_3(
					staticStatics,
					StringImageAnim,
					(IDAString*)USE_COM(1),
					(IDAFontStyle*)USE_COM(2),
					(IDAImage**)RET_COM_ADDR
				);
				FREE_COM;
				FREE_COM;
				PUSH_COM(RET_COM);
				break;
				
			case 45:
				// Execute: "push ImageBvr Statics.textImage(java.lang.String, FontStyleBvr)"
				// AUTOGENERATED
				instrTrace("push ImageBvr Statics.textImage(java.lang.String, FontStyleBvr)");
				METHOD_CALL_3(
					staticStatics,
					StringImage,
					USE_STRING(1),
					(IDAFontStyle*)USE_COM(1),
					(IDAImage**)RET_COM_ADDR
				);
				FREE_STRING;
				FREE_COM;
				PUSH_COM(RET_COM);
				break;
				
			case 46:
				// Execute: "push Path2Bvr Statics.textPath(StringBvr, FontStyleBvr)"
				// AUTOGENERATED
				instrTrace("push Path2Bvr Statics.textPath(StringBvr, FontStyleBvr)");
				METHOD_CALL_3(
					staticStatics,
					StringPathAnim,
					(IDAString*)USE_COM(1),
					(IDAFontStyle*)USE_COM(2),
					(IDAPath2**)RET_COM_ADDR
				);
				FREE_COM;
				FREE_COM;
				PUSH_COM(RET_COM);
				break;
				
			case 47:
				// Execute: "push ImageBvr ImageBvr.clipPolygon(Point2Array)"
				// AUTOGENERATED
				instrTrace("push ImageBvr ImageBvr.clipPolygon(Point2Array)");
				METHOD_CALL_3(
					(IDAImage*)USE_COM(1),
					ClipPolygonImageEx,
					USE_COM_ARRAY_LENGTH(1),
					(IDAPoint2**)USE_COM_ARRAY(1),
					(IDAImage**)RET_COM_ADDR
				);
				FREE_COM;
				FREE_COM_ARRAY;
				PUSH_COM(RET_COM);
				break;
				
			case 48:
				// Execute: "push ImageBvr Statics.radialGradientPolygon(ColorBvr, ColorBvr, Point2Array, double)"
				// AUTOGENERATED
				instrTrace("push ImageBvr Statics.radialGradientPolygon(ColorBvr, ColorBvr, Point2Array, double)");
				METHOD_CALL_6(
					staticStatics,
					RadialGradientPolygonEx,
					(IDAColor*)USE_COM(1),
					(IDAColor*)USE_COM(2),
					USE_COM_ARRAY_LENGTH(1),
					(IDAPoint2**)USE_COM_ARRAY(1),
					USE_DOUBLE(1),
					(IDAImage**)RET_COM_ADDR
				);
				FREE_DOUBLE(1);
				FREE_COM;
				FREE_COM;
				FREE_COM_ARRAY;
				PUSH_COM(RET_COM);
				break;
				
			case 49:
				// Execute: "push ImageBvr Statics.radialGradientPolygon(ColorBvr, ColorBvr, Point2Array, NumberBvr)"
				// AUTOGENERATED
				instrTrace("push ImageBvr Statics.radialGradientPolygon(ColorBvr, ColorBvr, Point2Array, NumberBvr)");
				METHOD_CALL_6(
					staticStatics,
					RadialGradientPolygonAnimEx,
					(IDAColor*)USE_COM(1),
					(IDAColor*)USE_COM(2),
					USE_COM_ARRAY_LENGTH(1),
					(IDAPoint2**)USE_COM_ARRAY(1),
					(IDANumber*)USE_COM(3),
					(IDAImage**)RET_COM_ADDR
				);
				FREE_COM;
				FREE_COM;
				FREE_COM;
				FREE_COM_ARRAY;
				PUSH_COM(RET_COM);
				break;
				
			case 50:
				// Execute: "push Path2Bvr Statics.polyline(Point2Array)"
				// AUTOGENERATED
				instrTrace("push Path2Bvr Statics.polyline(Point2Array)");
				METHOD_CALL_3(
					staticStatics,
					PolylineEx,
					USE_COM_ARRAY_LENGTH(1),
					(IDAPoint2**)USE_COM_ARRAY(1),
					(IDAPath2**)RET_COM_ADDR
				);
				FREE_COM_ARRAY;
				PUSH_COM(RET_COM);
				break;
				
			case 51:
				// Execute: "push Path2Bvr Statics.polydrawPath(Point2Array, NumberArray)"
				// AUTOGENERATED
				instrTrace("push Path2Bvr Statics.polydrawPath(Point2Array, NumberArray)");
				METHOD_CALL_5(
					staticStatics,
					PolydrawPathEx,
					USE_COM_ARRAY_LENGTH(1),
					(IDAPoint2**)USE_COM_ARRAY(1),
					USE_COM_ARRAY_LENGTH(2),
					(IDANumber**)USE_COM_ARRAY(2),
					(IDAPath2**)RET_COM_ADDR
				);
				FREE_COM_ARRAY;
				FREE_COM_ARRAY;
				PUSH_COM(RET_COM);
				break;
				
			case 52:
				// Execute: "push Point2Array Statics.point2Array(DoubleArray)"
				// USER GENERATED
				instrTrace("push Point2Array Statics.point2Array(DoubleArray)");
				{
					// Get length of array
					longTmp1 = longTmp2 = doubleArrayLen/2;
					// Create array of that size
					comArrayTmp1 = comArrayTmp2 = new IUnknown*[longTmp1];
					if (comArrayTmp1 != 0) {
				
						// Create Point2Bvr for each double
						double *tmpDouble = doubleArray;
						while (longTmp2-- && SUCCEEDED(status)) {
							doubleTmp1 = *tmpDouble++;
							doubleTmp2 = *tmpDouble++;
							status = staticStatics->Point2(doubleTmp1, doubleTmp2, (IDAPoint2**)comArrayTmp2++);
						}
				
						// Push array onto comArray stack
						PUSH_COM_ARRAY(comArrayTmp1);
						// Push length onto array length stack
						PUSH_COM_ARRAY_LENGTH(longTmp1);
					} else {
						status = E_OUTOFMEMORY;
					}
				}
				break;
				
			case 53:
				// Execute: "push Point2Array Statics.point2Array(Point2Bvr[])"
				// USER GENERATED
				instrTrace("push Point2Array Statics.point2Array(Point2Bvr[])");
				// NULL OP
				break;
				
			case 54:
				// Execute: "push Vector3Array Statics.vector3Array(DoubleArray)"
				// USER GENERATED
				instrTrace("push Vector3Array Statics.vector3Array(DoubleArray)");
				{
					// Get length of array
					longTmp1 = longTmp2 = doubleArrayLen/3;
					// Create array of that size
					comArrayTmp1 = comArrayTmp2 = new IUnknown*[longTmp1];
					if (comArrayTmp1 != 0) {
				
						// Create Vector3Bvr for each double
						double *tmpDouble = doubleArray;
						while (longTmp2-- && SUCCEEDED(status)) {
							doubleTmp1 = *tmpDouble++;
							doubleTmp2 = *tmpDouble++;
							doubleTmp3 = *tmpDouble++;
							status = staticStatics->Vector3(doubleTmp1, doubleTmp2, doubleTmp3, (IDAVector3**)comArrayTmp2++);
						}
				
						// Push array onto comArray stack
						PUSH_COM_ARRAY(comArrayTmp1);
						// Push length onto array length stack
						PUSH_COM_ARRAY_LENGTH(longTmp1);
					} else {
						status = E_OUTOFMEMORY;
					}
				}
				break;
				
			case 55:
				// Execute: "push Vector3Array Statics.vector3Array(Vector3Bvr[])"
				// USER GENERATED
				instrTrace("push Vector3Array Statics.vector3Array(Vector3Bvr[])");
				// NULL OP
				break;
				
			case 56:
				// Execute: "push Vector2Array Statics.vector2Array(DoubleArray)"
				// USER GENERATED
				instrTrace("push Vector2Array Statics.vector2Array(DoubleArray)");
				{
					// Get length of array
					longTmp1 = longTmp2 = doubleArrayLen/2;
					// Create array of that size
					comArrayTmp1 = comArrayTmp2 = new IUnknown*[longTmp1];
					if (comArrayTmp1 != 0) {
				
						// Create Vector2Bvr for each double
						double *tmpDouble = doubleArray;
						while (longTmp2-- && SUCCEEDED(status)) {
							doubleTmp1 = *tmpDouble++;
							doubleTmp2 = *tmpDouble++;
							status = staticStatics->Vector2(doubleTmp1, doubleTmp2, (IDAVector2**)comArrayTmp2++);
						}
				
						// Push array onto comArray stack
						PUSH_COM_ARRAY(comArrayTmp1);
						// Push length onto array length stack
						PUSH_COM_ARRAY_LENGTH(longTmp1);
					} else {
						status = E_OUTOFMEMORY;
					}
				}
				break;
				
			case 57:
				// Execute: "push Vector2Array Statics.vector2Array(Vector2Bvr[])"
				// USER GENERATED
				instrTrace("push Vector2Array Statics.vector2Array(Vector2Bvr[])");
				// NULL OP
				break;
				
			case 58:
				// Execute: "push Transform2Bvr Statics.transform3x2(NumberArray)"
				// AUTOGENERATED
				instrTrace("push Transform2Bvr Statics.transform3x2(NumberArray)");
				METHOD_CALL_3(
					staticStatics,
					Transform3x2AnimEx,
					USE_COM_ARRAY_LENGTH(1),
					(IDANumber**)USE_COM_ARRAY(1),
					(IDATransform2**)RET_COM_ADDR
				);
				FREE_COM_ARRAY;
				PUSH_COM(RET_COM);
				break;
				
			case 59:
				// Execute: "push Transform3Bvr Statics.transform4x4(NumberArray)"
				// AUTOGENERATED
				instrTrace("push Transform3Bvr Statics.transform4x4(NumberArray)");
				METHOD_CALL_3(
					staticStatics,
					Transform4x4AnimEx,
					USE_COM_ARRAY_LENGTH(1),
					(IDANumber**)USE_COM_ARRAY(1),
					(IDATransform3**)RET_COM_ADDR
				);
				FREE_COM_ARRAY;
				PUSH_COM(RET_COM);
				break;
				
			case 60:
				// Execute: "push Path2Bvr Statics.cubicBSplinePath(Point2Array, NumberArray)"
				// AUTOGENERATED
				instrTrace("push Path2Bvr Statics.cubicBSplinePath(Point2Array, NumberArray)");
				METHOD_CALL_5(
					staticStatics,
					CubicBSplinePathEx,
					USE_COM_ARRAY_LENGTH(1),
					(IDAPoint2**)USE_COM_ARRAY(1),
					USE_COM_ARRAY_LENGTH(2),
					(IDANumber**)USE_COM_ARRAY(2),
					(IDAPath2**)RET_COM_ADDR
				);
				FREE_COM_ARRAY;
				FREE_COM_ARRAY;
				PUSH_COM(RET_COM);
				break;
				
			case 61:
				// Execute: "push NumberArray Statics.numberArray(DoubleArray)"
				// USER GENERATED
				{
					instrTrace("push NumberArray Statics.numberArray(DoubleArray)");
					// Get length of array
					longTmp1 = longTmp2 = doubleArrayLen;
					// Create array of that size
					comArrayTmp1 = comArrayTmp2 = new IUnknown*[longTmp1];
					if (comArrayTmp1 != 0) {
				
						// Create NumberBvr for each double
						double *tmpDouble = doubleArray;
						while (longTmp2-- && SUCCEEDED(status)) {
							status = staticStatics->DANumber(*tmpDouble++, (IDANumber**)comArrayTmp2++);
						}
				
						// Push array onto comArray stack
						PUSH_COM_ARRAY(comArrayTmp1);
						// Push length onto array length stack
						PUSH_COM_ARRAY_LENGTH(longTmp1);
					} else {
						status = E_OUTOFMEMORY;
					}
				}
				break;
				
			case 62:
				// Execute: "push NumberArray Statics.numberArray(NumberBvr[])"
				// USER GENERATED
				instrTrace("push NumberArray Statics.numberArray(NumberBvr[])");
				// NULL OP
				break;
				
			case 63:
				// Execute: "push Point3Array Statics.point3Array(DoubleArray)"
				// USER GENERATED
				instrTrace("push Point3Array Statics.point3Array(DoubleArray)");
				{
					// Get length of array
					longTmp1 = longTmp2 = doubleArrayLen/3;
					// Create array of that size
					comArrayTmp1 = comArrayTmp2 = new IUnknown*[longTmp1];
					if (comArrayTmp1 != 0) {
				
						// Create Point2Bvr for each double
						double *tmpDouble = doubleArray;
						while (longTmp2-- && SUCCEEDED(status)) {
							doubleTmp1 = *tmpDouble++;
							doubleTmp2 = *tmpDouble++;
							doubleTmp3 = *tmpDouble++;
							status = staticStatics->Point3(doubleTmp1, doubleTmp2, doubleTmp3, (IDAPoint3**)comArrayTmp2++);
						}
				
						// Push array onto comArray stack
						PUSH_COM_ARRAY(comArrayTmp1);
						// Push length onto array length stack
						PUSH_COM_ARRAY_LENGTH(longTmp1);
					} else {
						status = E_OUTOFMEMORY;
					}
				}
				break;
				
			case 64:
				// Execute: "push Point3Array Statics.point3Array(Point3Bvr[])"
				// USER GENERATED
				instrTrace("push Point3Array Statics.point3Array(Point3Bvr[])");
				// NULL OP
				break;
				
			case 65:
				// Execute: "push NumberBvr Statics.bSpline(int, NumberArray, NumberArray, NumberArray, NumberBvr)"
				// AUTOGENERATED
				instrTrace("push NumberBvr Statics.bSpline(int, NumberArray, NumberArray, NumberArray, NumberBvr)");
				METHOD_CALL_9(
					staticStatics,
					NumberBSplineEx,
					USE_LONG(1),
					USE_COM_ARRAY_LENGTH(1),
					(IDANumber**)USE_COM_ARRAY(1),
					USE_COM_ARRAY_LENGTH(2),
					(IDANumber**)USE_COM_ARRAY(2),
					USE_COM_ARRAY_LENGTH(3),
					(IDANumber**)USE_COM_ARRAY(3),
					(IDANumber*)USE_COM(1),
					(IDANumber**)RET_COM_ADDR
				);
				FREE_LONG(1);
				FREE_COM;
				FREE_COM_ARRAY;
				FREE_COM_ARRAY;
				FREE_COM_ARRAY;
				PUSH_COM(RET_COM);
				break;
				
			case 66:
				// Execute: "push Point2Bvr Statics.bSpline(int, NumberArray, Point2Array, NumberArray, NumberBvr)"
				// AUTOGENERATED
				instrTrace("push Point2Bvr Statics.bSpline(int, NumberArray, Point2Array, NumberArray, NumberBvr)");
				METHOD_CALL_9(
					staticStatics,
					Point2BSplineEx,
					USE_LONG(1),
					USE_COM_ARRAY_LENGTH(1),
					(IDANumber**)USE_COM_ARRAY(1),
					USE_COM_ARRAY_LENGTH(2),
					(IDAPoint2**)USE_COM_ARRAY(2),
					USE_COM_ARRAY_LENGTH(3),
					(IDANumber**)USE_COM_ARRAY(3),
					(IDANumber*)USE_COM(1),
					(IDAPoint2**)RET_COM_ADDR
				);
				FREE_LONG(1);
				FREE_COM;
				FREE_COM_ARRAY;
				FREE_COM_ARRAY;
				FREE_COM_ARRAY;
				PUSH_COM(RET_COM);
				break;
				
			case 67:
				// Execute: "push Point3Bvr Statics.bSpline(int, NumberArray, Point3Array, NumberArray, NumberBvr)"
				// AUTOGENERATED
				instrTrace("push Point3Bvr Statics.bSpline(int, NumberArray, Point3Array, NumberArray, NumberBvr)");
				METHOD_CALL_9(
					staticStatics,
					Point3BSplineEx,
					USE_LONG(1),
					USE_COM_ARRAY_LENGTH(1),
					(IDANumber**)USE_COM_ARRAY(1),
					USE_COM_ARRAY_LENGTH(2),
					(IDAPoint3**)USE_COM_ARRAY(2),
					USE_COM_ARRAY_LENGTH(3),
					(IDANumber**)USE_COM_ARRAY(3),
					(IDANumber*)USE_COM(1),
					(IDAPoint3**)RET_COM_ADDR
				);
				FREE_LONG(1);
				FREE_COM;
				FREE_COM_ARRAY;
				FREE_COM_ARRAY;
				FREE_COM_ARRAY;
				PUSH_COM(RET_COM);
				break;
				
			case 68:
				// Execute: "push Vector2Bvr Statics.bSpline(int, NumberArray, Vector2Array, NumberArray, NumberBvr)"
				// AUTOGENERATED
				instrTrace("push Vector2Bvr Statics.bSpline(int, NumberArray, Vector2Array, NumberArray, NumberBvr)");
				METHOD_CALL_9(
					staticStatics,
					Vector2BSplineEx,
					USE_LONG(1),
					USE_COM_ARRAY_LENGTH(1),
					(IDANumber**)USE_COM_ARRAY(1),
					USE_COM_ARRAY_LENGTH(2),
					(IDAVector2**)USE_COM_ARRAY(2),
					USE_COM_ARRAY_LENGTH(3),
					(IDANumber**)USE_COM_ARRAY(3),
					(IDANumber*)USE_COM(1),
					(IDAVector2**)RET_COM_ADDR
				);
				FREE_LONG(1);
				FREE_COM;
				FREE_COM_ARRAY;
				FREE_COM_ARRAY;
				FREE_COM_ARRAY;
				PUSH_COM(RET_COM);
				break;
				
			case 69:
				// Execute: "push Vector3Bvr Statics.bSpline(int, NumberArray, Vector3Array, NumberArray, NumberBvr)"
				// AUTOGENERATED
				instrTrace("push Vector3Bvr Statics.bSpline(int, NumberArray, Vector3Array, NumberArray, NumberBvr)");
				METHOD_CALL_9(
					staticStatics,
					Vector3BSplineEx,
					USE_LONG(1),
					USE_COM_ARRAY_LENGTH(1),
					(IDANumber**)USE_COM_ARRAY(1),
					USE_COM_ARRAY_LENGTH(2),
					(IDAVector3**)USE_COM_ARRAY(2),
					USE_COM_ARRAY_LENGTH(3),
					(IDANumber**)USE_COM_ARRAY(3),
					(IDANumber*)USE_COM(1),
					(IDAVector3**)RET_COM_ADDR
				);
				FREE_LONG(1);
				FREE_COM;
				FREE_COM_ARRAY;
				FREE_COM_ARRAY;
				FREE_COM_ARRAY;
				PUSH_COM(RET_COM);
				break;
				
			case 70:
				// Execute: "push DoubleArray Statics.doubleArray(int[])"
				// USER GENERATED
				instrTrace("push DoubleArray Statics.doubleArray(int[])");
				{
					// Get the length of the array
					if (SUCCEEDED(status = readLong(&longTmp1))) {
						// Remember it
						doubleArrayLen = longTmp1;
						// Ensure double array is big enough and copy ints to it
						if (SUCCEEDED(status = ensureDoubleArrayCap(longTmp1))) {
							double *to = doubleArray;
							while (longTmp1-- && SUCCEEDED(status)) {
								if (SUCCEEDED(status = readSignedLong(&longTmp2)))
									*to++ = (double)longTmp2;
							}
						}
					}
				}
				break;
				
			case 71:
				// Execute: "push DoubleArray Statics.doubleArray(float[])"
				// USER GENERATED
				instrTrace("push DoubleArray Statics.doubleArray(float[])");
				{
					// Get the length of the array
					if (SUCCEEDED(status = readLong(&longTmp1))) {
						// Remember it
						doubleArrayLen = longTmp1;
						// Ensure double array is big enough and copy floats to it
						if (SUCCEEDED(status = ensureDoubleArrayCap(longTmp1))) {
							double *to = doubleArray;
							while (longTmp1-- && SUCCEEDED(status)) {			
								status = readFloat(&floatTmp1);
								*to++ = (double)floatTmp1;
							}
							
						}
					}
				}
				break;
				
			case 72:
				// Execute: "push DoubleArray Statics.doubleArray(double[])"
				// USER GENERATED
				instrTrace("push DoubleArray Statics.doubleArray(double[])");
				{
					// Get the length of the array
					if (SUCCEEDED(status = readLong(&longTmp1))) {
						// Remember it
						doubleArrayLen = longTmp1;
						// Ensure double array is big enough and copy doubles to it
						if (SUCCEEDED(status = ensureDoubleArrayCap(longTmp1))) {
							double *to = doubleArray;
							while (longTmp1-- && SUCCEEDED(status))
								status = readDouble(to++);
						}
					}
				}
				break;
				
			case 73:
				// Execute: "push DoubleArray Statics.doubleArrayOffset2(int[])"
				// USER GENERATED
				instrTrace("push DoubleArray Statics.doubleArrayOffset2(int[])");
				{
					// Get the length of the array
					if (SUCCEEDED(status = readLong(&longTmp1))) {
						// Remember it
						doubleArrayLen = longTmp1;
						// Initialize offsets
						doubleTmp1 = 0;
						doubleTmp2 = 0;
						// Ensure double array is big enough and copy adjusted ints to it
						if (SUCCEEDED(status = ensureDoubleArrayCap(longTmp1))) {
							double *to = doubleArray;
							longTmp1 /= 2;
							while (longTmp1-- && SUCCEEDED(status)) {
								if (SUCCEEDED(status = readSignedLong(&longTmp2))) {
									doubleTmp1 = *to++ = (double)longTmp2 + doubleTmp1;
									if (SUCCEEDED(status = readSignedLong(&longTmp2))) 
										doubleTmp2 = *to++ = (double)longTmp2 + doubleTmp2;
								}
							}
						}
					}
				}
				break;
				
			case 74:
				// Execute: "push DoubleArray Statics.doubleArrayPathSpecial(int[])"
				// USER GENERATED
				instrTrace("push DoubleArray Statics.doubleArrayPathSpecial(int[])");
				{
					// Get the count of 6's indices (subtract 1 for the initial size)
					if (SUCCEEDED(status = readLong(&longTmp1))) {
						longTmp1--;
						// Get the size of the actual array
						if (SUCCEEDED(status = readSignedLong(&longTmp2))) {
							// Remember it
							doubleArrayLen = longTmp2;
							// Ensure double array is big enough and fill it with 4's and 6's
							if (SUCCEEDED(status = ensureDoubleArrayCap(longTmp2))) {
								// Put in the 4's
								double *to = doubleArray;
								while (longTmp2--)
									*to++ = 4.0;
								
								// Now read in the indices of the 6's and set them
								while (longTmp1-- && SUCCEEDED(status)) {
									if (SUCCEEDED(status = readSignedLong(&longTmp2)))
										doubleArray[longTmp2] = 6.0;
								}
							}
						}
					}
				}
				break;
				
			case 75:
				// Execute: "push DoubleArray Statics.doubleArrayOffset3(int[])"
				// USER GENERATED
				instrTrace("push DoubleArray Statics.doubleArrayOffset3(int[])");
				{
					// Get the length of the array
					if (SUCCEEDED(status = readLong(&longTmp1))) {
						// Remember it
						doubleArrayLen = longTmp1;
						// Initialize offsets
						doubleTmp1 = 0;
						doubleTmp2 = 0;
						doubleTmp3 = 0;
						// Ensure double array is big enough and copy adjusted ints to it
						if (SUCCEEDED(status = ensureDoubleArrayCap(longTmp1))) {
							double *to = doubleArray;
							longTmp1 /= 3;
							while (longTmp1-- && SUCCEEDED(status)) {
								if (SUCCEEDED(status = readSignedLong(&longTmp2))) {
									doubleTmp1 = *to++ = (double)longTmp2 + doubleTmp1;
									if (SUCCEEDED(status = readSignedLong(&longTmp2))) {
										doubleTmp2 = *to++ = (double)longTmp2 + doubleTmp2;
										if (SUCCEEDED(status = readSignedLong(&longTmp2)))
											doubleTmp3 = *to++ = (double)longTmp2 + doubleTmp3;
									}
								}
							}
						}
					}
				}
				break;
				
			case 76:
				// Execute: "push DoubleArray Statics.doubleArrayOffset(int[])"
				// USER GENERATED
				instrTrace("push DoubleArray Statics.doubleArrayOffset(int[])");
				{
					// Get the length of the array
					if (SUCCEEDED(status = readLong(&longTmp1))) {
						// Remember it
						doubleArrayLen = longTmp1;
						// Initialize offset
						doubleTmp1 = 0;
						// Ensure double array is big enough and copy adjusted ints to it
						if (SUCCEEDED(status = ensureDoubleArrayCap(longTmp1))) {
							double *to = doubleArray;
							while (longTmp1-- && SUCCEEDED(status)) {
								if (SUCCEEDED(status = readSignedLong(&longTmp2)))
									doubleTmp1 = *to++ = (double)longTmp2 + doubleTmp1;
							}
						}
					}
				}
				break;
				
			case 77:
				// Execute: "push double NumberBvr.extractDouble()"
				// USER GENERATED
				instrTrace("push double NumberBvr.extractDouble()");
				METHOD_CALL_1(
					(IDANumber*)USE_COM(1),
					Extract,
					PUSH_DOUBLE_ADDR
				);
				FREE_COM;
				break;
				
			case 78:
				// Execute: "push ImageBvr Statics.importImageColorKey(java.lang.String, short, short, short)"
				// USER GENERATED
				instrTrace("push ImageBvr Statics.importImageColorKey(java.lang.String, short, short, short)");
				IMPORT_METHOD_CALL_5(
					staticStatics,
					ImportImageColorKey,
					USE_STRING(1),
					(BYTE)USE_LONG(1),
					(BYTE)USE_LONG(2),
					(BYTE)USE_LONG(3),
					(IDAImage**)RET_COM_ADDR
				);
				FREE_LONG(3);
				FREE_STRING;
				PUSH_COM(RET_COM);
				break;
				
			case 79:
				// Execute: "push ImportationResult Statics.importImageColorKey(java.lang.String, ImageBvr, short, short, short)"
				// USER GENERATED
				instrTrace("push ImportationResult Statics.importImageColorKey(java.lang.String, ImageBvr, short, short, short)");
				IMPORT_METHOD_CALL_6(
					staticStatics,
					ImportImageAsyncColorKey,
					USE_STRING(1),
					(IDAImage*)USE_COM(1),
					(BYTE)USE_LONG(1),
					(BYTE)USE_LONG(2),
					(BYTE)USE_LONG(3),
					(IDAImportationResult**)RET_COM_ADDR
				);
				FREE_LONG(3);
				FREE_STRING;
				FREE_COM;
				PUSH_COM(RET_COM);
				break;
				
			case 80:
				// Execute: "push UserData Statics.userData(IUnknown)"
				// AUTOGENERATED
				instrTrace("push UserData Statics.userData(IUnknown)");
				METHOD_CALL_2(
					staticStatics,
					UserData,
					(IUnknown*)USE_COM(1),
					(IDAUserData**)RET_COM_ADDR
				);
				FREE_COM;
				PUSH_COM(RET_COM);
				break;
				
			case 81:
				// Execute: "call Statics.pixelConstructionMode(boolean)"
				// AUTOGENERATED
				instrTrace("call Statics.pixelConstructionMode(boolean)");
				METHOD_CALL_1(
					staticStatics,
					put_PixelConstructionMode,
					USE_LONG_AS_BOOL(1)
				);
				FREE_LONG(1);
				break;
				
			case 82:
				// Execute: "call Engine.setSound(SoundBvr)"
				// USER GENERATED
				instrTrace("call Engine.setSound(SoundBvr)");
				if (m_pSound)
					m_pSound->SwitchTo((IDASound*)USE_COM(1));
				else {
					m_pSound = (IDASound *)USE_COM(1);
					m_pSound->AddRef();
				}
				FREE_COM;
				break;
				
			case 83:
				// Execute: "push boolean BooleanBvr.extractBoolean()"
				// USER GENERATED
				instrTrace("push boolean BooleanBvr.extractBoolean()");
				// A VARIANT_BOOL is a short that is -1 for true, 0 for false
				METHOD_CALL_1(
					(IDABoolean*)USE_COM(1),
					Extract,
					&tmpBool1
				);
				FREE_COM;
				PUSH_LONG(-tmpBool1);
				break;
				
			case 84:
				// Execute: "push IUnknown UserData.extractIUnknown()"
				// AUTOGENERATED
				instrTrace("push IUnknown UserData.extractIUnknown()");
				METHOD_CALL_1(
					(IDAUserData*)USE_COM(1),
					get_Data,
					(IUnknown**)RET_COM_ADDR
				);
				FREE_COM;
				PUSH_COM(RET_COM);
				break;
				
			case 85:
				// Execute: "push java.lang.String StringBvr.extractString()"
				// USER GENERATED
				instrTrace("push java.lang.String StringBvr.extractString()");
				METHOD_CALL_1(
					(IDAString*)USE_COM(1),
					Extract,
					&bstrTmp1
				);
				FREE_COM;
				bstrTmp2 = SysAllocString(bstrTmp1);
				PUSH_STRING(bstrTmp2);
				
				if (bstrTmp2 == 0)
					status = STATUS_ERROR;
				break;
				
			case 86:
				// Execute: "push IUnknown Engine.createObject(java.lang.String)"
				// USER GENERATED
				instrTrace("push IUnknown Engine.createObject(java.lang.String)");
				status = createObject(
					USE_STRING(1),
					(IUnknown**)RET_COM_ADDR
				);
				FREE_STRING;
				PUSH_COM(RET_COM);
				break;
				
			case 87:
				// Execute: "call Engine.initVarArg(java.lang.String)"
				// USER GENERATED
				bstrTmp1 = SysAllocString(USE_STRING(1));
				if (bstrTmp1 == 0)
					status = STATUS_ERROR;
				if (SUCCEEDED(status)) {
					status = initVariantArgFromString(
						bstrTmp1,
						&varArgs[nextVarArg++]
					);
				}
				FREE_STRING;
				break;
				
			case 88:
				// Execute: "call Engine.initVarArg(java.lang.String, int)"
				// USER GENERATED
				// WARNING: Possibly bad to call this if it grabs the string without copying!
				// TODO: Check what this really does, and see if we need to copy the
				// arg before we pass it in
				status = initVariantArg(
					USE_STRING(1),
					(VARTYPE)USE_LONG(1),
					&varArgs[nextVarArg++]
				);
				FREE_LONG(1);
				FREE_STRING;
				break;
				
			case 89:
				// Execute: "call Engine.initVarArg(IUnknown)"
				// USER GENERATED
				status = initVariantArgFromIUnknown(
					(IUnknown*)USE_COM(1),
					VT_UNKNOWN,
					&varArgs[nextVarArg++]
				);
				// Don't release here, release will be done when varArg is released
				POP_COM_NO_FREE;
				break;
				
			case 90:
				// Execute: "call Engine.initVarArg(int)"
				// USER GENERATED
				status = initVariantArgFromLong(
					USE_LONG(1),
					VT_I4,
					&varArgs[nextVarArg++]
				);
				FREE_LONG(1);
				break;
				
			case 91:
				// Execute: "call Engine.initVarArg(double)"
				// USER GENERATED
				status = initVariantArgFromDouble(
					USE_DOUBLE(1),
					VT_R8,
					&varArgs[nextVarArg++]
				);
				FREE_DOUBLE(1);
				break;
				
			case 92:
				// Execute: "call IUnknown.invokeMethod(java.lang.String, VarArgs)"
				// USER GENERATED
				instrTrace("call IUnknown.invokeMethod(java.lang.String, VarArgs)");
				status = invokeDispMethod(
					(IUnknown*)USE_COM(1),
					USE_STRING(1),
					DISPATCH_METHOD,
					nextVarArg,
					varArgs,
					&varArgReturn
				);
				FREE_STRING;
				FREE_COM;
				
				if (SUCCEEDED(status))
					status = releaseVarArgs();
				
				break;
				
			case 93:
				// Execute: "call IUnknown.putProperty(java.lang.String, VarArgs)"
				// USER GENERATED
				instrTrace("call IUnknown.putProperty(java.lang.String, VarArgs)");
				status = invokeDispMethod(
					(IUnknown*)USE_COM(1),
					USE_STRING(1),
					DISPATCH_PROPERTYPUT,
					nextVarArg,
					varArgs,
					&varArgReturn
				);
				FREE_STRING;
				FREE_COM;
				
				if (SUCCEEDED(status))
					status = releaseVarArgs();
				
				break;
				
			case 94:
				// Execute: "push double IUnknown.getDoubleProperty(java.lang.String, VarArgs)"
				// USER GENERATED
				instrTrace("call IUnknown.getDoubleProperty(java.lang.String, VarArgs)");
				status = invokeDispMethod(
					(IUnknown*)USE_COM(1),
					USE_STRING(1),
					DISPATCH_PROPERTYGET,
					nextVarArg,
					varArgs,
					&varArgReturn
				);
				FREE_STRING;
				FREE_COM;
				
				if (SUCCEEDED(status) &&
					SUCCEEDED(VariantChangeType(&varArgReturn, &varArgReturn, 0, VT_R8))) {
					
					PUSH_DOUBLE(varArgReturn.dblVal);
					status = releaseVarArgs();
				}
				
				break;
				
			case 95:
				// Execute: "push java.lang.String IUnknown.getStringProperty(java.lang.String, VarArgs)"
				// USER GENERATED
				instrTrace("push java.lang.String IUnknown.getStringProperty(java.lang.String, VarArgs)");
				status = invokeDispMethod(
					(IUnknown*)USE_COM(1),
					USE_STRING(1),
					DISPATCH_PROPERTYGET,
					nextVarArg,
					varArgs,
					&varArgReturn
				);
				FREE_STRING;
				FREE_COM;
				
				if (SUCCEEDED(status) &&
					SUCCEEDED(VariantChangeType(&varArgReturn, &varArgReturn, 0, VT_BSTR))) {
				
					bstrTmp1 = SysAllocString(varArgReturn.bstrVal);
					PUSH_STRING(bstrTmp1);
				
					if (bstrTmp1 == 0)
						status = STATUS_ERROR;
				}
				
				if (SUCCEEDED(status))
					status = releaseVarArgs();
				
				break;
				
			case 96:
				// Execute: "push IUnknown IUnknown.getIUnknownProperty(java.lang.String, VarArgs)"
				// USER GENERATED
				instrTrace("push IUnknown IUnknown.getIUnknownProperty(java.lang.String, VarArgs)");
				status = invokeDispMethod(
					(IUnknown*)USE_COM(1),
					USE_STRING(1),
					DISPATCH_PROPERTYGET,
					nextVarArg,
					varArgs,
					&varArgReturn
				);
				FREE_STRING;
				FREE_COM;
				
				if (SUCCEEDED(status) &&
					SUCCEEDED(VariantChangeType(&varArgReturn, &varArgReturn, 0, VT_UNKNOWN))) {
				
					if (varArgReturn.punkVal != 0) {
						varArgReturn.punkVal->AddRef();
						PUSH_COM(varArgReturn.punkVal);
						status = releaseVarArgs();
					} else
						status = STATUS_ERROR;
				}
				
				break;
				
			case 97:
				// Execute: "push double IUnknown.invokeDoubleMethod(java.lang.String, VarArgs)"
				// USER GENERATED
				instrTrace("push double IUnknown.invokeDoubleMethod(java.lang.String, VarArgs)");
				status = invokeDispMethod(
					(IUnknown*)USE_COM(1),
					USE_STRING(1),
					DISPATCH_METHOD,
					nextVarArg,
					varArgs,
					&varArgReturn
				);
				FREE_STRING;
				FREE_COM;
				
				if (SUCCEEDED(status) &&
					SUCCEEDED(VariantChangeType(&varArgReturn, &varArgReturn, 0, VT_R8))) {
				
					PUSH_DOUBLE(varArgReturn.dblVal);
					status = releaseVarArgs();
				}
								
				break;
				
			case 98:
				// Execute: "push java.lang.String IUnknown.invokeStringMethod(java.lang.String, VarArgs)"
				// USER GENERATED
				instrTrace("push java.lang.String IUnknown.invokeStringMethod(java.lang.String, VarArgs)");
				status = invokeDispMethod(
					(IUnknown*)USE_COM(1),
					USE_STRING(1),
					DISPATCH_METHOD,
					nextVarArg,
					varArgs,
					&varArgReturn
				);
				FREE_STRING;
				FREE_COM;
				
				if (SUCCEEDED(status) &&
					SUCCEEDED(status = VariantChangeType(&varArgReturn, &varArgReturn, 0, VT_BSTR))) {
				
					bstrTmp1 = SysAllocString(varArgReturn.bstrVal);
					PUSH_STRING(bstrTmp1);
				
					if (bstrTmp1 == 0)
						status = STATUS_ERROR;
				}
				
				if (SUCCEEDED(status))
					status = releaseVarArgs();
				
				break;
				
			case 99:
				// Execute: "push IUnknown IUnknown.invokeIUnknownMethod(java.lang.String, VarArgs)"
				// USER GENERATED
				instrTrace("push IUnknown IUnknown.invokeIUnknownMethod(java.lang.String, VarArgs)");
				status = invokeDispMethod(
					(IUnknown*)USE_COM(1),
					USE_STRING(1),
					DISPATCH_METHOD,
					nextVarArg,
					varArgs,
					&varArgReturn
				);
				FREE_STRING;
				FREE_COM;
				
				if (SUCCEEDED(status) &&
					SUCCEEDED(status = VariantChangeType(&varArgReturn, &varArgReturn, 0, VT_UNKNOWN))) {
				
					if (varArgReturn.punkVal != 0) {
						varArgReturn.punkVal->AddRef();
						PUSH_COM(varArgReturn.punkVal);
						status = releaseVarArgs();
					} else
						status = STATUS_ERROR;
				}
				
				break;
				
			case 100:
				// Execute: "push int IUnknown.invokeIntMethod(java.lang.String, VarArgs)"
				// USER GENERATED
				instrTrace("push int IUnknown.invokeIntMethod(java.lang.String, VarArgs)");
				status = invokeDispMethod(
					(IUnknown*)USE_COM(1),
					USE_STRING(1),
					DISPATCH_METHOD,
					nextVarArg,
					varArgs,
					&varArgReturn
				);
				FREE_STRING;
				FREE_COM;
				
				if (SUCCEEDED(status) &&
					SUCCEEDED(status = VariantChangeType(&varArgReturn, &varArgReturn, 0, VT_I4))) {
				
					PUSH_LONG(varArgReturn.lVal);
					status = releaseVarArgs();
				}
				
				break;
				
			case 101:
				// Execute: "push int IUnknown.getIntProperty(java.lang.String, VarArgs)"
				// USER GENERATED
				instrTrace("push int IUnknown.getIntProperty(java.lang.String, VarArgs)");
				status = invokeDispMethod(
					(IUnknown*)USE_COM(1),
					USE_STRING(1),
					DISPATCH_PROPERTYGET,
					nextVarArg,
					varArgs,
					&varArgReturn
				);
				FREE_STRING;
				FREE_COM;
				
				if (SUCCEEDED(status) &&
					SUCCEEDED(status = VariantChangeType(&varArgReturn, &varArgReturn, 0, VT_I4))) {
				
					PUSH_LONG(varArgReturn.lVal);
					status = releaseVarArgs();
				}
				
				break;
				
			case 102:
				// Execute: "call Engine.putNoExports(boolean)"
				// USER GENERATED
				instrTrace("call Engine.putNoExports(boolean)");
				status = m_pReader->put_NoExports(
					USE_LONG_AS_BOOL(1)
				);
				FREE_LONG(1);
				break;
				
			case 103:
				// Execute: "push boolean Engine.getNoExports()"
				// USER GENERATED
				instrTrace("push boolean Engine.getNoExports()");
				status = m_pReader->get_NoExports(
					&tmpBool1
				);
				PUSH_LONG(-tmpBool1);
				break;
				
			case 104:
				// Execute: "call Engine.putAsync(boolean)"
				// USER GENERATED
				instrTrace("call Engine.putAsync(boolean)");
				status = m_pReader->put_Async(
					USE_LONG_AS_BOOL(1)
				);
				FREE_LONG(1);
				break;
				
			case 105:
				// Execute: "push boolean Engine.getAsync()"
				// USER GENERATED
				instrTrace("push boolean Engine.getAsync()");
				status = m_pReader->get_Async(
					&tmpBool1
				);
				PUSH_LONG(-tmpBool1);
				break;
				
			case 106:
				// Execute: "push Statics.engine"
				// USER GENERATED
				instrTrace("push Statics.engine");
				/*
				GetUnknown()->AddRef();
				PUSH_COM((ILMEngine*)this);
				*/
				m_pWrapper->AddRef();
				PUSH_COM( m_pWrapper );
				break;
				
			case 107:
				// Execute: "push Behavior Engine.getBehavior(java.lang.String, Behavior)"
				// USER GENERATED
				instrTrace("push Behavior Engine.getBehavior(java.lang.String, Behavior)");
				METHOD_CALL_3(
					(ILMEngine*)USE_COM(1),
					GetBehavior,
					USE_STRING(1),
					(IDABehavior *)USE_COM(2),
					(IDABehavior**)RET_COM_ADDR
				);
				FREE_COM;
				FREE_STRING;
				FREE_COM;
				PUSH_COM(RET_COM);
				break;
				
			case 108:
				// Execute: "call Engine.setImage(Engine, ImageBvr)"
				// USER GENERATED
				instrTrace("call Engine.setImage(Engine, ImageBvr)");
				{
					//CLMEngine *engine = (CLMEngine*)(ILMEngine *)USE_COM(1);
					ILMEngineExecute *pExecute;
					status = getExecuteFromUnknown( USE_COM(1), &pExecute );
					if( SUCCEEDED( status ) )
					{
						IDAImage *pImage;
						status = USE_COM(2)->QueryInterface( IID_IDAImage, (void**)&pImage );
						if( SUCCEEDED( status ) )
						{
							pExecute->SetImage( pImage );
							pExecute->Release();
							pImage->Release();
						}
						else
							pExecute->Release();
					}
				
					FREE_COM;
					FREE_COM;
				}
				break;
				
			case 109:
				// Execute: "call Engine.exportBvr(Engine, java.lang.String, Behavior)"
				// USER GENERATED
				instrTrace("call Engine.exportBvr(Engine, java.lang.String, Behavior)");
				{
					//CLMEngine *engine = (CLMEngine*)(ILMEngine*)USE_COM(1);
					ILMEngineExecute *pExecute;
					status = getExecuteFromUnknown( USE_COM(1), &pExecute );
					if( SUCCEEDED( status ) )
					{
						IDABehavior *pBvr;
						status = USE_COM(2)->QueryInterface( IID_IDABehavior, (void**)&pBvr );
						if( SUCCEEDED( status ) )
						{
							//status = engine->m_exportTable->AddBehavior(USE_STRING(1), pBvr);
							status = pExecute->ExportBehavior( USE_STRING(1), pBvr );
							pBvr->Release();
							pExecute->Release();
						}
						else
							pExecute->Release();
					}
				
					FREE_STRING;
					FREE_COM;
					FREE_COM;
				}
				break;
				
			case 110:
				// Execute: "call Engine.setSound(Engine, SoundBvr)"
				// USER GENERATED
				instrTrace("call Engine.setSound(Engine, SoundBvr)");
				{
					//CLMEngine *engine = (CLMEngine*)(ILMEngine*)USE_COM(1);
					ILMEngineExecute *pExecute;
					status = getExecuteFromUnknown( USE_COM(1), &pExecute );
					if( SUCCEEDED( status ) )
					{
						IDASound *pSound;
						status = USE_COM(2)->QueryInterface( IID_IDASound, (void**)&pSound );
						if( SUCCEEDED( status ) )
						{
							
							pSound->Release();
							pExecute->Release();
						}
						else
							pExecute->Release();
					}
				
					FREE_COM;
					FREE_COM;
				}
				break;
				
			case 111:
				// Execute: "call ViewerControl.setTimerSource(int)"
				// USER GENERATED
				
				instrTrace("call ViewerControl.setTimerSource(int)");
				METHOD_CALL_1(
					(IDAViewerControl*)USE_COM(1),
					put_TimerSource,
					(DA_TIMER_SOURCE)USE_LONG(1)
				);
				FREE_LONG(1);
				FREE_COM;
				break;
				
			case 112:
				// Execute: "call Engine.callScriptAsync(java.lang.String, java.lang.String)"
				// USER GENERATED
				instrTrace("call Engine.callScriptAsync(java.lang.String, java.lang.String)");
				
				{
					// Call script asynchronously
					CLMEngineScriptData *scriptData = new CLMEngineScriptData();
					scriptData->scriptSourceToInvoke = USE_STRING(1);
					scriptData->scriptLanguage = USE_STRING(2);
					scriptData->event = NULL;
					scriptData->eventData = NULL;
					PostMessage(m_workerHwnd, WM_LMENGINE_SCRIPT_CALLBACK, (WPARAM)this, (LPARAM)scriptData);
					
					// The scriptData fields will be freed when the message is processed
					POP_STRING_NO_FREE;
					POP_STRING_NO_FREE;
				}
				break;
				
			case 113:
				// Execute: "call Engine.callScriptAsyncEvent(java.lang.String, java.lang.String, DXMEvent)"
				// USER GENERATED
				instrTrace("call Engine.callScriptAsyncEvent(java.lang.String, java.lang.String, DXMEvent)");
				
				{	
					// Call script asynchronously
					CLMEngineScriptData *scriptData = new CLMEngineScriptData();
					scriptData->scriptSourceToInvoke = USE_STRING(1);
					scriptData->scriptLanguage = USE_STRING(2);
					
					// This event will be triggered when the message is received and the
					// script has been executed.
					scriptData->event = (IDAEvent *)USE_COM(1);
					scriptData->eventData = NULL;
					PostMessage(m_workerHwnd, WM_LMENGINE_SCRIPT_CALLBACK, (WPARAM)this, (LPARAM)scriptData);
					
					// The scriptData fields will be freed when the message is processed
					POP_COM_NO_FREE;
					POP_STRING_NO_FREE;
					POP_STRING_NO_FREE;
				}
				break;
				
			case 114:
				// Execute: "call Engine.callScriptAsyncEventData(java.lang.String, java.lang.String, DXMEvent, Behavior)"
				// USER GENERATED
				instrTrace("call Engine.callScriptAsyncEventData(java.lang.String, java.lang.String, DXMEvent, Behavior)");
				
				{
					// Call script asynchronously
					CLMEngineScriptData *scriptData = new CLMEngineScriptData();
					scriptData->scriptSourceToInvoke = USE_STRING(1);
					scriptData->scriptLanguage = USE_STRING(2);
					
					// This event will be triggered when the message is received and the
					// script has been executed.
					scriptData->event = (IDAEvent *)USE_COM(1);
					scriptData->eventData = (IDABehavior *)USE_COM(2);
					PostMessage(m_workerHwnd, WM_LMENGINE_SCRIPT_CALLBACK, (WPARAM)this, (LPARAM)scriptData);
					
					// The scriptData fields will be freed when the message is processed
					POP_COM_NO_FREE;
					POP_COM_NO_FREE;
					POP_STRING_NO_FREE;
					POP_STRING_NO_FREE;
				}
				break;
				
			case 115:
				// Execute: "call Engine.setPauseEvent(DXMEvent, boolean)"
				// USER GENERATED
				
				//set the stop event on the engine pointed to by the first argument. com 1
				instrTrace("call Engine.setPauseEvent(DXMEvent, boolean)");
				
				{
					//CLMEngine *engine = (CLMEngine*)(ILMEngine*)USE_COM(1);
					ILMEngineExecute *pExecute;
					status = getExecuteFromUnknown( USE_COM(1), &pExecute );
					if( SUCCEEDED( status ) )
					{
						IDAEvent *pEvent;
						status = USE_COM(2)->QueryInterface( IID_IDAEvent, (void**)&pEvent );
						if( SUCCEEDED( status ) )
						{
							pExecute->SetStopEvent( pEvent, ( USE_LONG(1) == 1 )?TRUE:FALSE );
							pExecute->Release();
							pEvent->Release();
						}
						else
							pExecute->Release();
					}
				
					FREE_COM;
					FREE_COM;
					FREE_LONG(1);
				}
				break;
				
			case 116:
				// Execute: "call Engine.setPlayEvent(DXMEvent, boolean)"
				// USER GENERATED
				
				//set the start event on the engine pointed to by the first argument. com 1
				instrTrace("call Engine.setPlayEvent(DXMEvent, boolean)");
				{
					//CLMEngine *engine = (CLMEngine*)(ILMEngine*)USE_COM(1);
					ILMEngineExecute *pExecute;
					status = getExecuteFromUnknown( USE_COM(1), &pExecute );
					if( SUCCEEDED( status ) )
					{
						IDAEvent *pEvent;
						USE_COM(2)->QueryInterface( IID_IDAEvent, (void**)&pEvent );
						if( SUCCEEDED( status ) )
						{
							pExecute->SetStartEvent( pEvent, ( USE_LONG(1) == 1 )?TRUE:FALSE );
							pEvent->Release();
							pExecute->Release();
						}
						else
							pExecute->Release();
					}
				
				}
				FREE_COM;
				FREE_COM;
				FREE_LONG(1);
				break;
				
			case 117:
				// Execute: "push double Engine.getCurrentTime()"
				// USER GENERATED
				instrTrace("push double Engine.getCurrentTime()");
				
				{
					//get the engine pointed to by the first argument
					//CLMEngine *engine = (CLMEngine*)(ILMEngine*)USE_COM(1);
					ILMEngine2 *pEngine;
					status = getEngine2FromUnknown( USE_COM(1), &pEngine );
					if( SUCCEEDED( status ) )
					{
						double currentTime = -1.0;
						if( SUCCEEDED( pEngine->getCurrentGraphTime( &currentTime ) ) )
						{
							PUSH_DOUBLE( currentTime );
						} else {
							PUSH_DOUBLE( -1.0 );
						}
						pEngine->Release();
					}
				}
				//free the engine from the com stack
				FREE_COM;
				break;
				
			case 118:
				// Execute: "push boolean Engine.isStandaloneStreaming()"
				// USER GENERATED
				instrTrace("push boolean Engine.isStandaloneStreaming()");
				if(m_pReader != NULL )
				{
					//we can't do this without adding a method to ILMReader. blech.
					//if( ((CLMReader*)m_pReader)->isStandaloneStreaming() )
					IDAViewerControl *pViewerControl = NULL;
					m_pReader->get_ViewerControl( &pViewerControl );
					if( pViewerControl != NULL )
					{
						pViewerControl->Release();
						PUSH_LONG( 1 );
					}
					else
					{
						PUSH_LONG( 0 );
					}
				}
				else
				{
					PUSH_LONG( 0 );
				}
				break;
				
			case 119:
				// Execute: "push double Engine.getDAVersion()"
				// USER GENERATED
				instrTrace("push double Engine.getDAVersion()");
				{
					PUSH_DOUBLE( getDAVersionAsDouble() );
				}
				
				break;
				
			case 120:
				// Execute: "call ViewerControl.stopModel()"
				// USER GENERATED
				instrTrace("call ViewerControl.stopModel()");
				
				{
					IDAViewerControl *pViewerControl = (IDAViewerControl*)USE_COM(1);
					IDAView *pView = NULL;
					status = pViewerControl->get_View( &pView );
					if( SUCCEEDED( status ) )
					{
						status = pView->StopModel();
						pView->Release();
					}
				}
				//don't kill LMRT if we fail to get the view.
				status = S_OK;
				
				FREE_COM;
				break;
				
			case 121:
				// Execute: "push double Engine.staticGetCurrentTime()"
				// USER GENERATED
				instrTrace("push double Engine.staticGetCurrentTime()");
				{
					
					double currentTime = -1.0;
					if( m_pParentEngine != NULL )
					{
						if( SUCCEEDED( m_pParentEngine->getCurrentGraphTime( &currentTime ) ) )
						{
							PUSH_DOUBLE( currentTime );
						} else {
							PUSH_DOUBLE( -1.0 );
						}
					} else {
						if( SUCCEEDED( getCurrentGraphTime( &currentTime ) ) )
						{
							PUSH_DOUBLE( currentTime );
						} else {
							PUSH_DOUBLE( -1.0 );
						}
					}
					
					//PUSH_DOUBLE(-1.0);
				}
				break;
				
			case 122:
				// Execute: "call Engine.disableAutoAntialias()"
				// USER GENERATED
				instrTrace("call Engine.disableAutoAntialias()");

				if( m_pParentEngine != NULL )
					m_pParentEngine->disableAutoAntialias();
				else
					disableAutoAntialias();
				break;
				
			case 123:
				// Execute: "push double Engine.getLMRTVersion()"
				// USER GENERATED
				instrTrace("push double Engine.getLMRTVersion()");
				
				PUSH_DOUBLE( getLMRTVersionAsDouble() );

				break;
				
			case 124:
				// Execute: "call Engine.ensureBlockSize(int)"
				// USER GENERATED
				instrTrace("call Engine.ensureBlockSize(int)");
				
				if( m_pParentEngine != NULL )
					m_pParentEngine->ensureBlockSize( USE_LONG(1) );
				else
					ensureBlockSize( USE_LONG(1) );
				
				FREE_LONG(1);
				break;
				
			default:
				status = E_INVALIDARG;
				break;
			}
			break;
		
		default:
			status = E_INVALIDARG;
			break;
		}
		
		// END AUTOGENERATED

		LeaveCriticalSection(&m_CriticalSection);
		
		if (status == E_NOTIMPL)
			status = S_OK;
	}

#ifdef COM_DEBUG
	Assert(_com_count == 0, "COM count is not 0 at end of parsing");
#endif

	if (status == E_PENDING) 
		codeStream->Revert();

	return status;
}

void CLMEngine::releaseAll()
{
	// Release all com objects left on the stack, in arrays, and in temp store

	// Do the com stack
	while (comTop > comStack)
		FREE_COM_TEST;

	// Do the com array stack
	while (comArrayTop > comArrayStack)
		FREE_COM_ARRAY;

	// Do the com store
	for (int i=0; i<comStoreSize; i++) {
		if (comStore[i] != 0) {
			comStore[i]->Release();
			comStore[i] = NULL;
		}
	}

	// Release varArgs
	releaseVarArgs();
}

HRESULT CLMEngine::releaseVarArgs()
{
	HRESULT hr;

	for (int i=0; i<nextVarArg; i++)
		VariantClear(&varArgs[i]);

	nextVarArg = 0;

	VariantClear(&varArgReturn);

	return S_OK;
}

void CLMEngine::freeCOMArray(IUnknown** array, long length)
{
	if (array == 0)
		return;

	for (IUnknown **tmp = array; length--; ) {
		(*tmp)->Release();
		*tmp++ = NULL;
	}

	delete[] array;
}

HRESULT CLMEngine::ensureDoubleArrayCap(long cap)
{
	if (doubleArray && doubleArrayCap < cap) {
		// Allocated one is too small. Get rid of it
		delete[] doubleArray;
		doubleArray = 0;
	}

	if (doubleArray == 0) {
		// Not allocated yet
		doubleArray = new double[cap];

		if (doubleArray == 0)
			return E_UNEXPECTED;

		doubleArrayCap = cap;
	}

	return S_OK;
}


STDMETHODIMP CLMEngine::Notify(IDABehavior *eventData,
					IDABehavior *curRunningBvr,
					IDAView *curView,
					IDABehavior **ppBvr)
{
	if (!ppBvr)
		return E_POINTER;

	if (!curRunningBvr)
		return E_POINTER;

	if (!notifier)
		return E_UNEXPECTED;
	
// 	MessageBox(NULL, "Notify!!", "CLMNotifier", MB_OK);

	// Put the args into the temp variables
	comStore[0] = eventData;
	comStore[1] = curRunningBvr;

	eventData->AddRef();
	curRunningBvr->AddRef();

	// Reset the code stream to start from the beginning
	((ByteArrayStream*)codeStream)->reset();

	// Execute the code stream
	HRESULT hr = execute();

	if (SUCCEEDED(hr)) {
		// Pop the resulting behavior into the return variable, with no release
		*ppBvr = (IDABehavior*)POP_COM_NO_FREE;
	}

	// Release all COM objects
	releaseAll();

	return hr;
}

HRESULT CLMEngine::validateHeader()
{
	// Check for two possibilites:
	//   Header starts with LMReader
	//   Header starts with 200 bytes containing valid .x header with LMReader somewhere in it

	BYTE head[] = "xof 0302bin 0032{183C2599-0480-11d1-87EA-00C04FC29D46}";
	BYTE text[] = "LMReader";

	int count = 54;

	int checkLMReader = 0;
	int checkXHeader = 0;
	int checkLMReaderFailed = 0;

	BYTE *headp = head;
	BYTE *textp = text;

	HRESULT status = S_OK;

	codeStream->Commit();

	while (count-- && status == S_OK) {
		BYTE	byte;
		if (SUCCEEDED(status = codeStream->readByte(&byte))) {
			
			if (checkXHeader >= 0 && checkXHeader < 54) {
				if (*headp == byte) {
					headp++;
					checkXHeader++;
				} else {
					checkXHeader = -1;
				}
			}
			
			if (checkLMReader >= 0 && checkLMReader < 8) {
				if (*textp == byte) {
					textp++;
					checkLMReader++;
				} else {
					checkLMReader = -1;
				}
			}
			
			if (checkLMReader == 8)
				return S_OK;
		}
	}

	if (status == E_PENDING) 
		codeStream->Revert();

	if (!SUCCEEDED(status))
		return status;

	if (checkXHeader == 54)
		return S_OK;

	return E_UNEXPECTED;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\lm\dll\stdafx.cpp ===
/*++

Copyright (c) 1995-96 Microsoft Corporation

Abstract:

    Ole Object initialization

Revision:

--*/

#include "..\behaviors\headers.h"
#include "resource.h"

#undef map
#undef SubclassWindow

// Put this here to initialize all the ATL stuff

#ifdef _ATL_STATIC_REGISTRY
#include <statreg.h>
#include <statreg.cpp>
#endif

#include <atlimpl.cpp>
#include <atlctl.cpp>
#include <atlwin.cpp>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\lm\include\lmatl.h ===
/*******************************************************************************

Copyright (c) 1995_96 Microsoft Corporation

Abstract:

    {Insert General Comment Here}

*******************************************************************************/


#ifndef _LMATL_H
#define _LMATL_H

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#define _ATL_NO_DEBUG_CRT 1

#ifdef _DEBUG
#undef _ASSERTE
#endif

#define _ASSERTE(expr) ((void)0)

#define _ATL_STATIC_REGISTRY 1


#ifdef _DEBUG
inline void _cdecl AtlTrace2(LPCTSTR , ...){}
#define ATLTRACE            1 ? (void)0 : AtlTrace2
#endif

#include <atlbase.h>

//#define _ATL_APARTMENT_THREADED
// THIS MUST BE CALLED _Module - all the ATL header files depend on it
extern CComModule _Module;

#include <atlcom.h>
#include <atlctl.h>

// Just to make things more uniform
#define RELEASE(x) if (x) { (x)->Release(); (x) = NULL; }

#define LMCLEANUPIFFAILED(hr)	if (FAILED(hr)) { DASSERT(FALSE); goto cleanup; }
#define LMRETURNIFFAILED(hr)	if (FAILED(hr)) { DASSERT(FALSE); return hr; }
#define LMRETURNIFNULL(p)		if (p == NULL) { DASSERT(FALSE); return E_FAIL; }

#endif /* _LMATL_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\lm\idl\makefile.inc ===
$(SDKDIR)\lmrt.h : $(O)\lmrt.h
    copy /v $? $@

$(SDKDIR)\lmrt.tlb : $(O)\lmrt.tlb
    copy /v $? $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\lm\include\lmattrib.h ===
#ifndef INC_LM_ATTRIB_H
#define INC_LM_ATTRIB_H

//include the chrome attributes
#include "..\chrome\include\attrib.h"

#define BEHAVIOR_TYPE_AUTOEFFECT                 L"autoEffect"
#define BEHAVIOR_TYPE_AVOIDFOLLOW                L"avoidFollow"
#define BEHAVIOR_TYPE_JUMP   		             L"jump"

//properties for autoeffects
#define BEHAVIOR_PROPERTY_TYPE                   L"type"
#define BEHAVIOR_PROPERTY_CAUSE                  L"cause"
#define BEHAVIOR_PROPERTY_SPAN                   L"span"
#define BEHAVIOR_PROPERTY_SIZE                   L"size"
#define BEHAVIOR_PROPERTY_RATE                   L"rate"
#define BEHAVIOR_PROPERTY_GRAVITY                L"gravity"
#define BEHAVIOR_PROPERTY_WIND                   L"wind"
#define BEHAVIOR_PROPERTY_FILLCOLOR              L"fillColor"
#define BEHAVIOR_PROPERTY_STROKECOLOR            L"strokeColor"
#define BEHAVIOR_PROPERTY_OPACITY				 L"opacity"

//properties for avoid follow
#define BEHAVIOR_PROPERTY_RADIUS                 L"radius"
#define BEHAVIOR_PROPERTY_TARGET                 L"target"
#define BEHAVIOR_PROPERTY_VELOCITY               L"velocity"
#define TARGET_MOUSE                             L"mouse"

//properties for jump
#define BEHAVIOR_PROPERTY_INTERVAL				 L"interval"
#define BEHAVIOR_PROPERTY_RANGE					 L"range"

#endif// INC_LM_ATTRIB_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\lm\control\lmctrl.h ===
// lmctrl.h :

#ifndef __LMCTRL_H_
#define __LMCTRL_H_

#include "resource.h"       // main symbols
#include <htmlfilter.h>
#include "danim.h"
#include <strmif.h>  //for IPin
#include "lmrt.h"
#include "Engine.h"
#include "version.h"

/////////////////////////////////////////////////////////////////////////////
class LMEngineList
{
public:
	ILMEngine		*engine;
	LMEngineList	*next;
};

class ATL_NO_VTABLE CLMReader : 
    public CComObjectRootEx<CComMultiThreadModel>,
    public CComCoClass<CLMReader, &CLSID_LMReader>,
    public CComControl<CLMReader>,
    public IDispatchImpl<ILMReader2, &IID_ILMReader2, &LIBID_LiquidMotion>,
    public IProvideClassInfo2Impl<&CLSID_LMReader, NULL, &LIBID_LiquidMotion>,
    public IPersistStreamInitImpl<CLMReader>,
    public IPersistStorageImpl<CLMReader>,
    public IOleControlImpl<CLMReader>,
    public IOleObjectImpl<CLMReader>,
    public IOleInPlaceActiveObjectImpl<CLMReader>,
    public IViewObjectExImpl<CLMReader>,
    public IOleInPlaceObjectWindowlessImpl<CLMReader>,
    public IDataObjectImpl<CLMReader>,
    public ISpecifyPropertyPagesImpl<CLMReader>,
    public IObjectSafetyImpl<CLMReader>,
	public IOleCommandTarget,
	public IPersistPropertyBagImpl<CLMReader>,
	public IAMFilterGraphCallback
{
  public:
    CLMReader();
    ~CLMReader();
	bool isStandaloneStreaming();

DECLARE_REGISTRY_RESOURCEID(IDR_LMCTRL)

BEGIN_COM_MAP(CLMReader)
		COM_INTERFACE_ENTRY(ILMReader2)
        COM_INTERFACE_ENTRY(ILMReader)
        COM_INTERFACE_ENTRY(IDispatch)
        COM_INTERFACE_ENTRY_IMPL_IID(IID_IViewObject2, IViewObjectEx)
        COM_INTERFACE_ENTRY_IMPL_IID(IID_IViewObject, IViewObjectEx)
        COM_INTERFACE_ENTRY_IMPL(IOleInPlaceObjectWindowless)
        COM_INTERFACE_ENTRY_IMPL_IID(IID_IOleInPlaceObject, IOleInPlaceObjectWindowless)
        COM_INTERFACE_ENTRY_IMPL_IID(IID_IOleWindow, IOleInPlaceObjectWindowless)
        COM_INTERFACE_ENTRY_IMPL(IOleInPlaceActiveObject)
        COM_INTERFACE_ENTRY_IMPL(IOleControl)
        COM_INTERFACE_ENTRY_IMPL(IOleObject)
        COM_INTERFACE_ENTRY_IMPL(IPersistStorage)
        COM_INTERFACE_ENTRY_IMPL(IPersistStreamInit)
        COM_INTERFACE_ENTRY_IMPL(ISpecifyPropertyPages)
        COM_INTERFACE_ENTRY_IMPL(IDataObject)
        COM_INTERFACE_ENTRY_IMPL(IObjectSafety)
        COM_INTERFACE_ENTRY(IProvideClassInfo)
        COM_INTERFACE_ENTRY(IProvideClassInfo2)
 		COM_INTERFACE_ENTRY(IOleCommandTarget)
		COM_INTERFACE_ENTRY_IMPL(IPersistPropertyBag)
		COM_INTERFACE_ENTRY(IAMFilterGraphCallback)
END_COM_MAP()

BEGIN_PROPERTY_MAP(LMReader)
END_PROPERTY_MAP()


BEGIN_MSG_MAP(CLMReader)
END_MSG_MAP()
        
// IOleInPlaceObjectWindowlessImpl
	STDMETHOD(OnWindowMessage)(UINT msg, WPARAM wParam, LPARAM lParam, LRESULT *plResult)
	{
		return ProcessWindowMessage(m_hWnd, msg,
									wParam, lParam,
									*plResult)?S_OK:S_FALSE;
	}

// IOleCommandTarget
	STDMETHOD(QueryStatus)( const GUID* pguidCmdGroup, ULONG cCmds,
		OLECMD prgCmds[], OLECMDTEXT* pCmdText );
	STDMETHOD(Exec)(const GUID* pguidCmdGroup, DWORD nCmdID,
		DWORD nCmdexecopt, VARIANTARG* pvaIn, VARIANTARG* pvaOut );

// ILMReader
    STDMETHOD(get_Image)(/*[out, retval]*/ IDAImage **pVal);
    STDMETHOD(get_Sound)(/*[out, retval]*/ IDASound **pVal);
    STDMETHOD(get_Engine)(/*[out, retval]*/ ILMEngine **pVal);
	STDMETHOD(get_NoExports)(/*[out]*/ VARIANT_BOOL *pVal);
	STDMETHOD(put_NoExports)(/*[in]*/ VARIANT_BOOL pVal);
	STDMETHOD(get_Async)(/*[out]*/ VARIANT_BOOL *pVal);
	STDMETHOD(put_Async)(/*[in]*/ VARIANT_BOOL pVal);
	STDMETHOD(get_Src)(/*[out]*/ BSTR *pVal);
	STDMETHOD(createEngine)(/*[out, retval]*/ILMEngine **pVal);
	STDMETHOD(createAsyncEngine)(/*[out, retval]*/ILMEngine **pVal);
	STDMETHOD(execute)(/*[in, string]*/ BSTR url, /*[out, retval]*/ ILMEngine **pVal);
	STDMETHOD(_execute)(/*[in, string]*/ BSTR url, /*[in]*/LONG blkSize, /*[in]*/LONG delay, /*[out, retval]*/ ILMEngine **pVal);
	STDMETHOD(Load)(LPSTREAM pStm);
// ILMReader2
    STDMETHOD(put_ViewerControl)(/*[in]*/ IDAViewerControl *viewerControl);
	STDMETHOD(get_ViewerControl)(/*[out, retval]*/IDAViewerControl **viewerControl);
	STDMETHOD(get_VersionString)(/*[out, retval]*/BSTR *versionString);
	STDMETHOD(releaseFilterGraph)();

// IObjectSafetyImpl
	STDMETHOD(SetInterfaceSafetyOptions)(
							/* [in] */ REFIID riid,
							/* [in] */ DWORD dwOptionSetMask,
							/* [in] */ DWORD dwEnabledOptions);
	STDMETHOD(GetInterfaceSafetyOptions)(
							/* [in] */ REFIID riid, 
							/* [out] */DWORD *pdwSupportedOptions, 
							/* [out] */DWORD *pdwEnabledOptions);

// IPropertyBagImpl
	STDMETHOD(Load)(IPropertyBag *pPropertyBag, IErrorLog *pErrorLog);

// IOleInPlaceObjectWindowlessImpl
	STDMETHOD(InPlaceDeactivate)();
// IAMFilterGraphCallback
	HRESULT UnableToRender(IPin* pPin );

	HRESULT getHwnd( HWND* phwnd )
	{
		(*phwnd) = m_hWnd;
		return S_OK;
	}

protected:
	ILMEngine			*m_pEngine;
	VARIANT_BOOL		m_bAsync;
	VARIANT_BOOL		m_bNoExports;
	BSTR				m_Src;
	LONG				m_AsyncBlkSize;
	LONG				m_AsyncDelay;
	LMEngineList		*engineList, *engineListTail;
	IDAViewerControl    *m_pViewerControl;
	BOOL 				m_bAutoCodecDownloadEnabled;

	CLSID   m_clsidDownloaded;

};

class CDownloadCallback : public CComObjectRootEx<CComSingleThreadModel>,
			    public IBindStatusCallback, public IServiceProvider,
			    public IAuthenticate, public ICodeInstall
{
    BEGIN_COM_MAP(CDownloadCallback)
	    COM_INTERFACE_ENTRY(IBindStatusCallback)
	    COM_INTERFACE_ENTRY(IServiceProvider)
	    COM_INTERFACE_ENTRY(IAuthenticate)
	    COM_INTERFACE_ENTRY(ICodeInstall)
	    COM_INTERFACE_ENTRY(IWindowForBindingUI)
    END_COM_MAP()
	    
public:
    CDownloadCallback();
    ~CDownloadCallback();
    
    // --- IBindStatusCallback methods ---

    STDMETHODIMP    OnStartBinding(DWORD grfBSCOption, IBinding* pbinding);
    STDMETHODIMP    GetPriority(LONG* pnPriority);
    STDMETHODIMP    OnLowResource(DWORD dwReserved);
    STDMETHODIMP    OnProgress(ULONG ulProgress, ULONG ulProgressMax, ULONG ulStatusCode,
			LPCWSTR pwzStatusText);
    STDMETHODIMP    OnStopBinding(HRESULT hrResult, LPCWSTR szError);
    STDMETHODIMP    GetBindInfo(DWORD* pgrfBINDF, BINDINFO* pbindinfo);
    STDMETHODIMP    OnDataAvailable(DWORD grfBSCF, DWORD dwSize, FORMATETC *pfmtetc,
			STGMEDIUM* pstgmed);
    STDMETHODIMP    OnObjectAvailable(REFIID riid, IUnknown* punk);

    // IServiceProvider methods
    STDMETHODIMP     QueryService(REFGUID guidService, REFIID riid, void ** ppvObject);
    
    // IAuthenticate methods
    STDMETHODIMP Authenticate(HWND *phwnd, LPWSTR *pszUsername, LPWSTR *pszPassword);

    // IWindowForBindingUI methods
    STDMETHODIMP GetWindow(REFGUID rguidReason, HWND *phwnd);

    // ICodeInstall methods
    STDMETHODIMP OnCodeInstallProblem(ULONG ulStatusCode, LPCWSTR szDestination, 
				      LPCWSTR szSource, DWORD dwReserved);

	CLMReader*          m_pLMR;
    HRESULT             m_hrBinding;
    IUnknown *          m_pUnk;
    HANDLE              m_evFinished;
    ULONG		m_ulProgress, m_ulProgressMax;
};

#endif //__LMCTRL_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\lm\include\lmdefaults.h ===
#ifndef INC_LM_DEFAULTS_H
#define INC_LM_DEFAULTS_H

//include the chrome defaults
#include "..\chrome\include\defaults.h"

#define DEFAULT_AUTOEFFECT_TYPE				L"sparkles"
#define DEFAULT_AUTOEFFECT_CAUSE			L"time"		
#define DEFAULT_AUTOEFFECT_SPAN				0.5f
#define DEFAULT_AUTOEFFECT_SIZE				0.5f
#define DEFAULT_AUTOEFFECT_RATE				0.5f
#define DEFAULT_AUTOEFFECT_GRAVITY			0.0f
#define DEFAULT_AUTOEFFECT_WIND				0.0f
#define DEFAULT_AUTOEFFECT_FILLCOLOR		0xffffff
#define DEFAULT_AUTOEFFECT_STROKECOLOR		0x000000
#define DEFAULT_AUTOEFFECT_OPACITY			1.0f

#define DEFAULT_JUMPBVR_RANGE				L"page"
#define DEFAULT_JUMPBVR_INTERVAL			1.0f

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\lm\idl\lmbvrdispid.h ===
#ifndef __LMBEHAVIORDISPID_H_
#define __LMBEHAVIORDISPID_H_
//*********************************************************************************
//
// File: lmbvrdispid.h
// Author: kurtj
// Date Created: 11/6/98
//
//
//*********************************************************************************

//avoidfollow Behavior dispids
#define DISPID_AVOIDFOLLOWBVR_BASE 1
#define DISPID_IAVOIDFOLLOWBVR_ANIMATES             (DISPID_AVOIDFOLLOWBVR_BASE + 0)
#define DISPID_IAVOIDFOLLOWBVR_RADIUS				(DISPID_AVOIDFOLLOWBVR_BASE + 1)
#define DISPID_IAVOIDFOLLOWBVR_TARGET				(DISPID_AVOIDFOLLOWBVR_BASE + 2)
#define DISPID_IAVOIDFOLLOWBVR_VELOCITY				(DISPID_AVOIDFOLLOWBVR_BASE + 3)
#define DISPID_IAVOIDFOLLOWBVR_BUILDBVRFRAGS		(DISPID_AVOIDFOLLOWBVR_BASE + 4)

//autoeffect Behavior dispids
#define DISPID_AUTOEFFECTBVR_BASE 1
#define DISPID_IAUTOEFFECTBVR_ANIMATES				(DISPID_AUTOEFFECTBVR_BASE + 0)
#define DISPID_IAUTOEFFECTBVR_TYPE					(DISPID_AUTOEFFECTBVR_BASE + 1)
#define DISPID_IAUTOEFFECTBVR_CAUSE					(DISPID_AUTOEFFECTBVR_BASE + 2)
#define DISPID_IAUTOEFFECTBVR_SPAN					(DISPID_AUTOEFFECTBVR_BASE + 3)
#define DISPID_IAUTOEFFECTBVR_SIZE					(DISPID_AUTOEFFECTBVR_BASE + 4)
#define DISPID_IAUTOEFFECTBVR_RATE					(DISPID_AUTOEFFECTBVR_BASE + 5)
#define DISPID_IAUTOEFFECTBVR_GRAVITY				(DISPID_AUTOEFFECTBVR_BASE + 6)
#define DISPID_IAUTOEFFECTBVR_WIND					(DISPID_AUTOEFFECTBVR_BASE + 7)
#define DISPID_IAUTOEFFECTBVR_FILLCOLOR				(DISPID_AUTOEFFECTBVR_BASE + 8)
#define DISPID_IAUTOEFFECTBVR_STROKECOLOR			(DISPID_AUTOEFFECTBVR_BASE + 9)
#define DISPID_IAUTOEFFECTBVR_OPACITY				(DISPID_AUTOEFFECTBVR_BASE + 10)
#define DISPID_IAUTOEFFECTBVR_BUILDBVRFRAGS			(DISPID_AUTOEFFECTBVR_BASE + 11)
#define DISPID_IAUTOEFFECTBVR_MOUSEEVENT			(DISPID_AUTOEFFECTBVR_BASE + 12)

// Jump Behavior dispids
#define DISPID_JUMPBVR_BASE					1
#define DISPID_IJUMPBVR_INTERVAL			(DISPID_JUMPBVR_BASE+1)
#define DISPID_IJUMPBVR_RANGE				(DISPID_JUMPBVR_BASE+2)
#define DISPID_IJUMPBVR_BUILDBVRFRAGS		(DISPID_JUMPBVR_BASE+3)


//*********************************************************************************
//
// End of File
//
//*********************************************************************************
#endif //__LMBEHAVIORDISPID_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\lm\include\resource.h ===
/*******************************************************************************

Copyright (c) 1995_96 Microsoft Corporation

Abstract:

    LM Resources

*******************************************************************************/


#ifndef _RESOURCE_H
#define _RESOURCE_H

#define IDR_LMCTRL            101
#define IDR_LMBVRFACTORY      102
//#define IDR_AVOIDFOLLOWBVR    103 //punted for v1
#define IDR_AUTOEFFECTBVR	  104
//#define IDR_JUMPBVR			  105 //punted for v1

#define RESID_TYPELIB           1



#include "..\chrome\include\resource.h"

#endif /* _RESOURCE_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\lm\include\lmtrace.h ===
#ifndef _LM_TRACE_INC_
#define _LM_TRACE_INC_
/////////////////////////////////////////////////////////////
//trace definitions stolen from ATL 30 headers and customized
/////////////////////////////////////////////////////////////

/////////////////////////////////////
// LM DEBUG Defines
////////////////////////////////////
#ifdef _DEBUG
#include <assert.h>
#define LMASSERT(expr) assert((expr))

#define LM_TRACE_CATEGORY	(lmTraceNone)
#define LM_TRACE_LEVEL		(0)
#else
#define LMASSERT(expr) ((void)0)
#endif //_DEBUG
////////////////////////////////////
// End LM DEBUG Defines
////////////////////////////////////

enum lmTraceFlags
{
	//LM defined categories
	lmTraceNone					= 0x00000000,
	lmTraceLMRT 				= 0x00000001,
	lmTraceBaseBehavior			= 0x00000002,
	lmTraceMoveBehavior			= 0x00000004,
	lmTraceColorBehavior 		= 0x00000008,
	lmTraceAll					= 0xFFFFFFFF,
};

#ifndef LM_TRACE_CATEGORY
#define LM_TRACE_CATEGORY (lmTraceAll)
#endif

#ifdef _DEBUG

#ifndef LM_TRACE_LEVEL
#define LM_TRACE_LEVEL 0
#endif

inline void _cdecl LmTrace(LPCSTR lpszFormat, ...)
{
	va_list args;
	va_start(args, lpszFormat);

	int nBuf;
	char szBuffer[512];

	nBuf = _vsnprintf(szBuffer, sizeof(szBuffer), lpszFormat, args);
	LMASSERT(nBuf < sizeof(szBuffer)); //Output truncated as it was > sizeof(szBuffer)

	OutputDebugStringA(szBuffer);
	va_end(args);
}
inline void _cdecl LmTrace2(DWORD category, UINT level, LPCSTR lpszFormat, ...)
{
	if (category & LM_TRACE_CATEGORY && level <= LM_TRACE_LEVEL)
	{
		va_list args;
		va_start(args, lpszFormat);

		int nBuf;
		char szBuffer[512];

		nBuf = _vsnprintf(szBuffer, sizeof(szBuffer), lpszFormat, args);
		LMASSERT(nBuf < sizeof(szBuffer)); //Output truncated as it was > sizeof(szBuffer)

		OutputDebugStringA("LM: ");
		OutputDebugStringA(szBuffer);
		va_end(args);
	}
}
#ifndef OLE2ANSI
inline void _cdecl LmTrace(LPCWSTR lpszFormat, ...)
{
	va_list args;
	va_start(args, lpszFormat);

	int nBuf;
	WCHAR szBuffer[512];

	nBuf = _vsnwprintf(szBuffer, sizeof(szBuffer), lpszFormat, args);
	LMASSERT(nBuf < sizeof(szBuffer));//Output truncated as it was > sizeof(szBuffer)

	OutputDebugStringW(szBuffer);
	va_end(args);
}
inline void _cdecl LmTrace2(DWORD category, UINT level, LPCWSTR lpszFormat, ...)
{
	if (category & LM_TRACE_CATEGORY && level <= LM_TRACE_LEVEL)
	{
		va_list args;
		va_start(args, lpszFormat);

		int nBuf;
		WCHAR szBuffer[512];

		nBuf = _vsnwprintf(szBuffer, sizeof(szBuffer), lpszFormat, args);
		LMASSERT(nBuf < sizeof(szBuffer));//Output truncated as it was > sizeof(szBuffer)

		OutputDebugStringW(L"LM: ");
		OutputDebugStringW(szBuffer);
		va_end(args);
	}
}
#endif //!OLE2ANSI


#ifndef LMTRACE
#define LMTRACE            LmTrace
#define LMTRACE2           LmTrace2
#endif
#define LMTRACENOTIMPL(funcname)   LMTRACE2(lmTraceNotImpl, 2, _T("LM: %s not implemented.\n"), funcname); return E_NOTIMPL
#else // !DEBUG
inline void _cdecl LmTrace(LPCSTR , ...){}
inline void _cdecl LmTrace2(DWORD, UINT, LPCSTR , ...){}
#ifndef OLE2ANSI
inline void _cdecl LmTrace(LPCWSTR , ...){}
inline void _cdecl LmTrace2(DWORD, UINT, LPCWSTR , ...){}
#endif //OLE2ANSI
#ifndef LMTRACE
#define LMTRACE            1 ? (void)0 : LmTrace
#define LMTRACE2			1 ? (void)0 : LmTrace2
#endif //LMTRACE
#define LMTRACENOTIMPL(funcname)   return E_NOTIMPL
#endif //_DEBUG

#endif //_LM_TRACE_INC_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\lm\lmbehav\include\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by behavior.rc
//
#define IDS_PROJNAME                    100
#define IDR_JUMPBEHAVIOR                101
#define IDR_LMBEHAVIORFACTORY           102
#define IDR_PULSATEBEHAVIOR             103
#define IDR_COLORCYCLEBEHAVIOR          104

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        201
#define _APS_NEXT_COMMAND_VALUE         32768
#define _APS_NEXT_CONTROL_VALUE         201
#define _APS_NEXT_SYMED_VALUE           105
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\lm\lmbehav\dll\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//  stdafx.pch will be the pre-compiled header
//  stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

#ifdef _ATL_STATIC_REGISTRY
#include <statreg.h>
#include <statreg.cpp>
#endif

#include <atlimpl.cpp>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\lm\lmbehav\include\stdafx.h ===
// stdafx.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently

#if !defined(AFX_STDAFX_H__43AAC678_387C_11D2_BB7D_00A0C999C4C1__INCLUDED_)
#define AFX_STDAFX_H__43AAC678_387C_11D2_BB7D_00A0C999C4C1__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#define _WIN32_WINNT 0x0400

#define _ATL_APARTMENT_THREADED

#include <atlbase.h>
//You may derive a class from CComModule and use it if you want to override
//something, but do not change the name of _Module
extern CComModule _Module;
#include <atlcom.h>
#include <atlctl.h>

#include <mshtml.h>

#import "d:/nt/private/danim/libd/i386/danim.dll" \
  exclude( "_RemotableHandle", "IMoniker", "IPersist", "ISequentialStream", \
  "IParseDisplayName", "IOleClientSite", "_FILETIME", "tagSTATSTG" ) \
  named_guids \
  rename( "GUID", "DAGUID" ) \
  rename_namespace( "DAnim" )

using namespace DAnim;

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__43AAC678_387C_11D2_BB7D_00A0C999C4C1__INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\lm\lmbehav\dll\behavior.cpp ===
// behavior.cpp : Implementation of DLL Exports.


// Note: Proxy/Stub Information
//		To build a separate proxy/stub DLL, 
//		run nmake -f behaviorps.mk in the project directory.

#include "stdafx.h"
#include "resource.h"
#include "initguid.h"
#include "behavior.h"

#include "src\jump.h"
#include "src\factory.h"
#include "src\pulsate.h"
#include "src\colcycle.h"


CComModule _Module;

BEGIN_OBJECT_MAP(ObjectMap)
	OBJECT_ENTRY(CLSID_JumpBehavior, CJumpBehavior)
	OBJECT_ENTRY(CLSID_LMBehaviorFactory, CLMBehaviorFactory)
	OBJECT_ENTRY(CLSID_PulsateBehavior, CPulsateBehavior)
	OBJECT_ENTRY(CLSID_ColorCycleBehavior, CColorCycleBehavior)
END_OBJECT_MAP()

/////////////////////////////////////////////////////////////////////////////
// DLL Entry Point

extern "C"
BOOL WINAPI DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID /*lpReserved*/)
{
	if (dwReason == DLL_PROCESS_ATTACH)
	{
		_Module.Init(ObjectMap, hInstance);
		DisableThreadLibraryCalls(hInstance);
	}
	else if (dwReason == DLL_PROCESS_DETACH)
		_Module.Term();
	return TRUE;    // ok
}

/////////////////////////////////////////////////////////////////////////////
// Used to determine whether the DLL can be unloaded by OLE

STDAPI DllCanUnloadNow(void)
{
	return (_Module.GetLockCount()==0) ? S_OK : S_FALSE;
}

/////////////////////////////////////////////////////////////////////////////
// Returns a class factory to create an object of the requested type

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
	return _Module.GetClassObject(rclsid, riid, ppv);
}

/////////////////////////////////////////////////////////////////////////////
// DllRegisterServer - Adds entries to the system registry

STDAPI DllRegisterServer(void)
{
	// registers object, typelib and all interfaces in typelib
	return _Module.RegisterServer(TRUE);
}

/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Removes entries from the system registry

STDAPI DllUnregisterServer(void)
{
	_Module.UnregisterServer();
	return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\lm\lmbehav\rsrc\makefile.inc ===
behavior.rc : $(TARGETPATH)\$(TARGET_DIRECTORY)\lmbehav.tlb
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\lm\lmbehav\src\colcycle.cpp ===
// ColorCycleBehavior.cpp : Implementation of CColorCycleBehavior
#include "stdafx.h"
#include <limits.h>

#include "Behavior.h"
#include "ColCycle.h"

const WCHAR *	CColorCycleBehavior::RGSZ_DIRECTIONS[ NUM_DIRS ]	=
{
	L"clockwise",
	L"cclockwise",
	L"noHue"
};

/////////////////////////////////////////////////////////////////////////////
// CColorCycleBehavior

CColorCycleBehavior::CColorCycleBehavior() :
	m_bstrProperty( L"style.color" )
{
	m_direction			= DIR_CLOCKWISE;
}

HRESULT CColorCycleBehavior::BuildDABehaviors()
{
	HRESULT	hr		= S_OK;

	// Set up the DA tree.
	//----------------------------------------------------------------------
	IDAStaticsPtr	e;

	e.CreateInstance( L"DirectAnimation.DAStatics" );

	// Set up time
	//----------------------------------------------------------------------
	float 			fDuration	= 0.0;
	if ( FAILED( GetDur( &fDuration ) ) )
		return E_FAIL;

	IDANumberPtr	timePtr	= GetTimeNumberBvr();
	if ( timePtr == NULL )
		return E_FAIL;

	// Interpolate between the 2 colors in HSL space.
	//----------------------------------------------------------------------
	float h1, l1, s1;
	float h2, l2, s2;

	h1 = m_colorFrom.GetH();
	s1 = m_colorFrom.GetS();
	l1 = m_colorFrom.GetL();
	
	h2 = m_colorTo.GetH();
	s2 = m_colorTo.GetS();
	l2 = m_colorTo.GetL();

	// Hue is a circle, so adding or subtracting 1 gives the same hue, but
	// will cause a change in direction from initial hue to final hue.
	if ( ( h2 <= h1 ) && ( m_direction == DIR_CLOCKWISE ) )
	{
		h2 += 1.0;
	}
	else if ( ( h2 >= h1 ) && ( m_direction == DIR_CCLOCKWISE ) )
	{
		h2 -= 1.0;
	}

	IDANumberPtr	tNorm	= e->Div( timePtr, e->DANumber( fDuration ) );
	IDANumberPtr	hueNum1 = e->DANumber( h1 );
	IDANumberPtr	hueNum	= e->Add( hueNum1, e->Mul( tNorm, e->Sub( e->DANumber(h2), hueNum1 ) ) );
	
	IDANumberPtr	satNum1	= e->DANumber( s1 );
	IDANumberPtr	satNum	= e->Add( satNum1, e->Mul( tNorm, e->Sub( e->DANumber(s2), satNum1 ) ) );

	IDANumberPtr	lumNum1	= e->DANumber( l1 );
	IDANumberPtr	lumNum	= e->Add( lumNum1, e->Mul( tNorm, e->Sub( e->DANumber(l2), lumNum1 ) ) );
	
	IDAColorPtr		color	= e->ColorHslAnim( hueNum, satNum, lumNum );

	// Convert HSL into a long value representing the corresponding RGB.
	//----------------------------------------------------------------------
	IDANumberPtr	rgbNum;

	rgbNum = e->Add( e->Add( e->Mul( e->Round( e->Mul( color->Red, e->DANumber( UCHAR_MAX ) ) ), 
									 e->DANumber( UCHAR_MAX * UCHAR_MAX ) ),
							 e->Mul( e->Round( e->Mul( color->Green, e->DANumber( UCHAR_MAX ) ) ),
									 e->DANumber( UCHAR_MAX ) ) ),
					 e->Round( e->Mul( color->Blue, e->DANumber( UCHAR_MAX ) ) ) );

	// Animate the specified property.
	//----------------------------------------------------------------------
	CComBSTR cbstrID;
	CComBSTR sProp;

	hr = GetParentID( &cbstrID );
	if ( FAILED(hr) ) return hr;
	
	if ( cbstrID != NULL )
		sProp = cbstrID;

	sProp += ".";
	sProp += m_bstrProperty;

	rgbNum = e->Cond( e->GT( timePtr, e->DANumber( -1 ) ),
					  rgbNum,
					  e->DANumber( m_colorFrom.ToRGBDWORD() ) );
	
	IDANumberPtr animNum = rgbNum->AnimateProperty( _bstr_t(sProp), "JScript", VARIANT_FALSE, 0.02 );

	// Add to the behaviors to run
	//----------------------------------------------------------------------
	if ( m_vwrControlPtr != NULL )
		hr = m_vwrControlPtr->AddBehaviorToRun( animNum );
	
// 	LONG	lCookie;
	
// 	hr = AddBehavior( animNum, &lCookie );
// 	if ( FAILED(hr) ) return hr;

// 	hr = TurnOn();
// 	if ( FAILED(hr) ) return hr;

	return hr;
}

//////////////////////////////////////////////////////////////////////////////////////////////////////////////

STDMETHODIMP CColorCycleBehavior::Notify(LONG dwNotify, VARIANT * pVar)
{
	HRESULT hr = CBaseBehavior::Notify( dwNotify, pVar );

	if ( dwNotify == BEHAVIOREVENT_DOCUMENTREADY )
	{
// 		AddTimeBehavior();
		BuildDABehaviors();
	}
	
	return hr;
}


STDMETHODIMP CColorCycleBehavior::get_from(BSTR * out_pbstr)
{
	return m_colorFrom.ToString( out_pbstr );
}

STDMETHODIMP CColorCycleBehavior::put_from(BSTR in_bstr)
{
	return m_colorFrom.Parse( in_bstr );
}

STDMETHODIMP CColorCycleBehavior::get_to(BSTR * out_pbstr)
{
	return m_colorTo.ToString( out_pbstr );
}

STDMETHODIMP CColorCycleBehavior::put_to(BSTR in_bstr)
{
	return m_colorTo.Parse( in_bstr );
}

STDMETHODIMP CColorCycleBehavior::get_property(BSTR *out_pbstr)
{
	if ( out_pbstr == NULL )
		return E_POINTER;
	
	*out_pbstr = m_bstrProperty.Copy();
	
	return S_OK;
}

STDMETHODIMP CColorCycleBehavior::put_property(BSTR in_bstr)
{
	m_bstrProperty = in_bstr;

	return S_OK;
}

STDMETHODIMP CColorCycleBehavior::get_direction(BSTR * pbstrDir)
{
	if ( pbstrDir == NULL ) return E_INVALIDARG;
	
	*pbstrDir = ::SysAllocString( RGSZ_DIRECTIONS[ m_direction ] );

	return S_OK;
}

STDMETHODIMP CColorCycleBehavior::put_direction(BSTR bstrDir)
{
	HRESULT	hr = E_INVALIDARG;
	
	for ( int i = 0; i < NUM_DIRS; i++ )
	{
		if ( _wcsicmp( bstrDir, RGSZ_DIRECTIONS[ i ] ) == 0 )
		{
			m_direction	= (DirectionType) i;
			hr			= S_OK;
			break;
		}
	}

	return hr;
}

STDMETHODIMP CColorCycleBehavior::get_on(VARIANT * pVal)
{
	if( pVal == NULL )
		return E_INVALIDARG;

	V_VT(pVal)  = VT_BOOL;
	V_BOOL(pVal)= m_on ? VARIANT_TRUE : VARIANT_FALSE;

	return S_OK;
}

STDMETHODIMP CColorCycleBehavior::put_on(VARIANT newVal)
{
	VariantChangeType( &newVal, &newVal, 0, VT_BOOL );
	
	m_on = V_BOOL(&newVal) == VARIANT_TRUE ? true : false;
	
	HandleOnChange( m_on );

	return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\lm\lmbehav\src\colcycle.h ===
// ColorCycleBehavior.h : Declaration of the CColorCycleBehavior

#ifndef __COLORCYCLEBEHAVIOR_H_
#define __COLORCYCLEBEHAVIOR_H_

#include "resource.h"       // main symbols
#include "base.h"
#include "color.h"

/////////////////////////////////////////////////////////////////////////////
// CColorCycleBehavior
class ATL_NO_VTABLE CColorCycleBehavior :
	public CBaseBehavior,
	public CComCoClass<CColorCycleBehavior, &CLSID_ColorCycleBehavior>,
	public IDispatchImpl<IColorCycleBehavior, &IID_IColorCycleBehavior, &LIBID_BEHAVIORLib>
{
public:
	CColorCycleBehavior();

    // IElementBehavior
    //
	STDMETHOD(Notify)(LONG event, VARIANT * pVar);

DECLARE_REGISTRY_RESOURCEID(IDR_COLORCYCLEBEHAVIOR)

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CColorCycleBehavior)
	COM_INTERFACE_ENTRY(IColorCycleBehavior)
	COM_INTERFACE_ENTRY(IDispatch)
    COM_INTERFACE_ENTRY_CHAIN(CBaseBehavior)
END_COM_MAP()

    // Needed by CBaseBehavior
    void * 	GetInstance() { return (IColorCycleBehavior *) this ; }
	
    HRESULT GetTypeInfo(ITypeInfo ** ppInfo)
    { return GetTI(GetUserDefaultLCID(), ppInfo); }
	
// IColorCycleBehavior
public:
	STDMETHOD(get_on)(/*[out, retval]*/ VARIANT *pVal);
	STDMETHOD(put_on)(/*[in]*/ VARIANT newVal);
	STDMETHOD(get_direction)(/*[out, retval]*/ BSTR *pVal);
	STDMETHOD(put_direction)(/*[in]*/ BSTR newVal);
	STDMETHOD(get_property)(/*[out, retval]*/ BSTR *pVal);
	STDMETHOD(put_property)(/*[in]*/ BSTR newVal);
	STDMETHOD(get_to)(/*[out, retval]*/ BSTR *pVal);
	STDMETHOD(put_to)(/*[in]*/ BSTR newVal);
	STDMETHOD(get_from)(/*[out, retval]*/ BSTR *pVal);
	STDMETHOD(put_from)(/*[in]*/ BSTR newVal);
	
protected:	
	enum DirectionType {
		DIR_CLOCKWISE,
		DIR_CCLOCKWISE,
		DIR_NOHUE,
		NUM_DIRS
	};

	static const WCHAR *	RGSZ_DIRECTIONS[ NUM_DIRS ];
	
protected:
	HRESULT			BuildDABehaviors();
	
protected:
	CColor					m_colorFrom;
	CColor					m_colorTo;

	CComBSTR				m_bstrProperty;
	DirectionType			m_direction;
};

#endif //__COLORCYCLEBEHAVIOR_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\lm\lmbehav\src\color.h ===
#ifndef __COLOR_H__
#define __COLOR_H__

#include <limits.h>

class CColor
{
public:
	CColor();

	float	GetR() { return m_r / ((float) UCHAR_MAX ); }
	float	GetG() { return m_g / ((float) UCHAR_MAX ); }
	float	GetB() { return m_b / ((float) UCHAR_MAX ); }

	float	GetH() { return m_h; }
	float	GetS() { return m_s; }
	float 	GetL() { return m_l; }
	
	HRESULT	Parse( BSTR in_bstr );
	HRESULT	ToString( BSTR * out_pbstr );
	ULONG	ToRGBDWORD();
	HRESULT	RGBToHSL( float r, float g, float b, float& h, float& s, float &l );

public:
	static const WCHAR PREFIX_COLOR;
	static const float HUE_UNDEFINED;

private:
	unsigned char	m_r;
	unsigned char	m_g;
	unsigned char	m_b;

	float	m_h;
	float 	m_s;
	float	m_l;
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\lm\lmbehav\src\color.cpp ===
#include "stdafx.h"
#include "color.h"

const WCHAR 	CColor::PREFIX_COLOR					= '#';
const float 	CColor::HUE_UNDEFINED					= 0.0f;

CColor::CColor() :
	m_r( 0 ),
	m_g( 0 ),
	m_b( 0 ),
	m_h( 0.0f ),
	m_s( 0.0f ),
	m_l( 0.0f )
{
}

HRESULT CColor::Parse( BSTR in_bstr )
{
	if ( in_bstr == NULL )
		return E_POINTER;

	// TODO: Support named colors
	UINT cChars = ::SysStringLen( in_bstr );
	if ( ( cChars < 7 ) || ( in_bstr[0] != PREFIX_COLOR ) )
		return E_INVALIDARG;

	--cChars;

	WCHAR	*pStart = in_bstr + 1;
	WCHAR 	*pEnd;
	ULONG 	ulColor = wcstoul( pStart, &pEnd, 16 );
	
	if ( pEnd != pStart + cChars )
		return E_INVALIDARG;

	m_r = LOBYTE( HIWORD( ulColor ) );
	m_g = HIBYTE( LOWORD( ulColor ) );
	m_b = LOBYTE( LOWORD( ulColor ) );

	RGBToHSL( GetR(), GetG(), GetB(), m_h, m_s, m_l );
	
	return S_OK;
}

HRESULT CColor::ToString( BSTR * out_pbstr )
{
	if ( out_pbstr == NULL )
		return E_POINTER;
	
	WCHAR			wszColor[33];
	WCHAR			wszBuffer[34];
	unsigned long	ulColor = ToRGBDWORD();

	_ultow( ulColor, wszColor, 16 );
	swprintf( wszBuffer, L"#%s", wszColor );
	*out_pbstr = ::SysAllocString( wszBuffer );

	return S_OK;
}

ULONG CColor::ToRGBDWORD()
{
	unsigned long	ulColor = MAKELONG( MAKEWORD( m_b, m_g ), MAKEWORD( m_r, 0 ) );
	return ulColor;
}

HRESULT CColor::RGBToHSL( float r, float g, float b, float& h, float& s, float& l )
{
#define MIN( a, b ) ( (a) < (b) ? (a) : (b) )
#define MAX( a, b ) ( (a) > (b) ? (a) : (b) )
	
	HRESULT	hr = S_OK;
	
	float fMax = MAX(MAX(r, g), b);
	float fMin = MIN(MIN(r, g), b);

	l = (fMax + fMin) / 2;

	if( fMax == fMin )
	{
		s = 0.0f;
		h = HUE_UNDEFINED;
		hr = S_FALSE;
	}
	else
	{
		if( l < 0.5 )
			s = (fMax-fMin)/(fMax+fMin);
		else
			s = (fMax-fMin)/(2-fMax-fMin);

		float delta = fMax-fMin;

		if( r == fMax )
			h = (g-b)/delta;

		else if ( g == fMax )
			h = 2 + (b-r)/delta;

		else // if (b == fMax )
			h = 4 + (b-r)/delta;

		h = h / 6.0f; // Convert Ensure it's in [0...1]

		if( h < 1 )
			h = h + 1;
	}

	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\lm\lmbehav\src\base.cpp ===
/****************************************
*
* CBaseBehavior
*
*  A base class for LM behaviors
* 
****************************************/

#include "stdafx.h"

#include "behavior.h"

#include "base.h"

enum{
		DISP_ADDDABEHAVIOR,
		DISP_REMOVEDABEHAVIOR,
		DISP_TURNON,
		DISP_TURNOFF,
		DISP_DUR,
		DISP_REPEATCOUNT,
		DISP_REPEATDUR,
		NUM_TIME_DISPIDS
	};
const WCHAR * CBaseBehavior::rgszNames[] = {
		L"AddBehavior",
		L"RemoveBehavior",
		L"TurnOn",
		L"TurnOff",
		L"Dur",
		L"RepeatCount",
		L"RepeatDur"
	};

CComPtr<IElementBehaviorFactory> CBaseBehavior::m_timeBehaviorFactoryPtr;

bool CBaseBehavior::m_bDAStarted = false;

CBaseBehavior::CBaseBehavior()
{
	m_pBehaviorSite = NULL;

	m_rgTimeDispids = new DISPID[ NUM_TIME_DISPIDS ];
}

CBaseBehavior::~CBaseBehavior()
{
	if ( m_pBehaviorSite != NULL )
		m_pBehaviorSite->Release();
	if( m_rgTimeDispids != NULL )
		delete[] m_rgTimeDispids;
}

STDMETHODIMP CBaseBehavior::Init( IElementBehaviorSite *pSite )
{
	if( pSite == NULL )
		return E_INVALIDARG;

	HRESULT hr = S_OK;

	CComPtr<ITypeInfo> pTypeInfo;
	CComPtr<IHTMLElement> pElem;

	m_pBehaviorSite = pSite;
	pSite->AddRef();

	if( FAILED( hr = m_pBehaviorSite->GetElement( &pElem ) ) ||
		FAILED( hr = GetTypeInfo( &pTypeInfo ) ) )
		return hr;

	InitProps( GetInstance(), pTypeInfo, pElem );

	return hr;
}

STDMETHODIMP CBaseBehavior::Notify( LONG dwNotify, VARIANT *pVar )
{
	if ( dwNotify == BEHAVIOREVENT_DOCUMENTREADY )
	{
		CacheTimeDispids();
		CacheDAControl();
	}
	
	return S_OK;
}

STDMETHODIMP CBaseBehavior::Detach()
{
	return S_OK;
}

STDMETHODIMP CBaseBehavior::InitProps(void* pInstance, ITypeInfo *pTypeInfo, IHTMLElement *pElement)
{
	HRESULT hr;
    
    if( pInstance == NULL )
		return E_INVALIDARG;
	if( pTypeInfo == NULL )
		return E_INVALIDARG;
	if( pElement == NULL )
		return E_INVALIDARG;

    int cFuncs;
    
    {
        LPTYPEATTR pTypeAttr;
        
        hr = pTypeInfo->GetTypeAttr(&pTypeAttr);
        
        if (FAILED(hr))
        {
            goto done;
        }

        cFuncs = pTypeAttr->cFuncs;

        pTypeInfo->ReleaseTypeAttr(pTypeAttr);
    }
    
    int i;
    
    for (i = 0; i < cFuncs; i++)
    {
        LPFUNCDESC pFuncDesc;

        hr = pTypeInfo->GetFuncDesc(i, &pFuncDesc) ;
        
        if (FAILED(hr))
        {
            goto done;
        }

        if (pFuncDesc->invkind == INVOKE_PROPERTYPUT)
        {
            hr = UpdateProp(pInstance, pTypeInfo, pElement, pFuncDesc);
        }

        pTypeInfo->ReleaseFuncDesc(pFuncDesc);

        if (FAILED(hr))
        {
            goto done;
        }
    }

  done:
    return hr;
}

STDMETHODIMP CBaseBehavior::UpdateProp(void* pInstance, ITypeInfo *pTypeInfo, IHTMLElement *pElement, LPFUNCDESC pFuncDesc )
{
	HRESULT hr;
    
    CComVariant attribute;
    BSTR rgbstrNames[1] ;
    UINT cNames ;
    
    hr = pTypeInfo->GetNames(pFuncDesc->memid, rgbstrNames, 1, &cNames);
    
    if (FAILED(hr))
    {
        goto done;
    }
    
    // This should not happen but let's be safe and check
    if (cNames < 1)
    {
        hr = S_OK;
        goto done;
    }
    
    hr = pElement->getAttribute( rgbstrNames[0] , 0, &attribute );
    
    // For some reason if the property is not set it will still return
    // success but return a VT_NULL.  We want to ignore these.
    
    if (SUCCEEDED(hr) && V_VT(&attribute) != VT_NULL)
    {
        UINT* puArgErr = 0;
        DISPID propPutDispid = DISPID_PROPERTYPUT;
        DISPPARAMS dispparams;
        
        dispparams.rgvarg = &attribute;
        dispparams.rgdispidNamedArgs = &propPutDispid;
        dispparams.cArgs = 1;
        dispparams.cNamedArgs = 1;
        
        pTypeInfo->Invoke(pInstance,
                        pFuncDesc->memid,
                        DISPATCH_PROPERTYPUT,
                        &dispparams,
                        NULL,
                        NULL,
                        puArgErr);
    }
    
    SysFreeString(rgbstrNames[0]) ;

    hr = S_OK;
    
  done:
    return hr;
}

HRESULT CBaseBehavior::CacheTimeDispids()
{
	if ( m_pBehaviorSite == NULL ) return E_FAIL;

	CComPtr<IHTMLElement>	pElement;
	HRESULT					hr								= S_OK;
	
	hr = m_pBehaviorSite->GetElement( &pElement );
	if ( FAILED(hr) ) return hr;
	
	HRESULT	hrRet = S_OK;

	// Get the ID of each member of TIME that we're interested in.
	//----------------------------------------------------------------------
	//TODO: hack this to get the DA control off the page for the time being...
	CComQIPtr<IDispatch, &IID_IDispatch> pDispatch( pElement );
	if ( pDispatch == NULL ) return E_FAIL;

	for ( int i = 0; i < NUM_TIME_DISPIDS; i++ )
	{
		hr = pDispatch->GetIDsOfNames( IID_NULL,
									   const_cast<WCHAR**>( &rgszNames[i]),
									   1,
									   LOCALE_SYSTEM_DEFAULT,
									   &m_rgTimeDispids[i] );
		if ( FAILED(hr) ) hrRet = hr;;
	}
	
	return hrRet;
}

// REVIEW: This function may not be needed.
//----------------------------------------------------------------------

HRESULT CBaseBehavior::AddTimeBehavior()
{
	if ( m_pBehaviorSite == NULL ) return E_FAIL;

	HRESULT					hr = S_OK;

	// Cache pointer to time behavior factory if we don't have it
	//----------------------------------------------------------------------
	if ( m_timeBehaviorFactoryPtr == NULL )
	{
		hr = m_timeBehaviorFactoryPtr.CoCreateInstance( CLSID_LMBehaviorFactory, NULL );
		if ( FAILED(hr) ) return hr;
	}
	
	// Add behavior to our element
	//----------------------------------------------------------------------
	CComQIPtr<IUnknown, &IID_IUnknown> punkFactory( m_timeBehaviorFactoryPtr );
	CComPtr<IHTMLElement>	pElement;
 	
	hr = m_pBehaviorSite->GetElement( &pElement );
	if ( FAILED(hr) ) return hr;

	CComQIPtr<IHTMLElement2, &IID_IHTMLElement2> pElement2( pElement );
	if ( pElement2 == NULL ) return E_FAIL;

	CComVariant		varFactory( punkFactory );
	LONG			lCookie;
	
	hr = pElement2->addBehavior( CComBSTR( L"#TIMEFactory#Jump" ),
								 &varFactory,
								 &lCookie );

	return hr;
}

HRESULT CBaseBehavior::CacheDAControl()
{
	if ( m_pBehaviorSite == NULL ) return E_FAIL;

	// Get pointer to DA control
	CComPtr<IHTMLElement>	pElement;
	
	HRESULT hr = m_pBehaviorSite->GetElement( &pElement );
	if ( FAILED(hr) ) return hr;
	
	CComPtr<IDispatch>	pDispDoc;
	pElement->get_document( &pDispDoc );
	CComQIPtr<IHTMLDocument2, &IID_IHTMLDocument2> pDoc( pDispDoc );

	CComPtr<IHTMLElementCollection> pColl;
	pDoc->get_all( &pColl );

	CComVariant	varName( L"DAControl" );
	CComVariant varIndex( 0L );
	CComPtr<IDispatch> pDispElm;
	hr = pColl->item( varName, varIndex, &pDispElm );
	if ( FAILED(hr) ) return hr;
	if ( pDispElm == NULL ) return E_FAIL;

	CComQIPtr<IHTMLObjectElement, &IID_IHTMLObjectElement> pObjElt( pDispElm );
	if ( pObjElt == NULL ) return E_FAIL;

	CComPtr<IDispatch> pDispObjElt;
	pObjElt->get_object( &pDispObjElt );

	hr = pDispObjElt->QueryInterface( IID_IDAViewerControl, (LPVOID *) &m_vwrControlPtr );
	//if( !m_bDAStarted )
	//{
		m_bDAStarted = true;
		m_vwrControlPtr->raw_Start();
	//}
	/*
	else
	{
		CComPtr<IDAView> pView;
		CComPtr<IDAImage> pImage;
		CComPtr<IDASound> pSound;

		hr = m_vwrControlPtr->get_View( &pView );
		if( FAILED( hr ) )
			return hr;

		hr = m_vwrControlPtr->get_Image( &pImage );
		if( FAILED( hr ) )
			return hr;

		hr = m_vwrControlPtr->get_Sound( &pSound );
		if( FAILED( hr ) )
			return hr;

		double simTime;
		pView->get_SimulationTime( &simTime );
		pView->StopModel();

		pView->StartModel( pImage, pSound, simTime );

	}
	*/
	
	return hr;
}

HRESULT CBaseBehavior::AddBehavior( IDABehavior * in_pBehavior, long * out_pCookie )
{
	if ( m_pBehaviorSite == NULL ) return E_FAIL;

	CComPtr<IHTMLElement>	pElement;
	
	HRESULT hr = m_pBehaviorSite->GetElement( &pElement );
	if ( FAILED(hr) ) return hr;
	
	CComQIPtr<IDispatch, &IID_IDispatch> pDispatch( pElement );
	if ( pDispatch == NULL ) return E_FAIL;

	DISPPARAMS		params;
	CComVariant		varBehavior( in_pBehavior );
	CComVariant		varResult;
	EXCEPINFO		excepInfo;
	VARIANTARG		rgVarArgs[2];
	UINT			nArgErr;

	params.rgvarg				= &varBehavior;
	params.rgdispidNamedArgs	= NULL;
	params.cArgs				= 1;
	params.cNamedArgs			= 0;
	
	hr = pDispatch->Invoke( m_rgTimeDispids[ DISP_ADDDABEHAVIOR ],
							IID_NULL,
							LOCALE_USER_DEFAULT,
							DISPATCH_METHOD,
							&params,
							&varResult,
							&excepInfo,
							&nArgErr );

	if ( out_pCookie )
		*out_pCookie = V_I4( &varResult );
	
	return hr;
}

HRESULT CBaseBehavior::TurnOn()
{
	if ( m_pBehaviorSite == NULL ) return E_FAIL;

	CComPtr<IHTMLElement>	pElement;
	
	HRESULT hr = m_pBehaviorSite->GetElement( &pElement );
	if ( FAILED(hr) ) return hr;
	
	CComQIPtr<IDispatch, &IID_IDispatch> pDispatch( pElement );
	if ( pDispatch == NULL ) return E_FAIL;

	DISPPARAMS		paramsNoArgs = { NULL, NULL, 0, 0 };
	CComVariant		varResult;
	EXCEPINFO		excepInfo;
	VARIANTARG		rgVarArgs[2];
	UINT			nArgErr;

	hr = pDispatch->Invoke( m_rgTimeDispids[ DISP_TURNON ],
							IID_NULL,
							LOCALE_USER_DEFAULT,
							DISPATCH_METHOD,
							&paramsNoArgs,
							&varResult,
							&excepInfo,
							&nArgErr );
	
	return hr;
}

/**
*
*  Get the IDispatch pointer on the element.  For now we are not
*  supposed to cache pointers to the element, so we have to query
*  every time.
*
*/
HRESULT
CBaseBehavior::GetElementIDispatch( IDispatch **out_pDispatch )
{
	if( out_pDispatch == NULL )
		return E_INVALIDARG;

	if( m_pBehaviorSite == NULL )
		return E_FAIL;

	CComPtr<IHTMLElement> pElement;

	if( FAILED( m_pBehaviorSite->GetElement( &pElement ) ) )
		return E_FAIL;

	if( FAILED( pElement->QueryInterface( IID_IDispatch, (void**)out_pDispatch ) ) )
		return E_FAIL;

	return S_OK;
}

HRESULT 
CBaseBehavior::GetDur( float *out_pDur )
{
	if( out_pDur == NULL )
		return E_INVALIDARG;

	CComPtr<IDispatch> pDispatch;

	if( FAILED( GetElementIDispatch( &pDispatch ) ) )
		return E_FAIL;

	CComVariant varResult;

	m_DispatchDriver.GetProperty( pDispatch,  
								   m_rgTimeDispids[DISP_DUR], 
								   &varResult );

	varResult.ChangeType( VT_R4 );
	
	(*out_pDur) = V_R4( &varResult );

	return S_OK;
}

HRESULT 
CBaseBehavior::GetRepeatCount( float *out_pRepeatCount )
{
	if( out_pRepeatCount == NULL )
		return E_INVALIDARG;

	CComPtr<IDispatch> pDispatch;

	if( FAILED( GetElementIDispatch( &pDispatch ) ) )
		return E_FAIL;

	CComVariant varResult;

	m_DispatchDriver.GetProperty( pDispatch,  
								   m_rgTimeDispids[DISP_REPEATCOUNT], 
								   &varResult );

	varResult.ChangeType( VT_R4 );
	
	(*out_pRepeatCount) = V_R4( &varResult );

	return S_OK;
}

HRESULT 
CBaseBehavior::GetRepeatDur( float *out_pRepeatDur )
{
	if( out_pRepeatDur == NULL )
		return E_INVALIDARG;

	CComPtr<IDispatch> pDispatch;

	if( FAILED( GetElementIDispatch( &pDispatch ) ) )
		return E_FAIL;

	CComVariant varResult;

	m_DispatchDriver.GetProperty( pDispatch,  
								   m_rgTimeDispids[DISP_REPEATDUR], 
								   &varResult );

	varResult.ChangeType( VT_R4 );
	
	(*out_pRepeatDur) = V_R4( &varResult );
	return S_OK;
}

HRESULT
CBaseBehavior::GetParentElement( IHTMLElement** out_ppParentElement )
{
	if( out_ppParentElement == NULL )
		return E_INVALIDARG;
	if( m_pBehaviorSite == NULL )
		return E_FAIL;

	HRESULT hr = S_OK;

	// Get parent element
	//----------------------------------------------------------------------
	CComPtr<IHTMLElement>	pElement;
	IHTMLElement*	pParentElt;
	
	CComBSTR name;
	CComBSTR className;

	m_pBehaviorSite->GetElement( &pElement );
	pElement->get_parentElement( &pParentElt );

	//work our way up to a parent that is not an LM:ACTION
	if( pParentElt != NULL )
	{
		pParentElt->get_tagName( &name );
		pParentElt->get_className( &className );
	}

	IHTMLElement *pOldParent;

	while( pParentElt != NULL && 
		   ( (name != NULL && _wcsicmp( L"action", name )  == 0 ) || 
			 (className != NULL && _wcsicmp( L"action", className ) == 0 ) ) 
		 )
	{
		pOldParent = pParentElt;
		pOldParent->get_parentElement( &pParentElt );
		pOldParent->Release();

		if( pParentElt != NULL )
		{
			pParentElt->get_tagName( &name );
			pParentElt->get_className( &className );
		}
	}

	(*out_ppParentElement) = pParentElt;

	return S_OK;
}
	
HRESULT 
CBaseBehavior::GetParentID( BSTR *out_ppParentID )
{
	HRESULT hr = S_OK;

	CComPtr<IHTMLElement> pParentElt;

	GetParentElement( &pParentElt );

	if ( pParentElt != NULL )
	{
		pParentElt->get_id( out_ppParentID );

		// REVIEW: Get unique id if no ID was specified.
		//------------------------------------------------------------------
		if ( (*out_ppParentID) == NULL || SysStringLen( (*out_ppParentID) ) == 0 )
		{
			CComQIPtr<IHTMLUniqueName, &IID_IHTMLUniqueName> pUnique( pParentElt );
			if ( pUnique != NULL )
			{
				pUnique->get_uniqueID( out_ppParentID );
			}
		}
	}

	return hr;
}


IDANumberPtr 
CBaseBehavior::GetTimeNumberBvr()
{
	if( m_time != NULL )
	{
		return m_time;
	}

	CComPtr<IDispatch> pDispatch;

	if( FAILED( GetElementIDispatch( &pDispatch ) ) )
		return NULL;

	CComVariant varResult;

	m_DispatchDriver.GetProperty( pDispatch,  
								   m_rgTimeDispids[DISP_DUR], 
								   &varResult );

	varResult.ChangeType( VT_R4 );
	
	float duration = V_R4( &varResult);

	IDAStaticsPtr	s;
	s.CreateInstance( L"DirectAnimation.DAStatics" );

	IDANumberPtr baseTime = s->GlobalTime;

	m_startEvent = s->AppTriggeredEvent();

	IDANumberPtr startTime = s->UntilEx( s->DANumber( 0 ), m_startEvent->Snapshot( baseTime ) );
	startTime = startTime->RunOnce();

	if ( m_vwrControlPtr != NULL )
		m_vwrControlPtr->AddBehaviorToRun( startTime );

	//LONG lCookie;
	//AddBehavior( startTime, &lCookie );


	baseTime = s->Until( s->DANumber( -1 ), m_startEvent, s->Sub( baseTime, startTime ) );
	baseTime = baseTime->RunOnce();

	IDANumberPtr durationBvr = s->DANumber( duration );
	IDANumberPtr time = s->Cond( s->LT( baseTime, durationBvr ), 
								 baseTime,
								 durationBvr  
							   );

	//time = time->RunOnce();

	m_time = time;

	return time;
}

void CBaseBehavior::HandleOnChange( bool on )
{
	IDAStaticsPtr	s;
	s.CreateInstance( L"DirectAnimation.DAStatics" );

	if( on )
		s->TriggerEvent(m_startEvent, s->DATrue );
}

STDMETHODIMP CBaseBehavior::GetInterfaceSafetyOptions(REFIID riid, DWORD *pdwSupportedOptions, DWORD *pdwEnabledOptions)
{
	if (pdwSupportedOptions == NULL || pdwEnabledOptions == NULL)
		return E_POINTER;
	HRESULT hr = S_OK;

	if (riid == IID_IDispatch)
	{
		*pdwSupportedOptions = INTERFACESAFE_FOR_UNTRUSTED_CALLER;
		*pdwEnabledOptions = m_dwSafety & INTERFACESAFE_FOR_UNTRUSTED_CALLER;
	}
	else if (riid == IID_IPersistPropertyBag)
	{
		*pdwSupportedOptions = INTERFACESAFE_FOR_UNTRUSTED_DATA;
		*pdwEnabledOptions = m_dwSafety & INTERFACESAFE_FOR_UNTRUSTED_DATA;
	}
	else
	{
		*pdwSupportedOptions = 0;
		*pdwEnabledOptions = 0;
		hr = E_NOINTERFACE;
	}
	return hr;
}

STDMETHODIMP CBaseBehavior::SetInterfaceSafetyOptions(REFIID riid, DWORD dwOptionSetMask, DWORD dwEnabledOptions)
{	
	// If we're being asked to set our safe for scripting or
	// safe for initialization options then oblige
	if (riid == IID_IDispatch || riid == IID_IPersistPropertyBag  || riid == IID_IPersistStreamInit)
	{
		// Store our current safety level to return in GetInterfaceSafetyOptions
		m_dwSafety = dwEnabledOptions & dwOptionSetMask;
		return S_OK;
	}

	return E_NOINTERFACE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\lm\lmbehav\src\factory.cpp ===
// LMBehaviorFactory.cpp : Implementation of CLMBehaviorFactory
#include "stdafx.h"

#include "behavior.h"
#include "factory.h"

// Behaviors
#include "jump.h"
#include "pulsate.h"
#include "colcycle.h"
#include "move.h"

/////////////////////////////////////////////////////////////////////////////
// CLMBehaviorFactory

STDMETHODIMP CLMBehaviorFactory::FindBehavior( LPOLESTR pchBehaviorName,
											   LPOLESTR	pchBehaviorURL,
											   IUnknown * pUnkArg,
											   IElementBehavior ** ppBehavior)
{
    HRESULT     hr = E_FAIL;
 
	if ( _wcsicmp( L"Jump", pchBehaviorName ) == 0 )
	{
        CComObject<CJumpBehavior> * pJump;

        hr = CComObject<CJumpBehavior>::CreateInstance(&pJump);
        if ( FAILED(hr) ) goto Cleanup;

        hr = pJump->QueryInterface(IID_IElementBehavior, (void**)ppBehavior);
        if ( FAILED(hr) ) goto Cleanup;
	}
	else if ( _wcsicmp( L"Scale", pchBehaviorName ) == 0 )
	{
        CComObject<CPulsateBehavior> * pPulsate;

        hr = CComObject<CPulsateBehavior>::CreateInstance(&pPulsate);
        if ( FAILED(hr) ) goto Cleanup;

        hr = pPulsate->QueryInterface(IID_IElementBehavior, (void**)ppBehavior);
        if ( FAILED(hr) ) goto Cleanup;
	}
	else if ( _wcsicmp( L"Color", pchBehaviorName ) == 0 )
	{
        CComObject<CColorCycleBehavior> * pColor;

        hr = CComObject<CColorCycleBehavior>::CreateInstance(&pColor);
        if ( FAILED(hr) ) goto Cleanup;

        hr = pColor->QueryInterface(IID_IElementBehavior, (void**)ppBehavior);
        if ( FAILED(hr) ) goto Cleanup;
	}
	else if ( _wcsicmp( L"Move", pchBehaviorName ) == 0 )
	{
		CComObject<CMoveBehavior> *pMove;

		hr = CComObject<CMoveBehavior>::CreateInstance( &pMove );
		if( FAILED(hr) ) goto Cleanup;

		hr = pMove->QueryInterface( IID_IElementBehavior, (void**)ppBehavior );
		if( FAILED(hr) ) goto Cleanup;
	}
	
Cleanup:
    return hr;

}

STDMETHODIMP CLMBehaviorFactory::GetInterfaceSafetyOptions(REFIID riid, DWORD *pdwSupportedOptions, DWORD *pdwEnabledOptions)
{
	if (pdwSupportedOptions == NULL || pdwEnabledOptions == NULL)
		return E_POINTER;
	HRESULT hr = S_OK;

	if (riid == IID_IDispatch)
	{
		*pdwSupportedOptions = INTERFACESAFE_FOR_UNTRUSTED_CALLER;
		*pdwEnabledOptions = m_dwSafety & INTERFACESAFE_FOR_UNTRUSTED_CALLER;
	}
	else if (riid == IID_IPersistPropertyBag2 )
	{
		*pdwSupportedOptions = INTERFACESAFE_FOR_UNTRUSTED_DATA;
		*pdwEnabledOptions = m_dwSafety & INTERFACESAFE_FOR_UNTRUSTED_DATA;
	}
	else
	{
		*pdwSupportedOptions = 0;
		*pdwEnabledOptions = 0;
		hr = E_NOINTERFACE;
	}
	return hr;
}

STDMETHODIMP CLMBehaviorFactory::SetInterfaceSafetyOptions(REFIID riid, DWORD dwOptionSetMask, DWORD dwEnabledOptions)
{	
	// If we're being asked to set our safe for scripting or
	// safe for initialization options then oblige
	if (riid == IID_IDispatch || riid == IID_IPersistPropertyBag2 )
	{
		// Store our current safety level to return in GetInterfaceSafetyOptions
		m_dwSafety = dwEnabledOptions & dwOptionSetMask;
		return S_OK;
	}

	return E_NOINTERFACE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\lm\lmbehav\src\base.h ===
/********************************
*
* CBaseBehavior
*
*/

#ifndef __BASEBEHAVIOR_H_
#define __BASEBEHAVIOR_H_

class ATL_NO_VTABLE CBaseBehavior: 
		public CComObjectRootEx<CComSingleThreadModel>,
		public IObjectSafetyImpl<CBaseBehavior, INTERFACESAFE_FOR_UNTRUSTED_CALLER>,
		public IElementBehavior
{
public:
	CBaseBehavior();
	~CBaseBehavior();

	//Derived Classes must implement these

	//returns a pointer to the instance of IDispatch
	virtual void *GetInstance()=0;
	//
	virtual HRESULT GetTypeInfo( ITypeInfo **ppTypeInfo )=0;

	// IObjectSafetyImpl
	STDMETHOD(SetInterfaceSafetyOptions)(
							/* [in] */ REFIID riid,
							/* [in] */ DWORD dwOptionSetMask,
							/* [in] */ DWORD dwEnabledOptions);
	STDMETHOD(GetInterfaceSafetyOptions)(
							/* [in] */ REFIID riid, 
							/* [out] */DWORD *pdwSupportedOptions, 
							/* [out] */DWORD *pdwEnabledOptions);

	//IElementBehavior methods
	STDMETHOD(Init)(IElementBehaviorSite *pSite);
	STDMETHOD(Notify)(LONG event, VARIANT *pVar);
	
BEGIN_COM_MAP(CBaseBehavior)
	COM_INTERFACE_ENTRY(IObjectSafety)
	COM_INTERFACE_ENTRY(IElementBehavior)
END_COM_MAP()

protected:
	//methods
	STDMETHOD(InitProps)( void* pInstance, ITypeInfo *pTypeInfo, IHTMLElement *pElement );
	STDMETHOD(UpdateProp)( void* pInstance, ITypeInfo *pTypeInfo, IHTMLElement *pElement, LPFUNCDESC pFuncDesc );
	STDMETHOD(Detach)();

	HRESULT CacheTimeDispids();
	HRESULT	AddTimeBehavior();
	HRESULT	CacheDAControl();
	HRESULT AddBehavior( IDABehavior * in_pBehavior, long * out_pCookie );
	HRESULT	TurnOn();
	HRESULT GetDur( float *out_pDur );
	HRESULT GetRepeatCount( float *out_pRepeatCount );
	HRESULT GetRepeatDur( float *out_pRepeatDur );
	
	HRESULT GetParentElement( IHTMLElement** out_ppParentElement );
	HRESULT GetParentID( BSTR *out_ppParentID );

	HRESULT GetElementIDispatch( IDispatch **out_pDispatch );

	IDANumberPtr GetTimeNumberBvr();

	void HandleOnChange( bool on );

	
	//member vars

	static const WCHAR *rgszNames[];

	CComDispatchDriver						m_DispatchDriver;
	DISPID 									*m_rgTimeDispids;
	IElementBehaviorSite  					*m_pBehaviorSite;
	static CComPtr<IElementBehaviorFactory>	m_timeBehaviorFactoryPtr;

	// HACK
	IDAViewerControlPtr						m_vwrControlPtr;
	static bool								m_bDAStarted;
	bool m_on;

private:
	IDANumberPtr							m_time;
	IDAEventPtr								m_startEvent;

	DWORD									m_dwSafety;
};
#endif __BASEBEHAVIOR_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\lm\lmbehav\src\factory.h ===
// LMBehaviorFactory.h : Declaration of the CLMBehaviorFactory

#ifndef __LMBEHAVIORFACTORY_H_
#define __LMBEHAVIORFACTORY_H_

#include "resource.h"       // main symbols

/////////////////////////////////////////////////////////////////////////////
// CLMBehaviorFactory
class ATL_NO_VTABLE CLMBehaviorFactory : 
	public CComObjectRootEx<CComSingleThreadModel>,
	public CComCoClass<CLMBehaviorFactory, &CLSID_LMBehaviorFactory>,
	public IDispatchImpl<ILMBehaviorFactory, &IID_ILMBehaviorFactory, &LIBID_BEHAVIORLib>,
	public IObjectSafetyImpl<CLMBehaviorFactory, INTERFACESAFE_FOR_UNTRUSTED_CALLER>,
	public IElementBehaviorFactory
{
public:
	CLMBehaviorFactory()
	{
	}

	// IObjectSafetyImpl
	STDMETHOD(SetInterfaceSafetyOptions)(
							/* [in] */ REFIID riid,
							/* [in] */ DWORD dwOptionSetMask,
							/* [in] */ DWORD dwEnabledOptions);
	STDMETHOD(GetInterfaceSafetyOptions)(
							/* [in] */ REFIID riid, 
							/* [out] */DWORD *pdwSupportedOptions, 
							/* [out] */DWORD *pdwEnabledOptions);
    //
    // IElementBehaviorFactory
    //

	STDMETHOD(FindBehavior)(
        LPOLESTR pchNameSpace, LPOLESTR	pchTagName, IUnknown * pUnkArg, IElementBehavior ** ppBehavior);

	STDMETHODIMP UIDeactivate() { return S_OK; }
	
DECLARE_REGISTRY_RESOURCEID(IDR_LMBEHAVIORFACTORY)

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CLMBehaviorFactory)
	COM_INTERFACE_ENTRY(ILMBehaviorFactory)
	COM_INTERFACE_ENTRY(IObjectSafety)
	COM_INTERFACE_ENTRY(IDispatch)
	COM_INTERFACE_ENTRY(IElementBehaviorFactory)
END_COM_MAP()


private:
	DWORD m_dwSafety;

// ILMBehaviorFactory
public:
};

#endif //__LMBEHAVIORFACTORY_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\lm\lmbehav\src\point.h ===
/********************************
*
*
*********************************/

#ifndef __POINT_H_
#define __POINT_H_

#include "resource.h"

class CPoint
{
public:
	CPoint();
	~CPoint();

	double GetX(){ return m_x; }
	double GetY(){ return m_y; }
	double GetZ(){ return m_z; }

	HRESULT Parse( BSTR pString );

	HRESULT ToString( BSTR* pToString );

	IDAPoint2Ptr GetDAPoint2( IDAStaticsPtr s );

private:
	double m_x;
	double m_y;
	double m_z;

	BSTR m_pStringRep;
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\lm\lmbehav\src\move.h ===
/**********************************
*
*
*
************************************/

#ifndef __MOVEBEHAVIOR_H_
#define __MOVEBEHAVIOR_H_

#include "resource.h"

#include "behavior.h"

#include "base.h"

#include "point.h"

class ATL_NO_VTABLE CMoveBehavior: 
	public CComCoClass<CMoveBehavior, &CLSID_MoveBehavior>,
	public IDispatchImpl<IMoveBehavior, &IID_IMoveBehavior, &LIBID_BEHAVIORLib>,
	public CBaseBehavior
{
public:
	CMoveBehavior();
	~CMoveBehavior();

	DECLARE_PROTECT_FINAL_CONSTRUCT()

	BEGIN_COM_MAP(CMoveBehavior)
		COM_INTERFACE_ENTRY(IMoveBehavior)
		COM_INTERFACE_ENTRY(IDispatch)
		COM_INTERFACE_ENTRY_CHAIN(CBaseBehavior)
	END_COM_MAP()
public:
	STDMETHOD(get_on)(/*[out, retval]*/ VARIANT *pVal);
	STDMETHOD(put_on)(/*[in]*/ VARIANT newVal);
	//IElementBehavior
	STDMETHOD(Notify)(LONG event, VARIANT * pVar);

	//IMoveBehavior
	STDMETHOD(get_to)(/*[out, retval]*/ BSTR* pVal);
	STDMETHOD(put_to)(/*[in]*/ BSTR newVal);
	STDMETHOD(get_from)(/*[out, retval]*/ BSTR* pVal);
	STDMETHOD(put_from)(/*[in]*/ BSTR newVal);

	//returns a pointer to the instance of IDispatch
	void *GetInstance() 
		{ return (IMoveBehavior*)this; }
	//
	HRESULT GetTypeInfo( ITypeInfo **ppTypeInfo )
		{ return GetTI(GetUserDefaultLCID(), ppTypeInfo); }

protected:
	HRESULT BuildDABehaviors();
private:

	CPoint *m_pFrom;
	CPoint *m_pTo;

	DWORD m_cookie;
};

#endif //ifndef __MOVEBEHAVIOR_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\lm\lmbehav\src\pulsate.cpp ===
// PulsateBehavior.cpp : Implementation of CPulsateBehavior
#include "stdafx.h"
#include "Behavior.h"
#include "Pulsate.h"

/////////////////////////////////////////////////////////////////////////////
// CPulsateBehavior

CPulsateBehavior::CPulsateBehavior() :
	m_pFrom( NULL ),
	m_pTo( NULL ),
	m_pBy( NULL )
{
}

CPulsateBehavior::~CPulsateBehavior()
{
	delete m_pFrom;
	delete m_pTo;
	delete m_pBy;
}

HRESULT	CPulsateBehavior::BuildDABehaviors()
{
	if ( m_pBehaviorSite == NULL ) return E_FAIL;

	// Get parent element
	//----------------------------------------------------------------------
	CComPtr<IHTMLElement>	pElement;
	CComPtr<IHTMLElement>	pParentElt;
	CComPtr<IHTMLStyle>		pParentStyle;
	
	m_pBehaviorSite->GetElement( &pElement );
	pElement->get_parentElement( &pParentElt );

	pParentElt->get_style( &pParentStyle );

	if ( pParentStyle == NULL ) return E_FAIL;

	// Set up DA Tree
	//----------------------------------------------------------------------
	IDAStaticsPtr	e;
	
	e.CreateInstance( L"DirectAnimation.DAStatics" );

	float 			fDuration	= 0.0;
	if ( FAILED( GetDur( &fDuration ) ) )
		return E_FAIL;

	IDANumberPtr	timePtr	= GetTimeNumberBvr();
	if ( timePtr == NULL )
		return E_FAIL;

	IDANumberPtr	tNorm = e->Div( timePtr, e->DANumber( fDuration ) );
	
	// Get original values
	//----------------------------------------------------------------------
	HRESULT		hr			= S_OK;
	CComBSTR	cbstrID;
	
	hr = GetParentID( &cbstrID );
	if ( FAILED(hr) ) return hr;

	float 		fLeft, fTop, fWidth, fHeight;
		
	hr = pParentStyle->get_posLeft( &fLeft );
	if ( FAILED(hr) ) return E_FAIL;
	hr = pParentStyle->get_posTop( &fTop );
	if ( FAILED(hr) ) return E_FAIL;
	hr = pParentStyle->get_posWidth( &fWidth );
	if ( FAILED(hr) ) return E_FAIL;
	hr = pParentStyle->get_posHeight( &fHeight );
	if ( FAILED(hr) ) return E_FAIL;

	double			dXFrom, dYFrom;
	double			dXTo, dYTo;
	
	if ( m_pFrom == NULL )
	{
		dXFrom = 1.0;
		dYFrom = 1.0;
	}
	else
	{
		dXFrom = m_pFrom->GetX()/100.0;
		dYFrom = m_pFrom->GetY()/100.0;
	}
	
	if ( m_pTo == NULL )
	{
		if ( m_pBy == NULL )
		{
			dXTo = 1.0;
			dYTo = 1.0;
		}
		// TODO: Scale relative to current scale
		else
		{
			dXTo = 1.0;
			dYTo = 1.0;
		}
	}
	else
	{
		dXTo = m_pTo->GetX()/100.0;
		dYTo = m_pTo->GetY()/100.0;
	}
	
	// Animate width and height
	//----------------------------------------------------------------------
	double			xC		= fLeft + fWidth/2;
	double			yC		= fTop + fHeight/2;
	
	IDANumberPtr	fromX	= e->DANumber( dXFrom );
	IDANumberPtr	interpX = e->Add( fromX, e->Mul( tNorm, e->Sub( e->DANumber( dXTo ), fromX ) ) );

	IDANumberPtr	fromY	= e->DANumber( dYFrom );
	IDANumberPtr	interpY	= e->Add( fromY, e->Mul( tNorm, e->Sub( e->DANumber( dYTo ), fromY ) ) );

	IDANumberPtr	xScale	= e->Mul( interpX, e->DANumber( fWidth ) );
	IDANumberPtr	yScale	= e->Mul( interpY, e->DANumber( fHeight ) );

	xScale = e->Cond( e->GT( timePtr, e->DANumber( -1 ) ),
					  xScale,
					  e->DANumber( dXTo * fWidth ) );
	
	yScale = e->Cond( e->GT( timePtr, e->DANumber( -1 ) ),
					  yScale,
					  e->DANumber( dYTo * fHeight ) );
	
	IDANumberPtr	animWidth	= xScale->AnimateProperty(
		_bstr_t( cbstrID + L"." + L"style.posWidth" ), "JScript", VARIANT_FALSE, 0.02 );
	IDANumberPtr	animHeight	= yScale->AnimateProperty(
		_bstr_t( cbstrID + L"." + L"style.posHeight" ), "JScript", VARIANT_FALSE, 0.02 );

	// Left, Top must be animated to keep the center in the same place.
	IDANumberPtr	xPos	= e->Sub( e->DANumber( xC ), e->Div( xScale, e->DANumber( 2 ) ) );
	IDANumberPtr	yPos	= e->Sub( e->DANumber( yC ), e->Div( yScale, e->DANumber( 2 ) ) );

	IDAPoint2Ptr	pos		= e->Point2Anim( xPos, yPos );

	pos = e->Cond( e->GT( timePtr, e->DANumber( -1 ) ),
				   pos,
				   e->Point2( xC-(dXTo*fWidth/2), yC-(dYTo*fHeight/2) ) );
	
	IDAPoint2Ptr	animPos	= pos->AnimateControlPosition(
		_bstr_t( cbstrID ), L"JScript", VARIANT_FALSE, 0.02 );
		
	// Add all the behaviors to run
	//----------------------------------------------------------------------
	if ( m_vwrControlPtr != NULL )
	{
		hr = m_vwrControlPtr->AddBehaviorToRun( animPos );
		if ( FAILED(hr) ) return hr;
		
		hr = m_vwrControlPtr->AddBehaviorToRun( animWidth );
		if ( FAILED(hr) ) return hr;
		
		hr = m_vwrControlPtr->AddBehaviorToRun( animHeight );
		if ( FAILED(hr) ) return hr;
	}
	
// 	LONG			lCookieWidth, lCookieHeight;
// 	LONG			lCookiePos;
	
//  	hr = AddBehavior( animPos, &lCookiePos );
//  	if ( FAILED(hr) ) return hr;
	
// 	hr = AddBehavior( animWidth, &lCookieWidth );
// 	if ( FAILED(hr) ) return hr;
	
// 	hr = AddBehavior( animHeight, &lCookieHeight );
// 	if ( FAILED(hr) ) return hr;
	
// 	hr = TurnOn();
// 	if ( FAILED(hr) ) return hr;
	
	return S_OK;
}

STDMETHODIMP CPulsateBehavior::Notify(LONG dwNotify, VARIANT * pVar)
{
	HRESULT hr = CBaseBehavior::Notify( dwNotify, pVar );

	if ( dwNotify == BEHAVIOREVENT_DOCUMENTREADY )
	{
		BuildDABehaviors();
	}
	
	return hr;
}

STDMETHODIMP CPulsateBehavior::get_from(BSTR * pVal)
{
	if( pVal == NULL )
		return E_INVALIDARG;
	
	if( m_pFrom != NULL)
		m_pFrom->ToString( pVal );
	else
		(*pVal) = NULL;

	return S_OK;
}

STDMETHODIMP CPulsateBehavior::put_from(BSTR newVal)
{
	if( m_pFrom == NULL )
		m_pFrom = new CPoint();
	
	if( FAILED( m_pFrom->Parse( newVal ) ) )
		return E_FAIL;

	return S_OK;
}

STDMETHODIMP CPulsateBehavior::get_to(BSTR * pVal)
{
	if( pVal == NULL )
		return E_INVALIDARG;
	
	if(m_pTo != NULL )
		m_pTo->ToString( pVal );
	else
		(*pVal) = NULL;

	return S_OK;
}

STDMETHODIMP CPulsateBehavior::put_to(BSTR newVal)
{
	if( m_pTo == NULL )
		m_pTo = new CPoint();
	
	if( FAILED( m_pTo->Parse( newVal ) ) )
		return E_FAIL;

	return S_OK;
}

STDMETHODIMP CPulsateBehavior::get_by(BSTR * pVal)
{
	if( pVal == NULL )
		return E_INVALIDARG;
	
	if(m_pBy != NULL )
		m_pBy->ToString( pVal );
	else
		(*pVal) = NULL;

	return S_OK;
}

STDMETHODIMP CPulsateBehavior::put_by(BSTR newVal)
{
	if( m_pBy == NULL )
		m_pBy = new CPoint();
	
	if( FAILED( m_pBy->Parse( newVal ) ) )
		return E_FAIL;

	return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\lm\lmbehav\src\point.cpp ===
#include "stdafx.h"

#include "point.h"

//States for the parser
#define PARSE_ERROR -1
#define GETX  1
#define GETY  2
#define GETZ  3
#define END   4
/*
#define PARSE_ERROR -1
#define START 0
#define GOTX  1
#define GOTY  2
#define GOTZ  3
#define XDBL  4
#define YDBL  5
#define ZDBL  6
#define ENDX  7
#define ENDY  8
#define ENDZ  9
#define DONE  10
*/

CPoint::CPoint():
	m_x(0.0), 
	m_y(0.0), 
	m_z(0.0),
	m_pStringRep(NULL)
{
}

CPoint::~CPoint()
{
	if( m_pStringRep != NULL )
		SysFreeString( m_pStringRep );
}

HRESULT
CPoint::ToString( BSTR* pToString )
{
	if( pToString == NULL )
		return E_INVALIDARG;

	(*pToString) = SysAllocString( m_pStringRep );

	return S_OK;
}

HRESULT
CPoint::Parse(BSTR pString)
{
	if( m_pStringRep != NULL )
		SysFreeString( m_pStringRep );
	m_pStringRep = SysAllocString( pString );

	//zero out the double representation
	m_x = m_y = m_z = 0;

	int state = GETX;

	//if the string representation is non null
	if( m_pStringRep != NULL && state != END )
	{
		CComBSTR buffer( m_pStringRep );
		wchar_t* token = NULL;

		wchar_t* seps = L" ,\t\n";

		token = wcstok( buffer.m_str, seps );
		while( token != NULL )
		{
			switch( state )
			{
			case GETX:
				if( swscanf( token, L"%lf", &m_x ) == 1 )
					state = GETY;
				else
					state = PARSE_ERROR;
				break;
			case GETY:
				if( swscanf( token, L"%lf", &m_y ) == 1 )
					state = GETZ;
				else
					state = PARSE_ERROR;
				break;
			case GETZ:
				if( swscanf( token, L"%lf", &m_z ) == 1 )
					state = END;
				else
					state = PARSE_ERROR;
				break;
			default:
				state = PARSE_ERROR;
			}
			
			if( state != PARSE_ERROR )
				token = wcstok( NULL, seps );
		}
		if( state != GETX &&
			state != GETY &&
			state != GETZ &&
			state != END )
			return E_INVALIDARG;
	/*
		//parse it into double representation
		//we are expecting a string of the format
		//[x:[NN[.NN]];][y:[NN[.NN]];][z:[NN[.NN]];]
		//where N is a digit 0-9 and any value not specified
		// defaults to 0

		int state = START;

		int curCharNum = 0;
		WCHAR curChar;
		int len = SysStringLen(m_pStringRep);

		double whole = 0.0; 
		double frac = 0.0;
		bool inFrac = false;

		while( curCharNum < len && state != PARSE_ERROR )
		{
			curChar = m_pStringRep[curCharNum];
			//eat whitespace
			while( iswspace( curChar ) )
			{
				curCharNum++;
				if( curCharNum < len )
				{
					curChar = m_pStringRep[curCharNum];
				}
				else
				{
					state = PARSE_ERROR;
					break;
				}
			}

			switch( state )
			{

			case START:
				if( curChar == L'x' || curChar == L'X' )
					state = GOTX;
				else if( curChar == L'y' || curChar == L'Y' )
					state = GOTY;
				else if( curChar == L'z' || curChar == L'Z' )
					state = GOTZ;
				else
					state = PARSE_ERROR;
				break;
			case GOTX:
				if( curChar == L':' )
					state = XDBL;
				else
					state = PARSE_ERROR;
				break;
			case GOTY:
				if( curChar == L':' )
					state = YDBL;
				else
					state = PARSE_ERROR;
				break;
			case GOTZ:
				if( curChar == L':' )
					state = ZDBL;
				else
					state = PARSE_ERROR;
				break;
			case XDBL:
			case YDBL:
			case ZDBL:
				whole = 0.0;
				frac = 0.0;
				inFrac = false;
				//parse a double from the string
				while( curCharNum < len && 
					   ( (curChar >= L'0' && curChar <=L'9') || 
						 (curChar == L'.') 
					   ) 
					 )
				{
					curChar = m_pStringRep[curCharNum];

					if( curChar >= L'0' && curChar <= L'9' )
					{
						if( !inFrac )
							whole = 10 * whole + (curChar - L'0');
						else
							frac = (frac + (curChar - L'0' ) ) * 0.1;
					}
					else if( curChar == L'.' )
					{
						if( !inFrac )
							inFrac = true;
						else
						{
							state = PARSE_ERROR;
							break;
						}
					}

					curCharNum++;
				}

				if( state == PARSE_ERROR )
					break;
				
				curCharNum--;

				//eat whitespace
				while( iswspace( curChar ) )
				{
					curCharNum++;
					if( curCharNum < len )
					{
						curChar = m_pStringRep[curCharNum];
					}
					else
					{
						state = PARSE_ERROR;
						break;
					}
				}

				if( curChar == L';' )
				{
					if( state == XDBL )
					{
						m_x = whole + frac;
						state = ENDX;
					}
					else if( state == YDBL )
					{
						m_y = whole + frac;
						state = ENDY;
					}
					else if( state == ZDBL )
					{
						m_z = whole + frac;
						state = ENDZ;
					}
				}
				else
					state = PARSE_ERROR;
				break;
			case ENDX:
				if( curChar == L'y' || curChar == L'Y' )
					state = GOTY;
				else if( curChar == L'z' || curChar == L'Z' )
					state = GOTZ;
				else if( curChar == L'\0' )
					state = DONE;
				else
					state = PARSE_ERROR;
				break;
			case ENDY:
				if( curChar == L'z' || curChar == L'Z' )
					state = GOTZ;
				else if( curChar == L'\0' )
					state = DONE;
				else
					state = PARSE_ERROR;
				break;
			case ENDZ:
				if( curChar == L'\0' )
					state = DONE;
				else
					state = PARSE_ERROR;
				break;
			default:
				//shouldn't get here
				state = PARSE_ERROR;
			}

			curCharNum++;
		}
		if( state != DONE && 
			state != ENDX && 
			state != ENDY && 
			state != ENDZ)
		{
			return E_INVALIDARG;
		}
		*/
	}

	return S_OK;
}

IDAPoint2Ptr 
CPoint::GetDAPoint2( IDAStaticsPtr s )
{
	return s->Point2( m_x, m_y );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\lm\lmbehav\src\move.cpp ===
#include "stdafx.h"

#include "move.h"

CMoveBehavior::CMoveBehavior() : 
	m_pFrom(NULL),
	m_pTo(NULL)
{
}

CMoveBehavior::~CMoveBehavior()
{
	if( m_pFrom != NULL )
		delete m_pFrom;
	
	if( m_pTo != NULL )
		delete m_pTo;
}

//IElementBehavior

STDMETHODIMP 
CMoveBehavior::Notify(LONG dwNotify, VARIANT * pVar)
{
	HRESULT hr = CBaseBehavior::Notify( dwNotify, pVar );

	if ( dwNotify == BEHAVIOREVENT_DOCUMENTREADY )
	{
		BuildDABehaviors();

		CComPtr<IHTMLElement> pParent;
		GetParentElement( &pParent );
		if( pParent != NULL )
		{
			CComPtr<IHTMLCurrentStyle> pCurrentStyle;
			CComBSTR pCurrentPosition;

			CComQIPtr<IHTMLElement2, &IID_IHTMLElement2> pParent2(pParent);
			if( pParent2 == NULL )
				return E_FAIL;
			hr = pParent2->get_currentStyle( &pCurrentStyle );
			if( FAILED( hr ) )
				return hr;
			if( pCurrentStyle != NULL )
			{
				hr = pCurrentStyle->get_position( &pCurrentPosition );
				if( FAILED( hr ) )
					return hr;
				if( !pCurrentPosition || 
					( _wcsicmp( L"static", pCurrentPosition ) == 0 ) )
				{
					CComPtr<IHTMLStyle> pStyle;
					hr = pParent2->get_runtimeStyle( &pStyle );
					if( FAILED( hr ) )
						return hr;
					if( pStyle != NULL )
					{
						CComQIPtr<IHTMLStyle2, &IID_IHTMLStyle2> pStyle2(pStyle);
						hr = pStyle2->put_position( L"relative" );
						if( FAILED( hr ) )
							return hr;
					}
				}
			}
		}
	}
	
	return hr;
}


//IMoveBehavior

STDMETHODIMP 
CMoveBehavior::get_from(BSTR *pVal)
{
	if( pVal == NULL )
		return E_INVALIDARG;
	
	if( m_pFrom != NULL)
		m_pFrom->ToString( pVal );
	else
		(*pVal) = NULL;

	return S_OK;
}

STDMETHODIMP 
CMoveBehavior::put_from(BSTR newVal)
{
	if( m_pFrom == NULL )
		m_pFrom = new CPoint();
	
	if( FAILED( m_pFrom->Parse( newVal ) ) )
		return E_FAIL;

	return S_OK;
}

STDMETHODIMP
CMoveBehavior::get_to(BSTR *pVal)
{

	if( pVal == NULL )
		return E_INVALIDARG;
	
	if(m_pTo != NULL )
		m_pTo->ToString( pVal );
	else
		(*pVal) = NULL;

	return S_OK;
}

STDMETHODIMP
CMoveBehavior::put_to(BSTR newVal)
{
	if( m_pTo == NULL )
		m_pTo = new CPoint();
	
	if( FAILED( m_pTo->Parse( newVal ) ) )
		return E_FAIL;

	return S_OK;
}

//class members

HRESULT
CMoveBehavior::BuildDABehaviors()
{
	if( m_pFrom == NULL || m_pTo == NULL )
		return E_FAIL;

	HRESULT hr = S_OK;
	CComBSTR pParentID;

	hr = GetParentID( &pParentID );
	
	if( FAILED( hr ) )
		return hr;

	IDANumberPtr timeFunction;

	float duration = 0.0;
	if( FAILED ( GetDur( &duration ) ) )
		return E_FAIL;

	timeFunction = GetTimeNumberBvr();
	if( timeFunction == NULL )
		return E_FAIL;

	IDAStaticsPtr	s;

	s.CreateInstance( L"DirectAnimation.DAStatics" );

	//IDANumberPtr xCoord = s->Interpolate( m_pFrom->GetX(), m_pTo->GetX(), duration );
	//IDANumberPtr yCoord = s->Interpolate( m_pFrom->GetY(), m_pTo->GetY(), duration );

	IDANumberPtr startX = s->DANumber( m_pFrom->GetX() );
	IDANumberPtr startY = s->DANumber( m_pFrom->GetY() );
	IDANumberPtr endX   = s->DANumber( m_pTo->GetX() );
	IDANumberPtr endY   = s->DANumber( m_pTo->GetY() );
	IDANumberPtr durationBvr = s->DANumber( duration );

	IDANumberPtr t = s->Div( timeFunction, durationBvr );

	IDANumberPtr xCoord =  s->Add( startX, s->Mul( s->Sub( endX, startX ), t ) );
	IDANumberPtr yCoord =  s->Add( startY, s->Mul( s->Sub( endY, startY ), t ) );


	IDAPoint2Ptr pos = s->Point2Anim( xCoord, yCoord );

	pos = s->Cond( s->GT( timeFunction, s->DANumber( -1 ) ),
				   pos,
				   s->Point2( m_pFrom->GetX(), m_pFrom->GetY() )
				 );

	pos = pos->AnimateControlPosition( pParentID.m_str, L"JavaScript", VARIANT_FALSE, 0.02 );

	//add the behavior and start time.
	LONG	lCookie;
	
	if ( m_vwrControlPtr != NULL )
		hr = m_vwrControlPtr->AddBehaviorToRun( pos );

//	hr = AddBehavior( pos, &lCookie );
//		if ( FAILED(hr) ) return hr;

//	hr = TurnOn();
//		if ( FAILED(hr) ) return hr;

	return hr;
}

STDMETHODIMP CMoveBehavior::get_on(VARIANT * pVal)
{
	if( pVal == NULL )
		return E_INVALIDARG;

	V_VT(pVal)  = VT_BOOL;
	V_BOOL(pVal)= m_on ? VARIANT_TRUE : VARIANT_FALSE;

	return S_OK;
}

STDMETHODIMP CMoveBehavior::put_on(VARIANT newVal)
{
	VariantChangeType( &newVal, &newVal, 0, VT_BOOL );
	
	m_on = V_BOOL(&newVal) == VARIANT_TRUE ? true : false;
	
	HandleOnChange( m_on );

	return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\lm\lmbehav\src\jump.h ===
// JumpBehavior.h : Declaration of the CJumpBehavior

#ifndef __JUMPBEHAVIOR_H_
#define __JUMPBEHAVIOR_H_

#include "resource.h"       // main symbols
#include "base.h"

/////////////////////////////////////////////////////////////////////////////
// CJumpBehavior
class ATL_NO_VTABLE CJumpBehavior :
	public CBaseBehavior, 
	public CComCoClass<CJumpBehavior, &CLSID_JumpBehavior>,
	public IDispatchImpl<IJumpBehavior, &IID_IJumpBehavior, &LIBID_BEHAVIORLib>
{
public:
	CJumpBehavior();

	STDMETHOD(Notify)(LONG event, VARIANT * pVar);
	
	//needed by CBaseBehavior
	void *GetInstance() { return (IJumpBehavior *) this ; }
	
    HRESULT GetTypeInfo(ITypeInfo ** ppInfo)
    { return GetTI(GetUserDefaultLCID(), ppInfo); }

DECLARE_REGISTRY_RESOURCEID(IDR_JUMPBEHAVIOR)

BEGIN_COM_MAP(CJumpBehavior)
	COM_INTERFACE_ENTRY(IJumpBehavior)
	COM_INTERFACE_ENTRY(IDispatch)
	COM_INTERFACE_ENTRY_CHAIN(CBaseBehavior)
END_COM_MAP()

// IJumpBehavior
public:

protected:
	HRESULT			BuildDABehaviors();
};

#endif //__JUMPBEHAVIOR_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\lm\lmbehav\src\jump.cpp ===
// JumpBehavior.cpp : Implementation of CJumpBehavior
#include "stdafx.h"

#include "behavior.h"
#include "Jump.h"

/////////////////////////////////////////////////////////////////////////////
// CJumpBehavior

CJumpBehavior::CJumpBehavior()
{
}

HRESULT CJumpBehavior::BuildDABehaviors()
{
	HRESULT	hr		= S_OK;

	// Get parent element
	//----------------------------------------------------------------------
	CComPtr<IHTMLElement>	pElement;
	CComPtr<IHTMLElement>	pParentElt;
	CComPtr<IHTMLStyle>		pParentStyle;
	m_pBehaviorSite->GetElement( &pElement );
	pElement->get_parentElement( &pParentElt );

	pParentElt->get_style( &pParentStyle );

	if ( pParentStyle == NULL ) return E_FAIL;

	// Get original values
	//----------------------------------------------------------------------
	CComBSTR								cbstrID;
	
	hr = GetParentID( &cbstrID );
	if ( FAILED(hr) ) return hr;

	float 		fLeft, fTop;
	
	hr = pParentStyle->get_posLeft( &fLeft );
	if ( FAILED(hr) ) return E_FAIL;
	hr = pParentStyle->get_posTop( &fTop );
	if ( FAILED(hr) ) return E_FAIL;

	// Set up DA Tree
	//----------------------------------------------------------------------
	IDAStaticsPtr	e;

	e.CreateInstance( L"DirectAnimation.DAStatics" );

	float 			fDuration	= 0.0;
	if ( FAILED( GetDur( &fDuration ) ) )
		return E_FAIL;

	IDANumberPtr	timePtr	= GetTimeNumberBvr();
	if ( timePtr == NULL )
		return E_FAIL;

	// Animate values
	//----------------------------------------------------------------------
	double			dXRange		= 300.0;
	double			dYRange		= 300.0;
	
	// Random numbers between -0.5 and 0.5
	IDANumberPtr	randX = e->Sub( e->Mod( e->SeededRandom( rand() ), e->DANumber( 1.0 ) ), e->DANumber( 0.5 ) );
	IDANumberPtr	randY = e->Sub( e->Mod( e->SeededRandom( rand() ), e->DANumber( 1.0 ) ), e->DANumber( 0.5 ) );

	// Time changes only once at each interval
	IDANumberPtr	time = e->Floor( e->Div( timePtr, e->DANumber( fDuration ) ) );

	randX = randX->SubstituteTime( time );
	randY = randY->SubstituteTime( time );

 	// Jump range
	IDANumberPtr	rangeLeft = e->Add( e->DANumber( fLeft ), e->Mul( randX, e->DANumber( dXRange ) ) );
	IDANumberPtr	rangeTop  = e->Add( e->DANumber( fTop ), e->Mul( randY, e->DANumber( dYRange ) ) );

	IDAPoint2Ptr pos = e->Point2Anim( rangeLeft, rangeTop );

	pos = e->Cond( e->GT( timePtr, e->DANumber( -1 ) ),
				   pos,
				   e->Point2( fLeft, fTop ) );
					   
	IDAPoint2Ptr animPos = pos->AnimateControlPosition(
		_bstr_t( cbstrID ), L"JScript", VARIANT_FALSE, 0.02 );

	// Add to the behaviors to run
	//----------------------------------------------------------------------
	if ( m_vwrControlPtr != NULL )
		hr = m_vwrControlPtr->AddBehaviorToRun( animPos );
	
// 	LONG	lCookie;
// 	hr = AddBehavior( animPos, &lCookie );
// 	if ( FAILED(hr) ) return hr;
	
// 	hr = TurnOn();
// 	if ( FAILED(hr) ) return hr;
	
	return hr;
}

STDMETHODIMP CJumpBehavior::Notify(LONG dwNotify, VARIANT * pVar)
{
	HRESULT hr = CBaseBehavior::Notify( dwNotify, pVar );

	if ( dwNotify == BEHAVIOREVENT_DOCUMENTREADY )
	{
		BuildDABehaviors();
	}
	
	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\lm\lmbehav\src\pulsate.h ===
// PulsateBehavior.h : Declaration of the CPulsateBehavior




#ifndef __PULSATEBEHAVIOR_H_
#define __PULSATEBEHAVIOR_H_

#include "resource.h"       // main symbols
#include "base.h"
#include "point.h"

/////////////////////////////////////////////////////////////////////////////
// CPulsateBehavior
class ATL_NO_VTABLE CPulsateBehavior : 
	public CBaseBehavior,
	public CComCoClass<CPulsateBehavior, &CLSID_PulsateBehavior>,
	public IDispatchImpl<IPulsateBehavior, &IID_IPulsateBehavior, &LIBID_BEHAVIORLib>
{
protected:
	double					m_dPercent;
	
public:
	CPulsateBehavior();
	~CPulsateBehavior();

	STDMETHOD(Notify)(LONG event, VARIANT * pVar);
	
	//needed by CBaseBehavior
	void *GetInstance() { return (IPulsateBehavior *) this ; }

    HRESULT GetTypeInfo(ITypeInfo ** ppInfo)
    { return GetTI(GetUserDefaultLCID(), ppInfo); }
	
DECLARE_REGISTRY_RESOURCEID(IDR_PULSATEBEHAVIOR)

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CPulsateBehavior)
	COM_INTERFACE_ENTRY(IPulsateBehavior)
	COM_INTERFACE_ENTRY(IDispatch)
	COM_INTERFACE_ENTRY_CHAIN(CBaseBehavior)
END_COM_MAP()

// IPulsateBehavior
public:
	STDMETHOD(get_by)(/*[out, retval]*/ BSTR *pVal);
	STDMETHOD(put_by)(/*[in]*/ BSTR newVal);
	STDMETHOD(get_to)(/*[out, retval]*/ BSTR *pVal);
	STDMETHOD(put_to)(/*[in]*/ BSTR newVal);
	STDMETHOD(get_from)(/*[out, retval]*/ BSTR *pVal);
	STDMETHOD(put_from)(/*[in]*/ BSTR newVal);

protected:
	HRESULT			BuildDABehaviors();
	
protected:
	CPoint	*	m_pFrom;
	CPoint	*	m_pTo;
	CPoint	*	m_pBy;
};

#endif //__PULSATEBEHAVIOR_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\lm\messages\usa\makefile.inc ===
lmrt.rc : $(SDKDIR)\lmrt.tlb \
          lmctrl.rgs
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\lm\lmbehav\src\stdafx.h ===
#include "../include/stdafx.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\mmapi\common.inc ===
PROJNAME=mmapi
DO_NOT_USE_EH=1

!include $(ROOT)\common.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\mmapi\dll\stdafx.cpp ===
/*++

Copyright (c) 1995-96 Microsoft Corporation

Abstract:

    Ole Object initialization

Revision:

--*/

#include "headers.h"

#undef map
#undef SubclassWindow

// Put this here to initialize all the ATL stuff

#ifdef _ATL_STATIC_REGISTRY
#include <statreg.h>
#include <statreg.cpp>
#endif

#include <atlimpl.cpp>
#include <atlctl.cpp>
#include <atlwin.cpp>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\make\make1.inc ===
# -------------------------------------------------------------
# Symbols defined in build.inc or environment
# Note that all user definable symbols are prefixed with an "_".
# -------------------------------------------------------------
# _BCHECKER             - If 1, a BoundsChecker Pro build is done.
# _BROWSE               - full=2, partial=1, none=0 [default=0]
# _COPYMAC              - if 1, mfile Mac Appelles build to Macintosh
# _DEBUG                - 0 = Retail with symbols
#                         1 = Debug
# _ENABLE_PERF_RPTING   - 1 = performance reporting to stdout enabled
#                         0 = disable performance reporting [default]
# _ERRORS_OK            - if 1 then continue building on errors [default=0]
# _KEEPTEMPFILES        - keep temporary makefiles [default=0]
# _LINK_WITH_OBJS       - list objs in .lib files [default=0]
# _MACFOLDER            - root Mac folder to which Mac Appelles is mfile'd
# _MACSYMS              - compile and copy Macintosh symbol files
# _MACTEXT              - defined if no RichText library available
# _MACHINE              - [default=x86]
# _MAP                  - if 1 then build map files [default=0]
# _NO_CRT               - if 1 then don't use c runtime [default=0]
# _NO_DYNLINKCRT        - if 1 then don't use crt dll [default = 1]
# _NO_INCREMENTAL_LINK  - 1 forces a full link. 0 implies _MAP=0
#                          [default=0 for _DEBUG==1, 1 otherwise]
# _NO_MINIMAL_REBUILD   - 0 = Allow C++ compiler to skip .CPP files if no class
#                             definitions in any .H files have changed
#                         1 = Normal file dependancies
#                          [default = 0 iff PDBFILE != NONE,
#                                     1 otherwise ]
# _NO_INCREMENTAL_COMP  - 0 = Allow C++ compiler to skip functions which have
#                             not changed since last compile
#                         1 = Normal complete compiles
#                          [default = 1]
# _PROFILE              - 0 = disable IceCAP profiling [default]
#                         1 = enable IceCAP profiling
# _SYSTEM               - [default=winnt]
# _TIMING               - if 1 then turn on timing [default=0]
# _USERCFLAGS           - add to compiler flags [default=]
# _USERLFLAGS           - add to link flags [default=]
# _USERRFLAGS           - add to resource compiler flags [default=]
# _WARNINGLEVEL         - warning level [default=3]
# _WARNINGSAREERRORS    - stop compiling on warnings [default=1]
#
# -------------------------------------------------------------
# Symbols defined in makefile before including make1.inc
# -------------------------------------------------------------
# ROOT          - root of srctree  [required]
# MODULE        - name of module   [required]
# PCHFILE       - name of precompiled header, no extension or path [optional]
# PCHPATH       - path to precompiled header [optional]
# INCLUDEDIRS   - search for include files in these directories [optional]
# PDBFILE       - use this as pdb file, or if "NONE" don't use pdb file
#
# -------------------------------------------------------------
# Symbols defined in makefile after including make1.inc
# -------------------------------------------------------------
# LIBTARG       - build library
# LIBOBJS       - list of object files to add to library
#
# -------------------------------------------------------------
# Symbols defined by this file
# -------------------------------------------------------------
# BLDROOT       - root of build tree
# BLDDIR        - build directory for this module
# SRCROOT       - root of the source tree
# SRCDIR        - this directory
# TMPDIR        - location for temporary files
# BINDIR        - final products directory
# SDKDIR        - Appelles SDK
# ELEVATEDIR    - Elevated files
# CRTLIBC       - path to LIBC[D].LIB (including the "LIBC[D].LIB")
# MACDLLCREATOR - Mac Creator Sig for Appelles dll
# MACEXECREATOR - Mac Creator Sig for Appelles
#
# -------------------------------------------------------------
# Targets
# -------------------------------------------------------------
# beep          Beeps.  Generates a beep function that is audible to the
#                       developer.  Usage:  nmake all beep.
#
# all           Make everything in this module.
# clean         Delete build products from this module.
# depend        Make dependencies for this module.
# fresh         Make clean, depend and all.
#
# fall          Make everything in this module and all dependent modules.
# fclean        Delete build products from this module and all dep. modules.
# fdepend       Make dependencies for this module and all dependent modules.
# ffresh        Make clean, depend and all for this and all dependent modules.
#
# foo.cod       Build code listing for foo.cpp.
# foo.i         Build preprocessed file for foo.cpp.
# foo.obj       Build object file for foo.cpp.

!ifndef MODULE
!error MODULE must be defined in makefile
!endif

!ifndef ROOT
!error ROOT must be defined in makefile
!endif

SRCROOT=$(ROOT)\src

# _RELEASE is defined by the build subdirs, causing the build process
# to ignore the build.inc file.

!if "$(_RELEASE)" == ""
!   if exist ($(SRCROOT)\build.inc)
!       include "$(SRCROOT)\build.inc"
!   else
!       include "$(SRCROOT)\build.smp"
!   endif
!endif

!if exist($(SRCROOT)\project.inc)
!include $(SRCROOT)\project.inc
!endif

!if exist($(MAKEDIR)\..\project.inc)
!include $(MAKEDIR)\..\project.inc
!endif

# -------------------------------------------------------------
# Set user variables to default
# -------------------------------------------------------------

!ifndef _DEBUG
_DEBUG=1
!endif

!ifndef _ERRORS_OK
_ERRORS_OK=0
!endif

!ifndef _SYSTEM
_SYSTEM=winnt
!endif

!ifndef _MACHINE
_MACHINE=$(PROCESSOR_ARCHITECTURE)
!if "$(_MACHINE)" == ""
_MACHINE=x86
!endif
!endif

!ifndef _BROWSE
_BROWSE=0
!endif

!ifndef _MAP
_MAP=0
!endif

!ifndef _TIMING
_TIMING=0
!endif

!ifndef _LINK_WITH_OBJS
_LINK_WITH_OBJS=0
!endif

!ifndef _KEEPTEMPFILES
_KEEPTEMPFILES=0
!endif

!ifndef _WARNINGSAREERRORS
_WARNINGSAREERRORS=0
!endif

!ifndef _WARNINGLEVEL
_WARNINGLEVEL=3
!endif

!ifndef _BLDROOT

_BLDROOT=$(ROOT)\build

!if "$(_MACHINE)" == "MIPS"
_BLDROOT=$(_BLDROOT)\mips
!elseif "$(_MACHINE)" == "x86"
_BLDROOT=$(_BLDROOT)\win
!elseif "$(_MACHINE)" == "PPCMAC"
_BLDROOT=$(_BLDROOT)\ppcmac
!endif

!if "$(_DEBUG)" == "1"
_BLDROOT=$(_BLDROOT)\debug
!elseif "$(_PROFILE)" == "1"
_BLDROOT=$(_BLDROOT)\profile
!else
_BLDROOT=$(_BLDROOT)\ship
!endif

!if "$(_BCHECKER)" == "1"
_BLDROOT=$(_BLDROOT).bc
!endif

!endif

!ifndef _COPYMAC
#!if "$(_MACHINE)" == "PPCMAC" && "$(_MACFOLDER)" != ""
#_COPYMAC = 1
#!else
_COPYMAC = 0
#!endif
!endif

!ifndef _NO_DYNLINKCRT
_NO_DYNLINKCRT = 1
!endif

!ifndef _NO_CRT
!if "$(_DEBUG)" == "1"
_NO_CRT=0
!else
_NO_CRT=1
!endif
!endif

!ifndef _NO_INCREMENTAL_LINK
_NO_INCREMENTAL_LINK=0
!endif

!ifndef _NO_MINIMAL_REBUILD
_NO_MINIMAL_REBUILD=0
!endif

!ifndef _NO_INCREMENTAL_COMP
_NO_INCREMENTAL_COMP=1
!endif

!if "$(_DEBUG)" != "1"
_NO_INCREMENTAL_LINK=1
_NO_INCREMENTAL_COMP=1
!endif

!if "$(PDBFILE)" == "NONE"
_NO_MINIMAL_REBUILD=1
_NO_INCREMENTAL_COMP=1
!endif


# -------------------------------------------------------------
# Directories
# -------------------------------------------------------------

BLDROOT=$(_BLDROOT)
BLDDIR=$(BLDROOT)\$(MODULE)
TMPDIR=$(BLDDIR)
SRCDIR=$(MAKEDIR)
BINDIR=$(BLDROOT)\bin
SDKDIR=$(BLDROOT)\sdk
ELEVATEDIR=$(ROOT)\build\elevated
TOOLSROOT=$(ROOT)\tools
TOOLSDIR=$(TOOLSROOT)\$(_MACHINE)
JAVA15DIR=$(TOOLSDIR)\java15
JAVADIR=$(TOOLSDIR)\java20
QUARTZDIR=$(TOOLSDIR)\quartz
SHAREDDIR=$(TOOLSDIR)\msvc50\SharedIDE
AUXDLLDIR=$(TOOLSDIR)\msvc50\bin
VCDIR=$(TOOLSDIR)\msvc50\vc
SWEEPERDIR=$(VCDIR)
ATLDIR=$(VCDIR)\atl
MINLIBCDIR=$(TOOLSDIR)\minlibc
IE40DIR=$(TOOLSDIR)\ie40

!if "$(_MACHINE)" == "PPCMAC"
TOOLSUTILS=$(ROOT)\tools\x86\utils
TOOLSINCLUDE=
!else
TOOLSUTILS=$(TOOLSDIR)\utils
TOOLSINCLUDE= \
    $(TOOLSDIR)\qvlib\include\
    $(TOOLSDIR)\misc\include\
    $(TOOLSDIR)\quartz\include\
    $(IE40DIR)\inc\
    $(TOOLSDIR)\trident\include
!endif
ATLINCLUDE=$(ATLDIR)\include

TOOLSBINMSVC=$(VCDIR)\bin
TOOLSBINWIN32=$(TOOLSBINMSVC)
TOOLSBINYACC=$(TOOLSDIR)\bison
TOOLSBINLEX=$(TOOLSDIR)\flex
TOOLSBINJAVA=$(JAVADIR)\bin
TOOLSBINSHARED=$(SHAREDDIR)\bin

TOOLSLIBMSVC=$(VCDIR)\lib
TOOLSLIBWIN32=$(TOOLSLIBMSVC)
TOOLSLIBICAP=$(TOOLSDIR)\IceCap\x86
TOOLSLIBRL=$(TOOLSDIR)\RL\lib
TOOLSLIBMISC=$(TOOLSDIR)\misc\lib
TOOLSLIBSWEEPER=$(SWEEPERDIR)\lib
TOOLSLIBQUARTZ=$(QUARTZDIR)\lib
!if "$(_DEBUG)" == "1"
TOOLSLIBQV=$(TOOLSDIR)\QVLib\lib\WinRel
!else
TOOLSLIBQV=$(TOOLSDIR)\QVLib\lib\WinDebug
!endif
TOOLSLIBAACTIVE=$(TOOLSDIR)\aactive\lib
TOOLSLIBDIRECTX=$(TOOLSDIR)\directx\lib
TOOLSLIBGLU=$(TOOLSDIR)\glu\lib
TOOLSLIBAMOVIE=$(TOOLSDIR)\quartz\lib
TOOLSLIBTRIDENT=$(TOOLSDIR)\trident\lib
TOOLSLIBIE40=$(IE40DIR)\lib

MAKE2_INC=$(SRCROOT)\make\make2.inc
CRTLIBC=$(TOOLSLIBMSVC)\libc.lib

# -------------------------------------------------------------
# Tools
# -------------------------------------------------------------

!if "$(PROCESSOR_ARCHITECTURE)" == ""
EAT_ERRORS=
EAT_OUTPUT=
DEL      = -DEL
DELALL   = -ECHO y | DEL
XCOPY    = $(WINDIR)\COMMAND\XCOPY
!else
EAT_ERRORS=2>nul:
EAT_OUTPUT=1>nul:
DEL      = -DEL $(EAT_ERRORS)
DELALL   = $(DEL) /Q
XCOPY    = $(SYSTEMROOT)\SYSTEM32\XCOPY
!endif

SED      = $(TOOLSUTILS)\SED
MKDEP    = $(TOOLSUTILS)\MKDEP
TLMUNGE  = $(TOOLSUTILS)\TLMUNGE
CABARC   = $(TOOLSUTILS)\cabarc
WINZIP   = $(TOOLSDIR)\winzip\winzip32
DUBUILD  = $(TOOLSDIR)\misc\bin\dubuild
MKTYPLIB = $(TOOLSBINMSVC)\MKTYPLIB
CC       = $(TOOLSBINMSVC)\CL
BCC      = $(TOOLSBINMSVC)\CL
LIBR     = $(TOOLSBINMSVC)\LIB
LINK     = $(TOOLSBINMSVC)\LINK
BSCMAKE  = $(TOOLSBINMSVC)\BSCMAKE
MC       = $(TOOLSBINMSVC)\MC
RC       = $(TOOLSBINSHARED)\RC
AS       = $(TOOLSBINMSVC)\ML /c
CVTRES   = $(TOOLSBINMSVC)\CVTRES
JC       = $(TOOLSBINJAVA)\JVC
#JCOMGEN  = $(TOOLSBINJAVA)\jcom
JCOMGEN  = $(JAVA15DIR)\bin\JCOMGEN
ATTRJC   = $(JAVA15DIR)\bin\ATTRJVC
JTLB     = $(JAVA15DIR)\bin\JAVATLB

YACC     = $(TOOLSBINYACC)\bison.exe
LEX      = $(TOOLSBINLEX)\flex.exe

FLEXSKL  = $(TOOLSBINLEX)\flex.skl
BISONFILE= $(TOOLSBINYACC)\share\bison.simple

!if "$(_BCHECKER)" != ""
!if "$(_NORMALCC)" == ""
BCC = $(TOOLSBINMSVC)\BCOMPILE -Zop f:\bchecker.ini
!endif
LINK = $(TOOLSBINMSVC)\BCLINK
!endif

RENAME   = RENAME
SET      = SET
ECHO     = ECHO
MKDIR    = MKDIR $(EAT_ERRORS)
COPY     = COPY
MOVE     = MOVE $(EAT_OUTPUT)

!if "$(_MACHINE)" == "PPCMAC"
MIDL     = $(ROOT)\tools\x86\win32\bin\MIDL
MRC      = $(TOOLSBINMSVC)\MRC
MFILE    = $(TOOLSBINMSVC)\MFILE
MAP2SYM  = $(TOOLSBINMSVC)\MAP2SYM
!else
MIDL     = $(TOOLSBINMSVC)\MIDL
MAP2SYM  = $(TOOLSBINMSVC)\MAPSYM.exe
!endif

# -------------------------------------------------------------
# Miscellaneous Symbols specific to Mac Appelles
# -------------------------------------------------------------
!if "$(TARGET)" == "maccopy"
_COPYMAC = 1
!endif

!if "$(_COPYMAC)" == "1"
!if "$(_MACVOLUME)" == ""
_MACVOLUME=:HD
!else
_MACVOLUME=:$(_MACVOLUME)
!endif
!if "$(_MACFOLDER)" == ""
_MACFOLDER=$(_MACVOLUME):Appelles
!endif

!if "$(_DEBUG)" == "1"
_MACFOLDER=$(_MACFOLDER):debug
!elseif "$(_PROFILE)" == "1"
_MACFOLDER=$(_MACFOLDER):profile
!else
_MACFOLDER=$(_MACFOLDER):ship
!endif #"$(_DEBUG)" == "1"

!endif #"$(_COPYMAC)" == "1"

MACDLLCREATOR = cfmg
MACEXECREATOR = FRM3
MACSYMCREATOR = ????
MACTLBCREATOR = OLE2


MACTARG =
# -------------------------------------------------------------
# Create output directories
# -------------------------------------------------------------

!if [$(MKDIR) $(_BLDROOT)]
!endif

!if [$(MKDIR) $(BLDDIR)]
!endif

# -------------------------------------------------------------
# Verbosity & Temp files
# -------------------------------------------------------------

NOLOGO=/nologo

!if "$(MAKEFLAGS:S=)" != "$(MAKEFLAGS)"
# Use "!ifdef SILENTMODE" to determine if silent mode is on.
SILENTMODE=1
BATCH=/BATCH
!else
!undef SILENTMODE
BATCH=
!endif

!if $(_KEEPTEMPFILES)
KEEPFLAGS=KEEP
!else
KEEPFLAGS=NOKEEP
!endif

#
# Make sure the INCLUDE and CL environment variables are not set or that will
#  mess everything up!
#
!if [$(SET) INCLUDE=]
!endif
!if [$(SET) CL=]
!endif
!if [$(SET) ML=]
!endif
!if [$(SET) LIB=$(TOOLSLIBMSVC)]
!endif
!if [$(SET) PATH=$(TOOLSBINSHARED);$(AUXDLLDIR);%PATH%]
!endif

# -------------------------------------------------------------
# Rules
# -------------------------------------------------------------

# The suffixes list contains inferred dependent file extensions in
# order of precedence.  Do not add target file extensions to this list.
# The first .SUFFIXES line clears the default setttings.
.SUFFIXES:
.SUFFIXES: .cpp .cxx .c .hxx .h .asm .r .rc .h .tdl .l .y .class .java .tlb

#
# .cpp -> .obj
#
{$(SRCDIR)}.cpp.obj:
        $(BCC) $(NOLOGO) $< @$(BLDDIR)\cxx.rsp

#
# .cpp -> .obj
#
{$(BLDDIR)}.cpp.obj:
        $(BCC) $(NOLOGO) $< @$(BLDDIR)\cxx.rsp

#
# .cpp -> .cod
#
.cpp.cod:
        $(BCC) $(NOLOGO) $< /Fc$@ @$(BLDDIR)\cxx.rsp

#
# .cpp -> .i
#
.cpp.i:
        $(BCC) $(NOLOGO) @<< >$@
/I$(INCLUDEPATH:;=
/I)
$(CFLAGS: =
)
$(PCHFLAGS: =
)
/c
/E
$<
<<$(KEEFLAGS)

#
# .cxx -> .obj
#
{$(SRCDIR)}.cxx.obj:
        $(BCC) $(NOLOGO) $< @$(BLDDIR)\cxx.rsp

#
# .asm -> .obj
#
{$(SRCDIR)}.asm.obj:
        $(AS) $(NOLOGO) @<<
/I$(INCLUDEPATH:;=
/I)
$(AFLAGS: =
)
/c
/Fo$@
$<
<<$(KEEFLAGS)

#
# .cxx -> .cod
#
.cxx.cod:
        $(BCC) $(NOLOGO) $< /Fc$@ @$(BLDDIR)\cxx.rsp

#
# .cxx -> .i
#
.cxx.i:
        $(BCC) $(NOLOGO) @<< >$@
/I$(INCLUDEPATH:;=
/I)
$(CFLAGS: =
)
$(PCHFLAGS: =
)
/c
/E
$<
<<$(KEEFLAGS)

#
# .c -> .obj
#
{$(SRCDIR)}.c.obj:
        $(BCC) $(NOLOGO) @<<
/I$(INCLUDEPATH:;=
/I)
$(CFLAGS: =
)
/c
/Fo$@
$<
<<$(KEEFLAGS)

#
# .c -> .obj
# special case for the MIDL generated .c files
#
.c.obj:
        $(BCC) $(NOLOGO) @<<
/I$(INCLUDEPATH:;=
/I)
$(CFLAGS: =
)
/c
/Fo$@
$<
<<$(KEEFLAGS)

#
# .c -> .cod
#
.c.cod:
        $(BCC) $(NOLOGO) @<<
/I$(INCLUDEPATH:;=
/I)
$(CFLAGS: =
)
/c
/Fo$(BLDDIR)\$(@B).obj
/Fc$@
$<
<<$(KEEFLAGS)

#
# .c -> .i
#
.c.i:
        $(BCC) $(NOLOGO) @<< >$@
/I$(INCLUDEPATH:;=
/I)
$(CFLAGS: =
)
/c
/E
$<
<<$(KEEFLAGS)

#
# .h -> .pch
#
{$(SRCDIR)}.h.pch:
        $(ECHO) #include "$<" > $(TMPDIR)/$(@B).cpp
        $(CC) $(NOLOGO) @<<
/I$(INCLUDEPATH:;=
/I)
/c
$(CFLAGS: =
)
/Yc$<
/Fo$(@R).obj
/Fp$(@R).pcT
$(TMPDIR)\$(@B).cpp
<<$(KEEPFLAGS)
        $(DEL) $(@R).pch
        $(RENAME) $(@R).pcT $(@B).pch
!if "$(_BCHECKER)" != ""
!if "$(_NORMALCC)" == ""
        $(BCC) $(NOLOGO) @<<
/I$(INCLUDEPATH:;=
/I)
/c
$(CFLAGS: =
)
/Yc$<
/Fo$(@R).obj
/Fp$(@R).pcT
$(TMPDIR)\$(@B).cpp
<<$(KEEPFLAGS)
!endif
!endif

#
# .rc -> .res
#
{$(SRCDIR)}.rc.res:
!ifdef SILENTMODE
        $(ECHO) $(<F)
!endif
        $(RC) /I$(RESINCLPATH:;= /I) $(RFLAGS) /fo$@ $<

#
# .rc -> .res
#
{$(RESDIR)}.rc.res:
!ifdef SILENTMODE
        $(ECHO) $(<F)
!endif
        $(RC) /I$(RESINCLPATH:;= /I) $(RFLAGS) /fo$@ $<

#
# .odl -> .i
#
.odl.i:
        $(BCC) @<<
/I$(INCLUDEPATH:;=
/I)
/E
$<
>$@
<<$(KEEPFLAGS)

#
# .r -> .rsc
#
{$(SRCDIR)}.r.rsc:
        $(MRC) /I$(RESINCLPATH:;= /I) $(MRFLAGS) /o$@ $<


#
# .l -> .cpp
#
{$(SRCDIR)}.l.cpp:
        $(LEX) $(LEXFLAGS) -o$@ $<

#
# .l -> .c
#
{$(SRCDIR)}.l.c:
        $(LEX) $(LEXFLAGS) -o$@ $<

#
# .y -> .cpp
#
# Need to pass in file name with \\ since the compiler chokes
# on \ since it thinks they are escape sequences in the filename
# and bison generates #line using the exact command line name
{$(SRCDIR)}.y.cpp:
        @$(DEL) $@
        set BISON_SIMPLE=$(BISONFILE)
        $(YACC) $(YACCFLAGS) -o $(@:.cpp=.c) $(<:\=\\)
        @$(MOVE) $(@:.cpp=.c) $@

#
# .y -> .c
#
# Need to pass in file name with \\ since the compiler chokes
# on \ since it thinks they are escape sequences in the filename
# and bison generates #line using the exact command line name
{$(SRCDIR)}.y.c:
        set INIT=$(BISONINIT)
        $(YACC) $(YACCFLAGS) -o $@ $(<:\=\\)

#
# .java -> .class
#
{$(SRCDIR)}.java.class:
        $(JC) $(JCFLAGS) /d $(@D) $(<F)

#
# .class -> .tlb
#
{$(BINDIR)}.class{$(BLDDIR)}.tlb:
        $(JTLB) $(JTLBFLAGS) $<

#
# .class -> .tlb
#
{$(BINDIR)}.class.tlb:
        $(JTLB) $(JTLBFLAGS) $<

#
# .java -> .tlb
#
{$(BINDIR)}.java{$(BLDDIR)}.tlb:
        $(JCOMGEN) $(JCOMGENFLAGS) $<

#
# .java -> .tlb
#
{$(BINDIR)}.java.tlb:
        $(JCOMGEN) $(JCOMGENFLAGS) $<

# -------------------------------------------------------------
# DEFINES
# -------------------------------------------------------------

!if "$(_DEBUG)" == "1"
DEFINES=/D_DEBUG /DDBG=1 /DDEBUG $(DEFINES)
!endif

!if "$(_NO_CRT)" == "1"
DEFINES=$(DEFINES) /D_NO_CRT=1  /D_USE_PRINT=0
!else
DEFINES=$(DEFINES) /D_USE_PRINT=1
!endif

!if "$(_PROFILE)" == "1"
DEFINES=$(DEFINES) /DPRODUCT_PROF
ICECAPLIB=$(TOOLSLIBICAP)\icap.lib
!endif

!if "$(_MACHINE)"=="x86"
DEFINES=$(DEFINES) /D_X86_=1
!elseif "$(_MACHINE)"=="MIPS"
DEFINES=$(DEFINES) /D_MIPS_=1
!else if "$(_MACHINE)" == "PPCMAC"
DEFINES=$(DEFINES) /D_MAC /D_MPPC_ /D__pascal= /D_WLM_NOFORCE_LIBS /D_MACOLENAMES
DEFINES=$(DEFINES) /DOLE2ANSI /D_WIN32NLS /D_WIN32REG /D_WIN32
DEFINES=$(DEFINES) /DOLDROUTINENAMES=0
!if "$(_MACTEXT)" == "1"
DEFINES=$(DEFINES) /D_MACTEXT
!endif
!else
!error Unknown machine $(_MACHINE)
!endif

DEFINES=$(DEFINES) /DWIN32 /D_WINDOWS /DSTRICT /D_WIN32_WINNT=0x400

!if "$(_SYSTEM)" == "winnt"
# DEFINES= $(DEFINES) /DUNICODE /D_UNICODE
!endif

!if "$(_TIMING)" == "1"
DEFINES =$(DEFINES) /DTIMING
!endif

!if "$(_NO_INCREMENTAL_LINK)" == "1"
DEFINES =$(DEFINES) /D_NO_INCREMENTAL_LINK
!endif

# -------------------------------------------------------------
# AFLAGS
# -------------------------------------------------------------

!if "$(_DEBUG)" == "1"
#  /Zi  prepare for debugging
AFLAGS =/Zi
!endif

# -------------------------------------------------------------
# CFLAGS
# -------------------------------------------------------------

INCLUDEPATH=$(INCLUDEDIRS: =;)

!if "$(_MACHINE)"=="x86"
#   /Zp8    pack structs on 8 byte boundaries
#   /Oi     enable intrinsic functions
#   /ML     use Single-Threaded Staticaly-linked C runtime library (LIBC.LIB)
CFLAGS =$(NOLOGO) $(CFLAGS) -Zp8 -Oi
!else if "$(_MACHINE)" == "PPCMAC"
#   /Oi     enable intrinsic functions
#   /QPb    order bitfields low to high
#   /Zp8    pack structures on 1-byte
CFLAGS = $(NOLOGO) $(CFLAGS) -ML -Oi -QPb -Zp8
!endif

!if "$(PDBFILE)" == "NONE"
#   /Z7     generate debug info in OBJ file
CFLAGS =$(CFLAGS) -Z7
!else
#   /Zi     generate debug info in PDB file
CFLAGS =$(CFLAGS) -Zi
!endif

!if "$(_MACHINE)"=="x86"
!if "$(_NO_MINIMAL_REBUILD)" == "0"
#   /Gm     enable minimal rebuild:  allow C++ compiler to skip .CPP files iff
#             no class definitions in any .H files have changed
CFLAGS =$(CFLAGS) -Gm
!endif

!if "$(_NO_INCREMENTAL_COMP)" == "0"
#   /Gi     enable incremental compile:  allow C++ compiler to skip functions
#             which have not changed since last compile
CFLAGS =$(CFLAGS) -Gi
!endif

#   /G5     optimize for Pentium
#   /Gz     __stdcall calling convention
#   /GX     C++ exception unwind semantics
CFLAGS =$(CFLAGS) -G5 -GX
!endif  # _MACHINE == "x86"


!if "$(_DEBUG)" == "1"
#   /MDd    Use debug version of Multi-Threaded Dynamically-linked C runtime
#   /MTd    Use debug version of Multi-Threaded statically-linked C runtime
#   /Od     disable optimizations
#   /Ob1    (inline expansion on (needed for unicode wrappers))
#           XXX but I want it off to make debuggin easier
#   /Ob1    inline expansion on (needed for unicode wrappers)
#   /Ge     enable stack checking calls
#   /Gy     separate functions for linker

!if "$(_NO_DYNLINKCRT)" == "0"
CFLAGS =$(CFLAGS) -MDd
!elseif "$(_NO_CRT)" == "0"
CFLAGS =$(CFLAGS) -MTd
!endif  # _NO_DYNLINKCRT

CFLAGS =$(CFLAGS) -Od -Ob0 -Oi -Ge -Gy

!else

#   /MD     Use Multi-Threaded Dynamically-linked C runtime library
#   /MT     Use Multi-Threaded statically-linked C runtime library
#   /O1     minimize space, same as:
#           /Og  enable global optimization
#           /Os  favor code space
#           /Oy  enable frame pointer omission
#           /Ob1 inline expansion on
#           /Gs  disable stack checking
#           /Gf  enable string pooling
#           /Gy  separate functions for linker

!if "$(_NO_DYNLINKCRT)" == "0"
CFLAGS =$(CFLAGS) -MD
!elseif "$(_NO_CRT)" == "0"
CFLAGS =$(CFLAGS) -MT
!endif

CFLAGS =$(CFLAGS) -O1
!endif

!if "$(_PROFILE)" == "1"
#   /Gh     generate call to __penter in function calls
#           Used by cap and icecap for profiling.
CFLAGS =$(CFLAGS) /Gh
!endif

!ifdef PCHFILE
#   /Fp<file> name precompiled header file
#   /Yu[file] use .PCH file
PCHFLAGS   = /Fp$(PCHPATH)\$(PCHFILE).pch /Yu$(PCHFILE).h
PCHFILEOBJ = $(PCHPATH)\$(PCHFILE).obj
!else
PCHFLAGS   =
PCHFILEOBJ =
!endif

#   /Fd[file] name .PDB file
!if "$(PDBFILE)" != "NONE"
!ifdef PDBFILE
CFLAGS =$(CFLAGS) /Fd$(PDBFILE)
!else
CFLAGS =$(CFLAGS) /Fd$(BINDIR)\danim.pdb
!endif
!endif

!if "$(_BROWSE)" == "1"
#   /Fr[file] name source browser file
CFLAGS =$(CFLAGS) /Fr$(BLDDIR)^\
!endif

!if "$(_BROWSE)" == "2"
#   /FR[file] name extended .SBR file
CFLAGS =$(CFLAGS) /FR$(BLDDIR)^\
!endif

!if "$(_WARNINGSAREERRORS)" != "0"
#   /WX treat warnings as errors
CFLAGS = $(CFLAGS) /WX
!endif

!if "$(_ENABLE_PERF_RPTING)" == "1"
CFLAGS = $(CFLAGS) /DPERFORMANCE_REPORTING
!endif


CFLAGS=$(CFLAGS) /W$(_WARNINGLEVEL)
DEFINES=$(DEFINES) /DWARNINGLEVEL=$(_WARNINGLEVEL)

CFLAGS=$(CFLAGS) $(DEFINES) $(_USERCFLAGS)


# -------------------------------------------------------------
# LFLAGS
# -------------------------------------------------------------

!if "$(_MACHINE)"=="x86"
LINKMACHINE=iX86
!elseif "$(_MACHINE)" == "PPCMAC"
LINKMACHINE=MPPC
!else
LINKMACHINE=$(_MACHINE)
!endif

LFLAGS=$(NOLOGO) $(LFLAGS) /machine:$(LINKMACHINE) /base:@$(SRCROOT)\baseaddr.txt,$(@F)
!if "$(_DEBUG)" == "1" 
LFLAGS=$(LFLAGS) /debug
!endif

!if "$(_NO_INCREMENTAL_LINK)" != "1"
LFLAGS=$(LFLAGS) /incremental:yes
##_MAP=0
!else
!if defined(_DEBUGSHIP) && "$(_DEBUGSHIP)" != "0"
LFLAGS=$(LFLAGS) /incremental:no /debug
!else
LFLAGS=$(LFLAGS) /incremental:no /release
!endif
!endif

!if "$(_MAP)" != "0"
LFLAGS=$(LFLAGS) /map:$(@R).map
!endif

!if "$(_MACHINE)" != "PPCMAC"
!if "$(_PROFILE)" == "1"
LFLAGS=$(LFLAGS) /DEBUG:MAPPED /DEBUGTYPE:cv /opt:ref
!elseif "$(_DEBUG)" == "0"
LFLAGS=$(LFLAGS) /opt:ref
!endif
!endif

#!if "$(_DEBUG)" == "0" & "$(_PROFILE)" == "0"
#LFLAGS=$(LFLAGS) /PDB:NONE
#!else
!  ifdef PDBFILE
LFLAGS=$(LFLAGS) /PDB:$(PDBFILE)
!  else
LFLAGS=$(LFLAGS) /PDB:$*.pdb
!  endif
#!endif

LFLAGS=$(LFLAGS) $(_USERLFLAGS)


# -------------------------------------------------------------
# RFLAGS
# -------------------------------------------------------------

!if "$(RESINCLUDEDIRS)" == ""
RESINCLUDEDIRS=$(INCLUDEDIRS)
!endif

RESINCLPATH=$(RESINCLUDEDIRS: =;)

RFLAGS=$(RFLAGS) $(DEFINES) $(_USERRFLAGS)

!if "$(_MACHINE)" == "PPCMAC"
RESINCLUDEDIRS=$(RESINCLUDEDIRS) $(TOOLSROOT)\macinc\mrc
MRFLAGS=$(DEFINES) $(_USERRFLAGS)
RFLAGS=$(RFLAGS) /m
!endif

# -------------------------------------------------------------
# LEXFLAGS
# -------------------------------------------------------------
!if "$(LEXFLAGS)" == ""
LEXFLAGS= -s8 -S$(FLEXSKL) $(_USER_LEXFLAGS)
!endif

# -------------------------------------------------------------
# YACCFLAGS
# -------------------------------------------------------------
!if "$(YACCFLAGS)" == ""
YACCFLAGS= -d $(_USER_YACCFLAGS)
!endif


# -------------------------------------------------------------
# JCFLAGS
# -------------------------------------------------------------
!if "$(JCFLAGS)" == ""
JCFLAGS= /cp $(JCCLASSPATH) $(_USER_JCFLAGS)
!if "$(_DEBUG)" == "1"
JCFLAGS= $(JCFLAGS) -g
!else
JCFLAGS= $(JCFLAGS)
!endif
!endif

# -------------------------------------------------------------
# ATTRJCFLAGS
# -------------------------------------------------------------
!if "$(ATTRJCFLAGS)" == ""
ATTRJCFLAGS= /cp:p $(JCCLASSPATH) $(_USER_ATTRJCFLAGS)
!if "$(_DEBUG)" == "1"
ATTRJCFLAGS= $(ATTRJCFLAGS) -g
!else
ATTRJCFLAGS= $(ATTRJCFLAGS)
!endif
!endif

# -------------------------------------------------------------
# JCOMGENFLAGS
# -------------------------------------------------------------
!if "$(JCOMGENFLAGS)" == ""
JCOMGENFLAGS= /nologo $(_USER_JCOMGENFLAGS)
!endif

# -------------------------------------------------------------
# JTLBFLAGS
# -------------------------------------------------------------
!if "$(JTLBFLAGS)" == ""
JTLBFLAGS= $(_USER_JTLBFLAGS)
!endif

# -------------------------------------------------------------
# JHFLAGS
# -------------------------------------------------------------
!if "$(JHFLAGS)" == ""
JHFLAGS= -classpath $(JCCLASSPATH) -nologo $(_USER_JHFLAGS)
!endif

# -------------------------------------------------------------
# JCCLASSPATH
# -------------------------------------------------------------
!if "$(JCCLASSPATH)" == ""
JCCLASSPATH= $(JAVADIR)\classes\afc.zip;$(JAVADIR)\classes\classes.zip;$(SRCDIR);$(BLDDIR);$(SDKDIR);$(BINDIR)
!endif


# -------------------------------------------------------------
# Default Goal
# -------------------------------------------------------------

goal: all
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\mmapi\dll\headers.h ===
/*******************************************************************************

Copyright (c) 1995_96 Microsoft Corporation

Abstract:

    {Insert General Comment Here}

*******************************************************************************/


#ifndef _HEADERS_H
#define _HEADERS_H

#include "include/headers.h"
#include "mmapi.h"
#include "dacomutil.h"

#endif /* _HEADERS_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\mmapi\dll\init.cpp ===
/*******************************************************************************
 *
 * Copyright (c) 1998 Microsoft Corporation
 *
 * File: init.cpp
 *
 * Abstract:
 *
 *
 *
 *******************************************************************************/


#include "headers.h"

// Macro refers to a function of the name InitializeModule_Name,
// assumed to be defined, and then calls it.  If it's not defined,
// we'll get a link time error.
#define INITIALIZE_MODULE(ModuleName)           \
  extern bool InitializeModule_##ModuleName();  \
  if (!InitializeModule_##ModuleName()) return false;

#define DEINITIALIZE_MODULE(ModuleName,bShutdown)               \
  extern void DeinitializeModule_##ModuleName(bool);            \
  DeinitializeModule_##ModuleName(bShutdown);

bool
InitializeAllModules()
{
    INITIALIZE_MODULE(ATL);

    return true;
}

void
DeinitializeAllModules(bool bShutdown)
{
    DEINITIALIZE_MODULE(ATL, bShutdown);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\mmapi\include\util.h ===
/*******************************************************************************

Copyright (c) 1995_96 Microsoft Corporation

Abstract:

    {Insert General Comment Here}

*******************************************************************************/


#ifndef _UTIL_H
#define _UTIL_H

template <class T>
class CRPtr
{
  public:
    typedef T _PtrClass;
    CRPtr() { p = NULL; }
    CRPtr(T* lp, bool baddref = true)
    {
        p = lp;
        if (p != NULL && baddref)
            CRAddRefGC(p);
    }
    CRPtr(const CRPtr<T>& lp, bool baddref = true)
    {
        p = lp.p;

        if (p != NULL && baddref)
            CRAddRefGC(p);
    }
    ~CRPtr() {
        CRReleaseGC(p);
    }
    void Release() {
        CRReleaseGC(p);
        p = NULL;
    }
    operator T*() { return (T*)p; }
    T& operator*() { Assert(p != NULL); return *p; }
    T* operator=(T* lp)
    {
        return Assign(lp);
    }
    T* operator=(const CRPtr<T>& lp)
    {
        return Assign(lp.p);
    }

    bool operator!() const { return (p == NULL); }
    operator bool() const { return (p != NULL); }

    T* p;
  protected:
    T* Assign(T* lp) {
        if (lp != NULL)
            CRAddRefGC(lp);

        CRReleaseGC(p);

        p = lp;

        return lp;
    }
};

class CRLockGrabber
{
  public:
    CRLockGrabber() { CRAcquireGCLock(); }
    ~CRLockGrabber() { CRReleaseGCLock(); }
};


class SafeArrayAccessor
{
  public:
    SafeArrayAccessor(VARIANT & v,
                      bool allowNullArray = false);
    ~SafeArrayAccessor();

    unsigned int GetArraySize() { return _ubound - _lbound + 1; }

    IUnknown **GetArray() { return _isVar?_allocArr:_ppUnk; }

    bool IsOK() { return !_failed; }
  protected:
    SAFEARRAY * _s;
    union {
        VARIANT * _pVar;
        IUnknown ** _ppUnk;
        void * _v;
    };
    
    VARTYPE _vt;
    long _lbound;
    long _ubound;
    bool _inited;
    bool _isVar;
    CComVariant _retVar;
    bool _failed;
    IUnknown ** _allocArr;
};

inline WCHAR * CopyString(const WCHAR *str) {
    int len = str?lstrlenW(str)+1:1;
    WCHAR *newstr = new WCHAR [len] ;
    if (newstr) memcpy(newstr,str?str:L"",len * sizeof(WCHAR)) ;
    return newstr ;
}

#define ARRAY_SIZE(x) (sizeof(x) / sizeof((x)[0]))

#endif /* _UTIL_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\mmapi\dll\main.cpp ===
/*******************************************************************************
  Copyright (c) 1995-96 Microsoft Corporation

  Abstract:

    Initialization

 *******************************************************************************/

#include "headers.h"

HINSTANCE  hInst;

bool InitializeAllModules(void);
void DeinitializeAllModules(bool bShutdown);

extern "C" BOOL WINAPI _DllMainCRTStartup (HINSTANCE hInstance,
                                           DWORD dwReason,
                                           LPVOID lpReserved);

extern "C" BOOL WINAPI
_DllMainStartup(HINSTANCE hInstance, DWORD dwReason, LPVOID lpReserved)
{
    if (dwReason == DLL_PROCESS_DETACH) {
        // Call the routines in reverse order of initialization
        BOOL r = _DllMainCRTStartup(hInstance,dwReason,lpReserved);
        r = DALibStartup(hInstance,dwReason,lpReserved) && r;

        return r;
    } else {
        // In everything except DLL_PROCESS_DETACH call DALibStartup first
        return (DALibStartup(hInstance,dwReason,lpReserved) &&
                _DllMainCRTStartup(hInstance,dwReason,lpReserved));
    }
}

/////////////////////////////////////////////////////////////////////////////
// DLL Entry Point
extern "C"
BOOL WINAPI DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID lpReserved)
{
    if (dwReason == DLL_PROCESS_ATTACH) {
        hInst = hInstance;

        DisableThreadLibraryCalls(hInstance);

        // For APELDBG
        RESTOREDEFAULTDEBUGSTATE;

        if (!InitializeAllModules())
        {
            return FALSE;
        }
        
    } else if (dwReason == DLL_PROCESS_DETACH) {
        DeinitializeAllModules(lpReserved != NULL);

#if _DEBUG
        char buf[MAX_PATH + 1];
        
        GetModuleFileName(hInst, buf, MAX_PATH);
        
#if _DEBUGMEM
        TraceTag((tagLeaks, "\n[%s] unfreed memory:", buf));
        DUMPMEMORYLEAKS;
#endif

        // de-initialize the debug trace info.
        DeinitDebug();
#endif
    }
    
    return TRUE;
}

/////////////////////////////////////////////////////////////////////////////
// Used to determine whether the DLL can be unloaded by OLE

STDAPI DllCanUnloadNow(void)
{
    return (_Module.GetLockCount()==0) ? S_OK : S_FALSE;
}

/////////////////////////////////////////////////////////////////////////////
// Returns a class factory to create an object of the requested type

#ifdef _DEBUG
static bool breakDialog = false ;
DeclareTag(tagDebugBreak, "!Debug", "Breakpoint on entry to DLL");
#endif

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
#ifdef _DEBUG
    if (!breakDialog && IsTagEnabled(tagDebugBreak)) {
        char buf[MAX_PATH + 1];
        
        GetModuleFileName(hInst, buf, MAX_PATH);
        
        MessageBox(NULL,buf,"MMAPI - Creating first COM Object",MB_OK|MB_SETFOREGROUND) ;
        breakDialog = true;
    }
#endif

    return _Module.GetClassObject(rclsid, riid, ppv);
}

/////////////////////////////////////////////////////////////////////////////
// DllRegisterServer - Adds entries to the system registry

STDAPI DllRegisterServer(void)
{
    // registers object, typelib and all interfaces in typelib
    return _Module.RegisterServer(TRUE);
}

/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Removes entries from the system registry

STDAPI DllUnregisterServer(void)
{
    _Module.UnregisterServer();
    return S_OK;
}


#if _DEBUG
STDAPI_(void)
DoTraceTagDialog(HWND hwndStub,
                 HINSTANCE hAppInstance,
                 LPWSTR lpwszCmdLine,
                 int nCmdShow)
{
    DoTracePointsDialog(true);
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\make\make2.inc ===
# --------------------------------------------------------------
# LIBTARG
# --------------------------------------------------------------

!ifdef LIBTARG

!if "$(_NO_INCREMENTAL_LINK)" == "1" && "$(_LINK_WITH_OBJS)" == "0"

$(LIBTARG) : $(BLDDIR)\cxx.rsp $(LIBOBJS)
        $(DEL) $@
!ifdef SILENTMODE
        $(ECHO) Linking $@...
!endif
        $(LIBR) $(NOLOGO) -MACHINE:$(LINKMACHINE) @<<
        -OUT:$*.lib
        $(LIBOBJS: = ^
)
<<$(KEEPFLAGS)

!else

#
# For incremental linking we create a .lib file that is just a text file that
# contains a list of all the objs that would have gone into the lib.
#
$(LIBTARG) : $(BLDDIR)\cxx.rsp $(LIBOBJS)
        $(DEL) $@
        $(ECHO) Incrementally Linking $@...
# The following line creates a file with the name $(LIBTARG) that contains
#  the name of each object file on a separate line. SED is used to remove
#  blank lines.
        $(SED) "/^[ ]*$$/d" << >$@
$(LIBOBJS: = ^
)
<<$(KEEPFLAGS)

!endif

clean::
        $(DEL) $(LIBTARG)
        $(DEL) $(LIBTARG:.dll=.exp)
        $(DEL) $(LIBTARG:.dll=.lib)
!ifdef PDBFILE
        $(DEL) $(PDBFILE)
        $(DEL) $(PDBFILE:.pdb=.idb)
!endif

!endif

# -------------------------------------------------------------
# DLLTARG
# -------------------------------------------------------------

!ifdef DLLTARG


# How do we specify a resource-only DLL on the Mac?
!if "$(RESOURCE_ONLY)" == "1"  && "$(_MACHINE)" != "PPCMAC"
DLLENTRY=/NOENTRY
!else
!       if "$(_MACHINE)" == "PPCMAC"
DLLENTRY=-mac:init=WlmConnectionInit  -mac:term=WlmConnectionTerm
DLLMAC=-mac:NOMFILEPAD
!       else
DLLENTRY=/ENTRY:$(DLLENTRY)
DLLMAC=
!       endif
!endif

$(BLDDIR)\linkdll.rsp : $(DLLLIBS)
        @$(DEL) $(BLDDIR)\linkdll.rsp
        @$(DEL) $(BLDDIR)\linkdll.tmp
!if "$(DLLLIBS)" != ""
!  if "$(_NO_INCREMENTAL_LINK)" == "1" && "$(_LINK_WITH_OBJS)" == "0"
        @!echo $** >> $(BLDDIR)\linkdll.rsp
!  else
        @!type $** >> $(BLDDIR)\linkdll.tmp
        @$(SED) "y/ABCDEFGHIJKLMNOPQRSTUVWXYZ/abcdefghijklmnopqrstuvwxyz/" $(BLDDIR)\linkdll.tmp > $(BLDDIR)\linkdll.rsp
        $(DEL) $(BLDDIR)\linkdll.tmp
!  endif
!else
        @echo. > $(BLDDIR)\linkdll.rsp
!endif

$(DLLTARG) : $(BLDDIR)\cxx.rsp $(BLDDIR)\linkdll.rsp $(DLLOBJS) $(DLLXLIBS) $(PCHFILEOBJ) $(DLLDEF)
!ifdef SILENTMODE
!  if "$(_NO_INCREMENTAL_LINK)" == "1"
        $(ECHO) Linking $@...
!  else
        $(ECHO) Incrementally Linking $@...
!  endif
!endif
        $(LINK) $(LFLAGS) $(DLLMAC) /DEF:$(DLLDEF) /DLL /OUT:$(DLLTARG) /IMPLIB:$(SDKDIR)\$(@B).lib $(DLLENTRY) @$(BLDDIR)\linkdll.rsp @<<
$(DLLOBJS: =^
)
$(DLLXLIBS: =^
)
!if "$(_PROFILE)" == "1"
$(ICECAPLIB)
!endif
$(PCHFILEOBJ)
<<$(KEEPFLAGS)

!if "$(_MACHINE)"=="x86"
!if "$(_MAP)" != "0"
#        cd $(BINDIR)
        $(DEL) $(BINDIR)\$(@B).sym
        $(ECHO) Creating sym file: $(BINDIR)\$(@B).sym
        $(MAP2SYM) -o $(BINDIR)\$(@B).sym $(BINDIR)\$(@B).map
!endif
!endif


!if "$(_MACHINE)"=="PPCMAC"
$(MACTARG) : $(DLLTARG)
!       if "$(_MACSYMS)"=="1"
       $(DEL) $(@R).sym
       $(MAP2SYM) -n $(@R).sym $(@R).MAP
!       endif
!       if "$(_COPYMAC)"=="1"
#               MFILE requires that mrc.exe be in the executable path
                cd $(TOOLSBIN)
                $(MFILE) copy -n -c $(MACDLLCREATOR) -t shlb $(DLLTARG) \
                        "$(_MACFOLDER):$(@B).dll"
!               if "$(_MACSYMS)"=="1"
               $(MFILE) copy -n -c $(MACDLLCREATOR) -t TEXT $(@R).sym \
                       "$(_MACFOLDER):$(@B).sym"
!               endif
                cd $(ROOT)
                                @echo. > $(MACTARG)
!       endif
!endif



clean::
        $(DEL) $(DLLTARG)
        $(DEL) $(DLLTARG:.dll=.exp)
        $(DEL) $(DLLTARG:.dll=.lib)
        $(DEL) $(DLLTARG:.dll=.map)
        $(DEL) $(DLLTARG:.dll=.ilk)
        $(DEL) $(DLLTARG:.dll=.idb)
        $(DEL) $(DLLTARG:.dll=.dbg)
!ifdef PDBFILE
        $(DEL) $(PDBFILE)
        $(DEL) $(PDBFILE:.pdb=.idb)
!endif

!endif

# -------------------------------------------------------------
# EXETARG
# -------------------------------------------------------------

!ifdef EXETARG
!ifndef EXETYPE
!error EXETYPE must be console or windows for .exes
!endif

!if "$(_MACHINE)" == "PPCMAC"
EXEMAC=-mac:NOMFILEPAD -mac:bundle -mac:type=APPL -mac:creator=$(MACEXECREATOR)
!else
EXEMAC=
!endif

$(BLDDIR)\linkexe.rsp : $(EXELIBS)
        @$(DEL) $(BLDDIR)\linkexe.rsp
        @$(DEL) $(BLDDIR)\linkexe.tmp
!if "$(EXELIBS)" != ""
!  if "$(_NO_INCREMENTAL_LINK)" == "1" && "$(_LINK_WITH_OBJS)" == "0"
        @!echo $** >> $(BLDDIR)\linkexe.rsp
!  else
        @!type $** >> $(BLDDIR)\linkexe.tmp
        @$(SED) "y/ABCDEFGHIJKLMNOPQRSTUVWXYZ/abcdefghijklmnopqrstuvwxyz/" $(BLDDIR)\linkexe.tmp > $(BLDDIR)\linkexe.rsp
        $(DEL) $(BLDDIR)\linkexe.tmp
!  endif
!else
        @echo. > $(BLDDIR)\linkexe.rsp
!endif

$(EXETARG) : $(BLDDIR)\cxx.rsp $(BLDDIR)\linkexe.rsp $(EXEOBJS) $(EXEXLIBS) $(PCHFILEOBJ)
!ifdef SILENTMODE
!  if "$(_NO_INCREMENTAL_LINK)" == "1"
        $(ECHO) Linking $@...
!  else
        $(ECHO) Incrementally Linking $@...
!  endif
!endif
        $(LINK) $(LFLAGS) $(EXEMAC) -subsystem:$(EXETYPE) /OUT:$(EXETARG) @$(BLDDIR)\linkexe.rsp @<<
$(EXEOBJS: =^
)
$(EXEXLIBS: =^
)
!if "$(_PROFILE)" == "1"
$(ICECAPLIB)
!endif
$(PCHFILEOBJ)
<<$(KEEPFLAGS)

!if "$(_MACHINE)"=="PPCMAC"
$(MACTARG) : $(EXETARG)
!       if "$(_MACSYMS)"=="1"
        $(DEL) $(@B).sym
        $(MAP2SYM) -n $(@R).sym $(@R).MAP
!       endif
!   if "$(_COPYMAC)"=="1"
#       MFILE requires that mrc.exe be in the executable path
#                       (why doesn't PATH work here?)
                cd $(TOOLSBIN)
                $(MFILE) copy -n -c $(MACEXECREATOR) -t APPL $(@R).exe \
                                "$(_MACFOLDER):$(@B)"
!               if "$(_MACSYMS)"=="1"
                        $(MFILE) copy -n -c $(MACSYMCREATOR) -t TEXT $(@R).sym \
                                        "$(_MACFOLDER):$(@B).sym"
!               endif
                cd $(ROOT)
                @echo. > $(MACTARG)
!       endif
!endif

clean::
        $(DEL) $(EXETARG)
        $(DEL) $(EXETARG:.exe=.map)
        $(DEL) $(EXETARG:.exe=.ilk)
        $(DEL) $(EXETARG:.exe=.dbg)
!ifdef PDBFILE
        $(DEL) $(PDBFILE)
        $(DEL) $(PDBFILE:.pdb=.idb)
!endif

!endif

# -------------------------------------------------------------
# Browse
# -------------------------------------------------------------

!if defined(EXETARG)
BROWSETARG=$(EXETARG:.exe=.bsc)
!elseif defined(DLLTARG)
BROWSETARG=$(DLLTARG:.dll=.bsc)
!else
BROWSETARG=$(BLDROOT)\browse.bsc
!endif

browse:
        $(ECHO) /o $(BROWSETARG) /n > $(TMPDIR)\bsc1.tmp
        -DIR /s/b $(ROOT)\tools\x86\msvc\include\*.h > $(TMPDIR)\bsc2.tmp
        $(SED) -e "s/^/\/Ei/" $(TMPDIR)\bsc2.tmp >> $(TMPDIR)\bsc1.tmp
        -DIR /s/b $(BLDROOT)\*.sbr >> $(TMPDIR)\bsc1.tmp
        $(BSCMAKE) $(NOLOGO) @$(TMPDIR)\bsc1.tmp
        $(DEL) $(TMPDIR)\bsc1.tmp
        $(DEL) $(TMPDIR)\bsc2.tmp

# -------------------------------------------------------------
# Other Targets
# -------------------------------------------------------------

beep:
        @ECHO 

clean::
        $(DELALL) $(BLDDIR)\*.*

fresh: clean depend nmake_all

nmake_all::
        nmake all

FULLMAKE=$(MAKE) /$(MAKEFLAGS: =) $(NOLOGO) -f $(SRCROOT)\make\master.mak _RELEASE=$(_RELEASE) SRCROOT=$(SRCROOT) $(MODULE)

fclean:
        $(FULLMAKE) TARGET=clean

fdepend:
        $(FULLMAKE) TARGET=depend

fall:
        $(FULLMAKE) TARGET=all

ffresh: fclean fdepend fall

maccopy::

# -------------------------------------------------------------
# cxx.rsp
# -------------------------------------------------------------

$(BLDDIR)\cxx.rsp : makefile $(SRCROOT)\make\make1.inc $(SRCROOT)\make\make2.inc
    $(COPY) << $(BLDDIR)\cxx.rsp
/I$(INCLUDEPATH:;=
/I)
$(CFLAGS: =
)
$(PCHFLAGS: =
)
/Fo$(BLDDIR)\
/c
<<$(KEEPFLAGS)


# -------------------------------------------------------------
# Depend
# -------------------------------------------------------------

depend::
        $(SET) INCLUDE=
!ifdef PCHFILE
!if exist($(PCHFILE).h)
        $(MKDEP) @<< > $(TMPDIR)\depend.tmp
-n
/I $(INCLUDEDIRS: =
/I )
-s.obj
-P $(BLDDIR)\
*.cpp
*.cxx
*.c
$(BLDDIR)\*.cpp
$(BLDDIR)\*.cxx
$(BLDDIR)\*.c
$(PCHFILE).h
<<$(KEEPFLAGS)
        $(SED) -f << $(TMPDIR)\depend.tmp > $(BLDDIR)\depend.inc
s/$(BLDDIR:\=\\)\\$(PCHFILE)\.obj :/$(PCHPATH:\=\\)\\$(PCHFILE).pch : $(BLDDIR:\=\\)\\cxx.rsp $(PCHFILE).h/
s/\.obj :/.obj : $(BLDDIR:\=\\)\\cxx.rsp $(PCHPATH:\=\\)\\$(PCHFILE).pch/
<<$(KEEPFLAGS)
!else
        $(MKDEP) @<< > $(TMPDIR)\depend.tmp
-d$(PCHFILE).h
-n
/I $(INCLUDEDIRS: =
/I )
-s.obj
-P $(BLDDIR)\
*.cpp
*.cxx
*.c
$(BLDDIR)\*.cpp
$(BLDDIR)\*.cxx
$(BLDDIR)\*.c
<<$(KEEPFLAGS)
        $(SED) -f << $(TMPDIR)\depend.tmp > $(BLDDIR)\depend.inc
s/\.obj :/.obj : $(BLDDIR:\=\\)\\cxx.rsp $(PCHPATH:\=\\)\\$(PCHFILE).pch/
<<$(KEEPFLAGS)
!endif
        $(DEL) $(TMPDIR)\depend.tmp
!else
        $(MKDEP) @<< > $(BLDDIR)\depend.inc
-n
/I $(INCLUDEDIRS: =
/I )
-s.obj
-P $(BLDDIR)\
*.cpp
*.cxx
*.c
$(BLDDIR)\*.cpp
$(BLDDIR)\*.cxx
$(BLDDIR)\*.c
<<$(KEEPFLAGS)
!endif

!if exist($(BLDDIR)\depend.inc)
!include "$(BLDDIR)\depend.inc"
!endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\mmapi\include\resource.h ===
/*******************************************************************************

Copyright (c) 1998_98 Microsoft Corporation

Abstract:

    MMAPI Resources

*******************************************************************************/


#ifndef _RESOURCE_H
#define _RESOURCE_H

#define RESID_TYPELIB           1

#endif /* _RESOURCE_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\mmapi\rsrc\makefile.inc ===
$(PROJNAME).rc : $(SDK_LIB_PATH)\$(PROJNAME).tlb
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\mmapi\dll\oleobj.cpp ===
/*******************************************************************************
 *
 * Copyright (c) 1998 Microsoft Corporation
 *
 * File: oleobj.cpp
 *
 * Abstract:
 *
 *
 *
 *******************************************************************************/


#include "headers.h"
#include "src\mmfactory.h"
#include "dartapi.h"

DeclareTag(tagLockCount,"COM","Lock count");

DAComModule _Module;
extern HINSTANCE hInst;

BEGIN_OBJECT_MAP(COMObjectMap)
    OBJECT_ENTRY(CLSID_MMFactory, CMMFactory)
END_OBJECT_MAP()

bool bFailedLoad = false;

#define EXCEPTION(t) (GetExceptionCode() == t ? EXCEPTION_EXECUTE_HANDLER : EXCEPTION_CONTINUE_SEARCH )

LONG
DAComModule::Lock()
{
    // Can't depend on value return from Lock to be accurate.  Since
    // the CRConnect can be called multiple times w/o a problem simply
    // check the internal variable to see if it is 0.  This should
    // never cause anything except multiple calls to CRConnect
    
    bool bNeedConnect = (GetLockCount() == 0);

    LONG l = CComModule::Lock();

    TraceTag((tagLockCount,
              "DAComModule::Lock - new lockcount - %d, returned - %d",
              _Module.GetLockCount(),
              l));
    
    if (bNeedConnect) {
        __try {
            CRConnect(hInst);
        } __except (  EXCEPTION_EXECUTE_HANDLER ) {
            bFailedLoad = true;
        }
    }

    return l;
}

LONG
DAComModule::Unlock()
{
    LONG l = CComModule::Unlock();

    TraceTag((tagLockCount,
              "DAComModule::Unlock - new lockcount - %d, returned - %d",
              _Module.GetLockCount(),
              l));
    
    if (l) return l;
    if (!bFailedLoad)
        CRDisconnect(hInst);
    return 0;
}

#if DEVELOPER_DEBUG
#include <map>

typedef std::map<void *, const char *> ObjectMap;
ObjectMap *objMap = NULL;

void
DAComModule::AddComPtr(void *ptr, const char * name)
{
    EnterCriticalSection(&m_csObjMap);
    (*objMap)[ptr] = name;
    LeaveCriticalSection(&m_csObjMap) ;
}

void
DAComModule::RemoveComPtr(void *ptr)
{
    EnterCriticalSection(&m_csObjMap);
    objMap->erase(ptr);
    LeaveCriticalSection(&m_csObjMap) ;
}

void
DAComModule::DumpObjectList()
{
    if (objMap) {
        EnterCriticalSection(&m_csObjMap);
        if (objMap->size() > 0 || GetLockCount() > 0) {
            OutputDebugString ("MMAPI.DLL: Detected unfreed COM pointers\n");
            OutputDebugString ("Listing pointers and types:\n");
            for (ObjectMap::iterator i = objMap->begin();
                 i != objMap->end();
                 i++) {

                char buf[1024];

                wsprintf(buf, "%#x:", (*i).first);
                OutputDebugString(buf);

                if ((*i).second)
                    OutputDebugString((*i).second);

                OutputDebugString("\n");
            }
        }
             
        LeaveCriticalSection(&m_csObjMap) ;
    }
}

void
DumpCOMObjectList()
{
    _Module.DumpObjectList();
}

#endif

bool
InitializeModule_ATL()
{
    _Module.Init(COMObjectMap, hInst);

#if DEVELOPER_DEBUG
    objMap = NEW ObjectMap;
#endif

    return true;
}

void
DeinitializeModule_ATL(bool bShutdown)
{
#if DEVELOPER_DEBUG
    DumpCOMObjectList();
    
    delete objMap;
    objMap = NULL;
#endif
    
    _Module.Term();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\mmapi\include\headers.h ===
/*******************************************************************************
Copyright (c) 1995-96 Microsoft Corporation

    Precompiled headers for mmapi.dll
*******************************************************************************/

#ifndef MMAPI_HEADERS_HXX
#define MMAPI_HEADERS_HXX

/* Standard */
#include <math.h>
#include <stdio.h>
#include <stddef.h>
#include <stdlib.h>
#include <string.h>
#include <malloc.h>
#include <memory.h>
#include <wtypes.h>

// Warning 4786 (identifier was truncated to 255 chars in the browser
// info) can be safely disabled, as it only has to do with generation
// of browsing information.
#pragma warning(disable:4786)

#include "apeldbg/apeldbg.h"

// ATL - needs to be before windows.h
#include "daatl.h"

/* Windows */
#include <windows.h>
#include <windowsx.h>

/* C++ Replace DLL */
#include "dalibc.h"

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\mmapi\src\headers.h ===
/*******************************************************************************

Copyright (c) 1995_96 Microsoft Corporation

Abstract:

    {Insert General Comment Here}

*******************************************************************************/


#ifndef _HEADERS_H
#define _HEADERS_H

#include "include/headers.h"
#include "mmapi.h"
#include "dacomutil.h"
#include "dartapi.h"
#include "util.h"
#include <list>

#endif /* _HEADERS_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\mmapi\src\mmbvr.cpp ===
/*******************************************************************************

Copyright (c) 1995-96 Microsoft Corporation

Abstract:

    {Insert General Comment Here}

*******************************************************************************/


#include "headers.h"
#include "mmbvr.h"
#include "mmtimeline.h"

DeclareTag(tagBvr, "API", "CMMBehavior methods");

CMMBehavior::CMMBehavior()
{
    TraceTag((tagBvr,
              "CMMBehavior(%lx)::CMMBehavior()",
              this));
}

CMMBehavior::~CMMBehavior()
{
    TraceTag((tagBvr,
              "CMMBehavior(%lx)::~CMMBehavior()",
              this));
}

HRESULT
CMMBehavior::Init(LPOLESTR id, IDABehavior * dabvr)
{
    TraceTag((tagBvr,
              "CMMBehavior(%lx)::Init(%ls, %lx)",
              this,
              id,
              dabvr));

    HRESULT hr;
    
    CRBvrPtr bvr;
    
    if (!dabvr)
    {
        hr = E_INVALIDARG;
        goto done;
    }

    bvr = COMToCRBvr(dabvr);

    if (!bvr)
    {
        hr = CRGetLastError();
        goto done;
    }

    hr = BaseInit(id, bvr);

    if (FAILED(hr))
    {
        goto done;
    }
    
    hr = S_OK;
  done:
    return hr;
}

HRESULT
CMMBehavior::Error()
{
    LPCWSTR str = CRGetLastErrorString();
    HRESULT hr = CRGetLastError();
    
    TraceTag((tagError,
              "CMMBehavior(%lx)::Error(%hr,%ls)",
              this,
              hr,
              str?str:L"NULL"));

    if (str)
        return CComCoClass<CMMBehavior, &__uuidof(CMMBehavior)>::Error(str, IID_IMMBehavior, hr);
    else
        return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\mmapi\src\mmbasebvr.h ===
/*******************************************************************************

Copyright (c) 1995_96 Microsoft Corporation

Abstract:

    {Insert General Comment Here}

*******************************************************************************/


#ifndef _MMBASEBVR_H
#define _MMBASEBVR_H

#define MM_INFINITE HUGE_VAL

class CMMTimeline;
class CMMBehavior;
class CMMPlayer;

extern TAG tagBaseBvr;

class CallBackData;
typedef std::list<CallBackData *> CallBackList;

class CMMBaseBvr;
typedef std::list<CMMBaseBvr*> MMBaseBvrList;

class
ATL_NO_VTABLE CMMBaseBvr
    : public CComObjectRootEx<CComSingleThreadModel>
{
  public:
    CMMBaseBvr();
    virtual ~CMMBaseBvr();
    
    STDMETHOD_(ULONG,AddRef)(void) = 0;
    STDMETHOD_(ULONG,Release)(void) = 0;
    STDMETHOD(QueryInterface)(REFIID iid, void ** ppvObject) = 0;
    
    // We cannot put the real one here since the typecast causes it to
    // get the wrong vtables
    static HRESULT WINAPI
        BaseInternalQueryInterface(CMMBaseBvr* pThis,
                                   void * pv,
                                   const _ATL_INTMAP_ENTRY* pEntries,
                                   REFIID iid,
                                   void** ppvObject);

    // This must be in the derived class and not the base class since
    // the typecast down to the base class messes things up
    // Add a dummy one to assert just in case the derived class does
    // not add one
    static inline HRESULT WINAPI
        InternalQueryInterface(CMMBaseBvr* pThis,
                               const _ATL_INTMAP_ENTRY* pEntries,
                               REFIID iid,
                               void** ppvObject)
    {
        AssertStr(false, "InternalQueryInterface not defined in base class");
        return E_FAIL;
    }
    
    HRESULT BaseInit(LPWSTR id, CRBvrPtr rawbvr);

#if _DEBUG
    virtual const char * GetName() { return "CMMBaseBvr"; }
#endif

    // Base interface functions
    
    HRESULT GetID(LPOLESTR *);
    HRESULT SetID(LPOLESTR);
        
    HRESULT GetStartOffset(float *);
    HRESULT SetStartOffset(float);
        
    HRESULT GetDuration(float * pd);
    HRESULT SetDuration(float d);
        
    HRESULT GetRepeat(LONG * pr);
    HRESULT SetRepeat(LONG r);
       
    HRESULT GetAutoReverse(VARIANT_BOOL * pr);
    HRESULT SetAutoReverse(VARIANT_BOOL r);
        
    HRESULT GetRepeatDur(float *);
    HRESULT SetRepeatDur(float);
        
    HRESULT GetEndOffset(float *);
    HRESULT SetEndOffset(float);
        
    HRESULT GetEaseIn(float * pd);
    HRESULT SetEaseIn(float d);

    HRESULT GetEaseInStart(float * pd);
    HRESULT SetEaseInStart(float d);

    HRESULT GetEaseOut(float * pd);
    HRESULT SetEaseOut(float d);

    HRESULT GetEaseOutEnd(float * pd);
    HRESULT SetEaseOutEnd(float d);

    HRESULT GetEventCB(IMMEventCB ** ev);
    HRESULT SetEventCB(IMMEventCB * ev);
        
    HRESULT GetTotalTime(float * pd);
        
    HRESULT GetDABehavior(REFIID riid, void **);

    HRESULT Begin(bool bAfterOffset);
    HRESULT End();
    HRESULT Pause();
    HRESULT Resume();
    HRESULT Seek(double lTime);
    
    HRESULT GetLocalTime(double * d);

    HRESULT GetPlayState(MM_STATE * state);
    
    // Accessors

    CRBvrPtr GetRawBvr() { return m_rawbvr; }
    CRBvrPtr GetResultantBvr() { return m_resultantbvr; }
    float GetStartOffset() { return m_startOffset; }
    float GetDuration() { return m_duration; }
    float GetEndOffset() { return m_endOffset; }
    float GetRepeatDuration() { return m_repDuration; }
    long GetRepeat() { return m_repeat; }
    bool GetAutoReverse() { return m_bAutoReverse; }
    IMMEventCB * GetEventCB() { return m_eventcb; }
    float GetEaseIn() { return m_easeIn; }
    float GetEaseInStart() { return m_easeInStart; }
    float GetEaseOut() { return m_easeOut; }
    float GetEaseOutEnd() { return m_easeOutStart; }
    
    float GetTotalRepDuration() { return m_totalRepDuration; }
    float GetTotalDuration() { return m_totalDuration; }
    float GetStartTime() { return m_startOffset; }
    float GetEndTime() { return m_startOffset + m_totalRepDuration; }
    float GetAbsStartTime() { return m_absStartTime; }
    float GetAbsEndTime() { return m_absEndTime; }
    
    double GetCurrentLocalTime();
    
    CMMBaseBvr * GetParent() { return m_parent; }
    CMMPlayer * GetPlayer() { return m_player; }

    // This will call all the behaviors which are currently running
    // with the given event.  This is used when the timeline needs to
    // process a specific event like Pause/Resume/Stop/Play.
    
    bool ProcessEvent(CallBackList & l,
                      double time,
                      bool bFirstTick,
                      MM_EVENT_TYPE et);
    
    virtual bool _ProcessEvent(CallBackList & l,
                               double time,
                               bool bFirstTick,
                               MM_EVENT_TYPE et,
                               bool bNeedsReverse) { return true; }
    
    bool ProcessCB(CallBackList & l,
                   double lastTick,
                   double curTime,
                   bool bForward,
                   bool bFirstTick,
                   bool bNeedPlay);

    virtual bool _ProcessCB(CallBackList & l,
                            double lastTick,
                            double curTime,
                            bool bForward,
                            bool bFirstTick,
                            bool bNeedPlay,
                            bool bNeedsReverse) { return true; }

    virtual bool EventNotify(CallBackList &l,
                             double lTime,
                             MM_EVENT_TYPE et);
    
    virtual bool ParentEventNotify(CMMBaseBvr * bvr,
                                   double lTime,
                                   MM_EVENT_TYPE et)
    { return true; }
    
    virtual void Invalidate();
    
    virtual bool ConstructBvr(CRNumberPtr timeline);
    virtual void DestroyBvr();
    virtual bool ResetBvr();
    
    bool SetParent(CMMBaseBvr * parent,
                   MM_START_TYPE st,
                   CMMBaseBvr * startSibling);
    bool ClearParent();

    bool AttachToSibling();
    void DetachFromSibling();
    
    virtual void SetPlayer(CMMPlayer * player);
    virtual void ClearPlayer();

    //returns the number CRBvr that represents the start time of this MMBehavior in parent time
    CRNumberPtr GetStartTimeBvr() { return m_startTimeBvr; }
    //returns the number CRBvr that represents the stop time of this MMBehavior in the parent time.
    CRNumberPtr GetEndTimeBvr() { return m_endTimeBvr; }

    CMMBaseBvr *GetStartSibling() { return m_startSibling; }
    CMMBaseBvr *GetEndSibling() { return m_endSibling; }
    MM_START_TYPE GetStartType() { return m_startType; }

#if _DEBUG
    void Print(int spaces);
#endif
  protected:
    
    bool UpdateAbsStartTime(float f);
    bool UpdateAbsEndTime(float f);
    
    bool UpdateResultantBvr(CRBvrPtr bvr);
    void ClearResultantBvr();
    
    CRBvrPtr EncapsulateBvr(CRBvrPtr rawbvr);
    
    void CalculateEaseCoeff();

    // This will take the time behavior and ease it
    CRNumberPtr EaseTime(CRNumberPtr time);

    // This will take the given time and transform it to the correct
    // eased time
    // If the time is outside of our duration (i.e. <0 or >
    // m_duration) this will just return the given time
    double EaseTime(double time);

    virtual bool IsContinuousMediaBvr() { return false; }

    void UpdateTotalDuration();

    // Sibling dependency management
    bool AddStartTimeSink(CMMBaseBvr * sink);
    void RemoveStartTimeSink(CMMBaseBvr * sink);
    bool AddEndTimeSink(CMMBaseBvr* sink);
    void RemoveEndTimeSink(CMMBaseBvr* sink);

    // methods for the propagation of start times and end times.
    // The time passed in is the local time of the parent which we are
    // suppose to start on

    // This is where all the wiring gets hooked up
    // Basicly once we determine what our start time is we can then
    // propagate this information to all of our dependents and allow
    // them to in turn do the same

    bool StartTimeVisit(double time,
                        CallBackList & l,
                        bool bAfterOffset);

    // It is pretty much the same for the end time.  This can be
    // called when our start time is set if we know the duration and
    // will also be called for indeterminate durations or event
    // ending.
    
    bool EndTimeVisit(double time, CallBackList & l);

    bool UpdateTimeControl();

    virtual HRESULT Error() = 0;

    double GetContainerTime();

    bool IsPlaying() { return (GetCurrentLocalTime() != MM_INFINITE); }

    //
    // DATA declarations
    //
  protected:
    LPWSTR m_id;
    float m_startOffset;
    float m_duration;
    float m_repeatDur;
    long m_repeat;
    bool m_bAutoReverse;
    float m_endOffset;
    float m_easeIn;
    float m_easeInStart;
    float m_easeOut;
    float m_easeOutEnd;

    // These are the absolute local times which correspond to when the
    // behavior really starts and really ends - not including start
    // and end offsets.
    float m_absStartTime;
    float m_absEndTime;

    DAComPtr<IMMEventCB> m_eventcb;

    //The way in which this behavior begins.  Can be any of the enum MM_START_TYPE
    MM_START_TYPE m_startType;
    //if this behavior is begin with or after this holds the sibling
    //  that controls when we start.
    CMMBaseBvr *m_startSibling;
    //if this behavior is end with this holds the sibling that controls
    //  when we stop.
    CMMBaseBvr *m_endSibling;

    //TODO: these could be allocated as needed.  They may be fairly rarely used.
    MMBaseBvrList m_startTimeSinks;
    MMBaseBvrList m_endTimeSinks;

    // These behaviors represent the local begin and end times for
    // this behavior.  Siblings can reference these to place
    // themselves relatively according to start with/after and
    // endwith.
    
    CRPtr<CRNumber> m_startTimeBvr;
    CRPtr<CRNumber> m_endTimeBvr;

    // This represents the time sub we are using for the behavior
    // For beginafter/with this points to the siblings appropriate
    // behavior, for an event it points to infinity until the start
    // time is known, and for an absolute it is simply local time.
    // This also allows us to implement slipSync since we can use to
    // adjust ourselves as we need it
    
    CRPtr<CRNumber> m_timeControl;

    // A single segment duration
    float m_segDuration;
    
    // The duration for a single rep of a behavior
    float m_repDuration;

    // Total duration we calculate for a regular behavior 
    float m_totalRepDuration; 

    // The real duration determine by adding totalrepduration + start + end
    float m_totalDuration;

    CRPtr<CRBvr> m_rawbvr;
    CMMBaseBvr * m_parent;
    CR_BVR_TYPEID m_typeId;
    CMMPlayer * m_player;

    CRPtr<CRBvr> m_resultantbvr;
    long m_cookie;
    
    // The ease-in/out behavior modifier is applied using timeline
    // substitution.  The substitute timeline consists of three pieces
    // A, B and C, which are the ease-in, constant velocity and ease-out
    // parts respectively.  For B, a linear timeline is substituted; for
    // A and C, a quadratic warping of the input time is required.

    float m_flA0, m_flA1, m_flA2; // coefficients for the A piece
    float m_flB0, m_flB1;         // coefficients for the B piece
    float m_flC0, m_flC1, m_flC2; // coefficients for the C piece

    // These are the times to perform ease in/out
    float m_easeInEnd;
    float m_easeOutStart;
    bool m_bNeedEase;
};

class CallBackData
{
  public:
    CallBackData(IMMBehavior * bvr,
                 IMMEventCB * eventcb,
                 double time,
                 MM_EVENT_TYPE et);
    ~CallBackData();

    HRESULT CallEvent();

  protected:
    DAComPtr<IMMBehavior> m_bvr;
    double m_time;
    MM_EVENT_TYPE m_et;
    DAComPtr<IMMEventCB> m_eventcb;
};

bool ProcessCBList(CallBackList &l);

#if _DEBUG
inline char * EventString(MM_EVENT_TYPE et) {
    switch(et) {
      case MM_PLAY_EVENT:
        return "Play";
      case MM_STOP_EVENT:
        return "Stop";
      case MM_PAUSE_EVENT:
        return "Pause";
      case MM_RESUME_EVENT:
        return "Resume";
      case MM_REPEAT_EVENT:
        return "Repeat";
      case MM_AUTOREVERSE_EVENT:
        return "Autoreverse";
      default:
        return "Unknown";
    }
}
#endif

CMMBaseBvr * GetBvr(IUnknown *);

#endif /* _MMBASEBVR_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\mmapi\src\mmbasebvr.cpp ===
/*******************************************************************************
 *
 * Copyright (c) 1998 Microsoft Corporation
 *
 * File: mmbasebvr.cpp
 *
 * Abstract:
 *
 *
 *
 *******************************************************************************/

#include "headers.h"
#include "mmbasebvr.h"
#include "mmplayer.h"

DeclareTag(tagBaseBvr, "API", "CMMBaseBvr methods");

CMMBaseBvr::CMMBaseBvr()
  // The DA bvr we are referencing and its type
: m_id(NULL),
  m_rawbvr(NULL),
  m_typeId(CRINVALID_TYPEID),

  // Basic timing properties - only used to store values
  m_startOffset(0),
  m_duration(-1),
  m_repeatDur(-1),
  m_repeat(1),
  m_bAutoReverse(false),
  m_endOffset(0),
  m_easeIn(0.0),
  m_easeInStart(0.0),
  m_easeOut(0.0),
  m_easeOutEnd(0.0),

  // Calculated times
  m_totalDuration(0.0),
  m_segDuration(0.0),
  m_repDuration(0.0),
  m_totalRepDuration(0.0),
  m_absStartTime( MM_INFINITE ),
  m_absEndTime( MM_INFINITE ),

  m_player(NULL),
  m_parent(NULL),
  m_startSibling(NULL),
  m_endSibling(NULL),
  m_startType(MM_START_ABSOLUTE),

  m_cookie(0)
{
    TraceTag((tagBaseBvr,
              "CMMBaseBvr(%lx)::CMMBaseBvr()",
              this));
}

CMMBaseBvr::~CMMBaseBvr()
{
    TraceTag((tagBaseBvr,
              "CMMBaseBvr(%lx)::~CMMBaseBvr()",
              this));

    delete m_id;
}

HRESULT
CMMBaseBvr::BaseInit(LPOLESTR id, CRBvrPtr rawbvr)
{
    TraceTag((tagBaseBvr,
              "CMMBaseBvr(%lx)::BaseInit(%ls, %#lx)",
              id,
              rawbvr));
    
    HRESULT hr;

    CRLockGrabber __gclg;

    Assert(rawbvr);

    m_rawbvr = rawbvr;
    
    m_typeId = CRGetTypeId(m_rawbvr);
    
    Assert(m_typeId != CRUNKNOWN_TYPEID &&
           m_typeId != CRINVALID_TYPEID);
    
    m_startTimeBvr = CRModifiableNumber(MM_INFINITE);
    
    if (!m_startTimeBvr)
    {
        hr = CRGetLastError();
        goto done;
    }
    
    m_endTimeBvr = CRModifiableNumber(MM_INFINITE);

    if (!m_endTimeBvr)
    {
        hr = CRGetLastError();
        goto done;
    }
    
    m_timeControl = CRModifiableNumber(MM_INFINITE);

    if (!m_timeControl)
    {
        hr = CRGetLastError();
        goto done;
    }
    
    UpdateTotalDuration();
    
    if (id)
    {
        m_id = CopyString(id);
        
        if (m_id == NULL)
        {
            hr = E_OUTOFMEMORY;
            goto done;
        }
    }
    
    hr = S_OK;

  done:
    return hr;
}

void
CMMBaseBvr::UpdateTotalDuration()
{
    if (m_duration == -1)
    {
        m_segDuration = MM_INFINITE;
    }
    else
    {
        m_segDuration = m_duration;
    }
    
    if (m_bAutoReverse)
    {
        m_repDuration = m_segDuration * 2;
    }
    else
    {
        m_repDuration = m_segDuration;
    }
        
    if (m_repeatDur != -1)
    {
        m_totalRepDuration = m_repeatDur;
    }
    else
    {
        m_totalRepDuration = m_repeat * m_repDuration;
    }

    m_totalDuration = m_startOffset + m_totalRepDuration + m_endOffset;
}

void
CMMBaseBvr::Invalidate()
{
    TraceTag((tagBaseBvr,
              "CMMBaseBvr(%lx)::Invalidate()",
              this));

    UpdateTotalDuration();
    
    if (m_parent)
    {
        m_parent->Invalidate();
    }
}

bool
CMMBaseBvr::SetParent(CMMBaseBvr * parent,
                      MM_START_TYPE st,
                      CMMBaseBvr * startSibling)
{
    bool ok = false;
    
    // These will be cleared if we are called correctly
    
    Assert(!m_resultantbvr);
    Assert(m_parent == NULL);
    Assert(m_startTimeSinks.size() == 0);
    Assert(m_endTimeSinks.size() == 0);

    // Validate parameters

    switch (st)
    {
      case MM_START_ABSOLUTE:
        // This is not absolutely necessary but will ensure that if we
        // ever want to take a parameter we know that old code had
        // ensured that it was NULL
        
        if (startSibling != NULL)
        {
            CRSetLastError(E_INVALIDARG, NULL);
            goto done;
        }

        if (!UpdateAbsStartTime(m_startOffset))
        {
            goto done;
        }

        break;
      case MM_START_EVENT:
        // This is not absolutely necessary but will ensure that if we
        // ever want to take a parameter we know that old code had
        // ensured that it was NULL
        
        if (startSibling != NULL)
        {
            CRSetLastError(E_INVALIDARG, NULL);
            goto done;
        }

        if (!UpdateAbsStartTime(MM_INFINITE))
        {
            goto done;
        }

        break;
      case MM_START_WITH:
      case MM_START_AFTER:
        if (startSibling == NULL)
        {
            CRSetLastError(E_INVALIDARG, NULL);
            goto done;
        }

        if (!UpdateAbsStartTime(MM_INFINITE))
        {
            goto done;
        }

        break;
      default:
        CRSetLastError(E_INVALIDARG, NULL);
        goto done;
    }
    
    if (!UpdateAbsEndTime(GetAbsStartTime() + GetTotalRepDuration()))
    {
        goto done;
    }

    // Update args now that we know they are valid

    m_startType = st;
    m_startSibling = startSibling;
    m_parent = parent;

    ok = true;
  done:
    return ok;
}

bool
CMMBaseBvr::ClearParent()
{
    DetachFromSibling();
    
    m_startSibling = NULL;
    m_startType = MM_START_ABSOLUTE;
    m_parent = NULL;
  
    // There is no way for us to ensure this properly (since
    // dependents have no root anymore and our container usually
    // handles this), so our parent better have dealt with it
    
    Assert(m_startTimeSinks.size() == 0);
    Assert(m_endTimeSinks.size() == 0);

    // Just in case
    m_startTimeSinks.clear();
    m_endTimeSinks.clear();

    // Our resultant bvr is no longer valid - clear all constructed
    // behaviors
    DestroyBvr();

    UpdateAbsStartTime(MM_INFINITE);
    UpdateAbsEndTime(MM_INFINITE);

    return true;
}

bool
CMMBaseBvr::AttachToSibling()
{
    TraceTag((tagBaseBvr,
              "CMMBaseBvr(%lx)::AttachToSibling()",
              this));
    
    bool ok = false;
    switch(m_startType)
    {
      case MM_START_ABSOLUTE:
        Assert(m_startSibling == NULL);

        if (!UpdateAbsStartTime(m_startOffset))
        {
            goto done;
        }

        break;
      case MM_START_EVENT:
        Assert(m_startSibling == NULL);

        if (!UpdateAbsStartTime(MM_INFINITE))
        {
            goto done;
        }

        break;
      case MM_START_WITH:
        Assert(m_startSibling != NULL);

        // The sibling better have the same parent and it also should not
        // be NULL since it should have been added first
        
        Assert(m_startSibling->GetParent() != NULL);
        Assert(m_startSibling->GetParent() == m_parent);
        
        if (!m_startSibling->AddStartTimeSink(this))
        {
            goto done;
        }
        
        // Our absolute start time is the start time of the sibling
        // plus our start offset
        if (!UpdateAbsStartTime(m_startSibling->GetAbsStartTime() + m_startOffset))
        {
            goto done;
        }

        break;
      case MM_START_AFTER:
        Assert(m_startSibling != NULL);

        // The sibling better have the same parent and it also should not
        // be NULL since it should have been added first
        
        Assert(m_startSibling->GetParent() != NULL);
        Assert(m_startSibling->GetParent() == m_parent);
        
        if (!m_startSibling->AddEndTimeSink(this))
        {
            goto done;
        }
        
        if (!UpdateAbsStartTime(m_startSibling->GetAbsEndTime() + m_startOffset))
        {
            goto done;
        }

        break;
      default:
        Assert(!"CMMBaseBvr::AttachToSibling: Invalid start type");
        break;
    }

    if (!UpdateAbsEndTime(GetAbsStartTime() + GetTotalRepDuration()))
    {
        goto done;
    }

    ok = true;
  done:
    return ok;
}

void
CMMBaseBvr::DetachFromSibling()
{
    TraceTag((tagBaseBvr,
              "CMMBaseBvr(%lx)::DetachFromSibling()",
              this));
    
    switch(m_startType)
    {
      case MM_START_ABSOLUTE:
      case MM_START_EVENT:
        Assert(m_startSibling == NULL);
        break;
      case MM_START_WITH:
        Assert(m_startSibling != NULL);
        m_startSibling->RemoveStartTimeSink(this);
        break;
      case MM_START_AFTER:
        Assert(m_startSibling != NULL);
        m_startSibling->RemoveEndTimeSink(this);
        break;
      default:
        Assert(!"CMMBaseBvr::DetachFromSibling: Invalid start type");
        break;
    }
}

void
CMMBaseBvr::SetPlayer(CMMPlayer * player)
{
    Assert(m_player == NULL);
    Assert(!m_resultantbvr);
    
    m_player = player;
}

void
CMMBaseBvr::ClearPlayer()
{
    // We do not need to call Destroy since the clearplayer will do
    // the recursive calls and that would just waste time
    // Our resultant bvr is no longer valid
    ClearResultantBvr();

    m_player = NULL;
}

bool
CMMBaseBvr::ConstructBvr(CRNumberPtr timeline)
{
    TraceTag((tagBaseBvr,
              "CMMBaseBvr(%lx)::ConstructBvr(%#lx)",
              this,
              timeline));

    bool ok = false;
    
    Assert(!m_resultantbvr);
    // We should never be able to do this w/o a player
    Assert(m_player != NULL);
    
    // Need the GC Lock
    CRLockGrabber __gclg;
    
    CRBvrPtr bvr;

    if ((bvr = EncapsulateBvr(m_rawbvr)) == NULL)
    {
        goto done;
    }

    // First substitute our own control so inside the control we will
    // always refer to local time and it will actually be the local
    // time of the parent since we subst time with the containers
    // timeline after this
    if ((bvr = CRSubstituteTime(bvr, m_timeControl)) == NULL)
    {
        goto done;
    }
    
    // Now subst time the container timer
    
    if ((bvr = CRSubstituteTime(bvr, timeline)) == NULL)
    {
        goto done;
    }
    
    // Update the time control to be consistent with our current state
    // since at this point it has never been set before.
    
    if (!UpdateTimeControl())
    {
        goto done;
    }
    
    // Store away the new bvr in our resultant behavior
    if (!UpdateResultantBvr(bvr))
    {
        goto done;
    }
    
    ok = true;
  done:
    return ok;
}

void
CMMBaseBvr::DestroyBvr()
{
    TraceTag((tagBaseBvr,
              "CMMBaseBvr(%lx)::DestroyBvr()",
              this));

    ClearResultantBvr();
}

bool
CMMBaseBvr::UpdateResultantBvr(CRBvrPtr bvr)
{
    Assert(!m_resultantbvr);
    Assert(m_cookie == 0);
    Assert(m_player != NULL);
    
    bool ok = false;
    
    // Run once the behavior so we get a handle to its performance
    if ((bvr = CRRunOnce(bvr)) == NULL)
    {
        goto done;
    }
    
    long cookie;
    
    if ((cookie = m_player->AddRunningBehavior(bvr)) == 0)
    {
        goto done;
    }
    
    m_cookie = cookie;
    m_resultantbvr = bvr;

    ok = true;
  done:
    return ok;
}

void
CMMBaseBvr::ClearResultantBvr()
{
    // Make this robust enough to call even if things are partially setup

    if (m_cookie)
    {
        // If we got here and the player is null then somethings
        // really wrong
        
        Assert(m_player);

        m_player->RemoveRunningBehavior(m_cookie);

        m_cookie = 0;
    }
    
    m_resultantbvr.Release();
}

CRBvrPtr
CMMBaseBvr::EncapsulateBvr(CRBvrPtr rawbvr)
{
    TraceTag((tagBaseBvr,
              "CMMBaseBvr(%lx)::EncapsulateBvr(%#lx)",
              this,
              rawbvr));

    // Do not need to get GC lock since we have to return a CRBvrPtr
    // and thus the caller must have already acquired it
    
    CRBvrPtr newBvr = NULL;

    // Make sure we calculate the ease in/out coeff
    
    CalculateEaseCoeff();
    
    CRBvrPtr curbvr;

    curbvr = rawbvr;

    CRNumberPtr zeroTime;
    CRNumberPtr durationTime;
    
    if (m_bNeedEase)
    {
        CRNumberPtr time;

        if ((time = EaseTime(CRLocalTime())) == NULL)
        {
            goto done;
        }

        if ((curbvr = CRSubstituteTime(curbvr, time)) == NULL)
        {
            goto done;
        }
    }

    if ((zeroTime = CRCreateNumber(0)) == NULL)
    {
        goto done;
    }
    

    if ((durationTime = CRCreateNumber(m_segDuration)) == NULL)
    {
        goto done;
    }
    
    // For now clamp to the duration as well

    CRNumberPtr timeSub;
    CRBooleanPtr cond;

    if (m_bAutoReverse)
    {
        CRNumberPtr totalTime;
    
        // Invert time from duration to repduration and clamp to
        // zero
        
        if ((totalTime = CRCreateNumber(m_repDuration)) == NULL ||
            (timeSub = CRSub(totalTime, CRLocalTime())) == NULL ||
            (cond = CRLTE(timeSub, zeroTime)) == NULL ||
            (timeSub = (CRNumberPtr) CRCond(cond,
                                            (CRBvrPtr) zeroTime,
                                            (CRBvrPtr) timeSub)) == NULL)
            goto done;
    } else {
        timeSub = durationTime;
    }
    
    // We are localTime until the duration and then we are whatever
    // timeSub is currently set to from above (either clamped for
    // duration time for non-autoreversed or reversed for the autoreverse case)

    if ((cond = CRGTE(CRLocalTime(), durationTime)) == NULL ||
        (timeSub = (CRNumberPtr) CRCond(cond,
                                        (CRBvrPtr) timeSub,
                                        (CRBvrPtr) CRLocalTime())) == NULL)
        goto done;

    // Substitute the clock and clamp to the duration
    
    if (IsContinuousMediaBvr())
    {
        if (!(m_repeat == 0 && m_typeId == CRSOUND_TYPEID))
        {
            if ((curbvr = CRDuration(curbvr, m_segDuration)) == NULL)
                goto done;
        }
    }
    else
    {
        if ((curbvr = CRSubstituteTime(curbvr, timeSub)) == NULL ||
            (curbvr = CRDuration(curbvr, m_repDuration)) == NULL)
            goto done;
    }

    if (m_repeat != 1)
    {
        if (m_repeat == 0)
        {
            curbvr = CRRepeatForever(curbvr);
        }
        else
        {
            curbvr = CRRepeat(curbvr, m_repeat);
        }

        if (curbvr == NULL)
            goto done;
    }

    // We have a total time so add another duration node
    if (m_repeatDur != -1.0f)
    {
        if ((curbvr = CRDuration(curbvr, m_repeatDur)) == NULL)
        {
            goto done;
        }
    }
    
    //
    // We now need to add the start and end hold
    //

    // Offset by the start offset
    if ((timeSub = CRSub(CRLocalTime(), GetStartTimeBvr())) == NULL)
    {
        goto done;
    }
        
    if ((cond = CRGTE(timeSub, zeroTime)) == NULL)
    {
        goto done;
    }
        
    if ((timeSub = (CRNumberPtr) CRCond(cond,
                                        (CRBvrPtr) timeSub,
                                        (CRBvrPtr) zeroTime)) == NULL)
    {
        goto done;
    }
    
    // Now add the end hold and reset to 0 local time after the
    // interval

    CRNumberPtr endholdtime;

    if (m_endOffset != 0.0f)
    {
        // There is an offset so we need to hold the end time behavior
        // for the m_endOffset time
        
        if ((cond = CRGT(CRLocalTime(), GetEndTimeBvr())) == NULL)
        {
            goto done;
        }

        if ((timeSub = (CRNumberPtr) CRCond(cond,
                                            (CRBvrPtr) GetEndTimeBvr(),
                                            (CRBvrPtr) timeSub)) == NULL)
        {
            goto done;
        }

        // Now calculate the end hold time.  It is the behavior end of
        // the behavior plus the end hold value
        if ((endholdtime = CRCreateNumber(m_endOffset)) == NULL)
        {
            goto done;
        }
        
        if ((endholdtime = CRAdd(endholdtime, GetEndTimeBvr())) == NULL)
        {
            goto done;
        }
    }
    else
    {
        // The end time is the end time of the behavior
        endholdtime = GetEndTimeBvr();
    }
    
    if ((cond = CRGT(CRLocalTime(), endholdtime)) == NULL)
    {
        goto done;
    }
    
    if ((timeSub = (CRNumberPtr) CRCond(cond,
                                        (CRBvrPtr) zeroTime,
                                        (CRBvrPtr) timeSub)) == NULL)
    {
        goto done;
    }
    
    if ((curbvr = CRSubstituteTime(curbvr, timeSub)) == NULL)
    {
        goto done;
    }
    
    // indicate success
    newBvr = curbvr;
    
  done:
    return newBvr;
}

bool
CMMBaseBvr::UpdateTimeControl()
{
    TraceTag((tagBaseBvr,
              "CMMBaseBvr(%lx)::UpdateTimeControl()",
              this));

    bool ok = false;

    CRLockGrabber __gclg;

    CRNumberPtr tc;
    
    switch(m_startType)
    {
      case MM_START_ABSOLUTE:
        tc = NULL;
        break;
      case MM_START_EVENT:
        {
            if ((tc = CRCreateNumber(GetAbsStartTime())) == NULL)
            {
                goto done;
            }
        }
        
        break;
      case MM_START_WITH:
        Assert(m_startSibling != NULL);

        tc = m_startSibling->GetStartTimeBvr();

        Assert(tc != NULL);

        break;
      case MM_START_AFTER:
        Assert(m_startSibling != NULL);

        tc = m_startSibling->GetEndTimeBvr();

        Assert(tc != NULL);

        break;
      default:
        Assert(!"CMMBaseBvr::UpdateTimeControl: Invalid start type");
        goto done;
    }

    if (tc == NULL)
    {
        tc = CRLocalTime();
    }
    else
    {
        if ((tc = CRAdd(tc, CRLocalTime())) == NULL)
        {
            goto done;
        }
    }

    if (!CRSwitchTo((CRBvrPtr) m_timeControl.p,
                    (CRBvrPtr) tc,
                    true,
                    CRContinueTimeline,
                    0.0))
        goto done;
    
    ok = true;
  done:
    return ok;
}

bool
CMMBaseBvr::AddStartTimeSink( CMMBaseBvr * sink )
{
    m_startTimeSinks.push_back( sink );
    return true;
}

void
CMMBaseBvr::RemoveStartTimeSink( CMMBaseBvr * sink )
{
    m_startTimeSinks.remove( sink );
}

bool
CMMBaseBvr::AddEndTimeSink( CMMBaseBvr* sink )
{
    m_endTimeSinks.push_back( sink );
    return true;
}

void
CMMBaseBvr::RemoveEndTimeSink( CMMBaseBvr* sink )
{
    m_endTimeSinks.remove( sink );
}

// This takes the absolute time to begin.
// If bAfterOffset is true then the time passed in is the time after
// the startoffset, otherwise it is the time before the startoffset

bool 
CMMBaseBvr::StartTimeVisit(double time,
                           CallBackList & l,
                           bool bAfterOffset)
{
    TraceTag((tagBaseBvr,
              "CMMBaseBvr(%lx)::StartTimeVisit(%g, %#lx, %d)",
              this,
              time,
              &l,
              bAfterOffset));

    bool ok = false;
    double sTime = time;
    
    if (!bAfterOffset)
    {
        // Need to add our offset to get the real start time
        sTime += m_startOffset;
    }
    
    if (!UpdateAbsStartTime(sTime))
    {
        goto done;
    }
    
    if (!UpdateAbsEndTime(GetAbsStartTime() + GetTotalRepDuration()))
    {
        goto done;
    }

    if (!ProcessEvent(l, time - sTime, true, MM_PLAY_EVENT))
    {
        goto done;
    }
    
    {
        for (MMBaseBvrList::iterator i = m_startTimeSinks.begin(); 
             i != m_startTimeSinks.end(); 
             i++)
        {
            if (!(*i)->StartTimeVisit(sTime, l, false))
            {
                goto done;
            }
        }
    }

    ok = true;
  done:
    return ok;
}

bool 
CMMBaseBvr::EndTimeVisit(double time,
                         CallBackList & l)
{
    TraceTag((tagBaseBvr,
              "CMMBaseBvr(%lx)::EndTimeVisit(%g, %#lx)",
              this,
              time,
              &l));

    bool ok = false;

    if (!UpdateAbsEndTime(time))
    {
        goto done;
    }

    if (!ProcessEvent(l, time - GetAbsStartTime(), false, MM_STOP_EVENT))
    {
        goto done;
    }
    
    // Since we only have beginafters and not endwiths call all the
    // starttimevisit methods
    
    {
        for (MMBaseBvrList::iterator i = m_endTimeSinks.begin(); 
             i != m_endTimeSinks.end(); 
             i++)
        {
            if (!(*i)->StartTimeVisit(time, l, false))
            {
                goto done;
            }
        }
    }

    ok = true;
  done:
    return ok;
}

HRESULT
CMMBaseBvr::Begin(bool bAfterOffset)
{
    TraceTag((tagBaseBvr,
              "CMMBaseBvr(%lx)::Begin(%d)",
              this,
              bAfterOffset));

    HRESULT hr;
    bool ok = false;
    CallBackList l;
    
    // If no parent set this is an error
    if (m_parent == NULL && m_player == NULL)
    {
        CRSetLastError(E_FAIL, NULL);
        goto done;
    }

    // Get the current time of our parent
    double st;

    st = GetContainerTime();

    // If our container time is indeterminate then just ignore the
    // call
    if (st == MM_INFINITE)
    {
        // Return success: TODO: Need a real error message
        ok = true;
        goto done;
    }
    
    if (!StartTimeVisit(st, l, bAfterOffset))
    {
        goto done;
    }

    if (!ProcessCBList(l))
    {
        goto done;
    }
    
    ok = true;
    
  done:
    return ok?S_OK:Error();
}

HRESULT
CMMBaseBvr::End()
{
    TraceTag((tagBaseBvr,
              "CMMBaseBvr(%lx)::End()",
              this));

    HRESULT hr;
    bool ok = false;
    CallBackList l;
    
    // If no parent set this is an error
    if (m_parent == NULL && m_player == NULL)
    {
        CRSetLastError(E_FAIL, NULL);
        goto done;
    }

    // Get the current time of our parent
    double st;

    st = GetContainerTime();

    // If our container time is indeterminate then just ignore the
    // call
    if (st == MM_INFINITE ||
        !IsPlaying())
    {
        // Return success: TODO: Need a real error message
        ok = true;
        goto done;
    }
    
    if (!EndTimeVisit(st, l))
    {
        goto done;
    }

    if (!ProcessCBList(l))
    {
        goto done;
    }
    
    ok = true;
    
  done:
    return ok?S_OK:Error();
}

HRESULT
CMMBaseBvr::Pause()
{
    TraceTag((tagBaseBvr,
              "CMMBaseBvr(%lx)::Pause()",
              this));

    HRESULT hr;
    bool ok = false;
    
  done:
    return ok?S_OK:Error();
}

HRESULT
CMMBaseBvr::Resume()
{
    TraceTag((tagBaseBvr,
              "CMMBaseBvr(%lx)::Resume()",
              this));

    HRESULT hr;
    bool ok = false;
    
  done:
    return ok?S_OK:Error();
}

HRESULT
CMMBaseBvr::Seek(double lTime)
{
    TraceTag((tagBaseBvr,
              "CMMBaseBvr(%lx)::Seek(%g)",
              this,
              lTime));

    HRESULT hr;
    bool ok = false;
    
  done:
    return ok?S_OK:Error();
}

double
CMMBaseBvr::GetContainerTime()
{
    TraceTag((tagBaseBvr,
              "CMMBaseBvr(%lx)::GetContainerTime()",
              this));

    double ret = MM_INFINITE;
    
    if (m_parent)
    {
        ret = m_parent->GetCurrentLocalTime();
    }
    else if (m_player)
    {
        // We need to get the time from the player itself
        ret = m_player->GetCurrentTime();
    }
    
    return ret;
}

double
CMMBaseBvr::GetCurrentLocalTime()
{
    TraceTag((tagBaseBvr,
              "CMMBaseBvr(%lx)::GetCurrentLocalTime()",
              this));

    // Get our container's time
    double ret = GetContainerTime();

    // If the container's local time is infinite then so is ours
    if (ret != MM_INFINITE)
    {
        // If we are not inside our range then our local time is
        // infinite
        if (ret >= GetAbsStartTime() &&
            ret <= GetAbsEndTime())
        {
            // Convert our container's time to our local time
            ret = ret - GetAbsStartTime();
        }
        else
        {
            ret = MM_INFINITE;
        }
    }
    
    return ret;
}

bool
CMMBaseBvr::UpdateAbsStartTime(float f)
{
    TraceTag((tagBaseBvr,
              "CMMBaseBvr(%lx)::UpdateAbsStartTime(%g)",
              this,
              f));

    m_absStartTime = f;

    CRLockGrabber __gclg;
    return CRSwitchToNumber(m_startTimeBvr, (double) f);
}

bool
CMMBaseBvr::UpdateAbsEndTime(float f)
{
    TraceTag((tagBaseBvr,
              "CMMBaseBvr(%lx)::UpdateAbsEndTime(%g)",
              this,
              f));

    m_absEndTime = f;

    CRLockGrabber __gclg;
    return CRSwitchToNumber(m_endTimeBvr, (double) f);
}

bool
CMMBaseBvr::ResetBvr()
{
    TraceTag((tagBaseBvr,
              "CMMBaseBvr(%lx)::ResetBvr()",
              this));

    bool ok = false;

    switch(m_startType)
    {
      case MM_START_ABSOLUTE:
        if (!UpdateAbsStartTime(m_startOffset))
        {
            goto done;
        }

        break;
      case MM_START_EVENT:
        if (!UpdateAbsStartTime(MM_INFINITE))
        {
            goto done;
        }

        break;
      case MM_START_WITH:
        Assert(m_startSibling != NULL);

        if (!UpdateAbsStartTime(m_startSibling->GetAbsStartTime() + m_startOffset))
        {
            goto done;
        }

        break;
      case MM_START_AFTER:
        Assert(m_startSibling != NULL);

        if (!UpdateAbsStartTime(m_startSibling->GetAbsEndTime() + m_startOffset))
        {
            goto done;
        }

        break;
      default:
        Assert(!"CMMBaseBvr::ResetBvr: Invalid start type");
        break;
    }

    if (!UpdateAbsEndTime(GetAbsStartTime() + GetTotalRepDuration()))
    {
        goto done;
    }


    // Now go through our peers which depend on us and reset them

    {
        for (MMBaseBvrList::iterator i = m_startTimeSinks.begin(); 
             i != m_startTimeSinks.end(); 
             i++)
        {
            if (!(*i)->ResetBvr())
            {
                goto done;
            }
        }
    }

    {
        for (MMBaseBvrList::iterator i = m_endTimeSinks.begin(); 
             i != m_endTimeSinks.end(); 
             i++)
        {
            if (!(*i)->ResetBvr())
            {
                goto done;
            }
        }
    }

    ok = true;
  done:
    return ok;
}
    
#if _DEBUG
void
CMMBaseBvr::Print(int spaces)
{
    char buf[1024];

    sprintf(buf, "%*s[id = %ls, dur = %g, ttrep = %g, tt = %g, rep = %d, autoreverse = %d]\r\n",
            spaces,"",
            m_id,
            m_segDuration,
            m_totalRepDuration,
            m_totalDuration,
            m_repeat,
            m_bAutoReverse);

    OutputDebugString(buf);
}
#endif

class __declspec(uuid("f912d958-5c28-11d2-b957-3078302c2030"))
BvrGuid {};

HRESULT WINAPI
CMMBaseBvr::BaseInternalQueryInterface(CMMBaseBvr* pThis,
                                       void * pv,
                                       const _ATL_INTMAP_ENTRY* pEntries,
                                       REFIID iid,
                                       void** ppvObject)
{
    if (InlineIsEqualGUID(iid, __uuidof(BvrGuid)))
    {
        *ppvObject = pThis;
        return S_OK;
    }
    
    return CComObjectRootEx<CComSingleThreadModel>::InternalQueryInterface(pv,
                                                                           pEntries,
                                                                           iid,
                                                                           ppvObject);
}
        
CMMBaseBvr *
GetBvr(IUnknown * pbvr)
{
    CMMBaseBvr * bvr = NULL;

    if (pbvr)
    {
        pbvr->QueryInterface(__uuidof(BvrGuid),(void **)&bvr);
    }
    
    if (bvr == NULL)
    {
        CRSetLastError(E_INVALIDARG, NULL);
    }
                
    return bvr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\mmapi\src\mmbvr.h ===
/*******************************************************************************

Copyright (c) 1995_96 Microsoft Corporation

Abstract:

    {Insert General Comment Here}

*******************************************************************************/


#ifndef _MMBVR_H
#define _MMBVR_H

#include "mmfactory.h"
#include "mmbasebvr.h"

class
__declspec(uuid("ad8888cc-537a-11d2-b955-3078302c2030")) 
ATL_NO_VTABLE CMMBehavior
    : public CComCoClass<CMMBehavior, &__uuidof(CMMBehavior)>,
      public IDispatchImpl<IMMBehavior, &IID_IMMBehavior, &LIBID_WindowsMultimediaRuntime>,
      public ISupportErrorInfoImpl<&IID_IMMBehavior>,
      public CMMBaseBvr
{
  public:
    CMMBehavior();
    ~CMMBehavior();

    HRESULT Init(LPOLESTR id, IDABehavior * bvr);
    
#if _DEBUG
    virtual const char * GetName() { return "CMMBehavior"; }
#endif

    BEGIN_COM_MAP(CMMBehavior)
        COM_INTERFACE_ENTRY(IDispatch)
        COM_INTERFACE_ENTRY(IMMBehavior)
        COM_INTERFACE_ENTRY(ISupportErrorInfo)
    END_COM_MAP();

    // This must be in the derived class and not the base class since
    // the typecast down to the base class messes things up
    static inline HRESULT WINAPI
        InternalQueryInterface(CMMBehavior* pThis,
                               const _ATL_INTMAP_ENTRY* pEntries,
                               REFIID iid,
                               void** ppvObject)
    { return BaseInternalQueryInterface(pThis,
                                        (void *) pThis,
                                        pEntries,
                                        iid,
                                        ppvObject); }

    STDMETHOD(get_ID)(LPOLESTR * s)
        { return GetID(s); }
    
    STDMETHOD(put_ID)(LPOLESTR s)
        { return SetID(s); }
        
    STDMETHOD(get_StartOffset)(float * f)
        { return GetStartOffset(f); }
    
    STDMETHOD(put_StartOffset)(float f)
        { return SetStartOffset(f); }
        
    STDMETHOD(get_Duration)(float * pd)
        { return GetDuration(pd); }
    STDMETHOD(put_Duration)(float d)
        { return SetDuration(d); }
        
    STDMETHOD(get_Repeat)(LONG * pr)
        { return GetRepeat(pr); }
    STDMETHOD(put_Repeat)(LONG r)
        { return SetRepeat(r); }
       
    STDMETHOD(get_AutoReverse)(VARIANT_BOOL * pr)
        { return GetAutoReverse(pr); }
    STDMETHOD(put_AutoReverse)(VARIANT_BOOL r)
        { return SetAutoReverse(r); }
        
    STDMETHOD(get_RepeatDur)(float * f)
        { return GetRepeatDur(f); }
    STDMETHOD(put_RepeatDur)(float f)
        { return SetRepeatDur(f); }
        
    STDMETHOD(get_EndOffset)(float * f)
        { return GetEndOffset(f); }
    STDMETHOD(put_EndOffset)(float f)
        { return SetEndOffset(f); }
        
    STDMETHOD(get_EaseIn)(float * pd)
        { return GetEaseIn(pd); }
    STDMETHOD(put_EaseIn)(float d)
        { return SetEaseIn(d); }

    STDMETHOD(get_EaseInStart)(float * pd)
        { return GetEaseInStart(pd); }
    STDMETHOD(put_EaseInStart)(float d)
        { return SetEaseInStart(d); }

    STDMETHOD(get_EaseOut)(float * pd)
        { return GetEaseOut(pd); }
    STDMETHOD(put_EaseOut)(float d)
        { return SetEaseOut(d); }

    STDMETHOD(get_EaseOutEnd)(float * pd)
        { return GetEaseOutEnd(pd); }
    STDMETHOD(put_EaseOutEnd)(float d)
        { return SetEaseOutEnd(d); }

    STDMETHOD(get_EventCB)(IMMEventCB ** ev)
        { return GetEventCB(ev); }
    STDMETHOD(put_EventCB)(IMMEventCB * ev)
        { return SetEventCB(ev); }
        
    STDMETHOD(get_TotalTime)(float * pd)
        { return GetTotalTime(pd); }
        
    STDMETHOD(get_DABehavior)(IDABehavior ** bvr)
        { return CMMBaseBvr::GetDABehavior(IID_IDABehavior, (void **)bvr); }

    STDMETHOD(GetDABehavior)(REFIID riid, void ** bvr)
        { return CMMBaseBvr::GetDABehavior(riid, bvr); }

    STDMETHOD(Begin)(VARIANT_BOOL bAfterOffset)
        { return CMMBaseBvr::Begin(bAfterOffset?true:false); }
    
    STDMETHOD(End)()
        { return CMMBaseBvr::End(); }
    
    STDMETHOD(Pause)()
        { return CMMBaseBvr::Pause(); }
    
    STDMETHOD(Resume)()
        { return CMMBaseBvr::Resume(); }
    
    STDMETHOD(Seek)(double lTime)
        { return CMMBaseBvr::Seek(lTime); }

    STDMETHOD(get_CurrentTime)(double * d)
        { return GetLocalTime(d); }

    STDMETHOD(get_PlayState)(MM_STATE * state)
        { return GetPlayState(state); }

  protected:
    HRESULT Error();
};

#endif /* _MMBVR_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\mmapi\src\mmease.cpp ===
/*******************************************************************************
 *
 * Copyright (c) 1998 Microsoft Corporation
 *
 * File: mmease.cpp
 *
 * Abstract:
 *
 *
 *
 *******************************************************************************/


#include "headers.h"
#include "mmbasebvr.h"

void
CMMBaseBvr::CalculateEaseCoeff()
{
    Assert(m_easeIn >= 0.0f && m_easeIn <= 1.0f);
    Assert(m_easeOut >= 0.0f && m_easeOut <= 1.0f);
    Assert(m_easeInStart >= 0.0f && m_easeInStart <= 1.0f);
    Assert(m_easeOutEnd >= 0.0f && m_easeOutEnd <= 1.0f);

    // We need to ease the behavior if we are not infinite and either
    // ease in or ease out percentages are non-zero
    
    m_bNeedEase = (m_duration != HUGE_VAL &&
                   (m_easeIn > 0.0f || m_easeOut > 0.0f) &&
                   (m_easeIn + m_easeOut <= 1.0f));

    if (!m_bNeedEase) return;
    
    float flEaseInDuration = m_easeIn * m_duration;
    float flEaseOutDuration = m_easeOut * m_duration;
    float flMiddleDuration = m_duration - flEaseInDuration - flEaseOutDuration;
    
    // Compute B1, the velocity during segment B.
    float flInvB1 = (0.5f * m_easeIn * (m_easeInStart - 1.0f) +
                     0.5f * m_easeOut * (m_easeOutEnd - 1.0f) + 1.0f);
    Assert(flInvB1 > 0.0f);
    m_flB1 = 1.0f / flInvB1;
    
    // Basically for accelerated pieces - t = t0 + v0 * t + 1/2 at^2
    // and a = Vend - Vstart / t

    if (flEaseInDuration != 0.0f) {
        m_flA0 = 0.0f;
        m_flA1 = m_easeInStart * m_flB1;
        m_flA2 = 0.5f * (m_flB1 - m_flA1) / flEaseInDuration;
    } else {
        m_flA0 = m_flA1 = m_flA2 = 0.0f;
    }

    m_flB0 = m_flA0 + m_flA1 * flEaseInDuration + m_flA2 * flEaseInDuration * flEaseInDuration;
    
    if (flEaseOutDuration != 0.0f) {
        m_flC0 = m_flB1 * flMiddleDuration + m_flB0;
        m_flC1 = m_flB1;
        m_flC2 = 0.5f * (m_easeOutEnd * m_flB1 - m_flC1) / flEaseOutDuration;
    } else {
        m_flC0 = m_flC1 = m_flC2 = 0.0f;
    }

    m_easeInEnd = flEaseInDuration;
    m_easeOutStart = m_duration - flEaseOutDuration;
}

CRNumberPtr
Quadratic(CRNumberPtr time, float flA, float flB, float flC)
{
    // Assume that the GC lock is acquired
    
    // Need to calculate ax^2 + bx + c

    Assert(time != NULL);

    CRNumberPtr ret = NULL;
    CRNumberPtr accum = NULL;

    if (flC != 0.0f) {
        if ((accum = CRCreateNumber(flC)) == NULL)
            goto done;
    }

    if (flB != 0.0f) {
        CRNumberPtr term;

        if ((term = CRCreateNumber(flB)) == NULL ||
            (term = CRMul(term, time)) == NULL)
            goto done;

        if (accum) {
            if ((term = CRAdd(term, accum)) == NULL)
                goto done;
        }

        accum = term;
    }

    if (flA != 0.0f) {
        CRNumberPtr term;

        if ((term = CRCreateNumber(flA)) == NULL ||
            (term = CRMul(term, time)) == NULL ||
            (term = CRMul(term, time)) == NULL)
            goto done;

        if (accum) {
            if ((term = CRAdd(term, accum)) == NULL)
                goto done;
        }

        accum = term;
    }

    // If all the coeff are zero then just return 0
    
    if (accum == NULL) {
        if ((accum = CRCreateNumber(0.0f)) == NULL)
            goto done;
    }
    
    ret = accum;
    
  done:
    return ret;
}

CRNumberPtr
AddTerm(CRNumberPtr time,
        CRNumberPtr prevTerm,
        float prevDur,
        float flA, float flB, float flC)
{
    CRNumberPtr ret = NULL;
    CRNumberPtr term;
    
    // Offset the time to be zero since that is what the coeffs are
    // based on
    
    if (prevTerm) {
        CRNumberPtr t;
        
        if ((t = CRCreateNumber(prevDur)) == NULL ||
            (time = CRSub(time, t)) == NULL)
            goto done;
    }

    if ((term = Quadratic(time, flA, flB, flC)) == NULL)
        goto done;
    
    // Now we need to conditional use the new term

    if (prevTerm) {
        CRBooleanPtr cond;
        CRNumberPtr zeroTime;
        
        if ((zeroTime = CRCreateNumber(0)) == NULL ||
            (cond = CRLT(time, zeroTime)) == NULL ||
            (term = (CRNumberPtr) CRCond(cond,
                                         (CRBvrPtr) prevTerm,
                                         (CRBvrPtr) term)) == NULL)
            goto done;
    }

    ret = term;
  done:
    return ret;
}

CRNumberPtr
CMMBaseBvr::EaseTime(CRNumberPtr time)
{
    CRNumberPtr ret = NULL;
    CRNumberPtr subTime = NULL;
    
    if (!m_bNeedEase) {
        ret = time;
        goto done;
    }
    
    if (m_easeIn > 0) {
        if ((subTime = AddTerm(time,
                               subTime,
                               0.0,
                               m_flA2, m_flA1, m_flA0)) == NULL)
            goto done;
    }
    
    // If there is space between the end of easing in and the
    // beginning of easing out then we have some constant time
    // interval
    if (m_easeInEnd < m_easeOutStart) {
        if ((subTime = AddTerm(time,
                               subTime,
                               m_easeInEnd,
                               0, m_flB1, m_flB0)) == NULL)
            goto done;
    }

    if (m_easeOut > 0) {
        if ((subTime = AddTerm(time,
                               subTime,
                               m_easeOutStart,
                               m_flC2, m_flC1, m_flC0)) == NULL)
            goto done;
    }
    
    ret = subTime;
    
    Assert(ret);
  done:
    return ret;
}

double
Quadratic(double time, float flA, float flB, float flC)
{
    // Need to calculate ax^2 + bx + c
    // Use x * (a * x + b) + c - since it requires 1 less multiply
    
    return (time * (flA * time + flB) + flC);
}

double
CMMBaseBvr::EaseTime(double time)
{
    if (!m_bNeedEase || time <= 0 || time >= m_duration)
        return time;
    
    if (time <= m_easeInEnd) {
        return Quadratic(time, m_flA2, m_flA1, m_flA0);
    } else if (time < m_easeOutStart) {
        return Quadratic(time - m_easeInEnd, 0.0f, m_flB1, m_flB0);
    } else {
        return Quadratic(time - m_easeOutStart, m_flC2, m_flC1, m_flC0);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\mmapi\src\mmfactory.cpp ===
/*******************************************************************************

Copyright (c) 1995-96 Microsoft Corporation

Abstract:

    {Insert General Comment Here}

*******************************************************************************/


#include "headers.h"
#include "mmbvr.h"
#include "mmtimeline.h"
#include "mmplayer.h"
#include "mmfactory.h"

CMMFactory::CMMFactory()
{
}

CMMFactory::~CMMFactory()
{
}


HRESULT
CMMFactory::FinalConstruct()
{
    if (bFailedLoad)
    {
        return E_FAIL;
    }
    
    return S_OK;
}

STDMETHODIMP
CMMFactory::CreateBehavior(LPOLESTR id,
                           IDABehavior *bvr,
                           IMMBehavior **ppOut)
{
    CHECK_RETURN_SET_NULL(ppOut);
    
    HRESULT hr;
    
    DAComObject<CMMBehavior> *pNew;
    DAComObject<CMMBehavior>::CreateInstance(&pNew);

    if (!pNew)
    {
        THR(hr = E_OUTOFMEMORY);
    }
    else
    {
        THR(hr = pNew->Init(id, bvr));
        
        if (SUCCEEDED(hr))
        {
            THR(hr = pNew->QueryInterface(IID_IMMBehavior,
                                          (void **)ppOut));
        }
    }

    if (FAILED(hr))
    {
        delete pNew;
    }

    return hr;
}

STDMETHODIMP
CMMFactory::CreateTimeline(LPOLESTR id,
                           IMMTimeline **ppOut)
{
    CHECK_RETURN_SET_NULL(ppOut);
    
    HRESULT hr;
    
    DAComObject<CMMTimeline> *pNew;
    DAComObject<CMMTimeline>::CreateInstance(&pNew);

    if (!pNew)
    {
        THR(hr = E_OUTOFMEMORY);
    }
    else
    {
        THR(hr = pNew->Init(id));
        
        if (SUCCEEDED(hr))
        {
            THR(hr = pNew->QueryInterface(IID_IMMTimeline,
                                          (void **)ppOut));
        }
    }

    if (FAILED(hr))
    {
        delete pNew;
    }

    return hr;
}

STDMETHODIMP
CMMFactory::CreatePlayer(LPOLESTR id,
                         IMMBehavior * bvr,
                         IDAView * v,
                         IMMPlayer **ppOut)
{
    CHECK_RETURN_SET_NULL(ppOut);
    
    HRESULT hr;
    
    DAComObject<CMMPlayer> *pNew;
    DAComObject<CMMPlayer>::CreateInstance(&pNew);

    if (!pNew)
    {
        THR(hr = E_OUTOFMEMORY);
    }
    else
    {
        THR(hr = pNew->Init(id,bvr,v));
        
        if (SUCCEEDED(hr))
        {
            THR(hr = pNew->QueryInterface(IID_IMMPlayer,
                                          (void **)ppOut));
        }
    }

    if (FAILED(hr))
    {
        delete pNew;
    }

    return hr;
}

HRESULT
CMMFactory::Error()
{
    LPCWSTR str = CRGetLastErrorString();
    HRESULT hr = CRGetLastError();
    
    if (str)
    {
        return CComCoClass<CMMFactory, &CLSID_MMFactory>::Error(str,
                                                                IID_IMMFactory,
                                                                hr);
    }
    else
    {
        return hr;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\mmapi\src\mmfactory.h ===
/*******************************************************************************

Copyright (c) 1995_96 Microsoft Corporation

Abstract:

    {Insert General Comment Here}

*******************************************************************************/


#ifndef _MMFACTORY_H
#define _MMFACTORY_H

#define LIBID "WindowsMultimediaRuntime"

class ATL_NO_VTABLE CMMFactory
    : public CComObjectRootEx<CComSingleThreadModel>,
      public CComCoClass<CMMFactory, &CLSID_MMFactory>,
      public IDispatchImpl<IMMFactory, &IID_IMMFactory, &LIBID_WindowsMultimediaRuntime>,
      public ISupportErrorInfoImpl<&IID_IMMFactory>
{
  public:
    CMMFactory();
    ~CMMFactory();

    DA_DECLARE_NOT_AGGREGATABLE(CMMFactory);

    HRESULT FinalConstruct();
#if _DEBUG
    const char * GetName() { return "CMMFactory"; }
#endif

    DECLARE_REGISTRY(CLSID_MMFactory,
                     LIBID ".MMFactory.1",
                     LIBID ".MMFactory",
                     0,
                     THREADFLAGS_BOTH);

    BEGIN_COM_MAP(CMMFactory)
        COM_INTERFACE_ENTRY(IDispatch)
        COM_INTERFACE_ENTRY(IMMFactory)
        COM_INTERFACE_ENTRY(ISupportErrorInfo)
    END_COM_MAP();

    STDMETHOD(CreateBehavior)(LPOLESTR id,
                              IDABehavior *bvr,
                              IMMBehavior **ppOut);
    STDMETHOD(CreateTimeline)(LPOLESTR id,
                              IMMTimeline **ppOut);
    STDMETHOD(CreatePlayer)(LPOLESTR id,
                            IMMBehavior *bvr,
                            IDAView * v,
                            IMMPlayer **ppOut);

    HRESULT Error();
};


#endif /* _MMFACTORY_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\mmapi\src\mmnotify.cpp ===
/*******************************************************************************
 *
 * Copyright (c) 1998 Microsoft Corporation
 *
 * File: mmnotify.cpp
 *
 * Abstract:
 *
 *
 *
 *******************************************************************************/

#include "headers.h"
#include "mmbasebvr.h"
#include "mmtimeline.h"

DeclareTag(tagNotify, "API", "Notifications");

// IMPORTANT!!!!!
// This needs to be called in the right order so that we get the
// correct children firing during the current interval but they get
// reset for the next interval. Otherwise we will not get the correct
// results.

bool
CMMBaseBvr::EventNotify(CallBackList &l,
                        double gTime,
                        MM_EVENT_TYPE et)
{
    TraceTag((tagNotify,
              "CMMBaseBvr(%#lx)::Notify(%#x): gTime = %g, event = %s",
              this,
              m_parent,
              gTime,
              EventString(et)));

    bool ok = false;
    
    if (m_eventcb)
    {
        CallBackData * data = NEW CallBackData((IMMBehavior *) this,
                                               m_eventcb,
                                               gTime,
                                               et);
    
        if (!data)
        {
            CRSetLastError(E_OUTOFMEMORY, NULL);
            goto done;
        }
        
        l.push_back(data);
    }

    if (m_parent)
    {
        if (!m_parent->ParentEventNotify(this, gTime, et))
        {
            goto done;
        }
    }
    
    ok = true;
  done:
    return ok;
}

bool
CMMTimeline::EventNotify(CallBackList &l,
                         double gTime,
                         MM_EVENT_TYPE et)
{
    TraceTag((tagNotify,
              "CMMTimeline(%#lx)::Notify(%#x): gTime = %g, event = %s",
              this,
              m_parent,
              gTime,
              EventString(et)));

    bool ok = false;
    
    // For Repeat/Autoreverse events we need to make sure we
    // reset all the children of the behavior.
    
    if (et == MM_REPEAT_EVENT ||
        et == MM_AUTOREVERSE_EVENT)
    {
        if (!ResetChildren())
        {
            goto done;
        }
    }
    
    if (!CMMBaseBvr::EventNotify(l, gTime, et))
    {
        goto done;
    }
    
    ok = true;
  done:
    return ok;
}

// This is in our local time coordinates - which means that we begin
// at 0.  This needs to be handled by the caller

bool
CMMBaseBvr::ProcessCB(CallBackList & l,
                      double lastTick,
                      double curTime,
                      bool bForward,
                      bool bFirstTick,
                      bool bNeedPlay)
{
    TraceTag((tagBaseBvr,
              "CMMBaseBvr(%lx)::ProcessCB(%g, %g, %d, %d, %d)",
              this,
              lastTick,
              curTime,
              bForward,
              bFirstTick,
              bNeedPlay));

    // The duration is really the end time minus the start time since
    // the user can change it on the fly.  We need to handle this and
    // adjust as appropriate
    
    double totaldur = GetAbsEndTime() - GetAbsStartTime();

    if (bForward)
    {
        // See if we already pass this entire bvr last time or if we
        // have not got to it yet
        
        // The equality just needs to match what we checked below when
        // we fired the event the frame before.  We need to use LT for
        // curTime since we need to fire when we are 0
        
        if (lastTick >= totaldur || curTime < 0)
        {
            // Need to handle boundary case where we start at the end
            // of the animation.  If so then just fire the stop event
            // since the start was done by the start call itself
            
            int offset;
            
            if (curTime == totaldur && lastTick == totaldur && bFirstTick)
            {
                int offset = ceil(curTime / m_segDuration) - 1;
                if (offset < 0)
                {
                    offset = 0;
                }
                double timeOffset = offset * m_segDuration;

                if (!_ProcessCB(l,
                                lastTick - timeOffset,
                                curTime - timeOffset,
                                bForward,
                                bFirstTick,
                                bNeedPlay,
                                m_bAutoReverse && (offset & 0x1)))
                {
                    return false;
                }

                if (!EventNotify(l, totaldur, MM_STOP_EVENT))
                {
                    return false;
                }
            }

            return true;
        }
        
        // We now know that the last tick was less than the
        // totalrepduration and the current time is greater than the
        // beginning

        // If the last tick was 0 then we fire the start last time
        // since the check above if for less than
        // So the rule is fire when curTime == 0.0
        
        bool bNeedStart = (lastTick < 0 || bNeedPlay);

        if (bNeedStart)
        {
            // This means that we just entered

            if (!EventNotify(l, 0, MM_PLAY_EVENT))
            {
                return false;
            }
        }
        
        if (m_segDuration == MM_INFINITE)
        {
            // Just always process our children if we are infinite
            
            if (!_ProcessCB(l,
                            lastTick,
                            curTime,
                            bForward,
                            bFirstTick,
                            bNeedPlay,
                            false))
            {
                return false;
            }
        }
        else
        {
            // This is the last repeat/bounce boundary we hit
        
            int offset = int(lastTick / m_segDuration);

            if (offset < 0)
            {
                offset = 0;
            }

            double timeOffset = offset * m_segDuration;

            // Need to clamp our max time so it does not mess up our children
            double maxtime = min(totaldur, curTime);

            while (1)
            {
                // We need to request a reversal of the underlying
                // behavior if we are bouncing and the offset is odd
                
                if (!_ProcessCB(l,
                                lastTick - timeOffset,
                                maxtime - timeOffset,
                                true,
                                bFirstTick,
                                bNeedStart,
                                m_bAutoReverse && (offset & 0x1)))
                {
                    return false;
                }
                
                // If we have reached the end then notify and break
                
                if (curTime < (timeOffset + m_segDuration))
                {
                    break;
                }
                
                // We have reach the end of our current period so all
                // children must be stopped.
                
                {
                    double t;
                    
                    t = maxtime - timeOffset;
                    
                    if (t > m_segDuration)
                    {
                        t = m_segDuration;
                    }
                    
                    if (!_ProcessEvent(l,
                                       t,
                                       false,
                                       MM_STOP_EVENT,
                                       m_bAutoReverse && (offset & 0x1)))
                    {
                        return false;
                    }
                }
                
                offset++;
                timeOffset += m_segDuration;
                
                if (timeOffset >= totaldur)
                {
                    if (curTime >= totaldur)
                    {
                        // This means we were inside last time but not any more -
                        // generate an exit event
                        
                        if (!EventNotify(l, totaldur, MM_STOP_EVENT))
                        {
                            return false;
                        }
                    }
                    
                    break;
                }
                
                // Indicate a repeat or bounce
                // If we are autoreversing and the offset is odd then it is
                // a reverse and not a repeat
                
                if (m_bAutoReverse && (offset & 0x1))
                {
                    if (!EventNotify(l,
                                     timeOffset,
                                     MM_AUTOREVERSE_EVENT))
                    {
                        return false;
                    }
                }
                else
                {
                    if (!EventNotify(l, timeOffset, MM_REPEAT_EVENT))
                    {
                        return false;
                    }
                }
            }
        }
    } else {
        // See if we already pass this entire bvr last time or if we
        // have not got to it yet
        
        if (curTime > totaldur || lastTick <= 0)
        {
            if (curTime == 0.0 && lastTick == 0.0 && bFirstTick)
            {
                // Need to handle the boundary case where we start at
                // the beginning going backwards.  The start call
                // itself handles the start event but we need to
                // process the rest of the behaviors to fire the stops

                if (!_ProcessCB(l,
                                lastTick,
                                curTime,
                                bForward,
                                true,
                                bNeedPlay,
                                false))
                {
                    return false;
                }

                if (!EventNotify(l, 0.0, MM_STOP_EVENT))
                {
                    return false;
                }
            }
            
            return true;
        }
        
        // We now know that the last tick was greater than the beginning
        // and the current time less than the total duration
        
        bool bNeedStart = (lastTick > totaldur || bNeedPlay);

        if (bNeedStart)
        {
            // This means that we just entered and we cannot have an
            // infinite value

            if (!EventNotify(l, totaldur, MM_PLAY_EVENT))
            {
                return false;
            }
            
        }

        if (m_segDuration == MM_INFINITE)
        {
            // Just always process our children if we are infinite
            
            if (!_ProcessCB(l,
                            lastTick,
                            curTime,
                            bForward,
                            bFirstTick,
                            bNeedPlay,
                            false))
            {
                return false;
            }

            if (curTime <= 0)
            {
                if (!EventNotify(l, 0.0, MM_STOP_EVENT))
                {
                    return false;
                }
            }
                
        } else {
            // This will be the repeat point to begin with
            double maxtime = min(lastTick,totaldur);

            int offset;
            double timeOffset;
                
            // This puts us on the last duration boundary greater than
            // the last position

            // It needs to be one greater since our loop decrements
            // first
            offset = int(ceil(maxtime / m_segDuration));
            timeOffset = offset * m_segDuration;
            
            while (1)
            {
                offset--;
                timeOffset -= m_segDuration;
            
                if (!_ProcessCB(l,
                                maxtime - timeOffset,
                                curTime - timeOffset,
                                false,
                                bFirstTick,
                                bNeedStart,
                                m_bAutoReverse && (offset & 0x1)))
                {
                    return false;
                }
                
                if (timeOffset < curTime)
                {
                    break;
                }
                
                // We have reach the end of our current period so all
                // children must be stopped.
                {
                    double t;

                    t = curTime - timeOffset;

                    if (t > m_segDuration)
                    {
                        t = m_segDuration;
                    }
                
                    if (!_ProcessEvent(l,
                                       t,
                                       false,
                                       MM_STOP_EVENT,
                                       m_bAutoReverse && (offset & 0x1)))
                    {
                        return false;
                    }
                }
                
                // If we have reached the end then notify and break
                
                if (offset <= 0)
                {
                    // This means we were inside last time but not any more -
                    // generate an exit event
                    
                    if (!EventNotify(l, 0.0, MM_STOP_EVENT))
                    {
                        return false;
                    }
                    
                    break;
                }
                
                // Indicate a repeat or bounce
                // If we are bouncing and the offset is odd then it is
                // a bounce and not a repeat
                
                if (m_bAutoReverse && (offset & 0x1))
                {
                    if (!EventNotify(l,
                                     timeOffset,
                                     MM_AUTOREVERSE_EVENT))
                    {
                        return false;
                    }
                }
                else
                {
                    if (!EventNotify(l, timeOffset, MM_REPEAT_EVENT))
                    {
                        return false;
                    }
                }
            }
        }
    }
    


    return true;
}

// This is in our local time space

bool
CMMBaseBvr::ProcessEvent(CallBackList & l,
                         double time,
                         bool bFirstTick,
                         MM_EVENT_TYPE et)
{
    TraceTag((tagBaseBvr,
              "CMMBaseBvr(%lx)::ProcessEvent(%g, %d, %s)",
              this,
              time,
              bFirstTick,
              EventString(et)));

    double totaldur = GetAbsEndTime() - GetAbsStartTime();
    
    // If it is outside of our range then just bail
    
    if (time < 0 || time > totaldur)
    {
        return true;
    }
    
    // If it is not the first tick and we are on a boundary do not
    // fire the events - they were already fired
    if (!bFirstTick &&
        (time == 0 || time == totaldur))
    {
        return true;
    }
    
    // Plays and Pauses get called on the way down
    if (et == MM_PAUSE_EVENT || et == MM_PLAY_EVENT)
    {
        if (!EventNotify(l, time, et))
        {
            return false;
        }
    }
    
    if (GetTotalDuration() == MM_INFINITE) {
        // Just always process our children if we are infinite
        
        if (!_ProcessEvent(l,
                           time,
                           bFirstTick,
                           et,
                           false))
        {
            return false;
        }
    } else {
        // This is the last repeat/bounce boundary we hit
        int offset = int(time / m_segDuration);
        
        Assert(offset >= 0);

        // We need to request a reversal of the underlying
        // behavior if we are bouncing and the offset is odd
        
        if (!_ProcessEvent(l,
                           time - (offset * m_segDuration),
                           bFirstTick,
                           et,
                           m_bAutoReverse && (offset & 0x1)))
        {
            return false;
        }
    }
    
    // Stops and Resumes get called on the way up
    if (et == MM_STOP_EVENT || et == MM_RESUME_EVENT)
    {
        if (!EventNotify(l, time, et))
        {
            return false;
        }
    }
    
    return true;
}


CallBackData::CallBackData(IMMBehavior * bvr,
                           IMMEventCB * eventcb,
                           double time,
                           MM_EVENT_TYPE et)
: m_bvr(bvr),
  m_eventcb(eventcb),
  m_time(time),
  m_et(et)
{
    Assert(eventcb);
}

CallBackData::~CallBackData()
{
}

HRESULT
CallBackData::CallEvent()
{
    Assert(m_eventcb);
    
    return THR(m_eventcb->OnEvent(m_time,
                                  m_bvr,
                                  m_et));
}

bool
ProcessCBList(CallBackList &l)
{
    bool ok = true;
    
    for (CallBackList::iterator i = l.begin();
         i != l.end();
         i++) {

        if (FAILED((*i)->CallEvent()))
            ok = false;

        delete (*i);
    }

    l.clear();

    if (!ok)
        CRSetLastError(E_FAIL, NULL);

    return ok;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\time\time.inc ===
# include common.inc in da
!include $(ROOT)\common.inc

# treat warnings as errors
USER_C_FLAGS=$(USER_C_FLAGS) /WX

# optimize for the ppro/pII
X86_CPU_OPTIMIZATION = /G6
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\time\dll\headers.h ===
/*******************************************************************************

Copyright (c) 1995_96 Microsoft Corporation

Abstract:

    {Insert General Comment Here}

*******************************************************************************/


#ifndef _HEADERS_H
#define _HEADERS_H

#include "include/headers.h"
#include "datime.h"
#include "comutil.h"

#endif /* _HEADERS_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\mmapi\src\mmprops.cpp ===
/*******************************************************************************
 *
 * Copyright (c) 1998 Microsoft Corporation
 *
 * File: mmprops.cpp
 *
 * Abstract:
 *
 *
 *
 *******************************************************************************/


#include "headers.h"
#include "mmbasebvr.h"

HRESULT
CMMBaseBvr::GetID(LPOLESTR * p)
{
    TraceTag((tagBaseBvr,
              "CMMBaseBvr(%lx)::GetID()",
              this));

    HRESULT hr;
    
    CHECK_RETURN_SET_NULL(p);

    if (m_id)
    {
        *p = SysAllocString(m_id);

        if (*p == NULL)
        {
            hr = E_OUTOFMEMORY;
            goto done;
        }
    }
    
    hr = S_OK;
  done:
    return hr;
}

HRESULT
CMMBaseBvr::SetID(LPOLESTR s)
{
    TraceTag((tagBaseBvr,
              "CMMBaseBvr(%lx)::SetID(%ls)",
              this,
              s));

    HRESULT hr;

    delete m_id;
    m_id = NULL;

    if (s)
    {
        s = CopyString(s);

        if (s == NULL)
        {
            hr = E_OUTOFMEMORY;
            goto done;
        }
    }

    hr = S_OK;
  done:
    return hr;
}
        
HRESULT
CMMBaseBvr::GetStartOffset(float * p)
{
    TraceTag((tagBaseBvr,
              "CMMBaseBvr(%lx)::GetStartOffset()",
              this));

    CHECK_RETURN_NULL(p);

    *p = m_startOffset;
    return S_OK;
}

HRESULT
CMMBaseBvr::SetStartOffset(float s)
{
    TraceTag((tagBaseBvr,
              "CMMBaseBvr(%lx)::SetStartOffset(%g)",
              this,
              s));

    m_startOffset = s;

    Invalidate();
    
    return S_OK;
}
        
HRESULT
CMMBaseBvr::GetDuration(float * pdur)
{
    TraceTag((tagBaseBvr,
              "CMMBaseBvr(%lx)::GetDuration()",
              this));

    CHECK_RETURN_NULL(pdur);

    *pdur = m_duration;
    return S_OK;
}

HRESULT
CMMBaseBvr::SetDuration(float dur)
{
    TraceTag((tagBaseBvr,
              "CMMBaseBvr(%lx)::SetDuration(%g)",
              this,
              dur));

    m_duration = dur;

    Invalidate();
    
    return S_OK;
}
        
HRESULT
CMMBaseBvr::GetRepeatDur(float * pr)
{
    TraceTag((tagBaseBvr,
              "CMMBaseBvr(%lx)::GetRepeatDur()",
              this));

    CHECK_RETURN_NULL(pr);

    *pr = m_repeatDur;
    return S_OK;
}

HRESULT
CMMBaseBvr::SetRepeatDur(float r)
{
    TraceTag((tagBaseBvr,
              "CMMBaseBvr(%lx)::SetRepeatDur(%g)",
              this,
              r));

    m_repeatDur = r;

    Invalidate();
    
    return S_OK;
}
        
HRESULT
CMMBaseBvr::GetRepeat(LONG * prepeat)
{
    TraceTag((tagBaseBvr,
              "CMMBaseBvr(%lx)::GetRepeat()",
              this));

    CHECK_RETURN_NULL(prepeat);

    *prepeat = m_repeat;
    return S_OK;
}

HRESULT
CMMBaseBvr::SetRepeat(LONG repeat)
{
    TraceTag((tagBaseBvr,
              "CMMBaseBvr(%lx)::SetRepeat(%d)",
              this,
              repeat));

    m_repeat = repeat;

    Invalidate();
    
    return S_OK;
}
        
HRESULT
CMMBaseBvr::GetAutoReverse(VARIANT_BOOL * pautoreverse)
{
    TraceTag((tagBaseBvr,
              "CMMBaseBvr(%lx)::GetAutoReverse()",
              this));

    CHECK_RETURN_NULL(pautoreverse);

    *pautoreverse = m_bAutoReverse;
    return S_OK;
}

HRESULT
CMMBaseBvr::SetAutoReverse(VARIANT_BOOL autoreverse)
{
    TraceTag((tagBaseBvr,
              "CMMBaseBvr(%lx)::SetAutoReverse(%d)",
              this,
              autoreverse));

    m_bAutoReverse = autoreverse?true:false;

    Invalidate();
    
    return S_OK;
}
        
HRESULT
CMMBaseBvr::GetEndOffset(float * p)
{
    TraceTag((tagBaseBvr,
              "CMMBaseBvr(%lx)::GetEndOffset()",
              this));

    CHECK_RETURN_NULL(p);

    *p = m_endOffset;
    return S_OK;
}

HRESULT
CMMBaseBvr::SetEndOffset(float s)
{
    TraceTag((tagBaseBvr,
              "CMMBaseBvr(%lx)::SetEndOffset(%g)",
              this,
              s));

    m_endOffset = s;

    Invalidate();
    
    return S_OK;
}
        
HRESULT
CMMBaseBvr::GetEventCB(IMMEventCB ** evcb)
{
    TraceTag((tagBaseBvr,
              "CMMBaseBvr(%lx)::GetEventCB()",
              this));

    CHECK_RETURN_SET_NULL(evcb);

    *evcb = m_eventcb;
    if (m_eventcb) m_eventcb->AddRef();

    return S_OK;
}

HRESULT
CMMBaseBvr::SetEventCB(IMMEventCB * evcb)
{
    TraceTag((tagBaseBvr,
              "CMMBaseBvr(%lx)::SetEventCB(%lx)",
              this,
              evcb));

    m_eventcb = evcb;
    return S_OK;
}
        
HRESULT
CMMBaseBvr::GetEaseIn(float * pd)
{
    TraceTag((tagBaseBvr,
              "CMMBaseBvr(%lx)::GetEaseIn()",
              this));

    CHECK_RETURN_NULL(pd);

    *pd = m_easeIn;
    return S_OK;
}

HRESULT
CMMBaseBvr::SetEaseIn(float d)
{
    TraceTag((tagBaseBvr,
              "CMMBaseBvr(%lx)::SetEaseIn(%g)",
              this,
              d));

    if (d < 0.0 || d > 1.0) return E_INVALIDARG;
    
    m_easeIn = d;

    Invalidate();
    
    return S_OK;
}
        
HRESULT
CMMBaseBvr::GetEaseInStart(float * pd)
{
    TraceTag((tagBaseBvr,
              "CMMBaseBvr(%lx)::GetEaseInStart()",
              this));

    CHECK_RETURN_NULL(pd);

    *pd = m_easeInStart;
    return S_OK;
}

HRESULT
CMMBaseBvr::SetEaseInStart(float d)
{
    TraceTag((tagBaseBvr,
              "CMMBaseBvr(%lx)::SetEaseInStart(%g)",
              this,
              d));

    if (d < 0.0 || d > 1.0) return E_INVALIDARG;

    m_easeInStart = d;

    Invalidate();
    
    return S_OK;
}
        
HRESULT
CMMBaseBvr::GetEaseOut(float * pd)
{
    TraceTag((tagBaseBvr,
              "CMMBaseBvr(%lx)::GetEaseOut()",
              this));

    CHECK_RETURN_NULL(pd);

    *pd = m_easeOut;
    return S_OK;
}

HRESULT
CMMBaseBvr::SetEaseOut(float d)
{
    TraceTag((tagBaseBvr,
              "CMMBaseBvr(%lx)::SetEaseOut(%g)",
              this,
              d));

    if (d < 0.0 || d > 1.0) return E_INVALIDARG;

    m_easeOut = d;

    Invalidate();
    
    return S_OK;
}
        
HRESULT
CMMBaseBvr::GetEaseOutEnd(float * pd)
{
    TraceTag((tagBaseBvr,
              "CMMBaseBvr(%lx)::GetEaseOutEnd()",
              this));

    CHECK_RETURN_NULL(pd);

    *pd = m_easeOutEnd;
    return S_OK;
}

HRESULT
CMMBaseBvr::SetEaseOutEnd(float d)
{
    TraceTag((tagBaseBvr,
              "CMMBaseBvr(%lx)::SetEaseOutEnd(%g)",
              this,
              d));

    if (d < 0.0 || d > 1.0) return E_INVALIDARG;

    m_easeOutEnd = d;

    Invalidate();
    
    return S_OK;
}
        
HRESULT
CMMBaseBvr::GetTotalTime(float * pr)
{
    TraceTag((tagBaseBvr,
              "CMMBaseBvr(%lx)::GetTotalTime()",
              this));

    CHECK_RETURN_NULL(pr);

    *pr = m_totalDuration;
    return S_OK;
}


HRESULT
CMMBaseBvr::GetDABehavior(REFIID riid, void ** bvr)
{
    TraceTag((tagBaseBvr,
              "CMMBaseBvr(%lx)::GetDABehavior()",
              this));

    CHECK_RETURN_SET_NULL(bvr);

    Assert(m_rawbvr);

    if (!CRBvrToCOM(m_rawbvr,
                    riid,
                    bvr))
        return Error();
    
    return S_OK;
}

HRESULT
CMMBaseBvr::GetLocalTime(double * d)
{
    TraceTag((tagBaseBvr,
              "CMMBaseBvr(%lx)::GetLocalTime()",
              this));

    CHECK_RETURN_NULL(d);

    *d = GetCurrentLocalTime();
    
    return S_OK;
}

HRESULT
CMMBaseBvr::GetPlayState(MM_STATE * state)
{
    TraceTag((tagBaseBvr,
              "CMMBaseBvr(%lx)::GetPlayState()",
              this));

    CHECK_RETURN_NULL(state);

    double t = GetCurrentLocalTime();
    
    if (t == MM_INFINITE)
    {
        *state = MM_STOPPED_STATE;
    }
    else
    {
        // Now see if we are in the active period of our local time
        if (t < GetStartTime() ||
            t > GetEndTime())
        {
            *state = MM_STOPPED_STATE;
        }
        else
        {
            *state = MM_PLAYING_STATE;
        }
    }
    
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\mmapi\src\mmtimeline.h ===
/*******************************************************************************

Copyright (c) 1995_96 Microsoft Corporation

Abstract:

    {Insert General Comment Here}

*******************************************************************************/


#ifndef _MMTIMELINE_H
#define _MMTIMELINE_H

#include "mmplayer.h"

class
__declspec(uuid("0dfe0bae-537c-11d2-b955-3078302c2030")) 
ATL_NO_VTABLE
CMMTimeline
    : public CComCoClass<CMMTimeline, &__uuidof(CMMTimeline)>,
      public IDispatchImpl<IMMTimeline, &IID_IMMTimeline, &LIBID_WindowsMultimediaRuntime>,
      public ISupportErrorInfoImpl<&IID_IMMTimeline>,
      public CMMBaseBvr
{
  public:
    CMMTimeline();
    ~CMMTimeline();

    HRESULT Init(LPOLESTR id);

#if _DEBUG
    const char * GetName() { return "CMMTimeline"; }
#endif

    BEGIN_COM_MAP(CMMTimeline)
        COM_INTERFACE_ENTRY(IDispatch)
        COM_INTERFACE_ENTRY(IMMBehavior)
        COM_INTERFACE_ENTRY(IMMTimeline)
        COM_INTERFACE_ENTRY(ISupportErrorInfo)
    END_COM_MAP();

    // This must be in the derived class and not the base class since
    // the typecast down to the base class messes things up
    static inline HRESULT WINAPI
        InternalQueryInterface(CMMTimeline* pThis,
                               const _ATL_INTMAP_ENTRY* pEntries,
                               REFIID iid,
                               void** ppvObject)
    { return BaseInternalQueryInterface(pThis,
                                        (void *) pThis,
                                        pEntries,
                                        iid,
                                        ppvObject); }

    

    //
    // IMMTimeline
    //
    
    STDMETHOD(AddView)(IDAView * view, IUnknown * pUnk, IDAImage * img, IDASound * snd);

    STDMETHOD(AddBehavior)(IMMBehavior *bvr,
                           MM_START_TYPE st,
                           IMMBehavior * basebvr);
    STDMETHOD(RemoveBehavior)(IMMBehavior *bvr);

    STDMETHOD(get_EndSync)(DWORD * flags);
    STDMETHOD(put_EndSync)(DWORD flags);

    //
    // IMMBehavior
    //
    
    STDMETHOD(get_ID)(LPOLESTR * s)
        { return GetID(s); }
    
    STDMETHOD(put_ID)(LPOLESTR s)
        { return SetID(s); }
        
    STDMETHOD(get_StartOffset)(float * f)
        { return GetStartOffset(f); }
    
    STDMETHOD(put_StartOffset)(float f)
        { return SetStartOffset(f); }
        
    STDMETHOD(get_Duration)(float * pd)
        { return GetDuration(pd); }
    STDMETHOD(put_Duration)(float d)
        { return SetDuration(d); }
        
    STDMETHOD(get_Repeat)(LONG * pr)
        { return GetRepeat(pr); }
    STDMETHOD(put_Repeat)(LONG r)
        { return SetRepeat(r); }
       
    STDMETHOD(get_AutoReverse)(VARIANT_BOOL * pr)
        { return GetAutoReverse(pr); }
    STDMETHOD(put_AutoReverse)(VARIANT_BOOL r)
        { return SetAutoReverse(r); }
        
    STDMETHOD(get_RepeatDur)(float * f)
        { return GetRepeatDur(f); }
    STDMETHOD(put_RepeatDur)(float f)
        { return SetRepeatDur(f); }
        
    STDMETHOD(get_EndOffset)(float * f)
        { return GetEndOffset(f); }
    STDMETHOD(put_EndOffset)(float f)
        { return SetEndOffset(f); }
        
    STDMETHOD(get_EaseIn)(float * pd)
        { return GetEaseIn(pd); }
    STDMETHOD(put_EaseIn)(float d)
        { return SetEaseIn(d); }

    STDMETHOD(get_EaseInStart)(float * pd)
        { return GetEaseInStart(pd); }
    STDMETHOD(put_EaseInStart)(float d)
        { return SetEaseInStart(d); }

    STDMETHOD(get_EaseOut)(float * pd)
        { return GetEaseOut(pd); }
    STDMETHOD(put_EaseOut)(float d)
        { return SetEaseOut(d); }

    STDMETHOD(get_EaseOutEnd)(float * pd)
        { return GetEaseOutEnd(pd); }
    STDMETHOD(put_EaseOutEnd)(float d)
        { return SetEaseOutEnd(d); }

    STDMETHOD(get_EventCB)(IMMEventCB ** ev)
        { return GetEventCB(ev); }
    STDMETHOD(put_EventCB)(IMMEventCB * ev)
        { return SetEventCB(ev); }
        
    STDMETHOD(get_TotalTime)(float * pd)
        { return GetTotalTime(pd); }
        
    STDMETHOD(get_DABehavior)(IDABehavior ** bvr)
        { return CMMBaseBvr::GetDABehavior(IID_IDABehavior, (void **)bvr); }

    STDMETHOD(GetDABehavior)(REFIID riid, void ** bvr)
        { return CMMBaseBvr::GetDABehavior(riid, bvr); }

    STDMETHOD(Begin)(VARIANT_BOOL bAfterOffset)
        { return CMMBaseBvr::Begin(bAfterOffset?true:false); }
    
    STDMETHOD(End)()
        { return CMMBaseBvr::End(); }
    
    STDMETHOD(Pause)()
        { return CMMBaseBvr::Pause(); }
    
    STDMETHOD(Resume)()
        { return CMMBaseBvr::Resume(); }
    
    STDMETHOD(Seek)(double lTime)
        { return CMMBaseBvr::Seek(lTime); }

    STDMETHOD(get_CurrentTime)(double * d)
        { return GetLocalTime(d); }

    STDMETHOD(get_PlayState)(MM_STATE * state)
        { return GetPlayState(state); }

    virtual bool ConstructBvr(CRNumberPtr timeline);
    virtual void DestroyBvr();

    DWORD GetEndSync() { return m_fEndSync; }
    bool IsLastSync() { return (m_fEndSync & MM_ENDSYNC_LAST) != 0; }
    bool IsFirstSync() { return (m_fEndSync & MM_ENDSYNC_FIRST) != 0; }
  protected:
    HRESULT Error();

    virtual void SetPlayer(CMMPlayer * player);
    virtual void ClearPlayer();

    bool AddBehavior(CMMBaseBvr *bvr,
                     MM_START_TYPE st,
                     CMMBaseBvr * basebvr);
    bool RemoveBehavior(CMMBaseBvr *bvr);
    virtual bool ResetBvr();
    
    bool IsChild(CMMBaseBvr *bvr);
    bool IsPending(CMMBaseBvr *bvr);
    
    bool AddToChildren(CMMBaseBvr * bvr);
    void RemoveFromChildren(CMMBaseBvr * bvr);
    
    bool AddToPending(CMMBaseBvr * bvr);
    bool UpdatePending(CMMBaseBvr * bvr);
    void RemoveFromPending(CMMBaseBvr * bvr);
    
    bool _ProcessCB(CallBackList & l,
                    double lastTick,
                    double curTime,
                    bool bForward,
                    bool bFirstTick,
                    bool bNeedPlay,
                    bool bNeedsReverse);
    
    bool _ProcessEvent(CallBackList & l,
                       double time,
                       bool bFirstTick,
                       MM_EVENT_TYPE et,
                       bool bNeedsReverse);
    
    virtual bool EventNotify(CallBackList &l,
                             double lTime,
                             MM_EVENT_TYPE et);

    virtual bool ParentEventNotify(CMMBaseBvr * bvr,
                                   double lTime,
                                   MM_EVENT_TYPE et);
    
    bool ResetChildren();
  protected:
    MMBaseBvrList m_children;
    MMBaseBvrList m_pending;
    DWORD         m_fEndSync;
};

#endif /* _MMTIMELINE_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\mmapi\src\util.cpp ===
/*******************************************************************************

Copyright (c) 1995-96 Microsoft Corporation

Abstract:

    {Insert General Comment Here}

*******************************************************************************/


#include "headers.h"
#include <mshtml.h>

#define DISPID_GETSAFEARRAY -2700

#define IS_VARTYPE(x,vt) ((V_VT(x) & VT_TYPEMASK) == (vt))
#define IS_VARIANT(x) IS_VARTYPE(x,VT_VARIANT)
#define GET_VT(x) (V_VT(x) & VT_TYPEMASK)

SafeArrayAccessor::SafeArrayAccessor(VARIANT & v,
                                     bool canBeNull)
: _inited(false),
  _isVar(false),
  _s(NULL),
  _failed(true),
  _allocArr(NULL)
{
    HRESULT hr;
    VARIANT *pVar;

    // Check if it is a reference to another variant
    
    if (V_ISBYREF(&v) && !V_ISARRAY(&v) && IS_VARIANT(&v))
        pVar = V_VARIANTREF(&v);
    else
        pVar = &v;

    // Check for an array
    if (!V_ISARRAY(pVar)) {
        // For JSCRIPT
        // See if it is a IDispatch and see if we can get a safearray from
        // it
        if (!IS_VARTYPE(pVar,VT_DISPATCH)) {
            if (canBeNull && (IS_VARTYPE(pVar, VT_EMPTY) ||
                              IS_VARTYPE(pVar, VT_NULL))) {

                
                // if we allow empty, then just set the safearray
                // to null.
                _s = NULL;
                _v = NULL;
                _ubound = _lbound = 0;
                _inited = true;
                _failed = false;
                return;
            } else {
                CRSetLastError (DISP_E_TYPEMISMATCH,NULL);
                return;
            }
        }

        IDispatch * pdisp;
        
        if (V_ISBYREF(pVar))
            pdisp = *V_DISPATCHREF(pVar);
        else
            pdisp = V_DISPATCH(pVar);
    
        DISPPARAMS dispparamsNoArgs = {NULL, NULL, 0, 0};
        
        // Need to pass in a VARIANT that we own and will free.  Use
        // the internal _retVar parameter
        
        hr = pdisp->Invoke(DISPID_GETSAFEARRAY,
                           IID_NULL,
                           LOCALE_USER_DEFAULT,
                           DISPATCH_METHOD|DISPATCH_PROPERTYGET,
                           &dispparamsNoArgs,
                           &_retVar, NULL, NULL);
        
        if (FAILED(hr)) {
            CRSetLastError (DISP_E_TYPEMISMATCH,NULL);
            return;
        }
        
        // No need to check for a reference since you cannot return
        // VARIANT references
        pVar = &_retVar;
        
        // Check for an array
        if (!V_ISARRAY(pVar)) {
            CRSetLastError (DISP_E_TYPEMISMATCH,NULL);
            return;
        }
    }
    
    // See if it is a variant
    
    if (IS_VARIANT(pVar))
        _isVar = true;
    else if (!IS_VARTYPE(pVar,VT_UNKNOWN) &&
             !IS_VARTYPE(pVar,VT_DISPATCH)) {
        CRSetLastError (DISP_E_TYPEMISMATCH,NULL);
        return;
    }

    if (V_ISBYREF(pVar))
        _s = *V_ARRAYREF(pVar);
    else
        _s = V_ARRAY(pVar);
    
    if (_s == NULL) {
        if (canBeNull) {
            _v = NULL;
            _ubound = _lbound = 0;
            _inited = true;
            _failed = false;
            return;
        } else {
            CRSetLastError (E_INVALIDARG,NULL);
            return;
        }
    }

    if (SafeArrayGetDim(_s) != 1) {
        CRSetLastError (E_INVALIDARG,NULL);
        return;
    }

    hr = SafeArrayGetLBound(_s,1,&_lbound);
        
    if (FAILED(hr)) {
        CRSetLastError (E_INVALIDARG,NULL);
        return;
    }
        
    hr = SafeArrayGetUBound(_s,1,&_ubound);
        
    if (FAILED(hr)) {
        CRSetLastError (E_INVALIDARG,NULL);
        return;
    }
        
    hr = SafeArrayAccessData(_s,(void **)&_v);

    if (FAILED(hr)) {
        CRSetLastError (E_INVALIDARG,NULL);
        return;
    }
        
    _inited = true;

    // If it is a variant see if they are objects or not

    if (_isVar) {
        int size = GetArraySize();
        
        if (size > 0) {
            // Check the first argument to see its type

            VARIANT * pVar = &_pVar[0];

            // Check if it is a reference to another variant
            
            if (V_ISBYREF(pVar) && !V_ISARRAY(pVar) && IS_VARIANT(pVar))
                pVar = V_VARIANTREF(pVar);

            // Check if it is an object
            if (!IS_VARTYPE(pVar,VT_UNKNOWN) &&
                !IS_VARTYPE(pVar,VT_DISPATCH)) {
                CRSetLastError (DISP_E_TYPEMISMATCH,NULL);
                return;
            }

            _allocArr = (IUnknown **) malloc(size * sizeof (IUnknown *));

            if (_allocArr == NULL) {
                CRSetLastError(E_OUTOFMEMORY, NULL);
                return;
            }

            for (int i = 0; i < size; i++) {
                CComVariant var;
                HRESULT hr = var.ChangeType(VT_UNKNOWN, &_pVar[i]);
                
                if (FAILED(hr)) {
                    CRSetLastError(DISP_E_TYPEMISMATCH,NULL);
                    return;
                }
                
                _allocArr[i] = var.punkVal;
            }
        }
    }

    _failed = false;
}

SafeArrayAccessor::~SafeArrayAccessor()
{
    if (_inited && _s)
        SafeArrayUnaccessData(_s);
}

#if 0
HRESULT
CallScript(IOleClientSite * pClient,
           LPWSTR fun,
           IDispatch * disp,
           DWORD dwData)
{
    DISPID dispid;
    DAComPtr<IOleContainer> pRoot;
    DAComPtr<IHTMLDocument> pHTMLDoc;
    DAComPtr<IDispatch> pDispatch;
    CRBvrPtr bvr = NULL;
    DAComPtr<IDABehavior> event;
    DAComPtr<IDABehavior> curBvr;
    CComVariant retVal;
    HRESULT hr = E_INVALIDARG;
        
    if (!pClient) goto done;
    
    {
        CComBSTR bstrfun(fun);
        
        if (FAILED(hr = pClient->GetContainer(&pRoot)) ||
            FAILED(hr = pRoot->QueryInterface(IID_IHTMLDocument, (void **)&pHTMLDoc)) ||
            FAILED(hr = pHTMLDoc->get_Script(&pDispatch)) ||
            FAILED(hr = pDispatch->GetIDsOfNames(IID_NULL, &bstrfun, 1,
                                                 LOCALE_USER_DEFAULT,
                                                 &dispid))) {
            goto done;
        }
    }

        
    // paramters needed to be pushed in reverse order
    VARIANT rgvarg[2];
    rgvarg[1].vt = VT_DISPATCH;
    rgvarg[1].pdispVal = disp;
    rgvarg[0].vt = VT_I4;
    rgvarg[0].lVal = dwData;
    
    DISPPARAMS dp;
    dp.cNamedArgs = 0;
    dp.rgdispidNamedArgs = 0;
    dp.cArgs = 2;
    dp.rgvarg = rgvarg;
    
    hr = pDispatch->Invoke(dispid, IID_NULL,
                           LOCALE_USER_DEFAULT, DISPATCH_METHOD,
                           &dp, &retVal, NULL, NULL);

    if (FAILED(hr)) {
        goto done;
    }

  done:
    return hr;
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\time\dll\stdafx.cpp ===
/*++

Copyright (c) 1995-96 Microsoft Corporation

Abstract:

    Ole Object initialization

Revision:

--*/

#include "headers.h"

#undef map
#undef SubclassWindow

// Put this here to initialize all the ATL stuff

#ifdef _ATL_STATIC_REGISTRY
#include <statreg.h>
#include <statreg.cpp>
#endif

#include <atlimpl.cpp>
#include <atlctl.cpp>
#include <atlwin.cpp>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\mmapi\src\mmplayer.cpp ===
/*******************************************************************************

Copyright (c) 1995-96 Microsoft Corporation

Abstract:

    {Insert General Comment Here}

*******************************************************************************/


#include "headers.h"
#include "mmplayer.h"
#include "mmbasebvr.h"

DeclareTag(tagPlayer, "API", "CMMPlayer methods");
DeclareTag(tagDetailNotify, "API", "Detailed notify");

CMMPlayer::CMMPlayer()
: m_id(NULL),
  m_state(MM_STOPPED_STATE),
  m_bForward(true),
  m_bNeedsUpdate(true),
  m_firstTick(true),
  m_ignoreCB(0)
{
}

CMMPlayer::~CMMPlayer()
{
    // Ensure the player will not try to call us since we are going away

    if (m_playerhook)
    {
        m_playerhook->SetPlayer(NULL);
    }

    if (m_mmbvr)
    {
        m_mmbvr->ClearPlayer();
    }

    delete m_id;

    // run though and delete the items in the vector.
    std::vector<ViewListSt*>::iterator i;
    for (i = m_viewVec.begin(); i < m_viewVec.end(); i++) {
        delete (*i);
    }
}

HRESULT
CMMPlayer::Init(LPOLESTR id,
                IMMBehavior * bvr,
                IDAView * v)
{
    TraceTag((tagPlayer,
              "CMMPlayer(%lx)::Init(%ls, %#lx,%#lx)",
              this,
              id,
              bvr,
              v));
    
    HRESULT hr;
    
    if (!bvr || !v)
    {
        TraceTag((tagError,
                  "CMMPlayer(%lx)::Init: Invalid behavior passed in.",
                  this));
                  
        hr = E_INVALIDARG;
        goto done;
    }

    if (id)
    {
        m_id = CopyString(id);
        
        if (m_id == NULL)
        {
            hr = E_OUTOFMEMORY;
            goto done;
        }
    }
    
    // Need to do this early since some of the other initialization
    // needs the view to be around.  However, make sure on an error
    // that we release it so we do not have an outstanding addref for
    // too long
    hr = THR(v->QueryInterface(IID_IDA3View, (void **) & m_view));

    if (FAILED(hr))
    {
        hr = E_INVALIDARG;
        goto done;
    }
    
    CMMBaseBvr * cbvr;

    cbvr = GetBvr(bvr);
    
    if (!cbvr)
    {
        TraceTag((tagError,
                  "CMMPlayer(%lx)::Init: Invalid behavior passed in.",
                  this));
                  
        hr = E_INVALIDARG;
        goto done;
    }

    m_mmbvr = cbvr;
    
    m_mmbvr->SetPlayer(this);

    if (!m_mmbvr->SetParent(NULL, MM_START_ABSOLUTE, NULL))
    {
        hr = CRGetLastError();
        goto done;
    }

    m_playerhook = NEW PlayerHook;

    if (!m_playerhook)
    {
        TraceTag((tagError,
                  "CMMPlayer(%lx)::Init: Out of memory allocating player hook.",
                  this));
                  
        hr = E_OUTOFMEMORY;
        goto done;
    }
    
    {
        CRLockGrabber __gclg;
        m_modbvr = CRModifiableBvr(m_mmbvr->GetRawBvr(), 0);

        if (!m_modbvr)
        {
            hr = CRGetLastError();
            goto done;
        }

        CRNumberPtr ts;
        
        if (!(m_timeSub = CRModifiableNumber(0.0)))
        {
            hr = CRGetLastError();
            goto done;
        }
        
        // Place us in a stopped state
        if (!_Start(0) || !_Stop(0))
        {
            hr = CRGetLastError();
            goto done;
        }
    }

    hr = S_OK;
  done:

    if (FAILED(hr))
    {
        // Do some cleanup early - ensures no cycles
        m_playerhook.Release();
        m_view.Release();
    }
    
    return hr;
}


HRESULT
CMMPlayer::AddView(IDAView *view, IUnknown * pUnk, IDAImage *img, IDASound *snd)
{
    TraceTag((tagPlayer,
              "CMMPlayer(%lx)::AddView()",
              this));

    HRESULT hr;
    bool bPending = false;

    ViewListSt *ptVls;
    ptVls = NEW ViewListSt;

    ptVls->view         = view;
//    ptVls->img          = img;
//    ptVls->snd          = snd;

    hr = pUnk->QueryInterface(IID_IElementBehaviorSiteRender,
                                      (void **) &ptVls->SiteRender);

    if(FAILED(hr))
    {
        goto done;
    }

    m_viewVec.push_back(ptVls);
    
    hr = THR(view->put_DC(NULL));

    if (FAILED(hr))
    {
        CRSetLastError(hr, NULL);
        goto done;
    }

    hr = THR(view->StartModel(img, snd, 0.0));

    if (FAILED(hr))
    {
        CRSetLastError(hr, NULL);
        goto done;
    }

    hr = S_OK;
  done:
    return hr;
}

HRESULT
CMMPlayer::get_ID(LPOLESTR * p)
{
    TraceTag((tagPlayer,
              "CMMPlayer(%lx)::get_ID()",
              this));

    HRESULT hr;
    
    CHECK_RETURN_SET_NULL(p);

    if (m_id)
    {
        *p = SysAllocString(m_id);

        if (*p == NULL)
        {
            hr = E_OUTOFMEMORY;
            goto done;
        }
    }
    
    hr = S_OK;
  done:
    return hr;
}

HRESULT
CMMPlayer::put_ID(LPOLESTR s)
{
    TraceTag((tagPlayer,
              "CMMPlayer(%lx)::put_ID(%ls)",
              this,
              s));

    HRESULT hr;

    delete m_id;
    m_id = NULL;

    if (s)
    {
        s = CopyString(s);

        if (s == NULL)
        {
            hr = E_OUTOFMEMORY;
            goto done;
        }
    }

    hr = S_OK;
  done:
    return hr;
}
        
STDMETHODIMP
CMMPlayer::get_Behavior(IMMBehavior ** mmbvr)
{
    CHECK_RETURN_SET_NULL(mmbvr);

    Assert (m_mmbvr);
    
    return m_mmbvr->QueryInterface(IID_IMMBehavior,
                                   (void **) mmbvr);
}

STDMETHODIMP
CMMPlayer::get_View(IDAView ** v)
{
    CHECK_RETURN_SET_NULL(v);

    Assert (m_view);
    
    *v = m_view;
    m_view->AddRef();

    return S_OK;
}

STDMETHODIMP
CMMPlayer::get_PlayerState(MM_STATE * pstate)
{
    CHECK_RETURN_NULL(pstate);
    
    *pstate = m_state;

    return S_OK;
}

STDMETHODIMP
CMMPlayer::get_CurrentTime(double * d)
{
    CHECK_RETURN_NULL(d);

    *d = m_curTick;

    return S_OK;
}

STDMETHODIMP
CMMPlayer::SetPosition(double lTime)
{
    TraceTag((tagPlayer,
              "CMMPlayer(%lx)::SetPosition(%g)",
              this,
              lTime));

    bool ok = false;

    if (!_Seek(lTime))
    {
        goto done;
    }

    ok = true;
  done:
    return ok?S_OK:Error();
}

STDMETHODIMP
CMMPlayer::SetDirection(VARIANT_BOOL bForward)
{
    TraceTag((tagPlayer,
              "CMMPlayer(%lx)::SetDirection(%d)",
              this,
              bForward));

    if (IsStarted())
    {
        TraceTag((tagError,
                  "CMMPlayer(%lx)::SetDirection: Behavior already started.",
                  this));

        return E_FAIL;
    }

    m_bForward = bForward?true:false;
    return S_OK;
}


STDMETHODIMP
CMMPlayer::Play()
{
    TraceTag((tagPlayer,
              "CMMPlayer(%lx)::Play()",
              this));

    bool ok = false;
    CallBackList l;

    if (!IsStopped()) {
        CRSetLastError(E_FAIL, NULL);
        goto done;
    }
        
    if (!_Start(m_curTick) ||
        !ProcessEvent(l, m_curTick, MM_PLAY_EVENT) ||
        !ProcessCBList(l))
        goto done;

    ok = true;
  done:
    return ok?S_OK:Error();
}

STDMETHODIMP
CMMPlayer::Stop()
{
    TraceTag((tagPlayer,
              "CMMPlayer(%lx)::Stop()",
              this));

    bool ok = false;
    CallBackList l;

    if (IsStopped()) {
        ok = true;
        goto done;
    }
    
    if (!_Stop(m_curTick) ||
        !ProcessEvent(l, m_curTick, MM_STOP_EVENT) ||
        !ProcessCBList(l))
        goto done;
    
    ok = true;
  done:
    return ok?S_OK:Error();
}

STDMETHODIMP
CMMPlayer::Pause()
{
    TraceTag((tagPlayer,
              "CMMPlayer(%lx)::Pause()",
              this));

    bool ok = false;
    CallBackList l;

    if (IsPaused()) {
        ok = true;
        goto done;
    }
    
    if (IsStopped()) {
        if (FAILED(Play()))
            goto done;
    }
    
    Assert(IsPlaying());
        
    if (!_Pause() ||
        !ProcessEvent(l, m_curTick, MM_PAUSE_EVENT) ||
        !ProcessCBList(l))
        goto done;
    
    ok = true;
  done:
    return ok?S_OK:Error();
}

STDMETHODIMP
CMMPlayer::Resume()
{
    TraceTag((tagPlayer,
              "CMMPlayer(%lx)::Resume()",
              this));

    bool ok = false;
    CallBackList l;

    if (IsPlaying()) {
        ok = true;
        goto done;
    } else if (IsStopped()) {
        if (FAILED(Play()))
            goto done;
    } else {
        Assert(IsPaused());
    }
    
    if (!_Resume() ||
        !ProcessEvent(l, m_curTick, MM_RESUME_EVENT) ||
        !ProcessCBList(l))
        goto done;
    
    ok = true;
  done:
    return ok?S_OK:Error();
}

bool
CMMPlayer::_Start(double lTime)
{
    bool ok = false;
    
    CRLockGrabber __gclg;
    
    if (!UpdateBvr())
    {
        goto done;
    }

    CRBvrPtr bvr;

    bvr = m_dabasebvr;
    
    if ((m_dabvr = CRSubstituteTime(bvr, m_timeSub)) == NULL)
    {
        goto done;
    }
    
    if (!CRSwitchTo(m_modbvr, m_dabvr, true, CRSwitchCurrentTick, 0))
    {
        goto done;
    }
    
    if (!SetTimeSub(lTime, false))
    {
        goto done;
    }

    m_state = MM_PLAYING_STATE;
    m_curTick = lTime;
    m_firstTick = true;
    m_playerhook->SetPlayer(this);
    
    ok = true;
  done:
    if (!ok)
    {
        _Stop(lTime);
    }

    return ok;
}


bool
CMMPlayer::UpdateBvr()
{
    bool ok = false;
    
#if _DEBUG
    TraceTag((tagError,
              "Player(%#x)",
              this));
    m_mmbvr->Print(2);
#endif

    if (m_bNeedsUpdate)
    {
        CRBvrPtr baseBvr;

        if ((baseBvr = CRHook((CRBvrPtr) CRLocalTime(), m_playerhook)) == NULL)
        {
            TraceTag((tagPlayer,
                      "CMMPlayer(%lx)::UpdateBvr() - Error creating bvr hook",
                      this));

            goto done;
        }
        
        CRBooleanPtr cond;
        CRNumberPtr zeroTime;
        CRNumberPtr timeSub;
        
        if ((zeroTime = CRCreateNumber(0)) == NULL)
        {
            goto done;
        }

        if ((cond = CRLTE(CRLocalTime(), zeroTime)) == NULL)
        {
            goto done;
        }
        
        if ((timeSub = (CRNumberPtr) CRCond(cond,
                                            (CRBvrPtr) zeroTime,
                                            (CRBvrPtr) CRLocalTime())) == NULL)
        {
            goto done;
        }
        
        if (m_mmbvr->GetTotalDuration() != HUGE_VAL)
        {
            CRNumberPtr maxTime;
            
            if ((maxTime = CRCreateNumber(m_mmbvr->GetTotalDuration())) == NULL)
            {
                goto done;
            }

            if ((cond = CRGTE(timeSub, maxTime)) == NULL)
            {
                goto done;
            }
            
            if ((timeSub = (CRNumberPtr) CRCond(cond,
                                                (CRBvrPtr) maxTime,
                                                (CRBvrPtr) timeSub)) == NULL)
            {
                goto done;
            }
        }

        if ((baseBvr = CRSubstituteTime(baseBvr, timeSub)) == NULL)
        {
            goto done;
        }

        if (!m_mmbvr->ConstructBvr((CRNumberPtr) baseBvr))
        {
            TraceTag((tagPlayer,
                      "CMMPlayer(%lx)::UpdateBvr() - Error constructing behaviors",
                      this));

            goto done;
        }
        
        m_dabasebvr = baseBvr;
        m_bNeedsUpdate = false;
    }

    ok = true;

  done:
    if (!ok)
    {
        m_mmbvr->DestroyBvr();
    }
    
    return ok;
}

bool
CMMPlayer::_Stop(double lTime)
{
    bool ok = true;
    
    m_state = MM_STOPPED_STATE;
    m_playerhook->SetPlayer(NULL);
    
    if (!SetTimeSub(lTime, true))
    {
        ok = false;
    }

  done:
    return ok;
}

bool
CMMPlayer::_Pause()
{
    bool ok = false;
    
    if (!SetTimeSub(m_curTick, true))
    {
        goto done;
    }
    
    m_state = MM_PAUSED_STATE;
    
    ok = true;
  done:
    return ok;
}

bool
CMMPlayer::_Resume()
{
    bool ok = false;
    
    if (!SetTimeSub(m_curTick, false))
    {
        goto done;
    }
    
    m_state = MM_PLAYING_STATE;
    
    ok = true;
  done:
    return ok;
}

bool
CMMPlayer::_Seek(double lTime)
{
    TraceTag((tagPlayer,
              "CMMPlayer(%lx)::_Seek(%g)",
              this,
              lTime));

    bool ok = false;

    if (!SetTimeSub(lTime,
                    (m_state != MM_PLAYING_STATE)))
    {
        goto done;
    }
    
    ok = true;
  done:
    return ok;
}

bool
CMMPlayer::SetTimeSub(double lTime, bool bPause)
{
    bool ok = false;
    
    CRLockGrabber __gclg;

    CRNumberPtr tc;
    
    if ((tc = CRCreateNumber(lTime)) == NULL)
        goto done;

    if (!bPause) {
        if (m_bForward) {
            if ((tc = CRAdd(tc, CRLocalTime())) == NULL)
                goto done;
        } else {
            if ((tc = CRSub(tc, CRLocalTime())) == NULL)
                goto done;
        }
    }
    
    if (!CRSwitchTo((CRBvrPtr) m_timeSub.p,
                    (CRBvrPtr) tc,
                    true,
                    CRSwitchCurrentTick,
                    0))
        goto done;

    ok = true;
  done:
    return ok;
}

long
CMMPlayer::AddRunningBehavior(CRBvrPtr bvr)
{
    long ret = 0;

    Assert(m_view);
    Assert(bvr);

    HRESULT hr;

    DAComPtr<IDABehavior> dabvr;
    
    if (!CRBvrToCOM(bvr,
                    IID_IDABehavior,
                    (void **) &dabvr))
    {
        goto done;
    }
    

    // TODO: Need to have flags for AddBvrsToRun so we can tell it to
    // continue the timeline

    long cookie;
    hr = THR(m_view->AddBvrToRun(dabvr, &cookie));

    if (FAILED(hr))
    {
        goto done;
    }
    
    ret = cookie;

  done:
    return ret;
}

bool
CMMPlayer::RemoveRunningBehavior(long cookie)
{
    bool ok = false;

    Assert(m_view);

    HRESULT hr;
    
    // Once the view stops then all of these are removed
    if (IsStarted())
    {
        hr = THR(m_view->RemoveRunningBvr(cookie));
        
        if (FAILED(hr))
        {
            goto done;
        }
    }

    ok = true;
  done:
    return ok;
}

HRESULT
CMMPlayer::Error()
{
    LPCWSTR str = CRGetLastErrorString();
    HRESULT hr = CRGetLastError();
    
    if (str)
        return CComCoClass<CMMPlayer, &__uuidof(CMMPlayer)>::Error(str, IID_IMMPlayer, hr);
    else
        return hr;
}

bool
CMMPlayer::ProcessCB(CallBackList & l,
                     double lTime)
{
    TraceTag((tagPlayer,
              "CMMPlayer(%lx)::ProcessCB(%lx, %g)",
              this,
              &l,
              lTime));

    TraceTag((tagDetailNotify,
              "ProcessCB(%lx): lTime - %g, m_curTick - %g, firsttick - %d",
              this,
              lTime,
              m_curTick,
              m_firstTick));
    
    if (lTime != m_curTick || m_firstTick)
    {
        // See if we are at the end
        bool bIsDone = ((m_bForward && lTime >= GetTotalDuration()) ||
                        (!m_bForward && lTime <= 0));

        double sTime = m_mmbvr->GetAbsStartTime();

        m_mmbvr->ProcessCB(l,
                           m_curTick - sTime,
                           lTime - sTime,
                           m_bForward,
                           m_firstTick,
                           false);

        m_firstTick = false;
        m_curTick = lTime;

        if (bIsDone)
        {
            _Stop(m_curTick);
        }
    }
    
    // run though and tick the views that we have in our list.
    std::vector<ViewListSt*>::iterator it;
    VARIANT_BOOL needToRender;
    for (it = m_viewVec.begin(); it < m_viewVec.end(); it++) {
        (*it)->view->Tick(lTime,&needToRender);
        if (needToRender)
        {
            (*it)->SiteRender->Invalidate(NULL);
        }
    }
    
    return true;
}

bool
CMMPlayer::ProcessEvent(CallBackList &l,
                        double lTime,
                        MM_EVENT_TYPE event)
{
    return m_mmbvr->ProcessEvent(l, lTime, m_firstTick, event);
}

void
CMMPlayer::HookCallback(double lTime)
{
    TraceTag((tagDetailNotify,
              "HookCallback(%lx): lTime - %, m_curTick - %g, firsttick - %d\n",
              this,
              lTime,
              m_curTick,
              m_firstTick));
    
    if (IsPlaying() && !IsCBDisabled()) {
        CallBackList l;
            
        ProcessCB(l,
                  lTime);

        ProcessCBList(l);
    }
}

// While this object is alive we need to keep the DLL from getting
// unloaded

// Start off with a zero refcount
CMMPlayer::PlayerHook::PlayerHook()
: m_cRef(0),
  m_player(NULL)
{
}

CMMPlayer::PlayerHook::~PlayerHook()
{
}

CRSTDAPICB_(CRBvrPtr)
CMMPlayer::PlayerHook::Notify(long id,
                              bool startingPerformance,
                              double startTime,
                              double gTime,
                              double lTime,
                              CRBvrPtr sampleVal,
                              CRBvrPtr curRunningBvr)
{
    if (m_player && !startingPerformance)
    {
#if _DEBUG
        if (m_player->IsPlaying())
        {
            TraceTag((tagDetailNotify,
                      "Notify(%lx): id - %lx, lTime - %g, gTime - %g",
                      m_player,
                      id,
                      lTime,
                      gTime));
        }
#endif
        m_player->HookCallback(lTime);
    }
    
    return NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\mmapi\src\mmplayer.h ===
/*******************************************************************************
 *
 * Copyright (c) 1998 Microsoft Corporation
 *
 * File: mmplayer.h
 *
 * Abstract:
 *
 *
 *
 *******************************************************************************/

#ifndef _MMPLAYER_H
#define _MMPLAYER_H

#include "mmbasebvr.h"
#include <mshtml.h>
#include <vector>

interface IMMBehavior;

struct ViewListSt {
    IDAView  * view;
//    IDAImage * img;
//    IDASound * snd;
    IElementBehaviorSiteRender * SiteRender;
};

typedef std::list< DAComPtr<IDA3View> > ViewList;

class
__declspec(uuid("48ddc6be-5c06-11d2-b957-3078302c2030")) 
ATL_NO_VTABLE CMMPlayer
    : public CComObjectRootEx<CComSingleThreadModel>,
      public CComCoClass<CMMPlayer, &__uuidof(CMMPlayer)>,
      public IDispatchImpl<IMMPlayer, &IID_IMMPlayer, &LIBID_WindowsMultimediaRuntime>,
      public ISupportErrorInfoImpl<&IID_IMMPlayer>
{
  public:
    CMMPlayer();
    ~CMMPlayer();

    STDMETHOD_(ULONG,AddRef)(void) = 0;
    STDMETHOD_(ULONG,Release)(void) = 0;
    STDMETHOD(QueryInterface)(REFIID iid, void ** ppvObject) = 0;
    
    HRESULT Init(LPOLESTR id, IMMBehavior * bvr, IDAView * v);
    HRESULT AddView(IDAView * view, IUnknown * pUnk, IDAImage * img, IDASound * snd);

#if _DEBUG
    const char * GetName() { return "CMMPlayer"; }
#endif

    BEGIN_COM_MAP(CMMPlayer)
        COM_INTERFACE_ENTRY(IDispatch)
        COM_INTERFACE_ENTRY(IMMPlayer)
        COM_INTERFACE_ENTRY(ISupportErrorInfo)
    END_COM_MAP();

    STDMETHOD(get_ID)(LPOLESTR * s);
    STDMETHOD(put_ID)(LPOLESTR s);
        
    STDMETHOD(Play)();
    STDMETHOD(Stop)();
    STDMETHOD(Pause)();
    STDMETHOD(Resume)();
        
    STDMETHOD(get_PlayerState)(MM_STATE *);
        
    STDMETHOD(get_CurrentTime)(double * d);

    STDMETHOD(SetPosition)(double lTime);
    STDMETHOD(SetDirection)(VARIANT_BOOL bForward);
        
    STDMETHOD(get_View)(IDAView **);

    STDMETHOD(get_Behavior)(IMMBehavior ** mmbvr);

    bool IsStopped() { return m_state == MM_STOPPED_STATE; }
    bool IsStarted() { return m_state != MM_STOPPED_STATE; }
    bool IsPlaying() { return m_state == MM_PLAYING_STATE; }
    bool IsPaused() { return m_state == MM_PAUSED_STATE; }

    void Invalidate() { m_bNeedsUpdate = true; }

    void HookCallback(double lTime);

    double GetTotalDuration() { return m_mmbvr->GetTotalDuration(); }

    double GetCurrentTime() { return m_curTick; }

    long AddRunningBehavior(CRBvrPtr bvr);
    bool RemoveRunningBehavior(long);
  protected:
    bool UpdateBvr();
    bool _Start(double lTime);
    bool _Stop(double lTime);
    bool _Pause();
    bool _Resume();
    bool _Seek(double lTime);
    
    bool ProcessEvent(CallBackList &l,
                      double lTime,
                      MM_EVENT_TYPE event);
    
    bool ProcessCB(CallBackList & l,
                   double lTime);
    
    bool SetTimeSub(double lTime, bool bPause);
    
    HRESULT Error();
    
  protected:
    LPWSTR m_id;
    DAComPtr<CMMBaseBvr> m_mmbvr;
    DAComPtr<IDA3View> m_view;
    MM_STATE m_state;
    double m_curTick;
    bool m_bForward;
    bool m_bNeedsUpdate;
    bool m_firstTick;
    long m_ignoreCB;
    
    CRPtr<CRNumber> m_timeSub;
    CRPtr<CRBvr> m_dabvr;
    CRPtr<CRBvr> m_dabasebvr;
    CRPtr<CRBvr> m_modbvr;
    std::vector<ViewListSt*> m_viewVec;

//    ViewList m_viewlist;

    class PlayerHook : public CRBvrHook
    {
      public:
        PlayerHook();
        ~PlayerHook();
        
        virtual CRSTDAPICB_(ULONG) AddRef() { m_cRef++; return m_cRef; }
        virtual CRSTDAPICB_(ULONG) Release() {
            long r = --m_cRef;

            if (r == 0)
                delete this;

            return r;
        }
        
        CRSTDAPICB_(CRBvrPtr) Notify(long id,
                                     bool startingPerformance,
                                     double startTime,
                                     double gTime,
                                     double lTime,
                                     CRBvrPtr sampleVal,
                                     CRBvrPtr curRunningBvr);

        void SetPlayer(CMMPlayer * t) { m_player = t; }

      protected:
        // We do not need a refcount since we are single threaded and
        // the player will NULL it out if it goes away

        CMMPlayer * m_player;
        long m_cRef;
    };

    DAComPtr<PlayerHook> m_playerhook;

    void DisableCB() { m_ignoreCB++; }
    void EnableCB() { m_ignoreCB--; Assert (m_ignoreCB >= 0); }

    bool IsCBDisabled() { return m_ignoreCB > 0; }
};

#endif /* _MMPLAYER_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\mmapi\src\mmtimeline.cpp ===
/*******************************************************************************

Copyright (c) 1995-96 Microsoft Corporation

Abstract:

    {Insert General Comment Here}

*******************************************************************************/


#include "headers.h"
#include "mmbasebvr.h"
#include "mmtimeline.h"

DeclareTag(tagTimeline, "API", "CMMTimeline methods");

CMMTimeline::CMMTimeline()
: m_fEndSync(0)
{
    TraceTag((tagTimeline,
              "CMMTimeline(%lx)::CMMTimeline()",
              this));
}

CMMTimeline::~CMMTimeline()
{
    TraceTag((tagTimeline,
              "CMMTimeline(%lx)::~CMMTimeline()",
              this));
}

HRESULT
CMMTimeline::Init(LPOLESTR id)
{
    TraceTag((tagTimeline,
              "CMMTimeline(%lx)::Init(%ls)",
              this,
              id));
    
    HRESULT hr;

    hr = BaseInit(id, (CRBvrPtr) CRLocalTime());
    
    if (FAILED(hr))
    {
        goto done;
    }
    
    hr = S_OK;
  done:
    return hr;
}

STDMETHODIMP
CMMTimeline::AddView(IDAView *view, IUnknown * pUnk, IDAImage *img, IDASound *snd)
{
    TraceTag((tagTimeline,
              "CMMTimeline(%lx)::AddView()",
              this));

    HRESULT hr;

    hr = GetPlayer()->AddView(view,pUnk,img,snd);

  done:
    return hr;
}


STDMETHODIMP
CMMTimeline::AddBehavior(IMMBehavior *bvr,
                         MM_START_TYPE st,
                         IMMBehavior * basebvr)
{
    TraceTag((tagTimeline,
              "CMMTimeline(%lx)::AddBehavior(%#lx, %d, %#lx)",
              this,
              bvr,
              st,
              basebvr));
    
    CHECK_RETURN_NULL(bvr);

    bool ok = false;
    
    CMMBaseBvr * mmbvr;
    CMMBaseBvr * mmbasebvr;

    mmbvr = GetBvr(bvr);

    if (mmbvr == NULL)
    {
        goto done;
    }
    
    if (mmbvr->GetParent() != NULL)
    {
        CRSetLastError(E_INVALIDARG, NULL);
        goto done;
    }

    if (basebvr)
    {
        mmbasebvr = GetBvr(basebvr);
        
        if (mmbasebvr == NULL)
        {
            goto done;
        }
    }
    else
    {
        mmbasebvr = NULL;
    }
    
    if (!AddBehavior(mmbvr, st, mmbasebvr))
    {
        goto done;
    }
    
    ok = true;
  done:
    return ok?S_OK:Error();
}

STDMETHODIMP
CMMTimeline::RemoveBehavior(IMMBehavior *bvr)
{
    TraceTag((tagTimeline,
              "CMMTimeline(%lx)::RemoveBehavior(%#lx)",
              this,
              bvr));
    
    CHECK_RETURN_NULL(bvr);

    bool ok = false;
    
    CMMBaseBvr * mmbvr;

    mmbvr = GetBvr(bvr);

    if (mmbvr == NULL)
    {
        goto done;
    }
    
    if (mmbvr->GetParent() != this)
    {
        CRSetLastError(E_INVALIDARG, NULL);
        goto done;
    }

    if (!RemoveBehavior(mmbvr))
    {
        goto done;
    }
    
    ok = true;
  done:
    return ok?S_OK:Error();
}

bool
CMMTimeline::AddBehavior(CMMBaseBvr *bvr,
                         MM_START_TYPE st,
                         CMMBaseBvr * basebvr)
{
    TraceTag((tagTimeline,
              "CMMTimeline(%lx)::AddBehavior(%#lx, %d, %#lx)",
              this,
              bvr,
              st,
              basebvr));
    
    Assert(bvr);
    Assert(bvr->GetParent() == NULL);
    
    bool ok = false;
    
    if (!bvr->SetParent(this, st, basebvr))
    {
        goto done;
    }

    Assert(bvr->GetPlayer() == NULL);
    
    if (GetPlayer() != NULL)
    {
        bvr->SetPlayer(GetPlayer());
    }
    
    // Figure out if our sibling dependent if valid or not
    if (basebvr && !IsChild(basebvr))
    {
        if (basebvr->GetParent() != this &&
            basebvr->GetParent() != NULL)
        {
            CRSetLastError(E_INVALIDARG, NULL);
            goto done;
        }

        // It has not been added to us yet so add this bvr to the
        // pending list
        if (!AddToPending(bvr))
        {
            goto done;
        }
    }
    else
    {
        if (!AddToChildren(bvr))
        {
            goto done;
        }

        if (!UpdatePending(bvr))
        {
            goto done;
        }
    }
    
    ok = true;
  done:

    if (!ok)
    {
        RemoveBehavior(bvr);
    }
    
    return ok;
}

bool
CMMTimeline::RemoveBehavior(CMMBaseBvr *bvr)
{
    TraceTag((tagTimeline,
              "CMMTimeline(%lx)::RemoveBehavior(%#lx)",
              this,
              bvr));
    
    Assert(bvr);
    
    // This needs to be callable even from a partially added behavior
    
    bool ok = false;
    
    bvr->ClearParent();
    bvr->ClearPlayer();
    
    RemoveFromChildren(bvr);
    RemoveFromPending(bvr);
    
    ok = true;
  done:
    return ok;
}

bool
CMMTimeline::AddToChildren(CMMBaseBvr * bvr)
{
    TraceTag((tagTimeline,
              "CMMTimeline(%lx)::AddToChildren(%#lx)",
              this,
              bvr));

    bool ok = false;
    
    if (!bvr->AttachToSibling())
    {
        goto done;
    }
    
    m_children.push_back(bvr);
    
    if (m_resultantbvr)
    {
        if (!bvr->ConstructBvr((CRNumberPtr) m_resultantbvr.p))
        {
            goto done;
        }
    }

    ok = true;
  done:
    return ok;
}

void
CMMTimeline::RemoveFromChildren(CMMBaseBvr * bvr)
{
    TraceTag((tagTimeline,
              "CMMTimeline(%lx)::RemoveFromChildren(%#lx)",
              this,
              bvr));

    // TODO: Need to cycle through the children and remove all
    // dependents
    
    m_children.remove(bvr);
}

bool
CMMTimeline::AddToPending(CMMBaseBvr * bvr)
{
    TraceTag((tagTimeline,
              "CMMTimeline(%lx)::AddToPending(%#lx)",
              this,
              bvr));

    bool ok = false;
    
    m_pending.push_back(bvr);

    ok = true;
  done:
    return ok;
}

bool
CMMTimeline::UpdatePending(CMMBaseBvr * bvr)
{
    TraceTag((tagTimeline,
              "CMMTimeline(%lx)::UpdatePending(%#lx)",
              this,
              bvr));

    bool ok = false;
    
    MMBaseBvrList newlist;
    
    MMBaseBvrList::iterator i = m_pending.begin();

    while (i != m_pending.end())
    {
        // Need to do this so we can erase j if we need to
        MMBaseBvrList::iterator j = i;
        i++;
        
        if((*j)->GetStartSibling() == bvr)
        {
            newlist.push_back(*j);
            m_pending.erase(j);
        }
    }
    
    for (i = newlist.begin();
         i != newlist.end();
         i++)
    {
        if (!AddToChildren(*i))
        {
            goto done;
        }

        if (!UpdatePending(*i))
        {
            goto done;
        }
    }

    ok = true;
  done:
    return ok;
}

void
CMMTimeline::RemoveFromPending(CMMBaseBvr * bvr)
{
    TraceTag((tagTimeline,
              "CMMTimeline(%lx)::RemoveFromPending(%#lx)",
              this,
              bvr));

    m_pending.remove(bvr);
}

bool 
CMMTimeline::IsChild(CMMBaseBvr * bvr)
{
    TraceTag((tagTimeline,
              "CMMTimeline(%lx)::IsChild(%#lx)",
              this,
              bvr));

    for (MMBaseBvrList::iterator i = m_children.begin(); 
         i != m_children.end(); 
         i++)
    {
        if((*i) == bvr)
        {
            return true;
        }
    }
    
    return false;
}

bool 
CMMTimeline::IsPending(CMMBaseBvr * bvr)
{
    TraceTag((tagTimeline,
              "CMMTimeline(%lx)::IsPending(%#lx)",
              this,
              bvr));

    for (MMBaseBvrList::iterator i = m_pending.begin(); 
         i != m_pending.end(); 
         i++)
    {
        if((*i) == bvr)
        {
            return true;
        }
    }
    
    return false;
}

void
CMMTimeline::SetPlayer(CMMPlayer * player)
{
    TraceTag((tagTimeline,
              "CMMTimeline(%lx)::SetPlayer(%#lx)",
              this,
              player));

    CMMBaseBvr::SetPlayer(player);

    for (MMBaseBvrList::iterator i = m_children.begin(); 
         i != m_children.end(); 
         i++)
    {
        (*i)->SetPlayer(player);
    }
}

void
CMMTimeline::ClearPlayer()
{
    TraceTag((tagTimeline,
              "CMMTimeline(%lx)::ClearPlayer()",
              this));

    CMMBaseBvr::ClearPlayer();
    
    for (MMBaseBvrList::iterator i = m_children.begin(); 
         i != m_children.end(); 
         i++)
    {
        (*i)->ClearPlayer();
    }
}

bool
CMMTimeline::ConstructBvr(CRNumberPtr timeline)
{
    TraceTag((tagTimeline,
              "CMMTimeline(%lx)::ConstructBvr()",
              this));

    bool ok = false;
    
    Assert(!m_resultantbvr);
    
    if (!CMMBaseBvr::ConstructBvr(timeline))
    {
        goto done;
    }
    
    Assert(m_resultantbvr);
    
    {
        for (MMBaseBvrList::iterator i = m_children.begin(); 
             i != m_children.end(); 
             i++)
        {
            if (!(*i)->ConstructBvr((CRNumberPtr) m_resultantbvr.p))
            {
                goto done;
            }
        }
    }

    ok = true;
  done:
    return ok;
}

void
CMMTimeline::DestroyBvr()
{
    TraceTag((tagTimeline,
              "CMMTimeline(%lx)::DestroyBvr()",
              this));

    CMMBaseBvr::DestroyBvr();
    
    for (MMBaseBvrList::iterator i = m_children.begin(); 
         i != m_children.end(); 
         i++)
    {
        (*i)->DestroyBvr();
    }
}

bool
CMMTimeline::ResetBvr()
{
    TraceTag((tagTimeline,
              "CMMTimeline(%lx)::ResetBvr()",
              this));

    bool ok = false;

    // Call the base class first
    
    if (!CMMBaseBvr::ResetBvr())
    {
        goto done;
    }
    
    // Now go through our children

    if (!ResetChildren())
    {
        goto done;
    }
    
    ok = true;
  done:
    return ok;
}
    
bool
CMMTimeline::_ProcessCB(CallBackList & l,
                        double lastTick,
                        double curTime,
                        bool bForward,
                        bool bFirstTick,
                        bool bNeedPlay,
                        bool bNeedsReverse)
{
    TraceTag((tagTimeline,
              "CMMTimeline(%lx)::_ProcessCB(%g, %g, %d, %d, %d, %d)",
              this,
              lastTick,
              curTime,
              bForward,
              bFirstTick,
              bNeedPlay,
              bNeedsReverse));
    
    // If we need to reverse then invert which direct to process our
    // children and invert times for the current frame not our total
    // duration
    
    if (bNeedsReverse)
    {
        // Our caller should ensure that they do not call me to
        // reverse myself if I am infinite
        Assert(m_segDuration != MM_INFINITE);
        
        lastTick = m_segDuration - lastTick;
        curTime = m_segDuration - curTime;
        
        bForward = !bForward;
    }
    
    for (MMBaseBvrList::iterator i = m_children.begin();
         i != m_children.end();
         i++)
    {
        double sTime = (*i)->GetAbsStartTime();

        if (sTime != MM_INFINITE)
        {
            (*i)->ProcessCB(l,
                            EaseTime(lastTick - sTime),
                            EaseTime(curTime - sTime),
                            bForward,
                            bFirstTick,
                            bNeedPlay);
        }

    }
    
    return true;
}

bool
CMMTimeline::_ProcessEvent(CallBackList & l,
                           double time,
                           bool bFirstTick,
                           MM_EVENT_TYPE et,
                           bool bNeedsReverse)
{
    TraceTag((tagTimeline,
              "CMMTimeline(%lx)::_ProcessEvent(%g, %d, %s, %d)",
              this,
              time,
              bFirstTick,
              EventString(et),
              bNeedsReverse));
    
    // If we need to reverse then for the current frame not our total
    // duration
    
    if (bNeedsReverse)
    {
        // Our caller should ensure that they do not call me to
        // reverse myself if I am infinite
        Assert(m_segDuration != MM_INFINITE);
        
        time = m_segDuration - time;
    }
    
    for (MMBaseBvrList::iterator i = m_children.begin();
         i != m_children.end();
         i++)
    {
        double sTime = (*i)->GetAbsStartTime();

        if (sTime != MM_INFINITE)
        {
            (*i)->ProcessEvent(l,
                               EaseTime(time - sTime),
                               bFirstTick,
                               et);
        }
    }
        
    return true;
}

bool
CMMTimeline::ResetChildren()
{
    TraceTag((tagTimeline,
              "CMMTimeline(%lx)::ResetChildren()",
              this));

    bool ok = true;

    // Need to reset all children
    // Even if we detect a failure process all children and then just
    // return false

    // TODO: Should only really reset non-dependent children since the
    // dependents need to be updated by their sibling
    
    for (MMBaseBvrList::iterator i = m_children.begin(); 
         i != m_children.end(); 
         i++)
    {
        if (!(*i)->ResetBvr())
        {
            ok = false;
        }
    }

  done:
    return ok;
}

bool
CMMTimeline::ParentEventNotify(CMMBaseBvr * bvr,
                               double lTime,
                               MM_EVENT_TYPE et)
{
    TraceTag((tagTimeline,
              "CMMTimeline(%lx)::ParentEventNotify(%#lx, %g, %s)",
              this,
              bvr,
              lTime,
              EventString(et)));

    bool ok = true;

    Assert(IsChild(bvr));

    // TODO: Need to handle this.
    
    ok = true;
  done:
    return ok;
}
    
HRESULT
CMMTimeline::get_EndSync(DWORD * f)
{
    TraceTag((tagTimeline,
              "CMMTimeline(%lx)::get_EndSync()",
              this));

    CHECK_RETURN_NULL(f);

    *f = m_fEndSync;
    return S_OK;
}

HRESULT
CMMTimeline::put_EndSync(DWORD f)
{
    TraceTag((tagTimeline,
              "CMMTimeline(%lx)::put_EndSync(%d)",
              this,
              f));

    m_fEndSync = f;

    return S_OK;
}
        
HRESULT
CMMTimeline::Error()
{
    LPCWSTR str = CRGetLastErrorString();
    HRESULT hr = CRGetLastError();
    
    TraceTag((tagError,
              "CMMTimeline(%lx)::Error(%hr,%ls)",
              this,
              hr,
              str?str:L"NULL"));

    if (str)
        return CComCoClass<CMMTimeline, &__uuidof(CMMTimeline)>::Error(str, IID_IMMTimeline, hr);
    else
        return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\time\include\atlutil.h ===
/*******************************************************************************

Copyright (c) 1995_96 Microsoft Corporation

Abstract:

    {Insert General Comment Here}

*******************************************************************************/


#ifndef _LMATL_H
#define _LMATL_H

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#define _ATL_NO_DEBUG_CRT 1

#ifdef _DEBUG
#undef _ASSERTE
#endif

#define _ASSERTE(expr) ((void)0)

#define _ATL_STATIC_REGISTRY 1

#ifdef _DEBUG
inline void _cdecl AtlTrace2(LPCTSTR , ...){}
#define ATLTRACE            1 ? (void)0 : AtlTrace2
#endif

#include <atlbase.h>

// We are overriding these methods so we can hook them and do some
// stuff ourselves.
class DAComModule : public CComModule
{
  public:
    LONG Lock();
    LONG Unlock();

#if DEVELOPER_DEBUG
    void AddComPtr(void *ptr, const char * name);
    void RemoveComPtr(void *ptr);

    void DumpObjectList();
#endif
};

//#define _ATL_APARTMENT_THREADED
// THIS MUST BE CALLED _Module - all the ATL header files depend on it
extern DAComModule _Module;

#include <atlcom.h>
#include <atlctl.h>

#if _DEBUG
#include <typeinfo.h>
#endif

// COPIED FROM ATLCOM.H

//Base is the user's class that derives from CComObjectRoot and whatever
//interfaces the user wants to support on the object
class ModuleReleaser
{
  public:
    ModuleReleaser() {
        _Module.Lock();
    }

    ~ModuleReleaser() {
        _Module.Unlock();
    }
};

template <class Base>
class DAComObject 
    : public ModuleReleaser,
      public Base
{
  public:
    typedef Base _BaseClass;
    DAComObject(void* = NULL)
    {
#if DEVELOPER_DEBUG
#if _DEBUG
        _Module.AddComPtr(this, GetName());
#else
        _Module.AddComPtr(this, NULL);
#endif
#endif
    }
    // Set refcount to 1 to protect destruction
    ~DAComObject()
    {
#if DEVELOPER_DEBUG
        _Module.RemoveComPtr(this);
#endif
        m_dwRef = 1L;
        FinalRelease();
    }
    //If InternalAddRef or InteralRelease is undefined then your class
    //doesn't derive from CComObjectRoot
    STDMETHOD_(ULONG, AddRef)() {return InternalAddRef();}
    STDMETHOD_(ULONG, Release)()
    {
        ULONG l = InternalRelease();
        if (l == 0)
            delete this;
        return l;
    }
    //if _InternalQueryInterface is undefined then you forgot BEGIN_COM_MAP
    STDMETHOD(QueryInterface)(REFIID iid, void ** ppvObject)
    {return _InternalQueryInterface(iid, ppvObject);}
    static HRESULT WINAPI CreateInstance(DAComObject<Base>** pp);
};

template <class Base>
HRESULT WINAPI DAComObject<Base>::CreateInstance(DAComObject<Base>** pp)
{
    _ASSERTE(pp != NULL);
    HRESULT hRes = E_OUTOFMEMORY;
    DAComObject<Base>* p = NULL;
    ATLTRY((p = new DAComObject<Base>()));
    if (p != NULL) {
        p->SetVoid(NULL);
        p->InternalFinalConstructAddRef();
        hRes = p->FinalConstruct();
        p->InternalFinalConstructRelease();
        if (hRes != S_OK) {
            delete p;
            p = NULL;
        }
    }
    *pp = p;
    return hRes;
}

#define DA_DECLARE_NOT_AGGREGATABLE(x) public:\
        typedef CComCreator2< CComCreator< DAComObject< x > >, CComFailCreator<CLASS_E_NOAGGREGATION> > _CreatorClass;
#define DA_DECLARE_AGGREGATABLE(x) public:\
        typedef CComCreator2< CComCreator< DAComObject< x > >, CComCreator< CComAggObject< x > > > _CreatorClass;

// END OF COPIED CODE
// Just to make things more uniform
#define RELEASE(x) if (x) { (x)->Release(); (x) = NULL; }

extern bool bFailedLoad;

#endif /* _LMATL_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\time\include\comutil.h ===
/*******************************************************************************

Copyright (c) 1995_96 Microsoft Corporation

Abstract:

    {Insert General Comment Here}

*******************************************************************************/


#ifndef _COMUTIL_H
#define _COMUTIL_H

#define SET_NULL(x) {if (x) *(x) = NULL;}

#define CHECK_RETURN_NULL(x) {if (!(x)) return E_POINTER;}
#define CHECK_RETURN_SET_NULL(x) {if (!(x)) { return E_POINTER ;} else {*(x) = NULL;}}

template <class T>
class DAComPtr
{
  public:
    typedef T _PtrClass;
    DAComPtr() { p = NULL; }
    DAComPtr(T* lp, bool baddref = true)
    {
        p = lp;
        if (p != NULL && baddref)
            p->AddRef();
    }
    DAComPtr(const DAComPtr<T>& lp, bool baddref = true)
    {
        p = lp.p;

        if (p != NULL && baddref)
            p->AddRef();
    }
    ~DAComPtr() {
        if (p) p->Release();
    }
    void Release() {
        if (p) p->Release();
        p = NULL;
    }
    operator T*() { return (T*)p; }
    T& operator*() { Assert(p != NULL); return *p; }
    //The assert on operator& usually indicates a bug.  If this is really
    //what is needed, however, take the address of the p member explicitly.
    T** operator&() { Assert(p == NULL); return &p; }
    T* operator->() { Assert(p != NULL); return p; }
    T* operator=(T* lp)
    {
        return Assign(lp);
    }
    T* operator=(const DAComPtr<T>& lp)
    {
        return Assign(lp.p);
    }

    bool operator!() const { return (p == NULL); }
    operator bool() const { return (p != NULL); }

    T* p;
  protected:
    T* Assign(T* lp) {
        if (lp != NULL)
            lp->AddRef();

        if (p)
            p->Release();

        p = lp;

        return lp;
    }
};

#endif /* _COMUTIL_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\time\include\resource.h ===
/*******************************************************************************

Copyright (c) 1998_98 Microsoft Corporation

Abstract:

    DALite Resources

*******************************************************************************/


#ifndef _RESOURCE_H
#define _RESOURCE_H

#define RESID_TYPELIB           1

#endif /* _RESOURCE_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\time\idl\headers.h ===
/*******************************************************************************

Copyright (c) 1995_96 Microsoft Corporation

Abstract:

    {Insert General Comment Here}

*******************************************************************************/


#ifndef _HEADERS_H
#define _HEADERS_H

#include "include/headers.h"

#endif /* _HEADERS_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\time\dll\init.cpp ===
/*******************************************************************************
 *
 * Copyright (c) 1998 Microsoft Corporation
 *
 * File: init.cpp
 *
 * Abstract:
 *
 *
 *
 *******************************************************************************/


#include "headers.h"

// Macro refers to a function of the name InitializeModule_Name,
// assumed to be defined, and then calls it.  If it's not defined,
// we'll get a link time error.
#define INITIALIZE_MODULE(ModuleName)           \
  extern bool InitializeModule_##ModuleName();  \
  if (!InitializeModule_##ModuleName()) return false;

#define DEINITIALIZE_MODULE(ModuleName,bShutdown)               \
  extern void DeinitializeModule_##ModuleName(bool);            \
  DeinitializeModule_##ModuleName(bShutdown);

bool
InitializeAllModules()
{
    INITIALIZE_MODULE(ATL);
    INITIALIZE_MODULE(Util);

    return true;
}

void
DeinitializeAllModules(bool bShutdown)
{
    DEINITIALIZE_MODULE(Util, bShutdown);
    DEINITIALIZE_MODULE(ATL, bShutdown);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\time\dll\main.cpp ===
/*******************************************************************************
  Copyright (c) 1995-96 Microsoft Corporation

  Abstract:

    Initialization

 *******************************************************************************/

#include "headers.h"

HINSTANCE  hInst;

bool InitializeAllModules(void);
void DeinitializeAllModules(bool bShutdown);

extern "C" BOOL WINAPI _DllMainCRTStartup (HINSTANCE hInstance,
                                           DWORD dwReason,
                                           LPVOID lpReserved);

extern "C" BOOL WINAPI
_TIMEDllMainStartup(HINSTANCE hInstance, DWORD dwReason, LPVOID lpReserved)
{
    if (dwReason == DLL_PROCESS_DETACH) {
        // Call the routines in reverse order of initialization
        BOOL r = _DllMainCRTStartup(hInstance,dwReason,lpReserved);
        r = DALibStartup(hInstance,dwReason,lpReserved) && r;

        return r;
    } else {
        // In everything except DLL_PROCESS_DETACH call DALibStartup first
        return (DALibStartup(hInstance,dwReason,lpReserved) &&
                _DllMainCRTStartup(hInstance,dwReason,lpReserved));
    }
}

/////////////////////////////////////////////////////////////////////////////
// DLL Entry Point
extern "C"
BOOL WINAPI DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID lpReserved)
{
    if (dwReason == DLL_PROCESS_ATTACH) {
        hInst = hInstance;

        DisableThreadLibraryCalls(hInstance);

        // For APELDBG
        RESTOREDEFAULTDEBUGSTATE;

        if (!InitializeAllModules())
        {
            return FALSE;
        }
        
    } else if (dwReason == DLL_PROCESS_DETACH) {
        DeinitializeAllModules(lpReserved != NULL);

#if _DEBUG
        _TCHAR buf[MAX_PATH + 1];
        
        GetModuleFileName(hInst, buf, MAX_PATH);
        
#if _DEBUGMEM
        TraceTag((tagLeaks, "\n[%s] unfreed memory:", buf));
        DUMPMEMORYLEAKS;
#endif

        // de-initialize the debug trace info.
        DeinitDebug();
#endif
    }
    
    return TRUE;
}

/////////////////////////////////////////////////////////////////////////////
// Used to determine whether the DLL can be unloaded by OLE

STDAPI DllCanUnloadNow(void)
{
    return (_Module.GetLockCount()==0) ? S_OK : S_FALSE;
}

/////////////////////////////////////////////////////////////////////////////
// Returns a class factory to create an object of the requested type

#ifdef _DEBUG
static bool breakDialog = false ;
DeclareTag(tagDebugBreak, "!Debug", "Breakpoint on entry to DLL");
#endif

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
#ifdef _DEBUG
    if (!breakDialog && IsTagEnabled(tagDebugBreak)) {
        _TCHAR buf[MAX_PATH + 1];
        
        GetModuleFileName(hInst, buf, MAX_PATH);
        
        MessageBox(NULL,buf,__T("TIME - Creating first COM Object"),MB_OK|MB_SETFOREGROUND) ;
        breakDialog = true;
    }
#endif

    return _Module.GetClassObject(rclsid, riid, ppv);
}

/////////////////////////////////////////////////////////////////////////////
// DllRegisterServer - Adds entries to the system registry

STDAPI DllRegisterServer(void)
{
    // registers object, typelib and all interfaces in typelib
    return _Module.RegisterServer(TRUE);
}

/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Removes entries from the system registry

STDAPI DllUnregisterServer(void)
{
    _Module.UnregisterServer();
    return S_OK;
}


#if _DEBUG
STDAPI_(void)
DoTraceTagDialog(HWND hwndStub,
                 HINSTANCE hAppInstance,
                 LPWSTR lpwszCmdLine,
                 int nCmdShow)
{
    DoTracePointsDialog(true);
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\time\include\headers.h ===
/*******************************************************************************
Copyright (c) 1995-96 Microsoft Corporation

    Precompiled headers for dalite.dll
*******************************************************************************/

#ifndef DAL_HEADERS_HXX
#define DAL_HEADERS_HXX

/* Standard */
#include <math.h>
#include <stdio.h>
#include <stddef.h>
#include <stdlib.h>
#include <string.h>
#include <malloc.h>
#include <memory.h>
#include <wtypes.h>

// Warning 4786 (identifier was truncated to 255 chars in the browser
// info) can be safely disabled, as it only has to do with generation
// of browsing information.
#pragma warning(disable:4786)

#include "apeldbg/apeldbg.h"

#pragma warning(disable:4530)
// ATL - needs to be before windows.h
#include "daatl.h"

/* Windows */
#include <windows.h>
#include <windowsx.h>

/* C++ Replace DLL */
#include "dalibc.h"

#include <mshtmhst.h>
#include <mshtml.h>

#include <ddraw.h>

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\time\mmapi\headers.h ===
/*******************************************************************************

Copyright (c) 1995_96 Microsoft Corporation

Abstract:

    {Insert General Comment Here}

*******************************************************************************/


#ifndef _HEADERS_H
#define _HEADERS_H

#include "include/headers.h"
#include "mmapi.h"
#include "dacomutil.h"
#include "dartapi.h"
#include "datime.h"
#include "util.h"
#include <list>

#endif /* _HEADERS_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\time\dll\oleobj.cpp ===
/*******************************************************************************
 *
 * Copyright (c) 1998 Microsoft Corporation
 *
 * File: oleobj.cpp
 *
 * Abstract:
 *
 *
 *
 *******************************************************************************/


#include "headers.h"
#include "src\factory.h"
#include "mmapi\mmfactory.h"
#include "dartapi.h"

DeclareTag(tagLockCount,"COM","Lock count");

DAComModule _Module;
extern HINSTANCE hInst;

BEGIN_OBJECT_MAP(COMObjectMap)
    OBJECT_ENTRY(CLSID_TIMEFactory, CTIMEFactory)
    OBJECT_ENTRY(CLSID_TIMEMMFactory, CMMFactory)
END_OBJECT_MAP()

bool bFailedLoad = false;

#define EXCEPTION(t) (GetExceptionCode() == t ? EXCEPTION_EXECUTE_HANDLER : EXCEPTION_CONTINUE_SEARCH )

LONG
DAComModule::Lock()
{
    // Can't depend on value return from Lock to be accurate.  Since
    // the CRConnect can be called multiple times w/o a problem simply
    // check the internal variable to see if it is 0.  This should
    // never cause anything except multiple calls to CRConnect

    bool bNeedConnect = (GetLockCount() == 0);

    LONG l = CComModule::Lock();

    TraceTag((tagLockCount,
              "DAComModule::Lock - new lockcount - %d, returned - %d",
              _Module.GetLockCount(),
              l));

    if (bNeedConnect) {
        __try {
            CRConnect(hInst);
        } __except (  EXCEPTION_EXECUTE_HANDLER ) {
            bFailedLoad = true;
        }
    }

    return l;
}

LONG
DAComModule::Unlock()
{
    LONG l = CComModule::Unlock();

    TraceTag((tagLockCount,
              "DAComModule::Unlock - new lockcount - %d, returned - %d",
              _Module.GetLockCount(),
              l));

    if (l) return l;
    if (!bFailedLoad)
        CRDisconnect(hInst);
    return 0;
}

#if DEVELOPER_DEBUG
#include <map>

typedef std::map<void *, const _TCHAR *> ObjectMap;
ObjectMap *objMap = NULL;

void
DAComModule::AddComPtr(void *ptr, const _TCHAR * name)
{
    EnterCriticalSection(&m_csObjMap);
    (*objMap)[ptr] = name;
    LeaveCriticalSection(&m_csObjMap) ;
}

void
DAComModule::RemoveComPtr(void *ptr)
{
    EnterCriticalSection(&m_csObjMap);
    objMap->erase(ptr);
    LeaveCriticalSection(&m_csObjMap) ;
}

void
DAComModule::DumpObjectList()
{
    if (objMap) {
        EnterCriticalSection(&m_csObjMap);
        if (objMap->size() > 0 || GetLockCount() > 0) {
            OutputDebugString (__T("DATIME.DLL: Detected unfreed COM pointers\n"));
            OutputDebugString (__T("Listing pointers and types:\n"));
            for (ObjectMap::iterator i = objMap->begin();
                 i != objMap->end();
                 i++) {

                _TCHAR buf[1024];

                wsprintf(buf, __T("%#x:"), (*i).first);
                OutputDebugString(buf);

                if ((*i).second)
                    OutputDebugString((*i).second);

                OutputDebugString(__T("\n"));
            }
        }

        LeaveCriticalSection(&m_csObjMap) ;
    }
}

void
DumpCOMObjectList()
{
    _Module.DumpObjectList();
}

#endif

bool
InitializeModule_ATL()
{
    _Module.Init(COMObjectMap, hInst);

#if DEVELOPER_DEBUG
    // NOTE: Memory allocation during construction now gives a warning.
    // If this is ok because this is DEV_DEBUG then leave the following
    // pragma, otherwise move this NEW.
#pragma warning( disable: 4291 )
    objMap = NEW ObjectMap;
#endif

    return true;
}

void
DeinitializeModule_ATL(bool bShutdown)
{
#if DEVELOPER_DEBUG
    DumpCOMObjectList();

    delete objMap;
    objMap = NULL;
#endif

    _Module.Term();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\time\mmapi\mmbasebvr.cpp ===
/*******************************************************************************
 *
 * Copyright (c) 1998 Microsoft Corporation
 *
 * File: mmbasebvr.cpp
 *
 * Abstract:
 *
 *
 *
 *******************************************************************************/

#include "headers.h"
#include "mmbasebvr.h"
#include "mmplayer.h"

#define BEGIN_HOLD_EPSILON 0.000001

DeclareTag(tagMMBaseBvr, "API", "CMMBaseBvr methods");

CMMBaseBvr::CMMBaseBvr()
  // The DA bvr we are referencing and its type
: m_id(NULL),
  m_rawbvr(NULL),
  m_typeId(CRINVALID_TYPEID),

  // Basic timing properties - only used to store values
  m_startOffset(0),
  m_duration(-1),
  m_repeatDur(-1),
  m_repeat(1),
  m_bAutoReverse(false),
  m_endOffset(0),
  m_easeIn(0.0),
  m_easeInStart(0.0),
  m_easeOut(0.0),
  m_easeOutEnd(0.0),
  m_syncFlags(0),

  // Calculated times
  m_totalDuration(0.0),
  m_segDuration(0.0),
  m_repDuration(0.0),
  m_totalRepDuration(0.0),
  m_absStartTime( MM_INFINITE ),
  m_absEndTime( MM_INFINITE ),
  m_depStartTime( MM_INFINITE ),
  m_depEndTime( MM_INFINITE ),

  m_player(NULL),
  m_parent(NULL),
  m_startSibling(NULL),
  m_endSibling(NULL),
  m_startType(MM_START_ABSOLUTE),

  m_cookie(0),
  m_bPaused(false),
  m_bPlaying(false),
  
  m_lastTick(-MM_INFINITE),
  m_startOnEventTime(-MM_INFINITE)
{
    TraceTag((tagMMBaseBvr,
              "CMMBaseBvr(%lx)::CMMBaseBvr()",
              this));
}

CMMBaseBvr::~CMMBaseBvr()
{
    TraceTag((tagMMBaseBvr,
              "CMMBaseBvr(%lx)::~CMMBaseBvr()",
              this));

    delete m_id;
}

HRESULT
CMMBaseBvr::BaseInit(LPOLESTR id, CRBvrPtr rawbvr)
{
    TraceTag((tagMMBaseBvr,
              "CMMBaseBvr(%lx)::BaseInit(%ls, %#lx)",
              id,
              rawbvr));
    
    HRESULT hr;

    CRLockGrabber __gclg;

    if (rawbvr == NULL)
    {
        hr = E_FAIL;
        goto done;
    }

    m_rawbvr = rawbvr;
    
    m_typeId = CRGetTypeId(m_rawbvr);
    
    Assert(m_typeId != CRUNKNOWN_TYPEID &&
           m_typeId != CRINVALID_TYPEID);
    
    m_startTimeBvr = CRModifiableNumber(MM_INFINITE);
    
    if (!m_startTimeBvr)
    {
        hr = CRGetLastError();
        goto done;
    }
    
    m_endTimeBvr = CRModifiableNumber(MM_INFINITE);

    if (!m_endTimeBvr)
    {
        hr = CRGetLastError();
        goto done;
    }
    
    m_timeControl = CRModifiableNumber(MM_INFINITE);

    if (!m_timeControl)
    {
        hr = CRGetLastError();
        goto done;
    }
    
    UpdateTotalDuration();
    
    if (id)
    {
        m_id = CopyString(id);
        
        if (m_id == NULL)
        {
            hr = E_OUTOFMEMORY;
            goto done;
        }
    }
    
    hr = S_OK;

  done:
    return hr;
}

void
CMMBaseBvr::UpdateTotalDuration()
{
    if (m_duration == -1 )
    {
        m_segDuration = MM_INFINITE;
    }
    else
    {
        m_segDuration = m_duration;
    }
    
    if (m_bAutoReverse)
    {
        m_repDuration = m_segDuration * 2;
    }
    else
    {
        m_repDuration = m_segDuration;
    }
        
    if (m_repeatDur != -1)
    {
        m_totalRepDuration = m_repeatDur;

        if (m_segDuration == MM_INFINITE)
        {
            // If our segment time was infinite but we had a repeat
            // dur we can really consider this to be the real duration
            m_segDuration = m_repDuration = m_repeatDur;
        }
    }
    else if (m_repeat == 0)
    {
        m_totalRepDuration = MM_INFINITE;
    }
    else
    {
        m_totalRepDuration = m_repeat * m_repDuration;
    }

    m_totalDuration = m_startOffset + m_totalRepDuration + m_endOffset;
}

void
CMMBaseBvr::Invalidate()
{
    TraceTag((tagMMBaseBvr,
              "CMMBaseBvr(%lx)::Invalidate()",
              this));

    UpdateTotalDuration();
    
    if (m_parent)
    {
        m_parent->Invalidate();
    }
}

bool
CMMBaseBvr::SetParent(CMMBaseBvr * parent,
                      MM_START_TYPE st,
                      CMMBaseBvr * startSibling)
{
    bool ok = false;
    
    // These will be cleared if we are called correctly
    
    Assert(!m_resultantbvr);
    Assert(m_parent == NULL);
    Assert(m_startTimeSinks.size() == 0);
    Assert(m_endTimeSinks.size() == 0);

    // Validate parameters

    switch (st)
    {
      case MM_START_ABSOLUTE:
        // This is not absolutely necessary but will ensure that if we
        // ever want to take a parameter we know that old code had
        // ensured that it was NULL
        
        if (startSibling != NULL)
        {
            CRSetLastError(E_INVALIDARG, NULL);
            goto done;
        }

        if (!UpdateAbsStartTime(m_startOffset, true))
        {
            goto done;
        }

        break;
      case MM_START_EVENT:
        // This is not absolutely necessary but will ensure that if we
        // ever want to take a parameter we know that old code had
        // ensured that it was NULL
        
        if (startSibling != NULL)
        {
            CRSetLastError(E_INVALIDARG, NULL);
            goto done;
        }

        if (!UpdateAbsStartTime(MM_INFINITE, true))
        {
            goto done;
        }

        break;
      case MM_START_WITH:
      case MM_START_AFTER:
        if (startSibling == NULL)
        {
            CRSetLastError(E_INVALIDARG, NULL);
            goto done;
        }

        if (!UpdateAbsStartTime(MM_INFINITE, true))
        {
            goto done;
        }

        break;
      default:
        CRSetLastError(E_INVALIDARG, NULL);
        goto done;
    }
    
    if (!UpdateAbsEndTime(GetAbsStartTime() + GetTotalRepDuration(), true))
    {
        goto done;
    }

    // Update args now that we know they are valid

    m_startType = st;
    m_startSibling = startSibling;
    m_parent = parent;

    ok = true;
  done:
    return ok;
}

bool
CMMBaseBvr::ClearParent()
{
    DetachFromSibling();
    
    m_startSibling = NULL;
    m_startType = MM_START_ABSOLUTE;
    m_parent = NULL;
  
    // There is no way for us to ensure this properly (since
    // dependents have no root anymore and our container usually
    // handles this), so our parent better have dealt with it
    while (!m_startTimeSinks.empty())
    {
        (m_startTimeSinks.front())->DetachFromSibling();
    }
    
    while (!m_endTimeSinks.empty())
    {
        (m_endTimeSinks.front())->DetachFromSibling();
    }

    Assert(m_startTimeSinks.size() == 0);
    Assert(m_endTimeSinks.size() == 0);

    // Just in case
    m_startTimeSinks.clear();
    m_endTimeSinks.clear();

    // Our resultant bvr is no longer valid - clear all constructed
    // behaviors
    DestroyBvr();

    UpdateAbsStartTime(MM_INFINITE, true);
    UpdateAbsEndTime(MM_INFINITE, true);

    return true;
}

bool
CMMBaseBvr::AttachToSibling()
{
    TraceTag((tagMMBaseBvr,
              "CMMBaseBvr(%lx)::AttachToSibling()",
              this));
    
    bool ok = false;
    switch(m_startType)
    {
      case MM_START_ABSOLUTE:
        Assert(m_startSibling == NULL);

        if (!UpdateAbsStartTime(m_startOffset, true))
        {
            goto done;
        }

        break;
      case MM_START_EVENT:
        Assert(m_startSibling == NULL);

        if (!UpdateAbsStartTime(MM_INFINITE, true))
        {
            goto done;
        }

        break;
      case MM_START_WITH:
        Assert(m_startSibling != NULL);

        // The sibling better have the same parent and it also should not
        // be NULL since it should have been added first
        
        Assert(m_startSibling->GetParent() != NULL);
        Assert(m_startSibling->GetParent() == m_parent);
        
        if (!m_startSibling->AddStartTimeSink(this))
        {
            goto done;
        }
        
        // Our absolute start time is the start time of the sibling
        // plus our start offset
        if (!UpdateAbsStartTime(m_startSibling->GetDepStartTime() + m_startOffset, true))
        {
            goto done;
        }

        break;
      case MM_START_AFTER:
        Assert(m_startSibling != NULL);

        // The sibling better have the same parent and it also should not
        // be NULL since it should have been added first
        
        Assert(m_startSibling->GetParent() != NULL);
        Assert(m_startSibling->GetParent() == m_parent);
        
        if (!m_startSibling->AddEndTimeSink(this))
        {
            goto done;
        }
        
        if (!UpdateAbsStartTime(m_startSibling->GetDepEndTime() + m_startOffset, true))
        {
            goto done;
        }

        break;
      default:
        Assert(!"CMMBaseBvr::AttachToSibling: Invalid start type");
        break;
    }

    if (!UpdateAbsEndTime(GetAbsStartTime() + GetTotalRepDuration(), true))
    {
        goto done;
    }

    ok = true;
  done:
    return ok;
}

void
CMMBaseBvr::DetachFromSibling()
{
    TraceTag((tagMMBaseBvr,
              "CMMBaseBvr(%lx)::DetachFromSibling()",
              this));
    if (NULL == m_startSibling)
    {
        return;
    }

    switch(m_startType)
    {
      case MM_START_ABSOLUTE:
      case MM_START_EVENT:
        Assert(m_startSibling == NULL);
        break;
      case MM_START_WITH:
        Assert(m_startSibling != NULL);
        m_startSibling->RemoveStartTimeSink(this);
        break;
      case MM_START_AFTER:
        Assert(m_startSibling != NULL);
        m_startSibling->RemoveEndTimeSink(this);
        break;
      default:
        Assert(!"CMMBaseBvr::DetachFromSibling: Invalid start type");
        break;
    }

    // always clear this.
    m_startSibling = NULL;
}

void
CMMBaseBvr::SetPlayer(CMMPlayer * player)
{
    Assert(m_player == NULL);
    Assert(!m_resultantbvr);
    
    m_player = player;

    // if we need to registered a Timer Callback, add it to the player.
    if (IsClockSource())
    {
        m_player->AddBvrCB(this);
    }
}

void
CMMBaseBvr::ClearPlayer()
{
    // We do not need to call Destroy since the clearplayer will do
    // the recursive calls and that would just waste time
    // Our resultant bvr is no longer valid
    ClearResultantBvr();

    // if we registered a Timer Callback, remove it from the player.
    // Make sure we check for the player since we may not have
    // actually set it yet.
    if (IsClockSource() && m_player)
    {
        m_player->RemoveBvrCB(this);
    }

    m_player = NULL;

}

bool
CMMBaseBvr::ConstructBvr(CRNumberPtr timeline)
{
    TraceTag((tagMMBaseBvr,
              "CMMBaseBvr(%lx)::ConstructBvr(%#lx)",
              this,
              timeline));

    bool ok = false;
    
    Assert(!m_resultantbvr);
    // We should never be able to do this w/o a player
    Assert(m_player != NULL);
    
    // Need the GC Lock
    CRLockGrabber __gclg;
    
    CRBvrPtr bvr;

    if ((bvr = EncapsulateBvr(m_rawbvr)) == NULL)
    {
        goto done;
    }

    // First substitute our own control so inside the control we will
    // always refer to local time and it will actually be the local
    // time of the parent since we subst time with the containers
    // timeline after this
    if ((bvr = CRSubstituteTime(bvr, m_timeControl)) == NULL)
    {
        goto done;
    }
    
    // Now subst time the container timer
    
    if ((bvr = CRSubstituteTime(bvr, timeline)) == NULL)
    {
        goto done;
    }
    
    // Update the time control to be consistent with our current state
    // since at this point it has never been set before.
    
    if (!UpdateTimeControl())
    {
        goto done;
    }
    
    // Store away the new bvr in our resultant behavior
    if (!UpdateResultantBvr(bvr))
    {
        goto done;
    }
    
    ok = true;
  done:
    return ok;
}

void
CMMBaseBvr::DestroyBvr()
{
    TraceTag((tagMMBaseBvr,
              "CMMBaseBvr(%lx)::DestroyBvr()",
              this));

    ClearResultantBvr();
}

bool
CMMBaseBvr::UpdateResultantBvr(CRBvrPtr bvr)
{
    Assert(!m_resultantbvr);
    Assert(m_cookie == 0);
    Assert(m_player != NULL);
    
    bool ok = false;
    
    // Run once the behavior so we get a handle to its performance
    if ((bvr = CRRunOnce(bvr)) == NULL)
    {
        goto done;
    }
    
    long cookie;
    
    if ((cookie = m_player->AddRunningBehavior(bvr)) == 0)
    {
        goto done;
    }
    
    m_cookie = cookie;
    m_resultantbvr = bvr;

    ok = true;
  done:
    return ok;
}

void
CMMBaseBvr::ClearResultantBvr()
{
    // Make this robust enough to call even if things are partially setup

    if (m_cookie)
    {
        // If we got here and the player is null then somethings
        // really wrong
        
        Assert(m_player);

        m_player->RemoveRunningBehavior(m_cookie);

        m_cookie = 0;
    }
    
    m_resultantbvr.Release();
}

CRBvrPtr
CMMBaseBvr::EncapsulateBvr(CRBvrPtr rawbvr)
{
    TraceTag((tagMMBaseBvr,
              "CMMBaseBvr(%lx)::EncapsulateBvr(%#lx)",
              this,
              rawbvr));

    // Do not need to get GC lock since we have to return a CRBvrPtr
    // and thus the caller must have already acquired it
    
    CRBvrPtr newBvr = NULL;

    // Make sure we calculate the ease in/out coeff
    
    CalculateEaseCoeff();
    
    CRBvrPtr curbvr;

    curbvr = rawbvr;

    CRNumberPtr zeroTime;
    CRNumberPtr durationTime;
    
    if (m_bNeedEase)
    {
        CRNumberPtr time;

        if ((time = EaseTime(CRLocalTime())) == NULL)
        {
            goto done;
        }

        if ((curbvr = CRSubstituteTime(curbvr, time)) == NULL)
        {
            goto done;
        }
    }

    if ((zeroTime = CRCreateNumber(0)) == NULL)
    {
        goto done;
    }
    

    if ((durationTime = CRCreateNumber(m_segDuration)) == NULL)
    {
        goto done;
    }
    
    // For now clamp to the duration as well

    CRNumberPtr timeSub;
    CRBooleanPtr cond;

    if (m_bAutoReverse)
    {
        CRNumberPtr totalTime;
    
        // Invert time from duration to repduration and clamp to
        // zero
        
        if ((totalTime = CRCreateNumber(m_repDuration)) == NULL ||
            (timeSub = CRSub(totalTime, CRLocalTime())) == NULL ||
            (cond = CRLTE(timeSub, zeroTime)) == NULL ||
            (timeSub = (CRNumberPtr) CRCond(cond,
                                            (CRBvrPtr) zeroTime,
                                            (CRBvrPtr) timeSub)) == NULL)
            goto done;
    } else {
        timeSub = durationTime;
    }
    
    // We are localTime until the duration and then we are whatever
    // timeSub is currently set to from above (either clamped for
    // duration time for non-autoreversed or reversed for the autoreverse case)

    if ((cond = CRGTE(CRLocalTime(), durationTime)) == NULL ||
        (timeSub = (CRNumberPtr) CRCond(cond,
                                        (CRBvrPtr) timeSub,
                                        (CRBvrPtr) CRLocalTime())) == NULL)
        goto done;

    // Substitute the clock and clamp to the duration
    
    if (IsContinuousMediaBvr())
    {
        if (!(m_repeat == 0 && m_typeId == CRSOUND_TYPEID))
        {
            if ((curbvr = CRDuration(curbvr, m_segDuration)) == NULL)
                goto done;
        }
    }
    else
    {
        if ((curbvr = CRSubstituteTime(curbvr, timeSub)) == NULL ||
            (curbvr = CRDuration(curbvr, m_repDuration)) == NULL)
            goto done;
    }

    if (m_repeat != 1)
    {
        if (m_repeat == 0)
        {
            curbvr = CRRepeatForever(curbvr);
        }
        else
        {
            curbvr = CRRepeat(curbvr, m_repeat);
        }

        if (curbvr == NULL)
            goto done;
    }

    // We have a total time so add another duration node
    if (m_repeatDur != -1.0f)
    {
        if ((curbvr = CRDuration(curbvr, m_totalRepDuration)) == NULL)
        {
            goto done;
        }
    }
    
    //
    // We now need to add the start and end hold
    //

    // Offset by the start offset
    if ((timeSub = CRSub(CRLocalTime(), GetStartTimeBvr())) == NULL)
    {
        goto done;
    }
        
    if ((cond = CRGTE(timeSub, zeroTime)) == NULL)
    {
        goto done;
    }
        
    if ((timeSub = (CRNumberPtr) CRCond(cond,
                                        (CRBvrPtr) timeSub,
                                        (CRBvrPtr) zeroTime)) == NULL)
    {
        goto done;
    }
    
    // Now add the end hold and reset to 0 local time after the
    // interval

    CRNumberPtr endholdtime;

    if (m_endOffset != 0.0f)
    {
        // There is an offset so we need to hold the end time behavior
        // for the m_endOffset time
        
        if ((cond = CRGT(CRLocalTime(), GetEndTimeBvr())) == NULL)
        {
            goto done;
        }

        CRNumberPtr dur;

        if ((dur = CRSub(GetEndTimeBvr(), GetStartTimeBvr())) == NULL)
        {
            goto done;
        }
        
        if ((timeSub = (CRNumberPtr) CRCond(cond,
                                            (CRBvrPtr) dur,
                                            (CRBvrPtr) timeSub)) == NULL)
        {
            goto done;
        }

        // Now calculate the end hold time.  It is the behavior end of
        // the behavior plus the end hold value
        if ((endholdtime = CRCreateNumber(m_endOffset)) == NULL)
        {
            goto done;
        }
        
        if ((endholdtime = CRAdd(endholdtime, GetEndTimeBvr())) == NULL)
        {
            goto done;
        }
    }
    else
    {
        // The end time is the end time of the behavior
        endholdtime = GetEndTimeBvr();
    }
    
    if ((cond = CRGT(CRLocalTime(), endholdtime)) == NULL)
    {
        goto done;
    }
    
    if ((timeSub = (CRNumberPtr) CRCond(cond,
                                        (CRBvrPtr) zeroTime,
                                        (CRBvrPtr) timeSub)) == NULL)
    {
        goto done;
    }
    
    if ((curbvr = CRSubstituteTime(curbvr, timeSub)) == NULL)
    {
        goto done;
    }
    
    // indicate success
    newBvr = curbvr;
    
  done:
    return newBvr;
}

bool
CMMBaseBvr::UpdateTimeControl(/*bool bReset, double lTime*/)
{
    TraceTag((tagMMBaseBvr,
              "CMMBaseBvr(%lx)::UpdateTimeControl()",
              this));

    bool ok = false;

    CRLockGrabber __gclg;

    CRNumberPtr tc;
    DWORD dwFlags;
    
    tc = CRLocalTime();
    dwFlags = CRContinueTimeline;

/*
    if ((tc = CRAdd(GetStartTimeBvr(), CRLocalTime())) == NULL)
    {
        goto done;
    }
*/
    tc = CRLocalTime();
    
    if (!CRSwitchTo((CRBvrPtr) m_timeControl.p,
                    (CRBvrPtr) tc,
                    true,
                    dwFlags,
                    0.0))
        goto done;
    
    ok = true;
  done:
    return ok;
}

bool
CMMBaseBvr::AddStartTimeSink( CMMBaseBvr * sink )
{
    m_startTimeSinks.push_back( sink );
    return true;
}

void
CMMBaseBvr::RemoveStartTimeSink( CMMBaseBvr * sink )
{
    m_startTimeSinks.remove( sink );
}

bool
CMMBaseBvr::AddEndTimeSink( CMMBaseBvr* sink )
{
    m_endTimeSinks.push_back( sink );
    return true;
}

void
CMMBaseBvr::RemoveEndTimeSink( CMMBaseBvr* sink )
{
    m_endTimeSinks.remove( sink );
}

HRESULT
CMMBaseBvr::Begin(bool bAfterOffset)
{
    TraceTag((tagMMBaseBvr,
              "CMMBaseBvr(%lx)::Begin(%d)",
              this,
              bAfterOffset));

    HRESULT hr;
    bool ok = false;
    CallBackList l;
    
    // If no parent set this is an error
    if (m_parent == NULL || m_player == NULL)
    {
        CRSetLastError(E_FAIL, NULL);
        goto done;
    }

    if (m_startType == MM_START_WITH ||
        m_startType == MM_START_AFTER)
    {
        CRSetLastError(E_FAIL, NULL);
        goto done;
    }

    // Get the current time of our parent
    double st;

    st = GetContainerSegmentTime();
    if(m_startType == MM_START_EVENT)
    {
        m_lastTick = -MM_INFINITE;
        m_startOnEventTime = st;
    }

    // If our container time is indeterminate then just ignore the
    // call
    if (st == MM_INFINITE || GetParent()->IsPlaying() == false)
    {
        Assert(!IsPlaying());
        
        // Return success: TODO: Need a real error message
        ok = true;
        goto done;
    }
    
    if (!StartTimeVisit(st, &l, bAfterOffset))
    {
        goto done;
    }

    if (!ProcessCBList(l))
    {
        goto done;
    }
    
    m_bPaused = false;
    ok = true;
    
  done:
    return ok?S_OK:Error();
}

HRESULT
CMMBaseBvr::Reset(DWORD fCause)
{
    TraceTag((tagMMBaseBvr,
              "CMMBaseBvr(%lx)::Reset()",
              this));

    HRESULT hr;
    bool ok = false;
    CallBackList l;
    MMBaseBvrList::iterator i;
    
    if (m_player == NULL)
    {
        CRSetLastError(E_FAIL, NULL);
        goto done;
    }

    if (m_startType == MM_START_WITH ||
        m_startType == MM_START_AFTER)
    {
        AssertStr(false, _T("Reset called with startType of START_WITH or START_AFTER"));
        CRSetLastError(E_FAIL, NULL);
        goto done;
    }

    double st;
    st = GetContainerSegmentTime();


    switch(m_startType)
    {
    case MM_START_ABSOLUTE:
        if (st != MM_INFINITE)
        {
            if (!StartTimeVisit(st, &l, false, true, fCause))
            {
                goto done;
            }
        }
        else
        {
            if(!UpdateAbsStartTime(GetStartTime(), true))
            {
                goto done;
            }
            if(!UpdateAbsEndTime(GetAbsStartTime() + GetTotalRepDuration(), true))
            {
                goto done;
            }
        }
        break;
    case MM_START_EVENT:
        double stopTime, startTime, startOffset;
        startOffset = GetStartOffset();
        if( GetAbsStartTime() != MM_INFINITE)
        {
            if(!UpdateAbsStartTime(m_startOnEventTime + startOffset, true))
            {
                goto done;
            }
            if(!UpdateAbsEndTime(GetAbsStartTime() + GetTotalRepDuration(), true))
            {
                goto done;
            }
        }
        stopTime = GetAbsEndTime();
        startTime = GetAbsStartTime();
        if( IsPlaying())
        {
            if( st >= stopTime)
            {
                if (!ProcessEvent(&l, stopTime - GetAbsStartTime(),
                                true,
                                MM_STOP_EVENT, fCause))
                {
                    goto done;
                }
            }
            if( st <= startTime)
            {
                if (!ProcessEvent(&l, 0.0,
                                true,
                                MM_STOP_EVENT, fCause))
                {
                    goto done;
                }
                m_lastTick = -MM_INFINITE;
            }
        }
        else
        {
            if(GetAbsStartTime() == MM_INFINITE) //never played do nothing
                break;
            if (!ProcessEvent(&l, st - GetAbsStartTime(),
                            true,
                            MM_PLAY_EVENT, fCause))
            {
                goto done;
            }
            m_lastTick = -MM_INFINITE;
            
        }
        // Go through all the begin afters and reset them - this means
        // they will get the new end time from this behavior
        
        {
            for (MMBaseBvrList::iterator i = m_endTimeSinks.begin(); 
                 i != m_endTimeSinks.end(); 
                 i++)
            {
                if (FAILED((*i)->End()))
                {
                    goto done;
                }
                
                // Now reset them
                if (!(*i)->ResetBvr(&l))
                {
                    goto done;
                }
            }
        }


        break;
    default:
        break;
    }
    
    if (GetParent())
    {
        if ( !GetParent()->ReconstructBvr(this) )
            goto done;
    }

    if (!ProcessCBList(l))
    {
        goto done;
    }

    // Return error because we could not reconstruct the DA bvr.
    // Note: We do not check for this at the beginning of the function
    // because we want to allow refresh of timing structures by
    // setting a property on the body (editor-clocksourcing bug)
    if (m_parent == NULL)
    {
        CRSetLastError(E_FAIL, NULL);
        goto done;
    }

    ok = true;
    
  done:
    return ok?S_OK:Error();
}

HRESULT
CMMBaseBvr::ResetOnEventChanged(bool bBeginEvent)
{   
    HRESULT hr;
    CallBackList l;
    bool ok = false;
    
    // If no parent set this is an error
    if (m_parent == NULL || m_player == NULL)
    {
        CRSetLastError(E_FAIL, NULL);
        goto done;
    }

    if (m_startType == MM_START_WITH ||
        m_startType == MM_START_AFTER)
    {
        AssertStr(false, _T("Reset called with startType of START_WITH or START_AFTER"));
        CRSetLastError(E_FAIL, NULL);
        goto done;
    }

    double st;
    st = GetContainerSegmentTime();

    if (bBeginEvent)
    {
        m_startType = MM_START_EVENT;

        // begin event was turned on -- we need to turn off.
        if (!ProcessEvent(&l, st - GetAbsStartTime(),
            true,
            MM_STOP_EVENT, MM_EVENT_PROPERTY_CHANGE))
        {
            goto done;
        }
        
        if ( !UpdateAbsStartTime(MM_INFINITE, true) )
        {
            goto done;
        }
        if ( !UpdateAbsEndTime(MM_INFINITE, true) )
        {
            goto done;
        }
    }
    else
    {
        // end event was turned off -- we need to turn on.
        if ( !UpdateAbsEndTime(GetAbsStartTime() + GetTotalRepDuration(), true) )
        {
            goto done;
        }

        if (!ProcessEvent(&l, st - GetAbsStartTime(),
            true,
            MM_PLAY_EVENT, MM_EVENT_PROPERTY_CHANGE))
        {
            goto done;
        }
    }

    Assert(GetParent() != NULL);
    if (!GetParent()->ReconstructBvr(this))
    {
        goto done;
    }

    if (!ProcessCBList(l))
    {
        goto done;
    }

    ok = true;
done:
    return ok?S_OK:Error();
}
    

HRESULT
CMMBaseBvr::End()
{
    TraceTag((tagMMBaseBvr,
              "CMMBaseBvr(%lx)::End()",
              this));

    HRESULT hr;
    bool ok = false;
    CallBackList l;
    
    // If no parent set this is an error
    if (m_parent == NULL || m_player == NULL)
    {
        CRSetLastError(E_FAIL, NULL);
        goto done;
    }

    // Get the current time of our parent
    double st;

    st = GetContainerSegmentTime();

    // If our container time is indeterminate then just ignore the
    // call
    if (st == MM_INFINITE ||
        !IsPlaying())
    {
        // Return success: TODO: Need a real error message
        ok = true;
        goto done;
    }
    
    if (!EndTimeVisit(st, &l))
    {
        goto done;
    }

    if (!ProcessCBList(l))
    {
        goto done;
    }
    
    m_bPaused = false;
    ok = true;
    
  done:
    return ok?S_OK:Error();
}

HRESULT
CMMBaseBvr::Pause()
{
    TraceTag((tagMMBaseBvr,
              "CMMBaseBvr(%lx)::Pause()",
              this));

    HRESULT hr;
    bool ok = false;
    
    if (!IsPlaying())
    {
        CRSetLastError(E_FAIL, NULL);
        goto done;
    }
    
    if (IsPaused())
    {
        m_bPaused = true;
        ok = true;
        goto done;
    }
    
    m_bPaused = true;
    ok = true;
  done:
    return ok?S_OK:Error();
}

HRESULT
CMMBaseBvr::Run()
{
    TraceTag((tagMMBaseBvr,
              "CMMBaseBvr(%lx)::Run()",
              this));

    HRESULT hr;
    bool ok = false;
    
    if (!IsPlaying())
    {
        CRSetLastError(E_FAIL, NULL);
        goto done;
    }
    
    if (!IsPaused())
    {
        m_bPaused = false;
        ok = true;
        goto done;
    }
    
    m_bPaused = false;
    ok = true;
  done:
    return ok?S_OK:Error();
}

// This takes times which are post ease (since this is what the user
// sees)

HRESULT
CMMBaseBvr::Seek(double lTime)
{
    TraceTag((tagMMBaseBvr,
              "CMMBaseBvr(%lx)::Seek(%g)",
              this,
              lTime));

    bool ok = false;

    // Ensure that the player has been set
    if (NULL == m_player)
    {
        CRSetLastError(E_FAIL, NULL);
        goto done;
    }

    // Enforce rule for seeking only when paused.
    // TODO: this should actually be checking local play state (this->m_state), 
    // but for now we use global play state (m_player->m_state)
    // so we can seek only when whole document is paused
    if(!m_player->IsPaused())
    {
        CRSetLastError(E_FAIL, NULL);
        goto done;
    }
    
    // This checks the local play state 
    // (dilipk:) Maybe redundant; looks like local play state is not used anywhere.
    if (!IsPlaying())
    {
        CRSetLastError(E_FAIL, NULL);
        goto done;
    }
    
    double curTime;

    curTime = GetCurrentLocalTime();

    if (curTime == MM_INFINITE)
    {
        // I don't think this is possible but just in case handle it
        
        TraceTag((tagError,
                  "Seek: Current time was infinite - not valid"));

        CRSetLastError(E_FAIL, NULL);
        goto done;
    }

    if (!_Seek(curTime, lTime))
    {
        goto done;
    }
    
    ok = true;
  done:
    return ok?S_OK:Error();
}

// This takes pure local timeline times (pre-ease)

bool
CMMBaseBvr::_Seek(double curTime, double newTime)
{
    TraceTag((tagMMBaseBvr,
              "CMMBaseBvr(%lx)::Seek(%g, %g)",
              this,
              curTime,
              newTime));

    HRESULT hr;
    bool ok = false;
    
    Assert(curTime != MM_INFINITE);
    
    if (curTime == newTime)
    {
        ok = true;
        goto done;
    }
    
    if (IsLocked())
    {
        // Need to determine where to tell our parent to seek to so we
        // are at the new time.

        if (m_parent)
        {
            // TODO: !!!! This does not work - needs to take into
            // where the current parent base code is.
#if 0
            // The code needs to look something like this
            double parentNewTime = 0;
            
            double curParentTime = m_parent->GetCurrentLocalTime();

            // See if we were active last time - if not then use a
            // zero base
            if (curParentTime != MM_INFINITE)
            {
                // Need to calculate the base offset of the parent
                parentNewTime += m_parent->LocalTimeToSegmentBase(curParentTime);

            }
            
#endif
            double parentCurTime = m_parent->ReverseEaseTime(GetAbsStartTime() + curTime);
            double parentNewTime = m_parent->ReverseEaseTime(GetAbsStartTime() + newTime);
        
            hr = THR(m_parent->_Seek(parentCurTime, parentNewTime));

            if (FAILED(hr))
            {
                CRSetLastError(E_FAIL, NULL);
                goto done;
            }
        }
        else
        {
            // This means everything is locked and so we cannot seek
            CRSetLastError(E_FAIL, NULL);
            goto done;
        }
    }
    else
    {
        CallBackList l;

        //
        // if you change the order of this (stop event, play event) you will break a 
        // dependency in mmnotify.cpp : CMMBaseBvr::ProcessEvent(...)
        // jeffwall 2/22/99
        //

        if (!ProcessEvent(&l, curTime, true, MM_STOP_EVENT, MM_EVENT_SEEK))
        {
            goto done;
        }
        
        
        if (!ProcessEvent(&l, newTime, true, MM_PLAY_EVENT, MM_EVENT_SEEK))
        {
            goto done;
        }
        
        // We need to move our start time back by the amount we want to
        // move forward.  This means that we would have started that
        // amount in the past
        if (!UpdateAbsStartTime(GetAbsStartTime() - (newTime - curTime), false))
        {
            goto done;
        }
        
        // Do the same for the end time
        if (!UpdateAbsEndTime(GetAbsEndTime() - (newTime - curTime), true))
        {
            goto done;
        }
        
        // Go through all the begin afters and reset them - this means
        // they will get the new end time from this behavior
        
        {
            for (MMBaseBvrList::iterator i = m_endTimeSinks.begin(); 
                 i != m_endTimeSinks.end(); 
                 i++)
            {
                if (FAILED((*i)->End()))
                {
                    goto done;
                }
                
                // Now reset them
                if (!(*i)->ResetBvr(&l))
                {
                    goto done;
                }
            }
        }

        if (!ProcessCBList(l))
        {
            goto done;
        }
    }
    
    ok = true;
  done:
    return ok;
}

// This takes real times (post-ease)

bool
CMMBaseBvr::Sync(double newTime, double nextGlobalTime)
{
    TraceTag((tagMMBaseBvr,
              "CMMBaseBvr(%lx)::Sync(%g, %g)",
              this,
              newTime,
              nextGlobalTime));

    HRESULT hr;
    bool ok = false;
    
    Assert(newTime != MM_INFINITE);
    
    if (IsLocked())
    {
        // Need to determine where to tell our parent to seek to so we
        // are at the new time.

        if (m_parent)
        {
            double parentNewTime = 0;
            
            double curParentTime = m_parent->GetCurrentLocalTime();

            // See if we were active last time - if not then use a
            // zero base
            if (curParentTime != MM_INFINITE)
            {
                // Need to calculate the base offset of the parent
                parentNewTime += m_parent->LocalTimeToSegmentBase(curParentTime);

            }
            
            // Add the start offset
            parentNewTime += GetAbsStartTime();

            // If the newTime 
            if (newTime != -MM_INFINITE)
            {
                parentNewTime += newTime;
            }
            else
            {
                // If we have not started yet and the newtime also
                // indicates that we have not started then we need to
                // make our parent not start yet either
                if (parentNewTime <= 0)
                {
                    parentNewTime = -MM_INFINITE;
                }
            }
        
            hr = THR(m_parent->Sync(parentNewTime, nextGlobalTime));

            if (FAILED(hr))
            {
                CRSetLastError(E_FAIL, NULL);
                goto done;
            }
        }
        else
        {
            // This means everything is locked and so we cannot seek
            CRSetLastError(E_FAIL, NULL);
            goto done;
        }
    }
    else
    {
        double newParentTime = nextGlobalTime;
        
        if (m_parent)
        {
            newParentTime = m_parent->GlobalTimeToLocalTime(newParentTime);
        }
        
        // If our parent is going to end next time them anything we do
        // is irrelevant
        if (newParentTime == MM_INFINITE)
        {
            ok = true;
            goto done;
        }
            
        if (newTime == -MM_INFINITE)
        {
            newTime = -BEGIN_HOLD_EPSILON;
        }
        
        // In order for us to be at newTime next frame take:
        // starttime + localtime == parent time
        // so set starttime = parent time - localtime
        
        if (!UpdateSyncTime(newParentTime - newTime))
        {
            goto done;
        }
    }
    
    ok = true;
  done:
    return ok;
}

bool
CMMBaseBvr::UpdateSyncTime(double newtime)
{
    TraceTag((tagMMBaseBvr,
              "CMMBaseBvr(%lx)::UpdateSyncTime(%g)",
              this,
              newtime));

    bool ok = false;

    if (!UpdateAbsStartTime(newtime, true))
    {
        goto done;
    }
    
    // Now update the end time based on the new start time
    if (!UpdateAbsEndTime(GetAbsStartTime() + GetTotalRepDuration(), true))
    {
        goto done;
    }
    
    // Update all the start syncs - unless they are already running
    
    {
        for (MMBaseBvrList::iterator i = m_startTimeSinks.begin(); 
             i != m_startTimeSinks.end(); 
             i++)
        {
            if (!(*i)->IsPlaying())
            {
                if (!(*i)->UpdateSyncTime(GetAbsStartTime()))
                {
                    goto done;
                }
            }
        }
    }

    {
        for (MMBaseBvrList::iterator i = m_endTimeSinks.begin(); 
             i != m_endTimeSinks.end(); 
             i++)
        {
            if (!(*i)->IsPlaying())
            {
                if (!(*i)->UpdateSyncTime(GetAbsEndTime()))
                {
                    goto done;
                }
            }
        }
    }
    
    ok = true;
  done:
    return ok;
}

double
CMMBaseBvr::GetContainerSegmentTime()
{
    TraceTag((tagMMBaseBvr,
              "CMMBaseBvr(%lx)::GetContainerSegmentTime()",
              this));

    double ret = MM_INFINITE;
    
    if (m_parent)
    {
        ret = m_parent->GetCurrentSegmentTime();
    }
    else if (m_player)
    {
        // We need to get the time from the player itself
        ret = m_player->GetCurrentTime();
    }
    
    return ret;
}

double
CMMBaseBvr::GetCurrentLocalTime()
{
    TraceTag((tagMMBaseBvr,
              "CMMBaseBvr(%lx)::GetCurrentLocalTime()",
              this));

    double ret = MM_INFINITE;

    if (m_player)
    {
        ret = GlobalTimeToLocalTime(m_player->GetCurrentTime());
    }

    return ret;
}

double
CMMBaseBvr::GetCurrentLocalTimeEx()
{
    TraceTag((tagMMBaseBvr,
              "CMMBaseBvr(%lx)::GetCurrentLocalTime()",
              this));

    double ret = -MM_INFINITE;

    if (m_player)
    {
        ret = GlobalTimeToLocalTimeEx(m_player->GetCurrentTime());
    }

    return ret;
}

double
CMMBaseBvr::GetCurrentSegmentTime()
{
    TraceTag((tagMMBaseBvr,
              "CMMBaseBvr(%lx)::GetCurrentSegmentTime()",
              this));

    // Get our container's time
    double ret = GetCurrentLocalTime();

    // If the container's local time is infinite then so is ours
    if (ret != MM_INFINITE)
    {
        ret = LocalTimeToSegmentTime(ret);
    }
    
    return ret;
}

double
CMMBaseBvr::LocalTimeToSegmentBase(double t)
{
    TraceTag((tagMMBaseBvr,
              "CMMBaseBvr(%lx)::LocalTimeToSegmentBase(%g)",
              this,
              t));

    double ret = 0;
    
    // Most of this is copied from mmnotify to ensure we calc it the
    // same as the notifications
    if (t != MM_INFINITE && m_segDuration != MM_INFINITE)
    {
        // We need this to round down to the previous boundary
        // point but not inclusive of the boundary point
        // itself.
        int offset = ceil(t / m_segDuration) - 1;
        if (offset < 0)
        {
            offset = 0;
        }
        
        ret = offset * m_segDuration;
    }

    return ret;
}

double
CMMBaseBvr::LocalTimeToSegmentTime(double t)
{
    TraceTag((tagMMBaseBvr,
              "CMMBaseBvr(%lx)::LocalTimeToSegmentTime(%g)",
              this,
              t));

    double ret = t;
    
    // Most of this is copied from mmnotify to ensure we calc it the
    // same as the notifications
    if (ret != MM_INFINITE && ret != -MM_INFINITE && m_segDuration != MM_INFINITE)
    {
        // We need this to round down to the previous boundary
        // point but not inclusive of the boundary point
        // itself.
        int offset = ceil(ret / m_segDuration) - 1;
        if (offset < 0)
        {
            offset = 0;
        }
        
        ret = ret - (offset * m_segDuration);

        // If we have autoreverse set and the offset is odd then we
        // are in the reverse segment and need to flip the time to
        // indicate we were moving backwards
        if (m_bAutoReverse && (offset & 0x1))
        {
            ret = m_segDuration - ret;
        }
    }

    // Last thing is we need to ease the time
    
    ret = EaseTime(ret);
    
    return ret;
}

double
CMMBaseBvr::GlobalTimeToLocalTime(double gt)
{
    TraceTag((tagMMBaseBvr,
              "CMMBaseBvr(%lx)::GlobalTimeToLocalTime(%g)",
              this,
              gt));

    double ret = gt;
    
    if (m_parent)
    {
        ret = m_parent->GlobalTimeToLocalTime(ret);

        if (ret == MM_INFINITE)
        {
            goto done;
        }

        // Now convert to our our segment time
        ret = m_parent->LocalTimeToSegmentTime(ret);
    }
    else
    {
        // Fall through since the parent time is global time
    }
    
    // If we are not inside our range then our local time is
    // infinite
    if (ret >= GetAbsStartTime() &&
        ret <= GetAbsEndTime())
    {
        // Convert our container's time to our local time
        ret = ret - GetAbsStartTime();
    }
    else
    {
        ret = MM_INFINITE;
    }
    
  done:
    return ret;
}


double
CMMBaseBvr::GlobalTimeToLocalTimeEx(double gt)
{
    TraceTag((tagMMBaseBvr,
              "CMMBaseBvr(%lx)::GlobalTimeToLocalTime(%g)",
              this,
              gt));

    double ret = gt;
    
    if (m_parent)
    {
        ret = m_parent->GlobalTimeToLocalTimeEx(ret);

        if (ret == MM_INFINITE || ret == -MM_INFINITE)
        {
            goto done;
        }

        // Now convert to our our segment time
        ret = m_parent->LocalTimeToSegmentTime(ret);
    }
    else
    {
        // Fall through since the parent time is global time
    }
    
    // If we are not inside our range then our local time is
    // infinite
    if (ret >= GetAbsStartTime() &&
        ret <= GetAbsEndTime())
    {
        // Convert our container's time to our local time
        ret = ret - GetAbsStartTime();
    }
    else if (ret > GetAbsEndTime())
    {
        ret = MM_INFINITE;
    }
    else
    {
        ret = -MM_INFINITE;
    }
    
  done:
    return ret;
}

bool
CMMBaseBvr::UpdateAbsStartTime(double f,
                               bool bUpdateDepTime)
{
    TraceTag((tagMMBaseBvr,
              "CMMBaseBvr(%lx)::UpdateAbsStartTime(%g)",
              this,
              f));

    if (bUpdateDepTime)
    {
        m_depStartTime = f;
    }

    m_absStartTime = f;

    CRLockGrabber __gclg;
    return CRSwitchToNumber(m_startTimeBvr, f);
}

bool
CMMBaseBvr::UpdateAbsEndTime(double f,
                             bool bUpdateDepTime)
{
    TraceTag((tagMMBaseBvr,
              "CMMBaseBvr(%lx)::UpdateAbsEndTime(%g)",
              this,
              f));

    if (bUpdateDepTime)
    {
        m_depEndTime = f;
    }
    
    m_absEndTime = f;

    CRLockGrabber __gclg;
    return CRSwitchToNumber(m_endTimeBvr, f);
}

// This takes the absolute time to begin.
// If bAfterOffset is true then the time passed in is the time after
// the startoffset, otherwise it is the time before the startoffset

bool 
CMMBaseBvr::StartTimeVisit(double time,
                           CallBackList * l,
                           bool bAfterOffset,
                           bool bReset /* = false */,
                           DWORD fCause /* = 0 */ )
{
    TraceTag((tagMMBaseBvr,
              "CMMBaseBvr(%lx)::StartTimeVisit(%g, %#lx, %d)",
              this,
              time,
              l,
              bAfterOffset));

    bool ok = false;
    double sTime = time;
    
    if (!ResetBvr(l, false))
    {
        goto done;
    }
    
    if (bReset)
    {
        sTime = m_startOffset;
    }
    else if (!bAfterOffset)
    {
        // Need to add our offset to get the real start time
        sTime += m_startOffset;
    }
    
    if (!UpdateAbsStartTime(sTime, true))
    {
        goto done;
    }


    if (!UpdateAbsEndTime(GetAbsStartTime() + GetTotalRepDuration(), true))
    {
        goto done;
    }

    if (!ProcessEvent(l, time - sTime, true, MM_PLAY_EVENT, fCause))
    {
        goto done;
    }
    
    {
        for (MMBaseBvrList::iterator i = m_startTimeSinks.begin(); 
             i != m_startTimeSinks.end(); 
             i++)
        {
            if (!(*i)->StartTimeVisit(sTime, l, false, false, fCause))
            {
                goto done;
            }
        }
    }

    // Go through all the begin afters and reset them - this means
    // they will get the new end time from this behavior
    
    {
        for (MMBaseBvrList::iterator i = m_endTimeSinks.begin(); 
             i != m_endTimeSinks.end(); 
             i++)
        {
            if (FAILED((*i)->End()))
            {
                goto done;
            }

            // Now reset them
            if (!(*i)->ResetBvr(l))
            {
                goto done;
            }
        }
    }
    
    ok = true;
  done:
    return ok;
}

bool 
CMMBaseBvr::EndTimeVisit(double time,
                         CallBackList * l)
{
    TraceTag((tagMMBaseBvr,
              "CMMBaseBvr(%lx)::EndTimeVisit(%g, %#lx)",
              this,
              time,
              l));

    bool ok = false;

    if (!UpdateAbsEndTime(time, true))
    {
        goto done;
    }

    // Turn off play variable so we do not get into infinite recursion
    // handling the end sync
    m_bPlaying = false;
    
    if (!ProcessEvent(l, time - GetAbsStartTime(),
                      true,
                      MM_STOP_EVENT, 0))
    {
        goto done;
    }
    
    // Since we only have beginafters and not endwiths call all the
    // starttimevisit methods
    
    {
        for (MMBaseBvrList::iterator i = m_endTimeSinks.begin(); 
             i != m_endTimeSinks.end(); 
             i++)
        {
            if (!(*i)->StartTimeVisit(time, l, false))
            {
                goto done;
            }
        }
    }
    
    ok = true;
  done:
    return ok;
}

bool
CMMBaseBvr::ResetBvr(CallBackList * l,
                     bool bProcessSiblings)
{
    TraceTag((tagMMBaseBvr,
              "CMMBaseBvr(%lx)::ResetBvr(%lx, %d)",
              this,
              l,
              bProcessSiblings));

    bool ok = false;

    if (IsPlaying())
    {
        if (!EventNotify(l, 0.0, MM_RESET_EVENT, 0))
        {
            goto done;
        }
    }
    
    // Reset state variables
    
    m_bPlaying = false;
    m_bPaused = false;
    
    m_lastTick = -MM_INFINITE;
    
    switch(m_startType)
    {
      case MM_START_ABSOLUTE:
        if (!UpdateAbsStartTime(m_startOffset, true))
        {
            goto done;
        }

        break;
      case MM_START_EVENT:
        if (!UpdateAbsStartTime(MM_INFINITE, true))
        {
            goto done;
        }

        break;
      case MM_START_WITH:
        Assert(m_startSibling != NULL);

        if (!UpdateAbsStartTime(m_startSibling->GetDepStartTime() + m_startOffset, true))
        {
            goto done;
        }

        break;
      case MM_START_AFTER:
        Assert(m_startSibling != NULL);

        if (!UpdateAbsStartTime(m_startSibling->GetDepEndTime() + m_startOffset, true))
        {
            goto done;
        }

        break;
      default:
        Assert(!"CMMBaseBvr::ResetBvr: Invalid start type");
        break;
    }

    if (!UpdateAbsEndTime(GetAbsStartTime() + GetTotalRepDuration(), true))
    {
        goto done;
    }


    if (bProcessSiblings)
    {
        // Now go through our peers which depend on us and reset them
        
        {
            for (MMBaseBvrList::iterator i = m_startTimeSinks.begin(); 
                 i != m_startTimeSinks.end(); 
                 i++)
            {
                if (!(*i)->ResetBvr(l))
                {
                    goto done;
                }
            }
        }
        
        {
            for (MMBaseBvrList::iterator i = m_endTimeSinks.begin(); 
                 i != m_endTimeSinks.end(); 
                 i++)
            {
                if (!(*i)->ResetBvr(l))
                {
                    goto done;
                }
            }
        }
    }

    ok = true;
  done:
    return ok;
}
    
// This indicates whether the behavior is on the timeline and has not
// finished playing

bool
CMMBaseBvr::IsPlayable(double t)
{
    // If we are on the timeline yet and have not end then we are
    // playable
    
    // If we are on the end time then consider us stopped
    
    return (GetAbsStartTime() != MM_INFINITE &&
            GetAbsEndTime() > t);
}

#if _DEBUG
void
CMMBaseBvr::Print(int spaces)
{
    _TCHAR buf[1024];

    _stprintf(buf, __T("%*s[this = %p, id = %ls, dur = %g, ttrep = %g, tt = %g, rep = %d, autoreverse = %d]\r\n"),
            spaces,"",
            this,
            m_id,
            m_segDuration,
            m_totalRepDuration,
            m_totalDuration,
            m_repeat,
            m_bAutoReverse);

    OutputDebugString(buf);
}
#endif

class __declspec(uuid("f912d958-5c28-11d2-b957-3078302c2030"))
BvrGuid {};

HRESULT WINAPI
CMMBaseBvr::BaseInternalQueryInterface(CMMBaseBvr* pThis,
                                       void * pv,
                                       const _ATL_INTMAP_ENTRY* pEntries,
                                       REFIID iid,
                                       void** ppvObject)
{
    // Do not do an addref but return the original this pointer to
    // give access to the class pointer itself.
    
    if (InlineIsEqualGUID(iid, __uuidof(BvrGuid)))
    {
        *ppvObject = pThis;
        return S_OK;
    }
    
    return CComObjectRootEx<CComSingleThreadModel>::InternalQueryInterface(pv,
                                                                           pEntries,
                                                                           iid,
                                                                           ppvObject);
}
        
CMMBaseBvr *
GetBvr(IUnknown * pbvr)
{
    // This is a total hack to get the original class data.  The QI is
    // implemented above and does NOT do a addref so we do not need to
    // release it
    
    CMMBaseBvr * bvr = NULL;

    if (pbvr)
    {
        pbvr->QueryInterface(__uuidof(BvrGuid),(void **)&bvr);
    }
    
    if (bvr == NULL)
    {
        CRSetLastError(E_INVALIDARG, NULL);
    }
                
    return bvr;
}

DeclareTag(tagClockSync, "Sync", "Clock Sync");

bool
CMMBaseBvr::OnBvrCB(double gTime)
{
    TraceTag((tagClockSync,
              "CMMBaseBvr(%lx)::OnBvrCB(%g)",
              this,
              gTime));

    Assert(IsClockSource());

    if (!IsPlaying() ||
        !IsClockSource() ||
        !m_eventcb)
    {
        goto done;
    }
    
    // TODO:!!!!
    // Need to take into account crossing of our parent's segment
    // boundaries
    
    double dbllastTime;
    dbllastTime = GetCurrentLocalTime();

    if (dbllastTime == MM_INFINITE)
    {
        dbllastTime = -MM_INFINITE;
    }
    
    double dblnextTime;
    dblnextTime = GlobalTimeToLocalTime(gTime);

    // Init the new time to the next time so if they do not do
    // anything we will get the next time
    
    double newtime;
    newtime = dblnextTime;
    
    TraceTag((tagClockSync,
              "CMMBaseBvr(%lx)::OnBvrCB - calling OnTick (%g, %g, %p)",
              this,
              dbllastTime,
              dblnextTime,
              this));

    HRESULT hr;

    hr = m_eventcb->OnTick(dbllastTime,
                           dblnextTime,
                           (ITIMEMMBehavior *)this,
                           &newtime);
    
    TraceTag((tagClockSync,
              "CMMBaseBvr(%lx)::OnBvrCB - return from OnTick (%hr, %g)",
              this,
              hr,
              newtime));

    if (hr != S_OK)
    {
        goto done;
    }
    
    if (newtime == MM_INFINITE)
    {
        // This means that we should have ended.  Ignore this and
        // assume that we will be told to stop using the end method
        
        goto done;
    }
    
    // Our clock can never make us go backwards so check for this and
    // ignore it
    
    // If the newtime is less then the last tick then we are going
    // backwards in time
    // Keep us at the current position
    
    // TODO: Should take into account -MM_INFINITE so that we do not
    // start the behavior - just pass it through
    if (newtime < dbllastTime)
    {
        newtime = dbllastTime;
    }

    TraceTag((tagClockSync,
              "CMMBaseBvr(%lx)::OnBvrCB - calling Sync (%g, %g)",
              this,
              dblnextTime,
              newtime));

    if (dblnextTime == newtime)
    {
        goto done;
    }
    
    if (!Sync(newtime, gTime))
    {
        goto done;
    }
    
  done:
    return true;
} // OnBvrCB
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\time\include\util.h ===
/*******************************************************************************

Copyright (c) 1995_96 Microsoft Corporation

Abstract:

    {Insert General Comment Here}

*******************************************************************************/

#ifndef _UTIL_H
#define _UTIL_H

//************************************************************
// this is used globally to denote that when scripting, we 
// use English.
#define LCID_SCRIPTING 0x0409

template <class T>
class CRPtr
{
  public:
    typedef T _PtrClass;
    CRPtr() { p = NULL; }
    CRPtr(T* lp, bool baddref = true)
    {
        p = lp;
        if (p != NULL && baddref)
            CRAddRefGC(p);
    }
    CRPtr(const CRPtr<T>& lp, bool baddref = true)
    {
        p = lp.p;

        if (p != NULL && baddref)
            CRAddRefGC(p);
    }
    ~CRPtr() {
        CRReleaseGC(p);
    }
    void Release() {
        CRReleaseGC(p);
        p = NULL;
    }
    operator T*() { return (T*)p; }
    T& operator*() { Assert(p != NULL); return *p; }
    T* operator=(T* lp)
    {
        return Assign(lp);
    }
    T* operator=(const CRPtr<T>& lp)
    {
        return Assign(lp.p);
    }

    bool operator!() const { return (p == NULL); }
    operator bool() const { return (p != NULL); }

    T* p;
  protected:
    T* Assign(T* lp) {
        if (lp != NULL)
            CRAddRefGC(lp);

        CRReleaseGC(p);

        p = lp;

        return lp;
    }
};

class CRLockGrabber
{
  public:
    CRLockGrabber() { CRAcquireGCLock(); }
    ~CRLockGrabber() { CRReleaseGCLock(); }
};


class SafeArrayAccessor
{
  public:
    SafeArrayAccessor(VARIANT & v,
                      bool allowNullArray = false);
    ~SafeArrayAccessor();

    unsigned int GetArraySize() { return _ubound - _lbound + 1; }

    IUnknown **GetArray() { return _isVar?_allocArr:_ppUnk; }

    bool IsOK() { return !_failed; }
  protected:
    SAFEARRAY * _s;
    union {
        VARIANT * _pVar;
        IUnknown ** _ppUnk;
        void * _v;
    };
    
    VARTYPE _vt;
    long _lbound;
    long _ubound;
    bool _inited;
    bool _isVar;
    CComVariant _retVar;
    bool _failed;
    IUnknown ** _allocArr;
};

inline WCHAR * CopyString(const WCHAR *str) {
    int len = str?lstrlenW(str)+1:1;
    WCHAR *newstr = new WCHAR [len] ;
    if (newstr) memcpy(newstr,str?str:L"",len * sizeof(WCHAR)) ;
    return newstr ;
}

#define ARRAY_SIZE(x) (sizeof(x) / sizeof((x)[0]))

IDirectDraw * GetDirectDraw();

HRESULT
CreateOffscreenSurface(IDirectDraw *ddraw,
                       IDirectDrawSurface **surfPtrPtr,
                       DDPIXELFORMAT *pf,
                       bool vidmem,
                       LONG width, LONG height);

HRESULT
CopyDCToDdrawSurface(HDC srcDC,
                     LPRECT prcSrcRect,
                     IDirectDrawSurface *DDSurf,
                     LPRECT prcDestRect);

/////////////////////////  CriticalSections  //////////////////////

class CritSect
{
  public:
    CritSect();
    ~CritSect();
    void Grab();
    void Release();
    
  protected:
    CRITICAL_SECTION _cs;
};

class CritSectGrabber
{
  public:
    CritSectGrabber(CritSect& cs, bool grabIt = true);
    ~CritSectGrabber();
    
  protected:
    CritSect& _cs;
    bool grabbed;
};

/////////////////////// Misc ////////////////////


#define INDEFINITE HUGE_VAL //defined for Variant conversion functions

#define FOREVER    HUGE_VAL

#define INVALID    -HUGE_VAL

bool CRBvrToVARIANT(CRBvrPtr b, VARIANT * v);
CRBvrPtr VARIANTToCRBvr(VARIANT v, CR_BVR_TYPEID tid = CRINVALID_TYPEID);

HRESULT GetTIMEAttribute(IHTMLElement * elm, LPCWSTR str, LONG lFlags, VARIANT * value);
HRESULT SetTIMEAttribute(IHTMLElement * elm, LPCWSTR str, VARIANT value, LONG lFlags);
BSTR CreateTIMEAttrName(LPCWSTR str);

bool VariantToBool(VARIANT var);
float VariantToFloat(VARIANT var,
                     bool bAllowIndefinite = false,
                     bool bAllowForever = false);
HRESULT VariantToTime(VARIANT vt, float *retVal);
BOOL IsIndefinite(OLECHAR *szTime);

extern const wchar_t * TIMEAttrPrefix;

/////////////////////// Convenience macros ////////////////////

//
// used in QI implementations for safe pointer casting
// e.g. if( IsEqualGUID(IID_IBleah) ) *ppv = SAFECAST(this,IBleah);
// Note: w/ vc5, this is ~equiv to *ppv = static_cast<IBleah*>(this);
//
#define SAFECAST(_src, _type) (((_type)(_src)==(_src)?0:0), (_type)(_src))

// 
// used in QI calls, 
// e.g. IOleSite * pSite;  p->QI( IID_TO_PPV(IOleInPlaceSite, &pSite) ) 
// would cause a C2440 as _src is not really a _type **.
// Note: the riid must be the _type prepended by IID_.
//
#define IID_TO_PPV(_type,_src)      IID_##_type, \
                                    reinterpret_cast<void **>(static_cast<_type **>(_src))


//************************************************************


#if (_M_IX86 >= 300) && defined(DEBUG)
  #define PSEUDORETURN(dw)    _asm { mov eax, dw }
#else
  #define PSEUDORETURN(dw)
#endif // not _M_IX86


//
// ReleaseInterface calls 'Release' and NULLs the pointer
// The Release() return will be in eax for IA builds.
//
#define ReleaseInterface(p)\
{\
    ULONG cRef = 0u; \
    if (NULL != (p))\
    {\
        cRef = (p)->Release();\
        Assert((int)cRef>=0);\
        (p) = NULL;\
    }\
    PSEUDORETURN(cRef) \
}

//************************************************************
// Errot Reporting helper macros

inline HRESULT TIMESetLastError(HRESULT hr, LPCWSTR msg = NULL)
{
    CRSetLastError(hr, msg);
    return hr;
}

inline HRESULT TIMEGetLastError()
{
    return CRGetLastError();
}

#define WZ_OBFUSCATED_TIMEBODY_URN      L"#time#3CA6D405-6352-11d2-AF2D-00A0C9A03B8C"     // a GUID not intended for COM use

HRESULT CheckElementForBehaviorURN(IHTMLElement *pElement,
                                   WCHAR *wzURN,
                                   bool *pfReturn);

HRESULT AddBodyBehavior(IHTMLElement* pElement);
bool IsBodyElement(IHTMLElement *pElement);
HRESULT GetBodyElement(IHTMLElement *pElement, REFIID riid, void **);
bool IsTIMEBodyElement(IHTMLElement *pElement);
HRESULT FindTIMEInterface(IHTMLElement *pHTMLElem, ITIMEElement **ppTIMEElem);
HRESULT FindTIMEBehavior(IHTMLElement *pHTMLElem, IDispatch **ppDisp);


#endif /* _UTIL_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\time\mmapi\mmbvr.cpp ===
/*******************************************************************************

Copyright (c) 1995-96 Microsoft Corporation

Abstract:

    {Insert General Comment Here}

*******************************************************************************/


#include "headers.h"
#include "mmbvr.h"
#include "mmtimeline.h"

DeclareTag(tagMMBvr, "API", "CMMBehavior methods");

CMMBehavior::CMMBehavior()
{
    TraceTag((tagMMBvr,
              "CMMBehavior(%lx)::CMMBehavior()",
              this));
}

CMMBehavior::~CMMBehavior()
{
    TraceTag((tagMMBvr,
              "CMMBehavior(%lx)::~CMMBehavior()",
              this));
}

HRESULT
CMMBehavior::Init(LPOLESTR id, IDABehavior * dabvr)
{
    TraceTag((tagMMBvr,
              "CMMBehavior(%lx)::Init(%ls, %lx)",
              this,
              id,
              dabvr));

    HRESULT hr;
    
    CRBvrPtr bvr;
    
    if (!dabvr)
    {
        hr = E_INVALIDARG;
        goto done;
    }

    bvr = COMToCRBvr(dabvr);

    if (!bvr)
    {
        hr = CRGetLastError();
        goto done;
    }

    hr = BaseInit(id, bvr);

    if (FAILED(hr))
    {
        goto done;
    }
    
    hr = S_OK;
  done:
    return hr;
}

HRESULT
CMMBehavior::Error()
{
    LPCWSTR str = CRGetLastErrorString();
    HRESULT hr = CRGetLastError();
    
    TraceTag((tagError,
              "CMMBehavior(%lx)::Error(%hr,%ls)",
              this,
              hr,
              str?str:L"NULL"));

    if (str)
        return CComCoClass<CMMBehavior, &__uuidof(CMMBehavior)>::Error(str, IID_ITIMEMMBehavior, hr);
    else
        return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\time\mmapi\mmbasebvr.h ===
/*******************************************************************************

Copyright (c) 1995_96 Microsoft Corporation

Abstract:

    {Insert General Comment Here}

*******************************************************************************/


#ifndef _MMBASEBVR_H
#define _MMBASEBVR_H

#define MM_INFINITE HUGE_VAL

class CMMTimeline;
class CMMBehavior;
class CMMPlayer;

extern TAG tagMMBaseBvr;

class CallBackData;
typedef std::list<CallBackData *> CallBackList;

class CMMBaseBvr;
typedef std::list<CMMBaseBvr*> MMBaseBvrList;

class
ATL_NO_VTABLE CMMBaseBvr
    : public CComObjectRootEx<CComSingleThreadModel>
{
  public:
    CMMBaseBvr();
    virtual ~CMMBaseBvr();
    
    STDMETHOD_(ULONG,AddRef)(void) = 0;
    STDMETHOD_(ULONG,Release)(void) = 0;
    STDMETHOD(QueryInterface)(REFIID iid, void ** ppvObject) = 0;
    
    // We cannot put the real one here since the typecast causes it to
    // get the wrong vtables
    static HRESULT WINAPI
        BaseInternalQueryInterface(CMMBaseBvr* pThis,
                                   void * pv,
                                   const _ATL_INTMAP_ENTRY* pEntries,
                                   REFIID iid,
                                   void** ppvObject);

    // This must be in the derived class and not the base class since
    // the typecast down to the base class messes things up
    // Add a dummy one to assert just in case the derived class does
    // not add one
    static inline HRESULT WINAPI
        InternalQueryInterface(CMMBaseBvr* pThis,
                               const _ATL_INTMAP_ENTRY* pEntries,
                               REFIID iid,
                               void** ppvObject)
    {
        AssertStr(false, "InternalQueryInterface not defined in base class");
        return E_FAIL;
    }
    
    HRESULT BaseInit(LPWSTR id, CRBvrPtr rawbvr);

#if _DEBUG
    virtual const _TCHAR * GetName() { return __T("CMMBaseBvr"); }
#endif

    // Base interface functions
    
    HRESULT GetID(LPOLESTR *);
    HRESULT SetID(LPOLESTR);
        
    HRESULT GetStartOffset(float *);
    HRESULT SetStartOffset(float);
        
    HRESULT GetDuration(float * pd);
    HRESULT SetDuration(float d);
        
    HRESULT GetRepeat(LONG * pr);
    HRESULT SetRepeat(LONG r);
       
    HRESULT GetAutoReverse(VARIANT_BOOL * pr);
    HRESULT SetAutoReverse(VARIANT_BOOL r);
        
    HRESULT GetRepeatDur(float *);
    HRESULT SetRepeatDur(float);
        
    HRESULT GetEndOffset(float *);
    HRESULT SetEndOffset(float);
        
    HRESULT GetEaseIn(float * pd);
    HRESULT SetEaseIn(float d);

    HRESULT GetEaseInStart(float * pd);
    HRESULT SetEaseInStart(float d);

    HRESULT GetEaseOut(float * pd);
    HRESULT SetEaseOut(float d);

    HRESULT GetEaseOutEnd(float * pd);
    HRESULT SetEaseOutEnd(float d);

    HRESULT GetSyncFlags(DWORD * flags);
    HRESULT SetSyncFlags(DWORD flags);

    HRESULT GetEventCB(ITIMEMMEventCB ** ev);
    HRESULT SetEventCB(ITIMEMMEventCB * ev);
        
    HRESULT GetTotalTime(float * pd);
        
    HRESULT GetDABehavior(REFIID riid, void **);
    HRESULT GetResultantBehavior(REFIID riid, void **ret);

    HRESULT Begin(bool bAfterOffset);
    HRESULT End();
    HRESULT Pause();
    HRESULT Run();
    HRESULT Seek(double lTime);
    HRESULT Reset(DWORD fCause);
    HRESULT ResetOnEventChanged(bool bBeginEvent);

    HRESULT GetLocalTime(double * d);
    HRESULT GetLocalTimeEx(double * d);

    HRESULT GetSegmentTime(double * d);

    HRESULT GetPlayState(MM_STATE * state);

    HRESULT PutStartType(MM_START_TYPE st)
    {
        m_startType = st; return S_OK;
    }

    // Accessors

    CRBvrPtr GetRawBvr() { return m_rawbvr; }
    CRBvrPtr GetResultantBvr() { return m_resultantbvr; }
    float GetStartOffset() { return m_startOffset; }
    float GetDuration() { return m_duration; }
    float GetEndOffset() { return m_endOffset; }
    float GetRepeatDuration() { return m_repDuration; }
    long GetRepeat() { return m_repeat; }
    bool GetAutoReverse() { return m_bAutoReverse; }
    ITIMEMMEventCB * GetEventCB() { return m_eventcb; }
    float GetEaseIn() { return m_easeIn; }
    float GetEaseInStart() { return m_easeInStart; }
    float GetEaseOut() { return m_easeOut; }
    float GetEaseOutEnd() { return m_easeOutStart; }
    bool IsClockSource();
    bool IsLocked();
    bool IsCanSlip();
    DWORD GetSyncFlags();
    
    double GetTotalRepDuration() { return m_totalRepDuration; }
    double GetTotalDuration() { return m_totalDuration; }
    double GetStartTime() { return m_startOffset; }
    double GetEndTime() { return m_startOffset + m_totalRepDuration; }
    double GetAbsStartTime() { return m_absStartTime; }
    double GetAbsEndTime() { return m_absEndTime; }
    double GetDepStartTime() { return m_depStartTime; }
    double GetDepEndTime() { return m_depEndTime; }
    
    double GetCurrentLocalTime();
    double GetCurrentLocalTimeEx();
    double GetCurrentSegmentTime();
    
    CMMBaseBvr * GetParent() { return m_parent; }
    CMMPlayer * GetPlayer() { return m_player; }

    // This will call all the behaviors which are currently running
    // with the given event.  This is used when the timeline needs to
    // process a specific event like Pause/Resume/Stop/Play.
    
    bool ProcessEvent(CallBackList * l,
                      double time,
                      bool bFirstTick,
                      MM_EVENT_TYPE et,
                      DWORD flags);
    
    virtual bool _ProcessEvent(CallBackList * l,
                               double time,
                               bool bFirstTick,
                               MM_EVENT_TYPE et,
                               bool bNeedsReverse,
                               DWORD flags) { return true; }
    
    bool ProcessCB(CallBackList * l,
                   double lastTick,
                   double curTime,
                   bool bForward,
                   bool bFirstTick,
                   bool bNeedPlay);

    virtual bool _ProcessCB(CallBackList * l,
                            double lastTick,
                            double curTime,
                            bool bForward,
                            bool bFirstTick,
                            bool bNeedPlay,
                            bool bNeedsReverse) { return true; }

    virtual bool EventNotify(CallBackList *l,
                             double lTime,
                             MM_EVENT_TYPE et,
                             DWORD flags);
    
    virtual bool ParentEventNotify(CMMBaseBvr * bvr,
                                   double lTime,
                                   MM_EVENT_TYPE et,
                                   DWORD flags)
    { return true; }
    
    virtual void Invalidate();
    
    virtual bool ConstructBvr(CRNumberPtr timeline);
    virtual void DestroyBvr();
    virtual bool ResetBvr(CallBackList * l,
                          bool bProcessSiblings = true);

    bool SetParent(CMMBaseBvr * parent,
                   MM_START_TYPE st,
                   CMMBaseBvr * startSibling);
    bool ClearParent();

    bool AttachToSibling();
    void DetachFromSibling();
    
    virtual void SetPlayer(CMMPlayer * player);
    virtual void ClearPlayer();

    CMMBaseBvr *GetStartSibling() { return m_startSibling; }
    CMMBaseBvr *GetEndSibling() { return m_endSibling; }
    MM_START_TYPE GetStartType() { return m_startType; }

    inline bool IsPlaying();
    inline bool IsPaused();

    bool IsPlayable(double t);

#if _DEBUG
    virtual void Print(int spaces);
#endif

    virtual bool OnBvrCB(double gTime);

  protected:

    bool UpdateAbsStartTime(double f, bool bUpdateDepTime);
    bool UpdateAbsEndTime(double f, bool bUpdateDepTime);
    
    //returns the number CRBvr that represents the start time of this MMBehavior in parent time
    CRNumberPtr GetStartTimeBvr() { return m_startTimeBvr; }
    //returns the number CRBvr that represents the stop time of this MMBehavior in the parent time.
    CRNumberPtr GetEndTimeBvr() { return m_endTimeBvr; }
    
    bool UpdateResultantBvr(CRBvrPtr bvr);
    void ClearResultantBvr();
    
    CRBvrPtr EncapsulateBvr(CRBvrPtr rawbvr);
    
    void CalculateEaseCoeff();

    // This will take the time behavior and ease it
    CRNumberPtr EaseTime(CRNumberPtr time);

    // This will take the given time and transform it to the correct
    // eased time
    // If the time is outside of our duration (i.e. <0 or >
    // m_duration) this will just return the given time
    double EaseTime(double time);

    // This will take the given time and transform it to the time it
    // would have been w/o an ease
    double ReverseEaseTime(double time);

    virtual bool IsContinuousMediaBvr() { return false; }

    void UpdateTotalDuration();

    // Sibling dependency management
    bool AddStartTimeSink(CMMBaseBvr * sink);
    void RemoveStartTimeSink(CMMBaseBvr * sink);
    bool AddEndTimeSink(CMMBaseBvr* sink);
    void RemoveEndTimeSink(CMMBaseBvr* sink);

    // methods for the propagation of start times and end times.
    // The time passed in is the local time of the parent which we are
    // suppose to start on

    // This is where all the wiring gets hooked up
    // Basicly once we determine what our start time is we can then
    // propagate this information to all of our dependents and allow
    // them to in turn do the same

    bool StartTimeVisit(double time,
                        CallBackList * l,
                        bool bAfterOffset,
                        bool bReset = false,
                        DWORD fCause = 0);

    // It is pretty much the same for the end time.  This can be
    // called when our start time is set if we know the duration and
    // will also be called for indeterminate durations or event
    // ending.
    
    bool EndTimeVisit(double time, CallBackList * l);

    bool UpdateTimeControl();

    bool UpdateSyncTime(double newtime);
    
    virtual HRESULT Error() = 0;

    double GetContainerSegmentTime();
    
    // This will take the local time of the bvr and convert it to
    // it's segment time.  Basically it will take into account repeat
    // and bounce.
    
    double LocalTimeToSegmentTime(double t);

    // This will take the local time of bvr and return the local time
    // of the bvr which started the current segment
    
    double LocalTimeToSegmentBase(double t);

    // This converts a given global time to a local time

    double GlobalTimeToLocalTime(double gt);
    double GlobalTimeToLocalTimeEx(double gt);
    
    bool Sync(double newTime, double nextGlobalTime);

    // This takes pure local timeline times (pre-ease)
    // The curTime is the time on the current timeline we want to now
    // be at newTime.  For regular seeking this would be the current
    // localtime.
    bool _Seek(double curTime, double newTime);

    virtual bool ReconstructBvr(CMMBaseBvr* ) { CRSetLastError(E_NOTIMPL, NULL); return false; }

    //
    // DATA declarations
    //
  protected:
    LPWSTR m_id;
    float m_startOffset;
    float m_duration;
    float m_repeatDur;
    long m_repeat;
    bool m_bAutoReverse;
    float m_endOffset;
    float m_easeIn;
    float m_easeInStart;
    float m_easeOut;
    float m_easeOutEnd;
    DWORD m_syncFlags;
    bool m_bPlaying;

    // These are the absolute local times which correspond to when the
    // behavior really starts and really ends - not including start
    // and end offsets.
    double m_absStartTime;
    double m_absEndTime;

    double m_depStartTime;
    double m_depEndTime;

    DAComPtr<ITIMEMMEventCB> m_eventcb;

    //The way in which this behavior begins.  Can be any of the enum MM_START_TYPE
    MM_START_TYPE m_startType;
    //if this behavior is begin with or after this holds the sibling
    //  that controls when we start.
    CMMBaseBvr *m_startSibling;
    //if this behavior is end with this holds the sibling that controls
    //  when we stop.
    CMMBaseBvr *m_endSibling;

    //TODO: these could be allocated as needed.  They may be fairly rarely used.
    MMBaseBvrList m_startTimeSinks;
    MMBaseBvrList m_endTimeSinks;

    // These behaviors represent the local begin and end times for
    // this behavior.  Siblings can reference these to place
    // themselves relatively according to start with/after and
    // endwith.
    
    CRPtr<CRNumber> m_startTimeBvr;
    CRPtr<CRNumber> m_endTimeBvr;

    // This represents the time sub we are using for the behavior
    // For beginafter/with this points to the siblings appropriate
    // behavior, for an event it points to infinity until the start
    // time is known, and for an absolute it is simply local time.
    // This also allows us to implement slipSync since we can use to
    // adjust ourselves as we need it
    
    CRPtr<CRNumber> m_timeControl;

    // A single segment duration
    double m_segDuration;
    
    // The duration for a single rep of a behavior
    double m_repDuration;

    // Total duration we calculate for a regular behavior 
    double m_totalRepDuration; 

    // The real duration determine by adding totalrepduration + start + end
    float m_totalDuration;

    CRPtr<CRBvr> m_rawbvr;
    CMMBaseBvr * m_parent;
    CR_BVR_TYPEID m_typeId;
    CMMPlayer * m_player;

    CRPtr<CRBvr> m_resultantbvr;
    long m_cookie;
    
    bool m_bPaused;
    double m_pauseTime;
    
    // This is the last time we were ticked to ensure we never fire
    // events twice
    double m_lastTick;
    
    // The ease-in/out behavior modifier is applied using timeline
    // substitution.  The substitute timeline consists of three pieces
    // A, B and C, which are the ease-in, constant velocity and ease-out
    // parts respectively.  For B, a linear timeline is substituted; for
    // A and C, a quadratic warping of the input time is required.

    float m_flA0, m_flA1, m_flA2; // coefficients for the A piece
    float m_flB0, m_flB1;         // coefficients for the B piece
    float m_flC0, m_flC1, m_flC2; // coefficients for the C piece

    // These are the times to perform ease in/out
    float m_easeInEnd;
    float m_easeOutStart;
    bool m_bNeedEase;
    double m_startOnEventTime;
};

class CallBackData
{
  public:
    CallBackData(ITIMEMMBehavior * bvr,
                 ITIMEMMEventCB * eventcb,
                 double time,
                 MM_EVENT_TYPE et,
                 DWORD flags);
    ~CallBackData();

    HRESULT CallEvent();

    ITIMEMMBehavior* GetBehavior() { return m_bvr; }
    MM_EVENT_TYPE GetEventType() { return m_et; }
  protected:
    DAComPtr<ITIMEMMBehavior> m_bvr;
    double m_time;
    MM_EVENT_TYPE m_et;
    DAComPtr<ITIMEMMEventCB> m_eventcb;
    DWORD m_flags;
};

bool ProcessCBList(CallBackList &l);

#if _DEBUG
inline char * EventString(MM_EVENT_TYPE et) {
    switch(et) {
      case MM_PLAY_EVENT:
        return "Play";
      case MM_STOP_EVENT:
        return "Stop";
      case MM_PAUSE_EVENT:
        return "Pause";
      case MM_RESUME_EVENT:
        return "Resume";
      case MM_REPEAT_EVENT:
        return "Repeat";
      case MM_AUTOREVERSE_EVENT:
        return "Autoreverse";
      default:
        return "Unknown";
    }
}
#endif

inline bool
CMMBaseBvr::IsPlaying()
{
    return m_bPlaying;
}

inline bool
CMMBaseBvr::IsPaused()
{
    return m_bPaused;
}

inline bool
CMMBaseBvr::IsClockSource()
{
    return ((m_syncFlags & MM_CLOCKSOURCE) != 0);
}

inline bool
CMMBaseBvr::IsLocked()
{
    return ((m_syncFlags & MM_LOCKED) != 0);
}

inline bool
CMMBaseBvr::IsCanSlip()
{
    return !IsLocked();
}

inline DWORD
CMMBaseBvr::GetSyncFlags()
{
    return m_syncFlags;
}

CMMBaseBvr * GetBvr(IUnknown *);

#endif /* _MMBASEBVR_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\time\mmapi\mmbvr.h ===
/*******************************************************************************

Copyright (c) 1995_96 Microsoft Corporation

Abstract:

    {Insert General Comment Here}

*******************************************************************************/


#ifndef _MMBVR_H
#define _MMBVR_H

#include "mmfactory.h"
#include "mmbasebvr.h"

class
__declspec(uuid("ad8888cc-537a-11d2-b955-3078302c2030")) 
ATL_NO_VTABLE CMMBehavior
    : public CComCoClass<CMMBehavior, &__uuidof(CMMBehavior)>,
      public ITIMEMMBehavior,
      public ISupportErrorInfoImpl<&IID_ITIMEMMBehavior>,
      public CMMBaseBvr
{
  public:
    CMMBehavior();
    ~CMMBehavior();

    HRESULT Init(LPOLESTR id, IDABehavior * bvr);
    
#if _DEBUG
    virtual const _TCHAR * GetName() { return __T("CMMBehavior"); }
#endif

    BEGIN_COM_MAP(CMMBehavior)
        COM_INTERFACE_ENTRY(ITIMEMMBehavior)
        COM_INTERFACE_ENTRY(ISupportErrorInfo)
    END_COM_MAP();

    // This must be in the derived class and not the base class since
    // the typecast down to the base class messes things up
    static inline HRESULT WINAPI
        InternalQueryInterface(CMMBehavior* pThis,
                               const _ATL_INTMAP_ENTRY* pEntries,
                               REFIID iid,
                               void** ppvObject)
    { return BaseInternalQueryInterface(pThis,
                                        (void *) pThis,
                                        pEntries,
                                        iid,
                                        ppvObject); }

    STDMETHOD(get_ID)(LPOLESTR * s)
        { return GetID(s); }
    
    STDMETHOD(put_ID)(LPOLESTR s)
        { return SetID(s); }
        
    STDMETHOD(get_StartOffset)(float * f)
        { return GetStartOffset(f); }
    
    STDMETHOD(put_StartOffset)(float f)
        { return SetStartOffset(f); }
        
    STDMETHOD(get_Duration)(float * pd)
        { return GetDuration(pd); }
    STDMETHOD(put_Duration)(float d)
        { return SetDuration(d); }
        
    STDMETHOD(get_Repeat)(LONG * pr)
        { return GetRepeat(pr); }
    STDMETHOD(put_Repeat)(LONG r)
        { return SetRepeat(r); }
       
    STDMETHOD(get_AutoReverse)(VARIANT_BOOL * pr)
        { return GetAutoReverse(pr); }
    STDMETHOD(put_AutoReverse)(VARIANT_BOOL r)
        { return SetAutoReverse(r); }
        
    STDMETHOD(get_RepeatDur)(float * f)
        { return GetRepeatDur(f); }
    STDMETHOD(put_RepeatDur)(float f)
        { return SetRepeatDur(f); }
        
    STDMETHOD(get_EndOffset)(float * f)
        { return GetEndOffset(f); }
    STDMETHOD(put_EndOffset)(float f)
        { return SetEndOffset(f); }
        
    STDMETHOD(get_EaseIn)(float * pd)
        { return GetEaseIn(pd); }
    STDMETHOD(put_EaseIn)(float d)
        { return SetEaseIn(d); }

    STDMETHOD(get_EaseInStart)(float * pd)
        { return GetEaseInStart(pd); }
    STDMETHOD(put_EaseInStart)(float d)
        { return SetEaseInStart(d); }

    STDMETHOD(get_EaseOut)(float * pd)
        { return GetEaseOut(pd); }
    STDMETHOD(put_EaseOut)(float d)
        { return SetEaseOut(d); }

    STDMETHOD(get_EaseOutEnd)(float * pd)
        { return GetEaseOutEnd(pd); }
    STDMETHOD(put_EaseOutEnd)(float d)
        { return SetEaseOutEnd(d); }

    STDMETHOD(get_SyncFlags)(DWORD * pd)
        { return GetSyncFlags(pd); }
    STDMETHOD(put_SyncFlags)(DWORD d)
        { return SetSyncFlags(d); }

    STDMETHOD(get_EventCB)(ITIMEMMEventCB ** ev)
        { return GetEventCB(ev); }
    STDMETHOD(put_EventCB)(ITIMEMMEventCB * ev)
        { return SetEventCB(ev); }
        
    STDMETHOD(get_TotalTime)(float * pd)
        { return GetTotalTime(pd); }
        
    STDMETHOD(get_DABehavior)(IDABehavior ** bvr)
        { return CMMBaseBvr::GetDABehavior(IID_IDABehavior, (void **)bvr); }

    STDMETHOD(GetDABehavior)(REFIID riid, void ** bvr)
        { return CMMBaseBvr::GetDABehavior(riid, bvr); }

    STDMETHOD(GetResultantBehavior)(REFIID riid, void ** bvr)
        { return CMMBaseBvr::GetResultantBehavior(riid, bvr); }

    STDMETHOD(Begin)(VARIANT_BOOL bAfterOffset)
        { return CMMBaseBvr::Begin(bAfterOffset?true:false); }
    
    STDMETHOD(End)()
        { return CMMBaseBvr::End(); }
    
    STDMETHOD(Pause)()
        { return CMMBaseBvr::Pause(); }
    
    STDMETHOD(Run)()
        { return CMMBaseBvr::Run(); }
    
    STDMETHOD(Seek)(double lTime)
        { return CMMBaseBvr::Seek(lTime); }

    STDMETHOD(Reset)(DWORD fCause)
        { return CMMBaseBvr::Reset(fCause); }

    STDMETHOD(ResetOnEventChanged)(VARIANT_BOOL bBeginEvent)
        { return CMMBaseBvr::ResetOnEventChanged(bBeginEvent?true:false); }

    STDMETHOD(get_LocalTime)(double * d)
        { return GetLocalTime(d); }

    STDMETHOD(get_LocalTimeEx)(double * d)
        { return GetLocalTimeEx(d); }

    STDMETHOD(get_SegmentTime)(double * d)
        { return GetSegmentTime(d); }

    STDMETHOD(get_PlayState)(MM_STATE * state)
        { return GetPlayState(state); }

    STDMETHOD(put_StartType)(MM_START_TYPE st)
        { return PutStartType(st); }

  protected:
    HRESULT Error();
};

#endif /* _MMBVR_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\time\mmapi\mmease.cpp ===
/*******************************************************************************
 *
 * Copyright (c) 1998 Microsoft Corporation
 *
 * File: mmease.cpp
 *
 * Abstract:
 *
 *
 *
 *******************************************************************************/


#include "headers.h"
#include "mmbasebvr.h"

void
CMMBaseBvr::CalculateEaseCoeff()
{
    Assert(m_easeIn >= 0.0f && m_easeIn <= 1.0f);
    Assert(m_easeOut >= 0.0f && m_easeOut <= 1.0f);
    Assert(m_easeInStart >= 0.0f && m_easeInStart <= 1.0f);
    Assert(m_easeOutEnd >= 0.0f && m_easeOutEnd <= 1.0f);

    // We need to ease the behavior if we are not infinite and either
    // ease in or ease out percentagMMes are non-zero
    
    m_bNeedEase = (m_duration != HUGE_VAL &&
                   (m_easeIn > 0.0f || m_easeOut > 0.0f) &&
                   (m_easeIn + m_easeOut <= 1.0f));

    if (!m_bNeedEase) return;
    
    float flEaseInDuration = m_easeIn * m_duration;
    float flEaseOutDuration = m_easeOut * m_duration;
    float flMiddleDuration = m_duration - flEaseInDuration - flEaseOutDuration;
    
    // Compute B1, the velocity during segment B.
    float flInvB1 = (0.5f * m_easeIn * (m_easeInStart - 1.0f) +
                     0.5f * m_easeOut * (m_easeOutEnd - 1.0f) + 1.0f);
    Assert(flInvB1 > 0.0f);
    m_flB1 = 1.0f / flInvB1;
    
    // Basically for accelerated pieces - t = t0 + v0 * t + 1/2 at^2
    // and a = Vend - Vstart / t

    if (flEaseInDuration != 0.0f) {
        m_flA0 = 0.0f;
        m_flA1 = m_easeInStart * m_flB1;
        m_flA2 = 0.5f * (m_flB1 - m_flA1) / flEaseInDuration;
    } else {
        m_flA0 = m_flA1 = m_flA2 = 0.0f;
    }

    m_flB0 = m_flA0 + m_flA1 * flEaseInDuration + m_flA2 * flEaseInDuration * flEaseInDuration;
    
    if (flEaseOutDuration != 0.0f) {
        m_flC0 = m_flB1 * flMiddleDuration + m_flB0;
        m_flC1 = m_flB1;
        m_flC2 = 0.5f * (m_easeOutEnd * m_flB1 - m_flC1) / flEaseOutDuration;
    } else {
        m_flC0 = m_flC1 = m_flC2 = 0.0f;
    }

    m_easeInEnd = flEaseInDuration;
    m_easeOutStart = m_duration - flEaseOutDuration;
}

CRNumberPtr
Quadratic(CRNumberPtr time, float flA, float flB, float flC)
{
    // Assume that the GC lock is acquired
    
    // Need to calculate ax^2 + bx + c

    Assert(time != NULL);

    CRNumberPtr ret = NULL;
    CRNumberPtr accum = NULL;

    if (flC != 0.0f) {
        if ((accum = CRCreateNumber(flC)) == NULL)
            goto done;
    }

    if (flB != 0.0f) {
        CRNumberPtr term;

        if ((term = CRCreateNumber(flB)) == NULL ||
            (term = CRMul(term, time)) == NULL)
            goto done;

        if (accum) {
            if ((term = CRAdd(term, accum)) == NULL)
                goto done;
        }

        accum = term;
    }

    if (flA != 0.0f) {
        CRNumberPtr term;

        if ((term = CRCreateNumber(flA)) == NULL ||
            (term = CRMul(term, time)) == NULL ||
            (term = CRMul(term, time)) == NULL)
            goto done;

        if (accum) {
            if ((term = CRAdd(term, accum)) == NULL)
                goto done;
        }

        accum = term;
    }

    // If all the coeff are zero then just return 0
    
    if (accum == NULL) {
        if ((accum = CRCreateNumber(0.0f)) == NULL)
            goto done;
    }
    
    ret = accum;
    
  done:
    return ret;
}

CRNumberPtr
AddTerm(CRNumberPtr time,
        CRNumberPtr prevTerm,
        float prevDur,
        float flA, float flB, float flC)
{
    CRNumberPtr ret = NULL;
    CRNumberPtr term;
    
    // Offset the time to be zero since that is what the coeffs are
    // based on
    
    if (prevTerm) {
        CRNumberPtr t;
        
        if ((t = CRCreateNumber(prevDur)) == NULL ||
            (time = CRSub(time, t)) == NULL)
            goto done;
    }

    if ((term = Quadratic(time, flA, flB, flC)) == NULL)
        goto done;
    
    // Now we need to conditional use the new term

    if (prevTerm) {
        CRBooleanPtr cond;
        CRNumberPtr zeroTime;
        
        if ((zeroTime = CRCreateNumber(0)) == NULL ||
            (cond = CRLT(time, zeroTime)) == NULL ||
            (term = (CRNumberPtr) CRCond(cond,
                                         (CRBvrPtr) prevTerm,
                                         (CRBvrPtr) term)) == NULL)
            goto done;
    }

    ret = term;
  done:
    return ret;
}

CRNumberPtr
CMMBaseBvr::EaseTime(CRNumberPtr time)
{
    CRNumberPtr ret = NULL;
    CRNumberPtr subTime = NULL;
    
    if (!m_bNeedEase) {
        ret = time;
        goto done;
    }
    
    if (m_easeIn > 0) {
        if ((subTime = AddTerm(time,
                               subTime,
                               0.0,
                               m_flA2, m_flA1, m_flA0)) == NULL)
            goto done;
    }
    
    // If there is space between the end of easing in and the
    // beginning of easing out then we have some constant time
    // interval
    if (m_easeInEnd < m_easeOutStart) {
        if ((subTime = AddTerm(time,
                               subTime,
                               m_easeInEnd,
                               0, m_flB1, m_flB0)) == NULL)
            goto done;
    }

    if (m_easeOut > 0) {
        if ((subTime = AddTerm(time,
                               subTime,
                               m_easeOutStart,
                               m_flC2, m_flC1, m_flC0)) == NULL)
            goto done;
    }
    
    ret = subTime;
    
    Assert(ret);
  done:
    return ret;
}

double
Quadratic(double time, float flA, float flB, float flC)
{
    // Need to calculate ax^2 + bx + c
    // Use x * (a * x + b) + c - since it requires 1 less multiply
    
    return (time * (flA * time + flB) + flC);
}

double
CMMBaseBvr::EaseTime(double time)
{
    if (!m_bNeedEase || time <= 0 || time >= m_duration)
        return time;
    
    if (time <= m_easeInEnd) {
        return Quadratic(time, m_flA2, m_flA1, m_flA0);
    } else if (time < m_easeOutStart) {
        return Quadratic(time - m_easeInEnd, 0.0f, m_flB1, m_flB0);
    } else {
        return Quadratic(time - m_easeOutStart, m_flC2, m_flC1, m_flC0);
    }
}

double
CMMBaseBvr::ReverseEaseTime(double time)
{
    return time;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\time\mmapi\mmfactory.cpp ===
/*******************************************************************************

Copyright (c) 1995-96 Microsoft Corporation

Abstract:

    {Insert General Comment Here}

*******************************************************************************/


#include "headers.h"
#include "mmbvr.h"
#include "mmtimeline.h"
#include "mmplayer.h"
#include "mmview.h"
#include "mmfactory.h"

CMMFactory::CMMFactory()
{
}

CMMFactory::~CMMFactory()
{
}


HRESULT
CMMFactory::FinalConstruct()
{
    if (bFailedLoad)
    {
        return E_FAIL;
    }
    
    return S_OK;
}

STDMETHODIMP
CMMFactory::CreateBehavior(LPOLESTR id,
                           IDispatch *pDisp,
                           IUnknown **ppOut)
{
    CHECK_RETURN_SET_NULL(ppOut);
    
    if (pDisp == NULL)
        return E_POINTER;

    HRESULT hr;
    DAComObject<CMMBehavior> *pNew;
    DAComObject<CMMBehavior>::CreateInstance(&pNew);

    if (!pNew)
    {
        THR(hr = E_OUTOFMEMORY);
    }
    else
    {
        DAComPtr<IDABehavior> pbvr;
        THR(hr = pDisp->QueryInterface(IID_IDABehavior, (void **)&pbvr));
        if (SUCCEEDED(hr))
        {
            THR(hr = pNew->Init(id, pbvr));
            if (SUCCEEDED(hr))
            {
                THR(hr = pNew->QueryInterface(IID_IUnknown, (void **)ppOut));
            }
        }
    }

    if (FAILED(hr))
    {
        delete pNew;
    }

    return hr;
}

STDMETHODIMP
CMMFactory::CreateTimeline(LPOLESTR id,
                           IUnknown **ppOut)
{
    CHECK_RETURN_SET_NULL(ppOut);
    
    HRESULT hr;
    
    DAComObject<CMMTimeline> *pNew;
    DAComObject<CMMTimeline>::CreateInstance(&pNew);

    if (!pNew)
    {
        THR(hr = E_OUTOFMEMORY);
    }
    else
    {
        THR(hr = pNew->Init(id));
        
        if (SUCCEEDED(hr))
        {
            THR(hr = pNew->QueryInterface(IID_IUnknown,
                                          (void **)ppOut));
        }
    }

    if (FAILED(hr))
    {
        delete pNew;
    }

    return hr;
}

STDMETHODIMP
CMMFactory::CreatePlayer(LPOLESTR id,
                         IUnknown * punk,
                         IServiceProvider * sp,
                         IUnknown **ppOut)
{
    CHECK_RETURN_SET_NULL(ppOut);
    
    HRESULT hr;
    
    DAComObject<CMMPlayer> *pNew;
    DAComObject<CMMPlayer>::CreateInstance(&pNew);

    if (!pNew)
    {
        THR(hr = E_OUTOFMEMORY);
    }
    else
    {
        DAComPtr<ITIMEMMBehavior> bvr;

        THR(punk->QueryInterface(IID_ITIMEMMBehavior, (void**)&bvr));
        THR(hr = pNew->Init(id,bvr,sp));
        
        if (SUCCEEDED(hr))
        {
            THR(hr = pNew->QueryInterface(IID_IUnknown,
                                          (void **)ppOut));
        }
    }

    if (FAILED(hr))
    {
        delete pNew;
    }

    return hr;
}

STDMETHODIMP
CMMFactory::CreateView(LPOLESTR id,
                       IDispatch *pimg,
                       IDispatch *psnd,
                       IUnknown  *pUnk,
                       IUnknown **ppOut)
{
    CHECK_RETURN_SET_NULL(ppOut);
    
    HRESULT hr;
    
    if (pUnk == NULL)
        return E_POINTER;

    DAComObject<CMMView> *pNew;
    DAComObject<CMMView>::CreateInstance(&pNew);

    if (!pNew)
    {
        hr = THR(E_OUTOFMEMORY);
    }
    else
    {
        HRESULT hr1 = S_OK;
        HRESULT hr2 = S_OK;
        DAComPtr<IDAImage> pimgbvr;
        DAComPtr<IDASound> psndbvr;

        if (pimg != NULL)
            hr1 = THR(pimg->QueryInterface(IID_IDAImage, (void**)&pimgbvr));
        if (psnd != NULL)
            hr2 = THR(psnd->QueryInterface(IID_IDASound, (void**)&psndbvr));
        if (SUCCEEDED(hr1) && SUCCEEDED(hr2))
        {
            DAComPtr<ITIMEMMViewSite> site;

            hr = THR(pUnk->QueryInterface(IID_ITIMEMMViewSite, (void**)&site));
            if (SUCCEEDED(hr))
            {
                hr = THR(pNew->Init(id, pimgbvr, psndbvr, site));
                if (SUCCEEDED(hr))
                {
                    hr = THR(pNew->QueryInterface(IID_IUnknown, (void **)ppOut));
                }
            }
        }
    }

    if (FAILED(hr))
    {
        delete pNew;
    }

    return hr;
}

HRESULT
CMMFactory::Error()
{
    LPCWSTR str = CRGetLastErrorString();
    HRESULT hr = CRGetLastError();
    
    if (str)
    {
        return CComCoClass<CMMFactory, &CLSID_TIMEMMFactory>::Error(str,
                                                                IID_ITIMEMMFactory,
                                                                hr);
    }
    else
    {
        return hr;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\time\mmapi\mmnotify.cpp ===
/*******************************************************************************
 *
 * Copyright (c) 1998 Microsoft Corporation
 *
 * File: mmnotify.cpp
 *
 * Abstract:
 *
 *
 *
 *******************************************************************************/

#include "headers.h"
#include "mmbasebvr.h"
#include "mmtimeline.h"

DeclareTag(tagMMNotify, "API", "Notifications");

// IMPORTANT!!!!!
// This needs to be called in the right order so that we get the
// correct children firing during the current interval but they get
// reset for the next interval. Otherwise we will not get the correct
// results.

bool
CMMBaseBvr::EventNotify(CallBackList * l,
                        double gTime,
                        MM_EVENT_TYPE et,
                        DWORD flags)
{
    TraceTag((tagMMNotify,
              "CMMBaseBvr(%#lx)::Notify(%#x): gTime = %g, event = %s",
              this,
              m_parent,
              gTime,
              EventString(et)));

    bool ok = false;
    
    if (m_eventcb && l)
    {
        CallBackData * data = NEW CallBackData((ITIMEMMBehavior *) this,
                                               m_eventcb,
                                               gTime,
                                               et,
                                               flags);
    
        if (!data)
        {
            CRSetLastError(E_OUTOFMEMORY, NULL);
            goto done;
        }
        
        l->push_back(data);
    }

    if (et == MM_STOP_EVENT)
    {
        m_bPlaying = false;
    }
    else if (et == MM_PLAY_EVENT)
    {
        m_bPlaying = true;
    }
    
    if (m_parent)
    {
        // Convert time to parents timeline
        if (!m_parent->ParentEventNotify(this,
                                         gTime + GetAbsStartTime(),
                                         et,
                                         flags))
        {
            goto done;
        }
    }
    
    ok = true;
  done:
    return ok;
}

bool
CMMTimeline::EventNotify(CallBackList *l,
                         double gTime,
                         MM_EVENT_TYPE et,
                         DWORD flags)
{
    TraceTag((tagMMNotify,
              "CMMTimeline(%#lx)::Notify(%#x): gTime = %g, event = %s, flags = %lx",
              this,
              m_parent,
              gTime,
              EventString(et),
              flags));

    bool ok = false;
    
    // For Repeat/Autoreverse events we need to make sure we
    // reset all the children of the behavior.
    
    if (et == MM_REPEAT_EVENT ||
        et == MM_AUTOREVERSE_EVENT)
    {
        if (!ResetChildren(l))
        {
            goto done;
        }
    }
    
    if (!CMMBaseBvr::EventNotify(l, gTime, et, flags))
    {
        goto done;
    }
    
    ok = true;
  done:
    return ok;
}

// This is in our local time coordinates - which means that we begin
// at 0.  This needs to be handled by the caller

bool
CMMBaseBvr::ProcessCB(CallBackList * l,
                      double lastTick,
                      double curTime,
                      bool bForward,
                      bool bFirstTick,
                      bool bNeedPlay)
{
    TraceTag((tagMMBaseBvr,
              "CMMBaseBvr(%lx)::ProcessCB(lt - %g, m_lt - %g, ct - %g, %d, %d, %d)",
              this,
              lastTick,
              m_lastTick,
              curTime,
              bForward,
              bFirstTick,
              bNeedPlay));

    // The duration is really the end time minus the start time since
    // the user can change it on the fly.  We need to handle this and
    // adjust as appropriate
    
    double totaldur = GetAbsEndTime() - GetAbsStartTime();

    lastTick = m_lastTick;
    
    if (bForward)
    {
        // See if we already pass this entire bvr last time or if we
        // have not got to it yet
        
        // The equality just needs to match what we checked below when
        // we fired the event the frame before.  We need to use LT for
        // curTime since we need to fire when we are 0
        
        if (lastTick >= totaldur || curTime < 0)
        {
            // Need to handle boundary case where we start at the end
            // of the animation.  If so then just fire the stop event
            // since the start was done by the start call itself
            
            if (curTime == totaldur && lastTick == totaldur && bFirstTick)
            {
                // We need this to round down to the previous boundary
                // point but not inclusive of the boundary point
                // itself.
                int offset = ceil(curTime / m_segDuration) - 1;
                if (offset < 0)
                {
                    offset = 0;
                }
                double timeOffset = offset * m_segDuration;

                if (!_ProcessCB(l,
                                lastTick - timeOffset,
                                curTime - timeOffset,
                                bForward,
                                bFirstTick,
                                bNeedPlay,
                                m_bAutoReverse && (offset & 0x1)))
                {
                    return false;
                }

                if (!EventNotify(l, totaldur, MM_STOP_EVENT, 0))
                {
                    return false;
                }
            }

            return true;
        }
        
        // We now know that the last tick was less than the
        // totalrepduration and the current time is greater than the
        // beginning

        // If the last tick was 0 then we fire the start last time
        // since the check above if for less than
        // So the rule is fire when curTime == 0.0
        
        bool bNeedStart = (lastTick < 0 || bNeedPlay);

        if (bNeedStart)
        {
            // This means that we just entered

            if (!EventNotify(l, 0, MM_PLAY_EVENT, 0))
            {
                return false;
            }
        }
        
        if (m_segDuration == MM_INFINITE)
        {
            // Just always process our children if we are infinite
            
            if (!_ProcessCB(l,
                            lastTick,
                            curTime,
                            bForward,
                            bFirstTick,
                            bNeedPlay,
                            false))
            {
                return false;
            }
        }
        else
        {
            // This is the last repeat/bounce boundary we hit
        
            int offset = 0;
            if( lastTick != -MM_INFINITE)
            {
                offset = int(lastTick / m_segDuration);

                if (offset < 0)
                {
                    offset = 0;
                }
            }

            double timeOffset = offset * m_segDuration;

            // Need to clamp our max time so it does not mess up our children
            double maxtime = min(totaldur, curTime);

            while (1)
            {
                // We need to request a reversal of the underlying
                // behavior if we are bouncing and the offset is odd
                
                if (!_ProcessCB(l,
                                lastTick - timeOffset,
                                maxtime - timeOffset,
                                true,
                                bFirstTick,
                                bNeedStart,
                                m_bAutoReverse && (offset & 0x1)))
                {
                    return false;
                }
                
                // We have reach the end of our current period so all
                // children must be stopped.
                
                if (curTime >= (timeOffset + m_segDuration) ||
                    curTime >= totaldur)
                {
                    double t;
                    
                    t = maxtime - timeOffset;
                    
                    if (t > m_segDuration)
                    {
                        t = m_segDuration;
                    }
                    
                    // First fire the end event so they can pass it on
                    // to the parent

                    if (!_ProcessEvent(l,
                                       t,
                                       false,
                                       MM_STOP_EVENT,
                                       m_bAutoReverse && (offset & 0x1),
                                       0))
                    {
                        TraceTag((tagError,
                                  "CMMBaseBvr(%lx)::ProcessCB - _ProcessEvent failed"));

                        return false;
                    }

                    // Now fire the reset so we do not get endholds to
                    // fail
                    
                    if (!_ProcessEvent(l,
                                       t,
                                       false,
                                       MM_RESET_EVENT,
                                       m_bAutoReverse && (offset & 0x1),
                                       0))
                    {
                        TraceTag((tagError,
                                  "CMMBaseBvr(%lx)::ProcessCB - _ProcessEvent failed"));

                        return false;
                    }
                }
                
                offset++;
                timeOffset += m_segDuration;
                
                if (timeOffset > curTime ||
                    timeOffset >= totaldur ||
                    curTime >= totaldur)
                {
                    if (curTime >= totaldur)
                    {
                        // This means we were inside last time but not any more -
                        // generate an exit event
                        
                        if (!EventNotify(l, totaldur, MM_STOP_EVENT, 0))
                        {
                            return false;
                        }
                    }
                    
                    break;
                }
                
                // Indicate a repeat or bounce
                // If we are autoreversing and the offset is odd then it is
                // a reverse and not a repeat
                
                if (m_bAutoReverse && (offset & 0x1))
                {
                    if (!EventNotify(l,
                                     timeOffset,
                                     MM_AUTOREVERSE_EVENT,
                                     0))
                    {
                        return false;
                    }
                }
                else
                {
                    if (!EventNotify(l, timeOffset, MM_REPEAT_EVENT, 0))
                    {
                        return false;
                    }
                }
            }
        }
    } 
    else // we are moving backwards
    {
        // (This is a hack) We move backwards only when Autoreverse is set. At
        // the point of reversal all behaviors are reset. This causes m_lastTick
        // to be set to -MM_INFINITE. This is incorrect for the case when we are
        // moving backwards. m_lastTick should actually be initialized to MM_INFINITY.
        // (makes sense because we are moving from positive infinity to zero)
        // Below we detect and correct this problem.
        if(-MM_INFINITE == lastTick)
        {
            lastTick = MM_INFINITE;
        }

        // See if we already pass this entire bvr last time or if we
        // have not got to it yet
        if (curTime > totaldur || lastTick <= 0)
        {
            if (curTime == 0.0 && lastTick == 0.0 && bFirstTick)
            {
                // Need to handle the boundary case where we start at
                // the beginning going backwards.  The start call
                // itself handles the start event but we need to
                // process the rest of the behaviors to fire the stops

                if (!_ProcessCB(l,
                                lastTick,
                                curTime,
                                bForward,
                                true,
                                bNeedPlay,
                                false))
                {
                    return false;
                }

                if (!EventNotify(l, 0.0, MM_STOP_EVENT, 0))
                {
                    return false;
                }
            }
            
            return true;
        }
        
        // We now know that the last tick was greater than the beginning
        // and the current time less than the total duration. 
        // Below we determine if we need to start playing on the first tick.
        bool bNeedStart = (lastTick >= totaldur || bNeedPlay);
        if (bNeedStart)
        {
            if (!EventNotify(l, totaldur, MM_PLAY_EVENT, 0))
            {
                return false;
            }
            
        }

        if (m_segDuration == MM_INFINITE)
        {
            // Just always process our children if we are infinite
            
            if (!_ProcessCB(l,
                            lastTick,
                            curTime,
                            bForward,
                            bFirstTick,
                            bNeedPlay,
                            false))
            {
                return false;
            }

            if (curTime <= 0)
            {
                if (!EventNotify(l, 0.0, MM_STOP_EVENT, 0))
                {
                    return false;
                }
            }
                
        } else {
            // This will be the repeat point to begin with
            double maxtime = min(lastTick,totaldur);

            int offset;
            double timeOffset;
                
            // This puts us on the last duration boundary greater than
            // the last position

            // It needs to be one greater since our loop decrements
            // first
            offset = int(ceil(maxtime / m_segDuration));
            timeOffset = offset * m_segDuration;
            
            while (1)
            {
                offset--;
                timeOffset -= m_segDuration;
            
                if (!_ProcessCB(l,
                                maxtime - timeOffset,
                                curTime - timeOffset,
                                false,
                                bFirstTick,
                                bNeedStart,
                                m_bAutoReverse && (offset & 0x1)))
                {
                    return false;
                }
                
                if (timeOffset < curTime)
                {
                    break;
                }
                
                // We have reach the end of our current period so all
                // children must be stopped.
                {
                    double t;

                    t = curTime - timeOffset;

                    if (t > m_segDuration)
                    {
                        t = m_segDuration;
                    }
                
                    // First fire the end event so they can pass it on
                    // to the parent

                    if (!_ProcessEvent(l,
                                       t,
                                       false,
                                       MM_STOP_EVENT,
                                       m_bAutoReverse && (offset & 0x1),
                                       0))
                    {
                        return false;
                    }

                    // Now fire the reset so we do not get endholds to
                    // fail
                    
                    if (!_ProcessEvent(l,
                                       t,
                                       false,
                                       MM_RESET_EVENT,
                                       m_bAutoReverse && (offset & 0x1),
                                       0))
                    {
                        return false;
                    }
                }
                
                // If we have reached the end then notify and break
                
                if (offset <= 0)
                {
                    // This means we were inside last time but not any more -
                    // generate an exit event
                    
                    if (!EventNotify(l, 0.0, MM_STOP_EVENT, 0))
                    {
                        return false;
                    }
                    
                    break;
                }
                
                // Indicate a repeat or bounce
                // If we are bouncing and the offset is odd then it is
                // a bounce and not a repeat
                
                if (m_bAutoReverse && (offset & 0x1))
                {
                    if (!EventNotify(l,
                                     timeOffset,
                                     MM_AUTOREVERSE_EVENT,
                                     0))
                    {
                        return false;
                    }
                }
                else
                {
                    if (!EventNotify(l,
                                     timeOffset,
                                     MM_REPEAT_EVENT,
                                     0))
                    {
                        return false;
                    }
                }
            }
        }
    }
    
    m_lastTick = curTime;

    return true;
}

// This is in our local time space

bool
CMMBaseBvr::ProcessEvent(CallBackList * l,
                         double time,
                         bool bFirstTick,
                         MM_EVENT_TYPE et,
                         DWORD flags)
{
    TraceTag((tagMMBaseBvr,
              "CMMBaseBvr(%lx)::ProcessEvent(%g, %d, %s, %lx)",
              this,
              time,
              bFirstTick,
              EventString(et),
              flags));

    double totaldur = GetAbsEndTime() - GetAbsStartTime();
    
    // If it is outside of our range then just bail
    if (time < 0 || time > totaldur)
    {
        // (1) Need to update m_lastTick when we are seeking even if 
        // we are out of our range. (2) RESUME is not allowed
        // to update m_lastTick because whenever a 
        // PAUSE -> seek(i.e.STOP+PLAY) -> RESUME 
        // is carried out, RESUME stomps over the 
        // m_lastTick set by the seek. When no seeking is done
        // we should still be fine, since we can assume that
        // a RESUME is always preceeded by a PAUSE, which correctly 
        // sets m_lastTick.
        if ((MM_EVENT_SEEK & flags) && (MM_RESUME_EVENT != et))
        {
            if (MM_PLAY_EVENT == et)
            {
                // hack to make endhold work correctly while seeking fowards (over our lifespan)
                if (m_lastTick < 0 && time > totaldur)
                {
                    EventNotify(l, time, MM_PLAY_EVENT, MM_EVENT_SEEK);
                }
                else 
                {
                    // hack to make endhold work correctly while seeking backwards (over our lifespan)
                    if (time < 0 && m_lastTick > totaldur)
                    {
                        EventNotify(l, time, MM_RESET_EVENT, MM_EVENT_SEEK);
                    }
                }
            }

            m_lastTick = time;
            
            if (!_ProcessEvent(l,
                time,
                bFirstTick,
                et,
                false,
                flags))
            {
                return false;
            }
        }
        return true;
    }

    
    // Plays and Pauses get called on the way down
    if (et == MM_PAUSE_EVENT || et == MM_PLAY_EVENT)
    {
        
        if (!EventNotify(l, time, et, flags))
        {
            return false;
        }

        if (MM_EVENT_SEEK & flags)
        {
            bool bDeleted;
            bDeleted = false;
            for (CallBackList::iterator i = l->begin(); i != l->end(); i++)
            {
                if ( (ITIMEMMBehavior*) this == (*i)->GetBehavior() )
                {
                    if (MM_STOP_EVENT == (*i)->GetEventType() )
                    {
                        CallBackList::iterator j = l->end();
                        for (j--; j != l->begin(); j--)
                        {
                            if ( (ITIMEMMBehavior*) this == (*j)->GetBehavior() )
                            {
                                if ( MM_PLAY_EVENT == (*j)->GetEventType() )
                                {
                                    delete (*j);
                                    delete (*i);                        
                                    
                                    l->erase(i);
                                    l->erase(j);
                                    
                                    bDeleted = true;
                                    
                                    // Get out of inner for loop
                                    break;
                                }
                            }
                        } // for j

                        if (bDeleted)
                            // Get out of outer for loop
                            break;
                    }
                }
            } // for i
        }
    }
    
    if (m_segDuration == MM_INFINITE) {
        // Just always process our children if we are infinite
        
        if (!_ProcessEvent(l,
                           time,
                           bFirstTick,
                           et,
                           false,
                           flags))
        {
            return false;
        }
    } else {
        // This is the last repeat/bounce boundary we hit
        int offset = int(time / m_segDuration);
        
        Assert(offset >= 0);

        // We need to request a reversal of the underlying
        // behavior if we are bouncing and the offset is odd
        
        if (!_ProcessEvent(l,
                           time - (offset * m_segDuration),
                           bFirstTick,
                           et,
                           m_bAutoReverse && (offset & 0x1),
                           flags))
        {
            return false;
        }
    }
    
    // Stops and Resumes get called on the way up
    if (et == MM_STOP_EVENT || et == MM_RESUME_EVENT)
    {
        if (!EventNotify(l, time, et, flags))
        {
            return false;
        }
    }

    // Mark this as the last tick time.
    // RESUME is not allowed to set m_lastTick (See note near the start of this function).
    if (MM_RESUME_EVENT != et)
    {
        m_lastTick = time;
    }
    return true;
}


CallBackData::CallBackData(ITIMEMMBehavior * bvr,
                           ITIMEMMEventCB * eventcb,
                           double time,
                           MM_EVENT_TYPE et,
                           DWORD flags)
: m_bvr(bvr),
  m_eventcb(eventcb),
  m_time(time),
  m_et(et),
  m_flags(flags)
{
    Assert(eventcb);
}

CallBackData::~CallBackData()
{
}

HRESULT
CallBackData::CallEvent()
{
    Assert(m_eventcb);
    
    return THR(m_eventcb->OnEvent(m_time,
                                  m_bvr,
                                  m_et,
                                  m_flags));
}

bool
ProcessCBList(CallBackList &l)
{
    bool ok = true;
    
    for (CallBackList::iterator i = l.begin();
         i != l.end();
         i++) {

        if (FAILED((*i)->CallEvent()))
            ok = false;

        delete (*i);
    }

    l.clear();

    if (!ok)
        CRSetLastError(E_FAIL, NULL);

    return ok;
}

#ifdef _DEBUG

void PrintCBList(CallBackList &l)
{
    TraceTag((tagMMNotify, "Starting PrintCBList"));
    for (CallBackList::iterator i = l.begin(); i != l.end(); i++)
    {
        TraceTag((tagMMNotify,
              "ITIMEMMBehavior(%lx)     Event=%i",
              (*i)->GetBehavior(),
              (*i)->GetEventType() ));
    }
}

#endif // _DEBUG
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\time\mmapi\mmfactory.h ===
/*******************************************************************************

Copyright (c) 1995_96 Microsoft Corporation

Abstract:

    {Insert General Comment Here}

*******************************************************************************/


#ifndef _MMFACTORY_H
#define _MMFACTORY_H

#include "datime.h"

#define LIBID __T("TIME")

class ATL_NO_VTABLE CMMFactory
    : public CComObjectRootEx<CComSingleThreadModel>,
      public CComCoClass<CMMFactory, &CLSID_TIMEMMFactory>,
      public IDispatchImpl<ITIMEMMFactory, &IID_ITIMEMMFactory, &LIBID_TIME>,
      public ISupportErrorInfoImpl<&IID_ITIMEMMFactory>
{
  public:
    CMMFactory();
    ~CMMFactory();

    DA_DECLARE_NOT_AGGREGATABLE(CMMFactory);

    HRESULT FinalConstruct();
#if _DEBUG
    const _TCHAR * GetName() { return __T("CMMFactory"); }
#endif

    DECLARE_REGISTRY(CLSID_TIMEMMFactory,
                     LIBID __T(".MMFactory.1"),
                     LIBID __T(".MMFactory"),
                     0,
                     THREADFLAGS_BOTH);

    BEGIN_COM_MAP(CMMFactory)
        COM_INTERFACE_ENTRY(IDispatch)
        COM_INTERFACE_ENTRY(ITIMEMMFactory)
        COM_INTERFACE_ENTRY(ISupportErrorInfo)
    END_COM_MAP();

    STDMETHOD(CreateBehavior)(LPOLESTR id,
                              IDispatch *bvr,
                              IUnknown **ppOut);
    STDMETHOD(CreateTimeline)(LPOLESTR id,
                              IUnknown **ppOut);
    STDMETHOD(CreatePlayer)(LPOLESTR id,
                            IUnknown *bvr,
                            IServiceProvider * sp,
                            IUnknown **ppOut);
    STDMETHOD(CreateView)(LPOLESTR id,
                          IDispatch * imgbvr,
                          IDispatch * sndbvr,
                          IUnknown * viewsite,
                          IUnknown **ppOut);
    
    HRESULT Error();
};


#endif /* _MMFACTORY_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\time\mmapi\mmprops.cpp ===
/*******************************************************************************
 *
 * Copyright (c) 1998 Microsoft Corporation
 *
 * File: mmprops.cpp
 *
 * Abstract:
 *
 *
 *
 *******************************************************************************/


#include "headers.h"
#include "mmbasebvr.h"
#include "mmplayer.h"

HRESULT
CMMBaseBvr::GetID(LPOLESTR * p)
{
    TraceTag((tagMMBaseBvr,
              "CMMBaseBvr(%lx)::GetID()",
              this));

    HRESULT hr;
    
    CHECK_RETURN_SET_NULL(p);

    if (m_id)
    {
        *p = SysAllocString(m_id);

        if (*p == NULL)
        {
            hr = E_OUTOFMEMORY;
            goto done;
        }
    }
    
    hr = S_OK;
  done:
    return hr;
}

HRESULT
CMMBaseBvr::SetID(LPOLESTR s)
{
    TraceTag((tagMMBaseBvr,
              "CMMBaseBvr(%lx)::SetID(%ls)",
              this,
              s));

    HRESULT hr;

    delete m_id;
    m_id = NULL;

    if (s)
    {
        s = CopyString(s);

        if (s == NULL)
        {
            hr = E_OUTOFMEMORY;
            goto done;
        }
    }

    hr = S_OK;
  done:
    return hr;
}
        
HRESULT
CMMBaseBvr::GetStartOffset(float * p)
{
    TraceTag((tagMMBaseBvr,
              "CMMBaseBvr(%lx)::GetStartOffset()",
              this));

    CHECK_RETURN_NULL(p);

    *p = m_startOffset;
    return S_OK;
}

HRESULT
CMMBaseBvr::SetStartOffset(float s)
{
    TraceTag((tagMMBaseBvr,
              "CMMBaseBvr(%lx)::SetStartOffset(%g)",
              this,
              s));

    m_startOffset = s;

    Invalidate();
    
    return S_OK;
}
        
HRESULT
CMMBaseBvr::GetDuration(float * pdur)
{
    TraceTag((tagMMBaseBvr,
              "CMMBaseBvr(%lx)::GetDuration()",
              this));

    CHECK_RETURN_NULL(pdur);

    *pdur = m_duration;
    return S_OK;
}

HRESULT
CMMBaseBvr::SetDuration(float dur)
{
    TraceTag((tagMMBaseBvr,
              "CMMBaseBvr(%lx)::SetDuration(%g)",
              this,
              dur));

    m_duration = dur;

    Invalidate();
    
    return S_OK;
}
        
HRESULT
CMMBaseBvr::GetRepeatDur(float * pr)
{
    TraceTag((tagMMBaseBvr,
              "CMMBaseBvr(%lx)::GetRepeatDur()",
              this));

    CHECK_RETURN_NULL(pr);

    *pr = m_repeatDur;
    return S_OK;
}

HRESULT
CMMBaseBvr::SetRepeatDur(float r)
{
    TraceTag((tagMMBaseBvr,
              "CMMBaseBvr(%lx)::SetRepeatDur(%g)",
              this,
              r));

    m_repeatDur = r;

    Invalidate();
    
    return S_OK;
}
        
HRESULT
CMMBaseBvr::GetRepeat(LONG * prepeat)
{
    TraceTag((tagMMBaseBvr,
              "CMMBaseBvr(%lx)::GetRepeat()",
              this));

    CHECK_RETURN_NULL(prepeat);

    *prepeat = m_repeat;
    return S_OK;
}

HRESULT
CMMBaseBvr::SetRepeat(LONG repeat)
{
    TraceTag((tagMMBaseBvr,
              "CMMBaseBvr(%lx)::SetRepeat(%d)",
              this,
              repeat));

    m_repeat = repeat;

    Invalidate();
    
    return S_OK;
}
        
HRESULT
CMMBaseBvr::GetAutoReverse(VARIANT_BOOL * pautoreverse)
{
    TraceTag((tagMMBaseBvr,
              "CMMBaseBvr(%lx)::GetAutoReverse()",
              this));

    CHECK_RETURN_NULL(pautoreverse);

    *pautoreverse = m_bAutoReverse;
    return S_OK;
}

HRESULT
CMMBaseBvr::SetAutoReverse(VARIANT_BOOL autoreverse)
{
    TraceTag((tagMMBaseBvr,
              "CMMBaseBvr(%lx)::SetAutoReverse(%d)",
              this,
              autoreverse));

    m_bAutoReverse = autoreverse?true:false;

    Invalidate();
    
    return S_OK;
}
        
HRESULT
CMMBaseBvr::GetEndOffset(float * p)
{
    TraceTag((tagMMBaseBvr,
              "CMMBaseBvr(%lx)::GetEndOffset()",
              this));

    CHECK_RETURN_NULL(p);

    *p = m_endOffset;
    return S_OK;
}

HRESULT
CMMBaseBvr::SetEndOffset(float s)
{
    TraceTag((tagMMBaseBvr,
              "CMMBaseBvr(%lx)::SetEndOffset(%g)",
              this,
              s));

    m_endOffset = s;

    Invalidate();
    
    return S_OK;
}
        
HRESULT
CMMBaseBvr::GetEventCB(ITIMEMMEventCB ** evcb)
{
    TraceTag((tagMMBaseBvr,
              "CMMBaseBvr(%lx)::GetEventCB()",
              this));

    CHECK_RETURN_SET_NULL(evcb);

    *evcb = m_eventcb;
    if (m_eventcb) m_eventcb->AddRef();

    return S_OK;
}

HRESULT
CMMBaseBvr::SetEventCB(ITIMEMMEventCB * evcb)
{
    TraceTag((tagMMBaseBvr,
              "CMMBaseBvr(%lx)::SetEventCB(%lx)",
              this,
              evcb));

    m_eventcb = evcb;
    return S_OK;
}
        
HRESULT
CMMBaseBvr::GetEaseIn(float * pd)
{
    TraceTag((tagMMBaseBvr,
              "CMMBaseBvr(%lx)::GetEaseIn()",
              this));

    CHECK_RETURN_NULL(pd);

    *pd = m_easeIn;
    return S_OK;
}

HRESULT
CMMBaseBvr::SetEaseIn(float d)
{
    TraceTag((tagMMBaseBvr,
              "CMMBaseBvr(%lx)::SetEaseIn(%g)",
              this,
              d));

    if (d < 0.0 || d > 1.0) return E_INVALIDARG;
    
    m_easeIn = d;

    Invalidate();
    
    return S_OK;
}
        
HRESULT
CMMBaseBvr::GetEaseInStart(float * pd)
{
    TraceTag((tagMMBaseBvr,
              "CMMBaseBvr(%lx)::GetEaseInStart()",
              this));

    CHECK_RETURN_NULL(pd);

    *pd = m_easeInStart;
    return S_OK;
}

HRESULT
CMMBaseBvr::SetEaseInStart(float d)
{
    TraceTag((tagMMBaseBvr,
              "CMMBaseBvr(%lx)::SetEaseInStart(%g)",
              this,
              d));

    if (d < 0.0 || d > 1.0) return E_INVALIDARG;

    m_easeInStart = d;

    Invalidate();
    
    return S_OK;
}
        
HRESULT
CMMBaseBvr::GetEaseOut(float * pd)
{
    TraceTag((tagMMBaseBvr,
              "CMMBaseBvr(%lx)::GetEaseOut()",
              this));

    CHECK_RETURN_NULL(pd);

    *pd = m_easeOut;
    return S_OK;
}

HRESULT
CMMBaseBvr::SetEaseOut(float d)
{
    TraceTag((tagMMBaseBvr,
              "CMMBaseBvr(%lx)::SetEaseOut(%g)",
              this,
              d));

    if (d < 0.0 || d > 1.0) return E_INVALIDARG;

    m_easeOut = d;

    Invalidate();
    
    return S_OK;
}
        
HRESULT
CMMBaseBvr::GetEaseOutEnd(float * pd)
{
    TraceTag((tagMMBaseBvr,
              "CMMBaseBvr(%lx)::GetEaseOutEnd()",
              this));

    CHECK_RETURN_NULL(pd);

    *pd = m_easeOutEnd;
    return S_OK;
}

HRESULT
CMMBaseBvr::SetEaseOutEnd(float d)
{
    TraceTag((tagMMBaseBvr,
              "CMMBaseBvr(%lx)::SetEaseOutEnd(%g)",
              this,
              d));

    if (d < 0.0 || d > 1.0) return E_INVALIDARG;

    m_easeOutEnd = d;

    Invalidate();
    
    return S_OK;
}
        
HRESULT
CMMBaseBvr::GetSyncFlags(DWORD * flags)
{
    TraceTag((tagMMBaseBvr,
              "CMMBaseBvr(%lx)::GetSyncFlags()",
              this));

    CHECK_RETURN_NULL(flags);

    *flags = m_syncFlags;

    return S_OK;
}

HRESULT
CMMBaseBvr::SetSyncFlags(DWORD flags)
{
    TraceTag((tagMMBaseBvr,
              "CMMBaseBvr(%lx)::SetSyncFlags(%d)",
              this,
              flags));

    // if we need to registered a Timer Callback, add it to the player.
    if (m_player)
    {
        bool newcs = (flags & MM_CLOCKSOURCE) != 0;
        bool oldcs = IsClockSource();
        
        // If the clock source parameter changed update ourselves in
        // the player
        if (newcs && !oldcs)
        {
            m_player->AddBvrCB(this);
        }
        else if (oldcs && !newcs)
        {
            m_player->RemoveBvrCB(this);
        }
    }

    m_syncFlags = flags;

    return S_OK;
}

HRESULT
CMMBaseBvr::GetTotalTime(float * pr)
{
    TraceTag((tagMMBaseBvr,
              "CMMBaseBvr(%lx)::GetTotalTime()",
              this));

    CHECK_RETURN_NULL(pr);

    *pr = m_totalDuration;
    return S_OK;
}


HRESULT
CMMBaseBvr::GetDABehavior(REFIID riid, void ** bvr)
{
    TraceTag((tagMMBaseBvr,
              "CMMBaseBvr(%lx)::GetDABehavior()",
              this));

    CHECK_RETURN_SET_NULL(bvr);

    Assert(m_rawbvr);

    if (!CRBvrToCOM(m_rawbvr,
                    riid,
                    bvr))
        return Error();
    
    return S_OK;
}

HRESULT
CMMBaseBvr::GetResultantBehavior(REFIID riid, void ** bvr)
{
    TraceTag((tagMMBaseBvr,
              "CMMBaseBvr(%lx)::GetResultantBehavior()",
              this));

    CHECK_RETURN_SET_NULL(bvr);

    if (m_resultantbvr)
    {
        if (!CRBvrToCOM(m_resultantbvr,
                        riid,
                        bvr))
        {
            return Error();
        }
    }
    
    return S_OK;
}

HRESULT
CMMBaseBvr::GetLocalTime(double * d)
{
    TraceTag((tagMMBaseBvr,
              "CMMBaseBvr(%lx)::GetLocalTime()",
              this));

    CHECK_RETURN_NULL(d);

    *d = GetCurrentLocalTime();
    
    return S_OK;
}

HRESULT
CMMBaseBvr::GetLocalTimeEx(double * d)
{
    TraceTag((tagMMBaseBvr,
              "CMMBaseBvr(%lx)::GetLocalTimeEx()",
              this));

    CHECK_RETURN_NULL(d);

    *d = GetCurrentLocalTimeEx();

    return S_OK;
}

HRESULT
CMMBaseBvr::GetSegmentTime(double * d)
{
    TraceTag((tagMMBaseBvr,
              "CMMBaseBvr(%lx)::GetSegmentTime()",
              this));

    CHECK_RETURN_NULL(d);

    *d = GetCurrentSegmentTime();
    
    return S_OK;
}

HRESULT
CMMBaseBvr::GetPlayState(MM_STATE * state)
{
    TraceTag((tagMMBaseBvr,
              "CMMBaseBvr(%lx)::GetPlayState()",
              this));

    CHECK_RETURN_NULL(state);

    double t = GetCurrentLocalTime();
    
    if(m_bPlaying == false)
    {
        *state = MM_STOPPED_STATE;
        }
    else
    {
        *state = m_bPaused?MM_PAUSED_STATE:MM_PLAYING_STATE;
    }
    
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\time\mmapi\mmplayer.h ===
/*******************************************************************************
 *
 * Copyright (c) 1998 Microsoft Corporation
 *
 * File: mmplayer.h
 *
 * Abstract:
 *
 *
 *
 *******************************************************************************/

#ifndef _MMPLAYER_H
#define _MMPLAYER_H

#include "mmbasebvr.h"
#include <mshtml.h>
#include <vector>

interface ITIMEMMBehavior;
class CMMView;

typedef std::list< CMMView * > ViewList;
typedef std::list< CMMBaseBvr * > BvrCBList;

class
__declspec(uuid("48ddc6be-5c06-11d2-b957-3078302c2030")) 
ATL_NO_VTABLE CMMPlayer
    : public CComObjectRootEx<CComSingleThreadModel>,
      public CComCoClass<CMMPlayer, &__uuidof(CMMPlayer)>,
      public ITIMEMMPlayer,
      public ISupportErrorInfoImpl<&IID_ITIMEMMPlayer>
{
  public:
    CMMPlayer();
    ~CMMPlayer();

    STDMETHOD_(ULONG,AddRef)(void) = 0;
    STDMETHOD_(ULONG,Release)(void) = 0;
    STDMETHOD(QueryInterface)(REFIID iid, void ** ppvObject) = 0;
    
    HRESULT Init(LPOLESTR id,
                 ITIMEMMBehavior * bvr,
                 IServiceProvider * sp);


    void Deinit();
    
#if _DEBUG
    const _TCHAR * GetName() { return __T("CMMPlayer"); }
#endif

    BEGIN_COM_MAP(CMMPlayer)
        COM_INTERFACE_ENTRY(ITIMEMMPlayer)
        COM_INTERFACE_ENTRY(ISupportErrorInfo)
    END_COM_MAP();

    //
    // ITIMEMMPlayer
    //
    
    STDMETHOD(get_ID)(LPOLESTR * s);
    STDMETHOD(put_ID)(LPOLESTR s);
        
    STDMETHOD(Play)();
    STDMETHOD(Stop)();
    STDMETHOD(Pause)();
    STDMETHOD(Resume)();
    STDMETHOD(Shutdown)();
    
    STDMETHOD(get_PlayerState)(MM_STATE *);
        
    STDMETHOD(get_CurrentTime)(double * d);

    STDMETHOD(SetPosition)(double lTime);
    STDMETHOD(SetDirection)(VARIANT_BOOL bForward);
        
    STDMETHOD(get_Behavior)(ITIMEMMBehavior ** mmbvr);

    STDMETHOD(Tick)(double simTime);
    
    STDMETHOD(AddView)(ITIMEMMView * view);
    STDMETHOD(RemoveView)(ITIMEMMView * view);

    //
    // Accessors
    //

    bool IsStopped() { return m_state == MM_STOPPED_STATE; }
    bool IsStarted() { return m_state != MM_STOPPED_STATE; }
    bool IsPlaying() { return m_state == MM_PLAYING_STATE; }
    bool IsPaused() { return m_state == MM_PAUSED_STATE; }

    void Invalidate() { m_bNeedsUpdate = true; }

    void HookCallback(double lTime);

    double GetTotalDuration() { return m_mmbvr->GetTotalDuration(); }

    bool IsFirstTick() { return m_firstTick; }
    double GetCurrentTime() { return m_curTick; }

    long AddRunningBehavior(CRBvrPtr bvr);
    bool RemoveRunningBehavior(long);

    bool AddBvrCB(CMMBaseBvr *pbvr);
    bool RemoveBvrCB(CMMBaseBvr *pbvr);

    // !!This does not addref!!
    IServiceProvider * GetServiceProvider();
  protected:
    bool UpdateBvr();
    bool _Start(double lTime);
    bool _Stop(double lTime);
    bool _Pause();
    bool _Resume();
    bool _Seek(double lTime);
    
    bool ProcessEvent(CallBackList &l,
                      double lTime,
                      MM_EVENT_TYPE event);
    
    bool ProcessCB(CallBackList & l,
                   double lTime);
    
    bool SetTimeSub(double lTime, bool bPause);

    HRESULT Error();
    
  protected:
    LPWSTR m_id;
    DAComPtr<CMMBaseBvr> m_mmbvr;
    DAComPtr<IServiceProvider> m_sp;
    CRViewPtr m_view;
    MM_STATE m_state;
    double m_curTick;
    bool m_bForward;
    bool m_bNeedsUpdate;
    bool m_firstTick;
    
    CRPtr<CRNumber> m_timeSub;
    ViewList m_viewList;
    BvrCBList m_bvrCBList;

    class PlayerHook : public CRBvrHook
    {
      public:
        PlayerHook();
        ~PlayerHook();
        
        virtual CRSTDAPICB_(ULONG) AddRef() { m_cRef++; return m_cRef; }
        virtual CRSTDAPICB_(ULONG) Release() {
            long r = --m_cRef;

            if (r == 0)
                delete this;

            return r;
        }
        
        CRSTDAPICB_(CRBvrPtr) Notify(long id,
                                     bool startingPerformance,
                                     double startTime,
                                     double gTime,
                                     double lTime,
                                     CRBvrPtr sampleVal,
                                     CRBvrPtr curRunningBvr);

        void SetPlayer(CMMPlayer * t) { m_player = t; }

      protected:
        // We do not need a refcount since we are single threaded and
        // the player will NULL it out if it goes away

        CMMPlayer * m_player;
        long m_cRef;
    };

    DAComPtr<PlayerHook> m_playerhook;
};

inline IServiceProvider *
CMMPlayer::GetServiceProvider()
{
    return m_sp;
}

#endif /* _MMPLAYER_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\time\mmapi\mmplayer.cpp ===
/*******************************************************************************

Copyright (c) 1995-96 Microsoft Corporation

Abstract:

    {Insert General Comment Here}

*******************************************************************************/


#include "headers.h"
#include "mmplayer.h"
#include "mmbasebvr.h"
#include "mmview.h"

DeclareTag(tagMMPlayer, "API", "CMMPlayer methods");
DeclareTag(tagMMDetailNotify, "API", "Detailed notify");

CMMPlayer::CMMPlayer()
: m_id(NULL),
  m_state(MM_STOPPED_STATE),
  m_bForward(true),
  m_bNeedsUpdate(true),
  m_firstTick(true),
  m_view(NULL)
{
}

CMMPlayer::~CMMPlayer()
{
    Deinit();
}

HRESULT
CMMPlayer::Init(LPOLESTR id,
                ITIMEMMBehavior * bvr,
                IServiceProvider * sp)
{
    TraceTag((tagMMPlayer,
              "CMMPlayer(%lx)::Init(%ls, %#lx,%#lx)",
              this,
              id,
              bvr,
              sp));
    
    HRESULT hr = S_OK;
    
    Deinit();
    
    if (!bvr || !sp)
    {
        TraceTag((tagError,
                  "CMMPlayer(%lx)::Init: Invalid behavior passed in.",
                  this));
                  
        hr = E_INVALIDARG;
        goto done;
    }

    if (id)
    {
        m_id = CopyString(id);
        
        if (m_id == NULL)
        {
            hr = E_OUTOFMEMORY;
            goto done;
        }
    }
    
    m_sp = sp;
    
    m_view = CRCreateView();

    if (m_view == NULL)
    {
        hr = CRGetLastError();
        goto done;
    }
    
    if (!CRSetServiceProvider(m_view, sp))
    {
        hr = CRGetLastError();
        goto done;
    }
    
    if (!CRSetDC(m_view, NULL))
    {
        hr = CRGetLastError();
        goto done;
    }
    
    if (!CRStartModel(m_view, CREmptyImage(), NULL, 0.0, CRAsyncFlag, NULL))
    {
        hr = CRGetLastError();
        goto done;
    }
    
    CMMBaseBvr * cbvr;

    cbvr = GetBvr(bvr);
    
    if (!cbvr)
    {
        TraceTag((tagError,
                  "CMMPlayer(%lx)::Init: Invalid behavior passed in.",
                  this));
                  
        hr = E_INVALIDARG;
        goto done;
    }

    m_mmbvr = cbvr;
    
    m_mmbvr->SetPlayer(this);

    if (!m_mmbvr->SetParent(NULL, MM_START_ABSOLUTE, NULL))
    {
        hr = CRGetLastError();
        goto done;
    }

    m_playerhook = NEW PlayerHook;

    if (!m_playerhook)
    {
        TraceTag((tagError,
                  "CMMPlayer(%lx)::Init: Out of memory allocating player hook.",
                  this));
                  
        hr = E_OUTOFMEMORY;
        goto done;
    }
    
    {
        CRLockGrabber __gclg;

        if (!(m_timeSub = CRModifiableNumber(0.0)))
        {
            hr = CRGetLastError();
            goto done;
        }
        
        if (!UpdateBvr())
        {
            hr = CRGetLastError();
            goto done;
        }

        // Place us in a stopped state
        if (!_Start(0) || !_Stop(0))
        {
            hr = CRGetLastError();
            goto done;
        }
    }

    hr = S_OK;
  done:

    if (FAILED(hr))
    {
        // Clean up now
        Deinit();
    }
    
    return hr;
}

STDMETHODIMP
CMMPlayer::Shutdown()
{
    ViewList::iterator i;

    for (i = m_viewList.begin(); i != m_viewList.end(); i++)
    {
        // Need to call stop on the view to make sure it cleans up
        (*i)->Stop();
    }
    return S_OK;
}

void
CMMPlayer::Deinit()
{
    TraceTag((tagMMPlayer,
              "CMMPlayer(%lx)::Deinit()",
              this));

    // Ensure the player will not try to call us since we are going away

    if (m_playerhook)
    {
        m_playerhook->SetPlayer(NULL);
        m_playerhook = NULL;
    }

    if (m_mmbvr)
    {
        m_mmbvr->ClearPlayer();
        m_mmbvr = NULL;
    }

    if (m_view)
    {
        CRSetServiceProvider(m_view, NULL);
        CRStopModel(m_view);
        CRDestroyView(m_view);
        m_view = NULL;
    }
        
    m_sp.Release();
    
    delete m_id;
    m_id = NULL;

    BvrCBList::iterator j;
    for (j = m_bvrCBList.begin(); j != m_bvrCBList.end(); j++)
    {
        (*j)->Release();
    }

    // run though and delete the items in the vector.
    ViewList::iterator i;

    for (i = m_viewList.begin(); i != m_viewList.end(); i++)
    {
        // Need to call stop on the view to make sure it cleans up
        (*i)->Stop();
        (*i)->Release();
    }
}

HRESULT
CMMPlayer::get_ID(LPOLESTR * p)
{
    TraceTag((tagMMPlayer,
              "CMMPlayer(%lx)::get_ID()",
              this));

    HRESULT hr;
    
    CHECK_RETURN_SET_NULL(p);

    if (m_id)
    {
        *p = SysAllocString(m_id);

        if (*p == NULL)
        {
            hr = E_OUTOFMEMORY;
            goto done;
        }
    }
    
    hr = S_OK;
  done:
    return hr;
}

HRESULT
CMMPlayer::put_ID(LPOLESTR s)
{
    TraceTag((tagMMPlayer,
              "CMMPlayer(%lx)::put_ID(%ls)",
              this,
              s));

    HRESULT hr;

    delete m_id;
    m_id = NULL;

    if (s)
    {
        s = CopyString(s);

        if (s == NULL)
        {
            hr = E_OUTOFMEMORY;
            goto done;
        }
    }

    hr = S_OK;
  done:
    return hr;
}
        
STDMETHODIMP
CMMPlayer::get_Behavior(ITIMEMMBehavior ** mmbvr)
{
    CHECK_RETURN_SET_NULL(mmbvr);

    Assert (m_mmbvr);
    
    return m_mmbvr->QueryInterface(IID_ITIMEMMBehavior,
                                   (void **) mmbvr);
}

STDMETHODIMP
CMMPlayer::get_PlayerState(MM_STATE * pstate)
{
    CHECK_RETURN_NULL(pstate);
    
    *pstate = m_state;

    return S_OK;
}

STDMETHODIMP
CMMPlayer::get_CurrentTime(double * d)
{
    CHECK_RETURN_NULL(d);

    *d = m_curTick;

    return S_OK;
}

STDMETHODIMP
CMMPlayer::SetPosition(double lTime)
{
    TraceTag((tagMMPlayer,
              "CMMPlayer(%lx)::SetPosition(%g)",
              this,
              lTime));

    bool ok = false;

    if (!_Seek(lTime))
    {
        goto done;
    }

    ok = true;
  done:
    return ok?S_OK:Error();
}

STDMETHODIMP
CMMPlayer::SetDirection(VARIANT_BOOL bForward)
{
    TraceTag((tagMMPlayer,
              "CMMPlayer(%lx)::SetDirection(%d)",
              this,
              bForward));

    if (IsStarted())
    {
        TraceTag((tagError,
                  "CMMPlayer(%lx)::SetDirection: Behavior already started.",
                  this));

        return E_FAIL;
    }

    m_bForward = bForward?true:false;
    return S_OK;
}


STDMETHODIMP
CMMPlayer::Play()
{
    TraceTag((tagMMPlayer,
              "CMMPlayer(%lx)::Play()",
              this));

    bool ok = false;
    CallBackList l;

    if (!IsStopped()) {
        CRSetLastError(E_FAIL, NULL);
        goto done;
    }
        
    if (!_Start(m_curTick) ||
        !ProcessEvent(l, m_curTick, MM_PLAY_EVENT) ||
        !ProcessCBList(l))
        goto done;

    ok = true;
  done:
    return ok?S_OK:Error();
}

STDMETHODIMP
CMMPlayer::Stop()
{
    TraceTag((tagMMPlayer,
              "CMMPlayer(%lx)::Stop()",
              this));

    bool ok = false;
    CallBackList l;

    if (IsStopped()) {
        ok = true;
        goto done;
    }
    
    if (!_Stop(m_curTick) ||
        !ProcessEvent(l, m_curTick, MM_STOP_EVENT) ||
        !ProcessCBList(l))
        goto done;
    
    ok = true;
  done:
    return ok?S_OK:Error();
}

STDMETHODIMP
CMMPlayer::Pause()
{
    TraceTag((tagMMPlayer,
              "CMMPlayer(%lx)::Pause()",
              this));

    bool ok = false;
    CallBackList l;

    if (IsPaused()) {
        ok = true;
        goto done;
    }
    
    if (IsStopped()) {
        if (FAILED(Play()))
            goto done;
    }
    
    Assert(IsPlaying());
        
    if (!_Pause() ||
        !ProcessEvent(l, m_curTick, MM_PAUSE_EVENT) ||
        !ProcessCBList(l))
        goto done;
    
    ok = true;
  done:
    return ok?S_OK:Error();
}

STDMETHODIMP
CMMPlayer::Resume()
{
    TraceTag((tagMMPlayer,
              "CMMPlayer(%lx)::Resume()",
              this));

    bool ok = false;
    CallBackList l;

    if (IsPlaying()) {
        ok = true;
        goto done;
    } else if (IsStopped()) {
        if (FAILED(Play()))
            goto done;
    } else {
        Assert(IsPaused());
    }
    
    if (!_Resume() ||
        !ProcessEvent(l, m_curTick, MM_RESUME_EVENT) ||
        !ProcessCBList(l))
        goto done;
    
    ok = true;
  done:
    return ok?S_OK:Error();
}

STDMETHODIMP
CMMPlayer::AddView(ITIMEMMView * view)
{
    TraceTag((tagMMPlayer,
              "CMMPlayer(%lx)::AddView(%lx)",
              this,
              view));

    bool ok = false;
    
    // Get the view class from the interface
    
    CMMView * mmview;

    mmview = GetViewFromInterface(view);

    if (mmview == NULL)
    {
        goto done;
    }

    // Start the view
    // This will fail if the view has been added anywhere else (even
    // on this object)
    if (!mmview->Start(*this))
    {
        goto done;
    }
    
    // Now add it last so we do not need to remove it if we fail
    // We need to addref for the list storage
    
    mmview->AddRef();
    m_viewList.push_back(mmview);

    ok = true;
  done:
    return ok?S_OK:Error();
}

STDMETHODIMP
CMMPlayer::RemoveView(ITIMEMMView * view)
{
    TraceTag((tagMMPlayer,
              "CMMPlayer(%lx)::RemoveView(%lx)",
              this,
              view));

    bool ok = false;
    
    // Get the view class from the interface
    
    CMMView * mmview;

    mmview = GetViewFromInterface(view);

    if (mmview == NULL)
    {
        goto done;
    }

    // Stop the view
    // Ignore any failures since we want to clean up as much as
    // possible
    mmview->Stop();
    
    // Remove it from the list

    {
        for (ViewList::iterator i = m_viewList.begin();
             i != m_viewList.end();
             i++)
        {
            if ((*i) == mmview)
            {
                m_viewList.erase(i);
                mmview->Release();
                
                // We know it is only in the list once since we check on
                // add
                // This was done by the start call in addview
                break;
            }
        }
    }

    ok = true;
  done:
    return ok?S_OK:Error();
}

bool
CMMPlayer::_Start(double lTime)
{
    bool ok = false;
    
    CRLockGrabber __gclg;
    
    if (!SetTimeSub(lTime, false))
    {
        goto done;
    }

    m_state = MM_PLAYING_STATE;
    m_curTick = lTime;
    m_firstTick = true;
    m_playerhook->SetPlayer(this);
    
    if (!CRResumeModel(m_view))
    {
        goto done;
    }
    
    {
        // run though and tick the views that we have in our list.
        ViewList::iterator i;
        
        for (i = m_viewList.begin(); i != m_viewList.end(); i++)
        {
            (*i)->Resume();
        }
    }
    
    // Run through the callbacks and make them check their clocks
    {
        // process any callbacks that have been registered
        BvrCBList::iterator j;
        for (j = m_bvrCBList.begin(); j != m_bvrCBList.end(); j++)
        {
            (*j)->OnBvrCB(lTime);
        }
    }

    ok = true;
  done:
    if (!ok)
    {
        _Stop(lTime);
    }

    return ok;
}


bool
CMMPlayer::UpdateBvr()
{
    bool ok = false;
    
#if _DEBUG
    TraceTag((tagError,
              "Player(%#x)",
              this));
    m_mmbvr->Print(2);
#endif

    CRBooleanPtr cond;
    CRNumberPtr zeroTime;
    CRNumberPtr time;
    
    if ((zeroTime = CRCreateNumber(0)) == NULL)
    {
        goto done;
    }
    
    if ((cond = CRLTE(CRLocalTime(), zeroTime)) == NULL)
    {
        goto done;
    }
    
    if ((time = (CRNumberPtr) CRCond(cond,
                                     (CRBvrPtr) zeroTime,
                                     (CRBvrPtr) CRLocalTime())) == NULL)
    {
        goto done;
    }
    
    CRNumberPtr bvrtime;

    if ((bvrtime = (CRNumberPtr) CRSubstituteTime((CRBvrPtr) time, m_timeSub)) == NULL)
    {
        goto done;
    }
    
    if (!m_mmbvr->ConstructBvr(bvrtime))
    {
        TraceTag((tagMMPlayer,
                  "CMMPlayer(%lx)::UpdateBvr() - Error constructing behaviors",
                  this));
        
        goto done;
    }
    
    CRBvrPtr hookBvr;
    
    if ((hookBvr = CRHook((CRBvrPtr) time, m_playerhook)) == NULL)
    {
        TraceTag((tagMMPlayer,
                  "CMMPlayer(%lx)::UpdateBvr() - Error creating bvr hook",
                  this));
        
        goto done;
    }
    
    if ((hookBvr = CRSubstituteTime(hookBvr, m_timeSub)) == NULL)
    {
        goto done;
    }
    
    if (!AddRunningBehavior(hookBvr))
    {
        goto done;
    }

    ok = true;

  done:
    if (!ok)
    {
        m_mmbvr->DestroyBvr();
    }
    
    return ok;
}

bool
CMMPlayer::_Stop(double lTime)
{
    bool ok = true;
    
    m_state = MM_STOPPED_STATE;
    m_playerhook->SetPlayer(NULL);
    
    if (m_view)
    {
        if (!CRPauseModel(m_view))
        {
            goto done;
        }
    }
    
    {
        // run though and tick the views that we have in our list.
        ViewList::iterator i;
        
        for (i = m_viewList.begin(); i != m_viewList.end(); i++)
        {
            (*i)->Pause();
        }
    }
    
    if (!SetTimeSub(lTime, true))
    {
        ok = false;
    }

  done:
    return ok;
}

bool
CMMPlayer::_Pause()
{
    bool ok = false;
    
    if (!CRPauseModel(m_view))
    {
        goto done;
    }
    
    {
        // run though and tick the views that we have in our list.
        ViewList::iterator i;
        
        for (i = m_viewList.begin(); i != m_viewList.end(); i++)
        {
            (*i)->Pause();
        }
    }
    
    if (!SetTimeSub(m_curTick, true))
    {
        goto done;
    }
    
    m_state = MM_PAUSED_STATE;
    
    ok = true;
  done:
    return ok;
}

bool
CMMPlayer::_Resume()
{
    bool ok = false;
    
    if (!CRResumeModel(m_view))
    {
        goto done;
    }
    
    {
        // run though and tick the views that we have in our list.
        ViewList::iterator i;
        
        for (i = m_viewList.begin(); i != m_viewList.end(); i++)
        {
            (*i)->Resume();
        }
    }
    
    if (!SetTimeSub(m_curTick, false))
    {
        goto done;
    }
    
    m_state = MM_PLAYING_STATE;
    
    ok = true;
  done:
    return ok;
}

bool
CMMPlayer::_Seek(double lTime)
{
    TraceTag((tagMMPlayer,
              "CMMPlayer(%lx)::_Seek(%g)",
              this,
              lTime));

    bool ok = false;

    if (!SetTimeSub(lTime,
                    (m_state != MM_PLAYING_STATE)))
    {
        goto done;
    }
    
    ok = true;
  done:
    return ok;
}

bool
CMMPlayer::SetTimeSub(double lTime, bool bPause)
{
    bool ok = false;
    
    CRLockGrabber __gclg;

    CRNumberPtr tc;
    
    if ((tc = CRCreateNumber(lTime)) == NULL)
        goto done;

    if (!bPause) {
        if (m_bForward) {
            if ((tc = CRAdd(tc, CRLocalTime())) == NULL)
                goto done;
        } else {
            if ((tc = CRSub(tc, CRLocalTime())) == NULL)
                goto done;
        }
    }
    
    if (!CRSwitchTo((CRBvrPtr) m_timeSub.p,
                    (CRBvrPtr) tc,
                    true,
                    CRSwitchCurrentTick,
                    0))
        goto done;

    ok = true;
  done:
    return ok;
}

long
CMMPlayer::AddRunningBehavior(CRBvrPtr bvr)
{
    long ret = 0;

    Assert(m_view);
    Assert(bvr);

    long cookie;

    if (!CRAddBvrToRun(m_view, bvr, true, &cookie))
    {
        goto done;
    }
    
    ret = cookie;

  done:
    return ret;
}

bool
CMMPlayer::RemoveRunningBehavior(long cookie)
{
    bool ok = false;

    Assert(m_view);

    if (!CRRemoveRunningBvr(m_view, cookie))
    {
        goto done;
    }

    ok = true;
  done:
    return ok;
}

STDMETHODIMP
CMMPlayer::Tick(double gTime)
{
    TraceTag((tagMMPlayer,
              "CMMPlayer(%lx)::Tick(%g)",
              this,
              gTime));

    bool ok = false;
    
    {
        // process any callbacks that have been registered
        BvrCBList::iterator j;
        for (j = m_bvrCBList.begin(); j != m_bvrCBList.end(); j++)
        {
            (*j)->OnBvrCB(gTime);
        }
    }

    // Tick the view
    // We can ignore render since we know we passed in NULL to our
    // view

    // We need to tick first so we fire all events before ticking the
    // real views
    if (!CRTick(m_view, gTime, NULL))
    {
        goto done;
    }
    
    {
        // run though and tick the views that we have in our list.
        ViewList::iterator i;
        
        for (i = m_viewList.begin(); i != m_viewList.end(); i++)
        {
            (*i)->Tick(gTime);
        }
    }
    
    m_firstTick = false;
    ok = true;
  done:
    return ok?S_OK:Error();
}

HRESULT
CMMPlayer::Error()
{
    LPCWSTR str = CRGetLastErrorString();
    HRESULT hr = CRGetLastError();
    
    if (str)
        return CComCoClass<CMMPlayer, &__uuidof(CMMPlayer)>::Error(str, IID_ITIMEMMPlayer, hr);
    else
        return hr;
}

bool
CMMPlayer::ProcessCB(CallBackList & l,
                     double lTime)
{
    TraceTag((tagMMPlayer,
              "CMMPlayer(%lx)::ProcessCB(%lx, %g)",
              this,
              &l,
              lTime));

    TraceTag((tagMMDetailNotify,
              "ProcessCB(%lx): lTime - %g, m_curTick - %g, firsttick - %d",
              this,
              lTime,
              m_curTick,
              m_firstTick));
    
    if (lTime != m_curTick || m_firstTick)
    {
        double sTime = m_mmbvr->GetAbsStartTime();

        m_mmbvr->ProcessCB(&l,
                           m_curTick - sTime,
                           lTime - sTime,
                           m_bForward,
                           m_firstTick,
                           false);

        m_curTick = lTime;
    }
    
    return true;
}

bool
CMMPlayer::ProcessEvent(CallBackList &l,
                        double lTime,
                        MM_EVENT_TYPE event)
{
    return m_mmbvr->ProcessEvent(&l, (lTime - m_mmbvr->GetAbsStartTime()), m_firstTick, event, 0);
}

void
CMMPlayer::HookCallback(double lTime)
{
    TraceTag((tagMMDetailNotify,
              "HookCallback(%lx): lTime - %, m_curTick - %g, firsttick - %d\n",
              this,
              lTime,
              m_curTick,
              m_firstTick));
    
    if (IsPlaying())
    {
        CallBackList l;
            
        ProcessCB(l,
                  lTime);

        ProcessCBList(l);
    }
}

// While this object is alive we need to keep the DLL from getting
// unloaded

// Start off with a zero refcount
CMMPlayer::PlayerHook::PlayerHook()
: m_cRef(0),
  m_player(NULL)
{
}

CMMPlayer::PlayerHook::~PlayerHook()
{
}

CRSTDAPICB_(CRBvrPtr)
CMMPlayer::PlayerHook::Notify(long id,
                              bool startingPerformance,
                              double startTime,
                              double gTime,
                              double lTime,
                              CRBvrPtr sampleVal,
                              CRBvrPtr curRunningBvr)
{
    if (m_player && !startingPerformance)
    {
#if _DEBUG
        if (m_player->IsPlaying())
        {
            TraceTag((tagMMDetailNotify,
                      "Notify(%lx): id - %lx, lTime - %g, gTime - %g",
                      m_player,
                      id,
                      lTime,
                      gTime));
        }
#endif
        m_player->HookCallback(lTime);
    }
    
    return NULL;
}

bool
CMMPlayer::AddBvrCB(CMMBaseBvr *pbvr)
{
    Assert(pbvr != NULL);

    // Now add it last so we do not need to remove it if we fail
    // We need to addref for the list storage
    pbvr->AddRef();
    m_bvrCBList.push_back(pbvr);
    return S_OK;
} // AddBvrCB

bool
CMMPlayer::RemoveBvrCB(CMMBaseBvr *pbvr)
{
    Assert(pbvr != NULL);
    
    BvrCBList::iterator i;
    for (i = m_bvrCBList.begin(); i != m_bvrCBList.end(); i++)
    {
        if ((*i) == pbvr)
        {
            m_bvrCBList.erase(i);
            pbvr->Release();
            break;
        }
    }
    return S_OK;
} // RemoveBvrCB
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\time\mmapi\mmtimeline.h ===
/*******************************************************************************

Copyright (c) 1995_96 Microsoft Corporation

Abstract:

    {Insert General Comment Here}

*******************************************************************************/


#ifndef _MMTIMELINE_H
#define _MMTIMELINE_H

#include "mmplayer.h"

class
__declspec(uuid("0dfe0bae-537c-11d2-b955-3078302c2030")) 
ATL_NO_VTABLE
CMMTimeline
    : public CComCoClass<CMMTimeline, &__uuidof(CMMTimeline)>,
      public ITIMEMMTimeline,
      public ISupportErrorInfoImpl<&IID_ITIMEMMTimeline>,
      public CMMBaseBvr
{
  public:
    CMMTimeline();
    ~CMMTimeline();

    HRESULT Init(LPOLESTR id);
    
    void FinalRelease();

#if _DEBUG
    const _TCHAR * GetName() { return __T("CMMTimeline"); }
#endif

    BEGIN_COM_MAP(CMMTimeline)
        COM_INTERFACE_ENTRY(ITIMEMMBehavior)
        COM_INTERFACE_ENTRY(ITIMEMMTimeline)
        COM_INTERFACE_ENTRY(ISupportErrorInfo)
    END_COM_MAP();

    // This must be in the derived class and not the base class since
    // the typecast down to the base class messes things up
    static inline HRESULT WINAPI
        InternalQueryInterface(CMMTimeline* pThis,
                               const _ATL_INTMAP_ENTRY* pEntries,
                               REFIID iid,
                               void** ppvObject)
    { return BaseInternalQueryInterface(pThis,
                                        (void *) pThis,
                                        pEntries,
                                        iid,
                                        ppvObject); }

    

    //
    // ITIMEMMTimeline
    //
    
    STDMETHOD(AddBehavior)(ITIMEMMBehavior *bvr,
                           MM_START_TYPE st,
                           ITIMEMMBehavior * basebvr);
    STDMETHOD(RemoveBehavior)(ITIMEMMBehavior *bvr);

    STDMETHOD(get_EndSync)(DWORD * flags);
    STDMETHOD(put_EndSync)(DWORD flags);

    //
    // ITIMEMMBehavior
    //
    
    STDMETHOD(get_ID)(LPOLESTR * s)
        { return GetID(s); }
    
    STDMETHOD(put_ID)(LPOLESTR s)
        { return SetID(s); }
        
    STDMETHOD(get_StartOffset)(float * f)
        { return GetStartOffset(f); }
    
    STDMETHOD(put_StartOffset)(float f)
        { return SetStartOffset(f); }
        
    STDMETHOD(get_Duration)(float * pd)
        { return GetDuration(pd); }
    STDMETHOD(put_Duration)(float d)
        { return SetDuration(d); }
        
    STDMETHOD(get_Repeat)(LONG * pr)
        { return GetRepeat(pr); }
    STDMETHOD(put_Repeat)(LONG r)
        { return SetRepeat(r); }
       
    STDMETHOD(get_AutoReverse)(VARIANT_BOOL * pr)
        { return GetAutoReverse(pr); }
    STDMETHOD(put_AutoReverse)(VARIANT_BOOL r)
        { return SetAutoReverse(r); }
        
    STDMETHOD(get_RepeatDur)(float * f)
        { return GetRepeatDur(f); }
    STDMETHOD(put_RepeatDur)(float f)
        { return SetRepeatDur(f); }
        
    STDMETHOD(get_EndOffset)(float * f)
        { return GetEndOffset(f); }
    STDMETHOD(put_EndOffset)(float f)
        { return SetEndOffset(f); }
        
    STDMETHOD(get_EaseIn)(float * pd)
        { return GetEaseIn(pd); }
    STDMETHOD(put_EaseIn)(float d)
        { return SetEaseIn(d); }

    STDMETHOD(get_EaseInStart)(float * pd)
        { return GetEaseInStart(pd); }
    STDMETHOD(put_EaseInStart)(float d)
        { return SetEaseInStart(d); }

    STDMETHOD(get_EaseOut)(float * pd)
        { return GetEaseOut(pd); }
    STDMETHOD(put_EaseOut)(float d)
        { return SetEaseOut(d); }

    STDMETHOD(get_EaseOutEnd)(float * pd)
        { return GetEaseOutEnd(pd); }
    STDMETHOD(put_EaseOutEnd)(float d)
        { return SetEaseOutEnd(d); }

    STDMETHOD(get_SyncFlags)(DWORD * pd)
        { return GetSyncFlags(pd); }
    STDMETHOD(put_SyncFlags)(DWORD d)
        { return SetSyncFlags(d); }

    STDMETHOD(get_EventCB)(ITIMEMMEventCB ** ev)
        { return GetEventCB(ev); }
    STDMETHOD(put_EventCB)(ITIMEMMEventCB * ev)
        { return SetEventCB(ev); }
        
    STDMETHOD(get_TotalTime)(float * pd)
        { return GetTotalTime(pd); }
        
    STDMETHOD(get_DABehavior)(IDABehavior ** bvr)
        { return CMMBaseBvr::GetDABehavior(IID_IDABehavior, (void **)bvr); }

    STDMETHOD(GetDABehavior)(REFIID riid, void ** bvr)
        { return CMMBaseBvr::GetDABehavior(riid, bvr); }

    STDMETHOD(GetResultantBehavior)(REFIID riid, void ** bvr)
        { return CMMBaseBvr::GetResultantBehavior(riid, bvr); }

    STDMETHOD(Begin)(VARIANT_BOOL bAfterOffset)
        { return CMMBaseBvr::Begin(bAfterOffset?true:false); }
    
    STDMETHOD(End)()
        { return CMMBaseBvr::End(); }
    
    STDMETHOD(Pause)()
        { return CMMBaseBvr::Pause(); }
    
    STDMETHOD(Run)()
        { return CMMBaseBvr::Run(); }
    
    STDMETHOD(Seek)(double lTime)
        { return CMMBaseBvr::Seek(lTime); }

    STDMETHOD(Reset)(DWORD fCause)
        { return CMMBaseBvr::Reset(fCause); }

    STDMETHOD(ResetOnEventChanged)(VARIANT_BOOL bBeginEvent)
        { return CMMBaseBvr::ResetOnEventChanged(bBeginEvent?true:false); }

    STDMETHOD(get_LocalTime)(double * d)
        { return GetLocalTime(d); }

    STDMETHOD(get_LocalTimeEx)(double * d)
        { return GetLocalTimeEx(d); }

    STDMETHOD(get_SegmentTime)(double * d)
        { return GetSegmentTime(d); }

    STDMETHOD(get_PlayState)(MM_STATE * state)
        { return GetPlayState(state); }

    STDMETHOD(put_StartType)(MM_START_TYPE st)
        { return PutStartType(st); }

    virtual bool ConstructBvr(CRNumberPtr timeline);
    virtual void DestroyBvr();

    DWORD GetEndSync() { return m_fEndSync; }
    bool IsLastSync() { return (m_fEndSync & MM_ENDSYNC_LAST) != 0; }
    bool IsFirstSync() { return (m_fEndSync & MM_ENDSYNC_FIRST) != 0; }
  protected:
    HRESULT Error();

    virtual void SetPlayer(CMMPlayer * player);
    virtual void ClearPlayer();

    bool AddBehavior(CMMBaseBvr *bvr,
                     MM_START_TYPE st,
                     CMMBaseBvr * basebvr);
    bool RemoveBehavior(CMMBaseBvr *bvr);
    virtual bool ResetBvr(CallBackList * l,
                          bool bProcessSiblings = true);
    bool CheckEndSync(CallBackList *l);
    
    bool IsChild(CMMBaseBvr *bvr);
    bool IsPending(CMMBaseBvr *bvr);
    
    bool AddToChildren(CMMBaseBvr * bvr);
    void RemoveFromChildren(CMMBaseBvr * bvr);
    
    bool AddToPending(CMMBaseBvr * bvr);
    bool UpdatePending(CMMBaseBvr * bvr, CallBackList * l, double t);
    void RemoveFromPending(CMMBaseBvr * bvr);
    
    bool _ProcessCB(CallBackList * l,
                    double lastTick,
                    double curTime,
                    bool bForward,
                    bool bFirstTick,
                    bool bNeedPlay,
                    bool bNeedsReverse);
    
    bool _ProcessEvent(CallBackList * l,
                       double time,
                       bool bFirstTick,
                       MM_EVENT_TYPE et,
                       bool bNeedsReverse,
                       DWORD flags);
    
    virtual bool EventNotify(CallBackList *l,
                             double lTime,
                             MM_EVENT_TYPE et,
                             DWORD flags);

    virtual bool ParentEventNotify(CMMBaseBvr * bvr,
                                   double lTime,
                                   MM_EVENT_TYPE et,
                                   DWORD flags);
    
    bool ResetChildren(CallBackList * l);

    virtual bool ReconstructBvr(CMMBaseBvr*);

#if _DEBUG
    virtual void Print(int spaces);
#endif
  protected:
    MMBaseBvrList m_children;
    MMBaseBvrList m_pending;
    DWORD         m_fEndSync;
    double        m_endSyncTime;
};

#endif /* _MMTIMELINE_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\time\mmapi\mmtimeline.cpp ===
/*******************************************************************************

Copyright (c) 1995-96 Microsoft Corporation

Abstract:

    {Insert General Comment Here}

*******************************************************************************/


#include "headers.h"
#include "mmbasebvr.h"
#include "mmtimeline.h"

DeclareTag(tagMMTimeline, "API", "CMMTimeline methods");

CMMTimeline::CMMTimeline()
: m_fEndSync(0),
  m_endSyncTime(MM_INFINITE)
{
    TraceTag((tagMMTimeline,
              "CMMTimeline(%lx)::CMMTimeline()",
              this));
}

CMMTimeline::~CMMTimeline()
{
    TraceTag((tagMMTimeline,
              "CMMTimeline(%lx)::~CMMTimeline()",
              this));
}

HRESULT
CMMTimeline::Init(LPOLESTR id)
{
    TraceTag((tagMMTimeline,
              "CMMTimeline(%lx)::Init(%ls)",
              this,
              id));
    
    HRESULT hr;

    hr = BaseInit(id, (CRBvrPtr) CRLocalTime());
    
    if (FAILED(hr))
    {
        goto done;
    }
    
    hr = S_OK;
  done:
    return hr;
}

void CMMTimeline::FinalRelease()
{
    MMBaseBvrList::iterator i;

    // release bvrs in children list
    for (i = m_children.begin(); i != m_children.end(); i++)
    {
        (*i)->Release();
    }
    m_children.clear();

    // release bvrs in pending list
    for (i = m_pending.begin(); i != m_pending.end(); i++)
    {
        (*i)->Release();
    }
    m_pending.clear();
} // FinalRelease()



STDMETHODIMP
CMMTimeline::AddBehavior(ITIMEMMBehavior *bvr,
                         MM_START_TYPE st,
                         ITIMEMMBehavior * basebvr)
{
    TraceTag((tagMMTimeline,
              "CMMTimeline(%lx)::AddBehavior(%#lx, %d, %#lx)",
              this,
              bvr,
              st,
              basebvr));
    
    CHECK_RETURN_NULL(bvr);

    bool ok = false;
    
    CMMBaseBvr * mmbvr;
    CMMBaseBvr * mmbasebvr;

    mmbvr = GetBvr(bvr);

    if (mmbvr == NULL)
    {
        goto done;
    }
    
    if (mmbvr->GetParent() != NULL)
    {
        CRSetLastError(E_INVALIDARG, NULL);
        goto done;
    }

    if (basebvr)
    {
        mmbasebvr = GetBvr(basebvr);
        
        if (mmbasebvr == NULL)
        {
            goto done;
        }
    }
    else
    {
        mmbasebvr = NULL;
    }
    
    if (!AddBehavior(mmbvr, st, mmbasebvr))
    {
        goto done;
    }
    
    ok = true;
  done:
    return ok?S_OK:Error();
}

STDMETHODIMP
CMMTimeline::RemoveBehavior(ITIMEMMBehavior *bvr)
{
    TraceTag((tagMMTimeline,
              "CMMTimeline(%lx)::RemoveBehavior(%#lx)",
              this,
              bvr));
    
    CHECK_RETURN_NULL(bvr);

    bool ok = false;
    
    CMMBaseBvr * mmbvr;

    mmbvr = GetBvr(bvr);

    if (mmbvr == NULL)
    {
        goto done;
    }
    
    if (mmbvr->GetParent() != this)
    {
        CRSetLastError(E_INVALIDARG, NULL);
        goto done;
    }

    if (!RemoveBehavior(mmbvr))
    {
        goto done;
    }
    
    ok = true;
  done:
    return ok?S_OK:Error();
}

bool
CMMTimeline::AddBehavior(CMMBaseBvr *bvr,
                         MM_START_TYPE st,
                         CMMBaseBvr * basebvr)
{
    TraceTag((tagMMTimeline,
              "CMMTimeline(%lx)::AddBehavior(%#lx, %d, %#lx)",
              this,
              bvr,
              st,
              basebvr));
    
    Assert(bvr);
    Assert(bvr->GetParent() == NULL);
    
    CallBackList l;
    double t, bvrOffset;
    get_SegmentTime( &t);
    
    bool ok = false;
    
    if (!bvr->SetParent(this, st, basebvr))
    {
        goto done;
    }

    Assert(bvr->GetPlayer() == NULL);
    
    if (GetPlayer() != NULL)
    {
        bvr->SetPlayer(GetPlayer());
    }
    
    // Figure out if our sibling dependent if valid or not
    if (basebvr && !IsChild(basebvr))
    {
        if (basebvr->GetParent() != this &&
            basebvr->GetParent() != NULL)
        {
            CRSetLastError(E_INVALIDARG, NULL);
            goto done;
        }

        // It has not been added to us yet so add this bvr to the
        // pending list
        if (!AddToPending(bvr))
        {
            goto done;
        }
    }
    else
    {
        if (!AddToChildren(bvr))
        {
            goto done;
        }

        if (IsPlaying() && bvr -> GetStartType() == MM_START_ABSOLUTE)
        {
            bvrOffset = bvr -> GetStartOffset();

            if (!bvr->ProcessEvent(&l, t - bvrOffset, true, MM_PLAY_EVENT, 0))
            {
                goto done;
            }

        }

        if (!UpdatePending(bvr, IsPlaying()?(&l):NULL, t))
        {
            goto done;
        }
    }
    
    if (IsPlaying())
    {
        if (!ProcessCBList(l))
        {
            goto done;
        }
    }

    ok = true;
  done:

    if (!ok)
    {
        RemoveBehavior(bvr);
    }
    
    return ok;
}

bool
CMMTimeline::RemoveBehavior(CMMBaseBvr *bvr)
{
    TraceTag((tagMMTimeline,
              "CMMTimeline(%lx)::RemoveBehavior(%#lx)",
              this,
              bvr));
    
    Assert(bvr);
    
    // This needs to be callable even from a partially added behavior
    
    bool ok = false;
    
    bvr->ClearParent();
    bvr->ClearPlayer();
    
    RemoveFromChildren(bvr);
    RemoveFromPending(bvr);
    
    ok = true;

    return ok;
}

bool
CMMTimeline::AddToChildren(CMMBaseBvr * bvr)
{
    TraceTag((tagMMTimeline,
              "CMMTimeline(%lx)::AddToChildren(%#lx)",
              this,
              bvr));

    bool ok = false;
    
    if (!bvr->AttachToSibling())
    {
        goto done;
    }
    
    bvr->AddRef();
    m_children.push_back(bvr);
    
    if (m_resultantbvr)
    {
        if (!bvr->ConstructBvr((CRNumberPtr) m_resultantbvr.p))
        {
            goto done;
        }
    }

    ok = true;
  done:
    return ok;
}

void
CMMTimeline::RemoveFromChildren(CMMBaseBvr * bvr)
{
    TraceTag((tagMMTimeline,
              "CMMTimeline(%lx)::RemoveFromChildren(%#lx)",
              this,
              bvr));

    // TODO: Need to cycle through the children and remove all
    // dependents
    
    for (MMBaseBvrList::iterator i = m_children.begin(); 
         i != m_children.end(); 
         i++)
    {
        if((*i) == bvr)
        {
            bvr->Release();
        }
    }
    
    m_children.remove(bvr);
}

bool
CMMTimeline::AddToPending(CMMBaseBvr * bvr)
{
    TraceTag((tagMMTimeline,
              "CMMTimeline(%lx)::AddToPending(%#lx)",
              this,
              bvr));

    bool ok = false;
    
    m_pending.push_back(bvr);

    bvr->AddRef();

    ok = true;

    return ok;
}

bool
CMMTimeline::UpdatePending(CMMBaseBvr * bvr, CallBackList * l, double t)
{
    TraceTag((tagMMTimeline,
              "CMMTimeline(%lx)::UpdatePending(%#lx)",
              this,
              bvr));

    bool ok = false;
    
    MMBaseBvrList newlist;
    
    MMBaseBvrList::iterator i = m_pending.begin();

    while (i != m_pending.end())
    {
        // Need to do this so we can erase j if we need to
        MMBaseBvrList::iterator j = i;
        i++;
        
        if((*j)->GetStartSibling() == bvr)
        {
            newlist.push_back(*j);
            // we don't want to call RemoveFromPending() because we
            // don't want the bvr to be deleted at this point. Instead
            // all bvrs in newlist are released at the end, at "done".
            m_pending.erase(j);
        }
    }
    
    for (i = newlist.begin();
         i != newlist.end();
         i++)
    {
        if (!AddToChildren(*i))
        {
            goto done;
        }

        if (l)
        {
            if (!bvr->ProcessEvent(l, t, true, MM_PLAY_EVENT, 0))
            {
                goto done;
            }
        }

        if (!UpdatePending(*i, l ,t))
        {
            goto done;
        }
    }

    ok = true;
  done:
    for (i = newlist.begin();
         i != newlist.end();
         i++)
    {
        (*i)->Release();
    }
    return ok;
}

void
CMMTimeline::RemoveFromPending(CMMBaseBvr * bvr)
{
    TraceTag((tagMMTimeline,
              "CMMTimeline(%lx)::RemoveFromPending(%#lx)",
              this,
              bvr));

    for (MMBaseBvrList::iterator i = m_pending.begin(); 
         i != m_pending.end(); 
         i++)
    {
        if((*i) == bvr)
        {
            bvr->Release();
        }
    }
    
    m_pending.remove(bvr);
}

bool 
CMMTimeline::IsChild(CMMBaseBvr * bvr)
{
    TraceTag((tagMMTimeline,
              "CMMTimeline(%lx)::IsChild(%#lx)",
              this,
              bvr));

    for (MMBaseBvrList::iterator i = m_children.begin(); 
         i != m_children.end(); 
         i++)
    {
        if((*i) == bvr)
        {
            return true;
        }
    }
    
    return false;
}

bool 
CMMTimeline::IsPending(CMMBaseBvr * bvr)
{
    TraceTag((tagMMTimeline,
              "CMMTimeline(%lx)::IsPending(%#lx)",
              this,
              bvr));

    for (MMBaseBvrList::iterator i = m_pending.begin(); 
         i != m_pending.end(); 
         i++)
    {
        if((*i) == bvr)
        {
            return true;
        }
    }
    
    return false;
}

void
CMMTimeline::SetPlayer(CMMPlayer * player)
{
    TraceTag((tagMMTimeline,
              "CMMTimeline(%lx)::SetPlayer(%#lx)",
              this,
              player));

    CMMBaseBvr::SetPlayer(player);

    for (MMBaseBvrList::iterator i = m_children.begin(); 
         i != m_children.end(); 
         i++)
    {
        (*i)->SetPlayer(player);
    }
}

void
CMMTimeline::ClearPlayer()
{
    TraceTag((tagMMTimeline,
              "CMMTimeline(%lx)::ClearPlayer()",
              this));

    CMMBaseBvr::ClearPlayer();
    
    for (MMBaseBvrList::iterator i = m_children.begin(); 
         i != m_children.end(); 
         i++)
    {
        (*i)->ClearPlayer();
    }
}

bool
CMMTimeline::ReconstructBvr(CMMBaseBvr* pBvr)
{
    bool ok = false;
    Assert(pBvr != NULL);

    pBvr->DestroyBvr();

    if (m_resultantbvr)
    {
        if (!pBvr->ConstructBvr((CRNumberPtr) m_resultantbvr.p))
        {
            goto done;
        }
    }

    ok = true;
done:
    return ok;
}

bool
CMMTimeline::ConstructBvr(CRNumberPtr timeline)
{
    TraceTag((tagMMTimeline,
              "CMMTimeline(%lx)::ConstructBvr()",
              this));

    bool ok = false;
    
    Assert(!m_resultantbvr);
    
    if (!CMMBaseBvr::ConstructBvr(timeline))
    {
        goto done;
    }
    
    Assert(m_resultantbvr);
    
    {
        for (MMBaseBvrList::iterator i = m_children.begin(); 
             i != m_children.end(); 
             i++)
        {
            if (!(*i)->ConstructBvr((CRNumberPtr) m_resultantbvr.p))
            {
                goto done;
            }
        }
    }

    ok = true;
  done:
    return ok;
}

void
CMMTimeline::DestroyBvr()
{
    TraceTag((tagMMTimeline,
              "CMMTimeline(%lx)::DestroyBvr()",
              this));

    CMMBaseBvr::DestroyBvr();
    
    for (MMBaseBvrList::iterator i = m_children.begin(); 
         i != m_children.end(); 
         i++)
    {
        (*i)->DestroyBvr();
    }
}

bool
CMMTimeline::ResetBvr(CallBackList * l,
                      bool bProcessSiblings)
{
    TraceTag((tagMMTimeline,
              "CMMTimeline(%lx)::ResetBvr(%lx, %d)",
              this,
              l,
              bProcessSiblings));

    bool ok = false;

    // Call the base class first
    
    if (!CMMBaseBvr::ResetBvr(l, bProcessSiblings))
    {
        goto done;
    }
    
    // Now go through our children

    if (!ResetChildren(l))
    {
        goto done;
    }
    
    m_endSyncTime = MM_INFINITE;
    
    ok = true;
  done:
    return ok;
}
    
bool
CMMTimeline::CheckEndSync(CallBackList *l)
{
    TraceTag((tagMMTimeline,
              "CMMTimeline(%lx)::CMMTimeline(%lx)",
              this,
              &l));
 
    if (IsPlaying() && m_endSyncTime != MM_INFINITE)
    {
        if (!EndTimeVisit(m_endSyncTime, l))
        {
            return false;
        }
    }

    return true;
}

bool
CMMTimeline::_ProcessCB(CallBackList * l,
                        double lastTick,
                        double curTime,
                        bool bForward,
                        bool bFirstTick,
                        bool bNeedPlay,
                        bool bNeedsReverse)
{
    TraceTag((tagMMTimeline,
              "CMMTimeline(%lx)::_ProcessCB(%g, %g, %d, %d, %d, %d)",
              this,
              lastTick,
              curTime,
              bForward,
              bFirstTick,
              bNeedPlay,
              bNeedsReverse));
    
    // If we need to reverse then invert which direct to process our
    // children and invert times for the current frame not our total
    // duration
    
    if (bNeedsReverse)
    {
        // Our caller should ensure that they do not call me to
        // reverse myself if I am infinite
        Assert(m_segDuration != MM_INFINITE);
        
        lastTick = m_segDuration - lastTick;
        curTime = m_segDuration - curTime;
        
        bForward = !bForward;
    }
    
    for (MMBaseBvrList::iterator i = m_children.begin();
         i != m_children.end();
         i++)
    {
        double sTime = (*i)->GetAbsStartTime();

        if (sTime != MM_INFINITE)
        {
            (*i)->ProcessCB(l,
                            EaseTime(lastTick - sTime),
                            EaseTime(curTime - sTime),
                            bForward,
                            bFirstTick,
                            bNeedPlay);
        }

    }
    
    CheckEndSync(l);
    
    return true;
}

bool
CMMTimeline::_ProcessEvent(CallBackList * l,
                           double time,
                           bool bFirstTick,
                           MM_EVENT_TYPE et,
                           bool bNeedsReverse,
                           DWORD flags)
{
    TraceTag((tagMMTimeline,
              "CMMTimeline(%lx)::_ProcessEvent(%g, %d, %s, %d, %lx)",
              this,
              time,
              bFirstTick,
              EventString(et),
              bNeedsReverse,
              flags));
    
    // If we need to reverse then for the current frame not our total
    // duration
    
    if (bNeedsReverse)
    {
        // Our caller should ensure that they do not call me to
        // reverse myself if I am infinite
        Assert(m_segDuration != MM_INFINITE);
        
        time = m_segDuration - time;
    }
    
    for (MMBaseBvrList::iterator i = m_children.begin();
         i != m_children.end();
         i++)
    {
        double sTime = (*i)->GetAbsStartTime();

        if (sTime != MM_INFINITE)
        {
            (*i)->ProcessEvent(l,
                               EaseTime(time - sTime),
                               bFirstTick,
                               et,
                               flags);
        }
    }
        
    CheckEndSync(l);
    
    return true;
}

bool
CMMTimeline::ResetChildren(CallBackList * l)
{
    TraceTag((tagMMTimeline,
              "CMMTimeline(%lx)::ResetChildren(%lx)",
              this,
              l));

    bool ok = true;

    // Need to reset all children
    // Even if we detect a failure process all children and then just
    // return false

    // TODO: Should only really reset non-dependent children since the
    // dependents need to be updated by their sibling
    
    for (MMBaseBvrList::iterator i = m_children.begin(); 
         i != m_children.end(); 
         i++)
    {
        if (!(*i)->ResetBvr(l))
        {
            ok = false;
        }
    }


    return ok;
}

bool
CMMTimeline::ParentEventNotify(CMMBaseBvr * bvr,
                               double lTime,
                               MM_EVENT_TYPE et,
                               DWORD flags)
{
    TraceTag((tagMMTimeline,
              "CMMTimeline(%lx)::ParentEventNotify(%#lx, %g, %s, %lx)",
              this,
              bvr,
              lTime,
              EventString(et),
              flags));

    bool ok = true;

    Assert(IsChild(bvr));

    switch (et)
    {
      case MM_STOP_EVENT:
        double parentTime;
        parentTime = lTime + bvr->GetAbsStartTime();
        
        if (IsPlaying() && (m_endSyncTime == MM_INFINITE))
        {
            bool bIsEnded;

            if ((m_fEndSync & MM_ENDSYNC_FIRST))
            {
                bIsEnded = true;
            }
            else if (m_fEndSync & MM_ENDSYNC_LAST)
            {
                bIsEnded = true;
                
                for (MMBaseBvrList::iterator i = m_children.begin(); 
                     i != m_children.end(); 
                     i++)
                {
                    // Check each child to see if they are playable.
                    // If none are then this was the last one to stop
                    // and we should setup out endsync time
                    
                    if ((*i)->IsPlayable(parentTime))
                    {
                        bIsEnded = false;
                        break;
                    }
                }
            }
            else
            {
                bIsEnded = false;
            }
            
            if (bIsEnded)
            {
                m_endSyncTime = parentTime;
            }
        }
    }
    
    ok = true;

    return ok;
}
    
HRESULT
CMMTimeline::get_EndSync(DWORD * f)
{
    TraceTag((tagMMTimeline,
              "CMMTimeline(%lx)::get_EndSync()",
              this));

    CHECK_RETURN_NULL(f);

    *f = m_fEndSync;
    return S_OK;
}

HRESULT
CMMTimeline::put_EndSync(DWORD f)
{
    TraceTag((tagMMTimeline,
              "CMMTimeline(%lx)::put_EndSync(%d)",
              this,
              f));

    m_fEndSync = f;

    return S_OK;
}
        
#if _DEBUG
void
CMMTimeline::Print(int spaces)
{
    _TCHAR buf[1024];

    CMMBaseBvr::Print(spaces);
    
    _stprintf(buf, __T("%*s{\r\n"),
            spaces,
            "");

    OutputDebugString(buf);
    
    for (MMBaseBvrList::iterator i = m_children.begin(); 
         i != m_children.end(); 
         i++)
    {
        (*i)->Print(spaces + 2);
    }
    
    _stprintf(buf, __T("%*s}\r\n"),
            spaces,
            "");

    OutputDebugString(buf);
}
#endif

HRESULT
CMMTimeline::Error()
{
    LPCWSTR str = CRGetLastErrorString();
    HRESULT hr = CRGetLastError();
    
    TraceTag((tagError,
              "CMMTimeline(%lx)::Error(%hr,%ls)",
              this,
              hr,
              str?str:L"NULL"));

    if (str)
        return CComCoClass<CMMTimeline, &__uuidof(CMMTimeline)>::Error(str, IID_ITIMEMMTimeline, hr);
    else
        return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\time\mmapi\mmview.cpp ===
/*******************************************************************************
 *
 * Copyright (c) 1998 Microsoft Corporation
 *
 * File: mmview.cpp
 *
 * Abstract:
 *
 *
 *
 *******************************************************************************/


#include "headers.h"
#include "mmview.h"
#include "mmplayer.h"

DeclareTag(tagMMView, "API", "CMMView methods");

CMMView::CMMView()
: m_player(NULL),
  m_view(NULL),
  m_hdc(NULL)
{
    TraceTag((tagMMView,
              "CMMView(%lx)::CMMView()",
              this));
}

CMMView::~CMMView()
{
    TraceTag((tagMMView,
              "CMMView(%lx)::~CMMView()",
              this));

    if (m_view)
    {
        CRDestroyView(m_view);
        m_view = NULL;
    }
}

HRESULT
CMMView::Init(LPOLESTR id,
              IDAImage * img,
              IDASound * snd,
              ITIMEMMViewSite * site)
{
    TraceTag((tagMMView,
              "CMMView(%lx)::Init(%ls)",
              this,
              id));
    
    HRESULT hr;

    if (img)
    {
        m_img = (CRImagePtr) COMToCRBvr(img);

        if (!m_img)
        {
            hr = CRGetLastError();
            goto done;
        }
    }

    if (snd)
    {
        m_snd = (CRSoundPtr) COMToCRBvr(snd);

        if (!m_snd)
        {
            hr = CRGetLastError();
            goto done;
        }
    }

    m_view = CRCreateView();

    if (m_view == NULL)
    {
        hr = CRGetLastError();
        goto done;
    }
    
    m_site = site;
    
    hr = S_OK;

  done:

    if (FAILED(hr))
    {
        CRDestroyView(m_view);
        m_view = NULL;
        m_img.Release();
        m_snd.Release();
        m_site.Release();
    }
    
    return hr;
}

STDMETHODIMP
CMMView::Tick()
{
    TraceTag((tagMMView,
              "CMMView(%lx)::Tick()",
              this));

    bool ok = false;
    
    if (!IsStarted())
    {
        CRSetLastError(E_FAIL, NULL);
        goto done;
    }
    
    double time;

    time = CRGetSimulationTime(m_view);
    
    if (!Tick(time))
    {
        goto done;
    }

    ok = true;
  done:
    return ok?S_OK:Error();
}

STDMETHODIMP
CMMView::Draw(HDC hdc, LPRECT prc)
{
    TraceTag((tagMMView,
              "CMMView(%lx)::Draw(%lx, [%lx, %lx, %lx, %lx])",
              this,
              hdc,
              prc->left,
              prc->right,
              prc->top,
              prc->bottom));

    bool ok = false;
    
    if (!IsStarted())
    {
        CRSetLastError(E_FAIL, NULL);
        goto done;
    }
    
    if (hdc)
    {
        RECT rcDeviceBounds = *prc;
//        LPtoDP(hdc, (POINT *) &rcDeviceBounds, 2);

        if (!CRSetViewport(m_view,
                           rcDeviceBounds.left,
                           rcDeviceBounds.top,
                           rcDeviceBounds.right - rcDeviceBounds.left,
                           rcDeviceBounds.bottom - rcDeviceBounds.top))
        {
            goto done;
        }
        
        RECT rcClip;  // in dc coords
        GetClipBox(hdc, &rcClip);
//        LPtoDP(hdc, (POINT *) &rcClip, 2);

        if (!CRSetClipRect(m_view,
                           rcClip.left,
                           rcClip.top,
                           rcClip.right - rcClip.left,
                           rcClip.bottom - rcClip.top))
        {
            goto done;
        }
 
    }

    if (m_hdc != hdc)
    {
        if (!CRSetDC(m_view, hdc))
        {
            goto done;
        }

        // request all of the content to redraw.
        if (!CRRepaint(m_view,
                       prc->left,
                       prc->top,
                       prc->right,
                       prc->bottom))
        {
            goto done;
        }
        
        // cache the DC
        m_hdc = hdc;
    }

    if (!CRRender(m_view))
    {
        goto done;
    }

    ok = true;
  done:
    return ok?S_OK:Error();
}

STDMETHODIMP
CMMView::OnMouseMove(double when,
                     LONG xPos, LONG yPos,
                     BYTE modifiers)
{
    TraceTag((tagMMView,
              "CMMView(%lx)::OnMouseMove()",
              this));

    CROnMouseMove(m_view, when, xPos, yPos, modifiers);

    return S_OK;
}

    
STDMETHODIMP
CMMView::OnMouseButton(double when,
                       LONG xPos, LONG yPos,
                       BYTE button,
                       VARIANT_BOOL bPressed,
                       BYTE modifiers)
{
    TraceTag((tagMMView,
              "CMMView(%lx)::OnMouseButton()",
              this));

    CROnMouseButton(m_view,
                    when,
                    xPos,
                    yPos,
                    button,
                    bPressed?true:false,
                    modifiers);

    return S_OK;
}
    
STDMETHODIMP
CMMView::OnKey(double when,
               LONG key,
               VARIANT_BOOL bPressed,
               BYTE modifiers)
{
    TraceTag((tagMMView,
              "CMMView(%lx)::OnKey()",
              this));

    CROnKey(m_view,
            when,
            key,
            bPressed?true:false,
            modifiers);

    return S_OK;
}
    
STDMETHODIMP
CMMView::OnFocus(VARIANT_BOOL bHasFocus)
{
    TraceTag((tagMMView,
              "CMMView(%lx)::OnFocus()",
              this));

    CROnFocus(m_view, bHasFocus?true:false);

    return S_OK;
}

bool
CMMView::Start(CMMPlayer & player)
{
    TraceTag((tagMMView,
              "CMMView(%lx)::Start(%lx)",
              this,
              &player));

    bool ok = false;

    if (m_player != NULL)
    {
        CRSetLastError(E_INVALIDARG, NULL);
        goto done;
    }
    
    if (!CRSetServiceProvider(m_view, player.GetServiceProvider()))
    {
        goto done;
    }
    
    if (!CRSetDC(m_view, NULL))
    {
        goto done;
    }
    
    if (!CRStartModel(m_view, m_img, m_snd, 0.0, CRAsyncFlag, NULL))
    {
        goto done;
    }
    
    // The last thing should be to set the player variable indicating
    // we are started
    
    m_player = &player;
    
    ok = true;
  done:
    return ok;
}

void
CMMView::Stop()
{
    TraceTag((tagMMView,
              "CMMView(%lx)::Stop()",
              this));

    CRSetServiceProvider(m_view, NULL);
    CRStopModel(m_view);
    m_player = NULL;
    
    return;
}

bool
CMMView::Pause()
{
    TraceTag((tagMMView,
              "CMMView(%lx)::Pause()",
              this));

    bool ok = false;
    
    if (!IsStarted())
    {
        CRSetLastError(E_FAIL, NULL);
        goto done;
    }
    
    if (!CRPauseModel(m_view))
    {
        goto done;
    }

    ok = true;
    
  done:
    return ok;
}

bool
CMMView::Resume()
{
    TraceTag((tagMMView,
              "CMMView(%lx)::Resume()",
              this));

    bool ok = false;
    
    if (!IsStarted())
    {
        CRSetLastError(E_FAIL, NULL);
        goto done;
    }
    
    if (!CRResumeModel(m_view))
    {
        goto done;
    }

    ok = true;
    
  done:
    return ok;
}

bool
CMMView::Tick(double gTime)
{
    TraceTag((tagMMView,
              "CMMView(%lx)::Tick(%g)",
              this,
              gTime));

    bool ok = false;
    bool bNeedRender = false;
    
    if (!IsStarted())
    {
        CRSetLastError(E_FAIL, NULL);
        goto done;
    }
    
    if (!CRTick(m_view, gTime, &bNeedRender))
    {
        goto done;
    }

    if (bNeedRender && m_site)
    {
#if 1
        // For now always invalidate everything - there seems to be a
        // bug with this calculation
        IGNORE_HR(m_site->Invalidate(NULL));
#else
        RECT r;

        if (CRGetInvalidatedRects(m_view, 0, 1, &r) == 1)
        {
            IGNORE_HR(m_site->Invalidate(NULL));
        }
        else
        {
            IGNORE_HR(m_site->Invalidate(&r));
        }
#endif
    }
    
    ok = true;
  done:
    return ok;
}

HRESULT
CMMView::Error()
{
    LPCWSTR str = CRGetLastErrorString();
    HRESULT hr = CRGetLastError();
    
    TraceTag((tagError,
              "CMMView(%lx)::Error(%hr,%ls)",
              this,
              hr,
              str?str:L"NULL"));

    if (str)
        return CComCoClass<CMMView, &__uuidof(CMMView)>::Error(str, IID_ITIMEMMView, hr);
    else
        return hr;
}

class __declspec(uuid("98d6aa3a-9191-11d2-80b9-00c04fa32195"))
ViewGuid {};

HRESULT WINAPI
CMMView::InternalQueryInterface(CMMView* pThis,
                                const _ATL_INTMAP_ENTRY* pEntries,
                                REFIID iid,
                                void** ppvObject)
{
    // Do not do an addref but return the original this pointer to
    // give access to the class pointer itself.
    
    if (InlineIsEqualGUID(iid, __uuidof(ViewGuid)))
    {
        *ppvObject = pThis;
        return S_OK;
    }
    
    return CComObjectRootEx<CComSingleThreadModel>::InternalQueryInterface(pThis,
                                                                           pEntries,
                                                                           iid,
                                                                           ppvObject);
}
        
CMMView *
GetViewFromInterface(IUnknown * pv)
{
    // This is a total hack to get the original class data.  The QI is
    // implemented above and does NOT do a addref so we do not need to
    // release it
    
    CMMView * mmview = NULL;

    if (pv)
    {
        pv->QueryInterface(__uuidof(ViewGuid),(void **)&mmview);
    }
    
    if (mmview == NULL)
    {
        CRSetLastError(E_INVALIDARG, NULL);
    }
                
    return mmview;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\time\mmapi\mmview.h ===
/*******************************************************************************
 *
 * Copyright (c) 1998 Microsoft Corporation
 *
 * File: mmview.h
 *
 * Abstract:
 *
 *
 *
 *******************************************************************************/


#ifndef _MMVIEW_H
#define _MMVIEW_H

class CMMPlayer;

class
__declspec(uuid("47d014fe-9174-11d2-80b9-00c04fa32195")) 
ATL_NO_VTABLE
CMMView
    : public CComObjectRootEx<CComSingleThreadModel>,
      public CComCoClass<CMMView, &__uuidof(CMMView)>,
      public ITIMEMMView,
      public ISupportErrorInfoImpl<&IID_ITIMEMMView>
{
  public:
    CMMView();
    ~CMMView();

    STDMETHOD_(ULONG,AddRef)(void) = 0;
    STDMETHOD_(ULONG,Release)(void) = 0;
    STDMETHOD(QueryInterface)(REFIID iid, void ** ppvObject) = 0;

    HRESULT Init(LPOLESTR id,
                 IDAImage * img,
                 IDASound * snd,
                 ITIMEMMViewSite * site);

#if _DEBUG
    const _TCHAR * GetName() { return __T("CMMView"); }
#endif

    BEGIN_COM_MAP(CMMView)
        COM_INTERFACE_ENTRY(ITIMEMMView)
        COM_INTERFACE_ENTRY(ISupportErrorInfo)
    END_COM_MAP();

    static HRESULT WINAPI
        InternalQueryInterface(CMMView* pThis,
                               const _ATL_INTMAP_ENTRY* pEntries,
                               REFIID iid,
                               void** ppvObject);
    //
    // ITIMEMMView
    //
    
    STDMETHOD(Tick)();
    STDMETHOD(Draw)(HDC dc, LPRECT prc);
    STDMETHOD(OnMouseMove)(double when,
                           LONG xPos, LONG yPos,
                           BYTE modifiers);
    
    STDMETHOD(OnMouseButton)(double when,
                             LONG xPos, LONG yPos,
                             BYTE button,
                             VARIANT_BOOL bPressed,
                             BYTE modifiers);
    
    STDMETHOD(OnKey)(double when,
                     LONG key,
                     VARIANT_BOOL bPressed,
                     BYTE modifiers);
    
    STDMETHOD(OnFocus)(VARIANT_BOOL bHasFocus);

    bool Start(CMMPlayer &);
    bool Pause();
    bool Resume();
    void Stop();

    bool Tick(double gTime);
  protected:
    HRESULT Error();

    CMMPlayer * GetPlayer();
    
    bool IsStarted();
  protected:
    CRViewPtr m_view;
    DAComPtr<ITIMEMMViewSite> m_site;
    CMMPlayer * m_player;
    CRPtr<CRImage> m_img;
    CRPtr<CRSound> m_snd;
    HDC m_hdc;
};

inline CMMPlayer *
CMMView::GetPlayer()
{
    return m_player;
}

inline bool
CMMView::IsStarted()
{
    return m_player != NULL;
}

CMMView * GetViewFromInterface(IUnknown *);

#endif /* _MMVIEW_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\time\rsrc\makefile.inc ===
datime.rc : $(SDK_LIB_PATH)\datime.tlb
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\time\src\array.cpp ===
//************************************************************
//
// FileName:        array.cpp
//
// Created:         01/28/98
//
// Author:          TWillie
// 
// Abstract:        Declaration of the array templates
//************************************************************

#include "headers.h"
#include "array.h"

#define CFORMSARY_MAXELEMSIZE    128

//  CImplAry class

//
//  NOTE that this file does not include support for artificial
//    error simulation.  There are common usage patterns for arrays
//    which break our normal assumptions about errors.  For instance,
//    ary.EnsureSize() followed by ary.Append(); code which makes
//    this sequence of calls expects ary.Append() to always succeed.
//
//    Because of this, the Ary methods do not use THR internally.
//    Instead, the code which is calling Ary is expected to follow
//    the normal THR rules and use THR() around any call to an
//    Ary method which could conceivably fail.
//
//    This relies on the Ary methods having solid internal error
//    handling, since the error handling within will not be exercised
//    by the normal artifical failure code.
//

//************************************************************
//
//  Member: CImplAry::~CImplAry
//
//  Synopsis:   Resizeable array destructor. Frees storage allocated for the
//      array.
//
//************************************************************

// Suppress new warning about NEW without corresponding DELETE 
// We expect GCs to cleanup values.  Since this could be a useful
// warning, we should disable this on a file by file basis.
#pragma warning( disable : 4291 )  

CImplAry::~CImplAry()
{
    if (!UsingStackArray())
    {
        if (NULL != PData())
        {
            GlobalFreePtr(PData());
        }
    }

    m_pv = NULL;
    m_c  = 0;
} // ~CImplAry

//************************************************************
//
//  Member:     CImplAry::GetAlloced, public
//
//  Synopsis:   Returns the number of bytes that have been allocated.
//
//  Arguments:  [cb] -- Size of each element
//
//  Notes:      For the CStackAry classes the value returned is m_cStack*cb if
//              we're still using the stack-allocated array.
//
//************************************************************

ULONG
CImplAry::GetAlloced(size_t cb)
{
    if (UsingStackArray())
    {
        return GetStackSize() * cb;
    }

    if(PData()==NULL)
        return 0;
    else return GlobalSize(GlobalPtrHandle(PData()));
} // GetAlloced

//************************************************************
//
//  Member: CImplAry::EnsureSize
//
//  Synopsis:   Ensures that the array is at least the given size. That is,
//      if EnsureSize(c) succeeds, then (c-1) is a valid index. Note
//      that the array maintains a separate count of the number of
//      elements logically in the array, which is obtained with the
//      Size/SetSize methods. The logical size of the array is never
//      larger than the allocated size of the array.
//
//  Arguments:  cb    Element size
//              c     New allocated size for the array.
//
//  Returns:    HRESULT
//
//************************************************************

HRESULT
CImplAry::EnsureSize(size_t cb, long c)
{
    unsigned long cbAlloc;

    // check to see if we need to do anything
    if (UsingStackArray() && (long)(c * cb) <= (long)GetAlloced(cb))
        return S_OK;

    Assert(c >= 0);

    cbAlloc = ((c + 7) & ~7) * cb;
    
    if (UsingStackArray() ||
        (((unsigned long) c > ((m_c + 7) & ~7)) && cbAlloc > (PData()==NULL?0:GlobalSize(GlobalPtrHandle(PData())))))
    {
        if (UsingStackArray())
        {
            //
            // We have to switch from the stack-based array to an allocated
            // one, so allocate the memory and copy the data over.
            //
            void *pbDataOld = PData();

            PData() = GlobalAllocPtr(GHND, cbAlloc);
            if (PData() ==  NULL)
            {
                TraceTag((tagError, "CImplAry::EnsureSize - unable to alloc memory"));
                PData() = pbDataOld;
                return E_OUTOFMEMORY;
            }

            if(pbDataOld!=NULL) {
                  int cbOld  = GetAlloced(cb);
                  memcpy(PData(), pbDataOld, cbOld);
            }
        }
        else
        {
            // if we already have a pointer, realloc
            if (PData())
            {
                void *pTemp = GlobalReAllocPtr(PData(), cbAlloc, GHND);
                if (pTemp == NULL)
                {
                    TraceTag((tagError, "CImplAry::EnsureSize - unable to realloc memory"));
                    return E_OUTOFMEMORY;
                }

                PData() = pTemp;
            }
            else
            {
                PData() = GlobalAllocPtr(GHND, cbAlloc);
                if (PData() == NULL)
                {
                    TraceTag((tagError, "CImplAry::EnsureSize - unable to alloc memory"));
                    return E_OUTOFMEMORY;
                }
            }

        }

        m_fDontFree = false;
    }

    return S_OK;
} // EnsureSize

//************************************************************
//
//  Member:     CImplAry::Grow, public
//
//  Synopsis:   Ensures enough memory is allocated for c elements and then
//              sets the size of the array to that much.
//
//  Arguments:  [cb] -- Element Size
//              [c]  -- Number of elements to grow array to.
//
//  Returns:    HRESULT
//
//************************************************************

HRESULT
CImplAry::Grow(size_t cb, int c)
{
    HRESULT hr = EnsureSize(cb, c);
    if (FAILED(hr))
    {
        TraceTag((tagError, "CImplAry::Grow - EnsureSize() failed"));
        return hr;
    }

    // BUGBUG - This is a very bad design.  This is too dangerous.
    //          Consider the case where c < m_c.
    SetSize(c);

    return S_OK;
} // Grow

//************************************************************
//
//  Member:     CImplAry::AppendIndirect
//
//  Synopsis:   Appends the given element to the end of the array,
//              incrementing the array's logical size, and growing the
//              array's allocated size if necessary.  Note that the element
//              is passed with a pointer, rather than directly.
//
//  Arguments:  cb        Element size
//              pv        Pointer to the element to be appended
//              ppvPlaced Pointer to the element that's inside the array
//
//  Returns:    HRESULT
//
//  Notes:      If pv is NULL, the element is appended and initialized to
//              zero.
//
//************************************************************

HRESULT
CImplAry::AppendIndirect(size_t cb, void *pv, void **ppvPlaced)
{
    HRESULT hr;

    hr = EnsureSize(cb, m_c + 1);
    if (FAILED(hr))
    {
        TraceTag((tagError, "CImplAry::AppendIndirect - EnsureSize() failed!"));
        return(hr);
    }

    if (ppvPlaced)
    {
        *ppvPlaced = Deref(cb, m_c);
    }

    if (pv == NULL)
    {
        memset(Deref(cb, m_c), 0, cb);
    }
    else
    {
        memcpy(Deref(cb, m_c), pv, cb);
    }

    // increment the count
    m_c++;

    return NOERROR;
} // AppendIndirect

//************************************************************
//
//  Member: CImplAry::DeleteItem
//
//  Synopsis:   Removes the i'th element of the array, shuffling all
//              elements that follow one slot towards the beginning of the
//              array.
//
//  Arguments:  cb  Element size
//              i   Element to delete
//
//************************************************************

void
CImplAry::DeleteItem(size_t cb, int i)
{
    Assert(i >= 0);
    Assert(i < (int)m_c);

    // slide bottom data up one
    memmove(((BYTE *) PData()) + (i * cb),
            ((BYTE *) PData()) + ((i + 1) * cb),
            (m_c - i - 1) * cb);

    // decrement the count
    m_c--;
} // DeleteItem

//************************************************************
//
//  Member: CImplAry::DeleteByValueIndirect
//
//  Synopsis:   Removes the element matching the given value.
//
//  Arguments:  cb  Element size
//              pv  Element to delete
//
//  Returuns:   True if found & deleted.
//
//************************************************************

bool
CImplAry::DeleteByValueIndirect(size_t cb, void *pv)
{
    int i = FindIndirect(cb, pv);
    if (i >= 0)
    {
        DeleteItem(cb, i);
        return true;
    }
    
    return false;
} // DeleteByValueIndirect

//************************************************************
//
//  Member: CImplAry::DeleteMultiple
//
//  Synopsis:   Removes a range of elements of the array, shuffling all
//              elements that follow the last element being deleted slot
//              towards the beginning of the array.
//
//  Arguments:  cb    Element size
//              start First element to delete
//              end   Last element to delete
//
//************************************************************

void
CImplAry::DeleteMultiple(size_t cb, int start, int end)
{
    Assert((start >= 0) && (end >= 0));
    Assert((start < (int)m_c) && (end < (int)m_c));
    Assert(end >= start);

    if ((unsigned)end < (m_c - 1))
    {
        memmove(((BYTE *) PData()) + (start * cb),
                ((BYTE *) PData()) + ((end + 1) * cb),
                (m_c - end - 1) * cb);
    }

    m_c -= (end - start) + 1;
} // DeleteMultiple

//************************************************************
//
//  Member: CImplAry::DeleteAll
//
//  Synopsis:   Efficient method for emptying array of any contents
//
//************************************************************

void
CImplAry::DeleteAll(void)
{
    if (!UsingStackArray())
    {
        if (NULL != PData())
        {
            GlobalFreePtr(PData());
        }

        if (m_fStack)
        {
            PData() = GetStackPtr();
            m_fDontFree = true;
        }
        else
        {
            PData() = NULL;
        }
    }

    m_c = 0;
} // DeleteAll

//************************************************************
//
//  Member: CImplAry::InsertIndirect
//
//  Synopsis:   Inserts a pointer pv at index i. The element previously at
//      index i, and all elements that follow it, are shuffled one
//      slot away towards the end of the array.Note that the
//      clement is passed with a pointer, rather than directly.
//
//  Arguments:  cb    Element size
//              i     Index to insert...
//              pv        ...this pointer at
//
//              if pv is NULL then the element is initialized to all zero.
//
//************************************************************

HRESULT
CImplAry::InsertIndirect(size_t cb, int i, void *pv)
{
    HRESULT hr;

    hr = EnsureSize(cb, m_c + 1);
    if (FAILED(hr))
    {
        TraceTag((tagError, "CImplAry::InsertIndirect - EnsureSize() failed!"));
        return(hr);
    }

    memmove(((BYTE *) PData()) + ((i + 1) * cb),
            ((BYTE *) PData()) + (i * cb),
            (m_c - i) * cb);

    if (pv == NULL)
    {
        memset(Deref(cb, i), 0, cb);
    }
    else
    {
        memcpy(Deref(cb, i), pv, cb);
    }

    // increment the count
    m_c++;
    return NOERROR;

} // InsertIndirect

//************************************************************
//
//  Member:     CImplAry::FindIndirect
//
//  Synopsis:   Finds an element of a non-pointer array.
//
//  Arguments:  cb  The size of the element.
//              pv  Pointer to the element.
//
//  Returns:    The index of the element if found, otherwise -1.
//
//************************************************************

int
CImplAry::FindIndirect(size_t cb, void * pv)
{
    int     i;
    void *  pvT;

    pvT = PData();
    for (i = m_c; i > 0; i--)
    {
        if (!memcmp(pv, pvT, cb))
            return m_c - i;

        pvT = (char *) pvT + cb;
    }

    return -1;
} // FindIndirect

//************************************************************
//
//  Member:     CImplAry::Copy
//
//  Synopsis:   Creates a copy from another CImplAry object.
//
//  Arguments:  ary     Object to copy.
//              fAddRef Addref the elements on copy?
//
//************************************************************

HRESULT
CImplAry::Copy(size_t cb, const CImplAry& ary, bool fAddRef)
{
    return(CopyIndirect(cb, ary.m_c, ((CImplAry *)&ary)->PData(), fAddRef));
} // Copy

//************************************************************
//
//  Member:     CImplAry::CopyIndirect
//
//  Synopsis:   Fills a forms array from a C-style array of raw data
//
//  Arguments:  [cb]
//              [c]
//              [pv]
//              [fAddRef]
//
//  Returns:    HRESULT
//
//************************************************************

HRESULT
CImplAry::CopyIndirect(size_t cb, int c, void *pv, bool fAddRef)
{
    if ((pv == NULL) || (cb < 1) || (c < 1))
    {
        TraceTag((tagError, "CImplAry::CopyIndirect - invalid param"));
        return E_INVALIDARG;
    }

    // if we point to ourselves, da!
    if (pv == PData())
        return S_OK;

    // clear data out
    DeleteAll();

    // ensure size we now want
    HRESULT hr = EnsureSize(cb, c);
    if (FAILED(hr))
    {
        TraceTag((tagError, "CImplAry::CopyIndirect - EnsureSize() failed"));
        return hr;
    }

    // copy data over (blindly)
    memcpy(PData(), pv, c * cb);

    // set element count
    m_c = c;

    if (fAddRef)
    {
        for (IUnknown **ppUnk = (IUnknown **) PData(); c > 0; c--, ppUnk++)
        {
            (*ppUnk)->AddRef();
        }
    }

    return S_OK;
} // CopyIndirect

//************************************************************
//
//  Member:     CImplPtrAry::*
//
//  Synopsis:   CImplPtrAry elements are always of size four.
//              The following functions encode this knowledge.
//
//************************************************************

HRESULT
CImplPtrAry::EnsureSize(long c)
{
    return CImplAry::EnsureSize(sizeof(void *), c);
} // EnsureSize

//************************************************************

HRESULT
CImplPtrAry::Grow(int c)
{
    return CImplAry::Grow(sizeof(void *), c);
} // Grow

//************************************************************

HRESULT
CImplPtrAry::Append(void * pv)
{
    return CImplAry::AppendIndirect(sizeof(void *), &pv);
} // Append

//************************************************************

HRESULT
CImplPtrAry::Insert(int i, void * pv)
{
    return CImplAry::InsertIndirect(sizeof(void *), i, &pv);
} // Insert

//************************************************************

int
CImplPtrAry::Find(void * pv)
{
    int    i;
    void **ppv;

    for (i = 0, ppv = (void **) PData(); (unsigned)i < m_c; i++, ppv++)
    {
        if (pv == *ppv)
            return i;
    }

    return -1;
} // Find

//************************************************************

void
CImplPtrAry::DeleteItem(int i)
{
    CImplAry::DeleteItem(sizeof(void *), i);
}

//************************************************************

bool
CImplPtrAry::DeleteByValue(void *pv)
{
    int i = Find(pv);
    if (i >= 0)
    {
        CImplAry::DeleteItem(sizeof(void *), i);
        return true;
    }

    return false;
} // DeleteByValue

//************************************************************

void
CImplPtrAry::DeleteMultiple(int start, int end)
{
    CImplAry::DeleteMultiple(sizeof(void*), start, end);
} // DeleteMultiple

//************************************************************

void
CImplPtrAry::ReleaseAndDelete(int idx)
{
    IUnknown *pUnk;

    Assert(idx <= (int)m_c);

    // grab element at idx
    pUnk = ((IUnknown **) PData())[idx];
    if (pUnk)
        ReleaseInterface(pUnk);

    DeleteItem(idx);
} // ReleaseAndDelete

//************************************************************

void
CImplPtrAry::ReleaseAll(void)
{
    int        i;
    IUnknown **ppUnk;

    for (i = 0, ppUnk = (IUnknown **) PData(); (unsigned)i < m_c; i++, ppUnk++)
    {
        if (*ppUnk)
            ReleaseInterface(*ppUnk);
    }

    DeleteAll();
} // ReleaseAll

//************************************************************

HRESULT
CImplPtrAry::CopyIndirect(int c, void * pv, bool fAddRef)
{
    return CImplAry::CopyIndirect(sizeof(void *), c, pv, fAddRef);
} // CopyIndirect

//************************************************************

HRESULT
CImplPtrAry::Copy(const CImplAry& ary, bool fAddRef)
{
    return CImplAry::Copy(sizeof(void *), ary, fAddRef);
} // Copy

//************************************************************

HRESULT
CImplPtrAry::EnumElements(REFIID   iid,
                          void   **ppv,
                          bool     fAddRef,
                          bool     fCopy,
                          bool     fDelete)
{
    return CImplAry::EnumElements(sizeof(void *),
                                  iid,
                                  ppv,
                                  fAddRef,
                                  fCopy,
                                  fDelete);
} // EnumElements

//************************************************************

HRESULT
CImplPtrAry::EnumVARIANT(VARTYPE        vt,
                         IEnumVARIANT **ppenum,
                         bool           fCopy,
                         bool           fDelete)
{
    return CImplAry::EnumVARIANT(sizeof(void *),
                                 vt,
                                 ppenum,
                                 fCopy,
                                 fDelete);
} // EnumVARIANT

//************************************************************

// Determines whether a variant is a base type.
#define ISBASEVARTYPE(vt) ((vt & ~VT_TYPEMASK) == 0)

//************************************************************
//
//  CBaseEnum Implementation
//
//************************************************************

//************************************************************
//
//  Member:     CBaseEnum::Init
//
//  Synopsis:   2nd stage initialization performs copy of array if necessary.
//
//  Arguments:  [rgItems] -- Array to enumrate.
//              [fCopy]   -- Copy array?
//
//  Returns:    HRESULT.
//
//************************************************************

HRESULT
CBaseEnum::Init(CImplAry *rgItems, bool fCopy)
{
    HRESULT   hr = S_OK;
    CImplAry *rgCopy = NULL;     // copied array

    if (rgItems == NULL)
    {
        TraceTag((tagError, "CBaseEnum::Init - invalid param"));
        return E_INVALIDARG;
    }

    // Copy array if necessary.
    if (fCopy)
    {
        rgCopy = NEW CImplAry;
        if (rgCopy == NULL)
        {
            TraceTag((tagError, "CBaseEnum::Init - unable to alloc memory for new array class"));
            return E_OUTOFMEMORY;
        }

        hr = rgCopy->Copy(m_cb, *rgItems, m_fAddRef);
        if (FAILED(hr))
        {
            TraceTag((tagError, "CBaseEnum::Init - Copy() failed"));
            delete rgCopy;
            return hr;
        }

        rgItems = rgCopy;
    }

    m_rgItems = rgItems;

    return hr;
} // Init

//************************************************************
//
//  Member:     CBaseEnum::CBaseEnum
//
//  Synopsis:   Constructor.
//
//  Arguments:  [iid]     -- IID of enumerator interface.
//              [fAddRef] -- addref enumerated elements?
//              [fDelete] -- delete array on zero enumerators?
//
//************************************************************

CBaseEnum::CBaseEnum(size_t cb, REFIID iid, bool fAddRef, bool fDelete)
{
    m_ulRefs     = 1;

    m_cb         = cb;
    m_rgItems    = NULL;
    m_piid       = &iid;
    m_i          = 0;
    m_fAddRef    = fAddRef;
    m_fDelete    = fDelete;
} // CBaseEnum

//************************************************************
//
//  Member:     CBaseEnum::CBaseEnum
//
//  Synopsis:   Constructor.
//
//************************************************************

CBaseEnum::CBaseEnum(const CBaseEnum& benum)
{
    m_ulRefs     = 1;

    m_cb         = benum.m_cb;
    m_piid       = benum.m_piid;
    m_rgItems    = benum.m_rgItems;
    m_i          = benum.m_i;
    m_fAddRef    = benum.m_fAddRef;
    m_fDelete    = benum.m_fDelete;
} // CBaseEnum

//************************************************************
//
//  Member:     CBaseEnum::~CBaseEnum
//
//  Synopsis:   Destructor.
//
//************************************************************

CBaseEnum::~CBaseEnum(void)
{
    IUnknown **ppUnk;
    int        i;

    if (m_rgItems && m_fDelete)
    {
        if (m_fAddRef)
        {
            for (i = 0, ppUnk = (IUnknown **) Deref(0);
                 i < m_rgItems->Size();
                 i++, ppUnk++)
            {
                ReleaseInterface(*ppUnk);
            }
        }

        delete m_rgItems;
    }
} // ~CBaseEnum

//************************************************************
//
//  Member:     CBaseEnum::QueryInterface
//
//  Synopsis:   Per IUnknown::QueryInterface.
//
//************************************************************

STDMETHODIMP
CBaseEnum::QueryInterface(REFIID iid, void ** ppv)
{
    if (IsEqualIID(iid, IID_IUnknown) || IsEqualIID(iid, *m_piid))
    {
        AddRef();
        *ppv = this;
        return NOERROR;
    }

    return E_NOINTERFACE;
} // QueryInterface

//************************************************************
//
//  Member:     CBaseEnum::Skip
//
//  Synopsis:   Per IEnum*
//
//************************************************************

STDMETHODIMP
CBaseEnum::Skip(ULONG celt)
{
    int c = min((int) celt, m_rgItems->Size() - m_i);
    m_i += c;

    return ((c == (int) celt) ? S_OK : S_FALSE);
} // Skip

//************************************************************
//
//  Member:     CBaseEnum::Reset
//
//  Synopsis:   Per IEnum*
//
//************************************************************

STDMETHODIMP
CBaseEnum::Reset(void)
{
    m_i = 0;
    return S_OK;
} // Reset

//************************************************************
//
//  CEnumGeneric Implementation
//
//************************************************************

//************************************************************
//
//  Class:      CEnumGeneric (enumg)
//
//  Purpose:    OLE enumerator for class CImplAry.
//
//  Interface:  Next         -- Per IEnum
//              Clone        --     ""
//              Create       -- Creates a new enumerator.
//              CEnumGeneric -- ctor.
//              CEnumGeneric -- ctor.
//
//************************************************************

class CEnumGeneric : public CBaseEnum
{
public:
    //
    //  IEnum methods
    //
    STDMETHOD(Next) (ULONG celt, void *reelt, ULONG *pceltFetched);
    STDMETHOD(Clone) (CBaseEnum **ppenum);

    //
    //  CEnumGeneric methods
    //
    static HRESULT Create(size_t          cb,
                          CImplAry       *rgItems,
                          REFIID          iid,
                          bool            fAddRef,
                          bool            fCopy,
                          bool            fDelete,
                          CEnumGeneric  **ppenum);

protected:
    CEnumGeneric(size_t cb, REFIID iid, bool fAddRef, bool fDelete);
    CEnumGeneric(const CEnumGeneric & enumg);

    CEnumGeneric& operator=(const CEnumGeneric & enumg); // don't define
}; // class CEnumGeneric

//************************************************************
//
//  Member:     CEnumGeneric::Create
//
//  Synopsis:   Creates a new CEnumGeneric object.
//
//  Arguments:  [rgItems] -- Array to enumerate.
//              [iid]     -- IID of enumerator interface.
//              [fAddRef] -- AddRef enumerated elements?
//              [fCopy]   -- Copy array enumerated?
//              [fDelete] -- Delete array when zero enumerators of array?
//              [ppenum]  -- Resulting CEnumGeneric object.
//
//************************************************************

HRESULT
CEnumGeneric::Create(size_t          cb,
                     CImplAry       *rgItems,
                     REFIID          iid,
                     bool            fAddRef,
                     bool            fCopy,
                     bool            fDelete,
                     CEnumGeneric  **ppenum)
{
    HRESULT         hr = S_OK;
    CEnumGeneric   *penum;

    Assert(rgItems);
    Assert(ppenum);
    Assert(!fCopy || fDelete);
    
    *ppenum = NULL;
    
    penum = NEW CEnumGeneric(cb, iid, fAddRef, fDelete);
    if (penum == NULL)
    {
        TraceTag((tagError, "CEnumGeneric::Create - unable to alloc memory for CEnumGeneric"));
        return E_OUTOFMEMORY;
    }

    hr = penum->Init(rgItems, fCopy);
    if (FAILED(hr))
    {
        ReleaseInterface(penum);
        return hr;
    }

    *ppenum = penum;

    return hr;
} // Create

//************************************************************
//
//  Function:   CEnumGeneric
//
//  Synopsis:   ctor.
//
//  Arguments:  [iid]     -- IID of enumerator interface.
//              [fAddRef] -- AddRef enumerated elements?
//              [fDelete] -- delete array on zero enumerators?
//
//************************************************************

CEnumGeneric::CEnumGeneric(size_t cb, REFIID iid, bool fAddRef, bool fDelete) :
    CBaseEnum(cb, iid, fAddRef, fDelete)
{
} // CEnumGeneric (size_t, REFIID, bool, bool)

//************************************************************
//
//  Function:   CEnumGeneric
//
//  Synopsis:   ctor.
//
//************************************************************

CEnumGeneric::CEnumGeneric(const CEnumGeneric& enumg) : CBaseEnum(enumg)
{
} // CEnumGeneric

//************************************************************
//
//  Member:     CEnumGeneric::Next
//
//  Synopsis:   Returns the next celt members in the enumeration. If less
//              than celt members remain, then the remaining members are
//              returned and S_FALSE is reported. In all cases, the number
//              of elements actually returned in placed in *pceltFetched.
//
//  Arguments:  [celt]          Number of elements to fetch
//              [reelt]         The elements are returned in reelt[]
//              [pceltFetched]  Number of elements actually fetched
//
//************************************************************

STDMETHODIMP
CEnumGeneric::Next(ULONG celt, void *reelt, ULONG *pceltFetched)
{
    int        c;
    int        i;
    IUnknown **ppUnk;

    c = min((int) celt, m_rgItems->Size() - m_i);
    if ((c > 0) && (reelt == NULL))
    {
        TraceTag((tagError, "CEnumGeneric::Next - invalid params"));
        return E_INVALIDARG;
    }

    // nothing left
    if (c == 0)
        return S_FALSE;

    if (m_fAddRef)
    {
        for (i = 0, ppUnk = (IUnknown **) Deref(m_i); i < c; i++, ppUnk++)
        {
            (*ppUnk)->AddRef();
        }
    }

    memcpy(reelt, (BYTE *) Deref(m_i), c * m_cb);
    
    if (pceltFetched)
    {
        *pceltFetched = c;
    }
    
    m_i += c;

    return ((c == (int) celt) ? S_OK : S_FALSE);
} // Next

//************************************************************
//
//  Member:     CEnumGeneric::Clone
//
//  Synopsis:   Creates a copy of this enumerator; the copy should have the
//              same state as this enumerator.
//
//  Arguments:  [ppenum]    New enumerator is returned in *ppenum
//
//************************************************************

STDMETHODIMP
CEnumGeneric::Clone(CBaseEnum ** ppenum)
{
    HRESULT hr;

    if (ppenum == NULL)
    {
        TraceTag((tagError, "CEnumGeneric::Clone - invalid param"));
        return E_INVALIDARG;
    }

    *ppenum = NULL;

    hr = m_rgItems->EnumElements(m_cb, *m_piid, (void **) ppenum, m_fAddRef);
    if (FAILED(hr))
    {
        TraceTag((tagError, "CEnumGeneric::Clone - EnumElements() failed"));
        return hr;
    }
    
    (**(CEnumGeneric **)ppenum).m_i = m_i;
    
    return S_OK;
} // Clone

//************************************************************
//
//  Member:     CImplAry::EnumElements
//
//  Synopsis:   Creates and returns an enumerator for the elements of the
//              array.
//
//  Arguments:  [iid]     --    Type of the enumerator.
//              [ppv]     --    Location to put enumerator.
//              [fAddRef] --    AddRef enumerated elements?
//              [fCopy]   --    Create copy of this array for enumerator?
//              [fDelete] --    Delete this after no longer being used by
//                              enumerators?
//
//************************************************************

HRESULT
CImplAry::EnumElements(size_t   cb,
                       REFIID   iid,
                       void   **ppv,
                       bool     fAddRef,
                       bool     fCopy,
                       bool     fDelete)
{
    Assert(ppv);
    return CEnumGeneric::Create(cb,
                                this,
                                iid,
                                fAddRef,
                                fCopy,
                                fDelete,
                                (CEnumGeneric **) ppv);
} // EnumElements

//************************************************************
//
//  CEnumVARIANT Implementation
//
//************************************************************

//************************************************************
//
//  Class:      CEnumVARIANT (enumv)
//
//  Purpose:    OLE enumerator for class CImplAry.
//
//  Interface:  Next         -- Per IEnum
//              Clone        --     ""
//              Create       -- Creates a new enumerator.
//              CEnumGeneric -- ctor.
//              CEnumGeneric -- ctor.
//
//************************************************************

class CEnumVARIANT : public CBaseEnum
{
public:
    //  IEnum methods
    STDMETHOD(Next) (ULONG celt, void *reelt, ULONG *pceltFetched);
    STDMETHOD(Clone) (CBaseEnum **ppenum);

    static HRESULT Create(size_t          cb,
                          CImplAry       *rgItems,
                          VARTYPE         vt,
                          bool            fCopy,
                          bool            fDelete,
                          IEnumVARIANT  **ppenum);

protected:
    CEnumVARIANT(size_t cb, VARTYPE vt, bool fDelete);
    CEnumVARIANT(const CEnumVARIANT & enumv);

    // don't define
    CEnumVARIANT& operator =(const CEnumVARIANT & enumv);

    VARTYPE     m_vt;                    // type of element enumerated
}; // class CEnumVARIANT

//************************************************************
//
//  Member:     CEnumVARIANT::Create
//
//  Synopsis:   Creates a new CEnumGeneric object.
//
//  Arguments:  [rgItems] -- Array to enumerate.
//              [vt]      -- Type of elements enumerated.
//              [fCopy]   -- Copy array enumerated?
//              [fDelete] -- Delete array when zero enumerators of array?
//              [ppenum]  -- Resulting CEnumGeneric object.
//
//************************************************************

HRESULT
CEnumVARIANT::Create(size_t          cb,
                     CImplAry       *rgItems,
                     VARTYPE         vt,
                     bool            fCopy,
                     bool            fDelete,
                     IEnumVARIANT  **ppenum)
{
    HRESULT hr = S_OK;

    Assert(rgItems);
    Assert(ppenum);
    Assert(ISBASEVARTYPE(vt));

    *ppenum = NULL;

    CEnumVARIANT *penum = NEW CEnumVARIANT(cb, vt, fDelete);
    if (ppenum == NULL)
    {
        TraceTag((tagError, "CEnumVARIANT::Create - unable to alloc mem for CEnumVARIANT"));
        return E_OUTOFMEMORY;
    }

    hr = penum->Init(rgItems, fCopy);
    if (FAILED(hr))
    {
        TraceTag((tagError, "CEnumVARIANT::Create - Init() failed"));
        ReleaseInterface(penum);
        return hr;
    }

    *ppenum = (IEnumVARIANT *) (void *) penum;

    return hr;
} // Create

//************************************************************
//
//  Function:   CEnumVARIANT
//
//  Synopsis:   ctor.
//
//  Arguments:  [vt]      -- Type of elements enumerated.
//              [fDelete] -- delete array on zero enumerators?
//
//************************************************************

CEnumVARIANT::CEnumVARIANT(size_t cb, VARTYPE vt, bool fDelete) :
    CBaseEnum(cb, IID_IEnumVARIANT, vt == VT_UNKNOWN || vt == VT_DISPATCH, fDelete)
{
    Assert(ISBASEVARTYPE(vt));
    m_vt = vt;
} // CEnumVARIANT (size_t, VARTYPE, bool)

//************************************************************
//
//  Function:   CEnumVARIANT
//
//  Synopsis:   ctor.
//
//************************************************************

CEnumVARIANT::CEnumVARIANT(const CEnumVARIANT& enumv) : CBaseEnum(enumv)
{
    m_vt = enumv.m_vt;
} // CEnumVARIANT(const CEnumVARIANT&)

//************************************************************
//
//  Member:     CEnumVARIANT::Next
//
//  Synopsis:   Returns the next celt members in the enumeration. If less
//              than celt members remain, then the remaining members are
//              returned and S_FALSE is reported. In all cases, the number
//              of elements actually returned in placed in *pceltFetched.
//
//  Arguments:  [celt]          Number of elements to fetch
//              [reelt]         The elements are returned in reelt[]
//              [pceltFetched]  Number of elements actually fetched
//
//************************************************************

STDMETHODIMP
CEnumVARIANT::Next(ULONG celt, void *reelt, ULONG *pceltFetched)
{
    HRESULT     hr;
    int         c;
    int         i;
    int         j;
    BYTE       *pb;
    VARIANT    *pvar;

    c = min((int) celt, m_rgItems->Size() - m_i);
    
    if ((c > 0) && (reelt == NULL))
    {
        TraceTag((tagError, "CEnumVARIANT::Next - invalid param"));
        return E_INVALIDARG;
    }

    // nothing left
    if (c == 0)
        return S_FALSE;

    for (i = 0, pb = (BYTE *) Deref(m_i), pvar = (VARIANT *) reelt;
         i < c;
         i++, pb += m_cb, pvar++)
    {
        V_VT(pvar) = m_vt;
        switch (m_vt)
        {
        case VT_I2:
            Assert(sizeof(V_I2(pvar)) == m_cb);
            V_I2(pvar) = *(short *) pb;
            break;

        case VT_I4:
            Assert(sizeof(V_I4(pvar)) == m_cb);
            V_I4(pvar) = *(long *) pb;
            break;

        case VT_BOOL:
            Assert(sizeof(V_BOOL(pvar)) == m_cb);
            V_BOOL(pvar) = (short) -*(int *) pb;
            break;

        case VT_BSTR:
            Assert(sizeof(V_BSTR(pvar)) == m_cb);
            V_BSTR(pvar) = *(BSTR *) pb;
            break;

        case VT_UNKNOWN:
            Assert(sizeof(V_UNKNOWN(pvar)) == m_cb);
            V_UNKNOWN(pvar) = *(IUnknown **) pb;
            V_UNKNOWN(pvar)->AddRef();
            break;

        case VT_DISPATCH:
            Assert(sizeof(V_DISPATCH(pvar)) == m_cb);
            hr = (*(IUnknown **) pb)->QueryInterface(IID_TO_PPV(IDispatch, &V_DISPATCH(pvar)));
            if (FAILED(hr))
            {
                // Cleanup
                j = i;
                while (--j >= 0)
                {
                    ReleaseInterface(((IDispatch **) reelt)[j]);
                }

                return hr;
            }
            break;

        default:
            Assert(0 && "Unknown VARTYPE in IEnumVARIANT::Next");
            break;
        }
    }

    if (pceltFetched)
    {
        *pceltFetched = c;
    }

    m_i += c;
    return ((c == (int) celt) ? NOERROR : S_FALSE);
} // Next

//************************************************************
//
//  Member:     CEnumVARIANT::Clone
//
//  Synopsis:   Creates a copy of this enumerator; the copy should have the
//              same state as this enumerator.
//
//  Arguments:  [ppenum]    New enumerator is returned in *ppenum
//
//************************************************************

STDMETHODIMP
CEnumVARIANT::Clone(CBaseEnum **ppenum)
{
    HRESULT hr = S_OK;

    if (ppenum == NULL)
    {
        TraceTag((tagError, "CEnumVARIANT::Clone - invalid param"));
        return E_INVALIDARG;
    }

    *ppenum = NULL;
   
    hr = m_rgItems->EnumVARIANT(m_cb, m_vt, (IEnumVARIANT **)ppenum);
    if (FAILED(hr))
    {
        TraceTag((tagError, "CEnumVARIANT::Clone - EnumVARIANT() failed"));
        return hr;
    }

    (**(CEnumVARIANT **)ppenum).m_i = m_i;
    
    return hr;
} // Clone

//************************************************************
//
//  Member:     CImplAry::EnumElements
//
//  Synopsis:   Creates and returns an IEnumVARIANT enumerator for the elements
//              of the array.
//
//  Arguments:  [vt]      --    Type of elements enumerated.
//              [ppv]     --    Location to put enumerator.
//              [fCopy]   --    Create copy of this array for enumerator?
//              [fDelete] --    Delete this after no longer being used by
//                              enumerators?
//
//************************************************************

HRESULT
CImplAry::EnumVARIANT(size_t         cb,
                      VARTYPE        vt,
                      IEnumVARIANT **ppenum,
                      bool           fCopy,
                      bool           fDelete)
{
    Assert(ppenum);
    return CEnumVARIANT::Create(cb, this, vt, fCopy, fDelete, ppenum);
} // EnumVARIANT

//************************************************************
//
// End of file
//
//************************************************************
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\time\src\atomtable.h ===
#ifndef _ATOMTABLE_H_
#define _ATOMTABLE_H_

//************************************************************
//
// FileName:        atomtbl.h
//
// Created:         01/28/98
//
// Author:          TWillie
// 
// Abstract:        Declaration of the CAtomTable
//************************************************************

#include "array.h"

class CAtomTable
{
public:
    CAtomTable();
    virtual ~CAtomTable();
    
    //
    // CAtomTable impl
    //
    HRESULT AddNameToAtomTable(const WCHAR *pwszName,
                               long        *plOffset);
    HRESULT GetAtomFromName(const WCHAR *pwszName,
                            long        *plOffset);
    HRESULT GetNameFromAtom(long          lOffset, 
                            const WCHAR **ppwszName);
    
private:
    CPtrAry<BSTR> *m_rgNames;
};

#endif // _ATOMTABLE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\time\src\basebvr.cpp ===
/*******************************************************************************
 *
 * Copyright (c) 1998 Microsoft Corporation
 *
 * File: basebvr.cpp
 *
 * Abstract:
 *
 *
 *
 *******************************************************************************/


#include "headers.h"
#include "basebvr.h"
#include "tokens.h"

DeclareTag(tagBaseBvr, "API", "CBaseBvr methods");

CBaseBvr::CBaseBvr()
{

    TraceTag((tagBaseBvr,
              "CBaseBvr(%lx)::CBaseBvr()",
              this));
}

//////////////////////////////////////////////////////////////////////////////////////////////////////////////
// IElementBehavior

//////////////////////////////////////////////////////////////////////////////////////////////////////////////

STDMETHODIMP
CBaseBvr::Init(IElementBehaviorSite * pBehaviorSite)
{
    TraceTag((tagBaseBvr,
              "CBaseBvr(%lx)::Init(%lx)",
              this,
              pBehaviorSite));
    
    HRESULT hr = S_OK; 
    DAComPtr<IDispatch> pIDispatch;  
    
    if (pBehaviorSite == NULL)
    {
        hr = E_INVALIDARG;
        goto done;
    }
    
    m_pBvrSite = pBehaviorSite;

    hr = m_pBvrSite->QueryInterface(IID_IElementBehaviorSiteOM, (void **) &m_pBvrSiteOM);
    if (FAILED(hr))
    {
        goto done;
    }

    Assert(m_pBvrSiteOM.p != NULL);
        
    hr = m_pBvrSiteOM->RegisterName(WZ_REGISTERED_NAME);
    if (FAILED(hr))
    {
        goto done;
    }

    hr = THR(pBehaviorSite->GetElement(&m_pHTMLEle));
    if (FAILED(hr))
    {
        goto done;
    }

    Assert(m_pHTMLEle.p != NULL);
        
    hr = m_pBvrSite->QueryInterface(IID_IElementBehaviorSiteRender, (void **) &m_pBvrSiteRender);
    if (FAILED(hr))
    {
        goto done;
    }

    Assert(m_pBvrSiteRender.p != NULL);
        
    hr = THR(m_pBvrSite->QueryInterface(IID_IServiceProvider, (void **)&m_pSp));
    if (FAILED(hr))
    {
        goto done;
    }

    Assert(m_pSp.p != NULL);
        
    hr = THR(m_pHTMLEle->get_document(&pIDispatch));
    if (FAILED(hr))
    {
        goto done;
    }

    Assert(pIDispatch.p != NULL);
        
    hr = THR(pIDispatch->QueryInterface(IID_IHTMLDocument2, (void**)&m_pHTMLDoc));
    if (FAILED(hr))
    {
        goto done;
    }
    
    Assert(m_pHTMLDoc.p != NULL);
        
    // Do not set the init flag since it will be set by the first
    // notify which we want to skip
    
  done:
    return hr;
}
   
STDMETHODIMP
CBaseBvr::Notify(LONG, VARIANT *)
{
    return S_OK;
}

STDMETHODIMP
CBaseBvr::Detach()
{
    TraceTag((tagBaseBvr,
              "CBaseBvr(%lx)::Detach()",
              this));

    m_pBvrSite.Release();
    m_pBvrSiteOM.Release();
    m_pBvrSiteRender.Release();
    m_pHTMLEle.Release();
    m_pHTMLDoc.Release();
    m_pSp.Release();
    
    return S_OK;
}

//////////////////////////////////////////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////////////////////////////////////////
// IElementBehaviorRender

//////////////////////////////////////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CBaseBvr::GetRenderInfo(LONG *pdwRenderInfo)
{
    TraceTag((tagBaseBvr,
              "CBaseBvr(%lx)::GetRenderInfo()",
              this));
    
    // Return the layers we are interested in drawing

    // We do not do any rendering so return 0
    
    *pdwRenderInfo = 0;

    return S_OK;
}


STDMETHODIMP
CBaseBvr::Draw(HDC hdc, LONG dwLayer, LPRECT prc, IUnknown * pParams)
{
    TraceTag((tagBaseBvr,
              "CBaseBvr(%lx)::Draw(%#x, %#x, (%d, %d, %d, %d), %#x)",
              this,
              hdc,
              dwLayer,
              prc->left,
              prc->top,
              prc->right,
              prc->bottom,
              pParams));
    
    return E_NOTIMPL;
}

STDMETHODIMP
CBaseBvr::HitTestPoint(LPPOINT point,
                       IUnknown *pReserved,
                       BOOL *hit)
{
    TraceTag((tagBaseBvr,
              "CBaseBvr(%lx)::HitTestPoint()",
              this));

    *hit = FALSE;

    return S_OK;
}


//////////////////////////////////////////////////////////////////////////////////////////////////////////////
// CBaseBvr Methods

void
CBaseBvr::InvalidateRect(LPRECT lprect)
{
    TraceTag((tagBaseBvr,
              "CBaseBvr(%lx)::InvalidateRect",
              this));

    if (m_pBvrSiteRender)
    {
        m_pBvrSiteRender->Invalidate(lprect);
    }
}

void
CBaseBvr::InvalidateRenderInfo()
{
    TraceTag((tagBaseBvr,
              "CBaseBvr(%lx)::InvalidateRenderInfo",
              this));

    if (m_pBvrSiteRender)
    {
        m_pBvrSiteRender->InvalidateRenderInfo();
    }
}

//
// IServiceProvider interfaces
//
STDMETHODIMP
CBaseBvr::QueryService(REFGUID guidService,
                       REFIID riid,
                       void** ppv)
{
    if (InlineIsEqualGUID(guidService, SID_SHTMLWindow))
    {
        DAComPtr<IHTMLWindow2> wnd;

        if (SUCCEEDED(THR(m_pHTMLDoc->get_parentWindow(&wnd))))
        {
            if (wnd)
            {
                if (SUCCEEDED(wnd->QueryInterface(riid, ppv)))
                {
                    return S_OK;
                }
            }
        }
    }

    // Just delegate to our service provider

    return m_pSp->QueryService(guidService,
                               riid,
                               ppv);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\time\mmapi\util.cpp ===
/*******************************************************************************

Copyright (c) 1995-96 Microsoft Corporation

Abstract:

    {Insert General Comment Here}

*******************************************************************************/


#include "headers.h"
#include <mshtml.h>

#define DISPID_GETSAFEARRAY -2700

#define IS_VARTYPE(x,vt) ((V_VT(x) & VT_TYPEMASK) == (vt))
#define IS_VARIANT(x) IS_VARTYPE(x,VT_VARIANT)
#define GET_VT(x) (V_VT(x) & VT_TYPEMASK)

SafeArrayAccessor::SafeArrayAccessor(VARIANT & v,
                                     bool canBeNull)
: _inited(false),
  _isVar(false),
  _s(NULL),
  _failed(true),
  _allocArr(NULL)
{
    HRESULT hr;
    VARIANT *pVar;

    // Check if it is a reference to another variant
    
    if (V_ISBYREF(&v) && !V_ISARRAY(&v) && IS_VARIANT(&v))
        pVar = V_VARIANTREF(&v);
    else
        pVar = &v;

    // Check for an array
    if (!V_ISARRAY(pVar)) {
        // For JSCRIPT
        // See if it is a IDispatch and see if we can get a safearray from
        // it
        if (!IS_VARTYPE(pVar,VT_DISPATCH)) {
            if (canBeNull && (IS_VARTYPE(pVar, VT_EMPTY) ||
                              IS_VARTYPE(pVar, VT_NULL))) {

                
                // if we allow empty, then just set the safearray
                // to null.
                _s = NULL;
                _v = NULL;
                _ubound = _lbound = 0;
                _inited = true;
                _failed = false;
                return;
            } else {
                CRSetLastError (DISP_E_TYPEMISMATCH,NULL);
                return;
            }
        }

        IDispatch * pdisp;
        
        if (V_ISBYREF(pVar))
            pdisp = *V_DISPATCHREF(pVar);
        else
            pdisp = V_DISPATCH(pVar);
    
        DISPPARAMS dispparamsNoArgs = {NULL, NULL, 0, 0};
        
        // Need to pass in a VARIANT that we own and will free.  Use
        // the internal _retVar parameter
        
        hr = pdisp->Invoke(DISPID_GETSAFEARRAY,
                           IID_NULL,
                           LCID_SCRIPTING,
                           DISPATCH_METHOD|DISPATCH_PROPERTYGET,
                           &dispparamsNoArgs,
                           &_retVar, NULL, NULL);
        
        if (FAILED(hr)) {
            CRSetLastError (DISP_E_TYPEMISMATCH,NULL);
            return;
        }
        
        // No need to check for a reference since you cannot return
        // VARIANT references
        pVar = &_retVar;
        
        // Check for an array
        if (!V_ISARRAY(pVar)) {
            CRSetLastError (DISP_E_TYPEMISMATCH,NULL);
            return;
        }
    }
    
    // See if it is a variant
    
    if (IS_VARIANT(pVar))
        _isVar = true;
    else if (!IS_VARTYPE(pVar,VT_UNKNOWN) &&
             !IS_VARTYPE(pVar,VT_DISPATCH)) {
        CRSetLastError (DISP_E_TYPEMISMATCH,NULL);
        return;
    }

    if (V_ISBYREF(pVar))
        _s = *V_ARRAYREF(pVar);
    else
        _s = V_ARRAY(pVar);
    
    if (_s == NULL) {
        if (canBeNull) {
            _v = NULL;
            _ubound = _lbound = 0;
            _inited = true;
            _failed = false;
            return;
        } else {
            CRSetLastError (E_INVALIDARG,NULL);
            return;
        }
    }

    if (SafeArrayGetDim(_s) != 1) {
        CRSetLastError (E_INVALIDARG,NULL);
        return;
    }

    hr = SafeArrayGetLBound(_s,1,&_lbound);
        
    if (FAILED(hr)) {
        CRSetLastError (E_INVALIDARG,NULL);
        return;
    }
        
    hr = SafeArrayGetUBound(_s,1,&_ubound);
        
    if (FAILED(hr)) {
        CRSetLastError (E_INVALIDARG,NULL);
        return;
    }
        
    hr = SafeArrayAccessData(_s,(void **)&_v);

    if (FAILED(hr)) {
        CRSetLastError (E_INVALIDARG,NULL);
        return;
    }
        
    _inited = true;

    // If it is a variant see if they are objects or not

    if (_isVar) {
        int size = GetArraySize();
        
        if (size > 0) {
            // Check the first argument to see its type

            VARIANT * pVar = &_pVar[0];

            // Check if it is a reference to another variant
            
            if (V_ISBYREF(pVar) && !V_ISARRAY(pVar) && IS_VARIANT(pVar))
                pVar = V_VARIANTREF(pVar);

            // Check if it is an object
            if (!IS_VARTYPE(pVar,VT_UNKNOWN) &&
                !IS_VARTYPE(pVar,VT_DISPATCH)) {
                CRSetLastError (DISP_E_TYPEMISMATCH,NULL);
                return;
            }

            _allocArr = (IUnknown **) malloc(size * sizeof (IUnknown *));

            if (_allocArr == NULL) {
                CRSetLastError(E_OUTOFMEMORY, NULL);
                return;
            }

            for (int i = 0; i < size; i++) {
                CComVariant var;
                HRESULT hr = var.ChangeType(VT_UNKNOWN, &_pVar[i]);
                
                if (FAILED(hr)) {
                    CRSetLastError(DISP_E_TYPEMISMATCH,NULL);
                    return;
                }
                
                _allocArr[i] = var.punkVal;
            }
        }
    }

    _failed = false;
}

SafeArrayAccessor::~SafeArrayAccessor()
{
    if (_inited && _s)
        SafeArrayUnaccessData(_s);
}

#if 0
HRESULT
CallScript(IOleClientSite * pClient,
           LPWSTR fun,
           IDispatch * disp,
           DWORD dwData)
{
    DISPID dispid;
    DAComPtr<IOleContainer> pRoot;
    DAComPtr<IHTMLDocument> pHTMLDoc;
    DAComPtr<IDispatch> pDispatch;
    CRBvrPtr bvr = NULL;
    DAComPtr<IDABehavior> event;
    DAComPtr<IDABehavior> curBvr;
    CComVariant retVal;
    HRESULT hr = E_INVALIDARG;
        
    if (!pClient) goto done;
    
    {
        CComBSTR bstrfun(fun);
        
        if (FAILED(hr = pClient->GetContainer(&pRoot)) ||
            FAILED(hr = pRoot->QueryInterface(IID_IHTMLDocument, (void **)&pHTMLDoc)) ||
            FAILED(hr = pHTMLDoc->get_Script(&pDispatch)) ||
            FAILED(hr = pDispatch->GetIDsOfNames(IID_NULL, &bstrfun, 1,
                                                 LCID_SCRIPTING,
                                                 &dispid))) {
            goto done;
        }
    }

        
    // paramters needed to be pushed in reverse order
    VARIANT rgvarg[2];
    rgvarg[1].vt = VT_DISPATCH;
    rgvarg[1].pdispVal = disp;
    rgvarg[0].vt = VT_I4;
    rgvarg[0].lVal = dwData;
    
    DISPPARAMS dp;
    dp.cNamedArgs = 0;
    dp.rgdispidNamedArgs = 0;
    dp.cArgs = 2;
    dp.rgvarg = rgvarg;
    
    hr = pDispatch->Invoke(dispid, IID_NULL,
                           LCID_SCRIPTING, DISPATCH_METHOD,
                           &dp, &retVal, NULL, NULL);

    if (FAILED(hr)) {
        goto done;
    }

  done:
    return hr;
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\time\src\array.h ===
#ifndef _ARRAY_H_
#define _ARRAY_H_

//************************************************************
//
// FileName:        array.h
//
// Created:         01/28/98
//
// Author:          TWillie
// 
// Abstract:        Declaration of the array templates
//
//************************************************************


#define ULREF_IN_DESTRUCTOR 256

//************************************************************
//
// This is the implementation of the generic resizeable array classes. There
// are four array classes:
//
// CPtrAry<ELEM> --
//
//       Dynamic array class which is optimized for sizeof(ELEM) equal
//       to 4. The array is initially empty with no space or memory allocated
//       for data.
//
// CDataAry<ELEM> --
//
//       Same as CPtrAry but where sizeof(ELEM) is != 4 and less than 128.
//
// CStackPtrAry<ELEM, N> --
//
//       Dynamic array class optimized for sizeof(ELEM) equal to 4.
//       Space for N elements is allocated as member data of the class. If
//       this class is created on the stack, then space for N elements will
//       be created on the stack. The class can grow beyond N elements, at
//       which point memory will be allocated for the array data.
//
// CStackDataAry<ELEM, N> --
//
//       Same as CStackPtrAry, but where sizeof(ELEM) is != 4 and less than 128.
//
//
// All four classes have virtually the same methods, and are used the same.
// The only difference is that the DataAry classes have AppendIndirect and
// InsertIndirect, while the PtrAry classes use Append and Insert. The reason
// for the difference is that the Indirect methods take a pointer to the data,
// while the non-indirect methods take the actual data as an argument.
//
// The Stack arrays (CStackPtrAry and CStackDataAry) are used to pre-allocate
// space for elements in the array. This is useful if you create the array on
// the stack and you know that most of the time the array will be less than
// a certain number of elements. Creating one of these arrays on the stack
// allocates the array on the stack as well, preventing a separate memory
// allocation. Only if the array grows beyond the initial size will any
// additional memory be allocated.
//
// The fastest and most efficient way of looping through all elements in
// the array is as follows:
//
//            ELEM * pElem;
//            int    i;
//
//            for (i = aryElems.Size(), pElem = aryElems;
//                 i > 0;
//                 i--, pElem++)
//            {
//                (*pElem)->DoSomething();
//            }
//
// This loop syntax has been shown to be the fastest and produce the smallest
// code. Here's an example using a real data type:
//
//            CStackPtrAry<CSite*, 16> arySites;
//            CSite **ppSite;
//            int     i;
//
//            // Populate the array.
//            ...
//
//            // Now loop through every element in the array.
//            for (i = arySites.Size(), ppSite = arySites;
//                 i > 0;
//                 i--, ppSite++)
//            {
//                (*ppSite)->DoSomething();
//            }
//
// METHOD DESCRIPTIONS:
//
// Commonly used methods:
//
//        Size()             Returns the number of elements currently stored
//                           in the array.
//
//        operator []        Returns the given element in the array.
//
//        Item(int i)        Returns the given element in the array.
//
//        operator ELEM*     Allows the array class to be cast to a pointer
//                           to ELEM. Returns a pointer to the first element
//                           in the array. (Same as a Base() method).
//
//        Append(ELEM e)     Adds a new pointer to the end of the array,
//                           growing the array if necessary.  Only valid
//                           for arrays of pointers (CPtrAry, CStackPtrAry).
//
//        AppendIndirect(ELEM *pe, ELEM** ppePlaced)
//                           As Append, for non-pointer arrays
//                           (CDataAry, CStackDataAry).
//                           pe [in] - Pointer to element to add to array. The
//                                     data is copied into the array. Can be
//                                     NULL, in which case the new element is
//                                     initialized to all zeroes.
//                           ppePlaced [out] - Returns pointer to the new
//                                     element. Can be NULL.
//
//        Insert(int i, ELEM e)
//                           Inserts a new element (e) at the given index (i)
//                           in the array, growing the array if necessary. Any
//                           elements at or following the index are moved
//                           out of the way.
//
//        InsertIndirect(int i, ELEM *pe)
//                           As Insert, for non-pointer arrays
//                                 (CDataAry, CStackDataAry).
//
//        Find(ELEM e)       Returns the index at which a given element (e)
//                           is found (CPtrAry, CStackPtrAry).
//
//        FindIndirect(ELEM *pe)
//                           As Find, for non-pointer arrays
//                                 (CDataAry, CStackDataAry).
//
//        DeleteAll()        Empties the array and de-allocates associated
//                           memory.
//
//        DeleteItem(int i)  Deletes an element of the array, moving any
//                           elements that follow it to fill
//
//        DeleteMultiple(int start, int end)
//                           Deletes a range of elements from the array,
//                           moving to fill. [start] and [end] are the indices
//                           of the start and end elements (inclusive).
//
//        DeleteByValue(ELEM e)
//                           Delete the element matching the given value.
//
//        DeleteByValueIndirect(ELEM *pe)
//                           As DeleteByValue, for non-pointer arrays.
//                                    (CDataAry, CStackDataAry).
//
//
// Less commonly used methods:
//
//        EnsureSize(long c) If you know how many elements you are going to put
//                          in the array before you actually do it, you can use
//                          EnsureSize to allocate the memory all at once instead
//                          of relying on Append(Indirect) to grow the array. This
//                          can be much more efficient (by causing only a single
//                          memory allocation instead of many) than just using
//                          Append(Indirect). You pass in the number of elements
//                          that memory should be allocated for. Note that this
//                          does not affect the "Size" of the array, which is
//                          the number of elements currently stored in it.
//
//        SetSize(int c)    Sets the "Size" of the array, which is the number
//                          of elements currently stored in it. SetSize will not
//                          allocate memory if you're growing the array.
//                          EnsureSize must be called first to reserve space if
//                          the array is growing. Setting the size smaller does
//                          not de-allocate memory, it just chops off the
//                          elements at the end of the array.
//
//        Grow(int c)       Equivalent to calling EnsureSize(c) followed by
//                          SetSize(c).
//
//        BringToFront(int i) Moves the given element of the array to index 0,
//                          shuffling elements to make room.
//
//        SendToBack(int i) Moves the given element to the end of the array,
//                          shuffling elements to make room.
//
//        Swap(int i, int j) Swaps the given two elements.
//
//        ReleaseAll()      (CPtrAry and CStackPtrAry only) Calls Release()
//                          on each element in the array and empties the array.
//
//        ReleaseAndDelete(int idx)
//                          (CPtrAry and CStackPtrAry only) Calls Release() on
//                          the given element and removes it from the array.
//
//           (See the class definitions below for signatures of the following
//            methods and src\core\cdutil\formsary.cxx for argument
//            descriptions)
//
//        CopyAppend        Appends data from another array (of the same type)
//                          to the end.
//
//        Copy              Copies data from another array (of the same type)
//                          into this array, replacing any existing data.
//
//        CopyAppendIndirect  Appends data from a C-style array of element data
//                          to the end of this array.
//
//        CopyIndirect      Copies elements from a C-style array into this array
//                          replacing any existing data.
//
//        EnumElements      Create an enumerator which supports the given
//                          interface ID for the contents of the array
//
//        EnumVARIANT       Create an IEnumVARIANT enumerator.
//
//        operator void *   Allow the CImplAry class to be cast
//                          to a (void *). Avoid using if possible - use
//                          the type-safe operator ELEM * instead.
//
//************************************************************

//************************************************************
//
// Class:     CImplAry
//
// Purpose:   Base implementation of all the dynamic array classes.
//
// Interface:
//
//        Deref       Returns a pointer to an element of the array;
//                    should only be used by derived classes. Use the
//                    type-safe methods operator[] or Item() instead.
//
//        GetAlloced  Get number of elements allocated
//
//  Members:    m_c          Current size of the array
//              m_pv         Buffer storing the elements
//
//  Note:       The CImplAry class only supports arrays of elements
//              whose size is less than 128.
//
//************************************************************

class CImplAry
{
    friend class CBaseEnum;
    friend class CEnumGeneric;
    friend class CEnumVARIANT;

public:
    ~CImplAry();

    inline long Size() const
    {
        return m_c;
    } // Size

    inline void SetSize(int c)
    {
        m_c = c;
    } // SetSize

    inline operator void *()
    {
        return PData();
    } // void *
    
    void DeleteAll();

    void * Deref(size_t cb, int i);

//    NO_COPY(CImplAry);

protected:

    //  Methods which are wrapped by inline subclass methods
    CImplAry();

    HRESULT     EnsureSize(size_t cb, long c);
    HRESULT     Grow(size_t cb, int c);
    HRESULT     AppendIndirect(size_t cb, void *pv, void **ppvPlaced=NULL);
    HRESULT     InsertIndirect(size_t cb, int i, void *pv);
    int         FindIndirect(size_t cb, void *);

    void        DeleteItem(size_t cb, int i);
    bool        DeleteByValueIndirect(size_t cb, void *pv);
    void        DeleteMultiple(size_t cb, int start, int end);

    HRESULT     CopyAppend(size_t cb, const CImplAry& ary, bool fAddRef);
    HRESULT     Copy(size_t cb, const CImplAry& ary, bool fAddRef);
    HRESULT     CopyIndirect(size_t cb, int c, void *pv, bool fAddRef);

    ULONG       GetAlloced(size_t cb);

    HRESULT     EnumElements(size_t   cb,
                             REFIID   iid,
                             void   **ppv,
                             bool     fAddRef,
                             bool     fCopy = true,
                             bool     fDelete = true);

    HRESULT     EnumVARIANT(size_t         cb,
                            VARTYPE        vt,
                            IEnumVARIANT **ppenum,
                            bool           fCopy = true,
                            bool           fDelete = true);

    inline bool UsingStackArray()
    {
        return m_fDontFree;
    } // UsingStackArray

    UINT GetStackSize()
    { 
        Assert(m_fStack);
        return *(UINT*)((BYTE*)this + sizeof(CImplAry));
    } // GetStackSize

    void * GetStackPtr()
    {
        Assert(m_fStack);
        return (void*)((BYTE*)this + sizeof(CImplAry) + sizeof(int));
    } // GetStackPtr

    bool          m_fStack;    // Set if we're a stack-based array.
    bool          m_fDontFree; // Cleared if m_pv points to alloced memory.
    unsigned long m_c;         // Count of elements

    void           *m_pv;

    inline void * & PData()
    {
        return m_pv;
    } // PData
};

//************************************************************
//
//  Member:     CImplAry::CImplAry
//
//************************************************************

inline
CImplAry::CImplAry()
{
    memset(this, 0, sizeof(CImplAry));
} // CImplAry 

//************************************************************
//
//  Member:     CImplAry::Deref
//
//  Synopsis:   Returns a pointer to the i'th element of the array. This
//              method is normally called by type-safe methods in derived
//              classes.
//
//  Arguments:  i
//
//************************************************************

inline void *
CImplAry::Deref(size_t cb, int i)
{
    Assert(i >= 0);
    Assert(ULONG( i ) < GetAlloced(cb));

    return ((BYTE *) PData()) + i * cb;
} // Deref

//************************************************************
//
//  Class:      CImplPtrAry (ary)
//
//  Purpose:    Subclass used for arrays of pointers.  In this case, the
//              element size is known to be sizeof(void *).  Normally, the
//              CPtrAry template is used to define a specific concrete
//              implementation of this class, to hold a specific type of
//              pointer.
//
//              See documentation above for use.
//
//************************************************************

class CImplPtrAry : public CImplAry
{
protected:
    CImplPtrAry() : CImplAry()
    {
    } // CImplPtrAry

    HRESULT     Append(void * pv);
    HRESULT     Insert(int i, void * pv);
    int         Find(void * pv);
    bool        DeleteByValue(void *pv);

    HRESULT     CopyAppend(const CImplAry& ary, bool fAddRef);
    HRESULT     Copy(const CImplAry& ary, bool fAddRef);
    HRESULT     CopyIndirect(int c, void * pv, bool fAddRef);


public:
    HRESULT     EnsureSize(long c);

    HRESULT     Grow(int c);

    void        DeleteItem(int i);
    void        DeleteMultiple(int start, int end);

    void        ReleaseAll();
    void        ReleaseAndDelete(int idx);

    HRESULT     EnumElements(REFIID iid,
                             void **ppv,
                             bool   fAddRef,
                             bool   fCopy = true,
                             bool   fDelete = true);

    HRESULT     EnumVARIANT(VARTYPE        vt,
                            IEnumVARIANT **ppenum,
                            bool           fCopy = true,
                            bool           fDelete = true);
}; // CImplPtrAry

//************************************************************
//
//  Class:      CDataAry
//
//  Purpose:    This template class declares a concrete derived class
//              of CImplAry.
//
//              See documentation above for use.
//
//************************************************************

template <class ELEM>
class CDataAry : public CImplAry
{
public:
    CDataAry() : CImplAry()
    {
    } // CDataAry

    operator ELEM *()
    {
        return (ELEM *)PData();
    } // ELEM *

    CDataAry(const CDataAry &);

    ELEM & Item(int i)
    {
        return *(ELEM*)Deref(sizeof(ELEM), i);
    } // Item

    HRESULT EnsureSize(long c)
    {
        return CImplAry::EnsureSize(sizeof(ELEM), c);
    } // EnsureSize
    
    HRESULT Grow(int c)
    {
        return CImplAry::Grow(sizeof(ELEM), c);
    } // Grow
    
    HRESULT AppendIndirect(ELEM *pe, ELEM **ppePlaced=NULL)
    {
        return CImplAry::AppendIndirect(sizeof(ELEM), (void*)pe, (void**)ppePlaced);
    } // AppendIndirect
    
    ELEM * Append()
    {
        ELEM *pElem;
        return AppendIndirect( NULL, & pElem ) ? NULL : pElem;
    } // Append
    
    HRESULT InsertIndirect(int i, ELEM * pe)
    {
        return CImplAry::InsertIndirect(sizeof(ELEM), i, (void*)pe);
    } // InsertIndirect
    
    int FindIndirect(ELEM * pe)
    {
        return CImplAry::FindIndirect(sizeof(ELEM), (void*)pe);
    } // FindIndirect
    
    void DeleteItem(int i)
    {
        CImplAry::DeleteItem(sizeof(ELEM), i);
    } // DeleteItem
    
    bool DeleteByValueIndirect(ELEM *pe)
    {
        return CImplAry::DeleteByValueIndirect(sizeof(ELEM), (void*)pe);
    } // DeleteByValueIndirect
    
    void DeleteMultiple(int start, int end)
    {
        CImplAry::DeleteMultiple(sizeof(ELEM), start, end);
    } // DeleteMultiple
    
    HRESULT CopyAppend(const CDataAry<ELEM>& ary, bool fAddRef)
    {
        return E_NOTIMPL;
    } // CopyAppend
    
    HRESULT Copy(const CDataAry<ELEM>& ary, bool fAddRef)
    {
        return CImplAry::Copy(sizeof(ELEM), ary, fAddRef);
    } // Copy
    
    HRESULT CopyIndirect(int c, ELEM *pv, bool fAddRef)
    {
        return CImplAry::CopyIndirect(sizeof(ELEM), c, (void*)pv, fAddRef);
    } // CopyIndirect

    HRESULT EnumElements(REFIID  iid,
                         void  **ppv,
                         bool    fAddRef,
                         bool    fCopy = true,
                         bool    fDelete = true)
    {
        return CImplAry::EnumElements(sizeof(ELEM), iid, ppv, fAddRef, fCopy, fDelete);
    } // EnumElements

    HRESULT EnumVARIANT(VARTYPE        vt,
                        IEnumVARIANT **ppenum,
                        bool           fCopy = true,
                        bool           fDelete = true)
    {
        return CImplAry::EnumVARIANT(sizeof(ELEM), vt, ppenum, fCopy, fDelete);
    } // EnumVARIANT
}; // CDataAry

//************************************************************
//
//  Class:      CPtrAry
//
//  Purpose:    This template class declares a concrete derived class
//              of CImplPtrAry.
//
//              See documentation above for use.
//
//************************************************************

template <class ELEM>
class CPtrAry : public CImplPtrAry
{
public:

    CPtrAry() : CImplPtrAry()
    {
        Assert(sizeof(ELEM) == sizeof(void*));
    } // CPtrAry
    
    operator ELEM *()
    {
        return (ELEM *)PData();
    } // ELEM *
    
    CPtrAry(const CPtrAry &);

    ELEM & Item(int i)
    {
        return *(ELEM*)Deref(sizeof(ELEM), i);
    } // Item

    HRESULT Append(ELEM e)
    {
        return CImplPtrAry::Append((void*)e);
    } // Append

    HRESULT Insert(int i, ELEM e)
    {
        return CImplPtrAry::Insert(i, (void*)e);
    } // Insert

    bool DeleteByValue(ELEM e)
    {
        return CImplPtrAry::DeleteByValue((void*)e);
    } // DeleteByValue

    int Find(ELEM e)
    {
        return CImplPtrAry::Find((void*)e);
    } // Find

    HRESULT CopyAppend(const CPtrAry<ELEM>& ary, bool fAddRef)
    {
        return E_NOTIMPL;
    } // CopyAppend
    
    HRESULT Copy(const CPtrAry<ELEM>& ary, bool fAddRef)
    {
        return CImplPtrAry::Copy(ary, fAddRef);
    } // Copy
    
    HRESULT CopyIndirect(int c, ELEM *pe, bool fAddRef)
    {
        return CImplPtrAry::CopyIndirect(c, (void*)pe, fAddRef);
    } // CopyIndirect
}; // CPtrAry

//************************************************************
//
//  Class:      CStackDataAry
//
//  Purpose:    Declares a CDataAry that has initial storage on the stack.
//              N elements are declared on the stack, and the array will
//              grow dynamically beyond that if necessary.
//
//              See documentation above for use.
//
//************************************************************

template <class ELEM, int N>
class CStackDataAry : public CDataAry<ELEM>
{
public:
    CStackDataAry(): CDataAry<ELEM> ()
    {
        m_cStack     = N;
        m_fStack     = true;
        m_fDontFree  = true;
        PData()      = (void *) & m_achTInit;
    } // CStackDataAry

protected:
    int   m_cStack;                     // Must be first data member.
    char  m_achTInit[N*sizeof(ELEM)];
}; // CStackDataAry

//************************************************************
//
//  Class:      CStackPtrAry
//
//  Purpose:    Same as CStackDataAry except for pointer types.
//
//              See documentation above for use.
//
//************************************************************

template <class ELEM, int N>
class CStackPtrAry : public CPtrAry<ELEM>
{
public:
    CStackPtrAry() : CPtrAry<ELEM> ()
    {
        m_cStack     = N;
        m_fStack     = true;
        m_fDontFree  = true;
        PData()      = (void *) & m_achTInit;
    } // CStackPtrAry

protected:
    int   m_cStack;                     // Must be first data member.
    char  m_achTInit[N*sizeof(ELEM)];
}; // CStackPtrAry

//************************************************************
//
//  Class:      CBaseEnum (benum)
//
//  Purpose:    Base OLE enumerator class for a CImplAry.
//
//  Interface:  DECLARE_FORMS_STANRARD_IUNKNOWN
//
//              Next                   -- Per IEnum*
//              Skip                   --    ""
//              Reset                  --    ""
//              Clone                  --    ""
//              CBaseEnum              -- ctor.
//              CBaseEnum              -- ctor.
//              ~CBaseEnum             -- dtor.
//              Init                   -- 2nd stage initialization.
//              Deref                  -- gets pointer to element.
//
//  Notes:      Since there is no IEnum interface, we create a vtable
//              with the same layout as all IEnum interfaces.  Be careful
//              where you put virtual function declarations!
//
//************************************************************

class CBaseEnum : public IUnknown
{
public:
    //
    // IUnknown
    //
    STDMETHOD(QueryInterface) (REFIID riid, LPVOID * ppv);
    
    STDMETHOD_(ULONG, AddRef) (void)
    {
        return ++m_ulRefs;
    } // AddRef

    STDMETHOD_(ULONG, Release) (void)
    {
        if (--m_ulRefs == 0)
        {
            m_ulRefs = ULREF_IN_DESTRUCTOR;
            delete this;
            return 0;
        }
        return m_ulRefs;
    } // Release

    ULONG GetRefs(void)
    {
        return m_ulRefs;
    } // GetRefs

    //
    //  IEnum methods
    //
    STDMETHOD(Next) (ULONG celt, void * reelt, ULONG * pceltFetched) PURE;
    STDMETHOD(Skip) (ULONG celt);
    STDMETHOD(Reset) ();
    STDMETHOD(Clone) (CBaseEnum ** ppenum) PURE;

    //
    // Ensure that vtable contains virtual destructor after other virtual methods.
    //
    virtual ~CBaseEnum();

protected:
    CBaseEnum(size_t cb, REFIID iid, bool fAddRef, bool fDelete);
    CBaseEnum(const CBaseEnum & benum);

    CBaseEnum& operator=(const CBaseEnum & benum); // don't define

    HRESULT Init(CImplAry *rgItems, bool fCopy);
    void *  Deref(int i);

    CImplAry   *m_rgItems;
    const IID  *m_piid;
    int         m_i;
    size_t      m_cb;
    bool        m_fAddRef;
    bool        m_fDelete;
    ULONG       m_ulRefs;
}; // CBaseEnum

//************************************************************
//
//  Member:     CBaseEnum::Deref
//
//  Synopsis:   Forwards deref to m_rgItems.  Required because classes derived
//              from CBaseEnum are friends of CImplAry.
//
//************************************************************

inline void *
CBaseEnum::Deref(int i)
{
    Assert(i >= 0);
    return (BYTE *)m_rgItems->PData() + i * m_cb;
} // Deref 

#endif // _ARRAY_H_

//************************************************************
//
// End of file
//
//************************************************************
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\time\src\basebvr.h ===
/*******************************************************************************
 *
 * Copyright (c) 1998 Microsoft Corporation
 *
 * File: basebvr.h
 *
 * Abstract:
 *
 *
 *
 *******************************************************************************/


#ifndef _BASEBVR_H
#define _BASEBVR_H

class CBaseBvr :   
    public CComObjectRootEx<CComSingleThreadModel>,
    public IElementBehavior,
    public IElementBehaviorRender,
    public IServiceProvider,
    public IOleClientSite
{
  public:
    CBaseBvr();
    
    virtual void * GetInstance() = 0;
    virtual HRESULT GetTypeInfo(ITypeInfo ** ppInfo) = 0;

    // IElementBehavior
    //
    STDMETHOD(Init)(IElementBehaviorSite * pBvrSite);
    STDMETHOD(Notify)(LONG event, VARIANT * pVar);
    STDMETHOD(Detach)();

    //
    // IElementBehaviorRender
    //
    STDMETHOD(Draw)(HDC hdc, LONG dwLayer, LPRECT prc, IUnknown * pParams);
    STDMETHOD(GetRenderInfo)(LONG *pdwRenderInfo);
    STDMETHOD(HitTestPoint)(LPPOINT point,
                            IUnknown *pReserved,
                            BOOL *hit);
    
    IElementBehaviorSite * GetBvrSite()
    { return m_pBvrSite; }

    IElementBehaviorSiteOM * GetBvrSiteOM()
    { return m_pBvrSiteOM; }

    IElementBehaviorSiteRender * GetBvrSiteRender()
    { return m_pBvrSiteRender; }

    IHTMLElement * GetElement()
    { return m_pHTMLEle; }

    IHTMLDocument2 * GetDocument()
    { return m_pHTMLDoc; }
    
    IServiceProvider * GetServiceProvider()
    { return m_pSp; }
    
    virtual void InvalidateRect(LPRECT lprect);
    virtual void InvalidateRenderInfo();

    BEGIN_COM_MAP(CBaseBvr)
        COM_INTERFACE_ENTRY(IElementBehavior)
        COM_INTERFACE_ENTRY(IElementBehaviorRender)
        COM_INTERFACE_ENTRY(IServiceProvider)
        COM_INTERFACE_ENTRY(IOleClientSite)
    END_COM_MAP();

    //
    // IServiceProvider interfaces
    //

    STDMETHOD(QueryService)(REFGUID guidService,
                            REFIID riid,
                            void** ppv);

    //
    // IOleClientSite interfaces
    //
    
    STDMETHOD(SaveObject)()
    { return E_NOTIMPL; }
    STDMETHOD(GetMoniker)(DWORD dwAssign,
                          DWORD dwWhichMoniker, 
                          LPMONIKER * ppmk)
    { CHECK_RETURN_SET_NULL(ppmk); return E_NOTIMPL; }
    STDMETHOD(GetContainer)(LPOLECONTAINER * ppContainer)
    { CHECK_RETURN_SET_NULL(ppContainer); return E_NOTIMPL; }
    STDMETHOD(ShowObject)()
    { return E_NOTIMPL; }
    STDMETHOD(OnShowWindow)(BOOL fShow)
    { return E_NOTIMPL; }
    STDMETHOD(RequestNewObjectLayout)()
    { return E_NOTIMPL; }

    virtual WCHAR* GetBehaviorTypeAsURN() = 0;

  protected:
    DAComPtr<IElementBehaviorSite>          m_pBvrSite;
    DAComPtr<IElementBehaviorSiteOM>        m_pBvrSiteOM;
    DAComPtr<IElementBehaviorSiteRender>    m_pBvrSiteRender;
    DAComPtr<IHTMLElement>                  m_pHTMLEle;
    DAComPtr<IHTMLDocument2>                m_pHTMLDoc;
    DAComPtr<IServiceProvider>              m_pSp;
};

#endif /* _BASEBVR_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\time\src\atomtable.cpp ===
//************************************************************
//
// FileName:        atomtbl.cpp
//
// Created:         01/28/98
//
// Author:          TWillie
// 
// Abstract:        Implementation of CAtomTable.
//************************************************************

#include "headers.h"
#include "atomtable.h"

//************************************************************
// Author:          twillie
// Created:         01/28/98
// Abstract:        constructor
//************************************************************

// Suppress new warning about NEW without corresponding DELETE 
// We expect GCs to cleanup values.  Since this could be a useful
// warning, we should disable this on a file by file basis.
#pragma warning( disable : 4291 )  

CAtomTable::CAtomTable() :
    m_rgNames(NULL)
{
} // CAtomTable

//************************************************************
// Author:          twillie
// Created:         01/28/98
// Abstract:        destructor
//************************************************************

CAtomTable::~CAtomTable()
{
    if (m_rgNames)
    {
        // loop thru and release memory
        long lSize = m_rgNames->Size();
        for(long lIndex = 0; lIndex < lSize; lIndex++)
        {
            SysFreeString((*m_rgNames)[lIndex]);
        }

        delete m_rgNames;
        m_rgNames = NULL;
    }
} // ~CAtomTable

//************************************************************
// Author:	twillie
// Created:	02/06/98
// Abstract:    
//************************************************************

HRESULT
CAtomTable::AddNameToAtomTable(const WCHAR *pwszName, 
                               long        *plOffset)
{
    if ((plOffset == NULL) || (pwszName == NULL))
    {
        TraceTag((tagError, "CAtomTable::AddNameToAtomTable - Invalid param"));
        return E_INVALIDARG;
    }
    
    *plOffset = 0;
    
    // check to see if array is initialized
    if (m_rgNames == NULL)
    {
        m_rgNames = NEW CPtrAry<BSTR>;
        if (m_rgNames == NULL)
        {
            TraceTag((tagError, "CAtomTable::AddNameToAtomTable - Unable to alloc mem for array"));
            return E_OUTOFMEMORY;
        }
    }

    HRESULT hr = GetAtomFromName(pwszName, plOffset);
    if (hr == DISP_E_MEMBERNOTFOUND)
    {
        BSTR bstrName = SysAllocString(pwszName);
        if (bstrName == NULL)
        {
            TraceTag((tagError, "CAtomTable::AddNameToAtomTable - Unable to alloc mem for string"));
            return E_OUTOFMEMORY;
        }

        // add to table
        hr = m_rgNames->Append(bstrName);
        if (FAILED(hr))
        {
            TraceTag((tagError, "CAtomTable::AddNameToAtomTable - unable to add string to table"));
            SysFreeString(bstrName);
            return hr;
        }

        // calc offset
        *plOffset = m_rgNames->Size() - 1;
    }

    // otherwise return the results of FindAtom
    return hr;
} // AddNameToAtomTable


//************************************************************
// Author:	twillie
// Created:	02/06/98
// Abstract:    given a name, return the index
//************************************************************

HRESULT
CAtomTable::GetAtomFromName(const WCHAR *pwszName,
                            long        *plOffset)
{
    // validate out param
    if ((plOffset == NULL) || (pwszName == NULL))
    {
        TraceTag((tagError, "CAtomTable::GetAtomFromName - Invalid param"));
        return E_INVALIDARG;
    }

    // init param
    *plOffset = 0;

    // loop thru table looking for a match
    long   lSize  = m_rgNames->Size();
    BSTR  *ppItem = *m_rgNames;

    for (long lIndex = 0; lIndex < lSize; lIndex++, ppItem++)
    {
        Assert(*ppItem);

        if (wcscmp(pwszName, (*ppItem)) == 0)
        {
            *plOffset = lIndex;
            return S_OK;
        }
    }

    // not found
    return DISP_E_MEMBERNOTFOUND;
} // GetAtomFromName

//************************************************************
// Author:	twillie
// Created:	02/06/98
// Abstract:    given an index, return the contents
//************************************************************

HRESULT 
CAtomTable::GetNameFromAtom(long lOffset, const WCHAR **ppwszName)
{
    // validate out param
    if (ppwszName == NULL)
    {
        TraceTag((tagError, "CAtomTable::GetNameFromAtom - Invalid param"));
        return E_INVALIDARG;
    }

    *ppwszName = NULL;

    // check for empty table
    if (m_rgNames->Size() == 0)
    {
        TraceTag((tagError, "CAtomTable::GetNameFromAtom - table is empty"));
        return DISP_E_MEMBERNOTFOUND;
    }

    // check to make sure we are in range
    if ((lOffset < 0) || 
        (lOffset >= m_rgNames->Size()))
    {
        TraceTag((tagError, "CAtomTable::GetNameFromAtom - Invalid index"));
        return DISP_E_MEMBERNOTFOUND;
    }

    // set IDispatch
    *ppwszName = (*m_rgNames)[lOffset];
    return S_OK;
} // GetNameFromAtom

//************************************************************
//
// End of file
//
//************************************************************
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\time\src\bodyelm.cpp ===
/*******************************************************************************
 *
 * Copyright (c) 1998 Microsoft Corporation
 *
 * File: bodyelm.cpp
 *
 * Abstract:
 *
 *
 *
 *******************************************************************************/


#include "headers.h"
#include "bodyelm.h"
#include "daelm.h"
#include <mshtmdid.h>

DeclareTag(tagTimeBodyElm, "API", "CTIMEBodyElement methods");

// static class data.
CPtrAry<BSTR> CTIMEBodyElement::ms_aryPropNames;
DWORD CTIMEBodyElement::ms_dwNumBodyElems = 0;

// These must align with the class PROPERTY_INDEX enumeration.
LPWSTR CTIMEBodyElement::ms_rgwszTBodyPropNames[] = {
    L"timeStartRule",
};

CTIMEBodyElement::CTIMEBodyElement() :
    m_startRule(STARTRULE_ONDOCLOAD_TOKEN),
    m_player(*this),
    m_bodyPropertyAccesFlags(0),
    m_fStartRoot(false)
{
    TraceTag((tagTimeBodyElm,
              "CTIMEBodyElement(%lx)::CTIMEBodyElement()",
              this));

    m_clsid = __uuidof(CTIMEBodyElement);
    CTIMEBodyElement::ms_dwNumBodyElems++;

    // Override the default action
    // TODO: The right way to do this is to pass it in the constructor
    // but I am too lazy and this will work fine
    
    m_timeAction = NONE_TOKEN;

    // Set our body to be ourself
    m_pTIMEBody = this;
}

CTIMEBodyElement::~CTIMEBodyElement()
{
    CTIMEBodyElement::ms_dwNumBodyElems--;

    if (0 == CTIMEBodyElement::ms_dwNumBodyElems)
    {
        int iNames = CTIMEBodyElement::ms_aryPropNames.Size();

        for (int i = iNames - 1; i >= 0; i--)
        {
            BSTR bstrName = CTIMEBodyElement::ms_aryPropNames[i];
            CTIMEBodyElement::ms_aryPropNames.DeleteItem(i);
            ::SysFreeString(bstrName);
        }
    }
}


HRESULT
CTIMEBodyElement::Init(IElementBehaviorSite * pBehaviorSite)
{
    TraceTag((tagTimeBodyElm,
              "CTIMEBodyElement(%lx)::Init(%lx)",
              this,
              pBehaviorSite));
    
    HRESULT hr;

    hr = THR(CTIMEElementBase::Init(pBehaviorSite));
    if (FAILED(hr))
    {
        goto done;
    }

    hr = S_OK;

done:
    if (FAILED(hr))
    {
        Detach();
    }
    
    return hr;
}

HRESULT
CTIMEBodyElement::InitTimeline()
{
    TraceTag((tagTimeBodyElm, "CTIMEBodyElement(%lx)::InitTimeline()", this));
    HRESULT hr;

    hr = CTIMEElementBase::InitTimeline();
    if (FAILED(hr))
    {
        goto done;
    }

    Assert(m_timeline);
    
    if (!m_player.Init(*m_timeline))
    {
        hr = CRGetLastError();
        goto done;
    }

    Assert(!m_fStartRoot);

    // After we load properties, check to see if we need to start now.
    // If the doc is already started, we should start now.
    if ((m_startRule == STARTRULE_IMMEDIATE_TOKEN) || IsDocumentStarted())
    {
        HRESULT hr = THR(StartRootTime(NULL));
        if (FAILED(hr))
        {
            TraceTag((tagError, "CTIMEBodyElement::OnLoadComplete - StartRootTime() failed!"));
            goto done;
        }
    }
    hr = S_OK;
done:
    return hr;
}

STDMETHODIMP
CTIMEBodyElement::Detach()
{
    TraceTag((tagTimeBodyElm, "CTIMEBodyElement(%lx)::Detach()", this));
    
    HRESULT hr;

    if (m_fStartRoot)
    {
        Assert(m_timeline != NULL);
        StopRootTime(NULL);
    }

    m_player.Deinit();

    THR(CTIMEElementBase::Detach());

    hr = S_OK;

    return hr;
}


void CTIMEBodyElement::OnReadyStateChange(TOKEN state)
{
    TraceTag((tagTimeBodyElm, "CTIMEBodyElement(%lx)::OnReadyStateChange()", this));

    if (state == READYSTATE_COMPLETE_TOKEN)
    {
        // if the startRule is set to onDocComplete, start root time now.
        if ((m_startRule == STARTRULE_ONDOCCOMPLETE_TOKEN))
        {
            Assert(!m_fStartRoot);
            HRESULT hr = THR(StartRootTime(NULL));
            if (FAILED(hr))
            {
                TraceTag((tagError, "CTIMEBodyElement::OnReadyStateChange - StartRootTime() failed!"));
                goto done;
            }
        }
    }
        
done:
    return;
}

void CTIMEBodyElement::OnLoad()
{
    TraceTag((tagTimeBodyElm, "CTIMEBodyElement(%lx)::OnLoad()", this));

    // if the startRule is set to onDocLoad, start root time now.
    if ((m_startRule == STARTRULE_ONDOCLOAD_TOKEN))
    {
        Assert(!m_fStartRoot);
        HRESULT hr = THR(StartRootTime(NULL));
        if (FAILED(hr))
        {
            TraceTag((tagError, "CTIMEBodyElement::OnLoad - StartRootTime() failed!"));
            goto done;
        }
    }
        
done:
    CTIMEElementBase::OnLoad();
    return;
}

void
CTIMEBodyElement::OnPause(double dblLocalTime)
{
    base_pause();
    CTIMEElementBase::OnPause(dblLocalTime);
}

void
CTIMEBodyElement::OnResume(double dblLocalTime)
{
    base_resume();
    CTIMEElementBase::OnResume(dblLocalTime);
}

void
CTIMEBodyElement::OnSync(double dbllastTime, double & dblnewTime)
{
    IGNORE_HR(NotifyPropertyChanged(DISPID_TIMEELEMENT_LOCALTIME));
}


HRESULT
CTIMEBodyElement::StartRootTime(MMTimeline * tl)
{
    HRESULT hr;
    
    hr = THR(CTIMEElementBase::StartRootTime(tl));

    if (FAILED(hr))
    {
        goto done;
    }
    
    if (!IsDocumentInEditMode())
    {
        if (!m_player.Play())
        {
            hr = CRGetLastError();
            goto done;
        }
    }
    else
    {
        if (!m_player.Pause())
        {
            hr = CRGetLastError();
            goto done;
        }
    }

    hr = S_OK;
    m_fStartRoot = true;
  done:
    return hr;
}

void
CTIMEBodyElement::StopRootTime(MMTimeline * tl)
{
    m_fStartRoot = false;

    CTIMEElementBase::StopRootTime(tl);
    
    m_player.Stop();
}

HRESULT
CTIMEBodyElement::base_pause()
{
    bool ok = false;
    HRESULT hr;

    if (!m_player.Pause())
    {
        goto done;
    }
    
    hr = THR(CTIMEElementBase::base_pause());

    if (FAILED(hr))
    {
        CRSetLastError(hr, NULL);
        goto done;
    }
    
    ok = true;
  done:
    return ok?S_OK:Error();
}

HRESULT
CTIMEBodyElement::base_resume()
{
    bool ok = false;
    
    m_player.Resume();
    IGNORE_HR(CTIMEElementBase::base_resume());

    ok = true;

    return ok?S_OK:Error();
}

HRESULT
CTIMEBodyElement::get_timeStartRule(LPOLESTR * rule)
{
    HRESULT hr;
    
    CHECK_RETURN_SET_NULL(rule);

    *rule = SysAllocString(TokenToString(m_startRule));

    if (*rule == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto done;
    }
    
    hr = S_OK;
  done:
    return hr;
}

HRESULT
CTIMEBodyElement::put_timeStartRule(LPOLESTR rule)
{
    HRESULT hr;
    TOKEN newrule;

    newrule = StringToToken(rule);
    if (INVALID_TOKEN == newrule)
    {
        return E_INVALIDARG;
    }

    if (m_startRule != newrule)
    {
        m_startRule = newrule;
    }
    
    SetPropertyFlagAndNotify(DISPID_TIMEBODYELEMENT_TIMESTARTRULE, tb_startRule);
    hr = S_OK;
    return hr;
}

STDMETHODIMP
CTIMEBodyElement::addTIMEDAElement(ITIMEDAElement * elm)
{
    bool ok = false;
    
    CTIMEDAElement * daelm;

    daelm = GetDAElementFromInterface(elm);

    if (daelm == NULL)
    {
        goto done;
    }

    if (!daelm->AddToBody(*this))
    {
        goto done;
    }
    
    ok = true;
  done:
    return ok?S_OK:Error();
}

STDMETHODIMP
CTIMEBodyElement::removeTIMEDAElement(ITIMEDAElement * elm)
{
    bool ok = false;
    
    CTIMEDAElement * daelm;

    daelm = GetDAElementFromInterface(elm);

    if (daelm == NULL)
    {
        goto done;
    }

    daelm->RemoveFromBody();
    
    ok = true;
  done:
    return ok?S_OK:Error();
}

HRESULT
CTIMEBodyElement::Error()
{
    LPCWSTR str = CRGetLastErrorString();
    HRESULT hr = CRGetLastError();
    
    if (str)
        return CComCoClass<CTIMEBodyElement, &__uuidof(CTIMEBodyElement)>::Error(str, IID_ITIMEBodyElement, hr);
    else
        return hr;
}

//*****************************************************************************

HRESULT 
CTIMEBodyElement::SetPropertyByIndex(unsigned uIndex, VARIANT *pvarProp)
{
    HRESULT hr = E_FAIL;

    // Rely on the enumeration interval to determine where to look for the property.
    if (teb_maxTIMEElementBaseProp > uIndex)
    {
        hr = CTIMEElementBase::SetPropertyByIndex(uIndex, pvarProp);
    }
    else if (tb_maxTIMEBodyProp > uIndex)
    {
        switch (uIndex)
        {
            case tb_startRule :
                hr = put_timeStartRule(V_BSTR(pvarProp));
                break;
        };
    }

    return hr;
} // SetPropertyByIndex


void CTIMEBodyElement::SetPropertyFlag(DWORD uIndex)
{
    DWORD relIndex;
    if (teb_maxTIMEElementBaseProp > uIndex)
    {
        CTIMEElementBase::SetPropertyFlag(uIndex);
        return;
    }

    relIndex = uIndex - teb_maxTIMEElementBaseProp;
    DWORD bitPosition = 1 << relIndex;
    m_bodyPropertyAccesFlags =  m_bodyPropertyAccesFlags | bitPosition;
}

void CTIMEBodyElement::ClearPropertyFlag(DWORD uIndex)
{
    DWORD relIndex;
    if (teb_maxTIMEElementBaseProp > uIndex)
    {
        CTIMEElementBase::ClearPropertyFlag(uIndex);
        return;
    }

    relIndex = uIndex - teb_maxTIMEElementBaseProp;
    DWORD bitPosition = 1 << relIndex;
    m_bodyPropertyAccesFlags =  m_bodyPropertyAccesFlags & (~bitPosition);
}

bool CTIMEBodyElement::IsPropertySet(DWORD uIndex)
{
    DWORD relIndex;

    if (teb_maxTIMEElementBaseProp > uIndex)
    {
        return CTIMEElementBase::IsPropertySet( uIndex);
    }

    relIndex = uIndex - teb_maxTIMEElementBaseProp;
    if( relIndex >= 32) return true;
    if( relIndex >= tb_maxTIMEBodyProp - teb_maxTIMEElementBaseProp) return true;
    DWORD bitPosition = 1 << relIndex;
    if(m_bodyPropertyAccesFlags & bitPosition)
        return true;
    return false;
}

HRESULT 
CTIMEBodyElement::GetConnectionPoint(REFIID riid, IConnectionPoint **ppICP)
{
    return FindConnectionPoint(riid, ppICP);
} // GetConnectionPoint


//*****************************************************************************

HRESULT 
CTIMEBodyElement::GetPropertyByIndex(unsigned uIndex, VARIANT *pvarProp)
{
    HRESULT hr = E_FAIL;

    // Rely on the enumeration interval to determine where to look for the property.
    if (teb_maxTIMEElementBaseProp > uIndex)
    {
        hr = CTIMEElementBase::GetPropertyByIndex(uIndex, pvarProp);
    }
    else if (tb_maxTIMEBodyProp > uIndex)
    {
        Assert(VT_EMPTY == V_VT(pvarProp));
        switch (uIndex)
        {
            case tb_startRule :
                hr = get_timeStartRule(&(V_BSTR(pvarProp)));
                if (SUCCEEDED(hr) && (NULL != V_BSTR(pvarProp)))
                {
                    V_VT(pvarProp) = VT_BSTR;
                }
                break;
        };
    }

    return hr;
} // GetPropertyByIndex

//*****************************************************************************

HRESULT
CTIMEBodyElement::BuildPropertyNameList(CPtrAry<BSTR> *paryPropNames)
{
    // Start from the base class.
    HRESULT hr = CTIMEElementBase::BuildPropertyNameList(paryPropNames);

    if (SUCCEEDED(hr))
    {
        for (int i = teb_maxTIMEElementBaseProp; 
             (i < tb_maxTIMEBodyProp) && (SUCCEEDED(hr)); i++)
        {
            int iRelative = i - teb_maxTIMEElementBaseProp;
            Assert(NULL != ms_rgwszTBodyPropNames[iRelative]);
            BSTR bstrNewName = CreateTIMEAttrName(ms_rgwszTBodyPropNames[iRelative]);
            Assert(NULL != bstrNewName);
            if (NULL != bstrNewName)
            {
                hr = paryPropNames->Append(bstrNewName);
            }
            else
            {
                hr = E_OUTOFMEMORY;
            }
        }
    }

    return hr;
} // BuildPropertyNameList

//*****************************************************************************

HRESULT 
CTIMEBodyElement::GetPropertyBagInfo(CPtrAry<BSTR> **pparyPropNames)
{
    HRESULT hr = S_OK;

    // If we haven't built this yet, build it now.
    if (0 == ms_aryPropNames.Size())
    {
        hr = BuildPropertyNameList(&(CTIMEBodyElement::ms_aryPropNames));
    }

    if (SUCCEEDED(hr))
    {
        *pparyPropNames = &(CTIMEBodyElement::ms_aryPropNames);
    }

    return hr;
} // GetPropertyBagInfo

//*****************************************************************************

bool
CTIMEBodyElement::IsDocumentStarted()
{
    TraceTag((tagTimeBodyElm, "CTIMEBodyElement::IsDocumentStarted"));
    bool frc = false;
    BSTR bstrState = NULL;
    // get state
    HRESULT hr = GetDocument()->get_readyState(&bstrState);
    if (FAILED(hr))
    {
        TraceTag((tagError, "CTIMEBodyElement::IsDocumentStarted - get_readyState() failed!"));
        goto done;
    }

    Assert(bstrState != NULL);

    if (StrCmpIW(bstrState, L"complete") == 0)
    {
        frc = true;
    }

    SysFreeString(bstrState);

done:
    return frc;
}

#undef THIS
#define THIS CTIMEBodyElement
#define SUPER CTIMEElementBase

#include "pbagimp.cpp"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\time\src\bodyelmevents.cpp ===
///////////////////////////////////////////////////////////////
// Copyright (c) 1998 Microsoft Corporation
//
// File: EventMgr.cpp
//
// Abstract:  
//
///////////////////////////////////////////////////////////////

#include "headers.h"
#include "daview.h"
#include "mshtmdid.h"
#include "tokens.h"
#include "bodyelm.h"
#include "BodyElementEvents.h"

// Suppress new warning about NEW without corresponding DELETE 
// We expect GCs to cleanup values.  Since this could be a useful
// warning, we should disable this on a file by file basis.
#pragma warning( disable : 4291 )  


DeclareTag(tagBodyElementEvents, "API", "Body Element Events methods");


CBodyElementEvents::CBodyElementEvents(CTIMEBodyElement & elm)
: m_elm(elm),
  m_pDocConPt(NULL),
  m_pWndConPt(NULL),
  m_dwDocumentEventConPtCookie(0),
  m_dwWindowEventConPtCookie(0),
  m_refCount(1),
  m_pElement(NULL)
{
    TraceTag((tagBodyElementEvents,
              "CBodyElementEvents(%lx)::CBodyElementEvents(%lx)",
              this,
              &elm));
}

CBodyElementEvents::~CBodyElementEvents()
{
    TraceTag((tagBodyElementEvents,
              "CBodyElementEvents(%lx)::~CBodyElementEvents()",
              this));
}


HRESULT CBodyElementEvents::Init()
{
    HRESULT hr;
      
    m_pElement = m_elm.GetElement();
    m_pElement->AddRef();

    hr = THR(ConnectToContainerConnectionPoint());
    if (FAILED(hr))
    {
        goto done;
    }

  done:
    return hr;
}

HRESULT CBodyElementEvents::Deinit()
{
    if (m_pElement)
    {
        m_pElement->Release();
        m_pElement = NULL;
    }

    if (m_dwDocumentEventConPtCookie != 0 && m_pDocConPt)
    {
        m_pDocConPt->Unadvise (m_dwDocumentEventConPtCookie);
    }
    m_dwDocumentEventConPtCookie = 0;

    if (m_dwWindowEventConPtCookie != 0 && m_pWndConPt)
    {
        m_pWndConPt->Unadvise (m_dwWindowEventConPtCookie);
    }
    m_dwWindowEventConPtCookie = 0;

    
    return S_OK;
}

HRESULT CBodyElementEvents::ConnectToContainerConnectionPoint()
{
// Get a connection point to the container
    DAComPtr<IConnectionPointContainer> pWndCPC;
    DAComPtr<IConnectionPointContainer> pDocCPC; 
    DAComPtr<IHTMLDocument> pDoc; 
    DAComPtr<IDispatch> pDocDispatch;
    DAComPtr<IDispatch> pScriptDispatch;

    HRESULT hr;

    hr = THR(m_pElement->get_document(&pDocDispatch));
    if (FAILED(hr))
    {
        hr = E_FAIL;
        goto done;
    }

    //get the document and cache it.
    hr = THR(pDocDispatch->QueryInterface(IID_IHTMLDocument, (void**)&pDoc));
    if (FAILED(hr))
    {
        hr = E_FAIL;
        goto done;
    }

    //hook the documents events
    hr = THR(pDoc->QueryInterface(IID_IConnectionPointContainer, (void**)&pDocCPC));
    if (FAILED(hr))
    {
        hr = E_FAIL;
        goto done;
    }

    hr = THR(pDocCPC->FindConnectionPoint( DIID_HTMLDocumentEvents, &m_pDocConPt ));
    if (FAILED(hr))
    {
        hr = E_FAIL;
        goto done;
    }

    
    hr = THR(m_pDocConPt->Advise((IUnknown *)this, &m_dwDocumentEventConPtCookie));
    if (FAILED(hr))
    {
        hr = E_FAIL;
        goto done;
    }

    //hook the windows events
    hr = THR(pDoc->get_Script (&pScriptDispatch));
    if (FAILED(hr))
    {
        hr = E_FAIL;
        goto done;
    }

    hr = THR(pScriptDispatch->QueryInterface(IID_IConnectionPointContainer, (void**)&pWndCPC));
    if (FAILED(hr))
    {
        hr = E_FAIL;
        goto done;
    } 

    hr = THR(pWndCPC->FindConnectionPoint( DIID_HTMLWindowEvents, &m_pWndConPt ));
    if (FAILED(hr))
    {
        hr = E_FAIL;
        goto done;
    }

    hr = THR(m_pWndConPt->Advise((IUnknown *)this, &m_dwWindowEventConPtCookie));
    if (FAILED(hr))
    {
        hr = E_FAIL;
        goto done;
    }

    hr = S_OK;
  done:
    return hr;    
}


//IDispatch Methods
STDMETHODIMP CBodyElementEvents::QueryInterface( REFIID riid, void **ppv )
{
    if (NULL == ppv)
        return E_POINTER;

    *ppv = NULL;

    if ( InlineIsEqualGUID(riid, IID_IDispatch))
    {
        *ppv = this;
    }
        
    if ( NULL != *ppv )
    {
        ((LPUNKNOWN)*ppv)->AddRef();
        return NOERROR;
    }
    return E_NOINTERFACE;
}

STDMETHODIMP_(ULONG) CBodyElementEvents::AddRef(void)
{
    return ++m_refCount;
}


STDMETHODIMP_(ULONG) CBodyElementEvents::Release(void)
{
    m_refCount--;
    if (m_refCount == 0)
    {
        //delete this;
    }

    return m_refCount;
}

STDMETHODIMP CBodyElementEvents::GetTypeInfoCount(UINT* /*pctinfo*/)
{
    return E_NOTIMPL;
}

STDMETHODIMP CBodyElementEvents::GetTypeInfo(/* [in] */ UINT /*iTInfo*/,
                                   /* [in] */ LCID /*lcid*/,
                                   /* [out] */ ITypeInfo** /*ppTInfo*/)
{
    return E_NOTIMPL;
}

STDMETHODIMP CBodyElementEvents::GetIDsOfNames(
    /* [in] */ REFIID /*riid*/,
    /* [size_is][in] */ LPOLESTR* /*rgszNames*/,
    /* [in] */ UINT /*cNames*/,
    /* [in] */ LCID /*lcid*/,
    /* [size_is][out] */ DISPID* /*rgDispId*/)
{
    return E_NOTIMPL;
}

STDMETHODIMP CBodyElementEvents::Invoke(
    /* [in] */ DISPID dispIdMember,
    /* [in] */ REFIID /*riid*/,
    /* [in] */ LCID /*lcid*/,
    /* [in] */ WORD /*wFlags*/,
    /* [out][in] */ DISPPARAMS* pDispParams,
    /* [out] */ VARIANT* pVarResult,
    /* [out] */ EXCEPINFO* /*pExcepInfo*/,
    /* [out] */ UINT* puArgErr)
{
    // Listen for the two events we're interested in, and call back if necessary
    HRESULT hr = S_OK;

    switch (dispIdMember)
    {
        case DISPID_EVPROP_ONREADYSTATECHANGE:
        case DISPID_EVMETH_ONREADYSTATECHANGE:
            IGNORE_HR(ReadyStateChange());
            break;

        case DISPID_EVPROP_ONLOAD:
        case DISPID_EVMETH_ONLOAD:
            m_elm.OnLoad();
            break;

        case DISPID_EVPROP_ONUNLOAD:
        case DISPID_EVMETH_ONUNLOAD:
            m_elm.OnUnload();    
            break;
    }
    
  done:
    return S_OK;
}


HRESULT CBodyElementEvents::ReadyStateChange()
{   
    HRESULT hr;
    DAComPtr <IHTMLElement2> pElement2;
    VARIANT vReadyState;

    TOKEN tokReadyState = INVALID_TOKEN; 

    hr = THR(m_pElement->QueryInterface(IID_IHTMLElement2, (void **)&pElement2));
    if (FAILED (hr))
    {
        goto done;
    }

    hr = THR(pElement2->get_readyState(&vReadyState));
    if (FAILED (hr))
    {
        goto done;
    }

    if (vReadyState.vt != VT_BSTR)
    {
        hr = THR(VariantChangeType(&vReadyState, &vReadyState, 0, VT_BSTR));
        if (FAILED(hr))
        {
            VariantClear(&vReadyState)         ;
            goto done;
        }
    }

    tokReadyState = StringToToken(vReadyState.bstrVal);

    if (tokReadyState != INVALID_TOKEN)
    {
        m_elm.OnReadyStateChange(tokReadyState);
    }

    SysFreeString (vReadyState.bstrVal);
    VariantClear(&vReadyState);

  done:
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\time\src\bodyelmevents.h ===
///////////////////////////////////////////////////////////////
// Copyright (c) 1998 Microsoft Corporation
//
// File: BodyElementEvents.h
//
// Abstract:
//
///////////////////////////////////////////////////////////////

#ifndef _BODYELEMENTEVENTS_H
#define _BODYELEMENTEVENTS_H

class CTIMEBodyElement;

class CBodyElementEvents
    : public IDispatch
{
  public:
    CBodyElementEvents(CTIMEBodyElement  & elm);
    ~CBodyElementEvents();

    //methods
    HRESULT Init();
    HRESULT Deinit();

    //QueryInterface 
    STDMETHODIMP QueryInterface(REFIID, void **);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

    //IDispatch
    STDMETHODIMP GetTypeInfoCount(UINT* pctinfo);
    STDMETHODIMP GetTypeInfo(/* [in] */ UINT iTInfo,
                             /* [in] */ LCID lcid,
                             /* [out] */ ITypeInfo** ppTInfo);
    STDMETHODIMP GetIDsOfNames(
        /* [in] */ REFIID riid,
        /* [size_is][in] */ LPOLESTR *rgszNames,
        /* [in] */ UINT cNames,
        /* [in] */ LCID lcid,
        /* [size_is][out] */ DISPID *rgDispId);
    STDMETHODIMP Invoke(
        /* [in] */ DISPID dispIdMember,
        /* [in] */ REFIID riid,
        /* [in] */ LCID lcid,
        /* [in] */ WORD wFlags,
        /* [out][in] */ DISPPARAMS  *pDispParams,
        /* [out] */ VARIANT  *pVarResult,
        /* [out] */ EXCEPINFO *pExcepInfo,
        /* [out] */ UINT *puArgErr);


  protected:
    CTIMEBodyElement &                m_elm;
    DAComPtr<IHTMLElement>            m_pElement;
    DAComPtr<IConnectionPoint>        m_pDocConPt;
    DAComPtr<IConnectionPoint>        m_pWndConPt;
    DWORD                             m_dwDocumentEventConPtCookie;
    DWORD                             m_dwWindowEventConPtCookie;
    long                              m_refCount;   
    
    HRESULT                           ConnectToContainerConnectionPoint();
    HRESULT                           ReadyStateChange();
};

#endif /* _BODYELEMENTEVENTS_H*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\time\src\bodyelm.h ===
/*******************************************************************************
 *
 * Copyright (c) 1998 Microsoft Corporation
 *
 * File: bodyelm.h
 *
 * Abstract:
 *
 *
 *
 *******************************************************************************/


#ifndef _BODYELM_H
#define _BODYELM_H

#include "timeelmbase.h"
#include "mmutil.h"

/////////////////////////////////////////////////////////////////////////////
// CTIMEBodyElement

#define DEFAULT_SYNC_TOLERANCE_S 0.2f

class
ATL_NO_VTABLE
__declspec(uuid("efbad7f8-3f94-11d2-b948-00c04fa32195")) 
CTIMEBodyElement :
    public CTIMEElementBase,
    public CComCoClass<CTIMEBodyElement, &__uuidof(CTIMEBodyElement)>,
    public IDispatchImpl<ITIMEBodyElement, &IID_ITIMEBodyElement, &LIBID_TIME>,
    public ISupportErrorInfoImpl<&IID_ITIMEBodyElement>,
    public IConnectionPointContainerImpl<CTIMEBodyElement>,
    public IPersistPropertyBag2,
    public IPropertyNotifySinkCP<CTIMEBodyElement>
{
    public:
        CTIMEBodyElement();
        ~CTIMEBodyElement();
    
#if _DEBUG
        const _TCHAR * GetName() { return __T("CTIMEBodyElement"); }
#endif

        STDMETHOD_(ULONG,AddRef)(void) = 0;
        STDMETHOD_(ULONG,Release)(void) = 0;
        STDMETHOD(QueryInterface)(REFIID iid, void ** ppvObject) = 0;

        STDMETHOD(Init)(IElementBehaviorSite * pBvrSite);
        STDMETHOD(Detach)();

        virtual HRESULT InitTimeline(void);

        virtual void OnReadyStateChange(TOKEN state);
        virtual void OnLoad();
        virtual void OnPause(double dblLocalTime);
        virtual void OnResume(double dblLocalTime);
        virtual void OnSync(double dbllastTime, double & dblnewTime);

        virtual HRESULT base_pause();
        virtual HRESULT base_resume();

        //
        //IPersistPropertyBag2
        // 
        STDMETHOD(GetClassID)(CLSID* pclsid);
        STDMETHOD(InitNew)(void);
        STDMETHOD(IsDirty)(void)
            {return S_OK;};
        STDMETHOD(Load)(IPropertyBag2 *pPropBag,IErrorLog *pErrorLog);
        STDMETHOD(Save)(IPropertyBag2 *pPropBag, BOOL fClearDirty, BOOL fSaveAllProperties);

        //
        // ITIMEElement
        //
    
        STDMETHOD(get_begin)(VARIANT * time)
        { return base_get_begin(time); }
        STDMETHOD(put_begin)(VARIANT time)
        { return base_put_begin(time); }

        STDMETHOD(get_beginWith)(VARIANT * time)
        { return base_get_beginWith(time); }
        STDMETHOD(put_beginWith)(VARIANT time)
        { return base_put_beginWith(time); }

        STDMETHOD(get_beginAfter)(VARIANT * time)
        { return base_get_beginAfter(time); }
        STDMETHOD(put_beginAfter)(VARIANT time)
        { return base_put_beginAfter(time); }

        STDMETHOD(get_beginEvent)(VARIANT * time)
        { return base_get_beginEvent(time); }
        STDMETHOD(put_beginEvent)(VARIANT time)
        { return base_put_beginEvent(time); }

        STDMETHOD(get_dur)(VARIANT * time)
        { return base_get_dur(time); }
        STDMETHOD(put_dur)(VARIANT time)
        { return base_put_dur(time); }

        STDMETHOD(get_end)(VARIANT * time)
        { return base_get_end(time); }
        STDMETHOD(put_end)(VARIANT time)
        { return base_put_end(time); }

        STDMETHOD(get_endWith)(VARIANT * time)
        { return base_get_endWith(time); }
        STDMETHOD(put_endWith)(VARIANT time)
        { return base_put_endWith(time); }

        STDMETHOD(get_endEvent)(VARIANT * time)
        { return base_get_endEvent(time); }
        STDMETHOD(put_endEvent)(VARIANT time)
        { return base_put_endEvent(time); }

        STDMETHOD(get_endSync)(VARIANT * time)
        { return base_get_endSync(time); }
        STDMETHOD(put_endSync)(VARIANT time)
        { return base_put_endSync(time); }

        STDMETHOD(get_repeat)(VARIANT * time)
        { return base_get_repeat(time); }
        STDMETHOD(put_repeat)(VARIANT time)
        { return base_put_repeat(time); }

        STDMETHOD(get_repeatDur)(VARIANT * time)
        { return base_get_repeatDur(time); }
        STDMETHOD(put_repeatDur)(VARIANT time)
        { return base_put_repeatDur(time); }

        STDMETHOD(get_accelerate)(int * time)
        { return base_get_accelerate(time); }
        STDMETHOD(put_accelerate)(int time)
        { return base_put_accelerate(time); }

        STDMETHOD(get_decelerate)(int  * time)
        { return base_get_decelerate(time); }
        STDMETHOD(put_decelerate)(int time)
        { return base_put_decelerate(time); }

        STDMETHOD(get_autoReverse)(VARIANT_BOOL * b)
        { return base_get_autoReverse(b); }
        STDMETHOD(put_autoReverse)(VARIANT_BOOL b)
        { return base_put_autoReverse(b); }

        STDMETHOD(get_endHold)(VARIANT_BOOL * b)
        { return base_get_endHold(b); }
        STDMETHOD(put_endHold)(VARIANT_BOOL b)
        { return base_put_endHold(b); }

        STDMETHOD(get_eventRestart)(VARIANT_BOOL * b)
        { return base_get_eventRestart(b); }
        STDMETHOD(put_eventRestart)(VARIANT_BOOL b)
        { return base_put_eventRestart(b); }

        STDMETHOD(get_timeAction)(LPOLESTR * time)
        { return base_get_timeAction(time); }
        STDMETHOD(put_timeAction)(LPOLESTR time)
        { return base_put_timeAction(time); }

        STDMETHOD(beginElement)()
        { return base_beginElement(true); }
        STDMETHOD(endElement)()
        { return base_endElement(); }
        STDMETHOD(pause)()
        { return base_pause(); }
        STDMETHOD(resume)()
        { return base_resume(); }
        STDMETHOD(cue)()
        { return base_cue(); }

        STDMETHOD(get_timeline)(BSTR * pbstrTimeLine)
        { return base_get_timeline(pbstrTimeLine); }
        STDMETHOD(put_timeline)(BSTR bstrTimeLine)
        { return base_put_timeline(bstrTimeLine); }

        STDMETHOD(get_currTime)(float * time)
        { return base_get_currTime(time); }
        STDMETHOD(put_currTime)(float time)
        { return base_put_currTime(time); }

        STDMETHOD(get_localTime)(float * time)
        { return base_get_localTime(time); }
        STDMETHOD(put_localTime)(float time)
        { return base_put_localTime(time); }

        STDMETHOD(get_currState)(LPOLESTR * state)
        { return base_get_currState(state); }
        STDMETHOD(put_currState)(LPOLESTR state)
        { return base_put_currState(state); }

        STDMETHOD(get_syncBehavior)(LPOLESTR * sync)
        { return base_get_syncBehavior(sync); }
        STDMETHOD(put_syncBehavior)(LPOLESTR sync)
        { return base_put_syncBehavior(sync); }

        STDMETHOD(get_syncTolerance)(VARIANT * tol)
        { return base_get_syncTolerance(tol); }
        STDMETHOD(put_syncTolerance)(VARIANT tol)
        { return base_put_syncTolerance(tol); }

        STDMETHOD(get_parentTIMEElement)(ITIMEElement **bvr)
        { return base_get_parentTIMEElement(bvr); }
        STDMETHOD(put_parentTIMEElement)(ITIMEElement *bvr)
        { return base_put_parentTIMEElement(bvr); }

        STDMETHOD(get_allTIMEElements)(/*[out, retval]*/ ITIMEElementCollection **ppDisp);
        STDMETHOD(get_childrenTIMEElements)(/*[out, retval]*/ ITIMEElementCollection **ppDisp);
        STDMETHOD(get_allTIMEInterfaces)(/*[out, retval]*/ ITIMEElementCollection **ppDisp);
        STDMETHOD(get_childrenTIMEInterfaces)(/*[out, retval]*/ ITIMEElementCollection **ppDisp);

        STDMETHOD(get_timelineBehavior)(IDispatch ** bvr)
        { return base_get_timelineBehavior(bvr); }
        STDMETHOD(get_progressBehavior)(IDispatch ** bvr)
        { return base_get_progressBehavior(bvr); }
        STDMETHOD(get_onOffBehavior)(IDispatch ** bvr)
        { return base_get_onOffBehavior(bvr); }

        //
        // ITIMEBodyElement
        //
    
        STDMETHOD(get_timeStartRule)(LPOLESTR * startrule);
        STDMETHOD(put_timeStartRule)(LPOLESTR startrule);

        STDMETHOD(addTIMEDAElement)(ITIMEDAElement * daelm);
        STDMETHOD(removeTIMEDAElement)(ITIMEDAElement * daelm);

        // QI Map
    
        BEGIN_COM_MAP(CTIMEBodyElement)
            COM_INTERFACE_ENTRY(ITIMEBodyElement)
            COM_INTERFACE_ENTRY(ITIMEElement)
            COM_INTERFACE_ENTRY(IDispatch)
            COM_INTERFACE_ENTRY(ISupportErrorInfo)
            COM_INTERFACE_ENTRY_IMPL(IConnectionPointContainer)
            COM_INTERFACE_ENTRY(IPersistPropertyBag2)
            COM_INTERFACE_ENTRY_CHAIN(CBaseBvr)
        END_COM_MAP();

        // Connection Point to allow IPropertyNotifySink
        BEGIN_CONNECTION_POINT_MAP(CTIMEBodyElement)
            CONNECTION_POINT_ENTRY(IID_IPropertyNotifySink)
        END_CONNECTION_POINT_MAP();

        // This must be in the derived class and not the base class since
        // the typecast down to the base class messes things up
        static inline HRESULT WINAPI
            InternalQueryInterface(CTIMEBodyElement* pThis,
                                   const _ATL_INTMAP_ENTRY* pEntries,
                                   REFIID iid,
                                   void** ppvObject)
        { return BaseInternalQueryInterface(pThis,
                                            (void *) pThis,
                                            pEntries,
                                            iid,
                                            ppvObject); }

        // Needed by CBvrBase
    
        void * GetInstance()
        { return (ITIMEBodyElement *) this ; }
        HRESULT GetTypeInfo(ITypeInfo ** ppInfo)
        { return GetTI(GetUserDefaultLCID(), ppInfo); }
    
        MMPlayer & GetPlayer()
        { return m_player; }

        virtual bool IsGroup() { return true; }
        virtual bool IsBody() { return true; }
  
        float    GetDefaultSyncTolerance()
        { return DEFAULT_SYNC_TOLERANCE_S; }
        TOKEN    GetDefaultSyncBehavior()
        { return CANSLIP_TOKEN; }

        bool IsDocumentStarted();
        bool IsRootStarted() { return m_fStartRoot; }

    protected:
        HRESULT Error();
    
        virtual HRESULT StartRootTime(MMTimeline * tl);
        virtual void StopRootTime(MMTimeline * tl);

        enum PROPERTY_INDEX
        {
            tb_startRule = teb_maxTIMEElementBaseProp, 
            tb_maxTIMEBodyProp,
        };

        virtual HRESULT BuildPropertyNameList (CPtrAry<BSTR> *paryPropNames);
        virtual HRESULT SetPropertyByIndex(unsigned uIndex, VARIANT *pvarProp);
        virtual HRESULT GetPropertyByIndex(unsigned uIndex, VARIANT *pvarProp);
        virtual void SetPropertyFlag(DWORD uIndex);
        virtual void ClearPropertyFlag(DWORD uIndex);
        virtual bool IsPropertySet(DWORD uIndex);
        virtual HRESULT GetConnectionPoint(REFIID riid, IConnectionPoint **ppICP);
        virtual bool NeedSyncCB() { return true;}

    protected:
        TOKEN           m_startRule;
        MMPlayer        m_player;

        HRESULT GetPropertyBagInfo(CPtrAry<BSTR> **pparyPropNames);

        static LPWSTR ms_rgwszTBodyPropNames[];
        static CPtrAry<BSTR> ms_aryPropNames;
        static DWORD ms_dwNumBodyElems;
        DWORD m_bodyPropertyAccesFlags;
    private:
        bool    m_fStartRoot;
};

inline HRESULT CTIMEBodyElement::get_allTIMEElements(ITIMEElementCollection **ppDisp)
{
    return base_get_collection(ciAllElements, ppDisp);
} // get_all

inline HRESULT CTIMEBodyElement::get_childrenTIMEElements(ITIMEElementCollection **ppDisp)
{
    return base_get_collection(ciChildrenElements, ppDisp);
} // get_children

inline HRESULT CTIMEBodyElement::get_allTIMEInterfaces(ITIMEElementCollection **ppDisp)
{
    return base_get_collection(ciAllInterfaces, ppDisp);
} // get_time_all

inline HRESULT CTIMEBodyElement::get_childrenTIMEInterfaces(ITIMEElementCollection **ppDisp)
{
    return base_get_collection(ciChildrenInterfaces, ppDisp);
} // get_time_children

#endif /* _BODYELM_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\time\src\clock.cpp ===
/*******************************************************************************
 *
 * Copyright (c) 1998 Microsoft Corporation
 *
 * File: clock.cpp
 *
 * Abstract:
 *
 *
 *
 *******************************************************************************/


#include "headers.h"
#include "clock.h"

static LPCTSTR s_rgtchStarvationWindowClassName = _T("StarveTimer");
static LPCTSTR s_rgtchStarvationWindowName = _T("");

static const ULONG s_ulStarveCallbackInterval = 100;
static const ULONG s_ulStarvationThreshold = 3 * s_ulStarveCallbackInterval / 2;
static const ULONG s_ulStarvationFirstBackoffConstant = 2;
static const ULONG s_ulStarvationNBackoffConstant = 5;

DeclareTag(tagClock, "API", "Clock methods");

Clock::Clock()
: m_ulRefs(1),
  m_cookie(0),
  m_lastTime(0.0),
  m_curTime(0.0),
  m_ulLastStarvationCallback(0),
  m_uStarveTimerID(0),
  m_hWndStarveTimer(NULL),
  m_ulConsectiveStarvedTicks(0),
  m_fAllowOnTimer(true),
  m_fAllowStarvationCallback(true),
  m_state(CS_STOPPED)
{
    TraceTag((tagClock,
              "Clock(%lx)::Clock()",
              this));
}

Clock::~Clock()
{
    TraceTag((tagClock,
              "Clock(%lx)::~Clock()",
              this));

    Stop();

    if (NULL != m_hWndStarveTimer)
    {
        ::DestroyWindow(m_hWndStarveTimer);
    }
}

STDMETHODIMP
Clock::QueryInterface(REFIID riid, LPVOID * ppv)
{
    HRESULT hr = E_POINTER;

    if (ppv != NULL)
    {
        hr = E_NOINTERFACE;
        
        if (::IsEqualIID(riid, IID_ITimerSink) ||
            ::IsEqualIID(riid, IID_IUnknown))
        {
            *ppv = (ITimerSink *)this;
            AddRef();
            hr  = S_OK;
        }
    }

    return hr;
}

STDMETHODIMP_(ULONG)
Clock::AddRef(void)
{
    return ++m_ulRefs;
}

STDMETHODIMP_(ULONG)
Clock::Release(void)
{
    if (--m_ulRefs == 0)
    {
        delete this;
        return 0;
    }

    return m_ulRefs;
}

ULONG
Clock::GetNextInterval (void)
{
    ULONG ulInterval = m_interval;

    // If this is our first time through, 
    // we'll use the interval without question
    if (0 != m_ulLastStarvationCallback)
    {
        // How long since our last starvation callback?
        Assert(m_timer);
        if (m_timer)
        {
            CComVariant v;
            HRESULT hr = THR(m_timer->GetTime(&v));

            if (SUCCEEDED(hr))
            {
                // Have we hit the starvation threshold?  Also allow for the unlikely clock rollover.
                ULONG ulTimeSinceLastStarvationCallback = V_UI4(&v) - m_ulLastStarvationCallback;

                if ((m_ulLastStarvationCallback > V_UI4(&v)) ||
                    (ulTimeSinceLastStarvationCallback > s_ulStarvationThreshold))
                {
                    // If we're starving more than once, then back off more.
                    if (0 == m_ulConsectiveStarvedTicks)
                    {
                        ulInterval *= s_ulStarvationFirstBackoffConstant;
                    }
                    else
                    {
                        ulInterval *= s_ulStarvationNBackoffConstant;
                    }
                    m_ulConsectiveStarvedTicks++;
                }
                // Make sure to clear the starved tick count.
                else if (0 != m_ulConsectiveStarvedTicks)
                {
                    m_ulConsectiveStarvedTicks = 0;
                }
            }
        }
    }

    return ulInterval;
} // GetNextInterval

STDMETHODIMP
Clock::OnTimer(VARIANT timeAdvise)
{
    HRESULT hr = S_OK;

    // We have to protect ourselves against 
    // advise sink reentrancy.
    if (m_fAllowOnTimer)
    {
        m_fAllowOnTimer = false;
        // The 'cookie' expires as soon as this
        // callback occurs.
        m_cookie = 0;
        ProcessCB(GetITimerTime());
        // Adjust the new interval based on 
        // current load.
        hr = SetNextTimerInterval(GetNextInterval());
        m_fAllowOnTimer = true;
    }

    return hr;
}

HRESULT
Clock::SetITimer(IServiceProvider * serviceProvider, ULONG interval)
{
    HRESULT hr;

    DAComPtr<ITimerService> pTimerService;

    m_timer.Release();
    m_interval = interval;
    
    if (!serviceProvider)
    {
        return E_FAIL;
    }
    
    hr = serviceProvider->QueryService(SID_STimerService,
                                       IID_ITimerService,
                                       (void**)&pTimerService);
    if (FAILED(hr))
    {
        goto done;
    }

    hr = pTimerService->GetNamedTimer(NAMEDTIMER_DRAW, &m_timer);

    if (FAILED(hr))
    {
        goto done;
    }

    hr = S_OK;
  done:
    return hr;
}

double
Clock::GetITimerTime()
{
    Assert(m_timer);
    
    CComVariant v;
    
    HRESULT hr = THR(m_timer->GetTime(&v));

    Assert(SUCCEEDED(hr));

    hr = THR(v.ChangeType(VT_R8));

    Assert(SUCCEEDED(hr));
    
    return (V_R8(&v) / 1000.0);
}

void
Clock::CreateStarveTimerWindow (void)
{
    Assert(NULL == m_hWndStarveTimer);
    if (NULL == m_hWndStarveTimer)
    {
        WNDCLASS wndclass;
        memset(&wndclass, 0, sizeof(wndclass));
        wndclass.style         = 0;
        wndclass.lpfnWndProc   = Clock::StarveWndProc;
        wndclass.hInstance     = _Module.GetModuleInstance();
        wndclass.hCursor       = NULL;
        wndclass.hbrBackground = NULL;
        wndclass.lpszClassName = s_rgtchStarvationWindowClassName;
        ::RegisterClass(&wndclass);
        
        m_hWndStarveTimer = ::CreateWindowEx(
            WS_EX_TOOLWINDOW,
            s_rgtchStarvationWindowClassName,
            s_rgtchStarvationWindowName,
            WS_POPUP,
            0, 0, 0, 0,
            NULL,
            NULL,
            wndclass.hInstance,
            (LPVOID)NULL);
        if (NULL != m_hWndStarveTimer)
        {
            ::SetWindowLongPtr(m_hWndStarveTimer, GWLP_USERDATA, (LONG_PTR)this);
        }
    }
} // CreateStarveTimerWindow

void
Clock::SetStarveTimer (void)
{
    // Create the window on demand.
    if (NULL == m_hWndStarveTimer)
    {
        CreateStarveTimerWindow();
    }

    Assert(NULL != m_hWndStarveTimer);
    if (NULL != m_hWndStarveTimer)
    {
        // Make sure to roll past zero.
        if (0 == (++m_uStarveTimerID))
        {
            ++m_uStarveTimerID;
        }
        UINT uRes = ::SetTimer(m_hWndStarveTimer, m_uStarveTimerID, s_ulStarveCallbackInterval, NULL);
        Assert(uRes);
    }
} // SetStarveTimer

HRESULT
Clock::StartITimer()
{
    // This initializes starvation timer as well 
    // as the last-callback-time data, giving us a baseline 
    // from which to judge starvation at startup.
    StarvationCallback();

    return SetNextTimerInterval(m_interval);
} // StartITimer

HRESULT
Clock::SetNextTimerInterval (ULONG ulNextInterval)
{
    HRESULT hr = S_OK;
    
    // Next, get the current time and with the interval set
    // the timer to advise us again.
    VARIANT vtimeMin, vtimeMax, vtimeInt;

    VariantInit( &vtimeMin );
    VariantInit( &vtimeMax );
    VariantInit( &vtimeInt );
    V_VT(&vtimeMin) = VT_UI4;
    V_VT(&vtimeMax) = VT_UI4;
    V_VT(&vtimeInt) = VT_UI4;
    V_UI4(&vtimeMax) = 0;
    V_UI4(&vtimeInt) = 0;
    hr = THR(m_timer->GetTime(&vtimeMin));
    
    if (FAILED(hr))
    {
        goto done;
    }

    V_UI4(&vtimeMin) += ulNextInterval;

    hr = THR(m_timer->Advise(vtimeMin,
                             vtimeMax,
                             vtimeInt,
                             0,
                             this,
                             &m_cookie));

    if (FAILED(hr))
    {
        goto done;
    }

    if (!m_cookie)
    {
        TraceTag((tagError,
                  "Clock::ITimer::Advise failed with bad cookie"));
        hr = E_FAIL;
        goto done;
    }

    hr = S_OK;
    
  done:
    return hr;
} // SetNextTimerInterval

HRESULT
Clock::StopITimer()
{
    HRESULT hr = S_OK;
    
    if (m_timer && m_cookie)
    {
        hr = THR(m_timer->Unadvise(m_cookie));

        m_cookie = 0;
    }

    // Stop the starvation timer and 
    // reset the last starvation callback time.
    if (0 != m_uStarveTimerID)
    {
        ::KillTimer(m_hWndStarveTimer, m_uStarveTimerID);
        m_uStarveTimerID = 0;
    }
    m_ulLastStarvationCallback = 0;

    return hr;
}

HRESULT
Clock::Start()
{
    HRESULT hr;
    
    Stop();

    if (!m_timer)
    {
        hr = E_FAIL;
        goto done;
    }
    
    hr = THR(StartITimer());

    if (FAILED(hr))
    {
        goto done;
    }

    m_curTime = 0.0;
    m_lastTime = GetGlobalTime();
    m_state = CS_STARTED;
    
    hr = S_OK;
  done:
    return hr;
}

HRESULT
Clock::Pause()
{
    HRESULT hr;

    if (m_state == CS_PAUSED)
    {
        hr = S_OK;
        goto done;
    }

    if (m_state == CS_STARTED)
    {
        hr = THR(StopITimer());

        if (FAILED(hr))
        {
            goto done;
        }
    }
    
    m_state = CS_PAUSED;
    hr = S_OK;
    
  done:
    return hr;
}

HRESULT
Clock::Resume()
{
    HRESULT hr;

    if (m_state == CS_STARTED)
    {
        hr = S_OK;
        goto done;
    }

    if (m_state == CS_STOPPED)
    {
        hr = THR(Start());
        goto done;
    }
    
    Assert(m_state == CS_PAUSED);

    hr = THR(StartITimer());

    if (FAILED(hr))
    {
        goto done;
    }
    
    m_lastTime = GetGlobalTime();
    m_state = CS_STARTED;
    
    hr = S_OK;
    
  done:
    return hr;
}

HRESULT
Clock::Stop()
{
    THR(StopITimer());
    m_state = CS_STOPPED;
    return S_OK;
}

void
Clock::ProcessCB(double time)
{
    if (m_state == CS_STARTED)
    {
        if (time > m_lastTime)
        {
            m_curTime += (time - m_lastTime);
            m_lastTime = time;

            if (m_pClockSink)
            {
                m_pClockSink->OnTimer(m_curTime);
            }
        }
    }
}

void
Clock::StarvationCallback (void)
{
    if (m_fAllowStarvationCallback)
    {
        m_fAllowStarvationCallback = false;
        Assert(m_timer);
        if (m_timer)
        {
            CComVariant v;
            HRESULT hr = THR(m_timer->GetTime(&v));
            if (SUCCEEDED(hr))
            {
                m_ulLastStarvationCallback = V_UI4(&v);
            }
        }
        ::KillTimer(m_hWndStarveTimer, m_uStarveTimerID);
        SetStarveTimer();
        m_fAllowStarvationCallback = true;
    }
} // StarvationCallback 

LRESULT __stdcall 
Clock::StarveWndProc(HWND hWnd, UINT uiMessage, WPARAM wParam, LPARAM lParam)
{
    LRESULT lResult = 0;

    if (uiMessage == WM_TIMER)
    {
        Clock *pThis = reinterpret_cast<Clock *>(::GetWindowLongPtr(hWnd, GWLP_USERDATA));

        if (NULL != pThis)
        {
            pThis->StarvationCallback();
        }
    }

    lResult = ::DefWindowProc(hWnd, uiMessage, wParam, lParam);

    return lResult;
} // StarveWndProc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\time\src\collect.h ===
#ifndef __COLLECT_H_
#define __COLLECT_H_

//************************************************************
//
// Filename:    collect.h
//
// Created:     09/25/97
//
// Author:	twillie
//
// Abstract:    Collection implementation.
//              
//************************************************************

#include "dispex.h"
#include "atomtable.h"
#include "array.h"
#include "timeelmbase.h"
#include "datimeid.h"


#define NOT_DEPENDENT_COLLECTION   -1
#define CTL_E_METHODNOTAPPLICABLE  STD_CTL_SCODE(444)

//
// A class for declaring poiners to member functions
//
class CVoid
{
}; // CVoid

//
// prototype macros for function over rides
// These are used when owner of collection wants to customize it.
//
typedef HRESULT (STDMETHODCALLTYPE CVoid::*PFN_CVOID_ENSURE)(long *plVersionCookie);

typedef HRESULT (STDMETHODCALLTYPE CVoid::*PFN_CVOID_CREATECOL)(IDispatch **pDisp,
                                                      long        lIndex);

typedef HRESULT (STDMETHODCALLTYPE CVoid::*PFN_CVOID_REMOVEOBJECT)(long lCollection,
                                                         long lIndex);
typedef HRESULT (STDMETHODCALLTYPE CVoid::*PFN_CVOID_ADDNEWOBJECT)(long       lIndex, 
                                                         IDispatch *pObject, 
                                                         long       index);

typedef enum COLLECTIONCACHETYPE
{
    ctFreeEntry,
    ctNamed,
    ctTag,
    ctAll,
    ctChildren,
}; // COLLECTIONCACHETYPE

//
// CCollectionCache
//
class CCollectionCache
{
    class CCacheItem
    {
    public:
        CCacheItem() :
            m_pDisp(NULL),
            m_rgElem(NULL),
            m_cctype(ctFreeEntry),
            m_bstrName(NULL),
            m_lDependentIndex(NOT_DEPENDENT_COLLECTION),
            m_dispidMin(DISPID_COLLECTION_RESERVED_MIN),
            m_dispidMax(DISPID_COLLECTION_RESERVED_MAX),
            m_fInvalid(true),
            m_fIdentity(false),
            m_fOKToDelete(true),
            m_fNeedRebuild(false),
            m_fPromoteNames(true),
            m_fPromoteOrdinals(true),
            m_fGetLastCollectionItem(false),
            m_fIsCaseSensitive(false),
            m_fSettableNULL(false),
            m_fReturnHTMLInterface(false)
        {
        } // constructor

        virtual ~CCacheItem()
        {
            if (m_rgElem)
            {
                delete m_rgElem;
                m_rgElem = NULL;
            }

            if (m_pDisp)
                ReleaseInterface(m_pDisp);

            if (m_bstrName)
                SysFreeString(m_bstrName);
        } // destructor

        IDispatch                   *m_pDisp;           // IDispatch for ICrElementCollection
        CPtrAry<CTIMEElementBase *> *m_rgElem;          // array of elements in collection
        COLLECTIONCACHETYPE          m_cctype;          // cache type
        BSTR                         m_bstrName;        // Name if name-based
        long                         m_lDependentIndex; // Index of item that this depends.
        DISPID                       m_dispidMin;       // Offset to add/subtract
        DISPID                       m_dispidMax;       // Offset to add/subtract

        // bit flags
        int  m_fInvalid:1;      // set for named collections only
        int  m_fIdentity:1;     // set when a collection is Identity with its container/base object
        int  m_fOKToDelete:1;   // true for collections that the cache cooks up false when Base Obj provided this CPtrAry
        int  m_fNeedRebuild:1;  // true is collection need to be rebuilt.
        int  m_fPromoteNames:1;    // true if we promote names from the object
        int  m_fPromoteOrdinals:1; // true if we promote ordinals from the object
        int  m_fGetLastCollectionItem:1; // true to fetch last item only in collection
        int  m_fIsCaseSensitive:1;       // true if item's name must be compared in case sensitive manner
        int  m_fSettableNULL:1;          // true when collection[n]=NULL is valid. normally false.

        int  m_fReturnHTMLInterface:1;   // true when we need to return IHTMLInterface instead of ITIMEElement
    }; // CCacheItem

public:
    //
    // Constructor/Destructor
    //    
    CCollectionCache(CTIMEElementBase *pBase,
                     CAtomTable *pAtomTable = NULL,
                     PFN_CVOID_ENSURE pfnEnsure = NULL,
                     PFN_CVOID_CREATECOL pfnCreation = NULL,
                     PFN_CVOID_REMOVEOBJECT pfnRemove = NULL,
                     PFN_CVOID_ADDNEWOBJECT pfnAddNewObject = NULL);
    virtual ~CCollectionCache();

    //
    // internal methods
    //
    HRESULT Init(long lReservedSize, long lIdentityIndex = -1);
    HRESULT GetCollectionDisp(long lCollectionIndex, IDispatch **ppDisp);
    HRESULT SetCollectionType(long lCollectionIndex, COLLECTIONCACHETYPE cctype, bool fReturnHTMLInterface = false);
    long Size(long lCollectionIndex);
    HRESULT GetItem(long lCollectionIndex, long i, CTIMEElementBase **ppElem);
    void Invalidate();
    void BumpVersion();

    //
    // IDispatchEx methods
    //
    HRESULT GetDispID(long lCollectionIndex, BSTR bstrName, DWORD grfdex, DISPID *pid);
    HRESULT InvokeEx(long                 lCollectionIndex, 
                     DISPID               dispidMember,
                     LCID                 lcid,
                     WORD                 wFlags,
                     DISPPARAMS          *pdispparams,
                     VARIANT             *pvarResult,
                     EXCEPINFO           *pexcepinfo,
                     IServiceProvider    *pSrvProvider);
    HRESULT DeleteMemberByName(long lCollectionIndex, BSTR bstr,DWORD grfdex);
    HRESULT DeleteMemberByDispID(long lCollectionIndex, DISPID id);
    HRESULT GetMemberProperties(long lCollectionIndex, DISPID id, DWORD grfdexFetch, DWORD *pgrfdex);
    HRESULT GetMemberName(long lCollectionIndex, DISPID id, BSTR *pbstrName);
    HRESULT GetNextDispID(long lCollectionIndex, DWORD grfdex, DISPID id, DISPID *prgid);
    HRESULT GetNameSpaceParent(long lCollectionIndex, IUnknown **ppunk);
    
    //
    // Standard collection methods
    //
    HRESULT put_length(long lIndex, long retval);
    HRESULT get_length(long lIndex, long *retval);
    HRESULT get__newEnum(long lIndex, IUnknown **retval);
    HRESULT item(long lIndex, VARIANTARG varName, VARIANTARG varIndex, IDispatch **pDisp);
    HRESULT tags(long lIndex, VARIANT varName, IDispatch **pDisp);

private:
    // private functions
    HRESULT EnsureArray(long lCollectionIndex);
    void EnumStart(void);
    HRESULT EnumNextElement(long lCollectionIndex, CTIMEElementBase **pElem);

    HRESULT GetOuterDisp(long lCollectionIndex, CTIMEElementBase *pElem, IDispatch **ppDisp);
    HRESULT Remove(long lCollection, long lItemIndex);
    HRESULT CreateCollectionHelper(IDispatch **ppDisp, long lIndex);

    bool CompareName(CTIMEElementBase *pElem, const WCHAR *pwszName, bool fTagName, bool fCaseSensitive = false);

    HRESULT BuildNamedArray(long lCollectionIndex, const WCHAR *pwszName, bool fTagName, CPtrAry<CTIMEElementBase *> **prgNamed, bool fCaseSensitive = false);
    HRESULT GetUnknown(long lCollectionIndex, CTIMEElementBase *pElem, IUnknown **ppUnk);    
    
    HRESULT GetDisp(long lCollectionIndex, long lItemIndex, IDispatch **ppDisp);
    HRESULT GetDisp(long lCollectionIndex, const WCHAR *pwszName, long lItemIndex, IDispatch **ppDisp, bool fCaseSensitive = false);
    HRESULT GetDisp(long lCollectionIndex, const WCHAR *pwszName, bool fTagName, IDispatch **ppDisp, bool fCaseSensitive = false);

    HRESULT GetItemCount(long lIndex, long *plCount);
    HRESULT GetItemByIndex(long lIndex, long lElementIndex, CTIMEElementBase **pElem, bool fContinueFromPreviousSearch = false, long lLast = 0);
    HRESULT GetItemByName(long lIndex, const WCHAR *pwszName, long lElementIndex, CTIMEElementBase **pElem, bool fCaseSensitive = false);

    bool IsChildrenCollection(long lCollectionIndex);
    bool IsAllCollection(long lCollectionIndex);
    
    bool ValidateCollectionIndex(long lCollectionIndex);

    DISPID GetNamedMemberMin(long lCollectionIndex);
    DISPID GetNamedMemberMax(long lCollectionIndex);
    DISPID GetOrdinalMemberMin(long lCollectionIndex);
    DISPID GetOrdinalMemberMax(long lCollectionIndex);
    bool IsNamedCollectionMember(long lCollectionIndex, DISPID dispidMember);
    bool IsOrdinalCollectionMember(long lCollectionIndex, DISPID dispidMember);
    DISPID GetSensitiveNamedMemberMin (long lCollectionIndex);
    DISPID GetSensitiveNamedMemberMax(long lCollectionIndex);
    DISPID GetNotSensitiveNamedMemberMin(long lCollectionIndex);
    DISPID GetNotSensitiveNamedMemberMax(long lCollectionIndex);
    bool IsSensitiveNamedCollectionMember(long lCollectionIndex, DISPID dispidMember);
    bool IsNotSensitiveNamedCollectionMember( long lCollectionIndex, DISPID dispidMember);
    long GetNamedMemberOffset(long lCollectionIndex, DISPID id, bool *pfCaseSensitive = NULL);

private:
    CTIMEElementBase       *m_pElemEnum;        // Used as a place holder when we walk the tree
    long                    m_lEnumItem;        // Used as a place holder when we walk the tree
    long                    m_lReservedSize;    // number of CElementCollections that are reserved

    CPtrAry<CCacheItem *>  *m_rgItems;          // array of CCachItems

    long                    m_lCollectionVersion;
    long                    m_lDynamicCollectionVersion;

    CTIMEElementBase       *m_pBase;
    CAtomTable             *m_pAtomTable;       // array of named elements which we have DISPID's for
    
    // functions used to over ride default collection behavior                      
    PFN_CVOID_ENSURE        m_pfnEnsure;
    PFN_CVOID_REMOVEOBJECT  m_pfnRemoveObject; 
    PFN_CVOID_CREATECOL     m_pfnCreateCollection;
    PFN_CVOID_ADDNEWOBJECT  m_pfnAddNewObject;
}; // CCollectionCache

//
// CTIMEElementCollection
//
class CTIMEElementCollection : 
    public IDispatchEx,
    public ITIMEElementCollection,
    public ISupportErrorInfoImpl<&IID_ITIMEElementCollection>
{
public:
    CTIMEElementCollection(CCollectionCache *pCollectionCache, long lIndex);

    //
    // IUnknown Methods
    //
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);
    STDMETHODIMP QueryInterface(REFIID, void**);

    //
    // IDispatch methods
    //
    STDMETHOD(GetTypeInfoCount)(UINT FAR *pctinfo);
    STDMETHOD(GetTypeInfo)(UINT itinfo, LCID lcid, ITypeInfo **pptinfo);
    STDMETHOD(GetIDsOfNames)(REFIID                riid,
                             LPOLESTR             *rgszNames,
                             UINT                  cNames,
                             LCID                  lcid,
                             DISPID FAR           *rgdispid);
    STDMETHOD(Invoke)(DISPID          dispidMember,
                      REFIID          riid,
                      LCID            lcid,
                      WORD            wFlags,
                      DISPPARAMS     *pdispparams,
                      VARIANT        *pvarResult,
                      EXCEPINFO      *pexcepinfo,
                      UINT           *puArgErr);

    //
    // IDispatchEx methods
    //
    STDMETHOD(GetDispID)(BSTR bstrName, DWORD grfdex, DISPID *pid);
    STDMETHOD(InvokeEx)(DISPID               dispidMember,
                       LCID                 lcid,
                       WORD                 wFlags,
                       DISPPARAMS          *pdispparams,
                       VARIANT             *pvarResult,
                       EXCEPINFO           *pexcepinfo,
                       IServiceProvider    *pSrvProvider);
    STDMETHOD(DeleteMemberByName)(BSTR bstr,DWORD grfdex);
    STDMETHOD(DeleteMemberByDispID)(DISPID id);
    STDMETHOD(GetMemberProperties)(DISPID id, DWORD grfdexFetch, DWORD *pgrfdex);
    STDMETHOD(GetMemberName)(DISPID id, BSTR *pbstrName);
    STDMETHOD(GetNextDispID)(DWORD grfdex, DISPID id, DISPID *prgid);
    STDMETHOD(GetNameSpaceParent)(IUnknown **ppunk);
    
    //
    // Standard collection methods
    //
    STDMETHOD(put_length)(long retval);
    STDMETHOD(get_length)(long *retval);
    STDMETHOD(get__newEnum)(IUnknown **retval);
    STDMETHOD(item)(VARIANTARG varName, VARIANTARG varIndex, IDispatch **pDisp);
    STDMETHOD(tags)(VARIANT varName, IDispatch **pDisp);

private:
    virtual ~CTIMEElementCollection();
    HRESULT GetTI(ITypeInfo **pptinfo);

private:
    CCollectionCache *m_pCollectionCache;  // pointer to the cache
    long              m_lCollectionIndex;  // denotes which collection we are
    ULONG             m_cRef;
    ITypeInfo        *m_pInfo;             // our TypeInfo Interface
}; // CTIMEElementCollection

//************************************************************
// inline's for CCollectionCache
//************************************************************
inline void CCollectionCache::Invalidate()
{
    m_lCollectionVersion        = 0;
    m_lDynamicCollectionVersion = 0;        
} // Invalidate

inline void CCollectionCache::BumpVersion()
{
    m_lCollectionVersion++;
} // BumpVersion

inline bool CCollectionCache::ValidateCollectionIndex(long lCollectionIndex)
{
    if ((lCollectionIndex >= 0) && (lCollectionIndex < m_rgItems->Size()))
        return true;
    return false;
} // ValidateCollectionIndex

inline DISPID CCollectionCache::GetNamedMemberMin(long lCollectionIndex) 
{
    return (*m_rgItems)[lCollectionIndex]->m_dispidMin; 
} // GetNamedMemberMin

inline DISPID CCollectionCache::GetNamedMemberMax(long lCollectionIndex)
{ 
    return ((*m_rgItems)[lCollectionIndex]->m_dispidMin + 
            (((*m_rgItems)[lCollectionIndex]->m_dispidMax - (*m_rgItems)[lCollectionIndex]->m_dispidMin) / 2));
} // GetNamedMemberMax

inline DISPID CCollectionCache::GetOrdinalMemberMin(long lCollectionIndex)
{
    return GetNamedMemberMax(lCollectionIndex) + 1;
} // GetOrdinalMemberMin

inline DISPID CCollectionCache::GetOrdinalMemberMax(long lCollectionIndex)
{
    return (*m_rgItems)[lCollectionIndex]->m_dispidMax;
} // GetOrdinalMemberMax

inline bool CCollectionCache::IsNamedCollectionMember(long lCollectionIndex, DISPID dispidMember)
{
    return ((dispidMember >= GetNamedMemberMin(lCollectionIndex)) &&
            (dispidMember <= GetNamedMemberMax(lCollectionIndex)));
} // IsNamedCollectionMember

inline bool CCollectionCache::IsOrdinalCollectionMember(long lCollectionIndex, DISPID dispidMember)
{
    return ((dispidMember >= GetOrdinalMemberMin(lCollectionIndex)) && 
            (dispidMember <= GetOrdinalMemberMax(lCollectionIndex)));
} // IsOrdinalCollectionMember

inline DISPID CCollectionCache::GetSensitiveNamedMemberMin (long lCollectionIndex)
{
    return GetNamedMemberMin(lCollectionIndex);
} // GetSensitiveNamedMemberMin

inline DISPID CCollectionCache::GetSensitiveNamedMemberMax(long lCollectionIndex)
{ 
    return (GetNamedMemberMin(lCollectionIndex) + 
            ((GetNamedMemberMax(lCollectionIndex) - GetNamedMemberMin(lCollectionIndex)) / 2));
} // GetSensitiveNamedMemberMax

inline DISPID CCollectionCache::GetNotSensitiveNamedMemberMin(long lCollectionIndex)
{
    return GetSensitiveNamedMemberMax(lCollectionIndex) + 1;
} // GetNotSensitiveNamedMemberMin
 
inline DISPID CCollectionCache::GetNotSensitiveNamedMemberMax(long lCollectionIndex)
{ 
    return GetNamedMemberMax(lCollectionIndex);
} // GetNotSensitiveNamedMemberMax

inline bool CCollectionCache::IsSensitiveNamedCollectionMember(long lCollectionIndex, DISPID dispidMember)
{
    return ((dispidMember >= GetSensitiveNamedMemberMin(lCollectionIndex)) && 
            (dispidMember <= GetSensitiveNamedMemberMax(lCollectionIndex))) ;
} // IsSensitiveNamedCollectionMember

inline bool CCollectionCache::IsNotSensitiveNamedCollectionMember( long lCollectionIndex, DISPID dispidMember)
{
    return ((dispidMember >= GetNotSensitiveNamedMemberMin(lCollectionIndex)) && 
            (dispidMember <= GetNotSensitiveNamedMemberMax(lCollectionIndex))) ;
} // IsNotSensitiveNamedCollectionMember

#endif //__COLLECT_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\time\src\clock.h ===
/*******************************************************************************
 *
 * Copyright (c) 1998 Microsoft Corporation
 *
 * File: clock.h
 *
 * Abstract:
 *
 *
 *
 *******************************************************************************/


#ifndef _CLOCK_H
#define _CLOCK_H

#include <ocmm.h>
#include <htmlfilter.h>

// This needs to be implemented by the object that wants to be called
// back on timer ticks

class ClockSink
{
  public:
    virtual void OnTimer(double time)=0;
};

// This is the base clock implementation

enum ClockState
{
    CS_STARTED,
    CS_PAUSED,
    CS_STOPPED,
};

class Clock
    : public ITimerSink
{
  public :
    Clock();
    virtual ~Clock();

    HRESULT SetITimer(IServiceProvider * sp, ULONG iInterval);
    void SetSink(ClockSink *pClockSink)
    {
        m_pClockSink = pClockSink;
    }

    HRESULT Start();
    HRESULT Pause();
    HRESULT Resume();
    HRESULT Stop();

    // For the timer sink.
    STDMETHOD(QueryInterface) (REFIID riid, LPVOID * ppv);
    STDMETHOD_(ULONG, AddRef) (void);
    STDMETHOD_(ULONG, Release) (void);
    STDMETHOD(OnTimer) (VARIANT varTimeAdvise);

    // For the starvation sniffer
    void WINAPI StarvationCallback (void);
    static LRESULT __stdcall StarveWndProc (HWND hWnd, UINT uiMessage, WPARAM wParam, LPARAM lParam);

    double GetCurrentTime() { return m_curTime; }
    ClockState GetCurrentState() { return m_state; }
  protected :
    ULONG                      m_ulRefs;
    ClockState                 m_state;
    DAComPtr<ITimer>           m_timer;
    DWORD                      m_cookie;
    ClockSink                 *m_pClockSink;
    ULONG                      m_interval;
    double                     m_lastTime;
    double                     m_curTime;
    UINT                       m_uStarveTimerID;
    HWND                       m_hWndStarveTimer;
    ULONG                      m_ulLastStarvationCallback;
    ULONG                      m_ulConsectiveStarvedTicks;
    bool                       m_fAllowOnTimer;
    bool                       m_fAllowStarvationCallback;

    HRESULT StartITimer();
    HRESULT StopITimer();

    void CreateStarveTimerWindow (void);
    void SetStarveTimer (void);
    
    ULONG GetNextInterval (void);
    HRESULT SetNextTimerInterval (ULONG ulNextInterval);

    double GetITimerTime();
    double GetGlobalTime() { return GetITimerTime(); }

    void ProcessCB(double time);
};


#endif /* _CLOCK_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\time\src\containerobj.cpp ===
//************************************************************
//
// FileName:        containerobj.cpp
//
// Created:         10/08/98
//
// Author:          TWillie
// 
// Abstract:        container object implementation.
//
//************************************************************

#include "headers.h"
#include "containerobj.h"

// Suppress new warning about NEW without corresponding DELETE 
// We expect GCs to cleanup values.  Since this could be a useful
// warning, we should disable this on a file by file basis.
#pragma warning( disable : 4291 )  

DeclareTag(tagContainerObj, "API", "CContainerObj methods");

#define MediaPlayerCLSID L"{22d6f312-b0f6-11d0-94ab-0080c74c7e95}"

//************************************************************
// Author:          twillie
// Created:         10/08/98
// Abstract:        constructor
//************************************************************

CContainerObj::CContainerObj() :
    m_cRef(0),
    m_pSite(NULL),
    m_fStarted(false),
    m_pElem(NULL),
    m_fUsingWMP(false),
    m_bPauseOnPlay(false),
    m_bSeekOnPlay(false),
    m_dblSeekTime(0),
    m_bFirstOnMediaReady(true),
    m_bIsAsfFile(false)
{
    TraceTag((tagContainerObj, "CContainerObj::CContainerObj"));
} // CContainerObj

//************************************************************
// Author:          twillie
// Created:         10/08/98
// Abstract:        destructor
//************************************************************

CContainerObj::~CContainerObj()
{
    TraceTag((tagContainerObj, "CContainerObj::~CContainerObj"));

    if (m_pSite != NULL)
    {
        // make sure we are stopped
        if (m_fStarted)
            Stop();

        m_pSite->Close();
        ReleaseInterface(m_pSite);
    }
} // ~CContainerObj

//************************************************************
// Author:          twillie
// Created:         10/08/98
// Abstract:        Init
//************************************************************

HRESULT
CContainerObj::Init(REFCLSID clsid, CTIMEElementBase *pElem)
{
    TraceTag((tagContainerObj, "CContainerObj::Init"));

    HRESULT hr;

    Assert(pElem != NULL);

    m_pSite = NEW CContainerSite(this);
    if (m_pSite == NULL)
    {
        TraceTag((tagError, "CContainerObj::Init - Unable to allocate memory for CContainerSite"));
        return E_OUTOFMEMORY;
    }
    
    // addref the site
    m_pSite->AddRef();

    hr =  m_pSite->Init(clsid, pElem);
    if (FAILED(hr))
    {
        TraceTag((tagError, "CContainerObj::Init - Init() failed on CContainerSite"));
        goto done;
    }

    m_pElem = pElem;

    {
        // check to see if we are using WMP

        CLSID clsidWMP;
        if (SUCCEEDED(CLSIDFromString(MediaPlayerCLSID, &clsidWMP)))
        {
            if (IsEqualCLSID(clsid, clsidWMP))
                m_fUsingWMP = true;
        }
    }
done:
    return hr;
} // Init

//************************************************************
// Author:          pauld
// Created:         3/2/99
// Abstract:        DetachFromHostElement
//************************************************************
HRESULT
CContainerObj::DetachFromHostElement (void)
{
    HRESULT hr = S_OK;

    TraceTag((tagContainerObj, "CContainerObj::DetachFromHostElement(%lx)", this));
    m_pElem = NULL;
    if (NULL != m_pSite)
    {
        hr = m_pSite->DetachFromHostElement();
    }

    return hr;
} // DetachFromHostElement

//************************************************************
// Author:          twillie
// Created:         01/20/98
// Abstract:        AddRef
//************************************************************

STDMETHODIMP_(ULONG)
CContainerObj::AddRef(void)
{
    return ++m_cRef;
} // AddRef

//************************************************************
// Author:          twillie
// Created:         01/20/98
// Abstract:        Release
//************************************************************

STDMETHODIMP_(ULONG)
CContainerObj::Release(void)
{
    if (m_cRef == 0)
    {
        TraceTag((tagError, "CContainerObj::Release - YIKES! Trying to decrement when Ref count is zero!!!"));
        return m_cRef;
    }

    if (0 != --m_cRef)
    {
        return m_cRef;
    }

    delete this;
    return 0;
} // Release

//************************************************************
// Author:          twillie
// Created:         01/20/98
// Abstract:        QI
//************************************************************

STDMETHODIMP
CContainerObj::QueryInterface(REFIID riid, void **ppv)
{
    if( NULL == ppv )
    {
        Assert(false);
        return E_POINTER;
    }

    *ppv = NULL;
    if (IsEqualIID(riid, IID_IUnknown))
    {
        // SAFECAST macro doesn't work with IUnknown
        *ppv = this;
    }
    else if (IsEqualIID(riid, IID_IDispatch) ||
             IsEqualIID(riid, DIID_TIMEMediaPlayerEvents))
    {
        *ppv = SAFECAST(this, IDispatch*);
    }
    else if (IsEqualIID(riid, IID_IConnectionPointContainer))
    {
        *ppv = SAFECAST(this, IConnectionPointContainer*);
    }

    if (NULL != *ppv)
    {
        ((IUnknown*)*ppv)->AddRef();
        return NOERROR;
    }

    return E_NOINTERFACE;
} // QueryInterface

//************************************************************
// Author:          twillie
// Created:         01/20/98
// Function:        GetTypeInfoCount, IDispatch
// Abstract:        Returns the number of tyep information 
//                  (ITypeInfo) interfaces that the object 
//                  provides (0 or 1).
//************************************************************

HRESULT
CContainerObj::GetTypeInfoCount(UINT *pctInfo) 
{
    TraceTag((tagContainerObj, "CContainerObj::GetTypeInfoCount"));
    return E_NOTIMPL;
} // GetTypeInfoCount

//************************************************************
// Author:          twillie
// Created:         01/20/98
// Function:        GetTypeInfo, IDispatch
// Abstract:        Retrieves type information for the 
//                  automation interface. 
//************************************************************

HRESULT
CContainerObj::GetTypeInfo(UINT itinfo, LCID lcid, ITypeInfo **pptInfo) 
{ 
    TraceTag((tagContainerObj, "CContainerObj::GetTypeInfo"));
    return E_NOTIMPL;
} // GetTypeInfo

//************************************************************
// Author:          twillie
// Created:         01/20/98
// Function:        GetIDsOfNames, IDispatch
// Abstract:        constructor
//************************************************************

HRESULT
CContainerObj::GetIDsOfNames(REFIID riid, OLECHAR **rgszNames, UINT cNames, LCID lcid, DISPID *rgDispID)
{
    TraceTag((tagContainerObj, "CContainerObj::GetIDsOfNames"));
    return E_NOTIMPL;
} // GetIDsOfNames

//************************************************************
// Author:          twillie
// Created:         01/20/98
// Function:        Invoke, IDispatch
// Abstract:        get entry point given ID
//************************************************************

HRESULT
CContainerObj::Invoke(DISPID dispIDMember, REFIID riid, LCID lcid, unsigned short wFlags, 
              DISPPARAMS *pDispParams, VARIANT *pVarResult, EXCEPINFO *pExcepInfo, UINT *puArgErr) 
{ 
    TraceTag((tagContainerObj, "CContainerObj::Invoke(%08X, %04X)", dispIDMember, wFlags));
    HRESULT hr;

    switch (dispIDMember)
    {
        case DISPID_TIMEMEDIAPLAYEREVENTS_ONBEGIN:
        case DISPID_TIMEMEDIAPLAYEREVENTS_ONEND:
        case DISPID_TIMEMEDIAPLAYEREVENTS_ONRESUME:
        case DISPID_TIMEMEDIAPLAYEREVENTS_ONPAUSE:
        case DISPID_TIMEMEDIAPLAYEREVENTS_ONMEDIAREADY:
        case DISPID_TIMEMEDIAPLAYEREVENTS_ONMEDIASLIP:
        case DISPID_TIMEMEDIAPLAYEREVENTS_ONMEDIALOADFAILED:
            hr = ProcessEvent(dispIDMember);
            break;

        case DISPID_TIMEMEDIAPLAYEREVENTS_READYSTATECHANGE:
            {
                long state = 0;

                // BUGBUG:  need to grovel through args for state
                onreadystatechange(state);
                hr = S_OK;
            }
            break;

        default:
            hr = E_NOTIMPL;

            // HACKHACK
            // Pick off the script command from WMP and repackage the event as our own.
            // This allows triggers to work.  The real fix is to add another event on
            // TIMEMediaPlayerEvents.
            {
                #define DISPID_SCRIPTCOMMAND 3001

                if ( (dispIDMember == DISPID_SCRIPTCOMMAND) && 
                     (m_fUsingWMP) )
                {
                    if (NULL != m_pElem)
                    {
                        static LPWSTR pNames[] = {L"Param", L"scType"};
                        hr = m_pElem->GetEventMgr().FireEvent(TE_ONSCRIPTCOMMAND, 
                                                               pDispParams->cArgs, 
                                                               pNames, 
                                                               pDispParams->rgvarg);
                    }
                    else
                    {
                        hr = E_UNEXPECTED;
                    }
                }
            }
            break;
    }

    return hr;
} // Invoke

//************************************************************
// Author:          twillie
// Created:         10/08/98
// Abstract:        Start
//************************************************************

HRESULT
CContainerObj::Start()
{
    TraceTag((tagContainerObj, "CContainerObj::Start"));
    HRESULT hr;
    
    hr  = m_pSite->begin();
    if (FAILED(hr))
    {
        TraceTag((tagError, "CContainerObj::Start - begin() failed"));
        goto done;
    }

    m_fStarted = true;

done:
    return hr;
} // Start

//************************************************************
// Author:          twillie
// Created:         10/08/98
// Abstract:        Pause
//************************************************************

HRESULT
CContainerObj::Pause()
{
    TraceTag((tagContainerObj, "CContainerObj::Pause"));
    HRESULT hr;
    
    hr  = m_pSite->pause();
    if (FAILED(hr))
    {
        TraceTag((tagError, "CContainerObj::Pause - pause() failed"));
        m_bPauseOnPlay = true;
    }
    return hr;
} // Pause

//************************************************************
// Author:          twillie
// Created:         10/08/98
// Abstract:        Stop
//************************************************************

HRESULT
CContainerObj::Stop()
{
    TraceTag((tagContainerObj, "CContainerObj::Stop(%lx)", this));
    HRESULT hr = S_OK;

    if (m_fStarted)
    {    
        m_fStarted = false;

        hr  = m_pSite->end();
        if (FAILED(hr))
        {
            TraceTag((tagError, "CContainerObj::Stop - end() failed"));
            goto done;
        }
    }
done:
    return hr;
} // Stop

//************************************************************
// Author:          twillie
// Created:         10/08/98
// Abstract:        Resume
//************************************************************

HRESULT
CContainerObj::Resume()
{
    TraceTag((tagContainerObj, "CContainerObj::Resume"));
    HRESULT hr;
    
    hr  = m_pSite->resume();
    if (FAILED(hr))
    {    
        TraceTag((tagError, "CContainerObj::Resume - resume() failed"));
    }
    return hr;
} // Resume

//************************************************************
// Author:          twillie
// Created:         10/08/98
// Abstract:        Render
//************************************************************

HRESULT
CContainerObj::Render(HDC hdc, RECT *prc)
{
    HRESULT hr = S_OK;

    if (prc == NULL)
        TraceTag((tagContainerObj, "CContainerObj::Render(%O8X, NULL)"));
    else
        TraceTag((tagContainerObj, "CContainerObj::Render(%O8X, (%d, %d, %d, %d))", prc->left, prc->right, prc->top, prc->bottom));

    if (m_pSite != NULL)    
        hr = m_pSite->draw(hdc, prc);
    return hr;
} // Render

//************************************************************
// Author:          twillie
// Created:         10/08/98
// Abstract:        SetMediaSrc
//************************************************************

HRESULT
CContainerObj::SetMediaSrc(WCHAR *pwszSrc)
{
    TraceTag((tagContainerObj, "CContainerObj::SetMediaSrc (%S)", pwszSrc));
    HRESULT hr;

    isFileNameAsfExt(pwszSrc);

    hr  = m_pSite->GetPlayer()->put_src(pwszSrc);
    if (FAILED(hr))
    {    
        TraceTag((tagError, "CContainerObj::SetMediaSrc - put_src() failed"));
    }
    return hr;
} // SetMediaSrc


// the following is a helper function used because the CanSeek method on WMP only
// works on ASF fles.
bool
CContainerObj::isFileNameAsfExt(WCHAR *pwszSrc)
{
    WCHAR *pext;
    
    m_bIsAsfFile = false;
    
    if (NULL != pwszSrc)
    {
        if(wcslen(pwszSrc) > 4)
        {
            pext = pwszSrc + wcslen(pwszSrc) - 4;
            if(wcscmp(pext, L".asf") == 0)
            {
                m_bIsAsfFile = true;
            }
            else
            {
                m_bIsAsfFile = false;
            }
        }
    }

    return m_bIsAsfFile;
}


//************************************************************
// Author:          twillie
// Created:         10/08/98
// Abstract:        SetRepeat
//************************************************************

HRESULT
CContainerObj::SetRepeat(long lRepeat)
{
    TraceTag((tagContainerObj, "CContainerObj::SetRepeat (%d)", lRepeat));
    HRESULT hr;
    
    if (lRepeat == 1)
       return S_OK;
    
    Assert(m_pSite->GetPlayer() != NULL);    
    hr  = m_pSite->GetPlayer()->put_repeat(lRepeat);
    if (FAILED(hr))
    {    
        TraceTag((tagError, "CContainerObj::SetRepeat - put_repeat() failed"));
    }
    return hr;
} // SetRepeat

//************************************************************
// Author:          twillie
// Created:         10/08/98
// Abstract:        clipBegin
//************************************************************

HRESULT
CContainerObj::clipBegin(VARIANT var)
{
    TraceTag((tagContainerObj, "CContainerObj::clipBegin"));
    HRESULT hr;
    
    if (var.vt == VT_EMPTY)
        return S_OK;
            
    Assert(m_pSite->GetPlayer() != NULL);    
    hr  = m_pSite->GetPlayer()->clipBegin(var);
    if (FAILED(hr))
    {    
        TraceTag((tagError, "CContainerObj::clipBegin - clipBegin() failed"));
    }
    return hr;
} // ClipBegin

//************************************************************
// Author:          twillie
// Created:         10/08/98
// Abstract:        clipEnd
//************************************************************

HRESULT
CContainerObj::clipEnd(VARIANT var)
{
    TraceTag((tagContainerObj, "CContainerObj::clipEnd"));
    HRESULT hr;
    
    if (var.vt == VT_EMPTY)
        return S_OK;

    Assert(m_pSite->GetPlayer() != NULL);    
    hr  = m_pSite->GetPlayer()->clipEnd(var);
    if (FAILED(hr))
    {    
        TraceTag((tagError, "CContainerObj::clipEnd - clipEnd() failed"));
    }
    return hr;
} // ClipEnd

//************************************************************
// Author:          twillie
// Created:         10/08/98
// Abstract:        Render
//************************************************************

HRESULT
CContainerObj::Invalidate(const RECT *prc)
{
    HRESULT  hr;
    RECT     rc;
    RECT    *prcNew;

    // No need to forward call on if we are not started yet or if the element has detached.
    if ((!m_fStarted) || (NULL == m_pElem))
    {
        hr = E_UNEXPECTED;
        goto done;
    }

    // since we have incapatible types due to const.  Take the time and repack it.
    if (prc == NULL)
    {
        prcNew = NULL;
    }
    else
    {
        ::CopyRect(&rc, prc);
        prcNew = &rc;
    }

    // m_pElem != is checked above.
    m_pElem->InvalidateRect(prcNew);    
    hr = S_OK;

done:
    return hr;
} // Invalidate

//************************************************************
// Author:          twillie
// Created:         10/26/98
// Abstract:        GetControlDispatch
//************************************************************

HRESULT
CContainerObj::GetControlDispatch(IDispatch **ppDisp)
{
    TraceTag((tagContainerObj, "CContainerObj::GetControlDispatch"));
    Assert(m_pSite != NULL);
    HRESULT hr = m_pSite->GetPlayer()->QueryInterface(IID_TO_PPV(IDispatch, ppDisp));
    if (FAILED(hr))
    {    
        TraceTag((tagError, "CContainerObj::GetControlDispatch - QI failed for IDispatch"));
    }
    return hr;
} // GetControlDispatch

//************************************************************
// Author:          twillie
// Created:         11/06/98
// Abstract:        
//************************************************************

HRESULT
CContainerObj::EnumConnectionPoints(IEnumConnectionPoints ** ppEnum)
{
    TraceTag((tagContainerObj, "CContainerObj::EnumConnectionPoints"));

    if (ppEnum == NULL)
    {
        TraceTag((tagError, "CContainerObj::EnumConnectionPoints - invalid arg"));
        return E_POINTER;
    }

    return E_NOTIMPL;
}

//************************************************************
// Author:          twillie
// Created:         11/06/98
// Abstract:        Finds a connection point with a particular IID.
//************************************************************

HRESULT
CContainerObj::FindConnectionPoint(REFIID iid, IConnectionPoint **ppCP)
{
    TraceTag((tagContainerObj, "CContainerObj::FindConnectionPoint"));

    if (ppCP == NULL)
    {
        TraceTag((tagError, "CContainerObj::FindConnectionPoint - invalid arg"));
        return E_POINTER;
    }

    return E_NOTIMPL;
}

//************************************************************
// Author:          twillie
// Created:         11/12/98
// Abstract:        
//************************************************************
void 
CContainerObj::onbegin()
{
    TraceTag((tagContainerObj, "CContainerObj::onbegin"));
    THR(ProcessEvent(DISPID_TIMEMEDIAPLAYEREVENTS_ONBEGIN));
}

//************************************************************
// Author:          twillie
// Created:         11/12/98
// Abstract:        
//************************************************************
void 
CContainerObj::onend()
{
    TraceTag((tagContainerObj, "CContainerObj::onend"));
    THR(ProcessEvent(DISPID_TIMEMEDIAPLAYEREVENTS_ONEND));
}

//************************************************************
// Author:          twillie
// Created:         11/12/98
// Abstract:        
//************************************************************
void 
CContainerObj::onresume()
{
    TraceTag((tagContainerObj, "CContainerObj::onresume"));
    THR(ProcessEvent(DISPID_TIMEMEDIAPLAYEREVENTS_ONRESUME));
}

//************************************************************
// Author:          twillie
// Created:         11/12/98
// Abstract:        
//************************************************************
void 
CContainerObj::onpause()
{
    TraceTag((tagContainerObj, "CContainerObj::onpause"));
    THR(ProcessEvent(DISPID_TIMEMEDIAPLAYEREVENTS_ONPAUSE));
}

//************************************************************
// Author:          twillie
// Created:         11/12/98
// Abstract:        
//************************************************************
void 
CContainerObj::onmediaready()
{
    TraceTag((tagContainerObj, "CContainerObj::onmediaready"));
    THR(ProcessEvent(DISPID_TIMEMEDIAPLAYEREVENTS_ONMEDIAREADY));
}

//************************************************************
// Author:          twillie
// Created:         11/12/98
// Abstract:        
//************************************************************
void 
CContainerObj::onmediaslip()
{
    TraceTag((tagContainerObj, "CContainerObj::onmediaslip"));
    THR(ProcessEvent(DISPID_TIMEMEDIAPLAYEREVENTS_ONMEDIASLIP));
}

//************************************************************
// Author:          twillie
// Created:         11/12/98
// Abstract:        
//************************************************************
void 
CContainerObj::onmedialoadfailed()
{
    TraceTag((tagContainerObj, "CContainerObj::onmedialoadfailed"));
    THR(ProcessEvent(DISPID_TIMEMEDIAPLAYEREVENTS_ONMEDIALOADFAILED));
}

//************************************************************
// Author:          twillie
// Created:         11/12/98
// Abstract:        
//************************************************************
void 
CContainerObj::onreadystatechange(long readystate)
{
    TraceTag((tagContainerObj, "CContainerObj::onreadystatechange"));

    // BUGBUG - need to defined states that the player might want to communicate back to
    //          the host.
}

HRESULT
CContainerObj::ProcessEvent(DISPID dispid)
{
    TraceTag((tagContainerObj, "CContainerObj::ProcessEvent(%lx)",this));

    if (NULL != m_pElem)
    {
        switch (dispid)
        {
            case DISPID_TIMEMEDIAPLAYEREVENTS_ONMEDIALOADFAILED:
                m_pElem->FireEvent(TE_ONMEDIALOADFAILED, 0.0, 0);
                break;

            case DISPID_TIMEMEDIAPLAYEREVENTS_ONMEDIASLIP:
                m_pElem->FireEvent(TE_ONMEDIASLIP, 0.0, 0);
                break;

            case DISPID_TIMEMEDIAPLAYEREVENTS_ONMEDIAREADY:
                double mediaLength;
                VARIANT vdur;
                HRESULT hr;
                float endTime, duration;

                m_pSite->SetMediaReadyFlag();
                m_pSite->ClearAutosizeFlag();

                VariantInit(&vdur);

                m_pElem->FireEvent(TE_ONMEDIACOMPLETE, 0.0, 0);
                if (m_bFirstOnMediaReady)
                {            
                    m_bFirstOnMediaReady = false;
                    if (m_bPauseOnPlay)
                    {
                        THR(m_pSite->pause());
                        m_bPauseOnPlay = false;
                    }
                    else if (m_bSeekOnPlay)
                    {
                        THR(this->Seek(m_dblSeekTime));
                        m_bSeekOnPlay = false;
                    }

                    //check to see if either dur or end have default
                    //values. If they do not, we do not change the dur.

                    duration = m_pElem->GetDuration();
                    if (duration != valueNotSet)
                    {
                        VariantClear(&vdur);
                        break;
                    }

                    endTime = m_pElem->GetEndTime();
                    if (endTime != valueNotSet)
                    {
                        VariantClear(&vdur);
                        break;
                    }

                    hr = GetMediaLength( mediaLength);
                    if(FAILED(hr))
                    {
                        VariantClear(&vdur);
                        break;
                    }

                    V_VT(&vdur) = VT_R8;
                    V_R8(&vdur) = mediaLength;
                    hr = VariantChangeTypeEx(&vdur, &vdur, LCID_SCRIPTING, VARIANT_NOUSEROVERRIDE, VT_BSTR);
                    if(FAILED(hr))
                    {
                        VariantClear(&vdur);
                        break;
                    }
                    TraceTag((tagError, "CContainerObj::ProcessEvent(%lx) %g",this, mediaLength));

                    m_pElem->base_put_dur(vdur);
                    m_pElem->setNaturalDuration();

                    VariantClear(&vdur);
                }
                break;

            case DISPID_TIMEMEDIAPLAYEREVENTS_ONEND:
                // make sure we are stopped if there 
                // is no Duration specified
                if ( m_pElem->GetRealDuration() == valueNotSet)
                {
                    HRESULT hr = S_OK;
                    double dblMediaLength = 0.0;
                    if ( NULL == m_pElem || NULL == m_pElem->GetMMBvr().GetMMBvr() )
                    {
                        return S_OK;
                    }

                    hr = THR(m_pElem->GetMMBvr().GetMMBvr()->get_SegmentTime(&dblMediaLength));
                    if (FAILED(hr))
                    {
                        dblMediaLength = 0.0;
                    }

                    VARIANT varMediaLength;
                    VariantInit(&varMediaLength);

                    varMediaLength.vt = VT_R8;
                    varMediaLength.dblVal = dblMediaLength;
                    
                    hr = THR(m_pElem->base_put_dur(varMediaLength));

                    VariantClear(&varMediaLength);                                                            
                }
                break;
        }
    }
    return S_OK;
}


HRESULT
CContainerObj::CanSeek(bool &fcanSeek)
{
    HRESULT hr = S_OK;

    if(m_bIsAsfFile == true)
    {
        hr = m_pSite->CanSeek( fcanSeek);

        if(FAILED(hr))
        {
            goto done;
        }
    }
    else
    {
        fcanSeek = true;
    }
done:
    return hr;

}



HRESULT
CContainerObj::Seek(double dblTime)
{
    HRESULT hr = S_OK;
    bool fcanSeek;

    if (m_bFirstOnMediaReady)
    {
        // we haven't started yet, wait on the seek
        m_bSeekOnPlay = true;
        m_dblSeekTime = dblTime;
    }
    else if (m_pSite != NULL)
    {
        hr = CanSeek(fcanSeek);
        if(FAILED(hr))
        {
            fcanSeek = false;
            goto done;
        }

        if( fcanSeek == true)
        {
            hr = m_pSite->GetPlayer()->put_CurrentTime(dblTime);
        }
    }
done:
    return hr;
}

double
CContainerObj::GetCurrentTime()
{
    double dblTime = 0.0;
    
    if (m_pSite != NULL)
    {
        double dblTemp = 0.0;
        HRESULT hr;
        hr = m_pSite->GetPlayer()->get_CurrentTime(&dblTemp);
        if (SUCCEEDED(hr))
            dblTime = dblTemp;
    }
    return dblTime;
}


HRESULT
CContainerObj::SetSize(RECT *prect)
{
    HRESULT hr = S_OK;
    IOleInPlaceObject *pInPlaceObject;

    if (m_pSite == NULL)
    {
        hr = E_FAIL;
        goto done;
    }
    pInPlaceObject = m_pSite -> GetIOleInPlaceObject();
    if (pInPlaceObject == NULL)
    {
        hr = E_FAIL;
        goto done;
    }


    hr = pInPlaceObject -> SetObjectRects(prect, prect);

done:
    return hr;
}

HRESULT
CContainerObj::GetMediaLength(double &dblLength)
{
    HRESULT hr;
    if (!m_fUsingWMP)
        return E_FAIL;

    Assert(m_pSite != NULL);
    hr = m_pSite->GetMediaLength(dblLength);
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\time\src\collect.cpp ===
//************************************************************
//
// Filename:    collect.cpp
//
// Created:     09/25/98
//
// Author:	twillie
//
//              Collection implementation.
//
//************************************************************

#include "headers.h"
#include "collect.h"

// Suppress new warning about NEW without corresponding DELETE
// We expect GCs to cleanup values.  Since this could be a useful
// warning, we should disable this on a file by file basis.
#pragma warning( disable : 4291 )

#define TYPELIB_VERSION_MAJOR 1
#define TYPELIB_VERSION_MINOR 0

#define FL_UNSIGNED   1       /* wcstoul called */
#define FL_NEG        2       /* negative sign found */
#define FL_OVERFLOW   4       /* overflow occured */
#define FL_READDIGIT  8       /* we've read at least one correct digit */

#define LONG_MIN    (-2147483647L - 1) /* minimum (signed) long value */
#define LONG_MAX      2147483647L   /* maximum (signed) long value */
#define ULONG_MAX     0xffffffffUL  /* maximum unsigned long value */

//
// local prototypes
//
HRESULT ttol_with_error(const WCHAR *pStr, long *plValue);
static HRESULT PropertyStringToLong(const WCHAR   *nptr,
                                    WCHAR        **endptr,
                                    int            ibase,
                                    int            flags,
                                    unsigned long *plNumber);


DeclareTag(tagTimeCollection, "API", "CTIMEElementCollection methods");
DeclareTag(tagCollectionCache, "API", "CCollectionCache methods");


//************************************************************
// Author:	twillie
// Created:	02/06/98
// Abstract:    check to see if string is number
//************************************************************

HRESULT
ttol_with_error(const WCHAR *pStr, long *plValue)
{
    // Always do base 10 regardless of contents of
    return PropertyStringToLong(pStr, NULL, 10, 0, (unsigned long *)plValue);
} // ttol_with_error

//************************************************************
// Author:	twillie
// Created:	02/06/98
// Abstract:    try to convert string to number
//************************************************************
static HRESULT
PropertyStringToLong(const WCHAR   *nptr,
                     WCHAR        **endptr,
                     int            ibase,
                     int            flags,
                     unsigned long *plNumber)
{
    const WCHAR *p;
    WCHAR c;
    unsigned long number;
    unsigned digval;
    unsigned long maxval;

    *plNumber = 0;                  /* on error result is 0 */

    p = nptr;                       /* p is our scanning pointer */
    number = 0;                     /* start with zero */

    c = *p++;                       /* read char */
    while (_istspace(c))
        c = *p++;                   /* skip whitespace */

    if (c == '-')
    {
        flags |= FL_NEG;        /* remember minus sign */
        c = *p++;
    }
    else if (c == '+')
        c = *p++;               /* skip sign */

    if (ibase < 0 || ibase == 1 || ibase > 36)
    {
        /* bad base! */
        if (endptr)
            /* store beginning of string in endptr */
            *endptr = (WCHAR *)nptr;
        return E_POINTER;              /* return 0 */
    }
    else if (ibase == 0)
    {
        /* determine base free-lance, based on first two chars of
           string */
        if (c != L'0')
            ibase = 10;
        else if (*p == L'x' || *p == L'X')
            ibase = 16;
        else
            ibase = 8;
    }

    if (ibase == 16)
    {
        /* we might have 0x in front of number; remove if there */
        if (c == L'0' && (*p == L'x' || *p == L'X'))
        {
            ++p;
            c = *p++;       /* advance past prefix */
        }
    }

    /* if our number exceeds this, we will overflow on multiply */
    maxval = ULONG_MAX / ibase;


    for (;;)
    {      /* exit in middle of loop */
        /* convert c to value */
        if (_istdigit(c))
            digval = c - L'0';
        else if (_istalpha(c))
        {
            if (ibase > 10)
            {
                digval = (unsigned) PtrToUlong(CharUpper((LPTSTR)(LONG_PTR)c)) - L'A' + 10;
            }
            else
            {
                return E_INVALIDARG;              /* return 0 */
            }
        }
        else
            break;

        if (digval >= (unsigned)ibase)
            break;          /* exit loop if bad digit found */

        /* record the fact we have read one digit */
        flags |= FL_READDIGIT;

        /* we now need to compute number = number * base + digval,
           but we need to know if overflow occured.  This requires
           a tricky pre-check. */

        if (number < maxval || (number == maxval &&
            (unsigned long)digval <= ULONG_MAX % ibase))
        {
            /* we won't overflow, go ahead and multiply */
            number = number * ibase + digval;
        }
        else
        {
            /* we would have overflowed -- set the overflow flag */
            flags |= FL_OVERFLOW;
        }

        c = *p++;               /* read next digit */
    }

    --p;                            /* point to place that stopped scan */

    if (!(flags & FL_READDIGIT))
    {
        number = 0L;                        /* return 0 */

        /* no number there; return 0 and point to beginning of
           string */
        if (endptr)
            /* store beginning of string in endptr later on */
            p = nptr;

        return E_INVALIDARG;            // Return error not a number
    }
    else if ((flags & FL_OVERFLOW) ||
              (!(flags & FL_UNSIGNED) &&
                (((flags & FL_NEG) && (number > -LONG_MIN)) ||
                  (!(flags & FL_NEG) && (number > LONG_MAX)))))
    {
        /* overflow or signed overflow occurred */
        //errno = ERANGE;
        if (flags & FL_UNSIGNED)
            number = ULONG_MAX;
        else if (flags & FL_NEG)
            number = (unsigned long)(-LONG_MIN);
        else
            number = LONG_MAX;
    }

    if (endptr != NULL)
        /* store pointer to char that stopped the scan */
        *endptr = (WCHAR *)p;

    if (flags & FL_NEG)
        /* negate result if there was a neg sign */
        number = (unsigned long)(-(long)number);

    *plNumber = number;
    return S_OK;                  /* done. */
} // PropertyStringToLong

//************************************************************
// Author:	twillie
// Created:	02/06/98
// Abstract:    constructor
//************************************************************

CTIMEElementCollection::CTIMEElementCollection(CCollectionCache *pCollectionCache, long lIndex) :
    m_pCollectionCache(pCollectionCache),
    m_lCollectionIndex(lIndex),
    m_pInfo(NULL),
    m_cRef(0)
{
} // CTIMEElementCollection

//************************************************************
// Author:	twillie
// Created:	02/06/98
// Abstract:    destructor
//************************************************************

CTIMEElementCollection::~CTIMEElementCollection()
{
    ReleaseInterface(m_pInfo);
    m_pCollectionCache = NULL;
} // ~CTIMEElementCollection

//************************************************************
// Author:          twillie
// Created:         01/20/98
// Abstract:        AddRef
//************************************************************

STDMETHODIMP_(ULONG) CTIMEElementCollection::AddRef(void)
{
    return m_cRef++;
} // AddRef

//************************************************************
// Author:          twillie
// Created:         01/20/98
// Abstract:        Release
//************************************************************

STDMETHODIMP_(ULONG) CTIMEElementCollection::Release(void)
{
    if (m_cRef == 0)
    {
        TraceTag((tagError, "CTIMEElementCollection::Release - YIKES! Trying to decrement when Ref count is zero"));
        return m_cRef;
    }

    if (0 != --m_cRef)
    {
        return m_cRef;
    }

    delete this;
    return 0;
} // Release

//************************************************************
// Author:          twillie
// Created:         01/20/98
// Abstract:        QI
//************************************************************

HRESULT
CTIMEElementCollection::QueryInterface(REFIID riid, void **ppv)
{
    *ppv = NULL;
    if (IsEqualIID(riid, IID_IUnknown))
    {
        // SAFECAST macro doesn't work with IUnknown
        *ppv = this;
    }
    else if (IsEqualIID(riid, IID_IDispatch))
    {
        *ppv = SAFECAST((ITIMEElementCollection*)this, IDispatch*);
    }
    else if (IsEqualIID(riid, IID_IDispatchEx))
    {
        *ppv = SAFECAST(this, IDispatchEx*);
    }
    else if (IsEqualIID(riid, IID_ITIMEElementCollection))
    {
        *ppv = SAFECAST(this, ITIMEElementCollection*);
    }

    if (NULL != *ppv)
    {
        ((LPUNKNOWN)*ppv)->AddRef();
        return NOERROR;
    }

    return E_NOINTERFACE;
} // QueryInterface

//************************************************************
// Author:	twillie
// Created:	02/06/98
// Abstract:    IDispatch - GetTypeInfoCount
//************************************************************

HRESULT
CTIMEElementCollection::GetTypeInfoCount(UINT FAR *pctinfo)
{
    if (pctinfo == NULL)
    {
        TraceTag((tagError, "CTIMEElementCollection::GetTypeInfoCount - Invalid param (UINT FAR *)"));
        return TIMESetLastError(E_POINTER);
    }

    *pctinfo = 1;
    return S_OK;
} // GetTypeInfoCount

//************************************************************
// Author:	twillie
// Created:	02/06/98
// Abstract:    IDispatch - GetTypeInfo
//************************************************************

HRESULT
CTIMEElementCollection::GetTypeInfo(UINT itinfo, LCID lcid, ITypeInfo **pptinfo)
{
    if (pptinfo == NULL)
    {
        TraceTag((tagError, "CTIMEElementCollection::GetTypeInfo - Invalid param (ITypeInfo**)"));
        return TIMESetLastError(E_POINTER);
    }

    return GetTI(pptinfo);
} // GetTypeInfo

//************************************************************
// Author:	twillie
// Created:	02/06/98
// Abstract:    IDispatch - GetIDsOfNames
//************************************************************

HRESULT
CTIMEElementCollection::GetIDsOfNames(REFIID riid, LPOLESTR *rgszNames,
                                  UINT cNames, LCID lcid, DISPID FAR *rgdispid)
{
    // punt to IDispatchEx impl.
    return GetDispID(rgszNames[0], cNames, rgdispid);
} // GetIDsOfNames

//************************************************************
// Author:	twillie
// Created:	02/06/98
// Abstract:    IDispatch - Invoke
//************************************************************

HRESULT
CTIMEElementCollection::Invoke(DISPID dispidMember, REFIID iid, LCID lcid, WORD wFlags,
                           DISPPARAMS *pdispparams, VARIANT *pvarResult,
                           EXCEPINFO *pexcepinfo, UINT *pArg)
{
    // punt to IDispatchEx impl.
    return InvokeEx(dispidMember,
                    lcid,
                    wFlags,
                    pdispparams,
                    pvarResult,
                    pexcepinfo,
                    NULL);
} // Invoke

//************************************************************
// Author:	twillie
// Created:	02/06/98
// Abstract:    IDispatchEx - InvokeEx
//************************************************************

HRESULT
CTIMEElementCollection::InvokeEx(DISPID            dispidMember,
                             LCID              lcid,
                             WORD              wFlags,
                             DISPPARAMS       *pdispparams,
                             VARIANT          *pvarResult,
                             EXCEPINFO        *pexcepinfo,
                             IServiceProvider *pSrvProvider)
{
    HRESULT hr;

    hr = m_pCollectionCache->InvokeEx(m_lCollectionIndex, dispidMember, lcid, wFlags,
                                      pdispparams, pvarResult, pexcepinfo, pSrvProvider);

    // if that failed, try typelib
    if (FAILED(hr))
    {
        ITypeInfo *pInfo;
        hr = GetTI(&pInfo);
        if (FAILED(hr))
        {
            TraceTag((tagError, "CTIMEElementCollection::InvokeEx - GetTI() failed"));
            return TIMESetLastError(hr);
        }

        UINT* puArgErr = NULL;

        IDispatch *pDisp = NULL;
        hr = QueryInterface(IID_TO_PPV(IDispatch, &pDisp));
        if (FAILED(hr))
            return TIMESetLastError(hr);

        Assert(pInfo != NULL);

        hr = pInfo->Invoke(pDisp, dispidMember, wFlags, pdispparams, pvarResult, pexcepinfo, puArgErr);
        ReleaseInterface(pInfo);
        ReleaseInterface(pDisp);
        if (FAILED(hr))
        {
            TraceTag((tagError, "CTIMEElementCollection::InvokeEx - Invoke failed on Typelib"));
            return TIMESetLastError(hr);
        }
    }

    return hr;
} // InvokeEx

//************************************************************
// Author:	twillie
// Created:	02/06/98
// Abstract:    IDispatchEx - GetDispID
//************************************************************

HRESULT
CTIMEElementCollection::GetDispID(BSTR bstrName, DWORD grfdex, DISPID *pid)
{
    HRESULT hr = m_pCollectionCache->GetDispID(m_lCollectionIndex, bstrName, grfdex, pid);

    // if we failed or found nothing, try typelib
    if ((FAILED(hr)) || (*pid == DISPID_UNKNOWN))
    {
        // have string, see if it's a member function/property in typelib
        ITypeInfo *pInfo;
        hr = GetTI(&pInfo);
        if (FAILED(hr))
        {
            TraceTag((tagError, "CTIMEElementCollection::GetDispID - GetTI() failed"));
            return TIMESetLastError(hr);
        }

        Assert(pInfo != NULL);

        LPOLESTR rgszNames[1];
        rgszNames[0] = bstrName;

        hr = pInfo->GetIDsOfNames(rgszNames, 1, pid);
        ReleaseInterface(pInfo);
    }

    return hr;
} // GetDispID

//************************************************************
// Author:	twillie
// Created:	02/06/98
// Abstract:    IDispatchEx - deleteMemberByName
//************************************************************

HRESULT
CTIMEElementCollection::DeleteMemberByName(BSTR bstrName, DWORD grfdex)
{
    return TIMESetLastError(m_pCollectionCache->DeleteMemberByName(m_lCollectionIndex, bstrName, grfdex));
} // deleteMemberByName

//************************************************************
// Author:	twillie
// Created:	02/06/98
// Abstract:    IDispatchEx - deleteMemberByDispID
//************************************************************

HRESULT
CTIMEElementCollection::DeleteMemberByDispID(DISPID id)
{
    return TIMESetLastError(m_pCollectionCache->DeleteMemberByDispID(m_lCollectionIndex, id));
} // deleteMemberByDispID

//************************************************************
// Author:	twillie
// Created:	02/06/98
// Abstract:    IDispatchEx - GetMemberProperties
//************************************************************

HRESULT
CTIMEElementCollection::GetMemberProperties(DISPID id, DWORD grfdexFetch, DWORD *pgrfdex)
{
    return TIMESetLastError(m_pCollectionCache->GetMemberProperties(m_lCollectionIndex, id, grfdexFetch, pgrfdex));
} // GetMemberProperties

//************************************************************
// Author:	twillie
// Created:	02/06/98
// Abstract:    IDispatchEx - GetMemberName
//************************************************************

HRESULT
CTIMEElementCollection::GetMemberName(DISPID id, BSTR *pbstrName)
{
    return TIMESetLastError(m_pCollectionCache->GetMemberName(m_lCollectionIndex, id, pbstrName));
} // GetMemberName

//************************************************************
// Author:	twillie
// Created:	02/06/98
// Abstract:    IDispatchEx - GetNextDispID
//************************************************************

STDMETHODIMP
CTIMEElementCollection::GetNextDispID(DWORD grfdex, DISPID id, DISPID *prgid)
{
    return TIMESetLastError(m_pCollectionCache->GetNextDispID(m_lCollectionIndex, grfdex, id, prgid));
} // GetNextDispID

//************************************************************
// Author:	twillie
// Created:	02/06/98
// Abstract:    IDispatchEx - GetNameSpaceParent
//************************************************************

HRESULT
CTIMEElementCollection::GetNameSpaceParent(IUnknown **ppUnk)
{
    return TIMESetLastError(m_pCollectionCache->GetNameSpaceParent(m_lCollectionIndex, ppUnk));
} // GetNameSpaceParent

//************************************************************
// Author:	twillie
// Created:	02/06/98
// Abstract:    ITIMEElementCollection - get_length
//************************************************************

HRESULT
CTIMEElementCollection::get_length(long *plSize)
{
    return TIMESetLastError(m_pCollectionCache->get_length(m_lCollectionIndex, plSize));
} // get_length

//************************************************************
// Author:	twillie
// Created:	02/06/98
// Abstract:    ITIMEElementCollection - put_length
//************************************************************

HRESULT
CTIMEElementCollection::put_length(long lSize)
{
    return TIMESetLastError(m_pCollectionCache->put_length(m_lCollectionIndex, lSize));
} // put_length

//************************************************************
// Author:	twillie
// Created:	02/06/98
// Abstract:    ITIMEElementCollection - item
//************************************************************

HRESULT
CTIMEElementCollection::item(VARIANTARG var1, VARIANTARG var2, IDispatch **ppDisp)
{
    return TIMESetLastError(m_pCollectionCache->item(m_lCollectionIndex, var1, var2, ppDisp));
} // item

//************************************************************
// Author:	twillie
// Created:	02/06/98
// Abstract:    ITIMEElementCollection - tags
//************************************************************

HRESULT
CTIMEElementCollection::tags(VARIANT var1, IDispatch **ppDisp)
{
    return TIMESetLastError(m_pCollectionCache->tags(m_lCollectionIndex, var1, ppDisp));
} // tags

//************************************************************
// Author:	twillie
// Created:	02/06/98
// Abstract:    ITIMEElementCollection - get__newEnum
//************************************************************

HRESULT
CTIMEElementCollection::get__newEnum(IUnknown ** ppEnum)
{
    return TIMESetLastError(m_pCollectionCache->get__newEnum(m_lCollectionIndex, ppEnum));
} // get__newEnum

//************************************************************
// Author:	twillie
// Created:	02/06/98
// Abstract:    helper function for typeinfo
//************************************************************

HRESULT
CTIMEElementCollection::GetTI(ITypeInfo **pptinfo)
{
    HRESULT hr = E_FAIL;

    Assert(pptinfo != NULL);  //GetTI is an private internal function.  pptinfo should always be valid

    *pptinfo = NULL;

    if (m_pInfo == NULL)
    {
        ITypeLib* pTypeLib;

        hr = LoadRegTypeLib(LIBID_TIME, TYPELIB_VERSION_MAJOR, TYPELIB_VERSION_MINOR, LCID_SCRIPTING, &pTypeLib);
        if (SUCCEEDED(hr))
        {
            ITypeInfo* pTypeInfo;

            hr = pTypeLib->GetTypeInfoOfGuid(IID_ITIMEElementCollection, &pTypeInfo);
            if (SUCCEEDED(hr))
            {
	        m_pInfo = pTypeInfo;
            }

            ReleaseInterface(pTypeLib);
        }
    }

    *pptinfo = m_pInfo;
    if (m_pInfo != NULL)
    {
        m_pInfo->AddRef();
        hr = S_OK;
    }

    return hr;
} // GetTI

//************************************************************
// Author:	twillie
// Created:	02/06/98
// Abstract:    Constructor
//************************************************************

CCollectionCache::CCollectionCache(CTIMEElementBase *pBase,
                                   CAtomTable *pAtomTable /* = NULL */,
                                   PFN_CVOID_ENSURE pfnEnsure /* = NULL */,
                                   PFN_CVOID_CREATECOL pfnCreation /* = NULL */,
                                   PFN_CVOID_REMOVEOBJECT pfnRemove /* = NULL */,
                                   PFN_CVOID_ADDNEWOBJECT pfnAddNewObject /* = NULL */) :
    m_pBase(pBase),
    m_pAtomTable(pAtomTable),
    m_pfnEnsure(pfnEnsure),
    m_pfnCreateCollection(pfnCreation),
    m_pfnRemoveObject(pfnRemove),
    m_pfnAddNewObject(pfnAddNewObject),
    m_lReservedSize(0),
    m_lCollectionVersion(0),
    m_lDynamicCollectionVersion(0),
    m_rgItems(NULL)
{
    Assert(m_pBase != NULL);
} // CCollectionCache

//************************************************************
// Author:	twillie
// Created:	02/06/98
// Abstract:    Destructor
//************************************************************

CCollectionCache::~CCollectionCache()
{
    if (m_rgItems)
    {
        long lSize = m_rgItems->Size();

        for (long lIndex = 0; lIndex < lSize; lIndex++)
        {
            CCacheItem *pce = (*m_rgItems)[lIndex];
            if (pce->m_fOKToDelete)
            {
                // delete CCacheItem
                delete pce;
                pce = NULL;
            }
        }

        // delete array of CCacheItems
        delete m_rgItems;
        m_rgItems = NULL;
    }
} // ~CCollectionCache

//************************************************************
// Author:	twillie
// Created:	02/06/98
// Abstract:    Initialize class
//************************************************************

HRESULT
CCollectionCache::Init(long lReservedSize, long lIdentityIndex /* = -1 */)
{
    HRESULT hr = E_INVALIDARG;

    m_lReservedSize = lReservedSize;

    // Clear the reserved part of the cache.
    if (m_lReservedSize >= 0)
    {
        m_rgItems = NEW CPtrAry<CCacheItem *>;
        if (m_rgItems == NULL)
        {
            TraceTag((tagError, "CCollectionCache::Init - unable to alloc mem for array"));
            return E_OUTOFMEMORY;
        }

        // this is a speed thing.  Since we know we need a certain size,
        // make it so.
        hr = m_rgItems->EnsureSize(m_lReservedSize);
        if (FAILED(hr))
        {
            TraceTag((tagError, "CCollectionCache::Init - unable to init array to reserved size"));
            return hr;
        }

        // loop through initializing each reserved array
        for (long lIndex = 0; lIndex < lReservedSize; lIndex++)
        {
            // create new cache item
            CCacheItem *pce = NEW CCacheItem();
            if (pce == NULL)
            {
                TraceTag((tagError, "CCollectionCache::Init - unable to alloc mem for array (CCacheItem)"));
                return E_OUTOFMEMORY;
            }

            // add item to array
            hr = m_rgItems->Append(pce);
            if (FAILED(hr))
            {
                TraceTag((tagError, "CCollectionCache::Init - unable to add cache item"));
                delete pce;
                return hr;
            }

            // attach CTIMEElementCollection to item
            hr = CreateCollectionHelper(&pce->m_pDisp, lIndex);
            if (FAILED(hr))
            {
                TraceTag((tagError, "CCollectionCache::Init - CreateCollectionHelper() failed"));
                return hr;
            }
        }

        // handle identity flag
        if ((lIdentityIndex >= 0) && (lIdentityIndex < m_lReservedSize))
        {
            (*m_rgItems)[lIdentityIndex]->m_fIdentity = true;
        }
    }

    return S_OK;
} // Init

//************************************************************
// Author:	twillie
// Created:	02/06/98
// Abstract:    Get IDispatch for collection index
//************************************************************

HRESULT
CCollectionCache::GetCollectionDisp(long lCollectionIndex, IDispatch **ppDisp)
{
    if (!ValidateCollectionIndex(lCollectionIndex))
    {
        TraceTag((tagError, "CCollectionCache::GetCollectionDisp - Invalid param (collection index)"));
        return E_INVALIDARG;
    }

    if (ppDisp == NULL)
    {
        TraceTag((tagError, "CCollectionCache::GetCollectionDisp - Invalid param (IDispatch**)"));
        return E_POINTER;
    }

    HRESULT hr = S_OK;

    *ppDisp = NULL;

    // fetch particular Collection
    CCacheItem *pce = (*m_rgItems)[lCollectionIndex];

    // if identity, QI for IDispatch and return
    if (pce->m_fIdentity)
    {
        return GetOuterDisp(lCollectionIndex, m_pBase, ppDisp);
    }

    // if not identity and there is a collection, addref and return it
    Assert(pce->m_pDisp != NULL);

    pce->m_pDisp->AddRef();
    *ppDisp = pce->m_pDisp;

    return S_OK;
} // GetCollectionDisp

//************************************************************
// Author:	twillie
// Created:	02/06/98
// Abstract:    Set collection cache type
//************************************************************

HRESULT
CCollectionCache::SetCollectionType(long lCollectionIndex, COLLECTIONCACHETYPE cctype, bool fReturnHTMLInterface /*false*/)
{
    if (!ValidateCollectionIndex(lCollectionIndex))
    {
        TraceTag((tagError, "CCollectionCache::SetCollectionType - Invalid index"));
        return E_INVALIDARG;
    }

    CCacheItem *pce = (*m_rgItems)[lCollectionIndex];
    pce->m_cctype = cctype;
    pce->m_fReturnHTMLInterface = !!fReturnHTMLInterface;
    return S_OK;
} // SetCollectionType

//************************************************************
// Author:	twillie
// Created:	02/06/98
// Abstract:    given an index, see if it's a child collection
//************************************************************

bool
CCollectionCache::IsChildrenCollection(long lCollectionIndex)
{
    if ((lCollectionIndex >= 0) && lCollectionIndex < m_rgItems->Size())
    {
        CCacheItem *pce = (*m_rgItems)[lCollectionIndex];
        if (pce->m_cctype == ctChildren)
            return true;
    }
    return false;
} // IsChildrenCollection

//************************************************************
// Author:	twillie
// Created:	02/06/98
// Abstract:    given an index, see if it's an all collection
//************************************************************

bool
CCollectionCache::IsAllCollection(long lCollectionIndex)
{
    if ((lCollectionIndex >= 0) && lCollectionIndex < m_rgItems->Size())
    {
        CCacheItem *pce = (*m_rgItems)[lCollectionIndex];
        if (pce->m_cctype == ctAll)
            return true;
    }
    return false;
} // IsAllCollection

//************************************************************
// Author:	twillie
// Created:	02/06/98
// Abstract:    Implementation of IDispatchEx - GetDispID
//************************************************************

HRESULT
CCollectionCache::GetDispID(long lCollectionIndex, BSTR bstrName, DWORD grfdex, DISPID *pid)
{
    HRESULT hr;
    long    lItemIndex = 0;

    if (!ValidateCollectionIndex(lCollectionIndex))
    {
        TraceTag((tagError, "CCollectionCache::GetDispID - Invalid param (collection index)"));
        return E_INVALIDARG;
    }

    if (pid == NULL)
    {
        TraceTag((tagError, "CCollectionCache::GetDispID - Invalid param (DISPID*)"));
        return E_POINTER;
    }

    *pid = 0;

    // make sure array is up-to-date.
    hr = EnsureArray(lCollectionIndex);
    if (FAILED(hr))
    {
        TraceTag((tagError, "CCollectionCache::GetDispID - EnsureArray() failed"));
        return hr;
    }

    // check for index (number) - which equates to an ordinal
    hr = ttol_with_error(bstrName, &lItemIndex);
    if (hr == S_OK)
    {
        // Try to map name to a named element in the collection.
        // Ignore it if we're not promoting ordinals
        if (!(*m_rgItems)[lCollectionIndex]->m_fPromoteOrdinals)
        {
            return DISP_E_UNKNOWNNAME;
        }

        if (m_pfnAddNewObject)
        {
            // The presence of m_pfnAddNewObject indicates that the collection
            // allows setting to arbitrary indices. Expando on the collection
            // is not allowed.
            *pid = GetOrdinalMemberMin(lCollectionIndex) + lItemIndex;
            if (*pid > GetOrdinalMemberMax(lCollectionIndex))
            {
                return DISP_E_UNKNOWNNAME;
            }
            return S_OK;
        }

        // Without a m_pfnAddNewObject, the collection only supports
        // access to ordinals in the current range. Other accesses
        // become expando.
        if ((lItemIndex >= 0) &&
            (lItemIndex < Size(lCollectionIndex)))
        {
            *pid = GetOrdinalMemberMin(lCollectionIndex) + lItemIndex;
            if (*pid > GetOrdinalMemberMax(lCollectionIndex) )
            {
                return DISP_E_UNKNOWNNAME;
            }
            return S_OK;
        }

        return DISP_E_UNKNOWNNAME;
    }

    // see if it's an expando

    // If we don't promote named items - nothing more to do
    if (!(*m_rgItems)[lCollectionIndex]->m_fPromoteNames)
        return DISP_E_UNKNOWNNAME;

    CTIMEElementBase *pElem = NULL;
    long lIndex = 0;
    bool fCaseSensitive = ( grfdex & fdexNameCaseSensitive ) != 0;

    // check to make sure min/max are not wacky
    Assert((*m_rgItems)[lCollectionIndex]->m_dispidMin != 0);
    Assert(((*m_rgItems)[lCollectionIndex]->m_dispidMax != 0) &&
            ((*m_rgItems)[lCollectionIndex]->m_dispidMax > (*m_rgItems)[lCollectionIndex]->m_dispidMin));

    hr = GetItemByName(lCollectionIndex, bstrName, lIndex, &pElem, fCaseSensitive);
    if (FAILED(hr))
    {
        TraceTag((tagError, "CCollectionCache::GetDispID - GetItemByName() failed"));
        return hr;
    }

    Assert(pElem != NULL);  // double check to make sure we found something

    // add name to table
    long lOffset = 0;
    hr =  m_pAtomTable->AddNameToAtomTable(bstrName, &lOffset);
    if (FAILED(hr))
    {
        TraceTag((tagError, "CCollectionCache::GetDispID - AddNameToAtomTable() failed"));
        return hr;
    }

    // cook up an ID based on offset plus case sensitivity
    long lMax;
    if (fCaseSensitive)
    {
        lOffset += GetSensitiveNamedMemberMin(lCollectionIndex);
        lMax = GetSensitiveNamedMemberMax(lCollectionIndex);
    }
    else
    {
        lOffset += GetNotSensitiveNamedMemberMin(lCollectionIndex);
        lMax = GetNotSensitiveNamedMemberMax(lCollectionIndex);
    }

    *pid = lOffset;

    // if id greater than the max, punt
    if (*pid > lMax)
    {
        hr = DISP_E_UNKNOWNNAME;
    }
    return hr;
} // GetDispID

//************************************************************
// Author:	twillie
// Created:	02/06/98
// Abstract:    Implementation of IDispatchEx - InvokeEx
//************************************************************

HRESULT
CCollectionCache::InvokeEx(long lCollectionIndex, DISPID id, LCID lcid, WORD wFlags, DISPPARAMS *pdispparams, VARIANT *pvarResult, EXCEPINFO *pexcepinfo, IServiceProvider *pSrvProvider)
{
    HRESULT hr;

    // validate params
    if (!ValidateCollectionIndex(lCollectionIndex))
    {
        TraceTag((tagError, "CCollectionCache::InvokeEx - Invalid param (collection index)"));
        return E_INVALIDARG;
    }

    if (pdispparams == NULL)
    {
        TraceTag((tagError, "CCollectionCache::InvokeEx - Invalid param (DISPPARAMS*)"));
        return E_POINTER;
    }

    // make sure array is up-to-date
    hr = EnsureArray(lCollectionIndex);
    if (FAILED(hr))
    {
        TraceTag((tagError, "CCollectionCache::InvokeEx - unable to ensure array index"));
        return hr;
    }

    // make sure ID is in collection range
    // Note: this stop's requests for length which is handled
    //       in CTIMEElementCollection
    if ((id < (*m_rgItems)[lCollectionIndex]->m_dispidMin) ||
        (id > (*m_rgItems)[lCollectionIndex]->m_dispidMax))
        return DISP_E_MEMBERNOTFOUND;

    //
    // check for ordinal
    //
    if (IsOrdinalCollectionMember(lCollectionIndex, id))
    {
        if (wFlags & DISPATCH_PROPERTYPUT )
        {
            if (!m_pfnAddNewObject)
            {
                TraceTag((tagError, "CCollectionCache::InvokeEx - invalid arg passed to invoke"));
                return E_INVALIDARG;
            }

            if (!(pdispparams && pdispparams->cArgs == 1))
                // No result type we need one for the get to return.
                return DISP_E_MEMBERNOTFOUND;

            // Only allow VARIANT of type IDispatch to be put
            if (pdispparams->rgvarg[0].vt == VT_NULL)
            {
                // the options collection is special. it allows
                // options[n] = NULL to be specified. in this case
                // map the invoke to a delete on that appropriate index
                if ((*m_rgItems)[lCollectionIndex]->m_fSettableNULL)
                {
                    hr = Remove(lCollectionIndex, id - GetOrdinalMemberMin(lCollectionIndex));

                    // Like Nav - silently ignore the put if its's outside the current range
                    if ( hr == E_INVALIDARG )
                        return S_OK;
                    return hr;
                }
                return E_INVALIDARG;
            }
            else if (pdispparams->rgvarg[0].vt != VT_DISPATCH)
            {
                return E_INVALIDARG;
            }

            // All OK, let the collection cache validate the Put
            return ((CVoid *)((void *)m_pBase)->*m_pfnAddNewObject)(lCollectionIndex,
                                                                    V_DISPATCH(pdispparams->rgvarg),
                                                                    id - GetOrdinalMemberMin(lCollectionIndex));
        }
        else if (wFlags & DISPATCH_PROPERTYGET)
        {
            VARIANTARG      v1;
            VARIANTARG      v2;
            WCHAR          *pch = NULL;
            long            lIndex = id - GetOrdinalMemberMin(lCollectionIndex);

            if (!((lIndex >= 0) && (lIndex < Size(lCollectionIndex))))
            {
                hr = S_OK;
                if (pvarResult)
                {
                    VariantClear(pvarResult);
                    pvarResult->vt = VT_NULL;
                    return S_OK;
                }
            }

            v1.vt = VT_I4;
            v1.lVal = lIndex;

            // Always get the item by index.
            v2.vt = VT_ERROR;

            if (pvarResult)
            {
                hr = item(lCollectionIndex, v1, v2, &(pvarResult->pdispVal));
                if (SUCCEEDED(hr))
                {
                    if (!(pvarResult->pdispVal))
                    {
                        hr = E_FAIL;        // use super::Invoke
                    }
                    else
                    {
                        pvarResult->vt = VT_DISPATCH;
                    }
                }
            }
            return hr;
        }

        TraceTag((tagError, "CCollectionCache::InvokeEx - Invalid invocation of ordinal ID"));
        return DISP_E_MEMBERNOTFOUND;
    }

    //
    // check for expando
    //
    if (IsNamedCollectionMember(lCollectionIndex, id))
    {
        bool  fCaseSensitive;
        long  lOffset;

        lOffset = GetNamedMemberOffset(lCollectionIndex, id, &fCaseSensitive);

        const WCHAR  *pwszName;
        hr = m_pAtomTable->GetNameFromAtom(id - lOffset, &pwszName);
        if (FAILED(hr))
        {
            TraceTag((tagError, "CCollectionCache::InvokeEx - GetNameFromAtom() failed"));
            return hr;
        }

        // find name
        IDispatch *pDisp = NULL;
        hr = GetDisp(lCollectionIndex,
                     pwszName,
                     false,
                     &pDisp,
                     fCaseSensitive);
        if (FAILED(hr))
        {
            TraceTag((tagError, "CCollectionCache::InvokeEx - unable to GetDisp for expando"));
            return hr;
        }

        Assert(pDisp != NULL);
        UINT* puArgErr = NULL;

        if (wFlags == DISPATCH_PROPERTYGET ||
            wFlags == (DISPATCH_METHOD | DISPATCH_PROPERTYGET))
        {
            if (pvarResult == NULL)
            {
                TraceTag((tagError, "CCollectionCache::InvokeEx - invalid param (VARIANT*)"));
                return E_POINTER;
            }

            // cArgs==1 when Doc.foo(0) is used and =0 when Doc.foo.count
            //  this is only an issue when there are multiple occurances
            //  of foo, and a collection is supposed to be returned by
            //  document.foo
            if (pdispparams->cArgs > 1)
            {
                TraceTag((tagError, "CCollectionCache::InvokeEx - bad param count on get_/method call"));
                return DISP_E_BADPARAMCOUNT;
            }
            else if (pdispparams->cArgs == 1)
            {
                return pDisp->Invoke(DISPID_VALUE, IID_NULL, lcid, wFlags, pdispparams, pvarResult, pexcepinfo, puArgErr);
            }
            else
            {
                V_VT(pvarResult) = VT_DISPATCH;
                V_DISPATCH(pvarResult) = pDisp;
                return S_OK;
            }
        }
        else if (wFlags == DISPATCH_PROPERTYPUT ||
                 wFlags == DISPATCH_PROPERTYPUTREF)
        {
            if (pdispparams->cArgs != 1)
            {
                TraceTag((tagError, "CCollectionCache::InvokeEx - bad param count on put_ call"));
                return DISP_E_BADPARAMCOUNT;
            }

            return pDisp->Invoke(DISPID_VALUE, IID_NULL, lcid, wFlags, pdispparams, pvarResult, pexcepinfo, puArgErr);
        }

        // Any other kind of invocation is not valid.
        TraceTag((tagError, "CCollectionCache::InvokeEx - Invalid invocation of Named ID"));
        return DISP_E_MEMBERNOTFOUND;
    }

    // punt back to outer Invoke...
    return DISP_E_MEMBERNOTFOUND;
} // InvokeEx

//************************************************************
// Author:	twillie
// Created:	02/06/98
// Abstract:    Implementation of IDispatchEx - deleteMemberByName
//              Not needed
//************************************************************

HRESULT
CCollectionCache::DeleteMemberByName(long lCollectionIndex, BSTR bstrName, DWORD grfdex)
{
    return E_NOTIMPL;
} // deleteMemberByName

//************************************************************
// Author:	twillie
// Created:	02/06/98
// Abstract:    Implementation of IDispatchEx - deleteMemberByDispID
//              Not needed
//************************************************************

HRESULT
CCollectionCache::DeleteMemberByDispID(long lCollectionIndex, DISPID id)
{
    return E_NOTIMPL;
} // GetMemberProperties

//************************************************************
// Author:	twillie
// Created:	02/06/98
// Abstract:    Implementation of IDispatchEx - GetMemberProperties
//              Not needed
//************************************************************

HRESULT
CCollectionCache::GetMemberProperties(long lCollectionIndex, DISPID id, DWORD grfdexFetch, DWORD* pgrfdex)
{
    if (!ValidateCollectionIndex(lCollectionIndex))
    {
        TraceTag((tagError, "CCollectionCache::GetMemberProperties - Invalid param (collection index)"));
        return E_INVALIDARG;
    }

    if (pgrfdex == NULL)
    {
        TraceTag((tagError, "CCollectionCache::GetMemberProperties - Invalid param (DWORD*)"));
        return E_POINTER;
    }

    *pgrfdex = 0;
    return E_NOTIMPL;
} // GetMemberProperties

//************************************************************
// Author:	twillie
// Created:	02/06/98
// Abstract:    Implementation of IDispatchEx - GetMemberName
//************************************************************

HRESULT
CCollectionCache::GetMemberName(long lCollectionIndex, DISPID id, BSTR *pbstrName)
{
    if (!ValidateCollectionIndex(lCollectionIndex))
    {
        TraceTag((tagError, "CCollectionCache::GetMemberName - Invalid param (collection index)"));
        return E_INVALIDARG;
    }

    if (pbstrName == NULL)
    {
        TraceTag((tagError, "CCollectionCache::GetMemberName - Invalid param (BSTR*)"));
        return E_POINTER;
    }

    *pbstrName = NULL;

    // Make sure our collection is up-to-date.
    HRESULT hr = EnsureArray(lCollectionIndex);
    if (FAILED(hr))
    {
        TraceTag((tagError, "CCollectionCache::GetMemberName - unable to ensure array"));
        return S_FALSE;
    }

    // check to see if DISPID is an ordinal
    if (IsOrdinalCollectionMember(lCollectionIndex, id))
    {
        long lOffset = id - GetOrdinalMemberMin(lCollectionIndex);
        CTIMEElementBase *pElem = NULL;

        // element
        hr = GetItemByIndex(lCollectionIndex, lOffset, &pElem);
        if (FAILED(hr) || (pElem == NULL))
        {
            TraceTag((tagError, "CCollectionCache::GetMemberName - GetItemByIndex() failed"));
            return DISP_E_MEMBERNOTFOUND;
        }

        Assert(pElem != NULL);

        if ((*m_rgItems[lCollectionIndex])->m_fPromoteNames)
        {
            // get ID string
            hr = pElem->getIDString(pbstrName);
            if (FAILED(hr))
            {
                TraceTag((tagError, "CCollectionCache::GetMemberName - unable to find ID for element"));
                return DISP_E_MEMBERNOTFOUND;
            }
        }

        // check to see that it's either NULL or ""
        // if so, stick offset in string
        if ((*pbstrName == NULL) || (lstrlenW(*pbstrName) == 0))
        {
            // set offset as text
            VARIANT varData;
            VariantInit(&varData);

            V_VT(&varData) = VT_I4;
            V_I4(&varData) = lOffset;

            VARIANT varNew;
            VariantInit(&varNew);
            hr = VariantChangeTypeEx(&varNew, &varData, LCID_SCRIPTING, VARIANT_NOUSEROVERRIDE, VT_BSTR);
            if (FAILED(hr))
            {
                TraceTag((tagError, "CCollectionCache::GetMemberName - Unable to coerce long to BSTR"));
                // NOTE: we return DISP_E_MEMBERNOTFOUND instead of hr
                //       due to predefined method constraints
                return DISP_E_MEMBERNOTFOUND;
            }

            // Since we are going to return the BSTR, no need calling ClearVariant(&varNew).
            VariantClear(&varData);
            *pbstrName = V_BSTR(&varNew);
            return S_OK;
        }

        return S_OK;
    }

    // unable to find DISPID
    return DISP_E_MEMBERNOTFOUND;
} // GetMemberName

//************************************************************
// Author:	twillie
// Created:	02/06/98
// Abstract:    Implementation of IDispatchEx - GetNextDispID
//************************************************************

HRESULT
CCollectionCache::GetNextDispID(long lCollectionIndex, DWORD grfdex, DISPID id, DISPID *prgid)
{
    HRESULT hr;

    if (!ValidateCollectionIndex(lCollectionIndex))
    {
        TraceTag((tagError, "CCollectionCache::GetNextDispID - Invalid param (collection index)"));
        return E_INVALIDARG;
    }

    if (prgid == NULL)
    {
        TraceTag((tagError, "CCollectionCache::GetNextDispID - Invalid param (DISPID*)"));
        return E_POINTER;
    }

    *prgid = 0;

    // Make sure our collection is up-to-date.
    hr = EnsureArray(lCollectionIndex);
    if (FAILED(hr))
    {
        TraceTag((tagError, "CCollectionCache::GetNextDispID - unable to ensure array"));
        return S_FALSE;
    }

    // check to see if we are have been sent the enumerator index. (FFFFFFFF)
    if (id == DISPID_STARTENUM)
    {
         // move to the beginning of the array (0)
         *prgid = GetOrdinalMemberMin(lCollectionIndex);
         return S_OK;
    }

    // validate that we are working with ordinals
    if (IsOrdinalCollectionMember(lCollectionIndex, id))
    {
        // calc new offset
        long lItemIndex = id - GetOrdinalMemberMin(lCollectionIndex) + 1;

        // Is the number within range for an item in the collection?
        // We *must* call GetItemCount to be exact.
        long lSize = 0;
        hr = GetItemCount(lCollectionIndex, &lSize);
        if (FAILED(hr))
        {
            TraceTag((tagError, "CCollectionCache::GetNextDispID - GetItemCount() failed"));
            return S_FALSE;
        }

        // this is usually were we stop
        if ((lItemIndex < 0) || (lItemIndex >= lSize))
        {
            return S_FALSE;
        }

        // calc new DISPID
        *prgid = GetOrdinalMemberMin(lCollectionIndex) + lItemIndex;

        // check to see if calc DISPID is out of range
        if (*prgid > GetOrdinalMemberMax(lCollectionIndex))
        {
            // this signal's that we are done.
            *prgid = DISPID_UNKNOWN;
        }
        return S_OK;
    }

    // not found
    return S_FALSE;
} // GetNextDispID

//************************************************************
// Author:	twillie
// Created:	02/06/98
// Abstract:    Implementation of IDispatchEx - GetNameSpaceParent
//************************************************************

HRESULT
CCollectionCache::GetNameSpaceParent(long lCollectionIndex, IUnknown **ppUnk)
{
    HRESULT hr;

    if (!ValidateCollectionIndex(lCollectionIndex))
    {
        TraceTag((tagError, "CCollectionCache::GetNameSpaceParent - Invalid param (collection index)"));
        return E_INVALIDARG;
    }

    if (ppUnk == NULL)
    {
        TraceTag((tagError, "CCollectionCache::GetNameSpaceParent - Invalid param (IUnknown**)"));
        return E_POINTER;
    }

    *ppUnk = NULL;
    return S_OK;
} // GetNameSpaceParent

//************************************************************
// Author:	twillie
// Created:	02/06/98
// Abstract:    Implementation of standard Collection - get_length
//************************************************************

HRESULT
CCollectionCache::get_length(long lCollectionIndex, long *pretval)
{
    if (!ValidateCollectionIndex(lCollectionIndex))
    {
        TraceTag((tagError, "CCollectionCache::get_length - Invalid param (collection index)"));
        return E_INVALIDARG;
    }

    if (pretval == NULL)
    {
        TraceTag((tagError, "CCollectionCache::get_length - Invalid param (long*)"));
        return E_POINTER;
    }

    *pretval = 0;

    // Make sure our collection is up-to-date.
    HRESULT hr = EnsureArray(lCollectionIndex);
    if (FAILED(hr))
    {
        TraceTag((tagError, "CCollectionCache::get_length - unable to ensure array"));
        return hr;
    }

    return GetItemCount(lCollectionIndex, pretval);
} // get_length

//************************************************************
// Author:	twillie
// Created:	02/06/98
// Abstract:    Implementation of standard Collection - put_length
//              not needed.
//************************************************************

HRESULT
CCollectionCache::put_length(long lCollectionIndex, long retval)
{
    return E_NOTIMPL;
} // put_length

//************************************************************
// Author:	twillie
// Created:	02/06/98
// Abstract:    item is a standard method for collections
//              which looks up an item in a collection using
//              either a name or a numeric index.
//
//              we handle the following parameter cases:
//                  0 params            : by index = 0
//                  1 params bstr       : by name, index = 0
//                  1 params #          : by index
//                  2 params bstr, #    : by name, index
//                  2 params #, bstr    : by index, ignoring bstr
//************************************************************

HRESULT
CCollectionCache::item(long lCollectionIndex, VARIANTARG var1, VARIANTARG var2, IDispatch **ppDisp)
{
    HRESULT   hr;
    CTIMEElementBase *pElem = NULL;
    VARIANT  *pvarName = NULL;
    VARIANT  *pvarIndex = NULL;
    VARIANT  *pvar = NULL;
    long     lItemIndex = 0;

    // validate out param
    if (!ValidateCollectionIndex(lCollectionIndex))
    {
        TraceTag((tagError, "CCollectionCache::item - Invalid param (collection index)"));
        return E_INVALIDARG;
    }

    if (ppDisp == NULL)
    {
        TraceTag((tagError, "CCollectionCache::item - Invalid param (IDispatch**)"));
        return E_POINTER;
    }

    // initialize out param
    *ppDisp = NULL;

    pvar = (V_VT(&var1) == (VT_BYREF | VT_VARIANT)) ? V_VARIANTREF(&var1) : &var1;

    // check to see if first param is a string
    if ((V_VT(pvar) == VT_BSTR) || V_VT(pvar) == (VT_BYREF|VT_BSTR))
    {
        pvarName = (V_VT(pvar) & VT_BYREF) ? V_VARIANTREF(pvar) : pvar;

        // check second param.  If valid, it must be a secondary index (numeric)
        if ((V_VT(&var2) != VT_ERROR) && (V_VT(&var2) != VT_EMPTY))
        {
            pvarIndex = &var2;
        }
    }
    // first param is an index.
    // NOTE: we blow off the second param
    else if ((V_VT(&var1) != VT_ERROR) && (V_VT(&var1) != VT_EMPTY))
    {
        pvarIndex = &var1;
    }

    // Make sure our collection is up-to-date.
    hr = EnsureArray(lCollectionIndex);
    if (FAILED(hr))
    {
        TraceTag((tagError, "CCollectionCache::item- unable to ensure array"));
        return hr;
    }

    // if we have a pvarIndex, get it
    if (pvarIndex)
    {
        VARIANT varNum;

        VariantInit(&varNum);

        hr = VariantChangeTypeEx(&varNum, pvarIndex, LCID_SCRIPTING, VARIANT_NOUSEROVERRIDE, VT_I4);
        if (FAILED(hr))
        {
            TraceTag((tagError, "CCollectionCache::item - unable to convert variant to index"));
            return hr;
        }

        lItemIndex = V_I4(&varNum);

        VariantClear(&varNum);
    }

    // First, see if we have a string as first param
    if (pvarName)
    {
        BSTR bstrName = V_BSTR(pvarName);

        // NOTE: lItemIndex is always passed in.  In the case
        // were we have no secondary index specifed, it will
        // always be zero.
        if (pvarIndex)
        {
            // this ALWAYS returns a single CTIMEElementBase
            hr = GetDisp(lCollectionIndex, bstrName, lItemIndex, ppDisp);
            if (hr == DISP_E_MEMBERNOTFOUND)
                hr = S_OK;
            return hr;
        }
        else
        {
            // this could return either a collection or an CTIMEElementBase
            hr = GetDisp(lCollectionIndex, bstrName, false, ppDisp);
            if (hr == DISP_E_MEMBERNOTFOUND)
                hr = S_OK;
            return hr;
        }
    }
    else if (pvarIndex)
    {
        // this ALWAYS returns a single CTIMEElementBase
        hr = GetDisp(lCollectionIndex, lItemIndex, ppDisp);
        if (hr == DISP_E_MEMBERNOTFOUND)
            hr = S_OK;
        return hr;
    }

    TraceTag((tagError, "CCollectionCache::item - Invalid args passed in to ::item"));
    return E_INVALIDARG;
} //item

//************************************************************
// Author:	twillie
// Created:	02/06/98
// Abstract:    get__NewEnum is a standard method for collections
//              returns an enumeration of all the items in a
//              collection.
//************************************************************

HRESULT
CCollectionCache::get__newEnum(long lCollectionIndex, IUnknown **ppUnk)
{
    HRESULT hr;

    if (!ValidateCollectionIndex(lCollectionIndex))
    {
        TraceTag((tagError, "CCollectionCache::get__newEnum - Invalid param (collection index)"));
        return E_INVALIDARG;
    }

    if (ppUnk == NULL)
    {
        TraceTag((tagError, "CCollectionCache::get__newEnum - Invalid param (IUnknown**)"));
        return E_POINTER;
    }

    *ppUnk = NULL;

    // Make sure our collection is up-to-date.
    hr = EnsureArray(lCollectionIndex);
    if (FAILED(hr))
    {
        TraceTag((tagError, "CCollectionCache::get__newEnum - unable to ensure array"));
        return hr;
    }

    // Create new array
    CPtrAry<IUnknown *> *prgElem = NEW CPtrAry<IUnknown *>;
    if (prgElem == NULL)
    {
        TraceTag((tagError, "CCollectionCache::get__newEnum - unable to alloc mem for ptr array"));
        return E_OUTOFMEMORY;
    }

    // child collection
    if (IsChildrenCollection(lCollectionIndex))
    {
        Assert(m_pBase != NULL);

        // get child count
        long lCount = m_pBase->GetImmediateChildCount();
        // loop through, adding children
        for(long lIndex = 0; lIndex < lCount; lIndex++)
        {
            // get element
            CTIMEElementBase *pElemChild = m_pBase->GetChild(lIndex);
            Assert(pElemChild != NULL);
            // get IUnknown for element
            IUnknown *pIUnknown = NULL;
            hr = GetUnknown(lCollectionIndex, pElemChild, &pIUnknown);
            if (FAILED(hr))
            {
                TraceTag((tagError, "CCollectionCache::get__newEnum - unable to find IUnknown for element"));
                prgElem->ReleaseAll();
                delete prgElem;
                return hr;
            }

            // append to array
            hr = prgElem->Append(pIUnknown);
            if (FAILED(hr))
            {
                TraceTag((tagError, "CCollectionCache::get__newEnum - unable to append pointer"));
                ReleaseInterface(pIUnknown);
                prgElem->ReleaseAll();
                delete prgElem;
                return hr;
            }
        }
    }
    else if (IsAllCollection(lCollectionIndex)) // is it all collection?
    {
        EnumStart();

        // iterate over every element
        for (;;)
        {
            // get element
            CTIMEElementBase *pElem = NULL;
            hr = EnumNextElement(lCollectionIndex, &pElem);
            if (FAILED(hr))
            {
                TraceTag((tagError, "CCollectionCache::get__newEnum - EnumNextElement() failed"));
                prgElem->ReleaseAll();
                delete prgElem;
                return hr;
            }

            // if pElem is NULL, we are done.
            if (pElem == NULL)
                break;

            // get IUnknown for element
            IUnknown *pIUnknown = NULL;
            hr = GetUnknown(lCollectionIndex, pElem, &pIUnknown);
            if (FAILED(hr))
            {
                TraceTag((tagError, "CCollectionCache::get__newEnum - unable to find IUnknown for element"));
                prgElem->ReleaseAll();
                delete prgElem;
                return hr;
            }

            // append to array
            hr = prgElem->Append(pIUnknown);
            if (FAILED(hr))
            {
                TraceTag((tagError, "CCollectionCache::get__newEnum - unable to append pointer"));
                ReleaseInterface(pIUnknown);
                prgElem->ReleaseAll();
                delete prgElem;
                return hr;
            }

        }
    }
    else // must be an array impl
    {
        long lSize = (*m_rgItems)[lCollectionIndex]->m_rgElem->Size();

        // This is a speed thing.  Since we know the size, alloc now for
        // array.
        hr = prgElem->EnsureSize(lSize);
        if (FAILED(hr))
        {
            TraceTag((tagError, "CCollectionCache::get__newEnum - unable to ensure array"));
            prgElem->ReleaseAll();
            delete prgElem;
            return hr;
        }

        for (long lIndex = 0; lIndex < lSize; lIndex++)
        {
            IDispatch * pdisp;

            hr = GetDisp(lCollectionIndex, lIndex, &pdisp);
            if (FAILED(hr))
            {
                TraceTag((tagError, "CCollectionCache::get__newEnum - GetDisp() failed for index"));
                prgElem->ReleaseAll();
                delete prgElem;
                return hr;
            }

            hr = prgElem->Append(pdisp);
            if (FAILED(hr))
            {
                TraceTag((tagError, "CCollectionCache::get__newEnum - unable to append item"));
                prgElem->ReleaseAll();
                delete prgElem;
                return hr;
            }
        }
    } // end of "else everything"

    // Turn the snapshot into an enumerator.
    hr = prgElem->EnumVARIANT(VT_DISPATCH, (IEnumVARIANT **)ppUnk, FALSE, TRUE);
    if (FAILED(hr))
    {
        TraceTag((tagError, "CCollectionCache::get__newEnum - EnumVARIANT() failed"));
        prgElem->ReleaseAll();
        delete prgElem;
    }

    return hr;
} // get__newEnum

//************************************************************
// Author:	twillie
// Created:	02/06/98
// Abstract:    Return a subcollection containing only the
//              elements of this collection that have the
//              specified tag name.
//************************************************************

HRESULT
CCollectionCache::tags(long lCollectionIndex, VARIANT var1, IDispatch** ppDisp)
{
    if (!ValidateCollectionIndex(lCollectionIndex))
    {
        TraceTag((tagError, "CCollectionCache::tags - Invalid param (Collection index)"));
        return E_INVALIDARG;
    }

    if (ppDisp == NULL)
    {
        TraceTag((tagError, "CCollectionCache::tags - Invalid param (IDispatch**)"));
        return E_POINTER;
    }

    *ppDisp = NULL;

    VARIANT *pvarName = NULL;
    pvarName = (V_VT(&var1) == (VT_BYREF | VT_VARIANT)) ? V_VARIANTREF(&var1) : &var1;

    if ((V_VT(pvarName)==VT_BSTR) || V_VT(pvarName)==(VT_BYREF|VT_BSTR))
    {
        pvarName = (V_VT(pvarName)&VT_BYREF) ? V_VARIANTREF(pvarName) : pvarName;
    }
    else
    {
        return DISP_E_MEMBERNOTFOUND;
    }

    // Make sure our collection is up-to-date.
    HRESULT hr = EnsureArray(lCollectionIndex);
    if (FAILED(hr))
    {
        TraceTag((tagError, "CCollectionCache::item- unable to ensure array"));
        return hr;
    }

    // Get a collection of the specified tags.
    // NOTE: ALWAYS returns a collection
    return GetDisp(lCollectionIndex, V_BSTR(pvarName), true, ppDisp);
} //get_tags

//************************************************************
// Author:	twillie
// Created:	02/06/98
// Abstract:    returns Size of a collection
//************************************************************

long
CCollectionCache::Size(long lCollectionIndex)
{
    if (!ValidateCollectionIndex(lCollectionIndex))
    {
        TraceTag((tagError, "CCollectionCache::Size - invalid param (collection index)"));
        return E_INVALIDARG;
    }

    // Make sure our collection is up-to-date.
    HRESULT hr = EnsureArray(lCollectionIndex);
    if (FAILED(hr))
    {
        TraceTag((tagError, "CCollectionCache::Size - unable to ensure array"));
        return hr;
    }

    // if all or children collection, use GetItemCount
    if (IsChildrenCollection(lCollectionIndex) || IsAllCollection(lCollectionIndex))
    {
        long    cElem = 0;
        hr = GetItemCount(lCollectionIndex, &cElem);
        if (FAILED(hr)) {
            TraceTag((tagError, "CCollectionCache::Size - GetItemCount() failed"));
        }

        return cElem;
    }
    else
    {
        // must be an array. return size.
        return (*m_rgItems)[lCollectionIndex]->m_rgElem->Size();
    }
}

HRESULT
CCollectionCache::GetItem(long lCollectionIndex, long i, CTIMEElementBase **ppElem)
{
    if (!ValidateCollectionIndex(lCollectionIndex))
    {
        TraceTag((tagError, "CCollectionCache::GetItem - invalid param (collection index)"));
        return E_INVALIDARG;
    }

    if (ppElem == NULL)
    {
        TraceTag((tagError, "CCollectionCache::GetItem - invalid param (CTIMEElementBase**)"));
        return E_POINTER;
    }

    // if all or children collection, use GetItemByIndex
    if (IsChildrenCollection(lCollectionIndex) || IsAllCollection(lCollectionIndex))
    {
        HRESULT hr = GetItemByIndex(lCollectionIndex, i, ppElem);
        if (FAILED(hr))
        {
            if (hr == DISP_E_MEMBERNOTFOUND)
                TraceTag((tagCollectionCache, "CCollectionCache::GetItem - GetItemByIndex didn't find anything!"));
            else
                TraceTag((tagError, "CCollectionCache::GetItem - GetItemByIndex() failed"));
        }
        return hr;
    }
    else
    {
        // must be array.  access index.
        CCacheItem *pce = (*m_rgItems)[lCollectionIndex];
        Assert(pce != NULL);
        *ppElem = (*pce->m_rgElem)[i];
        return S_OK;
    }
} // GetItem

//************************************************************
// Author:	twillie
// Created:	02/06/98
// Abstract:    Validate the given collection Index
//************************************************************

HRESULT
CCollectionCache::EnsureArray(long lCollectionIndex)
{
    HRESULT hr = S_OK;

    if (m_pfnEnsure)
    {
        hr = (((CVoid *)(void *)m_pBase)->*m_pfnEnsure)(&m_lCollectionVersion);
        if (FAILED(hr))
        {
            TraceTag((tagError, "CCollectionCache::EnsureArray - outer Ensure function failed"));
            return hr;
        }
    }

    // used for customized collections
    //
    // if versions don't match invalidate everything
    if (m_lCollectionVersion != m_lDynamicCollectionVersion)
    {
        long lSize = m_rgItems->Size();
        for (long lIndex = m_lReservedSize; lIndex < lSize; lIndex++)
            (*m_rgItems)[lIndex]->m_fInvalid = true;

        // reset version number
        m_lDynamicCollectionVersion = m_lCollectionVersion;
    }

    CCacheItem *pce = (*m_rgItems)[lCollectionIndex];
    if ((lCollectionIndex >= m_lReservedSize) && pce->m_fInvalid)
    {
        // Ensure the collection we're based upon
        // note that this is a recursive call
        hr = EnsureArray(pce->m_lDependentIndex);
        if (FAILED(hr))
            return hr;

        switch (pce->m_cctype)
        {
        case ctTag:
            // Rebuild based on name
            hr = BuildNamedArray(pce->m_lDependentIndex,
                                 pce->m_bstrName,
                                 true,
                                 &pce->m_rgElem);
            if (hr == S_OK)
                pce->m_fInvalid = false;
            break;

        case ctNamed:
            // Rebuild based on tag name
            hr = BuildNamedArray(pce->m_lDependentIndex,
                                 pce->m_bstrName,
                                 false,
                                 &pce->m_rgElem);
            if (hr == S_OK)
                pce->m_fInvalid = false;
            break;


            // all && children collection is dynamic, no need to rebuild
        case ctChildren:
        case ctAll:
            TraceTag((tagError, "CCollectionCache::EnsureArray - This is odd.  Why are we doing this?"));
            Assert(false);
            break;

        case ctFreeEntry:
            // Free collection waiting to be reused
            break;

        default:
            TraceTag((tagError, "CCollectionCache::EnsureArray - invalid cache type"));
            Assert(false);
            break;
        }
    }

    return hr;
} // EnsureArray

//************************************************************
// Author:	twillie
// Created:	02/06/98
// Abstract:    This gets the out IDispatch for a given CTIMEElementBase
//************************************************************

HRESULT
CCollectionCache::GetOuterDisp(long lCollectionIndex, CTIMEElementBase *pElem, IDispatch **ppDisp)
{
    Assert(ppDisp != NULL);
    *ppDisp = NULL;

    Assert(pElem != NULL);

    HRESULT hr = E_UNEXPECTED;
    CCacheItem *pce = (*m_rgItems)[lCollectionIndex];
    Assert(pce != NULL);

    if (pce->m_fReturnHTMLInterface)
    {
        IHTMLElement *pHTMLElem = pElem->GetElement();
        Assert(NULL != pHTMLElem);
        hr = pHTMLElem->QueryInterface(IID_TO_PPV(IDispatch, ppDisp));
        if (FAILED(hr)) {
            TraceTag((tagError, "CCollectionCache::GetOuterDisp - QI failed (HTML)"));
        }
    }
    else
    {
        ITIMEElement *pTIMEElem = NULL;
        hr = pElem->QueryInterface(IID_TO_PPV(ITIMEElement, &pTIMEElem));
        Assert(SUCCEEDED(hr) && (pTIMEElem != NULL));
        hr = pTIMEElem->QueryInterface(IID_TO_PPV(IDispatch, ppDisp));
        if (FAILED(hr)) {
            TraceTag((tagError, "CCollectionCache::GetOuterDisp - QI failed (TIME)"));
        }
    }

    return hr;
} // GetOuterDisp

//************************************************************
// Author:	twillie
// Created:	02/06/98
// Abstract:    Creates a new collection
//************************************************************

HRESULT
CCollectionCache::CreateCollectionHelper(IDispatch **ppDisp, long lCollectionIndex)
{
    HRESULT hr;

    *ppDisp = NULL;

    if (m_pfnCreateCollection)
    {
        return (((CVoid *)(void *)m_pBase)->*m_pfnCreateCollection)(ppDisp, lCollectionIndex);
    }

    CTIMEElementCollection *pobj = NEW CTIMEElementCollection(this, lCollectionIndex);
    if (pobj == NULL)
    {
        TraceTag((tagError, "CCollectionCache::CreateCollectionHelper - unable to alloc mem for collection"));
        return E_OUTOFMEMORY;
    }

    hr = pobj->QueryInterface(IID_TO_PPV(IDispatch, ppDisp));
    return hr;
} // CreateCollectionHelper

//************************************************************
// Author:	twillie
// Created:	02/06/98
// Abstract:    retrieved offset of Named Member, given a DISPID
//************************************************************

long
CCollectionCache::GetNamedMemberOffset(long    lCollectionIndex,
                                       DISPID  id,
                                       bool   *pfCaseSensitive /* = NULL */)
{
    long lOffset;
    bool fSensitive;

    Assert(IsNamedCollectionMember(lCollectionIndex, id));

    // Check to see wich half of the dispid space the value goes
    if (IsSensitiveNamedCollectionMember(lCollectionIndex, id))
    {
        lOffset = GetSensitiveNamedMemberMin(lCollectionIndex);
        fSensitive = true;
    }
    else
    {
        lOffset = GetNotSensitiveNamedMemberMin(lCollectionIndex);
        fSensitive = false;
    }

    // return the sensitivity flag if required
    if (pfCaseSensitive != NULL)
        *pfCaseSensitive = fSensitive;

    return lOffset;
} // GetNamedMemberOffset

//************************************************************
// Author:	twillie
// Created:	02/06/98
// Abstract:    Compares names
//************************************************************

bool
CCollectionCache::CompareName(CTIMEElementBase *pElem, const WCHAR *pwszName, bool fTagName, bool fCaseSensitive /* = false */)
{
    if (pwszName == NULL)
        return false;

    BSTR bstrSrcName = NULL;
    HRESULT hr;
    if (fTagName)
        hr = pElem->getTagString(&bstrSrcName);
    else
        hr = pElem->getIDString(&bstrSrcName);

    if (FAILED(hr))
    {
        TraceTag((tagError, "Unable to retrieve src name from element"));
        return false;
    }

    if (bstrSrcName == NULL)
        return false;

    long lCompare;
    if (fCaseSensitive)
        lCompare = StrCmpW(bstrSrcName, pwszName);
    else
        lCompare = StrCmpIW(bstrSrcName, pwszName);

    // free bstr
    SysFreeString(bstrSrcName);

    return (lCompare == 0);
} // CompareName

//************************************************************
// Author:	twillie
// Created:	02/06/98
// Abstract:    removes an item from collection.
//              NOTE: that in order to do this, caller (owner
//              of the cache) need to provide Remove function.
//************************************************************

HRESULT
CCollectionCache::Remove(long lCollectionIndex, long lItemIndex)
{
    // Make sure our collection is up-to-date.
    HRESULT hr = EnsureArray(lCollectionIndex);
    if (FAILED(hr))
    {
        TraceTag((tagError, "CCollectionCache::Remove - unable to ensure array"));
        return hr;
    }

    CCacheItem *pce = (*m_rgItems)[lCollectionIndex];
    if ((lItemIndex < 0) || (lItemIndex >= pce->m_rgElem->Size()))
    {
        TraceTag((tagError, "CCollectionCache::Remove - invalid index"));
        return E_INVALIDARG;
    }

    if (!m_pfnRemoveObject)
    {
        TraceTag((tagError, "CCollectionCache::Remove - outer function not defined"));
        return CTL_E_METHODNOTAPPLICABLE;
    }

    return ((CVoid *)((void *)m_pBase)->*m_pfnRemoveObject)(lCollectionIndex, lItemIndex);
} // Remove

//************************************************************
// Author:	twillie
// Created:	02/06/98
// Abstract:    Builds a Named array from a given collection
//************************************************************

HRESULT
CCollectionCache::BuildNamedArray(long lCollectionIndex, const WCHAR *pwszName, bool fTagName, CPtrAry<CTIMEElementBase *> **prgNamed, bool fCaseSensitive /* = false */)
{
    CPtrAry<CTIMEElementBase *> *rgTemp = *prgNamed;
    HRESULT                      hr = S_OK;

    // if this array already exists, clear it.
    // Otherwise create a new array.
    if (rgTemp)
    {
        rgTemp->SetSize(0);
    }
    else
    {
        rgTemp = NEW CPtrAry<CTIMEElementBase *>;
        if (rgTemp == NULL)
        {
            TraceTag((tagError, "CCollectionCache::BuildNamedArray - unable to alloc mem for array"));
            return E_OUTOFMEMORY;
        }
    }

    // figure out which collection we are looking at,
    // look for matches, and build array

    if (IsChildrenCollection(lCollectionIndex))
    {
        Assert(m_pBase != NULL);

        // get child count
        long lCount = m_pBase->GetImmediateChildCount();
        for(long lIndex = 0; lIndex < lCount; lIndex++)
        {
            // get element
            CTIMEElementBase *pElemChild = m_pBase->GetChild(lIndex);
            Assert(pElemChild != NULL);

            if (CompareName(pElemChild, pwszName, fTagName, fCaseSensitive))
            {
                // append to array
                hr = rgTemp->Append(pElemChild);
                if (FAILED(hr))
                {
                    TraceTag((tagError, "CCollectionCache::BuildNamedArray - unable to append item"));
                    delete rgTemp;
                    return hr;
                }
            }
        }
        *prgNamed = rgTemp;
        return hr;
    }
    else if (IsAllCollection(lCollectionIndex))
    {
        EnumStart();

        // iterate over every element
        for (;;)
        {
            // get element
            CTIMEElementBase *pElem = NULL;
            hr = EnumNextElement(lCollectionIndex, &pElem);
            if (FAILED(hr))
            {
                TraceTag((tagError, "CCollectionCache::BuildNamedArray - EnumNextElement() failed"));
                return hr;
            }

            // if pElem is NULL, we are done.
            if (pElem == NULL)
                break;

            // compare name
            if (CompareName(pElem, pwszName, fTagName, fCaseSensitive))
            {
                // append to array
                hr = rgTemp->Append(pElem);
                if (FAILED(hr))
                {
                    TraceTag((tagError, "CCollectionCache::BuildNamedArray - unable to append item"));
                    delete rgTemp;
                    return hr;
                }
            }
        }
        *prgNamed = rgTemp;
        return hr;
    }
    else
    {
        // Must be a named array
        // Build a list of named elements.
        long               lSize = (*m_rgItems)[lCollectionIndex]->m_rgElem->Size();
        CTIMEElementBase  *pElem = NULL;

        for (long lIndex = 0; lIndex < lSize; lIndex++)
        {
            pElem = (*(*m_rgItems)[lCollectionIndex]->m_rgElem)[lIndex];
            Assert(pElem != NULL);

            if (CompareName(pElem, pwszName, fTagName, fCaseSensitive))
            {
                hr = rgTemp->Append(pElem);
                if (FAILED(hr))
                {
                    TraceTag((tagError, "CCollectionCache::BuildNamedArray - unable to append item"));
                    delete rgTemp;
                    return hr;
                }
            }
        }

        *prgNamed = rgTemp;
        return hr;
    }
} // BuildNamedArray

//************************************************************
// Author:	twillie
// Created:	02/06/98
// Abstract:    return IUnknown Interface for a given CTIMEElementBase
//************************************************************

HRESULT
CCollectionCache::GetUnknown(long lCollectionIndex, CTIMEElementBase *pElem, IUnknown **ppUnk)
{
    Assert(ppUnk != NULL);
    *ppUnk = NULL;

    Assert(pElem != NULL);

    HRESULT hr = E_UNEXPECTED;
    CCacheItem *pce = (*m_rgItems)[lCollectionIndex];
    Assert(pce != NULL);

    if (pce->m_fReturnHTMLInterface)
    {
        ITIMEElement *pTIMEElem = NULL;
        THR(pElem->QueryInterface(IID_TO_PPV(ITIMEElement, &pTIMEElem)));
        Assert(SUCCEEDED(hr) && (pTIMEElem != NULL));
        hr = pTIMEElem->QueryInterface(IID_TO_PPV(IUnknown, ppUnk));
        if (FAILED(hr)) {
            TraceTag((tagError, "CCollectionCache::GetUnknown - QI failed (TIME)"));
        }
    }
    else
    {
        IHTMLElement *pHTMLElem = pElem->GetElement();
        Assert(NULL != pHTMLElem);
        hr = pHTMLElem->QueryInterface(IID_TO_PPV(IUnknown, ppUnk));
        if (FAILED(hr)) {
            TraceTag((tagError, "CCollectionCache::GetUnknown - QI failed (HTML)"));
        }
    }

    return hr;
} // GetUnknown

//************************************************************
// Author:	twillie
// Created:	02/06/98
// Abstract:    Get IDispatch given an Index into a collection
//************************************************************

HRESULT
CCollectionCache::GetDisp(long lCollectionIndex, long lItemIndex, IDispatch **ppDisp)
{
    CTIMEElementBase *pElem = NULL;
    HRESULT hr = GetItemByIndex(lCollectionIndex, lItemIndex, &pElem);
    if (FAILED(hr))
    {
        TraceTag((tagError, "CCollectionCache::GetDisp - GetItemByIndex() failed"));
        return hr;
    }

    Assert(pElem != NULL);

    return GetOuterDisp(lCollectionIndex, pElem, ppDisp);
} // GetDisp (long, long, IDispatch **)

//************************************************************
// Author:	twillie
// Created:	02/06/98
// Abstract:    Get IDispatch given a name and index
//************************************************************

HRESULT
CCollectionCache::GetDisp(long lCollectionIndex, const WCHAR *pwszName, long lIndex, IDispatch **ppDisp, bool fCaseSensitive /*= false */)
{
    CTIMEElementBase *pElem = NULL;
    HRESULT hr = GetItemByName(lCollectionIndex, pwszName, lIndex, &pElem, fCaseSensitive);
    if (FAILED(hr))
    {
        TraceTag((tagError, "CCollectionCache::GetDisp - GetItemByName() failed"));
        return hr;
    }

    Assert(pElem != NULL);

    return GetOuterDisp(lCollectionIndex, pElem, ppDisp);
} // GetDisp (long, const WCHAR *, long, IDispatch **, bool)

//************************************************************
// Author:	twillie
// Created:	02/06/98
// Abstract:    Get IDispatch given a name.  Could return
//              either a CTIMEElementBase or sub collection depending
//              on results.
//************************************************************

HRESULT
CCollectionCache::GetDisp(long         lCollectionIndex,
                          const WCHAR *pwszName,
                          bool         fTagName,
                          IDispatch  **ppDisp,
                          bool         fCaseSensitive /* = false */)
{
    CPtrAry<CTIMEElementBase *> *rgNamed = NULL;
    HRESULT                      hr = S_OK;

    // figure out if we have this collection already built
    // return this named collection if it already exists.
    CCacheItem *pce = NULL;

    Assert(ppDisp != NULL);
    *ppDisp = NULL;

    long lSize = m_rgItems->Size();
    for (long lIndex = m_lReservedSize; lIndex < lSize; lIndex++)
    {
        pce = (*m_rgItems)[lIndex];

        // if CaseSensitivites match and
        //    Index matches DependentIndex
        //    either a tag or named collection
        bool fIsCaseSensitive = pce->m_fIsCaseSensitive ? true : false;

        if ((fIsCaseSensitive == fCaseSensitive) &&
            (lCollectionIndex == pce->m_lDependentIndex) &&
            ((fTagName && pce->m_cctype == ctTag) ||
             (!fTagName && pce->m_cctype == ctNamed)))
        {
            // compare names
            long lCompare;
            if (fCaseSensitive)
                lCompare = StrCmpW(pwszName, pce->m_bstrName);
            else
                lCompare = StrCmpIW(pwszName, pce->m_bstrName);

            // if we found a match, we are done
            if (lCompare == 0)
            {
                // addref IDispatch since we returning it
                pce->m_pDisp->AddRef();
                *ppDisp = pce->m_pDisp;
                return S_OK;
            }
        }
    }

    // Build a list of named elements.
    hr = BuildNamedArray(lCollectionIndex, pwszName, fTagName, &rgNamed, fCaseSensitive);
    if (FAILED(hr))
    {
        TraceTag((tagError, "CCollectionCache::GetDisp - BuildNamedArray() failed"));
        return hr;
    }

    // if we found nothing and are NOT enumerating tags, return
    // not a failure case
    if ((rgNamed->Size() == 0) && !fTagName)
    {
        delete rgNamed;
        return DISP_E_MEMBERNOTFOUND;
    }

    // if only one element was found and we are NOT
    // enumerating tags, then QI for IDispatch for that
    // element and return it.  This only happens in ::item.
    if ((rgNamed->Size() == 1) && !fTagName)
    {
        hr = GetOuterDisp(lCollectionIndex, (*rgNamed)[0], ppDisp);
        Assert(ppDisp != NULL);

        // return ppDisp and release the array.
        delete rgNamed;
        if (FAILED(hr)) {
            TraceTag((tagError, "CCollectionCache::GetDisp - GetOuterDisp() failed"));
        }
        return hr;
    }

    // We found more than one item.  Initialize global list
    // and return IDispatch of collection.
    long lNewIndex = m_rgItems->Size();

    // create new cache item
    pce = NEW CCacheItem();
    if (pce == NULL)
    {
        TraceTag((tagError, "CCollectionCache::GetDisp - unable to alloc memory for cache item"));
        delete rgNamed;
        return E_OUTOFMEMORY;
    }

    // assign pointer to new cache item
    hr = m_rgItems->Append(pce);
    if (FAILED(hr))
    {
        TraceTag((tagError, "CCollectionCache::GetDisp - Append() failed"));
        delete pce;
        delete rgNamed;
        return hr;
    }

    hr = CreateCollectionHelper(ppDisp, lNewIndex);
    if (FAILED(hr))
    {
        TraceTag((tagError, "CCollectionCache::GetDisp - CreateCollectionHelper() failed"));
        delete rgNamed;
        return hr;
    }

    Assert(*ppDisp != NULL);

    // init name
    pce->m_bstrName = SysAllocString(pwszName);
    if (pce->m_bstrName == NULL)
    {
        ReleaseInterface(*ppDisp);
        delete rgNamed;
        TraceTag((tagError, "CCollectionCache::GetDisp - unable to alloc mem for string"));
        return E_OUTOFMEMORY;
    }

    pce->m_pDisp            = *ppDisp;
    pce->m_rgElem           = rgNamed;
    pce->m_lDependentIndex  = lCollectionIndex;       // Remember the index we depend on.
    pce->m_cctype           = fTagName ? ctTag : ctNamed;
    pce->m_fInvalid         = false;
    pce->m_fIsCaseSensitive = fCaseSensitive;

    // The collection this named collection was built from is now
    // used to rebuild (ensure) this collection. so we need to
    // put a reference on it so that it will not go away.
    // The matching Release() will be done in the dtor
    // although it is not necessary to addref the reserved collections
    // it is done anyhow, simply for consistency.  This addref
    // only needs to be done for non-reserved collections
    if (lNewIndex >= m_lReservedSize)
    {
        (*ppDisp)->AddRef();
    }

    return S_OK;
} // GetDisp (long, const WCHAR *, bool, IDispatch **, bool)

//************************************************************
// Author:	twillie
// Created:	02/06/98
// Abstract:    Get the number of items in this collection.
//              The default implementation of this method uses
//              EnumStart and EnumNextElement to tally the number
//              of items.  For some subclasses of collection, there
//              will be more efficient means of doing this (e.g.
//              the item count may be stored explicitly.)
//************************************************************

HRESULT
CCollectionCache::GetItemCount(long lCollectionIndex, long *plCount)
{
    Assert(plCount != NULL);
    *plCount = 0;

    if (IsChildrenCollection(lCollectionIndex))
    {
        Assert(m_pBase != NULL);
        *plCount = m_pBase->GetImmediateChildCount();
        return S_OK;
    }
    else if (IsAllCollection(lCollectionIndex))
    {
        Assert(m_pBase != NULL);
        *plCount = m_pBase->GetAllChildCount();
        return S_OK;
    }
    else
    {
        Assert( ((*m_rgItems)[lCollectionIndex]->m_cctype == ctNamed) ||
                ((*m_rgItems)[lCollectionIndex]->m_cctype == ctTag) );

        // must be standard array.  (i.e. sub-collection
        // move to correct offset and find size of array
        *plCount = (*m_rgItems)[lCollectionIndex]->m_rgElem->Size();
        return S_OK;
    }
} // GetItemCount

//************************************************************
// Author:	twillie
// Created:	02/06/98
// Abstract:    Get an indexed item.  The default implementation
//              uses EnumStart and EnumNextElement to scan through
//              the items.  For some subclasses of collection, there
//              will be more efficient means of doing this (e.g.
//              the items are stored in a contiguous array, making
//              random access of the items trivial.)  If the index
//              is out of range, this method will still return
//              S_OK, but pElem will contain NULL.
//************************************************************

HRESULT
CCollectionCache::GetItemByIndex(long lCollectionIndex, long lElementIndex, CTIMEElementBase **ppElem, bool fContinueFromPreviousSearch, long lLast)
{
    Assert(ppElem != NULL);
    *ppElem = NULL;

    if (IsChildrenCollection(lCollectionIndex))
    {
        Assert(m_pBase != NULL);

        // check to see if index is greater than count
        long lChildCount = m_pBase->GetImmediateChildCount();
        if (lElementIndex > lChildCount)
            return E_INVALIDARG;

        *ppElem = m_pBase->GetChild(lElementIndex);
        return S_OK;
    }
    else if (IsAllCollection(lCollectionIndex))
    {
        // All Collection
        // Note: since this is iterative, check to see if we start at the
        //       beginning or from a previous spot.
        long lCount = lLast;
        Assert(lElementIndex >= lLast);
        if (!fContinueFromPreviousSearch)
        {
            lCount = 0;
            EnumStart();
        }

        for (;;)
        {
            HRESULT hr = EnumNextElement(lCollectionIndex, ppElem);
            if (FAILED(hr))
            {
                TraceTag((tagError,  "CCollectionCache::GetItemByIndex - EnumNextElement() failed"));
                return hr;
            }

            Assert(ppElem != NULL);
            if (*ppElem == NULL)
            {
                // we have exceeded the bounds of the collection,
                // and therefor this is an invalid index
                return E_INVALIDARG;
            }

            // Keep scanning until we reach lElementIndex or the
            // last item in the collection.
            if (lElementIndex == lCount)
                break;
            lCount++;
        }
        return S_OK;
    }
    else
    {
        // must be standard array
        // get element at index
        CCacheItem *pce = (*m_rgItems)[lCollectionIndex];
        if ( (lElementIndex < 0) ||
             (lElementIndex >= pce->m_rgElem->Size()) )
        {
            TraceTag((tagError, "CCollectionCache::GetItemByIndex - invalid index"));
            return E_INVALIDARG;
        }

        *ppElem = (*pce->m_rgElem)[lElementIndex];
        return S_OK;
    }
} // GetItemByIndex


//************************************************************
// Author:	twillie
// Created:	02/06/98
// Abstract:    Return an item in the collection with a
//              specified id.  If no such item is found,
//              pElem will contain NULL.
//************************************************************

HRESULT
CCollectionCache::GetItemByName(long lCollectionIndex, const WCHAR *pwszName, long lElementIndex, CTIMEElementBase **ppElem, bool fCaseSensitive)
{
    long    lItem = 0;

    Assert(ppElem != NULL);
    *ppElem = NULL;

    if (IsAllCollection(lCollectionIndex) ||
        IsChildrenCollection(lCollectionIndex))
    {
        EnumStart();

        for (;;)
        {
            HRESULT hr = EnumNextElement(lCollectionIndex, ppElem);
            if (FAILED(hr))
            {
                TraceTag((tagError, "CCollectionCache::GetItemByName - EnumNextElement() failed"));
                return hr;
            }

            // See if this was the last item in the collection
            if (*ppElem == NULL)
                break;

            // Compare the element's id to the target id
            if (CompareName(*ppElem, pwszName, false, fCaseSensitive))
            {
                // check to see if we are on specified index
                if (lElementIndex == lItem)
                    return S_OK;

                // continue looking
                lItem++;
            }
        }
        // not an error condition
        return DISP_E_MEMBERNOTFOUND;
    }
    else
    {
        long               lSize = (*m_rgItems)[lCollectionIndex]->m_rgElem->Size();
        CTIMEElementBase  *pElem = NULL;

        // loop thru array, looking for a match.
        // if an index is specified, then keep looking until index condition is met.
        for (long lIndex = 0; lIndex < lSize; lIndex++)
        {
            pElem = (*(*m_rgItems)[lCollectionIndex]->m_rgElem)[lIndex];

            Assert(pElem != NULL);

            if (CompareName(pElem, pwszName, false, fCaseSensitive))
            {
                    // check to see if we are on specified index
                    if (lElementIndex == lItem)
                    {
                        *ppElem = pElem;
                        return S_OK;
                    }

                    // continue looking
                    lItem++;
            }
        }

        // NOTE: if we got here, we didn't find anything
        return DISP_E_MEMBERNOTFOUND;
    }
} // GetItemByName

//************************************************************
// Author:	twillie
// Created:	02/06/98
// Abstract:    This function initializes variables so we can
//              start walking the tree.
//************************************************************

void
CCollectionCache::EnumStart()
{
    m_pElemEnum = m_pBase;
    m_lEnumItem = 0;
} // EnumStart


//************************************************************
// Author:	twillie
// Created:	02/06/98
// Abstract:    This function does the walking of our heirarchial
//              tree.
//************************************************************

HRESULT
CCollectionCache::EnumNextElement(long lCollectionIndex, CTIMEElementBase **ppElem)
{
    HRESULT hr;
    Assert(ppElem != NULL);
    *ppElem = NULL;

    if (IsChildrenCollection(lCollectionIndex))
    {
        hr = GetItemByIndex(lCollectionIndex, m_lEnumItem, ppElem);
        m_lEnumItem++;
        return hr;
    }
    else
    {
        long lChildCount = m_pElemEnum->GetImmediateChildCount();
        while (m_lEnumItem == lChildCount)
        {
            // We're one past the last element in the current child element
            // being enumerated.
            if (m_pElemEnum == m_pBase)
            {
                // We're done if we reached the last item in the
                // root element.
                *ppElem = NULL;
                return S_OK;
            }
            else
            {
                // Otherwise, back up the tree until we find some children
                // that we haven't traversed yet.
                // BUGBUG - need internal to walk back wards up tree.
                CTIMEElementBase *pElemParent = m_pElemEnum->GetParent();
                Assert(pElemParent != NULL);

                // It's probably better if we maintain a stack of offsets
                // during traversal, but since no element can appear more
                // than once in the scene graph, we can scan to find our
                // offset in the parent's child array.
                lChildCount = pElemParent->GetImmediateChildCount();
                m_lEnumItem = 0;

                while (m_lEnumItem < lChildCount)
                {
                    CTIMEElementBase *pElemChild = pElemParent->GetChild(m_lEnumItem);
                    m_lEnumItem++;
                    if (pElemChild == m_pElemEnum)
                        break;
                }

                m_pElemEnum = pElemParent;
            }
        }

        // This can only be the result of scene graph corruption
        // during traversal.
        Assert(m_lEnumItem < lChildCount);

        *ppElem = m_pElemEnum->GetChild(m_lEnumItem);
        Assert(*ppElem != NULL);

        // Advance to the next element.  If the current element is
        // has children, we move down the tree and start enumerating its
        // children.  Otherwise, we'll move on to the next child
        // of m_pElemEnum.
        if ((*ppElem)->GetImmediateChildCount() == 0)
        {
            m_lEnumItem++;
        }
        else
        {
            m_lEnumItem = 0;
            m_pElemEnum = *ppElem;
        }

        return S_OK;
    }
} // EnumNextElement


//************************************************************
//
// End of File
//
//************************************************************
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\time\src\containersite.cpp ===
//************************************************************
//
// FileName:        containersite.cpp
//
// Created:         10/08/98
//
// Author:          TWillie
// 
// Abstract:        container site implementation.
//
//************************************************************

#include "headers.h"
#include "containersite.h"

DeclareTag(tagContainerSite, "API", "CContainerSite methods");

//************************************************************
// Author:          twillie
// Created:         10/08/98
// Abstract:        constructor
//************************************************************

CContainerSite::CContainerSite(CContainerObj *pHost) :
    m_cRef(0),
    m_pObj(NULL),
    m_pIOleObject(NULL),
    m_pInPlaceObject(NULL),
    m_pViewObject(NULL),
    m_dwEventsCookie(0),
    m_pcpEvents(NULL),
    m_dwAdviseCookie(0),
    m_osMode(OS_PASSIVE),
    m_fWindowless(false),
    m_pHTMLDoc(NULL),
    m_pTIMEElem(NULL),
    m_pPlayer(NULL),
    m_pHost(pHost),
    m_fAutosize(false),
    m_fStarted(false),
    m_fMediaReady(false)
{
    TraceTag((tagContainerSite, "CContainerSite::CContainerSite"));
    Assert(pHost != NULL);
} // CContainerSite

//************************************************************
// Author:          twillie
// Created:         10/08/98
// Abstract:        destructor
//************************************************************

CContainerSite::~CContainerSite()
{
    TraceTag((tagContainerSite, "CContainerSite::~CContainerSite"));
} // ~CContainerSite

//************************************************************
// Author:          twillie
// Created:         10/08/98
// Abstract:        Init
//************************************************************

HRESULT
CContainerSite::Init(REFCLSID clsid, CTIMEElementBase *pElem)
{
    TraceTag((tagContainerSite, "CContainerSite::Init"));

    IDispatch *pDisp = NULL;
    IConnectionPointContainer *pcpc = NULL;
    HRESULT hr = S_OK;

    Assert(pElem != NULL);
    m_pTIMEElem = pElem;

    // Weak reference.
    IHTMLElement *pHTMLElem = m_pTIMEElem->GetElement();
    
    if (NULL == pHTMLElem)
    {
        TraceTag((tagError, "CContainerSite::Init - unable to get element pointer from time behavior!!!"));
        hr = E_UNEXPECTED;
        goto error_cleanup;
    }

    hr = pHTMLElem->get_document(&pDisp);
    if (FAILED(hr))
    {
        TraceTag((tagError, "CContainerSite::Init - unable to get document pointer from element!!!"));
        goto error_cleanup;
    }

    Assert(pDisp != NULL);
    Assert(m_pHTMLDoc == NULL);
    hr = pDisp->QueryInterface(IID_TO_PPV(IHTMLDocument2, &m_pHTMLDoc));
    ReleaseInterface(pDisp);
    if (FAILED(hr))
    {
        TraceTag((tagError, "CContainerSite::Init - unable to QI for document pointer!!!"));
        goto error_cleanup;
    }

    Assert(m_pHTMLDoc != NULL);

    // Create given a clsid
    hr = CoCreateInstance(clsid,
                          NULL,
                          CLSCTX_INPROC_SERVER,
                          IID_IUnknown,
                          (void **)&m_pObj);
    if (FAILED(hr))
    {
        TraceTag((tagError, "CContainerSite::Init - Unable to find instance of MSHTML.DLL!!!"));
        goto error_cleanup;
    }

    // before we try anything, see if it supports ITIMEMediaPlayer
    hr = m_pObj->QueryInterface(IID_TO_PPV(ITIMEMediaPlayer, &m_pPlayer));
    if (FAILED(hr))
    {
        TraceTag((tagError, "CContainerSite::Init - unable to find IID_ITIMEMediaPlayer"));
        goto error_cleanup;
    }

    Assert(m_pPlayer != NULL);

    hr = m_pPlayer->Init();
    if (FAILED(hr))
    {
        TraceTag((tagError, "CContainerSite::Init - Init() failed on ITIMEMediaPlayer"));
        goto error_cleanup;
    }

    // We need an IOleObject most of the time, so get one here.
    hr = m_pObj->QueryInterface(IID_TO_PPV(IOleObject, &m_pIOleObject));
    if (FAILED(hr))
    {
        TraceTag((tagError, "CContainerSite::Init - unable to find IID_IOleObject"));
        goto error_cleanup;
    }

    Assert(m_pIOleObject != NULL);

    hr = m_pIOleObject->QueryInterface(IID_TO_PPV(IViewObject2, &m_pViewObject));
    if (FAILED(hr))
    {
        TraceTag((tagError, "CContainerSite::Init - unable to find IID_IViewObject2!!!"));
        goto error_cleanup;
    }

    Assert(m_pViewObject != NULL);

    // SetClientSite is critical for DocObjects
    hr = m_pIOleObject->SetClientSite(SAFECAST(this, IOleClientSite*));
    if (FAILED(hr))
    {
        TraceTag((tagError, "CContainerSite::Init - unable to IOleObject->SetClientSite() failed!!!"));
        goto error_cleanup;
    }

    m_dwAdviseCookie = 0;
    hr = m_pIOleObject->Advise(SAFECAST(this, IAdviseSink*), &m_dwAdviseCookie);
    if (FAILED(hr))
    {
        TraceTag((tagError, "CContainerSite::Init - unable to IOleObject->Advise() failed!!!"));
        goto error_cleanup;
    }

    Assert(m_dwAdviseCookie != 0);

    // establish ConnectionPoint for Events
    hr = m_pIOleObject->QueryInterface(IID_TO_PPV(IConnectionPointContainer, &pcpc));
    if (FAILED(hr))
    {
        TraceTag((tagError, "CContainerSite::Init - unable to find IID_IConnectionPointContainer!!!"));
        goto error_cleanup;
    }
    
    Assert(pcpc != NULL);

    hr = pcpc->FindConnectionPoint(DIID_TIMEMediaPlayerEvents, &m_pcpEvents);
    ReleaseInterface(pcpc);
    if (FAILED(hr))
    {
        TraceTag((tagError, "CContainerSite::Init - FindConnectionPoint() failed!!!"));
        goto error_cleanup;
    }

    Assert(m_pcpEvents != NULL);

    hr = m_pcpEvents->Advise((IUnknown *)(IDispatch*)m_pHost, &m_dwEventsCookie);
    if (FAILED(hr))
    {
        ReleaseInterface(m_pcpEvents);
        m_dwEventsCookie = 0;
        TraceTag((tagError, "CContainerSite::Init - Advise() failed on connection point!!!"));
        goto error_cleanup;
    }

    Assert(m_dwEventsCookie != 0);

    // Put the object in the running state
    hr = OleRun(m_pIOleObject);
    if (FAILED(hr))
    {
        TraceTag((tagError, "CContainerSite::Init - OleRun() failed!!!"));
        goto error_cleanup;
    }
    
    m_osMode = OS_RUNNING;
    return S_OK;

error_cleanup:
    Close();
    return hr;
} // Init

//************************************************************
// Author:          pauld
// Created:         3/2/99
// Abstract:        DetachFromHostElement
//************************************************************
HRESULT 
CContainerSite::DetachFromHostElement (void)
{
    TraceTag((tagContainerSite, "CContainerSite::Detach(%lx)", this));

    Close();
    m_pTIMEElem = NULL;
    return S_OK;
} // DetachFromHostElement

//************************************************************
// Author:          twillie
// Created:         01/20/98
// Abstract:        AddRef
//************************************************************
void CContainerSite::Close()
{
    TraceTag((tagContainerSite, "CContainerSite::Close(%lx)", this));

    // Deactivate InPlace Object (Interface is released as a result of this call)
    if (m_pInPlaceObject != NULL)
    {
        m_pInPlaceObject->InPlaceDeactivate();
        ReleaseInterface(m_pInPlaceObject);
    }

    ReleaseInterface(m_pViewObject);

    // disconnect events
    if ((m_pcpEvents != NULL) && (m_dwEventsCookie != 0))
    {
        m_pcpEvents->Unadvise(m_dwEventsCookie);
        ReleaseInterface(m_pcpEvents);
        m_dwEventsCookie = 0;
    }

    if (m_pIOleObject != NULL)
    {
        m_pIOleObject->Close(OLECLOSE_NOSAVE);

        Assert(m_dwAdviseCookie != 0);

        m_pIOleObject->Unadvise(m_dwAdviseCookie);
        m_pIOleObject->SetClientSite(NULL);
        ReleaseInterface(m_pIOleObject);
    }

    m_osMode = OS_LOADED;

    ReleaseInterface(m_pObj);

    m_osMode = OS_PASSIVE;

    // local book keeping
    m_pTIMEElem = NULL;
    ReleaseInterface(m_pHTMLDoc);
    ReleaseInterface(m_pPlayer);
} // Close

//************************************************************
// Author:          twillie
// Created:         01/20/98
// Abstract:        Validate call
//************************************************************

bool
CContainerSite::IllegalSiteCall(DWORD dwFlags)
{
    // check ref count
    if (m_cRef == 0)
        return true;
    
    // check object state
    switch (dwFlags)
    {
        case VALIDATE_WINDOWLESSINPLACE:
            if (!m_fWindowless)
            {
                Assert(0 && "Illegal call to windowless interface by ActiveX control (not a hosting bug)");
                return true;
            }
            break;

        case VALIDATE_INPLACE:
            if (m_osMode < OS_INPLACE)
                return true;
            break;

        case VALIDATE_LOADED:
            if (m_osMode < OS_LOADED)
                return true;
            break;
    }

    return false;
} // IllegalSiteCall

//************************************************************
// Author:          twillie
// Created:         01/20/98
// Abstract:        AddRef
//************************************************************

STDMETHODIMP_(ULONG)
CContainerSite::AddRef(void)
{
    return ++m_cRef;
} // AddRef

//************************************************************
// Author:          twillie
// Created:         01/20/98
// Abstract:        Release
//************************************************************

STDMETHODIMP_(ULONG)
CContainerSite::Release(void)
{
    if (m_cRef == 0)
    {
        TraceTag((tagError, "CContainerSite::Release - YIKES! Trying to decrement when Ref count is zero!!!"));
        return m_cRef;
    }

    if (0 != --m_cRef)
    {
        return m_cRef;
    }

    delete this;
    return 0;
} // Release

//************************************************************
// Author:          twillie
// Created:         01/20/98
// Abstract:        QI
//************************************************************

STDMETHODIMP
CContainerSite::QueryInterface(REFIID riid, void **ppv)
{
    if( NULL == ppv )
    {
        Assert(false);
        return E_POINTER;
    }

    *ppv = NULL;
    if (IsEqualIID(riid, IID_IUnknown))
    {
        // SAFECAST macro doesn't work with IUnknown
        *ppv = this;
    }
    else if (IsEqualIID(riid, IID_IServiceProvider))
    {
        *ppv = SAFECAST(this, IServiceProvider*);
    }
    else if (IsEqualIID(riid, IID_IOleClientSite))
    {
        *ppv = SAFECAST(this, IOleClientSite*);
    }
    else if (IsEqualIID(riid, IID_IAdviseSink) ||
             IsEqualIID(riid, IID_IAdviseSinkEx))
    {
        *ppv = SAFECAST(this, IAdviseSinkEx*);
    }
    else if (IsEqualIID(riid, IID_IOleWindow) ||
             IsEqualIID(riid, IID_IOleInPlaceSite) ||
             IsEqualIID(riid, IID_IOleInPlaceSiteEx) ||
             IsEqualIID(riid, IID_IOleInPlaceSiteWindowless))
    {
        *ppv = SAFECAST(this, IOleInPlaceSiteWindowless*);
    }
    else if (IsEqualIID(riid, IID_IOleCommandTarget))
    {
        *ppv = SAFECAST(this, IOleCommandTarget*);
    }
    else if (IsEqualIID(riid, IID_IDispatch))
    {
        *ppv = SAFECAST(this, IDispatch*);
    }
    else if (IsEqualIID(riid, IID_IOleControlSite))
    {
        *ppv = SAFECAST(this, IOleControlSite*);
    }
    else if (IsEqualIID(riid, IID_IOleInPlaceUIWindow) || 
             IsEqualIID(riid, IID_IOleInPlaceFrame))
    {
        *ppv = SAFECAST(this, IOleInPlaceFrame*);
    }

    if (NULL != *ppv)
    {
        ((IUnknown*)*ppv)->AddRef();
        return NOERROR;
    }

    return E_NOINTERFACE;
} // QueryInterface

//************************************************************
// Author:          twillie
// Created:         01/20/98
// Abstract:        IService Provider method
//************************************************************

STDMETHODIMP
CContainerSite::QueryService(REFGUID sid, REFIID riid, void **ppv)
{
    HRESULT hr = E_NOINTERFACE;
    IServiceProvider *psp = NULL;

    if( NULL == ppv )
    {
        Assert( false );
        return E_POINTER;
    }

    *ppv = NULL;

    // check to see if this is something we support locally
    // in the container.
    if (IsEqualGUID(sid, IID_IUnknown))
    {
        // SAFECAST macro doesn't work with IUnknown
        *ppv = this;
        ((IUnknown*)*ppv)->AddRef();
        hr = S_OK;
        goto done;
    }

   
    // Fall back to TIME Element if we still have one.

    // We have the supporting Service Provider cached (at init() time) for 
    // the behavior over in CBaseBvr which CTIMEElementBase inherits from.
    Assert(m_pTIMEElem != NULL);
    if (m_pTIMEElem != NULL)
    {
        psp = m_pTIMEElem->GetServiceProvider();
        if (psp != NULL)
        {
            hr = psp->QueryService(sid, riid, ppv);
            if (FAILED(hr))
            {
                TraceTag((tagError, "CContainerSite::QueryService - query failed!!! [%08X]", hr));
            }
        }
    }
    else
    {
        hr = E_UNEXPECTED;
        goto done;
    }

done:
    return hr;
} // QueryService

//************************************************************
// Author:          twillie
// Created:         01/20/98
// Abstract:
//************************************************************
HRESULT
CContainerSite::begin()
{
    HRESULT hr;

    // always call end before begin.
    // NOTE: we don't care about the return.
    if (GetMediaReadyFlag() == true)
        m_pPlayer->end();

    if (!m_fStarted)
    {
        RECT rc;
        HWND hWnd;

        // Lets get it InPlace Activated before we say begin
        Assert(m_pTIMEElem != NULL);
        if (m_pTIMEElem != NULL)
        {
            hr = m_pTIMEElem->GetSize(&rc);
            if (FAILED(hr))
            {
                TraceTag((tagError, "CContainerSite::begin - GetSize() failed!!!"));
                goto done;
            }
        }
        else
        {
            hr = E_UNEXPECTED;
            goto done;
        }
    
        hr = GetWindow(&hWnd);
        if (FAILED(hr))
        {
            TraceTag((tagError, "CContainerSite::begin - GetWindow() failed!!!"));
            goto done;
        }

        // if the width or height of the element is zero, allow the control
        // to renegotiate for size.
        if ( ((rc.right - rc.left) == 0) ||
             ((rc.bottom - rc.top) == 0) )
        {
            m_fAutosize = true;
        } else if( m_pTIMEElem->IsDocumentInEditMode())
        {
            DAComPtr<IHTMLStyle> s;
            VARIANT styleWidth, styleHeight;
            VariantInit(&styleWidth);
            VariantInit(&styleHeight);

            if (m_pTIMEElem->GetElement())
            {
                if(SUCCEEDED(THR(m_pTIMEElem->GetElement()->get_style(&s))))
                {
                    if(SUCCEEDED(s -> get_width( &styleWidth))
                        && SUCCEEDED(s -> get_height( &styleHeight)))
                    {
                        if(styleWidth.vt == VT_BSTR && styleWidth.bstrVal == NULL
                           && styleHeight.vt == VT_BSTR && styleHeight.bstrVal == NULL)
                            m_fAutosize = true;
                    }
                }
            }
            VariantClear(&styleWidth);
            VariantClear(&styleHeight);
        }

        Assert(m_pIOleObject != NULL);
        TraceTag((tagContainerSite, "CContainerSite::begin - InPlaceActivate [hwnd=%08X, rect=(%d, %d, %d, %d)]", hWnd, rc.left, rc.top, rc.right, rc.bottom));
        hr = m_pIOleObject->DoVerb(OLEIVERB_INPLACEACTIVATE,
                                   NULL, 
                                   SAFECAST(this, IOleClientSite*), 
                                   0, 
                                   hWnd, 
                                   &rc);
        if (FAILED(hr))
        {
            TraceTag((tagError, "CContainerSite::begin - DoVerb() failed!!! [%08X]", hr));
            goto done;
        }
    }

    Assert(m_pPlayer != NULL);

    hr = m_pPlayer->begin();
    if (FAILED(hr))
    {
        TraceTag((tagError, "CContainerSite::begin - begin() failed on ITIMEMediaPlayer!!! [%08X]", hr));
        goto done;
    }
    
    m_fStarted = true;
done:
    return hr;
}

//************************************************************
// Author:          twillie
// Created:         01/20/98
// Abstract:
//************************************************************
HRESULT
CContainerSite::end()
{
    HRESULT hr;

    m_fStarted = false;
    if (GetMediaReadyFlag() != true)
    {
        hr = S_OK;
        goto done;
    }

    if (m_pInPlaceObject == NULL)
    {
        hr = S_OK;
        goto done;
    }
    hr = m_pInPlaceObject->InPlaceDeactivate();
    if (FAILED(hr))
    {
        TraceTag((tagError, "CContainerSite::end - InPlaceDeactivate() failed!!! [%08X]", hr));
        goto done;
    }

    hr =  m_pPlayer->end();
    if (FAILED(hr))
    {
        TraceTag((tagError, "CContainerSite::end - end() failed on ITIMEMediaPlayer!!! [%08X]", hr));
        goto done;
    }

done:
    return hr;
}

//************************************************************
// Author:          twillie
// Created:         01/20/98
// Abstract:
//************************************************************
HRESULT
CContainerSite::pause()
{
    return m_pPlayer->pause();
}

//************************************************************
// Author:          twillie
// Created:         01/20/98
// Abstract:
//************************************************************
HRESULT
CContainerSite::resume()
{
    return m_pPlayer->resume();
}

//************************************************************
// Author:          twillie
// Created:         01/20/98
// Abstract:        Requests that the container call OleSave 
//                  for the object that lives here.  Typically
//                  this happens on server shutdown.
//************************************************************

HRESULT
CContainerSite::draw(HDC hdc, RECT *prc)
{
    if (prc == NULL)
        TraceTag((tagContainerSite, "CContainerSite::draw(%08X, NULL)", hdc));
    else
        TraceTag((tagContainerSite, "CContainerSite::draw(%08X, (%d, %d, %d, %d))", hdc, prc->left, prc->top, prc->right, prc->bottom));

    Assert(m_pViewObject != NULL);
    
    // repack rect into RECTL.
    RECTL  rcl;
    RECTL *prcl;
    
    if (prc == NULL)
    {
        prcl = NULL;
    }
    else
    {
        rcl.left = prc->left;
        rcl.top = prc->top;
        rcl.right = prc->right;
        rcl.bottom = prc->bottom;
        prcl = &rcl;
    }

    return m_pViewObject->Draw(DVASPECT_CONTENT,
                               0,
                               NULL,
                               NULL,
                               NULL,
                               hdc,
                               prcl,
                               NULL,
                               NULL,
                               0);
} // render

//************************************************************
// Author:          twillie
// Created:         01/20/98
// Function:        SaveObject, IOleClientSite 
// Abstract:        Requests that the container call OleSave 
//                  for the object that lives here.  Typically
//                  this happens on server shutdown.
//************************************************************

HRESULT
CContainerSite::SaveObject(void)
{
    TraceTag((tagContainerSite, "CContainerSite::SaveObject"));

    if (IllegalSiteCall(VALIDATE_LOADED))
        return E_UNEXPECTED;

    RRETURN(E_NOTIMPL);
} // SaveObject

//************************************************************
// Author:          twillie
// Created:         01/20/98
// Function:        GetMoniker, IOleClientSite 
// Abstract:        
//************************************************************

HRESULT
CContainerSite::GetMoniker(DWORD dwAssign, DWORD dwWhich, IMoniker **ppmk)
{
    TraceTag((tagContainerSite, "CContainerSite::GetMoniker"));
    return E_NOTIMPL;
} // GetMoniker

//************************************************************
// Author:          twillie
// Created:         01/20/98
// Function:        GetContainer, IOleClientSite 
// Abstract:        
//************************************************************

HRESULT
CContainerSite::GetContainer(IOleContainer **ppContainer)
{
    TraceTag((tagContainerSite, "CContainerSite::GetContainer"));

    *ppContainer = NULL;
    return E_NOINTERFACE;
} // GetContainer

//************************************************************
// Author:          twillie
// Created:         01/20/98
// Function:        RequestNewObjectLayout, IOleClientSite 
// Abstract:        
//************************************************************

HRESULT
CContainerSite::RequestNewObjectLayout(void)
{
    TraceTag((tagContainerSite, "CContainerSite::RequestNewObjectLayout"));

    if (IllegalSiteCall(VALIDATE_LOADED))
        return E_UNEXPECTED;

    return E_NOTIMPL;
} // RequestNewObjectLayout

//************************************************************
// Author:          twillie
// Created:         01/20/98
// Function:        OnShowWindow, IOleClientSite 
// Abstract:        
//************************************************************

HRESULT
CContainerSite::OnShowWindow(BOOL fShow)
{
    TraceTag((tagContainerSite, "CContainerSite::OnShowWindow"));

    if (IllegalSiteCall(VALIDATE_LOADED))
        return E_UNEXPECTED;

    return S_OK;
} // OnShowWindow

//************************************************************
// Author:          twillie
// Created:         01/20/98
// Function:        ShowObject, IOleClientSite 
// Abstract:        
//************************************************************

HRESULT
CContainerSite::ShowObject(void)
{
    TraceTag((tagContainerSite, "CContainerSite::ShowObject"));
    if (IllegalSiteCall(VALIDATE_LOADED))
        return E_UNEXPECTED;

    return S_OK;
} // ShowObject

//************************************************************
// Author:          twillie
// Created:         05/04/98
// Function:        OnControlInfoChanged, IOleControlSite 
// Abstract:        
//************************************************************

HRESULT
CContainerSite::OnControlInfoChanged(void)
{
    TraceTag((tagContainerSite, "CContainerSite::OnControlInfoChanged"));
    return S_OK;
} // OnControlInfoChanged

//************************************************************
// Author:          twillie
// Created:         05/04/98
// Function:        LockInPlaceActive, IOleControlSite 
// Abstract:        
//************************************************************

HRESULT
CContainerSite::LockInPlaceActive(BOOL fLock)
{
    TraceTag((tagContainerSite, "CContainerSite::LockInPlaceActive"));
    if (IllegalSiteCall(VALIDATE_INPLACE))
        return E_UNEXPECTED;
    return S_OK;
} // LockInPlaceActive

//************************************************************
// Author:          twillie
// Created:         05/04/98
// Function:        GetExtendedControl, IOleControlSite 
// Abstract:        
//************************************************************

HRESULT
CContainerSite::GetExtendedControl(IDispatch **ppDisp)
{
    TraceTag((tagContainerSite, "CContainerSite::GetExtendedControl"));
    
    return m_pHost->QueryInterface(IID_TO_PPV(IDispatch, ppDisp));
} // TransformCoords

//************************************************************
// Author:          twillie
// Created:         05/04/98
// Function:        TransformCoords, IOleControlSite 
// Abstract:        
//************************************************************

HRESULT
CContainerSite::TransformCoords(POINTL *pPtlHiMetric,
                       POINTF *pPtfContainer,
                       DWORD   dwFlags)
{
    TraceTag((tagContainerSite, "CContainerSite::TransformCoords"));
    return E_NOTIMPL;
} // TransformCoords

//************************************************************
// Author:          twillie
// Created:         05/04/98
// Function:        TranslateAccelerator, IOleControlSite 
// Abstract:        
//************************************************************

HRESULT
CContainerSite::TranslateAccelerator(MSG *pmsg, DWORD grfModifiers)
{
    TraceTag((tagContainerSite, "CContainerSite::TranslateAccelerator"));
    if (IllegalSiteCall(VALIDATE_LOADED))
        return E_UNEXPECTED;
    return S_FALSE;
} // TranslateAccelerator

//************************************************************
// Author:          twillie
// Created:         05/04/98
// Function:        OnFocus, IOleControlSite 
// Abstract:        
//************************************************************

HRESULT
CContainerSite::OnFocus(BOOL fGotFocus)
{
    TraceTag((tagContainerSite, "CContainerSite::OnFocus"));
    return S_OK;
} // OnFocus

//************************************************************
// Author:          twillie
// Created:         05/04/98
// Function:        ShowPropertyFrame, IOleControlSite 
// Abstract:        
//************************************************************

HRESULT
CContainerSite::ShowPropertyFrame(void)
{
    TraceTag((tagContainerSite, "CContainerSite::ShowPropertyFrame"));
    return S_OK;
} // ShowPropertyFrame

//************************************************************
// Author:          twillie
// Created:         01/20/98
// Function:        GetWindow, IOleWindow 
// Abstract:        Retrieves the handle of the window 
//                  associated with the object on which this 
//                  interface is implemented.
//************************************************************

HRESULT
CContainerSite::GetWindow(HWND *phWnd)
{
    TraceTag((tagContainerSite, "CContainerSite::GetWindow"));

    if (phWnd == NULL)
    {
        TraceTag((tagError, "CContainerSite::GetWindow - invalid arg"));
        return E_POINTER;
    }
        
    Assert(m_pHTMLDoc != NULL);

    IOleWindow *pow = NULL;
    HRESULT hr = m_pHTMLDoc->QueryInterface(IID_TO_PPV(IOleWindow, &pow));
    if (FAILED(hr))
    {
        TraceTag((tagError, "CContainerSite::GetWindow - unable to QI for IOleWindow on hosting Document"));
        return hr;
    }

    Assert(pow != NULL);

    hr = pow->GetWindow(phWnd);
    Assert(*phWnd != NULL);
    ReleaseInterface(pow);
    return hr;
} // GetWindow

//************************************************************
// Author:          twillie
// Created:         01/20/98
// Function:        ContextSensitiveHelp, IOleWindow 
// Abstract:        Instructs the object on which this 
//                  interface is implemented to enter or leave 
//                  a context-sensitive help mode.
//************************************************************

HRESULT
CContainerSite::ContextSensitiveHelp(BOOL fEnterMode)
{
    TraceTag((tagContainerSite, "CContainerSite::ContextSensitiveHelp"));

    if (IllegalSiteCall(VALIDATE_LOADED))
        return E_UNEXPECTED;
    
    // BUGBUG - reach back to document and forward on call to it's InplaceSite!
    return NOERROR;
} // ContextSensitiveHelp

//************************************************************
// Author:          twillie
// Created:         01/20/98
// Function:        CanInPlaceActivate, IOleInPlaceSite
// Abstract:        Answers the server whether or not we can 
//                  currently in-place activate its object.  
//                  By implementing this interface we say
//                  that we support in-place activation, but 
//                  through this function we indicate whether 
//                  the object can currently be activated
//                  in-place.  Iconic aspects, for example, 
//                  cannot, meaning we return S_FALSE.
//************************************************************

HRESULT
CContainerSite::CanInPlaceActivate(void)
{    
    TraceTag((tagContainerSite, "CContainerSite::CanInPlaceActivate"));
    return S_OK;
} // CanInPlaceActivate

//************************************************************
// Author:          twillie
// Created:         01/20/98
// Function:        OnInPlaceActivate, IOleInPlaceSite
// Abstract:        Informs the container that an object is 
//                  being activated in-place such that the 
//                  container can prepare appropriately.  The
//                  container does not, however, make any user 
//                  interface changes at this point.
//                  See OnUIActivate.
//************************************************************

HRESULT
CContainerSite::OnInPlaceActivate(void)
{
    TraceTag((tagContainerSite, "CContainerSite::OnInPlaceActivate"));
    return OnInPlaceActivateEx(NULL, 0);
} // OnInPlaceActivate

//************************************************************
// Author:          twillie
// Created:         01/20/98
// Function:        OnInPlaceDeactivate, IOleInPlaceSite
// Abstract:        Notifies the container that the object has 
//                  deactivated itself from an in-place state.  
//                  Opposite of OnInPlaceActivate.  The 
//                  container does not change any UI at this 
//                  point.
//************************************************************

HRESULT
CContainerSite::OnInPlaceDeactivate(void)
{
    TraceTag((tagContainerSite, "CContainerSite::OnInPlaceDeactivate"));

    if (m_osMode == OS_UIACTIVE)
        OnUIDeactivate(false);
    
    Assert(m_pInPlaceObject != NULL);
    ReleaseInterface(m_pInPlaceObject);

    m_fWindowless = false;
    m_osMode = OS_RUNNING;

    return S_OK;
} // OnInPlaceDeactivate

//************************************************************
// Author:          twillie
// Created:         01/20/98
// Function:        OnUIActivate, IOleInPlaceSite
// Abstract:        Informs the container that the object is 
//                  going to start munging around with user 
//                  interface, like replacing the menu.  The
//                  container should remove any relevant UI in 
//                  preparation.
//************************************************************

HRESULT
CContainerSite::OnUIActivate(void)
{
    TraceTag((tagContainerSite, "CContainerSite::OnUIActivate"));
    if (IllegalSiteCall(VALIDATE_LOADED) ||
        (m_osMode < OS_RUNNING))
    {
        TraceTag((tagError, "Object is not inplace yet!!!"));
        return E_UNEXPECTED;
    }

    m_osMode = OS_UIACTIVE;
    return S_OK;
} // OnUIActivate

//************************************************************
// Author:          twillie
// Created:         01/20/98
// Function:        OnUIDeactivate, IOleInPlaceSite
// Abstract:        Informs the container that the object is 
//                  deactivating its in-place user interface 
//                  at which time the container may reinstate 
//                  its own.  Opposite of OnUIActivate.
//************************************************************

HRESULT
CContainerSite::OnUIDeactivate(BOOL fUndoable)
{
    TraceTag((tagContainerSite, "CContainerSite::OnUIDeactivate"));
    if (IllegalSiteCall(VALIDATE_INPLACE))
        return E_UNEXPECTED;
    
    m_osMode = OS_INPLACE;
    return S_OK;
} // OnUIDeactivate

//************************************************************
// Author:          twillie
// Created:         01/20/98
// Function:        DeactivateAndUndo, IOleInPlaceSite
// Abstract:        If immediately after activation the object 
//                  does an Undo, the action being undone is 
//                  the activation itself, and this call
//                  informs the container that this is, in 
//                  fact, what happened.
//************************************************************

HRESULT
CContainerSite::DeactivateAndUndo(void)
{
    TraceTag((tagContainerSite, "CContainerSite::DeactivateAndUndo"));
    if (IllegalSiteCall(VALIDATE_INPLACE))
        return E_UNEXPECTED;
    return E_NOTIMPL;
} // DeactivateAndUndo

//************************************************************
// Author:          twillie
// Created:         01/20/98
// Function:        DiscardUndoState, IOleInPlaceSite
// Abstract:        Informs the container that something 
//                  happened in the object that means the 
//                  container should discard any undo 
//                  information it currently maintains for the 
//                  object.
//************************************************************

HRESULT
CContainerSite::DiscardUndoState(void)
{
    TraceTag((tagContainerSite, "CContainerSite::DiscardUndoState"));
    if (IllegalSiteCall(VALIDATE_INPLACE))
        return E_UNEXPECTED;
    return S_OK;
} // DiscardUndoState

//************************************************************
// Author:          twillie
// Created:         01/20/98
// Function:        GetWindowContext, IOleInPlaceSite
// Abstract:        Provides an in-place object with pointers 
//                  to the frame and document level in-place 
//                  interfaces (IOleInPlaceFrame and 
//                  IOleInPlaceUIWindow) such that the object 
//                  can do border negotiation and so forth.  
//                  Also requests the position and clipping 
//                  rectangles of the object in the container 
//                  and a pointer to an OLEINPLACEFRAME info 
//                  structure which contains accelerator 
//                  information.
//
//                  NOTE: that the two interfaces this call 
//                  returns are not available through 
//                  QueryInterface on IOleInPlaceSite since 
//                  they live with the frame and document, but 
//                  not the site.
//************************************************************

HRESULT
CContainerSite::GetWindowContext(IOleInPlaceFrame    **ppFrame,
                                 IOleInPlaceUIWindow **ppUIWindow, 
                                 RECT                 *prcPos, 
                                 RECT                 *prcClip, 
                                 OLEINPLACEFRAMEINFO  *pFI)
{
    TraceTag((tagContainerSite, "CContainerSite::GetWindowContext"));
    HRESULT hr;

    if ( (ppFrame == NULL) ||
         (ppUIWindow == NULL) ||
         (prcPos == NULL) ||
         (prcClip == NULL) ||
         (pFI == NULL) )
    {
        TraceTag((tagError, "CContainerSite::GetWindowContext - invalid arg"));
        return E_POINTER;
    }

    *ppFrame = NULL;
    *ppUIWindow = NULL;
    SetRectEmpty(prcPos);
    SetRectEmpty(prcClip);
    memset(pFI, 0, sizeof(OLEINPLACEFRAMEINFO));

    if (IllegalSiteCall(VALIDATE_LOADED))
    {
        Assert(0 && "Unexpected call to client site.");
        hr = E_UNEXPECTED;
        goto done;
    }
    
    // return pointers to ourselves
    // NOTE: these are stubbed out
    hr = THR(this->QueryInterface(IID_IOleInPlaceFrame, (void**)ppFrame));
    if (FAILED(hr))
        goto done;

    hr = THR(this->QueryInterface(IID_IOleInPlaceUIWindow, (void**)ppUIWindow));
    if (FAILED(hr))
        goto done;

    // get position rect
    Assert(m_pTIMEElem != NULL);
    if (m_pTIMEElem != NULL)
    {
        hr = m_pTIMEElem->GetSize(prcPos);
        if (FAILED(hr))
        {
            TraceTag((tagError, "CContainerSite::GetWindowContext - GetSize() failed"));
            goto done;
        }
    }
    else
    {
        hr = E_UNEXPECTED;
        goto done;
    }
    
    // Note that Clip and Pos are the same.
    // BUGBUG - Need to provide correct clipping rect.
    ::CopyRect(prcClip, prcPos);

    hr = S_OK;

done:
    return hr;
} // GetWindowContext

//************************************************************
// Author:          twillie
// Created:         01/20/98
// Function:        Scroll, IOleInPlaceSite
// Abstract:        Asks the container to scroll the document, 
//                  and thus the object, by the given amounts 
//                  in the sz parameter.
//************************************************************

HRESULT
CContainerSite::Scroll(SIZE sz)
{
    // Not needed for DocObjects
    TraceTag((tagContainerSite, "CContainerSite::Scroll"));
    if (IllegalSiteCall(VALIDATE_INPLACE))
        return E_UNEXPECTED;
    return E_NOTIMPL;
} // Scroll

//************************************************************
// Author:          twillie
// Created:         01/20/98
// Function:        OnPosRectChange, IOleInPlaceSite
// Abstract:        Informs the container that the in-place 
//                  object was resized.  This does not change 
//                  the site's rectangle in any case.
//************************************************************

HRESULT
CContainerSite::OnPosRectChange(const RECT *prcPos)
{
    if (prcPos == NULL)
        TraceTag((tagContainerSite, "CContainerSite::OnPosRectChange(NULL)"));
    else
        TraceTag((tagContainerSite, "CContainerSite::OnPosRectChange((%d, %d, %d, %d))", prcPos->left, prcPos->top, prcPos->right, prcPos->bottom));
    
    HRESULT hr;
    IHTMLStyle *pStyle = NULL;

    Assert(m_pTIMEElem != NULL);
    if (m_pTIMEElem == NULL)
    {
        hr = E_UNEXPECTED;
        goto done;
    }

    if (prcPos == NULL)
    {
        TraceTag((tagError, "CContainerSite::OnPosRectChange - invalidarg"));
        hr = E_POINTER;
        goto done;
    }

    if (IllegalSiteCall(VALIDATE_INPLACE))
    {
        hr = E_UNEXPECTED;
        goto done;
    }

    if (!m_fAutosize)
    {
        // clamp the bouinding rect if we have width/height defined
        RECT rc;

        hr = m_pTIMEElem->GetSize(&rc);
        if (FAILED(hr))
        {
            TraceTag((tagError, "CContainerSite::OnPosRectChange - GetSize() failed"));
            goto done;
        }

        // BUGBUG - need to provide correct clipping rect
        hr = m_pInPlaceObject->SetObjectRects(&rc, &rc);
        if (FAILED(hr))
        {
            TraceTag((tagError, "CContainerSite::OnPosRectChange - SetObjectRects() failed [AutoSize]"));
            goto done;
        }

        // exit.
        goto done;
    }

    hr = m_pTIMEElem->SetSize(prcPos);
    if (FAILED(hr))
    {
        TraceTag((tagError, "CContainerSite::OnPosRectChange - SetSize() failed"));
        goto done;
    }

    // notify object that change has occured.
    // Note: that I assume the clipping rect to be the same as the pos rect.
    hr = m_pInPlaceObject->SetObjectRects(prcPos, prcPos);
    if (FAILED(hr))
    {
        TraceTag((tagError, "CContainerSite::OnPosRectChange - SetObjectRects() failed"));
        goto done;
    }
done:
    ReleaseInterface(pStyle);
    return hr;
} // OnPosRectChange

//************************************************************
// Author:          twillie
// Created:         01/20/98
// Function:        OnInPlaceActivateEx, IOleInPlaceSiteEx
// Abstract:        
//************************************************************

HRESULT
CContainerSite::OnInPlaceActivateEx(BOOL *pfNoRedraw, DWORD dwFlags)
{
    HRESULT hr;

    TraceTag((tagContainerSite, "CContainerSite::OnInPlaceActivateEx"));

    if (IllegalSiteCall(VALIDATE_LOADED))
        return E_UNEXPECTED;

    Assert(m_pInPlaceObject == NULL);

    // Make Sure we are Windowless
    if (dwFlags == ACTIVATE_WINDOWLESS)
    {
        hr = m_pObj->QueryInterface(IID_IOleInPlaceObjectWindowless, (void**)&m_pInPlaceObject);
        if (FAILED(hr))
        {
            TraceTag((tagError, "QI failed for windowless interface"));
            return hr;
        }
        m_fWindowless = true;
    }
    else
    {
        hr = m_pObj->QueryInterface(IID_IOleInPlaceObject, (void**)&m_pInPlaceObject);
        if (FAILED(hr))
        {
            TraceTag((tagError, "QI failed for windowless interface"));
            return hr;
        }
    }

    if (pfNoRedraw != NULL)
        *pfNoRedraw = m_fWindowless ? true : false;

    m_osMode = OS_INPLACE;

    return S_OK;
} // OnInPlaceActivateEx

//************************************************************
// Author:          twillie
// Created:         01/20/98
// Function:        OnInPlaceDeactivateEx, IOleInPlaceSiteEx
// Abstract:        
//************************************************************

HRESULT
CContainerSite::OnInPlaceDeactivateEx(BOOL fNoRedraw)
{
    TraceTag((tagContainerSite, "CContainerSite::OnInPlaceDeactivateEx"));
    
    // BUGBUG - may need to Invalidate if fNoRedraw is false and we are windowed...
    
    return OnInPlaceDeactivate();
} // OnInPlaceDeactivateEx

//************************************************************
// Author:          twillie
// Created:         01/20/98
// Function:        RequestUIActivate, IOleInPlaceSiteEx
// Abstract:        
//************************************************************

HRESULT
CContainerSite::RequestUIActivate(void)
{
    TraceTag((tagContainerSite, "CContainerSite::RequestUIActivate"));

    if (IllegalSiteCall(VALIDATE_LOADED))
        return E_UNEXPECTED;

    return S_OK;
} // RequestUIActivate

//************************************************************
// Author:          twillie
// Created:         01/20/98
// Function:        CanWindowlessActivate, IOleInPlaceSiteWindowless
// Abstract:        
//************************************************************

HRESULT
CContainerSite::CanWindowlessActivate(void)
{
    TraceTag((tagContainerSite, "CContainerSite::CanWindowlessActivate"));
    return S_OK;
} // CanWindowlessActivate

//************************************************************
// Author:          twillie
// Created:         01/20/98
// Function:        GetCapture, IOleInPlaceSiteWindowless
// Abstract:        
//************************************************************

HRESULT
CContainerSite::GetCapture(void)
{
    TraceTag((tagContainerSite, "CContainerSite::GetCapture"));

    if (IllegalSiteCall(VALIDATE_WINDOWLESSINPLACE))
        return E_UNEXPECTED;

    return E_NOTIMPL;
} // GetCapture

//************************************************************
// Author:          twillie
// Created:         01/20/98
// Function:        SetCapture, IOleInPlaceSiteWindowless
// Abstract:        Enables an in-place active, windowless 
//                  object to capture all mouse messages.
//                  If TRUE, the container should capture the 
//                  mouse for the object. If FALSE, the container 
//                  should release mouse capture for the object. 
//************************************************************

HRESULT
CContainerSite::SetCapture(BOOL fCapture)
{
    TraceTag((tagContainerSite, "CContainerSite::SetCapture"));

    if (IllegalSiteCall(VALIDATE_WINDOWLESSINPLACE))
        return E_UNEXPECTED;

    return E_NOTIMPL;
} // SetCapture

//************************************************************
// Author:          twillie
// Created:         01/20/98
// Function:        GetFocus, IOleInPlaceSiteWindowless
// Abstract:        Called by an in-place active, windowless 
//                  object to determine if it still has the 
//                  keyboard focus or not.
//************************************************************

HRESULT
CContainerSite::GetFocus(void)
{
    TraceTag((tagContainerSite, "CContainerSite::GetFocus"));

    if (IllegalSiteCall(VALIDATE_WINDOWLESSINPLACE))
        return E_UNEXPECTED;

    return S_FALSE;
} // GetFocus

//************************************************************
// Author:          twillie
// Created:         01/20/98
// Function:        SetFocus, IOleInPlaceSiteWindowless
// Abstract:        Sets the keyboard focus for a UI-active, 
//                  windowless object.  If TRUE, sets the 
//                  keyboard focus to the calling object. If FALSE, 
//                  removes the keyboard focus from the calling object, 
//                  provided that the object has the focus.
//************************************************************

HRESULT
CContainerSite::SetFocus(BOOL fFocus)
{
    TraceTag((tagContainerSite, "CContainerSite::SetFocus"));

    if (IllegalSiteCall(VALIDATE_WINDOWLESSINPLACE))
        return E_UNEXPECTED;

    return E_NOTIMPL;
 } // SetFocus

//************************************************************
// Author:          twillie
// Created:         01/20/98
// Function:        GetDC, IOleInPlaceSiteWindowless
// Abstract:        
//************************************************************

HRESULT
CContainerSite::GetDC(const RECT *prc, DWORD dwFlags, HDC *phDC)
{
    TraceTag((tagContainerSite, "CContainerSite::GetDC"));
    HRESULT hr;
    HWND hWnd;

    if (phDC == NULL)
    {
        TraceTag((tagError, "CContainerSite::GetDC - invalid arg"));
        hr = E_POINTER;
        goto done;
    }

    if (IllegalSiteCall(VALIDATE_WINDOWLESSINPLACE))
    {
        hr = E_UNEXPECTED;
        goto done;
    }

    hr = GetWindow(&hWnd);
    if (FAILED(hr) || (hWnd == NULL))
    {
        // BUGBUG: at some point in the future, we may need to support
        //         Documents which are windowless...
        TraceTag((tagError, "CContainerSite::GetDC - GetWindow() failed"));
        hr = E_FAIL;
        goto done;
    }

    *phDC = ::GetDC(hWnd);
    if (*phDC == NULL)
    {
        TraceTag((tagError, "CContainerSite::GetDC - Win32 GetDC returned NULL!"));
        hr = E_FAIL;
    }
    else
    {
        hr = S_OK;
    }

done:
    return hr;
} // GetDC

//************************************************************
// Author:          twillie
// Created:         01/20/98
// Function:        ReleaseDC, IOleInPlaceSiteWindowless
// Abstract:        
//************************************************************

HRESULT
CContainerSite::ReleaseDC(HDC hDC)
{
    TraceTag((tagContainerSite, "CContainerSite::ReleaseDC"));

    HRESULT hr;
    HWND    hWnd;

    if (IllegalSiteCall(VALIDATE_WINDOWLESSINPLACE))
        return E_UNEXPECTED;

    hr = GetWindow(&hWnd);
    Assert(SUCCEEDED(hr) && (hWnd != NULL));
    
    Assert(hDC != NULL);

    ::ReleaseDC(hWnd, hDC);

    return S_OK;
} // ReleaseDC

//*******************************************************************
// Author:          twillie
// Created:         01/20/98
// Function:        InvalidateRect, IOleInPlaceSiteWindowless
// Abstract:
//*******************************************************************

HRESULT
CContainerSite::InvalidateRect(const RECT *prc, BOOL fErase)
{
    if (prc == NULL)
        TraceTag((tagContainerSite, "CContainerSite::InvalidateRect(NULL)"));
    else
        TraceTag((tagContainerSite, "CContainerSite::InvalidateRect(%d, %d, %d, %d)", prc->left, prc->top, prc->right, prc->bottom));

    if (IllegalSiteCall(VALIDATE_WINDOWLESSINPLACE))
        return E_UNEXPECTED;

    // reach back to the time element and invalidate
    Assert(m_pHost != NULL);
    return m_pHost->Invalidate(prc);
} // InvalidateRect

//*******************************************************************
// Author:          twillie
// Created:         01/20/98
// Function:        InvalidateRgn, IOleInPlaceSiteWindowless
// Abstract:
//*******************************************************************

HRESULT
CContainerSite::InvalidateRgn(HRGN hRGN, BOOL fErase)
{
    TraceTag((tagContainerSite, "CContainerSite::InvalidateRgn"));

    if (IllegalSiteCall(VALIDATE_WINDOWLESSINPLACE))
        return E_UNEXPECTED;

    HRESULT hr = S_OK;
    return hr;
} // InvalidateRgn

//************************************************************
// Author:          twillie
// Created:         01/20/98
// Function:        ScrollRect, IOleInPlaceSiteWindowless
// Abstract:        
//************************************************************

HRESULT
CContainerSite::ScrollRect(INT dx, INT dy, const RECT *prcScroll, const RECT *prcClip)
{
    // Not needed for DocObjects
    TraceTag((tagContainerSite, "CContainerSite::ScrollRect"));

    if (IllegalSiteCall(VALIDATE_WINDOWLESSINPLACE))
        return E_UNEXPECTED;

    return E_NOTIMPL;
} // ScrollRect

//************************************************************
// Author:          twillie
// Created:         01/20/98
// Function:        AdjustRect, IOleInPlaceSiteWindowless
// Abstract:        
//************************************************************

HRESULT
CContainerSite::AdjustRect(RECT *prc)
{
    // Not needed for DocObjects
    TraceTag((tagContainerSite, "CContainerSite::AdjustRect"));

    if (IllegalSiteCall(VALIDATE_WINDOWLESSINPLACE))
        return E_UNEXPECTED;

    return E_NOTIMPL;
} // AdjustRect

//************************************************************
// Author:          twillie
// Created:         01/20/98
// Function:        OnDefWindowMessage, IOleInPlaceSiteWindowless
// Abstract:        
//************************************************************

HRESULT
CContainerSite::OnDefWindowMessage(UINT msg, WPARAM wParam, LPARAM lParam, LRESULT *plResult)
{
    TraceTag((tagContainerSite, "CContainerSite::OnDefWindowMessage"));

    if (IllegalSiteCall(VALIDATE_WINDOWLESSINPLACE))
        return E_UNEXPECTED;

    // Return that the message was not handled.
    // BUGBUG:  eventually, this might need to be bubbled out.

    // release focus for the document.
// BUGBUG: we don't handle focus right now
//    if (msg == WM_KILLFOCUS)
//        return SetFocus(false);

    switch (msg)
    {
// BUGBUG: we don't handle focus right now
//        case WM_SETFOCUS:
//            return SetFocus(true);
//        case WM_KILLFOCUS:
//            return SetFocus(false);

        case WM_MOUSEMOVE:
        case WM_KEYDOWN:
        case WM_KEYUP:
        case WM_CHAR:
        case WM_DEADCHAR:
        case WM_SYSKEYUP:
        case WM_SYSCHAR:
        case WM_SYSDEADCHAR:
        case WM_LBUTTONDOWN:
        case WM_MBUTTONDOWN:
        case WM_RBUTTONDOWN:
        case WM_LBUTTONUP:
        case WM_MBUTTONUP:
        case WM_RBUTTONUP:
        case WM_LBUTTONDBLCLK:
        case WM_MBUTTONDBLCLK:
        case WM_RBUTTONDBLCLK:
            return S_OK;

        case WM_SETCURSOR:
        case WM_CONTEXTMENU:
        case WM_HELP:
            return S_FALSE;

        case WM_MOUSEHOVER:
        case WM_MOUSELEAVE:
        case 0x8004: //  WM_MOUSEOVER
            return S_OK;

        case WM_CAPTURECHANGED:
            return S_OK;
    }

    return S_FALSE;
} // OnDefWindowMessage

//************************************************************
// Author:          twillie
// Created:         01/20/98
// Function:        OnDataChange, IAdviseSink
// Abstract:        
//************************************************************

void
CContainerSite::OnDataChange(FORMATETC *pFEIn, STGMEDIUM *pSTM)
{
    TraceTag((tagContainerSite, "CContainerSite::OnDataChange"));
} // OnDataChange

//************************************************************
// Author:          twillie
// Created:         01/20/98
// Function:        OnViewChange, IAdviseSink
// Abstract:        
//************************************************************

void 
CContainerSite::OnViewChange(DWORD dwAspect, LONG lindex)
{    
    TraceTag((tagContainerSite, "CContainerSite::OnViewChange"));
} // OnViewChange

//************************************************************
// Author:          twillie
// Created:         01/20/98
// Function:        OnRename, IAdviseSink
// Abstract:        
//************************************************************

void 
CContainerSite::OnRename(IMoniker *pmk)
{
    TraceTag((tagContainerSite, "CContainerSite::OnRename"));
} // OnRename

//************************************************************
// Author:          twillie
// Created:         01/20/98
// Function:        OnSave, IAdviseSink
// Abstract:        
//************************************************************

void 
CContainerSite::OnSave(void)
{
    TraceTag((tagContainerSite, "CContainerSite::OnSave"));
} // OnSave

//************************************************************
// Author:          twillie
// Created:         01/20/98
// Function:        OnClose, IAdviseSink
// Abstract:        
//************************************************************

void 
CContainerSite::OnClose(void)
{
    TraceTag((tagContainerSite, "CContainerSite::OnClose"));
} // OnClose

//************************************************************
// Author:          twillie
// Created:         01/20/98
// Function:        OnViewStatusChange, IAdviseSink
// Abstract:        
//************************************************************

void 
CContainerSite::OnViewStatusChange(DWORD dwViewStatus)
{
    TraceTag((tagContainerSite, "CContainerSite::OnViewStatusChange"));
} // OnViewStatusChange

//************************************************************
// Author:          twillie
// Created:         01/20/98
// Function:        GetTypeInfoCount, IDispatch
// Abstract:        Returns the number of tyep information 
//                  (ITypeInfo) interfaces that the object 
//                  provides (0 or 1).
//************************************************************

HRESULT
CContainerSite::GetTypeInfoCount(UINT *pctInfo) 
{
    TraceTag((tagContainerSite, "CContainerSite::GetTypeInfoCount"));
    return E_NOTIMPL;
} // GetTypeInfoCount

//************************************************************
// Author:          twillie
// Created:         01/20/98
// Function:        GetTypeInfo, IDispatch
// Abstract:        Retrieves type information for the 
//                  automation interface. 
//************************************************************

HRESULT
CContainerSite::GetTypeInfo(UINT itinfo, LCID lcid, ITypeInfo **pptInfo) 
{ 
    TraceTag((tagContainerSite, "CContainerSite::GetTypeInfo"));
    return E_NOTIMPL;
} // GetTypeInfo

//************************************************************
// Author:          twillie
// Created:         01/20/98
// Function:        GetIDsOfNames, IDispatch
// Abstract:        constructor
//************************************************************

HRESULT
CContainerSite::GetIDsOfNames(REFIID riid, OLECHAR **rgszNames, UINT cNames, LCID lcid, DISPID *rgDispID)
{
    TraceTag((tagContainerSite, "CContainerSite::GetIDsOfNames"));
    return E_NOTIMPL;
} // GetIDsOfNames

//************************************************************
// Author:          twillie
// Created:         01/20/98
// Function:        Invoke, IDispatch
// Abstract:        get entry point given ID
//************************************************************

HRESULT
CContainerSite::Invoke(DISPID dispIDMember, REFIID riid, LCID lcid, unsigned short wFlags, 
              DISPPARAMS *pDispParams, VARIANT *pVarResult, EXCEPINFO *pExcepInfo, UINT *puArgErr) 
{

#ifdef DEBUG
    // Here the key to wFlags:
    //
    // #define DISPATCH_METHOD         0x1
    // #define DISPATCH_PROPERTYGET    0x2
    // #define DISPATCH_PROPERTYPUT    0x4
    // #define DISPATCH_PROPERTYPUTREF 0x8

    switch (dispIDMember)
    {
        case DISPID_AMBIENT_USERMODE:
            TraceTag((tagContainerSite, "CContainerSite::Invoke(DISPID_AMBIENT_USERMODE, %04X)", wFlags));
            break;

        default:
            TraceTag((tagContainerSite, "CContainerSite::Invoke(%08X, %04X)", dispIDMember, wFlags));
            break;
    }
#endif

    return E_NOTIMPL;
} // Invoke

//************************************************************
// Author:          twillie
// Created:         01/20/98
// Function:        QueryStatus, IOleCommandTarget
// Abstract:        
//************************************************************

HRESULT
CContainerSite::QueryStatus(const GUID *pguidCmdGroup, ULONG cCmds, OLECMD prgCmds[], OLECMDTEXT *pCmdText)
{ 
    TraceTag((tagContainerSite, "CContainerSite::QueryStatus"));
    return E_NOTIMPL;
} // QueryStatus

//************************************************************
// Author:          twillie
// Created:         01/20/98
// Function:        Exec, IOleCommandTarget
// Abstract:        
//************************************************************

HRESULT
CContainerSite::Exec(const GUID *pguidCmdGroup, DWORD nCmdID, DWORD nCmdexecopt, VARIANTARG *pvaIn, VARIANTARG *pvaOut)
{ 
    TraceTag((tagContainerSite, "CContainerSite::Exec"));
    return E_NOTIMPL;
} // Exec
//************************************************************
// Author:          twillie
// Created:         01/19/99
// Function:        GetBorder, IOleUIWindow
// Abstract:        Returns the rectangle in which the 
//                  container is willing to negotiate about an 
//                  object's adornments. 
//************************************************************

HRESULT
CContainerSite::GetBorder(LPRECT prcBorder)
{ 
    TraceTag((tagContainerSite, "CContainerSite::GetBorder"));
    return NOERROR; 
} // GetBorder

//************************************************************
// Author:          twillie
// Created:         01/19/99
// Function:        RequestBorderSpace, IOleUIWindow
// Abstract:        Asks the container if it can surrender the
//                  amount of space in pBW that the object 
//                  would like for it's adornments.  The 
//                  container does nothing but validate the 
//                  spaces on this call. 
//************************************************************

HRESULT
CContainerSite::RequestBorderSpace(LPCBORDERWIDTHS pBW)
{ 
    TraceTag((tagContainerSite, "CContainerSite::RequestBorderSpace"));
    return NOERROR; 
} // RequestBorderSpace

//************************************************************
// Author:          twillie
// Created:         01/19/99
// Function:        SetBorderSpace, IOleUIWindow
// Abstract:        Called when the object now officially 
//                  requests that the container surrender 
//                  border space it previously allowed in 
//                  RequestBorderSpace.  The container should 
//                  resize windows appropriately to surrender 
//                  this space. 
//************************************************************

HRESULT
CContainerSite::SetBorderSpace(LPCBORDERWIDTHS pBW) 
{ 
    TraceTag((tagContainerSite, "CContainerSite::SetBorderSpace"));
    return NOERROR; 
} // SetBorderSpace

//************************************************************
// Author:          twillie
// Created:         01/19/99
// Function:        SetActiveObject, IOleUIWindow
// Abstract:        Provides the container with the object's 
//                  IOleInPlaceActiveObject pointer and a name 
//                  of the object to show in the container's 
//                  caption. 
//************************************************************

HRESULT
CContainerSite::SetActiveObject(LPOLEINPLACEACTIVEOBJECT pIIPActiveObj, LPCOLESTR pszObj) 
{ 
    TraceTag((tagContainerSite, "CContainerSite::SetActiveObject(%08X, %08X)", pIIPActiveObj, pszObj));
    return S_OK; 
} // SetActiveObject

//************************************************************
// Author:          twillie
// Created:         01/19/99
// Function:        InsertMenus, IOleInPlaceFrame
// Abstract:        Instructs the container to place its 
//                  in-place menu items where necessary in the 
//                  given menu and to fill in elements 0, 2, 
//                  and 4 of the OLEMENUGROUPWIDTHS array to 
//                  indicate how many top-level items are in 
//                  each group. 
//************************************************************

HRESULT
CContainerSite::InsertMenus(HMENU hMenu, LPOLEMENUGROUPWIDTHS pMGW) 
{ 
    TraceTag((tagContainerSite, "CContainerSite::InsertMenus"));
    return NOERROR; 
} // InsertMenus

//************************************************************
// Author:          twillie
// Created:         01/19/99
// Function:        SetMenu, IOleInPlaceFrame
// Abstract:        Instructs the container to replace 
//                  whatever menu it's currently using with 
//                  the given menu and to call 
//                  OleSetMenuDescritor so OLE knows to whom 
//                  to dispatch messages. 
//************************************************************

HRESULT
CContainerSite::SetMenu(HMENU hMenu, HOLEMENU hOLEMenu, HWND hWndObj) 
{ 
    TraceTag((tagContainerSite, "CContainerSite::SetMenu"));
    return NOERROR; 
} // SetMenu

//************************************************************
// Author:          twillie
// Created:         01/20/98
// Function:        RemoveMenus, IOleInPlaceFrame
// Abstract:        Asks the container to remove any menus it 
//                  put into hMenu in InsertMenus.
//************************************************************

HRESULT
CContainerSite::RemoveMenus(HMENU hMenu) 
{ 
    TraceTag((tagContainerSite, "CContainerSite::RemoveMenus"));
    return NOERROR; 
} // RemoveMenus

//************************************************************
// Author:          twillie
// Created:         01/19/99
// Function:        SetStatusText, IOleInPlaceFrame
// Abstract:        Asks the container to place some text in a 
//                  status line, if one exists.  If the 
//                  container does not have a status line it 
//                  should return E_FAIL here in which case 
//                  the object could display its own. 
//************************************************************

HRESULT
CContainerSite::SetStatusText(LPCOLESTR pszText) 
{ 
    TraceTag((tagContainerSite, "CContainerSite::SetStatusText"));
    return E_FAIL; 
} // SetStatusText

//************************************************************
// Author:          twillie
// Created:         01/19/99
// Function:        EnableModeless, IOleInPlaceFrame
// Abstract:        Instructs the container to show or hide 
//                  any modeless popup windows that it may be 
//                  using. 
//************************************************************

HRESULT
CContainerSite::EnableModeless(BOOL fEnable) 
{ 
    TraceTag((tagContainerSite, "CContainerSite::EnableModeless - %s", fEnable ? "TRUE" : "FALSE"));
    return NOERROR; 
} // EnableModeless

//************************************************************
// Author:          twillie
// Created:         01/19/99
// Function:        TranslateAccelerator, IOleInPlaceFrame
// Abstract:        When dealing with an in-place object from 
//                  an EXE server, this is called to give the 
//                  container a chance to process accelerators 
//                  after the server has looked at the message. 
//************************************************************

HRESULT
CContainerSite::TranslateAccelerator(LPMSG pMSG, WORD wID) 
{ 
    TraceTag((tagContainerSite, "CContainerSite::TranslateAccelerator"));
    return S_FALSE; 
} // TranslateAccelerator

#define DISPID_DURATION 1003
#define LCID_SCRIPTING 0x0409
#define DISPID_ISDURATIONVALID 1059
#define DISPID_CANSEEK 1012

HRESULT
CContainerSite::GetMediaLength(double &dblLength)
{
    HRESULT hr;
    DISPPARAMS dispparamsNoArgs = {NULL, NULL, 0, 0};
    DAComPtr<IDispatch> pdisp;
    CComVariant _retVar;
    CComVariant vIsValid;
    hr = m_pObj->QueryInterface(IID_TO_PPV(IDispatch, &pdisp));
    if (FAILED(hr))
    {
        goto done;
    }

    hr = pdisp->Invoke(DISPID_ISDURATIONVALID,
                       IID_NULL,
                       LCID_SCRIPTING,
                       DISPATCH_PROPERTYGET,
                       &dispparamsNoArgs,
                       &vIsValid, NULL, NULL);
    if (FAILED(hr))
    {
        goto done;
    }
    if (!vIsValid.boolVal)
    {
        hr = E_FAIL;
        goto done;
    }


    hr = pdisp->Invoke(DISPID_DURATION,
                       IID_NULL,
                       LCID_SCRIPTING,
                       DISPATCH_PROPERTYGET,
                       &dispparamsNoArgs,
                       &_retVar, NULL, NULL);
    if (FAILED(hr))
    {
        goto done;
    }


    hr = _retVar.ChangeType(VT_R8, NULL);
    if (FAILED(hr))
    {
        goto done;
    }
    dblLength = _retVar.dblVal;

    //hr = m_pMPlayer->get_Duration(&dblLength);

done:
    return hr;
}

HRESULT
CContainerSite::CanSeek(bool &fcanSeek)
{
    HRESULT hr;
    DISPPARAMS dispparamsNoArgs = {NULL, NULL, 0, 0};
    DAComPtr<IDispatch> pdisp;
    CComVariant vIsValid;
    hr = m_pObj->QueryInterface(IID_TO_PPV(IDispatch, &pdisp));
    if (FAILED(hr))
    {
        fcanSeek = false;
        goto done;
    }

    hr = pdisp->Invoke(DISPID_CANSEEK,
                       IID_NULL,
                       LCID_SCRIPTING,
                       DISPATCH_PROPERTYGET,
                       &dispparamsNoArgs,
                       &vIsValid, NULL, NULL);
    if (FAILED(hr))
    {
        fcanSeek = false;
        goto done;
    }
    if (vIsValid.boolVal)
    {
        fcanSeek = true;
    }
    else
    {
        fcanSeek = false;
    }

done:
    return hr;
}


//************************************************************
// End of file
//************************************************************
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\time\src\containerobj.h ===
#ifndef _CONTAINEROBJ_H_
#define _CONTAINEROBJ_H_

//************************************************************
//
// FileName:        containerobj.h
//
// Created:         10/08/98
//
// Author:          TWillie
// 
// Abstract:        Declaration of CContainerObj
//
//************************************************************


#include "containersite.h"

// forward declaration
class CContainerSite;

class CContainerObj :
    public IDispatch,
    public IConnectionPointContainer
{
    public: 
        CContainerObj();
        virtual ~CContainerObj();
        HRESULT Init(REFCLSID clsid, CTIMEElementBase *pElem);
        HRESULT DetachFromHostElement (void);

        // IUnknown Methods
        STDMETHODIMP_(ULONG) AddRef(void);
        STDMETHODIMP_(ULONG) Release(void);
        STDMETHODIMP QueryInterface(REFIID refiid, void** ppunk);

        // IDispatch Methods
        STDMETHODIMP GetTypeInfoCount(UINT *pctInfo);
        STDMETHODIMP GetTypeInfo(UINT itinfo, LCID lcid, ITypeInfo **pptInfo);
        STDMETHODIMP GetIDsOfNames(REFIID  riid, OLECHAR **rgszNames, UINT cNames, LCID lcid, DISPID *rgDispID);
        STDMETHODIMP Invoke(DISPID disIDMember, REFIID riid, LCID lcid, unsigned short wFlags, DISPPARAMS *pDispParams, VARIANT *pVarResult, EXCEPINFO *pExcepInfo, UINT *puArgErr);

        // IConnectionPointContainer methods
        STDMETHOD(EnumConnectionPoints)(IEnumConnectionPoints **ppEnum);
        STDMETHOD(FindConnectionPoint)(REFIID riid, IConnectionPoint **ppCP);

        // methods for hosting site
        HRESULT Start();
        HRESULT Stop();
        HRESULT Pause();
        HRESULT Resume();

        HRESULT Render(HDC hdc, RECT *prc);
        HRESULT SetMediaSrc(WCHAR * pwszSrc);
        HRESULT SetRepeat(long lRepeat);
        HRESULT SetSize(RECT *prect);

        HRESULT Invalidate(const RECT *prc);

        HRESULT GetControlDispatch(IDispatch **ppDisp);

        HRESULT clipBegin(VARIANT var);
        HRESULT clipEnd(VARIANT var);

        // event methods that can be fired on the container
        void onbegin();
        void onend();
        void onresume();
        void onpause();
        void onmediaready();
        void onmediaslip();
        void onmedialoadfailed();
        void onreadystatechange(long readystate);

        HRESULT Seek(double dblTime);
        double GetCurrentTime();
        CTIMEElementBase *GetTimeElem() { return m_pElem;}
        HRESULT GetMediaLength(double &dblLength);
        HRESULT CanSeek(bool &fcanSeek);

    private:
        HRESULT ProcessEvent(DISPID dispid);
        bool isFileNameAsfExt(WCHAR * pwszSrc);

    private:
        ULONG               m_cRef;
        CContainerSite     *m_pSite;
        CTIMEElementBase   *m_pElem;
        bool                m_fStarted;
        bool                m_fUsingWMP;
        bool                m_bPauseOnPlay;
        bool                m_bFirstOnMediaReady;
        bool                m_bSeekOnPlay;
        double              m_dblSeekTime;
        bool                m_bIsAsfFile;
}; // CContainerObj

#endif //_CONTAINEROBJ_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\time\src\containersite.h ===
#ifndef _CONTAINERSITE_H_
#define _CONTAINERSITE_H_

//************************************************************
//
// FileName:        containersite.h
//
// Created:         10/08/98
//
// Author:          TWillie
// 
// Abstract:        Declaration of the CContainerSite
//
//************************************************************

#include <docobj.h>
#include <mshtml.h>
#include "timeelmbase.h"
#include "containerobj.h"

// forward class declarations
class CContainerObj;

enum ObjectState
{
    OS_PASSIVE,
    OS_LOADED,
    OS_RUNNING,
    OS_INPLACE,
    OS_UIACTIVE,
};

class CContainerSite :
    public IDispatch,
    public IServiceProvider,
    public IOleClientSite,
    public IAdviseSinkEx,
    public IOleInPlaceSiteWindowless,
    public IOleInPlaceFrame,
    public IOleCommandTarget,
    public IOleControlSite
{
    public:
        CContainerSite(CContainerObj *pHost);
        virtual ~CContainerSite();

        //
        // IUnknown Methods
        //
        STDMETHODIMP_(ULONG) AddRef(void);
        STDMETHODIMP_(ULONG) Release(void);
        STDMETHODIMP QueryInterface(REFIID, void**);

        //
        // IServiceProvider methods
        //
        STDMETHODIMP QueryService(REFGUID guid, REFIID iid, void **ppv);

        //
        // IOleClientSite methods
        //
        STDMETHODIMP SaveObject(void);
        STDMETHODIMP GetMoniker(DWORD dwAssign, DWORD dwWhich, IMoniker **ppmk);
        STDMETHODIMP GetContainer(IOleContainer **ppContainer);
        STDMETHODIMP ShowObject(void);
        STDMETHODIMP OnShowWindow(BOOL fShow);
        STDMETHODIMP RequestNewObjectLayout(void);

        //
        // IAdviseSink Methods
        //
        STDMETHODIMP_(void) OnDataChange(FORMATETC *pFEIn, STGMEDIUM *pSTM);
        STDMETHODIMP_(void) OnViewChange(DWORD dwAspect, LONG lindex);
        STDMETHODIMP_(void) OnRename(IMoniker *pmk);
        STDMETHODIMP_(void) OnSave(void);
        STDMETHODIMP_(void) OnClose(void);

        //
        // IAdviseSinkEx Methods
        //
        STDMETHODIMP_(void) OnViewStatusChange(DWORD dwViewStatus);

        //
        // IOleWindow Methods
        //
        STDMETHODIMP GetWindow(HWND *phWnd);
        STDMETHODIMP ContextSensitiveHelp(BOOL fEnterMode);

        //
        // IOleInPlaceSite Methods
        //
        STDMETHODIMP CanInPlaceActivate(void);
        STDMETHODIMP OnInPlaceActivate(void);
        STDMETHODIMP OnUIActivate(void);
        STDMETHODIMP GetWindowContext(IOleInPlaceFrame **ppFrame, IOleInPlaceUIWindow **ppUIWin, RECT *prc, RECT *prcClip, OLEINPLACEFRAMEINFO *pFI);
        STDMETHODIMP Scroll(SIZE sz);
        STDMETHODIMP OnUIDeactivate(BOOL fUndoable);
        STDMETHODIMP OnInPlaceDeactivate(void);
        STDMETHODIMP DiscardUndoState(void);
        STDMETHODIMP DeactivateAndUndo(void);
        STDMETHODIMP OnPosRectChange(const RECT * prc);

        //
        // IOleInPlaceSiteEx Methods
        //
        STDMETHODIMP OnInPlaceActivateEx(BOOL * pfNoRedraw, DWORD dwFlags);
        STDMETHODIMP OnInPlaceDeactivateEx(BOOL fNoRedraw);
        STDMETHODIMP RequestUIActivate(void);

        //
        // IOleInPlaceSiteWindowless Methods
        //
        STDMETHODIMP CanWindowlessActivate(void);
        STDMETHODIMP GetCapture(void);
        STDMETHODIMP SetCapture(BOOL fCapture);
        STDMETHODIMP GetFocus(void);
        STDMETHODIMP SetFocus(BOOL fFocus);
        STDMETHODIMP GetDC(const RECT *pRect, DWORD dwFlags, HDC* phDC);
        STDMETHODIMP ReleaseDC(HDC hDC);
        STDMETHODIMP InvalidateRect(const RECT *pRect, BOOL fErase);
        STDMETHODIMP InvalidateRgn(HRGN hRGN, BOOL fErase);
        STDMETHODIMP ScrollRect(INT dx, INT dy, const RECT *prcScroll, const RECT *prcClip);
        STDMETHODIMP AdjustRect(RECT *prc);
        STDMETHODIMP OnDefWindowMessage(UINT msg, WPARAM wParam, LPARAM lParam, LRESULT* plResult);

        //
        // IOleUIWindow
        //
        STDMETHODIMP GetBorder(LPRECT prcBorder);
        STDMETHODIMP RequestBorderSpace(LPCBORDERWIDTHS pBW);
        STDMETHODIMP SetBorderSpace(LPCBORDERWIDTHS pBW);
        STDMETHODIMP SetActiveObject(LPOLEINPLACEACTIVEOBJECT pIIPActiveObj, LPCOLESTR pszObj);

        //
        // IOleInPlaceFrame Methods
        //
        STDMETHODIMP InsertMenus(HMENU hMenu, LPOLEMENUGROUPWIDTHS pMGW);
        STDMETHODIMP SetMenu(HMENU hMenu, HOLEMENU hOLEMenu, HWND hWndObj);
        STDMETHODIMP RemoveMenus(HMENU hMenu);
        STDMETHODIMP SetStatusText(LPCOLESTR pszText);
        STDMETHODIMP EnableModeless(BOOL fEnable);
        STDMETHODIMP TranslateAccelerator(LPMSG pMSG, WORD wID);

        //
        // IDispatch Methods
        //
        STDMETHODIMP GetTypeInfoCount(UINT *pctInfo);
        STDMETHODIMP GetTypeInfo(UINT itinfo, LCID lcid, ITypeInfo **pptInfo);
        STDMETHODIMP GetIDsOfNames(REFIID  riid, OLECHAR **rgszNames, UINT cNames, LCID lcid, DISPID *rgDispID);
        STDMETHODIMP Invoke(DISPID disIDMember, REFIID riid, LCID lcid, unsigned short wFlags, DISPPARAMS *pDispParams, VARIANT *pVarResult, EXCEPINFO *pExcepInfo, UINT *puArgErr);

        //
        // IOleCommandTarget
        //
        STDMETHODIMP QueryStatus(const GUID *pguidCmdGroup, ULONG cCmds, OLECMD prgCmds[], OLECMDTEXT *pCmdText);
        STDMETHODIMP Exec(const GUID *pguidCmdGroup, DWORD nCmdID, DWORD nCmdexecopt, VARIANTARG *pvaIn, VARIANTARG *pvaOut);

        //
        // IOleControlSite methods
        //
        STDMETHOD(OnControlInfoChanged)(void);
        STDMETHOD(LockInPlaceActive)(BOOL fLock);
        STDMETHOD(GetExtendedControl)(IDispatch **ppDisp);
        STDMETHOD(TransformCoords)(POINTL *pPtlHiMetric, POINTF *pPtfContainer, DWORD dwFlags);
        STDMETHOD(TranslateAccelerator)(MSG *pmsg, DWORD grfModifiers);
        STDMETHOD(OnFocus)(BOOL fGotFocus);
        STDMETHOD(ShowPropertyFrame)(void);

        // internal
        HRESULT Init(REFCLSID clsid, CTIMEElementBase *pElem);
        HRESULT DetachFromHostElement (void);
        void Close();
        HRESULT draw(HDC hdc, RECT *prc);
        HRESULT begin();
        HRESULT end();
        HRESULT pause();
        HRESULT resume();
        ITIMEMediaPlayer *GetPlayer();
        IOleInPlaceObject *GetIOleInPlaceObject() { return m_pInPlaceObject;}
        HRESULT GetMediaLength(double &dblLength);
        HRESULT CanSeek(bool &fcanSeek);
        void ClearAutosizeFlag() { m_fAutosize = false;}
        void SetMediaReadyFlag() { m_fMediaReady = true;}
        bool GetMediaReadyFlag() { return m_fMediaReady;}

    private:
        enum
        {
            VALIDATE_ATTACHED = 1,
            VALIDATE_LOADED   = 2,
            VALIDATE_INPLACE  = 3,
            VALIDATE_WINDOWLESSINPLACE = 4,
        };

        bool IllegalSiteCall(DWORD dwFlags);

    private:
        ULONG                            m_cRef;
        DWORD                            m_dwAdviseCookie;
        DWORD                            m_dwEventsCookie;
        ObjectState                      m_osMode;
        IConnectionPoint                *m_pcpEvents;
        IViewObject2                    *m_pViewObject;
        IOleObject                      *m_pIOleObject;
        IUnknown                        *m_pObj;
        IOleInPlaceObject               *m_pInPlaceObject;
        IHTMLDocument2                  *m_pHTMLDoc;
        ITIMEMediaPlayer                *m_pPlayer;
        CTIMEElementBase                *m_pTIMEElem;
        CContainerObj                   *m_pHost;
        bool                             m_fWindowless;
        bool                             m_fAutosize;
        bool                             m_fStarted;
        bool                             m_fMediaReady;

}; // CContainerSite

inline ITIMEMediaPlayer *
CContainerSite::GetPlayer()
{
    Assert(m_pPlayer != NULL);
    return m_pPlayer;
} // GetPlayer

#endif //_CONTAINERSITE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\time\src\daelm.cpp ===
/*******************************************************************************
 *
 * Copyright (c) 1998 Microsoft Corporation
 *
 * File: daelm.cpp
 *
 * Abstract:
 *
 *
 *
 *******************************************************************************/


#include "headers.h"
#include "daelm.h"
#include "bodyelm.h"

// static class data.
CPtrAry<BSTR> CTIMEDAElement::ms_aryPropNames;
DWORD CTIMEDAElement::ms_dwNumTimeDAElems = 0;

// These must align with the class PROPERTY_INDEX enumeration.
LPWSTR CTIMEDAElement::ms_rgwszTDAPropNames[] = {
    L"renderMode",
};

DeclareTag(tagDATimeElm, "API", "CTIMEDAElement methods");

CTIMEDAElement::CTIMEDAElement()
: m_renderMode(REPLACE_TOKEN),
  m_fPropertiesDirty(true),
  m_cookieValue(1)
{
    TraceTag((tagDATimeElm,
              "CTIMEDAElement(%lx)::CTIMEDAElement()",
              this));

    CTIMEDAElement::ms_dwNumTimeDAElems++;
}

CTIMEDAElement::~CTIMEDAElement()
{
    CTIMEDAElement::ms_dwNumTimeDAElems--;

    if (0 == CTIMEDAElement::ms_dwNumTimeDAElems)
    {
        int iNames = CTIMEDAElement::ms_aryPropNames.Size();

        for (int i = iNames - 1; i >= 0; i--)
        {
            BSTR bstrName = CTIMEDAElement::ms_aryPropNames[i];
            CTIMEDAElement::ms_aryPropNames.DeleteItem(i);
            ::SysFreeString(bstrName);
        }
    }
}


HRESULT
CTIMEDAElement::Notify(LONG event, VARIANT * pVar)
{
    TraceTag((tagDATimeElm,
              "CTIMEDAElement(%lx)::Notify(%lx)",
              this,
              event));

    THR(CBaseBvr::Notify(event, pVar));
    
    HRESULT hr = S_OK;
    if (BEHAVIOREVENT_DOCUMENTCONTEXTCHANGE == event)
    {
        DAComPtr<IHTMLElement> spHTMLEle;
        hr = m_pHTMLEle->get_parentElement(&spHTMLEle);
        if (FAILED(hr))
        {
            goto done;
        }
        if (NULL == spHTMLEle.p)
        {
            if (NULL != m_body.p)
            {
                std::map<long, ITIMEMMBehavior*>::iterator iter;
                iter = m_cookieMap.begin();
                
                while (iter != m_cookieMap.end())
                {
                    ITIMEMMBehavior *bvr;
                    
                    bvr = (*iter).second;
                    
                    ITIMEMMTimeline * tl;
                    
                    MMPlayer *player = &(m_body->GetPlayer());
                    if (NULL == player)
                    {
                        goto done;
                    }
                    
                    MMTimeline *timeline =  &(player->GetTimeline());
                    if (NULL == timeline)
                    {
                        goto done;
                    }
                    
                    tl = timeline->GetMMTimeline();
                    if (NULL == tl)
                    {
                        goto done;
                    }
                    
                    hr = THR(tl->RemoveBehavior(bvr));
                    
                    std::map<long, ITIMEMMBehavior*>::iterator olditer=iter;
                    iter++;
                    m_cookieMap.erase(olditer);            
                } // while
                m_cookieMap.clear();
            }
        }
    }

done:
    return S_OK;
}

HRESULT
CTIMEDAElement::Init(IElementBehaviorSite * pBehaviorSite)
{
    TraceTag((tagDATimeElm,
              "CTIMEDAElement(%lx)::Init(%#lx)",
              this,
              pBehaviorSite));

    HRESULT hr;

    hr = THR(CBaseBvr::Init(pBehaviorSite));
    if (FAILED(hr))
    {
        goto done;
    }
    
    hr = m_pBvrSite->RegisterNotification(BEHAVIOREVENT_DOCUMENTCONTEXTCHANGE);
    if (FAILED(hr))
    {
        goto done;
    }

    hr = m_pBvrSiteOM->RegisterName(WZ_REGISTERED_NAME_DAELM);
    if (FAILED(hr))
    {
        goto done;
    }

    Assert(GetBehaviorTypeAsURN());
    
    MMFactory::AddRef();
    
    if (MMFactory::GetFactory() == NULL)
    {
        hr = E_FAIL;
        goto done;
    }
    
    hr = THR(AddBodyBehavior(GetElement()));
    
    if (FAILED(hr))
    {
        goto done;
    }
    
    {
        CRLockGrabber __gclg;
        
        m_image = (CRImagePtr) CRModifiableBvr((CRBvrPtr) CREmptyImage(),0);
        
        if (!m_image)
        {
            TraceTag((tagError,
                      "CTIMEDAElement(%lx)::Init(): Failed to create image switcher - %hr, %ls",
                      this,
                      CRGetLastError(),
                      CRGetLastErrorString()));
            
            hr = CRGetLastError();
            goto done;
        }
        
        m_sound = (CRSoundPtr) CRModifiableBvr((CRBvrPtr) CRSilence(),0);
        
        if (!m_sound)
        {
            TraceTag((tagError,
                      "CTIMEDAElement(%lx)::Init(): Failed to create sound switcher - %hr, %ls",
                      this,
                      CRGetLastError(),
                      CRGetLastErrorString()));
            
            hr = CRGetLastError();
            goto done;
        }
    }
    
    if (!m_view.Init(NULL,
                     m_image,
                     m_sound,
                     (ITIMEMMViewSite *) this))
    {
        TraceTag((tagError,
                  "CTIMEDAElement(%lx)::Init(): Failed to init mmview - %hr, %ls",
                  this,
                  CRGetLastError(),
                  CRGetLastErrorString()));
            
        hr = CRGetLastError();
        goto done;
    }

    if (!RegisterWithBody())
    {
        TraceTag((tagError,
                  "CTIMEDAElement(%lx)::Init(): Failed to register with body - %hr, %ls",
                  this,
                  CRGetLastError(),
                  CRGetLastErrorString()));
            
        hr = CRGetLastError();
        goto done;
    }
    
    hr = S_OK;
  done:
    return hr;
}

HRESULT
CTIMEDAElement::Detach()
{
    TraceTag((tagDATimeElm,
              "CTIMEDAElement(%lx)::Detach()",
              this));

    RemoveFromBody();
    
    m_view.Deinit();

    MMFactory::Release();
    
    m_body.Release();
    m_renderSite.Release();
    
    THR(CBaseBvr::Detach());

    return S_OK;
}

HRESULT
CTIMEDAElement::get_image(VARIANT * img)
{
    bool ok = false;
    
    ok = CRBvrToVARIANT((CRBvrPtr) m_image.p, img);
    
    return ok?S_OK:Error();
}

HRESULT
CTIMEDAElement::put_image(VARIANT img)
{
    bool ok = false;

    CRBvrPtr bvr;
    
    bvr = VARIANTToCRBvr(img, CRIMAGE_TYPEID);
        
    if (bvr == NULL)
    {
        goto done;
    }
        
    Assert(m_image);
    if (m_image)
    {
        CRLockGrabber __gclg;
        
        if (!CRSwitchTo((CRBvrPtr) m_image.p,
                        bvr,
                        false,
                        CRContinueTimeline,
                        0.0))
        {
            TraceTag((tagError,
                      "CTIMEDAElement(%lx)::put_image(): Failed to switch image  - %hr, %ls",
                      this,
                      CRGetLastError(),
                      CRGetLastErrorString()));
            
            goto done;
        }
    }
    else
    {
        goto done;
    }
    
    ok = true;
  done:
    return ok?S_OK:Error();
}

    
HRESULT
CTIMEDAElement::get_sound(VARIANT * snd)
{
    bool ok = false;
    
    ok = CRBvrToVARIANT((CRBvrPtr) m_sound.p, snd);

    return ok?S_OK:Error();
}

HRESULT
CTIMEDAElement::put_sound(VARIANT snd)
{
    bool ok = false;

    CRBvrPtr bvr;

    bvr = VARIANTToCRBvr(snd, CRSOUND_TYPEID);
    
    if (bvr == NULL)
    {
        goto done;
    }
    
    {
        CRLockGrabber __gclg;

        if (!CRSwitchTo((CRBvrPtr) m_sound.p,
                        bvr,
                        false,
                        CRContinueTimeline,
                        0.0))
        {
            TraceTag((tagError,
                      "CTIMEDAElement(%lx)::put_sound(): Failed to switch sound  - %hr, %ls",
                      this,
                      CRGetLastError(),
                      CRGetLastErrorString()));
            
            goto done;
        }
    }
        
    ok = true;
  done:
    return ok?S_OK:Error();
}

HRESULT
CTIMEDAElement::get_renderMode(VARIANT * mode)
{
    HRESULT hr;
    
    if (mode == NULL)
    {
        hr = E_POINTER;
        goto done;
    }

    if (FAILED(hr = THR(VariantClear(mode))))
    {
        goto done;
    }
    
    V_VT(mode) = VT_BSTR;
    V_BSTR(mode) = SysAllocString(TokenToString(m_renderMode));

    hr = S_OK;
  done:
    return hr;
}

HRESULT
CTIMEDAElement::put_renderMode(VARIANT mode)
{
    CComVariant v;
    HRESULT hr;
  
    hr = v.ChangeType(VT_BSTR, &mode);

    if (FAILED(hr))
    {
        goto done;
    }
  
    TOKEN newmode;

    newmode = StringToToken(V_BSTR(&v));
    if (m_renderMode != newmode)
    {
        m_renderMode = newmode;
        InvalidateRect(NULL);
        InvalidateRenderInfo();
    }
    
    hr = S_OK;
  done:
    return hr;
}

    
HRESULT
CTIMEDAElement::addDABehavior(VARIANT var,
                              LONG * cookie)
{
    bool ok = false;
 
    HRESULT hr;
    DAComPtr<IDABehavior> dabvr;
    DAComPtr<IUnknown> punk;
    DAComPtr<ITIMEMMBehavior> mmbvr;

    CHECK_RETURN_SET_NULL(cookie);
    
    CComVariant newvar;

    std::map<long, ITIMEMMBehavior*>::iterator iterator;
    std::pair<std::map<long, ITIMEMMBehavior*>::iterator, bool> pair;

    if (!m_body)
    {
        hr = E_FAIL;
        goto done;
    }
    
    hr = THR(newvar.ChangeType(VT_UNKNOWN, &var));

    if (FAILED(hr))
    {
        goto done;
    }
    
    hr = THR(V_UNKNOWN(&newvar)->QueryInterface(IID_IDABehavior,
                                                (void **)&dabvr));
        

    if (FAILED(hr))
    {
        goto done;
    }
    
    Assert(MMFactory::GetFactory());
    
    hr = THR(MMFactory::GetFactory()->CreateBehavior(NULL, dabvr, &punk));

    if (FAILED(hr))
    {
        goto done;
    }
    
    hr = THR(punk->QueryInterface(IID_ITIMEMMBehavior, (void**)&mmbvr));

    if (FAILED(hr))
    {
        CRSetLastError(hr, NULL);
        goto done;
    }
    
    Assert(m_body);

    ITIMEMMTimeline * tl;
    
    tl = m_body->GetPlayer().GetTimeline().GetMMTimeline();

    hr = THR(tl->AddBehavior(mmbvr, MM_START_ABSOLUTE, NULL));

    if (FAILED(hr))
    {
        goto done;
    }

    
    {
        // if m_cookieValue wraps then simple incrementing may overlap two cookie values
        // this code could spin forever if all of the objects places are taken in the map
        iterator = m_cookieMap.find(m_cookieValue);
        while ( false == m_cookieMap.empty() && iterator != m_cookieMap.end() )
        {
            m_cookieValue++;
            if (0 == m_cookieValue)
                m_cookieValue++;
            iterator = m_cookieMap.find(m_cookieValue);
        }
        
        std::pair<const long, ITIMEMMBehavior*> *ppairInsert;
        ppairInsert = new std::pair<const long, ITIMEMMBehavior*>(m_cookieValue, mmbvr);
        if (NULL == ppairInsert)
        {
            // purposely drop the result, we are out of memory already.
            tl->RemoveBehavior(mmbvr);

            CRSetLastError(E_OUTOFMEMORY, NULL);
            goto done;
        }
        pair = m_cookieMap.insert(*ppairInsert);
        delete ppairInsert;
        
        if (false == pair.second)
        {
            // purposely drop the result, we are out of memory already.
            tl->RemoveBehavior(mmbvr);

            CRSetLastError(E_OUTOFMEMORY, NULL);
            goto done;
        }
        
        *cookie = m_cookieValue;
        m_cookieValue++;  
        if (0 == m_cookieValue)
            m_cookieValue++;
    }

    ok = true;
  done:
    return ok?S_OK:Error();
}

HRESULT
CTIMEDAElement::removeDABehavior(LONG cookie)
{
    bool ok = false;
    
    HRESULT hr = E_FAIL;

    ITIMEMMBehavior * bvr = NULL;

    std::map<long, ITIMEMMBehavior*>::iterator iterator;

    if (!m_body)
    {
        CRSetLastError(E_FAIL, NULL);
        goto done;
    }

    iterator = m_cookieMap.find(cookie);

    if ( iterator == m_cookieMap.end() )
    {
        // cookie wasn't found!
        CRSetLastError(E_INVALIDARG, NULL);
        goto done;
    }
    Assert( cookie == (*iterator).first);
    
    bvr = (*iterator).second;
    
    m_cookieMap.erase(iterator);

    ITIMEMMTimeline * tl;
    
    tl = m_body->GetPlayer().GetTimeline().GetMMTimeline();

    hr = THR(tl->RemoveBehavior(bvr));

    if (FAILED(hr))
    {
        goto done;
    }

    ok = true;
  done:
    return ok?S_OK:Error();
}

STDMETHODIMP
CTIMEDAElement::get_renderObject(ITIMEDAElementRender ** p)
{
    return QueryInterface(IID_ITIMEDAElementRender, (void **) p);
}

STDMETHODIMP
CTIMEDAElement::Tick()
{
    bool ok = false;

    if (!m_body)
    {
        CRSetLastError(E_FAIL, NULL);
        goto done;
    }
    
    if (!m_view.Tick())
    {
        goto done;
    }

    ok = true;
  done:
    return ok?S_OK:Error();
}

STDMETHODIMP
CTIMEDAElement::Draw(HDC dc, LPRECT prc)
{
    bool ok = false;

    if (!m_body)
    {
        CRSetLastError(E_FAIL, NULL);
        goto done;
    }
    
    if (!m_view.Render(dc, prc))
    {
        goto done;
    }

    ok = true;
  done:
    return ok?S_OK:Error();
}

STDMETHODIMP
CTIMEDAElement::get_RenderSite(ITIMEDAElementRenderSite ** ppSite)
{
    CHECK_RETURN_SET_NULL(ppSite);

    *ppSite = m_renderSite;

    if (*ppSite)
    {
        (*ppSite)->AddRef();
    }
    
    return S_OK;
}

STDMETHODIMP
CTIMEDAElement::put_RenderSite(ITIMEDAElementRenderSite * pSite)
{
    m_renderSite = pSite;

    return S_OK;
}

//
//
//

bool
CTIMEDAElement::AddToBody(CTIMEBodyElement & body)
{
    if (m_body)
    {
        CRSetLastError(E_FAIL, NULL);
        return false;
    }
    
    m_body = &body;
    return body.GetPlayer().AddView(m_view);
}

void
CTIMEDAElement::RemoveFromBody()
{
    if (m_body)
    {
        m_body->GetPlayer().RemoveView(m_view);
        m_body.Release();
    }
}

bool
CTIMEDAElement::RegisterWithBody()
{
    DAComPtr<IHTMLElement> pHTMLElem;
    DAComPtr<ITIMEElement> pTIMEElem;
    DAComPtr<ITIMEBodyElement> pTIMEBody;
    bool rc = false;
    HRESULT hr;

    Assert(!m_body);
    
    hr = THR(GetBodyElement(GetElement(), IID_IHTMLElement, (void **)&pHTMLElem));
    if (FAILED(hr))
    {
        CRSetLastError(hr, NULL);
        goto done;
    }

    Assert(pHTMLElem.p != NULL);

    hr = THR(FindTIMEInterface(pHTMLElem, &pTIMEElem));
    if (FAILED(hr))
    {
        goto done;
    }

    Assert(pTIMEElem.p != NULL);

    hr = THR(pTIMEElem->QueryInterface(IID_ITIMEBodyElement, (void**)&pTIMEBody));
    if (FAILED(hr))
    {
        goto done;
    }

    Assert(pTIMEBody.p != NULL);

    hr = THR(pTIMEBody->addTIMEDAElement(this));
    if (FAILED(hr))
    {
        TraceTag((tagError, "CTIMEDAElement::RegisterWithBody - failed to invoke addTIMEDAElement"));
        goto done;
    }

    rc = true;

done:
    return rc;
}

STDMETHODIMP
CTIMEDAElement::get_statics(IDispatch **ppDisp)
{
    TraceTag((tagDATimeElm,
          "CTIMEDAElement(%lx)::get_Statics()",
          this));

    DAComPtr<IDAStatics> pStatics;
 
    CHECK_RETURN_SET_NULL(ppDisp);

    HRESULT hr = S_OK;

    // Do not need to deal with NULLing pointer since CoCreateInstance
    // does this
    hr = CoCreateInstance(CLSID_DAStatics,
                          NULL,
                          CLSCTX_INPROC_SERVER,
                          IID_IDAStatics,
                          (void **)&pStatics);
    if (FAILED(hr))
    {
        goto done;
    }

    hr = pStatics->put_ClientSite((IOleClientSite *) this);
    if (FAILED(hr))
    {
        goto done;
    }

    // Make assignment for return value, convert to IDispatch
    // Note that we forward the addref on
    hr = pStatics->QueryInterface(IID_IDispatch, (void**)ppDisp);

  done:
    return hr;
}

//////////////////////////////////////////////////////////////////////////////////////////////////////////////
// ITIMEMMViewSite

//////////////////////////////////////////////////////////////////////////////////////////////////////////////

STDMETHODIMP
CTIMEDAElement::Invalidate(LPRECT prc)
{
    TraceTag((tagDATimeElm,
              "CTIMEDAElement(%lx)::Invalidate()",
              this));

    if (m_renderMode != NONE_TOKEN)
    {
        InvalidateRect(prc);
    }

    if (m_renderSite)
    {
        IGNORE_HR(m_renderSite->Invalidate(prc));
    }
    
    return S_OK;
}

// THESE ARE HERE TEMPORARILY UNTIL TRIDENT UPDATES MSHTML.H
#ifndef BEHAVIORRENDERINFO_SURFACE
#define BEHAVIORRENDERINFO_SURFACE    0x100000
#endif

#ifndef BEHAVIORRENDERINFO_3DSURFACE
#define BEHAVIORRENDERINFO_3DSURFACE  0x200000;
#endif

//////////////////////////////////////////////////////////////////////////////////////////////////////////////
// IElementBehaviorRender

//////////////////////////////////////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CTIMEDAElement::GetRenderInfo(LONG *pdwRenderInfo)
{
    TraceTag((tagDATimeElm,
              "CTIMEDAElement(%lx)::GetRenderInfo()",
              this));
    
    // Return the layers we are interested in drawing

    // We do not do any rendering so return 0
    
    *pdwRenderInfo = 0;

    if (m_renderMode != NONE_TOKEN)
    {
        *pdwRenderInfo |= BEHAVIORRENDERINFO_AFTERCONTENT;
        
        // For surface from DC
        *pdwRenderInfo |= BEHAVIORRENDERINFO_SURFACE;
        *pdwRenderInfo |= BEHAVIORRENDERINFO_3DSURFACE;
    }

    return S_OK;
}

 
STDMETHODIMP
CTIMEDAElement::Draw(HDC hdc, LONG dwLayer, LPRECT prc, IUnknown * pParams)
{
    TraceTag((tagDATimeElm,
              "CTIMEDAElement(%lx)::Draw(%#x, %#x, (%d, %d, %d, %d), %#x)",
              this,
              hdc,
              dwLayer,
              prc->left,
              prc->top,
              prc->right,
              prc->bottom,
              pParams));

	return Draw( hdc, prc );
}

STDMETHODIMP
CTIMEDAElement::HitTestPoint(LPPOINT point,
                             IUnknown *pReserved,
                             BOOL *hit)
{
    TraceTag((tagDATimeElm,
              "CTIMEDAElement(%lx)::HitTestPoint()",
              this));

    *hit = FALSE;

    return S_OK;
}

HRESULT
CTIMEDAElement::Error()
{
    LPCWSTR str = CRGetLastErrorString();
    HRESULT hr = CRGetLastError();
    
    if (str)
        return CComCoClass<CTIMEDAElement, &__uuidof(CTIMEDAElement)>::Error(str, IID_ITIMEDAElement, hr);
    else
        return hr;
}

//*****************************************************************************

HRESULT 
CTIMEDAElement::SetPropertyByIndex(unsigned uIndex, VARIANT *pvarprop)
{
    HRESULT hr = E_FAIL;

    CComVariant var;
    
    if (tme_maxTIMEDAProp > uIndex)
    {
        switch (uIndex)
        {
          case tda_renderMode :
            hr = put_renderMode(*pvarprop);
            break;
        };
    }

    return hr;
} // SetPropertyByIndex

//*****************************************************************************

HRESULT 
CTIMEDAElement::GetPropertyByIndex(unsigned uIndex, VARIANT *pvarprop)
{
    HRESULT hr = E_FAIL;

    if (tme_maxTIMEDAProp > uIndex)
    {
        Assert(VT_EMPTY == V_VT(pvarprop));
        switch (uIndex)
        {
          case tda_renderMode :
            hr = get_renderMode(pvarprop);
            break;
        };
    }

    return hr;
} // GetPropertyByIndex

//*****************************************************************************

HRESULT
CTIMEDAElement::BuildPropertyNameList(CPtrAry<BSTR> *paryPropNames)
{
    HRESULT hr = S_OK;
    
    for (int i = 0; 
         (i < tme_maxTIMEDAProp) && (SUCCEEDED(hr));
         i++)
    {
        Assert(NULL != ms_rgwszTDAPropNames[i]);
        BSTR bstrNewName = CreateTIMEAttrName(ms_rgwszTDAPropNames[i]);
        Assert(NULL != bstrNewName);
        if (NULL != bstrNewName)
        {
            hr = paryPropNames->Append(bstrNewName);
        }
        else
        {
            hr = E_OUTOFMEMORY;
        }
    }

    return hr;
} // BuildPropertyNameList

//*****************************************************************************

HRESULT 
CTIMEDAElement::GetPropertyBagInfo(CPtrAry<BSTR> **pparyPropNames)
{
    HRESULT hr = S_OK;

    // If we haven't built this yet, build it now.
    if (0 == ms_aryPropNames.Size())
    {
        hr = BuildPropertyNameList(&(CTIMEDAElement::ms_aryPropNames));
    }

    if (SUCCEEDED(hr))
    {
        *pparyPropNames = &(CTIMEDAElement::ms_aryPropNames);
    }

    return hr;
} // GetPropertyBagInfo

//*****************************************************************************
//IPersistPropertyBag2 methods
STDMETHODIMP 
CTIMEDAElement::Load(IPropertyBag2 *pPropBag,IErrorLog *pErrorLog)
{
    if (NULL == pPropBag)
    {
        return E_INVALIDARG;
    }

    CPtrAry<BSTR> *paryPropNames = NULL;
    HRESULT hr = GetPropertyBagInfo(&paryPropNames);

    if (hr == E_NOTIMPL)
    {
        return S_OK;
    }
    else if (FAILED(hr))
    {
        return hr;
    }

    // Unfortunately Load takes an array of Variants and not
    // Variant pointers.  We therefor need to loop through
    // each one and get the correct property this way.
    unsigned uNumProps = static_cast<unsigned>(paryPropNames->Size());
    for (unsigned uProperties = 0; uProperties < uNumProps; uProperties++)
    {
        HRESULT hrres = S_OK;
        PROPBAG2 propbag;
        VARIANT var;
        VariantInit(&var);
        propbag.vt = VT_BSTR;
        propbag.pstrName = (*paryPropNames)[uProperties];
        hr = pPropBag->Read(1,
                            &propbag,
                            pErrorLog,
                            &var,
                            &hrres);
        if (SUCCEEDED(hr))
        {
            // Skip over failures ... why would we want to 
            // allow that to abort all persistance?
            hr = SetPropertyByIndex(uProperties, &var);
            VariantClear(&var);
        }
    }

    // We return error codes not specific to properties 
    // by early-outing.
    return S_OK;
} // Load

//*****************************************************************************

STDMETHODIMP 
CTIMEDAElement::Save(IPropertyBag2 *pPropBag, BOOL fClearDirty, BOOL fSaveAllProperties)
{
    if (NULL == pPropBag)
    {
        return E_INVALIDARG;
    }

    if (fClearDirty)
    {
        m_fPropertiesDirty = false;
    }

    CPtrAry<BSTR> *paryPropNames = NULL;
    HRESULT hr = GetPropertyBagInfo(&paryPropNames);

    if (hr == E_NOTIMPL)
    {
        return S_OK;
    }
    else if (FAILED(hr))
    {
        return hr;
    }

    VARIANT var;
    VariantInit(&var);
    unsigned uNumProps = static_cast<unsigned>(paryPropNames->Size());
    for (unsigned uProperties = 0; uProperties < uNumProps; uProperties++)
    {
        PROPBAG2 propbag;

        Assert(NULL != (*paryPropNames)[uProperties]);
        if (NULL != (*paryPropNames)[uProperties])
        {
            propbag.vt = VT_BSTR;
            propbag.pstrName = (*paryPropNames)[uProperties];
            
            hr = GetPropertyByIndex(uProperties, &var);
            
            // Skip over failures ... why would we want to 
            // allow that to abort all persistance?
            if ((SUCCEEDED(hr)) && (var.vt != VT_EMPTY) && (var.vt != VT_NULL))
            {
                hr = pPropBag->Write(1, &propbag, &var);
                VariantClear(&var);
            }
        }
    }

    // We return error codes not specific to properties 
    // by early-outing.
    return S_OK;
} // Save

//*****************************************************************************

STDMETHODIMP 
CTIMEDAElement::GetClassID(CLSID* pclsid)
{
    if (NULL != pclsid)
    {
        return E_POINTER;
    }
    *pclsid = __uuidof(CTIMEDAElement);
    return S_OK;
} // GetClassID

//*****************************************************************************

STDMETHODIMP 
CTIMEDAElement::InitNew(void)
{
    return S_OK;
} // InitNew

//
//
//

class __declspec(uuid("e74afe10-927b-11d2-80ba-00c04fa32195"))
DAElmGuid {};

HRESULT WINAPI
CTIMEDAElement::InternalQueryInterface(CTIMEDAElement* pThis,
                                       const _ATL_INTMAP_ENTRY* pEntries,
                                       REFIID iid,
                                       void** ppvObject)
{
    // Do not do an addref but return the original this pointer to
    // give access to the class pointer itself.
    
    if (InlineIsEqualGUID(iid, __uuidof(DAElmGuid)))
    {
        *ppvObject = pThis;
        return S_OK;
    }
    
    return CComObjectRootEx<CComSingleThreadModel>::InternalQueryInterface(pThis,
                                                                           pEntries,
                                                                           iid,
                                                                           ppvObject);
}
        
CTIMEDAElement *
GetDAElementFromInterface(IUnknown * pv)
{
    // This is a total hack to get the original class data.  The QI is
    // implemented above and does NOT do a addref so we do not need to
    // release it
    
    CTIMEDAElement * daelm = NULL;

    if (pv)
    {
        pv->QueryInterface(__uuidof(DAElmGuid),(void **)&daelm);
    }
    
    if (daelm == NULL)
    {
        CRSetLastError(E_INVALIDARG, NULL);
    }
                
    return daelm;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\time\src\daelmbase.cpp ===
/*******************************************************************************
 *
 * Copyright (c) 1998 Microsoft Corporation
 *
 * File: timeelm.cpp
 *
 * Abstract:
 *
 *
 *
 *******************************************************************************/


#include "headers.h"
#include "daelmbase.h"
#include "htmlimg.h"
#include "bodyelm.h"

// Suppress new warning about NEW without corresponding DELETE 
// We expect GCs to cleanup values.  Since this could be a useful
// warning, we should disable this on a file by file basis.
#pragma warning( disable : 4291 )  

DeclareTag(tagDATimeElmBase, "API", "CDAElementBase methods");

CDAElementBase::CDAElementBase()
: m_renderMode(INVALID_TOKEN),
  m_contentSet(false),
  m_addedToView(false),
  m_clientSiteURL(NULL),
  m_cookieValue(1)

{
    TraceTag((tagDATimeElmBase,
              "CDAElementBase(%lx)::CDAElementBase()",
              this));
}

CDAElementBase::~CDAElementBase()
{
    TraceTag((tagDATimeElmBase,
              "CDAElementBase(%lx)::~CDAElementBase()",
              this));

    delete m_clientSiteURL;
    m_clientSiteURL = NULL;
}


HRESULT
CDAElementBase::Init(IElementBehaviorSite * pBehaviorSite)
{
    TraceTag((tagDATimeElmBase,
              "CDAElementBase(%lx)::Init(%lx)",
              this,
              pBehaviorSite));
    
    HRESULT hr;

    hr = THR(CTIMEElementBase::Init(pBehaviorSite));

    if (FAILED(hr))
    {
        goto done;
    }

    {
        CRLockGrabber __gclg;
        
        m_image = (CRImagePtr) CRModifiableBvr((CRBvrPtr) CREmptyImage(),0);
        
        if (!m_image)
        {
            TraceTag((tagError,
                      "CDAElementBase(%lx)::Init(): Failed to create image switcher - %hr, %ls",
                      this,
                      CRGetLastError(),
                      CRGetLastErrorString()));
            
            hr = CRGetLastError();
            goto done;
        }
        
        m_sound = (CRSoundPtr) CRModifiableBvr((CRBvrPtr) CRSilence(),0);
        
        if (!m_sound)
        {
            TraceTag((tagError,
                      "CDAElementBase(%lx)::Init(): Failed to create sound switcher - %hr, %ls",
                      this,
                      CRGetLastError(),
                      CRGetLastErrorString()));
            
            hr = CRGetLastError();
            goto done;
        }
    }
    
    if (!m_view.Init(m_id,
                     m_image,
                     m_sound,
                     (ITIMEMMViewSite *) this))
    {
        TraceTag((tagError,
                  "CDAElementBase(%lx)::Init(): Failed to init mmview - %hr, %ls",
                  this,
                  CRGetLastError(),
                  CRGetLastErrorString()));
            
        hr = CRGetLastError();
        goto done;
    }

    hr = S_OK;
  done:
    return hr;
}

STDMETHODIMP
CDAElementBase::Detach()
{
    TraceTag((tagDATimeElmBase,
              "CDAElementBase(%lx)::Detach()",
              this));
    
    HRESULT hr;

    if (m_addedToView && GetPlayer() != NULL)
    {
        GetPlayer()->RemoveView(m_view);
    }
    
    m_addedToView = false;
    
    m_view.Deinit();

    THR(CTIMEElementBase::Detach());

    hr = S_OK;

    return hr;
}

HRESULT
CDAElementBase::StartRootTime(MMTimeline * tl)
{
    TraceTag((tagDATimeElmBase,
              "CDAElementBase(%lx)::StartRootTime(%lx)",
              this,
              tl));
    
    HRESULT hr;  

    hr = THR(CTIMEElementBase::StartRootTime(tl));

    if (FAILED(hr))
    {
        goto done;
    }

    // Need to add to the player since these need to be rooted at the
    // top

    Assert(GetBody());
    
    if(m_contentSet)
    {
        if (!AddViewToPlayer())
        {
            hr = CRGetLastError();
            goto done;
        }
    }

    hr = S_OK;
  done:
    return hr;
}

bool 
CDAElementBase::AddViewToPlayer()
{
    TraceTag((tagDATimeElmBase,
              "CDAElementBase(%lx)::AddViewToPlayer()",
              this));
    
    bool ok = false;  
    
    if (!m_addedToView)
    {
        if (!GetBody()->GetPlayer().AddView(m_view))
        {
            goto done;
        }

        m_addedToView = true;
    }
    
    ok = true;
  done:
    return ok;
}


void
CDAElementBase::StopRootTime(MMTimeline * tl)
{
    TraceTag((tagDATimeElmBase,
              "CDAElementBase(%lx)::StopRootTime(%lx)",
              this,
              tl));
    
    CTIMEElementBase::StopRootTime(tl);
    
    Assert(GetBody());
    
    if (m_addedToView)
    {
        GetBody()->GetPlayer().RemoveView(m_view);
        m_addedToView = false;
    }
    
    return;
}

bool
CDAElementBase::Update()
{
    TraceTag((tagDATimeElmBase,
              "CDAElementBase(%lx)::Update()",
              this));
    
    bool ok = false;
    
    if (!CTIMEElementBase::Update())
    {
        goto done;
    }

    ok = true;
    
  done:
    return ok;
}

//////////////////////////////////////////////////////////////////////////////////////////////////////////////
// ITIMEMMViewSite

//////////////////////////////////////////////////////////////////////////////////////////////////////////////

STDMETHODIMP
CDAElementBase::Invalidate(LPRECT prc)
{
    TraceTag((tagDATimeElmBase,
              "CDAElementBase(%lx)::Invalidate()",
              this));

    InvalidateRect(prc);

    return S_OK;
}

// THESE ARE HERE TEMPORARILY UNTIL TRIDENT UPDATES MSHTML.H
#ifndef BEHAVIORRENDERINFO_SURFACE
#define BEHAVIORRENDERINFO_SURFACE    0x100000
#endif

#ifndef BEHAVIORRENDERINFO_3DSURFACE
#define BEHAVIORRENDERINFO_3DSURFACE  0x200000;
#endif

//////////////////////////////////////////////////////////////////////////////////////////////////////////////
// IElementBehaviorRender

//////////////////////////////////////////////////////////////////////////////////////////////////////////////
HRESULT
CDAElementBase::GetRenderInfo(LONG *pdwRenderInfo)
{
    TraceTag((tagDATimeElmBase,
              "CDAElementBase(%lx)::GetRenderInfo()",
              this));
    
    // Return the layers we are interested in drawing

    *pdwRenderInfo = 0;

    *pdwRenderInfo |= BEHAVIORRENDERINFO_AFTERCONTENT;
    
    // For surface from DC
    *pdwRenderInfo |= BEHAVIORRENDERINFO_SURFACE;
    *pdwRenderInfo |= BEHAVIORRENDERINFO_3DSURFACE;

    return S_OK;
}


HRESULT
CDAElementBase::Draw(HDC hdc, LONG dwLayer, LPRECT prc, IUnknown * pParams)
{
    TraceTag((tagDATimeElmBase,
              "CDAElementBase(%lx)::Draw(%#x, %#x, (%d, %d, %d, %d), %#x)",
              this,
              hdc,
              dwLayer,
              prc->left,
              prc->top,
              prc->right,
              prc->bottom,
              pParams));
    
    THR(m_view.Render(hdc, prc));

    return S_OK;
}

bool
CDAElementBase::SetImage(CRImagePtr newimg)
{
    bool ok = false;

    CRLockGrabber __gclg;

    if (!CRSwitchTo((CRBvrPtr) m_image.p,
                    (CRBvrPtr) newimg,
                    false,
                    CRContinueTimeline,
                    0.0))
    {
        TraceTag((tagError,
                  "CDAElementBase(%lx)::SetImage(): Failed to switch image  - %hr, %ls",
                  this,
                  CRGetLastError(),
                  CRGetLastErrorString()));
          
        goto done;
    }
    
    m_contentSet = true;

    if (!AddViewToPlayer())
    {
        goto done;
    }
    
    ok = true;
  done:
    return ok;
}

bool
CDAElementBase::SetSound(CRSoundPtr newsnd)
{
    bool ok = false;

    CRLockGrabber __gclg;

    if (!CRSwitchTo((CRBvrPtr) m_sound.p,
                    (CRBvrPtr) newsnd,
                    false,
                    CRContinueTimeline,
                    0.0))
    {
        TraceTag((tagError,
                  "CDAElementBase(%lx)::SetSound(): Failed to switch sound  - %hr, %ls",
                  this,
                  CRGetLastError(),
                  CRGetLastErrorString()));
          
        goto done;
    }
    
    m_contentSet = true;

    if (!AddViewToPlayer())
    {
        goto done;
    }
    
    ok = true;
  done:
    return ok;
}

bool 
CDAElementBase::SeekImage(double dblSeekTime)
{
    bool ok = false;
/*    CRLockGrabber __gclg;

    CRPtr<CRNumber> pSeekTime = CRCreateNumber(dblSeekTime);
    CRPtr<CRNumber> pNewLocalTme = CRAdd(pSeekTime, m_image.p->CRLocalTime());

    CRSubstituteTime(m_image.p.CRLocalTime(), pNewLocalTime);
*/
    ok = true;
//done:
    return ok;
}

//*******
// Below code is taken from DA
//*******


LPOLESTR
CDAElementBase::GetURLOfClientSite()
{
    CRLockGrabber __gclg;

    if (!m_clientSiteURL) {
        
        DAComPtr<IHTMLElementCollection> pElementCollection;
 
        if (FAILED(GetDocument()->get_all(&pElementCollection)))
            goto done;
        
        {
            CComVariant baseName;
            baseName.vt = VT_BSTR;
            baseName.bstrVal = SysAllocString(L"BASE");

            DAComPtr<IDispatch> pDispatch;
            if (FAILED(pElementCollection->tags(baseName, &pDispatch)))
                goto done;
            
            pElementCollection.Release();
            
            if (FAILED(pDispatch->QueryInterface(IID_IHTMLElementCollection,
                                                 (void **)&pElementCollection)))
                goto done;
        }

        {
            BSTR tempBstr = NULL;
            CComVariant index;
            index.vt = VT_I2;
            index.iVal = 0;
            DAComPtr<IDispatch> pDispatch;

            if (FAILED(pElementCollection->item(index,
                                                index,
                                                &pDispatch)) || !pDispatch)
            {
                if (FAILED(GetDocument()->get_URL(&tempBstr)))
                    goto done;
            }
            else
            {
                DAComPtr<IHTMLBaseElement> pBaseElement;
                if (FAILED(pDispatch->QueryInterface(IID_IHTMLBaseElement, (void **)&pBaseElement)))
                    goto done;
                
                if (FAILED(pBaseElement->get_href(&tempBstr)))
                    goto done;
            }

            m_clientSiteURL = CopyString(tempBstr);
            SysFreeString(tempBstr);
        }
    }

  done:
    if (m_clientSiteURL == NULL)
        m_clientSiteURL = CopyString(L"");
        
    return m_clientSiteURL;
} 


//*******
// Above code is taken from DA
//*******
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\time\src\daelmbase.h ===
/*******************************************************************************
 *
 * Copyright (c) 1998 Microsoft Corporation
 *
 * File: daelmbase.h
 *
 * Abstract:
 *
 *
 *
 *******************************************************************************/


#ifndef _DAELMBASE_H
#define _DAELMBASE_H

#include "timeelmbase.h"

#include <map>

class HTMLImage;

/////////////////////////////////////////////////////////////////////////////
// CDAElementBase

class ATL_NO_VTABLE
CDAElementBase : 
    public CTIMEElementBase,
    public ITIMEMMViewSite
{
  public:
    CDAElementBase();
    ~CDAElementBase();
        
#if _DEBUG
    const _TCHAR * GetName() { return __T("CDAElementBase"); }
#endif

    BEGIN_COM_MAP(CDAElementBase)
        COM_INTERFACE_ENTRY(ITIMEMMViewSite)
        COM_INTERFACE_ENTRY_CHAIN(CBaseBvr)
    END_COM_MAP();

    STDMETHOD(Init)(IElementBehaviorSite * pBvrSite);
    STDMETHOD(Detach)();

    //
    // IElementBehaviorRender
    //
    STDMETHOD(Draw)(HDC hdc, LONG dwLayer, LPRECT prc, IUnknown * pParams);
    STDMETHOD(GetRenderInfo)(LONG *pdwRenderInfo);

    //
    // ITIMEMMViewSite
    //
    
    STDMETHOD(Invalidate)(LPRECT prc);

    MMView * GetView() { return &m_view; }

    bool SetImage(CRImagePtr newimg);
    bool SetSound(CRSoundPtr newsnd);
    bool SeekImage(double dblTime);

    HRESULT StartRootTime(MMTimeline * tl);
    void StopRootTime(MMTimeline * tl);
    bool Update();
    LPOLESTR GetURLOfClientSite();

  protected:
    bool AddViewToPlayer();

  protected:
    MMView               m_view;
    TOKEN                m_renderMode;
    CRPtr<CRImage>       m_image;
    CRPtr<CRSound>       m_sound;
    bool                 m_contentSet;
    bool                 m_addedToView;
    LPOLESTR             m_clientSiteURL;
    std::map<long,MMBvr *> m_cookieMap;
    long m_cookieValue;
};

#endif /* _DAELMBASE_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\time\src\daelm.h ===
/*******************************************************************************
 *
 * Copyright (c) 1998 Microsoft Corporation
 *
 * File: daelm.h
 *
 * Abstract:
 *
 *
 *
 *******************************************************************************/


#ifndef _DAELM_H
#define _DAELM_H

#include "daelmbase.h"
#include "mmutil.h"

class CTIMEBodyElement;

/////////////////////////////////////////////////////////////////////////////
// CTIMEDAElement

class
ATL_NO_VTABLE
__declspec(uuid("efbad7f8-3f94-11d2-b948-00c04fa32195")) 
CTIMEDAElement :
    public CBaseBvr,
    public CComCoClass<CTIMEDAElement, &__uuidof(CTIMEDAElement)>,
    public IDispatchImpl<ITIMEDAElement, &IID_ITIMEDAElement, &LIBID_TIME>,
    public ISupportErrorInfoImpl<&IID_ITIMEDAElement>,
    public IConnectionPointContainerImpl<CTIMEDAElement>,
    public IPersistPropertyBag2,
    public IPropertyNotifySinkCP<CTIMEDAElement>,
    public ITIMEMMViewSite,
    public ITIMEDAElementRender
{
  public:
    CTIMEDAElement();
    ~CTIMEDAElement();
        
#if _DEBUG
    const _TCHAR * GetName() { return __T("CTIMEDAElement"); }
#endif

    STDMETHOD_(ULONG,AddRef)(void) = 0;
    STDMETHOD_(ULONG,Release)(void) = 0;
    STDMETHOD(QueryInterface)(REFIID iid, void ** ppvObject) = 0;


    STDMETHOD(Init)(IElementBehaviorSite * pBvrSite);
    STDMETHOD(Notify)(LONG event, VARIANT * pVar);
    STDMETHOD(Detach)();
    
    //
    // IElementBehaviorRender
    //
    STDMETHOD(Draw)(HDC hdc, LONG dwLayer, LPRECT prc, IUnknown * pParams);
    STDMETHOD(GetRenderInfo)(LONG *pdwRenderInfo);
    STDMETHOD(HitTestPoint)(LPPOINT point,
                            IUnknown *pReserved,
                            BOOL *hit);

    //
    // ITIMEMMViewSite
    //
    
    STDMETHOD(Invalidate)(LPRECT prc);

    MMView & GetView() { return m_view; }

    //
    // ITIMEDAElement
    //
    
    STDMETHOD(get_image)(VARIANT * img);
    STDMETHOD(put_image)(VARIANT img);
    
    STDMETHOD(get_sound)(VARIANT * snd);
    STDMETHOD(put_sound)(VARIANT snd);
    
    STDMETHOD(get_renderMode)(VARIANT * mode);
    STDMETHOD(put_renderMode)(VARIANT mode);
    
    STDMETHOD(addDABehavior)(VARIANT bvr,
                             LONG * cookie);
    STDMETHOD(removeDABehavior)(LONG cookie);
    
    STDMETHOD(get_statics)(IDispatch **ppStatics);

    STDMETHOD(get_renderObject)(ITIMEDAElementRender **);
    
    //
    // ITIMEDAElementRender
    //
    
    STDMETHOD(Tick)();
    STDMETHOD(Draw)(HDC dc, LPRECT prc);

    STDMETHOD(get_RenderSite)(ITIMEDAElementRenderSite ** ppSite);
    STDMETHOD(put_RenderSite)(ITIMEDAElementRenderSite * pSite);
    
    // QI Map
    
    BEGIN_COM_MAP(CTIMEDAElement)
        COM_INTERFACE_ENTRY(IDispatch)
        COM_INTERFACE_ENTRY(ITIMEDAElement)
        COM_INTERFACE_ENTRY(ITIMEDAElementRender)
        COM_INTERFACE_ENTRY(ITIMEMMViewSite)
        COM_INTERFACE_ENTRY(ISupportErrorInfo)
        COM_INTERFACE_ENTRY(IPersistPropertyBag2)
        COM_INTERFACE_ENTRY_IMPL(IConnectionPointContainer)
        COM_INTERFACE_ENTRY_CHAIN(CBaseBvr)
    END_COM_MAP();

    // Connection Point to allow IPropertyNotifySink 
    BEGIN_CONNECTION_POINT_MAP(CTIMEDAElement)
        CONNECTION_POINT_ENTRY(IID_IPropertyNotifySink)
    END_CONNECTION_POINT_MAP();

    static HRESULT WINAPI
        InternalQueryInterface(CTIMEDAElement* pThis,
                               const _ATL_INTMAP_ENTRY* pEntries,
                               REFIID iid,
                               void** ppvObject);
    // Needed by CBvrBase
    
    void * GetInstance()
    { return (ITIMEDAElement *) this ; }
    HRESULT GetTypeInfo(ITypeInfo ** ppInfo)
    { return GetTI(GetUserDefaultLCID(), ppInfo); }
    
    virtual WCHAR* GetBehaviorTypeAsURN() { return L"DIRECTANIMATION_BEHAVIOR_URN"; }

    //
    //IPersistPropertyBag2
    // 
    STDMETHOD(GetClassID)(CLSID* pclsid);
    STDMETHOD(InitNew)(void);
    STDMETHOD(IsDirty)(void)
        {return S_OK;};
    STDMETHOD(Load)(IPropertyBag2 *pPropBag,IErrorLog *pErrorLog);
    STDMETHOD(Save)(IPropertyBag2 *pPropBag, BOOL fClearDirty, BOOL fSaveAllProperties);

    enum PROPERTY_INDEX
    {
        tda_renderMode = 0,
        tme_maxTIMEDAProp,
    };

    bool AddToBody(CTIMEBodyElement & body);
    void RemoveFromBody();
  protected:
    HRESULT Error();


    HRESULT BuildPropertyNameList (CPtrAry<BSTR> *paryPropNames);
    HRESULT SetPropertyByIndex(unsigned uIndex, VARIANT *pvarProp);
    HRESULT GetPropertyByIndex(unsigned uIndex, VARIANT *pvarProp);
    HRESULT GetPropertyBagInfo(CPtrAry<BSTR> **pparyPropNames);

    bool RegisterWithBody();
    
  protected:
    static LPWSTR ms_rgwszTDAPropNames[];
    static CPtrAry<BSTR> ms_aryPropNames;
    static DWORD ms_dwNumTimeDAElems;
    
    bool                 m_fPropertiesDirty;
    TOKEN                m_renderMode;

    MMView               m_view;
    CRPtr<CRImage>       m_image;
    CRPtr<CRSound>       m_sound;
    DAComPtr<CTIMEBodyElement> m_body;
    DAComPtr<ITIMEDAElementRenderSite> m_renderSite;

  private:
	std::map<long, ITIMEMMBehavior*>    m_cookieMap;
	long                                m_cookieValue;

};

CTIMEDAElement * GetDAElementFromInterface(IUnknown * pv);

#endif /* _DAELM_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\time\src\eventmgr.h ===
///////////////////////////////////////////////////////////////
// Copyright (c) 1998 Microsoft Corporation
//
// File: EventMgr.h
//
// Abstract:
//
///////////////////////////////////////////////////////////////

#ifndef _EVENTMGR_H
#define _EVENTMGR_H

enum TIME_EVENT
{
    TE_ONBEGIN = 0,
    TE_ONPAUSE, 
    TE_ONRESUME, 
    TE_ONEND,
    TE_ONRESYNC,
    TE_ONREPEAT,
    TE_ONREVERSE,
    TE_ONMEDIACOMPLETE,
    TE_ONMEDIASLIP,
    TE_ONMEDIALOADFAILED,
    TE_ONRESET,
    TE_ONSCRIPTCOMMAND,
    TE_GENERIC,
    TE_MAX
};

class CTIMEElementBase;
class CEventSync;

class CEventMgr
    : public IDispatch
{
  public:
    CEventMgr(CTIMEElementBase & elm);
    ~CEventMgr();

    //methods
    HRESULT Init();
    HRESULT Deinit();
    HRESULT AttachEvents();
    HRESULT DetachEvents();
    
    //  Parameters needed to be packed into Variants by the caller
    HRESULT FireEvent(TIME_EVENT TimeEvent, 
                      long Count, 
                      LPWSTR szParamNames[], 
                      VARIANT varParams[]); 

    void ReadyStateChange(BSTR ReadyState);
    void PropertyChange(BSTR PropertyName);

    void MouseEvent(long x, 
                    long y, 
                    VARIANT_BOOL bMove,
                    VARIANT_BOOL bUp,
                    VARIANT_BOOL bShift, 
                    VARIANT_BOOL bAlt,
                    VARIANT_BOOL bCtrl,
                    long button);
    
    void KeyEvent(VARIANT_BOOL bLostFocus,
                  VARIANT_BOOL bUp,
                  VARIANT_BOOL bShift, 
                  VARIANT_BOOL bAlt,
                  VARIANT_BOOL bCtrl,
                  long KeyCode,
                  long RepeatCount);

    //QueryInterface 
    STDMETHODIMP QueryInterface(REFIID, void **);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

    //IDispatch
    STDMETHODIMP GetTypeInfoCount(UINT* pctinfo);
    STDMETHODIMP GetTypeInfo(/* [in] */ UINT iTInfo,
                             /* [in] */ LCID lcid,
                             /* [out] */ ITypeInfo** ppTInfo);
    STDMETHODIMP GetIDsOfNames(
        /* [in] */ REFIID riid,
        /* [size_is][in] */ LPOLESTR *rgszNames,
        /* [in] */ UINT cNames,
        /* [in] */ LCID lcid,
        /* [size_is][out] */ DISPID *rgDispId);
    STDMETHODIMP Invoke(
        /* [in] */ DISPID dispIdMember,
        /* [in] */ REFIID riid,
        /* [in] */ LCID lcid,
        /* [in] */ WORD wFlags,
        /* [out][in] */ DISPPARAMS  *pDispParams,
        /* [out] */ VARIANT  *pVarResult,
        /* [out] */ EXCEPINFO *pExcepInfo,
        /* [out] */ UINT *puArgErr);

  private:
      HRESULT ShouldFireThisEvent(bool *pfShouldFire);
      bool  IsValidEventInPausedAndEditMode(BSTR bstrEventName);

  protected:
    //Cookie for the Window ConnectionPoint
    CTIMEElementBase &                m_elm;
    CEventSync *                      m_pEventSync;
    DAComPtr<IConnectionPoint>        m_pWndConPt;
    DAComPtr<IConnectionPoint>        m_pDocConPt;
    DAComPtr<IHTMLWindow2>            m_pWindow;
    
    IHTMLElement *                    m_pElement;
    IHTMLElement2 **                  m_pBeginElement;
    IHTMLElement2 **                  m_pEndElement;
    long                              m_lBeginEventCount;
    long                              m_lEndEventCount;
    long                              m_lRepeatCount;
    BOOL                              m_bAttached;
    bool                              m_bLastEventClick;

    //Cookies
    long                              m_cookies[TE_MAX];
    DWORD                             m_dwWindowEventConPtCookie;
    DWORD                             m_dwDocumentEventConPtCookie;
    DISPID                           *m_dispDocBeginEventIDs;
    DISPID                           *m_dispDocEndEventIDs;
    
    //reference goo
    long                              m_refCount;
    
    HRESULT                           RegisterEvents();
    HRESULT                           Attach(BSTR Event, BOOL bAttach, IHTMLElement2 *pEventElement[], long Count, BOOL bAttachAll, DISPID *dispIDList,bool ScriptCommandAttach[]);
    HRESULT                           ConnectToContainerConnectionPoint();
    HRESULT                           GetEventName(BSTR bstrEvent, BSTR **pElementName, BSTR **pEventName, long Count);
    long                              GetEventCount(BSTR bstrEvent);
    bool                              MatchEvent(BSTR bstrEvent, IHTMLEventObj *pEventObj, long Count, bool ScriptCommandAttach[]);
	bool							  ValidateEvent(BSTR bstrEventName, IHTMLEventObj *pEventObj, IHTMLElement *pElement);
	bool							  RequireEventValidation();
    BYTE                              GetModifiers(VARIANT_BOOL bShift, VARIANT_BOOL bCtrl, VARIANT_BOOL bAlt);
    int                               IsEventInList(BSTR ElementName, BSTR EventName, long ListCount, BSTR Events);
    void                              BeginEndFired(bool bBeginEventMatch, bool bEndeventMatch, DISPID EventDispId);
    
        //input event parameters
    BYTE                              m_lastKeyMod;
    DWORD                             m_lastKey;
    int                               m_lastKeyCount;
    HWND                              m_hwndCurWnd;    
    long                              m_lastX;
    long                              m_lastY;
    long                              m_lastButton;
    BYTE                              m_lastMouseMod;
    double                            m_lastEventTime;
    bool                             *m_pScriptCommandBegin;
    bool                             *m_pScriptCommandEnd;
};

#endif /* _EVENTMGR_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\time\src\eventmgr.cpp ===
///////////////////////////////////////////////////////////////
// Copyright (c) 1998 Microsoft Corporation
//
// File: EventMgr.cpp
//
// Abstract:  
//
///////////////////////////////////////////////////////////////

#include "headers.h"
#include "eventmgr.h"
#include "mshtmdid.h"
#include "eventsync.h"
#include "tokens.h"
#include "mmapi.h"
#include "axadefs.h"
#include "timeelmbase.h"
#include "bodyelm.h"

// Suppress new warning about NEW without corresponding DELETE 
// We expect GCs to cleanup values.  Since this could be a useful
// warning, we should disable this on a file by file basis.
#pragma warning( disable : 4291 )  

#define ATTACH              TRUE
#define DETACH              FALSE

DeclareTag(tagEventMgr, "API", "Event Manager methods");

struct {
    TIME_EVENT event;
    wchar_t * wsz_name;
} g_EventNames[] =
{
    { TE_ONBEGIN,           L"onbegin"            },
    { TE_ONPAUSE,           L"onpause"            },
    { TE_ONRESUME,          L"onresume"           },
    { TE_ONEND,             L"onend"              },
    { TE_ONRESYNC,          L"onresync"           },
    { TE_ONREPEAT,          L"onrepeat"           },
    { TE_ONREVERSE,         L"onreverse"          },
    { TE_ONMEDIACOMPLETE,   L"onmediacomplete"    },
    { TE_ONMEDIASLIP,       L"onmediaslip"        },
    { TE_ONMEDIALOADFAILED, L"onmedialoadfailed"  },
    { TE_ONRESET,           NULL                  },
    { TE_ONSCRIPTCOMMAND,   L"onscriptcommand"    },
    { TE_GENERIC,           NULL                  },
};

OLECHAR *g_szEventName = L"TE_EventName";
OLECHAR *g_szRepeatCount = L"Iteration";

#define GENERIC_TYPE_PARAM 1

///////////////////////////////////////////////////////////////
//  Name: CEventMgr
//  Parameters:
//    CTIMEElement  & elm
//                               This parameter must be passed
//                               to the constructor so that 
//                               we can get info from elm
//
//  Abstract:
//    Stash away the element so we can get the OM when we need it
///////////////////////////////////////////////////////////////
CEventMgr::CEventMgr(CTIMEElementBase & elm)
: m_elm(elm),
  m_dwWindowEventConPtCookie(0),
  m_dwDocumentEventConPtCookie(0),
  m_pElement(NULL),
  m_pWindow(NULL),
  m_pWndConPt(NULL),
  m_pDocConPt(NULL),
  m_refCount(0),
  m_pEventSync(NULL),
  m_lastKeyMod(0),
  m_lastKey(0),
  m_lastKeyCount(0),
  m_hwndCurWnd(0),
  m_lastX(0),
  m_lastY(0),
  m_lastButton(0),
  m_lastMouseMod(0),
  m_pBeginElement(NULL),
  m_pEndElement(NULL),
  m_lBeginEventCount(0),
  m_lEndEventCount(0),
  m_bAttached(FALSE),
  m_lRepeatCount(0),
  m_dispDocBeginEventIDs(NULL),
  m_dispDocEndEventIDs(NULL), 
  m_lastEventTime(0),
  m_pScriptCommandBegin(NULL),
  m_pScriptCommandEnd(NULL),
  m_bLastEventClick(false)
{
    TraceTag((tagEventMgr,
              "EventMgr(%lx)::EventMgr(%lx)",
              this,
              &elm));

    // Zero out the cookies
    memset(m_cookies, 0, sizeof(m_cookies));

}

///////////////////////////////////////////////////////////////
//  Name: ~CEventMgr
//
//  Abstract:
//    Cleanup
///////////////////////////////////////////////////////////////
CEventMgr::~CEventMgr()
{
    TraceTag((tagEventMgr,
              "EventMgr(%lx)::~EventMgr()",
              this));
}


///////////////////////////////////////////////////////////////
//  Name: Fire_Event
//  Parameters:
//    TIME_EVENT TimeEvent     An enumeration value to indicate 
//                             which event should be fired.
//    long Count               The count of parameters to use
//    LPWSTR szParamNames[]    The names of the parameters to create.
//    VARIANT varParams[]      An array of VARIANTS that can
//                             be used to indicate the parameters
//                             to pass to an event.  
//
//  Abstract:
//
///////////////////////////////////////////////////////////////
HRESULT CEventMgr::FireEvent(TIME_EVENT TimeEvent, 
                             long lCount, 
                             LPWSTR szParamNames[], 
                             VARIANT varParams[])
{
    HRESULT hr = S_OK;
    DAComPtr <IHTMLEventObj> pEventObj;
    DAComPtr <IHTMLEventObj2> pEventObj2;
    IElementBehaviorSiteOM * pBvrSiteOM = m_elm.GetBvrSiteOM();
    WCHAR *pwszGenericName = NULL;
    long lGenericCookie = 0;

    Assert(TimeEvent < ARRAY_SIZE(g_EventNames));
    
    // This is not a fireable event - skip
    if ((g_EventNames[TimeEvent].wsz_name == NULL) && (TE_GENERIC != TimeEvent))
    {
        goto done;
    }

    // It better be valid
    Assert (pBvrSiteOM);
    
    if (!pBvrSiteOM) //this is possible in a multi-refresh condition.
    {
        goto done;
    }

    // if this is a generic event, see if we have already registered it.
    // if so, use that cookie.  Otherwise, register this.
    if (TE_GENERIC == TimeEvent)
    {
        if (varParams[GENERIC_TYPE_PARAM].bstrVal == NULL)
        {
            hr = E_INVALIDARG;
            goto done;
        }

        // build string name - "on" + scType + NULL
        pwszGenericName = NEW WCHAR[lstrlenW(varParams[GENERIC_TYPE_PARAM].bstrVal)+(2*sizeof(WCHAR))+sizeof(WCHAR)];
        if (pwszGenericName == NULL)
        {
            TraceTag((tagError, "CEventMgr::FireEvent - unable to alloc mem for string"));
            hr = E_OUTOFMEMORY;
            goto done;
        }
        lstrcpyW(pwszGenericName, L"on");
        lstrcatW(pwszGenericName, varParams[GENERIC_TYPE_PARAM].bstrVal);

        hr = THR(pBvrSiteOM->GetEventCookie(pwszGenericName, &lGenericCookie));
        if (FAILED(hr))
        {
            hr = THR(pBvrSiteOM->RegisterEvent(pwszGenericName, 0, &lGenericCookie));
            if (FAILED(hr))
            {
                goto done;
            }
        }
    }
    
    hr = THR(pBvrSiteOM->CreateEventObject(&pEventObj));
    if (FAILED(hr))
    {
        goto done;
    }

    hr = THR(pEventObj->QueryInterface(IID_IHTMLEventObj2, (void**)&pEventObj2));
    if (FAILED(hr))
    {
        goto done;
    }
	
	//hack to work around event naming problem
    //this sets an attribute so that we can sync to it
    VARIANT bstrTemp;
    VariantInit(&bstrTemp);
    bstrTemp.vt = VT_BSTR;
    if (TE_GENERIC != TimeEvent)
    {
        bstrTemp.bstrVal = SysAllocString(g_EventNames[TimeEvent].wsz_name);
    }
    else
    {
        bstrTemp.bstrVal = SysAllocString(pwszGenericName);
    }

    if (bstrTemp.bstrVal == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto done;
    }

    IGNORE_HR(pEventObj2->setAttribute(g_szEventName, bstrTemp));
    VariantClear(&bstrTemp);
    ////////////////////////////////////////////////////

    // unload param list into the setAttribute
    if (lCount > 0)
    {
        for (long i = 0; i < lCount; i++)
        {
            hr = THR(pEventObj2->setAttribute(szParamNames[i], varParams[i]));
            if (FAILED(hr))
            {
                goto done;
            }
        }
    } 

    //if this is a TE_REPEAT event, add support for current repeat count
    if (TimeEvent == TE_ONREPEAT)
    {
        VARIANT vRepCount;
        VariantInit (&vRepCount);
        vRepCount.vt = VT_I4;
        m_lRepeatCount++;
        vRepCount.lVal = m_lRepeatCount;       

        IGNORE_HR(pEventObj2->setAttribute(g_szRepeatCount, vRepCount));
    }
    else if (TimeEvent == TE_ONBEGIN || TimeEvent == TE_ONRESET) //reset the repeat count on begin
    {
        m_lRepeatCount = 0;
    }

    {
        //set the event object type
        BSTR bstrType = NULL;
        
        if (TE_GENERIC != TimeEvent)
        {
            // remove the "on" from the event name
            bstrType = SysAllocString(g_EventNames[TimeEvent].wsz_name + 2);
        }
        else
        {
            Assert(varParams[GENERIC_TYPE_PARAM].vt == VT_BSTR);
            bstrType = SysAllocString(varParams[GENERIC_TYPE_PARAM].bstrVal);
        }

        if (bstrType != NULL)
        {
            IGNORE_HR(pEventObj2->put_type(bstrType));
            SysFreeString(bstrType);
        }
        else 
        {
            // we were unable to set the type, bail!
            hr = E_OUTOFMEMORY;
            goto done;
        }
    }

    {
        long lCookie = 0;

        if (TE_GENERIC != TimeEvent)
        {
            Assert(TimeEvent < ARRAY_SIZE(m_cookies));
            lCookie = m_cookies[TimeEvent];
        }
        else
        {
            lCookie = lGenericCookie;
        }

        hr = THR(pBvrSiteOM->FireEvent(lCookie, pEventObj));
        if (FAILED(hr))
        {
            goto done;
        }
    }

    // if this is a ScriptCommand event, call FireEvent again
    // with the generic event.
    if (TimeEvent == TE_ONSCRIPTCOMMAND)
    {
        hr = FireEvent(TE_GENERIC, lCount, szParamNames, varParams);
        if (FAILED(hr))
            goto done;
    }

    hr = S_OK;

  done:
    delete pwszGenericName; 
    pwszGenericName = NULL;
    return hr;
}
   
///////////////////////////////////////////////////////////////
//  Name:  Init
//  Parameters:  None
//
//  Abstract:
//    Initializes the object
///////////////////////////////////////////////////////////////
HRESULT CEventMgr::Init()
{
    HRESULT hr;
    DAComPtr <IDispatch> pDisp;
    DAComPtr <IHTMLDocument2> pDoc;

    m_pElement = m_elm.GetElement();
    m_pElement->AddRef();

    m_pEventSync = NEW CEventSync(m_elm, this);
    if (NULL == m_pEventSync)
    {
        hr = E_OUTOFMEMORY;
        goto done;
    }

    m_pEventSync->Init();

    hr = THR(RegisterEvents());

    if (FAILED(hr))
    {
        goto done;
    }
    
    hr = THR(ConnectToContainerConnectionPoint());

    if (FAILED(hr))
    {
        goto done;
    }

    //get a pointer to the window
    hr = THR(m_pElement->get_document(&pDisp));
    if (FAILED(hr))
    {
        goto done;
    }

    hr = THR(pDisp->QueryInterface(IID_IHTMLDocument2, (void **)&pDoc));
    if (FAILED(hr))
    {
        goto done;
    }

    hr = THR(pDoc->get_parentWindow(&m_pWindow));
    if (FAILED(hr))
    {
        goto done;
    }

    hr = S_OK;

  done:
    return hr;
}

///////////////////////////////////////////////////////////////
//  Name:  Deinit
//  Parameters:  None
//
//  Abstract:
//    Cleans up the object
///////////////////////////////////////////////////////////////
HRESULT CEventMgr::Deinit()
{
    THR(DetachEvents());

    if (m_dwWindowEventConPtCookie != 0 && m_pWndConPt)
    {
        m_pWndConPt->Unadvise (m_dwWindowEventConPtCookie);
    }

    if (m_dwDocumentEventConPtCookie != 0 && m_pDocConPt)
    {
        m_pDocConPt->Unadvise (m_dwDocumentEventConPtCookie);
    }

    if (m_pScriptCommandBegin)
    {
        delete [] m_pScriptCommandBegin;
    }
    if (m_pScriptCommandEnd)
    {
        delete [] m_pScriptCommandEnd;
    }
    if (m_pEventSync)
    {
        m_pEventSync->Deinit();
        delete m_pEventSync;
        m_pEventSync = NULL;
    }

    m_dwWindowEventConPtCookie = 0;
    m_dwDocumentEventConPtCookie = 0;

    // Zero out the cookies
    memset(m_cookies, 0, sizeof(m_cookies));
    
    if (m_pElement)
    {
        m_pElement->Release();
        m_pElement = NULL;
    }

    //cleanup memory
    if (m_pBeginElement)
    {
        // Cycle through the elements and release the interfaces
        // NOTE: this should be cleaned up in DetachEvents.
        for (int i = 0; i < m_lBeginEventCount; i++)
        {
            if (m_pBeginElement[i] != NULL)
                m_pBeginElement[i]->Release();
        }

        delete [] m_pBeginElement;
        m_pBeginElement = NULL;

        m_lBeginEventCount = 0;
    }
    if (m_pEndElement)
    {
        // Cycle through the elements and release the interfaces
        // NOTE: this should be cleaned up in DetachEvents.
        for (int i = 0; i < m_lEndEventCount; i++)
        {
            if (m_pEndElement[i] != NULL)
                m_pEndElement[i]->Release();
        }
        
        delete [] m_pEndElement;
        m_pEndElement = NULL;

        m_lEndEventCount = 0;
    }

    if (m_dispDocBeginEventIDs)
    {
        delete [] m_dispDocBeginEventIDs;
    }
    if (m_dispDocEndEventIDs)
    {
        delete [] m_dispDocEndEventIDs;
    }

    // Release all references to trident.
    m_pDocConPt.Release();
    m_pWndConPt.Release();
    m_pWindow.Release();

    return S_OK;
}

///////////////////////////////////////////////////////////////
//  Name:  RegisterEvents
//  Parameters:  None
//
//  Abstract:
//    Registers the events that will be used by this class.
///////////////////////////////////////////////////////////////
HRESULT CEventMgr::RegisterEvents()
{
    HRESULT hr = S_OK;

    IElementBehaviorSiteOM * pBvrSiteOM = m_elm.GetBvrSiteOM();

    // It better be valid
    Assert (pBvrSiteOM);
    
    for (int i = 0; i < ARRAY_SIZE(g_EventNames); i++)
    {
        if (g_EventNames[i].wsz_name != NULL)
        {
            Assert(g_EventNames[i].event < ARRAY_SIZE(m_cookies));
            
            hr = THR(pBvrSiteOM->RegisterEvent(g_EventNames[i].wsz_name,
                                               0,
                                               (long *) &m_cookies[g_EventNames[i].event]));
            
            if (FAILED(hr))
            {
                goto done;
            }
        }
    }

  done:
    return hr;
}


///////////////////////////////////////////////////////////////
//  Name: AttachEvents
// 
//  Abstract:
//    Gets and caches the begin event and end events for this
//    behavior.  It then calls attach to hook the events
//    specified in BeginEvent and EndEvent.
///////////////////////////////////////////////////////////////
HRESULT CEventMgr::AttachEvents()
{
    //Determine the current Ready State of the document.
    DAComPtr <IHTMLElement2> pEle2;
    VARIANT vReadyState;
    HRESULT hr = S_OK;

    VariantInit(&vReadyState);
    Assert (m_pElement);
    hr = THR(m_pElement->QueryInterface(IID_IHTMLElement2, (void**)&pEle2));
    if (SUCCEEDED(hr))
    {
        hr = THR(pEle2->get_readyState(&vReadyState));
        if (SUCCEEDED(hr))
        {
            TOKEN CurReadyState = StringToToken(vReadyState.bstrVal);
            if (CurReadyState == READYSTATE_COMPLETE_TOKEN)
            {                         
                //if the ready state is "complete" then attach to the events.
                m_bAttached = TRUE;
            } 
            else
            {
                goto done;
            }
        }
    }

    if (m_elm.GetBeginEvent())
    {
        BSTR bstr = SysAllocString(m_elm.GetBeginEvent());

        if (bstr)
        {
            m_lBeginEventCount = GetEventCount(bstr);
            m_dispDocBeginEventIDs = NEW DISPID [m_lBeginEventCount];
            m_pBeginElement = NEW IHTMLElement2* [m_lBeginEventCount];
            if (m_pScriptCommandBegin)
            {
                delete [] m_pScriptCommandBegin;
            }
            m_pScriptCommandBegin = NEW bool [m_lBeginEventCount];

            if (m_pBeginElement == NULL || m_pScriptCommandBegin == NULL)
            {
                m_lBeginEventCount = 0;
                hr = E_FAIL;
                goto done;
            }
            ZeroMemory(m_pBeginElement, sizeof(IHTMLElement2 *) * m_lBeginEventCount);

            hr = THR(Attach(bstr, ATTACH, m_pBeginElement, m_lBeginEventCount, TRUE, m_dispDocBeginEventIDs, m_pScriptCommandBegin));
        }

        SysFreeString(bstr);
    }
    
    if (m_elm.GetEndEvent())
    {
        BSTR bstr = SysAllocString(m_elm.GetEndEvent());

        if (bstr)
        {
            m_lEndEventCount = GetEventCount(bstr);
            m_dispDocEndEventIDs = NEW DISPID [m_lEndEventCount];
            m_pEndElement = NEW IHTMLElement2* [m_lEndEventCount];
            if (m_pScriptCommandEnd)
            {
                delete [] m_pScriptCommandEnd;
            }
            m_pScriptCommandEnd = NEW bool [m_lEndEventCount];

            if (m_pEndElement == NULL || m_pScriptCommandEnd == NULL)
            {
                m_lEndEventCount = 0;
                hr = E_FAIL;
                goto done;
            }
            ZeroMemory(m_pEndElement, sizeof(IHTMLElement2 *) * m_lEndEventCount);

            hr = THR(Attach(bstr, ATTACH, m_pEndElement, m_lEndEventCount, FALSE, m_dispDocEndEventIDs, m_pScriptCommandEnd));
        }

        SysFreeString(bstr);
    }
  done:
    VariantClear(&vReadyState);
    return hr;
}

///////////////////////////////////////////////////////////////
//  Name: Attach
// 
//  Parameters:
//    BSTR Event        The element and event to sink to.  This
//                      parameter is in the form "Element.Event"
//                      where element is "this" if an event from
//                      the current element is to be attached to.
//    BOOL bAttach      True to indicate Attach to this event, and
//                      false to indicate Detach from this event.
//
//    BOOL bAttachAll   True indicates that all events in the list 
//                      should be attached to.  False indicates that
//                      only those events that differ from the beginEvent
//                      list should be attached to.
//
//  Abstract:
//    This is a generic routine that allows both attaching to
//    and detaching from Trident events.  This function decodes
//    the event name to find the correct element
///////////////////////////////////////////////////////////////
HRESULT CEventMgr::Attach(BSTR Event, 
                          BOOL bAttach, 
                          IHTMLElement2 *pEventElement[], 
                          long Count, 
                          BOOL bAttachAll,
                          DISPID *dispIDList,
                          bool ScriptCommandAttach[])
{
    VARIANT_BOOL bSuccess = FALSE;
    HRESULT hr = S_OK;
    BSTR *EventName = NULL;
    BSTR *ElementName = NULL;
    int i = 0;
    BSTR EventList = SysAllocString(m_elm.GetBeginEvent());

    hr = THR(GetEventName(Event, &ElementName, &EventName, Count));
    if (FAILED(hr))
    {
        goto done;
    }

    for (i = 0; i < Count; i++)
    {
        dispIDList[i] = -1; //invalid dispid
        int nInList = IsEventInList(ElementName[i], EventName[i], m_lBeginEventCount, EventList);
        if (bAttachAll || (nInList == -1))
        {
            if (bAttach == ATTACH)
            {
                DAComPtr <IHTMLElement2> pSrcEle;
                DAComPtr <IHTMLDocument2> pDoc2;
                DAComPtr <IHTMLElementCollection> pEleCol;
                DAComPtr <IDispatch> pSrcDisp;
                DAComPtr <IDispatch> pDocDisp;
                DAComPtr <IDispatchEx> pDispEx;

                //get the document
                hr = THR(m_pElement->get_document(&pDocDisp));
                if (FAILED(hr))
                {
                    continue;
                }

                hr = THR(pDocDisp->QueryInterface(IID_IHTMLDocument2, (void**)&pDoc2));
                if (FAILED(hr))
                {
                    continue;
                }

                if (StrCmpIW(ElementName[i], L"document") == 0)
                {

                    DISPID dispid;
                    DAComPtr <ITypeLib> pTypeLib;
                    DAComPtr <ITypeInfo> pTypeInfo;
                    DAComPtr <ITypeInfo> pTypeInfoEvents;
                    DAComPtr <IDispatch> pDispatch;
                    unsigned int index = 0;

                    //This code loads the typelib for the IHTMLDocument2 interface,
                    //and gets the ID for the event from the type info for the
                    //HTMLDocumentEvents dispinterface.
                    hr = THR(pDoc2->QueryInterface(IID_IDispatch, (void**)&pDispatch));
                    if (FAILED(hr))
                    {
                        continue;
                    }

                    hr = THR(pDispatch->GetTypeInfo(0, LCID_SCRIPTING, &pTypeInfo));
                    if (FAILED(hr))
                    {
                        continue;
                    }

                    hr = THR(pTypeInfo->GetContainingTypeLib(&pTypeLib, &index));
                    if (FAILED(hr))
                    {
                        continue;
                    }

                    hr = THR(pTypeLib->GetTypeInfoOfGuid(DIID_HTMLDocumentEvents, &pTypeInfoEvents));
                    if (FAILED(hr))
                    {
                        continue;
                    }

                    hr = THR(pTypeInfoEvents->GetIDsOfNames(&EventName[i], 1, &dispid));
                    if (FAILED(hr))
                    {
                        continue;
                    }

                    dispIDList[i] = dispid; 
                    continue; 
                }

                //get all elements in the document
                hr = THR(pDoc2->get_all(&pEleCol));
                if (FAILED(hr))
                {
                    continue;
                }

                //find the element with the correct name
                VARIANT vName;
                VARIANT vIndex;

                VariantInit(&vName);
                vName.vt = VT_BSTR;
                vName.bstrVal = SysAllocString(ElementName[i]);

                VariantInit(&vIndex);
                vIndex.vt = VT_I2;
                vIndex.iVal = 0;

                hr = THR(pEleCol->item(vName, vIndex, &pSrcDisp));
                if (FAILED(hr))
                {
                    VariantClear(&vName);
                    VariantClear(&vIndex);
                    continue;
                }
                VariantClear(&vName);
                VariantClear(&vIndex);

                if (!pSrcDisp) //will be NULL if the vName is invalid element.
                {
                    pEventElement[i] = NULL;
                    continue;
                }

                hr = THR(pSrcDisp->QueryInterface(IID_IHTMLElement2, (void**)&pSrcEle));
                if (FAILED(hr))
                {
                    continue;
                }

                //cache the IHTMLElement2 pointer for use on detach
                pEventElement[i] = pSrcEle;
                pEventElement[i]->AddRef();

                hr = THR(pSrcDisp->QueryInterface(IID_IDispatchEx, (void**)&pDispEx));
                if (SUCCEEDED(hr))
                {
                    //determine if this is a valid event
                    DISPID temp;

                    hr = THR(pDispEx->GetDispID(EventName[i], fdexNameCaseSensitive, &temp));
                    if (SUCCEEDED(hr))
                    {
                        ScriptCommandAttach[i] = false;
                        hr = THR(pSrcEle->attachEvent(EventName[i], (IDispatch *)this, &bSuccess));
                    }
                    else //this is not currently a valid event, but it could be a custom event.
                    {    //so TIME needs to attach to the onScriptCommand event to be able to catch custom events.
                        ScriptCommandAttach[i] = true;
                        BSTR ScriptEvent = SysAllocString(g_EventNames[TE_ONSCRIPTCOMMAND].wsz_name);
                        IGNORE_HR(pSrcEle->attachEvent(ScriptEvent, (IDispatch *)this, &bSuccess));
                        SysFreeString (ScriptEvent);
                    }
                }
            }
            else
            {
                if (pEventElement[i])
                {
                    DAComPtr <IDispatchEx> pDispEx;

                    hr = THR(pEventElement[i]->QueryInterface(IID_IDispatchEx, (void**)&pDispEx));
                    if (SUCCEEDED(hr))
                    {
                        //determine if this is a valid event
                        DISPID temp;
                        if (ScriptCommandAttach[i] == true)
                        {
                            BSTR ScriptEvent = SysAllocString(g_EventNames[TE_ONSCRIPTCOMMAND].wsz_name);
                            IGNORE_HR(pEventElement[i]->detachEvent(ScriptEvent, (IDispatch *)this));
                            SysFreeString(ScriptEvent);
                        }
                        else
                        {
                            hr = THR(pDispEx->GetDispID(EventName[i], fdexNameCaseSensitive, &temp));
                            if (SUCCEEDED(hr))
                            {
                                hr = THR(pEventElement[i]->detachEvent(EventName[i], (IDispatch *)this));
                            }
                        }
                    }
                    pEventElement[i]->Release();
                    pEventElement[i] = NULL;
                }
            }
        }
        else //this is an EndEvent with the event already in the beginEvent list
        {
            if (m_dispDocEndEventIDs && m_dispDocBeginEventIDs)
            {
                m_dispDocEndEventIDs[i] = m_dispDocBeginEventIDs[nInList];
            }
        }
    }
  done:

    if (EventList)
    {
        SysFreeString(EventList);
    }
    if (EventName)
    {
        for (i = 0; i < Count; i++)
        {
            SysFreeString(EventName[i]);
            SysFreeString(ElementName[i]);
        }
        delete [] EventName;
        delete [] ElementName;
    }
    return hr;
}

///////////////////////////////////////////////////////////////
//  Name: DetachEvents
// 
//  Abstract:
//    Simply checks the cached begin and end event strings and
//    calls Attach with the detach parameter to release the
//    events.
///////////////////////////////////////////////////////////////
HRESULT CEventMgr::DetachEvents()
{
    HRESULT hr = S_OK;

    
    //if this is called before to object is loaded ignore the call
    if (!m_bAttached)
    {
        goto done;
    }

    if (m_elm.GetBeginEvent())
    {
        BSTR bstr = SysAllocString(m_elm.GetBeginEvent());


        if (bstr)
        {
            hr = THR(Attach(bstr, DETACH, m_pBeginElement, m_lBeginEventCount, TRUE, m_dispDocBeginEventIDs, m_pScriptCommandBegin));
        }

        SysFreeString(bstr);
    }

    if (m_pBeginElement)
    {
        delete [] m_pBeginElement;
        m_pBeginElement = NULL;
        m_lBeginEventCount = 0;
    }
    
    if (m_elm.GetEndEvent())
    {
        BSTR bstr = SysAllocString(m_elm.GetEndEvent());

        if (bstr)
        {
            hr = THR(Attach(bstr, DETACH, m_pEndElement, m_lEndEventCount, FALSE, m_dispDocEndEventIDs, m_pScriptCommandEnd));
        }

        SysFreeString(bstr);
    }

    if (m_pEndElement)
    {
        delete [] m_pEndElement;
        m_pEndElement = NULL;
        m_lEndEventCount = 0;
    }
  done:
    return hr;
}


///////////////////////////////////////////////////////////////
//  Name: ConnectToContainerConnectionPoint
// 
//  Abstract:
//    Finds a connection point on the HTMLDocument interface
//    and passes this as an event handler.
///////////////////////////////////////////////////////////////
HRESULT CEventMgr::ConnectToContainerConnectionPoint()
{
    // Get a connection point to the container
    DAComPtr<IConnectionPointContainer> pWndCPC;
    DAComPtr<IConnectionPointContainer> pDocCPC; 
    DAComPtr<IHTMLDocument> pDoc; 
    DAComPtr<IDispatch> pDocDispatch;
    DAComPtr<IDispatch> pScriptDispatch;

    HRESULT hr;

    hr = THR(m_pElement->get_document(&pDocDispatch));
    if (FAILED(hr))
    {
        hr = E_FAIL;
        goto done;
    }

    //get the document and cache it.
    hr = THR(pDocDispatch->QueryInterface(IID_IHTMLDocument, (void**)&pDoc));
    if (FAILED(hr))
    {
        hr = E_FAIL;
        goto done;
    }

    //hook the documents events
    hr = THR(pDoc->QueryInterface(IID_IConnectionPointContainer, (void**)&pDocCPC));
    if (FAILED(hr))
    {
        hr = E_FAIL;
        goto done;
    }

    hr = THR(pDocCPC->FindConnectionPoint( DIID_HTMLDocumentEvents, &m_pDocConPt ));
    if (FAILED(hr))
    {
        hr = E_FAIL;
        goto done;
    }

    
    hr = THR(m_pDocConPt->Advise((IUnknown *)this, &m_dwDocumentEventConPtCookie));
    if (FAILED(hr))
    {
        hr = E_FAIL;
        goto done;
    }

    //hook the windows events
    hr = THR(pDoc->get_Script (&pScriptDispatch));
    if (FAILED(hr))
    {
        hr = E_FAIL;
        goto done;
    }

    hr = THR(pScriptDispatch->QueryInterface(IID_IConnectionPointContainer, (void**)&pWndCPC));
    if (FAILED(hr))
    {
        hr = E_FAIL;
        goto done;
    } 

    hr = THR(pWndCPC->FindConnectionPoint( DIID_HTMLWindowEvents, &m_pWndConPt ));
    if (FAILED(hr))
    {
        hr = E_FAIL;
        goto done;
    }

    hr = THR(m_pWndConPt->Advise((IUnknown *)this, &m_dwWindowEventConPtCookie));
    if (FAILED(hr))
    {
        hr = E_FAIL;
        goto done;
    }

    hr = S_OK;
  done:
    return hr;  
}


///////////////////////////////////////////////////////////////
//  Name: QueryInterface
// 
//  Abstract:
//    This QI only handles the IDispatch for HTMLWindowEvents
//    and returns this as the interface.
///////////////////////////////////////////////////////////////
STDMETHODIMP CEventMgr::QueryInterface( REFIID riid, void **ppv )
{
    if (NULL == ppv)
        return E_POINTER;

    *ppv = NULL;

    if ( InlineIsEqualGUID(riid, IID_IDispatch) || InlineIsEqualGUID(riid, DIID_HTMLWindowEvents))
    {
        *ppv = this;
    }
        
    if ( NULL != *ppv )
    {
        ((LPUNKNOWN)*ppv)->AddRef();
        return NOERROR;
    }
    return E_NOINTERFACE;
}

///////////////////////////////////////////////////////////////
//  Name: AddRef
// 
//  Abstract:
//    Stubbed to allow this object to inherit for IDispatch  
///////////////////////////////////////////////////////////////
STDMETHODIMP_(ULONG) CEventMgr::AddRef(void)
{
        return m_elm.InternalAddRef();
}

///////////////////////////////////////////////////////////////
//  Name: Release
// 
//  Abstract:
//    Stubbed to allow this object to inherit for IDispatch
///////////////////////////////////////////////////////////////
STDMETHODIMP_(ULONG) CEventMgr::Release(void)
{
        return m_elm.InternalRelease();
}



///////////////////////////////////////////////////////////////
//  Name: GetTypeInfoCount
// 
//  Abstract:
//    Stubbed to allow this object to inherit for IDispatch
///////////////////////////////////////////////////////////////
STDMETHODIMP CEventMgr::GetTypeInfoCount(UINT* /*pctinfo*/)
{
    return E_NOTIMPL;
}

///////////////////////////////////////////////////////////////
//  Name: GetTypeInfo
// 
//  Abstract:
//    Stubbed to allow this object to inherit for IDispatch
///////////////////////////////////////////////////////////////
STDMETHODIMP CEventMgr::GetTypeInfo(/* [in] */ UINT /*iTInfo*/,
                                   /* [in] */ LCID /*lcid*/,
                                   /* [out] */ ITypeInfo** /*ppTInfo*/)
{
    return E_NOTIMPL;
}

///////////////////////////////////////////////////////////////
//  Name: GetIDsOfNames
// 
//  Abstract:
//    Stubbed to allow this object to inherit for IDispatch
///////////////////////////////////////////////////////////////
STDMETHODIMP CEventMgr::GetIDsOfNames(
    /* [in] */ REFIID /*riid*/,
    /* [size_is][in] */ LPOLESTR* /*rgszNames*/,
    /* [in] */ UINT /*cNames*/,
    /* [in] */ LCID /*lcid*/,
    /* [size_is][out] */ DISPID* /*rgDispId*/)
{
    return E_NOTIMPL;
}

///////////////////////////////////////////////////////////////
//  Name: Invoke
// 
//  Abstract:
//    This switches on the dispid looking for dispid's of events
//    that it should handle.  Note, this is called for all events
//    fired from the window, only the selected events are handled.
///////////////////////////////////////////////////////////////
STDMETHODIMP CEventMgr::Invoke(
    /* [in] */ DISPID dispIdMember,
    /* [in] */ REFIID /*riid*/,
    /* [in] */ LCID /*lcid*/,
    /* [in] */ WORD /*wFlags*/,
    /* [out][in] */ DISPPARAMS* pDispParams,
    /* [out] */ VARIANT* pVarResult,
    /* [out] */ EXCEPINFO* /*pExcepInfo*/,
    /* [out] */ UINT* puArgErr)
{
    // Listen for the two events we're interested in, and call back if necessary
    HRESULT hr = S_OK;
    bool bBeginEventMatch = false;
    bool bEndEventMatch = false;
    int i = 0;

    for (i = 0; i < m_lBeginEventCount; i++)
    {
        if (m_dispDocBeginEventIDs[i] == dispIdMember)
        {
            bool fShouldFire;
            hr = ShouldFireThisEvent(&fShouldFire);
            if (FAILED(hr))
            {
                goto done;
            }

            if (!fShouldFire)
            {
                continue;
            }
            
            bBeginEventMatch = true;
        }
    }
    
    for (i = 0; i < m_lEndEventCount; i++)
    {
        if (m_dispDocEndEventIDs[i] == dispIdMember)
        {
            bool fShouldFire;
            hr = ShouldFireThisEvent(&fShouldFire);
            if (FAILED(hr))
            {
                goto done;
            }
            
            if (!fShouldFire)
            {
                continue;
            }

            bEndEventMatch = true;                        
        }
    }       


    if (bBeginEventMatch || bEndEventMatch)
    {
        if (dispIdMember == DISPID_HTMLDOCUMENTEVENTS_ONMOUSEOUT)
        {
            if (RequireEventValidation())
            {
                // In the case of a mouse out from the document, the toElement should be NULL
                // If is not, set matches to false
                DAComPtr <IHTMLEventObj> pEventObj;
                hr = THR(m_pWindow->get_event(&pEventObj));
                if (SUCCEEDED(hr))
                {
                    DAComPtr <IHTMLElement> pToElement;
                    hr = THR(pEventObj->get_toElement(&pToElement));
                    if (SUCCEEDED(hr) && pToElement)
                    {
                            bBeginEventMatch = bEndEventMatch = false;
                    }
                }
            }
        }
        else if (dispIdMember == DISPID_HTMLDOCUMENTEVENTS_ONMOUSEOVER)
        {
            if (RequireEventValidation())
            {
                // In the case of a mouse over from the document, the fromElement should be NULL
                // If it is not, set matches to false
                DAComPtr <IHTMLEventObj> pEventObj;
                hr = THR(m_pWindow->get_event(&pEventObj));
                if (SUCCEEDED(hr))
                {
                    DAComPtr <IHTMLElement> pFromElement;
                    hr = THR(pEventObj->get_fromElement(&pFromElement));
                    if (SUCCEEDED(hr) && pFromElement)
                    {
                        bBeginEventMatch = bEndEventMatch = false;
                    }
                }
            }
        }
    }

    switch (dispIdMember)
    {
        case 0: //this is the case for events that have been hooked using attachEvent
        {
            DAComPtr <IHTMLEventObj> pEventObj;
            BSTR bstrEventName;

            if ((NULL != pDispParams) && (NULL != pDispParams->rgvarg) &&
                (V_VT(&(pDispParams->rgvarg[0])) == VT_DISPATCH))
            {
                hr = THR((pDispParams->rgvarg[0].pdispVal)->QueryInterface(IID_IHTMLEventObj, (void**)&pEventObj));
                if (FAILED(hr))
                {
                    goto done;
                }
            }
            else
            {
                Assert(0 && "Unexpected dispparam values passed to CEventMgr::Invoke(dispid = 0)");
                hr = E_UNEXPECTED;
                goto done;
            }
            
            hr = THR(pEventObj->get_type(&bstrEventName));
            //
            // #40194 -- in paused state don't allow mouse or click events to fire
            //
            if (m_elm.GetBody() != NULL)
            {
                if (m_elm.GetBody()->IsPaused() )
                {
                    if (!IsValidEventInPausedAndEditMode(bstrEventName))
                    {
                        break;
                    }
                }
            }

            m_bLastEventClick = false;
            if (SUCCEEDED(hr))
            {
                if (StrCmpIW(bstrEventName, L"click") == 0)
                {
                    m_bLastEventClick = true;       
                }
            }
            SysFreeString(bstrEventName);

            //determine if this is the beginEvent
            if (m_elm.GetBeginEvent())
            {
                BSTR bstr = SysAllocString(m_elm.GetBeginEvent());
                
                if (bstr)
                {
                    bBeginEventMatch = MatchEvent(bstr, pEventObj, m_lBeginEventCount, m_pScriptCommandBegin);
                }
                
                SysFreeString(bstr);
            }

            //determine if this is the endEvent
            if (m_elm.GetEndEvent())
            {
                BSTR bstr = SysAllocString(m_elm.GetEndEvent());
                
                if (bstr)
                {
                    bEndEventMatch = MatchEvent(bstr, pEventObj, m_lEndEventCount, m_pScriptCommandEnd);
                }
                
                SysFreeString(bstr);
            }        
            break;
        }
        
        case DISPID_EVPROP_ONPROPERTYCHANGE:
        case DISPID_EVMETH_ONPROPERTYCHANGE:
            break;

        case DISPID_EVPROP_ONMOUSEMOVE:
        case DISPID_EVMETH_ONMOUSEMOVE:
            if (m_hwndCurWnd != 0 && m_pWindow)
            {
                DAComPtr <IHTMLEventObj> pEventObj;
                long x, y, button;
                VARIANT_BOOL bMove, bUp, bShift, bAlt, bCtrl;

                hr = THR(m_pWindow->get_event(&pEventObj));
                if (FAILED (hr))
                {
                    break;
                }
                
                bMove = TRUE;
                bUp = FALSE;
                hr = THR(pEventObj->get_x(&x));
                hr = THR(pEventObj->get_y(&y));
                hr = THR(pEventObj->get_shiftKey(&bShift));
                hr = THR(pEventObj->get_altKey(&bAlt));
                hr = THR(pEventObj->get_ctrlKey(&bCtrl));
                hr = THR(pEventObj->get_button(&button));
                MouseEvent(x, y, bMove, bUp, bShift, bAlt, bCtrl, button);
                
                VariantInit(pVarResult);
                pVarResult->vt = VT_BOOL;
                pVarResult->boolVal = VARIANT_TRUE;
            }
            break;

        case DISPID_EVPROP_ONMOUSEUP:
        case DISPID_EVMETH_ONMOUSEUP:
            if (m_hwndCurWnd != 0 && m_pWindow)
            {
                DAComPtr <IHTMLEventObj> pEventObj;
                long x, y, button;
                VARIANT_BOOL bMove, bUp, bShift, bAlt, bCtrl;

                hr = THR(m_pWindow->get_event(&pEventObj));
                if (FAILED (hr))
                {
                    break;
                }
                
                bMove = FALSE;
                bUp = TRUE;
                hr = THR(pEventObj->get_x(&x));
                hr = THR(pEventObj->get_y(&y));
                hr = THR(pEventObj->get_shiftKey(&bShift));
                hr = THR(pEventObj->get_altKey(&bAlt));
                hr = THR(pEventObj->get_ctrlKey(&bCtrl));
                hr = THR(pEventObj->get_button(&button));
                MouseEvent(x, y, bMove, bUp, bShift, bAlt, bCtrl, button);
                
                VariantInit(pVarResult);
                pVarResult->vt = VT_BOOL;
                pVarResult->boolVal = VARIANT_TRUE;
            }
            break;

 
        case DISPID_EVPROP_ONMOUSEOUT:
        case DISPID_EVMETH_ONMOUSEOUT:
            if (m_hwndCurWnd != 0 && m_pWindow)
            {
                DAComPtr <IHTMLEventObj> pEventObj;
                
                hr = THR(m_pWindow->get_event(&pEventObj));
                if (FAILED (hr))
                {
                    break;
                }
                
                MouseEvent(m_lastX, 
                           m_lastY, 
                           FALSE, 
                           TRUE, 
                           m_lastMouseMod & AXAEMOD_SHIFT_MASK, 
                           m_lastMouseMod & AXAEMOD_ALT_MASK, 
                           m_lastMouseMod & AXAEMOD_CTRL_MASK, 
                           m_lastButton);

                VariantInit(pVarResult);
                pVarResult->vt = VT_BOOL;
                pVarResult->boolVal = VARIANT_TRUE;
            }
        
            break;

        case DISPID_EVPROP_ONLOAD:
        case DISPID_EVMETH_ONLOAD:
            m_elm.OnLoad();
            if (m_pEventSync)
            {
                IGNORE_HR(m_pEventSync->InitMouse());
            }
            break;

        case DISPID_EVPROP_ONUNLOAD:
        case DISPID_EVMETH_ONUNLOAD:
            m_elm.OnBeforeUnload();  //signal that the element is unloading now.  No further events
                                     //will be fired.
            m_elm.OnUnload();    
            break;

        case DISPID_EVPROP_ONSTOP:
        case DISPID_EVMETH_ONSTOP:
            // if we are the Body, call pause
            if (m_elm.IsBody())
                THR(m_elm.base_pause());

            // BUGBUG - need to turn clock services off.
            break;
            
        case DISPID_EVPROP_ONREADYSTATECHANGE:
        case DISPID_EVMETH_ONREADYSTATECHANGE:
            //have to detach here because it is possible that the events have been attach before this
            //event is received.
            IGNORE_HR(DetachEvents());
            IGNORE_HR(AttachEvents());            
            break;

    }

    //handle a begin or end Event.
    if (bBeginEventMatch || bEndEventMatch)
    {
        BeginEndFired(bBeginEventMatch, bEndEventMatch, dispIdMember);
    }
        
  done:
    return S_OK;
}




///////////////////////////////////////////////////////////////
//  Name: GetEventCount
// 
//  Abstract:
//    Counts the number of events in an EventString where events
//    are separated by ';' or NULL terminated.
///////////////////////////////////////////////////////////////
long CEventMgr::GetEventCount(BSTR bstrEvent)
{
    long curCount = 0;
    OLECHAR *curChar;
    UINT strLen = 0;

    strLen = SysStringLen(bstrEvent);
    OLECHAR *szEvent = NEW OLECHAR [strLen + 1];
    if (szEvent == NULL)
    {
        return 0;
    }

    curChar = bstrEvent;

    //strip out ' '
    while (*curChar != '\0' && curCount < strLen)
    {
        if (*curChar != ' ')
        {
            szEvent[curCount] = *curChar;
            curCount++;
        }
        curChar++;
    }
    szEvent[curCount] = '\0';

    curCount = 0;
    curChar = szEvent;
    while (*curChar != '\0')
    {
        curChar++;
        if ((*curChar == ';') || ((*curChar == '\0') && ((*curChar - 1) != ';')))
        {
            curCount++;
        }
    }
    //determine if the end character was a ';'.
    if (*(curChar - 1) == ';')
    {
        curCount--;
    }   

    delete [] szEvent;
    return curCount;
}


///////////////////////////////////////////////////////////////
//  Name: GetEventName
// 
//  Abstract:
//    This gets the event names from a string that has the format
//    EventName()  It only handles strings like 
//    ElementName.EventName().  It can also handle the OR'ing of
//    event names using ";".  So Element1.Event1();Element2.Event2();...
//    can be handled.
///////////////////////////////////////////////////////////////
HRESULT CEventMgr::GetEventName(BSTR bstrEvent, BSTR **pElementName, BSTR **pEventName, long Count)
{
    BSTR bstrEventName;
    UINT strLen = 0;
    OLECHAR *curChar;
    int i = 0, j = 0;
    HRESULT hr = S_OK;
    BSTR bstrTempEvent = NULL;
    BSTR bstrTempElement = NULL;

    BSTR *bstrEventList = NULL;
    BSTR *bstrElementList = NULL;

    strLen = SysStringLen(bstrEvent);
    OLECHAR *sTemp = NEW OLECHAR [strLen + 1];
    if (sTemp == NULL)
    {
        hr = E_FAIL;
        goto done;
    }

    bstrElementList = NEW BSTR [Count];
    if (bstrElementList == NULL)
    {
        hr = E_FAIL;
        goto done;
    }
    
    bstrEventList = NEW BSTR [Count];
    if (bstrEventList == NULL)
    {
        hr = E_FAIL;
        goto done;
    }

    curChar = bstrEvent;
    for (j = 0; j < Count; j++)
    {
        //get the element name
        ZeroMemory(sTemp, sizeof(OLECHAR) * strLen);
        
        i = 0;
        //step through the bstr looking for \0 or the '.' or ';'
        while (i < strLen - 1 && *curChar != '\0' && *curChar != '.' && *curChar != ';')
        {
            if (*curChar != ' ')  //need to strip out spaces.
            {
                sTemp[i] = *curChar;
                i++;
            }
            curChar++;
        }
        
        if (*curChar != '.')
        {
            hr = E_FAIL;
            goto done;
        }
                
        bstrTempElement = SysAllocString(sTemp);
        if (NULL == bstrTempElement)
        {
            hr = E_OUTOFMEMORY;
            goto done;
        }

        bstrElementList[j] = bstrTempElement; 

        //get the event name
        ZeroMemory(sTemp, sizeof(OLECHAR) * strLen);

        curChar++;
        i = 0;
        //step through the bstr looking for \0 or the ';'
        while (i < strLen - 1 && *curChar != ';' && *curChar != '\0')
        {
            sTemp[i] = *curChar;
            i++;
            curChar++;
        }
        
        //strip out trailing spaces
        i--;
        while (sTemp[i] == ' ' && i > 0)
        {
            sTemp[i] = '\0';
            i--;
        }

        bstrTempEvent = SysAllocString(sTemp);
        if (NULL == bstrTempEvent)
        {
            hr = E_OUTOFMEMORY;
            goto done;
        }

        bstrEventList[j] = bstrTempEvent;

        //advance curChar to the next element or the end of the string
        if (j < Count - 1)
        {
            while (*curChar != ';' && *curChar != '\0')
            {
                curChar++;
            }
            if (*curChar == ';') 
            {
                curChar++;
            }
            if (*curChar == '\0')
            {
                goto done;
            }
        }
    }

  done:

    delete [] sTemp;
    if (SUCCEEDED(hr))
    {
        *pElementName = bstrElementList;
        *pEventName = bstrEventList;
    }
    else //cleanup code
    {
        for (i = 0; i < j; i++)
        {
            if (bstrEventList)
            {
                SysFreeString(bstrEventList[i]);
            }
            if (bstrElementList)
            {
                SysFreeString(bstrElementList[i]);
            }
        }
        if (bstrElementList)
        {
            delete [] bstrElementList;
        }
        if (bstrEventList)
        {
            delete [] bstrEventList;
        }
    }
    return hr;   
}

///////////////////////////////////////////////////////////////
//  Name: MatchEvent
// 
//  Parameters:
//    BSTR bstrEvent            The cached event name in the format
//                              "Elementname.EventName".
//    IHTMLEventObj *pEventObj  A pointer to the event object that is
//                              passed into IDispatch::Invoke.
//
//  Abstract:
//    Determines if the event that was just hooked matches
//    the event specified in bstrEvent.
///////////////////////////////////////////////////////////////
bool CEventMgr::MatchEvent(BSTR bstrEvent, IHTMLEventObj *pEventObj, long Count, bool ScriptCommandAttach[])
{
    bool bMatch = false;
    BSTR *bstrExpEventName = NULL; 
    BSTR *bstrExpElementName = NULL;
    BSTR bstrEventName = NULL;
    BSTR bstrElementName = NULL;
    HRESULT hr = S_OK;
    DAComPtr <IHTMLEventObj2> pEventObj2;
    int i = 0;

    hr = THR(pEventObj->get_type(&bstrEventName));
    
    hr = THR(pEventObj->QueryInterface(IID_IHTMLEventObj2, (void**)&pEventObj2));
    if (FAILED(hr))
    {
        goto done;
    }

	//hack to work around eventobject problems
	if (!bstrEventName)
    {
        VARIANT vTemp;
        VariantInit(&vTemp);
        pEventObj2->getAttribute(g_szEventName, 0, &vTemp);
        SysFreeString(bstrEventName );
        bstrEventName  = SysAllocString(vTemp.bstrVal);
        VariantClear(&vTemp);
    }

    hr = THR(GetEventName(bstrEvent, &bstrExpElementName, &bstrExpEventName, Count));
    if (FAILED(hr))
    {
        goto done;
    }
    
    for (i = 0; i < Count; i++)
    {
        if ((StrCmpIW(g_EventNames[TE_ONSCRIPTCOMMAND].wsz_name + 2, bstrEventName) == 0) && 
            (ScriptCommandAttach[i] == true))
        {
            //if this is a script command event and we attached to the script command event by default
            //then reset the event name to match the value of the "scType" parameter.
            VARIANT vTemp;
            VariantInit(&vTemp);
            pEventObj2->getAttribute(L"scType", 0, &vTemp);
            SysFreeString(bstrEventName);
            bstrEventName  = SysAllocString(vTemp.bstrVal);
            VariantClear(&vTemp);            
        }

        //check that the event names match
        if ((StrCmpIW(bstrExpEventName[i] + 2, bstrEventName) == 0) || (StrCmpIW(bstrExpEventName[i], bstrEventName) == 0))
        {
            //check that the Element name matches
            DAComPtr <IHTMLElement> pEle;

            hr = THR(pEventObj->get_srcElement(&pEle));
            if (FAILED(hr))
            {
                goto done;
            }
            if (NULL == pEle.p)
            {
                goto done;
            }
         
            //get the source element name
            THR(pEle->get_id(&bstrElementName));
        
            //handle the "this" string as an element name
            if (StrCmpIW(bstrExpElementName[i], L"this") == 0)
            {
                BSTR bstrName;
                hr = THR(m_pElement->get_id(&bstrName));
                if (FAILED(hr))
                {
                    SysFreeString(bstrName);
                    goto done;
                }

                if (StrCmpIW(bstrElementName, bstrName) == 0 &&
                    ValidateEvent(bstrEventName, pEventObj, m_pElement))
                {
                    bMatch = true;          
                    SysFreeString(bstrName);
                    SysFreeString(bstrElementName);
                    goto done;
                }

            }
            else if (StrCmpIW(bstrExpElementName[i], bstrElementName) == 0)
            {
                if (ValidateEvent(bstrEventName, pEventObj, pEle))
                {
                    bMatch = true;          
                    SysFreeString(bstrElementName);
                    goto done;
                }
            }
            else // may have to check the elements parents
            {
                DAComPtr<IHTMLElement> pCurEle;
                DAComPtr<IHTMLElement> pParentEle;
                bool bDone = false;

                //determine if this is a time event
                VARIANT vTemp;
                VARTYPE vType = VT_NULL;

                VariantInit(&vTemp);
                IGNORE_HR(pEventObj2->getAttribute(g_szEventName, 0, &vTemp));
                vType = vTemp.vt; //vType will be VT_NULL if this is not a time event.
                VariantClear(&vTemp);

                //if this is not a time event, check the parents.
                if (vType == VT_NULL) 
                {
                    IGNORE_HR(pEle->get_parentElement(&pParentEle));
                    while (pParentEle && !bDone)
                    {
                        if (pCurEle)
                        {
                            pCurEle->Release();
                        }
                        pCurEle = pParentEle;
                        pParentEle = NULL;
                    
                        //get the source element name
                        SysFreeString(bstrElementName);
                        IGNORE_HR(pCurEle->get_id(&bstrElementName));
                        if (StrCmpIW(bstrExpElementName[i], bstrElementName) == 0)
                        {
                            if (ValidateEvent(bstrEventName, pEventObj, pCurEle))
                            {
                                bMatch = true;
                            }
                                                
                            SysFreeString(bstrElementName);
                            bDone = true;
                        }
                        if (!bDone)
                        {
                            IGNORE_HR(pCurEle->get_parentElement(&pParentEle));
                        }
                    }
                }
            }
        }
        if (bstrElementName)
        {
            SysFreeString(bstrElementName);
        }
    }

  done:
    if (bstrExpEventName)
    {
        for (i = 0; i < Count; i++)
        {
            if (bstrExpEventName)
            {
                SysFreeString(bstrExpEventName[i]);
            }
            if (bstrExpElementName)
            {
                SysFreeString(bstrExpElementName[i]);
            }
        }
        if (bstrExpEventName)
        {
            delete [] bstrExpEventName;
        }
        if (bstrExpElementName)
        {
            delete [] bstrExpElementName;
        }
    }
    return bMatch;
}

///////////////////////////////////////////////////////////////
//  Name: ValidateEvent
// 
//  Parameters:
//    BSTR bstrEventName        The cached event name (e.g. "mouseover")
//    IHTMLEventObj *pEventObj  A pointer to the event object
//    IHTMLElement  *pElement   The element on which the event is occurring
//
//  Abstract:
//    Determines if the event is valid - used to filter out mouseover and mouseout events
//    happening on child elements, if the appropriate flag is set.
///////////////////////////////////////////////////////////////

bool CEventMgr::ValidateEvent(BSTR bstrEventName, IHTMLEventObj *pEventObj, IHTMLElement *pElement)
{
        HRESULT hr;

        if (StrCmpIW(bstrEventName, L"mouseout") == 0)
        {
                if (RequireEventValidation())
                {
                        // Check that event.toElement is NOT contained in pElement
                        DAComPtr <IHTMLElement> pToElement;
                        hr = pEventObj->get_toElement(&pToElement);
                        if (SUCCEEDED(hr) && pToElement)
                        {
                                VARIANT_BOOL varContained;
                                hr = pElement->contains(pToElement, &varContained);

                                if (SUCCEEDED(hr) && varContained != VARIANT_FALSE)
                                        return false;
                        }
                }
        }
        else if (StrCmpIW(bstrEventName, L"mouseover") == 0)
        {
                if (RequireEventValidation())
                {
                        // Check that event.fromElement is NOT contained in pElement
                        DAComPtr <IHTMLElement> pFromElement;
                        hr = pEventObj->get_fromElement(&pFromElement);
                        if (SUCCEEDED(hr) && pFromElement)
                        {
                                VARIANT_BOOL varContained;
                                hr = pElement->contains(pFromElement, &varContained);

                                if (SUCCEEDED(hr) && varContained != VARIANT_FALSE)
                                        return false;
                        }
                }
        }

        return true;
}

///////////////////////////////////////////////////////////////
//  Name: RequireEventValidation
// 
//  Parameters:
//
//  Abstract:
//    Determines whether event validation on mouseover and mouseout is required
//    by checking an attribute on m_pElement.
///////////////////////////////////////////////////////////////

bool CEventMgr::RequireEventValidation()
{
        bool result = false;

        if (m_pElement != NULL)
        {
                DAComPtr <IDispatch> pDispatch;
                HRESULT hr = m_pElement->QueryInterface(IID_TO_PPV(IDispatch, &pDispatch));
                if (SUCCEEDED(hr))
                {
                        DISPID dispid;
                        OLECHAR *attrName = L"an:filterMInOut";

                        hr = pDispatch->GetIDsOfNames(IID_NULL, &attrName, 1, LCID_SCRIPTING, &dispid);

                        if (SUCCEEDED(hr))
                        {
                                DISPPARAMS  params;
                                VARIANT     varResult;
                                EXCEPINFO   excepInfo;
                                UINT        nArgErr;

                                VariantInit(&varResult);

                                params.rgvarg             = NULL;
                                params.rgdispidNamedArgs  = NULL;
                                params.cArgs              = 0;
                                params.cNamedArgs         = 0;

        
                                hr = pDispatch->Invoke(dispid,
                                                       IID_NULL,
                                                       LCID_SCRIPTING,
                                                       DISPATCH_PROPERTYGET,
                                                       &params,
                                                       &varResult,
                                                       &excepInfo,
                                                       &nArgErr );

                                if (SUCCEEDED(hr))
                                {
                                        hr = VariantChangeTypeEx(&varResult, &varResult, LCID_SCRIPTING, 0, VT_BOOL);
                                        if (SUCCEEDED(hr))
                                        {
                                                if (V_BOOL(&varResult) == VARIANT_TRUE)
                                                        result = true;
                                        }

                                        VariantClear(&varResult);
                                }
                        }
                }
        }

        return result;
}

///////////////////////////////////////////////////////////////
//  Name: ReadyStateChange
// 
//  Parameters:
//      BSTR ReadyState             a string containing the 
//                                  current ready state.  Possible
//                                  values are "complete" or
//                                  "interactive".  Only "complete"
//                                  is currently used.
//
//  Abstract:
//    This method is called from the EventSync class to 
//    notify the event manager that the readystatechange
//    event has occured.
///////////////////////////////////////////////////////////////
void CEventMgr::ReadyStateChange(BSTR ReadyState)
{   
    TOKEN tokReadyState;

    tokReadyState = StringToToken(ReadyState);

    if (tokReadyState != INVALID_TOKEN)
    {
        m_elm.OnReadyStateChange(tokReadyState);
    }
}



///////////////////////////////////////////////////////////////
//  Name: PropertyChange
// 
//  Parameters:
//      BSTR PropertyName           The name of the property
//                                  that has changed.
//
//  Abstract:
//    This method is called from the EventSync class to 
//    notify the event manager that a propertychange event 
//    has occured.
///////////////////////////////////////////////////////////////
void CEventMgr::PropertyChange(BSTR PropertyName)
{
    TraceTag((tagEventMgr,
              "EventMgr(%lx)::PropertyChanged(%ls)",
              this,
              PropertyName));
    //////////////////////////////////////
    //UNDONE:
    // do something to notify the element
    // that the a property has changed
    //
    // QUESTION: 
    // should this look for t:propertyname,
    // t_propertyname, or just propertyname?
    //////////////////////////////////////
}

///////////////////////////////////////////////////////////////
//  Name: MouseEvent
// 
//  Parameters:
//    long x                    The current x coordinate 
//    long y                    The current y coordinate
//    VARIANT_BOOL bMove        True if this is a mouse move event
//    VARIANT_BOOL bUp          True if this is a mouse up event
//    VARIANT_BOOL bShift       True if the Shift key is down
//    VARIANT_BOOL bAlt         True if the Alt key is down
//    VARIANT_BOOL bCtrl        True if the Control key is down
//    long button               Mousebutton that triggered the
//                              event. Possible values are:
//                                  1 for left
//                                  2 for right
//                                  4 for middle
// 
//  Abstract:
//    This method is called from the EventSync class to 
//    notify the event manager that a Mouse event
//    has occured on the element.
///////////////////////////////////////////////////////////////
void CEventMgr::MouseEvent(long x, 
                           long y, 
                           VARIANT_BOOL bMove,
                           VARIANT_BOOL bUp,
                           VARIANT_BOOL bShift, 
                           VARIANT_BOOL bAlt,
                           VARIANT_BOOL bCtrl,
                           long button)
{
    MMView *view;
    double time;
    BYTE bButton;
    long offsetX, offsetY;
    HRESULT hr;
    
    view = m_elm.GetView();

    if (m_elm.GetPlayer())
    {
        time = m_elm.GetPlayer()->GetCurrentTime();
    }
    else
    {
        time = 0;
    }
    
    if (view == NULL || time == 0.0)
    {
        goto done;
    }
    
    hr = THR(m_pElement->get_offsetTop(&offsetY));
    if (FAILED(hr))
    {
        goto done;
    }
    hr = THR(m_pElement->get_offsetLeft(&offsetX));
    if (FAILED(hr))
    {
        goto done;
    }


    if (bMove)
    {
        view->OnMouseMove(time,
                          x - offsetX,
                          y - offsetY,
                          GetModifiers(bShift, bCtrl, bAlt));
        m_lastX = x;
        m_lastY = y;
    }
    else
    {
        BYTE mod;
        bButton = (button == 4) ? (BYTE)(button - 2) : (BYTE)(button - 1);

        if (!bUp)                       //if the button is a mouse down message
        {                               //capture the mouse and send the message.
            m_hwndCurWnd = GetFocus();    
            SetCapture(m_hwndCurWnd);
                
            mod = GetModifiers(bShift, bCtrl, bAlt);
            view->OnMouseButton(time,
                                x - offsetX,
                                y - offsetY,
                                bButton,
                                (bUp) ? AXA_STATE_UP : AXA_STATE_DOWN,
                                mod) ;

            m_lastButton = button;
            m_lastX = 0;
            m_lastY = 0;
            m_lastMouseMod = mod;
        }        
        else  //this is a mouse up
        {
            if (m_hwndCurWnd != 0)  //if there was a previous mouse down message
            {
                ReleaseCapture();
                m_hwndCurWnd = 0;
                    
                view->OnMouseButton(time,
                                    x - offsetX,
                                    y - offsetY,
                                    bButton,
                                    (bUp) ? AXA_STATE_UP : AXA_STATE_DOWN,
                                    GetModifiers(bShift, bCtrl, bAlt)) ;
                m_lastButton = 0;
                m_lastMouseMod = 0;
            }
            
        } 
    }

  done:
    return;
}
    

///////////////////////////////////////////////////////////////
//  Name: KeyEvent
// 
//  Parameters:
//    VARIANT_BOOL bLostFocus   True if there was a lost focus event
//    VARIANT_BOOL bUp          True if this is a KeyUp Event
//    VARIANT_BOOL bShift       True if the Shift key is down
//    VARIANT_BOOL bAlt         True if the Alt key is down
//    VARIANT_BOOL bCtrl        True if the Control key is down
//    long KeyCode              The unicode keycode for the key
// 
//  Abstract:
//    This method is called from the EventSync class to 
//    notify the event manager that a KeyBoard event
//    has occured on the element.
///////////////////////////////////////////////////////////////
void CEventMgr::KeyEvent(VARIANT_BOOL bLostFocus,
                         VARIANT_BOOL bUp,
                         VARIANT_BOOL bShift, 
                         VARIANT_BOOL bAlt,
                         VARIANT_BOOL bCtrl,
                         long KeyCode, 
                         long RepeatCount)
{
    MMView *view;
    double time;
    BYTE mod;

    // ignore repeated keys
    if (RepeatCount > 0)
    {
        goto done;
    }

    //get the view stuff
    view = m_elm.GetView();

    if (m_elm.GetPlayer())
    {
        time = m_elm.GetPlayer()->GetCurrentTime();
    }
    else
    {
        time = 0;
    }
    
    if (view == NULL || time == 0.0)
    {
        goto done;
    }
    
    mod = GetModifiers(bShift, bCtrl, bAlt);

    //if this is a lost focus event, only fire the keyup with the last keycode value
    if (bLostFocus)
    {
        if (m_lastKey != 0)
        {
            view->OnKey(time, 
                        m_lastKey,
                        false,
                        m_lastKeyMod);
        
            m_lastKey = 0;
        }
        goto done;
    }

    // See if we got a keydown before a keyup for the last
    // known keydown
    if (m_lastKey != 0 && !bUp) 
    {
        view->OnKey(time, 
                    m_lastKey,
                    false,
                    m_lastKeyMod);
        
        m_lastKey = 0 ;
    }

    //if this is a special key, convert it
    if (AXAIsSpecialVK(KeyCode)) 
    {
        KeyCode = VK_TO_AXAKEY(KeyCode);
    }

    if (bUp)
    {
        view->OnKey(time, 
                    KeyCode,
                    false,
                    mod);
        
        m_lastKey = 0;
        m_lastKeyMod = 0;  
    }
    else
    {
        view->OnKey(time, 
                    KeyCode,
                    true,
                    mod);
        
        m_lastKey = KeyCode ;
        m_lastKeyMod = mod ;  
    }

  done:
    return;
}  

///////////////////////////////////////////////////////////////
//  Name: GetModifiers
// 
//  Parameters:
//    VARIANT_BOOL bShift       True if the Shift key is down
//    VARIANT_BOOL bAlt         True if the Alt key is down
//    VARIANT_BOOL bCtrl        True if the Control key is down
// 
//  Abstract:
///////////////////////////////////////////////////////////////
BYTE CEventMgr::GetModifiers(VARIANT_BOOL bShift, VARIANT_BOOL bCtrl, VARIANT_BOOL bAlt)
{
    BYTE mod = AXAEMOD_NONE;

    if (bShift) mod |= AXAEMOD_SHIFT_MASK ;
    if (bCtrl) mod |= AXAEMOD_CTRL_MASK ;
    if (bAlt) mod |= AXAEMOD_ALT_MASK ;

    return mod;
}


int CEventMgr::IsEventInList(BSTR ElementName, BSTR EventName, long ListCount, BSTR Events)
{
    int nInList = -1;
    LPOLESTR curEvent;
    BSTR *EventList = NULL;
    BSTR *ElementList = NULL;
    HRESULT hr = S_OK;
    int i;

    hr = THR(GetEventName(Events, &ElementList, &EventList, ListCount));
    if (FAILED(hr))
    {
        goto done;
    } 

    for (i = 0; i < ListCount; i++)
    {
        if ((StrCmpIW(ElementName, ElementList[i]) == 0) &&
            (StrCmpIW(EventName, EventList[i]) == 0))
        {
            nInList = i;
            goto done;
        }
    }


  done:
    if (EventList)
    {
        for (i = 0; i < ListCount; i++)
        {
            SysFreeString(EventList[i]);
            SysFreeString(ElementList[i]);
        }
        delete [] EventList;
        delete [] ElementList;
    }
    return nInList;
}


///////////////////////////////////////////////////////////////
//  Name: BeginEndFired
// 
//  Parameters:
//    bBeginEventMatch          True if a beginEvent occurred
//    bEndEventMatch          True if an endEvent occurred
// 
//  Abstract:
//    This method determines how to handle the beginEvent/endEvent
//    occurrences.
///////////////////////////////////////////////////////////////
void CEventMgr::BeginEndFired(bool bBeginEventMatch, bool bEndEventMatch, DISPID EventDispId)
{
    float CurTime = 0;
    SYSTEMTIME sysTime;

    GetSystemTime(&sysTime); 
    CurTime = sysTime.wSecond * 1000 + sysTime.wMilliseconds;

    if (EventDispId == DISPID_HTMLDOCUMENTEVENTS_ONCLICK && 
        m_bLastEventClick == true) 
    {
        //this ignores the case of the document.onclick that immediately
        //follows all element.onclick events.
        m_bLastEventClick = false;
        goto done;
    }

    if ((CurTime != m_lastEventTime) ||
        (bBeginEventMatch != bEndEventMatch))
    {
        MM_STATE curMMState = m_elm.GetPlayState();

        if (bEndEventMatch && bBeginEventMatch)
        {
            if (m_elm.GetEventRestart() ||
                curMMState == MM_STOPPED_STATE)
            {
                m_elm.base_beginElement(false);
            }
            else if (curMMState == MM_PAUSED_STATE ||
                     curMMState == MM_PLAYING_STATE )
            {
                m_elm.base_endElement();
            }
        }
        else if  (bBeginEventMatch)
        {
            if (m_elm.GetEventRestart() ||
                curMMState == MM_STOPPED_STATE)
            {
                m_elm.base_beginElement(false);
            }
        }
        else if (bEndEventMatch)
        {
            if (curMMState == MM_PAUSED_STATE ||
                curMMState == MM_PLAYING_STATE )
            {
                m_elm.base_endElement();   
            }
        }
        m_lastEventTime = CurTime;
    }
  done:
    return;
}

HRESULT 
CEventMgr::ShouldFireThisEvent(bool *pfShouldFire)
{
    HRESULT hr = S_OK;

    *pfShouldFire = true;

    if (m_elm.GetBody() != NULL)
    {
        if (m_elm.GetBody()->IsPaused())
        {
            DAComPtr <IHTMLEventObj> pEventObj;
            Assert(NULL != m_pWindow.p);
            hr = THR(m_pWindow->get_event(&pEventObj));
            if (SUCCEEDED(hr))
            {
                BSTR bstrEventName;
                hr = THR(pEventObj->get_type(&bstrEventName));
                if (SUCCEEDED(hr))
                {
                    *pfShouldFire = IsValidEventInPausedAndEditMode(bstrEventName); 
                }
                SysFreeString(bstrEventName);                        
            }                
        }
    }
    return hr;
}

bool
CEventMgr::IsValidEventInPausedAndEditMode(BSTR bstrEventName)
{
    Assert(NULL != bstrEventName);
    if (wcsstr( bstrEventName, L"mouse" ) != NULL || wcsstr(bstrEventName, L"click") != NULL)
    {
        return false;
    }
    return true;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\time\src\headers.h ===
/*******************************************************************************

Copyright (c) 1995_96 Microsoft Corporation

Abstract:

    {Insert General Comment Here}

*******************************************************************************/


#ifndef _HEADERS_H
#define _HEADERS_H

#include "include/headers.h"
#include "datime.h"
#include "comutil.h"
#include "dartapi.h"
#include "mmapi.h"
#include "util.h"
#include <list>
#include "array.h"


#endif /* _HEADERS_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\time\src\eventsync.h ===
///////////////////////////////////////////////////////////////
// Copyright (c) 1998 Microsoft Corporation
//
// File: EventSync.h
//
// Abstract:  
//
///////////////////////////////////////////////////////////////

#ifndef _EVENTSYNC_H
#define _EVENTSYNC_H



enum ELEMENT_EVENT
{
    EE_ONPROPCHANGE = 0,
    //add non-input related events to hook here
    EE_ONREADYSTATECHANGE, 
    EE_ONMOUSEMOVE,
    EE_ONMOUSEDOWN,
    EE_ONMOUSEUP,
    EE_ONKEYDOWN,
    EE_ONKEYUP,
    EE_ONBLUR,
    //add input related events here
    EE_MAX
};

class CEventSync
    : public IDispatch
{
  public:
    CEventSync(CTIMEElementBase & elm, CEventMgr *pEventMgr);
    ~CEventSync();

    //methods
    HRESULT Init();
    HRESULT Deinit();
    HRESULT InitMouse();

    //QueryInterface 
    STDMETHODIMP QueryInterface(REFIID, void **);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

    //IDispatch
    STDMETHODIMP GetTypeInfoCount(UINT* pctinfo);
    STDMETHODIMP GetTypeInfo(/* [in] */ UINT iTInfo,
                             /* [in] */ LCID lcid,
                             /* [out] */ ITypeInfo** ppTInfo);
    STDMETHODIMP GetIDsOfNames(
        /* [in] */ REFIID riid,
        /* [size_is][in] */ LPOLESTR *rgszNames,
        /* [in] */ UINT cNames,
        /* [in] */ LCID lcid,
        /* [size_is][out] */ DISPID *rgDispId);
    STDMETHODIMP Invoke(
        /* [in] */ DISPID dispIdMember,
        /* [in] */ REFIID riid,
        /* [in] */ LCID lcid,
        /* [in] */ WORD wFlags,
        /* [out][in] */ DISPPARAMS  *pDispParams,
        /* [out] */ VARIANT  *pVarResult,
        /* [out] */ EXCEPINFO *pExcepInfo,
        /* [out] */ UINT *puArgErr);


  protected:
    //methods
    HRESULT                           AttachEvents();
    HRESULT                           DetachEvents();
    HRESULT                           NotifyReadyState(IHTMLEventObj *pEventObj);
    HRESULT                           NotifyPropertyChange(IHTMLEventObj *pEventObj);
    HRESULT                           NotifyMouseMove(IHTMLEventObj *pEventObj);
    HRESULT                           NotifyMouseUp(IHTMLEventObj *pEventObj);
    HRESULT                           NotifyMouseDown(IHTMLEventObj *pEventObj);
    HRESULT                           NotifyKeyDown(IHTMLEventObj *pEventObj);
    HRESULT                           NotifyKeyUp(IHTMLEventObj *pEventObj);

    //properties
    IHTMLElement *                    m_pElement;
    CTIMEElementBase &                m_elm;
    long                              m_refCount;
    DWORD                             m_dwElementEventConPtCookie;
    DAComPtr<IConnectionPoint>        m_pElementConPt;
    CEventMgr *                       m_pEventMgr;

};

#endif /* _EVENTSYNC_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\time\src\factory.h ===
/*******************************************************************************

Copyright (c) 1995_96 Microsoft Corporation

Abstract:

    {Insert General Comment Here}

*******************************************************************************/


#ifndef _FACTORY_H
#define _FACTORY_H

#define LIBID __T("TIME")

#include "timeman.h"

class ATL_NO_VTABLE CTIMEFactory
    : public CComObjectRootEx<CComSingleThreadModel>,
      public CComCoClass<CTIMEFactory, &CLSID_TIMEFactory>,
      public IDispatchImpl<ITIMEFactory, &IID_ITIMEFactory, &LIBID_TIME>,
      public ISupportErrorInfoImpl<&IID_ITIMEFactory>,
      public IElementBehaviorFactory,
      public IObjectSafety
{
  public:
    CTIMEFactory();
    ~CTIMEFactory();

    DA_DECLARE_NOT_AGGREGATABLE(CTIMEFactory);

    HRESULT FinalConstruct();
#if _DEBUG
    const _TCHAR * GetName() { return __T("CTIMEFactory"); }
#endif

    // IElementBehaviorFactory
    
    STDMETHOD(FindBehavior)(LPOLESTR pchNameSpace,
                            LPOLESTR pchTagName,
                            IElementBehaviorSite * pUnkArg,
                            IElementBehavior ** ppBehavior)
    {
        return FindBehavior(pchNameSpace, pchTagName, (IUnknown *) pUnkArg, ppBehavior);
    }

    STDMETHOD(FindBehavior)(LPOLESTR pchNameSpace,
                            LPOLESTR pchTagName,
                            IUnknown * pUnkArg,
                            IElementBehavior ** ppBehavior);

        // IObjectSafetyImpl
        STDMETHOD(SetInterfaceSafetyOptions)(
                                                        /* [in] */ REFIID riid,
                                                        /* [in] */ DWORD dwOptionSetMask,
                                                        /* [in] */ DWORD dwEnabledOptions);
        STDMETHOD(GetInterfaceSafetyOptions)(
                                                        /* [in] */ REFIID riid, 
                                                        /* [out] */DWORD *pdwSupportedOptions, 
                                                        /* [out] */DWORD *pdwEnabledOptions);

    // ITIMEFactory

    STDMETHOD(CreateTIMEElement)(REFIID riid, LPUNKNOWN pUnkElement, void ** ppOut);
    STDMETHOD(CreateTIMEBodyElement)(REFIID riid, void ** ppOut);
    STDMETHOD(CreateTIMEDAElement)(REFIID riid, void ** ppOut);
    STDMETHOD(CreateTIMEMediaElement)(REFIID riid, MediaType type, void ** ppOut);
    
    DECLARE_REGISTRY(CLSID_TIMEFactory,
                     LIBID __T(".TIMEFactory.1"),
                     LIBID __T(".TIMEFactory"),
                     0,
                     THREADFLAGS_BOTH);
    
    BEGIN_COM_MAP(CTIMEFactory)
        COM_INTERFACE_ENTRY(ITIMEFactory)
        COM_INTERFACE_ENTRY(IDispatch)
        COM_INTERFACE_ENTRY(ISupportErrorInfo)
        COM_INTERFACE_ENTRY(IObjectSafety)
        COM_INTERFACE_ENTRY(IElementBehaviorFactory)
    END_COM_MAP();

    HRESULT Error();

    
  protected:

    HRESULT GetHostElement (LPUNKNOWN pUnk, IHTMLElement **ppelHost);
    HRESULT GetScopeName (LPUNKNOWN pUnk, BSTR *pbstrScopeName);
    HRESULT CreateHostedTimeElement(REFIID riid, void **ppOut);
    HRESULT CreateTIMENamespaceElement (REFIID riid, LPUNKNOWN pUnk, LPWSTR wszTagSpecific, 
                                          void **ppBehavior);
    TimeManagerMap *m_tMMap;
    long m_dwSafety;
  private:
      bool IsBodyElementWithoutTime(IUnknown *pUnkArg);

};


#endif /* _FACTORY_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\time\src\factory.cpp ===
/*******************************************************************************
 *                                                                              
 * Copyright (c) 1998 Microsoft Corporation
 *
 * Abstract:
 *
 *******************************************************************************/

#include "headers.h"
#include "factory.h"
#include "timeelm.h"
#include "daelm.h"
#include "bodyelm.h"
#include "mediaelm.h"

DeclareTag(tagFactory, "API", "CTIMEFactory methods");

CTIMEFactory::CTIMEFactory() :m_tMMap(NULL)
{
    TraceTag((tagFactory,
              "CTIMEFactory(%lx)::CTIMEFactory()",
              this));
}

CTIMEFactory::~CTIMEFactory()
{
    TraceTag((tagFactory,
              "CTIMEFactory(%lx)::~CTIMEFactory()",
              this));
}


HRESULT
CTIMEFactory::FinalConstruct()
{
    TraceTag((tagFactory,
              "CTIMEFactory(%lx)::FinalConstruct()",
              this));

    if (bFailedLoad)
        return E_FAIL;
    return S_OK;
}

HRESULT
CTIMEFactory::Error()
{
    TraceTag((tagFactory,
              "CTIMEFactory(%lx)::Error()",
              this));

    LPCWSTR str = CRGetLastErrorString();
    HRESULT hr = CRGetLastError();
    
    if (str)
        return CComCoClass<CTIMEFactory, &CLSID_TIMEFactory>::Error(str, IID_ITIMEFactory, hr);
    else
        return hr;
}

HRESULT
CTIMEFactory::GetHostElement (LPUNKNOWN pUnk, IHTMLElement **ppelHost)
{
    HRESULT hr = E_INVALIDARG;
        
    if (NULL != pUnk)
    {
        IElementBehaviorSite *piBvrSite = NULL;
        hr = THR(pUnk->QueryInterface(IID_IElementBehaviorSite, 
                                      reinterpret_cast<void **>(&piBvrSite)));
        if (SUCCEEDED(hr))
        {
            hr = THR(piBvrSite->GetElement(ppelHost));
            piBvrSite->Release();
            if(SUCCEEDED(hr))
            {
                if (NULL == *ppelHost)
                {
                    hr = E_FAIL;
                }
            }
        }
    }

    return hr;
} // GetHostElement

HRESULT
CTIMEFactory::GetScopeName (LPUNKNOWN pUnk, BSTR *pbstrScope)
{
    IHTMLElement *pelHost = NULL;
    HRESULT hr = GetHostElement(pUnk, &pelHost);

    if (SUCCEEDED(hr))
    {
        IHTMLElement2 *pel2Host = NULL;
        hr = THR(pelHost->QueryInterface(IID_IHTMLElement2, 
                                         reinterpret_cast<void **>(&pel2Host)));
        pelHost->Release();
        if (SUCCEEDED(hr))
        {
            hr = THR(pel2Host->get_scopeName(pbstrScope));
        }

        pel2Host->Release();
    }

    return hr;
} // GetScopeName

HRESULT
CTIMEFactory::CreateHostedTimeElement(REFIID riid, void **ppOut)
{

    DAComObject<CTIMEElement> *pNew;
    HRESULT hr = DAComObject<CTIMEElement>::CreateInstance(&pNew);

    if (!pNew) 
    {
        THR(hr = E_OUTOFMEMORY);
    } 
    else 
    {
        if (SUCCEEDED(hr)) 
        {
            THR(hr = pNew->QueryInterface(riid, ppOut));
        }
    }

    if (FAILED(hr))
    {
        delete pNew;
    }

    return hr;
} // CreateHostedTimeElement

HRESULT
CTIMEFactory::CreateTIMENamespaceElement (REFIID riid, LPUNKNOWN pUnk, LPWSTR wszTagSpecific, 
                                          void **ppBehavior)
{
    // The scope qualifier must be present.  It will not be present when 
    // the namespace is not declared in the page header.  In that case,
    // any code dependent on a proper scope name will silently fail.
    // We have no recourse against this happening.
    BSTR bstrScope = NULL;
    HRESULT hr = GetScopeName(pUnk, &bstrScope);

    if (0 == StrCmpIW(wszTagSpecific, WZ_MEDIA))
    {
        hr = CreateTIMEMediaElement(riid, MT_Media, ppBehavior);
    }
    else if (0 == StrCmpIW(wszTagSpecific, WZ_IMG) &&
            (0 != StrCmpIW(bstrScope, WZ_DEFAULT_SCOPE_NAME)))
    {
        hr = CreateTIMEMediaElement(riid, MT_Image, ppBehavior);
    }
    else if (0 == StrCmpIW(wszTagSpecific, WZ_AUDIO))
    {
        hr = CreateTIMEMediaElement(riid, MT_Audio, ppBehavior);
    }
    else if (0 == StrCmpIW(wszTagSpecific, WZ_VIDEO))
    {
        hr = CreateTIMEMediaElement(riid, MT_Video, ppBehavior);
    }
    else if (0 == StrCmpIW(wszTagSpecific, WZ_BODY))
    {
        hr = CreateTIMEBodyElement(riid, ppBehavior);
    }
    // By default, we glom onto an externally-created element.
    // This will work with html and other xml tags.
    else
    {
        hr = CreateHostedTimeElement(riid, ppBehavior);
    }

    ::SysFreeString(bstrScope);

    return hr;
} // CreateTIMENamespaceElement

STDMETHODIMP
CTIMEFactory::CreateTIMEElement(REFIID riid, LPUNKNOWN pUnk, void ** ppOut)
{
    CHECK_RETURN_SET_NULL(ppOut);
    
    IHTMLElement *pelmHost = NULL;
    HRESULT hr = GetHostElement(pUnk, &pelmHost);

    if (SUCCEEDED(hr))
    {
        BSTR bstrTag = NULL;
        
        hr = THR(pelmHost->get_tagName(&bstrTag));
        pelmHost->Release();
        if (SUCCEEDED(hr))
        {
            if (NULL != bstrTag)
            {
                hr = CreateTIMENamespaceElement(riid, pUnk, bstrTag, ppOut);
                ::SysFreeString(bstrTag);
            }
            else
            {
                hr = E_UNEXPECTED;
            }
        }
    }

    return hr;
} // CreateTIMEElement

STDMETHODIMP
CTIMEFactory::CreateTIMEBodyElement(REFIID riid, void ** ppOut)
{
    CHECK_RETURN_SET_NULL(ppOut);
    
    HRESULT hr;
    
    DAComObject<CTIMEBodyElement> *pNew;
    hr = DAComObject<CTIMEBodyElement>::CreateInstance(&pNew);

    if (!pNew) {
        THR(hr = E_OUTOFMEMORY);
    } else {
        if (SUCCEEDED(hr)) {
            THR(hr = pNew->QueryInterface(riid,
                                          ppOut));
        }
    }

    if (FAILED(hr))
        delete pNew;

    return hr;
}

STDMETHODIMP
CTIMEFactory::CreateTIMEDAElement(REFIID riid, void ** ppOut)
{
    CHECK_RETURN_SET_NULL(ppOut);
    
    HRESULT hr;
    
    DAComObject<CTIMEDAElement> *pNew;
    hr = DAComObject<CTIMEDAElement>::CreateInstance(&pNew);

    if (!pNew) {
        THR(hr = E_OUTOFMEMORY);
    } else {
        if (SUCCEEDED(hr)) {
            THR(hr = pNew->QueryInterface(riid,
                                          ppOut));
        }
    }

    if (FAILED(hr))
        delete pNew;

    return hr;
}

STDMETHODIMP
CTIMEFactory::CreateTIMEMediaElement(REFIID riid, MediaType type, void ** ppOut)
{
    CHECK_RETURN_SET_NULL(ppOut);
    
    HRESULT hr;
    
    DAComObject<CTIMEMediaElement> *pNew;
    hr = DAComObject<CTIMEMediaElement>::CreateInstance(&pNew);

    if (!pNew) {
        THR(hr = E_OUTOFMEMORY);
    } else {
        pNew->SetMediaType(type);
        if (SUCCEEDED(hr)) {
            THR(hr = pNew->QueryInterface(riid,
                                          ppOut));
        }
    }

    if (FAILED(hr))
        delete pNew;

    return hr;
}

// returns true if IUnknown contains a body element without a time behavior attatched.
bool CTIMEFactory::IsBodyElementWithoutTime(IUnknown *pUnkArg)
{
    bool fIsBody = false;

    HRESULT hr = E_FAIL;

    DAComPtr<IElementBehaviorSite>      pTempBehaviorSite;
    DAComPtr<IHTMLElement>              pTempElement;
    DAComPtr<IHTMLBodyElement>          pTempBody;
    
    hr = pUnkArg->QueryInterface(IID_IElementBehaviorSite, (void**)&pTempBehaviorSite);
    if (FAILED(hr))
    {
        goto done;
    }

    hr = pTempBehaviorSite->GetElement(&pTempElement);
    if (FAILED(hr))
    {
        goto done;
    }

    if (IsTIMEBodyElement(pTempElement))
    {
        goto done;
    }

    hr = pTempElement->QueryInterface(IID_IHTMLBodyElement, (void**)&pTempBody);
    if (FAILED(hr))
    {
        goto done;
    }
    
    fIsBody = true;
done:
    return fIsBody;
}


STDMETHODIMP 
CTIMEFactory::FindBehavior(LPOLESTR pchNameSpace,
                           LPOLESTR pchTagName,
                           IUnknown * pUnkArg,
                           IElementBehavior ** ppBehavior)
{
    TraceTag((tagFactory,
              "CTIMEFactory(%lx)::FindBehavior(%ls, %ls, %#x)",
              this, pchNameSpace, pchTagName, pUnkArg));

    // if we are in 16 or less color mode on the Primary Device, bail
    // Note: Multi-monitor API are currently unavailable in this build
    HWND hwndDesktop = NULL;
    hwndDesktop = GetDesktopWindow();
    if (NULL != hwndDesktop)
    {
        HDC hdcPrimaryDevice = NULL;
        hdcPrimaryDevice = GetDC(NULL);
        if (NULL != hdcPrimaryDevice)
        {
            int bpp = 32;
            bpp = GetDeviceCaps(hdcPrimaryDevice, BITSPIXEL);
            ReleaseDC(hwndDesktop, hdcPrimaryDevice);
            if (bpp <= 4)
            {
                // This prevents time bvrs from being created
                return E_FAIL;
            }
        }
    }

    CHECK_RETURN_SET_NULL(ppBehavior);

    HRESULT hr;

    if (IsBodyElementWithoutTime(pUnkArg))
    {
        hr = CreateTIMEBodyElement(IID_IElementBehavior,
                                   (void **) ppBehavior);
    }
    else if ((StrCmpIW(pchTagName, WZ_TIME_STYLE_PREFIX) == 0) ||
             (StrCmpIW(pchTagName, WZ_DEFAULT_TIME_STYLE_PREFIX) == 0))
    {
        hr = CreateTIMEElement(IID_IElementBehavior, pUnkArg,
                               (void **) ppBehavior);
    }
    else if ((StrCmpIW(pchTagName, WZ_TIMEDA_STYLE_PREFIX) == 0)  ||
             (StrCmpIW(pchTagName, WZ_DEFAULT_TIMEDA_STYLE_PREFIX) == 0))
    {
        hr = CreateTIMEDAElement(IID_IElementBehavior, (void **) ppBehavior);
    }
    else if ((StrCmpIW(pchTagName, WZ_TIMEMEDIA_STYLE_PREFIX) == 0)  ||
             (StrCmpIW(pchTagName, WZ_DEFAULT_TIMEMEDIA_STYLE_PREFIX) == 0))
    {
        hr = CreateTIMEMediaElement(IID_IElementBehavior,
                                   MT_Media,
                                   (void **) ppBehavior);
    }
    else
    {
        hr = E_NOTIMPL;
    }

    return hr;
}

STDMETHODIMP 
CTIMEFactory::GetInterfaceSafetyOptions(REFIID riid, DWORD *pdwSupportedOptions, DWORD *pdwEnabledOptions)
{
    if (pdwSupportedOptions == NULL || pdwEnabledOptions == NULL)
        return E_POINTER;
    HRESULT hr = S_OK;

    if (riid == IID_IDispatch)
    {
        *pdwSupportedOptions = INTERFACESAFE_FOR_UNTRUSTED_CALLER;
        *pdwEnabledOptions = m_dwSafety & INTERFACESAFE_FOR_UNTRUSTED_CALLER;
    }
    else if (riid == IID_IPersistPropertyBag2 )
    {
        *pdwSupportedOptions = INTERFACESAFE_FOR_UNTRUSTED_DATA;
        *pdwEnabledOptions = m_dwSafety & INTERFACESAFE_FOR_UNTRUSTED_DATA;
    }
    else
    {
        *pdwSupportedOptions = 0;
        *pdwEnabledOptions = 0;
        hr = E_NOINTERFACE;
    }
    return hr;
}

STDMETHODIMP
CTIMEFactory::SetInterfaceSafetyOptions(REFIID riid, DWORD dwOptionSetMask, DWORD dwEnabledOptions)
{       
        // If we're being asked to set our safe for scripting or
        // safe for initialization options then oblige
        if (riid == IID_IDispatch || riid == IID_IPersistPropertyBag2 )
        {
                // Store our current safety level to return in GetInterfaceSafetyOptions
                m_dwSafety = dwEnabledOptions & dwOptionSetMask;
                return S_OK;
        }

        return E_NOINTERFACE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\time\src\eventsync.cpp ===
///////////////////////////////////////////////////////////////
// Copyright (c) 1998 Microsoft Corporation
//
// File: EventSync.cpp
//
// Abstract:  
//
///////////////////////////////////////////////////////////////


#include "headers.h"
#include "eventmgr.h"
#include "mshtmdid.h"
#include "timeelm.h"
#include "eventsync.h"

DeclareTag(tagEventSync, "API", "Event Sync methods");

struct {
    ELEMENT_EVENT event;
    wchar_t * wsz_name;
} g_ElementEventNames[] =
{
    { EE_ONPROPCHANGE,         L"onpropertychange" },
    //add non-input related events to hook here
    { EE_ONREADYSTATECHANGE,   L"onreadystatechange" },
    { EE_ONMOUSEMOVE,          L"onmousemove" },
    { EE_ONMOUSEDOWN,          L"onmousedown" },
    { EE_ONMOUSEUP,            L"onmouseup" },
    { EE_ONKEYDOWN,            L"onkeydown" }, 
    { EE_ONKEYUP,              L"onkeyup" },
    { EE_ONBLUR,               L"onblur" }
    //add input events here
};

///////////////////////////////////////////////////////////////
//  Name: CEventSync
//  Parameters:
//    CTIMEElement  & elm
//                               This parameter must be passed
//                               to the constructor so that 
//                               we can get info from elm
//    CEventMgr *    pEventMgr
//                               This parameter is passed so 
//                               the eventsync can notify then
//                               parent EventMgr when events
//                               have occured.
//  Abstract:
//    Stash away the element so we can get the OM when we need it
///////////////////////////////////////////////////////////////
CEventSync::CEventSync(CTIMEElementBase & elm, CEventMgr *pEventMgr)
: m_elm(elm),
  m_pElement(NULL),
  m_refCount(0),
  m_pEventMgr(NULL)
{
    TraceTag((tagEventSync,
              "EventSync(%lx)::EventSync(%lx)",
              this,
              &elm));

    m_pEventMgr = pEventMgr;
}

///////////////////////////////////////////////////////////////
//  Name: ~CEventSync
//
//  Abstract:
//    Cleanup
///////////////////////////////////////////////////////////////
CEventSync::~CEventSync()
{
    TraceTag((tagEventSync,
              "EventSync(%lx)::~EventSync()",
              this));


}


///////////////////////////////////////////////////////////////
//  Name:  Init
//  Parameters:  None
//
//  Abstract:
//    Initializes the object
///////////////////////////////////////////////////////////////
HRESULT CEventSync::Init()
{
    HRESULT hr = S_OK;

    m_pElement = m_elm.GetElement();
    m_pElement->AddRef();
    
    hr = THR(AttachEvents());
    if (FAILED(hr))
    {
        goto done;
    }

  done:
    return hr;
}

///////////////////////////////////////////////////////////////
//  Name:  Init
//  Parameters:  None
//
//  Abstract:
//    Attaches to mouse and keyboard events
///////////////////////////////////////////////////////////////
HRESULT CEventSync::InitMouse()
{
    DAComPtr <IHTMLElement2> pElement2;
    HRESULT hr = S_OK;
    VARIANT_BOOL bSuccess;
    int i = 0;

    if (!m_pElement)
    {
        hr = E_FAIL;
        goto done;
    }

    hr = THR(m_pElement->QueryInterface(IID_IHTMLElement2, (void**)&pElement2));
    if (FAILED(hr))
    {
        goto done;
    }

    //attach to mouse events
    if (m_elm.GetView() && !m_elm.IsBody())
    {
        for (i = EE_ONREADYSTATECHANGE + 1; i < EE_MAX; i++)
        {
            hr = THR(pElement2->attachEvent(g_ElementEventNames[i].wsz_name, (IDispatch *)this, &bSuccess)) ;
            if (FAILED(hr))
            {
                goto done;
            }
        }   
    }
    
  done:
    return hr;
}

///////////////////////////////////////////////////////////////
//  Name:  Deinit
//  Parameters:  None
//
//  Abstract:
//    Cleans up the object
///////////////////////////////////////////////////////////////
HRESULT CEventSync::Deinit()
{
    HRESULT hr = S_OK;

    hr = THR(DetachEvents());

    if (m_pElement)
    {
        m_pElement->Release();
        m_pElement = NULL;
    }

    if (m_dwElementEventConPtCookie != 0 && m_pElementConPt)
    {
        m_pElementConPt->Unadvise(m_dwElementEventConPtCookie);
    }

    return hr;
}


///////////////////////////////////////////////////////////////
//  Name: AddRef
// 
//  Abstract:
//    
///////////////////////////////////////////////////////////////
STDMETHODIMP_(ULONG) CEventSync::AddRef(void)
{
    return m_elm.InternalAddRef();
}

///////////////////////////////////////////////////////////////
//  Name: Release
// 
//  Abstract:
//    
///////////////////////////////////////////////////////////////
STDMETHODIMP_(ULONG) CEventSync::Release(void)
{
    return m_elm.InternalRelease();
}



///////////////////////////////////////////////////////////////
//  Name: GetTypeInfoCount
// 
//  Abstract:
//    Stubbed to allow this object to inherit for IDispatch
///////////////////////////////////////////////////////////////
STDMETHODIMP CEventSync::GetTypeInfoCount(UINT* /*pctinfo*/)
{
    return E_NOTIMPL;
}

///////////////////////////////////////////////////////////////
//  Name: GetTypeInfo
// 
//  Abstract:
//    Stubbed to allow this object to inherit for IDispatch
///////////////////////////////////////////////////////////////
STDMETHODIMP CEventSync::GetTypeInfo(/* [in] */ UINT /*iTInfo*/,
                                   /* [in] */ LCID /*lcid*/,
                                   /* [out] */ ITypeInfo** /*ppTInfo*/)
{
    return E_NOTIMPL;
}

///////////////////////////////////////////////////////////////
//  Name: GetIDsOfNames
// 
//  Abstract:
//    Stubbed to allow this object to inherit for IDispatch
///////////////////////////////////////////////////////////////
STDMETHODIMP CEventSync::GetIDsOfNames(
    /* [in] */ REFIID /*riid*/,
    /* [size_is][in] */ LPOLESTR* /*rgszNames*/,
    /* [in] */ UINT /*cNames*/,
    /* [in] */ LCID /*lcid*/,
    /* [size_is][out] */ DISPID* /*rgDispId*/)
{
    return E_NOTIMPL;
}

///////////////////////////////////////////////////////////////
//  Name: Invoke
// 
//  Abstract:
//     dispIdMember is always 0 so this Invoke switches on the
//     name of the event that causes the callback.
///////////////////////////////////////////////////////////////
STDMETHODIMP CEventSync::Invoke(
    /* [in] */ DISPID dispIdMember,
    /* [in] */ REFIID /*riid*/,
    /* [in] */ LCID /*lcid*/,
    /* [in] */ WORD /*wFlags*/,
    /* [out][in] */ DISPPARAMS* pDispParams,
    /* [out] */ VARIANT* pvarResult,
    /* [out] */ EXCEPINFO* /*pExcepInfo*/,
    /* [out] */ UINT* puArgErr)
{
    // Listen for the two events we're interested in, and call back if necessary
    HRESULT hr = S_OK;
    DAComPtr <IHTMLEventObj> pEventObj;
    BSTR bstrEventName;

    //get the event object from the IDispatch passed in
    hr = THR((pDispParams->rgvarg[0].pdispVal)->QueryInterface(IID_IHTMLEventObj, (void**)&pEventObj));
    if (FAILED(hr))
    {
        goto done;
    }
    
    //get the event name
    hr = THR(pEventObj->get_type(&bstrEventName));
    if (FAILED(hr))
    {
        goto done;
    }

    //handle the MouseMove event
    if (StrCmpIW (bstrEventName, g_ElementEventNames[EE_ONMOUSEMOVE].wsz_name + 2) == 0)
    {
        NotifyMouseMove(pEventObj);
    }
    //handle the MouseDown event
    else if (StrCmpIW (bstrEventName, g_ElementEventNames[EE_ONMOUSEDOWN].wsz_name + 2) == 0)
    {
        NotifyMouseDown(pEventObj);
    }
    //handle the MouseUp event
    else if (StrCmpIW (bstrEventName, g_ElementEventNames[EE_ONMOUSEUP].wsz_name + 2) == 0)
    {
        NotifyMouseUp(pEventObj);
    }
    //handle the KeyDown event
    else if (StrCmpIW (bstrEventName, g_ElementEventNames[EE_ONKEYDOWN].wsz_name + 2) == 0)
    {
        NotifyKeyDown(pEventObj);
    }
    //handle the KeyUp event
    else if (StrCmpIW (bstrEventName, g_ElementEventNames[EE_ONKEYUP].wsz_name + 2) == 0)
    {
        NotifyKeyUp(pEventObj);
    }
    //handle the Blur event
    else if (StrCmpIW (bstrEventName, g_ElementEventNames[EE_ONBLUR].wsz_name + 2) == 0)
    {
        m_pEventMgr->KeyEvent(TRUE, TRUE, FALSE, FALSE, FALSE, 0, 0);
    }
    //handle the PropertyChange event
    else if (StrCmpIW(bstrEventName, g_ElementEventNames[EE_ONPROPCHANGE].wsz_name + 2) == 0)
    {
        NotifyPropertyChange(pEventObj);
    }
    //handle the OnReadyStateChange event
    else if (StrCmpIW(bstrEventName, g_ElementEventNames[EE_ONREADYSTATECHANGE].wsz_name + 2) == 0)
    {
        NotifyReadyState(pEventObj);
    }
    
    //return TRUE
    VARIANT vReturnVal;
    VariantInit(&vReturnVal);
    vReturnVal.vt = VT_BOOL;
    vReturnVal.boolVal = VARIANT_TRUE;
    pEventObj->put_returnValue(vReturnVal);

    SysFreeString(bstrEventName);

  done:
    return S_OK;
}

///////////////////////////////////////////////////////////////
//  Name: QueryInterface
// 
//  Abstract:
//    This QI only handles the IDispatch for HTMLElementEvents
//    and returns this as the interface.
///////////////////////////////////////////////////////////////
STDMETHODIMP CEventSync::QueryInterface( REFIID riid, void **ppv )
{
    if (NULL == ppv)
        return E_POINTER;

    *ppv = NULL;

    if ( InlineIsEqualGUID(riid, IID_IDispatch))
    {
        *ppv = this;
    }
        
    if ( NULL != *ppv )
    {
        ((LPUNKNOWN)*ppv)->AddRef();
        return NOERROR;
    }
    return E_NOINTERFACE;
}


///////////////////////////////////////////////////////////////
//  Name: AttachEvents
// 
//  Abstract:
//    Hooks all the trident events that we are interested in.
//    automatically hooks non-mouse events.  Only hooks the mouse
//    events if they are relevant to the behavior.
///////////////////////////////////////////////////////////////
HRESULT CEventSync::AttachEvents()
{
    DAComPtr <IHTMLElement2> pElement2;
    HRESULT hr = S_OK;
    VARIANT_BOOL bSuccess;
    int i = 0;

    if (!m_pElement)
    {
        hr = E_FAIL;
        goto done;
    }

    hr = THR(m_pElement->QueryInterface(IID_IHTMLElement2, (void**)&pElement2));
    if (FAILED(hr))
    {
        goto done;
    }

    //register for events that all sync's need.
    for (i = 0; i <= EE_ONREADYSTATECHANGE; i++)
    {
        hr = THR(pElement2->attachEvent(g_ElementEventNames[i].wsz_name, (IDispatch *)this, &bSuccess)) ;
        if (FAILED(hr))
        {
            goto done;
        }
    }

  done:
    return hr;  
}


///////////////////////////////////////////////////////////////
//  Name: DetachEvents
// 
//  Abstract:
//    Detaches from all events to allow clean shutdown.
///////////////////////////////////////////////////////////////
HRESULT CEventSync::DetachEvents()
{
    DAComPtr <IHTMLElement2> pElement2;
    HRESULT hr = S_OK;
    int i = 0;

    if (!m_pElement)
    {
        hr = E_FAIL;
        goto done;
    }

    hr = THR(m_pElement->QueryInterface(IID_IHTMLElement2, (void**)&pElement2));
    if (FAILED(hr))
    {
        goto done;
    }

    
    //detach from events that all sync's need.
    for (i = 0; i <= EE_ONREADYSTATECHANGE; i++)
    {
        //attach to the onreadystatechangeevent
        hr = THR(pElement2->detachEvent(g_ElementEventNames[i].wsz_name, (IDispatch *)this)) ;
        if (FAILED(hr))
        {
            goto done;
        }
    }
    
    //detach from mouse events
    if (m_elm.GetView() && !m_elm.IsBody())
    {
        for (i = EE_ONREADYSTATECHANGE + 1; i < EE_MAX; i++)
        {
            //attach to the onreadystatechangeevent
            hr = THR(pElement2->detachEvent(g_ElementEventNames[i].wsz_name, (IDispatch *)this));
            if (FAILED(hr))
            {
                goto done;
            }
        }   
    }

  done:
    return hr;  
}


///////////////////////////////////////////////////////////////
//  Name: NotifyReadyState
// 
//  Parameters
//    IHTMLEventObj *pEventObj    A pointer to the event object
//                                that was passed to IDispatch::Invoke.
//
//  Abstract:
//    Determines the ready state that caused the ReadyStateChange
//    event and calls the EventManager to handle the new ready
//    state.
///////////////////////////////////////////////////////////////
HRESULT CEventSync::NotifyReadyState(IHTMLEventObj *pEventObj)
{
    HRESULT hr = S_OK;
    DAComPtr <IHTMLElement> pElement;
    DAComPtr <IHTMLElement2> pElement2;
    DAComPtr <IHTMLEventObj2> pEventObj2;
    VARIANT vReadyState;
    
    hr = THR(pEventObj->QueryInterface(IID_IHTMLEventObj2, (void **)&pEventObj2));
    if (FAILED(hr))
    {
        goto done;
    }

    hr = THR(pEventObj2->get_srcElement(&pElement));
    if (FAILED(hr))
    {
        goto done;
    }

    hr = THR(pElement->QueryInterface(IID_IHTMLElement2, (void **)&pElement2));
    if (FAILED(hr))
    {
        goto done;
    }
    
    VariantInit(&vReadyState);
    hr = THR(pElement2->get_readyState(&vReadyState));
    if (FAILED(hr))
    {
        goto done;
    }

    //if this is not a valid ready state, get the parent element's readystate.
    if (vReadyState.vt != VT_BSTR)
    {
        DAComPtr <IHTMLElement> pParentEle;
        DAComPtr <IHTMLElement2> pParentEle2;

        hr = THR(pElement->get_parentElement(&pParentEle));
        if (FAILED (hr))
        {
            goto done;
        }

        hr = THR(pParentEle->QueryInterface(IID_IHTMLElement2, (void **)&pParentEle2));
        if (FAILED (hr))
        {
            goto done;
        }

        VariantClear(&vReadyState);
        hr = THR(pParentEle2->get_readyState(&vReadyState));
        if (FAILED(hr))
        {
            goto done;
        }

    }
    m_pEventMgr->ReadyStateChange(vReadyState.bstrVal);
    VariantClear(&vReadyState);

  done:
    return hr;
}



///////////////////////////////////////////////////////////////
//  Name: NotifyPropertyChange
// 
//  Parameters
//    IHTMLEventObj *pEventObj    A pointer to the event object
//                                that was passed to IDispatch::Invoke.
//
//  Abstract:
//    Determines the ready state that caused the PropertyChange
//    event and calls the EventManager to handle the property
//    change.
///////////////////////////////////////////////////////////////
HRESULT CEventSync::NotifyPropertyChange(IHTMLEventObj *pEventObj)
{
    HRESULT hr = S_OK;

    DAComPtr <IHTMLEventObj2> pEventObj2;
    DAComPtr <IHTMLElement> pElement;
    BSTR bstrPropertyName;

    hr = THR(pEventObj->QueryInterface(IID_IHTMLEventObj2, (void **)&pEventObj2));
    if (FAILED(hr))
    {
        goto done;
    }
    
    //get the property name
    hr = THR(pEventObj2->get_propertyName(&bstrPropertyName));
    if (FAILED(hr))
    {
        goto done;
    }

    m_pEventMgr->PropertyChange(bstrPropertyName);
    SysFreeString(bstrPropertyName);
  
  done:
    return hr;

}


///////////////////////////////////////////////////////////////
//  Name: NotifyMouseMove
// 
//  Abstract:
//    This functions gets all the relevent information 
//    about a mouse move event from the event object
//    and notifies the event manager ofthe event.  
///////////////////////////////////////////////////////////////
HRESULT CEventSync::NotifyMouseMove(IHTMLEventObj *pEventObj)
{
    long x;
    long y;
    VARIANT_BOOL bShiftKeyPressed;
    VARIANT_BOOL bAltKeyPressed;
    VARIANT_BOOL bCtrlKeyPressed;
    HRESULT hr = S_OK;

    hr = THR(pEventObj->get_x(&x));
    hr = THR(pEventObj->get_y(&y));
    hr = THR(pEventObj->get_shiftKey(&bShiftKeyPressed));
    hr = THR(pEventObj->get_altKey(&bAltKeyPressed));
    hr = THR(pEventObj->get_ctrlKey(&bCtrlKeyPressed));

    m_pEventMgr->MouseEvent(x, 
                            y, 
                            TRUE,
                            FALSE,
                            bShiftKeyPressed, 
                            bAltKeyPressed, 
                            bCtrlKeyPressed,
                            0);

    return hr;
}

///////////////////////////////////////////////////////////////
//  Name: NotifyMouseUp
// 
//  Abstract:
//    This functions gets all the relevent information 
//    about a mouse up event from the event object
//    and notifies the event manager ofthe event.
///////////////////////////////////////////////////////////////
HRESULT CEventSync::NotifyMouseUp(IHTMLEventObj *pEventObj)
{
    
    long x;
    long y;
    VARIANT_BOOL bShiftKeyPressed;
    VARIANT_BOOL bAltKeyPressed;
    VARIANT_BOOL bCtrlKeyPressed;
    long Button;
    HRESULT hr = S_OK;

    hr = THR(pEventObj->get_x(&x));
    hr = THR(pEventObj->get_y(&y));
    hr = THR(pEventObj->get_shiftKey(&bShiftKeyPressed));
    hr = THR(pEventObj->get_altKey(&bAltKeyPressed));
    hr = THR(pEventObj->get_ctrlKey(&bCtrlKeyPressed));
    hr = THR(pEventObj->get_button(&Button));
    
    m_pEventMgr->MouseEvent(x, 
                            y, 
                            FALSE,
                            TRUE,
                            bShiftKeyPressed, 
                            bAltKeyPressed, 
                            bCtrlKeyPressed,
                            Button);

    return hr;
}

///////////////////////////////////////////////////////////////
//  Name: NotifyMouseDown
// 
//  Abstract:
//    This functions gets all the relevent information 
//    about a mouse down event from the event object
//    and notifies the event manager ofthe event.
///////////////////////////////////////////////////////////////
HRESULT CEventSync::NotifyMouseDown(IHTMLEventObj *pEventObj)
{
    
    long x;
    long y;
    VARIANT_BOOL bShiftKeyPressed;
    VARIANT_BOOL bAltKeyPressed;
    VARIANT_BOOL bCtrlKeyPressed;
    long Button;
    HRESULT hr = S_OK;

    hr = THR(pEventObj->get_x(&x));
    hr = THR(pEventObj->get_y(&y));
    hr = THR(pEventObj->get_shiftKey(&bShiftKeyPressed));
    hr = THR(pEventObj->get_altKey(&bAltKeyPressed));
    hr = THR(pEventObj->get_ctrlKey(&bCtrlKeyPressed));
    hr = THR(pEventObj->get_button(&Button));

    m_pEventMgr->MouseEvent(x, 
                            y, 
                            FALSE,
                            FALSE,
                            bShiftKeyPressed, 
                            bAltKeyPressed, 
                            bCtrlKeyPressed,
                            Button);

    return hr;
}

///////////////////////////////////////////////////////////////
//  Name: NotifyKeyDown
// 
//  Abstract:
//    This functions gets all the relevent information 
//    about a key down event from the event object
//    and notifies the event manager ofthe event.
///////////////////////////////////////////////////////////////
HRESULT CEventSync::NotifyKeyDown(IHTMLEventObj *pEventObj)
{
    DAComPtr <IHTMLEventObj2> pEventObj2;
    VARIANT_BOOL bShiftKeyPressed;
    VARIANT_BOOL bAltKeyPressed;
    VARIANT_BOOL bCtrlKeyPressed;
    long KeyCode;
    long RepeatCount = 0;
    HRESULT hr = S_OK;

    hr = THR(pEventObj->get_shiftKey(&bShiftKeyPressed));
    hr = THR(pEventObj->get_altKey(&bAltKeyPressed));
    hr = THR(pEventObj->get_ctrlKey(&bCtrlKeyPressed));
    hr = THR(pEventObj->get_keyCode(&KeyCode));
    
    //determine if this is a repeat keypress.
    hr = THR(pEventObj->QueryInterface(IID_IHTMLEventObj2, (void **)&pEventObj2));
    if (SUCCEEDED(hr))
    {
        VARIANT_BOOL bRepeat;
        hr = THR(pEventObj2->get_repeat(&bRepeat));
        if (SUCCEEDED(hr) && bRepeat)
        {
            RepeatCount = 1;
        }
    }
    
    m_pEventMgr->KeyEvent(FALSE,
                          FALSE,
                          bShiftKeyPressed,
                          bAltKeyPressed,
                          bCtrlKeyPressed,
                          KeyCode,
                          RepeatCount);

    return hr;
}

///////////////////////////////////////////////////////////////
//  Name: NotifyKeyUp
// 
//  Abstract:
//    This functions gets all the relevent information 
//    about a key up event from the event object
//    and notifies the event manager ofthe event.
///////////////////////////////////////////////////////////////
HRESULT CEventSync::NotifyKeyUp(IHTMLEventObj *pEventObj)
{
    VARIANT_BOOL bShiftKeyPressed;
    VARIANT_BOOL bAltKeyPressed;
    VARIANT_BOOL bCtrlKeyPressed;
    long KeyCode;

    HRESULT hr = S_OK;

    hr = THR(pEventObj->get_shiftKey(&bShiftKeyPressed));
    hr = THR(pEventObj->get_altKey(&bAltKeyPressed));
    hr = THR(pEventObj->get_ctrlKey(&bCtrlKeyPressed));
    hr = THR(pEventObj->get_keyCode(&KeyCode));
    
    m_pEventMgr->KeyEvent(FALSE,
                          TRUE,
                          bShiftKeyPressed,
                          bAltKeyPressed,
                          bCtrlKeyPressed,
                          KeyCode,
                          0);
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\time\src\htmlimg.cpp ===
/*******************************************************************************
 *
 * Copyright (c) 1998 Microsoft Corporation
 *
 * File: htmlimg.cpp
 *
 * Abstract:
 *
 *
 *
 *******************************************************************************/


#include "headers.h"
#include "htmlimg.h"

DeclareTag(tagHTMLImg, "API", "HTML Image methods");

HTMLImage::HTMLImage()
{
    TraceTag((tagHTMLImg,
              "HTMLImage(%lx)::HTMLImage()",
              this));
}

HTMLImage::~HTMLImage()
{
    TraceTag((tagHTMLImg,
              "HTMLImage(%lx)::~HTMLImage()",
              this));
}

HRESULT
HTMLImage::Init()
{
    TraceTag((tagHTMLImg,
              "HTMLImage(%lx)::Init()",
              this));
    
    HRESULT hr;
    
    // Create the basic DAImage as an empty image and wait for the
    // first draw to do something with it.
    
    {
        CRLockGrabber __gclg;
        m_image = (CRImagePtr) CRModifiableBvr((CRBvrPtr) CREmptyImage(),0);
        
        if (!m_image)
        {
            TraceTag((tagError,
                      "HTMLImage(%lx)::Init(): Failed to create image switcher - %hr, %ls",
                      this,
                      CRGetLastError(),
                      CRGetLastErrorString()));
            
            hr = CRGetLastError();
            goto done;
        }
    }

    hr = S_OK;
    
  done:
    return hr;
}


HRESULT
HTMLImage::SetSize(DWORD width, DWORD height)
{
    HRESULT hr;

    if (!m_ddsurf ||
        width != m_width ||
        height != m_height)
    {
        m_ddsurf.Release();

        hr = THR(CreateOffscreenSurface(NULL,
                                        &m_ddsurf,
                                        NULL,
                                        false,
                                        width,
                                        height));

        if (FAILED(hr))
        {
            TraceTag((tagError,
                      "HTMLImage(%lx)::Update: CreateOffscreenSurface failed - %hr",
                      this,
                      hr));

            goto done;
        }

        m_width = width;
        m_height = height;
    }
    
    hr = S_OK;
  done:
    return hr;
}


HRESULT
HTMLImage::Paint(HDC hdc, LPRECT prc)
{
    TraceTag((tagHTMLImg,
              "HTMLImage(%lx)::Paint(%lx, (%d, %d, %d, %d))",
              this,
              hdc,
              prc->left,
              prc->top,
              prc->right,
              prc->bottom));
    
    HRESULT hr;

    RECT destRect = { 0, 0, m_width, m_height };

    TraceTag((tagHTMLImg,
              "HTMLImage(%lx)::Paint - clipbox(%d, %d, %d, %d)",
              this,
              destRect.left,destRect.top,destRect.right,destRect.bottom));
    
    hr = CopyDCToDdrawSurface(hdc,
                              prc,
                              m_ddsurf,
                              &destRect);
                              
    if (FAILED(hr))
    {
        TraceTag((tagError,
                  "HTMLImage(%lx)::Paint: CopyDCToDdrawSurface failed - %hr",
                  this,
                  hr));
        
        goto done;
    }

    hr = Update();
  done:
    return hr;
}


HRESULT
HTMLImage::Update()
{
    TraceTag((tagHTMLImg,
              "HTMLImage(%lx)::Update()",
              this));
    
    HRESULT hr;

    CRImagePtr newimg;

    {
        CRLockGrabber __gclg;
        
        newimg = CRImportDirectDrawSurface (m_ddsurf, NULL);
        
        if (newimg == NULL)
        {
            TraceTag((tagError,
                      "HTMLImage(%lx)::Update(): Failed to import ddraw surface - %hr, %ls",
                      this,
                      CRGetLastError(),
                      CRGetLastErrorString()));
            
            hr = CRGetLastError();
            goto done;
        }
        
        if (!CRSwitchTo((CRBvrPtr) m_image.p,
                        (CRBvrPtr) newimg,
                        false,
                        0,
                        0.0))
        {
            TraceTag((tagError,
                      "HTMLImage(%lx)::Update(): Failed to switch import ddraw surface - %hr, %ls",
                      this,
                      CRGetLastError(),
                      CRGetLastErrorString()));
            
            hr = CRGetLastError();
            goto done;
        }
    }
                    
    hr = S_OK;
  done:
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\time\src\htmlimg.h ===
/*******************************************************************************
 *
 * Copyright (c) 1998 Microsoft Corporation
 *
 * File: htmlimg.h
 *
 * Abstract:
 *
 *
 *
 *******************************************************************************/


#ifndef _HTMLIMG_H
#define _HTMLIMG_H

/////////////////////////////////////////////////////////////////////////////
// HTMLImage

class HTMLImage
{
  public:
    HTMLImage();
    ~HTMLImage();
    
    HRESULT Init();
    HRESULT SetSize(DWORD width, DWORD height);
    HRESULT Paint(HDC hdc, LPRECT rect);
    HRESULT Update();

    CRImagePtr GetImage() { return m_image; }
    
  protected:
    CRPtr<CRImage>               m_image;
    DWORD                        m_width;
    DWORD                        m_height;
    DAComPtr<IDirectDrawSurface> m_ddsurf; 
};

#endif /* _HTMLIMG_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\time\src\init.cpp ===
// Init.cpp : Implementation of CTIMEInit
#include "headers.h"
#include "init.h"

CTIMEInit::CTIMEInit(REFGUID iid) :
m_iid(iid)
{
}



STDMETHODIMP CTIMEInit::Init(IElementBehaviorSite * pBehaviorSite)
{
    HRESULT hRes = S_OK; 
    char **params;
    int  numParams;

    // save off the site..
    m_pBehaviorSite = pBehaviorSite;

    GetParamArray(params, numParams);

    IHTMLElement *element = NULL;
    // Get IHTMLElement so we can read off the tag info.
    if(SUCCEEDED(hRes)) {
        
        pBehaviorSite->GetElement(&element);
        
        // now run though the elements....

        // We know what tags we support, so get the data from them.
        USES_CONVERSION;
        CComVariant v;

        for(int i=0; i< numParams; i++) {
            BSTR bstrRet = SysAllocString( A2W(params[i]) );
            if(SUCCEEDED(element->getAttribute(bstrRet,0,&v))) {
                // we were able to get the element data so set it
                DISPID rgdispid;                
                if(SUCCEEDED(GetIDsOfNames(m_iid,
                                           &bstrRet,
                                           1,
                                           GetUserDefaultLCID(),
                                           &rgdispid))) {
                
                    UINT* puArgErr = 0;
                    DISPID propPutDispid = DISPID_PROPERTYPUT;
                    DISPPARAMS dispparams;
                
                    dispparams.rgvarg = &v;
                    dispparams.rgdispidNamedArgs = &propPutDispid;
                    dispparams.cArgs = 1;
                    dispparams.cNamedArgs = 1;

                    Invoke(rgdispid,
                            m_iid,
                            GetUserDefaultLCID(),
                            DISPATCH_PROPERTYPUT,
                            &dispparams,
                            NULL,
                            NULL,
                            puArgErr);
                }
            }
            SysFreeString(bstrRet);
        }   // end of for
    }
    return hRes;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\time\src\init.h ===
// init.h : Declaration of the CTIMEInit

#ifndef __TIMEINIT_H_
#define __TIMEINIT_H_

/////////////////////////////////////////////////////////////////////////////
// CTIMEInit


class CTIMEInit :   
    public IElementBehavior,
    public IElementBehaviorRender
{
  public:
    CTIMEInit(REFGUID iid);
    STDMETHOD(Init)(IElementBehaviorSite * pBehaviorSite);
    IElementBehaviorSite *GetElementBehaviorSite(){return m_pBehaviorSite;};

    // virtual functions 
    STDMETHOD(GetIDsOfNames)(
        REFIID      riid,
        LPOLESTR *  rgszNames,
        UINT        cNames,
        LCID        lcid,
        DISPID *    rgdispid) = 0;

    STDMETHOD(Invoke)(
        DISPID          dispid, 
        REFIID          riid, 
        LCID            lcid, 
        WORD            wFlags, 
        DISPPARAMS *    pDispParams, 
        VARIANT *       pVarResult, 
        EXCEPINFO *     pExcepInfo, 
        unsigned int *  puArgErr) = 0;

     virtual void GetParamArray(char **&params, int &numParams)=0;

  public:
    REFGUID m_iid;
    DAComPtr<IElementBehaviorSite> m_pBehaviorSite;
};


#endif //__TIMEINIT_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\time\src\mmutil.cpp ===
/*******************************************************************************
 *
 * Copyright (c) 1998 Microsoft Corporation
 *
 * File: mmutil.cpp
 *
 * Abstract:
 *
 *
 *
 *******************************************************************************/

#include "headers.h"
#include "mmutil.h"
#include "timeelm.h"
#include "bodyelm.h"

// Suppress new warning about NEW without corresponding DELETE 
// We expect GCs to cleanup values.  Since this could be a useful
// warning, we should disable this on a file by file basis.
#pragma warning( disable : 4291 )  

DeclareTag(tagMMUTILBvr, "API", "MMBvr methods");
DeclareTag(tagMMUTILBaseBvr, "API", "MMBaseBvr methods");
DeclareTag(tagMMUTILPlayer, "API", "MMPlayer methods");
DeclareTag(tagMMUTILFactory, "API", "MMFactory methods");
DeclareTag(tagMMUTILTimeline, "API", "MMTimeline methods");
DeclareTag(tagMMUTILView, "API", "MMView methods");

ITIMEMMFactory * MMFactory::s_factory = NULL;
LONG MMFactory::s_refcount = 0;

MMBaseBvr::MMBaseBvr(CTIMEElementBase & elm, bool bFireEvents)
: m_elm(elm),
  m_bFireEvents(bFireEvents)
{
    TraceTag((tagMMUTILBaseBvr,
              "MMBaseBvr(%lx)::MMBaseBvr(%lx,%d)",
              this,
              &elm,
              bFireEvents));

    MMFactory::AddRef();
}

MMBaseBvr::~MMBaseBvr()
{
    TraceTag((tagMMUTILBaseBvr,
              "MMBaseBvr(%lx)::~MMBaseBvr()",
              this));

    if (m_eventCB)
    {
        m_eventCB->SetMMBvr(NULL);
        m_eventCB.Release();
    }

    MMFactory::Release();
}

bool
MMBaseBvr::Init()
{
    TraceTag((tagMMUTILBaseBvr,
              "MMBaseBvr(%lx)::Init()",
              this));

    bool ok = false;
    
    if (MMFactory::GetFactory() == NULL)
    {
        CRSetLastError(E_FAIL, NULL);
        goto done;
    }
    
    if (m_bFireEvents)
    {
        m_eventCB = NEW TIMEEventCB;
        
        if (!m_eventCB)
        {
            CRSetLastError(E_OUTOFMEMORY, NULL);
            goto done;
        }
        
        m_eventCB->SetMMBvr(this);
    }
    
    ok = true;
  done:
    return ok;
}

bool
MMBaseBvr::Begin(bool bAfterOffset)
{
    TraceTag((tagMMUTILBaseBvr,
              "MMBaseBvr(%lx)::Begin(%d)",
              this,
              bAfterOffset));

    bool ok = false;
    HRESULT hr;
    
    Assert(m_bvr);
    
    hr = THR(m_bvr->Begin(bAfterOffset?VARIANT_TRUE:VARIANT_FALSE));

    if (FAILED(hr))
    {
        CRSetLastError(hr, NULL);
        goto done;
    }

    ok = true;
  done:
    return ok;
}

bool
MMBaseBvr::Reset(DWORD fCause)
{
    TraceTag((tagMMUTILBaseBvr,
              "MMBaseBvr(%lx)::Begin(%d)",
              this));

    bool ok = false;
    HRESULT hr;
    
    Assert(m_bvr);
    
    hr = THR(m_bvr->Reset(fCause));

    if (FAILED(hr))
    {
        CRSetLastError(hr, NULL);
        goto done;
    }

    ok = true;
  done:
    return ok;
}

bool
MMBaseBvr::End()
{
    TraceTag((tagMMUTILBaseBvr,
              "MMBaseBvr(%lx)::End()",
              this));

    bool ok = false;
    HRESULT hr;
    
    if (m_bvr)
    {
        // Do not put a THR since this will fail a lot since we call
        // end to do all cleanup
        hr = m_bvr->End();
        
        if (FAILED(hr))
        {
            CRSetLastError(hr, NULL);
            goto done;
        }
    }

    ok = true;
  done:
    return ok;
}

bool
MMBaseBvr::Pause()
{
    TraceTag((tagMMUTILBaseBvr,
              "MMBaseBvr(%lx)::Pause()",
              this));

    bool ok = false;
    HRESULT hr;
    
    Assert(m_bvr);
    hr = THR(m_bvr->Pause());

    if (FAILED(hr))
    {
        CRSetLastError(hr, NULL);
        goto done;
    }

    ok = true;
  done:
    return ok;
}

bool
MMBaseBvr::Resume()
{
    TraceTag((tagMMUTILBaseBvr,
              "MMBaseBvr(%lx)::Resume()",
              this));

    bool ok = false;
    HRESULT hr;
    
    Assert(m_bvr);
    hr = THR(m_bvr->Run());

    if (FAILED(hr))
    {
        CRSetLastError(hr, NULL);
        goto done;
    }

    ok = true;
  done:
    return ok;
}

bool
MMBaseBvr::Seek(double time)
{
    TraceTag((tagMMUTILBaseBvr,
              "MMBaseBvr(%lx)::Seek(%g)",
              this));

    bool ok = false;
    HRESULT hr;
    
    Assert(m_bvr);
    hr = THR(m_bvr->Seek(time));

    if (FAILED(hr))
    {
        CRSetLastError(hr, NULL);
        goto done;
    }

    ok = true;
  done:
    return ok;
}

double
MMBaseBvr::GetLocalTime()
{
    TraceTag((tagMMUTILBaseBvr,
              "MMBaseBvr(%lx)::GetLocalTime()",
              this));

    double d = 0;
    
    if (m_bvr)
    {
        THR(m_bvr->get_LocalTime(&d));
    }

    return d;
}

double
MMBaseBvr::GetSegmentTime()
{
    TraceTag((tagMMUTILBaseBvr,
              "MMBaseBvr(%lx)::GetSegmentTime()",
              this));

    double d = 0;
    
    if (m_bvr)
    {
        THR(m_bvr->get_SegmentTime(&d));
    }

    return d;
}

MM_STATE
MMBaseBvr::GetPlayState()
{
    TraceTag((tagMMUTILBaseBvr,
              "MMBaseBvr(%lx)::GetPlayState()",
              this));

    MM_STATE s = MM_STOPPED_STATE;
    
    if (m_bvr)
    {
        THR(m_bvr->get_PlayState(&s));
    }

    return s;
}

bool
MMBaseBvr::Update()
{
    TraceTag((tagMMUTILBvr,
              "MMBaseBvr(%lx)::Update()",
              this));

    bool ok = false;
    // TODO: For now comment out - we need to get reset working otherwise this
    // never gets reset
    // End();
        
    // Now update the properties
    IGNORE_HR(m_bvr->put_StartOffset(m_elm.GetRealBeginTime()));
    IGNORE_HR(m_bvr->put_Duration(m_elm.GetRealDuration()));

    // Calc a decent number of repeats
    int reps;

    if (m_elm.GetRealRepeatTime() == HUGE_VAL)
    {
        reps = 0;
    }
    else if (m_elm.GetRealDuration() == HUGE_VAL)
    {
        reps = 1;
    }
    else
    {
        reps = ceil(m_elm.GetRealRepeatTime() /
                    m_elm.GetRealIntervalDuration());
    }
    
    IGNORE_HR(m_bvr->put_Repeat(reps));
    IGNORE_HR(m_bvr->put_RepeatDur(m_elm.GetRealRepeatTime()));

    // BUGBUG : Eventually change the corresponding names on mmapi.
    IGNORE_HR(m_bvr->put_EaseIn(m_elm.GetFractionalAcceleration()));
    IGNORE_HR(m_bvr->put_EaseOut(m_elm.GetFractionalDeceleration()));
    // Force defaults on the start/end values.
    IGNORE_HR(m_bvr->put_EaseInStart(0));
    IGNORE_HR(m_bvr->put_EaseOutEnd(0));

    IGNORE_HR(m_bvr->put_AutoReverse(m_elm.GetAutoReverse()));

    DWORD syncflags;

    syncflags = 0;

    if (m_elm.IsLocked())
    {
        syncflags |= MM_LOCKED;
    }
    
    if (m_elm.NeedSyncCB())
    {
        syncflags |= MM_CLOCKSOURCE;
    }
    
    IGNORE_HR(m_bvr->put_SyncFlags(syncflags));
    
    float fltEndOffset = 0.0f;
    if (m_elm.GetEndHold())
    {
        fltEndOffset = HUGE_VAL;
    }
    IGNORE_HR(m_bvr->put_EndOffset(fltEndOffset));

    // Get the total time from the behavior
    IGNORE_HR(m_bvr->get_TotalTime(&m_totalTime));
    
    // Add my callback
    IGNORE_HR(m_bvr->put_EventCB(m_eventCB));
    
    ok = true;

    return ok;
}

MMBaseBvr::TIMEEventCB::TIMEEventCB()
: m_mmbvr(NULL),
  m_cRef(0)
{
}

MMBaseBvr::TIMEEventCB::~TIMEEventCB()
{
    Assert (m_cRef == 0);
}
        
STDMETHODIMP_(ULONG)
MMBaseBvr::TIMEEventCB::AddRef()
{
    return ++m_cRef;
}

STDMETHODIMP_(ULONG)
MMBaseBvr::TIMEEventCB::Release()
{
    if (--m_cRef == 0)
    {
        delete this;
        return 0;
    }

    return m_cRef;
}

STDMETHODIMP
MMBaseBvr::TIMEEventCB::QueryInterface(REFIID riid, void **ppv)
{
    CHECK_RETURN_SET_NULL(ppv);

    if (InlineIsEqualUnknown(riid))
    {
        *ppv = (void *)(IUnknown *)this;
    }
    else if (InlineIsEqualGUID(riid, IID_ITIMEMMEventCB))
    {
        *ppv = (void *)(ITIMEMMEventCB *)this;
    }
    else
    {
        return E_NOINTERFACE;
    }

    AddRef();
    return S_OK;
}

STDMETHODIMP
MMBaseBvr::TIMEEventCB::OnEvent(double dblLocalTime,
                                ITIMEMMBehavior * mmbvr,
                                MM_EVENT_TYPE et,
                                DWORD flags)
{
    if (!m_mmbvr)
    {
        goto done;
    }

    Assert(m_mmbvr->m_bFireEvents);
    
    TIME_EVENT newet;
        
    switch(et)
    {
      case MM_PLAY_EVENT:
        newet = TE_ONBEGIN;
        break;
      case MM_STOP_EVENT:
        newet = TE_ONEND;
        break;
      case MM_REPEAT_EVENT:
        newet = TE_ONREPEAT;
        break;
      case MM_AUTOREVERSE_EVENT:
        newet = TE_ONREVERSE;
        break;
      case MM_PAUSE_EVENT:
        newet = TE_ONPAUSE;
        break;
      case MM_RESUME_EVENT:
        newet = TE_ONRESUME;
        break;
      case MM_RESET_EVENT:
        newet = TE_ONRESET;
        break;
      default:
        goto done;
    }
        
    m_mmbvr->m_elm.FireEvent(newet, dblLocalTime, flags);
    
  done:
    return S_OK;
}

STDMETHODIMP
MMBaseBvr::TIMEEventCB::OnTick(double lastTime,
                               double nextTime,
                               ITIMEMMBehavior *,
                               double * newTime)
{
    CHECK_RETURN_NULL(newTime);

    // Initialize to the same time
    
    *newTime = nextTime;

    if (!m_mmbvr)
    {
        goto done;
    }
    
    m_mmbvr->m_elm.OnSync(lastTime, *newTime);
    
  done:
    return S_OK;
}

/////////////////////////////////////////////////////////////////////
// MMBvr
/////////////////////////////////////////////////////////////////////

MMBvr::MMBvr(CTIMEElementBase & elm, bool bFireEvents, bool fNeedSyncCB)
: MMBaseBvr(elm,bFireEvents),
   m_fNeedSyncCB(fNeedSyncCB)

{
    TraceTag((tagMMUTILBvr,
              "MMBvr(%lx)::MMBvr(%lx,%d)",
              this,
              &elm,
              bFireEvents));
}

MMBvr::~MMBvr()
{
    TraceTag((tagMMUTILBvr,
              "MMBvr(%lx)::~MMBvr()",
              this));
}

bool
MMBvr::Init(CRBvrPtr bvr)
{
    TraceTag((tagMMUTILBvr,
              "MMBvr(%lx)::Init(%#lx)",
              this,
              bvr));

    bool ok = false;
    HRESULT hr;
    DAComPtr<IDABehavior> dabvr;
    DAComPtr<IUnknown> punk;

    if (!MMBaseBvr::Init())
    {
        hr = CRGetLastError();
        goto done;
    }
    
    if (!CRBvrToCOM(bvr,
                    IID_IDABehavior,
                    (void **) &dabvr))
    {
        goto done;
    }
        
    hr = THR(MMFactory::GetFactory()->CreateBehavior(m_elm.GetID(), dabvr, &punk));
    if (FAILED(hr))
    {
        CRSetLastError(hr, NULL);
        goto done;
    }
    
    hr = THR(punk->QueryInterface(IID_ITIMEMMBehavior, (void**)&m_bvr));
    if (FAILED(hr))
    {
        CRSetLastError(hr, NULL);
        goto done;
    }

    ok = true;
  done:
    return ok;
}

//
// MMFactory
//

// TODO: Need to add a critsect
LONG
MMFactory::AddRef()
{
    if (s_refcount == 0)
    {
        if (s_factory)
        {
            s_factory->Release();
            s_factory = NULL;
        }
        
        HRESULT hr;
        hr = THR(CoCreateInstance(CLSID_TIMEMMFactory,
                                  NULL,
                                  CLSCTX_INPROC_SERVER,
                                  IID_ITIMEMMFactory,
                                  (void **) &s_factory));

        if(FAILED(hr))
        {
            goto done;
        }
    }

    s_refcount++;
    
  done:
    return s_refcount;
}

LONG
MMFactory::Release()
{
    s_refcount--;

    if (s_refcount == 0)
    {
        s_factory->Release();
        s_factory = NULL;
    }

    return s_refcount;
}

// =======================================================================
//
// MMTimeline
//
// =======================================================================

MMTimeline::MMTimeline(CTIMEElementBase & elm, bool bFireEvents)
: MMBaseBvr(elm,bFireEvents),
    m_player(NULL)
{
    TraceTag((tagMMUTILTimeline,
              "MMTimeline(%lx)::MMTimeline(%lx,%d)",
              this,
              &elm,
              bFireEvents));
}

MMTimeline::~MMTimeline()
{
    TraceTag((tagMMUTILTimeline,
              "MMTimeline(%lx)::~MMTimeline()",
              this));
    if (m_player != NULL)
    {
        m_player->ClearTimeline();
        m_player = NULL;
    }
}

bool
MMTimeline::Init()
{
    TraceTag((tagMMUTILTimeline,
              "MMTimeline(%lx)::Init()",
              this));

    bool ok = false;
    DAComPtr<IUnknown> punk;
    HRESULT hr;
    
    if (!MMBaseBvr::Init())
    {
        goto done;
    }
    
    hr = THR(MMFactory::GetFactory()->CreateTimeline(m_elm.GetID(), &punk));
    if (FAILED(hr))
    {
        CRSetLastError(hr, NULL);
        goto done;
    }
    
    hr = THR(punk->QueryInterface(IID_ITIMEMMTimeline, (void**)&m_timeline));

    if (FAILED(hr))
    {
        CRSetLastError(hr, NULL);
        goto done;
    }
    
    m_bvr = m_timeline;
    
    ok = true;
  done:
    return ok;
}

bool
MMTimeline::AddBehavior(MMBaseBvr & bvr)
{
    TraceTag((tagMMUTILTimeline,
              "MMTimeline(%lx)::AddBehavior(%#lx)",
              this,
              &bvr));

    bool ok = false;
    HRESULT hr;
    MM_START_TYPE st;
    LPOLESTR id;
    bool fHasDependent = false;
    CTIMEElementBase *pelm = &bvr.GetElement();
    CTIMEElementBase *pParent = pelm->GetParent();
    bool fInSequence = ((pParent != NULL) && pParent->IsSequence());
    int nIndex = 0;
    CPtrAry<MMBaseBvr *> notSolvedFromPending;


    if (!bvr.GetMMBvr())
    {
        TraceTag((tagError,
                  "MMTimeline::AddBehavior: Invalid bvr passed in - ITIMEMMBehavior NULL"));
                  
        CRSetLastError(E_FAIL, NULL);
        goto done;
    }
    
    // Figure out if we have dependents or an event - store the start
    // type in st
    // if we are in a sequence, we ignore all of the dependents
    if (!fInSequence)
    {
        if (pelm->GetBeginWith() != NULL)
        {
            if (pelm->GetBeginAfter() != NULL ||
                pelm->GetBeginEvent() != NULL)
            {
                CRSetLastError(E_INVALIDARG, NULL);
                goto done;
            }

            st = MM_START_WITH;
            id = pelm->GetBeginWith();
            fHasDependent = true;
        }
        else if (pelm->GetBeginAfter() != NULL)
        {
            if (pelm->GetBeginWith() != NULL ||
                pelm->GetBeginEvent() != NULL)
            {
                CRSetLastError(E_INVALIDARG, NULL);
                goto done;
            }

            st = MM_START_AFTER;
            id = pelm->GetBeginAfter();
            fHasDependent = true;
        }
        else if (pelm->GetBeginEvent() != NULL)
        {
            if (pelm->GetBeginWith() != NULL ||
                pelm->GetBeginAfter() != NULL)
            {
                CRSetLastError(E_INVALIDARG, NULL);
                goto done;
            }

            st = MM_START_EVENT;
            id = NULL;
        }
        else
        {
            st = MM_START_ABSOLUTE;
            id = NULL;
        }
    }
    else
    {
        // get index of current child from parent
        Assert(pParent != NULL);
        nIndex = pParent->GetTimeChildIndex(pelm);
        if (nIndex == 0)
        {
            st = MM_START_ABSOLUTE;
            id = NULL;
        }
        else
        {
            st = MM_START_AFTER;
            fHasDependent = true;
        }
    }

    MMBaseBvr * base;
    
    // Now determine if we can get our base if we need it
    if (fHasDependent)
    {
        int i;

        if (!fInSequence)
            i = FindID(id, m_children);
        else
            i = FindID(pParent->GetChild(nIndex-1), m_children);

        if (i == -1)
        {
            hr = THR(m_pending.Append(&bvr));
            
            if (FAILED(hr))
            {
                CRSetLastError(hr, NULL);
                goto done;
            }
            
            ok = true;
            goto done;
        }
        else
        {
            base = m_children[i];
        }
    }
    else
    {
        base = NULL;
    }
    
    hr = THR(m_children.Append(&bvr));

    if (FAILED(hr))
    {
        CRSetLastError(hr, NULL);
        goto done;
    }
    
    hr = THR(m_timeline->AddBehavior(bvr.GetMMBvr(),
                                     st,
                                     base?base->GetMMBvr():NULL));
    
    if (FAILED(hr))
    {
        CRSetLastError(hr, NULL);
        goto done;
    }

    // Now that we have added the child we need to make sure all any
    // pending children who were waiting for this behavior have also
    // been added

    LPOLESTR curid;
    MMBaseBvr *testAgainstBvr;
    testAgainstBvr = &bvr;
    THR(notSolvedFromPending.Append(testAgainstBvr));

    while(notSolvedFromPending.Size() > 0)
    {
        testAgainstBvr = notSolvedFromPending.Item(0);
        curid = testAgainstBvr->GetElement().GetID();

        // If my id is NULL then no one could be a dependent
        if (curid == NULL)
        {
            //ok = true;
            //goto done;
            notSolvedFromPending.DeleteItem(0);
            continue;
        }

        int    i;
        MMBaseBvr **ppBvr;

        i = 0;
        ppBvr = m_pending;

        while (i < m_pending.Size())
        {
            LPOLESTR dep;
            MM_START_TYPE st;

            if ((*ppBvr)->GetElement().GetBeginWith() != NULL)
            {
                Assert((*ppBvr)->GetElement().GetBeginAfter() == NULL);
            
                dep = (*ppBvr)->GetElement().GetBeginWith();
                st = MM_START_WITH;
            }
            else
            {
                dep = (*ppBvr)->GetElement().GetBeginAfter();
                st = MM_START_AFTER;
            }
        
            Assert(dep != NULL);

            if (StrCmpIW(dep, curid) == 0)
            {
                hr = THR(m_timeline->AddBehavior((*ppBvr)->GetMMBvr(),
                                                st,
                                                testAgainstBvr->GetMMBvr()));
            
                hr = THR(m_children.Append((*ppBvr)));

                // Not sure what to do on failure
                // TODO: Need to figure out how to handle this error
                // condition
            
                notSolvedFromPending.Append(m_pending.Item(i));
                m_pending.DeleteItem(i);

                // Do not increment the pointers since the elements have
                // been shifted down
            }
            else
            {
                i++;
                ppBvr++;
            }
        }
        notSolvedFromPending.DeleteItem(0);
    }

    ok = true;
  done:

    if (!ok)
    {
        RemoveBehavior(bvr);
    }
    
    return ok;
}

void
MMTimeline::RemoveBehavior(MMBaseBvr & bvr)
{
    TraceTag((tagMMUTILTimeline,
              "MMTimeline(%lx)::RemoveBehavior(%#lx)",
              this,
              &bvr));

    if (bvr.GetMMBvr())
    {
        m_timeline->RemoveBehavior(bvr.GetMMBvr());
    }

    m_children.DeleteByValue(&bvr);
    m_pending.DeleteByValue(&bvr);

    // TODO:
    // We should recalc dependents on this behavior and move them from
    // children to pending but not right now.
    MoveDependentsToPending(&bvr);
}

void 
MMTimeline::MoveDependentsToPending(MMBaseBvr * bvr)
{
    Assert(NULL != bvr);
    HRESULT hr = S_OK;
    
    // If id is NULL then "bvr" can't have dependents
    if (NULL == bvr->GetElement().GetID())
    {
        return;
    }

    // Dependents are found by traversing the dependency graph rooted at "bvr".
    // A temporary Array is used as a "queue" for traversing the graph breadth-first. 
    // Siblings directly or indirectly dependent on "bvr" will be stored in this Array
    CPtrAry<MMBaseBvr *> tempArray;

    // Initialization: insert "bvr" into temp Array
    hr = THR(tempArray.Append(bvr));
    Assert(SUCCEEDED(hr));

    int iCurBvr = 0;

    // iterate through temp Array and push dependents of CurBvr onto the back of temp Array
    while (iCurBvr < tempArray.Size())
    {
        // get id of current bvr
        LPOLESTR curid;
        curid = (tempArray[iCurBvr])->GetElement().GetID();

        Assert(NULL != curid);
        
        int i = 0;
        MMBaseBvr **ppChildBvr = m_children;

        // search for children that are dependents of CurBvr
        while (i < m_children.Size())
        {
            LPOLESTR dep = NULL;
            MM_START_TYPE st;

            // Get id of this child's start sibling
            if ((*ppChildBvr)->GetElement().GetBeginWith() != NULL)
            {
                Assert((*ppChildBvr)->GetElement().GetBeginAfter() == NULL);
            
                dep = (*ppChildBvr)->GetElement().GetBeginWith();
                st = MM_START_WITH;
            }
            else
            {
                dep = (*ppChildBvr)->GetElement().GetBeginAfter();
                st = MM_START_AFTER;
            }
        
            // if this child depends on CurBvr
            if ((NULL != dep) && (StrCmpIW(dep, curid) == 0))
            {
                // move it to the temp Array
                hr = THR(tempArray.Append((*ppChildBvr)));
                Assert(SUCCEEDED(hr));

                // Not sure what to do on failure
                // TODO: Need to figure out how to handle this error
                // condition
            
                m_children.DeleteItem(i);

                // Do not increment the pointers since the elements have
                // been shifted down
            }
            else
            {
                // continue to next child
                i++;
                ppChildBvr++;
            }
        } // while (m_children loop)

        iCurBvr++;

    } // while (tempArray loop)

    // Remove first element, i.e. "bvr",  from temp Array because it was put there to simplify
    // the traversal code
    tempArray.DeleteItem(0);

    // Call End() on all bvrs in temp Array
    MMBaseBvr **ppCurBvr = NULL;
    for (iCurBvr = 0, ppCurBvr = tempArray; iCurBvr < tempArray.Size(); iCurBvr++, ppCurBvr++)
    {
        if (true != (*ppCurBvr)->End())
        {
            // TODO: put trace or handle error code
        }
        // Remove the behavior from MMAPI because the rule we are enforcing is that
        // if a bvr is in the pending list in MMUTILS then it should not exist in MMAPI.
        // This avoids maintaining a separate copy of the pending list in MMAPI. 
        m_timeline->RemoveBehavior((*ppCurBvr)->GetMMBvr());
        // Append to m_pending
        hr = THR(m_pending.Append(*ppCurBvr));
        Assert(SUCCEEDED(hr));
    }
    
    // destroy temp Array
    tempArray.DeleteAll();
}

void
MMTimeline::Clear()
{
    TraceTag((tagMMUTILTimeline,
              "MMTimeline(%lx)::Clear()",
              this));

    // TODO: Need to flesh this out
}

int
MMTimeline::FindID(LPOLESTR id,
                    CPtrAry<MMBaseBvr *> & arr)
{
    TraceTag((tagMMUTILTimeline,
              "MMTimeline::FindID(%ls, %#lx)",
              id,
              &arr));

    int    i;
    MMBaseBvr **ppBvr;

    for (i = 0, ppBvr = arr; (unsigned)i < arr.Size(); i++, ppBvr++)
    {
        if (StrCmpIW((*ppBvr)->GetElement().GetID(), id) == 0)
        {
            return i;
        }
    }

    return -1;
}

int
MMTimeline::FindID(CTIMEElementBase *pelm,
                    CPtrAry<MMBaseBvr *> & arr)
{
    TraceTag((tagMMUTILTimeline,
              "MMTimeline::FindID(%ls, %#lx)",
              pelm,
              &arr));

    int    i;
    MMBaseBvr **ppBvr;
    
    if (pelm == NULL)
        return -1;

    for (i = 0, ppBvr = arr; (unsigned)i < arr.Size(); i++, ppBvr++)
    {
        // compare MMBaseBvr pointers
        if (&(pelm->GetMMBvr()) == *ppBvr)
        {
            return i;
        }
    }

    return -1;
}

bool
MMTimeline::Update()
{
    TraceTag((tagMMUTILTimeline,
              "MMTimeline(%lx)::Update()",
              this));

    bool ok = false;
        
    // Now update the timeline properties

    // Handle endsync
    LPOLESTR str = m_elm.GetEndSync();
    DWORD endSyncFlag = MM_ENDSYNC_NONE;
    
    if (str == NULL ||
        StrCmpIW(str, WZ_NONE) == 0)
    {
        endSyncFlag = MM_ENDSYNC_NONE;
    }
    else if (StrCmpIW(str, WZ_LAST) == 0)
    {
        endSyncFlag = MM_ENDSYNC_LAST;
    }
    else if (StrCmpIW(str, WZ_FIRST) == 0)
    {
        endSyncFlag = MM_ENDSYNC_FIRST;
    }

    IGNORE_HR(m_timeline->put_EndSync(endSyncFlag));

    if (!MMBaseBvr::Update())
    {
        goto done;
    }
    
    ok = true;
  done:
    return ok;
}

// ================================================================
//
// MMView
//
// ================================================================

MMView::MMView()
{
    TraceTag((tagMMUTILView,
              "MMView(%lx)::MMView()",
              this));

    MMFactory::AddRef();
}

MMView::~MMView()
{
    TraceTag((tagMMUTILView,
              "MMView(%lx)::~MMView()",
              this));

    Deinit();
    MMFactory::Release();
}

bool
MMView::Init(LPWSTR id,
             CRImagePtr img,
             CRSoundPtr snd,
             ITIMEMMViewSite * site)
{
    TraceTag((tagMMUTILView,
              "MMView(%lx)::Init(%ls, %lx, %lx, %lx)",
              this,
              id,
              img,
              snd,
              site));

    bool ok = false;
    HRESULT hr;
    DAComPtr<IUnknown> punk;
    DAComPtr<IDAImage> daimg;
    DAComPtr<IDASound> dasnd;
    
    if (MMFactory::GetFactory() == NULL)
    {
        CRSetLastError(E_FAIL, NULL);
        goto done;
    }
    
    {
        CRLockGrabber __gclg;
        
        if (img)
        {
            if (!CRBvrToCOM((CRBvrPtr) img,
                            IID_IDAImage,
                            (void **) &daimg))
            {
                goto done;
            }
        }
        
        if (snd)
        {
            if (!CRBvrToCOM((CRBvrPtr) snd,
                            IID_IDASound,
                            (void **) &dasnd))
            {
                goto done;
            }
        }
    }
    
    hr = THR(MMFactory::GetFactory()->CreateView(id,
                                                 daimg,
                                                 dasnd,
                                                 (IUnknown *) site,
                                                 &punk));
    if (FAILED(hr))
    {
        CRSetLastError(hr, NULL);
        goto done;
    }
    
    hr = THR(punk->QueryInterface(IID_ITIMEMMView, (void**)&m_view));
        
    if (FAILED(hr))
    {
        CRSetLastError(hr, NULL);
        goto done;
    }
    
    ok = true;
  done:
    if (!ok)
    {
        m_view.Release();
    }
    
    return ok;
}

void
MMView::Deinit()
{
    TraceTag((tagMMUTILView,
              "MMView(%lx)::Deinit()",
              this));

    if(m_view)
        m_view.Release();
}

bool
MMView::Render(HDC hdc, LPRECT rect)
{
    TraceTag((tagMMUTILView,
              "MMView(%lx)::Render(%lx,[%lx,%lx,%lx,%lx])",
              this,
              hdc,
              rect->left,
              rect->right,
              rect->top,
              rect->bottom));

    bool ok = false;
    HRESULT hr;

    Assert(m_view);

    hr = THR(m_view->Draw(hdc, rect));

    if (FAILED(hr))
    {
        CRSetLastError(hr, NULL);
        goto done;
    }

    ok = true;
  done:
    return ok;
}
    
bool
MMView::Tick()
{
    TraceTag((tagMMUTILView,
              "MMView(%lx)::Tick()",
              this));

    bool ok = false;
    HRESULT hr;

    Assert(m_view);

    hr = THR(m_view->Tick());

    if (FAILED(hr))
    {
        CRSetLastError(hr, NULL);
        goto done;
    }

    ok = true;
  done:
    return ok;
}

void
MMView::OnMouseMove(double when,
                    LONG xPos,LONG yPos,
                    BYTE modifiers)
{
    Assert(m_view);

    THR(m_view->OnMouseMove(when,
                            xPos,yPos,
                            modifiers));
}

void
MMView::OnMouseButton(double when,
                      LONG xPos, LONG yPos,
                      BYTE button,
                      VARIANT_BOOL bPressed,
                      BYTE modifiers)
{
    Assert(m_view);

    THR(m_view->OnMouseButton(when,
                              xPos,yPos,
                              button,
                              bPressed,
                              modifiers));
}

void
MMView::OnKey(double when,
              LONG key,
              VARIANT_BOOL bPressed,
              BYTE modifiers)
{
    Assert(m_view);

    THR(m_view->OnKey(when,
                      key,
                      bPressed,
                      modifiers));
}
    
void
MMView::OnFocus(VARIANT_BOOL bHasFocus)
{
    Assert(m_view);

    THR(m_view->OnFocus(bHasFocus));
}

//
// MMPlayer
//

MMPlayer::MMPlayer(CTIMEBodyElement & elm)
: m_elm(elm),
  m_timeline(NULL)
{
    TraceTag((tagMMUTILPlayer,
              "MMPlayer(%lx)::MMPlayer(%lx)",
              this,
              &elm));

    MMFactory::AddRef();
}

MMPlayer::~MMPlayer()
{
    TraceTag((tagMMUTILPlayer,
              "MMPlayer(%lx)::~MMPlayer()",
              this));

    if (m_timeline)
    {
        m_timeline->put_Player(NULL);
    }

    Deinit();
    MMFactory::Release();
}

bool
MMPlayer::Init(MMTimeline & tl)
{
    TraceTag((tagMMUTILPlayer,
              "MMPlayer(%lx)::Init(%lx)",
              this,
              &tl));

    bool ok = false;
    HRESULT hr;
    DAComPtr<IUnknown> punk;
    
    if (MMFactory::GetFactory() == NULL)
    {
        CRSetLastError(E_FAIL, NULL);
        goto done;
    }
    
    m_timeline = &tl;
    if (m_timeline != NULL)
    {
        m_timeline->put_Player(this);
    }

    hr = THR(MMFactory::GetFactory()->CreatePlayer(m_elm.GetID(),
                                                   m_timeline->GetMMTimeline(),
                                                   &m_elm,
                                                   &punk));
    if (FAILED(hr))
    {
        CRSetLastError(hr, NULL);
        goto done;
    }
    
    hr = THR(punk->QueryInterface(IID_ITIMEMMPlayer, (void**)&m_player));
        
    if (FAILED(hr))
    {
        CRSetLastError(hr, NULL);
        goto done;
    }
    
    m_clock.SetSink(this);
    
    hr = THR(m_clock.SetITimer(&m_elm, 33));
    if (FAILED(hr))
    {
        CRSetLastError(hr, NULL);
        goto done;
    }
    
    ok = true;
  done:
    if (!ok)
    {
        m_player.Release();
    }
    
    return ok;
}

void
MMPlayer::Deinit()
{
    TraceTag((tagMMUTILPlayer,
              "MMPlayer(%lx)::Deinit()",
              this));

    if(m_player)
        m_player -> Shutdown();
    m_player.Release();
    m_clock.Stop();
}

bool
MMPlayer::Play()
{
    TraceTag((tagMMUTILPlayer,
              "MMPlayer(%lx)::Play()",
              this));

    bool ok = false;
    
    HRESULT hr;

    hr = THR(m_player->Play());

    if (FAILED(hr))
    {
        CRSetLastError(hr, NULL);
        goto done;
    }

    hr = THR(m_clock.Start());

    if (FAILED(hr))
    {
        CRSetLastError(hr, NULL);
        goto done;
    }

    // Tick the view at 0
    hr = THR(m_player->Tick(0.0));

    if (FAILED(hr))
    {
        CRSetLastError(hr, NULL);
        goto done;
    }

    ok = true;
  done:
    if (!ok)
    {
        m_player->Stop();
        m_clock.Stop();
    }
    
    return ok;
}

bool
MMPlayer::Pause()
{
    TraceTag((tagMMUTILPlayer,
              "MMPlayer(%lx)::Pause()",
              this));

    bool ok = false;
    
    HRESULT hr;

    hr = THR(m_player->Pause());

    if (FAILED(hr))
    {
        CRSetLastError(hr, NULL);
        goto done;
    }

    hr = THR(m_clock.Pause());

    if (FAILED(hr))
    {
        CRSetLastError(hr, NULL);
        goto done;
    }

    ok = true;
  done:
    return ok;
}

bool
MMPlayer::Resume()
{
    TraceTag((tagMMUTILPlayer,
              "MMPlayer(%lx)::Resume()",
              this));

    bool ok = false;
    
    HRESULT hr;

    hr = THR(m_player->Resume());

    if (FAILED(hr))
    {
        CRSetLastError(hr, NULL);
        goto done;
    }

    hr = THR(m_clock.Resume());

    if (FAILED(hr))
    {
        CRSetLastError(hr, NULL);
        goto done;
    }

    ok = true;
  done:
    return ok;
}

bool
MMPlayer::Stop()
{
    TraceTag((tagMMUTILPlayer,
              "MMPlayer(%lx)::Stop()",
              this));

    bool ok = false;

    if (m_player)
        IGNORE_HR(m_player->Stop());
    IGNORE_HR(m_clock.Stop());
    
    ok = true;

    return ok;
}

bool
MMPlayer::Tick(double gTime)
{
    TraceTag((tagMMUTILPlayer,
              "MMPlayer(%lx)::Tick(%g)",
              this,
              gTime));

    bool ok = false;
    
    HRESULT hr;

    hr = THR(m_player->Tick(gTime));

    if (FAILED(hr))
    {
        CRSetLastError(hr, NULL);
        goto done;
    }

    ok = true;
  done:
    return ok;
}

bool 
MMPlayer::TickOnceWhenPaused()
{
    // DBL_EPSILON is defined in float.h such that
    // 1.0 + DBL_EPSILON != 1.0
    return Tick(GetCurrentTime() + DBL_EPSILON);
}


void
MMPlayer::OnTimer(double time)
{
    TraceTag((tagMMUTILPlayer,
              "MMPlayer(%lx)::OnTimer(%g)",
              this,
              time));

    Tick(time);
}

bool
MMPlayer::AddView(MMView & v)
{
    TraceTag((tagMMUTILPlayer,
              "MMPlayer(%lx)::AddView(%lx)",
              this,
              &v));

    HRESULT hr;
    bool ok = false;

    Assert(m_player);
    Assert(v.GetView());
    
    hr = THR(m_player->AddView(v.GetView()));

    if (FAILED(hr))
    {
        CRSetLastError(hr, NULL);
        goto done;
    }

    ok = true;
  done:
    return ok;
}

bool
MMPlayer::RemoveView(MMView & v)
{
    TraceTag((tagMMUTILPlayer,
              "MMPlayer(%lx)::RemoveView(%lx)",
              this,
              &v));

    HRESULT hr;
    bool ok = false;

    if (m_player && v.GetView())
    {
        hr = THR(m_player->RemoveView(v.GetView()));
        
        if (FAILED(hr))
        {
            CRSetLastError(hr, NULL);
            goto done;
        }
    }

    ok = true;
  done:
    return ok;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\time\src\notify.h ===
#ifndef _NOTIFY_H
#define _NOTIFY_H


#include "daelmbase.h"
#include "containerobj.h"

class CTIMENotifyer : public CRUntilNotifier
{

  public:
    CTIMENotifyer(CTIMEElementBase *pelem) : m_cRef(1) , m_pTIMEElem(pelem){}

    ~CTIMENotifyer(){};
    
    
    CRSTDAPICB_(ULONG) AddRef() { return InterlockedIncrement(&m_cRef); }
    CRSTDAPICB_(ULONG) Release() {
        ULONG ul = InterlockedDecrement(&m_cRef) ;
        if (ul == 0) delete this;
        return ul;
    }

    virtual CRSTDAPICB_(CRBvrPtr) Notify(CRBvrPtr eventData,
                                         CRBvrPtr curRunningBvr,
                                         CRViewPtr curView) {
        
        RECT rc;
        Assert(m_pTIMEElem);
    
        if(SUCCEEDED(m_pTIMEElem->GetSize(&rc))) 
        {
            if( (rc.right  - rc.left == 0)  ||
                (rc.bottom - rc.top  == 0))
            {
                // need to pull out the size of the image..
                CRVector2Ptr crv2;
                double x;
                double y;

                crv2 = CRSub(CRMax((CRBbox2Ptr)eventData),CRMin((CRBbox2Ptr)eventData) );

                x = CRExtract(CRGetX(crv2));
                y = CRExtract(CRGetY(crv2));

                // need to convert to pixels from meters.
                HDC hdc = ::GetDC(NULL);
                if(hdc) {
                    int width  = ::GetDeviceCaps(hdc,LOGPIXELSX) * ((x * 100) / 2.54);
                    int height = ::GetDeviceCaps(hdc,LOGPIXELSY) * ((y * 100) / 2.54);
                    rc.bottom = height + rc.top;
                    rc.right  = width  + rc.left;
                    m_pTIMEElem->SetSize(&rc);
                    ::ReleaseDC(NULL,hdc);
                }
            }
        }

        m_pTIMEElem->InvalidateRect(NULL);

        return curRunningBvr ;
    }

  private:
    CTIMEElementBase   *m_pTIMEElem;
    long                m_cRef;

};

#endif /* _NOTIFY_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\time\src\mediaelm.cpp ===
/*******************************************************************************
 *
 * Copyright (c) 1998 Microsoft Corporation
 *
 * File: mediaelm.cpp
 *
 * Abstract:
 *
 *
 *
 *******************************************************************************/

#include "headers.h"
#include "mediaelm.h"
#include "bodyelm.h"
#include <mshtmdid.h>

// static class data.
CPtrAry<BSTR> CTIMEMediaElement::ms_aryPropNames;
DWORD CTIMEMediaElement::ms_dwNumTimeMediaElems = 0;

// These must align with the class PROPERTY_INDEX enumeration.
LPWSTR CTIMEMediaElement::ms_rgwszTMediaPropNames[] = {
    L"src", L"img", L"player", L"type", L"clipBegin", L"clipEnd", L"clockSource"
};

// Suppress new warning about NEW without corresponding DELETE 
// We expect GCs to cleanup values.  Since this could be a useful
// warning, we should disable this on a file by file basis.
#pragma warning( disable : 4291 )  
DeclareTag(tagMediaTimeElm, "API", "CTIMEMediaElement methods");
DeclareTag(tagMediaElementOnChanged, "API", "CTIMEMediaElement OnChanged method");

#define DEFAULT_M_SRC NULL
#define DEFAULT_M_IMG NULL
#define DEFAULT_M_SRCTYPE NULL

// BUGBUG : jeffwall 04/03/99 the frame rate is a big assumption
// 1/24th of a second is the assumed frame rate.
#define WMP_FRAME_RATE 1.0/24.0

CTIMEMediaElement::CTIMEMediaElement()
: m_src(DEFAULT_M_SRC),
  m_img(DEFAULT_M_IMG),
  m_srcType(DEFAULT_M_SRCTYPE),
  m_Player(NULL),
  m_fClockSource(false),
  m_fLoaded(false),
  m_fExternalPlayer(false),
  m_mediaElementPropertyAccesFlags(0),
  m_fMediaSizeSet(false),
  m_dwAdviseCookie(0),
  m_fInOnChangedFlag(false),
  m_fDurationIsNatural(false)
{
    TraceTag((tagMediaTimeElm,
              "CTIMEMediaElement(%lx)::CTIMEMediaElement()",
              this));

    m_clsid = __uuidof(CTIMEMediaElement);
    CTIMEMediaElement::ms_dwNumTimeMediaElems++;
    
    m_rcOrigSize.bottom = m_rcOrigSize.left = m_rcOrigSize.right = m_rcOrigSize.top = 0;
    m_rcMediaSize.bottom = m_rcMediaSize.left = m_rcMediaSize.right = m_rcMediaSize.top = 0;
}

CTIMEMediaElement::~CTIMEMediaElement()
{
    TraceTag((tagMediaTimeElm,
              "CTIMEMediaElement(%lx)::~CTIMEMediaElement()",
              this));
    
    delete m_src;
    delete m_img;
    delete m_srcType;
    if(m_Player)
    {
        m_Player->Stop();
        delete m_Player;
    }

    CTIMEMediaElement::ms_dwNumTimeMediaElems--;

    if (0 == CTIMEMediaElement::ms_dwNumTimeMediaElems)
    {
        int iNames = CTIMEMediaElement::ms_aryPropNames.Size();

        for (int i = iNames - 1; i >= 0; i--)
        {
            BSTR bstrName = CTIMEMediaElement::ms_aryPropNames[i];
            CTIMEMediaElement::ms_aryPropNames.DeleteItem(i);
            ::SysFreeString(bstrName);
        }
    }
}

void 
CTIMEMediaElement::SetMediaType(MediaType mt)
{
    TraceTag((tagMediaTimeElm,
              "CTIMEMediaElement(%lx)::SetMediaType()",
              this));
    m_type = mt;
}

HRESULT
CTIMEMediaElement::Init(IElementBehaviorSite * pBehaviorSite)
{
    TraceTag((tagMediaTimeElm,
              "CTIMEMediaElement(%lx)::Init()",
              this));

    HRESULT hr = E_FAIL; 
    DAComPtr<IHTMLElement2> pElem2;
    VARIANT_BOOL varboolSuccess;


    hr = THR(CDAElementBase::Init(pBehaviorSite));    
    if (FAILED(hr))
    {
        goto done;
    }    

    m_sp = GetServiceProvider();
    if (!m_sp)
    {
        TraceTag((tagError, "CTIMEMediaElement::Init - unable get QS"));
        hr = TIMESetLastError(DISP_E_TYPEMISMATCH, NULL);   
        goto done;
    }

    hr = CreatePlayer();
    if (FAILED(hr))
    {
        goto done;
    }

    hr = CTIMEElementBase::GetSize(&m_rcOrigSize);
    if (FAILED(hr))
        goto done;

    hr = InitPropertySink();
    if (FAILED(hr))
    {
        goto done;
    }

    Assert(GetElement() != NULL);
    hr = THR(GetElement()->QueryInterface(IID_TO_PPV(IHTMLElement2, &pElem2)));
    if (FAILED(hr))
    {
        goto done;
    }

    hr = pElem2->attachEvent( L"onresize", this, &varboolSuccess);
    if (FAILED(hr))
    {
        goto done;
    }



    
    hr = S_OK;

done:
    return hr;
}

HRESULT
CTIMEMediaElement::CreatePlayer()
{
    Assert(NULL == m_Player);

    HRESULT hr = E_FAIL;
    m_Player = NEW CTIMEPlayer(this);
    if (m_Player == NULL)
    {
        TraceTag((tagError, "CTIMEMediaElement::Init - unable to alloc mem for CTIMEPlayer"));
        hr = TIMESetLastError(E_OUTOFMEMORY, NULL);
        goto done;
    }

    hr = m_Player->Init();
    if (FAILED(hr))
    {
        TraceTag((tagError, "CTIMEMediaElement::Init - Init failed on CTIMEPlayer"));
        hr = TIMESetLastError(hr, NULL);
        goto done;
    }

    hr = S_OK;
done:
    return hr;
}

HRESULT
CTIMEMediaElement::Error()
{
    TraceTag((tagMediaTimeElm,
              "CTIMEMediaElement(%lx)::Error()",
              this));
    
    LPCWSTR str = CRGetLastErrorString();
    HRESULT hr = CRGetLastError();
    
    if (str)
        return CComCoClass<CTIMEMediaElement, &__uuidof(CTIMEMediaElement)>::Error(str, IID_ITIMEMediaElement, hr);
    else
        return hr;
}


HRESULT
CTIMEMediaElement::Notify(LONG event, VARIANT * pVar)
{
    TraceTag((tagMediaTimeElm,
              "CTIMEMediaElement(%lx)::Notify()",
              this));

    THR(CDAElementBase::Notify(event, pVar));

    switch (event)
    {
      case BEHAVIOREVENT_DOCUMENTREADY:
        break;
    }

    return S_OK;
}

HRESULT
CTIMEMediaElement::Detach()
{
    DAComPtr<IHTMLElement2> pElem2;
    HRESULT hr;
    TraceTag((tagMediaTimeElm,
              "CTIMEMediaElement(%lx)::Detach()",
              this));

    THR(UnInitPropertySink());
    Assert(GetElement() != NULL);
    hr = THR(GetElement()->QueryInterface(IID_TO_PPV(IHTMLElement2, &pElem2)));
    if (SUCCEEDED(hr))
    {
        THR(pElem2->detachEvent(L"onresize", this));
    }

    if (NULL != m_Player)
    {
        m_Player->Stop();
        THR(m_Player->DetachFromHostElement());
    }

    THR(CDAElementBase::Detach());
    
    return S_OK;
}

HRESULT
CTIMEMediaElement::get_src(VARIANT * url)
{
    HRESULT hr;
    
    if (url == NULL)
    {
        hr = E_POINTER;
        goto done;
    }

    if (FAILED(hr = THR(VariantClear(url))))
    {
        goto done;
    }
    
    V_VT(url) = VT_BSTR;
    V_BSTR(url) = SysAllocString(m_src);

    hr = S_OK;
  done:
    return hr;
}

HRESULT
CTIMEMediaElement::put_src(VARIANT url)
{
    CComVariant v;
    HRESULT hr;
    
    bool clearFlag = false;


    if(V_VT(&url) == VT_NULL)
    {
        clearFlag = true;
    }
    else
    {
        hr = v.ChangeType(VT_BSTR, &url);

        if (FAILED(hr))
        {
            goto done;
        }
    }

    delete [] m_src;

    //processing the attribute change should be done here

    if(!clearFlag)
    {
        m_src = CopyString(V_BSTR(&v));
        SetPropertyFlagAndNotify(DISPID_TIMEMEDIAELEMENT_SRC, tme_src);
    }
    else
    {
        m_src = DEFAULT_M_SRC;
        ClearPropertyFlagAndNotify(DISPID_TIMEMEDIAELEMENT_SRC, tme_src);
    }

    if (m_fLoaded)
    {
        hr = RecreatePlayer();
        if (FAILED(hr))
            goto done;
    }
    VARIANT varMediaLength;
    VariantInit(&varMediaLength);

    if (isNaturalDuration() == true)
    {
        V_VT(&varMediaLength) = VT_NULL;
        put_dur(varMediaLength);
        put_end(varMediaLength);
    }

    hr = S_OK;

  done:

    return hr;
}

HRESULT
CTIMEMediaElement::RecreatePlayer()
{
    HRESULT hr = E_FAIL;

    Assert(m_Player != NULL);

    // need to get the time
    double dblTime;

    hr = CalculateSeekTime(&dblTime);
    if (FAILED(hr))
    {
        goto done;
    }

    m_Player->Stop();
    THR(m_Player->DetachFromHostElement());

    delete m_Player;
    m_Player = NULL;

    hr = CreatePlayer();
    if (FAILED(hr))
        goto done;

    m_Player->SetClockSource(m_fClockSource);
    
    hr = THR(m_Player->OnLoad(m_src, m_img, m_type));
    if (FAILED(hr))
        goto done;
    
    m_Player->Seek(dblTime);
    // turn on/off the behavior as appropriate
    m_mmbvr->Reset(MM_EVENT_PROPERTY_CHANGE);        


    hr = S_OK;
done:
    return hr;
}

HRESULT
CTIMEMediaElement::CalculateSeekTime(double *pdblTime)
{
    HRESULT hr = E_FAIL;

    Assert(pdblTime != NULL);
    *pdblTime = 0;

    double dblTime;
    
    m_mmbvr->GetMMBvr()->get_SegmentTime(&dblTime);
    
    CTIMEElementBase *pBase = this;
    
    float flAdditionalOffset;
    
    m_mmbvr->GetMMBvr()->get_StartOffset(&flAdditionalOffset);
    
    while (HUGE_VAL == dblTime)
    {
        // End has been called on this element already -- we need to calculate where we should be                       
        if (pBase->GetParent() == NULL)
        {
            hr = S_OK;
            goto done;
        }

        Assert(pBase->GetParent() != NULL);
        
        MMBaseBvr& pMMbvr = pBase->GetParent()->GetMMBvr();
        ITIMEMMBehavior* pbvr = pMMbvr.GetMMBvr();
        
        Assert(pbvr != NULL);
        
        double dblLocalTime;            
        pbvr->get_LocalTime(&dblLocalTime);
        if (HUGE_VAL == dblLocalTime)
        {
            float flStartOffset;
            pbvr->get_StartOffset(&flStartOffset);
            if (flStartOffset != HUGE_VAL)
                flAdditionalOffset += flStartOffset;
        }
        else
        {
            dblTime = dblLocalTime - flAdditionalOffset ;
        }
        
        if (pBase->IsBody())
        {
            Assert(dblTime != HUGE_VAL);
            break;
        }

        pBase = pBase->GetParent();
    }
    
    if (dblTime < 0)
    {
        // the element hasn't even begun yet!
        dblTime = 0;
    }

    *pdblTime = dblTime;
    hr = S_OK;
done:
    return hr;
}
    
HRESULT
CTIMEMediaElement::get_img(VARIANT * url)
{
    HRESULT hr;
    
    if (url == NULL)
    {
        hr = E_POINTER;
        goto done;
    }

    if (FAILED(hr = THR(VariantClear(url))))
    {
        goto done;
    }
    
    V_VT(url) = VT_BSTR;
    V_BSTR(url) = SysAllocString(m_img);

    hr = S_OK;
  done:
    return hr;
}

HRESULT
CTIMEMediaElement::put_img(VARIANT url)
{
    CComVariant v;
    HRESULT hr;
    bool clearFlag = false;


    if(V_VT(&url) == VT_NULL)
    {
        clearFlag = true;
    }
    else
    {
        hr = v.ChangeType(VT_BSTR, &url);

        if (FAILED(hr))
        {
            goto done;
        }
    }
    
    
    delete [] m_img;
    //processing the attribute change should be done here

    if(!clearFlag)
    {
        m_img = CopyString(V_BSTR(&v));
        SetPropertyFlagAndNotify(DISPID_TIMEMEDIAELEMENT_IMG, tme_img);
    }
    else
    {
        m_img = DEFAULT_M_IMG;
        ClearPropertyFlagAndNotify(DISPID_TIMEMEDIAELEMENT_IMG, tme_img);
    }

    hr = S_OK;

  done:
    return hr;
}


HRESULT
CTIMEMediaElement::get_player(VARIANT  * clsid)
{
    HRESULT hr = E_FAIL;
    
    if (clsid == NULL)
    {
        hr = E_POINTER;
        goto done;
    }

    if (FAILED(hr = THR(VariantClear(clsid))))
    {
        goto done;
    }
    
    V_VT(clsid) = VT_BSTR;
    LPOLESTR ppsz;
        
    if(FAILED(StringFromCLSID(m_playerCLSID, &ppsz)))
    {
        goto done;
    }

    V_BSTR(clsid) = SysAllocString(ppsz);

    hr = S_OK;
  done:
    return hr;
}

HRESULT
CTIMEMediaElement::put_player(VARIANT clsid)
{
    CComVariant v;
    HRESULT hr;
    bool clearFlag = false;
    
    if(V_VT(&clsid) == VT_NULL)
    {
        clearFlag = true;
    }
    else
    {
        hr = v.ChangeType(VT_BSTR, &clsid);
        if (FAILED(hr))
        {
            goto done;
        }
    
        if(FAILED(CLSIDFromString(V_BSTR(&v), &m_playerCLSID)))
        {
            // either not valid format or not in registry
            CRSetLastError(DISP_E_TYPEMISMATCH,NULL);   
            goto done;
        }
    }

    if(!clearFlag)
    {
        Assert(m_Player != NULL);
        m_Player->SetCLSID(m_playerCLSID);
        m_fExternalPlayer = true;
        SetPropertyFlagAndNotify(DISPID_TIMEMEDIAELEMENT_PLAYER, tme_player);
    }

    hr = S_OK;
    
  done:

    return hr;
}


HRESULT
CTIMEMediaElement::get_type(VARIANT * type)
{
    HRESULT hr;
    
    if (type == NULL)
    {
        hr = E_POINTER;
        goto done;
    }

    if (FAILED(hr = THR(VariantClear(type))))
    {
        goto done;
    }
    
    V_VT(type) = VT_BSTR;
    V_BSTR(type) = SysAllocString(m_srcType);

    hr = S_OK;
  done:
    return hr;
}

HRESULT
CTIMEMediaElement::put_type(VARIANT type)
{
    CComVariant v;
    HRESULT hr;
    bool clearFlag = false;


    if(V_VT(&type) == VT_NULL)
    {
        clearFlag = true;
    }
    else
    {
        hr = v.ChangeType(VT_BSTR, &type);

        if (FAILED(hr))
        {
            goto done;
        }
    }
    
    
    delete [] m_srcType;
    //processing the attribute change should be done here

    if(!clearFlag)
    {
        m_srcType = CopyString(V_BSTR(&v));
        SetPropertyFlagAndNotify(DISPID_TIMEMEDIAELEMENT_SRCTYPE, tme_type);
    }
    else
    {
        m_srcType = DEFAULT_M_SRCTYPE;
        ClearPropertyFlagAndNotify(DISPID_TIMEMEDIAELEMENT_SRCTYPE, tme_type);
    }

    hr = S_OK;
    
  done:

    return hr;
}

HRESULT
CTIMEMediaElement::get_playerObject(IDispatch **ppDisp)
{
    TraceTag((tagMediaTimeElm, "CTIMEMediaElement::get_playerObject"));
    HRESULT hr;

    if (ppDisp == NULL)
    {
        TraceTag((tagError, "CTIMEMediaElement::get_playerObject - invalidarg"));
        return TIMESetLastError(E_POINTER, NULL);
    }

    *ppDisp = NULL;

    if (!m_fExternalPlayer)
    {
        TraceTag((tagError, "CTIMEMediaElement::get_playerObject - no external player set"));
        return TIMESetLastError(E_UNEXPECTED, NULL);
    }

    Assert(m_Player != NULL);
    
    hr = m_Player->GetExternalPlayerDispatch(ppDisp);
    if (FAILED(hr))
    {
        TraceTag((tagError, "CTIMEMediaElement::get_playerObject - GetExternalPlayerDispatch() failed"));
        TIMESetLastError(hr, NULL);
    }
    return hr;    
}

HRESULT
CTIMEMediaElement::get_clockSource(VARIANT_BOOL *pfClockSource)
{
    TraceTag((tagMediaTimeElm, "CTIMEMediaElement::get_clockSource"));
    HRESULT hr = E_FAIL;

    if (pfClockSource == NULL)
    {
        TraceTag((tagError, "CTIMEMediaElement::get_clockSource - invalidarg"));
        hr = E_POINTER;
        goto done;
    }

    *pfClockSource = m_fClockSource ? VARIANT_TRUE : VARIANT_FALSE;
    hr = S_OK;

done:
    return hr;
}

HRESULT
CTIMEMediaElement::put_clockSource(VARIANT_BOOL fClockSource)
{
    TraceTag((tagMediaTimeElm, "CTIMEMediaElement::put_clockSource"));
    HRESULT hr;
    
    m_fClockSource = fClockSource ? true : false;
    
    m_Player->SetClockSource(m_fClockSource);

    if (NULL != m_mmbvr)
    {
        m_mmbvr->Update();
    }

    hr = S_OK;

    SetPropertyFlagAndNotify(DISPID_TIMEMEDIAELEMENT_CLOCKSOURCE, tme_clockSource);
    return hr;
}

void 
CTIMEMediaElement::OnLoad()
{
    if (!m_fLoaded)
    {
        m_Player->OnLoad(m_src, m_img, m_type);
        m_fLoaded = true;
    }
}

void
CTIMEMediaElement::OnSync(double dbllastTime, double & dblnewTime)
{
    TraceTag((tagMediaTimeElm,
              "CTIMEMediaElement(%lx)::OnSync() dbllastTime = %g dblnewTime = %g",
              this, dbllastTime, dblnewTime));

    if (m_fLoaded)
    {
        Assert(NULL != m_mmbvr);
        Assert(NULL != m_mmbvr->GetMMBvr());

        double dblSegTime = dbllastTime;
        int offset = 0;
        // copied from CMMBaseBvr::LocalTimeToSegmentTime
        if (m_realIntervalDuration != HUGE_VAL)
        {
            // we want the previous boundary, unless we are or a boundary then we want this repeat count
            offset = floor(dblSegTime / m_realIntervalDuration);
            if (offset < 0)
            {
                offset = 0;
            }
            
            dblSegTime = dblSegTime - (offset * m_realIntervalDuration);
        }

        double dblSavedNewTime = dblnewTime;
        m_Player->OnSync(dblSegTime, dblnewTime);
        if (m_fClockSource && m_realIntervalDuration != HUGE_VAL && dblnewTime != dblSavedNewTime)
        {
            dblnewTime = dblnewTime + offset * m_realIntervalDuration;
        }
    }
}

void
CTIMEMediaElement::OnBegin(double dblLocalTime, DWORD flags)
{
    TraceTag((tagMediaTimeElm,
              "CTIMEMediaElement(%lx)::OnBegin()",
              this));

    CDAElementBase::OnBegin(dblLocalTime, flags);

    Assert(NULL != m_mmbvr);
    Assert(NULL != m_mmbvr->GetMMBvr());

    double dblSegmentTime = 0;
    HRESULT hr = S_OK;
    hr = THR(m_mmbvr->GetMMBvr()->get_SegmentTime(&dblSegmentTime));
    if (FAILED(hr))
    {
        return;
    }

    // Check if this event was fired by our hack to make endhold work correctly
    // when seeking forward (over our lifespan) 
    if ((flags & MM_EVENT_SEEK) && HUGE_VAL == dblSegmentTime)
    {
        // if endhold isn't set, we shouldn't start the player, so bail
        if (!CTIMEElementBase::GetEndHold())
        {
            return;
        }
        // else we should, and show the last frame (below)
    }
    
    
    Assert(m_Player != NULL);

    //In the case of begin=0, it is possible for this to be called 
    //before the OnLoad method.  In this case we will initialize here
    //instead of in the onload event.
    if (!m_fLoaded)
    {
        m_Player->OnLoad(m_src, m_img, m_type);
        m_fLoaded = true;
    }
    
   
    double dblMediaLength = 0;
    if (NULL != m_Player->GetContainerObj())
    {
        hr = THR(m_Player->GetContainerObj()->GetMediaLength(dblMediaLength));
        if (FAILED(hr))
        {
            // if the media is not yet loaded or is infinite, we don't know the duration, so set the length forward enough.
            dblMediaLength = HUGE_VAL;
        }

        if (dblMediaLength >= dblSegmentTime)
        {        
            m_Player->Start(dblSegmentTime);
    
            hr = THR(m_Player->Seek(dblSegmentTime));
            if (FAILED(hr))
            {    
                return;
            }
        }
        else
        {
            m_Player->Start(dblMediaLength - WMP_FRAME_RATE);

            hr = THR(m_Player->Seek(dblMediaLength - WMP_FRAME_RATE));
            if (FAILED(hr))
            {
                return;
            }
        }
    }
    else
    {
        m_Player->Start(dblSegmentTime);
    }

    MM_STATE curState = GetBody()->GetPlayState();
    if (MM_PAUSED_STATE == curState)
    {
        OnPause(dblSegmentTime);
    }
}

void
CTIMEMediaElement::OnEnd(double dblLocalTime)
{
    TraceTag((tagMediaTimeElm,
              "CTIMEMediElement(%lx)::OnEnd()",
              this));

    CDAElementBase::OnEnd(dblLocalTime);
    
    Assert(m_Player != NULL);
    m_Player->Stop();
}

void
CTIMEMediaElement::OnReset(double dblLocalTime, DWORD flags)
{
    TraceTag((tagMediaTimeElm,
              "CTIMEMediElement(%lx)::OnReset()",
              this));

    CDAElementBase::OnReset(dblLocalTime, flags);
    
    Assert(m_Player != NULL);
    m_Player->Stop();
}

void
CTIMEMediaElement::OnPause(double dblLocalTime)
{
    TraceTag((tagMediaTimeElm,
              "CTIMEMediElement(%lx)::OnPause()",
              this));

    CDAElementBase::OnPause(dblLocalTime);

    Assert(NULL != m_Player);
    m_Player->Pause();

}

void
CTIMEMediaElement::OnResume(double dblLocalTime)
{
    TraceTag((tagMediaTimeElm,
              "CTIMEMediElement(%lx)::OnResume()",
              this));

    CDAElementBase::OnResume(dblLocalTime);
    
    Assert(NULL != m_mmbvr);
    Assert(NULL != m_mmbvr->GetMMBvr());
    Assert(NULL != m_Player);

    // If we can't get either segment time or media length, resume unconditionally,
    // else use the information to decide whether to pause 
    double dblSegmentTime = 0.0f;
    if (FAILED(THR(m_mmbvr->GetMMBvr()->get_SegmentTime(&dblSegmentTime))) 
        || NULL == m_Player->GetContainerObj())
    {
        m_Player->Resume();
    }
    else
    {
        HRESULT hr = S_OK;
        double dblMediaLength = 0.0f;
        hr = THR(m_Player->GetContainerObj()->GetMediaLength(dblMediaLength));
        if (FAILED(hr))
        {
            // if the media is not yet loaded or is infinite, we don't know the duration, so set the length forward enough.
            dblMediaLength = HUGE_VAL;
        }

        if (dblSegmentTime <= dblMediaLength)
        {        
             m_Player->Resume();
        }
    } 

} // OnResume

void CTIMEMediaElement::OnRepeat(double dblLocalTime)
{
    TraceTag((tagMediaTimeElm,
              "CTIMEMediaElement(%lx)::OnRepeat()",
              this));

    CDAElementBase::OnRepeat(dblLocalTime);
    Assert(m_Player != NULL);

    m_Player->Start(0);
}

void
CTIMEMediaElement::OnUnload()
{
    TraceTag((tagMediaTimeElm,
              "CTIMEMediaElement(%lx)::OnUnload()",
              this));

    if (m_Player)
    {
        m_Player->Stop();
    }

    CTIMEElementBase::OnUnload();
}

HRESULT
CTIMEMediaElement::get_clipBegin(VARIANT *pvar)
{
    TraceTag((tagMediaTimeElm,
              "CTIMEMediElement(%lx)::get_clipBegin()",
              this));
    HRESULT hr;

    if (pvar == NULL)
    {
        hr = E_POINTER;
        goto done;
    }

    Assert(m_Player != NULL);
    hr = THR(m_Player->getClipBegin(pvar));

done:
    return hr;
}

HRESULT
CTIMEMediaElement::put_clipBegin(VARIANT var)
{
    TraceTag((tagMediaTimeElm,
              "CTIMEMediElement(%lx)::put_clipBegin()",
              this));
    HRESULT hr;

    Assert(m_Player != NULL);
    hr = THR(m_Player->putClipBegin(var));

    SetPropertyFlagAndNotify(DISPID_TIMEMEDIAELEMENT_CLIPBEGIN, tme_clipBegin);
    return hr;
}

HRESULT
CTIMEMediaElement::get_clipEnd(VARIANT *pvar)
{
    TraceTag((tagMediaTimeElm,
              "CTIMEMediElement(%lx)::get_clipEnd()",
              this));
    HRESULT hr;

    if (pvar == NULL)
    {
        hr = E_POINTER;
        goto done;
    }

    Assert(m_Player != NULL);
    hr = THR(m_Player->getClipEnd(pvar));

done:
    return hr;
}

HRESULT
CTIMEMediaElement::put_clipEnd(VARIANT var)
{
    TraceTag((tagMediaTimeElm,
              "CTIMEMediElement(%lx)::put_clipEnd()",
              this));
    HRESULT hr;

    Assert(m_Player != NULL);
    hr = THR(m_Player->putClipEnd(var));

    SetPropertyFlagAndNotify(DISPID_TIMEMEDIAELEMENT_CLIPEND, tme_clipEnd);
    return hr;
}

static bool IsEqual(RECT lhs, RECT rhs)
{
    bool equal = false;

    if (lhs.bottom != rhs.bottom)
        goto done;
    if (lhs.left != rhs.left)
        goto done;
    if (lhs.right != rhs.right)
        goto done;
    if (lhs.top != rhs.top)
        goto done;

    equal = true;

done:
    return equal;
}

HRESULT
CTIMEMediaElement::GetSize(RECT *prcPos)
{
    return CTIMEElementBase::GetSize(prcPos);
#if 0
    HRESULT hr = E_FAIL;
    
    RECT rcPos;
    hr = CTIMEElementBase::GetSize(&rcPos);
    if (FAILED(hr))
    {
        goto done;
    }

    if (IsEqual(rcPos, m_rcOrigSize) || ( m_fMediaSizeSet && IsEqual(rcPos, m_rcMediaSize) ) )
    {
        *prcPos = m_rcOrigSize;
    }
    else
    {
        // style must have changed -- use this as the new size
        m_rcOrigSize = rcPos;
        m_fMediaSizeSet = false;
        *prcPos = rcPos;
    }
    hr = S_OK;
done:
    return hr;
#endif
}

static void Sub(RECT *prcPos, RECT rcDelta)
{
    Assert(NULL != prcPos);
    (*prcPos).bottom -= rcDelta.bottom;
    (*prcPos).left -= rcDelta.left;
    (*prcPos).right -= rcDelta.right;
    (*prcPos).top -= rcDelta.top;
}

HRESULT 
CTIMEMediaElement::SetSize(const RECT *prcPos)
{
    HRESULT hr;
    //BUGBUG this ca be done without disconnecting the Notification

    hr = THR(UnInitPropertySink());
    if (FAILED(hr))
        goto done;
    hr = CTIMEElementBase::SetSize(prcPos);
    if (FAILED(hr))
        goto done;
    hr = THR(InitPropertySink());
    if (FAILED(hr))
        goto done;

done:
    return hr;
#if 0
    HRESULT hr = E_FAIL;
    
    RECT rcTemp = *prcPos;

    if (m_fMediaSizeSet)
    {
        // subtract the previous rect from this new rect
        Sub(&rcTemp, m_rcMediaSize); // rcTemp = rcTemp - m_rcMediaSize;
    }

    hr = CTIMEElementBase::SetSize(&rcTemp);

    m_fMediaSizeSet = true;
    
    hr = CTIMEElementBase::GetSize(&m_rcMediaSize);

    return hr;
#endif
}

//////////////////////////////////////////////////////////////////////////////////////////////////////////////
// IElementBehaviorRender

//////////////////////////////////////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CTIMEMediaElement::GetRenderInfo(LONG *pdwRenderInfo)
{
    // Return the layers we are interested in drawing
//    *pdwRenderInfo = BEHAVIORRENDERINFO_BEFORECONTENT; //BEHAVIORRENDERINFO_AFTERCONTENT;
    // BUGBUG - need to provide user schema of setting this.
    // Note that we do the same thing daelm does.
    *pdwRenderInfo = BEHAVIORRENDERINFO_AFTERCONTENT;
    return S_OK;
}


HRESULT
CTIMEMediaElement::Draw(HDC hdc, LONG dwLayer, LPRECT prc, IUnknown * pParams)
{
    HRESULT hr = S_OK;

    if (m_fLoaded)
        hr = THR(m_Player->Render(hdc, prc));
    return hr;        
}


//*****************************************************************************

HRESULT 
CTIMEMediaElement::SetPropertyByIndex(unsigned uIndex, VARIANT *pvarprop)
{
    HRESULT hr = E_FAIL;
    // copy variant for conversion type
    VARIANT varTemp;
    VariantInit(&varTemp);
    hr = VariantCopyInd(&varTemp, pvarprop);
    if (FAILED(hr))
        return hr;

    // Rely on the enumeration interval to determine where to look for the property.
    if (teb_maxTIMEElementBaseProp > uIndex)
    {
        hr = CTIMEElementBase::SetPropertyByIndex(uIndex, pvarprop);
    }
    else if (tme_maxTIMEMediaProp > uIndex)
    {
        switch (uIndex)
        {
            case tme_src :
                hr = put_src(*pvarprop);
                break;
            case tme_img :
                hr = put_img(*pvarprop);
                break;
            case tme_player :
                hr = put_player(*pvarprop);
                break;
            case tme_type : 
                hr = put_type(*pvarprop);
                break;
            case tme_clipBegin :
                hr = put_clipBegin(*pvarprop);
                break;
            case tme_clipEnd :
                hr = put_clipEnd(*pvarprop);
                break;
            case tme_clockSource :
                hr = VariantChangeTypeEx(&varTemp, &varTemp, LCID_SCRIPTING, NULL, VT_BOOL);
                if (SUCCEEDED(hr))
                    hr = put_clockSource(V_BOOL(&varTemp));
                break;
        };
    }

    return hr;
} // SetPropertyByIndex

//*****************************************************************************

HRESULT 
CTIMEMediaElement::GetPropertyByIndex(unsigned uIndex, VARIANT *pvarprop)
{
    HRESULT hr = E_FAIL;

    // Rely on the enumeration interval to determine where to look for the property.
    if (teb_maxTIMEElementBaseProp > uIndex)
    {
        hr = CTIMEElementBase::GetPropertyByIndex(uIndex, pvarprop);
    }
    else if (tme_maxTIMEMediaProp > uIndex)
    {
        Assert(VT_EMPTY == V_VT(pvarprop));
        switch (uIndex)
        {
            case tme_src :
                hr = get_src(pvarprop);
                break;
            case tme_img :
                hr = get_img(pvarprop);
                break;
            case tme_player :
                hr = get_player(pvarprop);
                break;
            case tme_type : 
                hr = get_type(pvarprop);
                break;
            case tme_clipBegin :
                hr = get_clipBegin(pvarprop);
                break;
            case tme_clipEnd :
                hr = get_clipEnd(pvarprop);
                break;
            case tme_clockSource :
                hr = get_clockSource(&(V_BOOL(pvarprop)));
                if (SUCCEEDED(hr))
                {
                    V_VT(pvarprop) = VT_BOOL;
                }
                break;
        };
    }

    return hr;
} // GetPropertyByIndex

//*****************************************************************************

void CTIMEMediaElement::SetPropertyFlag(DWORD uIndex)
{
    DWORD relIndex;
    if (teb_maxTIMEElementBaseProp > uIndex)
    {
        CTIMEElementBase::SetPropertyFlag(uIndex);
        return;
    }

    relIndex = uIndex - teb_maxTIMEElementBaseProp;
    DWORD bitPosition = 1 << relIndex;
    m_mediaElementPropertyAccesFlags =  m_mediaElementPropertyAccesFlags | bitPosition;
}

void CTIMEMediaElement::ClearPropertyFlag(DWORD uIndex)
{
    DWORD relIndex;
    if (teb_maxTIMEElementBaseProp > uIndex)
    {
        CTIMEElementBase::ClearPropertyFlag(uIndex);
        return;
    }

    relIndex = uIndex - teb_maxTIMEElementBaseProp;
    DWORD bitPosition = 1 << relIndex;
    m_mediaElementPropertyAccesFlags =  m_mediaElementPropertyAccesFlags & (~bitPosition);
}

bool CTIMEMediaElement::IsPropertySet(DWORD uIndex)
{
    DWORD relIndex;

    if (teb_maxTIMEElementBaseProp > uIndex)
    {
        return CTIMEElementBase::IsPropertySet( uIndex);
    }

    relIndex = uIndex - teb_maxTIMEElementBaseProp;
    if( relIndex >= 32) return true;
    if( relIndex >= tme_maxTIMEMediaProp - teb_maxTIMEElementBaseProp) return true;
    DWORD bitPosition = 1 << relIndex;
    if(m_mediaElementPropertyAccesFlags & bitPosition)
        return true;
    return false;
}

HRESULT
CTIMEMediaElement::BuildPropertyNameList(CPtrAry<BSTR> *paryPropNames)
{
    // Start from the base class.
    HRESULT hr = CTIMEElementBase::BuildPropertyNameList(paryPropNames);

    if (SUCCEEDED(hr))
    {
        for (int i = teb_maxTIMEElementBaseProp; 
             (i < tme_maxTIMEMediaProp) && (SUCCEEDED(hr)); i++)
        {
            int iRelative = i - teb_maxTIMEElementBaseProp;
            Assert(NULL != ms_rgwszTMediaPropNames[iRelative]);
            BSTR bstrNewName = CreateTIMEAttrName(ms_rgwszTMediaPropNames[iRelative]);
            Assert(NULL != bstrNewName);
            if (NULL != bstrNewName)
            {
                hr = paryPropNames->Append(bstrNewName);
            }
            else
            {
                hr = E_OUTOFMEMORY;
            }
        }
    }

    return hr;
} // BuildPropertyNameList

//*****************************************************************************

HRESULT 
CTIMEMediaElement::GetPropertyBagInfo(CPtrAry<BSTR> **pparyPropNames)
{
    HRESULT hr = S_OK;

    // If we haven't built this yet, build it now.
    if (0 == ms_aryPropNames.Size())
    {
        hr = BuildPropertyNameList(&(CTIMEMediaElement::ms_aryPropNames));
    }

    if (SUCCEEDED(hr))
    {
        *pparyPropNames = &(CTIMEMediaElement::ms_aryPropNames);
    }

    return hr;
} // GetPropertyBagInfo

//*****************************************************************************

HRESULT 
CTIMEMediaElement::GetConnectionPoint(REFIID riid, IConnectionPoint **ppICP)
{
    return FindConnectionPoint(riid, ppICP);
} // GetConnectionPoint

STDMETHODIMP
CTIMEMediaElement::OnRequestEdit(DISPID dispID)
{
    return S_OK;
}

STDMETHODIMP
CTIMEMediaElement::OnChanged(DISPID dispID)
{
    DAComPtr<IHTMLStyle> pStyle2;
    DAComPtr<IHTMLElement2> pElem2;
    DAComPtr<IHTMLStyle> s;
    VARIANT varStyleWidth, varStyleHeight;
    HRESULT hr = S_OK;

    if( m_fInOnChangedFlag == true)
        return S_OK;

    m_fInOnChangedFlag = true;

    switch(dispID)
    {
    case DISPID_IHTMLCURRENTSTYLE_TOP:
        TraceTag((tagMediaElementOnChanged,
                "CTIMEMediaElement(%lx)::OnChanged():TOP", this));
        break;

    case DISPID_IHTMLCURRENTSTYLE_LEFT:
        TraceTag((tagMediaElementOnChanged,
                "CTIMEMediaElement(%lx)::OnChanged():LEFT", this));
        break;

    case DISPID_IHTMLCURRENTSTYLE_WIDTH:
    case DISPID_IHTMLCURRENTSTYLE_HEIGHT:
        TraceTag((tagMediaElementOnChanged,
                "CTIMEMediaElement(%lx)::OnChanged():WIDTH or HEIGHT", this));
        long pixelWidth, pixelHeight;
#ifdef _DEBUG
        bool gotWidth = false;
        bool gotHeight = false;
#endif
        VariantInit(&varStyleWidth);
        VariantInit(&varStyleHeight);

        if (GetElement())
        {
            hr = THR(GetElement()->QueryInterface(IID_TO_PPV(IHTMLElement2, &pElem2)));
            if (FAILED(hr))
            {
                break;
            }
    
            hr = THR(pElem2->get_runtimeStyle(&pStyle2));
            if (FAILED(hr))
            {
                break;
            }    

            hr = THR(GetElement()->get_style(&s));
            if (FAILED(hr))
            {
                break;
            }    

            if (SUCCEEDED(s -> get_width( &varStyleWidth)))
            {
                if (varStyleWidth.vt == VT_BSTR && varStyleWidth.bstrVal != NULL) //check that width was set
                {
                    if (SUCCEEDED(s -> get_pixelWidth( &pixelWidth)))
                    {
#ifdef _DEBUG
                        gotWidth = true;
#endif
                        pStyle2 -> put_pixelWidth(pixelWidth);
                     }
                }
            }



            if (SUCCEEDED(s -> get_height( &varStyleHeight)))
            {
                if (varStyleHeight.vt == VT_BSTR && varStyleHeight.bstrVal != NULL) //check that height was set
                {
                    if (SUCCEEDED(s -> get_pixelHeight( &pixelHeight)))
                    {
#ifdef _DEBUG
                        gotHeight = true;
#endif
                        pStyle2 -> put_pixelHeight(pixelHeight);
                    }
                }
            }
        }
#ifdef _DEBUG
            if ( gotWidth)
            {
                TraceTag((tagMediaElementOnChanged,
                        "CTIMEMediaElement(%lx):: WIDTH %d - %ls", this, pixelWidth, varStyleWidth.bstrVal));
            }
            if ( gotHeight)
            {
                TraceTag((tagMediaElementOnChanged,
                        "CTIMEMediaElement(%lx)::HEIGHT %d - %ls", this, pixelHeight, varStyleHeight.bstrVal));
            }
#endif

        VariantClear(&varStyleWidth);
        VariantClear(&varStyleHeight);
        break;
    }
    m_fInOnChangedFlag = false;
    return hr;
}


HRESULT
CTIMEMediaElement::GetNotifyConnection(IConnectionPoint **ppConnection)
{
    HRESULT hr = S_OK;

    Assert(ppConnection != NULL);
    *ppConnection = NULL;

    IConnectionPointContainer *pContainer = NULL;
    IHTMLElement *pElement = GetElement();

    // Get connection point container
    hr = pElement->QueryInterface(IID_TO_PPV(IConnectionPointContainer, &pContainer));
    if(FAILED(hr))
        goto end;
    
    // Find the IPropertyNotifySink connection
    hr = pContainer->FindConnectionPoint(IID_IPropertyNotifySink, ppConnection);
    if(FAILED(hr))
        goto end;

end:
    ReleaseInterface( pContainer );

    return hr;
}

//*****************************************************************************

/**
* Initializes a property sink on the current style of the animated element so that
* can observe changes in width, height, visibility, zIndex, etc.
*/
HRESULT
CTIMEMediaElement::InitPropertySink()
{
    HRESULT hr = S_OK;

    // Get connection point
    IConnectionPoint *pConnection = NULL;
    hr = GetNotifyConnection(&pConnection);
    if (FAILED(hr))
        return hr;

    // Advise on it
    hr = pConnection->Advise(GetUnknown(), &m_dwAdviseCookie);
    ReleaseInterface(pConnection);
    if (FAILED(hr))
        return hr;

    return S_OK;
}

HRESULT
CTIMEMediaElement::UnInitPropertySink()
{
    HRESULT hr = S_OK;

    if (m_dwAdviseCookie == 0)
        return S_OK;

    // Get connection point
    IConnectionPoint *pConnection = NULL;
    hr = GetNotifyConnection(&pConnection);
    if (FAILED(hr) || pConnection == NULL )
        return hr;

    // Unadvise on it
    hr = pConnection->Unadvise(m_dwAdviseCookie);
    ReleaseInterface(pConnection);
    if (FAILED(hr))
        return hr;

    m_dwAdviseCookie = 0;

    return S_OK;
}

STDMETHODIMP
CTIMEMediaElement::Invoke( DISPID id,
                           REFIID riid,
                           LCID lcid,
                           WORD wFlags,
                           DISPPARAMS *pDispParams,
                           VARIANT *pvarResult,
                           EXCEPINFO *pExcepInfo,
                           UINT *puArgErr)
{
    DAComPtr<IDispatch> pDisp;
    DAComPtr<IHTMLDocument2> pDoc;
    DAComPtr<IHTMLWindow2> pWindow;
    DAComPtr<IHTMLEventObj> pEventObj;
    DAComPtr<IHTMLElement2> pElem2;
    HRESULT hr = S_OK;
    BSTR bstrEventName;
    BSTR bstrQualifier;
    RECT elementRect;
    IHTMLRect *pRect = NULL;


    if (id != 0) // we are only proccesing the onresize event. For other event we call the parent method.
    {
        hr = IDispatchImpl<ITIMEMediaElement, &IID_ITIMEMediaElement, &LIBID_TIME>::Invoke(
                            id, riid, lcid, wFlags, pDispParams, pvarResult, pExcepInfo, puArgErr);
        goto done; //BUGBUG call the other one
    }

    hr = THR(GetElement()->get_document(&pDisp));
    if (FAILED(hr))
    {
        goto done;
    }

    hr = THR(pDisp->QueryInterface(IID_IHTMLDocument2, (void **)&pDoc));
    if (FAILED(hr))
    {
        goto done;
    }

    hr = THR(pDoc->get_parentWindow(&pWindow));
    if (FAILED(hr))
    {
        goto done;
    }
    hr = THR(pWindow->get_event(&pEventObj));
    if (FAILED(hr))
    {
        goto done;
    }
    hr = pEventObj->get_type(&bstrEventName);
    if (FAILED(hr))
    {
        goto done;
    }

    if (StrCmpIW(bstrEventName, L"resize") != 0)
    {
        goto done;
    }

    hr = THR(GetElement()->QueryInterface(IID_TO_PPV(IHTMLElement2, &pElem2)));
    if (FAILED(hr))
    {
        goto done;       
    }
    hr = pElem2->getBoundingClientRect(&pRect);
    if (FAILED(hr) || pRect == NULL )
    {
        goto done;
    }

    long pixelWidth, pixelHeight;
    long pixelRight, pixelLeft;
    long pixelBottom, pixelTop;
    hr = pRect->get_right(&pixelRight);
    if (FAILED(hr))
    {
        goto done;
    }
    hr = pRect->get_left(&pixelLeft);
    if (FAILED(hr))
    {
        goto done;
    }

    hr = pRect->get_bottom(&pixelBottom);
    if (FAILED(hr))
    {
        goto done;
    }
    hr = pRect->get_top(&pixelTop);
    if (FAILED(hr))
    {
        goto done;
    }

    elementRect.top = elementRect.left = 0.0;
    elementRect.right = pixelRight - pixelLeft;
    elementRect.bottom = pixelBottom - pixelTop;

    hr = THR(m_Player -> SetSize(&elementRect));

    hr = S_OK;
done:
    return hr;
}



//*****************************************************************************
#undef THIS
#define THIS CTIMEMediaElement
#define SUPER CTIMEElementBase

#include "pbagimp.cpp"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\time\src\mmutil.h ===
/*******************************************************************************
 *
 * Copyright (c) 1998 Microsoft Corporation
 *
 * File: mmutil.h
 *
 * Abstract:
 *
 *
 *
 *******************************************************************************/


#ifndef _MMUTIL_H
#define _MMUTIL_H

#include "mmapi.h"
#include "clock.h"
#include "float.h"

class CTIMEElementBase;
class MMPlayer;

class MMFactory
{
  public:
    static ITIMEMMFactory * GetFactory()
    { return s_factory; }

    // TODO: Might need a critsect
    static LONG AddRef();
    static LONG Release();
    static ITIMEMMFactory * s_factory;
    static LONG s_refcount;
};

class MMBaseBvr
{
  public:
    MMBaseBvr(CTIMEElementBase & elm, bool bFireEvents);
    virtual ~MMBaseBvr();

    bool Init();
    
    bool Begin(bool bAfterOffset);
    bool End();
    bool Pause();
    bool Resume();
    bool Reset(DWORD fCause = 0);

    bool Seek(double time);

    virtual bool Update();

    double GetLocalTime();
    double GetSegmentTime();
    double GetTotalTime()
    { return (double) m_totalTime; }
    MM_STATE GetPlayState();

    ITIMEMMBehavior * GetMMBvr()
    { return m_bvr; }
    CTIMEElementBase & GetElement()
    { return m_elm; }
  protected:
    CTIMEElementBase & m_elm;
    DAComPtr<ITIMEMMBehavior> m_bvr;
    float m_totalTime;
    bool m_bFireEvents;

    class TIMEEventCB :
        public ITIMEMMEventCB
    {
      public:
        TIMEEventCB();
        ~TIMEEventCB();
        
        STDMETHOD_(ULONG, AddRef)();
        STDMETHOD_(ULONG, Release)();
        STDMETHOD(QueryInterface)(REFIID riid, void **ppv);
        STDMETHOD(OnEvent)(double eventTime,
                           ITIMEMMBehavior *,
                           MM_EVENT_TYPE et,
                           DWORD flags);
        STDMETHOD(OnTick)(double lastTime,
                          double nextTime,
                          ITIMEMMBehavior *,
                          double * newTime);
    
        void SetMMBvr(MMBaseBvr * t) { m_mmbvr = t; }

      protected:
        // This is a weak pointer and it is our parent's responsibility to
        // NULL this out before it goes away
        MMBaseBvr * m_mmbvr;
        long m_cRef;
    };

    friend TIMEEventCB;

    DAComPtr<TIMEEventCB> m_eventCB;
};

class MMBvr
    : public MMBaseBvr
{
  public:
    MMBvr(CTIMEElementBase & elm, bool bFireEvents, bool fNeedSyncCB);
    ~MMBvr();

    bool Init(CRBvrPtr bvr);
  protected:
    bool m_fNeedSyncCB;
};

class MMTimeline :
    public MMBaseBvr
{
  public:
    MMTimeline(CTIMEElementBase & elm, bool bFireEvents);
    ~MMTimeline();
    
    bool Init();
    
    bool AddBehavior(MMBaseBvr & bvr);
    void RemoveBehavior(MMBaseBvr & bvr);
    void MoveDependentsToPending(MMBaseBvr * bvr);
    void Clear();
    
    virtual bool Update();

    ITIMEMMBehavior * GetMMBvr()
    { return m_timeline; }
    ITIMEMMTimeline * GetMMTimeline()
    { return m_timeline; }
    void put_Player(MMPlayer *player)
    { m_player = player; }

  protected:
    DAComPtr<ITIMEMMTimeline> m_timeline;

    // These are the children we have already added because we found
    // their base
    CPtrAry<MMBaseBvr *> m_children;

    // These are the children we have not added since we do not know
    // their base
    CPtrAry<MMBaseBvr *> m_pending;

    // Return -1 if it is not found
    static int FindID(LPOLESTR id, CPtrAry<MMBaseBvr *> & arr);
    static int FindID(CTIMEElementBase *pelm, CPtrAry<MMBaseBvr *> & arr);
  private:
     MMPlayer * m_player;
};

class MMView
{
  public:
    MMView();
    ~MMView();
    
    bool Init(LPWSTR id,
              CRImagePtr img,
              CRSoundPtr snd,
              ITIMEMMViewSite * site);
    
    void Deinit();

    bool Tick();
    bool Render(HDC hdc, LPRECT rect);
    
    void OnMouseMove(double when,
                     LONG xPos,LONG yPos,
                     BYTE modifiers);

    void OnMouseButton(double when,
                       LONG xPos, LONG yPos,
                       BYTE button,
                       VARIANT_BOOL bPressed,
                       BYTE modifiers);

    void OnKey(double when,
               LONG key,
               VARIANT_BOOL bPressed,
               BYTE modifiers);
    
    void OnFocus(VARIANT_BOOL bHasFocus);

    ITIMEMMView * GetView() { return m_view; }
  protected:
    DAComPtr<ITIMEMMView> m_view;
};

class CTIMEBodyElement;

class MMPlayer
    : public ClockSink
{
  public:
    MMPlayer(CTIMEBodyElement & elm);
    ~MMPlayer();
    
    bool Init(MMTimeline & tl);
    void Deinit();

    bool Play();
    bool Stop();
    bool Pause();
    bool Resume();
    bool Tick(double gTime);
    // This forces one tick, so updates will be drawn even 
    // when the clock and player are paused (used for editing)
    bool TickOnceWhenPaused(void);
    
    inline bool AddBehavior(MMBaseBvr & bvr)
    { return m_timeline->AddBehavior(bvr); }
    inline void RemoveBehavior(MMBaseBvr & bvr)
    { m_timeline->RemoveBehavior(bvr); }

    bool AddView(MMView & v);
    bool RemoveView(MMView & v);
    
    inline void Clear()
    { m_timeline->Clear(); }
    
    inline bool Update()
    { return m_timeline->Update(); }
    
    ITIMEMMPlayer * GetMMPlayer()
    { return m_player; }
    MMTimeline & GetTimeline()
    { return *m_timeline; }

    double GetCurrentTime()
    { return m_clock.GetCurrentTime(); }

    void ClearTimeline()
    { m_timeline = NULL; }

  protected:
    void OnTimer(double time);

  protected:
    CTIMEBodyElement & m_elm;
    MMTimeline * m_timeline;
    DAComPtr<ITIMEMMPlayer> m_player;
    Clock                   m_clock;
};

#endif /* _MMUTIL_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\time\src\mediaelm.h ===
/*******************************************************************************
 *
 * Copyright (c) 1998 Microsoft Corporation
 *
 * File: mediaelm.h
 *
 * Abstract:
 *
 *
 *
 *******************************************************************************/


#ifndef _MEDIAELM_H
#define _MEDIAELM_H

#include "daelmbase.h"
#include "containerobj.h"
#include "player.h"


/////////////////////////////////////////////////////////////////////////////
// CTIMEMediaElement

class
ATL_NO_VTABLE
__declspec(uuid("efbad7f8-3f94-11d2-b948-00c04fa32195")) 
CTIMEMediaElement :
    public CDAElementBase,
    public CComCoClass<CTIMEMediaElement, &__uuidof(CTIMEMediaElement)>,
    public IDispatchImpl<ITIMEMediaElement, &IID_ITIMEMediaElement, &LIBID_TIME>,
    public ISupportErrorInfoImpl<&IID_ITIMEMediaElement>,
    public IConnectionPointContainerImpl<CTIMEMediaElement>,
    public IPersistPropertyBag2,
    public IPropertyNotifySinkCP<CTIMEMediaElement>,
    public IPropertyNotifySink
{
  public:
    CTIMEMediaElement();
    ~CTIMEMediaElement();
    void SetMediaType(MediaType mt);
        
#if _DEBUG
    const _TCHAR * GetName() { return __T("CTIMEMediaElement"); }
#endif

    STDMETHOD(Init)(IElementBehaviorSite * pBvrSite);
    STDMETHOD(Draw)(HDC hdc, LONG dwLayer, LPRECT prc, IUnknown * pParams);
    STDMETHOD(GetRenderInfo)(LONG *pdwRenderInfo); 
    STDMETHOD(Notify)(LONG event, VARIANT * pVar);
    STDMETHOD(Detach)();

    STDMETHOD(get_src)(VARIANT * url);
    STDMETHOD(put_src)(VARIANT url);

    STDMETHOD(get_img)(VARIANT * url);
    STDMETHOD(put_img)(VARIANT url);
        
    STDMETHOD(get_player)(VARIANT * clsid);
    STDMETHOD(put_player)(VARIANT clsid);
    
    STDMETHOD(get_type)(VARIANT * type);
    STDMETHOD(put_type)(VARIANT type);
    
    STDMETHOD(get_playerObject)(IDispatch **ppDisp);

    STDMETHOD(get_clockSource)(VARIANT_BOOL *fClockSource);
    STDMETHOD(put_clockSource)(VARIANT_BOOL fClockSource);

    STDMETHOD(get_clipBegin)(VARIANT * pvar);
    STDMETHOD(put_clipBegin)(VARIANT var);
    STDMETHOD(get_clipEnd)(VARIANT * pvar);
    STDMETHOD(put_clipEnd)(VARIANT var);

    //
    //IPersistPropertyBag2
    // 
    STDMETHOD(GetClassID)(CLSID* pclsid);
    STDMETHOD(InitNew)(void);
    STDMETHOD(IsDirty)(void)
        {return S_OK;};
    STDMETHOD(Load)(IPropertyBag2 *pPropBag,IErrorLog *pErrorLog);
    STDMETHOD(Save)(IPropertyBag2 *pPropBag, BOOL fClearDirty, BOOL fSaveAllProperties);


    // IPropertyNotifySink methods
    STDMETHOD(OnChanged)(DISPID dispID);
    STDMETHOD(OnRequestEdit)(DISPID dispID);
    STDMETHODIMP Invoke( DISPID id,
            REFIID riid,
            LCID lcid,
            WORD wFlags,
            DISPPARAMS *pDispParams,
            VARIANT *pvarResult,
            EXCEPINFO *pExcepInfo,
            UINT *puArgErr);

    //
    // ITIMEElement
    //

    STDMETHOD(get_begin)(VARIANT * time)
    { return base_get_begin(time); }
    STDMETHOD(put_begin)(VARIANT time)
    { return base_put_begin(time); }

    STDMETHOD(get_beginWith)(VARIANT * time)
    { return base_get_beginWith(time); }
    STDMETHOD(put_beginWith)(VARIANT time)
    { return base_put_beginWith(time); }

    STDMETHOD(get_beginAfter)(VARIANT * time)
    { return base_get_beginAfter(time); }
    STDMETHOD(put_beginAfter)(VARIANT time)
    { return base_put_beginAfter(time); }

    STDMETHOD(get_beginEvent)(VARIANT * time)
    { return base_get_beginEvent(time); }
    STDMETHOD(put_beginEvent)(VARIANT time)
    { return base_put_beginEvent(time); }

    STDMETHOD(get_dur)(VARIANT * time)
    { return base_get_dur(time); }
    STDMETHOD(put_dur)(VARIANT time)
    { clearNaturalDuration(); return base_put_dur(time); }

    STDMETHOD(get_end)(VARIANT * time)
    { return base_get_end(time); }
    STDMETHOD(put_end)(VARIANT time)
    { clearNaturalDuration(); return base_put_end(time); }

    STDMETHOD(get_endWith)(VARIANT * time)
    { return base_get_endWith(time); }
    STDMETHOD(put_endWith)(VARIANT time)
    { return base_put_endWith(time); }

    STDMETHOD(get_endEvent)(VARIANT * time)
    { return base_get_endEvent(time); }
    STDMETHOD(put_endEvent)(VARIANT time)
    { return base_put_endEvent(time); }

    STDMETHOD(get_endSync)(VARIANT * time)
    { return base_get_endSync(time); }
    STDMETHOD(put_endSync)(VARIANT time)
    { return base_put_endSync(time); }

    STDMETHOD(get_repeat)(VARIANT * time)
    { return base_get_repeat(time); }
    STDMETHOD(put_repeat)(VARIANT time)
    { return base_put_repeat(time); }

    STDMETHOD(get_repeatDur)(VARIANT * time)
    { return base_get_repeatDur(time); }
    STDMETHOD(put_repeatDur)(VARIANT time)
    { return base_put_repeatDur(time); }

    STDMETHOD(get_accelerate)(int * time)
    { return base_get_accelerate(time); }
    STDMETHOD(put_accelerate)(int time)
    { return base_put_accelerate(time); }

    STDMETHOD(get_decelerate)(int * time)
    { return base_get_decelerate(time); }
    STDMETHOD(put_decelerate)(int time)
    { return base_put_decelerate(time); }

    STDMETHOD(get_autoReverse)(VARIANT_BOOL * b)
    { return base_get_autoReverse(b); }
    STDMETHOD(put_autoReverse)(VARIANT_BOOL b)
    { return base_put_autoReverse(b); }

    STDMETHOD(get_endHold)(VARIANT_BOOL * b)
    { return base_get_endHold(b); }
    STDMETHOD(put_endHold)(VARIANT_BOOL b)
    { return base_put_endHold(b); }

    STDMETHOD(get_eventRestart)(VARIANT_BOOL * b)
    { return base_get_eventRestart(b); }
    STDMETHOD(put_eventRestart)(VARIANT_BOOL b)
    { return base_put_eventRestart(b); }

    STDMETHOD(get_timeAction)(LPOLESTR * time)
    { return base_get_timeAction(time); }
    STDMETHOD(put_timeAction)(LPOLESTR time)
    { return base_put_timeAction(time); }

    STDMETHOD(beginElement)()
    { return base_beginElement(true); }
    STDMETHOD(endElement)()
    { return base_endElement(); }
    STDMETHOD(pause)()
    { return base_pause(); }
    STDMETHOD(resume)()
    { return base_resume(); }
    STDMETHOD(cue)()
    { return base_cue(); }

    STDMETHOD(get_timeline)(BSTR *pbstrTimeLine)
    { return base_get_timeline(pbstrTimeLine); }
    STDMETHOD(put_timeline)(BSTR bstrTimeLine)
    { return base_put_timeline(bstrTimeLine); }

    STDMETHOD(get_currTime)(float * time)
    { return base_get_currTime(time); }
    STDMETHOD(put_currTime)(float time)
    { return base_put_currTime(time); }

    STDMETHOD(get_localTime)(float * time)
    { return base_get_localTime(time); }
    STDMETHOD(put_localTime)(float time)
    { return base_put_localTime(time); }

    STDMETHOD(get_currState)(LPOLESTR * state)
    { return base_get_currState(state); }
    STDMETHOD(put_currState)(LPOLESTR state)
    { return base_put_currState(state); }

    STDMETHOD(get_syncBehavior)(LPOLESTR * sync)
    { return base_get_syncBehavior(sync); }
    STDMETHOD(put_syncBehavior)(LPOLESTR sync)
    { return base_put_syncBehavior(sync); }

    STDMETHOD(get_syncTolerance)(VARIANT * tol)
    { return base_get_syncTolerance(tol); }
    STDMETHOD(put_syncTolerance)(VARIANT tol)
    { return base_put_syncTolerance(tol); }

    STDMETHOD(get_parentTIMEElement)(ITIMEElement **bvr)
    { return base_get_parentTIMEElement(bvr); }
    STDMETHOD(put_parentTIMEElement)(ITIMEElement *bvr)
    { return base_put_parentTIMEElement(bvr); }

    STDMETHOD(get_allTIMEElements)(/*[out, retval]*/ ITIMEElementCollection **ppDisp);
    STDMETHOD(get_childrenTIMEElements)(/*[out, retval]*/ ITIMEElementCollection **ppDisp);
    STDMETHOD(get_allTIMEInterfaces)(/*[out, retval]*/ ITIMEElementCollection **ppDisp);
    STDMETHOD(get_childrenTIMEInterfaces)(/*[out, retval]*/ ITIMEElementCollection **ppDisp);

    STDMETHOD(get_timelineBehavior)(IDispatch ** bvr)
    { return base_get_timelineBehavior(bvr); }
    STDMETHOD(get_progressBehavior)(IDispatch ** bvr)
    { return base_get_progressBehavior(bvr); }
    STDMETHOD(get_onOffBehavior)(IDispatch ** bvr)
    { return base_get_onOffBehavior(bvr); }

    virtual void OnLoad();
    virtual void OnBegin(double dblLocalTime, DWORD flags);
    virtual void OnEnd(double dblLocalTime);
    virtual void OnReset(double dblLocalTime, DWORD flags);
    virtual void OnPause(double dblLocalTime);
    virtual void OnResume(double dblLocalTime);
    virtual void OnSync(double dbllastTime, double & dblnewTime);
    virtual void OnRepeat(double dblLocalTime);

    virtual void OnUnload();

    // QI Map
    BEGIN_COM_MAP(CTIMEMediaElement)
        COM_INTERFACE_ENTRY(ITIMEMediaElement)
        COM_INTERFACE_ENTRY(ITIMEElement)
        COM_INTERFACE_ENTRY(IDispatch)
        COM_INTERFACE_ENTRY(ISupportErrorInfo)
        COM_INTERFACE_ENTRY_IMPL(IConnectionPointContainer)
        COM_INTERFACE_ENTRY(IPersistPropertyBag2)
        COM_INTERFACE_ENTRY_CHAIN(CDAElementBase)
        COM_INTERFACE_ENTRY(IPropertyNotifySink)
    END_COM_MAP();

    // Connection Point to allow IPropertyNotifySink
    BEGIN_CONNECTION_POINT_MAP(CTIMEMediaElement)
        CONNECTION_POINT_ENTRY(IID_IPropertyNotifySink)
    END_CONNECTION_POINT_MAP();

    // This must be in the derived class and not the base class since
    // the typecast down to the base class messes things up
    static inline HRESULT WINAPI
        InternalQueryInterface(CTIMEMediaElement* pThis,
                               const _ATL_INTMAP_ENTRY* pEntries,
                               REFIID iid,
                               void** ppvObject)
    { return BaseInternalQueryInterface(pThis,
                                        (void *) pThis,
                                        pEntries,
                                        iid,
                                        ppvObject); }

    // Needed by CBvrBase
    void * GetInstance()
    { return (ITIMEMediaElement *) this ; }
    HRESULT GetTypeInfo(ITypeInfo ** ppInfo)
    { return GetTI(GetUserDefaultLCID(), ppInfo); }

    bool isNaturalDuration() { return m_fDurationIsNatural;}
    void clearNaturalDuration() { m_fDurationIsNatural = false;}
    void setNaturalDuration() { m_fDurationIsNatural = true;}
    
  protected:
    HRESULT Error();

    enum PROPERTY_INDEX
    {
        tme_src = teb_maxTIMEElementBaseProp, tme_img, 
        tme_player, tme_type, tme_clipBegin, tme_clipEnd, tme_clockSource,
        tme_maxTIMEMediaProp,
    };

    virtual HRESULT BuildPropertyNameList (CPtrAry<BSTR> *paryPropNames);
    virtual HRESULT SetPropertyByIndex(unsigned uIndex, VARIANT *pvarProp);
    virtual HRESULT GetPropertyByIndex(unsigned uIndex, VARIANT *pvarProp);
    virtual void SetPropertyFlag(DWORD uIndex);
    virtual void ClearPropertyFlag(DWORD uIndex);
    virtual bool IsPropertySet(DWORD uIndex);

    HRESULT GetPropertyBagInfo(CPtrAry<BSTR> **pparyPropNames);
    virtual HRESULT GetConnectionPoint(REFIID riid, IConnectionPoint **ppICP);
    HRESULT GetNotifyConnection(IConnectionPoint **ppConnection);
    HRESULT InitPropertySink();
    HRESULT UnInitPropertySink();

    virtual bool NeedSyncCB();

    static LPWSTR ms_rgwszTMediaPropNames[];
    static CPtrAry<BSTR> ms_aryPropNames;
    static DWORD ms_dwNumTimeMediaElems;

    virtual HRESULT GetSize(RECT *prcPos);
    virtual HRESULT SetSize(const RECT *prcPos);

  private:
    HRESULT CalculateSeekTime(double *pdblTime);
    HRESULT RecreatePlayer();
    HRESULT CreatePlayer();

    LPOLESTR                    m_src;
    LPOLESTR                    m_img;
    LPOLESTR                    m_srcType;
    DAComPtr<IServiceProvider>  m_sp;
    MediaType                   m_type;
    CLSID                       m_playerCLSID;
    CTIMEPlayer                *m_Player;
    bool                        m_fClockSource;
    bool                        m_fLoaded;
    bool                        m_fExternalPlayer;
    DWORD                       m_mediaElementPropertyAccesFlags;
    RECT                        m_rcOrigSize;
    RECT                        m_rcMediaSize;
    bool                        m_fMediaSizeSet;
    DWORD                       m_dwAdviseCookie;
    bool                        m_fInOnChangedFlag;
    bool                        m_fDurationIsNatural;

};

inline HRESULT CTIMEMediaElement::get_allTIMEElements(ITIMEElementCollection **ppDisp)
{
    return base_get_collection(ciAllElements, ppDisp);
} // get_all

inline HRESULT CTIMEMediaElement::get_childrenTIMEElements(ITIMEElementCollection **ppDisp)
{
    return base_get_collection(ciChildrenElements, ppDisp);
} // get_children

inline HRESULT CTIMEMediaElement::get_allTIMEInterfaces(ITIMEElementCollection **ppDisp)
{
    return base_get_collection(ciAllInterfaces, ppDisp);
} // get_time_all

inline HRESULT CTIMEMediaElement::get_childrenTIMEInterfaces(ITIMEElementCollection **ppDisp)
{
    return base_get_collection(ciChildrenInterfaces, ppDisp);
} // get_time_children

inline bool 
CTIMEMediaElement::NeedSyncCB()
{   
    return true;
} // NeedSyncCB

#endif /* _MEDIAELM_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\time\src\player.h ===
/*******************************************************************************
 *
 * Copyright (c) 1998 Microsoft Corporation
 *
 * File: player.h
 *
 * Abstract:
 *
 *
 *
 *******************************************************************************/


#ifndef _PLAYER_H
#define _PLAYER_H

#include "daelmbase.h"
#include "containerobj.h"
#include "notify.h"


#define MediaPlayer L"{22d6f312-b0f6-11d0-94ab-0080c74c7e95}"
#define MP_INFINITY -1

/////////////////////////////////////////////////////////////////////////////
// CTTIMEPlayer

class CTIMEPlayer 
{
  public:
    CTIMEPlayer(CDAElementBase *pTIMEElem);
    ~CTIMEPlayer();

    HRESULT Init();
    HRESULT DetachFromHostElement (void);

    HRESULT OnLoad(LPOLESTR src, LPOLESTR img, MediaType type);
    void OnSync(double dbllastTime, double & dblnewTime);
    void SetCLSID(REFCLSID clsid);
    void Start(double dblLocalTime);
    void Stop();
    void Pause();
    void Resume();
    HRESULT Render(HDC hdc, LPRECT prc);

    HRESULT GetExternalPlayerDispatch(IDispatch **ppDisp);

    HRESULT getClipBegin(VARIANT *pvar);
    HRESULT putClipBegin(VARIANT var);
    HRESULT getClipEnd(VARIANT *pvar);
    HRESULT putClipEnd(VARIANT var);

    bool SetClockSource(bool fClockSource);
    HRESULT SetSize(RECT *prect);

    double GetCurrentTime();
    HRESULT Seek(double dblTime);

    CContainerObj* GetContainerObj() { return m_pContainer; }

  protected:

    void LoadAudio(LPOLESTR szURL);
    void LoadVideo(LPOLESTR szURL);
    void LoadImage(LPOLESTR szURL);
    void LoadMedia(LPOLESTR src, LPOLESTR img);
    void UseMediaPlayer(LPOLESTR src);
    
    CLSID               m_playerCLSID;
    CContainerObj      *m_pContainer;
    bool                m_fExternalPlayer;
    MediaType           m_type;
    CDAElementBase     *m_pDAElementBase;
    VARIANT             m_varClipBegin;
    VARIANT             m_varClipEnd;
    bool                m_fClockSource;
    bool                m_fRunning;
    double              m_dblStart;
};

inline bool
CTIMEPlayer::SetClockSource(bool fClockSource)
{
    m_fClockSource = fClockSource;
    return true;
} // SetClockSource

bool UseAudio(MediaType m_type);
bool UseImage(MediaType m_type);

#endif /* _PLAYER_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\time\src\player.cpp ===
/*******************************************************************************
 *
 * Copyright (c) 1998 Microsoft Corporation
 *
 * File: player.cpp
 *
 * Abstract:
 *
 *
 *
 *******************************************************************************/


#include "headers.h"
#include "player.h"

// Suppress new warning about NEW without corresponding DELETE 
// We expect GCs to cleanup values.  Since this could be a useful
// warning, we should disable this on a file by file basis.
#pragma warning( disable : 4291 )  

DeclareTag(tagMediaTimePlayer, "API", "CTIMEPlayer methods");

CTIMEPlayer::CTIMEPlayer(CDAElementBase *pelem)
: m_fExternalPlayer(false),
  m_pContainer(NULL),
  m_pDAElementBase(pelem),
  m_fClockSource(false),
  m_fRunning(false),
  m_dblStart(0.0)
{
    TraceTag((tagMediaTimePlayer,
              "CTIMEPlayer(%lx)::CTIMEPlayer()",
              this));

    VariantInit(&m_varClipBegin);
    VariantInit(&m_varClipEnd);
}

CTIMEPlayer::~CTIMEPlayer()
{
    TraceTag((tagMediaTimePlayer,
              "CTIMEPlayer(%lx)::~CTIMEPlayer()",
              this));

    if (m_pContainer != NULL)
    {
        m_pContainer->Release();
    }

    VariantClear(&m_varClipBegin);
    VariantClear(&m_varClipEnd);
}

HRESULT
CTIMEPlayer::Init()
{
    TraceTag((tagMediaTimePlayer,
              "CTIMEPlayer(%lx)::Init)",
              this));   

    Assert(m_pDAElementBase->GetView() != NULL);
    
    return S_OK;
}

HRESULT
CTIMEPlayer::DetachFromHostElement (void)
{
    HRESULT hr = S_OK;

    TraceTag((tagMediaTimePlayer,
              "CTIMEPlayer(%lx)::DetachFromHostElement)",
              this));   

    if (NULL != m_pContainer)
    {
        // Propogating this error wouldn't mean much 
        // to the caller since it is shutting down.
        THR(m_pContainer->Stop());
        THR(m_pContainer->DetachFromHostElement());
    }

    return hr;
}

HRESULT
CTIMEPlayer::OnLoad(LPOLESTR src, LPOLESTR img, MediaType type)
{
    TraceTag((tagMediaTimePlayer,
              "CTIMEPlayer(%lx)::OnLoad()",
              this));
    
    m_type = type;
    UseMediaPlayer(src);

    if(m_fExternalPlayer)
    {
        HRESULT hr;

        Assert(m_pContainer == NULL);
        m_pContainer = NEW CContainerObj();
        if (m_pContainer == NULL)
        {
            TraceTag((tagError, "CTIMEPlayer::Init - unable to alloc mem for container services!!!"));
            hr = E_OUTOFMEMORY;
            goto error_cleanup;
        }

        // NOTE: we hold a ref count to this object because it acts as a COM object we cannot delete it!
        m_pContainer->AddRef();

        hr = m_pContainer->Init(m_playerCLSID, m_pDAElementBase);
        if (FAILED(hr))
        {
            TraceTag((tagError, "CTIMEPlayer::Init - init failed"));
            goto error_cleanup;
        }

        hr = m_pContainer->SetMediaSrc(src);
        if (FAILED(hr))
        {
            TraceTag((tagError, "CTIMEPlayer::Init - unable set media src on player"));
            goto error_cleanup;
        }

        hr = m_pContainer->clipBegin(m_varClipBegin);
        if (FAILED(hr))
        {
            TraceTag((tagError, "CTIMEPlayer::Init - unable set ClipBegin on player"));
            goto error_cleanup;
        }

        hr = m_pContainer->clipEnd(m_varClipEnd);
        if (FAILED(hr))
        {
            TraceTag((tagError, "CTIMEPlayer::Init - unable set ClipEnd on player"));
            goto error_cleanup;
        }

        goto done;

// if we got an error, drop back
error_cleanup:
        if (m_pContainer != NULL)
        {
            delete m_pContainer;
            m_pContainer = NULL;
            m_fExternalPlayer = false;
        }
    }

    LoadMedia(src,img);

done:
    return S_OK;
}

void
CTIMEPlayer::OnSync(double dbllastTime, double & dblnewTime)
{
    TraceTag((tagMediaTimePlayer,
              "CTIMEPlayer(%lx)::OnSync(%g, %g)",
              this,
              dbllastTime,
              dblnewTime));
    
    // if we are not the external player and not running, go away
    if (!m_fExternalPlayer)
    {
        goto done;
    }

    if (m_fRunning)
    {
        // get current time from player and
        // sync to this time
        double dblCurrentTime;
        dblCurrentTime = m_pContainer->GetCurrentTime();

        TraceTag((tagMediaTimePlayer,
                  "CTIMEPlayer(%lx)::OnSync - player returned %g",
                  this,
                  dblCurrentTime));
    
        // If the current time is -1 then the player is not ready and we
        // should sync to the last time.  We also should not respect the
        // tolerance since the behavior has not started.
    
        if (dblCurrentTime < 0)
        {
            TraceTag((tagMediaTimePlayer,
                      "CTIMEPlayer(%lx)::OnSync - player returned -1 - setting to dbllastTime (%g)",
                      this,
                      dbllastTime));
    
            dblCurrentTime = 0;
            // When we want this to actually hold at the begin value then enable
            // this code
            // dblCurrentTime = -HUGE_VAL;
        }
        else if (dblnewTime == HUGE_VAL)
        {
            if (dblCurrentTime >= (m_pDAElementBase->GetRealRepeatTime() - m_pDAElementBase->GetRealSyncTolerance()))
            {
                TraceTag((tagMediaTimePlayer,
                          "CTIMEPlayer(%lx)::OnSync - new time is ended and player w/i sync tolerance of end",
                          this));
    
                goto done;
            }
        }
        else if (fabs(dblnewTime - dblCurrentTime) <= m_pDAElementBase->GetRealSyncTolerance())
        {
            TraceTag((tagMediaTimePlayer,
                      "CTIMEPlayer(%lx)::OnSync - player w/i sync tolerance (new:%g, curr:%g, diff:%g, tol:%g)",
                      this,
                      dblnewTime,
                      dblCurrentTime,
                      fabs(dblnewTime - dblCurrentTime),
                      m_pDAElementBase->GetRealSyncTolerance()));
    
            goto done;
        }
        
        if (m_fClockSource)
        {
            dblnewTime = dblCurrentTime;
        }
    }
    else if (!m_fRunning && m_pDAElementBase->IsDocumentInEditMode())
    {
        // if we are paused and in edit mode, make sure
        // WMP has the latest time.
        double dblMediaLen = 0.0f;
        TraceTag((tagMediaTimePlayer,
                "CTIMEPlayer(%lx)::OnSync(SeekTo=%g m_fRunning=%d)",
                this,
                dbllastTime, m_fRunning));
        // GetMediaLength fails if duration is indefinite (e.g. live stream).
        if (FAILED(m_pContainer->GetMediaLength(dblMediaLen)))
        {
            goto done;
        }

        // Don't seek beyond duration of media clip. 
        if (dbllastTime > dblMediaLen)
        {
            goto done;
        }

        if (m_pContainer != NULL)
            THR(m_pContainer->Seek(dbllastTime));
    }
  done:
    return ;
}    

void 
CTIMEPlayer::UseMediaPlayer(LPOLESTR src)
{
    LPOLESTR    MimeType = NULL;

    if(m_fExternalPlayer)
        return;

    if(SUCCEEDED(IsValidURL(NULL, src, 0)))
    {
        FindMimeFromData(NULL,src,NULL,NULL,NULL,0,&MimeType,0);
        // see if we have a valid URL and MIME type
        if(MimeType != NULL)
        {
            // pass to Windows Media Player is video or sound
            if((wcsncmp(L"audio", MimeType , 5 ) == 0) ||
               (wcsncmp(L"video", MimeType , 5 ) == 0) )
            {
               CLSID clsid;
               if(SUCCEEDED(CLSIDFromString(MediaPlayer, &clsid)))
               {
                    SetCLSID(clsid);
               }
            }
        }
    }

}

void
CTIMEPlayer::SetCLSID(REFCLSID clsid) 
{
    m_playerCLSID = clsid; 
    m_fExternalPlayer = true;
}


void
CTIMEPlayer::Start(double dblLocalTime)
{
    TraceTag((tagMediaTimePlayer,
              "CTIMEPlayer(%lx)::Start()",
              this));

    m_dblStart = dblLocalTime;

    if(m_fExternalPlayer && (NULL != m_pContainer))
        m_pContainer->Start();

    m_fRunning = true;
}

void
CTIMEPlayer::Stop()
{
    TraceTag((tagMediaTimePlayer,
              "CTIMEPlayer(%lx)::Stop()",
              this));
    
    m_fRunning = false;
    m_dblStart = 0.0;

    if(m_fExternalPlayer && (NULL != m_pContainer))
        m_pContainer->Stop();
}

void
CTIMEPlayer::Pause()
{
    TraceTag((tagMediaTimePlayer,
              "CTIMEPlayer(%lx)::Pause()",
              this));

    m_fRunning = false;

    if(m_fExternalPlayer && (NULL != m_pContainer))
        m_pContainer->Pause();
}

void
CTIMEPlayer::Resume()
{
    TraceTag((tagMediaTimePlayer,
              "CTIMEPlayer(%lx)::Resume()",
              this));

    if(m_fExternalPlayer && (NULL != m_pContainer))
        m_pContainer->Resume();

    m_fRunning = true;
}
    
HRESULT
CTIMEPlayer::Render(HDC hdc, LPRECT prc)
{
    TraceTag((tagMediaTimePlayer,
              "CTIMEPlayer(%lx)::Render()",
              this));
    HRESULT hr;

    if (m_fExternalPlayer)
    {
        if (NULL != m_pContainer)
        {
            hr = THR(m_pContainer->Render(hdc, prc));
        }
        else
        {
            hr = E_UNEXPECTED;
        }
    }
    else
    {
        if (!m_pDAElementBase->GetView()->Render(hdc, prc))
        {
            hr = CRGetLastError();
        }
    }

    return hr;
}


void
CTIMEPlayer::LoadImage(LPOLESTR szURL)
{
    // we have an image 
    CRImagePtr pImage;
    CREventPtr pEvent;
    CRNumberPtr pProgress;
    CRNumberPtr pSize;
    CREventPtr pev;

    if((szURL != NULL) && UseImage(m_type))
    {

        Assert(m_pDAElementBase);

        CRLockGrabber __gclg;
        CRImportImage(m_pDAElementBase->GetURLOfClientSite(), szURL, NULL, 
                           NULL, false, 0, 0,
                           0, CREmptyImage(),&pImage,
                           &pEvent,&pProgress, &pSize);

        RECT rc;
        CTIMENotifyer *notifyier = NEW CTIMENotifyer(m_pDAElementBase);
        if(SUCCEEDED(m_pDAElementBase->GetSize(&rc))) {
            if( (rc.right  - rc.left == 0) ||
                (rc.bottom - rc.top  == 0)) {
                // we need to set the size..
                pev = CRNotify(CRSnapshot(pEvent,(CRBvrPtr)CRBoundingBox(pImage)), notifyier);
            }
            else {
                // size is set for us..
                pev = CRNotify(pEvent,notifyier);
            }
            m_pDAElementBase->SetImage((CRImagePtr)CRUntil((CRBvrPtr)pImage,pev,(CRBvrPtr)pImage));
        }
    }
}

void
CTIMEPlayer::LoadAudio(LPOLESTR szURL)
{
    CRSoundPtr pSound;
    CRNumberPtr pDuration;

    if((szURL != NULL) && UseAudio(m_type))
    {
        CRLockGrabber __gclg;

        CRImportSound(m_pDAElementBase->GetURLOfClientSite(), szURL, NULL, 
                           NULL, true, CRSilence(),
                           &pSound, &pDuration,
                           NULL, NULL, NULL);

        m_pDAElementBase->SetSound(pSound);
    }
}

void
CTIMEPlayer::LoadVideo(LPOLESTR szURL)
{
    CRImagePtr pImage;
    CRSoundPtr pSound;
    CRNumberPtr pDuration;

    if(szURL != NULL)
    {
        CRLockGrabber __gclg;

        CRImportMovie(m_pDAElementBase->GetURLOfClientSite(), szURL, NULL, 
                           NULL, true, NULL, NULL,
                           &pImage, &pSound,
                           &pDuration, NULL,
                           NULL, NULL);

        if(UseImage(m_type)) m_pDAElementBase->SetImage(pImage);
        if(UseAudio(m_type)) m_pDAElementBase->SetSound(pSound);
    }
}

void
CTIMEPlayer::LoadMedia(LPOLESTR src, LPOLESTR img)
{   
    LPOLESTR    szURL;
    LPOLESTR    MimeType = NULL;
    bool        bSecondAttempt = false;

    szURL = CopyString(src);

try_imgURL:
    if(SUCCEEDED(IsValidURL(NULL, szURL, 0)))
    {
        FindMimeFromData(NULL,szURL,NULL,NULL,NULL,0,&MimeType,0);
        // see if we have a valid URL and MIME type
        if(MimeType != NULL)
        {
            // Load the correct media...
            if(wcsncmp(L"image", MimeType , 5 ) == 0)
            {
                LoadImage(szURL); // we have an image 
                goto done;
            }
            else if(wcsncmp(L"audio", MimeType , 5 ) == 0)
            {
                LoadAudio(szURL); // we have an sound
                goto done;
            }
            else if(wcsncmp(L"video", MimeType , 5 ) == 0)
            {
                LoadVideo(szURL); // we have an movie
                goto done;
            }
        }
    }
    if(!bSecondAttempt && img != NULL)
    {
        // We were unable to get the MIME type from the src URL ... we should just
        // display the URL specified in the img URL.
        szURL = CopyString(img);
        m_type = MT_Image;          // Only valid for visual types.
        bSecondAttempt = true;
        goto try_imgURL;
    }
    CRSetLastError(DISP_E_TYPEMISMATCH,NULL);

done:
    return;
}

HRESULT
CTIMEPlayer::GetExternalPlayerDispatch(IDispatch **ppDisp)
{
    // check to see if player is being used
    if (!m_fExternalPlayer || (m_pContainer == NULL))
        return E_UNEXPECTED;

    return m_pContainer->GetControlDispatch(ppDisp);
}

HRESULT 
CTIMEPlayer::getClipBegin(VARIANT *pvar)
{
    HRESULT hr = S_OK;

    Assert(pvar != NULL);

    // prepare var for copy
    hr = THR(VariantClear(pvar));
    if (FAILED(hr))
        goto done;

    // copy contents over
    if (m_varClipBegin.vt != VT_EMPTY)
    {
        hr = THR(VariantCopy(pvar, &m_varClipBegin));
        if (FAILED(hr))
            goto done;
    }

done:
    return hr;
}

HRESULT 
CTIMEPlayer::putClipBegin(VARIANT var)
{
    HRESULT hr = S_OK;
    VARIANT varTemp;

    VariantInit(&varTemp);

    // if cached var is not empty, save off contents
    // so we can undo if error occurs
    if (m_varClipBegin.vt != VT_EMPTY)
    {
        hr = THR(VariantCopy(&varTemp, &m_varClipBegin));
        // if this failed, exit with out trying to recover.
        if (FAILED(hr))
            goto done;
    }

    // copy the contents over
    hr = THR(VariantClear(&m_varClipBegin));
    if (FAILED(hr))
        goto error;

    hr = THR(VariantCopy(&m_varClipBegin, &var));
    if (FAILED(hr))
        goto error;

    // Eat the HRESULT as we have updated the var
    THR(VariantClear(&varTemp));

    goto done;

error:
    if (varTemp.vt != VT_EMPTY)
        THR(VariantCopy(&m_varClipBegin, &varTemp));
    else
        VariantInit(&m_varClipBegin);

    THR(VariantClear(&varTemp));

done:
    return hr;

}

HRESULT 
CTIMEPlayer::getClipEnd(VARIANT *pvar)
{
    HRESULT hr = S_OK;

    Assert(pvar != NULL);

    // prepare var for copy
    hr = THR(VariantClear(pvar));
    if (FAILED(hr))
        goto done;

    // copy contents over
    if (m_varClipEnd.vt != VT_EMPTY)
    {
        hr = THR(VariantCopy(pvar, &m_varClipEnd));
        if (FAILED(hr))
            goto done;
    }

done:
    return hr;
}

HRESULT 
CTIMEPlayer::putClipEnd(VARIANT var)
{
    HRESULT hr = S_OK;
    VARIANT varTemp;

    VariantInit(&varTemp);

    // if cached var is not empty, save off contents
    // so we can undo if error occurs
    if (m_varClipEnd.vt != VT_EMPTY)
    {
        hr = THR(VariantCopy(&varTemp, &m_varClipEnd));
        // if this failed, exit with out trying to recover.
        if (FAILED(hr))
            goto done;
    }

    // copy the contents over
    hr = THR(VariantClear(&m_varClipEnd));
    if (FAILED(hr))
        goto error;

    hr = THR(VariantCopy(&m_varClipEnd, &var));
    if (FAILED(hr))
        goto error;

    // Eat the HRESULT as we have updated the var
    THR(VariantClear(&varTemp));
    
    goto done;    

error:
    if (varTemp.vt != VT_EMPTY)
        THR(VariantCopy(&m_varClipEnd, &varTemp));
    else
        VariantInit(&m_varClipEnd);

    THR(VariantClear(&varTemp));

done:
    return hr;

}

// Helper functions..

bool UseAudio(MediaType m_type)
{
    return (m_type != MT_Image);
}

bool UseImage(MediaType m_type)
{
    return (m_type != MT_Audio);
}

double 
CTIMEPlayer::GetCurrentTime()
{
    double dblCurrentTime = 0;
    
    if (m_pContainer != NULL)
    {
        dblCurrentTime = m_pContainer->GetCurrentTime();
    }
    
    return dblCurrentTime;
}

HRESULT
CTIMEPlayer::Seek(double dblTime)
{
    HRESULT hr = S_FALSE;

    if (m_pContainer != NULL)
    {
        hr = m_pContainer->Seek(dblTime);
    }
    else
    {
        // time transform the da image
        this->m_pDAElementBase->SeekImage(dblTime);
    }

    return hr;
}

HRESULT
CTIMEPlayer::SetSize(RECT *prect)
{
    if(m_pContainer == NULL) return E_FAIL;
    return m_pContainer -> SetSize(prect);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\time\src\timeelm.cpp ===
/*******************************************************************************
 *
 * Copyright (c) 1998 Microsoft Corporation
 *
 * File: timeelm.cpp
 *
 * Abstract:
 *
 *
 *
 *******************************************************************************/


#include "headers.h"
#include "timeelm.h"

DeclareTag(tagTimeElm, "API", "CTIMEElement methods");

// static class data.
CPtrAry<BSTR> CTIMEElement::ms_aryPropNames;
DWORD CTIMEElement::ms_dwNumTimeElems = 0;

CTIMEElement::CTIMEElement()
{
    m_clsid = __uuidof(CTIMEElement);
    TraceTag((tagTimeElm,
              "CTIMEElement(%lx)::CTIMEElement()",
              this));
    CTIMEElement::ms_dwNumTimeElems++;
}

CTIMEElement::~CTIMEElement()
{
    CTIMEElement::ms_dwNumTimeElems--;

    if (0 == CTIMEElement::ms_dwNumTimeElems)
    {
        int iNames = CTIMEElement::ms_aryPropNames.Size();

        for (int i = iNames - 1; i >= 0; i--)
        {
            BSTR bstrName = CTIMEElement::ms_aryPropNames[i];
            CTIMEElement::ms_aryPropNames.DeleteItem(i);
            ::SysFreeString(bstrName);
        }
    }
}


HRESULT
CTIMEElement::Error()
{
    LPCWSTR str = CRGetLastErrorString();
    HRESULT hr = CRGetLastError();
    
    if (str)
        return CComCoClass<CTIMEElement, &__uuidof(CTIMEElement)>::Error(str, IID_ITIMEElement, hr);
    else
        return hr;
}

//*****************************************************************************

HRESULT 
CTIMEElement::GetPropertyBagInfo(CPtrAry<BSTR> **pparyPropNames)
{
    HRESULT hr = S_OK;

    // If we haven't built this yet, build it now.
    if (0 == ms_aryPropNames.Size())
    {
        hr = BuildPropertyNameList(&(CTIMEElement::ms_aryPropNames));
    }

    if (SUCCEEDED(hr))
    {
        *pparyPropNames = &(CTIMEElement::ms_aryPropNames);
    }

    return hr;
} // GetPropertyBagInfo

//*****************************************************************************

HRESULT 
CTIMEElement::GetConnectionPoint(REFIID riid, IConnectionPoint **ppICP)
{
    return FindConnectionPoint(riid, ppICP);
} // GetConnectionPoint


//*****************************************************************************
#undef THIS
#define THIS CTIMEElement
#define SUPER CTIMEElementBase

#include "pbagimp.cpp"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\time\src\pbagimp.cpp ===
//*****************************************************************************
//
// File: pbagimp.cpp
// Author: jeff ort
// Date Created: Sept 26, 1998
//
// Abstract: Implementation of IPersistPropertyBag2 interface
//           for all objects to call to base class.
//
// Modification List:
// Date		Author		Change
// 11/21/98	jeffort		Created this file
//
//*****************************************************************************

STDMETHODIMP 
THIS::GetClassID(CLSID* pclsid)
{
    return SUPER::GetClassID(pclsid);
} // GetClassID

//*****************************************************************************

STDMETHODIMP 
THIS::InitNew(void)
{
    return SUPER::InitNew();
} // InitNew

//*****************************************************************************

STDMETHODIMP 
THIS::Load(IPropertyBag2 *pPropBag,IErrorLog *pErrorLog)
{
    return SUPER::Load(pPropBag, pErrorLog);
} // Load

//*****************************************************************************

STDMETHODIMP 
THIS::Save(IPropertyBag2 *pPropBag, BOOL fClearDirty, BOOL fSaveAllProperties)
{
    return SUPER::Save(pPropBag, fClearDirty, fSaveAllProperties);

} // Save 

//*****************************************************************************

//*****************************************************************************
//
// End of File
//
//*****************************************************************************
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\time\src\timeelm.h ===
/*******************************************************************************
 *
 * Copyright (c) 1998 Microsoft Corporation
 *
 * File: timeelm.h
 *
 * Abstract:
 *
 *
 *
 *******************************************************************************/


#ifndef _TIMEELM_H
#define _TIMEELM_H

#include "timeelmbase.h"

/////////////////////////////////////////////////////////////////////////////
// CTIMEElement

class
ATL_NO_VTABLE
__declspec(uuid("efbad7f8-3f94-11d2-b948-00c04fa32195")) 
CTIMEElement :
    public CTIMEElementBase,
    public CComCoClass<CTIMEElement, &__uuidof(CTIMEElement)>,
    public IDispatchImpl<ITIMEElement, &IID_ITIMEElement, &LIBID_TIME>,
    public ISupportErrorInfoImpl<&IID_ITIMEElement>,
    public IConnectionPointContainerImpl<CTIMEElement>,
    public IPersistPropertyBag2,
    public IPropertyNotifySinkCP<CTIMEElement>
{
  public:
    CTIMEElement();
    ~CTIMEElement();
        
#if _DEBUG
    const _TCHAR * GetName() { return __T("CTIMEElement"); }
#endif

    //
    //IPersistPropertyBag2
    // 
    STDMETHOD(GetClassID)(CLSID* pclsid);
    STDMETHOD(InitNew)(void);
    STDMETHOD(IsDirty)(void)
        {return S_OK;};
    STDMETHOD(Load)(IPropertyBag2 *pPropBag,IErrorLog *pErrorLog);
    STDMETHOD(Save)(IPropertyBag2 *pPropBag, BOOL fClearDirty, BOOL fSaveAllProperties);

    //
    // ITIMEElement
    //
    
    STDMETHOD(get_begin)(VARIANT * time)
    { return base_get_begin(time); }
    STDMETHOD(put_begin)(VARIANT time)
    { return base_put_begin(time); }

    STDMETHOD(get_beginWith)(VARIANT * time)
    { return base_get_beginWith(time); }
    STDMETHOD(put_beginWith)(VARIANT time)
    { return base_put_beginWith(time); }

    STDMETHOD(get_beginAfter)(VARIANT * time)
    { return base_get_beginAfter(time); }
    STDMETHOD(put_beginAfter)(VARIANT time)
    { return base_put_beginAfter(time); }

    STDMETHOD(get_beginEvent)(VARIANT * time)
    { return base_get_beginEvent(time); }
    STDMETHOD(put_beginEvent)(VARIANT time)
    { return base_put_beginEvent(time); }

    STDMETHOD(get_dur)(VARIANT * time)
    { return base_get_dur(time); }
    STDMETHOD(put_dur)(VARIANT time)
    { return base_put_dur(time); }

    STDMETHOD(get_end)(VARIANT * time)
    { return base_get_end(time); }
    STDMETHOD(put_end)(VARIANT time)
    { return base_put_end(time); }

    STDMETHOD(get_endWith)(VARIANT * time)
    { return base_get_endWith(time); }
    STDMETHOD(put_endWith)(VARIANT time)
    { return base_put_endWith(time); }

    STDMETHOD(get_endEvent)(VARIANT * time)
    { return base_get_endEvent(time); }
    STDMETHOD(put_endEvent)(VARIANT time)
    { return base_put_endEvent(time); }

    STDMETHOD(get_endSync)(VARIANT * time)
    { return base_get_endSync(time); }
    STDMETHOD(put_endSync)(VARIANT time)
    { return base_put_endSync(time); }

    STDMETHOD(get_repeat)(VARIANT * time)
    { return base_get_repeat(time); }
    STDMETHOD(put_repeat)(VARIANT time)
    { return base_put_repeat(time); }

    STDMETHOD(get_repeatDur)(VARIANT * time)
    { return base_get_repeatDur(time); }
    STDMETHOD(put_repeatDur)(VARIANT time)
    { return base_put_repeatDur(time); }

    STDMETHOD(get_accelerate)(int * time)
    { return base_get_accelerate(time); }
    STDMETHOD(put_accelerate)(int time)
    { return base_put_accelerate(time); }

    STDMETHOD(get_decelerate)(int * time)
    { return base_get_decelerate(time); }
    STDMETHOD(put_decelerate)(int time)
    { return base_put_decelerate(time); }

    STDMETHOD(get_autoReverse)(VARIANT_BOOL * b)
    { return base_get_autoReverse(b); }
    STDMETHOD(put_autoReverse)(VARIANT_BOOL b)
    { return base_put_autoReverse(b); }

    STDMETHOD(get_endHold)(VARIANT_BOOL * b)
    { return base_get_endHold(b); }
    STDMETHOD(put_endHold)(VARIANT_BOOL b)
    { return base_put_endHold(b); }

    STDMETHOD(get_eventRestart)(VARIANT_BOOL * b)
    { return base_get_eventRestart(b); }
    STDMETHOD(put_eventRestart)(VARIANT_BOOL b)
    { return base_put_eventRestart(b); }

    STDMETHOD(get_timeAction)(LPOLESTR * time)
    { return base_get_timeAction(time); }
    STDMETHOD(put_timeAction)(LPOLESTR time)
    { return base_put_timeAction(time); }

    STDMETHOD(beginElement)()
    { return base_beginElement(true); }
    STDMETHOD(endElement)()
    { return base_endElement(); }
    STDMETHOD(pause)()
    { return base_pause(); }
    STDMETHOD(resume)()
    { return base_resume(); }
    STDMETHOD(cue)()
    { return base_cue(); }

    STDMETHOD(get_timeline)(BSTR * pbstrTimeLine)
    { return base_get_timeline(pbstrTimeLine); }
    STDMETHOD(put_timeline)(BSTR bstrTimeLine)
    { return base_put_timeline(bstrTimeLine); }

    STDMETHOD(get_currTime)(float * time)
    { return base_get_currTime(time); }
    STDMETHOD(put_currTime)(float time)
    { return base_put_currTime(time); }

    STDMETHOD(get_localTime)(float * time)
    { return base_get_localTime(time); }
    STDMETHOD(put_localTime)(float time)
    { return base_put_localTime(time); }

    STDMETHOD(get_currState)(LPOLESTR * state)
    { return base_get_currState(state); }
    STDMETHOD(put_currState)(LPOLESTR state)
    { return base_put_currState(state); }

    STDMETHOD(get_syncBehavior)(LPOLESTR * sync)
    { return base_get_syncBehavior(sync); }
    STDMETHOD(put_syncBehavior)(LPOLESTR sync)
    { return base_put_syncBehavior(sync); }

    STDMETHOD(get_syncTolerance)(VARIANT * tol)
    { return base_get_syncTolerance(tol); }
    STDMETHOD(put_syncTolerance)(VARIANT tol)
    { return base_put_syncTolerance(tol); }

    STDMETHOD(get_parentTIMEElement)(ITIMEElement **bvr)
    { return base_get_parentTIMEElement(bvr); }
    STDMETHOD(put_parentTIMEElement)(ITIMEElement *bvr)
    { return base_put_parentTIMEElement(bvr); }

    STDMETHOD(get_allTIMEElements)(/*[out, retval]*/ ITIMEElementCollection **ppDisp);
    STDMETHOD(get_childrenTIMEElements)(/*[out, retval]*/ ITIMEElementCollection **ppDisp);
    STDMETHOD(get_allTIMEInterfaces)(/*[out, retval]*/ ITIMEElementCollection **ppDisp);
    STDMETHOD(get_childrenTIMEInterfaces)(/*[out, retval]*/ ITIMEElementCollection **ppDisp);

    STDMETHOD(get_timelineBehavior)(IDispatch ** bvr)
    { return base_get_timelineBehavior(bvr); }
    STDMETHOD(get_progressBehavior)(IDispatch ** bvr)
    { return base_get_progressBehavior(bvr); }
    STDMETHOD(get_onOffBehavior)(IDispatch ** bvr)
    { return base_get_onOffBehavior(bvr); }

    // QI Map
    
    BEGIN_COM_MAP(CTIMEElement)
        COM_INTERFACE_ENTRY(ITIMEElement)
        COM_INTERFACE_ENTRY(IDispatch)
        COM_INTERFACE_ENTRY(ISupportErrorInfo)
        COM_INTERFACE_ENTRY(IPersistPropertyBag2)
        COM_INTERFACE_ENTRY_IMPL(IConnectionPointContainer)
        COM_INTERFACE_ENTRY_CHAIN(CBaseBvr)
    END_COM_MAP();

    // Connection Point to allow IPropertyNotifySink
    BEGIN_CONNECTION_POINT_MAP(CTIMEElement)
        CONNECTION_POINT_ENTRY(IID_IPropertyNotifySink)
    END_CONNECTION_POINT_MAP();

    // This must be in the derived class and not the base class since
    // the typecast down to the base class messes things up
    static inline HRESULT WINAPI
        InternalQueryInterface(CTIMEElement* pThis,
                               const _ATL_INTMAP_ENTRY* pEntries,
                               REFIID iid,
                               void** ppvObject)
    { return BaseInternalQueryInterface(pThis,
                                        (void *) pThis,
                                        pEntries,
                                        iid,
                                        ppvObject); }

    // Needed by CBvrBase
    
    void * GetInstance()
    { return (ITIMEElement *) this ; }
    HRESULT GetTypeInfo(ITypeInfo ** ppInfo)
    { return GetTI(GetUserDefaultLCID(), ppInfo); }
    
  protected:
    
    HRESULT Error();
    HRESULT GetPropertyBagInfo(CPtrAry<BSTR> **pparyPropNames);
    virtual HRESULT GetConnectionPoint(REFIID riid, IConnectionPoint **ppICP);

    static CPtrAry<BSTR> ms_aryPropNames;
    static DWORD ms_dwNumTimeElems;

};

//************************************************************

inline HRESULT CTIMEElement::get_allTIMEElements(ITIMEElementCollection **ppDisp)
{
    return base_get_collection(ciAllElements, ppDisp);
} // get_all

inline HRESULT CTIMEElement::get_childrenTIMEElements(ITIMEElementCollection **ppDisp)
{
    return base_get_collection(ciChildrenElements, ppDisp);
} // get_children

inline HRESULT CTIMEElement::get_allTIMEInterfaces(ITIMEElementCollection **ppDisp)
{
    return base_get_collection(ciAllInterfaces, ppDisp);
} // get_time_all

inline HRESULT CTIMEElement::get_childrenTIMEInterfaces(ITIMEElementCollection **ppDisp)
{
    return base_get_collection(ciChildrenInterfaces, ppDisp);
} // get_time_children

#endif /* _TIMEELM_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\time\src\timeman.cpp ===
/*******************************************************************************
 *
 * Copyright (c) 1998 Microsoft Corporation
 *
 * File: TimeMan.cpp
 *
 * Abstract:
 *
 *
 *
 *******************************************************************************/


#include "headers.h"
#include "timeman.h"
#include "timeelm.h"

DeclareTag(tagTimeMan, "API", "CTIMETimeManager methods");

CTIMETimeManager::CTIMETimeManager()
{
    TraceTag((tagTimeMan,
              "CTIMETimeManager(%lx)::CTIMETimeManager()",
              this));
}

CTIMETimeManager::~CTIMETimeManager()
{
    TraceTag((tagTimeMan,
              "CTIMETimeManager(%lx)::~CTIMETimeManager()",
              this));

}

void
CTIMETimeManager::Add(CTIMEElement *pTimeElement)
{
    TraceTag((tagTimeMan,
              "CTIMETimeManager(%lx)::Add()",
              this));

    float       fBeginTime;
    bool        bWith=false;
    CComVariant var;
    TimeLineMap::iterator i;
    USES_CONVERSION;
    
    char * tagName =  W2A(pTimeElement->GetTagName());
    pTimeElement->get_beginWith(&var);
    if(var.bstrVal != NULL)
    {
        bWith = true;
    }
    else
    {
        pTimeElement->get_beginAfter(&var);
    }

    fBeginTime = pTimeElement->GetBeginTime();
    if(var.bstrVal == NULL)
    {
        // we should add this to the begin list.
        pTimeElement->SetRealTime(fBeginTime);
        m_TimeLine[tagName] = pTimeElement;
    }
    else
    {
        char * dependantName =  W2A(var.bstrVal);
        i = m_TimeLine.find(dependantName);
        if (i != m_TimeLine.end())
        {
            // found it....
            CTIMEElement *pTimeEle;
            pTimeEle = (*i).second;
            if(bWith)
            {
                pTimeElement->SetRealTime(pTimeEle->GetRealTime() + fBeginTime);
            }
            else
            {
                float dur = CalculateDuration(pTimeEle);
                if(dur == valueNotSet) // no duration ...default to forever. 
                    goto AddToWaitList;
                pTimeElement->SetRealTime(pTimeEle->GetRealTime() + dur + fBeginTime);

            }
            m_TimeLine[tagName] = pTimeElement;
        }
        else
        {
            // not found....
AddToWaitList:
            m_NotFinishedList.push_back(pTimeElement);
        }
    }
    // Check the ones that are not in the map 
    InsertElements();

/*
    // this is for debugging only...
    char buf[256];
    for (i = m_TimeLine.begin(); i != m_TimeLine.end(); i++) 
    {
        CTIMEElement *pTimeEle;
        pTimeEle = (*i).second;
        char * tagName =  W2A(pTimeEle->GetTagName());
        wsprintf(buf,"name %s, time %d\n",tagName,(int)pTimeEle->GetRealTime());
        OutputDebugString(buf);
    }
*/
}


void
CTIMETimeManager::Remove(CTIMEElement *pTimeElement)
{
    TraceTag((tagTimeMan,
              "CTIMETimeManager(%lx)::Remove()",
              this));

    TimeLineMap::iterator i;
    USES_CONVERSION;

    char * tagName =  W2A(pTimeElement->GetTagName());
    m_TimeLine.erase(tagName);
}


void
CTIMETimeManager::Recalc()
{
    TraceTag((tagTimeMan,
              "CTIMETimeManager(%lx)::Recalc()",
              this));
    
    USES_CONVERSION;

    // Need to recalc the timeline....
    
    TimeLineMap::iterator i;
    CComVariant var;

    for (i = m_TimeLine.begin(); i != m_TimeLine.end(); i++) 
    {
        CTIMEElement *pTimeEle;
        pTimeEle = (*i).second;
        pTimeEle->get_beginWith(&var);
        if(var.bstrVal == NULL)
        {
            pTimeEle->get_beginAfter(&var);
        }
        if(var.bstrVal != NULL)
        {
            // this needs to be taken out and recalced...
            pTimeEle->SetRealTime(0.0);
            m_NotFinishedList.push_back(pTimeEle);
            m_TimeLine.erase(i);
        }
        else 
        {
            // just make sure that the RealTime is set correctly..
            pTimeEle->SetRealTime(pTimeEle->GetBeginTime());
        }
    }
    InsertElements();
}


void
CTIMETimeManager::InsertElements()
{
    TraceTag((tagTimeMan,
              "CTIMETimeManager(%lx)::InsertElements()",
              this));

    TimeLineMap::iterator i;
    bool        bWith;
    CComVariant var; 
    USES_CONVERSION;

       // we also need to run though the temp ones to see if they can be moved to the map...
startProcess:
    for (std::list<CTIMEElement *>::iterator j = m_NotFinishedList.begin(); j != m_NotFinishedList.end(); j++) 
    {
        bWith = false; 
        (*j)->get_beginWith(&var);
        if(var.bstrVal != NULL)
        {
            bWith = true;
        }
        else
        {
            (*j)->get_beginAfter(&var);
        }
        char * dependantName =  W2A(var.bstrVal);
        i = m_TimeLine.find(dependantName);
        if (i != m_TimeLine.end())
        {
            // found it....
            CTIMEElement *pTimeEle;
            pTimeEle = (*i).second;
            if(bWith) 
            {
                (*j)->SetRealTime(pTimeEle->GetRealTime() + (*j)->GetBeginTime());
            }
            else
            {
                float dur = CalculateDuration(pTimeEle);
                if(dur == valueNotSet) // no duration ...default to forever. 
                    continue;
                (*j)->SetRealTime(pTimeEle->GetRealTime() + dur + (*j)->GetBeginTime());
            }
        
            char * tagName =  W2A((*j)->GetTagName());
            m_TimeLine[tagName] = (*j);
            m_NotFinishedList.erase(j); // remove from notFinished List..
            goto startProcess;          // the data has changed start over....
        }      
    }
}


float 
CTIMETimeManager::CalculateDuration(CTIMEElement *pTimeEle)
{
    TraceTag((tagTimeMan,
              "CTIMETimeManager(%lx)::CalculateDuration()",
              this));

    float repeatCount;
    float dur = pTimeEle->GetDuration();
    if(dur == valueNotSet) // no duration ...default to forever. 
        goto done;
    
    repeatCount = pTimeEle->GetRepeat();
    if(repeatCount != valueNotSet)
        dur *= repeatCount;
    else
    {
        if(valueNotSet != pTimeEle->GetRepeatDur())
            dur = pTimeEle->GetRepeatDur();
    }
done:
    return dur;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\time\src\timeelmbase.h ===
/*******************************************************************************
 *
 * Copyright (c) 1998 Microsoft Corporation
 *
 * File: timeelmbase.h
 *
 * Abstract:
 *
 *
 *
 *******************************************************************************/


#ifndef _TIMEELMBASE_H
#define _TIMEELMBASE_H

#include "resource.h"
#include "basebvr.h"
#include "tokens.h"
#include "eventmgr.h"
#include "mmutil.h"
#include "collect.h"

class CCollectionCache;

/////////////////////////////////////////////////////////////////////////////
// CTIMEElementBase

class
ATL_NO_VTABLE
CTIMEElementBase : 
    public CBaseBvr
{
  public:
    CTIMEElementBase();
    ~CTIMEElementBase();
        
#if _DEBUG
    const _TCHAR * GetName() { return __T("CTIMEElementBase"); }
#endif

    STDMETHOD(Init)(IElementBehaviorSite * pBvrSite);
    STDMETHOD(Notify)(LONG event, VARIANT * pVar);
    STDMETHOD(Detach)();

    // We cannot put the real one here since the typecast causes it to
    // get the wrong vtables
    static HRESULT WINAPI
        BaseInternalQueryInterface(CTIMEElementBase* pThis,
                                   void * pv,
                                   const _ATL_INTMAP_ENTRY* pEntries,
                                   REFIID iid,
                                   void** ppvObject);

    // This must be in the derived class and not the base class since
    // the typecast down to the base class messes things up
    // Add a dummy one to assert just in case the derived class does
    // not add one
    static inline HRESULT WINAPI
        InternalQueryInterface(CTIMEElementBase* pThis,
                               const _ATL_INTMAP_ENTRY* pEntries,
                               REFIID iid,
                               void** ppvObject)
    {
        AssertStr(false, "InternalQueryInterface not defined in base class");
        return E_FAIL;
    }


    virtual void OnLoad() { m_bLoaded = true; }
    virtual void OnUnload() { }
    virtual void OnBeforeUnload (void) 
        { m_bUnloading = true; }

    virtual void OnPropChange(LPOLESTR propname) {}
    virtual void OnReadyStateChange(TOKEN state) {}

    virtual void OnBegin(double dblLocalTime, DWORD flags);
    virtual void OnEnd(double dblLocalTime);
    virtual void OnPause(double dblLocalTime);
    virtual void OnResume(double dblLocalTime);
    virtual void OnReset(double dblLocalTime, DWORD flags);
    virtual void OnSync(double dbllastTime, double & dblnewTime);
    virtual void OnRepeat(double dbllastTime) {};

    virtual MMView *GetView() { return NULL; }
    
    virtual HRESULT STDMETHODCALLTYPE QueryInterface(REFIID riid, void **ppv) = 0;


    //
    // ITIMEElement
    //
    
    HRESULT base_get_begin(VARIANT * time);
    HRESULT base_put_begin(VARIANT time);

    HRESULT base_get_beginWith(VARIANT * time);
    HRESULT base_put_beginWith(VARIANT time);

    HRESULT base_get_beginAfter(VARIANT * time);
    HRESULT base_put_beginAfter(VARIANT time);

    HRESULT base_get_beginEvent(VARIANT * time);
    HRESULT base_put_beginEvent(VARIANT time);

    HRESULT base_get_dur(VARIANT * time);
    HRESULT base_put_dur(VARIANT time);

    HRESULT base_get_end(VARIANT * time);
    HRESULT base_put_end(VARIANT time);

    HRESULT base_get_endWith(VARIANT * time);
    HRESULT base_put_endWith(VARIANT time);

    HRESULT base_get_endEvent(VARIANT * time);
    HRESULT base_put_endEvent(VARIANT time);
    
    HRESULT base_get_endSync(VARIANT * time);
    HRESULT base_put_endSync(VARIANT time);

    HRESULT base_get_repeat(VARIANT * time);
    HRESULT base_put_repeat(VARIANT time);

    HRESULT base_get_repeatDur(VARIANT * time);
    HRESULT base_put_repeatDur(VARIANT time);

    HRESULT base_get_accelerate(int * time);
    HRESULT base_put_accelerate(int time);

    HRESULT base_get_decelerate(int * time);
    HRESULT base_put_decelerate(int time);

    HRESULT base_get_autoReverse(VARIANT_BOOL * b);
    HRESULT base_put_autoReverse(VARIANT_BOOL b);

    HRESULT base_get_endHold(VARIANT_BOOL * b);
    HRESULT base_put_endHold(VARIANT_BOOL b);

    HRESULT base_get_eventRestart(VARIANT_BOOL * b);
    HRESULT base_put_eventRestart(VARIANT_BOOL b);

    HRESULT base_get_timeAction(LPOLESTR * time);
    HRESULT base_put_timeAction(LPOLESTR time);

    HRESULT base_beginElement(bool bAfterOffset);
    HRESULT base_endElement();
    virtual HRESULT base_pause();
    virtual HRESULT base_resume();
    HRESULT base_cue();

    HRESULT base_get_timeline(BSTR *);
    HRESULT base_put_timeline(BSTR);

    HRESULT base_get_currTime(float * time);
    HRESULT base_put_currTime(float time);
    
    HRESULT base_get_localTime(float * time);
    HRESULT base_put_localTime(float time);

    HRESULT base_get_currState(LPOLESTR * state);
    HRESULT base_put_currState(LPOLESTR state);

    HRESULT base_get_syncBehavior(LPOLESTR * sync);
    HRESULT base_put_syncBehavior(LPOLESTR sync);

    HRESULT base_get_syncTolerance(VARIANT * tol);
    HRESULT base_put_syncTolerance(VARIANT tol);

    HRESULT AddTIMEElement(CTIMEElementBase *bvr);
    HRESULT RemoveTIMEElement(CTIMEElementBase *bvr);

    HRESULT base_get_parentTIMEElement(ITIMEElement **bvr);
    HRESULT base_put_parentTIMEElement(ITIMEElement *bvr);

    HRESULT base_get_timelineBehavior(IDispatch ** bvr);
    HRESULT base_get_progressBehavior(IDispatch ** bvr);
    HRESULT base_get_onOffBehavior(IDispatch ** bvr);

    //
    // Accessors
    //

    CEventMgr & GetEventMgr() { return m_eventMgr; } 

    float    GetBeginTime() { return m_begin;};
    float    GetEndTime() { return m_end;};
    LPOLESTR GetBeginWith() { return m_beginWith; }
    LPOLESTR GetBeginAfter() { return m_beginAfter; }
    float    GetDuration() {return m_dur;};
    float    GetRepeat() {return m_repeat;};
    float    GetRepeatDur() {return m_repeatDur;};
    float        GetFractionalAcceleration() 
                {return static_cast<float>(m_accelerate) / 100.0f;};
    float        GetFractionalDeceleration() 
                {return static_cast<float>(m_decelerate) / 100.0f;};
    bool     GetAutoReverse() 
                {return m_bautoreverse;};
    bool     GetEndHold () 
                {return m_bendHold;};
    bool     GetEventRestart() {return m_beventrestart;};
    TOKEN    GetTimeAction() { return m_timeAction; }
    LPOLESTR GetBeginEvent() {return m_beginEvent;};
    LPOLESTR GetEndEvent() {return m_endEvent;};
    LPOLESTR GetEndSync() {return m_endSync;};

    virtual bool IsGroup() { return (m_TimelineType == ttPar) || (m_TimelineType == ttSeq); }
    bool IsGroup(IHTMLElement *pElement); // determine if elem passed in is a group
    bool IsPar() { return (m_TimelineType == ttPar); }
    bool IsSequence() { return (m_TimelineType == ttSeq); }
    virtual bool IsBody() { return false; }
    
    // Be aware that this can return NULL if no ID was set on the
    // element
    LPOLESTR GetID() { return m_id; };
  
    float    GetRealBeginTime() 
        {return m_realBeginTime; };
    float    GetRealDuration() 
        {return m_realDuration; };
    float    GetRealRepeatTime() 
        {return m_realRepeatTime; };
    float    GetRealRepeatCount() 
        {return m_realRepeatCount; };
    float    GetRealIntervalDuration (void)
        { return m_realIntervalDuration; }
    float    GetRealSyncTolerance();
    TOKEN    GetRealSyncBehavior();

    bool     IsLocked();

    MM_STATE GetPlayState();

    bool IsStarted() { return m_bStarted; }
    bool IsUnloading (void)
        {return m_bUnloading; }

    virtual bool Update();

    virtual HRESULT InitTimeline(void);

    virtual CRBvr * GetBaseBvr();

    bool FireEvent(TIME_EVENT TimeEvent, double dblLocalTime, DWORD flags);

    // internal methods
    HRESULT getTagString(BSTR *pbstrID);
    HRESULT getIDString(BSTR *pbstrTag);

    // Collection
    typedef enum COLLECTION_INDEX
    {
        ciAllElements,
        ciChildrenElements,
        ciAllInterfaces,
        ciChildrenInterfaces,
        NUM_COLLECTIONS
    };

    HRESULT base_get_collection(COLLECTION_INDEX index, ITIMEElementCollection **ppDisp);
    HRESULT EnsureCollectionCache();
    HRESULT InvalidateCollectionCache();
    CCollectionCache *GetCollectionCache();

    long GetImmediateChildCount();
    long GetAllChildCount();
    CTIMEElementBase *GetChild(long i);
    CTIMEElementBase *GetParent();
    CTIMEBodyElement *GetBody();
    MMPlayer *GetPlayer();
    int GetTimeChildIndex(CTIMEElementBase *pelm);

    MMBaseBvr & GetMMBvr()
    {
        Assert(m_mmbvr);
        return *m_mmbvr;
    }
    MMTimeline * GetMMTimeline() { return m_timeline; }

    virtual HRESULT GetSize(RECT * prcPos);
    virtual HRESULT SetSize(const RECT * prcPos);
    HRESULT ClearSize();

    enum TimelineType
    {
        ttUninitialized,
        ttNone,
        ttPar,
        ttSeq
    };

    virtual bool NeedSyncCB();

    bool IsDocumentInEditMode();

    bool IsPaused() { return m_fPaused; }
    virtual bool isNaturalDuration() { return false;}
    virtual void clearNaturalDuration() { return;}
    virtual void setNaturalDuration() { return;}

  protected:

    //IPersistPropertyBag2 methods
    STDMETHOD(GetClassID)(CLSID* pclsid);
    STDMETHOD(InitNew)(void);
    STDMETHOD(IsDirty)(void)
        {return S_OK;};
    STDMETHOD(Load)(IPropertyBag2 *pPropBag,IErrorLog *pErrorLog);
    STDMETHOD(Save)(IPropertyBag2 *pPropBag, BOOL fClearDirty, BOOL fSaveAllProperties);
    HRESULT NotifyPropertyChanged(DISPID dispid);
    // Persistance helper methods

    enum PROPERTY_INDEX
    {
        teb_begin = 0, teb_beginWith, teb_beginAfter, teb_beginEvent, 
        teb_dur, teb_end, teb_endWith, teb_endEvent, teb_endSync, teb_endHold,
        teb_eventRestart, teb_repeat, teb_repeatDur, teb_autoReverse,
        teb_accelerate, teb_decelerate, teb_timeAction, teb_timeline,
        teb_syncBehavior, teb_syncTolerance, teb_maxTIMEElementBaseProp,
    };

    virtual HRESULT GetPropertyBagInfo(CPtrAry<BSTR> **pparyPropNames)
        {return E_NOTIMPL;}
    virtual HRESULT SetPropertyByIndex(unsigned uIndex, VARIANT *pvarProp);
    virtual HRESULT GetPropertyByIndex(unsigned uIndex, VARIANT *pvarProp);
    virtual bool IsPropertySet(DWORD uIndex);
    virtual void SetPropertyFlag(DWORD uIndex);
    virtual void ClearPropertyFlag(DWORD uIndex);
    void SetPropertyFlagAndNotify(DISPID dispid, DWORD uindex);
    void ClearPropertyFlagAndNotify(DISPID dispid, DWORD uindex);
    virtual HRESULT GetConnectionPoint(REFIID riid, IConnectionPoint **ppICP)
    {
        return E_NOTIMPL;
    }

    virtual HRESULT Error(void) = 0;
    virtual HRESULT StartRootTime(MMTimeline * tl);
    virtual void StopRootTime(MMTimeline * tl);

    void CalcTimes();
    bool AddTimeAction();
    bool RemoveTimeAction();
    bool ToggleTimeAction(bool on);

    virtual HRESULT BuildPropertyNameList (CPtrAry<BSTR> *paryPropNames);

    virtual WCHAR* GetBehaviorTypeAsURN() { return L"TIME_BEHAVIOR_URN"; }

  protected:
    // Settable properties
    float           m_begin;
    LPOLESTR        m_beginWith;
    LPOLESTR        m_beginAfter;
    LPOLESTR        m_beginEvent;
    float           m_dur;
    float           m_end;
    LPOLESTR        m_endWith;
    LPOLESTR        m_endEvent;
    LPOLESTR        m_endSync;
    float           m_repeat;
    float           m_repeatDur;
    int             m_accelerate;
    int             m_decelerate;
    bool            m_bautoreverse;
    bool            m_bendHold;
    bool            m_beventrestart;
    TOKEN           m_timeAction;
    TOKEN           m_syncBehavior;
    float           m_syncTolerance;
    bool            m_bLoaded;
    bool            m_bUnloading;
    bool            m_fTimelineInitialized;
    TimelineType    m_TimelineType;

    // internal variables
    float           m_realBeginTime;
    float           m_realDuration;
    float           m_realRepeatTime;
    float           m_realRepeatCount;
    float           m_realIntervalDuration;
    LPOLESTR        m_id;
    CEventMgr       m_eventMgr;
    MMBaseBvr      *m_mmbvr;
    
    LPOLESTR        m_origAction;

    bool            m_bStarted;
    bool            m_fPropertiesDirty;
    CLSID           m_clsid;
        
    CTIMEElementBase            *m_pTIMEParent;
    CTIMEBodyElement            *m_pTIMEBody;
    CPtrAry<CTIMEElementBase*>   m_pTIMEChildren;
    MMTimeline                  *m_timeline;
  
    CRPtr<CRNumber> m_datimebvr;
    CRPtr<CRNumber> m_progress;
    CRPtr<CRBoolean> m_onoff;

    bool m_fPaused;

  private:
    HRESULT SetParent(ITIMEElement *pelem, bool fReparentChildren = true);
    HRESULT UnparentElement();
    HRESULT ParentElement();
    HRESULT ReparentChildren(ITIMEElement *pTIMEParent, IHTMLElement *pelem);
    HRESULT UpdateMMAPI();
    void    UpdateProgressBvr();

    HRESULT InitAtomTable();
    void ReleaseAtomTable();
    CAtomTable *GetAtomTable();

    static LPWSTR ms_rgwszTEBasePropNames[];

    CCollectionCache  *m_pCollectionCache;
    static CAtomTable *s_pAtomTable;
    static DWORD s_cAtomTableRef;
    DWORD m_propertyAccesFlags;
};


CTIMEElementBase * GetTIMEElementBase(IUnknown *);

inline CAtomTable *
CTIMEElementBase::GetAtomTable()
{
    Assert(s_pAtomTable != NULL);
    return s_pAtomTable;
} // GetAtomTable

inline long 
CTIMEElementBase::GetImmediateChildCount()
{
    return m_pTIMEChildren.Size();
} // GetImmediateChildCount

inline long 
CTIMEElementBase::GetAllChildCount()
{
    long lSize = m_pTIMEChildren.Size();
    long lCount = 0;
    for (long i=0; i < lSize; i++)
        lCount += m_pTIMEChildren[i]->GetAllChildCount();
    return lCount + lSize;
} // GetAllChildCount

inline CTIMEElementBase * 
CTIMEElementBase::GetChild(long i)
{
    Assert(i >= 0);
    return m_pTIMEChildren[i];
} // GetChild

inline CTIMEElementBase * 
CTIMEElementBase::GetParent()
{
    return m_pTIMEParent;
} // GetParent

inline CTIMEBodyElement *
CTIMEElementBase::GetBody()
{
    return m_pTIMEBody;
}

inline CCollectionCache * 
CTIMEElementBase::GetCollectionCache()
{
    return m_pCollectionCache;
} // GetCollectionCache

inline bool 
CTIMEElementBase::NeedSyncCB()
{   
    return false;
} // NeedSyncCB

inline bool
CTIMEElementBase::IsLocked()
{
    return GetRealSyncBehavior() == LOCKED_TOKEN;
}


#define valueNotSet -1

#endif /* _TIMEELMBASE_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\time\src\tokens.cpp ===
/*******************************************************************************
 *
 * Copyright (c) 1998 Microsoft Corporation
 *
 * File: token.cpp
 *
 * Abstract:
 *
 *
 *
 *******************************************************************************/


#include "headers.h"
#include "tokens.h"

TOKEN NONE_TOKEN          = L"none";
TOKEN FILTER_TOKEN        = L"filter";
TOKEN REPLACE_TOKEN       = L"replace";
TOKEN ONOFF_TOKEN         = L"onoff";
TOKEN STYLE_TOKEN         = L"style";
TOKEN VISIBILITY_TOKEN    = L"visibility";
TOKEN DISPLAY_TOKEN       = L"display";
TOKEN INVALID_TOKEN       = L"";

TOKEN ONOFF_PROPERTY_TOKEN         = L"on";
TOKEN STYLE_PROPERTY_TOKEN         = L"style";
TOKEN DISPLAY_PROPERTY_TOKEN       = L"display";
TOKEN VISIBILITY_PROPERTY_TOKEN    = L"visibility";

TOKEN TRUE_TOKEN   = L"true";
TOKEN FALSE_TOKEN  = L"false";
TOKEN HIDDEN_TOKEN  = L"hidden";

TOKEN READYSTATE_COMPLETE_TOKEN = L"complete";

TOKEN CANSLIP_TOKEN  = L"canSlip";
TOKEN LOCKED_TOKEN   = L"locked";

TOKEN STARTRULE_IMMEDIATE_TOKEN = L"immediate";
TOKEN STARTRULE_ONDOCLOAD_TOKEN = L"onDocLoad";
TOKEN STARTRULE_ONDOCCOMPLETE_TOKEN = L"onDocComplete";

// TODO: Need to make this much faster

TOKEN tokenArray[] =
{
    NONE_TOKEN,
    FILTER_TOKEN,
    REPLACE_TOKEN,
    ONOFF_TOKEN,
    STYLE_TOKEN,
    VISIBILITY_TOKEN,
    DISPLAY_TOKEN,
    ONOFF_PROPERTY_TOKEN,
    STYLE_PROPERTY_TOKEN,
    DISPLAY_PROPERTY_TOKEN,
    VISIBILITY_PROPERTY_TOKEN,
    TRUE_TOKEN,
    FALSE_TOKEN,
    HIDDEN_TOKEN,
    READYSTATE_COMPLETE_TOKEN,
    CANSLIP_TOKEN,
    LOCKED_TOKEN,
    STARTRULE_IMMEDIATE_TOKEN,
    STARTRULE_ONDOCLOAD_TOKEN,
    STARTRULE_ONDOCCOMPLETE_TOKEN,
    NULL
};

TOKEN
StringToToken(wchar_t * str)
{
    for (int i = 0; i < ARRAY_SIZE(tokenArray); i++)
    {
        if (StrCmpIW(str, (wchar_t *) tokenArray[i]) == 0)
            return tokenArray[i];
    }

    return INVALID_TOKEN;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\time\src\timeman.h ===
/*******************************************************************************
 *
 * Copyright (c) 1998 Microsoft Corporation
 *
 * File: timeman.h
 *
 * Abstract:
 *
 *
 *
 *******************************************************************************/


#ifndef _TIMEMAN_H
#define _TIMEMAN_H

#include "resource.h"
#include <string>
#include <map>
#include <list>

class CTIMEElement;

/////////////////////////////////////////////////////////////////////////////
// CTIMETimeManager

typedef std::map<std::wstring,CTIMEElement *> TimeLineMap;

class CTIMETimeManager 
{
  public:
    CTIMETimeManager();
    ~CTIMETimeManager();
    
#if _DEBUG
    const _TCHAR * GetName() { return __T("CTIMETimeManager"); }
#endif

    //
    // ITIMETimeManager
    //

    void Add(CTIMEElement *pTimeElement);
    void Remove(CTIMEElement *pTimeElement);
    void Recalc();

  private:
    void InsertElements();
    float CalculateDuration(CTIMEElement *pTimeEle);

    std::list<CTIMEElement *>m_NotFinishedList;
    TimeLineMap m_TimeLine;
   
};

typedef std::map<IUnknown*,CTIMETimeManager*> TimeManagerMap;

#endif /* _TIMEMAN_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\time\src\timeelmbase.cpp ===
/*******************************************************************************
 *
 * Copyright (c) 1998 Microsoft Corporation
 *
 * File: timeelmbase.cpp
 *
 * Abstract:
 *
 *
 *
 *******************************************************************************/

#include "headers.h"
#include "timeelmbase.h"
#include "array.h"
#include "htmlimg.h"
#include "bodyelm.h"


// Suppress new warning about NEW without corresponding DELETE
// We expect GCs to cleanup values.  Since this could be a useful
// warning, we should disable this on a file by file basis.
#pragma warning( disable : 4291 )

DeclareTag(tagTimeElmBase, "API", "CTIMEElementBase methods");

// These must align with the class PROPERTY_INDEX enumeration.
LPWSTR CTIMEElementBase::ms_rgwszTEBasePropNames[] = {
    L"begin", L"beginWith", L"beginAfter", L"beginEvent",
    L"dur", L"end", L"endWith", L"endEvent", L"endSync", L"endHold",
    L"eventRestart", L"repeat", L"repeatDur", L"autoReverse",
    L"accelerate", L"decelerate", L"timeAction", L"timeline",
    L"syncBehavior", L"syncTolerance",
};

// init static variables
DWORD CTIMEElementBase::s_cAtomTableRef = 0;
CAtomTable *CTIMEElementBase::s_pAtomTable = NULL;

#define DEFAULT_M_BEGIN 0
#define DEFAULT_M_BEGINWITH NULL
#define DEFAULT_M_BEGINAFTER NULL
#define DEFAULT_M_BEGINEVENT NULL
#define DEFAULT_M_DUR valueNotSet
#define DEFAULT_M_END valueNotSet
#define DEFAULT_M_ENDWITH NULL
#define DEFAULT_M_ENDEVENT NULL
#define DEFAULT_M_ENDSYNC NULL
#define DEFAULT_M_REPEAT 1
#define DEFAULT_M_REPEATDUR valueNotSet
#define DEFAULT_M_TIMEACTION VISIBILITY_TOKEN
#define DEFAULT_M_TIMELINETYPE ttUninitialized
#define DEFAULT_M_SYNCBEHAVIOR INVALID_TOKEN
#define DEFAULT_M_SYNCTOLERANCE valueNotSet
#define DEFAULT_M_PTIMEPARENT NULL
#define DEFAULT_M_PTIMEBODY NULL
#define DEFAULT_M_ID NULL
#define DEFAULT_M_EVENTMGR *this
#define DEFAULT_M_MMBVR NULL
#define DEFAULT_M_ORIGINACTION NULL
#define DEFAULT_M_BSTARTED false
#define DEFAULT_M_PCOLLECTIONCACHE NULL
#define DEFAULT_M_TIMELINE NULL
#define DEFAULT_M_ACCELERATE 0
#define DEFAULT_M_DECELERATE 0
#define DEFAULT_M_BAUTOREVERSE false
#define DEFAULT_M_BEVENTRESTART true
#define DEFAULT_M_BLOADED false,
#define DEFAULT_M_FPROPERTIESDIRTY true
#define DEFAULT_M_BENDHOLD false
#define DEFAULT_M_FTIMELINEINITIALIZED false
#define DEFAULT_M_REALBEGINTIME valueNotSet
#define DEFAULT_M_REALDURATION valueNotSet
#define DEFAULT_M_REALREPEATTIME valueNotSet
#define DEFAULT_M_REALREPEATCOUNT valueNotSet
#define DEFAULT_M_REALREPEATINTERVALDURATION valueNotSet
#define DEFAULT_M_PROPERTYACCESFLAGS 0
#define DEFAULT_M_MLOFFSETWIDTH 0

CTIMEElementBase::CTIMEElementBase() :
    m_begin(DEFAULT_M_BEGIN),
    m_beginWith(NULL),
    m_beginAfter(NULL),
    m_beginEvent(DEFAULT_M_BEGINEVENT),
    m_dur(DEFAULT_M_DUR),
    m_end(DEFAULT_M_END),
    m_endWith(NULL),
    m_endEvent(DEFAULT_M_ENDEVENT),
    m_endSync(NULL),
    m_repeat(DEFAULT_M_REPEAT),
    m_repeatDur(DEFAULT_M_REPEATDUR),
    m_timeAction(DEFAULT_M_TIMEACTION),
    m_TimelineType(ttUninitialized),
    m_syncBehavior(INVALID_TOKEN),
    m_syncTolerance(valueNotSet),
    m_pTIMEParent(NULL),
    m_pTIMEBody(NULL),
    m_id(NULL),
    m_eventMgr(*this),
    m_mmbvr(NULL),
    m_origAction(NULL),
    m_bStarted(false),
    m_pCollectionCache(NULL),
    m_timeline(NULL),
    m_accelerate(0),
    m_decelerate(0),
    m_bautoreverse(false),
    m_beventrestart(true),
    m_bLoaded(false),
    m_bUnloading(false),
    m_fPropertiesDirty(true),
    m_bendHold(false),
    m_fTimelineInitialized(false),
    m_realBeginTime(valueNotSet),
    m_realDuration(valueNotSet),
    m_realRepeatTime(valueNotSet),
    m_realRepeatCount(valueNotSet),
    m_realIntervalDuration(valueNotSet),
    m_propertyAccesFlags(0),
    m_fPaused(false)
{
    TraceTag((tagTimeElmBase,
              "CTIMEElementBase(%lx)::CTIMEElementBase()",
              this));
}

CTIMEElementBase::~CTIMEElementBase()
{
    TraceTag((tagTimeElmBase,
              "CTIMEElementBase(%lx)::~CTIMEElementBase()",
              this));

    delete m_beginWith;
    delete m_beginAfter;
    delete m_beginEvent;
    delete m_endWith;
    delete m_endEvent;
    delete m_endSync;
    delete m_id;
    delete m_origAction;
    delete m_mmbvr;
    // !!! Do not delete m_timeline since m_mmbvr points to the same
    // object
    m_timeline = NULL;

    if (m_pCollectionCache != NULL)
    {
        delete m_pCollectionCache;
        m_pCollectionCache = NULL;
    }

    // double check the children list
    Assert(m_pTIMEChildren.Size() == 0);
}


HRESULT
CTIMEElementBase::Init(IElementBehaviorSite * pBehaviorSite)
{
    TraceTag((tagTimeElmBase,
              "CTIMEElementBase(%lx)::Init(%lx)",
              this,
              pBehaviorSite));

    HRESULT hr;
    BSTR bstrID = NULL;
    BSTR bstrTagName = NULL;

    hr = THR(CBaseBvr::Init(pBehaviorSite));
    if (FAILED(hr))
    {
        goto done;
    }

    Assert(GetBehaviorTypeAsURN());

    bool fBehaviorExists;

    fBehaviorExists = false;

    hr = CheckElementForBehaviorURN(m_pHTMLEle, GetBehaviorTypeAsURN(), &fBehaviorExists);
    if (FAILED(hr))
    {
        goto done;
    }

    if (fBehaviorExists)
    {
        hr = E_UNEXPECTED;
        goto done;
    }

    // we did not find a match, so set our urn on the behavior site
    hr = m_pBvrSiteOM->RegisterUrn(GetBehaviorTypeAsURN());

    if (FAILED(hr))
    {
        goto done;
    }

    // since we support t:par and t:sequence, get tag name and
    // see if we are one of the above.  By default, we are ttNone.
    hr = THR(GetElement()->get_tagName(&bstrTagName));
    if (FAILED(hr))
    {
        goto done;
    }

    Assert(m_TimelineType == ttUninitialized);

    if (StrCmpIW(bstrTagName, WZ_PAR) == 0)
    {
        m_TimelineType = ttPar;
    }
    else if (StrCmpIW(bstrTagName, WZ_SEQUENCE) == 0)
    {
        m_TimelineType = ttSeq;
    }
    else if (StrCmpIW(bstrTagName, WZ_BODY) == 0)
    {
        m_TimelineType = ttPar;
    }

    SysFreeString(bstrTagName);

    // get ID of element and cache it
    hr = THR(GetElement()->get_id(&bstrID));
    if (SUCCEEDED(hr) && bstrID)
    {
        m_id = CopyString(bstrID);
        if (m_id == NULL)
        {
            hr = E_OUTOFMEMORY;
        }
    }

    SysFreeString(bstrID);
    if (FAILED(hr))
    {
        goto done;
    }

    hr = THR(m_eventMgr.Init());
    if (FAILED(hr))
    {
        goto done;
    }

    if (!AddTimeAction())
    {
        hr = CRGetLastError();
        goto done;
    }

    if (!ToggleTimeAction(false))
    {
        hr = CRGetLastError();
        goto done;
    }

    // init atom table for collections
    hr = THR(InitAtomTable());
    if (FAILED(hr))
    {
        goto done;
    }

    if (!IsBody())
    {
        hr = THR(AddBodyBehavior(GetElement()));
        if (FAILED(hr))
        {
            goto done;
        }
    }

    // Create the behaviors

    {
        CRLockGrabber __gclg;

        m_datimebvr = CRModifiableNumber(0.0);

        if (!m_datimebvr)
        {
            hr = CRGetLastError();
            goto done;
        }

        m_progress = CRModifiableNumber(0.0);

        if (!m_progress)
        {
            hr = CRGetLastError();
            goto done;
        }

        m_onoff = (CRBooleanPtr) CRModifiableBvr((CRBvrPtr) CRFalse(), 0);

        if (!m_onoff)
        {
            hr = CRGetLastError();
            goto done;
        }
    }

    // if we are not a body element, walk up the HTML tree looking for our TIME parent.
    if (!IsBody())
    {
        hr = ParentElement();
        if (FAILED(hr))
        {
            goto done;
        }
    }
    hr = S_OK;

done:
    return hr;
}

HRESULT
CTIMEElementBase::Notify(LONG event, VARIANT * pVar)
{
    TraceTag((tagTimeElmBase,
              "CTIMEElementBase(%lx)::Notify(%lx)",
              this,
              event));

    THR(CBaseBvr::Notify(event, pVar));

    return S_OK;
}

HRESULT
CTIMEElementBase::Detach()
{
    TraceTag((tagTimeElmBase, "CTIMEElementBase(%lx)::Detach()", this));

    // TraceTag((tagError, "CTIMEElementBase(%lx)::Detach() - %08X, %S", this, m_pTIMEParent, m_id ));

    DAComPtr<ITIMEElement> pTIMEParent = NULL;
    if (GetParent() != NULL)
    {
        THR(GetParent()->QueryInterface(IID_TO_PPV(ITIMEElement, &pTIMEParent)));
    }

    THR(UnparentElement());

    // clear all children from holding a reference to ourselves
    // NOTE: this is a weak reference
    while (m_pTIMEChildren.Size() > 0)
    {
        CTIMEElementBase *pChild = m_pTIMEChildren[0];
        pChild->SetParent(pTIMEParent, false);
        // TraceTag((tagError, "CTIMEElementBase(%lx)::Detach() - setting parent to %08X, %S", m_pTIMEChildren[0], m_pTIMEChildren[0]->m_pTIMEParent, m_pTIMEChildren[0]->m_id ));

        // if we found a parent and it's timeline is present,
        // kick-start our root time.
        CTIMEElementBase *pElemNewParent = pChild->GetParent();
        if (pElemNewParent != NULL)
        {
            MMTimeline *tl = pElemNewParent->GetMMTimeline();
            if (tl != NULL)
            {
                if(!IsUnloading())
                {
                    pChild->StartRootTime(tl);
                }
            }
        }
    }
    m_pTIMEChildren.DeleteAll();

    delete m_mmbvr;
    m_mmbvr = NULL;

    // Do not delete m_timeline since it is the same object as
    // m_timeline
    m_timeline = NULL;

    RemoveTimeAction();

    THR(m_eventMgr.Deinit());

    THR(CBaseBvr::Detach());

    ReleaseAtomTable();

    return S_OK;
}

/////////////////////////////////////////////////////////////////////
// ITIMEElement base interfaces
/////////////////////////////////////////////////////////////////////

HRESULT
CTIMEElementBase::base_get_begin(VARIANT * time)
{
    HRESULT hr;
    VARIANT fTemp, bstrTemp;
    if (time == NULL)
    {
        hr = E_POINTER;
        goto done;
    }

    if (FAILED(hr = THR(VariantClear(time))))
    {
        goto done;
    }

    VariantInit(&fTemp);
    VariantInit(&bstrTemp);
    fTemp.vt = VT_R4;
    fTemp.fltVal = m_begin;

    hr = THR(VariantChangeTypeEx(&bstrTemp, &fTemp, LCID_SCRIPTING, VARIANT_NOUSEROVERRIDE, VT_BSTR));
    if (SUCCEEDED(hr))
    {
        time->vt = VT_BSTR;
        time->bstrVal = SysAllocString(bstrTemp.bstrVal);
    }
    else
    {
        time->vt = VT_R4;
        time->fltVal = fTemp.fltVal;
    }

    VariantClear(&fTemp);
    SysFreeString(bstrTemp.bstrVal);
    VariantClear(&bstrTemp);

    hr = S_OK;
  done:
    return hr;
}

HRESULT
CTIMEElementBase::UpdateMMAPI()
{
    HRESULT hr = E_FAIL;
    if (NULL != m_mmbvr)
    {
        if (!Update())
        {
            hr = TIMEGetLastError();
            goto done;
        }

        Assert(m_mmbvr != NULL);

        if (!m_mmbvr->Reset(MM_EVENT_PROPERTY_CHANGE))
        {
            hr = TIMEGetLastError();
            goto done;
        }

        UpdateProgressBvr();
    }
    hr = S_OK;

done:
    return hr;
}

HRESULT
CTIMEElementBase::base_put_begin(VARIANT time)
{
    TraceTag((tagTimeElmBase,
        "CTIMEElementBase::(%lx)::base_put_begin()",
        this));

    float fOldBegin = m_begin;

    HRESULT hr = E_FAIL;
    bool isClear = false;

    if(V_VT(&time) != VT_NULL)
    {
        hr = VariantToTime(time, &m_begin);
        if (FAILED(hr))
            goto done;
    }
    else
    {
        m_begin = DEFAULT_M_BEGIN;
        isClear = true;
    }

    hr = UpdateMMAPI();
    if (FAILED(hr))
        goto done;

    hr = S_OK;

    if(!isClear)
    {
        SetPropertyFlagAndNotify(DISPID_TIMEELEMENT_BEGIN, teb_begin);
    }
    else
    {
        ClearPropertyFlagAndNotify(DISPID_TIMEELEMENT_BEGIN, teb_begin);
    }
done:
    if (FAILED(hr))
    {
        // return this object to its original state.
        m_begin = fOldBegin;
        if (NULL != m_mmbvr)
            Update();
    }
    return hr;
}

HRESULT
CTIMEElementBase::base_get_beginWith(VARIANT * time)
{
    HRESULT hr;

    if (time == NULL)
    {
        hr = E_POINTER;
        goto done;
    }

    if (FAILED(hr = THR(VariantClear(time))))
    {
        goto done;
    }

    V_VT(time) = VT_BSTR;
    V_BSTR(time) = SysAllocString(m_beginWith);

    hr = S_OK;
  done:
    return hr;
}

HRESULT
CTIMEElementBase::base_put_beginWith(VARIANT time)
{
    CComVariant v;
    HRESULT hr;


    hr = v.ChangeType(VT_BSTR, &time);

    if (FAILED(hr))
    {
        goto done;
    }

    delete[] m_beginWith;
    m_beginWith = CopyString(V_BSTR(&v));
    hr = S_OK;


    SetPropertyFlagAndNotify(DISPID_TIMEELEMENT_BEGINWITH, teb_beginWith);
  done:
    return hr;
}

HRESULT
CTIMEElementBase::base_get_beginAfter(VARIANT * time)
{
    HRESULT hr;

    if (time == NULL)
    {
        hr = E_POINTER;
        goto done;
    }

    if (FAILED(hr = THR(VariantClear(time))))
    {
        goto done;
    }

    V_VT(time) = VT_BSTR;
    V_BSTR(time) = SysAllocString(m_beginAfter);

    hr = S_OK;
  done:
    return hr;
}

HRESULT
CTIMEElementBase::base_put_beginAfter(VARIANT time)
{


    CComVariant v;
    HRESULT hr;

    hr = v.ChangeType(VT_BSTR, &time);

    if (FAILED(hr))
    {
        goto done;
    }

    delete [] m_beginAfter;
    m_beginAfter = CopyString(V_BSTR(&v));
    hr = S_OK;

    SetPropertyFlagAndNotify(DISPID_TIMEELEMENT_BEGINAFTER, teb_beginAfter);
  done:
    return hr;
}

HRESULT
CTIMEElementBase::base_get_beginEvent(VARIANT * time)
{
    HRESULT hr;

    if (time == NULL)
    {
        hr = E_POINTER;
        goto done;
    }

    if (FAILED(hr = THR(VariantClear(time))))
    {
        goto done;
    }

    V_VT(time) = VT_BSTR;
    V_BSTR(time) = SysAllocString(m_beginEvent);

    hr = S_OK;
  done:
    return hr;
}

HRESULT
CTIMEElementBase::base_put_beginEvent(VARIANT time)
{
    CComVariant v;
    HRESULT hr;
    BOOL bAttach = FALSE;
    bool clearFlag = false;

    if(V_VT(&time) == VT_NULL)
    {
        clearFlag = true;
    }
    else
    {
        hr = v.ChangeType(VT_BSTR, &time);

        if (FAILED(hr))
        {
            goto done;
        }
    }

    IGNORE_HR(m_eventMgr.DetachEvents());

    delete [] m_beginEvent;

    //processing the attribute change should be done here

    if(!clearFlag)
    {
        m_beginEvent = CopyString(V_BSTR(&v));
        if (m_mmbvr != NULL)
        {
            hr = m_mmbvr->GetMMBvr()->ResetOnEventChanged(VARIANT_TRUE);
            if (FAILED(hr))
            {
                goto done;
            }
            UpdateProgressBvr();
        }
        SetPropertyFlagAndNotify(DISPID_TIMEELEMENT_BEGINEVENT, teb_beginEvent);
    }
    else
    {
        m_beginEvent = DEFAULT_M_BEGINEVENT;
        if (m_mmbvr != NULL)
        {
            Assert(NULL != m_mmbvr->GetMMBvr());
            hr = m_mmbvr->GetMMBvr()->put_StartType(MM_START_ABSOLUTE);
            if (FAILED(hr))
            {
                goto done;
            }

            hr = UpdateMMAPI();
            if (FAILED(hr))
            {
                goto done;
            }
        }
        ClearPropertyFlagAndNotify(DISPID_TIMEELEMENT_BEGINEVENT, teb_beginEvent);
    }

    hr = S_OK;
    IGNORE_HR(m_eventMgr.AttachEvents());

  done:
    return hr;
}

HRESULT
CTIMEElementBase::base_get_dur(VARIANT * time)
{
    HRESULT hr;
    VARIANT fTemp;
    if (time == NULL)
    {
        hr = E_POINTER;
        goto done;
    }

    if (FAILED(hr = THR(VariantClear(time))))
    {
        goto done;
    }

    VariantInit(&fTemp);
    fTemp.vt = VT_R4;
    fTemp.fltVal = m_dur;

    if( m_dur != INDEFINITE)
    {
        hr = THR(VariantChangeTypeEx(time, &fTemp, LCID_SCRIPTING, VARIANT_NOUSEROVERRIDE, VT_BSTR));
        if (!SUCCEEDED(hr))
        {
            VariantClear(&fTemp);
            goto done;
        }
    }
    else
    {
        V_VT(time) = VT_BSTR;
        V_BSTR(time) = SysAllocString(WZ_INDEFINITE);
    }


    VariantClear(&fTemp);

    hr = S_OK;
  done:
    return hr;
}

HRESULT
CTIMEElementBase::base_put_dur(VARIANT time)
{
    TraceTag((tagTimeElmBase,
        "CTIMEElementBase::(%lx)::base_put_dur()",
        this));

    float fOldDur = m_dur;
    HRESULT hr = E_FAIL;
    float CurTime = 0;
    bool isClear = false;

    if(V_VT(&time) != VT_NULL)
    {
        hr = VariantToTime(time, &m_dur);
        if (FAILED(hr))
            goto done;
    }
    else
    {
        m_dur = DEFAULT_M_DUR;
        isClear = true;
    }

    hr = UpdateMMAPI();
    if (FAILED(hr))
        goto done;

    hr = S_OK;

    if(!isClear)
    {
        SetPropertyFlagAndNotify(DISPID_TIMEELEMENT_DUR, teb_dur);
    }
    else
    {
        ClearPropertyFlagAndNotify(DISPID_TIMEELEMENT_DUR, teb_dur);
    }

done:
    if (FAILED(hr))
    {
        // return this object to its original state.
        m_dur = fOldDur;
        if (NULL != m_mmbvr)
        {
            Update();
        }
    }
    return hr;
}

HRESULT
CTIMEElementBase::base_get_end(VARIANT * time)
{
    HRESULT hr;
    VARIANT fTemp, bstrTemp;
    if (time == NULL)
    {
        hr = E_POINTER;
        goto done;
    }

    if (FAILED(hr = THR(VariantClear(time))))
    {
        goto done;
    }

    if(m_end != INDEFINITE)
    {
        if (m_end == valueNotSet)
        {
            time->vt = VT_R4;
            time->fltVal = HUGE_VAL;
        }
        else
        {
            VariantInit(&fTemp);
            VariantInit(&bstrTemp);
            fTemp.vt = VT_R4;
            fTemp.fltVal = m_end;

            hr = THR(VariantChangeTypeEx(&bstrTemp, &fTemp, LCID_SCRIPTING, VARIANT_NOUSEROVERRIDE, VT_BSTR));
            if (SUCCEEDED(hr))
            {
                time->vt = VT_BSTR;
                time->bstrVal = SysAllocString(bstrTemp.bstrVal);
            }
            else
            {
                time->vt = VT_R4;
                time->fltVal = fTemp.fltVal;
            }
            VariantClear(&fTemp);
            SysFreeString(bstrTemp.bstrVal);
            VariantClear(&bstrTemp);
        }
    }
    else
    {
        V_VT(time) = VT_BSTR;
        V_BSTR(time) = SysAllocString(WZ_INDEFINITE);
    }

    hr = S_OK;
  done:
    return hr;
}

HRESULT
CTIMEElementBase::base_put_end(VARIANT time)
{
    float fOldEnd = m_end;
    HRESULT hr = E_FAIL;
    float CurTime = 0;
    bool isClear = false;

    if(V_VT(&time) != VT_NULL)
    {
        hr = VariantToTime(time, &m_end);
        if (FAILED(hr))
            goto done;
    }
    else
    {
        m_end = DEFAULT_M_END;
        isClear = true;
    }

    hr = UpdateMMAPI();
    if (FAILED(hr))
        goto done;

    hr = S_OK;

    if(!isClear)
    {
        SetPropertyFlagAndNotify(DISPID_TIMEELEMENT_END, teb_end);
    }
    else
    {
        ClearPropertyFlagAndNotify(DISPID_TIMEELEMENT_END, teb_end);
    }

done:
    if (FAILED(hr))
    {
        m_end = fOldEnd;
        if (NULL != m_mmbvr)
        {
            Update();
        }
    }

    return hr;
}

HRESULT
CTIMEElementBase::base_get_endWith(VARIANT * time)
{
    HRESULT hr;

    if (time == NULL)
    {
        hr = E_POINTER;
        goto done;
    }

    if (FAILED(hr = THR(VariantClear(time))))
    {
        goto done;
    }

    V_VT(time) = VT_BSTR;
    V_BSTR(time) = SysAllocString(m_endWith);

    hr = S_OK;
  done:
    return hr;
}

HRESULT
CTIMEElementBase::base_put_endWith(VARIANT time)
{
    CComVariant v;
    HRESULT hr;

    hr = v.ChangeType(VT_BSTR, &time);

    if (FAILED(hr))
    {
        goto done;
    }

    delete [] m_endWith;
    m_endWith = CopyString(V_BSTR(&v));
    hr = S_OK;

    SetPropertyFlagAndNotify(DISPID_TIMEELEMENT_ENDWITH, teb_endWith);
  done:
    return hr;
}

HRESULT
CTIMEElementBase::base_get_endEvent(VARIANT * time)
{
    HRESULT hr;

    if (time == NULL)
    {
        hr = E_POINTER;
        goto done;
    }

    if (FAILED(hr = THR(VariantClear(time))))
    {
        goto done;
    }

    V_VT(time) = VT_BSTR;
    V_BSTR(time) = SysAllocString(m_endEvent);

    hr = S_OK;
  done:
    return hr;
}

HRESULT
CTIMEElementBase::base_put_endEvent(VARIANT time)
{
    CComVariant v;
    HRESULT hr;
    BOOL bAttach = FALSE;
    bool clearFlag = false;

    // only interested in the value -- not the contents.
    BSTR bstrPreviousEndEvent = m_endEvent;

    if(V_VT(&time) == VT_NULL)
    {
        clearFlag = true;
    }
    else
    {
        hr = v.ChangeType(VT_BSTR, &time);

        if (FAILED(hr))
        {
            goto done;
        }
    }

    //if we have already attached to events then
    //detach from the events
    IGNORE_HR(m_eventMgr.DetachEvents());
    delete [] m_endEvent;

    if(!clearFlag)
    {
        m_endEvent = CopyString(V_BSTR(&v));
        SetPropertyFlagAndNotify(DISPID_TIMEELEMENT_ENDEVENT, teb_endEvent);
    }
    else
    {
        m_endEvent = DEFAULT_M_ENDEVENT;
        ClearPropertyFlagAndNotify(DISPID_TIMEELEMENT_ENDEVENT, teb_endEvent);
    }

    hr = S_OK;

    IGNORE_HR(m_eventMgr.AttachEvents());

    if (m_mmbvr && bstrPreviousEndEvent != NULL)
    {
        hr = m_mmbvr->GetMMBvr()->ResetOnEventChanged(VARIANT_FALSE);
        UpdateProgressBvr();
    }
    else
    {
        if (NULL != m_mmbvr)
            hr = Update();
    }

  done:
    return hr;
}

HRESULT
CTIMEElementBase::base_get_endSync(VARIANT * time)
{
    HRESULT hr;

    if (time == NULL)
    {
        hr = E_POINTER;
        goto done;
    }

    if (FAILED(hr = THR(VariantClear(time))))
    {
        goto done;
    }

    V_VT(time) = VT_BSTR;
    V_BSTR(time) = SysAllocString(m_endSync);

    hr = S_OK;
  done:
    return hr;
}

HRESULT
CTIMEElementBase::base_put_endSync(VARIANT time)
{
    CComVariant v;
    HRESULT hr;

    hr = v.ChangeType(VT_BSTR, &time);

    if (FAILED(hr))
    {
        goto done;
    }

    delete [] m_endSync;
    m_endSync = CopyString(V_BSTR(&v));
    hr = S_OK;

    SetPropertyFlagAndNotify(DISPID_TIMEELEMENT_ENDSYNC, teb_endSync);
  done:
    return hr;
}

HRESULT
CTIMEElementBase::base_get_repeat(VARIANT * time)
{
    HRESULT hr;
    // Still need to take in to consideration "infinite"

    if (time == NULL)
    {
        hr = E_POINTER;
        goto done;
    }

    if (FAILED(hr = THR(VariantClear(time))))
    {
        goto done;
    }

    if(m_repeat != INDEFINITE)
    {
        V_VT(time) = VT_R4;
        V_R4(time) = m_repeat;
    }
        else
    {
        V_VT(time) = VT_BSTR;
        V_BSTR(time) = SysAllocString(WZ_INDEFINITE);
    }

    hr = S_OK;
  done:
    return hr;
}

HRESULT
CTIMEElementBase::base_put_repeat(VARIANT time)
{
    VARIANT v;
    VARIANT vTemp;
    float fOldRepeat = m_repeat;

	VariantInit(&v);
	VariantInit(&vTemp);

    HRESULT hr = THR(VariantChangeTypeEx(&vTemp, &time, LCID_SCRIPTING, VARIANT_NOUSEROVERRIDE, VT_BSTR));
    bool isClear = false;

    if (SUCCEEDED(hr) && IsIndefinite(V_BSTR(&vTemp)))
    {
        m_repeat = INDEFINITE;
    }
    else if(V_VT(&time) != VT_NULL)
    {
        hr = THR(VariantChangeTypeEx(&v, &time, LCID_SCRIPTING, VARIANT_NOUSEROVERRIDE, VT_R4));
        if (FAILED(hr))
        {
            goto done;
        }

        if (0.0f >= V_R4(&v))
        {
            hr = E_INVALIDARG;
            goto done;
        }

        m_repeat = V_R4(&v);
    }
    else
    {
        m_repeat = DEFAULT_M_REPEAT;
        isClear = true;
    }

    hr = UpdateMMAPI();
    if (FAILED(hr))
        goto done;

    hr = S_OK;

    if(!isClear)
    {
        SetPropertyFlagAndNotify(DISPID_TIMEELEMENT_REPEAT, teb_repeat);
    }
    else
    {
        ClearPropertyFlagAndNotify(DISPID_TIMEELEMENT_REPEAT, teb_repeat);
    }

  done:
	VariantClear(&vTemp);
	VariantClear(&v);

	if (FAILED(hr))
    {
        m_repeat = fOldRepeat;
        if (NULL != m_mmbvr)
        {
            Update();
        }
    }

    return hr;
}

HRESULT
CTIMEElementBase::base_get_repeatDur(VARIANT * time)
{
    HRESULT hr;
    VARIANT fTemp, bstrTemp;
    if (time == NULL)
    {
        hr = E_POINTER;
        goto done;
    }

    if (FAILED(hr = THR(VariantClear(time))))
    {
        goto done;
    }

    if(m_repeatDur != INDEFINITE)
    {
        VariantInit(&fTemp);
        VariantInit(&bstrTemp);
        fTemp.vt = VT_R4;
        fTemp.fltVal = m_repeatDur;

        hr = THR(VariantChangeTypeEx(&bstrTemp, &fTemp, LCID_SCRIPTING, VARIANT_NOUSEROVERRIDE, VT_BSTR));
        if (SUCCEEDED(hr))
        {
            time->vt = VT_BSTR;
            time->bstrVal = SysAllocString(bstrTemp.bstrVal);
        }
        else
        {
            time->vt = VT_R4;
            time->fltVal = fTemp.fltVal;
        }
        VariantClear(&fTemp);
        SysFreeString(bstrTemp.bstrVal);
        VariantClear(&bstrTemp);
    }
    else
    {
        V_VT(time) = VT_BSTR;
        V_BSTR(time) = SysAllocString(WZ_INDEFINITE);
    }


    hr = S_OK;

  done:

    return hr;
}

HRESULT
CTIMEElementBase::base_put_repeatDur(VARIANT time)
{
    HRESULT hr = E_FAIL;

    bool isClear = false;
    float fOldRepeatDur = m_repeatDur;

    if(V_VT(&time) != VT_NULL)
    {
        hr = VariantToTime(time, &m_repeatDur);
        if (FAILED(hr))
            goto done;
    }
    else
    {
        m_repeatDur = DEFAULT_M_REPEATDUR;
        isClear = true;
    }

    hr = UpdateMMAPI();
    if (FAILED(hr))
        goto done;

    if(!isClear)
    {
        SetPropertyFlagAndNotify(DISPID_TIMEELEMENT_REPEATDUR, teb_repeatDur);
    }
    else
    {
        ClearPropertyFlagAndNotify(DISPID_TIMEELEMENT_REPEATDUR, teb_repeatDur);
    }
    hr = S_OK;

done:
    if (FAILED(hr))
    {
        m_repeatDur = fOldRepeatDur;
        if (NULL != m_mmbvr)
        {
            Update();
        }
    }
    return hr;
}

HRESULT
CTIMEElementBase::base_get_accelerate(int * e)
{
    HRESULT hr;

    if (e == NULL)
    {
        hr = E_POINTER;
        goto done;
    }

    *e = m_accelerate;

    hr = S_OK;
  done:
    return hr;
}

HRESULT
CTIMEElementBase::base_put_accelerate(int e)
{
    HRESULT hr;

    if (e < 0 || e > 100)
    {
        hr = E_INVALIDARG;
        goto done;
    }

    m_accelerate = e;

    hr = S_OK;

    SetPropertyFlagAndNotify(DISPID_TIMEELEMENT_ACCELERATE, teb_accelerate);
  done:

    return hr;
}

HRESULT
CTIMEElementBase::base_get_decelerate(int * e)
{
    HRESULT hr;

    if (e == NULL)
    {
        hr = E_POINTER;
        goto done;
    }

    *e = m_decelerate;

    hr = S_OK;
  done:
    return hr;
}

HRESULT
CTIMEElementBase::base_put_decelerate(int e)
{
    HRESULT hr;

    if (e < 0 || e > 100)
    {
        hr = E_INVALIDARG;
        goto done;
    }

    m_decelerate = e;

    hr = S_OK;

    SetPropertyFlagAndNotify(DISPID_TIMEELEMENT_DECELERATE, teb_decelerate);
  done:

    return hr;
}

HRESULT
CTIMEElementBase::base_get_autoReverse(VARIANT_BOOL * b)
{
    CHECK_RETURN_NULL(b);

    *b = m_bautoreverse?VARIANT_TRUE:VARIANT_FALSE;

    return S_OK;
}

HRESULT
CTIMEElementBase::base_put_autoReverse(VARIANT_BOOL b)
{
    HRESULT hr;
    bool bOldAutoreverse = m_bautoreverse;

    m_bautoreverse = b?true:false;

    hr = UpdateMMAPI();
    if (FAILED(hr))
        goto done;

    hr = S_OK;

    SetPropertyFlagAndNotify(DISPID_TIMEELEMENT_AUTOREVERSE, teb_autoReverse);
done:
    if (FAILED(hr))
    {
        m_bautoreverse = bOldAutoreverse;
        if (NULL != m_mmbvr)
        {
            Update();
        }
    }
    return hr;
}

HRESULT
CTIMEElementBase::base_get_endHold(VARIANT_BOOL * b)
{
    CHECK_RETURN_NULL(b);

    *b = m_bendHold?VARIANT_TRUE:VARIANT_FALSE;

    return S_OK;
}

HRESULT
CTIMEElementBase::base_put_endHold(VARIANT_BOOL b)
{
    HRESULT hr;

    bool bOldEndHold = m_bendHold;

    m_bendHold = b?true:false;

    hr = UpdateMMAPI();
    if (FAILED(hr))
    {
        goto done;
    }

    hr = S_OK;

    SetPropertyFlagAndNotify(DISPID_TIMEELEMENT_ENDHOLD, teb_endHold);
done:
    if (FAILED(hr))
    {
        m_bendHold = bOldEndHold;
        if (NULL != m_mmbvr)
        {
            Update();
        }
    }

    return hr;
}

HRESULT
CTIMEElementBase::base_get_eventRestart(VARIANT_BOOL * b)
{
    CHECK_RETURN_NULL(b);

    *b = m_beventrestart?VARIANT_TRUE:VARIANT_FALSE;

    return S_OK;
}

HRESULT
CTIMEElementBase::base_put_eventRestart(VARIANT_BOOL b)
{
    HRESULT hr;

    m_beventrestart = b?true:false;

    hr = S_OK;

    SetPropertyFlagAndNotify(DISPID_TIMEELEMENT_EVENTRESTART, teb_eventRestart);
    return hr;
}

HRESULT
CTIMEElementBase::base_get_timeAction(LPOLESTR * action)
{
    HRESULT hr;

    CHECK_RETURN_SET_NULL(action);

    *action = SysAllocString(TokenToString(m_timeAction));

    if (*action == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto done;
    }

    hr = S_OK;
  done:
    return hr;
}

HRESULT
CTIMEElementBase::base_put_timeAction(LPOLESTR action)
{
    HRESULT hr;
    bool clearFlag = false;
    TOKEN tok_action;

    if( action == NULL)
    {
        tok_action = DEFAULT_M_TIMEACTION;
        clearFlag = true;
    }
    else
    {
        tok_action = StringToToken(action);
    }
    if (tok_action != DISPLAY_TOKEN &&
        tok_action != VISIBILITY_TOKEN &&
        tok_action != ONOFF_TOKEN &&
        tok_action != STYLE_TOKEN &&
        tok_action != NONE_TOKEN)
    {
        hr = E_INVALIDARG;
        goto done;
    }

    if (m_timeAction != tok_action)
    {
        if (!RemoveTimeAction())
        {
            hr = CRGetLastError();
            goto done;
        }

        m_timeAction = tok_action;

        if (!AddTimeAction())
        {
            hr = CRGetLastError();
            goto done;
        }

        // If we've not yet started or we've stopped, make sure to toggle the time action accordingly.
        if ((NULL == m_mmbvr) || (HUGE_VAL == m_mmbvr->GetLocalTime()))
        {
            if (!ToggleTimeAction(false))
            {
                hr = CRGetLastError();
                goto done;
            }
        }
    }

    hr = S_OK;

    if(!clearFlag)
    {
        SetPropertyFlagAndNotify(DISPID_TIMEELEMENT_TIMEACTION, teb_timeAction);
    }
    else
    {
        ClearPropertyFlagAndNotify(DISPID_TIMEELEMENT_TIMEACTION, teb_timeAction);
    }
  done:
    return hr;
}

HRESULT
CTIMEElementBase::base_beginElement(bool bAfterOffset)
{
    bool ok = false;

    if (!Update())
    {
        goto done;
    }

    Assert(NULL != m_mmbvr);
    if (NULL != m_mmbvr)
    {
        MM_STATE mmstate = m_mmbvr->GetPlayState();

        if (m_beventrestart || (MM_STOPPED_STATE == mmstate))
        {
            if (MM_PLAYING_STATE == mmstate)
            {
                float time = m_mmbvr->GetLocalTime();
                if (time == 0)
                {
                    goto done;
                }
            }

            MMTimeline *timeline = GetMMTimeline();
            if (NULL != timeline)
            {
                if (!timeline->Begin(bAfterOffset))
                {
                    goto done;
                }
            }
            else if (!m_mmbvr->Begin(bAfterOffset))
            {
                goto done;
            }
        }

        ok = true;
    }

  done:
    return ok?S_OK:Error();
}

HRESULT
CTIMEElementBase::base_endElement()
{
    bool ok = false;


    Assert(NULL != m_mmbvr);
    if (NULL != m_mmbvr)
    {
        if (!m_mmbvr->End())
        {
            goto done;
        }

        ok = true;
    }


  done:
    return ok?S_OK:Error();
}

HRESULT
CTIMEElementBase::base_pause()
{
    bool ok = false;

    Assert(NULL != m_mmbvr);
    if (NULL != m_mmbvr)
    {
        if (!m_mmbvr->Pause())
        {
            goto done;
        }

        ok = true;
    }

  done:
    return ok?S_OK:Error();
}

HRESULT
CTIMEElementBase::base_resume()
{
    bool ok = false;

    Assert(NULL != m_mmbvr);
    if (NULL != m_mmbvr)
    {
        if (!m_mmbvr->Resume())
        {
            goto done;
        }

        ok = true;
    }

  done:
    return ok?S_OK:Error();
}

HRESULT
CTIMEElementBase::base_cue()
{
    bool ok = false;

    ok = true;

    return ok?S_OK:Error();
}

HRESULT
CTIMEElementBase::base_get_timeline(BSTR * pbstrTimeLine)
{
    HRESULT hr = S_OK;
    CHECK_RETURN_NULL(pbstrTimeLine);
        LPWSTR wszTimelineString = WZ_NONE;

        switch(m_TimelineType)
        {
            case ttPar :
                    wszTimelineString = WZ_PAR;
                    break;
            case ttSeq :
                    wszTimelineString = WZ_SEQUENCE;
                    break;
        }

    *pbstrTimeLine = SysAllocString(wszTimelineString);
    if (NULL == *pbstrTimeLine)
        hr = E_OUTOFMEMORY;

    return hr;
}

HRESULT
CTIMEElementBase::base_put_timeline(BSTR bstrNewTimeline)
{
    CHECK_RETURN_NULL(bstrNewTimeline);
    HRESULT hr = S_OK;
    BSTR bstrTagName = NULL;
    TimelineType newTimelineType;
    TimelineType oldTimelineType;

    oldTimelineType = m_TimelineType;

    hr = THR(GetElement()->get_tagName(&bstrTagName));
    if (FAILED(hr))
    {
        goto done;
    }

    if (StrCmpIW(bstrTagName, WZ_PAR) == 0 || StrCmpIW(bstrTagName, WZ_SEQUENCE) == 0)
    {
        hr = E_FAIL;
        goto done;
    }

    if (0 == StrCmpIW(WZ_PAR, bstrNewTimeline))
    {
        newTimelineType = ttPar;
    }
    else if (0 == StrCmpIW(WZ_SEQUENCE, bstrNewTimeline))
    {
        newTimelineType = ttSeq;
    }
    else if ((0 == StrCmpIW(WZ_NONE, bstrNewTimeline)) &&
        !IsBody() )
    {
        newTimelineType = ttNone;
    }
    else
    {
        hr = E_INVALIDARG;
        goto done;
    }

    if (m_TimelineType == ttUninitialized)
    {
        m_TimelineType = newTimelineType;
    }

    if (oldTimelineType != newTimelineType && newTimelineType != ttSeq)
    {
        DAComPtr<ITIMEElement> pTimeElement;


        MMTimeline* pTimeline;
        if (NULL == GetParent())
        {
            hr = E_FAIL;
            goto done;
        }

        bool doTimeline = m_bStarted;
        if(doTimeline)
        {
            pTimeline = GetParent()->GetMMTimeline();

            Assert(pTimeline != NULL);
            this->StopRootTime(pTimeline);
        }
        m_TimelineType = newTimelineType;

        if (ttPar == m_TimelineType)
        {
            THR(this->QueryInterface(IID_TO_PPV(ITIMEElement, &pTimeElement)));

            hr = ReparentChildren(pTimeElement, m_pHTMLEle);
            if (FAILED(hr))
                // what to do?
                goto done;
        }
        else
        {
            Assert(ttNone == m_TimelineType);

            for(int i = this->GetAllChildCount(); i > 0; i--)
            {
                CTIMEElementBase *pChild = this->GetChild(i - 1);

                if (NULL != GetParent())
                    THR(GetParent()->QueryInterface(IID_TO_PPV(ITIMEElement, &pTimeElement)));

                hr = THR(pChild->SetParent(pTimeElement, false));
                if (FAILED(hr))
                    goto done;

                if (NULL != GetParent() && doTimeline)
                    // ignore the result if startroottime fails
                    (void) THR(pChild->StartRootTime(GetParent()->GetMMTimeline()));
                pTimeElement.Release();
            }
        }

        if(doTimeline)
        {
            m_fTimelineInitialized = false;
            delete m_mmbvr;
            m_mmbvr = NULL;
            m_timeline = NULL;
            hr = this->InitTimeline();
            if (FAILED(hr))
                goto done;
            if (!m_mmbvr->Reset())
            {
                hr = TIMEGetLastError();
                goto done;
            }
        }
    }
    else
    {
        if( oldTimelineType != ttUninitialized)
            if (ttSeq == oldTimelineType || ttSeq == newTimelineType)
            {
                hr = E_FAIL;
                goto done;
            }

    }

    SetPropertyFlagAndNotify(DISPID_TIMEELEMENT_TIMELINE, teb_timeline);
done:
    if (FAILED(hr))
        m_TimelineType = oldTimelineType;

    SysFreeString(bstrTagName);
    return hr;
}

HRESULT
CTIMEElementBase::base_get_currTime(float * time)
{
    TraceTag((tagTimeElmBase,
              "CTIMEElementBase(%lx)::base_get_currTime(%lx)",
              this,
              time));

    HRESULT hr = E_FAIL;

    CHECK_RETURN_SET_NULL(time);

    Assert(NULL != m_mmbvr);
    if (NULL != m_mmbvr)
    {
        *time = m_mmbvr->GetSegmentTime();
        hr = S_OK;
    }

    return hr;
}

HRESULT
CTIMEElementBase::base_put_currTime(float time)
{
    TraceTag((tagTimeElmBase,
              "CTIMEElementBase(%lx)::base_put_currTime(%g)",
              this,
              time));
    return E_NOTIMPL;
}


HRESULT
CTIMEElementBase::base_get_localTime(float * time)
{
    TraceTag((tagTimeElmBase,
              "CTIMEElementBase(%lx)::base_get_localTime(%lx)",
              this,
              time));

    HRESULT hr = E_FAIL;

    CHECK_RETURN_SET_NULL(time);

    Assert(NULL != m_mmbvr);
    if (NULL != m_mmbvr)
    {
        *time = m_mmbvr->GetLocalTime();
        hr = S_OK;
    }

    return hr;
}

HRESULT
CTIMEElementBase::base_put_localTime(float time)
{
    TraceTag((tagTimeElmBase,
              "CTIMEElementBase(%lx)::base_put_localTime(%g)",
              this,
              time));

    bool ok = false;

    Assert(NULL != m_mmbvr);
    if (NULL != m_mmbvr)
    {
        // seeking when paused is enforced in MMAPI
        if (!m_mmbvr->Seek(time))
        {
            goto done;
        }
        // Make sure we have a player
        if (!GetPlayer())
        {
            goto done;
        }
        // Force a tick to render updates.
        if (!(GetPlayer()->TickOnceWhenPaused()))
        {
            goto done;
        }
    }

    ok = true;
  done:
    return ok?S_OK:Error();
}

HRESULT
CTIMEElementBase::base_get_currState(LPOLESTR * state)
{
    HRESULT hr;

    CHECK_RETURN_SET_NULL(state);

    hr = E_NOTIMPL;

    return hr;
}

HRESULT
CTIMEElementBase::base_put_currState(LPOLESTR state)
{
    return E_NOTIMPL;
}

HRESULT
CTIMEElementBase::base_get_syncBehavior(LPOLESTR * sync)
{
    HRESULT hr;

    CHECK_RETURN_SET_NULL(sync);

    *sync = SysAllocString(TokenToString(m_syncBehavior));

    if (*sync == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto done;
    }

    hr = S_OK;
  done:
    return hr;
}

HRESULT
CTIMEElementBase::base_put_syncBehavior(LPOLESTR sync)
{
    HRESULT hr;

    TOKEN tok_sync = StringToToken(sync);

    if( (tok_sync != CANSLIP_TOKEN) &&
        (tok_sync != LOCKED_TOKEN))
    {
        hr = E_INVALIDARG;
        goto done;
    }

    if (m_syncBehavior != tok_sync)
    {
        m_syncBehavior = tok_sync;
    }

    if (NULL != m_mmbvr)
    {
        m_mmbvr->Update();
    }

    hr = S_OK;


    SetPropertyFlagAndNotify(DISPID_TIMEELEMENT_SYNCBEHAVIOR, teb_syncBehavior);
  done:
    return hr;
}


HRESULT
CTIMEElementBase::base_get_syncTolerance(VARIANT * time)
{
    HRESULT hr;
    VARIANT fTemp, bstrTemp;
    if (time == NULL)
    {
        hr = E_POINTER;
        goto done;
    }

    if (FAILED(hr = THR(VariantClear(time))))
    {
        goto done;
    }

    VariantInit(&fTemp);
    VariantInit(&bstrTemp);
    fTemp.vt = VT_R4;
    fTemp.fltVal = m_syncTolerance;

    hr = THR(VariantChangeTypeEx(&bstrTemp, &fTemp, LCID_SCRIPTING, VARIANT_NOUSEROVERRIDE, VT_BSTR));
    if (SUCCEEDED(hr))
    {
        time->vt = VT_BSTR;
        time->bstrVal = SysAllocString(bstrTemp.bstrVal);
    }
    else
    {
        time->vt = VT_R4;
        time->fltVal = fTemp.fltVal;
    }

    VariantClear(&fTemp);
    SysFreeString(bstrTemp.bstrVal);
    VariantClear(&bstrTemp);

    hr = S_OK;
  done:
    return hr;
}

HRESULT
CTIMEElementBase::base_put_syncTolerance(VARIANT time)
{
    VariantToTime(time, &m_syncTolerance);

    SetPropertyFlagAndNotify(DISPID_TIMEELEMENT_SYNCTOLERANCE, teb_syncTolerance);
    return S_OK;
}

HRESULT
CTIMEElementBase::AddTIMEElement(CTIMEElementBase *elm)
{
    HRESULT hr = S_OK;

    hr = THR(m_pTIMEChildren.Append(elm));
    if (FAILED(hr))
    {
        goto done;
    }

done:
    return hr;
}

HRESULT
CTIMEElementBase::RemoveTIMEElement(CTIMEElementBase *elm)
{
    HRESULT hr = S_OK;

    bool bFound = m_pTIMEChildren.DeleteByValue(elm);
    if (bFound == false)
    {
        // no real error returned.  should fix up the array code...
        goto done;
    }

done:
    return hr;
}


HRESULT
CTIMEElementBase::base_get_parentTIMEElement(ITIMEElement **ppElem)
{
    HRESULT hr = S_OK;
    if (ppElem == NULL)
    {
        TraceTag((tagError, "CTIMEElementBase::base_get_parentTIMEElement - invalid arg"));
        hr = E_POINTER;
        goto done;
    }

    *ppElem = NULL;

    if (m_pTIMEParent != NULL)
    {
        hr = THR(m_pTIMEParent->QueryInterface(IID_ITIMEElement, (void**)ppElem));
    }

done:
    return hr;
}

HRESULT
CTIMEElementBase::base_put_parentTIMEElement(ITIMEElement *pElem)
{
    return E_NOTIMPL;
}

//*****************************************************************************
// method:   ReparentChildren()
//
// abstract: this method walks down an HTML tree, reparenting children that
//           have TIME behaviors to this TIME element.
//           Note:  if we find a TIME element that is a group, we need to stop.
//*****************************************************************************
HRESULT
CTIMEElementBase::ReparentChildren(ITIMEElement *pTIMEParent, IHTMLElement *pElem)
{
    DAComPtr<IDispatch>               pChildrenDisp;
    DAComPtr<IHTMLElementCollection>  pChildrenCollection;
    VARIANT varName;
    VARIANT varIndex;
    HRESULT hr;
    long    lChildren = 0;
    long    i;

    if (pElem == NULL)
    {
        hr = E_FAIL;
        Assert(false && "CTIMEElementBase::ReparentChildren was passed a NULL!");
        goto done;
    }

    // get pointer to children
    hr = THR(pElem->get_children(&pChildrenDisp));
    if (FAILED(hr))
    {
        goto done;
    }

    Assert(pChildrenDisp.p != NULL);

    // move to collection interface
    hr = THR(pChildrenDisp->QueryInterface(IID_IHTMLElementCollection, (void**)&pChildrenCollection));
    if (FAILED(hr))
    {
        goto done;
    }

    Assert(pChildrenCollection.p != NULL);

    // get length
    hr = THR(pChildrenCollection->get_length(&lChildren));
    if (FAILED(hr))
    {
        goto done;
    }

    // Variants for IHTMLElementCollection->item() call.
    // NOTE: we are using first Variant as an index.  The second variant
    //       is along for the ride.  The second variant only comes into play
    //       when you use the first variant as a name and multiple names exist.
    //       Then, the second can act as a index.
    VariantInit(&varName);
    varName.vt = VT_I4;
    varName.lVal = 0;

    VariantInit(&varIndex);

    // loop thru children
    for (i = 0; i < lChildren; i++)
    {
        DAComPtr<IDispatch>       pChildDisp;
        DAComPtr<ITIMEElement>    pTIMEElem;
        DAComPtr<IHTMLElement>    pChildElement;
        CTIMEElementBase *pTempTEB = NULL;

        varName.lVal = i;

        // get indexed child
        hr = THR(pChildrenCollection->item(varName, varIndex, &pChildDisp));
        if (FAILED(hr))
        {
            goto done;
        }

        Assert(pChildDisp.p != NULL);

        // get IHTMLElement
        hr = THR(pChildDisp->QueryInterface(IID_IHTMLElement, (void**)&pChildElement));
        if (FAILED(hr))
        {
            goto done;
        }

        // Is there a TIME behavior on this element
        pTIMEElem = NULL;
        hr = FindTIMEInterface(pChildElement, &pTIMEElem);
        if (SUCCEEDED(hr))
        {
            Assert(pTIMEElem.p != NULL);
            pTempTEB = GetTIMEElementBase(pTIMEElem);

            Assert(pTempTEB != NULL);

            // set parent.  do not set children
            hr = pTempTEB->SetParent(pTIMEParent, false);
            if (FAILED(hr))
            {
                goto done;
            }
        }

        // if NO TIME was found or the TIME element is not a group
        // continue walking down the tree
        if ( (pTIMEElem.p == NULL) ||
             ((pTempTEB != NULL) && !pTempTEB->IsGroup()) )
        {
            hr = ReparentChildren(pTIMEParent, pChildElement);
            if (FAILED(hr))
            {
                goto done;
            }
        }
    } // for loop

    hr = S_OK;
done:
    return hr;
}

//*****************************************************************************
// method:   UnparentElement()
//
// abstract: this is a centralized method that knows how to detach a TIME element
//           from it's parent (if it has one).  There only two cases when this is
//           called.  Either you are shutting down (ie ::detach()) or you are being
//           reparented (ie SetParent() with new parent).
//*****************************************************************************
HRESULT
CTIMEElementBase::UnparentElement()
{
    HRESULT hr;

    // stop timeline
    if (m_bStarted)
    {
        MMTimeline * tl = NULL;
        if (m_pTIMEParent != NULL)
            tl = m_pTIMEParent->GetMMTimeline();
        StopRootTime(tl);
    }

    if (m_pTIMEParent != NULL)
    {
        // if the parent is around, traverse back up, invalidating the collection cache.
        THR(InvalidateCollectionCache());

        // clear ourselves from our parents list
        hr = THR(m_pTIMEParent->RemoveTIMEElement(this));
        if (FAILED(hr))
        {
            goto done;
        }

        // these are both week references and we should NULL them since
        // we have no parent and are not associated with the inner TIME
        // heirarchy.
        m_pTIMEParent = NULL;
        m_pTIMEBody = NULL;
    }

    hr = S_OK;
done:
    return hr;
}

HRESULT
CTIMEElementBase::SetParent(ITIMEElement *pElem, bool fReparentChildren /* true */)
{
    HRESULT hr = S_OK;
    CTIMEElementBase *pTempTEB = NULL;

    // for the body return with an error
    if (IsBody())
    {
        TraceTag((tagError, "CTIMEElementBase::SetParent - error trying to parent a body element"));
        hr = E_UNEXPECTED;
        goto done;
    }

    // if we already have a parent, remove ourselves from it's child list
    if (m_pTIMEParent != NULL)
    {
        DAComPtr<ITIMEElement> pParent;

        // PERF: if the parent coming in is equal to current parent, make it a nop
        // NOTE: this can never fail!
        THR(m_pTIMEParent->QueryInterface(IID_ITIMEElement, (void**)&pParent));
        if (pParent == pElem)
        {
            hr = S_OK;
            goto done;
        }

        // need to unparent element.
        hr = UnparentElement();
        if (FAILED(hr))
        {
            TraceTag((tagError, "CTIMEElementBase::SetParent(%lx) - UnparentElement() failed", this));
            goto done;
        }
    }

    Assert(m_pTIMEParent == NULL);

    // if NULL was passed in, our work is done
    if (pElem == NULL)
    {
        hr = S_OK;
        goto done;
    }

    // move from the interface pointer to the class pointer
    pTempTEB = GetTIMEElementBase(pElem);
    if (pTempTEB == NULL)
    {
        TraceTag((tagError, "CTIMEElementBase::SetParent - GetTIMEElementBase() failed"));
        hr = E_INVALIDARG;
        goto done;
    }

    // add ourselves as a child
    hr = THR(pTempTEB->AddTIMEElement(this));
    if (FAILED(hr))
    {
        goto done;
    }

    // cache the parent
    // BUGBUG: this is a weak reference
    m_pTIMEParent = pTempTEB;

    // cache the designated Body
    // BUGBUG: this is a weak reference
    Assert(pTempTEB->GetBody());
    m_pTIMEBody = pTempTEB->GetBody();

    // reparent any children of this HTML element that have children, if we
    // are a group.
    if (fReparentChildren && IsGroup())
    {
        DAComPtr<ITIMEElement> pTIMEElem;

        // This should ALWAYS work
        THR(QueryInterface(IID_ITIMEElement, (void**)&pTIMEElem));
        Assert(pTIMEElem.p != NULL);
        hr = ReparentChildren(pTIMEElem, GetElement());
        if (FAILED(hr))
        {
            goto done;
        }
    }
    hr = S_OK;
done:
    return hr;
}

HRESULT
CTIMEElementBase::ParentElement()
{
    TraceTag((tagTimeElmBase, "CTIMEElementBase::ParentElement"));
    // Loop thru parents until one is found with TIME on it
    bool fFound = false;
    bool fBehaviorExists = false;
    DAComPtr<IHTMLElement> pElem = GetElement();
    DAComPtr<IHTMLElement> pElemParent = NULL;
    DAComPtr<ITIMEElement> pTIMEElem = NULL;
    HRESULT hr = S_FALSE;

    Assert(!IsBody());

    // walk up the HTML tree, looking for element's with TIME behaviors on them
    while (!fFound)
    {
        hr = THR(pElem->get_parentElement(&pElemParent));
        if (FAILED(hr))
        {
            TraceTag((tagError, "CTIMEElementBase::ParentElement - get_parentElement() failed"));
            goto done;
        }

        // see if we have a parent
        // If not, this is an orphaned case
        if (pElemParent.p == NULL)
        {
            TraceTag((tagTimeElmBase, "CTIMEElementBase::ParentElement - orphaned node!!!"));
            hr = S_FALSE;
            goto done;
        }

        // see if TIME behavior exists on parent
        fBehaviorExists = false;
        hr = CheckElementForBehaviorURN(pElemParent, GetBehaviorTypeAsURN(), &fBehaviorExists);
        if (FAILED(hr))
        {
            goto done;
        }

        // if this element has a TIME behavior and is either a
        // par or seq, then we have found our parent.
        if (fBehaviorExists && IsGroup(pElemParent))
        {
            fFound = true;
        }
        else
        {
            // continue walking up the tree
            pElem = pElemParent;
            pElemParent.Release();
        }
    }

    // if we found a parent with TIME, add our selves to it's children
    if (fFound && (pElemParent.p != NULL))
    {
        // get TIME interface
        hr = FindTIMEInterface(pElemParent, &pTIMEElem);
        if (FAILED(hr))
        {
            TraceTag((tagError, "CTIMEElementBase::ParentElement - FindTIMEInterface() failed"));
            goto done;
        }

        Assert(pTIMEElem.p != NULL);

        // set our parent
        hr = THR(SetParent(pTIMEElem));
        if (FAILED(hr))
        {
            TraceTag((tagError, "CTIMEElementBase::ParentElement - SetParent() failed"));
            goto done;
        }
        hr = S_OK;
    }

done:
    return hr;
}

HRESULT
CTIMEElementBase::base_get_timelineBehavior(IDispatch **ppDisp)
{
    TraceTag((tagTimeElmBase,
              "CTIMEElementBase(%lx)::base_get_timelineBehavior()",
              this));

    CHECK_RETURN_SET_NULL(ppDisp);
    DAComPtr<IDANumber> bvr;
    bool ok = false;
    HRESULT hr;

    Assert(m_datimebvr);

    if (!CRBvrToCOM((CRBvrPtr) m_datimebvr.p,
                    IID_IDANumber,
                    (void **) &bvr.p))
    {
        goto done;
    }

    // make assignment.  keep ref count.
    hr = THR(bvr->QueryInterface(IID_IDispatch, (void**)ppDisp));
    if (FAILED(hr))
    {
        CRSetLastError(hr, NULL);
        goto done;
    }

    ok = true;
  done:
    return ok?S_OK:Error();
}

HRESULT
CTIMEElementBase::base_get_progressBehavior(IDispatch **ppDisp)
{
    TraceTag((tagTimeElmBase,
              "CTIMEElementBase(%lx)::base_get_progressBehavior()",
              this));

    CHECK_RETURN_SET_NULL(ppDisp);
    DAComPtr<IDANumber> bvr;
    bool ok = false;
    HRESULT hr;

    Assert(m_progress);

    if (!CRBvrToCOM((CRBvrPtr) m_progress.p,
                    IID_IDANumber,
                    (void **) &bvr.p))
    {
        goto done;
    }

    // make assignment.  keep ref count.
    hr = THR(bvr->QueryInterface(IID_IDispatch, (void**)ppDisp));
    if (FAILED(hr))
    {
        CRSetLastError(hr, NULL);
        goto done;
    }

    ok = true;
  done:
    return ok?S_OK:Error();
}

HRESULT
CTIMEElementBase::base_get_onOffBehavior(IDispatch **ppDisp)
{
    TraceTag((tagTimeElmBase,
              "CTIMEElementBase(%lx)::base_get_onOffBehavior()",
              this));

    CHECK_RETURN_SET_NULL(ppDisp);
    DAComPtr<IDABoolean> bvr;
    bool ok = false;
    HRESULT hr;

    Assert(m_onoff);

    if (!CRBvrToCOM((CRBvrPtr) m_onoff.p,
                    IID_IDABoolean,
                    (void **) &bvr.p))
    {
        goto done;
    }

    // make assignment.  keep ref count.
    hr = THR(bvr->QueryInterface(IID_IDispatch, (void**)ppDisp));
    if (FAILED(hr))
    {
        CRSetLastError(hr, NULL);
        goto done;
    }
    ok = true;
  done:
    return ok?S_OK:Error();
}

HRESULT
CTIMEElementBase::StartRootTime(MMTimeline * tl)
{
    HRESULT hr = E_FAIL;

    Assert(!m_bStarted);

    if (!Update())
    {
        hr = CRGetLastError();
        goto done;
    }

    Assert(tl || m_timeline);
    Assert(NULL != m_mmbvr);
    if (NULL != m_mmbvr)
    {

        // Need to make sure the timeline passed in
        if (tl != NULL && !tl->AddBehavior(*m_mmbvr))
        {
            hr = CRGetLastError();
            goto done;
        }

        // is this element a par or seq
        if (IsGroup())
        {
            CTIMEElementBase **ppElm;
            int i;

            for (i = m_pTIMEChildren.Size(), ppElm = m_pTIMEChildren;
                 i > 0;
                 i--, ppElm++)
            {
                Assert(m_timeline);

                hr = THR((*ppElm)->StartRootTime(m_timeline));
                if (FAILED(hr))
                {
                    goto done;
                }
            }
        }
        else
        {
            // If we are not par then we should not have children
            Assert(m_pTIMEChildren.Size() == 0);
        }

        m_bStarted = true;
        hr = S_OK;
    }
  done:
    return hr;
}

void
CTIMEElementBase::StopRootTime(MMTimeline * tl)
{
    Assert(NULL != m_mmbvr);
    if (NULL != m_mmbvr)
    {
        if (tl != NULL)
        {
            tl->RemoveBehavior(*m_mmbvr);
        }

        // if this a par or seq, then process children
        if (IsGroup())
        {
            CTIMEElementBase **ppElm;
            int i;

            for (i = m_pTIMEChildren.Size(), ppElm = m_pTIMEChildren;
                 i > 0;
                 i--, ppElm++)
            {
                Assert(m_timeline);
                (*ppElm)->StopRootTime(m_timeline);
            }
        }
        else
        {
            // If we are not par then we should not have children
            Assert(m_pTIMEChildren.Size() == 0);
        }
    }

    m_bStarted = false;

    return;
}

bool
CTIMEElementBase::Update()
{
    bool ok = false;
    CRBvr * bvr;

    CRLockGrabber __gclg;

    CalcTimes();

    // Force updating of the timing structures

    Assert(NULL != m_mmbvr);
    if (NULL != m_mmbvr)
    {
        if (!m_mmbvr->Update())
        {
            goto done;
        }

        if (m_timeline && !m_timeline->Update())
        {
            goto done;
        }

        ok = true;
    }

  done:
    return ok;
}

void
CTIMEElementBase::CalcTimes()
{
    m_realBeginTime = m_begin;
    m_realRepeatCount = m_repeat;

    if (m_dur != valueNotSet)
    {
        m_realDuration = m_dur;
    }
    else if (m_end != valueNotSet)
    {
        if (m_end < m_begin)
        {
            m_realDuration = HUGE_VAL;
        }
        else
        {
            m_realDuration = m_end - m_begin;
        }
    }
    else
    {
        m_realDuration = HUGE_VAL;
    }

    if (m_realDuration == 0.0f)
    {
        m_realDuration = HUGE_VAL;
    }

    if (m_bautoreverse && (HUGE_VAL != m_realDuration))
    {
        m_realIntervalDuration = m_realDuration * 2;
    }
    else
    {
        m_realIntervalDuration = m_realDuration;
    }

    if (m_repeatDur != valueNotSet)
    {
        m_realRepeatTime = m_repeatDur;
    }
    else
    {
        m_realRepeatTime = m_repeat * m_realIntervalDuration;
    }

    if (m_realRepeatTime == 0.0f)
    {
        m_realRepeatTime = HUGE_VAL;
    }
}

TOKEN
GetActionPropertyToken(TOKEN action)
{
    TOKEN token;

    Assert(action != NONE_TOKEN);

    if (action == ONOFF_TOKEN)
    {
        token = ONOFF_PROPERTY_TOKEN;
    }
    else if (action == STYLE_TOKEN)
    {
        token = STYLE_PROPERTY_TOKEN;
    }
    else if (action == DISPLAY_TOKEN)
    {
        token = DISPLAY_PROPERTY_TOKEN;
    }
    else
    {
        token = VISIBILITY_PROPERTY_TOKEN;
    }

    return token;
}

bool
CTIMEElementBase::AddTimeAction()
{
    bool ok = false;

    if (m_timeAction == NONE_TOKEN)
    {
        ok = true;
        goto done;
    }
    else if (m_timeAction == ONOFF_TOKEN)
    {
        CComVariant v;
        BSTR bstr;

        bstr = SysAllocString(TokenToString(ONOFF_PROPERTY_TOKEN));

        // Need to free bstr
        if (bstr == NULL)
        {
            CRSetLastError(E_OUTOFMEMORY, NULL);
            goto done;
        }

        // We do not care if this succeeds
        THR(GetElement()->getAttribute(bstr,0,&v));

        SysFreeString(bstr);

        if (SUCCEEDED(THR(v.ChangeType(VT_BSTR))))
        {
            m_origAction = CopyString(V_BSTR(&v));
        }

    }
    else if (m_timeAction == STYLE_TOKEN)
    {
        DAComPtr<IHTMLStyle> s;

        if ((!GetElement()) || FAILED(THR(GetElement()->get_style(&s))))
        {
            goto done;
        }

        BSTR bstr = NULL;

        if (FAILED(THR(s->get_cssText(&bstr))))
        {
            goto done;
        }

        m_origAction = CopyString(bstr);

        SysFreeString(bstr);
    }
    else if (m_timeAction == DISPLAY_TOKEN)
    {
        DAComPtr<IHTMLStyle> s;

        if ((!GetElement()) || FAILED(THR(GetElement()->get_style(&s))))
        {
            goto done;
        }

        BSTR bstr = NULL;

        if (FAILED(THR(s->get_display(&bstr))))
        {
            goto done;
        }

        m_origAction = CopyString(bstr);

        SysFreeString(bstr);
    }
    else
    {
        DAComPtr<IHTMLStyle> s;

        if ((!GetElement()) || FAILED(THR(GetElement()->get_style(&s))))
        {
            goto done;
        }

        BSTR bstr = NULL;

        if (FAILED(THR(s->get_visibility(&bstr))))
        {
            goto done;
        }

        m_origAction = CopyString(bstr);

        SysFreeString(bstr);
    }

    ok = true;
  done:
    return ok;
}

bool
CTIMEElementBase::RemoveTimeAction()
{
    bool ok = false;
    HRESULT hr = S_OK;

    if (m_timeAction == NONE_TOKEN)
    {
        ok = true;
        goto done;
    }
    else if (m_timeAction == ONOFF_TOKEN)
    {
        CComVariant v(m_origAction);

        BSTR bstr;

        bstr = SysAllocString(TokenToString(ONOFF_PROPERTY_TOKEN));

        // Need to free bstr
        if (bstr == NULL)
        {
            CRSetLastError(E_OUTOFMEMORY, NULL);
            goto done;
        }

        // We do not care if this succeeds
        THR(GetElement()->setAttribute(bstr,v,0));

        SysFreeString(bstr);

        delete [] m_origAction;
        m_origAction = NULL;
    }
    else if (m_timeAction == STYLE_TOKEN)
    {
        DAComPtr<IHTMLStyle> s;

        if ((!GetElement()) || FAILED(THR(GetElement()->get_style(&s))))
        {
            goto done;
        }

        BSTR bstr;

        bstr = SysAllocString(m_origAction);

        // Need to free bstr
        if (bstr == NULL)
        {
            CRSetLastError(E_OUTOFMEMORY, NULL);
            goto done;
        }

        THR(s->put_cssText(bstr));

        SysFreeString(bstr);

        delete [] m_origAction;
        m_origAction = NULL;
    }
    else if (m_timeAction == DISPLAY_TOKEN)
    {
        DAComPtr<IHTMLStyle> s;
        DAComPtr<IHTMLElement2> pElement2;

        if (!GetElement())
        {
            goto done;
        }

        hr = THR(GetElement()->QueryInterface(IID_IHTMLElement2, (void **)&pElement2));
        if (FAILED(hr))
        {
            goto done;
        }

        if (!pElement2 || FAILED(THR(pElement2->get_runtimeStyle(&s))))
        {
            goto done;
        }

        BSTR bstr;

        bstr = SysAllocString(m_origAction);

        // Need to free bstr
        if (bstr == NULL)
        {
            CRSetLastError(E_OUTOFMEMORY, NULL);
            goto done;
        }

        THR(s->put_display(bstr));

        SysFreeString(bstr);

        delete [] m_origAction;
        m_origAction = NULL;
    }
    else
    {
        DAComPtr<IHTMLStyle> s;
        DAComPtr<IHTMLElement2> pElement2;

        if (!GetElement())
        {
            goto done;
        }

        hr = THR(GetElement()->QueryInterface(IID_IHTMLElement2, (void **)&pElement2));
        if (FAILED(hr))
        {
            goto done;
        }

        if (!pElement2 || FAILED(THR(pElement2->get_runtimeStyle(&s))))
        {
            goto done;
        }

        BSTR bstr;

        bstr = SysAllocString(m_origAction);

        // Need to free bstr
        if (bstr == NULL)
        {
            CRSetLastError(E_OUTOFMEMORY, NULL);
            goto done;
        }

        THR(s->put_visibility(bstr));

        SysFreeString(bstr);

        delete [] m_origAction;
        m_origAction = NULL;
    }

    ok = true;
  done:
    return ok;
}

bool
CTIMEElementBase::ToggleTimeAction(bool on)
{
    TraceTag((tagTimeElmBase,
              "CTIMEElementBase(%lx)::ToggleTimeAction(%d) id=%ls",
              this,
              on,
              m_id?m_id:L"unknown"));

    bool ok = false;
    BSTR bstr = NULL;

    if (m_timeAction == NONE_TOKEN)
    {
        ok = true;
        goto done;
    }
    else if (m_timeAction == ONOFF_TOKEN)
    {
        CComVariant v(TokenToString(on?TRUE_TOKEN:FALSE_TOKEN));
        BSTR bstr;

        bstr = SysAllocString(TokenToString(ONOFF_PROPERTY_TOKEN));

        // Need to free bstr
        if (bstr == NULL)
        {
            CRSetLastError(E_OUTOFMEMORY, NULL);
            goto done;
        }

        // We do not care if this succeeds
        THR(GetElement()->setAttribute(bstr,v,0));

        SysFreeString(bstr);
    }
    else if (m_timeAction == STYLE_TOKEN)
    {
        DAComPtr<IHTMLStyle> s;

        if ((!GetElement()) || FAILED(THR(GetElement()->get_style(&s))))
        {
            goto done;
        }

        BSTR bstr;

        bstr = SysAllocString(on?m_origAction:TokenToString(NONE_TOKEN));

        // Need to free bstr
        if (bstr == NULL)
        {
            CRSetLastError(E_OUTOFMEMORY, NULL);
            goto done;
        }

        THR(s->put_cssText(bstr));

        SysFreeString(bstr);
    }
    else if (m_timeAction == DISPLAY_TOKEN)
    {
        DAComPtr<IHTMLStyle> s;
        DAComPtr<IHTMLElement2> pElement2;

        if ((!GetElement()) || FAILED(THR(GetElement()->QueryInterface(IID_TO_PPV(IHTMLElement2, &pElement2)))))
        {
            goto done;
        }

        if (!pElement2 || FAILED(THR(pElement2->get_runtimeStyle(&s))))
        {
            goto done;
        }

        BSTR bstr;

        bstr = SysAllocString(on?m_origAction:TokenToString(NONE_TOKEN));

        // Need to free bstr
        if (bstr == NULL)
        {
            CRSetLastError(E_OUTOFMEMORY, NULL);
            goto done;
        }

        THR(s->put_display(bstr));

        SysFreeString(bstr);
    }
    else
    {
        HRESULT hr = S_OK;

        DAComPtr<IHTMLStyle> s;
        DAComPtr<IHTMLElement2> pElement2;

        if (!GetElement())
        {
            goto done;
        }

        hr = THR(GetElement()->QueryInterface(IID_IHTMLElement2, (void **)&pElement2));
        if (FAILED(hr))
        {
            goto done;
        }


        if (!pElement2 || FAILED(THR(pElement2->get_runtimeStyle(&s))))
        {
            goto done;
        }

        BSTR bstr;

        bstr = SysAllocString(on?m_origAction:TokenToString(HIDDEN_TOKEN));

        // Need to free bstr
        if (bstr == NULL)
        {
            CRSetLastError(E_OUTOFMEMORY, NULL);
            goto done;
        }

        THR(s->put_visibility(bstr));

        SysFreeString(bstr);
    }

    ok = true;
  done:
    return ok;
}


CRBvr *
CTIMEElementBase::GetBaseBvr()
{
    TraceTag((tagTimeElmBase,
              "CTIMEElementBase(%lx)::GetBaseBvr()",
              this));

    return (CRBvr *) CRLocalTime();
}

bool
CTIMEElementBase::FireEvent(TIME_EVENT TimeEvent,
                            double dblLocalTime,
                            DWORD flags)
{
    TraceTag((tagTimeElmBase,
              "CTIMEElementBase(%lx)::FireEvent(%d)",
              this,
              TimeEvent));

    bool ok = false;
    HRESULT hr;

    switch(TimeEvent)
    {
      case TE_ONBEGIN:
        OnBegin(dblLocalTime, flags);
        break;
      case TE_ONEND:
        OnEnd(dblLocalTime);
        break;
      case TE_ONPAUSE:
        OnPause(dblLocalTime);
        break;
      case TE_ONRESUME:
        OnResume(dblLocalTime);
        break;
      case TE_ONRESET:
        OnReset(dblLocalTime, flags);
        break;
      case TE_ONREPEAT:
        OnRepeat(dblLocalTime);
        break;
    }

    // If we are not seeking then fire the event out

    if ((flags & MM_EVENT_SEEK) == 0)
    {
        if (!IsUnloading())
        {
            LPWSTR wzParamNames[] = {WZ_EVENT_CAUSE_IS_RESTART,};
            VARIANT varParamValue;

            VariantInit(&varParamValue);
            V_VT(&varParamValue) = VT_BOOL;

            // Do we need to indicate a reset here?
            if (0 == (flags & MM_EVENT_PROPERTY_CHANGE))
            {
                V_BOOL(&varParamValue) = VARIANT_FALSE;
            }
            else
            {
                V_BOOL(&varParamValue) = VARIANT_TRUE;
            }

            hr = THR(m_eventMgr.FireEvent(TimeEvent,
                                          1,
                                          wzParamNames,
                                          &varParamValue));

            VariantClear(&varParamValue);

            if (FAILED(hr))
            {
                CRSetLastError(hr, NULL);
                goto done;
            }
        }
    }

    ok = true;
  done:
    return ok;
}

void
CTIMEElementBase::UpdateProgressBvr()
{
    CRLockGrabber __gclg;

    HRESULT hr;

    // Get the resultant behavior

    DAComPtr<IUnknown> unk;

    hr = THR(m_mmbvr->GetMMBvr()->GetResultantBehavior(IID_IUnknown,
        (void **) &unk));

    if (FAILED(hr))
    {
        goto done;
    }

    Assert(unk);

    CRNumberPtr resBvr;

    resBvr = (CRNumberPtr) COMToCRBvr(unk);

    if (!resBvr)
    {
        TraceTag((tagError,
            "CTIMEDAElement::OnBegin - Error getting da number"));
        hr = CRGetLastError();
        goto done;
    }

    if (!CRSwitchTo((CRBvrPtr) m_datimebvr.p,
        (CRBvrPtr) resBvr,
        true,
        CRContinueTimeline,
        0.0))
    {
        goto done;
    }

    CRNumberPtr n;

    if ((n = CRCreateNumber(m_realDuration)) == NULL)
    {
        TraceTag((tagError,
            "CTIMEDAElement::OnBegin - Error creating duration behavior"));
        goto done;
    }

    if ((n = CRDiv(resBvr, n)) == NULL)
    {
        TraceTag((tagError,
            "CTIMEDAElement::OnBegin - Error creating div"));
        goto done;
    }

    if (!CRSwitchTo((CRBvrPtr) m_progress.p,
        (CRBvrPtr) n,
        true,
        CRContinueTimeline,
        0.0))
    {
        goto done;
    }

    // Make sure we have a player
    if (!GetPlayer())
    {
        goto done;
    }

    // Force a tick to render updates.
    if (!(GetPlayer()->Tick(GetPlayer()->GetCurrentTime())))
    {
        goto done;
    }

done:
    return;
}

void
CTIMEElementBase::OnBegin(double dblLocalTime, DWORD flags)
{
    TraceTag((tagTimeElmBase,
              "CTIMEElementBase(%lx)::OnBegin()",
              this));

    Assert(NULL != m_mmbvr);
    Assert(NULL != m_mmbvr->GetMMBvr());

    double dblSegmentTime = 0;
    HRESULT hr = S_OK;
    hr = THR(m_mmbvr->GetMMBvr()->get_SegmentTime(&dblSegmentTime));
    if (FAILED(hr))
    {
        return;
    }

    // Check if this event was fired by our hack to make endhold work correctly
    // when seeking forward (over our lifespan)
    if ((flags & MM_EVENT_SEEK) && HUGE_VAL == dblSegmentTime)
    {
        // if endhold isn't set, we shouldn't toggle TimeAction or the OnOff bvr, so bail
        if (!GetEndHold())
        {
            return;
        }
        // else we should (below)
    }

    ToggleTimeAction(true);


    CRLockGrabber __gclg;

    CRSwitchTo((CRBvrPtr) m_onoff.p,
        (CRBvrPtr) CRTrue(),
        false,
        0,
        0.0);

    UpdateProgressBvr();

    return;
}

#define MM_INFINITE HUGE_VAL


void
CTIMEElementBase::OnEnd(double dblLocalTime)
{
    TraceTag((tagTimeElmBase,
              "CTIMEElementBase(%lx)::OnEnd()",
              this));

    HRESULT hr = S_OK;
    double dblTime = 0.0;

    Assert(m_mmbvr != NULL);
    Assert(m_mmbvr->GetMMBvr() != NULL);

    hr = THR(m_mmbvr->GetMMBvr()->get_LocalTimeEx(&dblTime));
    if (FAILED(hr))
    {
        // what to do?  just try to be reasonable
        dblTime = 0.0;
    }
    // we compare with -MM_INFINITE to avoid doing an end hold
    // when seeking backwards beyond the beginning of the element.
    if (!GetEndHold() || dblTime == -MM_INFINITE)
    {
        ToggleTimeAction(false);

        {
            CRLockGrabber __gclg;
            CRSwitchTo((CRBvrPtr) m_onoff.p,
                       (CRBvrPtr) CRFalse(),
                       false,
                       0,
                       0.0);
        }
    }
}


void
CTIMEElementBase::OnPause(double dblLocalTime)
{
    TraceTag((tagTimeElmBase,
              "CTIMEElementBase(%lx)::OnPause()",
              this));
    m_fPaused = true;
}

void
CTIMEElementBase::OnResume(double dblLocalTime)
{
    TraceTag((tagTimeElmBase,
              "CTIMEElementBase(%lx)::OnResume()",
              this));
    m_fPaused = false;
}

void
CTIMEElementBase::OnReset(double dblLocalTime, DWORD flags)
{
    TraceTag((tagTimeElmBase,
              "CTIMEElementBase(%lx)::OnReset()",
              this));

    HRESULT hr = S_OK;
    double dblTime = 0.0;

    Assert(m_mmbvr != NULL);
    Assert(m_mmbvr->GetMMBvr() != NULL);

    hr = THR(m_mmbvr->GetMMBvr()->get_LocalTimeEx(&dblTime));
    if (FAILED(hr))
    {
        // what to do?  just try to be reasonable
        dblTime = 0.0;
    }

    if (!GetEndHold() || dblTime < m_realDuration)
    {
        ToggleTimeAction(false);

        CRLockGrabber __gclg;

        CRSwitchTo((CRBvrPtr) m_onoff.p, (CRBvrPtr) CRFalse(), false, 0, 0.0);
        if ((flags & MM_EVENT_SEEK) == 0)
        {
            CRSwitchToNumber(m_progress.p, 0.0);
            CRSwitchToNumber(m_datimebvr.p, 0.0);
        }
    }
}

void
CTIMEElementBase::OnSync(double dbllastTime, double & dblnewTime)
{
}

MM_STATE
CTIMEElementBase::GetPlayState()
{
    TraceTag((tagTimeElmBase,
              "CTIMEElementBase(%lx)::GetPlayState()",
              this));

    MM_STATE retState = MM_STOPPED_STATE;

    Assert(NULL != m_mmbvr);
    if (NULL != m_mmbvr)
    {
        retState = m_mmbvr->GetPlayState();
    }

    return retState;
}

//
// Sneaky way to get a CTIMEElementBase out of an ITIMEElement:
//

class __declspec(uuid("AED49AA3-5C7A-11d2-AF2D-00A0C9A03B8C"))
TIMEElementBaseGUID {};

HRESULT WINAPI
CTIMEElementBase::BaseInternalQueryInterface(CTIMEElementBase* pThis,
                                             void * pv,
                                             const _ATL_INTMAP_ENTRY* pEntries,
                                             REFIID iid,
                                             void** ppvObject)
{
    if (InlineIsEqualGUID(iid, __uuidof(TIMEElementBaseGUID)))
    {
        *ppvObject = pThis;
        return S_OK;
    }

    return CComObjectRootEx<CComSingleThreadModel>::InternalQueryInterface(pv,
                                                                           pEntries,
                                                                           iid,
                                                                           ppvObject);
}

CTIMEElementBase *
GetTIMEElementBase(IUnknown * pInputUnknown)
{
    CTIMEElementBase * pTEB = NULL;

    if (pInputUnknown)
    {
        pInputUnknown->QueryInterface(__uuidof(TIMEElementBaseGUID),(void **)&pTEB);
    }

    if (pTEB == NULL)
    {
        CRSetLastError(E_INVALIDARG, NULL);
    }

    return pTEB;
}


//************************************************************
// Author:      twillie
// Created:     10/07/98
// Abstract:    get Tag string from HTML element
//************************************************************

HRESULT
CTIMEElementBase::getTagString(BSTR *pbstrID)
{
    return GetElement()->get_id(pbstrID);
} // getTagString

//************************************************************
// Author:      twillie
// Created:     10/07/98
// Abstract:    get ID string from HTML element
//************************************************************

HRESULT
CTIMEElementBase::getIDString(BSTR *pbstrTag)
{
    return GetElement()->get_id(pbstrTag);
}  // getIDString

//************************************************************
// Author:      twillie
// Created:     10/07/98
// Abstract:    helper function to wade thru cache.
//************************************************************

HRESULT
CTIMEElementBase::base_get_collection(COLLECTION_INDEX index, ITIMEElementCollection ** ppDisp)
{
    HRESULT hr;

    // validate out param
    if (ppDisp == NULL)
        return TIMESetLastError(E_POINTER);

    *ppDisp = NULL;

    hr = EnsureCollectionCache();
    if (FAILED(hr))
    {
        TraceTag((tagError, "CTIMEElementBase::GetCollection - EnsureCollectionCache() failed"));
        return hr;
    }

    // call in
    return m_pCollectionCache->GetCollectionDisp(index, (IDispatch **)ppDisp);
} // GetCollection

//************************************************************
// Author:      twillie
// Created:     10/07/98
// Abstract:    Make sure collection cache is up
//************************************************************

HRESULT
CTIMEElementBase::EnsureCollectionCache()
{
    // check to see if collection cache has been created
    if (m_pCollectionCache == NULL)
    {
        // bring up collection cache
        // NOTE: we need to handle CRSetLastError here as
        // cache object doesn't have that concept.
        m_pCollectionCache = NEW CCollectionCache(this, GetAtomTable());
        if (m_pCollectionCache == NULL)
        {
            TraceTag((tagError, "CTIMEElementBase::EnsureCollectionCache - Unable to create Collection Cache"));
            return TIMESetLastError(E_OUTOFMEMORY);
        }

        HRESULT hr = m_pCollectionCache->Init(NUM_COLLECTIONS);
        if (FAILED(hr))
        {
            TraceTag((tagError, "CTIMEElementBase::EnsureCollectionCache - collection cache init failed"));
            delete m_pCollectionCache;
            return TIMESetLastError(hr);
        }

        // set collection types
        m_pCollectionCache->SetCollectionType(ciAllElements, ctAll, true);
        m_pCollectionCache->SetCollectionType(ciChildrenElements, ctChildren, true);
        m_pCollectionCache->SetCollectionType(ciAllInterfaces, ctAll);
        m_pCollectionCache->SetCollectionType(ciChildrenInterfaces, ctChildren);
    }

    return S_OK;
} // EnsureCollectionCache

//************************************************************
// Author:      twillie
// Created:     10/07/98
// Abstract:    invalidate all collection cache's that might
//              reference this object.
//************************************************************

HRESULT
CTIMEElementBase::InvalidateCollectionCache()
{
    CTIMEElementBase *pelem = this;

    // walk up tree, invalidating CollectionCache's
    // we skip if the collection is not initialized
    // we walk until we run out of parent's.  In this
    // manner, we keep the collectioncache fresh, even
    // if the object branch is orphaned.
    while (pelem != NULL)
    {
        // not everybody will have the collection cache
        // initialized
        CCollectionCache *pCollCache = pelem->GetCollectionCache();
        if (pCollCache != NULL)
            pCollCache->BumpVersion();

        // move to parent
        pelem = pelem->GetParent();
    }

    return S_OK;
} // InvalidateCollectionCache

//************************************************************
// Author:      twillie
// Created:     10/07/98
// Abstract:    init Atom Table
//              Note:  this is only done once and then addref'd.
//************************************************************

HRESULT
CTIMEElementBase::InitAtomTable()
{
    if (s_cAtomTableRef == 0)
    {
        Assert(s_pAtomTable == NULL);

        s_pAtomTable = NEW CAtomTable();
        if (s_pAtomTable == NULL)
        {
            TraceTag((tagError, "CElement::InitAtomTable - alloc failed for CAtomTable"));
            return TIMESetLastError(E_OUTOFMEMORY);
        }
    }

    s_cAtomTableRef++;
    return S_OK;
} // InitAtomTable

//************************************************************
// Author:      twillie
// Created:     10/07/98
// Abstract:    release Atom Table
//              Note: this decrement's until zero and then
//              releases the Atom table.
//************************************************************

void
CTIMEElementBase::ReleaseAtomTable()
{
    Assert(s_pAtomTable != NULL);
    Assert(s_cAtomTableRef > 0);
    if (s_cAtomTableRef > 0)
    {
        s_cAtomTableRef--;
        if (s_cAtomTableRef == 0)
        {
            if (s_pAtomTable != NULL)
            {
                delete s_pAtomTable;
                s_pAtomTable = NULL;
            }
        }
    }
    return;
} // ReleaseAtomTable


bool
CTIMEElementBase::IsGroup(IHTMLElement *pElement)
{
    HRESULT hr;
    bool    rc = false;
    DAComPtr<ITIMEElement> pTIMEElem;
    DAComPtr<ITIMEBodyElement> pTIMEBody;
    BSTR  bstrTimeline = NULL;
    BSTR  bstrTagName = NULL;

    hr = FindTIMEInterface(pElement, &pTIMEElem);
    if (FAILED(hr))
    {
        goto done;
    }

    Assert(pTIMEElem.p != NULL);

    hr = pTIMEElem->get_timeline(&bstrTimeline);
    if (FAILED(hr))
    {
        goto done;
    }

    Assert(bstrTimeline != NULL);

    // Check to see what the contents of the BSTR are.
    // If it is a seq or par, we want to return true.
    if ( (bstrTimeline != NULL) &&
         ((StrCmpIW(bstrTimeline, WZ_PAR) == 0) ||
          (StrCmpIW(bstrTimeline, WZ_SEQUENCE) == 0)) )
    {
         rc = true;
         goto done;
    }

    // check to see if it is the body element.
    // if so, then the element is *always" a group.
    hr = pTIMEElem->QueryInterface(IID_ITIMEBodyElement, (void**)&pTIMEBody);
    if (SUCCEEDED(hr))
    {
         rc = true;
         goto done;
    }

    // see if the tag name is <t:par> or <t:seq>
    hr = THR(pElement->get_tagName(&bstrTagName));
    if (FAILED(hr))
    {
        goto done;
    }

    Assert(bstrTagName != NULL);

    if ( (StrCmpIW(bstrTagName, WZ_PAR) == 0) ||
         (StrCmpIW(bstrTagName, WZ_SEQUENCE) == 0) )
    {
         rc = true;
         goto done;
    }

done:
    if (bstrTagName != NULL)
        SysFreeString(bstrTagName);
    if (bstrTimeline != NULL)
        SysFreeString(bstrTimeline);
    return rc;
}

bool
CTIMEElementBase::IsDocumentInEditMode()
{
    HRESULT hr;
    bool fRC = false;
    BSTR bstrMode = NULL;
    IDispatch *pDisp = NULL;
    IHTMLDocument2 *pDoc = NULL;
    IHTMLElement *pElem = GetElement();

    // if there is no pElem, we are not attached to an HTML element, and can't give any information.
    if (NULL == pElem)
        return false;

    hr = pElem->get_document(&pDisp);
    if (FAILED(hr))
    {
        TraceTag((tagError, "CContainerSite::Init - unable to get document pointer from element!!!"));
        goto done;
    }

    Assert(pDisp != NULL);

    hr = pDisp->QueryInterface(IID_TO_PPV(IHTMLDocument2, &pDoc));
    ReleaseInterface(pDisp);
    if (FAILED(hr))
    {
        TraceTag((tagError, "CContainerSite::Init - unable to QI for document pointer!!!"));
        goto done;
    }

    Assert(pDoc != NULL);

    hr = pDoc->get_designMode(&bstrMode);
    ReleaseInterface(pDoc);
    if (FAILED(hr))
    {
        TraceTag((tagError, "CContainerSite::Init - unable to QI for document pointer!!!"));
        goto done;
    }

    if (StrCmpIW(bstrMode, L"On") == 0)
    {
        fRC = true;
    }

    SysFreeString(bstrMode);

done:
    return fRC;
}

//************************************************************
// Author:          twillie
// Created:         11/24/98
// Abstract:        return left,top,width,height of element
//************************************************************
HRESULT
CTIMEElementBase::GetSize(RECT *prcPos)
{
    HRESULT hr;
    long lWidth = 0;
    long lHeight = 0;
    IHTMLElement *pElem = GetElement();
    DAComPtr<IHTMLElement2> pElem2;

    if (prcPos == NULL)
    {
        hr = E_POINTER;
        goto done;
    }

    if (pElem == NULL)
    {
        hr = E_UNEXPECTED;
        goto done;
    }

    hr = THR(pElem->QueryInterface(IID_IHTMLElement2, (void **)&pElem2));
    if (FAILED(hr))
    {
        hr = E_UNEXPECTED;
        goto done;
    }

    hr = THR(pElem2->get_clientWidth(&lWidth));
    if (FAILED(hr))
    {
        goto done;
    }

    hr = THR(pElem2->get_clientHeight(&lHeight));
    if (FAILED(hr))
    {
        goto done;
    }


    // fill in rect
    prcPos->left = prcPos->top = 0;
    prcPos->right = lWidth;
    prcPos->bottom = lHeight;

    TraceTag((tagTimeElmBase, "CTIMEElementBase::GetSize(%d, %d, %d, %d)", prcPos->left, prcPos->top, prcPos->right, prcPos->bottom));
    hr = S_OK;

done:
    return hr;
}

HRESULT
CTIMEElementBase::ClearSize()
{
    DAComPtr<IHTMLStyle> pStyle;
    DAComPtr<IHTMLElement2> pElement2;

    HRESULT hr = E_FAIL;

    if (!GetElement())
    {
        goto done;
    }

    hr = THR(GetElement()->QueryInterface(IID_TO_PPV(IHTMLElement2, &pElement2)));
    if (FAILED(hr))
    {
        goto done;
    }

    hr = THR(pElement2->get_runtimeStyle(&pStyle));
    if (FAILED(hr))
    {
        goto done;
    }

    Assert(pStyle);

    hr = pStyle->put_pixelWidth(0);
    if (FAILED(hr))
    {
        goto done;
    }

    hr = pStyle->put_pixelHeight(0);
    if (FAILED(hr))
    {
        goto done;
    }

done:
    return hr;
}

HRESULT
CTIMEElementBase::SetSize(const RECT *prcPos)
{
    DAComPtr<IHTMLStyle> pStyle;
    DAComPtr<IHTMLElement2> pElem2;
    IHTMLElement *pElem = GetElement();

    HRESULT hr;
    long lLeft = 0;
    long lTop = 0;
    long lCurWidth = 0;
    long lCurHeight = 0;
    long lClientWidth = 0;
    long lClientHeight = 0;
    int i = 0;

    if (prcPos == NULL)
    {
        hr = E_POINTER;
        goto done;
    }

    if (pElem == NULL)
    {
        hr = E_UNEXPECTED;
        goto done;
    }

    // negative size is unexpected
    Assert((prcPos->right - prcPos->left) >= 0);
    Assert((prcPos->bottom - prcPos->top) >= 0);

    // if width or height is zero or less, bail
    if ( ((prcPos->right - prcPos->left) <= 0) ||
         ((prcPos->bottom - prcPos->top) <= 0) )
    {
        hr = ClearSize();
        goto done;
    }

    hr = THR(GetElement()->QueryInterface(IID_TO_PPV(IHTMLElement2, &pElem2)));
    if (FAILED(hr))
    {
        goto done;
    }

    hr = THR(pElem2->get_runtimeStyle(&pStyle));
    if (FAILED(hr))
    {
        goto done;
    }

    // get offset into document.
    hr = THR(pElem->get_offsetLeft(&lLeft));
    if (FAILED(hr))
        goto done;

    hr = THR(pElem->get_offsetTop(&lTop));
    if (FAILED(hr))
        goto done;

    Assert(pStyle);


    lClientWidth = prcPos->right - prcPos->left;
    lClientHeight = prcPos->bottom - prcPos->top;

    // Request increasingly larger total size (pixel width) until we get the correct client size.
    // This iterative solution is to avoid having to parse the border size etc. (strings sith dimensions)
    // that Trident returns.
    i = 0;
    while (((lCurWidth != lClientWidth) ||
           (lCurHeight != lClientHeight)) &&
           i < 5)   // the i < 5 condition limits the loop to 5 times through
                    // this causes the case of bordersize > 5 * the size of the element
                    // to fail.  In this case the default will be to ignore the border and
                    // simply set the size.
    {
        // if we got more than what we requested in the last iteration, might have infinite loop
        Assert((lCurWidth <= lClientWidth) && (lCurHeight <= lClientHeight));

        i++;
        if (lCurWidth == 0)
        {
            lCurWidth = lClientWidth * i; //increase in mutiples in case the first size is not larger than the border width
        }
        else if (lCurWidth != lClientWidth)  // != 0 and != Requested width
        {
            lCurWidth =  lClientWidth * (i - 1) + (lClientWidth - lCurWidth);
        }
        if (lCurHeight == 0)
        {
            lCurHeight = lClientHeight * i; //increase in mutiples incase the first size is not larger than the border width
        }
        else if (lCurHeight != lClientHeight)  // != 0 and != Requested width
        {
            lCurHeight =  lClientHeight * (i - 1) + (lClientHeight - lCurHeight);
        }

        // Set the total size (client size + borders etc.)
        hr = THR(pStyle->put_pixelWidth(lCurWidth));
        if (FAILED(hr))
            goto done;

        hr = THR(pStyle->put_pixelHeight(lCurHeight));
        if (FAILED(hr))
            goto done;

        //get the current client size
        hr = THR(pElem2->get_clientWidth(&lCurWidth));
        if (FAILED(hr))
        {
            goto done;
        }

        hr = THR(pElem2->get_clientHeight(&lCurHeight));
        if (FAILED(hr))
        {
            goto done;
        }
    } // while

    if (((lCurWidth != lClientWidth) ||
           (lCurHeight != lClientHeight)) &&
           (i == 5))  // if the max count has been reached, then simply set the element
    {                 // size to the requested size without trying to compensate for a border.
        hr = THR(pStyle->put_pixelWidth(lClientWidth));
        if (FAILED(hr))
            goto done;

        hr = THR(pStyle->put_pixelHeight(lClientHeight));
        if (FAILED(hr))
            goto done;
    }

    hr = S_OK;

done:
    TraceTag((tagTimeElmBase, "CTIMEElementBase::SetSize(%d, %d, %d, %d) [pos(%d, %d)]", prcPos->left, prcPos->top, prcPos->right, prcPos->bottom, lLeft, lTop));
    return hr;
} // SetSize

//*****************************************************************************

HRESULT
CTIMEElementBase::BuildPropertyNameList (CPtrAry<BSTR> *paryPropNames)
{
    HRESULT hr = S_OK;

    Assert(NULL != paryPropNames);

    for (int i = 0; (i < teb_maxTIMEElementBaseProp) && (SUCCEEDED(hr)); i++)
    {
        Assert(NULL != ms_rgwszTEBasePropNames[i]);
        BSTR bstrNewName = CreateTIMEAttrName(ms_rgwszTEBasePropNames[i]);
        Assert(NULL != bstrNewName);
        if (NULL != bstrNewName)
        {
            hr = paryPropNames->Append(bstrNewName);
        }
        else
        {
            hr = E_OUTOFMEMORY;
        }
    }

    return hr;
}

//*****************************************************************************

HRESULT
CTIMEElementBase::SetPropertyByIndex(unsigned uIndex, VARIANT *pvarProp)
{
    Assert(NULL != pvarProp);

    HRESULT hr = E_FAIL;
    // copy variant for conversion type
    VARIANT varTemp;
    VariantInit(&varTemp);
    hr = VariantCopyInd(&varTemp, pvarProp);
    if (FAILED(hr))
        return hr;

    Assert(teb_maxTIMEElementBaseProp > uIndex);
    if (teb_maxTIMEElementBaseProp > uIndex)
    {
        switch (uIndex)
        {
          case teb_begin :
            hr = base_put_begin(*pvarProp);
            break;
          case teb_beginWith :
            hr = base_put_beginWith(*pvarProp);
            break;
          case teb_beginAfter :
            hr = base_put_beginAfter(*pvarProp);
            break;
          case teb_beginEvent :
            hr = base_put_beginEvent(*pvarProp);
            break;
          case teb_dur :
            hr = base_put_dur(*pvarProp);
            break;
          case teb_end :
            hr = base_put_end(*pvarProp);
            break;
          case teb_endWith :
            hr = base_put_endWith(*pvarProp);
            break;
          case teb_endEvent :
            hr = base_put_endEvent(*pvarProp);
            break;
          case teb_endSync :
            hr = base_put_endSync(*pvarProp);
            break;
          case teb_endHold :
            hr = VariantChangeTypeEx(&varTemp, &varTemp, LCID_SCRIPTING, NULL, VT_BOOL);
            if (SUCCEEDED(hr))
                hr = base_put_endHold(V_BOOL(&varTemp));
            break;
          case teb_eventRestart :
            hr = VariantChangeTypeEx(&varTemp, &varTemp, LCID_SCRIPTING, NULL, VT_BOOL);
            if (SUCCEEDED(hr))
                hr = base_put_eventRestart(V_BOOL(&varTemp));
            break;
          case teb_repeat :
            hr = base_put_repeat(*pvarProp);
            break;
          case teb_repeatDur :
            hr = base_put_repeatDur(*pvarProp);
            break;
          case teb_autoReverse :
            hr = VariantChangeTypeEx(&varTemp, &varTemp, LCID_SCRIPTING, NULL, VT_BOOL);
            if (SUCCEEDED(hr))
                hr = base_put_autoReverse(V_BOOL(&varTemp));
            break;
          case teb_accelerate :
            hr = VariantChangeTypeEx(&varTemp, &varTemp, LCID_SCRIPTING, VARIANT_NOUSEROVERRIDE, VT_INT);
            if (SUCCEEDED(hr))
                hr = base_put_accelerate(V_INT(&varTemp));
            break;
          case teb_decelerate :
            hr = VariantChangeTypeEx(&varTemp, &varTemp, LCID_SCRIPTING, VARIANT_NOUSEROVERRIDE, VT_INT);
            if (SUCCEEDED(hr))
                hr = base_put_decelerate(V_INT(&varTemp));
            break;
          case teb_timeAction :
            hr = VariantChangeTypeEx(&varTemp, &varTemp, LCID_SCRIPTING, NULL, VT_BSTR);
            if (SUCCEEDED(hr))
                hr = base_put_timeAction(V_BSTR(&varTemp));
            break;
          case teb_timeline :
            hr = VariantChangeTypeEx(&varTemp, &varTemp, LCID_SCRIPTING, NULL, VT_BSTR);
            if (SUCCEEDED(hr))
                hr = base_put_timeline(V_BSTR(&varTemp));
            break;
          case teb_syncBehavior :
            hr = VariantChangeTypeEx(&varTemp, &varTemp, LCID_SCRIPTING, NULL, VT_BSTR);
            if (SUCCEEDED(hr))
                hr = base_put_syncBehavior(V_BSTR(&varTemp));
            break;
          case teb_syncTolerance :
            hr = base_put_syncTolerance(*pvarProp);
            break;
        };
    }
    else
    {
        hr = E_UNEXPECTED;
    }

    // Cleanup
    VariantClear(&varTemp);

    return hr;
}

//*****************************************************************************

HRESULT
CTIMEElementBase::InitTimeline (void)
{
    HRESULT hr = S_OK;

    if (!m_fTimelineInitialized)
    {
        if (IsGroup())
        {
            m_timeline = NEW MMTimeline(*this, true);

            if (m_timeline == NULL)
            {
                hr = E_OUTOFMEMORY;
                goto done;
            }

            // Immediately assign to m_mmbvr so we ensure that we clean it
            // up on destruction since the m_timeline is ignored
            m_mmbvr = m_timeline;

            if (!m_timeline->Init())
            {
                hr = CRGetLastError();
                goto done;
            }

        }
        else
        {
            MMBvr * b;
            b = NEW MMBvr(*this, true, NeedSyncCB());

            if (b == NULL)
            {
                hr = E_OUTOFMEMORY;
                goto done;
            }

            // Immediately assign to m_mmbvr so we ensure that we clean it
            // up on destruction
            m_mmbvr = b;

            if (!b->Init((CRBvrPtr) CRLocalTime()))
            {
                hr = CRGetLastError();
                goto done;
            }
        }
        m_fTimelineInitialized = true;
    }

    // if we are not the body, have a cached body element pointer, and it is started (i.e. StartRootTimte)
    // then we should start ourselves and do not wait for notification.
    if (!IsBody() && (GetBody() != NULL) && GetBody()->IsRootStarted())
    {
        // being extra careful.  If we have a body cached, we know we are parented and that we can reach
        // back.
        if (GetParent() != NULL)
        {
            HRESULT hr = THR(StartRootTime(GetParent()->GetMMTimeline()));
            if (FAILED(hr))
            {
                TraceTag((tagError, "CTIMEBodyElement::InitTimeline - StartRootTime() failed!"));
                goto done;
            }
        }
    }

done :
    return hr;
}


//IPersistPropertyBag2 methods
STDMETHODIMP
CTIMEElementBase::Load(IPropertyBag2 *pPropBag,IErrorLog *pErrorLog)
{
    if (NULL == pPropBag)
    {
        return E_INVALIDARG;
    }

    CPtrAry<BSTR> *paryPropNames = NULL;
    HRESULT hr = GetPropertyBagInfo(&paryPropNames);

    if (hr == E_NOTIMPL)
    {
        return S_OK;
    }
    else if (FAILED(hr))
    {
        return hr;
    }

    // Unfortunately Load takes an array of Variants and not
    // Variant pointers.  We therefor need to loop through
    // each one and get the correct property this way.
    unsigned uNumProps = static_cast<unsigned>(paryPropNames->Size());
    for (unsigned uProperties = 0; uProperties < uNumProps; uProperties++)
    {
        HRESULT hrres = S_OK;
        PROPBAG2 propbag;
        VARIANT var;
        VariantInit(&var);
        propbag.vt = VT_BSTR;
        propbag.pstrName = (*paryPropNames)[uProperties];
        hr = pPropBag->Read(1,
                            &propbag,
                            pErrorLog,
                            &var,
                            &hrres);
        if (SUCCEEDED(hr))
        {
            // Skip over failures ... why would we want to
            // allow that to abort all persistance?
            hr = SetPropertyByIndex(uProperties, &var);
            VariantClear(&var);
        }
    }


    // Once we've read the properties in,
    // set up the timeline.  This is immutable
    // in script.
    hr = InitTimeline();

    // We return error codes not specific to properties
    // by early-outing.
    return S_OK;
} // Load

//*****************************************************************************

HRESULT
CTIMEElementBase::GetPropertyByIndex(unsigned uIndex, VARIANT *pvarProp)
{
    HRESULT hr = E_FAIL;

    Assert(teb_maxTIMEElementBaseProp > uIndex);
    Assert(VT_EMPTY == V_VT(pvarProp));
    if (teb_maxTIMEElementBaseProp > uIndex)
    {
        switch (uIndex)
        {
            case teb_begin :
                hr = base_get_begin(pvarProp);
                break;
            case teb_beginWith :
                hr = base_get_beginWith(pvarProp);
                break;
            case teb_beginAfter :
                hr = base_get_beginAfter(pvarProp);
                break;
            case teb_beginEvent :
                hr = base_get_beginEvent(pvarProp);
                break;
            case teb_dur :
                hr = base_get_dur(pvarProp);
                break;
            case teb_end :
                hr = base_get_end(pvarProp);
                break;
            case teb_endWith :
                hr = base_get_endWith(pvarProp);
                break;
            case teb_endEvent :
                hr = base_get_endEvent(pvarProp);
                break;
            case teb_endSync :
                hr = base_get_endSync(pvarProp);
                break;
            case teb_endHold :
                hr = base_get_endHold(&(V_BOOL(pvarProp)));
                if (SUCCEEDED(hr))
                {
                    V_VT(pvarProp) = VT_BOOL;
                }
                break;
            case teb_eventRestart :
                hr = base_get_eventRestart(&(V_BOOL(pvarProp)));
                if (SUCCEEDED(hr))
                {
                    V_VT(pvarProp) = VT_BOOL;
                }
                break;
            case teb_repeat :
                hr = base_get_repeat(pvarProp);
                break;
            case teb_repeatDur :
                hr = base_get_repeatDur(pvarProp);
                break;
            case teb_autoReverse :
                hr = base_get_autoReverse(&(V_BOOL(pvarProp)));
                if (SUCCEEDED(hr))
                {
                    V_VT(pvarProp) = VT_BOOL;
                }
                break;
            case teb_accelerate :
                hr = base_get_accelerate(&(V_INT(pvarProp)));
                if (SUCCEEDED(hr))
                {
                    V_VT(pvarProp) = VT_INT;
                }
                break;
            case teb_decelerate :
                hr = base_get_decelerate(&(V_INT(pvarProp)));
                if (SUCCEEDED(hr))
                {
                    V_VT(pvarProp) = VT_INT;
                }
                break;
            case teb_timeAction :
                hr = base_get_timeAction(&(V_BSTR(pvarProp)));
                if (SUCCEEDED(hr) && (NULL != V_BSTR(pvarProp)))
                {
                    V_VT(pvarProp) = VT_BSTR;
                }
                break;
            case teb_timeline :
                hr = base_get_timeline(&(V_BSTR(pvarProp)));
                if (SUCCEEDED(hr))
                {
                    V_VT(pvarProp) = VT_BSTR;
                }
                break;
            case teb_syncBehavior :
                if (INVALID_TOKEN != m_syncBehavior)
                {
                    hr = base_get_syncBehavior(&(V_BSTR(pvarProp)));
                    if (SUCCEEDED(hr) && (NULL != V_BSTR(pvarProp)))
                    {
                        V_VT(pvarProp) = VT_BSTR;
                    }
                }
                else
                {
                    // Unset property, but not an error.
                    // The pvarProp remains empty and
                    // nothing gets persisted.
                    hr = S_OK;
                }
                break;
            case teb_syncTolerance :
                if (valueNotSet != m_syncTolerance)
                {
                    hr = base_get_syncTolerance(pvarProp);
                }
                else
                {
                    // Unset property, but not an error.
                    // The pvarProp remains empty and
                    // nothing gets persisted.
                    hr = S_OK;
                }
                break;
        };
    }
    else
    {
        hr = E_UNEXPECTED;
    }

    // No need to propogate a NULL string back.  A number of our
    // get methods return NULL strings.
    if ((VT_BSTR == V_VT(pvarProp)) && (NULL == V_BSTR(pvarProp)))
    {
        hr = VariantClear(pvarProp);
    }

    return hr;
}

void CTIMEElementBase::SetPropertyFlag(DWORD uIndex)
{
    DWORD bitPosition = 1 << uIndex;
    m_propertyAccesFlags =  m_propertyAccesFlags | bitPosition;
}

void CTIMEElementBase::ClearPropertyFlag(DWORD uIndex)
{
    DWORD bitPosition = 1 << uIndex;
    m_propertyAccesFlags =  m_propertyAccesFlags & (~bitPosition);
}


void CTIMEElementBase::SetPropertyFlagAndNotify(DISPID dispid, DWORD uIndex)
{
    SetPropertyFlag(uIndex);
    IGNORE_HR(NotifyPropertyChanged(dispid));
}

void CTIMEElementBase::ClearPropertyFlagAndNotify(DISPID dispid, DWORD uIndex)
{
    ClearPropertyFlag(uIndex);
    IGNORE_HR(NotifyPropertyChanged(dispid));
}

bool CTIMEElementBase::IsPropertySet(DWORD uIndex)
{
    if( uIndex >= 32) return true;
    if( uIndex >= teb_maxTIMEElementBaseProp) return true;
    DWORD bitPosition = 1 << uIndex;
    if(m_propertyAccesFlags & bitPosition)
        return true;
    return false;
}


//*****************************************************************************

STDMETHODIMP
CTIMEElementBase::Save(IPropertyBag2 *pPropBag, BOOL fClearDirty, BOOL fSaveAllProperties)
{
    if (NULL == pPropBag)
    {
        return E_INVALIDARG;
    }

    if (fClearDirty)
    {
        m_fPropertiesDirty = false;
    }

    CPtrAry<BSTR> *paryPropNames = NULL;
    HRESULT hr = GetPropertyBagInfo(&paryPropNames);

    if (hr == E_NOTIMPL)
    {
        return S_OK;
    }
    else if (FAILED(hr))
    {
        return hr;
    }

    VARIANT var;
    VariantInit(&var);
    unsigned uNumProps = static_cast<unsigned>(paryPropNames->Size());
    for (unsigned uProperties = 0; uProperties < uNumProps; uProperties++)
    {
        PROPBAG2 propbag;

        Assert(NULL != (*paryPropNames)[uProperties]);
        if (NULL != (*paryPropNames)[uProperties])
        {
            propbag.vt = VT_BSTR;
            propbag.pstrName = (*paryPropNames)[uProperties];


            hr = GetPropertyByIndex(uProperties, &var);

            // Skip over failures ... why would we want to
            // allow that to abort all persistance?
            if ((SUCCEEDED(hr)) && (var.vt != VT_EMPTY) && (var.vt != VT_NULL))
            {
                if(IsPropertySet(uProperties))
                    hr = pPropBag->Write(1, &propbag, &var);
                VariantClear(&var);
            }
        }
    }

    // We return error codes not specific to properties
    // by early-outing.
    return S_OK;
} // Save

//*****************************************************************************

STDMETHODIMP
CTIMEElementBase::GetClassID(CLSID* pclsid)
{
    if (NULL != pclsid)
    {
        return E_POINTER;
    }
    *pclsid = m_clsid;
    return S_OK;
} // GetClassID

//*****************************************************************************

STDMETHODIMP
CTIMEElementBase::InitNew(void)
{
    return S_OK;
} // InitNew

//*****************************************************************************
// if elment doesn't exist in child list, make return -1.
int
CTIMEElementBase::GetTimeChildIndex(CTIMEElementBase *pelm)
{
    if (pelm == NULL)
        return -1;

    long lSize = m_pTIMEChildren.Size();
    for (long i=0; i < lSize; i++)
    {
        if (m_pTIMEChildren[i] == pelm)
             return i;
    }

    // didn't find it
    return -1;
} // GetTimeChildIndex

MMPlayer *
CTIMEElementBase::GetPlayer()
{
    if (m_pTIMEBody)
    {
        return &(m_pTIMEBody->GetPlayer());
    }
    else
    {
        return NULL;
    }
}

float
CTIMEElementBase::GetRealSyncTolerance()
{
    if (m_syncTolerance == valueNotSet)
    {
        return GetBody()->GetDefaultSyncTolerance();
    }
    else
    {
        return m_syncTolerance;
    }
}

TOKEN
CTIMEElementBase::GetRealSyncBehavior()
{
    if (GetParent() != NULL && GetParent()->IsSequence())
    {
        return LOCKED_TOKEN;
    }

    if (m_syncBehavior == INVALID_TOKEN)
    {
        return GetBody()->GetDefaultSyncBehavior();
    }
    else
    {
        return m_syncBehavior;
    }
}

HRESULT
CTIMEElementBase::NotifyPropertyChanged(DISPID dispid)
{
    HRESULT hr;

    IConnectionPoint *pICP;
    IEnumConnections *pEnum = NULL;

    m_fPropertiesDirty = true;
    hr = GetConnectionPoint(IID_IPropertyNotifySink,&pICP);
    if (SUCCEEDED(hr) && pICP != NULL)
    {
        hr = pICP->EnumConnections(&pEnum);
        ReleaseInterface(pICP);
        if (FAILED(hr))
        {
            //DPF_ERR("Error finding connection enumerator");
            //return SetErrorInfo(hr);
            TIMESetLastError(hr);
            goto done;
        }
        CONNECTDATA cdata;
        hr = pEnum->Next(1, &cdata, NULL);
        while (hr == S_OK)
        {
            // check cdata for the object we need
            IPropertyNotifySink *pNotify;
            hr = cdata.pUnk->QueryInterface(IID_TO_PPV(IPropertyNotifySink, &pNotify));
            cdata.pUnk->Release();
            if (FAILED(hr))
            {
                //DPF_ERR("Error invalid object found in connection enumeration");
                //return SetErrorInfo(hr);
                TIMESetLastError(hr);
                goto done;
            }
            hr = pNotify->OnChanged(dispid);
            ReleaseInterface(pNotify);
            if (FAILED(hr))
            {
                //DPF_ERR("Error calling Notify sink's on change");
                //return SetErrorInfo(hr);
                TIMESetLastError(hr);
                goto done;
            }
            // and get the next enumeration
            hr = pEnum->Next(1, &cdata, NULL);
        }
    }
done:
    if (NULL != pEnum)
    {
        ReleaseInterface(pEnum);
    }

    return hr;
} // NotifyPropertyChanged
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\time\src\util.cpp ===
/*******************************************************************************
 *
 * Copyright (c) 1998 Microsoft Corporation
 *
 * File: util.cpp
 *
 * Abstract:
 *
 *
 *
 *******************************************************************************/

#include "headers.h"
#include "util.h"
#define INITGUID
#include <initguid.h>  // needed for precomp headers...
#define IUSEDDRAW
#include <ddrawex.h>
#include "tokens.h"

//defined for VariantToTime conversion function
#define SECPERMINUTE 60   //seconds per minute
#define SECPERHOUR   3600 //seconds per hour

IDirectDraw * g_directdraw = NULL;
CritSect * g_ddCS = NULL;

IDirectDraw *
GetDirectDraw()
{
    HRESULT hr;
    
    {
        CritSectGrabber _csg(*g_ddCS);
        
        if (g_directdraw == NULL)
        {
            DAComPtr<IDirectDrawFactory> lpDDF;
            
            hr = CoCreateInstance(CLSID_DirectDrawFactory,
                                  NULL, CLSCTX_INPROC_SERVER,
                                  IID_IDirectDrawFactory,
                                  (void **) & lpDDF);

            if (FAILED(hr))
            {
                Assert(FALSE && "Could not create DirectDrawFactory object");
                return NULL;
            }
            
            hr = lpDDF->CreateDirectDraw(NULL, NULL, DDSCL_NORMAL, 0, NULL, &g_directdraw);

            if (FAILED(hr))
            {
                Assert(FALSE && "Could not create DirectDraw object");
                return NULL;
            }

            hr = g_directdraw->SetCooperativeLevel(NULL,
                                                   DDSCL_NORMAL);

            if (FAILED(hr))
            {
                Assert(FALSE && "Could not set DirectDraw properties");
                g_directdraw->Release();
                g_directdraw = NULL;
                return NULL;
            }

        }
    }

    return g_directdraw;
}

HRESULT
CreateOffscreenSurface(IDirectDraw *ddraw,
                       IDirectDrawSurface **surfPtrPtr,
                       DDPIXELFORMAT * pf,
                       bool vidmem,
                       LONG width, LONG height)
{
    HRESULT hr = S_OK;
    DDSURFACEDESC       ddsd;
    ZeroMemory(&ddsd, sizeof(ddsd));

    ddsd.dwSize = sizeof( ddsd );
    ddsd.dwFlags = DDSD_CAPS | DDSD_HEIGHT | DDSD_WIDTH;
    ddsd.dwWidth  = width;
    ddsd.dwHeight = height;

    if (pf)
    {
        // KEVIN: if you want the pixelformat of the surface tomatach the
        // screen, comment out this line.
        ddsd.dwFlags |= DDSD_PIXELFORMAT;
        
        ddsd.ddpfPixelFormat = *pf;
    }

    // DX3 bug workaround (bug 11166): StretchBlt doesn't always work
    // for hdc's we get from ddraw surfaces.  Need to specify OWNDC
    // in order for it to work.
    ddsd.ddsCaps.dwCaps =
        (DDSCAPS_3DDEVICE |
         DDSCAPS_OFFSCREENPLAIN |
         (vidmem ? DDSCAPS_VIDEOMEMORY : DDSCAPS_SYSTEMMEMORY | DDSCAPS_OWNDC));

    IDirectDraw * dd = ddraw;

    if (!dd)
    {
        dd = GetDirectDraw();
    
        if (!dd)
        {
            hr = E_FAIL;
            goto done;
        }
    }
    
    hr = dd->CreateSurface( &ddsd, surfPtrPtr, NULL );

    if (FAILED(hr))
    {
        *surfPtrPtr = NULL;
    }

  done:
    return hr;
}

inline Width(LPRECT r) { return r->right - r->left; }
inline Height(LPRECT r) { return r->bottom - r->top; }

HRESULT
CopyDCToDdrawSurface(HDC srcDC,
                     LPRECT prcSrcRect,
                     IDirectDrawSurface *DDSurf,
                     LPRECT prcDestRect)
{
    HRESULT hr;
    
    HDC destDC;
    hr = DDSurf->GetDC(&destDC);
    
    if (SUCCEEDED(hr))
    {
        HRGN hrgn;

        hrgn = CreateRectRgn(0,0,1,1);
        
        if (hrgn == NULL)
        {
            hr = GetLastError();
        }
        else
        {
            if (GetClipRgn(srcDC, hrgn) == ERROR)
            {
                hr = GetLastError();
            } 
            else
            {
                TraceTag((tagError,
                          "CopyDCToDdrawSurface - prcDestRect(%d, %d, %d, %d)",
                          prcDestRect->left,prcDestRect->top,prcDestRect->right,prcDestRect->bottom));

                RECT targetRect;
                RECT rgnRect;

                GetRgnBox(hrgn, &rgnRect);
                
                TraceTag((tagError,
                          "CopyDCToDdrawSurface - rgn box(%d, %d, %d, %d)",
                          rgnRect.left,rgnRect.top,rgnRect.right,rgnRect.bottom));
                
                if (IntersectRect(&targetRect, &rgnRect, prcDestRect))
                {
                    TraceTag((tagError,
                              "CopyDCToDdrawSurface - targetrect(%d, %d, %d, %d)",
                              targetRect.left,targetRect.top,targetRect.right,targetRect.bottom));
                
                    if (false && SelectClipRgn(destDC, hrgn) == ERROR)
                    {
                        hr = GetLastError();
                    }
                    else
                    {
                        BitBlt(destDC,
                               prcDestRect->left,
                               prcDestRect->top,
                               Width(prcDestRect),
                               Height(prcDestRect),
                               
                               srcDC,
                               prcSrcRect->left,
                               prcSrcRect->top,
                               SRCCOPY);
                        
                        //SelectClipRgn(destDC, NULL);
                    }
                }
            }
            
            DeleteObject(hrgn);
        }

        DDSurf->ReleaseDC(destDC);
    }

    return hr;
}

//////////////////////

CritSect::CritSect()
{
    InitializeCriticalSection(&_cs) ;
}

CritSect::~CritSect()
{
    DeleteCriticalSection(&_cs) ;
}

void
CritSect::Grab()
{
    EnterCriticalSection(&_cs) ;
}

void
CritSect::Release()
{
    LeaveCriticalSection(&_cs) ;
}

////// CritSect Grabber //////

CritSectGrabber::CritSectGrabber(CritSect& cs, bool grabIt)
: _cs(cs), grabbed(grabIt)
{
    if (grabIt) _cs.Grab();
}

CritSectGrabber::~CritSectGrabber()
{
    if (grabbed) _cs.Release();
}

//// Misc ///

bool
CRBvrToVARIANT(CRBvrPtr b, VARIANT * v)
{
    bool ok = false;
    
    if (v == NULL)
    {
        CRSetLastError(E_POINTER, NULL);
        goto done;
    }
    
    IUnknown * iunk;
    
    if (!CRBvrToCOM(b,
                    IID_IUnknown,
                    (void **) &iunk))
    {
        TraceTag((tagError,
                  "CRBvrToVARIANT: Failed to get create com pointer - %hr, %ls",
                  CRGetLastError(),
                  CRGetLastErrorString()));
            
        goto done;
    }
    
    V_VT(v) = VT_UNKNOWN;
    V_UNKNOWN(v) = iunk;

    ok = true;
  done:
    return ok;
}

CRBvrPtr
VARIANTToCRBvr(VARIANT var, CR_BVR_TYPEID tid)
{
    CRBvrPtr ret = NULL;
    HRESULT hr;
    CComVariant v;

    hr = v.ChangeType(VT_UNKNOWN, &var);

    if (FAILED(hr))
    {
        CRSetLastError(hr, NULL);
        goto done;
    }
    
    CRBvrPtr bvr;

    bvr = COMToCRBvr(V_UNKNOWN(&v));

    if (bvr == NULL)
    {
        goto done;
    }
    
    if (tid != CRINVALID_TYPEID &&
        CRGetTypeId(bvr) != tid)
    {
        CRSetLastError(DISP_E_TYPEMISMATCH, NULL);
        goto done;
    }
    
    ret = bvr;
    
  done:
    return ret;
}

const wchar_t * TIMEAttrPrefix = L"t:";

BSTR
CreateTIMEAttrName(LPCWSTR str)
{
    BSTR bstr = NULL;

    LPWSTR newstr = (LPWSTR) _alloca(sizeof(wchar_t) *
                                     (lstrlenW(str) +
                                      lstrlenW(TIMEAttrPrefix) +
                                      1));

    if (newstr == NULL)
    {
        goto done;
    }
    
    StrCpyW(newstr, TIMEAttrPrefix);
    StrCatW(newstr, str);

    bstr = SysAllocString(newstr);

  done:
    return bstr;
}

HRESULT
GetTIMEAttribute(IHTMLElement * elm,
                 LPCWSTR str,
                 LONG lFlags,
                 VARIANT * value)
{
    BSTR bstr;
    HRESULT hr;

    bstr = CreateTIMEAttrName(str);

    // Need to free bstr
    if (bstr == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto done;
    }
    
    hr = THR(elm->getAttribute(bstr,lFlags,value));
    
    SysFreeString(bstr);
    
  done:
    return hr;
}

HRESULT
SetTIMEAttribute(IHTMLElement * elm,
                 LPCWSTR str,
                 VARIANT value,
                 LONG lFlags)
{
    BSTR bstr;
    HRESULT hr;

    bstr = CreateTIMEAttrName(str);

    // Need to free bstr
    if (bstr == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto done;
    }
    
    hr = THR(elm->setAttribute(bstr,value,lFlags));
    
    SysFreeString(bstr);
    
  done:
    return hr;
}

//
// Initialization
//

bool
InitializeModule_Util()
{
    g_ddCS = new CritSect;

    if (g_ddCS == NULL)
    {
        return false;
    }
    
    return true;
}

void
DeinitializeModule_Util(bool bShutdown)
{
    delete g_ddCS;
    g_ddCS = NULL;
}


///////////////////////////////////////////////////////////
// Name: VariantToBool
//
// Parameters:   VARIANT var      - a variant to convert to a 
//                                  BOOL value.
//
// Abstract:
//    This function coverts any VARIANT to a boolean value using
//    TRUE = 1 and FALSE = 0.  (COM uses TRUE = -1 and FALSE = 0).
//    Any VARIANT that can be coerced to a BOOL is and the coerced
//    value is returned.  If the VARIANT cannot be coerced, FALSE
//    is returned.
///////////////////////////////////////////////////////////
bool VariantToBool(VARIANT var)
{
    //if the value is already a bool return it.
    if (var.vt == VT_BOOL)
    {
        return var.boolVal == FALSE ? false : true;
    }
    else  //otherwise convert it to VT_BOOL
    {
        VARIANT vTemp;
        HRESULT hr;
        
        VariantInit(&vTemp);
        hr = VariantChangeTypeEx(&vTemp, &var, LCID_SCRIPTING, 0, VT_BOOL);
        if (SUCCEEDED(hr)) //if it can be converted return it
        {
            return vTemp.boolVal == FALSE ? false : true;
        }
        else //if it can't be converted return false
        {
            return false;
        }
    }

}


///////////////////////////////////////////////////////////
// Name: VariantToFloat
//
// Parameters:   VARIANT var      - a variant to convert to a 
//                                  float value.  This can contain
//                                  the special cases 'FOREVER' and
//                                  'INDEFINITE'.
//
// Abstract:
//
///////////////////////////////////////////////////////////
float VariantToFloat(VARIANT var, bool bAllowIndefinite, bool bAllowForever)
{
    float fResult = INVALID;

    if (var.vt == VT_R4)
    {
        fResult = var.fltVal;
        goto done;
    }

    VARIANT vTemp;
    HRESULT hr;

    VariantInit(&vTemp);
    hr = VariantChangeTypeEx(&vTemp, &var, LCID_SCRIPTING, VARIANT_NOUSEROVERRIDE, VT_R4);
    if (SUCCEEDED(hr)) 
    {
        fResult = vTemp.fltVal;
        goto done;
    }

    //Check to see if it is 'FOREVER' and 'INDEFINITE
    //Should these be case sensitive?
    if (bAllowForever == TRUE)
    {
        if (var.vt == VT_BSTR)
        {
            if (StrCmpIW(var.bstrVal, L"FOREVER") == 0)
            {
                fResult = FOREVER;
                goto done;
            }
        }
    }
    if (bAllowIndefinite == TRUE)
    {
        if (var.vt == VT_BSTR)
        {
            if (StrCmpIW(var.bstrVal, WZ_INDEFINITE) == 0)
            {
                fResult = INDEFINITE;
                goto done;
            }
        }
    }

  done:
    return fResult;

}

///////////////////////////////////////////////////////////
// Name: VariantToTime
//
// Parameters:   VARIANT var      - a VARIANT to convert to a 
//                                  from a time value to seconds.\
//                                    this can take the form of
//                                    HH:MM:SS.DD
//                                    MM:SS.DD
//                                    SS.DD
//                                    DD.DDs
//                                    DD.DDm
//                                    DD.DDh
//                                    and may be preceeded by a + or -
//                                    
//                                    
// 
// Abstract:
//    Converts the incoming variant to a BSTR and parses for valid
//    clock values.  It passes the value back in retVal and returns
//    S_OK or E_INVALIDARG in the case of incorrect input. If the
//    return value is E_INVALIDARG, *retVal is passed back as
//    INDEFINITE.
///////////////////////////////////////////////////////////
HRESULT VariantToTime(VARIANT var, float *retVal)
{    

    HRESULT hr = S_OK;
    OLECHAR *szTime;
    bool bPositive = TRUE;
    int nHour = 0;
    int nMin = 0;
    int nSec = 0;
    float fFSec = 0;
    VARIANT vTemp;

    //convert the parameter to a BSTR
    VariantInit(&vTemp);
    if (var.vt != VT_BSTR)
    {
        hr = VariantChangeTypeEx(&vTemp, &var, LCID_SCRIPTING, VARIANT_NOUSEROVERRIDE, VT_BSTR);
        if (FAILED(hr))
        {
            *retVal = INVALID;
            goto done;
        }
    }
    else
    {
        hr = VariantCopy(&vTemp, &var);
        if (FAILED(hr))
        {
            *retVal = INVALID;
            goto done;
        }
    }

    hr = S_OK;

    //convert to a char array. If not possible, return error.
    szTime = vTemp.bstrVal;
    
    if (IsIndefinite(szTime))
    {
        *retVal = INDEFINITE;
        goto done;
    }

    //remove leading whitespace
    while (*szTime == ' ')
    {
        szTime++;
    }
    //check for +/- if none, assume +
    if (*szTime == '-')
    {
        bPositive = false;
        szTime++;
    }
    else if (*szTime == '+')
    {
        szTime++;
    }

    //check for invalid and err out
    if (*szTime == '\0')
    {
        *retVal = INVALID;
        goto done;
    }

    //get first set of numbers
    while (*szTime >= '0' && *szTime <= '9')
    {
        nSec = nSec * 10 + (*szTime - '0');
        szTime++;
    }
    if (*szTime == '\0')    //if none use time as seconds
    {
        *retVal = nSec * (bPositive ? 1 : -1); //this is the end so return;
        goto done;
    }
    else if (*szTime == '.')  //if it is a '.' treat this as the fractional part
    {
        float nDiv = 10.0;
        szTime++;
        while (*szTime >= '0' && *szTime <= '9')
        {
            fFSec = fFSec + (*szTime - '0') / nDiv;
            szTime++;
            nDiv *= 10;
        }        
        if (*szTime == '\0')
        {
            *retVal = (nSec + fFSec) * (bPositive? 1 : -1);
            goto done;
        }
    }
    
    if (*szTime == 'h') //if "h" use time as hours
    {
        nHour = nSec;
        nSec = 0;
        szTime++;
        if (*szTime != '\0') 
        {
            *retVal = INVALID;
        }
        else
        {
            *retVal = (((float)nHour + fFSec) * SECPERHOUR) * (bPositive? 1 : -1);
        }
        goto done;
    }
    else if (*szTime == 'm' && *(szTime + 1) == 'i' && *(szTime + 2) == 'n') //if "min" use time as minutes
    {
        nMin = nSec;
        nSec = 0;
        szTime += 3;
        if (*szTime != '\0') 
        {
            *retVal = INVALID;
        }
        else
        {
            *retVal = (((float)nMin + fFSec) * SECPERMINUTE)* (bPositive? 1 : -1); 
        }
        goto done;
    }
    else if (*szTime == 's') //if "s" use time as seconds
    {
        szTime++;
        if (*szTime != '\0')
        {
            *retVal = INVALID;
        }
        else
        {
            *retVal = (nSec + fFSec) * (bPositive? 1 : -1); 
        }
        goto done;
    }
    else if (*szTime == 'm' && *(szTime + 1) == 's') //if "ms" use time as milliseconds
    {
        fFSec = (fFSec + nSec) / 1000.0;
        szTime += 2;
        if (*szTime != '\0') 
        {
            *retVal = INVALID;
        }
        else
        {
            *retVal = fFSec * (bPositive? 1 : -1); //convert minutes to seconds
        }
        goto done;
    }
    else if (*szTime == ':' && fFSec == 0)
    {
        //handle the HH:MM:SS format here
        nMin = nSec;
        nSec = 0;
        
        //next part must be 2 digits
        szTime++;
        if (*szTime >= '0' && *szTime <= '9')
        {
            nSec = *szTime - '0';
        }
        else 
        {
            *retVal = INVALID;
            goto done;
        }
        szTime++;
        if (*szTime >= '0' && *szTime <= '9')
        {
            nSec = nSec * 10 + (*szTime - '0');
        }
        else 
        {
            *retVal = INVALID;
            goto done;
        }
        szTime++;
        if (*szTime == ':')
        {
            nHour = nMin;
            nMin = nSec;
            nSec = 0;
            //next part must be 2 digits
            szTime++;
            if (*szTime >= '0' && *szTime <= '9')
            {
                nSec = *szTime - '0';
            }
            else 
            {
                *retVal = INVALID;
                goto done;
            }
            szTime++;
            if (*szTime >= '0' && *szTime <= '9')
            {
                nSec = nSec * 10 + (*szTime - '0');
            }
            else 
            {
                *retVal = INVALID;
                goto done;
            }
            szTime++;
        }
        
        if (*szTime == '.') 
        {
            //handle fractional part
            float nDiv = 10.0;
            szTime++;
            while ((*szTime >= '0') && (*szTime <= '9'))
            {
                fFSec = fFSec + ((*szTime - '0') / nDiv);
                szTime++;
                nDiv *= 10;
            }
        }
        
        //check to be sure the string terminated
        if (*szTime != '\0')
        {
            *retVal = INVALID;
            goto done;
        }
    
        if (nSec < 00 || nSec > 59 || nMin < 00 || nMin > 59)
        {
            *retVal = INVALID;
            goto done;
        }
        *retVal = (((float)(nHour * SECPERHOUR + nMin * SECPERMINUTE + nSec) + fFSec)) * (bPositive? 1 : -1);
    }
    else
    {
        *retVal = INVALID;
    }
  done:

    if (vTemp.vt == VT_BSTR)
    {
        VariantClear(&vTemp);
    }

    if (*retVal == INVALID)
    {
        *retVal = INDEFINITE;
        hr = E_INVALIDARG;
    }

    return hr;

}

///////////////////////////////////////
// Name: IsIndefinite
//
// Abstract:
//   Determines in a case-insensitive manner
//   if the string szTime is 'INDEFINITE'.
///////////////////////////////////////
BOOL IsIndefinite(OLECHAR *szTime)
{
    BOOL bResult = FALSE;
    OLECHAR szTemp[11] = { 0 };
    
    for (int i = 0; i < 10; i++)
    {
        if (szTime[i] == '\0')
        {
            goto done;
        }
        szTemp[i] = towupper(szTime[i]);
    }

    if (szTime[10] != '\0')
    {
        goto done;
    }
 
    if (StrCmpIW(szTime, L"INDEFINITE") == 0)
    {
        bResult = TRUE;
    }

  done:
    return bResult;
}

HRESULT
CheckElementForBehaviorURN(IHTMLElement *pElement,
                           WCHAR *wzURN,
                           bool *pfReturn)
{
    Assert(pElement != NULL);
    Assert(wzURN != NULL);
    Assert(pfReturn != NULL);

    *pfReturn = false;
    HRESULT hr;
    IHTMLElement2 *pElement2;
    hr = pElement->QueryInterface(IID_TO_PPV(IHTMLElement2, &pElement2));
    if (SUCCEEDED(hr) && pElement2 != NULL)
    {
        // get a collection of urns from the element
        IDispatch *pDisp;
        hr = pElement2->get_behaviorUrns(&pDisp);
        ReleaseInterface(pElement2);
        if (FAILED(hr))
        {
            return hr;
        }
        IHTMLUrnCollection *pUrnCollection;
        hr = pDisp->QueryInterface(IID_TO_PPV(IHTMLUrnCollection, &pUrnCollection));
        ReleaseInterface(pDisp);
        if (FAILED(hr))
        {
            return hr;
        }
        long cUrns;
        hr = pUrnCollection->get_length(&cUrns);
        if (FAILED(hr))
        {
            ReleaseInterface(pUrnCollection);
            return hr;
        }
        for (long iUrns = 0; iUrns < cUrns; iUrns++)
        {
            // get the urn from the collection
            BSTR bstrUrn;
            hr = pUrnCollection->item(iUrns, &bstrUrn);
            if (FAILED(hr))
            {
                ReleaseInterface(pUrnCollection);
                return hr;
            }
            // now compare this urn with our behavior type
            if (bstrUrn != NULL && StrCmpIW(bstrUrn, wzURN) == 0)
            {
                // we have a match. . .get out of here 
                SysFreeString(bstrUrn);
                ReleaseInterface(pUrnCollection);
                *pfReturn = true;
                return S_OK;

            }
            if (bstrUrn != NULL)
                SysFreeString(bstrUrn);
        }
        ReleaseInterface(pUrnCollection);
    }
    return S_OK;
} // CheckElementForBehaviorURN



HRESULT 
AddBodyBehavior(IHTMLElement* pBaseElement)
{
    HRESULT hr = S_OK;

    DAComPtr<IHTMLElement2>     pElement2;
    DAComPtr<ITIMEFactory>      pTimeFactory;
    long nCookie;

    VARIANT varTIMEFactory;

    hr = THR(GetBodyElement(pBaseElement,
                            IID_IHTMLElement2,
                            (void **) &pElement2));
    if (FAILED(hr))
    {
        goto done;
    }

    {
        DAComPtr<IHTMLElement>      pElement;

        // Trident doesn't believe in inheritance:
        hr = THR(pElement2->QueryInterface(IID_IHTMLElement, (void **)&pElement));
        if (FAILED(hr))
        {
            goto done;
        }
        
        if (IsTIMEBodyElement(pElement))
        {
            // someone's already put a TIMEBody behavior on the time body.  bail out.
            goto done;
        }
    }

    hr = THR(CoCreateInstance(CLSID_TIMEFactory,
                              NULL,
                              CLSCTX_INPROC_SERVER,
                              IID_ITIMEFactory,
                              (void**)&pTimeFactory));
    if (FAILED(hr))
    {
        goto done;
    }

    VariantInit(&varTIMEFactory);
    varTIMEFactory.vt = VT_UNKNOWN;
    varTIMEFactory.punkVal = (IUnknown*)pTimeFactory;

    hr = THR(pElement2->addBehavior(WZ_OBFUSCATED_TIMEBODY_URN, &varTIMEFactory, &nCookie));
    if (FAILED(hr))
    {
        goto done;
    }

    // pass thru:
  done:
    return hr;
}


bool
IsBodyElement(IHTMLElement* pElement)
{
    HRESULT hr = S_OK;
    bool rc = false;

    Assert(pElement);

    DAComPtr<IHTMLElement>      pBodyElement;

    hr = pElement->QueryInterface(IID_IHTMLBodyElement, (void**)&pBodyElement);
    if (FAILED(hr))
    {
        // not really an error, per se.
        goto done;
    }

    Assert(pBodyElement);       // The HTML document may (incorrectly) succeed and return NULL during early load

    // yup, they're a BODY element
    rc = true;

// pass thru:
  done:

    return rc;
}

HRESULT 
GetBodyElement(IHTMLElement* pElem, REFIID riid, void** ppBE)
{
    HRESULT hr = S_OK;

    DAComPtr<IDispatch>         pBodyDispatch;
    DAComPtr<IHTMLDocument2>    pDocument2;
    DAComPtr<IHTMLElement>      pBodyElement;

    if (!pElem)
    {
        TraceTag((tagError, "CTIMEElement::GetBody -- GetElement() failed."));
        hr = E_FAIL;
        goto done;
    }


    hr = THR(pElem->get_document(&pBodyDispatch));
    if (FAILED(hr))
    {
        goto done;
    }

    hr = THR(pBodyDispatch->QueryInterface(IID_IHTMLDocument2, (void**)&pDocument2));
    if (FAILED(hr))
    {
        goto done;
    }

    hr = THR(pDocument2->get_body(&pBodyElement));
    
    // We need to check the point aswell as the hr since we get lied to by Trident sometimes.
    if (FAILED(hr) || !pBodyElement)
    {
        hr = E_FAIL;
        goto done;
    }

    hr = THR(pBodyElement->QueryInterface(riid, ppBE));
    if (FAILED(hr))
    {
        goto done;
    }

    // pass thru:
  done:
    return hr;
}

bool
IsTIMEBodyElement(IHTMLElement *pElement)
{
    HRESULT hr;
    bool rc = false;
    DAComPtr<ITIMEElement> pTIMEElem;
    DAComPtr<ITIMEBodyElement> pTIMEBody;
    
    // find TIME interface on element.
    hr = FindTIMEInterface(pElement, &pTIMEElem);
    if (FAILED(hr))
    {
        goto done;
    }

    Assert(pTIMEElem.p != NULL);

    // QI for body.
    hr = pTIMEElem->QueryInterface(IID_ITIMEBodyElement, (void**)&pTIMEBody);
    if (FAILED(hr))
    {
        goto done;
    }
    
    Assert(pTIMEBody.p != NULL);
    rc = true;

done:
    return rc;
}

HRESULT
FindTIMEInterface(IHTMLElement *pHTMLElem, ITIMEElement **ppTIMEElem)
{
    HRESULT hr;
    DAComPtr<IDispatch> pDisp;

    if ( (pHTMLElem == NULL) || (ppTIMEElem == NULL) )
    {
        hr = E_POINTER;
        goto done;
    }

    *ppTIMEElem = NULL;


    // Get IDispatch for TIME behavior
    hr = FindTIMEBehavior(pHTMLElem, &pDisp);
    if (FAILED(hr))
    {
        goto done;
    }

    Assert(pDisp.p != NULL);

    // get ITIMEElement interface
    hr = THR(pDisp->QueryInterface(IID_ITIMEElement, (void**)ppTIMEElem));
    if (FAILED(hr))
    {
        goto done;
    }

    hr = S_OK;
        
done:
    return hr;
}

HRESULT
FindTIMEBehavior(IHTMLElement *pHTMLElem, IDispatch **ppDisp)
{
    DISPID  dispid;
    DISPPARAMS dispparams = { NULL, NULL, 0, 0 };
    WCHAR   *wzName = WZ_REGISTERED_NAME;
    VARIANT varResult;
    HRESULT hr;
   
    VariantInit(&varResult);

    if ( (pHTMLElem == NULL) || (ppDisp == NULL) )
    {
        hr = E_POINTER;
        goto done;
    }

    *ppDisp = NULL;

    // Call GetIDsOfNames on element named "HTMLTIME"
    // which we registered the behavior with.
    hr = pHTMLElem->GetIDsOfNames(IID_NULL, &wzName, 1, LCID_SCRIPTING, &dispid);
    if (FAILED(hr))
    {
        goto done;
    }

    hr = pHTMLElem->Invoke(dispid, 
                           IID_NULL, 
                           LCID_SCRIPTING, 
                           DISPATCH_PROPERTYGET,
                           &dispparams, 
                           &varResult, 
                           NULL, 
                           NULL);
    if (FAILED(hr))
    {
        goto done;
    }
    
    if ((varResult.vt != VT_DISPATCH) || (varResult.pdispVal == NULL))
    {
        hr = E_UNEXPECTED;
        goto done;
    }

    // although this looks odd, this assigns the IDispatch we found and
    // takes care of the addref.    
    hr = varResult.pdispVal->QueryInterface(IID_IDispatch, (void**)ppDisp);

done:
    VariantClear(&varResult);
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\time\src\tokens.h ===
/*******************************************************************************
 *
 * Copyright (c) 1998 Microsoft Corporation
 *
 * File: tokens.h
 *
 * Abstract:
 *
 *
 *
 *******************************************************************************/


#ifndef _TOKENS_H
#define _TOKENS_H

//
// Good place to put general string expansion macros that are not tokens:
//
#define WZ_PARENTTIMEELEMENT            L"ParentTIMEElement"
#define WZ_TIMELINE                     L"timeline"
#define WZ_PAR                          L"par"
#define WZ_SEQUENCE                     L"seq"
#define WZ_TIMESTARTRULE                L"timeStartRule"
#define WZ_ADDTIMEDAELEMENT             L"addTIMEDAElement"

#define WZ_LAST                         L"last"
#define WZ_FIRST                        L"first"
#define WZ_NONE                         L"none"
#define WZ_INDEFINITE                   L"indefinite"

#define WZ_MEDIA                        L"media"
#define WZ_IMG                          L"img"
#define WZ_AUDIO                        L"audio"
#define WZ_VIDEO                        L"video"
#define WZ_DA                           L"da"
#define WZ_BODY                         L"body"

#define WZ_DEFAULT_SCOPE_NAME           L"HTML"

#define WZ_TIME_STYLE_PREFIX            L"#time"
#define WZ_TIMEDA_STYLE_PREFIX          L"#time#"##WZ_DA
#define WZ_TIMEMEDIA_STYLE_PREFIX       L"#time#"##WZ_MEDIA

#define WZ_DEFAULT_TIME_STYLE_PREFIX        L"#default#time"
#define WZ_DEFAULT_TIMEDA_STYLE_PREFIX      L"#default#time#"##WZ_DA
#define WZ_DEFAULT_TIMEMEDIA_STYLE_PREFIX   L"#default#time#"##WZ_MEDIA

#define WZ_REGISTERED_NAME                  L"HTMLTIME"
#define WZ_REGISTERED_NAME_DAELM            L"HTMLTIMEDAELM"

#define WZ_EVENT_CAUSE_IS_RESTART           L"restart"

// This is to save on string storage space and to avoid unnecessary
// string comparisons

typedef void * TOKEN;

TOKEN StringToToken(wchar_t * str);
inline wchar_t * TokenToString(TOKEN token) { return (wchar_t *) token; }

extern TOKEN NONE_TOKEN;
extern TOKEN FILTER_TOKEN;
extern TOKEN REPLACE_TOKEN;
extern TOKEN INVALID_TOKEN;
extern TOKEN ONOFF_TOKEN;
extern TOKEN STYLE_TOKEN;
extern TOKEN DISPLAY_TOKEN;
extern TOKEN VISIBILITY_TOKEN;

extern TOKEN ONOFF_PROPERTY_TOKEN;
extern TOKEN STYLE_PROPERTY_TOKEN;
extern TOKEN DISPLAY_PROPERTY_TOKEN;
extern TOKEN VISIBILITY_PROPERTY_TOKEN;

extern TOKEN TRUE_TOKEN;
extern TOKEN FALSE_TOKEN;
extern TOKEN HIDDEN_TOKEN;

extern TOKEN CANSLIP_TOKEN;
extern TOKEN LOCKED_TOKEN;

extern TOKEN STARTRULE_IMMEDIATE_TOKEN;
extern TOKEN STARTRULE_ONDOCLOAD_TOKEN;
extern TOKEN STARTRULE_ONDOCCOMPLETE_TOKEN;

extern TOKEN READYSTATE_COMPLETE_TOKEN;
#endif /* _TOKENS_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\types\idl\danimid.h ===
// Copyright (C) Microsoft Corporation, 1998
//
// IDs for DANIM Events
//
// Just follow the template when adding either DISPIDs or new interfaces.
//

#ifndef __DANIMDISPID_H__
#define __DANIMDISPID_H__

// Base offset:

#define DISPID_BASE                                             0x00000000

// Interface offsets:
#define DAVIEWERCONTROL_OFFSET                                  0x1000
#define DAVIEW_OFFSET                                           0x2000

// Interface bases:
#define DISPID_DANIMEVENT_BASE                                  (DISPID_BASE + DAVIEWERCONTROL_OFFSET)
#define DISPID_VIEWEVENT_BASE                                   (DISPID_BASE + DAVIEW_OFFSET)

// DAVIEWERCONTROL DISPIDs:
#define DISPID_DANIMEVENT_START                          (DISPID_DANIMEVENT_BASE + 0x01)
#define DISPID_DANIMEVENT_MOUSEUP                        (DISPID_DANIMEVENT_BASE + 0x02)
#define DISPID_DANIMEVENT_MOUSEDOWN                      (DISPID_DANIMEVENT_BASE + 0x03)
#define DISPID_DANIMEVENT_MOUSEMOVE                      (DISPID_DANIMEVENT_BASE + 0x04)
#define DISPID_DANIMEVENT_CLICK                          (DISPID_DANIMEVENT_BASE + 0x05)
#define DISPID_DANIMEVENT_KEYPRESS                       (DISPID_DANIMEVENT_BASE + 0x06)
#define DISPID_DANIMEVENT_KEYUP                          (DISPID_DANIMEVENT_BASE + 0x07)
#define DISPID_DANIMEVENT_KEYDOWN                        (DISPID_DANIMEVENT_BASE + 0x08)
#define DISPID_DANIMEVENT_ERROR                          (DISPID_DANIMEVENT_BASE + 0x09)
#define DISPID_DANIMEVENT_STOP                           (DISPID_DANIMEVENT_BASE + 0x0A)
#define DISPID_DANIMEVENT_PAUSE                          (DISPID_DANIMEVENT_BASE + 0x0B)
#define DISPID_DANIMEVENT_RESUME                         (DISPID_DANIMEVENT_BASE + 0x0C)

//VIEW DISPIDS
#define DISPID_VIEWEVENT_START                                  (DISPID_VIEWEVENT_BASE + 0x01)
#define DISPID_VIEWEVENT_STOP                                   (DISPID_VIEWEVENT_BASE + 0x02)
#define DISPID_VIEWEVENT_ONMOUSEMOVE                            (DISPID_VIEWEVENT_BASE + 0x03)
#define DISPID_VIEWEVENT_ONMOUSEBUTTON                          (DISPID_VIEWEVENT_BASE + 0x04)
#define DISPID_VIEWEVENT_ONKEY                                  (DISPID_VIEWEVENT_BASE + 0x05)
#define DISPID_VIEWEVENT_ONFOCUS                                (DISPID_VIEWEVENT_BASE + 0x06)
#define DISPID_VIEWEVENT_PAUSE                                  (DISPID_VIEWEVENT_BASE + 0x07)
#define DISPID_VIEWEVENT_RESUME                                 (DISPID_VIEWEVENT_BASE + 0x08)
#define DISPID_VIEWEVENT_ERROR                                  (DISPID_VIEWEVENT_BASE + 0x09)

#endif  //__DANIMDISPID_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\types\idl\primfuns.h ===
HRESULT Pow ([in] IDANumber * a_0, [in] IDANumber * b_1, [out, retval] IDANumber * * ret_2) ;

        HRESULT Abs ([in] IDANumber * a_0, [out, retval] IDANumber * * ret_1) ;

        HRESULT Sqrt ([in] IDANumber * a_0, [out, retval] IDANumber * * ret_1) ;

        HRESULT Floor ([in] IDANumber * a_0, [out, retval] IDANumber * * ret_1) ;

        HRESULT Round ([in] IDANumber * a_0, [out, retval] IDANumber * * ret_1) ;

        HRESULT Ceiling ([in] IDANumber * a_0, [out, retval] IDANumber * * ret_1) ;

        HRESULT Asin ([in] IDANumber * a_0, [out, retval] IDANumber * * ret_1) ;

        HRESULT Acos ([in] IDANumber * a_0, [out, retval] IDANumber * * ret_1) ;

        HRESULT Atan ([in] IDANumber * a_0, [out, retval] IDANumber * * ret_1) ;

        HRESULT Sin ([in] IDANumber * a_0, [out, retval] IDANumber * * ret_1) ;

        HRESULT Cos ([in] IDANumber * a_0, [out, retval] IDANumber * * ret_1) ;

        HRESULT Tan ([in] IDANumber * a_0, [out, retval] IDANumber * * ret_1) ;

        HRESULT Exp ([in] IDANumber * a_0, [out, retval] IDANumber * * ret_1) ;

        HRESULT Ln ([in] IDANumber * a_0, [out, retval] IDANumber * * ret_1) ;

        HRESULT Log10 ([in] IDANumber * a_0, [out, retval] IDANumber * * ret_1) ;

        HRESULT ToDegrees ([in] IDANumber * a_0, [out, retval] IDANumber * * ret_1) ;

        HRESULT ToRadians ([in] IDANumber * a_0, [out, retval] IDANumber * * ret_1) ;

        HRESULT Mod ([in] IDANumber * a_0, [in] IDANumber * b_1, [out, retval] IDANumber * * ret_2) ;

        HRESULT Atan2 ([in] IDANumber * a_0, [in] IDANumber * b_1, [out, retval] IDANumber * * ret_2) ;

        HRESULT Add ([in] IDANumber * a_0, [in] IDANumber * b_1, [out, retval] IDANumber * * ret_2) ;

        HRESULT Sub ([in] IDANumber * a_0, [in] IDANumber * b_1, [out, retval] IDANumber * * ret_2) ;

        HRESULT Mul ([in] IDANumber * a_0, [in] IDANumber * b_1, [out, retval] IDANumber * * ret_2) ;

        HRESULT Div ([in] IDANumber * a_0, [in] IDANumber * b_1, [out, retval] IDANumber * * ret_2) ;

        HRESULT LT ([in] IDANumber * a_0, [in] IDANumber * b_1, [out, retval] IDABoolean * * ret_2) ;

        HRESULT LTE ([in] IDANumber * a_0, [in] IDANumber * b_1, [out, retval] IDABoolean * * ret_2) ;

        HRESULT GT ([in] IDANumber * a_0, [in] IDANumber * b_1, [out, retval] IDABoolean * * ret_2) ;

        HRESULT GTE ([in] IDANumber * a_0, [in] IDANumber * b_1, [out, retval] IDABoolean * * ret_2) ;

        HRESULT EQ ([in] IDANumber * a_0, [in] IDANumber * b_1, [out, retval] IDABoolean * * ret_2) ;

        HRESULT NE ([in] IDANumber * a_0, [in] IDANumber * b_1, [out, retval] IDABoolean * * ret_2) ;

        HRESULT Neg ([in] IDANumber * a_0, [out, retval] IDANumber * * ret_1) ;

        HRESULT InterpolateAnim ([in] IDANumber * from_0, [in] IDANumber * to_1, [in] IDANumber * duration_2, [out, retval] IDANumber * * ret_3) ;

        HRESULT Interpolate ([in] double from_0, [in] double to_1, [in] double duration_2, [out, retval] IDANumber * * ret_3) ;

        HRESULT SlowInSlowOutAnim ([in] IDANumber * from_0, [in] IDANumber * to_1, [in] IDANumber * duration_2, [in] IDANumber * sharpness_3, [out, retval] IDANumber * * ret_4) ;

        HRESULT SlowInSlowOut ([in] double from_0, [in] double to_1, [in] double duration_2, [in] double sharpness_3, [out, retval] IDANumber * * ret_4) ;

        HRESULT SoundSource ([in] IDASound * snd_0, [out, retval] IDAGeometry * * ret_1) ;

        HRESULT Mix ([in] IDASound * left_0, [in] IDASound * right_1, [out, retval] IDASound * * ret_2) ;

        HRESULT And ([in] IDABoolean * a_0, [in] IDABoolean * b_1, [out, retval] IDABoolean * * ret_2) ;

        HRESULT Or ([in] IDABoolean * a_0, [in] IDABoolean * b_1, [out, retval] IDABoolean * * ret_2) ;

        HRESULT Not ([in] IDABoolean * a_0, [out, retval] IDABoolean * * ret_1) ;

        HRESULT Integral ([in] IDANumber * b_0, [out, retval] IDANumber * * ret_1) ;

        HRESULT Derivative ([in] IDANumber * b_0, [out, retval] IDANumber * * ret_1) ;

        HRESULT IntegralVector2 ([in] IDAVector2 * v_0, [out, retval] IDAVector2 * * ret_1) ;

        HRESULT IntegralVector3 ([in] IDAVector3 * v_0, [out, retval] IDAVector3 * * ret_1) ;

        HRESULT DerivativeVector2 ([in] IDAVector2 * v_0, [out, retval] IDAVector2 * * ret_1) ;

        HRESULT DerivativeVector3 ([in] IDAVector3 * v_0, [out, retval] IDAVector3 * * ret_1) ;

        HRESULT DerivativePoint2 ([in] IDAPoint2 * v_0, [out, retval] IDAVector2 * * ret_1) ;

        HRESULT DerivativePoint3 ([in] IDAPoint3 * v_0, [out, retval] IDAVector3 * * ret_1) ;

        HRESULT KeyState ([in] IDANumber * n_0, [out, retval] IDABoolean * * ret_1) ;

        HRESULT KeyUp ([in] LONG arg_0, [out, retval] IDAEvent * * ret_1) ;

        HRESULT KeyDown ([in] LONG arg_0, [out, retval] IDAEvent * * ret_1) ;

        HRESULT DANumber ([in] double num_0, [out, retval] IDANumber * * ret_1) ;

        HRESULT DAString ([in] BSTR str_0, [out, retval] IDAString * * ret_1) ;

        HRESULT DABoolean ([in] VARIANT_BOOL num_0, [out, retval] IDABoolean * * ret_1) ;

        HRESULT SeededRandom ([in] double arg_0, [out, retval] IDANumber * * ret_1) ;

        [propget] HRESULT MousePosition ([out, retval] IDAPoint2 * * ret_0) ;

        [propget] HRESULT LeftButtonState ([out, retval] IDABoolean * * ret_0) ;

        [propget] HRESULT RightButtonState ([out, retval] IDABoolean * * ret_0) ;

        [propget] HRESULT DATrue ([out, retval] IDABoolean * * ret_0) ;

        [propget] HRESULT DAFalse ([out, retval] IDABoolean * * ret_0) ;

        [propget] HRESULT LocalTime ([out, retval] IDANumber * * ret_0) ;

        [propget] HRESULT GlobalTime ([out, retval] IDANumber * * ret_0) ;

        [propget] HRESULT Pixel ([out, retval] IDANumber * * ret_0) ;

        HRESULT UserData ([in] IUnknown * data_0, [out, retval] IDAUserData * * ret_1) ;

        HRESULT UntilNotify ([in] IDABehavior * b0_0, [in] IDAEvent * event_1, [in] IDAUntilNotifier * notifier_2, [out, retval] IDABehavior * * ret_3) ;

        HRESULT Until ([in] IDABehavior * b0_0, [in] IDAEvent * event_1, [in] IDABehavior * b1_2, [out, retval] IDABehavior * * ret_3) ;

        HRESULT UntilEx ([in] IDABehavior * b0_0, [in] IDAEvent * event_1, [out, retval] IDABehavior * * ret_2) ;

        HRESULT Sequence ([in] IDABehavior * s1_0, [in] IDABehavior * s2_1, [out, retval] IDABehavior * * ret_2) ;

        HRESULT FollowPath ([in] IDAPath2 * path_0, [in] double duration_1, [out, retval] IDATransform2 * * ret_2) ;

        HRESULT FollowPathAngle ([in] IDAPath2 * path_0, [in] double duration_1, [out, retval] IDATransform2 * * ret_2) ;

        HRESULT FollowPathAngleUpright ([in] IDAPath2 * path_0, [in] double duration_1, [out, retval] IDATransform2 * * ret_2) ;

        HRESULT FollowPathEval ([in] IDAPath2 * path_0, [in] IDANumber * eval_1, [out, retval] IDATransform2 * * ret_2) ;

        HRESULT FollowPathAngleEval ([in] IDAPath2 * path_0, [in] IDANumber * eval_1, [out, retval] IDATransform2 * * ret_2) ;

        HRESULT FollowPathAngleUprightEval ([in] IDAPath2 * path_0, [in] IDANumber * eval_1, [out, retval] IDATransform2 * * ret_2) ;

        HRESULT FollowPathAnim ([in] IDAPath2 * obsoleted1_0, [in] IDANumber * obsoleted2_1, [out, retval] IDATransform2 * * ret_2) ;

        HRESULT FollowPathAngleAnim ([in] IDAPath2 * obsoleted1_0, [in] IDANumber * obsoleted2_1, [out, retval] IDATransform2 * * ret_2) ;

        HRESULT FollowPathAngleUprightAnim ([in] IDAPath2 * obsoleted1_0, [in] IDANumber * obsoleted2_1, [out, retval] IDATransform2 * * ret_2) ;

        HRESULT ConcatString ([in] IDAString * s1_0, [in] IDAString * s2_1, [out, retval] IDAString * * ret_2) ;

        HRESULT PerspectiveCamera ([in] double focalDist_0, [in] double nearClip_1, [out, retval] IDACamera * * ret_2) ;

        HRESULT PerspectiveCameraAnim ([in] IDANumber * focalDist_0, [in] IDANumber * nearClip_1, [out, retval] IDACamera * * ret_2) ;

        HRESULT ParallelCamera ([in] double nearClip_0, [out, retval] IDACamera * * ret_1) ;

        HRESULT ParallelCameraAnim ([in] IDANumber * nearClip_0, [out, retval] IDACamera * * ret_1) ;

        HRESULT ColorRgbAnim ([in] IDANumber * red_0, [in] IDANumber * green_1, [in] IDANumber * blue_2, [out, retval] IDAColor * * ret_3) ;

        HRESULT ColorRgb ([in] double red_0, [in] double green_1, [in] double blue_2, [out, retval] IDAColor * * ret_3) ;

        HRESULT ColorRgb255 ([in] short red_0, [in] short green_1, [in] short blue_2, [out, retval] IDAColor * * ret_3) ;

        HRESULT ColorHsl ([in] double hue_0, [in] double saturation_1, [in] double lum_2, [out, retval] IDAColor * * ret_3) ;

        HRESULT ColorHslAnim ([in] IDANumber * hue_0, [in] IDANumber * saturation_1, [in] IDANumber * lum_2, [out, retval] IDAColor * * ret_3) ;

        [propget] HRESULT Red ([out, retval] IDAColor * * ret_0) ;

        [propget] HRESULT Green ([out, retval] IDAColor * * ret_0) ;

        [propget] HRESULT Blue ([out, retval] IDAColor * * ret_0) ;

        [propget] HRESULT Cyan ([out, retval] IDAColor * * ret_0) ;

        [propget] HRESULT Magenta ([out, retval] IDAColor * * ret_0) ;

        [propget] HRESULT Yellow ([out, retval] IDAColor * * ret_0) ;

        [propget] HRESULT Black ([out, retval] IDAColor * * ret_0) ;

        [propget] HRESULT White ([out, retval] IDAColor * * ret_0) ;

        [propget] HRESULT Aqua ([out, retval] IDAColor * * ret_0) ;

        [propget] HRESULT Fuchsia ([out, retval] IDAColor * * ret_0) ;

        [propget] HRESULT Gray ([out, retval] IDAColor * * ret_0) ;

        [propget] HRESULT Lime ([out, retval] IDAColor * * ret_0) ;

        [propget] HRESULT Maroon ([out, retval] IDAColor * * ret_0) ;

        [propget] HRESULT Navy ([out, retval] IDAColor * * ret_0) ;

        [propget] HRESULT Olive ([out, retval] IDAColor * * ret_0) ;

        [propget] HRESULT Purple ([out, retval] IDAColor * * ret_0) ;

        [propget] HRESULT Silver ([out, retval] IDAColor * * ret_0) ;

        [propget] HRESULT Teal ([out, retval] IDAColor * * ret_0) ;

        HRESULT Predicate ([in] IDABoolean * b_0, [out, retval] IDAEvent * * ret_1) ;

        HRESULT NotEvent ([in] IDAEvent * event_0, [out, retval] IDAEvent * * ret_1) ;

        HRESULT AndEvent ([in] IDAEvent * e1_0, [in] IDAEvent * e2_1, [out, retval] IDAEvent * * ret_2) ;

        HRESULT OrEvent ([in] IDAEvent * e1_0, [in] IDAEvent * e2_1, [out, retval] IDAEvent * * ret_2) ;

        HRESULT ThenEvent ([in] IDAEvent * e1_0, [in] IDAEvent * e2_1, [out, retval] IDAEvent * * ret_2) ;

        [propget] HRESULT LeftButtonDown ([out, retval] IDAEvent * * ret_0) ;

        [propget] HRESULT LeftButtonUp ([out, retval] IDAEvent * * ret_0) ;

        [propget] HRESULT RightButtonDown ([out, retval] IDAEvent * * ret_0) ;

        [propget] HRESULT RightButtonUp ([out, retval] IDAEvent * * ret_0) ;

        [propget] HRESULT Always ([out, retval] IDAEvent * * ret_0) ;

        [propget] HRESULT Never ([out, retval] IDAEvent * * ret_0) ;

        HRESULT TimerAnim ([in] IDANumber * n_0, [out, retval] IDAEvent * * ret_1) ;

        HRESULT Timer ([in] double n_0, [out, retval] IDAEvent * * ret_1) ;

        HRESULT AppTriggeredEvent ([out, retval] IDAEvent * * ret_0) ;

        HRESULT ScriptCallback ([in] BSTR obsolete1_0, [in] IDAEvent * obsolete2_1, [in] BSTR obsolete3_2, [out, retval] IDAEvent * * ret_3) ;

        [propget] HRESULT EmptyGeometry ([out, retval] IDAGeometry * * ret_0) ;

        HRESULT UnionGeometry ([in] IDAGeometry * g1_0, [in] IDAGeometry * g2_1, [out, retval] IDAGeometry * * ret_2) ;

        HRESULT UnionGeometryArrayEx ([in] LONG imgs_0size, [in,size_is(imgs_0size)] IDAGeometry * imgs_0[], [out, retval] IDAGeometry * * ret_1) ;

        HRESULT UnionGeometryArray ([in] VARIANT imgs_0, [out, retval] IDAGeometry * * ret_1) ;

        [propget] HRESULT EmptyImage ([out, retval] IDAImage * * ret_0) ;

        [propget] HRESULT DetectableEmptyImage ([out, retval] IDAImage * * ret_0) ;

        HRESULT SolidColorImage ([in] IDAColor * col_0, [out, retval] IDAImage * * ret_1) ;

        HRESULT GradientPolygonEx ([in] LONG points_0size, [in,size_is(points_0size)] IDAPoint2 * points_0[], [in] LONG colors_1size, [in,size_is(colors_1size)] IDAColor * colors_1[], [out, retval] IDAImage * * ret_2) ;

        HRESULT GradientPolygon ([in] VARIANT points_0, [in] VARIANT colors_1, [out, retval] IDAImage * * ret_2) ;

        HRESULT RadialGradientPolygonEx ([in] IDAColor * inner_0, [in] IDAColor * outer_1, [in] LONG points_2size, [in,size_is(points_2size)] IDAPoint2 * points_2[], [in] double fallOff_3, [out, retval] IDAImage * * ret_4) ;

        HRESULT RadialGradientPolygon ([in] IDAColor * inner_0, [in] IDAColor * outer_1, [in] VARIANT points_2, [in] double fallOff_3, [out, retval] IDAImage * * ret_4) ;

        HRESULT RadialGradientPolygonAnimEx ([in] IDAColor * inner_0, [in] IDAColor * outer_1, [in] LONG points_2size, [in,size_is(points_2size)] IDAPoint2 * points_2[], [in] IDANumber * fallOff_3, [out, retval] IDAImage * * ret_4) ;

        HRESULT RadialGradientPolygonAnim ([in] IDAColor * inner_0, [in] IDAColor * outer_1, [in] VARIANT points_2, [in] IDANumber * fallOff_3, [out, retval] IDAImage * * ret_4) ;

        HRESULT GradientSquare ([in] IDAColor * lowerLeft_0, [in] IDAColor * upperLeft_1, [in] IDAColor * upperRight_2, [in] IDAColor * lowerRight_3, [out, retval] IDAImage * * ret_4) ;

        HRESULT RadialGradientSquare ([in] IDAColor * inner_0, [in] IDAColor * outer_1, [in] double fallOff_2, [out, retval] IDAImage * * ret_3) ;

        HRESULT RadialGradientSquareAnim ([in] IDAColor * inner_0, [in] IDAColor * outer_1, [in] IDANumber * fallOff_2, [out, retval] IDAImage * * ret_3) ;

        HRESULT RadialGradientRegularPoly ([in] IDAColor * inner_0, [in] IDAColor * outer_1, [in] double numEdges_2, [in] double fallOff_3, [out, retval] IDAImage * * ret_4) ;

        HRESULT RadialGradientRegularPolyAnim ([in] IDAColor * inner_0, [in] IDAColor * outer_1, [in] IDANumber * numEdges_2, [in] IDANumber * fallOff_3, [out, retval] IDAImage * * ret_4) ;

        HRESULT GradientHorizontal ([in] IDAColor * start_0, [in] IDAColor * stop_1, [in] double fallOff_2, [out, retval] IDAImage * * ret_3) ;

        HRESULT GradientHorizontalAnim ([in] IDAColor * start_0, [in] IDAColor * stop_1, [in] IDANumber * fallOff_2, [out, retval] IDAImage * * ret_3) ;

        HRESULT HatchHorizontal ([in] IDAColor * lineClr_0, [in] double spacing_1, [out, retval] IDAImage * * ret_2) ;

        HRESULT HatchHorizontalAnim ([in] IDAColor * lineClr_0, [in] IDANumber * spacing_1, [out, retval] IDAImage * * ret_2) ;

        HRESULT HatchVertical ([in] IDAColor * lineClr_0, [in] double spacing_1, [out, retval] IDAImage * * ret_2) ;

        HRESULT HatchVerticalAnim ([in] IDAColor * lineClr_0, [in] IDANumber * spacing_1, [out, retval] IDAImage * * ret_2) ;

        HRESULT HatchForwardDiagonal ([in] IDAColor * lineClr_0, [in] double spacing_1, [out, retval] IDAImage * * ret_2) ;

        HRESULT HatchForwardDiagonalAnim ([in] IDAColor * lineClr_0, [in] IDANumber * spacing_1, [out, retval] IDAImage * * ret_2) ;

        HRESULT HatchBackwardDiagonal ([in] IDAColor * lineClr_0, [in] double spacing_1, [out, retval] IDAImage * * ret_2) ;

        HRESULT HatchBackwardDiagonalAnim ([in] IDAColor * lineClr_0, [in] IDANumber * spacing_1, [out, retval] IDAImage * * ret_2) ;

        HRESULT HatchCross ([in] IDAColor * lineClr_0, [in] double spacing_1, [out, retval] IDAImage * * ret_2) ;

        HRESULT HatchCrossAnim ([in] IDAColor * lineClr_0, [in] IDANumber * spacing_1, [out, retval] IDAImage * * ret_2) ;

        HRESULT HatchDiagonalCross ([in] IDAColor * lineClr_0, [in] double spacing_1, [out, retval] IDAImage * * ret_2) ;

        HRESULT HatchDiagonalCrossAnim ([in] IDAColor * lineClr_0, [in] IDANumber * spacing_1, [out, retval] IDAImage * * ret_2) ;

        HRESULT Overlay ([in] IDAImage * top_0, [in] IDAImage * bottom_1, [out, retval] IDAImage * * ret_2) ;

        HRESULT OverlayArrayEx ([in] LONG imgs_0size, [in,size_is(imgs_0size)] IDAImage * imgs_0[], [out, retval] IDAImage * * ret_1) ;

        HRESULT OverlayArray ([in] VARIANT imgs_0, [out, retval] IDAImage * * ret_1) ;

        [propget] HRESULT AmbientLight ([out, retval] IDAGeometry * * ret_0) ;

        [propget] HRESULT DirectionalLight ([out, retval] IDAGeometry * * ret_0) ;

        [propget] HRESULT PointLight ([out, retval] IDAGeometry * * ret_0) ;

        HRESULT SpotLightAnim ([in] IDANumber * fullcone_0, [in] IDANumber * cutoff_1, [out, retval] IDAGeometry * * ret_2) ;

        HRESULT SpotLight ([in] IDANumber * fullcone_0, [in] double cutoff_1, [out, retval] IDAGeometry * * ret_2) ;

        [propget] HRESULT DefaultLineStyle ([out, retval] IDALineStyle * * ret_0) ;

        [propget] HRESULT EmptyLineStyle ([out, retval] IDALineStyle * * ret_0) ;

        [propget] HRESULT JoinStyleBevel ([out, retval] IDAJoinStyle * * ret_0) ;

        [propget] HRESULT JoinStyleRound ([out, retval] IDAJoinStyle * * ret_0) ;

        [propget] HRESULT JoinStyleMiter ([out, retval] IDAJoinStyle * * ret_0) ;

        [propget] HRESULT EndStyleFlat ([out, retval] IDAEndStyle * * ret_0) ;

        [propget] HRESULT EndStyleSquare ([out, retval] IDAEndStyle * * ret_0) ;

        [propget] HRESULT EndStyleRound ([out, retval] IDAEndStyle * * ret_0) ;

        [propget] HRESULT DashStyleSolid ([out, retval] IDADashStyle * * ret_0) ;

        [propget] HRESULT DashStyleDashed ([out, retval] IDADashStyle * * ret_0) ;

        [propget] HRESULT DefaultMicrophone ([out, retval] IDAMicrophone * * ret_0) ;

        [propget] HRESULT OpaqueMatte ([out, retval] IDAMatte * * ret_0) ;

        [propget] HRESULT ClearMatte ([out, retval] IDAMatte * * ret_0) ;

        HRESULT UnionMatte ([in] IDAMatte * m1_0, [in] IDAMatte * m2_1, [out, retval] IDAMatte * * ret_2) ;

        HRESULT IntersectMatte ([in] IDAMatte * m1_0, [in] IDAMatte * m2_1, [out, retval] IDAMatte * * ret_2) ;

        HRESULT DifferenceMatte ([in] IDAMatte * m1_0, [in] IDAMatte * m2_1, [out, retval] IDAMatte * * ret_2) ;

        HRESULT FillMatte ([in] IDAPath2 * p_0, [out, retval] IDAMatte * * ret_1) ;

        HRESULT TextMatte ([in] IDAString * str_0, [in] IDAFontStyle * fs_1, [out, retval] IDAMatte * * ret_2) ;

        [propget] HRESULT EmptyMontage ([out, retval] IDAMontage * * ret_0) ;

        HRESULT ImageMontage ([in] IDAImage * im_0, [in] double depth_1, [out, retval] IDAMontage * * ret_2) ;

        HRESULT ImageMontageAnim ([in] IDAImage * im_0, [in] IDANumber * depth_1, [out, retval] IDAMontage * * ret_2) ;

        HRESULT UnionMontage ([in] IDAMontage * m1_0, [in] IDAMontage * m2_1, [out, retval] IDAMontage * * ret_2) ;

        HRESULT Concat ([in] IDAPath2 * p1_0, [in] IDAPath2 * p2_1, [out, retval] IDAPath2 * * ret_2) ;

        HRESULT ConcatArrayEx ([in] LONG paths_0size, [in,size_is(paths_0size)] IDAPath2 * paths_0[], [out, retval] IDAPath2 * * ret_1) ;

        HRESULT ConcatArray ([in] VARIANT paths_0, [out, retval] IDAPath2 * * ret_1) ;

        HRESULT Line ([in] IDAPoint2 * p1_0, [in] IDAPoint2 * p2_1, [out, retval] IDAPath2 * * ret_2) ;

        HRESULT Ray ([in] IDAPoint2 * pt_0, [out, retval] IDAPath2 * * ret_1) ;

        HRESULT StringPathAnim ([in] IDAString * str_0, [in] IDAFontStyle * fs_1, [out, retval] IDAPath2 * * ret_2) ;

        HRESULT StringPath ([in] BSTR str_0, [in] IDAFontStyle * fs_1, [out, retval] IDAPath2 * * ret_2) ;

        HRESULT PolylineEx ([in] LONG points_0size, [in,size_is(points_0size)] IDAPoint2 * points_0[], [out, retval] IDAPath2 * * ret_1) ;

        HRESULT Polyline ([in] VARIANT points_0, [out, retval] IDAPath2 * * ret_1) ;

        HRESULT PolydrawPathEx ([in] LONG points_0size, [in,size_is(points_0size)] IDAPoint2 * points_0[], [in] LONG codes_1size, [in,size_is(codes_1size)] IDANumber * codes_1[], [out, retval] IDAPath2 * * ret_2) ;

        HRESULT PolydrawPath ([in] VARIANT points_0, [in] VARIANT codes_1, [out, retval] IDAPath2 * * ret_2) ;

        HRESULT ArcRadians ([in] double startAngle_0, [in] double endAngle_1, [in] double arcWidth_2, [in] double arcHeight_3, [out, retval] IDAPath2 * * ret_4) ;

        HRESULT ArcRadiansAnim ([in] IDANumber * startAngle_0, [in] IDANumber * endAngle_1, [in] IDANumber * arcWidth_2, [in] IDANumber * arcHeight_3, [out, retval] IDAPath2 * * ret_4) ;

        HRESULT ArcDegrees ([in] double startAngle_0, [in] double endAngle_1, [in] double arcWidth_2, [in] double arcHeight_3, [out, retval] IDAPath2 * * ret_4) ;

        HRESULT PieRadians ([in] double startAngle_0, [in] double endAngle_1, [in] double arcWidth_2, [in] double arcHeight_3, [out, retval] IDAPath2 * * ret_4) ;

        HRESULT PieRadiansAnim ([in] IDANumber * startAngle_0, [in] IDANumber * endAngle_1, [in] IDANumber * arcWidth_2, [in] IDANumber * arcHeight_3, [out, retval] IDAPath2 * * ret_4) ;

        HRESULT PieDegrees ([in] double startAngle_0, [in] double endAngle_1, [in] double arcWidth_2, [in] double arcHeight_3, [out, retval] IDAPath2 * * ret_4) ;

        HRESULT Oval ([in] double width_0, [in] double height_1, [out, retval] IDAPath2 * * ret_2) ;

        HRESULT OvalAnim ([in] IDANumber * width_0, [in] IDANumber * height_1, [out, retval] IDAPath2 * * ret_2) ;

        HRESULT Rect ([in] double width_0, [in] double height_1, [out, retval] IDAPath2 * * ret_2) ;

        HRESULT RectAnim ([in] IDANumber * width_0, [in] IDANumber * height_1, [out, retval] IDAPath2 * * ret_2) ;

        HRESULT RoundRect ([in] double width_0, [in] double height_1, [in] double cornerArcWidth_2, [in] double cornerArcHeight_3, [out, retval] IDAPath2 * * ret_4) ;

        HRESULT RoundRectAnim ([in] IDANumber * width_0, [in] IDANumber * height_1, [in] IDANumber * cornerArcWidth_2, [in] IDANumber * cornerArcHeight_3, [out, retval] IDAPath2 * * ret_4) ;

        HRESULT CubicBSplinePathEx ([in] LONG points_0size, [in,size_is(points_0size)] IDAPoint2 * points_0[], [in] LONG knots_1size, [in,size_is(knots_1size)] IDANumber * knots_1[], [out, retval] IDAPath2 * * ret_2) ;

        HRESULT CubicBSplinePath ([in] VARIANT points_0, [in] VARIANT knots_1, [out, retval] IDAPath2 * * ret_2) ;

        HRESULT TextPath ([in] IDAString * obsolete1_0, [in] IDAFontStyle * obsolete2_1, [out, retval] IDAPath2 * * ret_2) ;

        [propget] HRESULT Silence ([out, retval] IDASound * * ret_0) ;

        HRESULT MixArrayEx ([in] LONG snds_0size, [in,size_is(snds_0size)] IDASound * snds_0[], [out, retval] IDASound * * ret_1) ;

        HRESULT MixArray ([in] VARIANT snds_0, [out, retval] IDASound * * ret_1) ;

        [propget] HRESULT SinSynth ([out, retval] IDASound * * ret_0) ;

        [propget] HRESULT DefaultFont ([out, retval] IDAFontStyle * * ret_0) ;

        HRESULT FontAnim ([in] IDAString * str_0, [in] IDANumber * size_1, [in] IDAColor * col_2, [out, retval] IDAFontStyle * * ret_3) ;

        HRESULT Font ([in] BSTR str_0, [in] double size_1, [in] IDAColor * col_2, [out, retval] IDAFontStyle * * ret_3) ;

        HRESULT StringImageAnim ([in] IDAString * str_0, [in] IDAFontStyle * fs_1, [out, retval] IDAImage * * ret_2) ;

        HRESULT StringImage ([in] BSTR str_0, [in] IDAFontStyle * fs_1, [out, retval] IDAImage * * ret_2) ;

        HRESULT TextImageAnim ([in] IDAString * obsoleted1_0, [in] IDAFontStyle * obsoleted2_1, [out, retval] IDAImage * * ret_2) ;

        HRESULT TextImage ([in] BSTR obsoleted1_0, [in] IDAFontStyle * obsoleted2_1, [out, retval] IDAImage * * ret_2) ;

        [propget] HRESULT XVector2 ([out, retval] IDAVector2 * * ret_0) ;

        [propget] HRESULT YVector2 ([out, retval] IDAVector2 * * ret_0) ;

        [propget] HRESULT ZeroVector2 ([out, retval] IDAVector2 * * ret_0) ;

        [propget] HRESULT Origin2 ([out, retval] IDAPoint2 * * ret_0) ;

        HRESULT Vector2Anim ([in] IDANumber * x_0, [in] IDANumber * y_1, [out, retval] IDAVector2 * * ret_2) ;

        HRESULT Vector2 ([in] double x_0, [in] double y_1, [out, retval] IDAVector2 * * ret_2) ;

        HRESULT Point2Anim ([in] IDANumber * x_0, [in] IDANumber * y_1, [out, retval] IDAPoint2 * * ret_2) ;

        HRESULT Point2 ([in] double x_0, [in] double y_1, [out, retval] IDAPoint2 * * ret_2) ;

        HRESULT Vector2PolarAnim ([in] IDANumber * theta_0, [in] IDANumber * radius_1, [out, retval] IDAVector2 * * ret_2) ;

        HRESULT Vector2Polar ([in] double theta_0, [in] double radius_1, [out, retval] IDAVector2 * * ret_2) ;

        HRESULT Vector2PolarDegrees ([in] double theta_0, [in] double radius_1, [out, retval] IDAVector2 * * ret_2) ;

        HRESULT Point2PolarAnim ([in] IDANumber * theta_0, [in] IDANumber * radius_1, [out, retval] IDAPoint2 * * ret_2) ;

        HRESULT Point2Polar ([in] double theta_0, [in] double radius_1, [out, retval] IDAPoint2 * * ret_2) ;

        HRESULT DotVector2 ([in] IDAVector2 * v_0, [in] IDAVector2 * u_1, [out, retval] IDANumber * * ret_2) ;

        HRESULT NegVector2 ([in] IDAVector2 * v_0, [out, retval] IDAVector2 * * ret_1) ;

        HRESULT SubVector2 ([in] IDAVector2 * v1_0, [in] IDAVector2 * v2_1, [out, retval] IDAVector2 * * ret_2) ;

        HRESULT AddVector2 ([in] IDAVector2 * v1_0, [in] IDAVector2 * v2_1, [out, retval] IDAVector2 * * ret_2) ;

        HRESULT AddPoint2Vector ([in] IDAPoint2 * p_0, [in] IDAVector2 * v_1, [out, retval] IDAPoint2 * * ret_2) ;

        HRESULT SubPoint2Vector ([in] IDAPoint2 * p_0, [in] IDAVector2 * v_1, [out, retval] IDAPoint2 * * ret_2) ;

        HRESULT SubPoint2 ([in] IDAPoint2 * p1_0, [in] IDAPoint2 * p2_1, [out, retval] IDAVector2 * * ret_2) ;

        HRESULT DistancePoint2 ([in] IDAPoint2 * p_0, [in] IDAPoint2 * q_1, [out, retval] IDANumber * * ret_2) ;

        HRESULT DistanceSquaredPoint2 ([in] IDAPoint2 * p_0, [in] IDAPoint2 * q_1, [out, retval] IDANumber * * ret_2) ;

        [propget] HRESULT XVector3 ([out, retval] IDAVector3 * * ret_0) ;

        [propget] HRESULT YVector3 ([out, retval] IDAVector3 * * ret_0) ;

        [propget] HRESULT ZVector3 ([out, retval] IDAVector3 * * ret_0) ;

        [propget] HRESULT ZeroVector3 ([out, retval] IDAVector3 * * ret_0) ;

        [propget] HRESULT Origin3 ([out, retval] IDAPoint3 * * ret_0) ;

        HRESULT Vector3Anim ([in] IDANumber * x_0, [in] IDANumber * y_1, [in] IDANumber * z_2, [out, retval] IDAVector3 * * ret_3) ;

        HRESULT Vector3 ([in] double x_0, [in] double y_1, [in] double z_2, [out, retval] IDAVector3 * * ret_3) ;

        HRESULT Point3Anim ([in] IDANumber * x_0, [in] IDANumber * y_1, [in] IDANumber * z_2, [out, retval] IDAPoint3 * * ret_3) ;

        HRESULT Point3 ([in] double x_0, [in] double y_1, [in] double z_2, [out, retval] IDAPoint3 * * ret_3) ;

        HRESULT Vector3SphericalAnim ([in] IDANumber * xyAngle_0, [in] IDANumber * yzAngle_1, [in] IDANumber * radius_2, [out, retval] IDAVector3 * * ret_3) ;

        HRESULT Vector3Spherical ([in] double xyAngle_0, [in] double yzAngle_1, [in] double radius_2, [out, retval] IDAVector3 * * ret_3) ;

        HRESULT Point3SphericalAnim ([in] IDANumber * zxAngle_0, [in] IDANumber * xyAngle_1, [in] IDANumber * radius_2, [out, retval] IDAPoint3 * * ret_3) ;

        HRESULT Point3Spherical ([in] double zxAngle_0, [in] double xyAngle_1, [in] double radius_2, [out, retval] IDAPoint3 * * ret_3) ;

        HRESULT DotVector3 ([in] IDAVector3 * v_0, [in] IDAVector3 * u_1, [out, retval] IDANumber * * ret_2) ;

        HRESULT CrossVector3 ([in] IDAVector3 * v_0, [in] IDAVector3 * u_1, [out, retval] IDAVector3 * * ret_2) ;

        HRESULT NegVector3 ([in] IDAVector3 * v_0, [out, retval] IDAVector3 * * ret_1) ;

        HRESULT SubVector3 ([in] IDAVector3 * v1_0, [in] IDAVector3 * v2_1, [out, retval] IDAVector3 * * ret_2) ;

        HRESULT AddVector3 ([in] IDAVector3 * v1_0, [in] IDAVector3 * v2_1, [out, retval] IDAVector3 * * ret_2) ;

        HRESULT AddPoint3Vector ([in] IDAPoint3 * p_0, [in] IDAVector3 * v_1, [out, retval] IDAPoint3 * * ret_2) ;

        HRESULT SubPoint3Vector ([in] IDAPoint3 * p_0, [in] IDAVector3 * v_1, [out, retval] IDAPoint3 * * ret_2) ;

        HRESULT SubPoint3 ([in] IDAPoint3 * p1_0, [in] IDAPoint3 * p2_1, [out, retval] IDAVector3 * * ret_2) ;

        HRESULT DistancePoint3 ([in] IDAPoint3 * p_0, [in] IDAPoint3 * q_1, [out, retval] IDANumber * * ret_2) ;

        HRESULT DistanceSquaredPoint3 ([in] IDAPoint3 * p_0, [in] IDAPoint3 * q_1, [out, retval] IDANumber * * ret_2) ;

        [propget] HRESULT IdentityTransform3 ([out, retval] IDATransform3 * * ret_0) ;

        HRESULT Translate3Anim ([in] IDANumber * tx_0, [in] IDANumber * ty_1, [in] IDANumber * tz_2, [out, retval] IDATransform3 * * ret_3) ;

        HRESULT Translate3 ([in] double tx_0, [in] double ty_1, [in] double tz_2, [out, retval] IDATransform3 * * ret_3) ;

        HRESULT Translate3Rate ([in] double tx_0, [in] double ty_1, [in] double tz_2, [out, retval] IDATransform3 * * ret_3) ;

        HRESULT Translate3Vector ([in] IDAVector3 * delta_0, [out, retval] IDATransform3 * * ret_1) ;

        HRESULT Translate3Point ([in] IDAPoint3 * new_origin_0, [out, retval] IDATransform3 * * ret_1) ;

        HRESULT Scale3Anim ([in] IDANumber * x_0, [in] IDANumber * y_1, [in] IDANumber * z_2, [out, retval] IDATransform3 * * ret_3) ;

        HRESULT Scale3 ([in] double x_0, [in] double y_1, [in] double z_2, [out, retval] IDATransform3 * * ret_3) ;

        HRESULT Scale3Rate ([in] double x_0, [in] double y_1, [in] double z_2, [out, retval] IDATransform3 * * ret_3) ;

        HRESULT Scale3Vector ([in] IDAVector3 * scale_vec_0, [out, retval] IDATransform3 * * ret_1) ;

        HRESULT Scale3UniformAnim ([in] IDANumber * uniform_scale_0, [out, retval] IDATransform3 * * ret_1) ;

        HRESULT Scale3Uniform ([in] double uniform_scale_0, [out, retval] IDATransform3 * * ret_1) ;

        HRESULT Scale3UniformRate ([in] double uniform_scale_0, [out, retval] IDATransform3 * * ret_1) ;

        HRESULT Rotate3Anim ([in] IDAVector3 * axis_0, [in] IDANumber * angle_1, [out, retval] IDATransform3 * * ret_2) ;

        HRESULT Rotate3 ([in] IDAVector3 * axis_0, [in] double angle_1, [out, retval] IDATransform3 * * ret_2) ;

        HRESULT Rotate3Rate ([in] IDAVector3 * axis_0, [in] double angle_1, [out, retval] IDATransform3 * * ret_2) ;

        HRESULT Rotate3Degrees ([in] IDAVector3 * axis_0, [in] double angle_1, [out, retval] IDATransform3 * * ret_2) ;

        HRESULT Rotate3RateDegrees ([in] IDAVector3 * axis_0, [in] double angle_1, [out, retval] IDATransform3 * * ret_2) ;

        HRESULT XShear3Anim ([in] IDANumber * a_0, [in] IDANumber * b_1, [out, retval] IDATransform3 * * ret_2) ;

        HRESULT XShear3 ([in] double a_0, [in] double b_1, [out, retval] IDATransform3 * * ret_2) ;

        HRESULT XShear3Rate ([in] double a_0, [in] double b_1, [out, retval] IDATransform3 * * ret_2) ;

        HRESULT YShear3Anim ([in] IDANumber * c_0, [in] IDANumber * d_1, [out, retval] IDATransform3 * * ret_2) ;

        HRESULT YShear3 ([in] double c_0, [in] double d_1, [out, retval] IDATransform3 * * ret_2) ;

        HRESULT YShear3Rate ([in] double c_0, [in] double d_1, [out, retval] IDATransform3 * * ret_2) ;

        HRESULT ZShear3Anim ([in] IDANumber * e_0, [in] IDANumber * f_1, [out, retval] IDATransform3 * * ret_2) ;

        HRESULT ZShear3 ([in] double e_0, [in] double f_1, [out, retval] IDATransform3 * * ret_2) ;

        HRESULT ZShear3Rate ([in] double e_0, [in] double f_1, [out, retval] IDATransform3 * * ret_2) ;

        HRESULT Transform4x4AnimEx ([in] LONG m_0size, [in,size_is(m_0size)] IDANumber * m_0[], [out, retval] IDATransform3 * * ret_1) ;

        HRESULT Transform4x4Anim ([in] VARIANT m_0, [out, retval] IDATransform3 * * ret_1) ;

        HRESULT Compose3 ([in] IDATransform3 * a_0, [in] IDATransform3 * b_1, [out, retval] IDATransform3 * * ret_2) ;

        HRESULT Compose3ArrayEx ([in] LONG xfs_0size, [in,size_is(xfs_0size)] IDATransform3 * xfs_0[], [out, retval] IDATransform3 * * ret_1) ;

        HRESULT Compose3Array ([in] VARIANT xfs_0, [out, retval] IDATransform3 * * ret_1) ;

        HRESULT LookAtFrom ([in] IDAPoint3 * to_0, [in] IDAPoint3 * from_1, [in] IDAVector3 * up_2, [out, retval] IDATransform3 * * ret_3) ;

        [propget] HRESULT IdentityTransform2 ([out, retval] IDATransform2 * * ret_0) ;

        HRESULT Translate2Anim ([in] IDANumber * Tx_0, [in] IDANumber * Ty_1, [out, retval] IDATransform2 * * ret_2) ;

        HRESULT Translate2 ([in] double Tx_0, [in] double Ty_1, [out, retval] IDATransform2 * * ret_2) ;

        HRESULT Translate2Rate ([in] double Tx_0, [in] double Ty_1, [out, retval] IDATransform2 * * ret_2) ;

        HRESULT Translate2Vector ([in] IDAVector2 * delta_0, [out, retval] IDATransform2 * * ret_1) ;

        HRESULT Translate2Point ([in] IDAPoint2 * pos_0, [out, retval] IDATransform2 * * ret_1) ;

        HRESULT Scale2Anim ([in] IDANumber * x_0, [in] IDANumber * y_1, [out, retval] IDATransform2 * * ret_2) ;

        HRESULT Scale2 ([in] double x_0, [in] double y_1, [out, retval] IDATransform2 * * ret_2) ;

        HRESULT Scale2Rate ([in] double x_0, [in] double y_1, [out, retval] IDATransform2 * * ret_2) ;

        HRESULT Scale2Vector2 ([in] IDAVector2 * obsoleteMethod_0, [out, retval] IDATransform2 * * ret_1) ;

        HRESULT Scale2Vector ([in] IDAVector2 * scale_vec_0, [out, retval] IDATransform2 * * ret_1) ;

        HRESULT Scale2UniformAnim ([in] IDANumber * uniform_scale_0, [out, retval] IDATransform2 * * ret_1) ;

        HRESULT Scale2Uniform ([in] double uniform_scale_0, [out, retval] IDATransform2 * * ret_1) ;

        HRESULT Scale2UniformRate ([in] double uniform_scale_0, [out, retval] IDATransform2 * * ret_1) ;

        HRESULT Rotate2Anim ([in] IDANumber * angle_0, [out, retval] IDATransform2 * * ret_1) ;

        HRESULT Rotate2 ([in] double angle_0, [out, retval] IDATransform2 * * ret_1) ;

        HRESULT Rotate2Rate ([in] double angle_0, [out, retval] IDATransform2 * * ret_1) ;

        HRESULT Rotate2Degrees ([in] double angle_0, [out, retval] IDATransform2 * * ret_1) ;

        HRESULT Rotate2RateDegrees ([in] double angle_0, [out, retval] IDATransform2 * * ret_1) ;

        HRESULT XShear2Anim ([in] IDANumber * arg_0, [out, retval] IDATransform2 * * ret_1) ;

        HRESULT XShear2 ([in] double arg_0, [out, retval] IDATransform2 * * ret_1) ;

        HRESULT XShear2Rate ([in] double arg_0, [out, retval] IDATransform2 * * ret_1) ;

        HRESULT YShear2Anim ([in] IDANumber * arg_0, [out, retval] IDATransform2 * * ret_1) ;

        HRESULT YShear2 ([in] double arg_0, [out, retval] IDATransform2 * * ret_1) ;

        HRESULT YShear2Rate ([in] double arg_0, [out, retval] IDATransform2 * * ret_1) ;

        HRESULT Transform3x2AnimEx ([in] LONG m_0size, [in,size_is(m_0size)] IDANumber * m_0[], [out, retval] IDATransform2 * * ret_1) ;

        HRESULT Transform3x2Anim ([in] VARIANT m_0, [out, retval] IDATransform2 * * ret_1) ;

        HRESULT Compose2 ([in] IDATransform2 * a_0, [in] IDATransform2 * b_1, [out, retval] IDATransform2 * * ret_2) ;

        HRESULT Compose2ArrayEx ([in] LONG xfs_0size, [in,size_is(xfs_0size)] IDATransform2 * xfs_0[], [out, retval] IDATransform2 * * ret_1) ;

        HRESULT Compose2Array ([in] VARIANT xfs_0, [out, retval] IDATransform2 * * ret_1) ;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\types\idl\makefile.inc ===
$(SDKDIR)\danim.tlb : $(O)\danim.tlb
    copy $? $@

$(SDKDIR)\danim.h : $(O)\danim.h danim.pl makefile.inc
    perl danim.pl <$(O)\danim.h >$@
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\tools\toolsrc\mkdep\mkdep.c ===
/*-----------------------------------------------------------------------------
Name:   mkdep.c

Description:
Determine file dependencies

To Build:
    cl /Ox /W3 mkdep.c

Revision History:
brendand (8/3/94) - Taken from GaryBu, merged files into a single unit
brendand (8/4/94) - Added .PCH and wild-card support
-----------------------------------------------------------------------------*/

// Includes -------------------------------------------------------------------
#define LINT_ARGS
#include    <assert.h>
#include    <ctype.h>
#include    <io.h>
#include    <malloc.h>
#include    <process.h>
#include    <stdlib.h>
#include    <stdio.h>
#include    <string.h>

// Types and Constants --------------------------------------------------------
#ifndef CDECL
#define CDECL
#endif
#ifndef CONST
#define CONST
#endif

#ifndef STATIC
#define STATIC static
#endif

#ifndef Assert
#define Assert(f)       assert(f)
#endif

#define TRUE 1
#define FALSE 0

#define FOREVER while(1)
#define BLOCK
#define VOID    void

#ifdef D86
#define szROText        "rt"
#define szRWText        "r+t"
#define szWOText        "wt"
#define szROBin         "rb"
#define szRWBin         "r+b"
#define szWOBin         "wb"
#endif

typedef int                             BOOL;
typedef char*                   SZ;
typedef unsigned char   BYTE;
typedef BYTE*                   PB;
typedef unsigned short  WORD;
typedef WORD*                   PW;
typedef unsigned long   LONG;

#define lpbNull ((PB) NULL)

#define LOWORD(l)       ((WORD)l)
#define HIWORD(l)       ((WORD)(((LONG)l >> 16) & 0xffff))
#define LOBYTE(w)       ((BYTE)w)
#define HIBYTE(w)       (((WORD)w >> 8) & 0xff)
#define MAKEWORD(l,h)   ((WORD)(l)|((WORD)(h)<<8))
#define MAKELONG(l,h)   ((long)(((unsigned)l)|((unsigned long)((unsigned)h))<<16))

/* Args Record - MarkArgs, UnmarkArgs */
typedef struct
    {
    int cargArr;
    SZ *pszArr;
    } ARR;

/* drive usage types - getdt */
#define dtNil           0
#define dtLocal         1
#define dtUserNet       2

/* File attributes  - getatr, setatr */
#define atrError                0xffff
#define atrReadOnly             FILE_READONLY
#define atrHidden               FILE_HIDDEN
#define atrSystem               FILE_SYSTEM
#define atrVolume               0x08
#define atrDirectory    FILE_DIRECTORY
#define atrArchive              FILE_ARCHIVED

/* Macro for defining Linked list inertion */
#define AddToList(new,head,tail,link,null) { if(head==null) head=new; else tail->link = new; tail=new; new->link=null; }

/* & deletion */
#define DeleteFromList(item,head,tail,link,null,prev) { if(prev==null) head=item->link; else prev->link = item->link; \
if (tail==item) tail = prev; }

/* for MtimeOfFile() */
typedef long MTIME;
#define mtimeError ((MTIME) -1L)

typedef enum
    {
    langUnknown,
    langC,
    langAsm,
    langRC
    } LANG;

typedef struct _di
    {
    struct _di      *pdiNext;       /* next in list */
    char            *szPath;        /* path name */
    char            *szName;        /* full name */
    BOOL            fPathIsStd; /* name from standard includes (-I) */
    } DI;   /* dir info */

typedef struct _lk
    {
    struct _lk      *plkNext;       /* next in list */
    struct _fi      *pfi;           /* file info for link */
    } LK;   /* File link */

typedef struct _fi
    {
    struct _fi      *pfiNext;       /* single link */
    char            *szPath;        /* path name */
    char            *szName;        /* full name */
    LANG            lang;           /* language */
    struct _lk      *plkHead;       /* included list */
    struct _lk      *plkTail;       /* included list */
    unsigned        fIgnore:1;      /* ignore: either -X and std include or -x <file> */
    unsigned        cout:15;        /* output count */
    } FI;   /* file info */

typedef VOID (*PFN_ENUM)(char *, char *);

#define iszIncMax 40
char*   szPrefix = "";
char*   szSuffix = ".$O";

#define rmj                     1
#define rmm                     1
#define rup                     0
#define szVerName       "Forms3 Version"

// Globals --------------------------------------------------------------------
DI*     pdiHead = NULL; /* stack of directories of files included */
FI*     pfiHead = NULL;
FI*     pfiTail = NULL;
WORD    coutCur = 0;
int     cchLine;

int     iszIncMac = 0;
char*   rgszIncPath[iszIncMax];     // actual path
char*   rgszIncName[iszIncMax];     // name to output

BOOL    fVerbose       = FALSE;
BOOL    fReplacePrefix = FALSE;
BOOL    fNoGenHeaders  = FALSE;      // True if all header files must be present
BOOL    fIgnoreStd = FALSE;          // True if std include files should be ignored
BOOL    fUseCurDir = FALSE;          // When True: if a file doesn't exist and
                                     //   we are going to print a dependency for
                                     //   it, use the current directory rather
                                     //   than the directory of the source file.
char*   szPrintDir = NULL;           // If set, only print files in this dir.
char*   szPCHFile = NULL;            // .H which marks end of .PCH


// Prototypes -----------------------------------------------------------------

int     main(int, char**);
VOID    Usage(void);

char*   SzIncludesC(char *, BOOL *), *SzIncludesAsm(char *), *SzIncludesRC(char *, BOOL *);
FI*     PfiDependFn(char *, char *, BOOL, LANG, BOOL);
FI*     PfiLookup(char *, char *, LANG);
FI*     PfiAlloc(char *, char *, BOOL, LANG);
VOID    FreeFi(FI *);
VOID    AllocLk(FI *, FI *);
VOID    FreeAllLk(FI *);
VOID    StartReport(void);
VOID    ContinueReport(void);
VOID    EndReport(void);
VOID    EndLine(void);
VOID    Indent(void);
VOID    Report(char *, char *);
VOID    PrReverse(char *, char *);
BOOL    FPrintFi(FI *);
VOID    EnumChildren(FI *, PFN_ENUM, char *);
VOID    Process(char *, BOOL);
VOID    Fatal(char *);
SZ      SzTransEnv(SZ);
VOID    NormalizePath(SZ);
VOID    MakeName(SZ, SZ, SZ);
VOID    CopyPath(SZ, SZ);
VOID    PushDir(char *, char *, BOOL);
VOID    PopDir(void);
DI*     PdiFromIdi(int);
int     AddIncludeDir(char *);

VOID
Fatal(sz)
char *sz;
    {
    fprintf(stderr, "mkdep: error: %s\n", sz);
    exit(1);
    }


VOID
Usage()
    {
    if (rup == 0)
        fprintf(stderr, "Mkdep V%d.%02d\n", rmj, rmm);
    else
        fprintf(stderr, "Mkdep V%d.%02d.%02d\n", rmj, rmm, rup);

    fprintf(stderr,
        "usage: mkdep [-v] [-r] [-n] [-X] [-C] [-I includeDir]*\n"
         "\t[-p prefix] [-P replace_prefix] [-s suffix] \n"
         "\t[-d file]* [-D printDir] files\n\n"
         "\t-v  Verbose\n"
         "\t-r  Reverse the dependencies that are output\n"
         "\t-n  Don't emit dependencies on files that don't now exist\n"
         "\t-X  Search, but don't print standard includes\n"
         "\t-C  If file doesn't exist, use .\\ not the directory of including file\n"
         "\t-I  Include directory to search for <> includes\n"
         // "\t-J  Search include directories from the INCLUDE environment variable\n"
         "\t-p  Prefix for all target-file names\n"
         "\t-P  Ditto, but first remove existing prefix from name\n"
         "\t-s  Suffix for all target-file names (default %s)\n"
         "\t-d  Search, but don't print named file\n"
         "\t-D  Only print files which are in named dir\n"
         "\t-h  Header which marks the end of the .PCH\n\n"
         "A response file can be used by specifying '@filename' as an option.\n"
             , szSuffix);
    exit(1);
    }


char **CmdArgs;
int    cArgs;
int    CurArg = 1;
FILE  *pfileResponse = NULL;
char   achBuf[256];
char * pBuf = NULL;

char *
GetNextArg()
{
    char *pszTokens = " \t\n";

    if (pfileResponse)
    {
        char * psz;

        if (pBuf)
        {
            pBuf = strtok(NULL, pszTokens);

            if (pBuf)
                return pBuf;
        }

        do
        {
            psz = fgets(achBuf, 256, pfileResponse);
            if (psz == NULL)
            {
                fclose(pfileResponse);
                pfileResponse = NULL;
            }
            else if (achBuf[strlen(achBuf)-1] != '\n')
            {
                fclose(pfileResponse);
                Fatal("Line too long in response file. Must be less "
                        "than 256 characters.");
            }
            else
            {
                pBuf = strtok(achBuf, pszTokens);

                if (pBuf)
                    return pBuf;
            }
        } while (psz && !pBuf);
    }

    if (CurArg >= cArgs)
        return NULL;

    return CmdArgs[CurArg++];
}

#define FSwitchCh(ch)   ((ch)=='-' || (ch) == '/' || (ch) == '@')

int
main(iszMax, rgsz)
int iszMax;
char *rgsz[];
    {
    BOOL    fReverse = FALSE;
    char   *pszArg;
    int i = 0;

    if (iszMax == 1)
        Usage();

    CmdArgs = rgsz;
    cArgs   = iszMax;

    /* Parse command line switches.
     */
    while (((pszArg = GetNextArg()) != NULL) && FSwitchCh(pszArg[0]))
        {
        char chSwitch = pszArg[1];

        if (pszArg[0] == '@')
        {
            if (pszArg[1] == '\0')
                Usage();

            pfileResponse = fopen(&pszArg[1], "rt");
            if (!pfileResponse)
            {
                fprintf(stderr, "mkdep: error: Could not open response file "
                        "'%s'.\n", &pszArg[1]);
                return(1);
            }

            continue;
        }

        // fprintf(stderr, "Arg %d: '%s' ", i++, pszArg);

        switch (chSwitch)
            {
        case 'v':
            fVerbose = TRUE;
            break;
        case 'r':
            fReverse = TRUE;
            break;
        case 'n':
            fNoGenHeaders = TRUE;
            break;
        case 'x':
        case 'X':
            fIgnoreStd = TRUE;
            break;
        case 'C':
            fUseCurDir = TRUE;
            break;

#if 0
        case 'J':
            {
            SZ szInc = getenv("INCLUDE");
            if (szInc)
                {
                char    rgszDir[iszIncMax][_MAX_FNAME];
                int     nDirs,i;
                char*   psz;

                // Convert embedded semicolons to blanks
                for (psz=szInc; *psz; psz++)
                    if (*psz == ';')
                        *psz = ' ';

                /* This is very bogus! a dynamic way of reading the dirs
                   should be done so up to iszIncMax dirs can be read. Also,
                   AddIncludeDir does not copy the strings and rgszDir is
                   an automatic variable!
                */
                fprintf(stderr, "-J option: only first 16 include dirs parsed.\n");
                nDirs =
                     sscanf(szInc,
                       "%s %s %s %s %s %s %s %s %s %s %s %s %s %s %s %s",
                       rgszDir[0],rgszDir[1],rgszDir[2],rgszDir[3],rgszDir[4],
                       rgszDir[5],rgszDir[6],rgszDir[7],rgszDir[8],rgszDir[9],
                       rgszDir[10],rgszDir[11],rgszDir[12],rgszDir[13],
                       rgszDir[14],rgszDir[15]);
                for (i = 0; i < nDirs; i++)
                    AddIncludeDir(rgszDir[i]);
                }
            else
                fprintf(stderr,"-J option: INCLUDE variable not set.\n");
            }
            break;
#endif

        case 's':
        case 'P':
        case 'p':
        case 'I':
        case 'd':
        case 'D':
        case 'h':
            {
            char *sz = &pszArg[2];

            if (sz[0] == '\0')
                {
                /* Allow "-I includefile"
                 * and   "-IincludeFile"
                 */
                pszArg = GetNextArg();
                if (!pszArg)
                    Usage();

                sz = pszArg;
                }

            // fprintf(stderr, "File: '%s'.", sz);

            sz = strdup(sz);

            switch (chSwitch)
                {
            case 's':
                szSuffix = sz;
                break;
            case 'P':
                fReplacePrefix = TRUE;
                // Drop through
            case 'p':
                szPrefix = sz;
                break;
            case 'I':
                AddIncludeDir(sz);
                break;
            case 'd':
                {
                FI *pfi;

                // exlude file given
                // NOTE: the -C option if given, must appear before now

                NormalizePath(sz);

                if ((pfi = PfiDependFn(SzTransEnv(sz), sz, FALSE, langUnknown, FALSE)) != NULL)
                    // file existed; ignore it
                    pfi->fIgnore = TRUE;
                else
                    // file doesn't exist, create FI
                    (void)PfiAlloc(SzTransEnv(sz), sz, TRUE, langUnknown);
                break;
                }
            case 'D':
                /* only print files from given directory */
                NormalizePath(sz);
                szPrintDir = sz;
                break;
            case 'h':
                szPCHFile = sz;
                break;
                }
            }
            break;

        default:
            Usage();
            break;
            }

        // fprintf(stderr, "\n");
        }

    while (pszArg)
        {
        long                hf;
        char                szPath[_MAX_DIR];
        char                szName[_MAX_PATH];
        struct _finddata_t  fd;

        // fprintf(stderr, "Reading path '%s' - ", pszArg);

        NormalizePath(pszArg);
        CopyPath(szPath, pszArg);

        // fprintf(stderr, "'%s\\%s'\n", szPath, pszArg);

        hf = _findfirst(pszArg, &fd);

        if (hf > -1)
            {
            do
                {
                MakeName(szName, szPath, fd.name);
                // fprintf(stderr, "     -- '%s'\n", szName);
                Process(szName, fReverse);
                }
            while (!_findnext(hf, &fd));
            _findclose(hf);
            }
//      else
//          fprintf(stderr, "Unable to find source file: %s\n", pszArg);

        pszArg = GetNextArg();
        }
    return( 0 );
    }

/*****************************************************************************/
/* standard dependency report */

VOID
StartReport()
/*
  -- prepare for a new line
*/
    {
    cchLine = 77;
    }

VOID
EndLine()
/*
  -- Make it so that the next Report starts on a new line.
 */
    {
    cchLine = 0;
    }


VOID
ContinueReport()
/*
  -- Output continuation character, new line, then indent.
 */
    {
    printf(" \\\n");
    StartReport();
    Indent();
    }

VOID
EndReport()
/*
  -- Finish off this line.
 */
    {
    printf("\n\n");
    }

VOID
Indent()
/*
  -- Indent a tab at the beginning of a line.
 */
    {
    printf("\t");
    cchLine -= 8;           /* for tab */
    }


VOID
Report(sz, szParm)
/*
  -- report string
  -- if too many characters extend line
*/
register char * sz;
char *  szParm;         /* ignored */
    {
    int cch = strlen(sz);

    if (cch > cchLine)
        {
        ContinueReport();
        while (isspace(sz[0]))
            {
            sz++;
            cch--;
            }
        }

    while (*sz != '\0')
        {
        if (*sz == '#')
            {
            putchar('\\');          /* escape any # in path */
            cch++;
            }
        putchar(*sz);
        sz++;
        }
    cchLine -= cch;
    }


/*****************************************************************************/
/* Reverse dependency printing */

VOID
PrReverse(szHdr, szSource)
/*
  -- report reverse dependency
*/
char *  szHdr;
char *  szSource;
    {
    printf("%s: %s\n", szHdr, szSource);
    }


/*****************************************************************************/

BOOL FPrintFi(pfi)
/*
  -- returns true if we should print this file; false if ignore; false if
     szPrintDir is != 0 and it is a prefix of szName.  The current directory
     is a zero length string and is handled specially
*/
FI *pfi;
    {
    if (pfi->fIgnore)
        return FALSE;

    if (szPrintDir == NULL)
        return TRUE;

    if (*szPrintDir == '\0')
        // only print current directory (check for / in name)
        return strchr(pfi->szName, '/') == 0;
    else
        // print if szPrintDir is prefix of name
        return strncmp(szPrintDir, pfi->szName, strlen(szPrintDir)) == 0;
    }


VOID
EnumChildren(pfi, pfnDo, szParm)
/*
  -- enumerate children, call *pfnDo for each element
*/
FI *    pfi;
PFN_ENUM pfnDo;
char *  szParm;
    {
    LK *plk;

    for (plk = pfi->plkHead; plk != NULL; plk = plk->plkNext)
        {
        FI *pfi = plk->pfi;

        if (pfi->cout < coutCur)
            {
            /* Mark that we've visited this node, to prevent
             * infinite recursion should we have a self referential
             * dependency graph.
             */
            pfi->cout = coutCur;

            if (FPrintFi(pfi))
                {
                if (szParm == NULL)
                    (*pfnDo)(" ", szParm);
                (*pfnDo)(pfi->szName, szParm);
                }

            // recurse on nested includes; may include a non-standard includes
            EnumChildren(pfi, pfnDo, szParm);
            }
        }
    }



VOID
Process(szPath, fReverse)
/*
  -- process a file
  -- reverse => show headers as depending on files
*/
char *  szPath;                 // path name to file
BOOL    fReverse;
    {
    FI *    pfi;

    strlwr(szPath);

    /* Build a list of all dependencies. */
    pfi = PfiDependFn(szPath, szPath, FALSE, langUnknown, FALSE);

    if (pfi == NULL)
        {
        if (fVerbose)
            fprintf(stderr, "mkdep: warning: file %s ignored\n", szPath);
        }
    else if (pfi->plkHead != NULL)
        {
        /* file depends on something */

        if (!fReverse)
            {
            /* normal dependencies */
            char *  pch;

            /* truncate any suffix */
            pch = strrchr(szPath, '.');
            if (pch)
                {
                if (strchr(pch, '/') || strchr(pch, '\\'))
                    pch = NULL;
                }
            if (pch != NULL)
                *pch = '\0';

            StartReport();

            Report(szPrefix, NULL);
            if (fReplacePrefix)
                {
                /* prefix replaces any name prefix */
                char *  szName = szPath;

                while (*szPath != '\0')
                    {
                    if (*szPath == '\\' || *szPath == '/')
                        szName = szPath+1;
                    szPath++;
                    }
                Report(szName, NULL);
                }
            else
                {
                Report(szPath, NULL);
                }
            Report(szSuffix, NULL);
            Report(" :", NULL);

            EndLine();

            coutCur++;
            EnumChildren(pfi, Report, NULL);

            EndReport();
            }
        else
            {
            /* reverse dependencies */
            coutCur++;
            EnumChildren(pfi, PrReverse, szPath);
            }
        }

    if (pfi != NULL)
        // free top level FI (presumably for .c/.asm file which won't be needed)
        FreeFi(pfi);
    }



FI *
PfiDependFn(szPath, szName, fPathIsStd, lang, fIsPCHFile)
/*
  -- given a file name & language, return a filled in FI
  -- return NULL if error
*/
char *  szPath;                 // path name to file
char *  szName;                 // official name of file
BOOL    fPathIsStd;             // path portion of szPath is from standard includes (-I)
LANG    lang;                   // propagate parent language
BOOL    fIsPCHFile;             // Is .PCH marker file
    {
    FILE *  pfile;
    char    rgch[256];
    char *  sz;
    char *  szSuffix;
    FI *    pfi;

    /* first check to see if already in list */
    if ((pfi = PfiLookup(szPath, szName, lang)) != NULL)
        return pfi;

    if (lang != langUnknown)
        {
            /* do nothing -- keep old language */
        }
    else if ((szSuffix = strrchr(szPath, '.')) == NULL)
        return NULL;
    else if (strcmp(szSuffix, ".asm") == 0 || strcmp(szSuffix, ".inc") == 0)
        lang = langAsm;
    else if (strcmp(szSuffix, ".rc") == 0)
        lang = langRC;
    else
        lang = langC;

    if ((pfile = fopen(szPath, "rt")) == NULL)
    {
        // fprintf(stderr, "Could not open file '%s'.\n", szPath);
        return NULL;
    }

    pfi = PfiAlloc(szPath, szName, fPathIsStd && fIgnoreStd, lang);

    if (lang == langRC)
    {
        //
        // Make sure we don't try to parse binary files - major waste of time!
        //
        static char *aszBinary[] = { ".ico", ".sqz", ".bmp", ".tlb", ".cur",
                                     ".odg", ".ppg", ".otb" };
        static int cBinary = sizeof(aszBinary)/sizeof(aszBinary[0]);
        int    i;

        if (!szSuffix)
        {
            if ((szSuffix = strrchr(szPath, '.')) == NULL)
                goto Cleanup;
        }

        for (i = cBinary; i && stricmp(szSuffix, aszBinary[i-1]); i--)
            ;

        if (i != 0)
            goto Cleanup;
    }

    // Don't search inside of the .PCH marker file
    if (!fIsPCHFile)
        {

        BLOCK
            {
            /* Push the directory of this file on the list of directories for
             * include searches.  Save an indication as to whether this include is
             * from a standard place.
             */
            char    szPathT[256];
            char    szNameT[256];

            CopyPath(szPathT, szPath);
            CopyPath(szNameT, szName);

            PushDir(szPathT, szNameT, fPathIsStd);
            }

        while ((sz = fgets(rgch, 256, pfile)) != NULL)
            {
            char *  szInc;
            BOOL    fThisDirNew = FALSE;    /* must be in this directory */
            int     cch = strlen(sz);

            if (cch < 2)
                continue;
            if (sz[cch-1] == '\n')
                sz[cch-1] = '\0';  /* note : will truncate long lines */

            if ((lang == langC && (szInc = SzIncludesC(sz, &fThisDirNew)) != NULL) ||
                (lang == langAsm && (szInc = SzIncludesAsm(sz)) != NULL) ||
                (lang == langRC && (szInc = SzIncludesRC(sz, &fThisDirNew)) != NULL))
                {
                FI *    pfiNew = NULL;
                char    szPathNew[256];
                char    szNameNew[256];
                BOOL    fIsPCH;

                fIsPCH = (szPCHFile && !_stricmp(szInc, szPCHFile));

                /* if file can be found in current directory, cycle
                 * through all current directories possible.
                 */
                if (fThisDirNew)
                    {
                    int     idi;
                    DI *    pdi;

                    for (idi = 0; (pdi = PdiFromIdi(idi)) != NULL; idi++)
                        {
                        MakeName(szPathNew, pdi->szPath, szInc);
                        MakeName(szNameNew, pdi->szName, szInc);

                        /* Do recursive call to include file */
                        pfiNew = PfiDependFn(szPathNew, szNameNew, pdi->fPathIsStd, lang, fIsPCH);

                        /* If we found it, get out of loop */
                        if (pfiNew != NULL)
                            break;
                        }
                    }

                /* If the file hasn't been found yet, look for it
                 * in the standard include directories.
                 */
                if (pfiNew == NULL)
                    {
                    int     isz;

                    for (isz = 0; isz < iszIncMac; isz++)
                        {
                        MakeName(szPathNew, rgszIncPath[isz], szInc);
                        MakeName(szNameNew, rgszIncName[isz], szInc);

                        /* Do recursive call to include file */
                        pfiNew = PfiDependFn(szPathNew, szNameNew, TRUE, lang, fIsPCH);

                        /* If we found it, mark it and get out of loop */
                        if (pfiNew != NULL)
                            break;
                        }
                    }

                /* The file doesn't exist anywhere.  If it was included
                 * with quote marks and the user didn't specify -n, we
                 * will pretend the file is in the same directory as
                 * the file that's including it.
                 */
                if (pfiNew == NULL && fThisDirNew && !fNoGenHeaders)
                    {
                    BOOL fPathIsStd;

                    if (fUseCurDir)
                        {
                        MakeName(szPathNew, ".\\", szInc);
                        MakeName(szNameNew, ".\\", szInc);
                        fPathIsStd = FALSE;

                        /* Look for -d names */
                        if ((pfiNew = PfiLookup(szPathNew, szNameNew,lang)) == NULL)
                            pfiNew = PfiAlloc(szPathNew, szNameNew, FALSE, lang);
                        }
                    else
                        {
                        DI *    pdi;

                        pdi = PdiFromIdi(0);
                        if (pdi == NULL)
                            Fatal("mkdep: internal error");
                        MakeName(szPathNew, pdi->szPath, szInc);
                        MakeName(szNameNew, pdi->szName, szInc);

                        // in this case we already look through existing FI list

                        pfiNew = PfiAlloc(szPathNew, szNameNew,
                            pdi->fPathIsStd && fIgnoreStd, lang);
                        }
                    }

                // If the .PCH marker file has been found, truncate all preceeding .H files
                if (pfiNew && fIsPCH)
                    {
                    FreeAllLk(pfi);
                    FreeFi(pfi->pfiNext);
                    pfi->pfiNext = NULL;
                    }

                /* If we found the file, add it to the list of files */
                if (pfiNew != NULL)
                    {
                    /* add if not already in list */
                    LK *    plk;
                    BOOL    fRedundant = FALSE;

                    for (plk = pfi->plkHead; plk != NULL;
                        plk = plk->plkNext)
                        {
                        if (plk->pfi == pfiNew)
                            {
                            fRedundant = TRUE;
                            break;
                            }
                        }
                    if (!fRedundant)
                        AllocLk(pfi, pfiNew);
                    }
                }
            }

        PopDir();
    }

Cleanup:
    fclose(pfile);
    return pfi;
    }



char *
SzIncludesC(sz, pfThisDir)
/*
  -- return file name of include file or NULL
  -- if returning non-NULL, set *pfThisDir if file should exist in this
    directory (i.e. #include "...").
*/
char *sz;
BOOL *pfThisDir;
    {
    char *szLine = sz;

    while (isspace(*sz))
        sz++;

    if (sz[0] == '#')
        {
        /* Allow space after '#' but before directive.
         */
        sz++;
        while (isspace(sz[0]))
            sz++;

        if (strncmp(sz, "include", 7) == 0)
            {
            /* found it */
            char *  pchEnd;

            sz += 7;
            while (isspace(*sz))
                sz++;
            if ((*sz == '<' && (pchEnd =strchr(sz+1,'>')) !=NULL) ||
                (*sz == '"' && (pchEnd =strchr(sz+1, '"')) !=NULL))
                {
                *pfThisDir = *sz == '"';
                *pchEnd = '\0';
                return sz+1;
                }
            else
                {
                fprintf(stderr, "mkdep: warning: ignoring line : %s\n", szLine);
                return NULL;
                }
            }
        }
    return NULL;
    }



char *
SzIncludesAsm(sz)
/*
  -- return file name of include file or NULL
*/
char *sz;
    {
    char *szLine = sz;

    strlwr(szLine);

    while (isspace(*sz))
        sz++;

    if (strncmp(sz, "include", 7) == 0)
        {
        /* found it */
        char *pchEnd;

        sz += 7;
        while (isspace(*sz))
            sz++;
        pchEnd = sz;
        while (*pchEnd && !isspace(*pchEnd) && *pchEnd != ';')
            pchEnd++;
        if (pchEnd == sz)
            {
            fprintf(stderr, "mkdep: warning: ignoring line : %s\n", szLine);
            return NULL;
            }
        *pchEnd = '\0';
        return sz;
        }
    return NULL;
    }

char *
SzIncludesRC(sz, pfThisDir)
/*
  -- return name of include file or resource file for an RC file
  -- if returning non-NULL, set *pfThisDir if file should exist in this
    directory (i.e. #include "...").
*/
char *sz;
BOOL *pfThisDir;
    {

    static char *aszValidTypes[] =
    {
        "CURSOR", "ICON", "RT_DOCFILE", "TYPELIB", "BITMAP"
    };
    static int cValidTypes = sizeof(aszValidTypes)/sizeof(aszValidTypes[0]);

    char   achIdent[255] = { 0 };
    char   achType[255]  = { 0 };
    char   achFile[255]  = { 0 };
    char * pch;
    int    cch;
    char * szC;
    int    n, i;

    szC = SzIncludesC(sz, pfThisDir);
    if (szC)
        return szC;

    *pfThisDir = TRUE;

    n = sscanf(sz, "%[a-zA-Z0-9_] %[a-zA-Z0-9_] %n%[a-zA-Z0-9.\"]",
               achIdent, achType, &cch, achFile);

    if (n < 3)
        return NULL;

    for (i = cValidTypes; i && stricmp(achType, aszValidTypes[i-1]); i--)
        ;

    if (i == 0)
        return NULL;

    sz += cch;

    while (isspace(*sz))
        sz++;

    sz[strlen(achFile)] = '\0';

    if (*sz == '\"')
        sz++;

    if ((pch = strrchr(sz, '\"')) != NULL)
        *pch = '\0';

    return sz;

    }



FI *
PfiLookup(szPath, szName, lang)
/*
  -- lookup name in current list of FI; if file is of an unknown language and
     lang is not, set the language of this file.
*/
char *  szPath;                 // path name to file
char *  szName;                 // official name of file
LANG    lang;                   // lang desired; langUnknown means any acceptible
    {
    FI *pfi;

    for (pfi = pfiHead; pfi != NULL; pfi = pfi->pfiNext)
        {
        if (strcmp(szPath, pfi->szPath) == 0)
            {
            /* got one */
            if (lang != langUnknown && lang != pfi->lang)
                {
                // want a specific language and that is not what the file is
                if (pfi->lang != langUnknown)
                    fprintf(stderr,
                        "mkdep: warning: language conflict for file %s\n",
                        pfi->szPath);
                else
                    pfi->lang = lang;               // was unknown, set to known
                }

            return pfi;
            }
        }

    return NULL;
    }



FI *
PfiAlloc(szPath, szName, fIgnore, lang)
/*
  -- allocate an FI
*/
char *  szPath;                 // path name to file
char *  szName;                 // official name of file
BOOL    fIgnore;                // true -> don't print this file
LANG    lang;                   // lang for file; can be langUnknown
    {
    FI *pfi;

    if ((pfi = (FI *) malloc(sizeof(FI))) == NULL ||
        (pfi->szName = strdup(szName)) == NULL ||
        (pfi->szPath = strdup(szPath)) == NULL)
        Fatal("out of memory");
    pfi->lang = lang;
    pfi->fIgnore = fIgnore;
    pfi->plkHead = pfi->plkTail = NULL;
    AddToList(pfi, pfiHead, pfiTail, pfiNext, NULL);
    pfi->cout = coutCur;
    return pfi;
    }


VOID
FreeFi(pfiFree)
/*
  -- free an FI and all associated LK and remove from FI list
*/
FI *pfiFree;
    {
    FI *pfiT, *pfiPrev;

    FreeAllLk(pfiFree);

    for (pfiT = pfiHead, pfiPrev = 0; pfiT != pfiFree; pfiPrev = pfiT, pfiT = pfiT->pfiNext)
        {
        // should find it on list
        // Assert(pfiT != NULL);
        }

    DeleteFromList(pfiFree, pfiHead, pfiTail, pfiNext, NULL, pfiPrev);

    free(pfiFree);
    }



VOID
AllocLk(pfiOwner, pfiNew)
/*
  -- allocate a LK - add to owner list - point to pfiNew
*/
FI *pfiOwner;
FI *pfiNew;
    {
    LK *plk;

    if ((plk = (LK *) malloc(sizeof(LK))) == NULL)
        Fatal("out of memory");
    plk->plkNext = NULL;
    AddToList(plk, pfiOwner->plkHead, pfiOwner->plkTail, plkNext, NULL);
    plk->pfi = pfiNew;
    }


VOID
FreeAllLk(pfi)
/*
  -- free all lk attached to FI
*/
FI *pfi;
    {
    LK *    plk;
    LK *    plkNext;

    for (plk = pfi->plkHead; plk != NULL; plk = plkNext)
        {
        plkNext = plk->plkNext;
        free(plk);
        }

    pfi->plkHead = NULL;
    pfi->plkTail = NULL;
    }



SZ
SzTransEnv(sz)
/*
  -- return a path string with optional $(...) in it
*/
SZ      sz;
    {
    SZ      szEnv;
    char *  pch;
    char    szT[256];

    if (sz[0] != '$' || sz[1] != '(')
        return sz;
    sz += 2;

    if ((pch = strchr(sz, ')')) == NULL)
        return sz;              // something wrong

    *pch = '\0';
    if ((szEnv = getenv(sz)) == NULL)
        {
        fprintf(stderr,
           "mkdep: warning: environment variable %s not defined\n");
        Fatal("incomplete path");
        }
    *pch = ')';             // restore string

    /* copy the environment variable into buffer */
    strcpy(szT, szEnv);
    strcat(szT, pch+1);             // and rest of string
    NormalizePath(szT);             // normalize again with new prefix
    return strdup(szT);
    }


VOID NormalizePath(sz)
/*
  -- convert path to a normal form in place: forward slashes, no ../, etc.
*/
char *sz;
    {
    char *pch, *pch2;

    /* change all backslashes to forward slashes */
    for (pch=sz; *pch; ++pch)
        if (*pch == '\\')
            *pch = '/';

    /* Remove ".." entries.  (The algorithm below doesn't find all
     * possible cases, but it's good enuff.)
     */
    while ((pch=strstr(sz, "/../")) != NULL)
        {
        *pch = '\0';
        pch2 = strrchr(sz, '/');
        if (pch2 != NULL && pch2[1] != '$' && pch2[1] != '.')
            memmove(pch2+1, pch+4, strlen(pch+1)+1);
        else
            {
            *pch = '/';
            break;
            }
        }

    // remove single . and leading ./
    if (sz[0] == '.')
        {
        if (sz[1] == '\0')
            sz[0] = '\0';

        else if (sz[1] == '/')
            memmove(sz, sz+2, strlen(sz)-2+1);
        }
    }


VOID
MakeName(szDest, szSrcPath, szSrcFile)
/*
  -- copy a path plus filename into a complete filename
  -- normalizes when done
*/
char *  szDest;                 // where to store complete filename
char *  szSrcPath;              // path
char *  szSrcFile;              // filename
    {
    if (szSrcFile[0] && szSrcFile[1]==':')
        {
        if (!(szSrcPath[0] && szSrcPath[1]==':') ||
            tolower(szSrcPath[0]) != tolower(szSrcFile[0]))
            {
            strcpy(szDest, szSrcFile);
            NormalizePath(szDest);
            return;
            }
        *szDest++ = *szSrcFile++;  *szDest++ = *szSrcFile++;
        }
    if (szSrcFile[0] == '/' || szSrcFile[0] == '\\')
        {
        strcpy(szDest, szSrcFile);
        NormalizePath(szDest);
        return;
        }

    strcpy(szDest, szSrcPath);
    if (szDest[0] != '\0')
        {
        char ch = szDest[strlen(szDest)-1];

        if (ch != ':' && ch != '/' && ch != '\\')
            strcat(szDest, "/");
        }
    strcat(szDest, szSrcFile);

    NormalizePath(szDest);
    }




VOID
CopyPath(szDestPath, szSrcFullName)
/*
  -- copy the path part of szSrcFullName into szDestPath
*/
char *  szDestPath;
char *  szSrcFullName;
    {
    int     ich;
    int     ichPathEnd;     // index to end of path part of szSrcFullName
    char    ch;

    /* Figure out where the path part of szSrcFullName ends and the
     * name part begins.
     */
    for (ich = ichPathEnd = 0; (ch=szSrcFullName[ich]) != 0; ++ich)
        if (ch == ':' || ch == '/' || ch == '\\')
            ichPathEnd = ich+1;

    /* Copy the path */
    for (ich = 0; ich < ichPathEnd; ++ich)
        szDestPath[ich] = szSrcFullName[ich];
    szDestPath[ich] = 0;
    }



VOID
PushDir(szPath, szName, fPathIsStd)
/*
  -- push a directory name on the stack of directories for all nested
     includes
*/
char *  szPath;                 // path name of file (e.g. "c:\foo\bar")
char *  szName;                 // official name of file (e.g. "$(INCL)")
BOOL    fPathIsStd;             // path portion of szPath is from standard includes (-I)
    {
    DI *    pdi;

    if ((pdi = malloc(sizeof(DI))) == NULL)
        Fatal("out of memory");
    pdi->szPath = strdup(szPath);
    pdi->szName = strdup(szName);
    pdi->fPathIsStd = fPathIsStd;
    /* Insert at head of list */
    pdi->pdiNext = pdiHead;
    pdiHead = pdi;
    }



VOID
PopDir(void)
/*
  -- pop a directory name from the stack of directories for all nested
     includes
*/
    {
    DI *pdiFree;

    if (pdiHead == NULL)
        Fatal("mkdep: internal error");

    pdiFree = pdiHead;
    pdiHead = pdiHead->pdiNext;

    free(pdiFree->szPath);
    free(pdiFree->szName);
    free(pdiFree);
    }



DI *
PdiFromIdi(idi)
/*
  -- return a pointer to one element from the stack, or NULL
*/
int     idi;                    // index of element to get (0 = top of stack)
    {
    DI *    pdi;

    for (pdi = pdiHead; pdi && idi; idi--)
        pdi = pdi->pdiNext;
    return pdi;
    }

int
AddIncludeDir(szFile)
char * szFile;
{
    if (iszIncMac+1 >= iszIncMax)
        {
        fprintf(stderr,
                "mkdep: warning"
                ": too many include directories"
                "; ignoring %s\n", szFile);
        return 0;
        }
    else
        {
        /* normal include */
        NormalizePath(szFile);
        rgszIncPath[iszIncMac] = SzTransEnv(szFile);
        rgszIncName[iszIncMac] = szFile;
        // fprintf(stderr,"Added include: %s\n",szFile);
        iszIncMac++;
        return 1;
        }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\tools\toolsrc\quadgrid\quadgrid.cpp ===
/*******************************************************************************
This program generates a gridded quadrilateral of given dimensions, and writes
the result as a VRML 1.0 or X-file formatted output stream.  The resultant
quadrilateral is in the XY plane, going from [-1,-1] to [+1,+1].
*******************************************************************************/

#include <stdio.h>
#include <stdlib.h>


void WriteVRML1 (int nrows, int ncols);
void WriteXFILE (int nrows, int ncols);

inline void print (char *string) { fputs (string, stdout); }



/*****************************************************************************
*****************************************************************************/

int main (int argc, char *argv[])
{
    enum { VRML, XFILE } filetype = VRML;

    int nrows = 0,
        ncols = 0;

    int argi;
    for (argi=1;  argi < argc;  ++argi)
    {
        if ((argv[argi][0] == '-') && (tolower(argv[argi][1]) == 'x'))
        {   filetype = XFILE;
            continue;
        }

        if (nrows == 0)
            nrows = atoi (argv[argi]);
        else
            ncols = atoi (argv[argi]);
    }

    if (nrows <= 0)
    {   fputs
        (   "quadgrid:  Generates VRML1 or X-file gridded quadrilateral\n"
            "Usage:     quadgrid [-x] <rows> [columns]\n"
            "\n"
            "If [columns] is omitted, quadgrid uses the number of rows.\n"
            "Use the -x option to generate X files.\n\n",
            stderr
        );
        exit (-1);
    }

    if (ncols == 0)
        ncols = nrows;

    if (filetype == VRML)
        WriteVRML1 (nrows, ncols);
    else
        WriteXFILE (nrows, ncols);

    return 0;
}



/*****************************************************************************
This procedure writes out a grid in VRML 1.0 format.
*****************************************************************************/

void WriteVRML1 (int nrows, int ncols)
{
    // VRML 1.0 Header

    printf (
        "#VRML V1.0 ascii\n\n"
        "Separator {\n"
        "Info { string "
            "\"%d x %d gridded quadrilateral generated by quadgrid.\""
        " }\n",
        nrows, ncols
    );

    // Write out the vertex coordinates.

    print ("\nCoordinate3 { point [\n");

    //   N   2N        3N     ... (N+1)(M+1)-1  This is the vertex indexing
    //   :    :         :              :        for the generated grid layout.
    //   3  (N+1)+3  2(N+1)+3 ...   M(N+1)+3    This contains (N+1)(M+1)
    //   2  (N+1)+2  2(N+1)+2 ...   M(N+1)+2    vertices, NM quadrilaterals,
    //   1  (N+1)+1  2(N+1)+1       M(N+1)+1    and 2NM triangles.
    //   0  (N+1)    2(N+1)   ...   M(N+1)

    int row, col;

    for (col=0;  col <= ncols;  ++col)
    {   for (row=0;  row <= nrows;  ++row)
        {   printf ("\t% g\t% g\t0,\n",
                (((col / double(ncols)) * 2) - 1),
                (((row / double(nrows)) * 2) - 1));
        }
    }

    print ("] } # Coordinate3\n");

    // Write out the texture coordinates.

    print ("\nTextureCoordinate2 { point [\n");

    for (col=0;  col <= ncols;  ++col)
    {   for (row=0;  row <= nrows;  ++row)
        {   printf ("\t%g\t%g,\n",
                (col / double (ncols)),
                (row / double (nrows)));
        }
    }

    print ("] } # TextureCoordinate2\n");

    // Write out the normal vectors.

    print
    (   "\nNormal { vector [0 0 1] }\n"
        "NormalBinding { value OVERALL }\n"
    );

    // Lay out triangles column by column.

    print ("\nIndexedFaceSet { coordIndex [\n");

    int left  = 0;         // Lower Left  Vertex Index
    int right = 1+nrows;   // Lower Right Vertex Index

    for (col=0;  col < ncols;  ++col, ++left, ++right)
    {   for (row=0;  row < nrows;  ++row, ++left, ++right)
        {   printf ("\t%d,\t%d,\t%d,\t-1,\n", left, right, right+1);
            printf ("\t%d,\t%d,\t%d,\t-1,\n", left, right+1, left+1);
        }
    }

    // Epilogue

    print
    (   "] } # IndexedFaceSet\n"
        "\n} # Separator\n"
    );
}



/*****************************************************************************
This procedure writes out a grid in X-file format.
*****************************************************************************/

void WriteXFILE (int nrows, int ncols)
{
    int nverts = (nrows+1) * (ncols+1);

    // Header

    printf
    (   "xof 0302txt 0032\n\n"
        "# %d x %d gridded quadrilateral generated by 'quadgrid'\n\n"
        "Header { 1;0;1; }\n\n"
        "Mesh {\n\n",
        nrows, ncols
    );

    // Write out the vertex coordinates.

    print ("# Vertex Coordinates\n\n");

    //   N   2N        3N     ... (N+1)(M+1)-1  This is the vertex indexing
    //   :    :         :              :        for the generated grid layout.
    //   3  (N+1)+3  2(N+1)+3 ...   M(N+1)+3    This contains (N+1)(M+1)
    //   2  (N+1)+2  2(N+1)+2 ...   M(N+1)+2    vertices, NM quadrilaterals,
    //   1  (N+1)+1  2(N+1)+1       M(N+1)+1    and 2NM triangles.
    //   0  (N+1)    2(N+1)   ...   M(N+1)

    printf ("%d;\n", nverts);

    int row, col;

    for (col=0;  col <= ncols;  ++col)
    {
        for (row=0;  row <= nrows;  ++row)
        {
            if (col || row) print (",\n");

            printf ("% f; % f; 0.0;",
                (((col / double(ncols)) * 2) - 1),
                (((row / double(nrows)) * 2) - 1));
        }
    }

    print (";\n\n");

    // Face Coordinate Indices

    printf ("# Faces\n\n%d;\n", 2 * nrows * ncols);

    int left  = 0;         // Lower Left  Vertex Index
    int right = 1+nrows;   // Lower Right Vertex Index

    for (col=0;  col < ncols;  ++col, ++left, ++right)
    {   for (row=0;  row < nrows;  ++row, ++left, ++right)
        {   if (row || col) print (",\n");
            printf ("3;%4d,%4d,%4d;,\n", left, right+1, right);
            printf ("3;%4d,%4d,%4d;",    left, left+1,  right+1);
        }
    }

    print (";\n\n");

    // Write out the texture coordinates.

    printf ("MeshTextureCoords { \n\t%d;\n", nverts);

    for (col=0;  col <= ncols;  ++col)
    {   for (row=0;  row <= nrows;  ++row)
        {   printf ("%s\t%.4f; %.4f;",
                ((row || col) ? ",\n" : ""),
                (col / double (ncols)),
                (row / double (nrows)));
        }
    }

    print (";\n}\n\n");

    // Write out default material

    print
    (   "MeshMaterialList {\n"
        "	# Diffuse White\n"
        "	1;1;0;;\n"
        "	Material {\n"
        "		1.0; 1.0; 1.0; 1.0;;\n"
        "		1.0;\n"
        "		0.0; 0.0; 0.0;\n"
        "		0.0; 0.0; 0.0;\n"
        "	}\n"
        "}\n\n"
    );

    // Write out the normal vectors.

    print ("MeshNormals {\n\t1;\n\t0.0; 0.0; -1.0;;\n\n");

    // Face Normal Indices

    printf ("\t%d;\n", 2 * nrows * ncols);

    int i;
    for (i=0;  i < (2*nrows*ncols);  ++i)
        printf ("%s\t3;0,0,0;", (i ? ",\n" : ""));

    print (";\n}\n");

    // Epilogue

    print ("\n}\n");
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\types\idl\primtype.h ===
interface IDABoolean;
    interface IDACamera;
    interface IDAColor;
    interface IDAGeometry;
    interface IDAImage;
    interface IDAMatte;
    interface IDAMicrophone;
    interface IDAMontage;
    interface IDANumber;
    interface IDAPath2;
    interface IDAPoint2;
    interface IDAPoint3;
    interface IDASound;
    interface IDAString;
    interface IDATransform2;
    interface IDATransform3;
    interface IDAVector2;
    interface IDAVector3;
    interface IDAFontStyle;
    interface IDALineStyle;
    interface IDAEndStyle;
    interface IDAJoinStyle;
    interface IDADashStyle;
    interface IDABbox2;
    interface IDABbox3;
    interface IDAPair;
    interface IDAEvent;
    interface IDAArray;
    interface IDATuple;
    interface IDAUserData;

    // ====================================
    // IDABoolean interface definition
    // ====================================

    [
        uuid(C46C1BC0-3C52-11d0-9200-848C1D000000),
        helpstring("DirectAnimation Boolean Behavior"),
        local,
        object,
        pointer_default(unique),
        oleautomation,
        hidden,
        dual
    ]
    interface IDABoolean : IDABehavior
    {
        HRESULT Extract ([out, retval] VARIANT_BOOL * ret_0) ;

    }

    // ====================================
    // IDACamera interface definition
    // ====================================

    [
        uuid(C46C1BE1-3C52-11d0-9200-848C1D000000),
        helpstring("DirectAnimation Camera Behavior"),
        local,
        object,
        pointer_default(unique),
        oleautomation,
        hidden,
        dual
    ]
    interface IDACamera : IDABehavior
    {
        HRESULT Transform ([in] IDATransform3 * xf_0, [out, retval] IDACamera * * ret_1) ;
        HRESULT Depth ([in] double depth_0, [out, retval] IDACamera * * ret_1) ;
        HRESULT DepthAnim ([in] IDANumber * depth_0, [out, retval] IDACamera * * ret_1) ;
        HRESULT DepthResolution ([in] double resolution_0, [out, retval] IDACamera * * ret_1) ;
        HRESULT DepthResolutionAnim ([in] IDANumber * resolution_0, [out, retval] IDACamera * * ret_1) ;

    }

    // ====================================
    // IDAColor interface definition
    // ====================================

    [
        uuid(C46C1BC5-3C52-11d0-9200-848C1D000000),
        helpstring("DirectAnimation Color Behavior"),
        local,
        object,
        pointer_default(unique),
        oleautomation,
        hidden,
        dual
    ]
    interface IDAColor : IDABehavior
    {
        [propget] HRESULT Red ([out, retval] IDANumber * * ret_0) ;
        [propget] HRESULT Green ([out, retval] IDANumber * * ret_0) ;
        [propget] HRESULT Blue ([out, retval] IDANumber * * ret_0) ;
        [propget] HRESULT Hue ([out, retval] IDANumber * * ret_0) ;
        [propget] HRESULT Saturation ([out, retval] IDANumber * * ret_0) ;
        [propget] HRESULT Lightness ([out, retval] IDANumber * * ret_0) ;

    }

    // ====================================
    // IDAGeometry interface definition
    // ====================================

    [
        uuid(C46C1BDF-3C52-11d0-9200-848C1D000000),
        helpstring("DirectAnimation Geometry Behavior"),
        local,
        object,
        pointer_default(unique),
        oleautomation,
        hidden,
        dual
    ]
    interface IDAGeometry : IDABehavior
    {
        HRESULT RenderSound ([in] IDAMicrophone * mic_0, [out, retval] IDASound * * ret_1) ;
        HRESULT Pickable ([out, retval] IDAPickableResult * * ret_0) ;
        HRESULT PickableOccluded ([out, retval] IDAPickableResult * * ret_0) ;
        HRESULT Undetectable ([out, retval] IDAGeometry * * ret_0) ;
        HRESULT EmissiveColor ([in] IDAColor * col_0, [out, retval] IDAGeometry * * ret_1) ;
        HRESULT DiffuseColor ([in] IDAColor * col_0, [out, retval] IDAGeometry * * ret_1) ;
        HRESULT SpecularColor ([in] IDAColor * col_0, [out, retval] IDAGeometry * * ret_1) ;
        HRESULT SpecularExponent ([in] double power_0, [out, retval] IDAGeometry * * ret_1) ;
        HRESULT SpecularExponentAnim ([in] IDANumber * power_0, [out, retval] IDAGeometry * * ret_1) ;
        HRESULT Texture ([in] IDAImage * texture_0, [out, retval] IDAGeometry * * ret_1) ;
        HRESULT Opacity ([in] double level_0, [out, retval] IDAGeometry * * ret_1) ;
        HRESULT OpacityAnim ([in] IDANumber * level_0, [out, retval] IDAGeometry * * ret_1) ;
        HRESULT Transform ([in] IDATransform3 * xf_0, [out, retval] IDAGeometry * * ret_1) ;
        [propget] HRESULT BoundingBox ([out, retval] IDABbox3 * * ret_0) ;
        HRESULT Render ([in] IDACamera * cam_0, [out, retval] IDAImage * * ret_1) ;
        HRESULT LightColor ([in] IDAColor * color_0, [out, retval] IDAGeometry * * ret_1) ;
        HRESULT LightAttenuationAnim ([in] IDANumber * constant_0, [in] IDANumber * linear_1, [in] IDANumber * quadratic_2, [out, retval] IDAGeometry * * ret_3) ;
        HRESULT LightAttenuation ([in] double constant_0, [in] double linear_1, [in] double quadratic_2, [out, retval] IDAGeometry * * ret_3) ;

    }

    // ====================================
    // IDAImage interface definition
    // ====================================

    [
        uuid(C46C1BD3-3C52-11d0-9200-848C1D000000),
        helpstring("DirectAnimation Image Behavior"),
        local,
        object,
        pointer_default(unique),
        oleautomation,
        hidden,
        dual
    ]
    interface IDAImage : IDABehavior
    {
        HRESULT Pickable ([out, retval] IDAPickableResult * * ret_0) ;
        HRESULT PickableOccluded ([out, retval] IDAPickableResult * * ret_0) ;
        HRESULT ApplyBitmapEffect ([in] IUnknown * effectToApply_0, [in] IDAEvent * firesWhenChanged_1, [out, retval] IDAImage * * ret_2) ;
        [propget] HRESULT BoundingBox ([out, retval] IDABbox2 * * ret_0) ;
        HRESULT Crop ([in] IDAPoint2 * min_0, [in] IDAPoint2 * max_1, [out, retval] IDAImage * * ret_2) ;
        HRESULT Transform ([in] IDATransform2 * xf_0, [out, retval] IDAImage * * ret_1) ;
        HRESULT OpacityAnim ([in] IDANumber * opacity_0, [out, retval] IDAImage * * ret_1) ;
        HRESULT Opacity ([in] double opacity_0, [out, retval] IDAImage * * ret_1) ;
        HRESULT Undetectable ([out, retval] IDAImage * * ret_0) ;
        HRESULT Tile ([out, retval] IDAImage * * ret_0) ;
        HRESULT Clip ([in] IDAMatte * m_0, [out, retval] IDAImage * * ret_1) ;
        HRESULT MapToUnitSquare ([out, retval] IDAImage * * ret_0) ;
        HRESULT ClipPolygonImageEx ([in] LONG points_0size, [in,size_is(points_0size)] IDAPoint2 * points_0[], [out, retval] IDAImage * * ret_1) ;
        HRESULT ClipPolygonImage ([in] VARIANT points_0, [out, retval] IDAImage * * ret_1) ;

    }

    // ====================================
    // IDAMatte interface definition
    // ====================================

    [
        uuid(C46C1BD1-3C52-11d0-9200-848C1D000000),
        helpstring("DirectAnimation Matte Behavior"),
        local,
        object,
        pointer_default(unique),
        oleautomation,
        hidden,
        dual
    ]
    interface IDAMatte : IDABehavior
    {
        HRESULT Transform ([in] IDATransform2 * xf_0, [out, retval] IDAMatte * * ret_1) ;

    }

    // ====================================
    // IDAMicrophone interface definition
    // ====================================

    [
        uuid(C46C1BE5-3C52-11d0-9200-848C1D000000),
        helpstring("DirectAnimation Microphone Behavior"),
        local,
        object,
        pointer_default(unique),
        oleautomation,
        hidden,
        dual
    ]
    interface IDAMicrophone : IDABehavior
    {
        HRESULT Transform ([in] IDATransform3 * xf_0, [out, retval] IDAMicrophone * * ret_1) ;

    }

    // ====================================
    // IDAMontage interface definition
    // ====================================

    [
        uuid(C46C1BD5-3C52-11d0-9200-848C1D000000),
        helpstring("DirectAnimation Montage Behavior"),
        local,
        object,
        pointer_default(unique),
        oleautomation,
        hidden,
        dual
    ]
    interface IDAMontage : IDABehavior
    {
        HRESULT Render ([out, retval] IDAImage * * ret_0) ;

    }

    // ====================================
    // IDANumber interface definition
    // ====================================

    [
        uuid(9CDE7340-3C20-11d0-A330-00AA00B92C03),
        helpstring("DirectAnimation Number Behavior"),
        local,
        object,
        pointer_default(unique),
        oleautomation,
        hidden,
        dual
    ]
    interface IDANumber : IDABehavior
    {
        HRESULT Extract ([out, retval] double * ret_0) ;
        HRESULT AnimateProperty ([in] BSTR propertyPath_0, [in] BSTR scriptingLanguage_1, [in] VARIANT_BOOL invokeAsMethod_2, [in] double minUpdateInterval_3, [out, retval] IDANumber * * ret_4) ;
        HRESULT ToStringAnim ([in] IDANumber * precision_0, [out, retval] IDAString * * ret_1) ;
        HRESULT ToString ([in] double precision_0, [out, retval] IDAString * * ret_1) ;

    }

    // ====================================
    // IDAPath2 interface definition
    // ====================================

    [
        uuid(C46C1BCF-3C52-11d0-9200-848C1D000000),
        helpstring("DirectAnimation Path2 Behavior"),
        local,
        object,
        pointer_default(unique),
        oleautomation,
        hidden,
        dual
    ]
    interface IDAPath2 : IDABehavior
    {
        HRESULT Transform ([in] IDATransform2 * xf_0, [out, retval] IDAPath2 * * ret_1) ;
        HRESULT BoundingBox ([in] IDALineStyle * style_0, [out, retval] IDABbox2 * * ret_1) ;
        HRESULT Fill ([in] IDALineStyle * border_0, [in] IDAImage * fill_1, [out, retval] IDAImage * * ret_2) ;
        HRESULT Draw ([in] IDALineStyle * border_0, [out, retval] IDAImage * * ret_1) ;
        HRESULT Close ([out, retval] IDAPath2 * * ret_0) ;

    }

    // ====================================
    // IDAPoint2 interface definition
    // ====================================

    [
        uuid(C46C1BC7-3C52-11d0-9200-848C1D000000),
        helpstring("DirectAnimation Point2 Behavior"),
        local,
        object,
        pointer_default(unique),
        oleautomation,
        hidden,
        dual
    ]
    interface IDAPoint2 : IDABehavior
    {
        HRESULT AnimateControlPosition ([in] BSTR propertyPath_0, [in] BSTR scriptingLanguage_1, [in] VARIANT_BOOL invokeAsMethod_2, [in] double minUpdateInterval_3, [out, retval] IDAPoint2 * * ret_4) ;
        HRESULT AnimateControlPositionPixel ([in] BSTR propertyPath_0, [in] BSTR scriptingLanguage_1, [in] VARIANT_BOOL invokeAsMethod_2, [in] double minUpdateInterval_3, [out, retval] IDAPoint2 * * ret_4) ;
        [propget] HRESULT X ([out, retval] IDANumber * * ret_0) ;
        [propget] HRESULT Y ([out, retval] IDANumber * * ret_0) ;
        [propget] HRESULT PolarCoordAngle ([out, retval] IDANumber * * ret_0) ;
        [propget] HRESULT PolarCoordLength ([out, retval] IDANumber * * ret_0) ;
        HRESULT Transform ([in] IDATransform2 * xf_0, [out, retval] IDAPoint2 * * ret_1) ;

    }

    // ====================================
    // IDAPoint3 interface definition
    // ====================================

    [
        uuid(C46C1BD7-3C52-11d0-9200-848C1D000000),
        helpstring("DirectAnimation Point3 Behavior"),
        local,
        object,
        pointer_default(unique),
        oleautomation,
        hidden,
        dual
    ]
    interface IDAPoint3 : IDABehavior
    {
        HRESULT Project ([in] IDACamera * cam_0, [out, retval] IDAPoint2 * * ret_1) ;
        [propget] HRESULT X ([out, retval] IDANumber * * ret_0) ;
        [propget] HRESULT Y ([out, retval] IDANumber * * ret_0) ;
        [propget] HRESULT Z ([out, retval] IDANumber * * ret_0) ;
        [propget] HRESULT SphericalCoordXYAngle ([out, retval] IDANumber * * ret_0) ;
        [propget] HRESULT SphericalCoordYZAngle ([out, retval] IDANumber * * ret_0) ;
        [propget] HRESULT SphericalCoordLength ([out, retval] IDANumber * * ret_0) ;
        HRESULT Transform ([in] IDATransform3 * xf_0, [out, retval] IDAPoint3 * * ret_1) ;

    }

    // ====================================
    // IDASound interface definition
    // ====================================

    [
        uuid(C46C1BE3-3C52-11d0-9200-848C1D000000),
        helpstring("DirectAnimation Sound Behavior"),
        local,
        object,
        pointer_default(unique),
        oleautomation,
        hidden,
        dual
    ]
    interface IDASound : IDABehavior
    {
        HRESULT PhaseAnim ([in] IDANumber * phaseAmt_0, [out, retval] IDASound * * ret_1) ;
        HRESULT Phase ([in] double phaseAmt_0, [out, retval] IDASound * * ret_1) ;
        HRESULT RateAnim ([in] IDANumber * pitchShift_0, [out, retval] IDASound * * ret_1) ;
        HRESULT Rate ([in] double pitchShift_0, [out, retval] IDASound * * ret_1) ;
        HRESULT PanAnim ([in] IDANumber * panAmt_0, [out, retval] IDASound * * ret_1) ;
        HRESULT Pan ([in] double panAmt_0, [out, retval] IDASound * * ret_1) ;
        HRESULT GainAnim ([in] IDANumber * gainAmt_0, [out, retval] IDASound * * ret_1) ;
        HRESULT Gain ([in] double gainAmt_0, [out, retval] IDASound * * ret_1) ;
        HRESULT Loop ([out, retval] IDASound * * ret_0) ;

    }

    // ====================================
    // IDAString interface definition
    // ====================================

    [
        uuid(C46C1BC3-3C52-11d0-9200-848C1D000000),
        helpstring("DirectAnimation String Behavior"),
        local,
        object,
        pointer_default(unique),
        oleautomation,
        hidden,
        dual
    ]
    interface IDAString : IDABehavior
    {
        HRESULT Extract ([out, retval] BSTR * ret_0) ;
        HRESULT AnimateProperty ([in] BSTR propertyPath_0, [in] BSTR scriptingLanguage_1, [in] VARIANT_BOOL invokeAsMethod_2, [in] double minUpdateInterval_3, [out, retval] IDAString * * ret_4) ;

    }

    // ====================================
    // IDATransform2 interface definition
    // ====================================

    [
        uuid(C46C1BCB-3C52-11d0-9200-848C1D000000),
        helpstring("DirectAnimation Transform2 Behavior"),
        local,
        object,
        pointer_default(unique),
        oleautomation,
        hidden,
        dual
    ]
    interface IDATransform2 : IDABehavior
    {
        HRESULT Inverse ([out, retval] IDATransform2 * * ret_0) ;
        [propget] HRESULT IsSingular ([out, retval] IDABoolean * * ret_0) ;

    }

    // ====================================
    // IDATransform3 interface definition
    // ====================================

    [
        uuid(C46C1BDB-3C52-11d0-9200-848C1D000000),
        helpstring("DirectAnimation Transform3 Behavior"),
        local,
        object,
        pointer_default(unique),
        oleautomation,
        hidden,
        dual
    ]
    interface IDATransform3 : IDABehavior
    {
        HRESULT Inverse ([out, retval] IDATransform3 * * ret_0) ;
        [propget] HRESULT IsSingular ([out, retval] IDABoolean * * ret_0) ;
        HRESULT ParallelTransform2 ([out, retval] IDATransform2 * * ret_0) ;

    }

    // ====================================
    // IDAVector2 interface definition
    // ====================================

    [
        uuid(C46C1BC9-3C52-11d0-9200-848C1D000000),
        helpstring("DirectAnimation Vector2 Behavior"),
        local,
        object,
        pointer_default(unique),
        oleautomation,
        hidden,
        dual
    ]
    interface IDAVector2 : IDABehavior
    {
        [propget] HRESULT Length ([out, retval] IDANumber * * ret_0) ;
        [propget] HRESULT LengthSquared ([out, retval] IDANumber * * ret_0) ;
        HRESULT Normalize ([out, retval] IDAVector2 * * ret_0) ;
        HRESULT MulAnim ([in] IDANumber * scalar_0, [out, retval] IDAVector2 * * ret_1) ;
        HRESULT Mul ([in] double scalar_0, [out, retval] IDAVector2 * * ret_1) ;
        HRESULT DivAnim ([in] IDANumber * scalar_0, [out, retval] IDAVector2 * * ret_1) ;
        HRESULT Div ([in] double scalar_0, [out, retval] IDAVector2 * * ret_1) ;
        [propget] HRESULT X ([out, retval] IDANumber * * ret_0) ;
        [propget] HRESULT Y ([out, retval] IDANumber * * ret_0) ;
        [propget] HRESULT PolarCoordAngle ([out, retval] IDANumber * * ret_0) ;
        [propget] HRESULT PolarCoordLength ([out, retval] IDANumber * * ret_0) ;
        HRESULT Transform ([in] IDATransform2 * xf_0, [out, retval] IDAVector2 * * ret_1) ;

    }

    // ====================================
    // IDAVector3 interface definition
    // ====================================

    [
        uuid(C46C1BD9-3C52-11d0-9200-848C1D000000),
        helpstring("DirectAnimation Vector3 Behavior"),
        local,
        object,
        pointer_default(unique),
        oleautomation,
        hidden,
        dual
    ]
    interface IDAVector3 : IDABehavior
    {
        [propget] HRESULT Length ([out, retval] IDANumber * * ret_0) ;
        [propget] HRESULT LengthSquared ([out, retval] IDANumber * * ret_0) ;
        HRESULT Normalize ([out, retval] IDAVector3 * * ret_0) ;
        HRESULT MulAnim ([in] IDANumber * scalar_0, [out, retval] IDAVector3 * * ret_1) ;
        HRESULT Mul ([in] double scalar_0, [out, retval] IDAVector3 * * ret_1) ;
        HRESULT DivAnim ([in] IDANumber * scalar_0, [out, retval] IDAVector3 * * ret_1) ;
        HRESULT Div ([in] double scalar_0, [out, retval] IDAVector3 * * ret_1) ;
        [propget] HRESULT X ([out, retval] IDANumber * * ret_0) ;
        [propget] HRESULT Y ([out, retval] IDANumber * * ret_0) ;
        [propget] HRESULT Z ([out, retval] IDANumber * * ret_0) ;
        [propget] HRESULT SphericalCoordXYAngle ([out, retval] IDANumber * * ret_0) ;
        [propget] HRESULT SphericalCoordYZAngle ([out, retval] IDANumber * * ret_0) ;
        [propget] HRESULT SphericalCoordLength ([out, retval] IDANumber * * ret_0) ;
        HRESULT Transform ([in] IDATransform3 * xf_0, [out, retval] IDAVector3 * * ret_1) ;

    }

    // ====================================
    // IDAFontStyle interface definition
    // ====================================

    [
        uuid(25B0F91D-D23D-11d0-9B85-00C04FC2F51D),
        helpstring("DirectAnimation FontStyle Behavior"),
        local,
        object,
        pointer_default(unique),
        oleautomation,
        hidden,
        dual
    ]
    interface IDAFontStyle : IDABehavior
    {
        HRESULT Bold ([out, retval] IDAFontStyle * * ret_0) ;
        HRESULT Italic ([out, retval] IDAFontStyle * * ret_0) ;
        HRESULT Underline ([out, retval] IDAFontStyle * * ret_0) ;
        HRESULT Strikethrough ([out, retval] IDAFontStyle * * ret_0) ;
        HRESULT AntiAliasing ([in] double aaStyle_0, [out, retval] IDAFontStyle * * ret_1) ;
        HRESULT Color ([in] IDAColor * col_0, [out, retval] IDAFontStyle * * ret_1) ;
        HRESULT FamilyAnim ([in] IDAString * face_0, [out, retval] IDAFontStyle * * ret_1) ;
        HRESULT Family ([in] BSTR face_0, [out, retval] IDAFontStyle * * ret_1) ;
        HRESULT SizeAnim ([in] IDANumber * size_0, [out, retval] IDAFontStyle * * ret_1) ;
        HRESULT Size ([in] double size_0, [out, retval] IDAFontStyle * * ret_1) ;
        HRESULT Weight ([in] double weight_0, [out, retval] IDAFontStyle * * ret_1) ;
        HRESULT WeightAnim ([in] IDANumber * weight_0, [out, retval] IDAFontStyle * * ret_1) ;

    }

    // ====================================
    // IDALineStyle interface definition
    // ====================================

    [
        uuid(C46C1BF1-3C52-11d0-9200-848C1D000000),
        helpstring("DirectAnimation LineStyle Behavior"),
        local,
        object,
        pointer_default(unique),
        oleautomation,
        hidden,
        dual
    ]
    interface IDALineStyle : IDABehavior
    {
        HRESULT End ([in] IDAEndStyle * sty_0, [out, retval] IDALineStyle * * ret_1) ;
        HRESULT Join ([in] IDAJoinStyle * sty_0, [out, retval] IDALineStyle * * ret_1) ;
        HRESULT Dash ([in] IDADashStyle * sty_0, [out, retval] IDALineStyle * * ret_1) ;
        HRESULT WidthAnim ([in] IDANumber * sty_0, [out, retval] IDALineStyle * * ret_1) ;
        HRESULT width ([in] double sty_0, [out, retval] IDALineStyle * * ret_1) ;
        HRESULT AntiAliasing ([in] double aaStyle_0, [out, retval] IDALineStyle * * ret_1) ;
        HRESULT Detail ([out, retval] IDALineStyle * * ret_0) ;
        HRESULT Color ([in] IDAColor * clr_0, [out, retval] IDALineStyle * * ret_1) ;

    }

    // ====================================
    // IDAEndStyle interface definition
    // ====================================

    [
        uuid(C46C1BEB-3C52-11d0-9200-848C1D000000),
        helpstring("DirectAnimation EndStyle Behavior"),
        local,
        object,
        pointer_default(unique),
        oleautomation,
        hidden,
        dual
    ]
    interface IDAEndStyle : IDABehavior
    {

    }

    // ====================================
    // IDAJoinStyle interface definition
    // ====================================

    [
        uuid(C46C1BED-3C52-11d0-9200-848C1D000000),
        helpstring("DirectAnimation JoinStyle Behavior"),
        local,
        object,
        pointer_default(unique),
        oleautomation,
        hidden,
        dual
    ]
    interface IDAJoinStyle : IDABehavior
    {

    }

    // ====================================
    // IDADashStyle interface definition
    // ====================================

    [
        uuid(C46C1BEF-3C52-11d0-9200-848C1D000000),
        helpstring("DirectAnimation DashStyle Behavior"),
        local,
        object,
        pointer_default(unique),
        oleautomation,
        hidden,
        dual
    ]
    interface IDADashStyle : IDABehavior
    {

    }

    // ====================================
    // IDABbox2 interface definition
    // ====================================

    [
        uuid(C46C1BCD-3C52-11d0-9200-848C1D000000),
        helpstring("DirectAnimation Bbox2 Behavior"),
        local,
        object,
        pointer_default(unique),
        oleautomation,
        hidden,
        dual
    ]
    interface IDABbox2 : IDABehavior
    {
        [propget] HRESULT Min ([out, retval] IDAPoint2 * * ret_0) ;
        [propget] HRESULT Max ([out, retval] IDAPoint2 * * ret_0) ;

    }

    // ====================================
    // IDABbox3 interface definition
    // ====================================

    [
        uuid(C46C1BDD-3C52-11d0-9200-848C1D000000),
        helpstring("DirectAnimation Bbox3 Behavior"),
        local,
        object,
        pointer_default(unique),
        oleautomation,
        hidden,
        dual
    ]
    interface IDABbox3 : IDABehavior
    {
        [propget] HRESULT Min ([out, retval] IDAPoint3 * * ret_0) ;
        [propget] HRESULT Max ([out, retval] IDAPoint3 * * ret_0) ;

    }

    // ====================================
    // IDAPair interface definition
    // ====================================

    [
        uuid(C46C1BF3-3C52-11d0-9200-848C1D000000),
        helpstring("DirectAnimation Pair Behavior"),
        local,
        object,
        pointer_default(unique),
        oleautomation,
        hidden,
        dual
    ]
    interface IDAPair : IDABehavior
    {
        [propget] HRESULT First ([out, retval] IDABehavior * * ret_0) ;
        [propget] HRESULT Second ([out, retval] IDABehavior * * ret_0) ;

    }

    // ====================================
    // IDAEvent interface definition
    // ====================================

    [
        uuid(50B4791E-4731-11d0-8912-00C04FC2A0CA),
        helpstring("DirectAnimation Event Behavior"),
        local,
        object,
        pointer_default(unique),
        oleautomation,
        hidden,
        dual
    ]
    interface IDAEvent : IDABehavior
    {
        HRESULT Notify ([in] IDAUntilNotifier * notifier_0, [out, retval] IDAEvent * * ret_1) ;
        HRESULT Snapshot ([in] IDABehavior * b_0, [out, retval] IDAEvent * * ret_1) ;
        HRESULT AttachData ([in] IDABehavior * data_0, [out, retval] IDAEvent * * ret_1) ;
        HRESULT ScriptCallback ([in] BSTR scriptlet_0, [in] BSTR language_1, [out, retval] IDAEvent * * ret_2) ;

    }

    // ====================================
    // IDAArray interface definition
    // ====================================

    [
        uuid(D17506C2-6B26-11d0-8914-00C04FC2A0CA),
        helpstring("DirectAnimation Array Behavior"),
        local,
        object,
        pointer_default(unique),
        oleautomation,
        hidden,
        dual
    ]
    interface IDAArray : IDABehavior
    {
        HRESULT NthAnim ([in] IDANumber * index_0, [out, retval] IDABehavior * * ret_1) ;
        HRESULT Length ([out, retval] IDANumber * * ret_0) ;

    }

    // ====================================
    // IDATuple interface definition
    // ====================================

    [
        uuid(5DFB2650-9668-11d0-B17B-00C04FC2A0CA),
        helpstring("DirectAnimation Tuple Behavior"),
        local,
        object,
        pointer_default(unique),
        oleautomation,
        hidden,
        dual
    ]
    interface IDATuple : IDABehavior
    {
        HRESULT Nth ([in] long index_0, [out, retval] IDABehavior * * ret_1) ;
        [propget] HRESULT Length ([out, retval] long * ret_0) ;

    }

    // ====================================
    // IDAUserData interface definition
    // ====================================

    [
        uuid(AF868305-AB0B-11d0-876A-00C04FC29D46),
        helpstring("DirectAnimation Userdata Behavior"),
        local,
        object,
        pointer_default(unique),
        oleautomation,
        hidden,
        dual
    ]
    interface IDAUserData : IDABehavior
    {
        [propget] HRESULT Data ([out, retval] IUnknown * * ret_0) ;

    }
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\tools\x86\aactive\lib\msimus_i.c ===
/* this file contains the actual definitions of */
/* the IIDs and CLSIDs */

/* link this file in with the server and any clients */


/* File created by MIDL compiler version 3.00.44 */
/* at Fri Nov 08 14:45:43 1996
 */
/* Compiler settings for MSIMusic.odl:
    Os (OptLev=s), W1, Zp8, env=Win32, ms_ext, c_ext
    error checks: none
*/
//@@MIDL_FILE_HEADING(  )
#ifdef __cplusplus
extern "C"{
#endif 


#ifndef __IID_DEFINED__
#define __IID_DEFINED__

typedef struct _IID
{
    unsigned long x;
    unsigned short s1;
    unsigned short s2;
    unsigned char  c[8];
} IID;

#endif // __IID_DEFINED__

#ifndef CLSID_DEFINED
#define CLSID_DEFINED
typedef IID CLSID;
#endif // CLSID_DEFINED

const IID LIBID_AudioActive = {0xBCE4CC3f,0x2F1A,0x11CF,{0xBF,0x16,0x00,0xAA,0x00,0xC0,0x81,0x46}};


const IID IID_IAABand = {0xBCE4CC4e,0x2F1A,0x11CF,{0xBF,0x16,0x00,0xAA,0x00,0xC0,0x81,0x46}};


const IID IID_IAAEventSink = {0xBCE4CC43,0x2F1A,0x11CF,{0xBF,0x16,0x00,0xAA,0x00,0xC0,0x81,0x46}};


const IID IID_IAALoader = {0xBCE4CC5d,0x2F1A,0x11CF,{0xBF,0x16,0x00,0xAA,0x00,0xC0,0x81,0x46}};


const IID IID_IAAMIDISink = {0xBCE4CC44,0x2F1A,0x11CF,{0xBF,0x16,0x00,0xAA,0x00,0xC0,0x81,0x46}};


const IID IID_IAAMotif = {0xBCE4CC4b,0x2F1A,0x11CF,{0xBF,0x16,0x00,0xAA,0x00,0xC0,0x81,0x46}};


const IID IID_IAANotifySink = {0xBCE4CC45,0x2F1A,0x11CF,{0xBF,0x16,0x00,0xAA,0x00,0xC0,0x81,0x46}};


const IID IID_IAAMIDIExportNotifySink = {0xBCE4CC5f,0x2F1A,0x11CF,{0xBF,0x16,0x00,0xAA,0x00,0xC0,0x81,0x46}};


const IID IID_IAAPattern = {0xBCE4CC50,0x2F1A,0x11CF,{0xBF,0x16,0x00,0xAA,0x00,0xC0,0x81,0x46}};


const IID IID_IAAPersonality = {0xBCE4CC4d,0x2F1A,0x11CF,{0xBF,0x16,0x00,0xAA,0x00,0xC0,0x81,0x46}};


const IID IID_IAARealTime = {0xBCE4CC42,0x2F1A,0x11CF,{0xBF,0x16,0x00,0xAA,0x00,0xC0,0x81,0x46}};


const IID IID_IAASection = {0xBCE4CC49,0x2F1A,0x11CF,{0xBF,0x16,0x00,0xAA,0x00,0xC0,0x81,0x46}};


const IID IID_IAASection2 = {0xBCE4CC60,0x2F1A,0x11CF,{0xBF,0x16,0x00,0xAA,0x00,0xC0,0x81,0x46}};


const IID IID_IAASong = {0xBCE4CC4a,0x2F1A,0x11CF,{0xBF,0x16,0x00,0xAA,0x00,0xC0,0x81,0x46}};


const IID IID_IAAStyle = {0xBCE4CC4c,0x2F1A,0x11CF,{0xBF,0x16,0x00,0xAA,0x00,0xC0,0x81,0x46}};


const IID IID_IAATemplate = {0xBCE4CC4f,0x2F1A,0x11CF,{0xBF,0x16,0x00,0xAA,0x00,0xC0,0x81,0x46}};


const IID IID_IReferenceClock = {0x56a86897,0x0ad4,0x11ce,{0xb0,0x3a,0x00,0x20,0xaf,0x0b,0xa7,0x70}};


const IID IID_IAAEngine = {0xBCE4CC41,0x2F1A,0x11CF,{0xBF,0x16,0x00,0xAA,0x00,0xC0,0x81,0x46}};


const IID IID_IAAMIDIIn = {0xBCE4CC46,0x2F1A,0x11CF,{0xBF,0x16,0x00,0xAA,0x00,0xC0,0x81,0x46}};


const IID IID_IAAMIDIOut = {0xBCE4CC47,0x2F1A,0x11CF,{0xBF,0x16,0x00,0xAA,0x00,0xC0,0x81,0x46}};


const CLSID CLSID_CAAEngine = {0xBCE4CC51,0x2F1A,0x11CF,{0xBF,0x16,0x00,0xAA,0x00,0xC0,0x81,0x46}};


const CLSID CLSID_CAARealTime = {0xBCE4CC52,0x2F1A,0x11CF,{0xBF,0x16,0x00,0xAA,0x00,0xC0,0x81,0x46}};


const CLSID CLSID_CAAMIDIOut = {0xBCE4CC53,0x2F1A,0x11CF,{0xBF,0x16,0x00,0xAA,0x00,0xC0,0x81,0x46}};


const CLSID CLSID_CAASection = {0xBCE4CC55,0x2F1A,0x11CF,{0xBF,0x16,0x00,0xAA,0x00,0xC0,0x81,0x46}};


const CLSID CLSID_CAASong = {0xBCE4CC56,0x2F1A,0x11CF,{0xBF,0x16,0x00,0xAA,0x00,0xC0,0x81,0x46}};


const CLSID CLSID_CAAMotif = {0xBCE4CC57,0x2F1A,0x11CF,{0xBF,0x16,0x00,0xAA,0x00,0xC0,0x81,0x46}};


const CLSID CLSID_CAAStyle = {0xBCE4CC58,0x2F1A,0x11CF,{0xBF,0x16,0x00,0xAA,0x00,0xC0,0x81,0x46}};


const CLSID CLSID_CAAPersonality = {0xBCE4CC59,0x2F1A,0x11CF,{0xBF,0x16,0x00,0xAA,0x00,0xC0,0x81,0x46}};


const CLSID CLSID_CAABand = {0xBCE4CC5a,0x2F1A,0x11CF,{0xBF,0x16,0x00,0xAA,0x00,0xC0,0x81,0x46}};


const CLSID CLSID_CAATemplate = {0xBCE4CC5b,0x2F1A,0x11CF,{0xBF,0x16,0x00,0xAA,0x00,0xC0,0x81,0x46}};


const CLSID CLSID_CAAPattern = {0xBCE4CC5c,0x2F1A,0x11CF,{0xBF,0x16,0x00,0xAA,0x00,0xC0,0x81,0x46}};


const CLSID CLSID_CAALoader = {0xBCE4CC5e,0x2F1A,0x11CF,{0xBF,0x16,0x00,0xAA,0x00,0xC0,0x81,0x46}};


#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\tools\x86\aactive\inc\msimusic.h ===
/* this ALWAYS GENERATED file contains the definitions for the interfaces */


/* File created by MIDL compiler version 3.00.44 */
/* at Fri Nov 08 14:45:43 1996
 */
/* Compiler settings for MSIMusic.odl:
    Os (OptLev=s), W1, Zp8, env=Win32, ms_ext, c_ext
    error checks: none
*/
//@@MIDL_FILE_HEADING(  )
#include "rpc.h"
#include "rpcndr.h"

#ifndef __MSIMusic_h__
#define __MSIMusic_h__

#ifdef __cplusplus
extern "C"{
#endif 

/* Forward Declarations */ 

#ifndef __IAABand_FWD_DEFINED__
#define __IAABand_FWD_DEFINED__
typedef interface IAABand IAABand;
#endif 	/* __IAABand_FWD_DEFINED__ */


#ifndef __IAAEventSink_FWD_DEFINED__
#define __IAAEventSink_FWD_DEFINED__
typedef interface IAAEventSink IAAEventSink;
#endif 	/* __IAAEventSink_FWD_DEFINED__ */


#ifndef __IAALoader_FWD_DEFINED__
#define __IAALoader_FWD_DEFINED__
typedef interface IAALoader IAALoader;
#endif 	/* __IAALoader_FWD_DEFINED__ */


#ifndef __IAAMIDISink_FWD_DEFINED__
#define __IAAMIDISink_FWD_DEFINED__
typedef interface IAAMIDISink IAAMIDISink;
#endif 	/* __IAAMIDISink_FWD_DEFINED__ */


#ifndef __IAAMotif_FWD_DEFINED__
#define __IAAMotif_FWD_DEFINED__
typedef interface IAAMotif IAAMotif;
#endif 	/* __IAAMotif_FWD_DEFINED__ */


#ifndef __IAANotifySink_FWD_DEFINED__
#define __IAANotifySink_FWD_DEFINED__
typedef interface IAANotifySink IAANotifySink;
#endif 	/* __IAANotifySink_FWD_DEFINED__ */


#ifndef __IAAMIDIExportNotifySink_FWD_DEFINED__
#define __IAAMIDIExportNotifySink_FWD_DEFINED__
typedef interface IAAMIDIExportNotifySink IAAMIDIExportNotifySink;
#endif 	/* __IAAMIDIExportNotifySink_FWD_DEFINED__ */


#ifndef __IAAPattern_FWD_DEFINED__
#define __IAAPattern_FWD_DEFINED__
typedef interface IAAPattern IAAPattern;
#endif 	/* __IAAPattern_FWD_DEFINED__ */


#ifndef __IAAPersonality_FWD_DEFINED__
#define __IAAPersonality_FWD_DEFINED__
typedef interface IAAPersonality IAAPersonality;
#endif 	/* __IAAPersonality_FWD_DEFINED__ */


#ifndef __IAARealTime_FWD_DEFINED__
#define __IAARealTime_FWD_DEFINED__
typedef interface IAARealTime IAARealTime;
#endif 	/* __IAARealTime_FWD_DEFINED__ */


#ifndef __IAASection_FWD_DEFINED__
#define __IAASection_FWD_DEFINED__
typedef interface IAASection IAASection;
#endif 	/* __IAASection_FWD_DEFINED__ */


#ifndef __IAASection2_FWD_DEFINED__
#define __IAASection2_FWD_DEFINED__
typedef interface IAASection2 IAASection2;
#endif 	/* __IAASection2_FWD_DEFINED__ */


#ifndef __IAASong_FWD_DEFINED__
#define __IAASong_FWD_DEFINED__
typedef interface IAASong IAASong;
#endif 	/* __IAASong_FWD_DEFINED__ */


#ifndef __IAAStyle_FWD_DEFINED__
#define __IAAStyle_FWD_DEFINED__
typedef interface IAAStyle IAAStyle;
#endif 	/* __IAAStyle_FWD_DEFINED__ */


#ifndef __IAATemplate_FWD_DEFINED__
#define __IAATemplate_FWD_DEFINED__
typedef interface IAATemplate IAATemplate;
#endif 	/* __IAATemplate_FWD_DEFINED__ */


#ifndef __IReferenceClock_FWD_DEFINED__
#define __IReferenceClock_FWD_DEFINED__
typedef interface IReferenceClock IReferenceClock;
#endif 	/* __IReferenceClock_FWD_DEFINED__ */


#ifndef __IAAEngine_FWD_DEFINED__
#define __IAAEngine_FWD_DEFINED__
typedef interface IAAEngine IAAEngine;
#endif 	/* __IAAEngine_FWD_DEFINED__ */


#ifndef __IAAMIDIIn_FWD_DEFINED__
#define __IAAMIDIIn_FWD_DEFINED__
typedef interface IAAMIDIIn IAAMIDIIn;
#endif 	/* __IAAMIDIIn_FWD_DEFINED__ */


#ifndef __IAAMIDIOut_FWD_DEFINED__
#define __IAAMIDIOut_FWD_DEFINED__
typedef interface IAAMIDIOut IAAMIDIOut;
#endif 	/* __IAAMIDIOut_FWD_DEFINED__ */


void __RPC_FAR * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void __RPC_FAR * ); 


#ifndef __AudioActive_LIBRARY_DEFINED__
#define __AudioActive_LIBRARY_DEFINED__

/****************************************
 * Generated header for library: AudioActive
 * at Fri Nov 08 14:45:43 1996
 * using MIDL 3.00.44
 ****************************************/
/* [version][lcid][helpstring][uuid] */ 


















typedef IAABand __RPC_FAR *LPAABAND;

typedef IAAEventSink __RPC_FAR *LPAAEVENTSINK;

typedef IAALoader __RPC_FAR *LPAALOADER;

typedef IAAMIDISink __RPC_FAR *LPAAMIDISINK;

typedef IAAMotif __RPC_FAR *LPAAMOTIF;

typedef IAANotifySink __RPC_FAR *LPAANOTIFYSINK;

typedef IAAMIDIExportNotifySink __RPC_FAR *LPAAMIDIEXPORTNOTIFYSINK;

typedef IAAPattern __RPC_FAR *LPAAPATTERN;

typedef IAAPersonality __RPC_FAR *LPAAPERSONALITY;

typedef IAARealTime __RPC_FAR *LPREALTIME;

typedef IAASection __RPC_FAR *LPAASECTION;

typedef IAASong __RPC_FAR *LPAASONG;

typedef IAAStyle __RPC_FAR *LPAASTYLE;

typedef IAATemplate __RPC_FAR *LPAATEMPLATE;

typedef struct  _ReferenceTime
    {
    LARGE_INTEGER RefTime;
    }	ReferenceTime;

typedef unsigned long TIME;

typedef unsigned long HEVENT;

typedef unsigned long HSEMAPHORE;

typedef struct  AAEVENT
    {
    WORD cbSize;
    WORD wType;
    DWORD dwTime;
    }	AAEVENT;

typedef struct  AAINSTRUMENT
    {
    WORD cbSize;
    WORD wType;
    DWORD dwFullPatch;
    LPCTSTR pszName;
    BYTE abNotesUsed[ 16 ];
    BYTE bGMPatch;
    BYTE bReserved;
    }	AAINSTRUMENT;

typedef struct  AASTYLEINFO
    {
    WORD cbSize;
    GUID guid;
    LPCTSTR pszName;
    LPCTSTR pszCategory;
    LPCTSTR pszFileName;
    DWORD dwTimeSignature;
    WORD wClicksPerBeat;
    }	AASTYLEINFO;

typedef struct  AAPERSONALITYINFO
    {
    WORD cbSize;
    GUID guid;
    LPCTSTR pszName;
    LPCTSTR pszUserName;
    LPCTSTR pszFileName;
    }	AAPERSONALITYINFO;

typedef struct  AAMETERS
    {
    WORD cbSize;
    WORD wMutes;
    BYTE abCurrentVolume[ 16 ];
    signed char achCurrentPan[ 16 ];
    WORD awCurrentLevel[ 16 ];
    WORD awAveragedCurrentLevel[ 16 ];
    }	AAMETERS;

typedef 
enum __MIDL___MIDL__intf_0000_0001
    {	AAS_FALLING	= 0,
	AAS_LEVEL	= AAS_FALLING + 1,
	AAS_LOOPABLE	= AAS_LEVEL + 1,
	AAS_LOUD	= AAS_LOOPABLE + 1,
	AAS_QUIET	= AAS_LOUD + 1,
	AAS_PEAKING	= AAS_QUIET + 1,
	AAS_RANDOM	= AAS_PEAKING + 1,
	AAS_RISING	= AAS_RANDOM + 1,
	AAS_SONG	= AAS_RISING + 1
    }	AAShape;

typedef 
enum __MIDL___MIDL__intf_0000_0002
    {	AAF_NONE	= 0,
	AAF_EXCLUSIVE_FLAGS	= 0x3f,
	AAF_NEXT_MEASURE	= 0,
	AAF_END_CONTINUOUS	= 0,
	AAF_NEXT_BEAT	= 0x1,
	AAF_NEXT_CLICK	= 0x2,
	AAF_IMMEDIATE	= 0x3,
	AAF_ASAP	= 0x3,
	AAF_NEXT_SECTION	= 0x4,
	AAF_QUEUE	= 0x5,
	AAF_FAIL_IF_PLAYING	= 0x6,
	AAF_ABSOLUTE_TIME	= 0x7,
	AAF_MEASURES_FROM_NOW	= 0x8,
	AAF_BEATS_FROM_NOW	= 0x9,
	AAF_CLICKS_FROM_NOW	= 0xa,
	AAF_NONEXCLUSIVE_FLAGS	= 0xffffffc0,
	AAF_ALLOW_OVERLAP	= 0x100,
	AAF_PLAY_WITH_STYLE	= 0x200,
	AAF_IGNORE_KEY	= 0x400,
	AAF_IGNORE_CHORD	= 0x800,
	AAF_MODULATE	= 0x1000,
	AAF_LONG	= 0x2000,
	AAF_IS_TRANSITION	= 0x4000,
	AAF_ENDED_EARLY	= 0x8000,
	AAF_IGNORE_STANDARD_LOCATION	= 0x10000,
	AAF_ENDING	= 0x20000,
	AAF_NOTIFY	= 0x40000,
	AAF_PLAY_METRONOME	= 0x80000,
	AAF_MEASURE_BOUNDARIES_ONLY	= 0x100000,
	AAF_CONTINUOUS	= 0x200000
    }	AAFlags;

typedef 
enum __MIDL___MIDL__intf_0000_0003
    {	AAC_NONE	= 0,
	AAC_FILL	= 0x1,
	AAC_INTRO	= 0x2,
	AAC_BREAK	= 0x20,
	AAC_END	= 0x40,
	AAC_INTRO_AND_END	= 0x42,
	AAC_EMBELLISHMENTS	= 0x63,
	AAC_GROOVE_A	= 0x80,
	AAC_GROOVE_B	= 0x100,
	AAC_GROOVE_C	= 0x200,
	AAC_GROOVE_D	= 0x400,
	AAC_GROOVES	= 0x780
    }	AACommands;

typedef IReferenceClock __RPC_FAR *PREFERENCECLOCK;

#ifdef __AUDIOACTIVE
#define AAEXPORT __declspec(dllexport)
#else
#define AAEXPORT __declspec(dllimport)
#endif

#ifdef __cplusplus
extern "C"
{
#endif

AAEXPORT HRESULT WINAPI AllocAAClock( IReferenceClock** ppClock );
AAEXPORT HRESULT WINAPI AllocAAEngine( IAAEngine** ppEngine );
AAEXPORT HRESULT WINAPI AllocAAMIDIIn( IAAMIDIIn** ppMIDIIn );
AAEXPORT HRESULT WINAPI AllocAAMIDIOut( IAAMIDIOut** ppMIDIOut );
AAEXPORT HRESULT WINAPI AllocAARealTime( IAARealTime** ppRealTime );
AAEXPORT HRESULT WINAPI MusicEngineSimpleInit( IAAEngine** ppEngine, IAANotifySink* pNotifySink, IAALoader* pLoader );
AAEXPORT HRESULT WINAPI MusicEngineSimpleInitNT( IAAEngine** ppEngine, IAANotifySink* pNotifySink, IAALoader* pLoader );
AAEXPORT HRESULT WINAPI MusicEngineSimpleInit95( IAAEngine** ppEngine, IAANotifySink* pNotifySink, IAALoader* pLoader );
AAEXPORT IAAMIDISink* WINAPI GetFinalMIDISink( IAAEngine* pEngine );
AAEXPORT HRESULT WINAPI LoadBandFile( IAAEngine* pEngine, LPCTSTR pszFileName, IAABand** ppBand );
AAEXPORT HRESULT WINAPI LoadMotifFile( IAAEngine* pEngine, LPCTSTR pszFileName, IAAMotif** ppMotif );
AAEXPORT HRESULT WINAPI LoadPatternFile( IAAEngine* pEngine, LPCTSTR pszFileName, IAAPattern** ppPattern );
AAEXPORT HRESULT WINAPI LoadPersonalityByName( IAAEngine* pEngine, LPCTSTR pszName, IAAPersonality** ppPersonality );
AAEXPORT HRESULT WINAPI LoadPersonalityFile( IAAEngine* pEngine, LPCTSTR pszFileName, IAAPersonality** ppPersonality );
AAEXPORT HRESULT WINAPI LoadPersonalityFromMemory( IAAEngine* pEngine, void* pMem, IAAPersonality** ppPersonality );
AAEXPORT HRESULT WINAPI LoadSectionFile( IAAEngine* pEngine, LPCTSTR pszFileName, IAASection** ppSection );
AAEXPORT HRESULT WINAPI SaveSectionFile( LPCTSTR pszFileName, IAASection* pSection );
AAEXPORT HRESULT WINAPI SaveSectionAsMIDIFile( LPCTSTR pszFileName, IAASection* pSection );
AAEXPORT HRESULT WINAPI LoadSongFile( IAAEngine* pEngine, LPCTSTR pszFileName, IAASong** ppSong );
AAEXPORT HRESULT WINAPI LoadStyleByName( IAAEngine* pEngine, LPCTSTR pszName, IAAStyle** ppStyle );
AAEXPORT HRESULT WINAPI LoadStyleFile( IAAEngine* pEngine, LPCTSTR pszFileName, IAAStyle** ppStyle );
AAEXPORT HRESULT WINAPI LoadStyleFromMemory( IAAEngine* pEngine, void* pMem, IAAStyle** ppStyle );
AAEXPORT HRESULT WINAPI LoadTemplateFile( IAAEngine* pEngine, LPCTSTR pszFileName, IAATemplate** ppTemplate );
AAEXPORT HRESULT WINAPI Panic( IAAEngine* pEngine );
AAEXPORT void WINAPI SetAADebug( WORD wDebugLevel );

#ifdef __cplusplus
}
#endif

// Error return values
#define AA_E_ALREADYPLAYING  0x80041000
#define AA_E_NOMUSICPLAYING  0x80041001
#define AA_W_MIDIINUSE       0x40041000

#define MAKE_TEMPO( bpm, fract ) ( (long)( ((DWORD)(WORD)bpm) | ( ((DWORD)(WORD)fract) << 16 ) ) )
#define TEMPO_BPM( tempo ) ( (short)tempo )
#define TEMPO_FRACT( tempo ) ( (WORD)( ((DWORD)tempo) >> 16 ) )

#define MAKE_TIMESIG( bpm, beat ) ( (long)( ((DWORD)(WORD)beat) | ( ((DWORD)(WORD)bpm) << 16 ) ) )
#define TIMESIG_BEAT( tsig ) ( (short)tsig )
#define TIMESIG_BPM( tsig ) ( (WORD)( ((DWORD)tsig) >> 16 ) )

#define MAKE_KEY( isflat, root ) ( (isflat) ? ( 0x8000 | (root) ) | (root) )
#define KEY_ROOT( key ) ( (key) & 0x1f )
#define KEY_ISFLAT( key ) ( ( (key) & 0x8000 ) != 0 )

#define MAKE_MIDIMSG( stat, not, vel ) \
    ( (DWORD)(((BYTE)(stat) | ((BYTE)(not)<<8)) | (((DWORD)(BYTE)(vel))<<16)) )

#define GET_MIDIMSG_STATUS( msg ) \
    ( (BYTE)(msg) )

#define GET_MIDIMSG_NOTE( msg ) \
    ( (BYTE)((msg) >> 8) )

#define GET_MIDIMSG_VELOCITY( msg ) \
    ( (BYTE)((msg) >> 16) )

#define NOW 0xfffffffful
#define MIN_TEMPO           10
#define MAX_TEMPO           350
#define SECTION_MAX_LENGTH  1000

#define AA_FINST_DRUM   0x80000000
#define AA_FINST_EMPTY  0x40000000
#define AA_FINST_USEGM  0x00400000
#define AA_FINST_USEGS  0x00200000

#ifdef _DEBUG
enum AAMEM_FLAGS
{
    AAMEM_RESET = 1,
    AAMEM_DEBUG = 2,
    AAMEM_BYTES = 4,
    AAMEM_ALLOC = 0,
};

typedef struct AAMemoryData
{
    DWORD                   dwSize;
    DWORD                   dwTotal;
    DWORD                   dwMaximum;
    DWORD                   dwCurrent;
} AAMEMORYDATA, *LPAAMEMORYDATA;

#ifdef __cplusplus
extern "C"
{
#endif

AAEXPORT HRESULT WINAPI AAMemoryAudit( LPAAMEMORYDATA pmd, DWORD fdwFlags );
AAEXPORT HRESULT WINAPI AASetMemoryFault( DWORD dwLimit, DWORD fdwFlags );

#ifdef __cplusplus
}
#endif

#endif

DEFINE_GUID(LIBID_AudioActive,0xBCE4CC3f,0x2F1A,0x11CF,0xBF,0x16,0x00,0xAA,0x00,0xC0,0x81,0x46);

#ifndef __IAABand_INTERFACE_DEFINED__
#define __IAABand_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IAABand
 * at Fri Nov 08 14:45:43 1996
 * using MIDL 3.00.44
 ****************************************/
/* [object][uuid] */ 



DEFINE_GUID(IID_IAABand,0xBCE4CC4e,0x2F1A,0x11CF,0xBF,0x16,0x00,0xAA,0x00,0xC0,0x81,0x46);

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface IAABand : public IUnknown
    {
    public:
        virtual IAABand __RPC_FAR *STDMETHODCALLTYPE Clone( void) = 0;
        
        virtual LPCTSTR STDMETHODCALLTYPE GetName( void) = 0;
        
        virtual short STDMETHODCALLTYPE GetOctave( 
            /* [in] */ WORD wInstrument) = 0;
        
        virtual short STDMETHODCALLTYPE GetPan( 
            /* [in] */ WORD wInstrument) = 0;
        
        virtual WORD STDMETHODCALLTYPE GetPatch( 
            /* [in] */ WORD wInstrument) = 0;
        
        virtual WORD STDMETHODCALLTYPE GetVolume( 
            /* [in] */ WORD wInstrument) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetInstrument( 
            /* [in] */ WORD wInstrument,
            /* [in] */ AAINSTRUMENT __RPC_FAR *pInstrument) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Lock( 
            /* [in] */ VARIANT_BOOL fWait) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE QueryState( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Send( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetInstrument( 
            /* [in] */ WORD wInstrument,
            /* [in] */ AAINSTRUMENT __RPC_FAR *pInstrument) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetName( 
            /* [in] */ LPCTSTR pszName) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetNoteRange( 
            /* [in] */ WORD wInstrument,
            /* [in] */ WORD wLowNote,
            /* [in] */ WORD wHighNote,
            /* [in] */ VARIANT_BOOL fOn) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetOctave( 
            /* [in] */ WORD wInstrument,
            /* [in] */ short nOctave) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetPan( 
            /* [in] */ WORD wInstrument,
            /* [in] */ short nPan,
            /* [in] */ VARIANT_BOOL fSend) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetPatch( 
            /* [in] */ WORD wInstrument,
            /* [in] */ WORD wPatch,
            /* [in] */ VARIANT_BOOL fSend) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetVolume( 
            /* [in] */ WORD wInstrument,
            /* [in] */ WORD wVolume,
            /* [in] */ VARIANT_BOOL fSend) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Unlock( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IAABandVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IAABand __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IAABand __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IAABand __RPC_FAR * This);
        
        IAABand __RPC_FAR *( STDMETHODCALLTYPE __RPC_FAR *Clone )( 
            IAABand __RPC_FAR * This);
        
        LPCTSTR ( STDMETHODCALLTYPE __RPC_FAR *GetName )( 
            IAABand __RPC_FAR * This);
        
        short ( STDMETHODCALLTYPE __RPC_FAR *GetOctave )( 
            IAABand __RPC_FAR * This,
            /* [in] */ WORD wInstrument);
        
        short ( STDMETHODCALLTYPE __RPC_FAR *GetPan )( 
            IAABand __RPC_FAR * This,
            /* [in] */ WORD wInstrument);
        
        WORD ( STDMETHODCALLTYPE __RPC_FAR *GetPatch )( 
            IAABand __RPC_FAR * This,
            /* [in] */ WORD wInstrument);
        
        WORD ( STDMETHODCALLTYPE __RPC_FAR *GetVolume )( 
            IAABand __RPC_FAR * This,
            /* [in] */ WORD wInstrument);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetInstrument )( 
            IAABand __RPC_FAR * This,
            /* [in] */ WORD wInstrument,
            /* [in] */ AAINSTRUMENT __RPC_FAR *pInstrument);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Lock )( 
            IAABand __RPC_FAR * This,
            /* [in] */ VARIANT_BOOL fWait);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryState )( 
            IAABand __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Send )( 
            IAABand __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetInstrument )( 
            IAABand __RPC_FAR * This,
            /* [in] */ WORD wInstrument,
            /* [in] */ AAINSTRUMENT __RPC_FAR *pInstrument);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetName )( 
            IAABand __RPC_FAR * This,
            /* [in] */ LPCTSTR pszName);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetNoteRange )( 
            IAABand __RPC_FAR * This,
            /* [in] */ WORD wInstrument,
            /* [in] */ WORD wLowNote,
            /* [in] */ WORD wHighNote,
            /* [in] */ VARIANT_BOOL fOn);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetOctave )( 
            IAABand __RPC_FAR * This,
            /* [in] */ WORD wInstrument,
            /* [in] */ short nOctave);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetPan )( 
            IAABand __RPC_FAR * This,
            /* [in] */ WORD wInstrument,
            /* [in] */ short nPan,
            /* [in] */ VARIANT_BOOL fSend);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetPatch )( 
            IAABand __RPC_FAR * This,
            /* [in] */ WORD wInstrument,
            /* [in] */ WORD wPatch,
            /* [in] */ VARIANT_BOOL fSend);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetVolume )( 
            IAABand __RPC_FAR * This,
            /* [in] */ WORD wInstrument,
            /* [in] */ WORD wVolume,
            /* [in] */ VARIANT_BOOL fSend);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Unlock )( 
            IAABand __RPC_FAR * This);
        
        END_INTERFACE
    } IAABandVtbl;

    interface IAABand
    {
        CONST_VTBL struct IAABandVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IAABand_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IAABand_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IAABand_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IAABand_Clone(This)	\
    (This)->lpVtbl -> Clone(This)

#define IAABand_GetName(This)	\
    (This)->lpVtbl -> GetName(This)

#define IAABand_GetOctave(This,wInstrument)	\
    (This)->lpVtbl -> GetOctave(This,wInstrument)

#define IAABand_GetPan(This,wInstrument)	\
    (This)->lpVtbl -> GetPan(This,wInstrument)

#define IAABand_GetPatch(This,wInstrument)	\
    (This)->lpVtbl -> GetPatch(This,wInstrument)

#define IAABand_GetVolume(This,wInstrument)	\
    (This)->lpVtbl -> GetVolume(This,wInstrument)

#define IAABand_GetInstrument(This,wInstrument,pInstrument)	\
    (This)->lpVtbl -> GetInstrument(This,wInstrument,pInstrument)

#define IAABand_Lock(This,fWait)	\
    (This)->lpVtbl -> Lock(This,fWait)

#define IAABand_QueryState(This)	\
    (This)->lpVtbl -> QueryState(This)

#define IAABand_Send(This)	\
    (This)->lpVtbl -> Send(This)

#define IAABand_SetInstrument(This,wInstrument,pInstrument)	\
    (This)->lpVtbl -> SetInstrument(This,wInstrument,pInstrument)

#define IAABand_SetName(This,pszName)	\
    (This)->lpVtbl -> SetName(This,pszName)

#define IAABand_SetNoteRange(This,wInstrument,wLowNote,wHighNote,fOn)	\
    (This)->lpVtbl -> SetNoteRange(This,wInstrument,wLowNote,wHighNote,fOn)

#define IAABand_SetOctave(This,wInstrument,nOctave)	\
    (This)->lpVtbl -> SetOctave(This,wInstrument,nOctave)

#define IAABand_SetPan(This,wInstrument,nPan,fSend)	\
    (This)->lpVtbl -> SetPan(This,wInstrument,nPan,fSend)

#define IAABand_SetPatch(This,wInstrument,wPatch,fSend)	\
    (This)->lpVtbl -> SetPatch(This,wInstrument,wPatch,fSend)

#define IAABand_SetVolume(This,wInstrument,wVolume,fSend)	\
    (This)->lpVtbl -> SetVolume(This,wInstrument,wVolume,fSend)

#define IAABand_Unlock(This)	\
    (This)->lpVtbl -> Unlock(This)

#endif /* COBJMACROS */


#endif 	/* C style interface */



IAABand __RPC_FAR *STDMETHODCALLTYPE IAABand_Clone_Proxy( 
    IAABand __RPC_FAR * This);


void __RPC_STUB IAABand_Clone_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


LPCTSTR STDMETHODCALLTYPE IAABand_GetName_Proxy( 
    IAABand __RPC_FAR * This);


void __RPC_STUB IAABand_GetName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


short STDMETHODCALLTYPE IAABand_GetOctave_Proxy( 
    IAABand __RPC_FAR * This,
    /* [in] */ WORD wInstrument);


void __RPC_STUB IAABand_GetOctave_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


short STDMETHODCALLTYPE IAABand_GetPan_Proxy( 
    IAABand __RPC_FAR * This,
    /* [in] */ WORD wInstrument);


void __RPC_STUB IAABand_GetPan_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


WORD STDMETHODCALLTYPE IAABand_GetPatch_Proxy( 
    IAABand __RPC_FAR * This,
    /* [in] */ WORD wInstrument);


void __RPC_STUB IAABand_GetPatch_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


WORD STDMETHODCALLTYPE IAABand_GetVolume_Proxy( 
    IAABand __RPC_FAR * This,
    /* [in] */ WORD wInstrument);


void __RPC_STUB IAABand_GetVolume_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAABand_GetInstrument_Proxy( 
    IAABand __RPC_FAR * This,
    /* [in] */ WORD wInstrument,
    /* [in] */ AAINSTRUMENT __RPC_FAR *pInstrument);


void __RPC_STUB IAABand_GetInstrument_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAABand_Lock_Proxy( 
    IAABand __RPC_FAR * This,
    /* [in] */ VARIANT_BOOL fWait);


void __RPC_STUB IAABand_Lock_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAABand_QueryState_Proxy( 
    IAABand __RPC_FAR * This);


void __RPC_STUB IAABand_QueryState_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAABand_Send_Proxy( 
    IAABand __RPC_FAR * This);


void __RPC_STUB IAABand_Send_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAABand_SetInstrument_Proxy( 
    IAABand __RPC_FAR * This,
    /* [in] */ WORD wInstrument,
    /* [in] */ AAINSTRUMENT __RPC_FAR *pInstrument);


void __RPC_STUB IAABand_SetInstrument_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAABand_SetName_Proxy( 
    IAABand __RPC_FAR * This,
    /* [in] */ LPCTSTR pszName);


void __RPC_STUB IAABand_SetName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAABand_SetNoteRange_Proxy( 
    IAABand __RPC_FAR * This,
    /* [in] */ WORD wInstrument,
    /* [in] */ WORD wLowNote,
    /* [in] */ WORD wHighNote,
    /* [in] */ VARIANT_BOOL fOn);


void __RPC_STUB IAABand_SetNoteRange_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAABand_SetOctave_Proxy( 
    IAABand __RPC_FAR * This,
    /* [in] */ WORD wInstrument,
    /* [in] */ short nOctave);


void __RPC_STUB IAABand_SetOctave_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAABand_SetPan_Proxy( 
    IAABand __RPC_FAR * This,
    /* [in] */ WORD wInstrument,
    /* [in] */ short nPan,
    /* [in] */ VARIANT_BOOL fSend);


void __RPC_STUB IAABand_SetPan_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAABand_SetPatch_Proxy( 
    IAABand __RPC_FAR * This,
    /* [in] */ WORD wInstrument,
    /* [in] */ WORD wPatch,
    /* [in] */ VARIANT_BOOL fSend);


void __RPC_STUB IAABand_SetPatch_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAABand_SetVolume_Proxy( 
    IAABand __RPC_FAR * This,
    /* [in] */ WORD wInstrument,
    /* [in] */ WORD wVolume,
    /* [in] */ VARIANT_BOOL fSend);


void __RPC_STUB IAABand_SetVolume_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAABand_Unlock_Proxy( 
    IAABand __RPC_FAR * This);


void __RPC_STUB IAABand_Unlock_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IAABand_INTERFACE_DEFINED__ */


#ifndef __IAAEventSink_INTERFACE_DEFINED__
#define __IAAEventSink_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IAAEventSink
 * at Fri Nov 08 14:45:43 1996
 * using MIDL 3.00.44
 ****************************************/
/* [object][uuid] */ 



DEFINE_GUID(IID_IAAEventSink,0xBCE4CC43,0x2F1A,0x11CF,0xBF,0x16,0x00,0xAA,0x00,0xC0,0x81,0x46);

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface IAAEventSink : public IUnknown
    {
    public:
        virtual IAAEventSink __RPC_FAR *STDMETHODCALLTYPE GetEventSink( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE QueueEvent( 
            /* [in] */ AAEVENT __RPC_FAR *pEvent) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetEventSink( 
            /* [in] */ IAAEventSink __RPC_FAR *pEventSink) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IAAEventSinkVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IAAEventSink __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IAAEventSink __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IAAEventSink __RPC_FAR * This);
        
        IAAEventSink __RPC_FAR *( STDMETHODCALLTYPE __RPC_FAR *GetEventSink )( 
            IAAEventSink __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueueEvent )( 
            IAAEventSink __RPC_FAR * This,
            /* [in] */ AAEVENT __RPC_FAR *pEvent);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetEventSink )( 
            IAAEventSink __RPC_FAR * This,
            /* [in] */ IAAEventSink __RPC_FAR *pEventSink);
        
        END_INTERFACE
    } IAAEventSinkVtbl;

    interface IAAEventSink
    {
        CONST_VTBL struct IAAEventSinkVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IAAEventSink_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IAAEventSink_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IAAEventSink_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IAAEventSink_GetEventSink(This)	\
    (This)->lpVtbl -> GetEventSink(This)

#define IAAEventSink_QueueEvent(This,pEvent)	\
    (This)->lpVtbl -> QueueEvent(This,pEvent)

#define IAAEventSink_SetEventSink(This,pEventSink)	\
    (This)->lpVtbl -> SetEventSink(This,pEventSink)

#endif /* COBJMACROS */


#endif 	/* C style interface */



IAAEventSink __RPC_FAR *STDMETHODCALLTYPE IAAEventSink_GetEventSink_Proxy( 
    IAAEventSink __RPC_FAR * This);


void __RPC_STUB IAAEventSink_GetEventSink_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAAEventSink_QueueEvent_Proxy( 
    IAAEventSink __RPC_FAR * This,
    /* [in] */ AAEVENT __RPC_FAR *pEvent);


void __RPC_STUB IAAEventSink_QueueEvent_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAAEventSink_SetEventSink_Proxy( 
    IAAEventSink __RPC_FAR * This,
    /* [in] */ IAAEventSink __RPC_FAR *pEventSink);


void __RPC_STUB IAAEventSink_SetEventSink_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IAAEventSink_INTERFACE_DEFINED__ */


#ifndef __IAALoader_INTERFACE_DEFINED__
#define __IAALoader_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IAALoader
 * at Fri Nov 08 14:45:43 1996
 * using MIDL 3.00.44
 ****************************************/
/* [object][uuid] */ 



DEFINE_GUID(IID_IAALoader,0xBCE4CC5d,0x2F1A,0x11CF,0xBF,0x16,0x00,0xAA,0x00,0xC0,0x81,0x46);

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface IAALoader : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetFirstPersonalityInfo( 
            /* [out][in] */ AAPERSONALITYINFO __RPC_FAR *pPersonalityInfo) = 0;
        
        virtual LPCTSTR STDMETHODCALLTYPE GetFirstPersonalityName( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetFirstStyleInfo( 
            /* [out][in] */ AASTYLEINFO __RPC_FAR *pStyleInfo) = 0;
        
        virtual LPCTSTR STDMETHODCALLTYPE GetFirstStyleName( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetNextPersonalityInfo( 
            /* [out][in] */ AAPERSONALITYINFO __RPC_FAR *pPersonalityInfo) = 0;
        
        virtual LPCTSTR STDMETHODCALLTYPE GetNextPersonalityName( 
            /* [in] */ LPCTSTR pszPrevPersonalityName) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetNextStyleInfo( 
            /* [out][in] */ AASTYLEINFO __RPC_FAR *pStyleInfo) = 0;
        
        virtual LPCTSTR STDMETHODCALLTYPE GetNextStyleName( 
            /* [in] */ LPCTSTR pszPrevStyleName) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE LoadPersonality( 
            /* [in] */ IAAEngine __RPC_FAR *pEngine,
            /* [in] */ LPGUID pguid,
            /* [in] */ LPCTSTR pszFileName,
            /* [in] */ LPCTSTR pszPersonalityName,
            /* [retval][out] */ IAAPersonality __RPC_FAR *__RPC_FAR *ppPersonality) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE LoadStyle( 
            /* [in] */ IAAEngine __RPC_FAR *pEngine,
            /* [in] */ LPGUID pguid,
            /* [in] */ LPCTSTR pszFileName,
            /* [in] */ LPCTSTR pszStyleName,
            /* [retval][out] */ IAAStyle __RPC_FAR *__RPC_FAR *ppStyle) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetSearchDirectory( 
            /* [in] */ LPCTSTR pszDirectoryName,
            /* [in] */ AAFlags fFlags) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IAALoaderVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IAALoader __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IAALoader __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IAALoader __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetFirstPersonalityInfo )( 
            IAALoader __RPC_FAR * This,
            /* [out][in] */ AAPERSONALITYINFO __RPC_FAR *pPersonalityInfo);
        
        LPCTSTR ( STDMETHODCALLTYPE __RPC_FAR *GetFirstPersonalityName )( 
            IAALoader __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetFirstStyleInfo )( 
            IAALoader __RPC_FAR * This,
            /* [out][in] */ AASTYLEINFO __RPC_FAR *pStyleInfo);
        
        LPCTSTR ( STDMETHODCALLTYPE __RPC_FAR *GetFirstStyleName )( 
            IAALoader __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetNextPersonalityInfo )( 
            IAALoader __RPC_FAR * This,
            /* [out][in] */ AAPERSONALITYINFO __RPC_FAR *pPersonalityInfo);
        
        LPCTSTR ( STDMETHODCALLTYPE __RPC_FAR *GetNextPersonalityName )( 
            IAALoader __RPC_FAR * This,
            /* [in] */ LPCTSTR pszPrevPersonalityName);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetNextStyleInfo )( 
            IAALoader __RPC_FAR * This,
            /* [out][in] */ AASTYLEINFO __RPC_FAR *pStyleInfo);
        
        LPCTSTR ( STDMETHODCALLTYPE __RPC_FAR *GetNextStyleName )( 
            IAALoader __RPC_FAR * This,
            /* [in] */ LPCTSTR pszPrevStyleName);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *LoadPersonality )( 
            IAALoader __RPC_FAR * This,
            /* [in] */ IAAEngine __RPC_FAR *pEngine,
            /* [in] */ LPGUID pguid,
            /* [in] */ LPCTSTR pszFileName,
            /* [in] */ LPCTSTR pszPersonalityName,
            /* [retval][out] */ IAAPersonality __RPC_FAR *__RPC_FAR *ppPersonality);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *LoadStyle )( 
            IAALoader __RPC_FAR * This,
            /* [in] */ IAAEngine __RPC_FAR *pEngine,
            /* [in] */ LPGUID pguid,
            /* [in] */ LPCTSTR pszFileName,
            /* [in] */ LPCTSTR pszStyleName,
            /* [retval][out] */ IAAStyle __RPC_FAR *__RPC_FAR *ppStyle);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetSearchDirectory )( 
            IAALoader __RPC_FAR * This,
            /* [in] */ LPCTSTR pszDirectoryName,
            /* [in] */ AAFlags fFlags);
        
        END_INTERFACE
    } IAALoaderVtbl;

    interface IAALoader
    {
        CONST_VTBL struct IAALoaderVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IAALoader_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IAALoader_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IAALoader_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IAALoader_GetFirstPersonalityInfo(This,pPersonalityInfo)	\
    (This)->lpVtbl -> GetFirstPersonalityInfo(This,pPersonalityInfo)

#define IAALoader_GetFirstPersonalityName(This)	\
    (This)->lpVtbl -> GetFirstPersonalityName(This)

#define IAALoader_GetFirstStyleInfo(This,pStyleInfo)	\
    (This)->lpVtbl -> GetFirstStyleInfo(This,pStyleInfo)

#define IAALoader_GetFirstStyleName(This)	\
    (This)->lpVtbl -> GetFirstStyleName(This)

#define IAALoader_GetNextPersonalityInfo(This,pPersonalityInfo)	\
    (This)->lpVtbl -> GetNextPersonalityInfo(This,pPersonalityInfo)

#define IAALoader_GetNextPersonalityName(This,pszPrevPersonalityName)	\
    (This)->lpVtbl -> GetNextPersonalityName(This,pszPrevPersonalityName)

#define IAALoader_GetNextStyleInfo(This,pStyleInfo)	\
    (This)->lpVtbl -> GetNextStyleInfo(This,pStyleInfo)

#define IAALoader_GetNextStyleName(This,pszPrevStyleName)	\
    (This)->lpVtbl -> GetNextStyleName(This,pszPrevStyleName)

#define IAALoader_LoadPersonality(This,pEngine,pguid,pszFileName,pszPersonalityName,ppPersonality)	\
    (This)->lpVtbl -> LoadPersonality(This,pEngine,pguid,pszFileName,pszPersonalityName,ppPersonality)

#define IAALoader_LoadStyle(This,pEngine,pguid,pszFileName,pszStyleName,ppStyle)	\
    (This)->lpVtbl -> LoadStyle(This,pEngine,pguid,pszFileName,pszStyleName,ppStyle)

#define IAALoader_SetSearchDirectory(This,pszDirectoryName,fFlags)	\
    (This)->lpVtbl -> SetSearchDirectory(This,pszDirectoryName,fFlags)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IAALoader_GetFirstPersonalityInfo_Proxy( 
    IAALoader __RPC_FAR * This,
    /* [out][in] */ AAPERSONALITYINFO __RPC_FAR *pPersonalityInfo);


void __RPC_STUB IAALoader_GetFirstPersonalityInfo_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


LPCTSTR STDMETHODCALLTYPE IAALoader_GetFirstPersonalityName_Proxy( 
    IAALoader __RPC_FAR * This);


void __RPC_STUB IAALoader_GetFirstPersonalityName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAALoader_GetFirstStyleInfo_Proxy( 
    IAALoader __RPC_FAR * This,
    /* [out][in] */ AASTYLEINFO __RPC_FAR *pStyleInfo);


void __RPC_STUB IAALoader_GetFirstStyleInfo_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


LPCTSTR STDMETHODCALLTYPE IAALoader_GetFirstStyleName_Proxy( 
    IAALoader __RPC_FAR * This);


void __RPC_STUB IAALoader_GetFirstStyleName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAALoader_GetNextPersonalityInfo_Proxy( 
    IAALoader __RPC_FAR * This,
    /* [out][in] */ AAPERSONALITYINFO __RPC_FAR *pPersonalityInfo);


void __RPC_STUB IAALoader_GetNextPersonalityInfo_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


LPCTSTR STDMETHODCALLTYPE IAALoader_GetNextPersonalityName_Proxy( 
    IAALoader __RPC_FAR * This,
    /* [in] */ LPCTSTR pszPrevPersonalityName);


void __RPC_STUB IAALoader_GetNextPersonalityName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAALoader_GetNextStyleInfo_Proxy( 
    IAALoader __RPC_FAR * This,
    /* [out][in] */ AASTYLEINFO __RPC_FAR *pStyleInfo);


void __RPC_STUB IAALoader_GetNextStyleInfo_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


LPCTSTR STDMETHODCALLTYPE IAALoader_GetNextStyleName_Proxy( 
    IAALoader __RPC_FAR * This,
    /* [in] */ LPCTSTR pszPrevStyleName);


void __RPC_STUB IAALoader_GetNextStyleName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAALoader_LoadPersonality_Proxy( 
    IAALoader __RPC_FAR * This,
    /* [in] */ IAAEngine __RPC_FAR *pEngine,
    /* [in] */ LPGUID pguid,
    /* [in] */ LPCTSTR pszFileName,
    /* [in] */ LPCTSTR pszPersonalityName,
    /* [retval][out] */ IAAPersonality __RPC_FAR *__RPC_FAR *ppPersonality);


void __RPC_STUB IAALoader_LoadPersonality_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAALoader_LoadStyle_Proxy( 
    IAALoader __RPC_FAR * This,
    /* [in] */ IAAEngine __RPC_FAR *pEngine,
    /* [in] */ LPGUID pguid,
    /* [in] */ LPCTSTR pszFileName,
    /* [in] */ LPCTSTR pszStyleName,
    /* [retval][out] */ IAAStyle __RPC_FAR *__RPC_FAR *ppStyle);


void __RPC_STUB IAALoader_LoadStyle_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAALoader_SetSearchDirectory_Proxy( 
    IAALoader __RPC_FAR * This,
    /* [in] */ LPCTSTR pszDirectoryName,
    /* [in] */ AAFlags fFlags);


void __RPC_STUB IAALoader_SetSearchDirectory_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IAALoader_INTERFACE_DEFINED__ */


#ifndef __IAAMIDISink_INTERFACE_DEFINED__
#define __IAAMIDISink_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IAAMIDISink
 * at Fri Nov 08 14:45:43 1996
 * using MIDL 3.00.44
 ****************************************/
/* [object][uuid] */ 



DEFINE_GUID(IID_IAAMIDISink,0xBCE4CC44,0x2F1A,0x11CF,0xBF,0x16,0x00,0xAA,0x00,0xC0,0x81,0x46);

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface IAAMIDISink : public IUnknown
    {
    public:
        virtual IAAMIDISink __RPC_FAR *STDMETHODCALLTYPE GetMIDISink( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE LockInstrument( 
            /* [in] */ AAINSTRUMENT __RPC_FAR *pInstrument,
            /* [in] */ VARIANT_BOOL fWait,
            /* [retval][out] */ HANDLE __RPC_FAR *phInstrument) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE PlayMIDIEvent( 
            /* [in] */ DWORD dwMIDIEvent,
            /* [in] */ DWORD dwTimeInMils) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE PlaySysExEvent( 
            /* [in] */ DWORD dwSysExLength,
            /* [in] */ BYTE __RPC_FAR *pSysExData,
            /* [in] */ DWORD dwTimeInMils) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE QueryInstrument( 
            /* [in] */ HANDLE hInstrument) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetMIDISink( 
            /* [in] */ IAAMIDISink __RPC_FAR *pMIDISink) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE UnlockInstrument( 
            /* [in] */ HANDLE hInstrument) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IAAMIDISinkVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IAAMIDISink __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IAAMIDISink __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IAAMIDISink __RPC_FAR * This);
        
        IAAMIDISink __RPC_FAR *( STDMETHODCALLTYPE __RPC_FAR *GetMIDISink )( 
            IAAMIDISink __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *LockInstrument )( 
            IAAMIDISink __RPC_FAR * This,
            /* [in] */ AAINSTRUMENT __RPC_FAR *pInstrument,
            /* [in] */ VARIANT_BOOL fWait,
            /* [retval][out] */ HANDLE __RPC_FAR *phInstrument);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *PlayMIDIEvent )( 
            IAAMIDISink __RPC_FAR * This,
            /* [in] */ DWORD dwMIDIEvent,
            /* [in] */ DWORD dwTimeInMils);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *PlaySysExEvent )( 
            IAAMIDISink __RPC_FAR * This,
            /* [in] */ DWORD dwSysExLength,
            /* [in] */ BYTE __RPC_FAR *pSysExData,
            /* [in] */ DWORD dwTimeInMils);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInstrument )( 
            IAAMIDISink __RPC_FAR * This,
            /* [in] */ HANDLE hInstrument);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetMIDISink )( 
            IAAMIDISink __RPC_FAR * This,
            /* [in] */ IAAMIDISink __RPC_FAR *pMIDISink);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *UnlockInstrument )( 
            IAAMIDISink __RPC_FAR * This,
            /* [in] */ HANDLE hInstrument);
        
        END_INTERFACE
    } IAAMIDISinkVtbl;

    interface IAAMIDISink
    {
        CONST_VTBL struct IAAMIDISinkVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IAAMIDISink_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IAAMIDISink_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IAAMIDISink_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IAAMIDISink_GetMIDISink(This)	\
    (This)->lpVtbl -> GetMIDISink(This)

#define IAAMIDISink_LockInstrument(This,pInstrument,fWait,phInstrument)	\
    (This)->lpVtbl -> LockInstrument(This,pInstrument,fWait,phInstrument)

#define IAAMIDISink_PlayMIDIEvent(This,dwMIDIEvent,dwTimeInMils)	\
    (This)->lpVtbl -> PlayMIDIEvent(This,dwMIDIEvent,dwTimeInMils)

#define IAAMIDISink_PlaySysExEvent(This,dwSysExLength,pSysExData,dwTimeInMils)	\
    (This)->lpVtbl -> PlaySysExEvent(This,dwSysExLength,pSysExData,dwTimeInMils)

#define IAAMIDISink_QueryInstrument(This,hInstrument)	\
    (This)->lpVtbl -> QueryInstrument(This,hInstrument)

#define IAAMIDISink_SetMIDISink(This,pMIDISink)	\
    (This)->lpVtbl -> SetMIDISink(This,pMIDISink)

#define IAAMIDISink_UnlockInstrument(This,hInstrument)	\
    (This)->lpVtbl -> UnlockInstrument(This,hInstrument)

#endif /* COBJMACROS */


#endif 	/* C style interface */



IAAMIDISink __RPC_FAR *STDMETHODCALLTYPE IAAMIDISink_GetMIDISink_Proxy( 
    IAAMIDISink __RPC_FAR * This);


void __RPC_STUB IAAMIDISink_GetMIDISink_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAAMIDISink_LockInstrument_Proxy( 
    IAAMIDISink __RPC_FAR * This,
    /* [in] */ AAINSTRUMENT __RPC_FAR *pInstrument,
    /* [in] */ VARIANT_BOOL fWait,
    /* [retval][out] */ HANDLE __RPC_FAR *phInstrument);


void __RPC_STUB IAAMIDISink_LockInstrument_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAAMIDISink_PlayMIDIEvent_Proxy( 
    IAAMIDISink __RPC_FAR * This,
    /* [in] */ DWORD dwMIDIEvent,
    /* [in] */ DWORD dwTimeInMils);


void __RPC_STUB IAAMIDISink_PlayMIDIEvent_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAAMIDISink_PlaySysExEvent_Proxy( 
    IAAMIDISink __RPC_FAR * This,
    /* [in] */ DWORD dwSysExLength,
    /* [in] */ BYTE __RPC_FAR *pSysExData,
    /* [in] */ DWORD dwTimeInMils);


void __RPC_STUB IAAMIDISink_PlaySysExEvent_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAAMIDISink_QueryInstrument_Proxy( 
    IAAMIDISink __RPC_FAR * This,
    /* [in] */ HANDLE hInstrument);


void __RPC_STUB IAAMIDISink_QueryInstrument_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAAMIDISink_SetMIDISink_Proxy( 
    IAAMIDISink __RPC_FAR * This,
    /* [in] */ IAAMIDISink __RPC_FAR *pMIDISink);


void __RPC_STUB IAAMIDISink_SetMIDISink_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAAMIDISink_UnlockInstrument_Proxy( 
    IAAMIDISink __RPC_FAR * This,
    /* [in] */ HANDLE hInstrument);


void __RPC_STUB IAAMIDISink_UnlockInstrument_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IAAMIDISink_INTERFACE_DEFINED__ */


#ifndef __IAAMotif_INTERFACE_DEFINED__
#define __IAAMotif_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IAAMotif
 * at Fri Nov 08 14:45:43 1996
 * using MIDL 3.00.44
 ****************************************/
/* [object][uuid] */ 



DEFINE_GUID(IID_IAAMotif,0xBCE4CC4b,0x2F1A,0x11CF,0xBF,0x16,0x00,0xAA,0x00,0xC0,0x81,0x46);

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface IAAMotif : public IUnknown
    {
    public:
        virtual IAAMotif __RPC_FAR *STDMETHODCALLTYPE Clone( void) = 0;
        
        virtual IAABand __RPC_FAR *STDMETHODCALLTYPE GetBand( void) = 0;
        
        virtual WORD STDMETHODCALLTYPE GetBeatsPerMeasure( void) = 0;
        
        virtual WORD STDMETHODCALLTYPE GetClicksPerBeat( void) = 0;
        
        virtual WORD STDMETHODCALLTYPE GetLength( void) = 0;
        
        virtual LPCTSTR STDMETHODCALLTYPE GetName( void) = 0;
        
        virtual VARIANT_BOOL STDMETHODCALLTYPE IsPlaying( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Play( 
            /* [in] */ AAFlags flags,
            /* [in] */ DWORD dwTime) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetBand( 
            /* [in] */ IAABand __RPC_FAR *pBand) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetLength( 
            /* [in] */ WORD wLength) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetName( 
            /* [in] */ LPCTSTR pszName) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Stop( 
            /* [in] */ AAFlags flags) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IAAMotifVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IAAMotif __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IAAMotif __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IAAMotif __RPC_FAR * This);
        
        IAAMotif __RPC_FAR *( STDMETHODCALLTYPE __RPC_FAR *Clone )( 
            IAAMotif __RPC_FAR * This);
        
        IAABand __RPC_FAR *( STDMETHODCALLTYPE __RPC_FAR *GetBand )( 
            IAAMotif __RPC_FAR * This);
        
        WORD ( STDMETHODCALLTYPE __RPC_FAR *GetBeatsPerMeasure )( 
            IAAMotif __RPC_FAR * This);
        
        WORD ( STDMETHODCALLTYPE __RPC_FAR *GetClicksPerBeat )( 
            IAAMotif __RPC_FAR * This);
        
        WORD ( STDMETHODCALLTYPE __RPC_FAR *GetLength )( 
            IAAMotif __RPC_FAR * This);
        
        LPCTSTR ( STDMETHODCALLTYPE __RPC_FAR *GetName )( 
            IAAMotif __RPC_FAR * This);
        
        VARIANT_BOOL ( STDMETHODCALLTYPE __RPC_FAR *IsPlaying )( 
            IAAMotif __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Play )( 
            IAAMotif __RPC_FAR * This,
            /* [in] */ AAFlags flags,
            /* [in] */ DWORD dwTime);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetBand )( 
            IAAMotif __RPC_FAR * This,
            /* [in] */ IAABand __RPC_FAR *pBand);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetLength )( 
            IAAMotif __RPC_FAR * This,
            /* [in] */ WORD wLength);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetName )( 
            IAAMotif __RPC_FAR * This,
            /* [in] */ LPCTSTR pszName);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Stop )( 
            IAAMotif __RPC_FAR * This,
            /* [in] */ AAFlags flags);
        
        END_INTERFACE
    } IAAMotifVtbl;

    interface IAAMotif
    {
        CONST_VTBL struct IAAMotifVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IAAMotif_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IAAMotif_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IAAMotif_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IAAMotif_Clone(This)	\
    (This)->lpVtbl -> Clone(This)

#define IAAMotif_GetBand(This)	\
    (This)->lpVtbl -> GetBand(This)

#define IAAMotif_GetBeatsPerMeasure(This)	\
    (This)->lpVtbl -> GetBeatsPerMeasure(This)

#define IAAMotif_GetClicksPerBeat(This)	\
    (This)->lpVtbl -> GetClicksPerBeat(This)

#define IAAMotif_GetLength(This)	\
    (This)->lpVtbl -> GetLength(This)

#define IAAMotif_GetName(This)	\
    (This)->lpVtbl -> GetName(This)

#define IAAMotif_IsPlaying(This)	\
    (This)->lpVtbl -> IsPlaying(This)

#define IAAMotif_Play(This,flags,dwTime)	\
    (This)->lpVtbl -> Play(This,flags,dwTime)

#define IAAMotif_SetBand(This,pBand)	\
    (This)->lpVtbl -> SetBand(This,pBand)

#define IAAMotif_SetLength(This,wLength)	\
    (This)->lpVtbl -> SetLength(This,wLength)

#define IAAMotif_SetName(This,pszName)	\
    (This)->lpVtbl -> SetName(This,pszName)

#define IAAMotif_Stop(This,flags)	\
    (This)->lpVtbl -> Stop(This,flags)

#endif /* COBJMACROS */


#endif 	/* C style interface */



IAAMotif __RPC_FAR *STDMETHODCALLTYPE IAAMotif_Clone_Proxy( 
    IAAMotif __RPC_FAR * This);


void __RPC_STUB IAAMotif_Clone_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


IAABand __RPC_FAR *STDMETHODCALLTYPE IAAMotif_GetBand_Proxy( 
    IAAMotif __RPC_FAR * This);


void __RPC_STUB IAAMotif_GetBand_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


WORD STDMETHODCALLTYPE IAAMotif_GetBeatsPerMeasure_Proxy( 
    IAAMotif __RPC_FAR * This);


void __RPC_STUB IAAMotif_GetBeatsPerMeasure_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


WORD STDMETHODCALLTYPE IAAMotif_GetClicksPerBeat_Proxy( 
    IAAMotif __RPC_FAR * This);


void __RPC_STUB IAAMotif_GetClicksPerBeat_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


WORD STDMETHODCALLTYPE IAAMotif_GetLength_Proxy( 
    IAAMotif __RPC_FAR * This);


void __RPC_STUB IAAMotif_GetLength_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


LPCTSTR STDMETHODCALLTYPE IAAMotif_GetName_Proxy( 
    IAAMotif __RPC_FAR * This);


void __RPC_STUB IAAMotif_GetName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


VARIANT_BOOL STDMETHODCALLTYPE IAAMotif_IsPlaying_Proxy( 
    IAAMotif __RPC_FAR * This);


void __RPC_STUB IAAMotif_IsPlaying_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAAMotif_Play_Proxy( 
    IAAMotif __RPC_FAR * This,
    /* [in] */ AAFlags flags,
    /* [in] */ DWORD dwTime);


void __RPC_STUB IAAMotif_Play_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAAMotif_SetBand_Proxy( 
    IAAMotif __RPC_FAR * This,
    /* [in] */ IAABand __RPC_FAR *pBand);


void __RPC_STUB IAAMotif_SetBand_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAAMotif_SetLength_Proxy( 
    IAAMotif __RPC_FAR * This,
    /* [in] */ WORD wLength);


void __RPC_STUB IAAMotif_SetLength_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAAMotif_SetName_Proxy( 
    IAAMotif __RPC_FAR * This,
    /* [in] */ LPCTSTR pszName);


void __RPC_STUB IAAMotif_SetName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAAMotif_Stop_Proxy( 
    IAAMotif __RPC_FAR * This,
    /* [in] */ AAFlags flags);


void __RPC_STUB IAAMotif_Stop_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IAAMotif_INTERFACE_DEFINED__ */


#ifndef __IAANotifySink_INTERFACE_DEFINED__
#define __IAANotifySink_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IAANotifySink
 * at Fri Nov 08 14:45:43 1996
 * using MIDL 3.00.44
 ****************************************/
/* [object][uuid] */ 



DEFINE_GUID(IID_IAANotifySink,0xBCE4CC45,0x2F1A,0x11CF,0xBF,0x16,0x00,0xAA,0x00,0xC0,0x81,0x46);

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface IAANotifySink : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE OnEmbellishment( 
            /* [in] */ DWORD dwTime,
            /* [in] */ AACommands lEmbellishment,
            /* [in] */ AAFlags fFlags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE OnGroove( 
            /* [in] */ DWORD dwTime,
            /* [in] */ AACommands lGroove,
            /* [in] */ AAFlags fFlags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE OnMetronome( 
            /* [in] */ DWORD dwTime,
            /* [in] */ WORD wMeasure,
            /* [in] */ WORD wBeat) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE OnMotifEnded( 
            /* [in] */ DWORD dwTime,
            /* [in] */ IAAMotif __RPC_FAR *pMotif,
            /* [in] */ AAFlags fFlags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE OnMotifStarted( 
            /* [in] */ DWORD dwTime,
            /* [in] */ IAAMotif __RPC_FAR *pMotif,
            /* [in] */ AAFlags fFlags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE OnMusicStopped( 
            /* [in] */ DWORD dwTime) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE OnNextSection( 
            /* [in] */ DWORD dwTime,
            /* [in] */ IAASection __RPC_FAR *pSection,
            /* [in] */ AAFlags fFlags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE OnSectionEnded( 
            /* [in] */ DWORD dwTime,
            /* [in] */ IAASection __RPC_FAR *pSection,
            /* [in] */ AAFlags fFlags,
            /* [in] */ DWORD dwEndTime) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE OnSectionChanged( 
            /* [in] */ DWORD dwTime,
            /* [in] */ IAASection __RPC_FAR *pSection,
            /* [in] */ AAFlags fFlags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE OnSectionStarted( 
            /* [in] */ DWORD dwTime,
            /* [in] */ IAASection __RPC_FAR *pSection,
            /* [in] */ AAFlags fFlags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE OnSongEnded( 
            /* [in] */ DWORD dwTime,
            /* [in] */ IAASong __RPC_FAR *pSong,
            /* [in] */ AAFlags fFlags,
            /* [in] */ DWORD dwEndTime) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE OnSongStarted( 
            /* [in] */ DWORD dwTime,
            /* [in] */ IAASong __RPC_FAR *pSong,
            /* [in] */ AAFlags fFlags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE OnUserEvent( 
            /* [in] */ DWORD dwTime,
            /* [in] */ DWORD dwParam1,
            /* [in] */ DWORD dwParam2) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IAANotifySinkVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IAANotifySink __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IAANotifySink __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IAANotifySink __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *OnEmbellishment )( 
            IAANotifySink __RPC_FAR * This,
            /* [in] */ DWORD dwTime,
            /* [in] */ AACommands lEmbellishment,
            /* [in] */ AAFlags fFlags);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *OnGroove )( 
            IAANotifySink __RPC_FAR * This,
            /* [in] */ DWORD dwTime,
            /* [in] */ AACommands lGroove,
            /* [in] */ AAFlags fFlags);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *OnMetronome )( 
            IAANotifySink __RPC_FAR * This,
            /* [in] */ DWORD dwTime,
            /* [in] */ WORD wMeasure,
            /* [in] */ WORD wBeat);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *OnMotifEnded )( 
            IAANotifySink __RPC_FAR * This,
            /* [in] */ DWORD dwTime,
            /* [in] */ IAAMotif __RPC_FAR *pMotif,
            /* [in] */ AAFlags fFlags);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *OnMotifStarted )( 
            IAANotifySink __RPC_FAR * This,
            /* [in] */ DWORD dwTime,
            /* [in] */ IAAMotif __RPC_FAR *pMotif,
            /* [in] */ AAFlags fFlags);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *OnMusicStopped )( 
            IAANotifySink __RPC_FAR * This,
            /* [in] */ DWORD dwTime);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *OnNextSection )( 
            IAANotifySink __RPC_FAR * This,
            /* [in] */ DWORD dwTime,
            /* [in] */ IAASection __RPC_FAR *pSection,
            /* [in] */ AAFlags fFlags);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *OnSectionEnded )( 
            IAANotifySink __RPC_FAR * This,
            /* [in] */ DWORD dwTime,
            /* [in] */ IAASection __RPC_FAR *pSection,
            /* [in] */ AAFlags fFlags,
            /* [in] */ DWORD dwEndTime);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *OnSectionChanged )( 
            IAANotifySink __RPC_FAR * This,
            /* [in] */ DWORD dwTime,
            /* [in] */ IAASection __RPC_FAR *pSection,
            /* [in] */ AAFlags fFlags);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *OnSectionStarted )( 
            IAANotifySink __RPC_FAR * This,
            /* [in] */ DWORD dwTime,
            /* [in] */ IAASection __RPC_FAR *pSection,
            /* [in] */ AAFlags fFlags);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *OnSongEnded )( 
            IAANotifySink __RPC_FAR * This,
            /* [in] */ DWORD dwTime,
            /* [in] */ IAASong __RPC_FAR *pSong,
            /* [in] */ AAFlags fFlags,
            /* [in] */ DWORD dwEndTime);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *OnSongStarted )( 
            IAANotifySink __RPC_FAR * This,
            /* [in] */ DWORD dwTime,
            /* [in] */ IAASong __RPC_FAR *pSong,
            /* [in] */ AAFlags fFlags);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *OnUserEvent )( 
            IAANotifySink __RPC_FAR * This,
            /* [in] */ DWORD dwTime,
            /* [in] */ DWORD dwParam1,
            /* [in] */ DWORD dwParam2);
        
        END_INTERFACE
    } IAANotifySinkVtbl;

    interface IAANotifySink
    {
        CONST_VTBL struct IAANotifySinkVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IAANotifySink_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IAANotifySink_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IAANotifySink_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IAANotifySink_OnEmbellishment(This,dwTime,lEmbellishment,fFlags)	\
    (This)->lpVtbl -> OnEmbellishment(This,dwTime,lEmbellishment,fFlags)

#define IAANotifySink_OnGroove(This,dwTime,lGroove,fFlags)	\
    (This)->lpVtbl -> OnGroove(This,dwTime,lGroove,fFlags)

#define IAANotifySink_OnMetronome(This,dwTime,wMeasure,wBeat)	\
    (This)->lpVtbl -> OnMetronome(This,dwTime,wMeasure,wBeat)

#define IAANotifySink_OnMotifEnded(This,dwTime,pMotif,fFlags)	\
    (This)->lpVtbl -> OnMotifEnded(This,dwTime,pMotif,fFlags)

#define IAANotifySink_OnMotifStarted(This,dwTime,pMotif,fFlags)	\
    (This)->lpVtbl -> OnMotifStarted(This,dwTime,pMotif,fFlags)

#define IAANotifySink_OnMusicStopped(This,dwTime)	\
    (This)->lpVtbl -> OnMusicStopped(This,dwTime)

#define IAANotifySink_OnNextSection(This,dwTime,pSection,fFlags)	\
    (This)->lpVtbl -> OnNextSection(This,dwTime,pSection,fFlags)

#define IAANotifySink_OnSectionEnded(This,dwTime,pSection,fFlags,dwEndTime)	\
    (This)->lpVtbl -> OnSectionEnded(This,dwTime,pSection,fFlags,dwEndTime)

#define IAANotifySink_OnSectionChanged(This,dwTime,pSection,fFlags)	\
    (This)->lpVtbl -> OnSectionChanged(This,dwTime,pSection,fFlags)

#define IAANotifySink_OnSectionStarted(This,dwTime,pSection,fFlags)	\
    (This)->lpVtbl -> OnSectionStarted(This,dwTime,pSection,fFlags)

#define IAANotifySink_OnSongEnded(This,dwTime,pSong,fFlags,dwEndTime)	\
    (This)->lpVtbl -> OnSongEnded(This,dwTime,pSong,fFlags,dwEndTime)

#define IAANotifySink_OnSongStarted(This,dwTime,pSong,fFlags)	\
    (This)->lpVtbl -> OnSongStarted(This,dwTime,pSong,fFlags)

#define IAANotifySink_OnUserEvent(This,dwTime,dwParam1,dwParam2)	\
    (This)->lpVtbl -> OnUserEvent(This,dwTime,dwParam1,dwParam2)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IAANotifySink_OnEmbellishment_Proxy( 
    IAANotifySink __RPC_FAR * This,
    /* [in] */ DWORD dwTime,
    /* [in] */ AACommands lEmbellishment,
    /* [in] */ AAFlags fFlags);


void __RPC_STUB IAANotifySink_OnEmbellishment_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAANotifySink_OnGroove_Proxy( 
    IAANotifySink __RPC_FAR * This,
    /* [in] */ DWORD dwTime,
    /* [in] */ AACommands lGroove,
    /* [in] */ AAFlags fFlags);


void __RPC_STUB IAANotifySink_OnGroove_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAANotifySink_OnMetronome_Proxy( 
    IAANotifySink __RPC_FAR * This,
    /* [in] */ DWORD dwTime,
    /* [in] */ WORD wMeasure,
    /* [in] */ WORD wBeat);


void __RPC_STUB IAANotifySink_OnMetronome_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAANotifySink_OnMotifEnded_Proxy( 
    IAANotifySink __RPC_FAR * This,
    /* [in] */ DWORD dwTime,
    /* [in] */ IAAMotif __RPC_FAR *pMotif,
    /* [in] */ AAFlags fFlags);


void __RPC_STUB IAANotifySink_OnMotifEnded_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAANotifySink_OnMotifStarted_Proxy( 
    IAANotifySink __RPC_FAR * This,
    /* [in] */ DWORD dwTime,
    /* [in] */ IAAMotif __RPC_FAR *pMotif,
    /* [in] */ AAFlags fFlags);


void __RPC_STUB IAANotifySink_OnMotifStarted_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAANotifySink_OnMusicStopped_Proxy( 
    IAANotifySink __RPC_FAR * This,
    /* [in] */ DWORD dwTime);


void __RPC_STUB IAANotifySink_OnMusicStopped_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAANotifySink_OnNextSection_Proxy( 
    IAANotifySink __RPC_FAR * This,
    /* [in] */ DWORD dwTime,
    /* [in] */ IAASection __RPC_FAR *pSection,
    /* [in] */ AAFlags fFlags);


void __RPC_STUB IAANotifySink_OnNextSection_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAANotifySink_OnSectionEnded_Proxy( 
    IAANotifySink __RPC_FAR * This,
    /* [in] */ DWORD dwTime,
    /* [in] */ IAASection __RPC_FAR *pSection,
    /* [in] */ AAFlags fFlags,
    /* [in] */ DWORD dwEndTime);


void __RPC_STUB IAANotifySink_OnSectionEnded_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAANotifySink_OnSectionChanged_Proxy( 
    IAANotifySink __RPC_FAR * This,
    /* [in] */ DWORD dwTime,
    /* [in] */ IAASection __RPC_FAR *pSection,
    /* [in] */ AAFlags fFlags);


void __RPC_STUB IAANotifySink_OnSectionChanged_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAANotifySink_OnSectionStarted_Proxy( 
    IAANotifySink __RPC_FAR * This,
    /* [in] */ DWORD dwTime,
    /* [in] */ IAASection __RPC_FAR *pSection,
    /* [in] */ AAFlags fFlags);


void __RPC_STUB IAANotifySink_OnSectionStarted_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAANotifySink_OnSongEnded_Proxy( 
    IAANotifySink __RPC_FAR * This,
    /* [in] */ DWORD dwTime,
    /* [in] */ IAASong __RPC_FAR *pSong,
    /* [in] */ AAFlags fFlags,
    /* [in] */ DWORD dwEndTime);


void __RPC_STUB IAANotifySink_OnSongEnded_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAANotifySink_OnSongStarted_Proxy( 
    IAANotifySink __RPC_FAR * This,
    /* [in] */ DWORD dwTime,
    /* [in] */ IAASong __RPC_FAR *pSong,
    /* [in] */ AAFlags fFlags);


void __RPC_STUB IAANotifySink_OnSongStarted_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAANotifySink_OnUserEvent_Proxy( 
    IAANotifySink __RPC_FAR * This,
    /* [in] */ DWORD dwTime,
    /* [in] */ DWORD dwParam1,
    /* [in] */ DWORD dwParam2);


void __RPC_STUB IAANotifySink_OnUserEvent_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IAANotifySink_INTERFACE_DEFINED__ */


#ifndef __IAAMIDIExportNotifySink_INTERFACE_DEFINED__
#define __IAAMIDIExportNotifySink_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IAAMIDIExportNotifySink
 * at Fri Nov 08 14:45:43 1996
 * using MIDL 3.00.44
 ****************************************/
/* [object][uuid] */ 



DEFINE_GUID(IID_IAAMIDIExportNotifySink,0xBCE4CC5f,0x2F1A,0x11CF,0xBF,0x16,0x00,0xAA,0x00,0xC0,0x81,0x46);

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface IAAMIDIExportNotifySink : public IAANotifySink
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE OnExport( 
            /* [in] */ WORD wPercentComplete) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IAAMIDIExportNotifySinkVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IAAMIDIExportNotifySink __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IAAMIDIExportNotifySink __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IAAMIDIExportNotifySink __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *OnEmbellishment )( 
            IAAMIDIExportNotifySink __RPC_FAR * This,
            /* [in] */ DWORD dwTime,
            /* [in] */ AACommands lEmbellishment,
            /* [in] */ AAFlags fFlags);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *OnGroove )( 
            IAAMIDIExportNotifySink __RPC_FAR * This,
            /* [in] */ DWORD dwTime,
            /* [in] */ AACommands lGroove,
            /* [in] */ AAFlags fFlags);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *OnMetronome )( 
            IAAMIDIExportNotifySink __RPC_FAR * This,
            /* [in] */ DWORD dwTime,
            /* [in] */ WORD wMeasure,
            /* [in] */ WORD wBeat);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *OnMotifEnded )( 
            IAAMIDIExportNotifySink __RPC_FAR * This,
            /* [in] */ DWORD dwTime,
            /* [in] */ IAAMotif __RPC_FAR *pMotif,
            /* [in] */ AAFlags fFlags);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *OnMotifStarted )( 
            IAAMIDIExportNotifySink __RPC_FAR * This,
            /* [in] */ DWORD dwTime,
            /* [in] */ IAAMotif __RPC_FAR *pMotif,
            /* [in] */ AAFlags fFlags);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *OnMusicStopped )( 
            IAAMIDIExportNotifySink __RPC_FAR * This,
            /* [in] */ DWORD dwTime);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *OnNextSection )( 
            IAAMIDIExportNotifySink __RPC_FAR * This,
            /* [in] */ DWORD dwTime,
            /* [in] */ IAASection __RPC_FAR *pSection,
            /* [in] */ AAFlags fFlags);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *OnSectionEnded )( 
            IAAMIDIExportNotifySink __RPC_FAR * This,
            /* [in] */ DWORD dwTime,
            /* [in] */ IAASection __RPC_FAR *pSection,
            /* [in] */ AAFlags fFlags,
            /* [in] */ DWORD dwEndTime);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *OnSectionChanged )( 
            IAAMIDIExportNotifySink __RPC_FAR * This,
            /* [in] */ DWORD dwTime,
            /* [in] */ IAASection __RPC_FAR *pSection,
            /* [in] */ AAFlags fFlags);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *OnSectionStarted )( 
            IAAMIDIExportNotifySink __RPC_FAR * This,
            /* [in] */ DWORD dwTime,
            /* [in] */ IAASection __RPC_FAR *pSection,
            /* [in] */ AAFlags fFlags);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *OnSongEnded )( 
            IAAMIDIExportNotifySink __RPC_FAR * This,
            /* [in] */ DWORD dwTime,
            /* [in] */ IAASong __RPC_FAR *pSong,
            /* [in] */ AAFlags fFlags,
            /* [in] */ DWORD dwEndTime);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *OnSongStarted )( 
            IAAMIDIExportNotifySink __RPC_FAR * This,
            /* [in] */ DWORD dwTime,
            /* [in] */ IAASong __RPC_FAR *pSong,
            /* [in] */ AAFlags fFlags);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *OnUserEvent )( 
            IAAMIDIExportNotifySink __RPC_FAR * This,
            /* [in] */ DWORD dwTime,
            /* [in] */ DWORD dwParam1,
            /* [in] */ DWORD dwParam2);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *OnExport )( 
            IAAMIDIExportNotifySink __RPC_FAR * This,
            /* [in] */ WORD wPercentComplete);
        
        END_INTERFACE
    } IAAMIDIExportNotifySinkVtbl;

    interface IAAMIDIExportNotifySink
    {
        CONST_VTBL struct IAAMIDIExportNotifySinkVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IAAMIDIExportNotifySink_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IAAMIDIExportNotifySink_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IAAMIDIExportNotifySink_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IAAMIDIExportNotifySink_OnEmbellishment(This,dwTime,lEmbellishment,fFlags)	\
    (This)->lpVtbl -> OnEmbellishment(This,dwTime,lEmbellishment,fFlags)

#define IAAMIDIExportNotifySink_OnGroove(This,dwTime,lGroove,fFlags)	\
    (This)->lpVtbl -> OnGroove(This,dwTime,lGroove,fFlags)

#define IAAMIDIExportNotifySink_OnMetronome(This,dwTime,wMeasure,wBeat)	\
    (This)->lpVtbl -> OnMetronome(This,dwTime,wMeasure,wBeat)

#define IAAMIDIExportNotifySink_OnMotifEnded(This,dwTime,pMotif,fFlags)	\
    (This)->lpVtbl -> OnMotifEnded(This,dwTime,pMotif,fFlags)

#define IAAMIDIExportNotifySink_OnMotifStarted(This,dwTime,pMotif,fFlags)	\
    (This)->lpVtbl -> OnMotifStarted(This,dwTime,pMotif,fFlags)

#define IAAMIDIExportNotifySink_OnMusicStopped(This,dwTime)	\
    (This)->lpVtbl -> OnMusicStopped(This,dwTime)

#define IAAMIDIExportNotifySink_OnNextSection(This,dwTime,pSection,fFlags)	\
    (This)->lpVtbl -> OnNextSection(This,dwTime,pSection,fFlags)

#define IAAMIDIExportNotifySink_OnSectionEnded(This,dwTime,pSection,fFlags,dwEndTime)	\
    (This)->lpVtbl -> OnSectionEnded(This,dwTime,pSection,fFlags,dwEndTime)

#define IAAMIDIExportNotifySink_OnSectionChanged(This,dwTime,pSection,fFlags)	\
    (This)->lpVtbl -> OnSectionChanged(This,dwTime,pSection,fFlags)

#define IAAMIDIExportNotifySink_OnSectionStarted(This,dwTime,pSection,fFlags)	\
    (This)->lpVtbl -> OnSectionStarted(This,dwTime,pSection,fFlags)

#define IAAMIDIExportNotifySink_OnSongEnded(This,dwTime,pSong,fFlags,dwEndTime)	\
    (This)->lpVtbl -> OnSongEnded(This,dwTime,pSong,fFlags,dwEndTime)

#define IAAMIDIExportNotifySink_OnSongStarted(This,dwTime,pSong,fFlags)	\
    (This)->lpVtbl -> OnSongStarted(This,dwTime,pSong,fFlags)

#define IAAMIDIExportNotifySink_OnUserEvent(This,dwTime,dwParam1,dwParam2)	\
    (This)->lpVtbl -> OnUserEvent(This,dwTime,dwParam1,dwParam2)


#define IAAMIDIExportNotifySink_OnExport(This,wPercentComplete)	\
    (This)->lpVtbl -> OnExport(This,wPercentComplete)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IAAMIDIExportNotifySink_OnExport_Proxy( 
    IAAMIDIExportNotifySink __RPC_FAR * This,
    /* [in] */ WORD wPercentComplete);


void __RPC_STUB IAAMIDIExportNotifySink_OnExport_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IAAMIDIExportNotifySink_INTERFACE_DEFINED__ */


#ifndef __IAAPattern_INTERFACE_DEFINED__
#define __IAAPattern_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IAAPattern
 * at Fri Nov 08 14:45:43 1996
 * using MIDL 3.00.44
 ****************************************/
/* [object][uuid] */ 



DEFINE_GUID(IID_IAAPattern,0xBCE4CC50,0x2F1A,0x11CF,0xBF,0x16,0x00,0xAA,0x00,0xC0,0x81,0x46);

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface IAAPattern : public IUnknown
    {
    public:
        virtual IAAPattern __RPC_FAR *STDMETHODCALLTYPE Clone( void) = 0;
        
        virtual WORD STDMETHODCALLTYPE GetBeatsPerMeasure( void) = 0;
        
        virtual WORD STDMETHODCALLTYPE GetClicksPerBeat( void) = 0;
        
        virtual WORD STDMETHODCALLTYPE GetLength( void) = 0;
        
        virtual LPCTSTR STDMETHODCALLTYPE GetName( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetLength( 
            /* [in] */ WORD wLength) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetName( 
            /* [in] */ LPCTSTR pszName) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IAAPatternVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IAAPattern __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IAAPattern __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IAAPattern __RPC_FAR * This);
        
        IAAPattern __RPC_FAR *( STDMETHODCALLTYPE __RPC_FAR *Clone )( 
            IAAPattern __RPC_FAR * This);
        
        WORD ( STDMETHODCALLTYPE __RPC_FAR *GetBeatsPerMeasure )( 
            IAAPattern __RPC_FAR * This);
        
        WORD ( STDMETHODCALLTYPE __RPC_FAR *GetClicksPerBeat )( 
            IAAPattern __RPC_FAR * This);
        
        WORD ( STDMETHODCALLTYPE __RPC_FAR *GetLength )( 
            IAAPattern __RPC_FAR * This);
        
        LPCTSTR ( STDMETHODCALLTYPE __RPC_FAR *GetName )( 
            IAAPattern __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetLength )( 
            IAAPattern __RPC_FAR * This,
            /* [in] */ WORD wLength);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetName )( 
            IAAPattern __RPC_FAR * This,
            /* [in] */ LPCTSTR pszName);
        
        END_INTERFACE
    } IAAPatternVtbl;

    interface IAAPattern
    {
        CONST_VTBL struct IAAPatternVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IAAPattern_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IAAPattern_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IAAPattern_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IAAPattern_Clone(This)	\
    (This)->lpVtbl -> Clone(This)

#define IAAPattern_GetBeatsPerMeasure(This)	\
    (This)->lpVtbl -> GetBeatsPerMeasure(This)

#define IAAPattern_GetClicksPerBeat(This)	\
    (This)->lpVtbl -> GetClicksPerBeat(This)

#define IAAPattern_GetLength(This)	\
    (This)->lpVtbl -> GetLength(This)

#define IAAPattern_GetName(This)	\
    (This)->lpVtbl -> GetName(This)

#define IAAPattern_SetLength(This,wLength)	\
    (This)->lpVtbl -> SetLength(This,wLength)

#define IAAPattern_SetName(This,pszName)	\
    (This)->lpVtbl -> SetName(This,pszName)

#endif /* COBJMACROS */


#endif 	/* C style interface */



IAAPattern __RPC_FAR *STDMETHODCALLTYPE IAAPattern_Clone_Proxy( 
    IAAPattern __RPC_FAR * This);


void __RPC_STUB IAAPattern_Clone_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


WORD STDMETHODCALLTYPE IAAPattern_GetBeatsPerMeasure_Proxy( 
    IAAPattern __RPC_FAR * This);


void __RPC_STUB IAAPattern_GetBeatsPerMeasure_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


WORD STDMETHODCALLTYPE IAAPattern_GetClicksPerBeat_Proxy( 
    IAAPattern __RPC_FAR * This);


void __RPC_STUB IAAPattern_GetClicksPerBeat_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


WORD STDMETHODCALLTYPE IAAPattern_GetLength_Proxy( 
    IAAPattern __RPC_FAR * This);


void __RPC_STUB IAAPattern_GetLength_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


LPCTSTR STDMETHODCALLTYPE IAAPattern_GetName_Proxy( 
    IAAPattern __RPC_FAR * This);


void __RPC_STUB IAAPattern_GetName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAAPattern_SetLength_Proxy( 
    IAAPattern __RPC_FAR * This,
    /* [in] */ WORD wLength);


void __RPC_STUB IAAPattern_SetLength_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAAPattern_SetName_Proxy( 
    IAAPattern __RPC_FAR * This,
    /* [in] */ LPCTSTR pszName);


void __RPC_STUB IAAPattern_SetName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IAAPattern_INTERFACE_DEFINED__ */


#ifndef __IAAPersonality_INTERFACE_DEFINED__
#define __IAAPersonality_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IAAPersonality
 * at Fri Nov 08 14:45:43 1996
 * using MIDL 3.00.44
 ****************************************/
/* [object][uuid] */ 



DEFINE_GUID(IID_IAAPersonality,0xBCE4CC4d,0x2F1A,0x11CF,0xBF,0x16,0x00,0xAA,0x00,0xC0,0x81,0x46);

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface IAAPersonality : public IUnknown
    {
    public:
        virtual IAAPersonality __RPC_FAR *STDMETHODCALLTYPE Clone( void) = 0;
        
        virtual DWORD STDMETHODCALLTYPE GetScale( void) = 0;
        
        virtual LPCTSTR STDMETHODCALLTYPE GetName( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetName( 
            /* [in] */ LPCTSTR pszName) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetScale( 
            /* [in] */ DWORD dwScale) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IAAPersonalityVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IAAPersonality __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IAAPersonality __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IAAPersonality __RPC_FAR * This);
        
        IAAPersonality __RPC_FAR *( STDMETHODCALLTYPE __RPC_FAR *Clone )( 
            IAAPersonality __RPC_FAR * This);
        
        DWORD ( STDMETHODCALLTYPE __RPC_FAR *GetScale )( 
            IAAPersonality __RPC_FAR * This);
        
        LPCTSTR ( STDMETHODCALLTYPE __RPC_FAR *GetName )( 
            IAAPersonality __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetName )( 
            IAAPersonality __RPC_FAR * This,
            /* [in] */ LPCTSTR pszName);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetScale )( 
            IAAPersonality __RPC_FAR * This,
            /* [in] */ DWORD dwScale);
        
        END_INTERFACE
    } IAAPersonalityVtbl;

    interface IAAPersonality
    {
        CONST_VTBL struct IAAPersonalityVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IAAPersonality_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IAAPersonality_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IAAPersonality_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IAAPersonality_Clone(This)	\
    (This)->lpVtbl -> Clone(This)

#define IAAPersonality_GetScale(This)	\
    (This)->lpVtbl -> GetScale(This)

#define IAAPersonality_GetName(This)	\
    (This)->lpVtbl -> GetName(This)

#define IAAPersonality_SetName(This,pszName)	\
    (This)->lpVtbl -> SetName(This,pszName)

#define IAAPersonality_SetScale(This,dwScale)	\
    (This)->lpVtbl -> SetScale(This,dwScale)

#endif /* COBJMACROS */


#endif 	/* C style interface */



IAAPersonality __RPC_FAR *STDMETHODCALLTYPE IAAPersonality_Clone_Proxy( 
    IAAPersonality __RPC_FAR * This);


void __RPC_STUB IAAPersonality_Clone_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


DWORD STDMETHODCALLTYPE IAAPersonality_GetScale_Proxy( 
    IAAPersonality __RPC_FAR * This);


void __RPC_STUB IAAPersonality_GetScale_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


LPCTSTR STDMETHODCALLTYPE IAAPersonality_GetName_Proxy( 
    IAAPersonality __RPC_FAR * This);


void __RPC_STUB IAAPersonality_GetName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAAPersonality_SetName_Proxy( 
    IAAPersonality __RPC_FAR * This,
    /* [in] */ LPCTSTR pszName);


void __RPC_STUB IAAPersonality_SetName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAAPersonality_SetScale_Proxy( 
    IAAPersonality __RPC_FAR * This,
    /* [in] */ DWORD dwScale);


void __RPC_STUB IAAPersonality_SetScale_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IAAPersonality_INTERFACE_DEFINED__ */


#ifndef __IAARealTime_INTERFACE_DEFINED__
#define __IAARealTime_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IAARealTime
 * at Fri Nov 08 14:45:43 1996
 * using MIDL 3.00.44
 ****************************************/
/* [object][uuid] */ 



DEFINE_GUID(IID_IAARealTime,0xBCE4CC42,0x2F1A,0x11CF,0xBF,0x16,0x00,0xAA,0x00,0xC0,0x81,0x46);

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface IAARealTime : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE FlushEventsAfterTime( 
            /* [in] */ DWORD dwTime) = 0;
        
        virtual IReferenceClock __RPC_FAR *STDMETHODCALLTYPE GetClock( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetMeters( 
            /* [out][in] */ AAMETERS __RPC_FAR *pMeters) = 0;
        
        virtual DWORD STDMETHODCALLTYPE GetMusicTime( void) = 0;
        
        virtual WORD STDMETHODCALLTYPE GetMutes( void) = 0;
        
        virtual WORD STDMETHODCALLTYPE GetPPQN( void) = 0;
        
        virtual IReferenceClock __RPC_FAR *STDMETHODCALLTYPE GetPremixClock( void) = 0;
        
        virtual DWORD STDMETHODCALLTYPE GetPremixTime( void) = 0;
        
        virtual WORD STDMETHODCALLTYPE GetRelTempo( void) = 0;
        
        virtual WORD STDMETHODCALLTYPE GetRelVolume( void) = 0;
        
        virtual VARIANT_BOOL STDMETHODCALLTYPE GetSendOutputEarly( void) = 0;
        
        virtual DWORD STDMETHODCALLTYPE GetTempo( void) = 0;
        
        virtual WORD STDMETHODCALLTYPE GetTimerRes( void) = 0;
        
        virtual VARIANT_BOOL STDMETHODCALLTYPE IsPlaying( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ResetMusicTime( 
            /* [in] */ DWORD dwMusicTime) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetClock( 
            /* [in] */ IReferenceClock __RPC_FAR *pClock) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetMutes( 
            /* [in] */ WORD wMutes) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetPremixClock( 
            /* [in] */ IReferenceClock __RPC_FAR *pClock) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetRelTempo( 
            /* [in] */ WORD wRelTempo) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetRelVolume( 
            /* [in] */ WORD wRelVolume) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetSendOutputEarly( 
            /* [in] */ VARIANT_BOOL fEarly) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetTempo( 
            /* [in] */ DWORD dwTempo) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetTimerRes( 
            /* [in] */ WORD wTimerRes) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Start( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Stop( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IAARealTimeVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IAARealTime __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IAARealTime __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IAARealTime __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *FlushEventsAfterTime )( 
            IAARealTime __RPC_FAR * This,
            /* [in] */ DWORD dwTime);
        
        IReferenceClock __RPC_FAR *( STDMETHODCALLTYPE __RPC_FAR *GetClock )( 
            IAARealTime __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetMeters )( 
            IAARealTime __RPC_FAR * This,
            /* [out][in] */ AAMETERS __RPC_FAR *pMeters);
        
        DWORD ( STDMETHODCALLTYPE __RPC_FAR *GetMusicTime )( 
            IAARealTime __RPC_FAR * This);
        
        WORD ( STDMETHODCALLTYPE __RPC_FAR *GetMutes )( 
            IAARealTime __RPC_FAR * This);
        
        WORD ( STDMETHODCALLTYPE __RPC_FAR *GetPPQN )( 
            IAARealTime __RPC_FAR * This);
        
        IReferenceClock __RPC_FAR *( STDMETHODCALLTYPE __RPC_FAR *GetPremixClock )( 
            IAARealTime __RPC_FAR * This);
        
        DWORD ( STDMETHODCALLTYPE __RPC_FAR *GetPremixTime )( 
            IAARealTime __RPC_FAR * This);
        
        WORD ( STDMETHODCALLTYPE __RPC_FAR *GetRelTempo )( 
            IAARealTime __RPC_FAR * This);
        
        WORD ( STDMETHODCALLTYPE __RPC_FAR *GetRelVolume )( 
            IAARealTime __RPC_FAR * This);
        
        VARIANT_BOOL ( STDMETHODCALLTYPE __RPC_FAR *GetSendOutputEarly )( 
            IAARealTime __RPC_FAR * This);
        
        DWORD ( STDMETHODCALLTYPE __RPC_FAR *GetTempo )( 
            IAARealTime __RPC_FAR * This);
        
        WORD ( STDMETHODCALLTYPE __RPC_FAR *GetTimerRes )( 
            IAARealTime __RPC_FAR * This);
        
        VARIANT_BOOL ( STDMETHODCALLTYPE __RPC_FAR *IsPlaying )( 
            IAARealTime __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ResetMusicTime )( 
            IAARealTime __RPC_FAR * This,
            /* [in] */ DWORD dwMusicTime);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetClock )( 
            IAARealTime __RPC_FAR * This,
            /* [in] */ IReferenceClock __RPC_FAR *pClock);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetMutes )( 
            IAARealTime __RPC_FAR * This,
            /* [in] */ WORD wMutes);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetPremixClock )( 
            IAARealTime __RPC_FAR * This,
            /* [in] */ IReferenceClock __RPC_FAR *pClock);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetRelTempo )( 
            IAARealTime __RPC_FAR * This,
            /* [in] */ WORD wRelTempo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetRelVolume )( 
            IAARealTime __RPC_FAR * This,
            /* [in] */ WORD wRelVolume);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetSendOutputEarly )( 
            IAARealTime __RPC_FAR * This,
            /* [in] */ VARIANT_BOOL fEarly);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetTempo )( 
            IAARealTime __RPC_FAR * This,
            /* [in] */ DWORD dwTempo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetTimerRes )( 
            IAARealTime __RPC_FAR * This,
            /* [in] */ WORD wTimerRes);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Start )( 
            IAARealTime __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Stop )( 
            IAARealTime __RPC_FAR * This);
        
        END_INTERFACE
    } IAARealTimeVtbl;

    interface IAARealTime
    {
        CONST_VTBL struct IAARealTimeVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IAARealTime_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IAARealTime_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IAARealTime_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IAARealTime_FlushEventsAfterTime(This,dwTime)	\
    (This)->lpVtbl -> FlushEventsAfterTime(This,dwTime)

#define IAARealTime_GetClock(This)	\
    (This)->lpVtbl -> GetClock(This)

#define IAARealTime_GetMeters(This,pMeters)	\
    (This)->lpVtbl -> GetMeters(This,pMeters)

#define IAARealTime_GetMusicTime(This)	\
    (This)->lpVtbl -> GetMusicTime(This)

#define IAARealTime_GetMutes(This)	\
    (This)->lpVtbl -> GetMutes(This)

#define IAARealTime_GetPPQN(This)	\
    (This)->lpVtbl -> GetPPQN(This)

#define IAARealTime_GetPremixClock(This)	\
    (This)->lpVtbl -> GetPremixClock(This)

#define IAARealTime_GetPremixTime(This)	\
    (This)->lpVtbl -> GetPremixTime(This)

#define IAARealTime_GetRelTempo(This)	\
    (This)->lpVtbl -> GetRelTempo(This)

#define IAARealTime_GetRelVolume(This)	\
    (This)->lpVtbl -> GetRelVolume(This)

#define IAARealTime_GetSendOutputEarly(This)	\
    (This)->lpVtbl -> GetSendOutputEarly(This)

#define IAARealTime_GetTempo(This)	\
    (This)->lpVtbl -> GetTempo(This)

#define IAARealTime_GetTimerRes(This)	\
    (This)->lpVtbl -> GetTimerRes(This)

#define IAARealTime_IsPlaying(This)	\
    (This)->lpVtbl -> IsPlaying(This)

#define IAARealTime_ResetMusicTime(This,dwMusicTime)	\
    (This)->lpVtbl -> ResetMusicTime(This,dwMusicTime)

#define IAARealTime_SetClock(This,pClock)	\
    (This)->lpVtbl -> SetClock(This,pClock)

#define IAARealTime_SetMutes(This,wMutes)	\
    (This)->lpVtbl -> SetMutes(This,wMutes)

#define IAARealTime_SetPremixClock(This,pClock)	\
    (This)->lpVtbl -> SetPremixClock(This,pClock)

#define IAARealTime_SetRelTempo(This,wRelTempo)	\
    (This)->lpVtbl -> SetRelTempo(This,wRelTempo)

#define IAARealTime_SetRelVolume(This,wRelVolume)	\
    (This)->lpVtbl -> SetRelVolume(This,wRelVolume)

#define IAARealTime_SetSendOutputEarly(This,fEarly)	\
    (This)->lpVtbl -> SetSendOutputEarly(This,fEarly)

#define IAARealTime_SetTempo(This,dwTempo)	\
    (This)->lpVtbl -> SetTempo(This,dwTempo)

#define IAARealTime_SetTimerRes(This,wTimerRes)	\
    (This)->lpVtbl -> SetTimerRes(This,wTimerRes)

#define IAARealTime_Start(This)	\
    (This)->lpVtbl -> Start(This)

#define IAARealTime_Stop(This)	\
    (This)->lpVtbl -> Stop(This)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IAARealTime_FlushEventsAfterTime_Proxy( 
    IAARealTime __RPC_FAR * This,
    /* [in] */ DWORD dwTime);


void __RPC_STUB IAARealTime_FlushEventsAfterTime_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


IReferenceClock __RPC_FAR *STDMETHODCALLTYPE IAARealTime_GetClock_Proxy( 
    IAARealTime __RPC_FAR * This);


void __RPC_STUB IAARealTime_GetClock_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAARealTime_GetMeters_Proxy( 
    IAARealTime __RPC_FAR * This,
    /* [out][in] */ AAMETERS __RPC_FAR *pMeters);


void __RPC_STUB IAARealTime_GetMeters_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


DWORD STDMETHODCALLTYPE IAARealTime_GetMusicTime_Proxy( 
    IAARealTime __RPC_FAR * This);


void __RPC_STUB IAARealTime_GetMusicTime_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


WORD STDMETHODCALLTYPE IAARealTime_GetMutes_Proxy( 
    IAARealTime __RPC_FAR * This);


void __RPC_STUB IAARealTime_GetMutes_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


WORD STDMETHODCALLTYPE IAARealTime_GetPPQN_Proxy( 
    IAARealTime __RPC_FAR * This);


void __RPC_STUB IAARealTime_GetPPQN_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


IReferenceClock __RPC_FAR *STDMETHODCALLTYPE IAARealTime_GetPremixClock_Proxy( 
    IAARealTime __RPC_FAR * This);


void __RPC_STUB IAARealTime_GetPremixClock_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


DWORD STDMETHODCALLTYPE IAARealTime_GetPremixTime_Proxy( 
    IAARealTime __RPC_FAR * This);


void __RPC_STUB IAARealTime_GetPremixTime_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


WORD STDMETHODCALLTYPE IAARealTime_GetRelTempo_Proxy( 
    IAARealTime __RPC_FAR * This);


void __RPC_STUB IAARealTime_GetRelTempo_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


WORD STDMETHODCALLTYPE IAARealTime_GetRelVolume_Proxy( 
    IAARealTime __RPC_FAR * This);


void __RPC_STUB IAARealTime_GetRelVolume_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


VARIANT_BOOL STDMETHODCALLTYPE IAARealTime_GetSendOutputEarly_Proxy( 
    IAARealTime __RPC_FAR * This);


void __RPC_STUB IAARealTime_GetSendOutputEarly_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


DWORD STDMETHODCALLTYPE IAARealTime_GetTempo_Proxy( 
    IAARealTime __RPC_FAR * This);


void __RPC_STUB IAARealTime_GetTempo_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


WORD STDMETHODCALLTYPE IAARealTime_GetTimerRes_Proxy( 
    IAARealTime __RPC_FAR * This);


void __RPC_STUB IAARealTime_GetTimerRes_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


VARIANT_BOOL STDMETHODCALLTYPE IAARealTime_IsPlaying_Proxy( 
    IAARealTime __RPC_FAR * This);


void __RPC_STUB IAARealTime_IsPlaying_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAARealTime_ResetMusicTime_Proxy( 
    IAARealTime __RPC_FAR * This,
    /* [in] */ DWORD dwMusicTime);


void __RPC_STUB IAARealTime_ResetMusicTime_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAARealTime_SetClock_Proxy( 
    IAARealTime __RPC_FAR * This,
    /* [in] */ IReferenceClock __RPC_FAR *pClock);


void __RPC_STUB IAARealTime_SetClock_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAARealTime_SetMutes_Proxy( 
    IAARealTime __RPC_FAR * This,
    /* [in] */ WORD wMutes);


void __RPC_STUB IAARealTime_SetMutes_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAARealTime_SetPremixClock_Proxy( 
    IAARealTime __RPC_FAR * This,
    /* [in] */ IReferenceClock __RPC_FAR *pClock);


void __RPC_STUB IAARealTime_SetPremixClock_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAARealTime_SetRelTempo_Proxy( 
    IAARealTime __RPC_FAR * This,
    /* [in] */ WORD wRelTempo);


void __RPC_STUB IAARealTime_SetRelTempo_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAARealTime_SetRelVolume_Proxy( 
    IAARealTime __RPC_FAR * This,
    /* [in] */ WORD wRelVolume);


void __RPC_STUB IAARealTime_SetRelVolume_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAARealTime_SetSendOutputEarly_Proxy( 
    IAARealTime __RPC_FAR * This,
    /* [in] */ VARIANT_BOOL fEarly);


void __RPC_STUB IAARealTime_SetSendOutputEarly_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAARealTime_SetTempo_Proxy( 
    IAARealTime __RPC_FAR * This,
    /* [in] */ DWORD dwTempo);


void __RPC_STUB IAARealTime_SetTempo_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAARealTime_SetTimerRes_Proxy( 
    IAARealTime __RPC_FAR * This,
    /* [in] */ WORD wTimerRes);


void __RPC_STUB IAARealTime_SetTimerRes_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAARealTime_Start_Proxy( 
    IAARealTime __RPC_FAR * This);


void __RPC_STUB IAARealTime_Start_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAARealTime_Stop_Proxy( 
    IAARealTime __RPC_FAR * This);


void __RPC_STUB IAARealTime_Stop_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IAARealTime_INTERFACE_DEFINED__ */


#ifndef __IAASection_INTERFACE_DEFINED__
#define __IAASection_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IAASection
 * at Fri Nov 08 14:45:43 1996
 * using MIDL 3.00.44
 ****************************************/
/* [object][uuid] */ 



DEFINE_GUID(IID_IAASection,0xBCE4CC49,0x2F1A,0x11CF,0xBF,0x16,0x00,0xAA,0x00,0xC0,0x81,0x46);

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface IAASection : public IUnknown
    {
    public:
        virtual IAASection __RPC_FAR *STDMETHODCALLTYPE Clone( void) = 0;
        
        virtual IAABand __RPC_FAR *STDMETHODCALLTYPE GetBand( void) = 0;
        
        virtual WORD STDMETHODCALLTYPE GetCurrentMeasure( void) = 0;
        
        virtual WORD STDMETHODCALLTYPE GetKey( void) = 0;
        
        virtual WORD STDMETHODCALLTYPE GetLength( void) = 0;
        
        virtual DWORD STDMETHODCALLTYPE GetLengthInMils( void) = 0;
        
        virtual LPCTSTR STDMETHODCALLTYPE GetName( void) = 0;
        
        virtual IAAPersonality __RPC_FAR *STDMETHODCALLTYPE GetPersonality( void) = 0;
        
        virtual WORD STDMETHODCALLTYPE GetRepeats( void) = 0;
        
        virtual IAAStyle __RPC_FAR *STDMETHODCALLTYPE GetStyle( void) = 0;
        
        virtual DWORD STDMETHODCALLTYPE GetTempo( void) = 0;
        
        virtual DWORD STDMETHODCALLTYPE GetUserData( void) = 0;
        
        virtual VARIANT_BOOL STDMETHODCALLTYPE IsPlaying( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE LockBand( 
            /* [in] */ VARIANT_BOOL fWait) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Play( 
            /* [in] */ AAFlags flags,
            /* [in] */ DWORD dwStartTime) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RemoveFromQueue( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SaveAsMIDI( 
            /* [in] */ IStream __RPC_FAR *pStream) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetBand( 
            /* [in] */ IAABand __RPC_FAR *pBand) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetKey( 
            /* [in] */ WORD nKey) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetLength( 
            /* [in] */ WORD wLength) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetName( 
            /* [in] */ LPCTSTR pszName) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetPersonality( 
            /* [in] */ IAAPersonality __RPC_FAR *pPersonality) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetRepeats( 
            /* [in] */ WORD wRepeats) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetStyle( 
            /* [in] */ IAAStyle __RPC_FAR *pStyle) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetTempo( 
            /* [in] */ DWORD lTempo) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetUserData( 
            /* [in] */ DWORD lUserData) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Stop( 
            /* [in] */ AAFlags flags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE UnlockBand( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IAASectionVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IAASection __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IAASection __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IAASection __RPC_FAR * This);
        
        IAASection __RPC_FAR *( STDMETHODCALLTYPE __RPC_FAR *Clone )( 
            IAASection __RPC_FAR * This);
        
        IAABand __RPC_FAR *( STDMETHODCALLTYPE __RPC_FAR *GetBand )( 
            IAASection __RPC_FAR * This);
        
        WORD ( STDMETHODCALLTYPE __RPC_FAR *GetCurrentMeasure )( 
            IAASection __RPC_FAR * This);
        
        WORD ( STDMETHODCALLTYPE __RPC_FAR *GetKey )( 
            IAASection __RPC_FAR * This);
        
        WORD ( STDMETHODCALLTYPE __RPC_FAR *GetLength )( 
            IAASection __RPC_FAR * This);
        
        DWORD ( STDMETHODCALLTYPE __RPC_FAR *GetLengthInMils )( 
            IAASection __RPC_FAR * This);
        
        LPCTSTR ( STDMETHODCALLTYPE __RPC_FAR *GetName )( 
            IAASection __RPC_FAR * This);
        
        IAAPersonality __RPC_FAR *( STDMETHODCALLTYPE __RPC_FAR *GetPersonality )( 
            IAASection __RPC_FAR * This);
        
        WORD ( STDMETHODCALLTYPE __RPC_FAR *GetRepeats )( 
            IAASection __RPC_FAR * This);
        
        IAAStyle __RPC_FAR *( STDMETHODCALLTYPE __RPC_FAR *GetStyle )( 
            IAASection __RPC_FAR * This);
        
        DWORD ( STDMETHODCALLTYPE __RPC_FAR *GetTempo )( 
            IAASection __RPC_FAR * This);
        
        DWORD ( STDMETHODCALLTYPE __RPC_FAR *GetUserData )( 
            IAASection __RPC_FAR * This);
        
        VARIANT_BOOL ( STDMETHODCALLTYPE __RPC_FAR *IsPlaying )( 
            IAASection __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *LockBand )( 
            IAASection __RPC_FAR * This,
            /* [in] */ VARIANT_BOOL fWait);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Play )( 
            IAASection __RPC_FAR * This,
            /* [in] */ AAFlags flags,
            /* [in] */ DWORD dwStartTime);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *RemoveFromQueue )( 
            IAASection __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SaveAsMIDI )( 
            IAASection __RPC_FAR * This,
            /* [in] */ IStream __RPC_FAR *pStream);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetBand )( 
            IAASection __RPC_FAR * This,
            /* [in] */ IAABand __RPC_FAR *pBand);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetKey )( 
            IAASection __RPC_FAR * This,
            /* [in] */ WORD nKey);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetLength )( 
            IAASection __RPC_FAR * This,
            /* [in] */ WORD wLength);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetName )( 
            IAASection __RPC_FAR * This,
            /* [in] */ LPCTSTR pszName);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetPersonality )( 
            IAASection __RPC_FAR * This,
            /* [in] */ IAAPersonality __RPC_FAR *pPersonality);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetRepeats )( 
            IAASection __RPC_FAR * This,
            /* [in] */ WORD wRepeats);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetStyle )( 
            IAASection __RPC_FAR * This,
            /* [in] */ IAAStyle __RPC_FAR *pStyle);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetTempo )( 
            IAASection __RPC_FAR * This,
            /* [in] */ DWORD lTempo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetUserData )( 
            IAASection __RPC_FAR * This,
            /* [in] */ DWORD lUserData);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Stop )( 
            IAASection __RPC_FAR * This,
            /* [in] */ AAFlags flags);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *UnlockBand )( 
            IAASection __RPC_FAR * This);
        
        END_INTERFACE
    } IAASectionVtbl;

    interface IAASection
    {
        CONST_VTBL struct IAASectionVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IAASection_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IAASection_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IAASection_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IAASection_Clone(This)	\
    (This)->lpVtbl -> Clone(This)

#define IAASection_GetBand(This)	\
    (This)->lpVtbl -> GetBand(This)

#define IAASection_GetCurrentMeasure(This)	\
    (This)->lpVtbl -> GetCurrentMeasure(This)

#define IAASection_GetKey(This)	\
    (This)->lpVtbl -> GetKey(This)

#define IAASection_GetLength(This)	\
    (This)->lpVtbl -> GetLength(This)

#define IAASection_GetLengthInMils(This)	\
    (This)->lpVtbl -> GetLengthInMils(This)

#define IAASection_GetName(This)	\
    (This)->lpVtbl -> GetName(This)

#define IAASection_GetPersonality(This)	\
    (This)->lpVtbl -> GetPersonality(This)

#define IAASection_GetRepeats(This)	\
    (This)->lpVtbl -> GetRepeats(This)

#define IAASection_GetStyle(This)	\
    (This)->lpVtbl -> GetStyle(This)

#define IAASection_GetTempo(This)	\
    (This)->lpVtbl -> GetTempo(This)

#define IAASection_GetUserData(This)	\
    (This)->lpVtbl -> GetUserData(This)

#define IAASection_IsPlaying(This)	\
    (This)->lpVtbl -> IsPlaying(This)

#define IAASection_LockBand(This,fWait)	\
    (This)->lpVtbl -> LockBand(This,fWait)

#define IAASection_Play(This,flags,dwStartTime)	\
    (This)->lpVtbl -> Play(This,flags,dwStartTime)

#define IAASection_RemoveFromQueue(This)	\
    (This)->lpVtbl -> RemoveFromQueue(This)

#define IAASection_SaveAsMIDI(This,pStream)	\
    (This)->lpVtbl -> SaveAsMIDI(This,pStream)

#define IAASection_SetBand(This,pBand)	\
    (This)->lpVtbl -> SetBand(This,pBand)

#define IAASection_SetKey(This,nKey)	\
    (This)->lpVtbl -> SetKey(This,nKey)

#define IAASection_SetLength(This,wLength)	\
    (This)->lpVtbl -> SetLength(This,wLength)

#define IAASection_SetName(This,pszName)	\
    (This)->lpVtbl -> SetName(This,pszName)

#define IAASection_SetPersonality(This,pPersonality)	\
    (This)->lpVtbl -> SetPersonality(This,pPersonality)

#define IAASection_SetRepeats(This,wRepeats)	\
    (This)->lpVtbl -> SetRepeats(This,wRepeats)

#define IAASection_SetStyle(This,pStyle)	\
    (This)->lpVtbl -> SetStyle(This,pStyle)

#define IAASection_SetTempo(This,lTempo)	\
    (This)->lpVtbl -> SetTempo(This,lTempo)

#define IAASection_SetUserData(This,lUserData)	\
    (This)->lpVtbl -> SetUserData(This,lUserData)

#define IAASection_Stop(This,flags)	\
    (This)->lpVtbl -> Stop(This,flags)

#define IAASection_UnlockBand(This)	\
    (This)->lpVtbl -> UnlockBand(This)

#endif /* COBJMACROS */


#endif 	/* C style interface */



IAASection __RPC_FAR *STDMETHODCALLTYPE IAASection_Clone_Proxy( 
    IAASection __RPC_FAR * This);


void __RPC_STUB IAASection_Clone_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


IAABand __RPC_FAR *STDMETHODCALLTYPE IAASection_GetBand_Proxy( 
    IAASection __RPC_FAR * This);


void __RPC_STUB IAASection_GetBand_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


WORD STDMETHODCALLTYPE IAASection_GetCurrentMeasure_Proxy( 
    IAASection __RPC_FAR * This);


void __RPC_STUB IAASection_GetCurrentMeasure_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


WORD STDMETHODCALLTYPE IAASection_GetKey_Proxy( 
    IAASection __RPC_FAR * This);


void __RPC_STUB IAASection_GetKey_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


WORD STDMETHODCALLTYPE IAASection_GetLength_Proxy( 
    IAASection __RPC_FAR * This);


void __RPC_STUB IAASection_GetLength_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


DWORD STDMETHODCALLTYPE IAASection_GetLengthInMils_Proxy( 
    IAASection __RPC_FAR * This);


void __RPC_STUB IAASection_GetLengthInMils_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


LPCTSTR STDMETHODCALLTYPE IAASection_GetName_Proxy( 
    IAASection __RPC_FAR * This);


void __RPC_STUB IAASection_GetName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


IAAPersonality __RPC_FAR *STDMETHODCALLTYPE IAASection_GetPersonality_Proxy( 
    IAASection __RPC_FAR * This);


void __RPC_STUB IAASection_GetPersonality_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


WORD STDMETHODCALLTYPE IAASection_GetRepeats_Proxy( 
    IAASection __RPC_FAR * This);


void __RPC_STUB IAASection_GetRepeats_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


IAAStyle __RPC_FAR *STDMETHODCALLTYPE IAASection_GetStyle_Proxy( 
    IAASection __RPC_FAR * This);


void __RPC_STUB IAASection_GetStyle_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


DWORD STDMETHODCALLTYPE IAASection_GetTempo_Proxy( 
    IAASection __RPC_FAR * This);


void __RPC_STUB IAASection_GetTempo_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


DWORD STDMETHODCALLTYPE IAASection_GetUserData_Proxy( 
    IAASection __RPC_FAR * This);


void __RPC_STUB IAASection_GetUserData_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


VARIANT_BOOL STDMETHODCALLTYPE IAASection_IsPlaying_Proxy( 
    IAASection __RPC_FAR * This);


void __RPC_STUB IAASection_IsPlaying_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAASection_LockBand_Proxy( 
    IAASection __RPC_FAR * This,
    /* [in] */ VARIANT_BOOL fWait);


void __RPC_STUB IAASection_LockBand_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAASection_Play_Proxy( 
    IAASection __RPC_FAR * This,
    /* [in] */ AAFlags flags,
    /* [in] */ DWORD dwStartTime);


void __RPC_STUB IAASection_Play_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAASection_RemoveFromQueue_Proxy( 
    IAASection __RPC_FAR * This);


void __RPC_STUB IAASection_RemoveFromQueue_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAASection_SaveAsMIDI_Proxy( 
    IAASection __RPC_FAR * This,
    /* [in] */ IStream __RPC_FAR *pStream);


void __RPC_STUB IAASection_SaveAsMIDI_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAASection_SetBand_Proxy( 
    IAASection __RPC_FAR * This,
    /* [in] */ IAABand __RPC_FAR *pBand);


void __RPC_STUB IAASection_SetBand_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAASection_SetKey_Proxy( 
    IAASection __RPC_FAR * This,
    /* [in] */ WORD nKey);


void __RPC_STUB IAASection_SetKey_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAASection_SetLength_Proxy( 
    IAASection __RPC_FAR * This,
    /* [in] */ WORD wLength);


void __RPC_STUB IAASection_SetLength_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAASection_SetName_Proxy( 
    IAASection __RPC_FAR * This,
    /* [in] */ LPCTSTR pszName);


void __RPC_STUB IAASection_SetName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAASection_SetPersonality_Proxy( 
    IAASection __RPC_FAR * This,
    /* [in] */ IAAPersonality __RPC_FAR *pPersonality);


void __RPC_STUB IAASection_SetPersonality_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAASection_SetRepeats_Proxy( 
    IAASection __RPC_FAR * This,
    /* [in] */ WORD wRepeats);


void __RPC_STUB IAASection_SetRepeats_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAASection_SetStyle_Proxy( 
    IAASection __RPC_FAR * This,
    /* [in] */ IAAStyle __RPC_FAR *pStyle);


void __RPC_STUB IAASection_SetStyle_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAASection_SetTempo_Proxy( 
    IAASection __RPC_FAR * This,
    /* [in] */ DWORD lTempo);


void __RPC_STUB IAASection_SetTempo_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAASection_SetUserData_Proxy( 
    IAASection __RPC_FAR * This,
    /* [in] */ DWORD lUserData);


void __RPC_STUB IAASection_SetUserData_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAASection_Stop_Proxy( 
    IAASection __RPC_FAR * This,
    /* [in] */ AAFlags flags);


void __RPC_STUB IAASection_Stop_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAASection_UnlockBand_Proxy( 
    IAASection __RPC_FAR * This);


void __RPC_STUB IAASection_UnlockBand_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IAASection_INTERFACE_DEFINED__ */


#ifndef __IAASection2_INTERFACE_DEFINED__
#define __IAASection2_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IAASection2
 * at Fri Nov 08 14:45:43 1996
 * using MIDL 3.00.44
 ****************************************/
/* [object][uuid] */ 



DEFINE_GUID(IID_IAASection2,0xBCE4CC60,0x2F1A,0x11CF,0xBF,0x16,0x00,0xAA,0x00,0xC0,0x81,0x46);

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface IAASection2 : public IUnknown
    {
    public:
        virtual IAASection __RPC_FAR *STDMETHODCALLTYPE ClonePart( 
            /* [in] */ WORD wStartMeasure,
            /* [in] */ WORD wEndMeasure) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetFailedLoadInfo( 
            /* [out] */ VARIANT_BOOL __RPC_FAR *pfDidStyleLoad,
            /* [out] */ LPCSTR __RPC_FAR *ppszStyleName,
            /* [out] */ VARIANT_BOOL __RPC_FAR *pfDidPersonalityLoad,
            /* [out] */ LPCSTR __RPC_FAR *ppszPersonalityName) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IAASection2Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IAASection2 __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IAASection2 __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IAASection2 __RPC_FAR * This);
        
        IAASection __RPC_FAR *( STDMETHODCALLTYPE __RPC_FAR *ClonePart )( 
            IAASection2 __RPC_FAR * This,
            /* [in] */ WORD wStartMeasure,
            /* [in] */ WORD wEndMeasure);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetFailedLoadInfo )( 
            IAASection2 __RPC_FAR * This,
            /* [out] */ VARIANT_BOOL __RPC_FAR *pfDidStyleLoad,
            /* [out] */ LPCSTR __RPC_FAR *ppszStyleName,
            /* [out] */ VARIANT_BOOL __RPC_FAR *pfDidPersonalityLoad,
            /* [out] */ LPCSTR __RPC_FAR *ppszPersonalityName);
        
        END_INTERFACE
    } IAASection2Vtbl;

    interface IAASection2
    {
        CONST_VTBL struct IAASection2Vtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IAASection2_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IAASection2_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IAASection2_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IAASection2_ClonePart(This,wStartMeasure,wEndMeasure)	\
    (This)->lpVtbl -> ClonePart(This,wStartMeasure,wEndMeasure)

#define IAASection2_GetFailedLoadInfo(This,pfDidStyleLoad,ppszStyleName,pfDidPersonalityLoad,ppszPersonalityName)	\
    (This)->lpVtbl -> GetFailedLoadInfo(This,pfDidStyleLoad,ppszStyleName,pfDidPersonalityLoad,ppszPersonalityName)

#endif /* COBJMACROS */


#endif 	/* C style interface */



IAASection __RPC_FAR *STDMETHODCALLTYPE IAASection2_ClonePart_Proxy( 
    IAASection2 __RPC_FAR * This,
    /* [in] */ WORD wStartMeasure,
    /* [in] */ WORD wEndMeasure);


void __RPC_STUB IAASection2_ClonePart_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAASection2_GetFailedLoadInfo_Proxy( 
    IAASection2 __RPC_FAR * This,
    /* [out] */ VARIANT_BOOL __RPC_FAR *pfDidStyleLoad,
    /* [out] */ LPCSTR __RPC_FAR *ppszStyleName,
    /* [out] */ VARIANT_BOOL __RPC_FAR *pfDidPersonalityLoad,
    /* [out] */ LPCSTR __RPC_FAR *ppszPersonalityName);


void __RPC_STUB IAASection2_GetFailedLoadInfo_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IAASection2_INTERFACE_DEFINED__ */


#ifndef __IAASong_INTERFACE_DEFINED__
#define __IAASong_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IAASong
 * at Fri Nov 08 14:45:43 1996
 * using MIDL 3.00.44
 ****************************************/
/* [object][uuid] */ 



DEFINE_GUID(IID_IAASong,0xBCE4CC4a,0x2F1A,0x11CF,0xBF,0x16,0x00,0xAA,0x00,0xC0,0x81,0x46);

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface IAASong : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE AppendSection( 
            /* [in] */ IAASection __RPC_FAR *pSection) = 0;
        
        virtual IAASong __RPC_FAR *STDMETHODCALLTYPE Clone( void) = 0;
        
        virtual LPCTSTR STDMETHODCALLTYPE GetAuthor( void) = 0;
        
        virtual IAASection __RPC_FAR *STDMETHODCALLTYPE GetFirstSection( void) = 0;
        
        virtual WORD STDMETHODCALLTYPE GetLength( void) = 0;
        
        virtual DWORD STDMETHODCALLTYPE GetLengthInMils( void) = 0;
        
        virtual LPCTSTR STDMETHODCALLTYPE GetName( void) = 0;
        
        virtual IAASection __RPC_FAR *STDMETHODCALLTYPE GetNextSection( 
            /* [in] */ IAASection __RPC_FAR *pSection) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE InsertSection( 
            /* [in] */ IAASection __RPC_FAR *pPrevSection,
            /* [in] */ IAASection __RPC_FAR *pSection) = 0;
        
        virtual VARIANT_BOOL STDMETHODCALLTYPE IsPlaying( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Play( 
            /* [in] */ AAFlags flags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ReleaseSection( 
            /* [in] */ IAASection __RPC_FAR *pSection) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SaveAsMIDI( 
            /* [in] */ IStream __RPC_FAR *pStream) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetAuthor( 
            /* [in] */ LPCTSTR pszAuthor) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetName( 
            /* [in] */ LPCTSTR pszName) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Stop( 
            /* [in] */ AAFlags flags) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IAASongVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IAASong __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IAASong __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IAASong __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *AppendSection )( 
            IAASong __RPC_FAR * This,
            /* [in] */ IAASection __RPC_FAR *pSection);
        
        IAASong __RPC_FAR *( STDMETHODCALLTYPE __RPC_FAR *Clone )( 
            IAASong __RPC_FAR * This);
        
        LPCTSTR ( STDMETHODCALLTYPE __RPC_FAR *GetAuthor )( 
            IAASong __RPC_FAR * This);
        
        IAASection __RPC_FAR *( STDMETHODCALLTYPE __RPC_FAR *GetFirstSection )( 
            IAASong __RPC_FAR * This);
        
        WORD ( STDMETHODCALLTYPE __RPC_FAR *GetLength )( 
            IAASong __RPC_FAR * This);
        
        DWORD ( STDMETHODCALLTYPE __RPC_FAR *GetLengthInMils )( 
            IAASong __RPC_FAR * This);
        
        LPCTSTR ( STDMETHODCALLTYPE __RPC_FAR *GetName )( 
            IAASong __RPC_FAR * This);
        
        IAASection __RPC_FAR *( STDMETHODCALLTYPE __RPC_FAR *GetNextSection )( 
            IAASong __RPC_FAR * This,
            /* [in] */ IAASection __RPC_FAR *pSection);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *InsertSection )( 
            IAASong __RPC_FAR * This,
            /* [in] */ IAASection __RPC_FAR *pPrevSection,
            /* [in] */ IAASection __RPC_FAR *pSection);
        
        VARIANT_BOOL ( STDMETHODCALLTYPE __RPC_FAR *IsPlaying )( 
            IAASong __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Play )( 
            IAASong __RPC_FAR * This,
            /* [in] */ AAFlags flags);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ReleaseSection )( 
            IAASong __RPC_FAR * This,
            /* [in] */ IAASection __RPC_FAR *pSection);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SaveAsMIDI )( 
            IAASong __RPC_FAR * This,
            /* [in] */ IStream __RPC_FAR *pStream);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetAuthor )( 
            IAASong __RPC_FAR * This,
            /* [in] */ LPCTSTR pszAuthor);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetName )( 
            IAASong __RPC_FAR * This,
            /* [in] */ LPCTSTR pszName);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Stop )( 
            IAASong __RPC_FAR * This,
            /* [in] */ AAFlags flags);
        
        END_INTERFACE
    } IAASongVtbl;

    interface IAASong
    {
        CONST_VTBL struct IAASongVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IAASong_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IAASong_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IAASong_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IAASong_AppendSection(This,pSection)	\
    (This)->lpVtbl -> AppendSection(This,pSection)

#define IAASong_Clone(This)	\
    (This)->lpVtbl -> Clone(This)

#define IAASong_GetAuthor(This)	\
    (This)->lpVtbl -> GetAuthor(This)

#define IAASong_GetFirstSection(This)	\
    (This)->lpVtbl -> GetFirstSection(This)

#define IAASong_GetLength(This)	\
    (This)->lpVtbl -> GetLength(This)

#define IAASong_GetLengthInMils(This)	\
    (This)->lpVtbl -> GetLengthInMils(This)

#define IAASong_GetName(This)	\
    (This)->lpVtbl -> GetName(This)

#define IAASong_GetNextSection(This,pSection)	\
    (This)->lpVtbl -> GetNextSection(This,pSection)

#define IAASong_InsertSection(This,pPrevSection,pSection)	\
    (This)->lpVtbl -> InsertSection(This,pPrevSection,pSection)

#define IAASong_IsPlaying(This)	\
    (This)->lpVtbl -> IsPlaying(This)

#define IAASong_Play(This,flags)	\
    (This)->lpVtbl -> Play(This,flags)

#define IAASong_ReleaseSection(This,pSection)	\
    (This)->lpVtbl -> ReleaseSection(This,pSection)

#define IAASong_SaveAsMIDI(This,pStream)	\
    (This)->lpVtbl -> SaveAsMIDI(This,pStream)

#define IAASong_SetAuthor(This,pszAuthor)	\
    (This)->lpVtbl -> SetAuthor(This,pszAuthor)

#define IAASong_SetName(This,pszName)	\
    (This)->lpVtbl -> SetName(This,pszName)

#define IAASong_Stop(This,flags)	\
    (This)->lpVtbl -> Stop(This,flags)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IAASong_AppendSection_Proxy( 
    IAASong __RPC_FAR * This,
    /* [in] */ IAASection __RPC_FAR *pSection);


void __RPC_STUB IAASong_AppendSection_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


IAASong __RPC_FAR *STDMETHODCALLTYPE IAASong_Clone_Proxy( 
    IAASong __RPC_FAR * This);


void __RPC_STUB IAASong_Clone_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


LPCTSTR STDMETHODCALLTYPE IAASong_GetAuthor_Proxy( 
    IAASong __RPC_FAR * This);


void __RPC_STUB IAASong_GetAuthor_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


IAASection __RPC_FAR *STDMETHODCALLTYPE IAASong_GetFirstSection_Proxy( 
    IAASong __RPC_FAR * This);


void __RPC_STUB IAASong_GetFirstSection_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


WORD STDMETHODCALLTYPE IAASong_GetLength_Proxy( 
    IAASong __RPC_FAR * This);


void __RPC_STUB IAASong_GetLength_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


DWORD STDMETHODCALLTYPE IAASong_GetLengthInMils_Proxy( 
    IAASong __RPC_FAR * This);


void __RPC_STUB IAASong_GetLengthInMils_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


LPCTSTR STDMETHODCALLTYPE IAASong_GetName_Proxy( 
    IAASong __RPC_FAR * This);


void __RPC_STUB IAASong_GetName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


IAASection __RPC_FAR *STDMETHODCALLTYPE IAASong_GetNextSection_Proxy( 
    IAASong __RPC_FAR * This,
    /* [in] */ IAASection __RPC_FAR *pSection);


void __RPC_STUB IAASong_GetNextSection_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAASong_InsertSection_Proxy( 
    IAASong __RPC_FAR * This,
    /* [in] */ IAASection __RPC_FAR *pPrevSection,
    /* [in] */ IAASection __RPC_FAR *pSection);


void __RPC_STUB IAASong_InsertSection_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


VARIANT_BOOL STDMETHODCALLTYPE IAASong_IsPlaying_Proxy( 
    IAASong __RPC_FAR * This);


void __RPC_STUB IAASong_IsPlaying_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAASong_Play_Proxy( 
    IAASong __RPC_FAR * This,
    /* [in] */ AAFlags flags);


void __RPC_STUB IAASong_Play_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAASong_ReleaseSection_Proxy( 
    IAASong __RPC_FAR * This,
    /* [in] */ IAASection __RPC_FAR *pSection);


void __RPC_STUB IAASong_ReleaseSection_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAASong_SaveAsMIDI_Proxy( 
    IAASong __RPC_FAR * This,
    /* [in] */ IStream __RPC_FAR *pStream);


void __RPC_STUB IAASong_SaveAsMIDI_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAASong_SetAuthor_Proxy( 
    IAASong __RPC_FAR * This,
    /* [in] */ LPCTSTR pszAuthor);


void __RPC_STUB IAASong_SetAuthor_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAASong_SetName_Proxy( 
    IAASong __RPC_FAR * This,
    /* [in] */ LPCTSTR pszName);


void __RPC_STUB IAASong_SetName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAASong_Stop_Proxy( 
    IAASong __RPC_FAR * This,
    /* [in] */ AAFlags flags);


void __RPC_STUB IAASong_Stop_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IAASong_INTERFACE_DEFINED__ */


#ifndef __IAAStyle_INTERFACE_DEFINED__
#define __IAAStyle_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IAAStyle
 * at Fri Nov 08 14:45:43 1996
 * using MIDL 3.00.44
 ****************************************/
/* [object][uuid] */ 



DEFINE_GUID(IID_IAAStyle,0xBCE4CC4c,0x2F1A,0x11CF,0xBF,0x16,0x00,0xAA,0x00,0xC0,0x81,0x46);

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface IAAStyle : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE AddBand( 
            /* [in] */ IAABand __RPC_FAR *pBand) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE AddMotif( 
            /* [in] */ IAAMotif __RPC_FAR *pMotif) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE AddPattern( 
            /* [in] */ IAAPattern __RPC_FAR *pPattern) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE AddPersonality( 
            /* [in] */ IAAPersonality __RPC_FAR *pPersonality) = 0;
        
        virtual IAAStyle __RPC_FAR *STDMETHODCALLTYPE Clone( void) = 0;
        
        virtual IAABand __RPC_FAR *STDMETHODCALLTYPE FindBand( 
            /* [in] */ LPCTSTR pszName) = 0;
        
        virtual IAAMotif __RPC_FAR *STDMETHODCALLTYPE FindMotif( 
            /* [in] */ LPCTSTR pszName) = 0;
        
        virtual IAAPattern __RPC_FAR *STDMETHODCALLTYPE FindPattern( 
            /* [in] */ LPCTSTR pszName) = 0;
        
        virtual IAAPersonality __RPC_FAR *STDMETHODCALLTYPE FindPersonality( 
            /* [in] */ LPCTSTR pszName) = 0;
        
        virtual WORD STDMETHODCALLTYPE GetBeatsPerMeasure( void) = 0;
        
        virtual LPCTSTR STDMETHODCALLTYPE GetCategory( void) = 0;
        
        virtual WORD STDMETHODCALLTYPE GetClicksPerBeat( void) = 0;
        
        virtual IAABand __RPC_FAR *STDMETHODCALLTYPE GetDefaultBand( void) = 0;
        
        virtual IAAPersonality __RPC_FAR *STDMETHODCALLTYPE GetDefaultPersonality( void) = 0;
        
        virtual DWORD STDMETHODCALLTYPE GetDefaultTempo( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetEmbellishmentLength( 
            /* [in] */ AACommands lEmbellishment,
            /* [out] */ WORD __RPC_FAR *pwNumMeasures,
            /* [out] */ DWORD __RPC_FAR *pdwActualLength) = 0;
        
        virtual IAABand __RPC_FAR *STDMETHODCALLTYPE GetFirstBand( void) = 0;
        
        virtual IAAMotif __RPC_FAR *STDMETHODCALLTYPE GetFirstMotif( void) = 0;
        
        virtual IAAPattern __RPC_FAR *STDMETHODCALLTYPE GetFirstPattern( void) = 0;
        
        virtual IAAPersonality __RPC_FAR *STDMETHODCALLTYPE GetFirstPersonality( void) = 0;
        
        virtual LPCTSTR STDMETHODCALLTYPE GetName( void) = 0;
        
        virtual IAABand __RPC_FAR *STDMETHODCALLTYPE GetNextBand( 
            /* [in] */ IAABand __RPC_FAR *pBand) = 0;
        
        virtual IAAMotif __RPC_FAR *STDMETHODCALLTYPE GetNextMotif( 
            /* [in] */ IAAMotif __RPC_FAR *pMotif) = 0;
        
        virtual IAAPattern __RPC_FAR *STDMETHODCALLTYPE GetNextPattern( 
            /* [in] */ IAAPattern __RPC_FAR *pPattern) = 0;
        
        virtual IAAPersonality __RPC_FAR *STDMETHODCALLTYPE GetNextPersonality( 
            /* [in] */ IAAPersonality __RPC_FAR *pPersonality) = 0;
        
        virtual DWORD STDMETHODCALLTYPE GetTimeSignature( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE LockBand( 
            /* [in] */ IAABand __RPC_FAR *pBand,
            /* [in] */ VARIANT_BOOL fWait) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE LockBandByName( 
            /* [in] */ LPCTSTR pszBandName,
            /* [in] */ VARIANT_BOOL fWait) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ReleaseBand( 
            /* [in] */ IAABand __RPC_FAR *pBand) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ReleaseMotif( 
            /* [in] */ IAAMotif __RPC_FAR *pMotif) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ReleasePattern( 
            /* [in] */ IAAPattern __RPC_FAR *pPattern) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ReleasePersonality( 
            /* [in] */ IAAPersonality __RPC_FAR *pPersonality) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetBeatsPerMeasure( 
            /* [in] */ WORD wBeatsPerMeasure) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetCategory( 
            /* [in] */ LPCTSTR pszCategory) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetClicksPerBeat( 
            /* [in] */ WORD wClicksPerBeat) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetDefaultBand( 
            /* [in] */ IAABand __RPC_FAR *pBand) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetDefaultPersonality( 
            /* [in] */ IAAPersonality __RPC_FAR *pPersonality) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetDefaultTempo( 
            /* [in] */ DWORD lTempo) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetName( 
            /* [in] */ LPCTSTR pszName) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetTimeSignature( 
            /* [in] */ DWORD lTimeSig) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE UnlockBand( 
            /* [in] */ IAABand __RPC_FAR *pBand) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE UnlockBandByName( 
            /* [in] */ LPCTSTR pszBandName) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IAAStyleVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IAAStyle __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IAAStyle __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IAAStyle __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *AddBand )( 
            IAAStyle __RPC_FAR * This,
            /* [in] */ IAABand __RPC_FAR *pBand);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *AddMotif )( 
            IAAStyle __RPC_FAR * This,
            /* [in] */ IAAMotif __RPC_FAR *pMotif);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *AddPattern )( 
            IAAStyle __RPC_FAR * This,
            /* [in] */ IAAPattern __RPC_FAR *pPattern);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *AddPersonality )( 
            IAAStyle __RPC_FAR * This,
            /* [in] */ IAAPersonality __RPC_FAR *pPersonality);
        
        IAAStyle __RPC_FAR *( STDMETHODCALLTYPE __RPC_FAR *Clone )( 
            IAAStyle __RPC_FAR * This);
        
        IAABand __RPC_FAR *( STDMETHODCALLTYPE __RPC_FAR *FindBand )( 
            IAAStyle __RPC_FAR * This,
            /* [in] */ LPCTSTR pszName);
        
        IAAMotif __RPC_FAR *( STDMETHODCALLTYPE __RPC_FAR *FindMotif )( 
            IAAStyle __RPC_FAR * This,
            /* [in] */ LPCTSTR pszName);
        
        IAAPattern __RPC_FAR *( STDMETHODCALLTYPE __RPC_FAR *FindPattern )( 
            IAAStyle __RPC_FAR * This,
            /* [in] */ LPCTSTR pszName);
        
        IAAPersonality __RPC_FAR *( STDMETHODCALLTYPE __RPC_FAR *FindPersonality )( 
            IAAStyle __RPC_FAR * This,
            /* [in] */ LPCTSTR pszName);
        
        WORD ( STDMETHODCALLTYPE __RPC_FAR *GetBeatsPerMeasure )( 
            IAAStyle __RPC_FAR * This);
        
        LPCTSTR ( STDMETHODCALLTYPE __RPC_FAR *GetCategory )( 
            IAAStyle __RPC_FAR * This);
        
        WORD ( STDMETHODCALLTYPE __RPC_FAR *GetClicksPerBeat )( 
            IAAStyle __RPC_FAR * This);
        
        IAABand __RPC_FAR *( STDMETHODCALLTYPE __RPC_FAR *GetDefaultBand )( 
            IAAStyle __RPC_FAR * This);
        
        IAAPersonality __RPC_FAR *( STDMETHODCALLTYPE __RPC_FAR *GetDefaultPersonality )( 
            IAAStyle __RPC_FAR * This);
        
        DWORD ( STDMETHODCALLTYPE __RPC_FAR *GetDefaultTempo )( 
            IAAStyle __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetEmbellishmentLength )( 
            IAAStyle __RPC_FAR * This,
            /* [in] */ AACommands lEmbellishment,
            /* [out] */ WORD __RPC_FAR *pwNumMeasures,
            /* [out] */ DWORD __RPC_FAR *pdwActualLength);
        
        IAABand __RPC_FAR *( STDMETHODCALLTYPE __RPC_FAR *GetFirstBand )( 
            IAAStyle __RPC_FAR * This);
        
        IAAMotif __RPC_FAR *( STDMETHODCALLTYPE __RPC_FAR *GetFirstMotif )( 
            IAAStyle __RPC_FAR * This);
        
        IAAPattern __RPC_FAR *( STDMETHODCALLTYPE __RPC_FAR *GetFirstPattern )( 
            IAAStyle __RPC_FAR * This);
        
        IAAPersonality __RPC_FAR *( STDMETHODCALLTYPE __RPC_FAR *GetFirstPersonality )( 
            IAAStyle __RPC_FAR * This);
        
        LPCTSTR ( STDMETHODCALLTYPE __RPC_FAR *GetName )( 
            IAAStyle __RPC_FAR * This);
        
        IAABand __RPC_FAR *( STDMETHODCALLTYPE __RPC_FAR *GetNextBand )( 
            IAAStyle __RPC_FAR * This,
            /* [in] */ IAABand __RPC_FAR *pBand);
        
        IAAMotif __RPC_FAR *( STDMETHODCALLTYPE __RPC_FAR *GetNextMotif )( 
            IAAStyle __RPC_FAR * This,
            /* [in] */ IAAMotif __RPC_FAR *pMotif);
        
        IAAPattern __RPC_FAR *( STDMETHODCALLTYPE __RPC_FAR *GetNextPattern )( 
            IAAStyle __RPC_FAR * This,
            /* [in] */ IAAPattern __RPC_FAR *pPattern);
        
        IAAPersonality __RPC_FAR *( STDMETHODCALLTYPE __RPC_FAR *GetNextPersonality )( 
            IAAStyle __RPC_FAR * This,
            /* [in] */ IAAPersonality __RPC_FAR *pPersonality);
        
        DWORD ( STDMETHODCALLTYPE __RPC_FAR *GetTimeSignature )( 
            IAAStyle __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *LockBand )( 
            IAAStyle __RPC_FAR * This,
            /* [in] */ IAABand __RPC_FAR *pBand,
            /* [in] */ VARIANT_BOOL fWait);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *LockBandByName )( 
            IAAStyle __RPC_FAR * This,
            /* [in] */ LPCTSTR pszBandName,
            /* [in] */ VARIANT_BOOL fWait);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ReleaseBand )( 
            IAAStyle __RPC_FAR * This,
            /* [in] */ IAABand __RPC_FAR *pBand);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ReleaseMotif )( 
            IAAStyle __RPC_FAR * This,
            /* [in] */ IAAMotif __RPC_FAR *pMotif);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ReleasePattern )( 
            IAAStyle __RPC_FAR * This,
            /* [in] */ IAAPattern __RPC_FAR *pPattern);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ReleasePersonality )( 
            IAAStyle __RPC_FAR * This,
            /* [in] */ IAAPersonality __RPC_FAR *pPersonality);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetBeatsPerMeasure )( 
            IAAStyle __RPC_FAR * This,
            /* [in] */ WORD wBeatsPerMeasure);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetCategory )( 
            IAAStyle __RPC_FAR * This,
            /* [in] */ LPCTSTR pszCategory);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetClicksPerBeat )( 
            IAAStyle __RPC_FAR * This,
            /* [in] */ WORD wClicksPerBeat);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetDefaultBand )( 
            IAAStyle __RPC_FAR * This,
            /* [in] */ IAABand __RPC_FAR *pBand);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetDefaultPersonality )( 
            IAAStyle __RPC_FAR * This,
            /* [in] */ IAAPersonality __RPC_FAR *pPersonality);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetDefaultTempo )( 
            IAAStyle __RPC_FAR * This,
            /* [in] */ DWORD lTempo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetName )( 
            IAAStyle __RPC_FAR * This,
            /* [in] */ LPCTSTR pszName);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetTimeSignature )( 
            IAAStyle __RPC_FAR * This,
            /* [in] */ DWORD lTimeSig);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *UnlockBand )( 
            IAAStyle __RPC_FAR * This,
            /* [in] */ IAABand __RPC_FAR *pBand);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *UnlockBandByName )( 
            IAAStyle __RPC_FAR * This,
            /* [in] */ LPCTSTR pszBandName);
        
        END_INTERFACE
    } IAAStyleVtbl;

    interface IAAStyle
    {
        CONST_VTBL struct IAAStyleVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IAAStyle_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IAAStyle_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IAAStyle_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IAAStyle_AddBand(This,pBand)	\
    (This)->lpVtbl -> AddBand(This,pBand)

#define IAAStyle_AddMotif(This,pMotif)	\
    (This)->lpVtbl -> AddMotif(This,pMotif)

#define IAAStyle_AddPattern(This,pPattern)	\
    (This)->lpVtbl -> AddPattern(This,pPattern)

#define IAAStyle_AddPersonality(This,pPersonality)	\
    (This)->lpVtbl -> AddPersonality(This,pPersonality)

#define IAAStyle_Clone(This)	\
    (This)->lpVtbl -> Clone(This)

#define IAAStyle_FindBand(This,pszName)	\
    (This)->lpVtbl -> FindBand(This,pszName)

#define IAAStyle_FindMotif(This,pszName)	\
    (This)->lpVtbl -> FindMotif(This,pszName)

#define IAAStyle_FindPattern(This,pszName)	\
    (This)->lpVtbl -> FindPattern(This,pszName)

#define IAAStyle_FindPersonality(This,pszName)	\
    (This)->lpVtbl -> FindPersonality(This,pszName)

#define IAAStyle_GetBeatsPerMeasure(This)	\
    (This)->lpVtbl -> GetBeatsPerMeasure(This)

#define IAAStyle_GetCategory(This)	\
    (This)->lpVtbl -> GetCategory(This)

#define IAAStyle_GetClicksPerBeat(This)	\
    (This)->lpVtbl -> GetClicksPerBeat(This)

#define IAAStyle_GetDefaultBand(This)	\
    (This)->lpVtbl -> GetDefaultBand(This)

#define IAAStyle_GetDefaultPersonality(This)	\
    (This)->lpVtbl -> GetDefaultPersonality(This)

#define IAAStyle_GetDefaultTempo(This)	\
    (This)->lpVtbl -> GetDefaultTempo(This)

#define IAAStyle_GetEmbellishmentLength(This,lEmbellishment,pwNumMeasures,pdwActualLength)	\
    (This)->lpVtbl -> GetEmbellishmentLength(This,lEmbellishment,pwNumMeasures,pdwActualLength)

#define IAAStyle_GetFirstBand(This)	\
    (This)->lpVtbl -> GetFirstBand(This)

#define IAAStyle_GetFirstMotif(This)	\
    (This)->lpVtbl -> GetFirstMotif(This)

#define IAAStyle_GetFirstPattern(This)	\
    (This)->lpVtbl -> GetFirstPattern(This)

#define IAAStyle_GetFirstPersonality(This)	\
    (This)->lpVtbl -> GetFirstPersonality(This)

#define IAAStyle_GetName(This)	\
    (This)->lpVtbl -> GetName(This)

#define IAAStyle_GetNextBand(This,pBand)	\
    (This)->lpVtbl -> GetNextBand(This,pBand)

#define IAAStyle_GetNextMotif(This,pMotif)	\
    (This)->lpVtbl -> GetNextMotif(This,pMotif)

#define IAAStyle_GetNextPattern(This,pPattern)	\
    (This)->lpVtbl -> GetNextPattern(This,pPattern)

#define IAAStyle_GetNextPersonality(This,pPersonality)	\
    (This)->lpVtbl -> GetNextPersonality(This,pPersonality)

#define IAAStyle_GetTimeSignature(This)	\
    (This)->lpVtbl -> GetTimeSignature(This)

#define IAAStyle_LockBand(This,pBand,fWait)	\
    (This)->lpVtbl -> LockBand(This,pBand,fWait)

#define IAAStyle_LockBandByName(This,pszBandName,fWait)	\
    (This)->lpVtbl -> LockBandByName(This,pszBandName,fWait)

#define IAAStyle_ReleaseBand(This,pBand)	\
    (This)->lpVtbl -> ReleaseBand(This,pBand)

#define IAAStyle_ReleaseMotif(This,pMotif)	\
    (This)->lpVtbl -> ReleaseMotif(This,pMotif)

#define IAAStyle_ReleasePattern(This,pPattern)	\
    (This)->lpVtbl -> ReleasePattern(This,pPattern)

#define IAAStyle_ReleasePersonality(This,pPersonality)	\
    (This)->lpVtbl -> ReleasePersonality(This,pPersonality)

#define IAAStyle_SetBeatsPerMeasure(This,wBeatsPerMeasure)	\
    (This)->lpVtbl -> SetBeatsPerMeasure(This,wBeatsPerMeasure)

#define IAAStyle_SetCategory(This,pszCategory)	\
    (This)->lpVtbl -> SetCategory(This,pszCategory)

#define IAAStyle_SetClicksPerBeat(This,wClicksPerBeat)	\
    (This)->lpVtbl -> SetClicksPerBeat(This,wClicksPerBeat)

#define IAAStyle_SetDefaultBand(This,pBand)	\
    (This)->lpVtbl -> SetDefaultBand(This,pBand)

#define IAAStyle_SetDefaultPersonality(This,pPersonality)	\
    (This)->lpVtbl -> SetDefaultPersonality(This,pPersonality)

#define IAAStyle_SetDefaultTempo(This,lTempo)	\
    (This)->lpVtbl -> SetDefaultTempo(This,lTempo)

#define IAAStyle_SetName(This,pszName)	\
    (This)->lpVtbl -> SetName(This,pszName)

#define IAAStyle_SetTimeSignature(This,lTimeSig)	\
    (This)->lpVtbl -> SetTimeSignature(This,lTimeSig)

#define IAAStyle_UnlockBand(This,pBand)	\
    (This)->lpVtbl -> UnlockBand(This,pBand)

#define IAAStyle_UnlockBandByName(This,pszBandName)	\
    (This)->lpVtbl -> UnlockBandByName(This,pszBandName)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IAAStyle_AddBand_Proxy( 
    IAAStyle __RPC_FAR * This,
    /* [in] */ IAABand __RPC_FAR *pBand);


void __RPC_STUB IAAStyle_AddBand_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAAStyle_AddMotif_Proxy( 
    IAAStyle __RPC_FAR * This,
    /* [in] */ IAAMotif __RPC_FAR *pMotif);


void __RPC_STUB IAAStyle_AddMotif_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAAStyle_AddPattern_Proxy( 
    IAAStyle __RPC_FAR * This,
    /* [in] */ IAAPattern __RPC_FAR *pPattern);


void __RPC_STUB IAAStyle_AddPattern_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAAStyle_AddPersonality_Proxy( 
    IAAStyle __RPC_FAR * This,
    /* [in] */ IAAPersonality __RPC_FAR *pPersonality);


void __RPC_STUB IAAStyle_AddPersonality_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


IAAStyle __RPC_FAR *STDMETHODCALLTYPE IAAStyle_Clone_Proxy( 
    IAAStyle __RPC_FAR * This);


void __RPC_STUB IAAStyle_Clone_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


IAABand __RPC_FAR *STDMETHODCALLTYPE IAAStyle_FindBand_Proxy( 
    IAAStyle __RPC_FAR * This,
    /* [in] */ LPCTSTR pszName);


void __RPC_STUB IAAStyle_FindBand_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


IAAMotif __RPC_FAR *STDMETHODCALLTYPE IAAStyle_FindMotif_Proxy( 
    IAAStyle __RPC_FAR * This,
    /* [in] */ LPCTSTR pszName);


void __RPC_STUB IAAStyle_FindMotif_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


IAAPattern __RPC_FAR *STDMETHODCALLTYPE IAAStyle_FindPattern_Proxy( 
    IAAStyle __RPC_FAR * This,
    /* [in] */ LPCTSTR pszName);


void __RPC_STUB IAAStyle_FindPattern_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


IAAPersonality __RPC_FAR *STDMETHODCALLTYPE IAAStyle_FindPersonality_Proxy( 
    IAAStyle __RPC_FAR * This,
    /* [in] */ LPCTSTR pszName);


void __RPC_STUB IAAStyle_FindPersonality_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


WORD STDMETHODCALLTYPE IAAStyle_GetBeatsPerMeasure_Proxy( 
    IAAStyle __RPC_FAR * This);


void __RPC_STUB IAAStyle_GetBeatsPerMeasure_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


LPCTSTR STDMETHODCALLTYPE IAAStyle_GetCategory_Proxy( 
    IAAStyle __RPC_FAR * This);


void __RPC_STUB IAAStyle_GetCategory_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


WORD STDMETHODCALLTYPE IAAStyle_GetClicksPerBeat_Proxy( 
    IAAStyle __RPC_FAR * This);


void __RPC_STUB IAAStyle_GetClicksPerBeat_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


IAABand __RPC_FAR *STDMETHODCALLTYPE IAAStyle_GetDefaultBand_Proxy( 
    IAAStyle __RPC_FAR * This);


void __RPC_STUB IAAStyle_GetDefaultBand_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


IAAPersonality __RPC_FAR *STDMETHODCALLTYPE IAAStyle_GetDefaultPersonality_Proxy( 
    IAAStyle __RPC_FAR * This);


void __RPC_STUB IAAStyle_GetDefaultPersonality_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


DWORD STDMETHODCALLTYPE IAAStyle_GetDefaultTempo_Proxy( 
    IAAStyle __RPC_FAR * This);


void __RPC_STUB IAAStyle_GetDefaultTempo_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAAStyle_GetEmbellishmentLength_Proxy( 
    IAAStyle __RPC_FAR * This,
    /* [in] */ AACommands lEmbellishment,
    /* [out] */ WORD __RPC_FAR *pwNumMeasures,
    /* [out] */ DWORD __RPC_FAR *pdwActualLength);


void __RPC_STUB IAAStyle_GetEmbellishmentLength_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


IAABand __RPC_FAR *STDMETHODCALLTYPE IAAStyle_GetFirstBand_Proxy( 
    IAAStyle __RPC_FAR * This);


void __RPC_STUB IAAStyle_GetFirstBand_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


IAAMotif __RPC_FAR *STDMETHODCALLTYPE IAAStyle_GetFirstMotif_Proxy( 
    IAAStyle __RPC_FAR * This);


void __RPC_STUB IAAStyle_GetFirstMotif_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


IAAPattern __RPC_FAR *STDMETHODCALLTYPE IAAStyle_GetFirstPattern_Proxy( 
    IAAStyle __RPC_FAR * This);


void __RPC_STUB IAAStyle_GetFirstPattern_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


IAAPersonality __RPC_FAR *STDMETHODCALLTYPE IAAStyle_GetFirstPersonality_Proxy( 
    IAAStyle __RPC_FAR * This);


void __RPC_STUB IAAStyle_GetFirstPersonality_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


LPCTSTR STDMETHODCALLTYPE IAAStyle_GetName_Proxy( 
    IAAStyle __RPC_FAR * This);


void __RPC_STUB IAAStyle_GetName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


IAABand __RPC_FAR *STDMETHODCALLTYPE IAAStyle_GetNextBand_Proxy( 
    IAAStyle __RPC_FAR * This,
    /* [in] */ IAABand __RPC_FAR *pBand);


void __RPC_STUB IAAStyle_GetNextBand_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


IAAMotif __RPC_FAR *STDMETHODCALLTYPE IAAStyle_GetNextMotif_Proxy( 
    IAAStyle __RPC_FAR * This,
    /* [in] */ IAAMotif __RPC_FAR *pMotif);


void __RPC_STUB IAAStyle_GetNextMotif_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


IAAPattern __RPC_FAR *STDMETHODCALLTYPE IAAStyle_GetNextPattern_Proxy( 
    IAAStyle __RPC_FAR * This,
    /* [in] */ IAAPattern __RPC_FAR *pPattern);


void __RPC_STUB IAAStyle_GetNextPattern_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


IAAPersonality __RPC_FAR *STDMETHODCALLTYPE IAAStyle_GetNextPersonality_Proxy( 
    IAAStyle __RPC_FAR * This,
    /* [in] */ IAAPersonality __RPC_FAR *pPersonality);


void __RPC_STUB IAAStyle_GetNextPersonality_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


DWORD STDMETHODCALLTYPE IAAStyle_GetTimeSignature_Proxy( 
    IAAStyle __RPC_FAR * This);


void __RPC_STUB IAAStyle_GetTimeSignature_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAAStyle_LockBand_Proxy( 
    IAAStyle __RPC_FAR * This,
    /* [in] */ IAABand __RPC_FAR *pBand,
    /* [in] */ VARIANT_BOOL fWait);


void __RPC_STUB IAAStyle_LockBand_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAAStyle_LockBandByName_Proxy( 
    IAAStyle __RPC_FAR * This,
    /* [in] */ LPCTSTR pszBandName,
    /* [in] */ VARIANT_BOOL fWait);


void __RPC_STUB IAAStyle_LockBandByName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAAStyle_ReleaseBand_Proxy( 
    IAAStyle __RPC_FAR * This,
    /* [in] */ IAABand __RPC_FAR *pBand);


void __RPC_STUB IAAStyle_ReleaseBand_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAAStyle_ReleaseMotif_Proxy( 
    IAAStyle __RPC_FAR * This,
    /* [in] */ IAAMotif __RPC_FAR *pMotif);


void __RPC_STUB IAAStyle_ReleaseMotif_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAAStyle_ReleasePattern_Proxy( 
    IAAStyle __RPC_FAR * This,
    /* [in] */ IAAPattern __RPC_FAR *pPattern);


void __RPC_STUB IAAStyle_ReleasePattern_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAAStyle_ReleasePersonality_Proxy( 
    IAAStyle __RPC_FAR * This,
    /* [in] */ IAAPersonality __RPC_FAR *pPersonality);


void __RPC_STUB IAAStyle_ReleasePersonality_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAAStyle_SetBeatsPerMeasure_Proxy( 
    IAAStyle __RPC_FAR * This,
    /* [in] */ WORD wBeatsPerMeasure);


void __RPC_STUB IAAStyle_SetBeatsPerMeasure_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAAStyle_SetCategory_Proxy( 
    IAAStyle __RPC_FAR * This,
    /* [in] */ LPCTSTR pszCategory);


void __RPC_STUB IAAStyle_SetCategory_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAAStyle_SetClicksPerBeat_Proxy( 
    IAAStyle __RPC_FAR * This,
    /* [in] */ WORD wClicksPerBeat);


void __RPC_STUB IAAStyle_SetClicksPerBeat_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAAStyle_SetDefaultBand_Proxy( 
    IAAStyle __RPC_FAR * This,
    /* [in] */ IAABand __RPC_FAR *pBand);


void __RPC_STUB IAAStyle_SetDefaultBand_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAAStyle_SetDefaultPersonality_Proxy( 
    IAAStyle __RPC_FAR * This,
    /* [in] */ IAAPersonality __RPC_FAR *pPersonality);


void __RPC_STUB IAAStyle_SetDefaultPersonality_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAAStyle_SetDefaultTempo_Proxy( 
    IAAStyle __RPC_FAR * This,
    /* [in] */ DWORD lTempo);


void __RPC_STUB IAAStyle_SetDefaultTempo_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAAStyle_SetName_Proxy( 
    IAAStyle __RPC_FAR * This,
    /* [in] */ LPCTSTR pszName);


void __RPC_STUB IAAStyle_SetName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAAStyle_SetTimeSignature_Proxy( 
    IAAStyle __RPC_FAR * This,
    /* [in] */ DWORD lTimeSig);


void __RPC_STUB IAAStyle_SetTimeSignature_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAAStyle_UnlockBand_Proxy( 
    IAAStyle __RPC_FAR * This,
    /* [in] */ IAABand __RPC_FAR *pBand);


void __RPC_STUB IAAStyle_UnlockBand_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAAStyle_UnlockBandByName_Proxy( 
    IAAStyle __RPC_FAR * This,
    /* [in] */ LPCTSTR pszBandName);


void __RPC_STUB IAAStyle_UnlockBandByName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IAAStyle_INTERFACE_DEFINED__ */


#ifndef __IAATemplate_INTERFACE_DEFINED__
#define __IAATemplate_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IAATemplate
 * at Fri Nov 08 14:45:43 1996
 * using MIDL 3.00.44
 ****************************************/
/* [object][uuid] */ 



DEFINE_GUID(IID_IAATemplate,0xBCE4CC4f,0x2F1A,0x11CF,0xBF,0x16,0x00,0xAA,0x00,0xC0,0x81,0x46);

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface IAATemplate : public IUnknown
    {
    public:
        virtual IAATemplate __RPC_FAR *STDMETHODCALLTYPE Clone( void) = 0;
        
        virtual WORD STDMETHODCALLTYPE GetLength( void) = 0;
        
        virtual LPCTSTR STDMETHODCALLTYPE GetName( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetLength( 
            /* [in] */ WORD nLength) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetName( 
            /* [in] */ LPCTSTR pszName) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IAATemplateVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IAATemplate __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IAATemplate __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IAATemplate __RPC_FAR * This);
        
        IAATemplate __RPC_FAR *( STDMETHODCALLTYPE __RPC_FAR *Clone )( 
            IAATemplate __RPC_FAR * This);
        
        WORD ( STDMETHODCALLTYPE __RPC_FAR *GetLength )( 
            IAATemplate __RPC_FAR * This);
        
        LPCTSTR ( STDMETHODCALLTYPE __RPC_FAR *GetName )( 
            IAATemplate __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetLength )( 
            IAATemplate __RPC_FAR * This,
            /* [in] */ WORD nLength);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetName )( 
            IAATemplate __RPC_FAR * This,
            /* [in] */ LPCTSTR pszName);
        
        END_INTERFACE
    } IAATemplateVtbl;

    interface IAATemplate
    {
        CONST_VTBL struct IAATemplateVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IAATemplate_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IAATemplate_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IAATemplate_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IAATemplate_Clone(This)	\
    (This)->lpVtbl -> Clone(This)

#define IAATemplate_GetLength(This)	\
    (This)->lpVtbl -> GetLength(This)

#define IAATemplate_GetName(This)	\
    (This)->lpVtbl -> GetName(This)

#define IAATemplate_SetLength(This,nLength)	\
    (This)->lpVtbl -> SetLength(This,nLength)

#define IAATemplate_SetName(This,pszName)	\
    (This)->lpVtbl -> SetName(This,pszName)

#endif /* COBJMACROS */


#endif 	/* C style interface */



IAATemplate __RPC_FAR *STDMETHODCALLTYPE IAATemplate_Clone_Proxy( 
    IAATemplate __RPC_FAR * This);


void __RPC_STUB IAATemplate_Clone_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


WORD STDMETHODCALLTYPE IAATemplate_GetLength_Proxy( 
    IAATemplate __RPC_FAR * This);


void __RPC_STUB IAATemplate_GetLength_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


LPCTSTR STDMETHODCALLTYPE IAATemplate_GetName_Proxy( 
    IAATemplate __RPC_FAR * This);


void __RPC_STUB IAATemplate_GetName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAATemplate_SetLength_Proxy( 
    IAATemplate __RPC_FAR * This,
    /* [in] */ WORD nLength);


void __RPC_STUB IAATemplate_SetLength_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAATemplate_SetName_Proxy( 
    IAATemplate __RPC_FAR * This,
    /* [in] */ LPCTSTR pszName);


void __RPC_STUB IAATemplate_SetName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IAATemplate_INTERFACE_DEFINED__ */


#ifndef __IReferenceClock_INTERFACE_DEFINED__
#define __IReferenceClock_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IReferenceClock
 * at Fri Nov 08 14:45:43 1996
 * using MIDL 3.00.44
 ****************************************/
/* [unique][uuid][object] */ 



DEFINE_GUID(IID_IReferenceClock,0x56a86897,0x0ad4,0x11ce,0xb0,0x3a,0x00,0x20,0xaf,0x0b,0xa7,0x70);

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface IReferenceClock : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE AdviseTime( 
            /* [in] */ ReferenceTime baseTime,
            /* [in] */ ReferenceTime streamTime,
            /* [in] */ HEVENT hEvent,
            /* [out] */ DWORD __RPC_FAR *pdwAdviseCookie) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE AdvisePeriodic( 
            /* [in] */ ReferenceTime startTime,
            /* [in] */ ReferenceTime periodTime,
            /* [in] */ HSEMAPHORE hSemaphore,
            /* [out] */ DWORD __RPC_FAR *pdwAdviseCookie) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Unadvise( 
            /* [in] */ DWORD dwAdviseCookie) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ConvertRealTime( 
            /* [in] */ TIME realTime,
            /* [out] */ ReferenceTime __RPC_FAR *pRefTime) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetTime( 
            /* [out] */ ReferenceTime __RPC_FAR *pTime) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IReferenceClockVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IReferenceClock __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IReferenceClock __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IReferenceClock __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *AdviseTime )( 
            IReferenceClock __RPC_FAR * This,
            /* [in] */ ReferenceTime baseTime,
            /* [in] */ ReferenceTime streamTime,
            /* [in] */ HEVENT hEvent,
            /* [out] */ DWORD __RPC_FAR *pdwAdviseCookie);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *AdvisePeriodic )( 
            IReferenceClock __RPC_FAR * This,
            /* [in] */ ReferenceTime startTime,
            /* [in] */ ReferenceTime periodTime,
            /* [in] */ HSEMAPHORE hSemaphore,
            /* [out] */ DWORD __RPC_FAR *pdwAdviseCookie);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Unadvise )( 
            IReferenceClock __RPC_FAR * This,
            /* [in] */ DWORD dwAdviseCookie);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ConvertRealTime )( 
            IReferenceClock __RPC_FAR * This,
            /* [in] */ TIME realTime,
            /* [out] */ ReferenceTime __RPC_FAR *pRefTime);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTime )( 
            IReferenceClock __RPC_FAR * This,
            /* [out] */ ReferenceTime __RPC_FAR *pTime);
        
        END_INTERFACE
    } IReferenceClockVtbl;

    interface IReferenceClock
    {
        CONST_VTBL struct IReferenceClockVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IReferenceClock_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IReferenceClock_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IReferenceClock_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IReferenceClock_AdviseTime(This,baseTime,streamTime,hEvent,pdwAdviseCookie)	\
    (This)->lpVtbl -> AdviseTime(This,baseTime,streamTime,hEvent,pdwAdviseCookie)

#define IReferenceClock_AdvisePeriodic(This,startTime,periodTime,hSemaphore,pdwAdviseCookie)	\
    (This)->lpVtbl -> AdvisePeriodic(This,startTime,periodTime,hSemaphore,pdwAdviseCookie)

#define IReferenceClock_Unadvise(This,dwAdviseCookie)	\
    (This)->lpVtbl -> Unadvise(This,dwAdviseCookie)

#define IReferenceClock_ConvertRealTime(This,realTime,pRefTime)	\
    (This)->lpVtbl -> ConvertRealTime(This,realTime,pRefTime)

#define IReferenceClock_GetTime(This,pTime)	\
    (This)->lpVtbl -> GetTime(This,pTime)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IReferenceClock_AdviseTime_Proxy( 
    IReferenceClock __RPC_FAR * This,
    /* [in] */ ReferenceTime baseTime,
    /* [in] */ ReferenceTime streamTime,
    /* [in] */ HEVENT hEvent,
    /* [out] */ DWORD __RPC_FAR *pdwAdviseCookie);


void __RPC_STUB IReferenceClock_AdviseTime_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IReferenceClock_AdvisePeriodic_Proxy( 
    IReferenceClock __RPC_FAR * This,
    /* [in] */ ReferenceTime startTime,
    /* [in] */ ReferenceTime periodTime,
    /* [in] */ HSEMAPHORE hSemaphore,
    /* [out] */ DWORD __RPC_FAR *pdwAdviseCookie);


void __RPC_STUB IReferenceClock_AdvisePeriodic_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IReferenceClock_Unadvise_Proxy( 
    IReferenceClock __RPC_FAR * This,
    /* [in] */ DWORD dwAdviseCookie);


void __RPC_STUB IReferenceClock_Unadvise_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IReferenceClock_ConvertRealTime_Proxy( 
    IReferenceClock __RPC_FAR * This,
    /* [in] */ TIME realTime,
    /* [out] */ ReferenceTime __RPC_FAR *pRefTime);


void __RPC_STUB IReferenceClock_ConvertRealTime_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IReferenceClock_GetTime_Proxy( 
    IReferenceClock __RPC_FAR * This,
    /* [out] */ ReferenceTime __RPC_FAR *pTime);


void __RPC_STUB IReferenceClock_GetTime_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IReferenceClock_INTERFACE_DEFINED__ */


#ifndef __IAAEngine_INTERFACE_DEFINED__
#define __IAAEngine_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IAAEngine
 * at Fri Nov 08 14:45:43 1996
 * using MIDL 3.00.44
 ****************************************/
/* [object][uuid] */ 



DEFINE_GUID(IID_IAAEngine,0xBCE4CC41,0x2F1A,0x11CF,0xBF,0x16,0x00,0xAA,0x00,0xC0,0x81,0x46);

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface IAAEngine : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE AllocBand( 
            /* [retval][out] */ IAABand __RPC_FAR *__RPC_FAR *ppBand) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE AllocMotif( 
            /* [retval][out] */ IAAMotif __RPC_FAR *__RPC_FAR *ppMotif) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE AllocPattern( 
            /* [retval][out] */ IAAPattern __RPC_FAR *__RPC_FAR *ppPattern) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE AllocPersonality( 
            /* [retval][out] */ IAAPersonality __RPC_FAR *__RPC_FAR *ppPersonality) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE AllocSection( 
            /* [retval][out] */ IAASection __RPC_FAR *__RPC_FAR *ppSection) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE AllocSong( 
            /* [retval][out] */ IAASong __RPC_FAR *__RPC_FAR *ppSong) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE AllocStyle( 
            /* [retval][out] */ IAAStyle __RPC_FAR *__RPC_FAR *ppStyle) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE AllocTemplate( 
            /* [retval][out] */ IAATemplate __RPC_FAR *__RPC_FAR *ppTemplate) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE AutoTransition( 
            /* [in] */ IAASection __RPC_FAR *pToSection,
            /* [in] */ AACommands command,
            /* [in] */ AAFlags flags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ComposeSection( 
            /* [in] */ IAAStyle __RPC_FAR *pStyle,
            /* [in] */ IAATemplate __RPC_FAR *pTemplate,
            /* [in] */ WORD wActivity,
            /* [in] */ IAAPersonality __RPC_FAR *pPersonality,
            /* [retval][out] */ IAASection __RPC_FAR *__RPC_FAR *ppSection) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ComposeSectionFromShape( 
            /* [in] */ IAAStyle __RPC_FAR *pStyle,
            /* [in] */ WORD wNumMeasures,
            /* [in] */ AAShape shape,
            /* [in] */ WORD wActivity,
            /* [in] */ AACommands command,
            /* [in] */ IAAPersonality __RPC_FAR *pPersonality,
            /* [retval][out] */ IAASection __RPC_FAR *__RPC_FAR *ppSection) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ComposeTemplateFromShape( 
            /* [in] */ WORD wNumMeasures,
            /* [in] */ AAShape shape,
            /* [retval][out] */ IAATemplate __RPC_FAR *__RPC_FAR *pTemplate) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ComposeTransition( 
            /* [in] */ IAASection __RPC_FAR *pFromSection,
            /* [in] */ IAASection __RPC_FAR *pToSection,
            /* [in] */ WORD wMeasureNum,
            /* [in] */ AACommands command,
            /* [in] */ AAFlags flags,
            /* [retval][out] */ IAASection __RPC_FAR *__RPC_FAR *ppSection) = 0;
        
        virtual IAAPersonality __RPC_FAR *STDMETHODCALLTYPE FindPersonality( 
            /* [in] */ REFGUID guid) = 0;
        
        virtual IAAPersonality __RPC_FAR *STDMETHODCALLTYPE FindPersonalityByName( 
            /* [in] */ LPCTSTR pszName) = 0;
        
        virtual IAAStyle __RPC_FAR *STDMETHODCALLTYPE FindStyle( 
            /* [in] */ REFGUID guid) = 0;
        
        virtual IAAStyle __RPC_FAR *STDMETHODCALLTYPE FindStyleByName( 
            /* [in] */ LPCTSTR pszName) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE FlushSectionQueue( void) = 0;
        
        virtual IAASection __RPC_FAR *STDMETHODCALLTYPE GetCurrentSection( void) = 0;
        
        virtual IAAEventSink __RPC_FAR *STDMETHODCALLTYPE GetEventSink( void) = 0;
        
        virtual IAALoader __RPC_FAR *STDMETHODCALLTYPE GetLoader( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetMeters( 
            /* [out][in] */ AAMETERS __RPC_FAR *pMeters) = 0;
        
        virtual AAFlags STDMETHODCALLTYPE GetMetronomeFlags( void) = 0;
        
        virtual DWORD STDMETHODCALLTYPE GetMusicTime( void) = 0;
        
        virtual WORD STDMETHODCALLTYPE GetMutes( void) = 0;
        
        virtual IAANotifySink __RPC_FAR *STDMETHODCALLTYPE GetNotifySink( void) = 0;
        
        virtual WORD STDMETHODCALLTYPE GetPPQN( void) = 0;
        
        virtual IAARealTime __RPC_FAR *STDMETHODCALLTYPE GetRealTime( void) = 0;
        
        virtual WORD STDMETHODCALLTYPE GetRelTempo( void) = 0;
        
        virtual WORD STDMETHODCALLTYPE GetRelVolume( void) = 0;
        
        virtual DWORD STDMETHODCALLTYPE GetTempo( void) = 0;
        
        virtual DWORD STDMETHODCALLTYPE GetTimeSignature( void) = 0;
        
        virtual VARIANT_BOOL STDMETHODCALLTYPE IsPlaying( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE PlayMotif( 
            /* [in] */ IAAMotif __RPC_FAR *pMotif,
            /* [in] */ AAFlags flags,
            /* [in] */ DWORD dwTime) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE PlaySection( 
            /* [in] */ IAASection __RPC_FAR *pSection,
            /* [in] */ AAFlags flags,
            /* [in] */ DWORD dwStartTime) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE PlaySong( 
            /* [in] */ IAASong __RPC_FAR *pSong,
            /* [in] */ AAFlags flags,
            /* [in] */ DWORD dwStartTime) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE QueueUserMsg( 
            /* [in] */ DWORD dwTime,
            /* [in] */ DWORD dwParam1,
            /* [in] */ DWORD dwParam2) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ReleaseAllPersonalities( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ReleaseAllStyles( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ReleasePersonality( 
            /* [in] */ IAAPersonality __RPC_FAR *pPersonality) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ReleaseStyle( 
            /* [in] */ IAAStyle __RPC_FAR *pStyle) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetEventSink( 
            /* [in] */ IAAEventSink __RPC_FAR *pEventSink) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetLoader( 
            /* [in] */ IAALoader __RPC_FAR *pLoader) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetMutes( 
            /* [in] */ WORD wMutes) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetNotifySink( 
            /* [in] */ IAANotifySink __RPC_FAR *pNotifySink) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetPrepareTime( 
            /* [in] */ WORD wPrepareTime) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetRealTime( 
            /* [in] */ IAARealTime __RPC_FAR *pRealTime) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetRelTempo( 
            /* [in] */ WORD wRelTempo) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetRelVolume( 
            /* [in] */ WORD wRelVolume) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetMetronomeFlags( 
            /* [in] */ AAFlags fFlags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetStyleCacheSize( 
            /* [in] */ WORD wNumStyles) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Stop( 
            /* [in] */ AAFlags flags) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IAAEngineVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IAAEngine __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IAAEngine __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IAAEngine __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *AllocBand )( 
            IAAEngine __RPC_FAR * This,
            /* [retval][out] */ IAABand __RPC_FAR *__RPC_FAR *ppBand);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *AllocMotif )( 
            IAAEngine __RPC_FAR * This,
            /* [retval][out] */ IAAMotif __RPC_FAR *__RPC_FAR *ppMotif);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *AllocPattern )( 
            IAAEngine __RPC_FAR * This,
            /* [retval][out] */ IAAPattern __RPC_FAR *__RPC_FAR *ppPattern);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *AllocPersonality )( 
            IAAEngine __RPC_FAR * This,
            /* [retval][out] */ IAAPersonality __RPC_FAR *__RPC_FAR *ppPersonality);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *AllocSection )( 
            IAAEngine __RPC_FAR * This,
            /* [retval][out] */ IAASection __RPC_FAR *__RPC_FAR *ppSection);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *AllocSong )( 
            IAAEngine __RPC_FAR * This,
            /* [retval][out] */ IAASong __RPC_FAR *__RPC_FAR *ppSong);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *AllocStyle )( 
            IAAEngine __RPC_FAR * This,
            /* [retval][out] */ IAAStyle __RPC_FAR *__RPC_FAR *ppStyle);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *AllocTemplate )( 
            IAAEngine __RPC_FAR * This,
            /* [retval][out] */ IAATemplate __RPC_FAR *__RPC_FAR *ppTemplate);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *AutoTransition )( 
            IAAEngine __RPC_FAR * This,
            /* [in] */ IAASection __RPC_FAR *pToSection,
            /* [in] */ AACommands command,
            /* [in] */ AAFlags flags);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ComposeSection )( 
            IAAEngine __RPC_FAR * This,
            /* [in] */ IAAStyle __RPC_FAR *pStyle,
            /* [in] */ IAATemplate __RPC_FAR *pTemplate,
            /* [in] */ WORD wActivity,
            /* [in] */ IAAPersonality __RPC_FAR *pPersonality,
            /* [retval][out] */ IAASection __RPC_FAR *__RPC_FAR *ppSection);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ComposeSectionFromShape )( 
            IAAEngine __RPC_FAR * This,
            /* [in] */ IAAStyle __RPC_FAR *pStyle,
            /* [in] */ WORD wNumMeasures,
            /* [in] */ AAShape shape,
            /* [in] */ WORD wActivity,
            /* [in] */ AACommands command,
            /* [in] */ IAAPersonality __RPC_FAR *pPersonality,
            /* [retval][out] */ IAASection __RPC_FAR *__RPC_FAR *ppSection);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ComposeTemplateFromShape )( 
            IAAEngine __RPC_FAR * This,
            /* [in] */ WORD wNumMeasures,
            /* [in] */ AAShape shape,
            /* [retval][out] */ IAATemplate __RPC_FAR *__RPC_FAR *pTemplate);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ComposeTransition )( 
            IAAEngine __RPC_FAR * This,
            /* [in] */ IAASection __RPC_FAR *pFromSection,
            /* [in] */ IAASection __RPC_FAR *pToSection,
            /* [in] */ WORD wMeasureNum,
            /* [in] */ AACommands command,
            /* [in] */ AAFlags flags,
            /* [retval][out] */ IAASection __RPC_FAR *__RPC_FAR *ppSection);
        
        IAAPersonality __RPC_FAR *( STDMETHODCALLTYPE __RPC_FAR *FindPersonality )( 
            IAAEngine __RPC_FAR * This,
            /* [in] */ REFGUID guid);
        
        IAAPersonality __RPC_FAR *( STDMETHODCALLTYPE __RPC_FAR *FindPersonalityByName )( 
            IAAEngine __RPC_FAR * This,
            /* [in] */ LPCTSTR pszName);
        
        IAAStyle __RPC_FAR *( STDMETHODCALLTYPE __RPC_FAR *FindStyle )( 
            IAAEngine __RPC_FAR * This,
            /* [in] */ REFGUID guid);
        
        IAAStyle __RPC_FAR *( STDMETHODCALLTYPE __RPC_FAR *FindStyleByName )( 
            IAAEngine __RPC_FAR * This,
            /* [in] */ LPCTSTR pszName);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *FlushSectionQueue )( 
            IAAEngine __RPC_FAR * This);
        
        IAASection __RPC_FAR *( STDMETHODCALLTYPE __RPC_FAR *GetCurrentSection )( 
            IAAEngine __RPC_FAR * This);
        
        IAAEventSink __RPC_FAR *( STDMETHODCALLTYPE __RPC_FAR *GetEventSink )( 
            IAAEngine __RPC_FAR * This);
        
        IAALoader __RPC_FAR *( STDMETHODCALLTYPE __RPC_FAR *GetLoader )( 
            IAAEngine __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetMeters )( 
            IAAEngine __RPC_FAR * This,
            /* [out][in] */ AAMETERS __RPC_FAR *pMeters);
        
        AAFlags ( STDMETHODCALLTYPE __RPC_FAR *GetMetronomeFlags )( 
            IAAEngine __RPC_FAR * This);
        
        DWORD ( STDMETHODCALLTYPE __RPC_FAR *GetMusicTime )( 
            IAAEngine __RPC_FAR * This);
        
        WORD ( STDMETHODCALLTYPE __RPC_FAR *GetMutes )( 
            IAAEngine __RPC_FAR * This);
        
        IAANotifySink __RPC_FAR *( STDMETHODCALLTYPE __RPC_FAR *GetNotifySink )( 
            IAAEngine __RPC_FAR * This);
        
        WORD ( STDMETHODCALLTYPE __RPC_FAR *GetPPQN )( 
            IAAEngine __RPC_FAR * This);
        
        IAARealTime __RPC_FAR *( STDMETHODCALLTYPE __RPC_FAR *GetRealTime )( 
            IAAEngine __RPC_FAR * This);
        
        WORD ( STDMETHODCALLTYPE __RPC_FAR *GetRelTempo )( 
            IAAEngine __RPC_FAR * This);
        
        WORD ( STDMETHODCALLTYPE __RPC_FAR *GetRelVolume )( 
            IAAEngine __RPC_FAR * This);
        
        DWORD ( STDMETHODCALLTYPE __RPC_FAR *GetTempo )( 
            IAAEngine __RPC_FAR * This);
        
        DWORD ( STDMETHODCALLTYPE __RPC_FAR *GetTimeSignature )( 
            IAAEngine __RPC_FAR * This);
        
        VARIANT_BOOL ( STDMETHODCALLTYPE __RPC_FAR *IsPlaying )( 
            IAAEngine __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *PlayMotif )( 
            IAAEngine __RPC_FAR * This,
            /* [in] */ IAAMotif __RPC_FAR *pMotif,
            /* [in] */ AAFlags flags,
            /* [in] */ DWORD dwTime);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *PlaySection )( 
            IAAEngine __RPC_FAR * This,
            /* [in] */ IAASection __RPC_FAR *pSection,
            /* [in] */ AAFlags flags,
            /* [in] */ DWORD dwStartTime);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *PlaySong )( 
            IAAEngine __RPC_FAR * This,
            /* [in] */ IAASong __RPC_FAR *pSong,
            /* [in] */ AAFlags flags,
            /* [in] */ DWORD dwStartTime);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueueUserMsg )( 
            IAAEngine __RPC_FAR * This,
            /* [in] */ DWORD dwTime,
            /* [in] */ DWORD dwParam1,
            /* [in] */ DWORD dwParam2);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ReleaseAllPersonalities )( 
            IAAEngine __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ReleaseAllStyles )( 
            IAAEngine __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ReleasePersonality )( 
            IAAEngine __RPC_FAR * This,
            /* [in] */ IAAPersonality __RPC_FAR *pPersonality);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ReleaseStyle )( 
            IAAEngine __RPC_FAR * This,
            /* [in] */ IAAStyle __RPC_FAR *pStyle);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetEventSink )( 
            IAAEngine __RPC_FAR * This,
            /* [in] */ IAAEventSink __RPC_FAR *pEventSink);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetLoader )( 
            IAAEngine __RPC_FAR * This,
            /* [in] */ IAALoader __RPC_FAR *pLoader);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetMutes )( 
            IAAEngine __RPC_FAR * This,
            /* [in] */ WORD wMutes);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetNotifySink )( 
            IAAEngine __RPC_FAR * This,
            /* [in] */ IAANotifySink __RPC_FAR *pNotifySink);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetPrepareTime )( 
            IAAEngine __RPC_FAR * This,
            /* [in] */ WORD wPrepareTime);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetRealTime )( 
            IAAEngine __RPC_FAR * This,
            /* [in] */ IAARealTime __RPC_FAR *pRealTime);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetRelTempo )( 
            IAAEngine __RPC_FAR * This,
            /* [in] */ WORD wRelTempo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetRelVolume )( 
            IAAEngine __RPC_FAR * This,
            /* [in] */ WORD wRelVolume);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetMetronomeFlags )( 
            IAAEngine __RPC_FAR * This,
            /* [in] */ AAFlags fFlags);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetStyleCacheSize )( 
            IAAEngine __RPC_FAR * This,
            /* [in] */ WORD wNumStyles);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Stop )( 
            IAAEngine __RPC_FAR * This,
            /* [in] */ AAFlags flags);
        
        END_INTERFACE
    } IAAEngineVtbl;

    interface IAAEngine
    {
        CONST_VTBL struct IAAEngineVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IAAEngine_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IAAEngine_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IAAEngine_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IAAEngine_AllocBand(This,ppBand)	\
    (This)->lpVtbl -> AllocBand(This,ppBand)

#define IAAEngine_AllocMotif(This,ppMotif)	\
    (This)->lpVtbl -> AllocMotif(This,ppMotif)

#define IAAEngine_AllocPattern(This,ppPattern)	\
    (This)->lpVtbl -> AllocPattern(This,ppPattern)

#define IAAEngine_AllocPersonality(This,ppPersonality)	\
    (This)->lpVtbl -> AllocPersonality(This,ppPersonality)

#define IAAEngine_AllocSection(This,ppSection)	\
    (This)->lpVtbl -> AllocSection(This,ppSection)

#define IAAEngine_AllocSong(This,ppSong)	\
    (This)->lpVtbl -> AllocSong(This,ppSong)

#define IAAEngine_AllocStyle(This,ppStyle)	\
    (This)->lpVtbl -> AllocStyle(This,ppStyle)

#define IAAEngine_AllocTemplate(This,ppTemplate)	\
    (This)->lpVtbl -> AllocTemplate(This,ppTemplate)

#define IAAEngine_AutoTransition(This,pToSection,command,flags)	\
    (This)->lpVtbl -> AutoTransition(This,pToSection,command,flags)

#define IAAEngine_ComposeSection(This,pStyle,pTemplate,wActivity,pPersonality,ppSection)	\
    (This)->lpVtbl -> ComposeSection(This,pStyle,pTemplate,wActivity,pPersonality,ppSection)

#define IAAEngine_ComposeSectionFromShape(This,pStyle,wNumMeasures,shape,wActivity,command,pPersonality,ppSection)	\
    (This)->lpVtbl -> ComposeSectionFromShape(This,pStyle,wNumMeasures,shape,wActivity,command,pPersonality,ppSection)

#define IAAEngine_ComposeTemplateFromShape(This,wNumMeasures,shape,pTemplate)	\
    (This)->lpVtbl -> ComposeTemplateFromShape(This,wNumMeasures,shape,pTemplate)

#define IAAEngine_ComposeTransition(This,pFromSection,pToSection,wMeasureNum,command,flags,ppSection)	\
    (This)->lpVtbl -> ComposeTransition(This,pFromSection,pToSection,wMeasureNum,command,flags,ppSection)

#define IAAEngine_FindPersonality(This,guid)	\
    (This)->lpVtbl -> FindPersonality(This,guid)

#define IAAEngine_FindPersonalityByName(This,pszName)	\
    (This)->lpVtbl -> FindPersonalityByName(This,pszName)

#define IAAEngine_FindStyle(This,guid)	\
    (This)->lpVtbl -> FindStyle(This,guid)

#define IAAEngine_FindStyleByName(This,pszName)	\
    (This)->lpVtbl -> FindStyleByName(This,pszName)

#define IAAEngine_FlushSectionQueue(This)	\
    (This)->lpVtbl -> FlushSectionQueue(This)

#define IAAEngine_GetCurrentSection(This)	\
    (This)->lpVtbl -> GetCurrentSection(This)

#define IAAEngine_GetEventSink(This)	\
    (This)->lpVtbl -> GetEventSink(This)

#define IAAEngine_GetLoader(This)	\
    (This)->lpVtbl -> GetLoader(This)

#define IAAEngine_GetMeters(This,pMeters)	\
    (This)->lpVtbl -> GetMeters(This,pMeters)

#define IAAEngine_GetMetronomeFlags(This)	\
    (This)->lpVtbl -> GetMetronomeFlags(This)

#define IAAEngine_GetMusicTime(This)	\
    (This)->lpVtbl -> GetMusicTime(This)

#define IAAEngine_GetMutes(This)	\
    (This)->lpVtbl -> GetMutes(This)

#define IAAEngine_GetNotifySink(This)	\
    (This)->lpVtbl -> GetNotifySink(This)

#define IAAEngine_GetPPQN(This)	\
    (This)->lpVtbl -> GetPPQN(This)

#define IAAEngine_GetRealTime(This)	\
    (This)->lpVtbl -> GetRealTime(This)

#define IAAEngine_GetRelTempo(This)	\
    (This)->lpVtbl -> GetRelTempo(This)

#define IAAEngine_GetRelVolume(This)	\
    (This)->lpVtbl -> GetRelVolume(This)

#define IAAEngine_GetTempo(This)	\
    (This)->lpVtbl -> GetTempo(This)

#define IAAEngine_GetTimeSignature(This)	\
    (This)->lpVtbl -> GetTimeSignature(This)

#define IAAEngine_IsPlaying(This)	\
    (This)->lpVtbl -> IsPlaying(This)

#define IAAEngine_PlayMotif(This,pMotif,flags,dwTime)	\
    (This)->lpVtbl -> PlayMotif(This,pMotif,flags,dwTime)

#define IAAEngine_PlaySection(This,pSection,flags,dwStartTime)	\
    (This)->lpVtbl -> PlaySection(This,pSection,flags,dwStartTime)

#define IAAEngine_PlaySong(This,pSong,flags,dwStartTime)	\
    (This)->lpVtbl -> PlaySong(This,pSong,flags,dwStartTime)

#define IAAEngine_QueueUserMsg(This,dwTime,dwParam1,dwParam2)	\
    (This)->lpVtbl -> QueueUserMsg(This,dwTime,dwParam1,dwParam2)

#define IAAEngine_ReleaseAllPersonalities(This)	\
    (This)->lpVtbl -> ReleaseAllPersonalities(This)

#define IAAEngine_ReleaseAllStyles(This)	\
    (This)->lpVtbl -> ReleaseAllStyles(This)

#define IAAEngine_ReleasePersonality(This,pPersonality)	\
    (This)->lpVtbl -> ReleasePersonality(This,pPersonality)

#define IAAEngine_ReleaseStyle(This,pStyle)	\
    (This)->lpVtbl -> ReleaseStyle(This,pStyle)

#define IAAEngine_SetEventSink(This,pEventSink)	\
    (This)->lpVtbl -> SetEventSink(This,pEventSink)

#define IAAEngine_SetLoader(This,pLoader)	\
    (This)->lpVtbl -> SetLoader(This,pLoader)

#define IAAEngine_SetMutes(This,wMutes)	\
    (This)->lpVtbl -> SetMutes(This,wMutes)

#define IAAEngine_SetNotifySink(This,pNotifySink)	\
    (This)->lpVtbl -> SetNotifySink(This,pNotifySink)

#define IAAEngine_SetPrepareTime(This,wPrepareTime)	\
    (This)->lpVtbl -> SetPrepareTime(This,wPrepareTime)

#define IAAEngine_SetRealTime(This,pRealTime)	\
    (This)->lpVtbl -> SetRealTime(This,pRealTime)

#define IAAEngine_SetRelTempo(This,wRelTempo)	\
    (This)->lpVtbl -> SetRelTempo(This,wRelTempo)

#define IAAEngine_SetRelVolume(This,wRelVolume)	\
    (This)->lpVtbl -> SetRelVolume(This,wRelVolume)

#define IAAEngine_SetMetronomeFlags(This,fFlags)	\
    (This)->lpVtbl -> SetMetronomeFlags(This,fFlags)

#define IAAEngine_SetStyleCacheSize(This,wNumStyles)	\
    (This)->lpVtbl -> SetStyleCacheSize(This,wNumStyles)

#define IAAEngine_Stop(This,flags)	\
    (This)->lpVtbl -> Stop(This,flags)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IAAEngine_AllocBand_Proxy( 
    IAAEngine __RPC_FAR * This,
    /* [retval][out] */ IAABand __RPC_FAR *__RPC_FAR *ppBand);


void __RPC_STUB IAAEngine_AllocBand_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAAEngine_AllocMotif_Proxy( 
    IAAEngine __RPC_FAR * This,
    /* [retval][out] */ IAAMotif __RPC_FAR *__RPC_FAR *ppMotif);


void __RPC_STUB IAAEngine_AllocMotif_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAAEngine_AllocPattern_Proxy( 
    IAAEngine __RPC_FAR * This,
    /* [retval][out] */ IAAPattern __RPC_FAR *__RPC_FAR *ppPattern);


void __RPC_STUB IAAEngine_AllocPattern_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAAEngine_AllocPersonality_Proxy( 
    IAAEngine __RPC_FAR * This,
    /* [retval][out] */ IAAPersonality __RPC_FAR *__RPC_FAR *ppPersonality);


void __RPC_STUB IAAEngine_AllocPersonality_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAAEngine_AllocSection_Proxy( 
    IAAEngine __RPC_FAR * This,
    /* [retval][out] */ IAASection __RPC_FAR *__RPC_FAR *ppSection);


void __RPC_STUB IAAEngine_AllocSection_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAAEngine_AllocSong_Proxy( 
    IAAEngine __RPC_FAR * This,
    /* [retval][out] */ IAASong __RPC_FAR *__RPC_FAR *ppSong);


void __RPC_STUB IAAEngine_AllocSong_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAAEngine_AllocStyle_Proxy( 
    IAAEngine __RPC_FAR * This,
    /* [retval][out] */ IAAStyle __RPC_FAR *__RPC_FAR *ppStyle);


void __RPC_STUB IAAEngine_AllocStyle_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAAEngine_AllocTemplate_Proxy( 
    IAAEngine __RPC_FAR * This,
    /* [retval][out] */ IAATemplate __RPC_FAR *__RPC_FAR *ppTemplate);


void __RPC_STUB IAAEngine_AllocTemplate_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAAEngine_AutoTransition_Proxy( 
    IAAEngine __RPC_FAR * This,
    /* [in] */ IAASection __RPC_FAR *pToSection,
    /* [in] */ AACommands command,
    /* [in] */ AAFlags flags);


void __RPC_STUB IAAEngine_AutoTransition_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAAEngine_ComposeSection_Proxy( 
    IAAEngine __RPC_FAR * This,
    /* [in] */ IAAStyle __RPC_FAR *pStyle,
    /* [in] */ IAATemplate __RPC_FAR *pTemplate,
    /* [in] */ WORD wActivity,
    /* [in] */ IAAPersonality __RPC_FAR *pPersonality,
    /* [retval][out] */ IAASection __RPC_FAR *__RPC_FAR *ppSection);


void __RPC_STUB IAAEngine_ComposeSection_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAAEngine_ComposeSectionFromShape_Proxy( 
    IAAEngine __RPC_FAR * This,
    /* [in] */ IAAStyle __RPC_FAR *pStyle,
    /* [in] */ WORD wNumMeasures,
    /* [in] */ AAShape shape,
    /* [in] */ WORD wActivity,
    /* [in] */ AACommands command,
    /* [in] */ IAAPersonality __RPC_FAR *pPersonality,
    /* [retval][out] */ IAASection __RPC_FAR *__RPC_FAR *ppSection);


void __RPC_STUB IAAEngine_ComposeSectionFromShape_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAAEngine_ComposeTemplateFromShape_Proxy( 
    IAAEngine __RPC_FAR * This,
    /* [in] */ WORD wNumMeasures,
    /* [in] */ AAShape shape,
    /* [retval][out] */ IAATemplate __RPC_FAR *__RPC_FAR *pTemplate);


void __RPC_STUB IAAEngine_ComposeTemplateFromShape_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAAEngine_ComposeTransition_Proxy( 
    IAAEngine __RPC_FAR * This,
    /* [in] */ IAASection __RPC_FAR *pFromSection,
    /* [in] */ IAASection __RPC_FAR *pToSection,
    /* [in] */ WORD wMeasureNum,
    /* [in] */ AACommands command,
    /* [in] */ AAFlags flags,
    /* [retval][out] */ IAASection __RPC_FAR *__RPC_FAR *ppSection);


void __RPC_STUB IAAEngine_ComposeTransition_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


IAAPersonality __RPC_FAR *STDMETHODCALLTYPE IAAEngine_FindPersonality_Proxy( 
    IAAEngine __RPC_FAR * This,
    /* [in] */ REFGUID guid);


void __RPC_STUB IAAEngine_FindPersonality_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


IAAPersonality __RPC_FAR *STDMETHODCALLTYPE IAAEngine_FindPersonalityByName_Proxy( 
    IAAEngine __RPC_FAR * This,
    /* [in] */ LPCTSTR pszName);


void __RPC_STUB IAAEngine_FindPersonalityByName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


IAAStyle __RPC_FAR *STDMETHODCALLTYPE IAAEngine_FindStyle_Proxy( 
    IAAEngine __RPC_FAR * This,
    /* [in] */ REFGUID guid);


void __RPC_STUB IAAEngine_FindStyle_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


IAAStyle __RPC_FAR *STDMETHODCALLTYPE IAAEngine_FindStyleByName_Proxy( 
    IAAEngine __RPC_FAR * This,
    /* [in] */ LPCTSTR pszName);


void __RPC_STUB IAAEngine_FindStyleByName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAAEngine_FlushSectionQueue_Proxy( 
    IAAEngine __RPC_FAR * This);


void __RPC_STUB IAAEngine_FlushSectionQueue_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


IAASection __RPC_FAR *STDMETHODCALLTYPE IAAEngine_GetCurrentSection_Proxy( 
    IAAEngine __RPC_FAR * This);


void __RPC_STUB IAAEngine_GetCurrentSection_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


IAAEventSink __RPC_FAR *STDMETHODCALLTYPE IAAEngine_GetEventSink_Proxy( 
    IAAEngine __RPC_FAR * This);


void __RPC_STUB IAAEngine_GetEventSink_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


IAALoader __RPC_FAR *STDMETHODCALLTYPE IAAEngine_GetLoader_Proxy( 
    IAAEngine __RPC_FAR * This);


void __RPC_STUB IAAEngine_GetLoader_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAAEngine_GetMeters_Proxy( 
    IAAEngine __RPC_FAR * This,
    /* [out][in] */ AAMETERS __RPC_FAR *pMeters);


void __RPC_STUB IAAEngine_GetMeters_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


AAFlags STDMETHODCALLTYPE IAAEngine_GetMetronomeFlags_Proxy( 
    IAAEngine __RPC_FAR * This);


void __RPC_STUB IAAEngine_GetMetronomeFlags_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


DWORD STDMETHODCALLTYPE IAAEngine_GetMusicTime_Proxy( 
    IAAEngine __RPC_FAR * This);


void __RPC_STUB IAAEngine_GetMusicTime_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


WORD STDMETHODCALLTYPE IAAEngine_GetMutes_Proxy( 
    IAAEngine __RPC_FAR * This);


void __RPC_STUB IAAEngine_GetMutes_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


IAANotifySink __RPC_FAR *STDMETHODCALLTYPE IAAEngine_GetNotifySink_Proxy( 
    IAAEngine __RPC_FAR * This);


void __RPC_STUB IAAEngine_GetNotifySink_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


WORD STDMETHODCALLTYPE IAAEngine_GetPPQN_Proxy( 
    IAAEngine __RPC_FAR * This);


void __RPC_STUB IAAEngine_GetPPQN_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


IAARealTime __RPC_FAR *STDMETHODCALLTYPE IAAEngine_GetRealTime_Proxy( 
    IAAEngine __RPC_FAR * This);


void __RPC_STUB IAAEngine_GetRealTime_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


WORD STDMETHODCALLTYPE IAAEngine_GetRelTempo_Proxy( 
    IAAEngine __RPC_FAR * This);


void __RPC_STUB IAAEngine_GetRelTempo_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


WORD STDMETHODCALLTYPE IAAEngine_GetRelVolume_Proxy( 
    IAAEngine __RPC_FAR * This);


void __RPC_STUB IAAEngine_GetRelVolume_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


DWORD STDMETHODCALLTYPE IAAEngine_GetTempo_Proxy( 
    IAAEngine __RPC_FAR * This);


void __RPC_STUB IAAEngine_GetTempo_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


DWORD STDMETHODCALLTYPE IAAEngine_GetTimeSignature_Proxy( 
    IAAEngine __RPC_FAR * This);


void __RPC_STUB IAAEngine_GetTimeSignature_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


VARIANT_BOOL STDMETHODCALLTYPE IAAEngine_IsPlaying_Proxy( 
    IAAEngine __RPC_FAR * This);


void __RPC_STUB IAAEngine_IsPlaying_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAAEngine_PlayMotif_Proxy( 
    IAAEngine __RPC_FAR * This,
    /* [in] */ IAAMotif __RPC_FAR *pMotif,
    /* [in] */ AAFlags flags,
    /* [in] */ DWORD dwTime);


void __RPC_STUB IAAEngine_PlayMotif_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAAEngine_PlaySection_Proxy( 
    IAAEngine __RPC_FAR * This,
    /* [in] */ IAASection __RPC_FAR *pSection,
    /* [in] */ AAFlags flags,
    /* [in] */ DWORD dwStartTime);


void __RPC_STUB IAAEngine_PlaySection_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAAEngine_PlaySong_Proxy( 
    IAAEngine __RPC_FAR * This,
    /* [in] */ IAASong __RPC_FAR *pSong,
    /* [in] */ AAFlags flags,
    /* [in] */ DWORD dwStartTime);


void __RPC_STUB IAAEngine_PlaySong_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAAEngine_QueueUserMsg_Proxy( 
    IAAEngine __RPC_FAR * This,
    /* [in] */ DWORD dwTime,
    /* [in] */ DWORD dwParam1,
    /* [in] */ DWORD dwParam2);


void __RPC_STUB IAAEngine_QueueUserMsg_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAAEngine_ReleaseAllPersonalities_Proxy( 
    IAAEngine __RPC_FAR * This);


void __RPC_STUB IAAEngine_ReleaseAllPersonalities_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAAEngine_ReleaseAllStyles_Proxy( 
    IAAEngine __RPC_FAR * This);


void __RPC_STUB IAAEngine_ReleaseAllStyles_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAAEngine_ReleasePersonality_Proxy( 
    IAAEngine __RPC_FAR * This,
    /* [in] */ IAAPersonality __RPC_FAR *pPersonality);


void __RPC_STUB IAAEngine_ReleasePersonality_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAAEngine_ReleaseStyle_Proxy( 
    IAAEngine __RPC_FAR * This,
    /* [in] */ IAAStyle __RPC_FAR *pStyle);


void __RPC_STUB IAAEngine_ReleaseStyle_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAAEngine_SetEventSink_Proxy( 
    IAAEngine __RPC_FAR * This,
    /* [in] */ IAAEventSink __RPC_FAR *pEventSink);


void __RPC_STUB IAAEngine_SetEventSink_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAAEngine_SetLoader_Proxy( 
    IAAEngine __RPC_FAR * This,
    /* [in] */ IAALoader __RPC_FAR *pLoader);


void __RPC_STUB IAAEngine_SetLoader_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAAEngine_SetMutes_Proxy( 
    IAAEngine __RPC_FAR * This,
    /* [in] */ WORD wMutes);


void __RPC_STUB IAAEngine_SetMutes_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAAEngine_SetNotifySink_Proxy( 
    IAAEngine __RPC_FAR * This,
    /* [in] */ IAANotifySink __RPC_FAR *pNotifySink);


void __RPC_STUB IAAEngine_SetNotifySink_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAAEngine_SetPrepareTime_Proxy( 
    IAAEngine __RPC_FAR * This,
    /* [in] */ WORD wPrepareTime);


void __RPC_STUB IAAEngine_SetPrepareTime_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAAEngine_SetRealTime_Proxy( 
    IAAEngine __RPC_FAR * This,
    /* [in] */ IAARealTime __RPC_FAR *pRealTime);


void __RPC_STUB IAAEngine_SetRealTime_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAAEngine_SetRelTempo_Proxy( 
    IAAEngine __RPC_FAR * This,
    /* [in] */ WORD wRelTempo);


void __RPC_STUB IAAEngine_SetRelTempo_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAAEngine_SetRelVolume_Proxy( 
    IAAEngine __RPC_FAR * This,
    /* [in] */ WORD wRelVolume);


void __RPC_STUB IAAEngine_SetRelVolume_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAAEngine_SetMetronomeFlags_Proxy( 
    IAAEngine __RPC_FAR * This,
    /* [in] */ AAFlags fFlags);


void __RPC_STUB IAAEngine_SetMetronomeFlags_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAAEngine_SetStyleCacheSize_Proxy( 
    IAAEngine __RPC_FAR * This,
    /* [in] */ WORD wNumStyles);


void __RPC_STUB IAAEngine_SetStyleCacheSize_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAAEngine_Stop_Proxy( 
    IAAEngine __RPC_FAR * This,
    /* [in] */ AAFlags flags);


void __RPC_STUB IAAEngine_Stop_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IAAEngine_INTERFACE_DEFINED__ */


#ifndef __IAAMIDIIn_INTERFACE_DEFINED__
#define __IAAMIDIIn_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IAAMIDIIn
 * at Fri Nov 08 14:45:43 1996
 * using MIDL 3.00.44
 ****************************************/
/* [object][uuid] */ 



DEFINE_GUID(IID_IAAMIDIIn,0xBCE4CC46,0x2F1A,0x11CF,0xBF,0x16,0x00,0xAA,0x00,0xC0,0x81,0x46);

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface IAAMIDIIn : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Activate( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Deactivate( void) = 0;
        
        virtual IAAMIDISink __RPC_FAR *STDMETHODCALLTYPE GetMIDISink( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetMIDISink( 
            /* [in] */ IAAMIDISink __RPC_FAR *pMIDISink) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetDevice( 
            /* [in] */ WORD wDeviceID) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IAAMIDIInVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IAAMIDIIn __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IAAMIDIIn __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IAAMIDIIn __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Activate )( 
            IAAMIDIIn __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Deactivate )( 
            IAAMIDIIn __RPC_FAR * This);
        
        IAAMIDISink __RPC_FAR *( STDMETHODCALLTYPE __RPC_FAR *GetMIDISink )( 
            IAAMIDIIn __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetMIDISink )( 
            IAAMIDIIn __RPC_FAR * This,
            /* [in] */ IAAMIDISink __RPC_FAR *pMIDISink);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetDevice )( 
            IAAMIDIIn __RPC_FAR * This,
            /* [in] */ WORD wDeviceID);
        
        END_INTERFACE
    } IAAMIDIInVtbl;

    interface IAAMIDIIn
    {
        CONST_VTBL struct IAAMIDIInVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IAAMIDIIn_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IAAMIDIIn_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IAAMIDIIn_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IAAMIDIIn_Activate(This)	\
    (This)->lpVtbl -> Activate(This)

#define IAAMIDIIn_Deactivate(This)	\
    (This)->lpVtbl -> Deactivate(This)

#define IAAMIDIIn_GetMIDISink(This)	\
    (This)->lpVtbl -> GetMIDISink(This)

#define IAAMIDIIn_SetMIDISink(This,pMIDISink)	\
    (This)->lpVtbl -> SetMIDISink(This,pMIDISink)

#define IAAMIDIIn_SetDevice(This,wDeviceID)	\
    (This)->lpVtbl -> SetDevice(This,wDeviceID)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IAAMIDIIn_Activate_Proxy( 
    IAAMIDIIn __RPC_FAR * This);


void __RPC_STUB IAAMIDIIn_Activate_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAAMIDIIn_Deactivate_Proxy( 
    IAAMIDIIn __RPC_FAR * This);


void __RPC_STUB IAAMIDIIn_Deactivate_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


IAAMIDISink __RPC_FAR *STDMETHODCALLTYPE IAAMIDIIn_GetMIDISink_Proxy( 
    IAAMIDIIn __RPC_FAR * This);


void __RPC_STUB IAAMIDIIn_GetMIDISink_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAAMIDIIn_SetMIDISink_Proxy( 
    IAAMIDIIn __RPC_FAR * This,
    /* [in] */ IAAMIDISink __RPC_FAR *pMIDISink);


void __RPC_STUB IAAMIDIIn_SetMIDISink_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAAMIDIIn_SetDevice_Proxy( 
    IAAMIDIIn __RPC_FAR * This,
    /* [in] */ WORD wDeviceID);


void __RPC_STUB IAAMIDIIn_SetDevice_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IAAMIDIIn_INTERFACE_DEFINED__ */


#ifndef __IAAMIDIOut_INTERFACE_DEFINED__
#define __IAAMIDIOut_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IAAMIDIOut
 * at Fri Nov 08 14:45:43 1996
 * using MIDL 3.00.44
 ****************************************/
/* [object][uuid] */ 



DEFINE_GUID(IID_IAAMIDIOut,0xBCE4CC47,0x2F1A,0x11CF,0xBF,0x16,0x00,0xAA,0x00,0xC0,0x81,0x46);

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface IAAMIDIOut : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Activate( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Deactivate( void) = 0;
        
        virtual VARIANT_BOOL STDMETHODCALLTYPE IsActive( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetDevice( 
            /* [in] */ WORD wDeviceID) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IAAMIDIOutVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IAAMIDIOut __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IAAMIDIOut __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IAAMIDIOut __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Activate )( 
            IAAMIDIOut __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Deactivate )( 
            IAAMIDIOut __RPC_FAR * This);
        
        VARIANT_BOOL ( STDMETHODCALLTYPE __RPC_FAR *IsActive )( 
            IAAMIDIOut __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetDevice )( 
            IAAMIDIOut __RPC_FAR * This,
            /* [in] */ WORD wDeviceID);
        
        END_INTERFACE
    } IAAMIDIOutVtbl;

    interface IAAMIDIOut
    {
        CONST_VTBL struct IAAMIDIOutVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IAAMIDIOut_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IAAMIDIOut_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IAAMIDIOut_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IAAMIDIOut_Activate(This)	\
    (This)->lpVtbl -> Activate(This)

#define IAAMIDIOut_Deactivate(This)	\
    (This)->lpVtbl -> Deactivate(This)

#define IAAMIDIOut_IsActive(This)	\
    (This)->lpVtbl -> IsActive(This)

#define IAAMIDIOut_SetDevice(This,wDeviceID)	\
    (This)->lpVtbl -> SetDevice(This,wDeviceID)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IAAMIDIOut_Activate_Proxy( 
    IAAMIDIOut __RPC_FAR * This);


void __RPC_STUB IAAMIDIOut_Activate_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAAMIDIOut_Deactivate_Proxy( 
    IAAMIDIOut __RPC_FAR * This);


void __RPC_STUB IAAMIDIOut_Deactivate_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


VARIANT_BOOL STDMETHODCALLTYPE IAAMIDIOut_IsActive_Proxy( 
    IAAMIDIOut __RPC_FAR * This);


void __RPC_STUB IAAMIDIOut_IsActive_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAAMIDIOut_SetDevice_Proxy( 
    IAAMIDIOut __RPC_FAR * This,
    /* [in] */ WORD wDeviceID);


void __RPC_STUB IAAMIDIOut_SetDevice_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IAAMIDIOut_INTERFACE_DEFINED__ */


#ifdef __cplusplus
DEFINE_GUID(CLSID_CAAEngine,0xBCE4CC51,0x2F1A,0x11CF,0xBF,0x16,0x00,0xAA,0x00,0xC0,0x81,0x46);

class CAAEngine;
#endif

#ifdef __cplusplus
DEFINE_GUID(CLSID_CAARealTime,0xBCE4CC52,0x2F1A,0x11CF,0xBF,0x16,0x00,0xAA,0x00,0xC0,0x81,0x46);

class CAARealTime;
#endif

#ifdef __cplusplus
DEFINE_GUID(CLSID_CAAMIDIOut,0xBCE4CC53,0x2F1A,0x11CF,0xBF,0x16,0x00,0xAA,0x00,0xC0,0x81,0x46);

class CAAMIDIOut;
#endif

#ifdef __cplusplus
DEFINE_GUID(CLSID_CAASection,0xBCE4CC55,0x2F1A,0x11CF,0xBF,0x16,0x00,0xAA,0x00,0xC0,0x81,0x46);

class CAASection;
#endif

#ifdef __cplusplus
DEFINE_GUID(CLSID_CAASong,0xBCE4CC56,0x2F1A,0x11CF,0xBF,0x16,0x00,0xAA,0x00,0xC0,0x81,0x46);

class CAASong;
#endif

#ifdef __cplusplus
DEFINE_GUID(CLSID_CAAMotif,0xBCE4CC57,0x2F1A,0x11CF,0xBF,0x16,0x00,0xAA,0x00,0xC0,0x81,0x46);

class CAAMotif;
#endif

#ifdef __cplusplus
DEFINE_GUID(CLSID_CAAStyle,0xBCE4CC58,0x2F1A,0x11CF,0xBF,0x16,0x00,0xAA,0x00,0xC0,0x81,0x46);

class CAAStyle;
#endif

#ifdef __cplusplus
DEFINE_GUID(CLSID_CAAPersonality,0xBCE4CC59,0x2F1A,0x11CF,0xBF,0x16,0x00,0xAA,0x00,0xC0,0x81,0x46);

class CAAPersonality;
#endif

#ifdef __cplusplus
DEFINE_GUID(CLSID_CAABand,0xBCE4CC5a,0x2F1A,0x11CF,0xBF,0x16,0x00,0xAA,0x00,0xC0,0x81,0x46);

class CAABand;
#endif

#ifdef __cplusplus
DEFINE_GUID(CLSID_CAATemplate,0xBCE4CC5b,0x2F1A,0x11CF,0xBF,0x16,0x00,0xAA,0x00,0xC0,0x81,0x46);

class CAATemplate;
#endif

#ifdef __cplusplus
DEFINE_GUID(CLSID_CAAPattern,0xBCE4CC5c,0x2F1A,0x11CF,0xBF,0x16,0x00,0xAA,0x00,0xC0,0x81,0x46);

class CAAPattern;
#endif

#ifdef __cplusplus
DEFINE_GUID(CLSID_CAALoader,0xBCE4CC5e,0x2F1A,0x11CF,0xBF,0x16,0x00,0xAA,0x00,0xC0,0x81,0x46);

class CAALoader;
#endif
#endif /* __AudioActive_LIBRARY_DEFINED__ */

/* Additional Prototypes for ALL interfaces */

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\tools\x86\icecap\icapexp.h ===
/*****************************************************************************/
/*                                                                           */
/*    ICAPEXP.H -- Exports from ICAP.DLL				     */
/*									     */
/*    Copyright (C) 1995 by Microsoft Corp.				     */
/*    All rights reserved						     */
/*									     */
/*****************************************************************************/

#ifndef __ICAPEXP_H__
#define __ICAPEXP_H__

#ifndef PROFILE
#define PROFILE 1		// define this as zero to macro-out the API
#endif

#if PROFILE

#ifdef __cplusplus
extern "C"
{
#endif

int __stdcall StartCAP(void);	// start profiling
int __stdcall StopCAP(void);    // stop profiling until StartCAP
int __stdcall SuspendCAP(void); // suspend profiling until ResumeCAP
int __stdcall ResumeCAP(void);  // resume profiling

int __stdcall StartCAPAll(void);    // process-wide start profiling
int __stdcall StopCAPAll(void);     // process-wide stop profiling
int __stdcall SuspendCAPAll(void);  // process-wide suspend profiling
int __stdcall ResumeCAPAll(void);   // process-wide resume profiling

#ifdef __cplusplus
}
#endif

#else // NOT PROFILE

#define StartCAP()      0
#define StopCAP()       0
#define SuspendCAP()    0
#define ResumeCAP()     0

#define StartCAPAll()   0
#define StopCAPAll()    0
#define SuspendCAPAll() 0
#define ResumeCAPAll()  0

#endif // NOT PROFILE

#endif  // __ICAPEXP_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\tools\x86\icecap\prologue.inc ===
pushcontext listing
.nolist
;
;	(C) Copyright Microsoft Corporation 1992, 1995

;	This file is used to create the same sets of prologue and epilogue
;	sequences which the Microsoft C 6.00 compiler will produce.  This
;	file would be used for writing windows programs and to provide
;	such features as stack checking in the assembler portions of
;	a C based project.


;	The following global variables will affect the prolog/epilog
;	sequences produced
;
;	PROFILE - If 1 then __penter calls will be inserted in all prologs
;	?WP_DEBUG - If 1 then prolog/epilog sequences will be forced
;	?WP_CHECKSTACK - If 1 then a check stack will be forced on all
;			procedures
;	?WP_INCBP - If 1 then the inc bp sequence will be generated on
;		all far procedures
;	?WP_LOADDS - If 1 then the load ds sequence will be generated on
;		all far procedures
;
ifndef ?WP_DEBUG
?WP_DEBUG = 0
endif
ifndef ?WP_CHECKSTACK
?WP_CHECKSTACK = 0
endif
ifndef ?WP_INCBP
?WP_INCBP = 0
endif
ifndef ?WP_LOADDS
?WP_LOADDS = 0
endif
ifndef PROFILE
PROFILE = 0
endif

;
;	Complain if we are in a segment as this will affect how the
;	externdefs are done and therefore the fixups and code
;	created on the checkstack calls
;
% ifnb	 <@CurSeg>
echo	Include should not be contained in a segment
endif

externdef C	_aNchkstk:near		; Extern the symbols
externdef C	_aFchkstk:far		; for later reference
externdef C	_penter:near

;
;	This macro will produce the same output as will the
;	C6 compiler for the given switches.
;
;	The following may be placed in the MacroArgs field of the
;		proc defintion:
;
;	CHECKSTACK
;	NOCHECKSTACK
;	LOADDS
;	NOLOADDS
;	FORCEFRAME
;	INCBP
;	NOINCBP
;	PROFILE

option prologue:cPrologue

cPrologue macro szProcName, flags, cbParams, cbLocals, rgRegs, rgUserParams
	LOCAL	?doPrologue
	LOCAL	?loadds
	LOCAL	?checkstack
	LOCAL	?incbp
	LOCAL	?cbLocals
	LOCAL	?doProfile
;	pushcontext	listing
;	.nolistmacro
;	.listmacroall

	?doPrologue = 0
	?loadds = 0
	?checkstack = 0
	?incbp = 0
	?cbLocals = cbLocals
	?doProfile = 0

;;	Set the defaults based on the global values specified
;;
if	?WP_DEBUG NE 0			;; Force frames by default
 ?doPrologue = 1
endif

if	?WP_CHECKSTACK NE 0		;; Force checkstack by default
 ?checkstack = 1
endif

if	?WP_INCBP NE 0			;; Force incbp by default if far
 if flags AND 020h
  ?incbp = 1
 endif
endif

if	?WP_LOADDS NE 0 		;; Force loadds by default if far
 if flags AND 020h
  ?loadds = 1
 endif
endif

if	PROFILE NE 0		    ;; profiling wanted
 ?doProfile  = 1			;; turn on profiling
endif

;;
;;	Get all of the user parameters parsed
;;

ifnb	<rgUserParams>		;;	Parse user params if exsisting
 for p,<rgUserParams>		;;	For every user param

  ifidni <p>, <CHECKSTACK>	 ;;	 Is it checkstack?
   ?checkstack = 1		;;		Yes -- do checkstack
  endif

  ifidni <p>, <NOCHECKSTACK>	 ;;	 Don't do checkstack?
   ?checkstack = 0		;;		Yes -- clear checkstack
  endif

  ifidni <p>, <LOADDS>	 ;;	 Is it LoadDS
   ?loadds = 1			;;		Yes -- do loadds sequence
  endif

  ifidni <p>, <NOLOADDS> ;;	 Don't do LoadDS?
   ?loadds = 0			;;		Yes -- clear loadds flag
  endif

  ifidni <p>, <INCBP>		 ;; Is it IncBP
   if flags AND 020h		;;	and far?
    ?incbp = 1			;;	Yes -- do IncBP sequence
   endif
  endif

  ifidni <p>, <NOINCBP>  ;;	 Is it NoIncBP
   ?incbp = 0			;;		Yes -- Clear the incbp flag
  endif

  ifidni <p>, <FORCEFRAME>	 ;;	 Is it ForceFrame?
   ?doPrologue = 1			;;		Yes -- force out a frame
  endif

  ifidni <p>, <PROFILE>
   ?doProfile = 1
  endif

  ifidni <p>, <NOPROFILE>
   ?doProfile = 0
  endif

 endm			;; End of user parameter parsing loop
endif

;;  Turn off options that don't make sense in USE32 segment

if @WordSize eq 4
  ?checkstack = 0
  ?loadds = 0
  ?incbp = 0
endif

;;  Frames are generated iff
;;	1. cbLocals + cbParams != 0
;;	2. FORCEFRAME is set
;;	3. INCBP is set and proc is far
;;	4. LOADDS is set
;;
;; Force a prolog?

?doPrologue = ?doPrologue OR ?incbp OR ?loadds OR ?checkstack OR (?cbLocals NE 0) OR (cbParams NE 0)

if	?doProfile EQ 1 	;; generate profiling call
	call	_penter
endif

if	?doPrologue EQ 0	;; No prolog needed -- so get out of here
;	popcontext listing
	exitm<0>
endif

if	?loadds EQ 1		;; Create the loadds code -- force in
	push	ds		;;	Put DS into AX -- we will place
	pop	ax	     ;;      back in DS later.	This sequence
	nop			;;	is altered by the OS if needed
endif

if	?incbp EQ 1		;; Mark as a far procedure for stack
	inc	bp	     ;;      walking
endif

if @WordSize eq 4
	push	ebp
	mov	ebp, esp
else
	push	bp	     ;; Create the frame
	mov	bp,sp
endif

if	?loadds EQ 1		;; Load up DS with the value in AX
	push	ds		;;
	mov	ds,ax	     ;;
	?cbLocals = ?cbLocals + 2
endif

if	?checkstack EQ 1	;; Now	allocate space for locals
	mov	ax,cbLocals  ;;      # of bytes of locals (unadjusted)
% ifidni <@CurSeg>, <_TEXT>
	call	_aNchkstk	;;	Call run time routine to allocate
 else
	call	_aFchkstk
 endif
else	; ?checkstack NE 1
  if	cbLocals NE 0
    if @WordSize eq 4
	sub	esp, cbLocals
    else
	sub	sp,cbLocals   ;;      make space on the stack for locals
    endif
  endif
endif

ifnb	rgRegs			;; There are registers to be saved.  do so
	for r,rgRegs
		push	r
	endm
endif
;	popcontext listing
	exitm <?cbLocals>

endm



;
;	This macro will produce the same output as will the
;	C6 compiler for the given switches.
;
;	The following may be placed in the MacroArgs field of the
;		proc defintion:
;
;	CHECKSTACK
;	NOCHECKSTACK
;	LOADDS
;	NOLOADDS
;	FORCEFRAME
;	INCBP
;	NOINCBP

option epilogue:cEpilogue

cEpilogue macro szProcName, flags, cbParams, cbLocals, rgRegs, rgUserParams
	LOCAL	?doPrologue
	LOCAL	?loadds
	LOCAL	?checkstack
	LOCAL	?incbp
;	pushcontext	listing
;	.nolistmacro
;	.listmacroall

	?doPrologue = 0
	?loadds = 0
	?checkstack = 0
	?incbp = 0

;;  Turn off options that don't make sense in USE32 segment

if @WordSize eq 4
  ?checkstack = 0
  ?loadds = 0
  ?incbp = 0
endif

;;	Set the defaults based on the global values specified
;;
if	?WP_DEBUG NE 0			;; Force frames by default
 ?doPrologue = 1
endif

if	?WP_CHECKSTACK NE 0		;; Force checkstack by default
 ?checkstack = 1
endif

if	?WP_INCBP NE 0			;; Force incbp by default
 if flags AND 020h
  ?incbp = 1
 endif
endif

if	?WP_LOADDS NE 0 		;; Force loadds by default
 if flags AND 020h
  ?loadds = 1
 endif
endif

;;
;;	Get all of the user parameters parsed
;;

ifnb	<rgUserParams>		;;	Parse user params if exsisting
 for p,<rgUserParams>		;;	For every user param

  ifidni <p>, <CHECKSTACK>	 ;;	 Is it checkstack?
   ?checkstack = 1		;;		Yes -- do checkstack
  endif

  ifidni <p>, <NOCHECKSTACK>	 ;;	 Don't do checkstack?
   ?checkstack = 0		;;		Yes -- clear checkstack
  endif

  ifidni <p>, <LOADDS>	 ;;	 Is it LoadDS
   ?loadds = 1			;;		Yes -- do loadds sequence
  endif

  ifidni <p>, <NOLOADDS> ;;	 Don't do LoadDS?
   ?loadds = 0			;;		Yes -- clear loadds flag
  endif

  ifidni <p>, <INCBP>	 ;;	 Is it IncBP
   if flags AND 020h
    ?incbp = 1			;;		Yes -- do IncBP sequence
   endif
  endif

  ifidni <p>, <NOINCBP>  ;;	 Is it NoIncBP
   ?incbp = 0			;;		Yes -- Clear the incbp flag
  endif

  ifidni <p>, <FORCEFRAME>	 ;;	 Is it ForceFrame?
   ?doPrologue = 1			;;		Yes -- force out a frame
  endif

 endm			;; End of user parameter parsing loop
endif

;;  Turn off options that don't make sense in USE32 segment

if @WordSize eq 4
  ?checkstack = 0
  ?loadds = 0
  ?incbp = 0
endif

;;  Frames are generated iff
;;	1. cbLocals + cbParams != 0
;;	2. FORCEFRAME is set
;;	3. INCBP is set and proc is far
;;	4. LOADDS is set
;;
;; Force a prolog?

?doPrologue = ?doPrologue OR ?incbp OR ?loadds OR ?checkstack OR (cbLocals NE 0) OR (cbParams NE 0)

if	?doPrologue EQ 0	;; No epilog needed -- so get out of here
	ret
	exitm
endif

ifnb	rgRegs			;; Pop off the registers -- they are in
	for r,rgRegs		;; inverse order from the prologue call
		pop	r
	endm
endif

if	?loadds 		;;
	dec	bp
	dec	bp
	mov	sp,bp
	pop	ds
	pop	bp
else

  if @WordSize eq 4
	mov	esp, ebp
	pop	ebp
  else
	mov	sp,bp
	pop	bp
  endif
endif

if	?incbp			;; Remove the increment of BP if necessary
	dec	bp
endif

if	flags AND 010h		;; Caller pops stack arguments
	ret
else				;; Callee pops args
 if	cbParams NE 0		;; Put out the correct form of return
	ret	cbParams
 else
	ret
 endif
endif
endm

popcontext	listing
.listmacro
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\tools\x86\misc\include\jpeglib.h ===
/*
 * jpeglib.h
 *
 * Copyright (C) 1991-1995, Thomas G. Lane.
 * This file is part of the Independent JPEG Group's software.
 * For conditions of distribution and use, see the accompanying README file.
 *
 * This file defines the application interface for the JPEG library.
 * Most applications using the library need only include this file,
 * and perhaps jerror.h if they want to know the exact error codes.
 */

#ifndef JPEGLIB_H
#define JPEGLIB_H
#pragma pack (8)   // pack on 8-byte boundaries for best perf

/*
 * First we include the configuration files that record how this
 * installation of the JPEG library is set up.  jconfig.h can be
 * generated automatically for many systems.  jmorecfg.h contains
 * manual configuration options that most people need not worry about.
 */

#ifndef JCONFIG_INCLUDED        /* in case jinclude.h already did */
#include "jconfig.h"            /* widely used configuration options */
#endif
#include "jmorecfg.h"           /* seldom changed options */

/* Version ID for the JPEG library.
 * Might be useful for tests like "#if JPEG_LIB_VERSION >= 60".
 */

#define JPEG_LIB_VERSION  60    /* Version 6 */


/* Various constants determining the sizes of things.
 * All of these are specified by the JPEG standard, so don't change them
 * if you want to be compatible.
 */

#define DCTSIZE             8   /* The basic DCT block is 8x8 samples */
#define DCTSIZE2            64  /* DCTSIZE squared; # of elements in a block */
#define NUM_QUANT_TBLS      4   /* Quantization tables are numbered 0..3 */
#define NUM_HUFF_TBLS       4   /* Huffman tables are numbered 0..3 */
#define NUM_ARITH_TBLS      16  /* Arith-coding tables are numbered 0..15 */
#define MAX_COMPS_IN_SCAN   4   /* JPEG limit on # of components in one scan */
#define MAX_SAMP_FACTOR     4   /* JPEG limit on sampling factors */
/* Unfortunately, it seems Adobe doesn't always follow the standard;
 * the PostScript DCT filter can emit files with many more than 10 blocks/MCU.
 * If you happen to run across such a file, you can up D_MAX_BLOCKS_IN_MCU
 * to handle it.  We even let you do this from the jconfig.h file.  However,
 * we strongly discourage changing C_MAX_BLOCKS_IN_MCU; just because Adobe
 * sometimes emits noncompliant files doesn't mean you should too.
 */
#define C_MAX_BLOCKS_IN_MCU   10 /* compressor's limit on blocks per MCU */
#ifndef D_MAX_BLOCKS_IN_MCU
#define D_MAX_BLOCKS_IN_MCU   10 /* decompressor's limit on blocks per MCU */
#endif


/* This macro is used to declare a "method", that is, a function pointer.
 * We want to supply prototype parameters if the compiler can cope.
 * Note that the arglist parameter must be parenthesized!
 */

#ifdef HAVE_PROTOTYPES
#define JMETHOD(type,methodname,arglist)  type (*methodname) arglist
#else
#define JMETHOD(type,methodname,arglist)  type (*methodname) ()
#endif


/* Data structures for images (arrays of samples and of DCT coefficients).
 * On 80x86 machines, the image arrays are too big for near pointers,
 * but the pointer arrays can fit in near memory.
 */

typedef JSAMPLE FAR *JSAMPROW;  /* ptr to one image row of pixel samples. */
typedef JSAMPROW *JSAMPARRAY;   /* ptr to some rows (a 2-D sample array) */
typedef JSAMPARRAY *JSAMPIMAGE; /* a 3-D sample array: top index is color */

typedef JCOEF JBLOCK[DCTSIZE2]; /* one block of coefficients */
typedef JBLOCK FAR *JBLOCKROW;  /* pointer to one row of coefficient blocks */
typedef JBLOCKROW *JBLOCKARRAY;         /* a 2-D array of coefficient blocks */
typedef JBLOCKARRAY *JBLOCKIMAGE;       /* a 3-D array of coefficient blocks */

typedef JCOEF FAR *JCOEFPTR;    /* useful in a couple of places */


/* Types for JPEG compression parameters and working tables. */


/* DCT coefficient quantization tables. */

typedef struct {
  /* This field directly represents the contents of a JPEG DQT marker.
   * Note: the values are always given in zigzag order.
   */
  UINT16 quantval[DCTSIZE2];    /* quantization step for each coefficient */
  /* This field is used only during compression.  It's initialized FALSE when
   * the table is created, and set TRUE when it's been output to the file.
   * You could suppress output of a table by setting this to TRUE.
   * (See jpeg_suppress_tables for an example.)
   */
  boolean sent_table;           /* TRUE when table has been output */
} JQUANT_TBL;


/* Huffman coding tables. */

typedef struct {
  /* These two fields directly represent the contents of a JPEG DHT marker */
  UINT8 bits[17];               /* bits[k] = # of symbols with codes of */
				/* length k bits; bits[0] is unused */
  UINT8 huffval[256];           /* The symbols, in order of incr code length */
  /* This field is used only during compression.  It's initialized FALSE when
   * the table is created, and set TRUE when it's been output to the file.
   * You could suppress output of a table by setting this to TRUE.
   * (See jpeg_suppress_tables for an example.)
   */
  boolean sent_table;           /* TRUE when table has been output */
} JHUFF_TBL;


/* Basic info about one component (color channel). */

typedef struct {
  /* These values are fixed over the whole image. */
  /* For compression, they must be supplied by parameter setup; */
  /* for decompression, they are read from the SOF marker. */
  int component_id;             /* identifier for this component (0..255) */
  int component_index;          /* its index in SOF or cinfo->comp_info[] */
  int h_samp_factor;            /* horizontal sampling factor (1..4) */
  int v_samp_factor;            /* vertical sampling factor (1..4) */
  int quant_tbl_no;             /* quantization table selector (0..3) */
  /* These values may vary between scans. */
  /* For compression, they must be supplied by parameter setup; */
  /* for decompression, they are read from the SOS marker. */
  /* The decompressor output side may not use these variables. */
  int dc_tbl_no;                /* DC entropy table selector (0..3) */
  int ac_tbl_no;                /* AC entropy table selector (0..3) */
  
  /* Remaining fields should be treated as private by applications. */
  
  /* These values are computed during compression or decompression startup: */
  /* Component's size in DCT blocks.
   * Any dummy blocks added to complete an MCU are not counted; therefore
   * these values do not depend on whether a scan is interleaved or not.
   */
  JDIMENSION width_in_blocks;
  JDIMENSION height_in_blocks;
  /* Size of a DCT block in samples.  Always DCTSIZE for compression.
   * For decompression this is the size of the output from one DCT block,
   * reflecting any scaling we choose to apply during the IDCT step.
   * Values of 1,2,4,8 are likely to be supported.  Note that different
   * components may receive different IDCT scalings.
   */
  int DCT_scaled_size;
  /* The downsampled dimensions are the component's actual, unpadded number
   * of samples at the main buffer (preprocessing/compression interface), thus
   * downsampled_width = ceil(image_width * Hi/Hmax)
   * and similarly for height.  For decompression, IDCT scaling is included, so
   * downsampled_width = ceil(image_width * Hi/Hmax * DCT_scaled_size/DCTSIZE)
   */
  JDIMENSION downsampled_width;  /* actual width in samples */
  JDIMENSION downsampled_height; /* actual height in samples */
  /* This flag is used only for decompression.  In cases where some of the
   * components will be ignored (eg grayscale output from YCbCr image),
   * we can skip most computations for the unused components.
   */
  boolean component_needed;     /* do we need the value of this component? */

  /* These values are computed before starting a scan of the component. */
  /* The decompressor output side may not use these variables. */
  int MCU_width;                /* number of blocks per MCU, horizontally */
  int MCU_height;               /* number of blocks per MCU, vertically */
  int MCU_blocks;               /* MCU_width * MCU_height */
  int MCU_sample_width;         /* MCU width in samples, MCU_width*DCT_scaled_size */
  int last_col_width;           /* # of non-dummy blocks across in last MCU */
  int last_row_height;          /* # of non-dummy blocks down in last MCU */

  /* Saved quantization table for component; NULL if none yet saved.
   * See jdinput.c comments about the need for this information.
   * This field is not currently used by the compressor.
   */
  JQUANT_TBL * quant_table;

  /* Private per-component storage for DCT or IDCT subsystem. */
  void * dct_table;
} jpeg_component_info;


/* The script for encoding a multiple-scan file is an array of these: */

typedef struct {
  int comps_in_scan;            /* number of components encoded in this scan */
  int component_index[MAX_COMPS_IN_SCAN]; /* their SOF/comp_info[] indexes */
  int Ss, Se;                   /* progressive JPEG spectral selection parms */
  int Ah, Al;                   /* progressive JPEG successive approx. parms */
} jpeg_scan_info;


/* Known color spaces. */

typedef enum {
	JCS_UNKNOWN,            /* error/unspecified */
	JCS_GRAYSCALE,          /* monochrome */
	JCS_RGB,                /* red/green/blue */
	JCS_YCbCr,              /* Y/Cb/Cr (also known as YUV) */
	JCS_CMYK,               /* C/M/Y/K */
	JCS_YCCK                /* Y/Cb/Cr/K */
} J_COLOR_SPACE;

/* DCT/IDCT algorithm options. */

typedef enum {
	JDCT_ISLOW,             /* slow but accurate integer algorithm */
	JDCT_IFAST,             /* faster, less accurate integer method */
	JDCT_FLOAT              /* floating-point: accurate, fast on fast HW */
} J_DCT_METHOD;

#ifndef JDCT_DEFAULT            /* may be overridden in jconfig.h */
#define JDCT_DEFAULT  JDCT_ISLOW
#endif
#ifndef JDCT_FASTEST            /* may be overridden in jconfig.h */
#define JDCT_FASTEST  JDCT_IFAST
#endif

/* Dithering options for decompression. */

typedef enum {
	JDITHER_NONE,           /* no dithering */
	JDITHER_ORDERED,        /* simple ordered dither */
	JDITHER_FS              /* Floyd-Steinberg error diffusion dither */
} J_DITHER_MODE;


/* Common fields between JPEG compression and decompression master structs. */

#define jpeg_common_fields \
  struct jpeg_error_mgr * err;  /* Error handler module */\
  struct jpeg_memory_mgr * mem; /* Memory manager module */\
  struct jpeg_progress_mgr * progress; /* Progress monitor, or NULL if none */\
  boolean is_decompressor;      /* so common code can tell which is which */\
  int global_state              /* for checking call sequence validity */

/* Routines that are to be used by both halves of the library are declared
 * to receive a pointer to this structure.  There are no actual instances of
 * jpeg_common_struct, only of jpeg_compress_struct and jpeg_decompress_struct.
 */
struct jpeg_common_struct {
  jpeg_common_fields;           /* Fields common to both master struct types */
  /* Additional fields follow in an actual jpeg_compress_struct or
   * jpeg_decompress_struct.  All three structs must agree on these
   * initial fields!  (This would be a lot cleaner in C++.)
   */
};

typedef struct jpeg_common_struct * j_common_ptr;
typedef struct jpeg_compress_struct * j_compress_ptr;
typedef struct jpeg_decompress_struct * j_decompress_ptr;


/* Master record for a compression instance */

struct jpeg_compress_struct {
  jpeg_common_fields;           /* Fields shared with jpeg_decompress_struct */

  /* Destination for compressed data */
  struct jpeg_destination_mgr * dest;

  /* Description of source image --- these fields must be filled in by
   * outer application before starting compression.  in_color_space must
   * be correct before you can even call jpeg_set_defaults().
   */

  JDIMENSION image_width;       /* input image width */
  JDIMENSION image_height;      /* input image height */
  int input_components;         /* # of color components in input image */
  J_COLOR_SPACE in_color_space; /* colorspace of input image */

  double input_gamma;           /* image gamma of input image */

  /* Compression parameters --- these fields must be set before calling
   * jpeg_start_compress().  We recommend calling jpeg_set_defaults() to
   * initialize everything to reasonable defaults, then changing anything
   * the application specifically wants to change.  That way you won't get
   * burnt when new parameters are added.  Also note that there are several
   * helper routines to simplify changing parameters.
   */

  int data_precision;           /* bits of precision in image data */

  int num_components;           /* # of color components in JPEG image */
  J_COLOR_SPACE jpeg_color_space; /* colorspace of JPEG image */

  jpeg_component_info * comp_info;
  /* comp_info[i] describes component that appears i'th in SOF */
  
  JQUANT_TBL * quant_tbl_ptrs[NUM_QUANT_TBLS];
  /* ptrs to coefficient quantization tables, or NULL if not defined */
  
  JHUFF_TBL * dc_huff_tbl_ptrs[NUM_HUFF_TBLS];
  JHUFF_TBL * ac_huff_tbl_ptrs[NUM_HUFF_TBLS];
  /* ptrs to Huffman coding tables, or NULL if not defined */
  
  UINT8 arith_dc_L[NUM_ARITH_TBLS]; /* L values for DC arith-coding tables */
  UINT8 arith_dc_U[NUM_ARITH_TBLS]; /* U values for DC arith-coding tables */
  UINT8 arith_ac_K[NUM_ARITH_TBLS]; /* Kx values for AC arith-coding tables */

  int num_scans;                /* # of entries in scan_info array */
  const jpeg_scan_info * scan_info; /* script for multi-scan file, or NULL */
  /* The default value of scan_info is NULL, which causes a single-scan
   * sequential JPEG file to be emitted.  To create a multi-scan file,
   * set num_scans and scan_info to point to an array of scan definitions.
   */

  boolean raw_data_in;          /* TRUE=caller supplies downsampled data */
  boolean arith_code;           /* TRUE=arithmetic coding, FALSE=Huffman */
  boolean optimize_coding;      /* TRUE=optimize entropy encoding parms */
  boolean CCIR601_sampling;     /* TRUE=first samples are cosited */
  int smoothing_factor;         /* 1..100, or 0 for no input smoothing */
  J_DCT_METHOD dct_method;      /* DCT algorithm selector */

  /* The restart interval can be specified in absolute MCUs by setting
   * restart_interval, or in MCU rows by setting restart_in_rows
   * (in which case the correct restart_interval will be figured
   * for each scan).
   */
  unsigned int restart_interval; /* MCUs per restart, or 0 for no restart */
  int restart_in_rows;          /* if > 0, MCU rows per restart interval */

  /* Parameters controlling emission of special markers. */

  boolean write_JFIF_header;    /* should a JFIF marker be written? */
  /* These three values are not used by the JPEG code, merely copied */
  /* into the JFIF APP0 marker.  density_unit can be 0 for unknown, */
  /* 1 for dots/inch, or 2 for dots/cm.  Note that the pixel aspect */
  /* ratio is defined by X_density/Y_density even when density_unit=0. */
  UINT8 density_unit;           /* JFIF code for pixel size units */
  UINT16 X_density;             /* Horizontal pixel density */
  UINT16 Y_density;             /* Vertical pixel density */
  boolean write_Adobe_marker;   /* should an Adobe marker be written? */
  
  /* State variable: index of next scanline to be written to
   * jpeg_write_scanlines().  Application may use this to control its
   * processing loop, e.g., "while (next_scanline < image_height)".
   */

  JDIMENSION next_scanline;     /* 0 .. image_height-1  */

  /* Remaining fields are known throughout compressor, but generally
   * should not be touched by a surrounding application.
   */

  /*
   * These fields are computed during compression startup
   */
  boolean progressive_mode;     /* TRUE if scan script uses progressive mode */
  int max_h_samp_factor;        /* largest h_samp_factor */
  int max_v_samp_factor;        /* largest v_samp_factor */

  JDIMENSION total_iMCU_rows;   /* # of iMCU rows to be input to coef ctlr */
  /* The coefficient controller receives data in units of MCU rows as defined
   * for fully interleaved scans (whether the JPEG file is interleaved or not).
   * There are v_samp_factor * DCTSIZE sample rows of each component in an
   * "iMCU" (interleaved MCU) row.
   */
  
  /*
   * These fields are valid during any one scan.
   * They describe the components and MCUs actually appearing in the scan.
   */
  int comps_in_scan;            /* # of JPEG components in this scan */
  jpeg_component_info * cur_comp_info[MAX_COMPS_IN_SCAN];
  /* *cur_comp_info[i] describes component that appears i'th in SOS */
  
  JDIMENSION MCUs_per_row;      /* # of MCUs across the image */
  JDIMENSION MCU_rows_in_scan;  /* # of MCU rows in the image */
  
  int blocks_in_MCU;            /* # of DCT blocks per MCU */
  int MCU_membership[C_MAX_BLOCKS_IN_MCU];
  /* MCU_membership[i] is index in cur_comp_info of component owning */
  /* i'th block in an MCU */

  int Ss, Se, Ah, Al;           /* progressive JPEG parameters for scan */

  /*
   * Links to compression subobjects (methods and private variables of modules)
   */
  struct jpeg_comp_master * master;
  struct jpeg_c_main_controller * main;
  struct jpeg_c_prep_controller * prep;
  struct jpeg_c_coef_controller * coef;
  struct jpeg_marker_writer * marker;
  struct jpeg_color_converter * cconvert;
  struct jpeg_downsampler * downsample;
  struct jpeg_forward_dct * fdct;
  struct jpeg_entropy_encoder * entropy;
};


/* Master record for a decompression instance */

struct jpeg_decompress_struct {
  jpeg_common_fields;           /* Fields shared with jpeg_compress_struct */

  /* Source of compressed data */
  struct jpeg_source_mgr * src;

  /* Basic description of image --- filled in by jpeg_read_header(). */
  /* Application may inspect these values to decide how to process image. */

  JDIMENSION image_width;       /* nominal image width (from SOF marker) */
  JDIMENSION image_height;      /* nominal image height */
  int num_components;           /* # of color components in JPEG image */
  J_COLOR_SPACE jpeg_color_space; /* colorspace of JPEG image */

  /* Decompression processing parameters --- these fields must be set before
   * calling jpeg_start_decompress().  Note that jpeg_read_header() initializes
   * them to default values.
   */

  J_COLOR_SPACE out_color_space; /* colorspace for output */

  unsigned int scale_num, scale_denom; /* fraction by which to scale image */

  double output_gamma;          /* image gamma wanted in output */

  boolean buffered_image;       /* TRUE=multiple output passes */
  boolean raw_data_out;         /* TRUE=downsampled data wanted */

  J_DCT_METHOD dct_method;      /* IDCT algorithm selector */
  boolean do_fancy_upsampling;  /* TRUE=apply fancy upsampling */
  boolean do_block_smoothing;   /* TRUE=apply interblock smoothing */

  boolean quantize_colors;      /* TRUE=colormapped output wanted */
  /* the following are ignored if not quantize_colors: */
  J_DITHER_MODE dither_mode;    /* type of color dithering to use */
  boolean two_pass_quantize;    /* TRUE=use two-pass color quantization */
  int desired_number_of_colors; /* max # colors to use in created colormap */
  /* these are significant only in buffered-image mode: */
  boolean enable_1pass_quant;   /* enable future use of 1-pass quantizer */
  boolean enable_external_quant;/* enable future use of external colormap */
  boolean enable_2pass_quant;   /* enable future use of 2-pass quantizer */

  /* Description of actual output image that will be returned to application.
   * These fields are computed by jpeg_start_decompress().
   * You can also use jpeg_calc_output_dimensions() to determine these values
   * in advance of calling jpeg_start_decompress().
   */

  JDIMENSION output_width;      /* scaled image width */
  JDIMENSION output_height;     /* scaled image height */
  int out_color_components;     /* # of color components in out_color_space */
  int output_components;        /* # of color components returned */
  /* output_components is 1 (a colormap index) when quantizing colors;
   * otherwise it equals out_color_components.
   */
  int rec_outbuf_height;        /* min recommended height of scanline buffer */
  /* If the buffer passed to jpeg_read_scanlines() is less than this many rows
   * high, space and time will be wasted due to unnecessary data copying.
   * Usually rec_outbuf_height will be 1 or 2, at most 4.
   */

  /* When quantizing colors, the output colormap is described by these fields.
   * The application can supply a colormap by setting colormap non-NULL before
   * calling jpeg_start_decompress; otherwise a colormap is created during
   * jpeg_start_decompress or jpeg_start_output.
   * The map has out_color_components rows and actual_number_of_colors columns.
   */
  int actual_number_of_colors;  /* number of entries in use */
  JSAMPARRAY colormap;          /* The color map as a 2-D pixel array */

  /* State variables: these variables indicate the progress of decompression.
   * The application may examine these but must not modify them.
   */

  /* Row index of next scanline to be read from jpeg_read_scanlines().
   * Application may use this to control its processing loop, e.g.,
   * "while (output_scanline < output_height)".
   */
  JDIMENSION output_scanline;   /* 0 .. output_height-1  */

  /* Current input scan number and number of iMCU rows completed in scan.
   * These indicate the progress of the decompressor input side.
   */
  int input_scan_number;        /* Number of SOS markers seen so far */
  JDIMENSION input_iMCU_row;    /* Number of iMCU rows completed */

  /* The "output scan number" is the notional scan being displayed by the
   * output side.  The decompressor will not allow output scan/row number
   * to get ahead of input scan/row, but it can fall arbitrarily far behind.
   */
  int output_scan_number;       /* Nominal scan number being displayed */
  JDIMENSION output_iMCU_row;   /* Number of iMCU rows read */

  /* Current progression status.  coef_bits[c][i] indicates the precision
   * with which component c's DCT coefficient i (in zigzag order) is known.
   * It is -1 when no data has yet been received, otherwise it is the point
   * transform (shift) value for the most recent scan of the coefficient
   * (thus, 0 at completion of the progression).
   * This pointer is NULL when reading a non-progressive file.
   */
  int (*coef_bits)[DCTSIZE2];   /* -1 or current Al value for each coef */

  /* Internal JPEG parameters --- the application usually need not look at
   * these fields.  Note that the decompressor output side may not use
   * any parameters that can change between scans.
   */

  /* Quantization and Huffman tables are carried forward across input
   * datastreams when processing abbreviated JPEG datastreams.
   */

  JQUANT_TBL * quant_tbl_ptrs[NUM_QUANT_TBLS];
  /* ptrs to coefficient quantization tables, or NULL if not defined */

  JHUFF_TBL * dc_huff_tbl_ptrs[NUM_HUFF_TBLS];
  JHUFF_TBL * ac_huff_tbl_ptrs[NUM_HUFF_TBLS];
  /* ptrs to Huffman coding tables, or NULL if not defined */

  /* These parameters are never carried across datastreams, since they
   * are given in SOF/SOS markers or defined to be reset by SOI.
   */

  int data_precision;           /* bits of precision in image data */

  jpeg_component_info * comp_info;
  /* comp_info[i] describes component that appears i'th in SOF */

  boolean progressive_mode;     /* TRUE if SOFn specifies progressive mode */
  boolean arith_code;           /* TRUE=arithmetic coding, FALSE=Huffman */

  UINT8 arith_dc_L[NUM_ARITH_TBLS]; /* L values for DC arith-coding tables */
  UINT8 arith_dc_U[NUM_ARITH_TBLS]; /* U values for DC arith-coding tables */
  UINT8 arith_ac_K[NUM_ARITH_TBLS]; /* Kx values for AC arith-coding tables */

  unsigned int restart_interval; /* MCUs per restart interval, or 0 for no restart */

  /* These fields record data obtained from optional markers recognized by
   * the JPEG library.
   */
  boolean saw_JFIF_marker;      /* TRUE iff a JFIF APP0 marker was found */
  /* Data copied from JFIF marker: */
  UINT8 density_unit;           /* JFIF code for pixel size units */
  UINT16 X_density;             /* Horizontal pixel density */
  UINT16 Y_density;             /* Vertical pixel density */
  boolean saw_Adobe_marker;     /* TRUE iff an Adobe APP14 marker was found */
  UINT8 Adobe_transform;        /* Color transform code from Adobe marker */

  boolean CCIR601_sampling;     /* TRUE=first samples are cosited */

  /* Remaining fields are known throughout decompressor, but generally
   * should not be touched by a surrounding application.
   */

  /*
   * These fields are computed during decompression startup
   */
  int max_h_samp_factor;        /* largest h_samp_factor */
  int max_v_samp_factor;        /* largest v_samp_factor */

  int min_DCT_scaled_size;      /* smallest DCT_scaled_size of any component */

  JDIMENSION total_iMCU_rows;   /* # of iMCU rows in image */
  /* The coefficient controller's input and output progress is measured in
   * units of "iMCU" (interleaved MCU) rows.  These are the same as MCU rows
   * in fully interleaved JPEG scans, but are used whether the scan is
   * interleaved or not.  We define an iMCU row as v_samp_factor DCT block
   * rows of each component.  Therefore, the IDCT output contains
   * v_samp_factor*DCT_scaled_size sample rows of a component per iMCU row.
   */

  JSAMPLE * sample_range_limit; /* table for fast range-limiting */

  /*
   * These fields are valid during any one scan.
   * They describe the components and MCUs actually appearing in the scan.
   * Note that the decompressor output side must not use these fields.
   */
  int comps_in_scan;            /* # of JPEG components in this scan */
  jpeg_component_info * cur_comp_info[MAX_COMPS_IN_SCAN];
  /* *cur_comp_info[i] describes component that appears i'th in SOS */

  JDIMENSION MCUs_per_row;      /* # of MCUs across the image */
  JDIMENSION MCU_rows_in_scan;  /* # of MCU rows in the image */

  int blocks_in_MCU;            /* # of DCT blocks per MCU */
  int MCU_membership[D_MAX_BLOCKS_IN_MCU];
  /* MCU_membership[i] is index in cur_comp_info of component owning */
  /* i'th block in an MCU */

  int Ss, Se, Ah, Al;           /* progressive JPEG parameters for scan */

  /* This field is shared between entropy decoder and marker parser.
   * It is either zero or the code of a JPEG marker that has been
   * read from the data source, but has not yet been processed.
   */
  int unread_marker;

  /*
   * Links to decompression subobjects (methods, private variables of modules)
   */
  struct jpeg_decomp_master * master;
  struct jpeg_d_main_controller * main;
  struct jpeg_d_coef_controller * coef;
  struct jpeg_d_post_controller * post;
  struct jpeg_input_controller * inputctl;
  struct jpeg_marker_reader * marker;
  struct jpeg_entropy_decoder * entropy;
  struct jpeg_inverse_dct * idct;
  struct jpeg_upsampler * upsample;
  struct jpeg_color_deconverter * cconvert;
  struct jpeg_color_quantizer * cquantize;
};


/* "Object" declarations for JPEG modules that may be supplied or called
 * directly by the surrounding application.
 * As with all objects in the JPEG library, these structs only define the
 * publicly visible methods and state variables of a module.  Additional
 * private fields may exist after the public ones.
 */


/* Error handler object */

struct jpeg_error_mgr {
  /* Error exit handler: does not return to caller */
  JMETHOD(void, error_exit, (j_common_ptr cinfo));
  /* Conditionally emit a trace or warning message */
  JMETHOD(void, emit_message, (j_common_ptr cinfo, int msg_level));
  /* Routine that actually outputs a trace or error message */
  JMETHOD(void, output_message, (j_common_ptr cinfo));
  /* Format a message string for the most recent JPEG error or message */
  JMETHOD(void, format_message, (j_common_ptr cinfo, char * buffer));
#define JMSG_LENGTH_MAX  200    /* recommended size of format_message buffer */
  /* Reset error state variables at start of a new image */
  JMETHOD(void, reset_error_mgr, (j_common_ptr cinfo));
  
  /* The message ID code and any parameters are saved here.
   * A message can have one string parameter or up to 8 int parameters.
   */
  int msg_code;
#define JMSG_STR_PARM_MAX  80
  union {
    int i[8];
    char s[JMSG_STR_PARM_MAX];
  } msg_parm;
  
  /* Standard state variables for error facility */
  
  int trace_level;              /* max msg_level that will be displayed */
  
  /* For recoverable corrupt-data errors, we emit a warning message,
   * but keep going unless emit_message chooses to abort.  emit_message
   * should count warnings in num_warnings.  The surrounding application
   * can check for bad data by seeing if num_warnings is nonzero at the
   * end of processing.
   */
  long num_warnings;            /* number of corrupt-data warnings */

  /* These fields point to the table(s) of error message strings.
   * An application can change the table pointer to switch to a different
   * message list (typically, to change the language in which errors are
   * reported).  Some applications may wish to add additional error codes
   * that will be handled by the JPEG library error mechanism; the second
   * table pointer is used for this purpose.
   *
   * First table includes all errors generated by JPEG library itself.
   * Error code 0 is reserved for a "no such error string" message.
   */
  const char * const * jpeg_message_table; /* Library errors */
  int last_jpeg_message;    /* Table contains strings 0..last_jpeg_message */
  /* Second table can be added by application (see cjpeg/djpeg for example).
   * It contains strings numbered first_addon_message..last_addon_message.
   */
  const char * const * addon_message_table; /* Non-library errors */
  int first_addon_message;      /* code for first string in addon table */
  int last_addon_message;       /* code for last string in addon table */
};


/* Progress monitor object */

struct jpeg_progress_mgr {
  JMETHOD(void, progress_monitor, (j_common_ptr cinfo));

  long pass_counter;            /* work units completed in this pass */
  long pass_limit;              /* total number of work units in this pass */
  int completed_passes;         /* passes completed so far */
  int total_passes;             /* total number of passes expected */
};


/* Data destination object for compression */

struct jpeg_destination_mgr {
  JOCTET * next_output_byte;    /* => next byte to write in buffer */
  size_t free_in_buffer;        /* # of byte spaces remaining in buffer */

  JMETHOD(void, init_destination, (j_compress_ptr cinfo));
  JMETHOD(boolean, empty_output_buffer, (j_compress_ptr cinfo));
  JMETHOD(void, term_destination, (j_compress_ptr cinfo));
};


/* Data source object for decompression */

struct jpeg_source_mgr {
  const JOCTET * next_input_byte; /* => next byte to read from buffer */
  size_t bytes_in_buffer;       /* # of bytes remaining in buffer */

  JMETHOD(void, init_source, (j_decompress_ptr cinfo));
  JMETHOD(boolean, fill_input_buffer, (j_decompress_ptr cinfo));
  JMETHOD(void, skip_input_data, (j_decompress_ptr cinfo, long num_bytes));
  JMETHOD(boolean, resync_to_restart, (j_decompress_ptr cinfo, int desired));
  JMETHOD(void, term_source, (j_decompress_ptr cinfo));
};


/* Memory manager object.
 * Allocates "small" objects (a few K total), "large" objects (tens of K),
 * and "really big" objects (virtual arrays with backing store if needed).
 * The memory manager does not allow individual objects to be freed; rather,
 * each created object is assigned to a pool, and whole pools can be freed
 * at once.  This is faster and more convenient than remembering exactly what
 * to free, especially where malloc()/free() are not too speedy.
 * NB: alloc routines never return NULL.  They exit to error_exit if not
 * successful.
 */

#define JPOOL_PERMANENT 0       /* lasts until master record is destroyed */
#define JPOOL_IMAGE     1       /* lasts until done with image/datastream */
#define JPOOL_NUMPOOLS  2

typedef struct jvirt_sarray_control * jvirt_sarray_ptr;
typedef struct jvirt_barray_control * jvirt_barray_ptr;


struct jpeg_memory_mgr {
  /* Method pointers */
  JMETHOD(void *, alloc_small, (j_common_ptr cinfo, int pool_id,
				size_t sizeofobject));
  JMETHOD(void FAR *, alloc_large, (j_common_ptr cinfo, int pool_id,
				     size_t sizeofobject));
  JMETHOD(JSAMPARRAY, alloc_sarray, (j_common_ptr cinfo, int pool_id,
				     JDIMENSION samplesperrow,
				     JDIMENSION numrows));
  JMETHOD(JBLOCKARRAY, alloc_barray, (j_common_ptr cinfo, int pool_id,
				      JDIMENSION blocksperrow,
				      JDIMENSION numrows));
  JMETHOD(jvirt_sarray_ptr, request_virt_sarray, (j_common_ptr cinfo,
						  int pool_id,
						  boolean pre_zero,
						  JDIMENSION samplesperrow,
						  JDIMENSION numrows,
						  JDIMENSION maxaccess));
  JMETHOD(jvirt_barray_ptr, request_virt_barray, (j_common_ptr cinfo,
						  int pool_id,
						  boolean pre_zero,
						  JDIMENSION blocksperrow,
						  JDIMENSION numrows,
						  JDIMENSION maxaccess));
  JMETHOD(void, realize_virt_arrays, (j_common_ptr cinfo));
  JMETHOD(JSAMPARRAY, access_virt_sarray, (j_common_ptr cinfo,
					   jvirt_sarray_ptr ptr,
					   JDIMENSION start_row,
					   JDIMENSION num_rows,
					   boolean writable));
  JMETHOD(JBLOCKARRAY, access_virt_barray, (j_common_ptr cinfo,
					    jvirt_barray_ptr ptr,
					    JDIMENSION start_row,
					    JDIMENSION num_rows,
					    boolean writable));
  JMETHOD(void, free_pool, (j_common_ptr cinfo, int pool_id));
  JMETHOD(void, self_destruct, (j_common_ptr cinfo));

  /* Limit on memory allocation for this JPEG object.  (Note that this is
   * merely advisory, not a guaranteed maximum; it only affects the space
   * used for virtual-array buffers.)  May be changed by outer application
   * after creating the JPEG object.
   */
  long max_memory_to_use;
};


/* Routine signature for application-supplied marker processing methods.
 * Need not pass marker code since it is stored in cinfo->unread_marker.
 */
typedef JMETHOD(boolean, jpeg_marker_parser_method, (j_decompress_ptr cinfo));


/* Declarations for routines called by application.
 * The JPP macro hides prototype parameters from compilers that can't cope.
 * Note JPP requires double parentheses.
 */

#ifdef HAVE_PROTOTYPES
#define JPP(arglist)    arglist
#else
#define JPP(arglist)    ()
#endif


/* Short forms of external names for systems with brain-damaged linkers.
 * We shorten external names to be unique in the first six letters, which
 * is good enough for all known systems.
 * (If your compiler itself needs names to be unique in less than 15 
 * characters, you are out of luck.  Get a better compiler.)
 */

#ifdef NEED_SHORT_EXTERNAL_NAMES
#define jpeg_std_error          jStdError
#define jpeg_create_compress    jCreaCompress
#define jpeg_create_decompress  jCreaDecompress
#define jpeg_destroy_compress   jDestCompress
#define jpeg_destroy_decompress jDestDecompress
#define jpeg_stdio_dest         jStdDest
#define jpeg_stdio_src          jStdSrc
#define jpeg_set_defaults       jSetDefaults
#define jpeg_set_colorspace     jSetColorspace
#define jpeg_default_colorspace jDefColorspace
#define jpeg_set_quality        jSetQuality
#define jpeg_set_linear_quality jSetLQuality
#define jpeg_add_quant_table    jAddQuantTable
#define jpeg_quality_scaling    jQualityScaling
#define jpeg_simple_progression jSimProgress
#define jpeg_suppress_tables    jSuppressTables
#define jpeg_alloc_quant_table  jAlcQTable
#define jpeg_alloc_huff_table   jAlcHTable
#define jpeg_start_compress     jStrtCompress
#define jpeg_write_scanlines    jWrtScanlines
#define jpeg_finish_compress    jFinCompress
#define jpeg_write_raw_data     jWrtRawData
#define jpeg_write_marker       jWrtMarker
#define jpeg_write_tables       jWrtTables
#define jpeg_read_header        jReadHeader
#define jpeg_start_decompress   jStrtDecompress
#define jpeg_read_scanlines     jReadScanlines
#define jpeg_finish_decompress  jFinDecompress
#define jpeg_read_raw_data      jReadRawData
#define jpeg_has_multiple_scans jHasMultScn
#define jpeg_start_output       jStrtOutput
#define jpeg_finish_output      jFinOutput
#define jpeg_input_complete     jInComplete
#define jpeg_new_colormap       jNewCMap
#define jpeg_consume_input      jConsumeInput
#define jpeg_calc_output_dimensions     jCalcDimensions
#define jpeg_set_marker_processor       jSetMarker
#define jpeg_read_coefficients  jReadCoefs
#define jpeg_write_coefficients jWrtCoefs
#define jpeg_copy_critical_parameters   jCopyCrit
#define jpeg_abort_compress     jAbrtCompress
#define jpeg_abort_decompress   jAbrtDecompress
#define jpeg_abort              jAbort
#define jpeg_destroy            jDestroy
#define jpeg_resync_to_restart  jResyncRestart
#endif /* NEED_SHORT_EXTERNAL_NAMES */


/* Default error-management setup */
EXTERN "C" { struct jpeg_error_mgr *jpeg_std_error JPP((struct jpeg_error_mgr *err));}

/* Initialization and destruction of JPEG compression objects */
/* NB: you must set up the error-manager BEFORE calling jpeg_create_xxx */
EXTERN "C" { void jpeg_create_compress JPP((j_compress_ptr cinfo));}
EXTERN "C" { void jpeg_create_decompress JPP((j_decompress_ptr cinfo));}
EXTERN "C" { void jpeg_destroy_compress JPP((j_compress_ptr cinfo));}
EXTERN "C" { void jpeg_destroy_decompress JPP((j_decompress_ptr cinfo));}

/* Standard data source and destination managers: stdio streams. */
/* Caller is responsible for opening the file before and closing after. */
EXTERN "C" { void jpeg_stdio_dest JPP((j_compress_ptr cinfo, FILE * outfile));}
EXTERN "C" { void jpeg_stdio_src JPP((j_decompress_ptr cinfo, FILE * infile));}

/* Default parameter setup for compression */
EXTERN "C" { void jpeg_set_defaults JPP((j_compress_ptr cinfo));}
/* Compression parameter setup aids */
EXTERN "C" { void jpeg_set_colorspace JPP((j_compress_ptr cinfo,
				     J_COLOR_SPACE colorspace));}
EXTERN "C" { void jpeg_default_colorspace JPP((j_compress_ptr cinfo));}
EXTERN "C" { void jpeg_set_quality JPP((j_compress_ptr cinfo, int quality,
				  boolean force_baseline));     }
EXTERN "C" { void jpeg_set_linear_quality JPP((j_compress_ptr cinfo,
					 int scale_factor,
					 boolean force_baseline)); }
EXTERN "C" { void jpeg_add_quant_table JPP((j_compress_ptr cinfo, int which_tbl,
				      const unsigned int *basic_table,
				      int scale_factor,
				      boolean force_baseline));}
EXTERN "C" { int jpeg_quality_scaling JPP((int quality));}
EXTERN "C" { void jpeg_simple_progression JPP((j_compress_ptr cinfo));}
EXTERN "C" { void jpeg_suppress_tables JPP((j_compress_ptr cinfo,
				      boolean suppress));}
EXTERN "C" { JQUANT_TBL * jpeg_alloc_quant_table JPP((j_common_ptr cinfo));}
EXTERN "C" { JHUFF_TBL * jpeg_alloc_huff_table JPP((j_common_ptr cinfo));}

/* Main entry points for compression */
EXTERN "C" { void jpeg_start_compress JPP((j_compress_ptr cinfo,
				     boolean write_all_tables));}
EXTERN "C" { JDIMENSION jpeg_write_scanlines JPP((j_compress_ptr cinfo,
					    JSAMPARRAY scanlines,
					    JDIMENSION num_lines));}
EXTERN "C" { void jpeg_finish_compress JPP((j_compress_ptr cinfo));}

/* Replaces jpeg_write_scanlines when writing raw downsampled data. */
EXTERN "C" { JDIMENSION jpeg_write_raw_data JPP((j_compress_ptr cinfo,
					   JSAMPIMAGE data,
					   JDIMENSION num_lines));}

/* Write a special marker.  See libjpeg.doc concerning safe usage. */
EXTERN "C" { void jpeg_write_marker JPP((j_compress_ptr cinfo, int marker,
				   const JOCTET *dataptr, unsigned int datalen));}

/* Alternate compression function: just write an abbreviated table file */
EXTERN "C" { void jpeg_write_tables JPP((j_compress_ptr cinfo));}

/* Decompression startup: read start of JPEG datastream to see what's there */
EXTERN "C" { int jpeg_read_header JPP((j_decompress_ptr cinfo,
				 boolean require_image));}
/* Return value is one of: */
#define JPEG_SUSPENDED          0 /* Suspended due to lack of input data */
#define JPEG_HEADER_OK          1 /* Found valid image datastream */
#define JPEG_HEADER_TABLES_ONLY 2 /* Found valid table-specs-only datastream */
/* If you pass require_image = TRUE (normal case), you need not check for
 * a TABLES_ONLY return code; an abbreviated file will cause an error exit.
 * JPEG_SUSPENDED is only possible if you use a data source module that can
 * give a suspension return (the stdio source module doesn't).
 */

/* Main entry points for decompression */
EXTERN "C" { boolean jpeg_start_decompress JPP((j_decompress_ptr cinfo));}
EXTERN "C" { JDIMENSION jpeg_read_scanlines JPP((j_decompress_ptr cinfo,
					   JSAMPARRAY scanlines,
					   JDIMENSION max_lines));}
EXTERN "C" { boolean jpeg_finish_decompress JPP((j_decompress_ptr cinfo));}

/* Replaces jpeg_read_scanlines when reading raw downsampled data. */
EXTERN "C" { JDIMENSION jpeg_read_raw_data JPP((j_decompress_ptr cinfo,
					  JSAMPIMAGE data,
					  JDIMENSION max_lines));}

/* Additional entry points for buffered-image mode. */
EXTERN "C" { boolean jpeg_has_multiple_scans JPP((j_decompress_ptr cinfo));}
EXTERN "C" { boolean jpeg_start_output JPP((j_decompress_ptr cinfo,
				      int scan_number));}
EXTERN "C" { boolean jpeg_finish_output JPP((j_decompress_ptr cinfo));}
EXTERN "C" { boolean jpeg_input_complete JPP((j_decompress_ptr cinfo));}
EXTERN "C" { void jpeg_new_colormap JPP((j_decompress_ptr cinfo));}
EXTERN "C" { int jpeg_consume_input JPP((j_decompress_ptr cinfo));}
/* Return value is one of: */
/* #define JPEG_SUSPENDED       0    Suspended due to lack of input data */
#define JPEG_REACHED_SOS        1 /* Reached start of new scan */
#define JPEG_REACHED_EOI        2 /* Reached end of image */
#define JPEG_ROW_COMPLETED      3 /* Completed one iMCU row */
#define JPEG_SCAN_COMPLETED     4 /* Completed last iMCU row of a scan */

/* Precalculate output dimensions for current decompression parameters. */
EXTERN "C" { void jpeg_calc_output_dimensions JPP((j_decompress_ptr cinfo));}

/* Install a special processing method for COM or APPn markers. */
EXTERN "C" { void jpeg_set_marker_processor JPP((j_decompress_ptr cinfo,
					   int marker_code,
					   jpeg_marker_parser_method routine));}

/* Read or write raw DCT coefficients --- useful for lossless transcoding. */
EXTERN "C" { jvirt_barray_ptr * jpeg_read_coefficients JPP((j_decompress_ptr cinfo));}
EXTERN "C" { void jpeg_write_coefficients JPP((j_compress_ptr cinfo,
					 jvirt_barray_ptr * coef_arrays));}
EXTERN "C" { void jpeg_copy_critical_parameters JPP((j_decompress_ptr srcinfo,
					       j_compress_ptr dstinfo));}

/* If you choose to abort compression or decompression before completing
 * jpeg_finish_(de)compress, then you need to clean up to release memory,
 * temporary files, etc.  You can just call jpeg_destroy_(de)compress
 * if you're done with the JPEG object, but if you want to clean it up and
 * reuse it, call this:
 */
EXTERN "C" { void jpeg_abort_compress JPP((j_compress_ptr cinfo));}
EXTERN "C" { void jpeg_abort_decompress JPP((j_decompress_ptr cinfo));}

/* Generic versions of jpeg_abort and jpeg_destroy that work on either
 * flavor of JPEG object.  These may be more convenient in some places.
 */
EXTERN "C" { void jpeg_abort JPP((j_common_ptr cinfo));}
EXTERN "C" { void jpeg_destroy JPP((j_common_ptr cinfo));}

/* Default restart-marker-resync procedure for use by data source modules */
EXTERN "C" { boolean jpeg_resync_to_restart JPP((j_decompress_ptr cinfo,
					   int desired));}


/* These marker codes are exported since applications and data source modules
 * are likely to want to use them.
 */

#define JPEG_RST0       0xD0    /* RST0 marker code */
#define JPEG_EOI        0xD9    /* EOI marker code */
#define JPEG_APP0       0xE0    /* APP0 marker code */
#define JPEG_COM        0xFE    /* COM marker code */


/* If we have a brain-damaged compiler that emits warnings (or worse, errors)
 * for structure definitions that are never filled in, keep it quiet by
 * supplying dummy definitions for the various substructures.
 */

#ifdef INCOMPLETE_TYPES_BROKEN
#ifndef JPEG_INTERNALS          /* will be defined in jpegint.h */
struct jvirt_sarray_control { long dummy; };
struct jvirt_barray_control { long dummy; };
struct jpeg_comp_master { long dummy; };
struct jpeg_c_main_controller { long dummy; };
struct jpeg_c_prep_controller { long dummy; };
struct jpeg_c_coef_controller { long dummy; };
struct jpeg_marker_writer { long dummy; };
struct jpeg_color_converter { long dummy; };
struct jpeg_downsampler { long dummy; };
struct jpeg_forward_dct { long dummy; };
struct jpeg_entropy_encoder { long dummy; };
struct jpeg_decomp_master { long dummy; };
struct jpeg_d_main_controller { long dummy; };
struct jpeg_d_coef_controller { long dummy; };
struct jpeg_d_post_controller { long dummy; };
struct jpeg_input_controller { long dummy; };
struct jpeg_marker_reader { long dummy; };
struct jpeg_entropy_decoder { long dummy; };
struct jpeg_inverse_dct { long dummy; };
struct jpeg_upsampler { long dummy; };
struct jpeg_color_deconverter { long dummy; };
struct jpeg_color_quantizer { long dummy; };
#endif /* JPEG_INTERNALS */
#endif /* INCOMPLETE_TYPES_BROKEN */


/*
 * The JPEG library modules define JPEG_INTERNALS before including this file.
 * The internal structure declarations are read only when that is true.
 * Applications using the library should not include jpegint.h, but may wish
 * to include jerror.h.
 */

#ifdef JPEG_INTERNALS
#include "jpegint.h"            /* fetch private declarations */
#include "jerror.h"             /* fetch error codes too */
#endif

#pragma pack ()                // restore structure packing to /Zp setting

#endif /* JPEGLIB_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\ddk\makefile.inc ===
!IFDEF PASS0ONLY
BuildDDK:

!ELSE

#
# Process only on the second pass
#

BuildDDK:
	call $(RAZZLETOOLPATH)\copyddkfiles.cmd  ddk_multimedia.ini  ddk $(PROJECT_ROOT)

!ENDIF
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\ddrawex\bfid.c ===
#include <windows.h>
#include <objbase.h>
#include <initguid.h>


DEFINE_GUID(BFID_MONOCHROME,
0xe436eb78, 0x524f, 0x11ce, 0x9f, 0x53, 0x00, 0x20, 0xaf, 0x0b, 0xa7, 0x70);

// e436eb79-524f-11ce-9f53-0020af0ba770            BFID_RGB4
DEFINE_GUID(BFID_RGB_4,
0xe436eb79, 0x524f, 0x11ce, 0x9f, 0x53, 0x00, 0x20, 0xaf, 0x0b, 0xa7, 0x70);

// e436eb7a-524f-11ce-9f53-0020af0ba770            BFID_RGB8
DEFINE_GUID(BFID_RGB_8,
0xe436eb7a, 0x524f, 0x11ce, 0x9f, 0x53, 0x00, 0x20, 0xaf, 0x0b, 0xa7, 0x70);

// e436eb7b-524f-11ce-9f53-0020af0ba770            BFID_RGB565
DEFINE_GUID(BFID_RGB_565,
0xe436eb7b, 0x524f, 0x11ce, 0x9f, 0x53, 0x00, 0x20, 0xaf, 0x0b, 0xa7, 0x70);

// e436eb7c-524f-11ce-9f53-0020af0ba770            BFID_RGB555
DEFINE_GUID(BFID_RGB_555,
0xe436eb7c, 0x524f, 0x11ce, 0x9f, 0x53, 0x00, 0x20, 0xaf, 0x0b, 0xa7, 0x70);

// e436eb7d-524f-11ce-9f53-0020af0ba770            BFID_RGB24
DEFINE_GUID(BFID_RGB_24,
0xe436eb7d, 0x524f, 0x11ce, 0x9f, 0x53, 0x00, 0x20, 0xaf, 0x0b, 0xa7, 0x70);

// e436eb7e-524f-11ce-9f53-0020af0ba770            BFID_RGB32
DEFINE_GUID(BFID_RGB_32,
0xe436eb7e, 0x524f, 0x11ce, 0x9f, 0x53, 0x00, 0x20, 0xaf, 0x0b, 0xa7, 0x70);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\ddraw\dmemmgr.h ===
/*==========================================================================;
 *
 *  Copyright (C) 1994-1997 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:	dmemmgr.h
 *  Content:	Direct Memory Manager include file
 *@@BEGIN_MSINTERNAL
 *  History:
 *   Date	By	Reason
 *   ====	==	======
 *   10-jun-95	craige	initial implementation
 *   18-jun-95	craige	pitch in VidMemInit
 *   17-jul-95	craige	added VidMemLargestFree
 *   29-nov-95  colinmc added VidMemAmountAllocated
 *   05-jul-96  colinmc Work Item: Removing the restriction on taking Win16
 *                      lock on VRAM surfaces (not including the primary)
 *   18-jan-97  colinmc Work Item: AGP support
 *   03-mar-97  jeffno  Work item: Extended surface memory alignment
 *@@END_MSINTERNAL
 ***************************************************************************/

#ifndef __DMEMMGR_INCLUDED__
#define __DMEMMGR_INCLUDED__

#ifdef __cplusplus
extern "C" {
#endif

/*
 * pointer to video meory
 */
typedef unsigned long	FLATPTR;


/*
 * Structure for querying extended heap alignment requirements
 */

typedef struct _SURFACEALIGNMENT
{
    union
    {
        struct
        {
            DWORD       dwStartAlignment;
            DWORD       dwPitchAlignment;
            DWORD       dwReserved1;
            DWORD       dwReserved2;
        } Linear;
        struct
        {
            DWORD       dwXAlignment;
            DWORD       dwYAlignment;
            DWORD       dwReserved1;
            DWORD       dwReserved2;
        } Rectangular;
    };
} SURFACEALIGNMENT;
typedef struct _SURFACEALIGNMENT FAR *LPSURFACEALIGNMENT;

typedef struct _HEAPALIGNMENT
{
    DWORD                dwSize;
    DDSCAPS              ddsCaps;       /* Indicates which alignment fields are valid.*/
    DWORD                dwReserved;
    SURFACEALIGNMENT     ExecuteBuffer; /* Surfaces tagged with DDSCAPS_EXECUTEBUFFER */
    SURFACEALIGNMENT     Overlay;       /* Surfaces tagged with DDSCAPS_OVERLAY       */
    SURFACEALIGNMENT     Texture;       /* Surfaces tagged with DDSCAPS_TEXTURE       */
    SURFACEALIGNMENT     ZBuffer;       /* Surfaces tagged with DDSCAPS_ZBUFFER       */
    SURFACEALIGNMENT     AlphaBuffer;   /* Surfaces tagged with DDSCAPS_ALPHA         */
    SURFACEALIGNMENT     Offscreen;     /* Surfaces tagged with DDSCAPS_OFFSCREENPLAIN*/
    SURFACEALIGNMENT     FlipTarget;    /* Surfaces whose bits are potential primaries i.e. back buffers*/
} HEAPALIGNMENT;
typedef struct _HEAPALIGNMENT FAR *LPHEAPALIGNMENT;

/*
 * video memory manager structures
 */
typedef struct _VMEML
{
    struct _VMEML 	FAR *next;
    FLATPTR		ptr;
    DWORD		size;
} VMEML, FAR *LPVMEML, FAR * FAR *LPLPVMEML;

typedef struct _VMEMR
{
    struct _VMEMR 	FAR *next;
    struct _VMEMR       FAR *prev;
    /*
     * The pUp, pDown, pLeft and pRight members were removed in DX5
     */
    struct _VMEMR 	FAR *pUp;
    struct _VMEMR 	FAR *pDown;
    struct _VMEMR 	FAR *pLeft;
    struct _VMEMR 	FAR *pRight;
    FLATPTR		ptr;
    DWORD		size;
    DWORD               x;
    DWORD               y;
    DWORD               cx;
    DWORD               cy;
    DWORD		flags;
    FLATPTR             pBits;
} VMEMR, FAR *LPVMEMR, FAR * FAR *LPLPVMEMR;

#ifdef NT_KERNEL_HEAPS
typedef void VMEMHEAP;
#else
typedef struct _VMEMHEAP
{
    DWORD		        dwFlags;
    DWORD                       stride;
    LPVOID		        freeList;
    LPVOID		        allocList;
    DWORD                       dwTotalSize;
    FLATPTR                     fpGARTLin;      /* AGP: GART linear base of heap (app. visible)   */
    FLATPTR                     fpGARTDev;      /* AGP: GART device base of heap (driver visible) */
    DWORD                       dwCommitedSize; /* AGP: Number of bytes commited to heap          */
    /*
     * Extended alignment data:
     * Filled in by DirectDraw in response to a GetHeapAlignment HAL call.
     */
    DWORD                       dwCoalesceCount;
    HEAPALIGNMENT               Alignment;
} VMEMHEAP;
#endif

typedef VMEMHEAP FAR *LPVMEMHEAP;

#define VMEMHEAP_LINEAR			0x00000001l /* Heap is linear                    */
#define VMEMHEAP_RECTANGULAR		0x00000002l /* Heap is rectangular               */
#define VMEMHEAP_ALIGNMENT  		0x00000004l /* Heap has extended alignment info  */

/*
 * These legacy DLL exports don't handle nonlocal heaps
 */
extern FLATPTR WINAPI VidMemAlloc( LPVMEMHEAP pvmh, DWORD width, DWORD height );
extern void WINAPI VidMemFree( LPVMEMHEAP pvmh, FLATPTR ptr );

/*
 * This DLL export can be used by drivers to allocate aligned surfaces from heaps which
 * they have previously exposed to DDRAW.DLL. This function can allocate from nonlocal heaps.
 */
extern FLATPTR WINAPI HeapVidMemAllocAligned( 
                struct _VIDMEM* lpVidMem,
                DWORD dwWidth, 
                DWORD dwHeight, 
                LPSURFACEALIGNMENT lpAlignment , 
                LPLONG lpNewPitch );


//@@BEGIN_MSINTERNAL
extern FLATPTR WINAPI HeapVidMemAlloc( struct _VIDMEM* lpVidMem, DWORD x, DWORD y, HANDLE hdev , LPSURFACEALIGNMENT lpAlignment , LPLONG lpNewPitch );
extern LPVMEMHEAP WINAPI VidMemInit( DWORD flags, FLATPTR start, FLATPTR end_or_width, DWORD height, DWORD pitch );
extern void WINAPI VidMemFini( LPVMEMHEAP pvmh );
extern DWORD WINAPI VidMemAmountFree( LPVMEMHEAP pvmh );
extern DWORD WINAPI VidMemAmountAllocated( LPVMEMHEAP pvmh );
extern DWORD WINAPI VidMemLargestFree( LPVMEMHEAP pvmh );
extern LPVMEMHEAP WINAPI HeapVidMemInit( struct _VIDMEM* lpVidMem, DWORD pitch, HANDLE hdev, LPHEAPALIGNMENT phad);
extern void WINAPI HeapVidMemFini( struct _VIDMEM* lpVidMem, HANDLE hdev );
//@@END_MSINTERNAL

#ifdef __cplusplus
};
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\ddrawex\comdll.h ===
#ifndef _INC_COMDLL
#define _INC_COMDLL

#include <windows.h>
#include <objbase.h>

// helper macros...
#define _IOffset(class, itf)         ((UINT_PTR)&(((class *)0)->itf))
#define IToClass(class, itf, pitf)   ((class  *)(((LPSTR)pitf)-_IOffset(class, itf)))

// standard DLL goo...
extern HANDLE g_hinst;
STDAPI_(void) DllAddRef();
STDAPI_(void) DllRelease();

#ifndef ARRAYSIZE
#define ARRAYSIZE(x) (sizeof(x) / sizeof((x)[0]))
#endif

// Functions to create standard objects
STDAPI DirectDrawFactory_CreateInstance(IUnknown * pUnkOuter, REFIID riid, void ** ppv);


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\ddrawex\crtfree.h ===
//
// Code to help free modules from the bondage and tyranny of CRT libraries
//
// Include this header in a single component and #define CPP_FUNCTIONS
//


#if defined(__cplusplus) && defined(CPP_FUNCTIONS)

void *  __cdecl operator new(size_t nSize)
    {
    // Zero init just to save some headaches
    return((LPVOID)LocalAlloc(LPTR, nSize));
    }


void  __cdecl operator delete(void *pv)
    {
    LocalFree((HLOCAL)pv);
    }

extern "C" int __cdecl _purecall(void) {return 0;}

#endif

#ifdef __cplusplus
extern "C" {
#endif

#if defined(DEFINE_FLOAT_STUFF)
// If you aren't using any floating-point CRT functions and you know
// you aren't performing any float conversions or arithmetic, yet the
// linker wants these symbols declared, then define DEFINE_FLOAT_STUFF.
//
// Warning: declaring these symbols in a component that needs floating
// point support from the CRT will produce undefined results.  (You will
// need fp support from the CRT if you simply perform fp arithmetic.)

int _fltused = 0;
void __cdecl _fpmath(void) { }
#endif

#ifdef __cplusplus
};
#endif

//
// This file should be included in a global component header
// to use the following
//

#ifndef __CRTFREE_H_
#define __CRTFREE_H_

#ifdef __cplusplus

#ifndef _M_PPC
#pragma intrinsic(memcpy)
#pragma intrinsic(memcmp)
#pragma intrinsic(memset)
#endif

#endif

#endif  // __CRTFREE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\ddrawex\ddraw3i.h ===
/*==========================================================================
 *
 *  Copyright (C) 1997 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       ddraw3i.h
 *  Content:	DirectDraw 3 internal data structures
 *  History:
 *   Date	By	Reason
 *   ====	==	======
 *   27-feb-97	craige	initial implementation
 *
 ***************************************************************************/

#define DDRAWISURFGBL_MEMFREE		0x00000001L	// memory has been freed
#define DDRAWISURFGBL_SYSMEMREQUESTED	0x00000002L	// surface is in system memory at request of user

#define DDRAWISURF_HASPIXELFORMAT	0x00002000L	// surface structure has pixel format data

typedef ULONG_PTR FLATPTR;

typedef struct _DDRAWI_DDRAWSURFACE_GBL FAR  *LPDDRAWI_DDRAWSURFACE_GBL;
typedef struct _DDRAWI_DDRAWSURFACE_MORE FAR *LPDDRAWI_DDRAWSURFACE_MORE;
typedef struct _DDRAWI_DDRAWSURFACE_LCL FAR  *LPDDRAWI_DDRAWSURFACE_LCL;
typedef struct _DDRAWI_DDRAWSURFACE_INT FAR  *LPDDRAWI_DDRAWSURFACE_INT;

/*
 * DBLNODE - a node in a doubly-linked list of surface interfaces
 */
typedef struct _DBLNODE
{
    struct  _DBLNODE                    FAR *next;  // link to next node
    struct  _DBLNODE                    FAR *prev;  // link to previous node
    LPDDRAWI_DDRAWSURFACE_LCL           object;     // link to object
    LPDDRAWI_DDRAWSURFACE_INT		object_int; // object interface
} DBLNODE;
typedef DBLNODE FAR *LPDBLNODE;

/*
 * DDRAW surface interface struct
 */
typedef struct _DDRAWI_DDRAWSURFACE_INT
{
    LPVOID				lpVtbl;		// pointer to array of interface methods
    LPDDRAWI_DDRAWSURFACE_LCL		lpLcl;		// pointer to interface data
    LPDDRAWI_DDRAWSURFACE_INT		lpLink;		// link to next interface
    DWORD				dwIntRefCnt;	// interface reference count
} DDRAWI_DDRAWSURFACE_INT;

/*
 * DDRAW internal version of DIRECTDRAWSURFACE struct
 *
 * the GBL structure is global data for all duplicate objects
 */
typedef struct _DDRAWI_DDRAWSURFACE_GBL
{
    DWORD			dwRefCnt;	// reference count
    DWORD			dwGlobalFlags;	// global flags
    union
    {
	LPVOID			lpRectList;	// list of accesses
	DWORD			dwBlockSizeY;	// block size that display driver requested (return)
    };
    union
    {
	LPVOID			lpVidMemHeap;	// heap vidmem was alloc'ed from
	DWORD			dwBlockSizeX;	// block size that display driver requested (return)
    };
    union
    {
	LPVOID			lpDD; 		// internal DIRECTDRAW object
	LPVOID			lpDDHandle; 	// handle to internal DIRECTDRAW object
						// for use by display driver
						// when calling fns in DDRAW16.DLL
    };
    FLATPTR			fpVidMem;	// pointer to video memory
    union
    {
	LONG			lPitch;		// pitch of surface
	DWORD                   dwLinearSize;   // linear size of non-rectangular surface
    };
    WORD			wHeight;	// height of surface
    WORD			wWidth;		// width of surface
    DWORD			dwUsageCount;	// number of access to this surface
    DWORD			dwReserved1;	// reserved for use by display driver
    //
    // NOTE: this part of the structure is ONLY allocated if the pixel
    //	     format differs from that of the primary display
    //
    DDPIXELFORMAT		ddpfSurface;	// pixel format of surface

} DDRAWI_DDRAWSURFACE_GBL;

/*
 * a structure holding additional LCL surface information (can't simply be appended
 * to the LCL structure as that structure is of variable size).
 */
typedef struct _DDRAWI_DDRAWSURFACE_MORE
{
    DWORD			dwSize;
    VOID			FAR *lpIUnknowns;   // IUnknowns aggregated by this surface
    LPVOID			lpDD_lcl;	    // Pointer to the DirectDraw local object
    DWORD			dwPageLockCount;    // count of pagelocks
    DWORD			dwBytesAllocated;   // size of sys mem allocated
    LPVOID			lpDD_int;	    // Pointer to the DirectDraw interface
    DWORD                       dwMipMapCount;      // Number of mip-map levels in the chain
    LPVOID			lpDDIClipper;	    // Interface to attached clipper object
} DDRAWI_DDRAWSURFACE_MORE;

/*
 * the LCL structure is local data for each individual surface object
 */
struct _DDRAWI_DDRAWSURFACE_LCL
{
    LPDDRAWI_DDRAWSURFACE_MORE		lpSurfMore;	// pointer to additional local data
    LPDDRAWI_DDRAWSURFACE_GBL		lpGbl;		// pointer to surface shared data
    DWORD                               hDDSurface;     // NT Kernel-mode handle was dwUnused0
    LPVOID				lpAttachList;	// link to surfaces we attached to
    LPVOID				lpAttachListFrom;// link to surfaces that attached to this one
    DWORD				dwLocalRefCnt;	// object refcnt
    DWORD				dwProcessId;	// owning process
    DWORD				dwFlags;	// flags
    DDSCAPS				ddsCaps;	// capabilities of surface
    union
    {
	LPVOID			 	lpDDPalette; 	// associated palette
	LPVOID			 	lp16DDPalette; 	// 16-bit ptr to associated palette
    };
    union
    {
	LPVOID			 	lpDDClipper; 	// associated clipper
	LPVOID			 	lp16DDClipper; 	// 16-bit ptr to associated clipper
    };
    DWORD				dwModeCreatedIn;
    DWORD				dwBackBufferCount; // number of back buffers created
    DDCOLORKEY				ddckCKDestBlt;	// color key for destination blt use
    DDCOLORKEY				ddckCKSrcBlt;	// color key for source blt use
//    IUnknown				FAR *pUnkOuter;	// outer IUnknown
    DWORD				hDC;		// owned dc
    DWORD				dwReserved1;	// reserved for use by display driver

    /*
     * NOTE: this part of the structure is ONLY allocated if the surface
     *	     can be used for overlays.  ddckCKSrcOverlay MUST NOT BE MOVED
     *	     from the start of this area.
     */
    DDCOLORKEY				ddckCKSrcOverlay;// color key for source overlay use
    DDCOLORKEY				ddckCKDestOverlay;// color key for destination overlay use
    LPDDRAWI_DDRAWSURFACE_INT		lpSurfaceOverlaying; // surface we are overlaying
    DBLNODE				dbnOverlayNode;
    /*
     * overlay rectangle, used by DDHEL
     */
    RECT				rcOverlaySrc;
    RECT				rcOverlayDest;
    /*
     * the below values are kept here for ddhel. they're set by UpdateOverlay,
     * they're used whenever the overlays are redrawn.
     */
    DWORD				dwClrXparent; 	// the *actual* color key (override, colorkey, or CLR_INVALID)
    DWORD				dwAlpha; 	// the per surface alpha
    /*
     * overlay position
     */
    LONG				lOverlayX;	// current x position
    LONG				lOverlayY;	// current y position
};
typedef struct _DDRAWI_DDRAWSURFACE_LCL DDRAWI_DDRAWSURFACE_LCL;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\ddrawex\ddrawex.h ===
//*********************************************************************
//*                  Microsoft Windows                               **
//*            Copyright(c) Microsoft Corp., 1995-1997               **
//*********************************************************************
//
//	DDRAWEX.H 
//
//	Header file for DirectDrawEx functionality

#ifndef __DDRAWEXH__
#define __DDRAWEXH__

#ifdef __cplusplus
extern "C" {
#endif

#include <ddraw.h>

// {4FD2A832-86C8-11d0-8FCA-00C04FD9189D}
DEFINE_GUID(CLSID_DirectDrawFactory, 
0x4fd2a832, 0x86c8, 0x11d0, 0x8f, 0xca, 0x0, 0xc0, 0x4f, 0xd9, 0x18, 0x9d);

DEFINE_GUID(IID_IDirectDrawFactory, 
0x4fd2a833, 0x86c8, 0x11d0, 0x8f, 0xca, 0x0, 0xc0, 0x4f, 0xd9, 0x18, 0x9d);

#ifndef DIRECTDRAW_VERSION

//Functionality supported by DDrawex but not DX3
#define DDSD_LPSURFACE		0x00000800l

DEFINE_GUID( IID_IDirectDrawSurface3,
0xDA044E00,0x69B2,0x11D0,0xA1,0xD5,0x00,0xAA,0x00,0xB8,0xDF,0xBB );

typedef struct IDirectDrawSurface3		FAR *LPDIRECTDRAWSURFACE3;

#undef INTERFACE
#define INTERFACE IDirectDrawSurface3
DECLARE_INTERFACE_( IDirectDrawSurface3, IUnknown )
{
    /*** IUnknown methods ***/
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR * ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;
    /*** IDirectDrawSurface methods ***/
    STDMETHOD(AddAttachedSurface)(THIS_ LPDIRECTDRAWSURFACE3) PURE;
    STDMETHOD(AddOverlayDirtyRect)(THIS_ LPRECT) PURE;
    STDMETHOD(Blt)(THIS_ LPRECT,LPDIRECTDRAWSURFACE3, LPRECT,DWORD, LPDDBLTFX) PURE;
    STDMETHOD(BltBatch)(THIS_ LPDDBLTBATCH, DWORD, DWORD ) PURE;
    STDMETHOD(BltFast)(THIS_ DWORD,DWORD,LPDIRECTDRAWSURFACE3, LPRECT,DWORD) PURE;
    STDMETHOD(DeleteAttachedSurface)(THIS_ DWORD,LPDIRECTDRAWSURFACE3) PURE;
    STDMETHOD(EnumAttachedSurfaces)(THIS_ LPVOID,LPDDENUMSURFACESCALLBACK) PURE;
    STDMETHOD(EnumOverlayZOrders)(THIS_ DWORD,LPVOID,LPDDENUMSURFACESCALLBACK) PURE;
    STDMETHOD(Flip)(THIS_ LPDIRECTDRAWSURFACE3, DWORD) PURE;
    STDMETHOD(GetAttachedSurface)(THIS_ LPDDSCAPS, LPDIRECTDRAWSURFACE3 FAR *) PURE;
    STDMETHOD(GetBltStatus)(THIS_ DWORD) PURE;
    STDMETHOD(GetCaps)(THIS_ LPDDSCAPS) PURE;
    STDMETHOD(GetClipper)(THIS_ LPDIRECTDRAWCLIPPER FAR*) PURE;
    STDMETHOD(GetColorKey)(THIS_ DWORD, LPDDCOLORKEY) PURE;
    STDMETHOD(GetDC)(THIS_ HDC FAR *) PURE;
    STDMETHOD(GetFlipStatus)(THIS_ DWORD) PURE;
    STDMETHOD(GetOverlayPosition)(THIS_ LPLONG, LPLONG ) PURE;
    STDMETHOD(GetPalette)(THIS_ LPDIRECTDRAWPALETTE FAR*) PURE;
    STDMETHOD(GetPixelFormat)(THIS_ LPDDPIXELFORMAT) PURE;
    STDMETHOD(GetSurfaceDesc)(THIS_ LPDDSURFACEDESC) PURE;
    STDMETHOD(Initialize)(THIS_ LPDIRECTDRAW, LPDDSURFACEDESC) PURE;
    STDMETHOD(IsLost)(THIS) PURE;
    STDMETHOD(Lock)(THIS_ LPRECT,LPDDSURFACEDESC,DWORD,HANDLE) PURE;
    STDMETHOD(ReleaseDC)(THIS_ HDC) PURE;
    STDMETHOD(Restore)(THIS) PURE;
    STDMETHOD(SetClipper)(THIS_ LPDIRECTDRAWCLIPPER) PURE;
    STDMETHOD(SetColorKey)(THIS_ DWORD, LPDDCOLORKEY) PURE;
    STDMETHOD(SetOverlayPosition)(THIS_ LONG, LONG ) PURE;
    STDMETHOD(SetPalette)(THIS_ LPDIRECTDRAWPALETTE) PURE;
    STDMETHOD(Unlock)(THIS_ LPVOID) PURE;
    STDMETHOD(UpdateOverlay)(THIS_ LPRECT, LPDIRECTDRAWSURFACE3,LPRECT,DWORD, LPDDOVERLAYFX) PURE;
    STDMETHOD(UpdateOverlayDisplay)(THIS_ DWORD) PURE;
    STDMETHOD(UpdateOverlayZOrder)(THIS_ DWORD, LPDIRECTDRAWSURFACE3) PURE;
    /*** Added in the v2 interface ***/
    STDMETHOD(GetDDInterface)(THIS_ LPVOID FAR *) PURE;
    STDMETHOD(PageLock)(THIS_ DWORD) PURE;
    STDMETHOD(PageUnlock)(THIS_ DWORD) PURE;
    /*** Added in the v3 interface ***/
    STDMETHOD(SetSurfaceDesc)(THIS_ LPDDSURFACEDESC, DWORD ) PURE;
};
#endif




#define	DDSCAPS_DATAEXCHANGE	(DDSCAPS_SYSTEMMEMORY|DDSCAPS_VIDEOMEMORY)

#undef	INTERFACE
#define INTERFACE IDirectDrawFactory

DECLARE_INTERFACE_(IDirectDrawFactory, IUnknown)
{
    /*** IUnknown methods ***/
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR * ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;
    /*** IDirectDrawFactory methods ***/
    STDMETHOD(CreateDirectDraw) (THIS_ GUID * pGUID, HWND hWnd, DWORD dwCoopLevelFlags, DWORD dwReserved, IUnknown *pUnkOuter, IDirectDraw **ppDirectDraw) PURE;
    STDMETHOD(DirectDrawEnumerate) (THIS_ LPDDENUMCALLBACK lpCallback, LPVOID lpContext) PURE;
};


 
// {618F8AD4-8B7A-11d0-8FCC-00C04FD9189D}
DEFINE_GUID(IID_IDirectDraw3, 
0x618f8ad4, 0x8b7a, 0x11d0, 0x8f, 0xcc, 0x0, 0xc0, 0x4f, 0xd9, 0x18, 0x9d);

typedef struct IDirectDraw3		FAR *LPDIRECTDRAW3;

#undef	INTERFACE
#define INTERFACE IDirectDraw3

DECLARE_INTERFACE_(IDirectDraw3, IUnknown)
{
    /*** IUnknown methods ***/
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR * ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;
    /*** IDirectDraw methods ***/
    STDMETHOD(Compact)(THIS) PURE;
    STDMETHOD(CreateClipper)(THIS_ DWORD, LPDIRECTDRAWCLIPPER FAR*, IUnknown FAR * ) PURE;
    STDMETHOD(CreatePalette)(THIS_ DWORD, LPPALETTEENTRY, LPDIRECTDRAWPALETTE FAR*, IUnknown FAR * ) PURE;
    STDMETHOD(CreateSurface)(THIS_  LPDDSURFACEDESC, LPDIRECTDRAWSURFACE FAR *, IUnknown FAR *) PURE;
    STDMETHOD(DuplicateSurface)( THIS_ LPDIRECTDRAWSURFACE, LPDIRECTDRAWSURFACE FAR * ) PURE;
    STDMETHOD(EnumDisplayModes)( THIS_ DWORD, LPDDSURFACEDESC, LPVOID, LPDDENUMMODESCALLBACK ) PURE;
    STDMETHOD(EnumSurfaces)(THIS_ DWORD, LPDDSURFACEDESC, LPVOID,LPDDENUMSURFACESCALLBACK ) PURE;
    STDMETHOD(FlipToGDISurface)(THIS) PURE;
    STDMETHOD(GetCaps)( THIS_ LPDDCAPS, LPDDCAPS) PURE;
    STDMETHOD(GetDisplayMode)( THIS_ LPDDSURFACEDESC) PURE;
    STDMETHOD(GetFourCCCodes)(THIS_  LPDWORD, LPDWORD ) PURE;
    STDMETHOD(GetGDISurface)(THIS_ LPDIRECTDRAWSURFACE FAR *) PURE;
    STDMETHOD(GetMonitorFrequency)(THIS_ LPDWORD) PURE;
    STDMETHOD(GetScanLine)(THIS_ LPDWORD) PURE;
    STDMETHOD(GetVerticalBlankStatus)(THIS_ LPBOOL ) PURE;
    STDMETHOD(Initialize)(THIS_ GUID FAR *) PURE;
    STDMETHOD(RestoreDisplayMode)(THIS) PURE;
    STDMETHOD(SetCooperativeLevel)(THIS_ HWND, DWORD) PURE;
    STDMETHOD(SetDisplayMode)(THIS_ DWORD, DWORD,DWORD, DWORD, DWORD) PURE;
    STDMETHOD(WaitForVerticalBlank)(THIS_ DWORD, HANDLE ) PURE;
    /*** Added in the v2 interface ***/
    STDMETHOD(GetAvailableVidMem)(THIS_ LPDDSCAPS, LPDWORD, LPDWORD) PURE;
    /*** IDirectDraw3 methods ***/
    STDMETHOD(GetSurfaceFromDC) (THIS_ HDC, IDirectDrawSurface **) PURE;
};

#if !defined(__cplusplus) || defined(CINTERFACE)
#define IDirectDraw3_QueryInterface(p, a, b)         (p)->lpVtbl->QueryInterface(p, a, b)
#define IDirectDraw3_AddRef(p)                       (p)->lpVtbl->AddRef(p)
#define IDirectDraw3_Release(p)                      (p)->lpVtbl->Release(p)
#define IDirectDraw3_Compact(p)                      (p)->lpVtbl->Compact(p)
#define IDirectDraw3_CreateClipper(p, a, b, c)       (p)->lpVtbl->CreateClipper(p, a, b, c)
#define IDirectDraw3_CreatePalette(p, a, b, c, d)    (p)->lpVtbl->CreatePalette(p, a, b, c, d)
#define IDirectDraw3_CreateSurface(p, a, b, c)       (p)->lpVtbl->CreateSurface(p, a, b, c)
#define IDirectDraw3_DuplicateSurface(p, a, b)       (p)->lpVtbl->DuplicateSurface(p, a, b)
#define IDirectDraw3_EnumDisplayModes(p, a, b, c, d) (p)->lpVtbl->EnumDisplayModes(p, a, b, c, d)
#define IDirectDraw3_EnumSurfaces(p, a, b, c, d)     (p)->lpVtbl->EnumSurfaces(p, a, b, c, d)
#define IDirectDraw3_FlipToGDISurface(p)             (p)->lpVtbl->FlipToGDISurface(p)
#define IDirectDraw3_GetCaps(p, a, b)                (p)->lpVtbl->GetCaps(p, a, b)
#define IDirectDraw3_GetDisplayMode(p, a)            (p)->lpVtbl->GetDisplayMode(p, a)
#define IDirectDraw3_GetFourCCCodes(p, a, b)         (p)->lpVtbl->GetFourCCCodes(p, a, b)
#define IDirectDraw3_GetGDISurface(p, a)             (p)->lpVtbl->GetGDISurface(p, a)
#define IDirectDraw3_GetMonitorFrequency(p, a)       (p)->lpVtbl->GetMonitorFrequency(p, a)
#define IDirectDraw3_GetScanLine(p, a)               (p)->lpVtbl->GetScanLine(p, a)
#define IDirectDraw3_GetVerticalBlankStatus(p, a)    (p)->lpVtbl->GetVerticalBlankStatus(p, a)
#define IDirectDraw3_Initialize(p, a)                (p)->lpVtbl->Initialize(p, a)
#define IDirectDraw3_RestoreDisplayMode(p)           (p)->lpVtbl->RestoreDisplayMode(p)
#define IDirectDraw3_SetCooperativeLevel(p, a, b)    (p)->lpVtbl->SetCooperativeLevel(p, a, b)
#define IDirectDraw3_SetDisplayMode(p, a, b, c, d, e) (p)->lpVtbl->SetDisplayMode(p, a, b, c, d, e)
#define IDirectDraw3_WaitForVerticalBlank(p, a, b)   (p)->lpVtbl->WaitForVerticalBlank(p, a, b)
#define IDirectDraw3_GetAvailableVidMem(p, a, b, c)  (p)->lpVtbl->GetAvailableVidMem(p, a, b, c)
#define IDirectDraw3_GetSurfaceFromDC(p, a, b)       (p)->lpVtbl->GetSurfaceFromDC(p, a, b)
#endif

 

/*===========================================================================
 *
 *
 * DIRECTDRAWEX RETURN CODES
 *
 * The return values from DirectDrawEx Commands and Surface that return an
 * HRESULT are codes from DirectDrawEx concerning the results of the action
 * requested by DirectDrawEx.
 *
 *==========================================================================*/

/*
 * An attempt was made to load ddraw.dll
 */
#define DDERR_LOADFAILED                        MAKE_DDHRESULT( 901 )

/*
 * Unable to determine module/os version number
 */
#define DDERR_BADVERSIONINFO                    MAKE_DDHRESULT( 902 )

/*
 * Unable to determine address of ddraw.dll exported symbol (DirectDrawCreate or
 * DirectDrawEnumerate).
 */
#define DDERR_BADPROCADDRESS                    MAKE_DDHRESULT( 903 )

/*
 * Legacy usage: do not use QI() to create D3D device objects from surface objects.  
 * Use IDirect3D2::CreateDevice()
 */
#define DDERR_LEGACYUSAGE                       MAKE_DDHRESULT( 904 )

#ifdef __cplusplus
}
#endif


#endif // __DDRAWEXH__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\ddrawex\ddfactry.h ===
/*==========================================================================
 *
 *  Copyright (C) 1997 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       ddfactry.h
 *  Content:	DirectDraw factory class header
 *		includes defns for CDDFactory, CDirectDrawEx,
 *		and CDDSurface
 *  History:
 *   Date	By	Reason
 *   ====	==	======
 *   24-feb-97	ralphl	initial implementation
 *   25-feb-97	craige	minor tweaks for dx checkin; integrated IBitmapSurface
 *			stuff
 *   03-mar-97	craige	added IRGBColorTable support
 *   06-mar-97	craige	IDirectDrawSurface3 support
 *   14-mar-97  jeffort SetBits changed to reflect DX5 as SetSurfaceDesc
 *   01-apr-97  jeffort Following changes checked in:
 *                      D3D Interface support
 *                      Linked list of surfaces real/internal interfaces kept
 *                      Complex surface/Attach list handleing
 *                      Handle for palettes added
 *                      Add/GetAttachedSurface, Flip, and Blit are aggregated
 *
 *   04-apr-97  jeffort TRIDENT ifdef's removed.
 *                      IDirectDraw3 Class implementation
 *   09-apr-97  jeffort Added #defines for version and member function for OWNDC stuff
 *   28-apr-97  jeffort Palette wrapping added/DX5 support
 *   02-may-97  jeffort Removed commented code, added GetDDInterface function wrapping
 *   06-may-97  jeffort DeleteAttachedSurface wrapping added
 *   20-may-97  jeffort Added fields in surface object for NT4.0 gold
 *   02-jul-97  jeffort Added m_bSaveDC boolean if a DX5 surface with OWNDC set
 *                      we need to not NULL out the DC when ReleaseDC is called
 *                      so that a call to GetSurfaceFromDC will work
 *   07-jul-97  jeffort Added GetSurfaceDesc internal function for wrapping
 *   10-jul-97  jeffort Added m_hBMOld to store old bitmap handle to reset at destruction
 *   18-jul-97  jeffort Added D3D MMX Device support
 *   22-jul-97  jeffort Removed IBitmapSurface and associated interfaces
 *   02-aug-97  jeffort New structure added to surface object to store attached
 *                      surfaces created with a different ddrawex object
 *   20-feb-98  stevela Added Chrome rasterizers
 ***************************************************************************/
#undef WIN32_LEAN_AND_MEAN
#define WIN32_LEAN_AND_MEAN
#include <windows.h>
#include "crtfree.h"
#include "ddraw.h"
#include "d3d.h"
#include "ddrawex.h"
#include "ddraw3i.h"
#include "comdll.h"
#ifdef INITGUID
#include <initguid.h>
#endif

/*
 * reminder
 */
#define QUOTE(x) #x
#define QQUOTE(y) QUOTE(y)
#define REMIND(str) __FILE__ "(" QQUOTE(__LINE__) "):" str

#ifndef ARRAYSIZE
#define ARRAYSIZE(x) (sizeof(x) / sizeof((x)[0]))
#endif

class CDirectDrawEx;
class CDDSurface;
class CDDPalette;

#ifndef CINTERFACE
#define IDirectDrawVtbl void
#define IDirectDraw2Vtbl void
#define IDirectDraw4Vtbl void
#define IDirectDrawSurfaceVtbl void
#define IDirectDrawSurface2Vtbl void
#define IDirectDrawSurface3Vtbl void
#define IDirectDrawPaletteVtbl void
#define IDirectDrawSurface4Vtbl void
#endif


#ifndef DIRECTDRAW_VERSION
//these are not included in DX3 include files, define them here
DEFINE_GUID( IID_IDirect3DRampDevice,   0xF2086B20,0x259F,0x11CF,0xA3,0x1A,0x00,0xAA,0x00,0xB9,0x33,0x56 );
DEFINE_GUID( IID_IDirect3DRGBDevice,    0xA4665C60,0x2673,0x11CF,0xA3,0x1A,0x00,0xAA,0x00,0xB9,0x33,0x56 );
DEFINE_GUID( IID_IDirect3DHALDevice,    0x84E63dE0,0x46AA,0x11CF,0x81,0x6F,0x00,0x00,0xC0,0x20,0x15,0x6E );
DEFINE_GUID( IID_IDirect3DMMXDevice,    0x881949a1,0xd6f3,0x11d0,0x89,0xab,0x00,0xa0,0xc9,0x05,0x41,0x29 );
DEFINE_GUID( IID_IDirect3DChrmDevice,    0x2f4d2045,0x9764,0x11d1,0x91,0xf2,0x0,0x0,0xf8,0x75,0x8e,0x66 );
#endif

#ifndef IID_IDirect3DChrmDevice
DEFINE_GUID( IID_IDirect3DChrmDevice,    0x2f4d2045,0x9764,0x11d1,0x91,0xf2,0x0,0x0,0xf8,0x75,0x8e,0x66 );
#endif


#define SURFACE_DATAEXCHANGE 0x00000001

//defines for our version information
#define WIN95_DX2   0x00000001
#define WIN95_DX3   0x00000002
#define WIN95_DX5   0x00000003
#define WINNT_DX2   0x00000004
#define WINNT_DX3   0x00000005
#define WINNT_DX5   0x00000006

extern "C" {
void WINAPI AcquireDDThreadLock(void);
void WINAPI ReleaseDDThreadLock(void);
};

#define ENTER_DDEX() AcquireDDThreadLock();
#define LEAVE_DDEX() ReleaseDDThreadLock();

/*
 * ddraw's internal interface structure
 */
typedef struct _REALDDINTSTRUC
{
    void	*lpVtbl;
    void	*pDDInternal1;
    void	*pDDInternal2;
    void	*pDDInternal3;
} REALDDINTSTRUC;

/*
 * Our version of the IDirectDraw interface internal structure
 */
typedef struct _DDINTSTRUC
{
    IDirectDrawVtbl 	*lpVtbl;
    void		*pDDInternal1;
    void		*pDDInternal2;
    void		*pDDInternal3;
    // ONLY ADD STUFF AFTER THESE 4 ENTRIES!!!
    CDirectDrawEx	*m_pDirectDrawEx;
    IDirectDraw		*m_pRealInterface;
} INTSTRUC_IDirectDraw;

/*
 * Our version of the IDirectDraw2 interface internal structure
 */
typedef struct _DD2INTSTRUC
{
    IDirectDraw2Vtbl	*lpVtbl;
    void		*pDDInternal1;
    void		*pDDInternal2;
    void		*pDDInternal3;
    // ONLY ADD STUFF AFTER THESE 4 ENTRIES!!!
    CDirectDrawEx	*m_pDirectDrawEx;
    IDirectDraw2	*m_pRealInterface;
} INTSTRUC_IDirectDraw2;

typedef struct _DD4INTSTRUC
{
    IDirectDraw4Vtbl	*lpVtbl;
    void		*pDDInternal1;
    void		*pDDInternal2;
    void		*pDDInternal3;
    // ONLY ADD STUFF AFTER THESE 4 ENTRIES!!!
    CDirectDrawEx	*m_pDirectDrawEx;
    IDirectDraw4	*m_pRealInterface;
} INTSTRUC_IDirectDraw4;



/*
 * Our version of the IDirectDrawSurface interface internal structure
 */
typedef struct _DDSURFINTSTRUC
{
    IDirectDrawSurfaceVtbl	*lpVtbl;
    void			*pDDInternal1;
    void			*pDDInternal2;
    void			*pDDInternal3;
    // ONLY ADD STUFF AFTER THESE 4 ENTRIES!!!
    CDDSurface			*m_pSimpleSurface;
    IDirectDrawSurface		*m_pRealInterface;
} INTSTRUC_IDirectDrawSurface;

/*
 * Our version of the IDirectDrawSurface2 interface internal structure
 */
typedef struct _DDSURF2INTSTRUC
{
    IDirectDrawSurface2Vtbl	*lpVtbl;
    void			*pDDInternal1;
    void			*pDDInternal2;
    void			*pDDInternal3;
    // ONLY ADD STUFF AFTER THESE 4 ENTRIES!!!
    CDDSurface			*m_pSimpleSurface;
    IDirectDrawSurface2		*m_pRealInterface;
} INTSTRUC_IDirectDrawSurface2;


/*
 * Our version of the IDirectDrawSurface3 interface internal structure
 */
typedef struct _DDSURF3INTSTRUC
{
    IDirectDrawSurface3Vtbl	*lpVtbl;
    void			*pDDInternal1;
    void			*pDDInternal2;
    void			*pDDInternal3;
    // ONLY ADD STUFF AFTER THESE 4 ENTRIES!!!
    CDDSurface			*m_pSimpleSurface;
    IDirectDrawSurface3		*m_pRealInterface;
} INTSTRUC_IDirectDrawSurface3;


typedef struct _DDSURF4INTSTRUC
{
    IDirectDrawSurface4Vtbl	*lpVtbl;
    void			*pDDInternal1;
    void			*pDDInternal2;
    void			*pDDInternal3;
    // ONLY ADD STUFF AFTER THESE 4 ENTRIES!!!
    CDDSurface			*m_pSimpleSurface;
    IDirectDrawSurface4		*m_pRealInterface;
} INTSTRUC_IDirectDrawSurface4;



/*
 * Our version of IDirectDrawPalette interface internal structure
 */

typedef struct _DDPALINTSTRUC
{
    IDirectDrawPaletteVtbl      *lpVtbl;
    void			*pDDInternal1;
    void			*pDDInternal2;
    void			*pDDInternal3;
    CDDPalette                  *m_pSimplePalette;
    IDirectDrawPalette          *m_pRealInterface;
} INTSTRUC_IDirectDrawPalette;


typedef struct tagDDAttachSurface
{
    CDDSurface *     pSurface;
    struct tagDDAttachSurface  *     pNext;
}DDAttachSurface;



/*
 * Non Delegating IUnknown interface
 */
interface INonDelegatingUnknown
{
    virtual STDMETHODIMP NonDelegatingQueryInterface(REFIID riid, void **ppv) = 0;
    virtual STDMETHODIMP_(ULONG) NonDelegatingAddRef(void) = 0;
    virtual STDMETHODIMP_(ULONG) NonDelegatingRelease(void) = 0;
};


#pragma warning (disable:4355)
#define CAST_TO_IUNKNOWN(object) (reinterpret_cast<IUnknown *>(static_cast<INonDelegatingUnknown *>(object)))

typedef HRESULT (WINAPI *LPDIRECTDRAWCREATE)( GUID FAR *lpGUID, LPDIRECTDRAW FAR *lplpDD, IUnknown FAR *pUnkOuter );
typedef HRESULT (WINAPI *LPDIRECTDRAWENUMW)( LPDDENUMCALLBACKW lpCallback, LPVOID lpContext );
typedef HRESULT (WINAPI *LPDIRECTDRAWENUMA)( LPDDENUMCALLBACKA lpCallback, LPVOID lpContext );

/*
 * DDFactor class definition
 */
class CDDFactory : public INonDelegatingUnknown, public IDirectDrawFactory
{
public:
    // Non-Delegating versions of IUnknown
    STDMETHODIMP NonDelegatingQueryInterface(REFIID riid, void **ppv);
    STDMETHODIMP_(ULONG) NonDelegatingAddRef(void);
    STDMETHODIMP_(ULONG) NonDelegatingRelease(void);

    // IUnknown
    STDMETHODIMP QueryInterface(REFIID riid, void **ppv);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

    // IDirectDrawFactory
    STDMETHODIMP CreateDirectDraw(GUID * pGUID, HWND hWnd, DWORD dwCoopLevelFlags, DWORD dwReserved, IUnknown *pUnkOuter, IDirectDraw **ppDirectDraw);
    STDMETHODIMP DirectDrawEnumerate(LPDDENUMCALLBACK lpCallback, LPVOID lpContext);

    CDDFactory(IUnknown *pUnkOuter);
    
public:
    LONG		m_cRef;
    IUnknown		*m_pUnkOuter;
    HANDLE		m_hDDrawDLL;
    DWORD		m_dwDDVerMS;
    LPDIRECTDRAWCREATE	m_pDirectDrawCreate;
    LPDIRECTDRAWENUMW	m_pDirectDrawEnumerateW;
    LPDIRECTDRAWENUMA	m_pDirectDrawEnumerateA;
};

/*
 * DirectDrawEx class definition
 */
 
class CDirectDrawEx : public INonDelegatingUnknown, public IDirectDraw3
{
public:
    // Non-Delegating versions of IUnknown
    STDMETHODIMP NonDelegatingQueryInterface(REFIID riid, void **ppv);
    STDMETHODIMP_(ULONG) NonDelegatingAddRef(void);
    STDMETHODIMP_(ULONG) NonDelegatingRelease(void);

    // IUnknown
    STDMETHODIMP QueryInterface(REFIID riid, void **ppv);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

 
    // IDirectDraw3
    STDMETHODIMP Compact();
    STDMETHODIMP CreateClipper(DWORD, LPDIRECTDRAWCLIPPER FAR*, IUnknown FAR * );
    STDMETHODIMP DuplicateSurface(LPDIRECTDRAWSURFACE, LPDIRECTDRAWSURFACE FAR * );
    STDMETHODIMP EnumDisplayModes(DWORD, LPDDSURFACEDESC, LPVOID, LPDDENUMMODESCALLBACK );
    STDMETHODIMP EnumSurfaces(DWORD, LPDDSURFACEDESC, LPVOID,LPDDENUMSURFACESCALLBACK );
    STDMETHODIMP FlipToGDISurface();
    STDMETHODIMP GetCaps(LPDDCAPS, LPDDCAPS);
    STDMETHODIMP GetDisplayMode(LPDDSURFACEDESC);
    STDMETHODIMP GetFourCCCodes(LPDWORD, LPDWORD );
    STDMETHODIMP GetGDISurface(LPDIRECTDRAWSURFACE FAR *);
    STDMETHODIMP GetMonitorFrequency(LPDWORD);
    STDMETHODIMP GetScanLine(LPDWORD);
    STDMETHODIMP GetVerticalBlankStatus(LPBOOL );
    STDMETHODIMP Initialize(GUID FAR *);
    STDMETHODIMP RestoreDisplayMode();
    STDMETHODIMP SetDisplayMode(DWORD, DWORD,DWORD, DWORD, DWORD);
    STDMETHODIMP WaitForVerticalBlank(DWORD, HANDLE );
    STDMETHODIMP GetAvailableVidMem(LPDDSCAPS, LPDWORD, LPDWORD);
    STDMETHODIMP GetSurfaceFromDC(HDC, IDirectDrawSurface **);      

    
    // Internal goop
    CDirectDrawEx(IUnknown *pUnkOuter);
    ~CDirectDrawEx();
    HRESULT Init(GUID * pGUID, HWND hWnd, DWORD dwCoopLevelFlags, DWORD dwReserved, LPDIRECTDRAWCREATE pDirectDrawCreate );
    STDMETHODIMP CreateSurface(LPDDSURFACEDESC pSurfaceDesc, IDirectDrawSurface **ppNewSurface, IUnknown *pUnkOuter);
    STDMETHODIMP CreateSurface(LPDDSURFACEDESC2 pSurfaceDesc, IDirectDrawSurface4 **ppNewSurface4, IUnknown *pUnkOuter);
    STDMETHODIMP CreatePalette(DWORD dwFlags, LPPALETTEENTRY pEntries, LPDIRECTDRAWPALETTE FAR * ppPal, IUnknown FAR * pUnkOuter);
    STDMETHODIMP SetCooperativeLevel(HWND hwnd, DWORD dwFlags);


    void AddSurfaceToList(CDDSurface *pSurface);
    void RemoveSurfaceFromList(CDDSurface *pSurface);
    void AddSurfaceToPrimaryList(CDDSurface *pSurface);
    void RemoveSurfaceFromPrimaryList(CDDSurface *pSurface);
    void AddPaletteToList(CDDPalette *pPalette);
    void RemovePaletteFromList(CDDPalette *pPalette);
    HRESULT HandleAttachList(LPDDSURFACEDESC pSurfaceDesc, IUnknown *pUnkOuter,IDirectDrawSurface **ppNewSurface, IDirectDrawSurface * pOrigSurf, DWORD dwFlags); 
    HRESULT CreateSimpleSurface(LPDDSURFACEDESC pSurfaceDesc, IUnknown *pUnkOuter, IDirectDrawSurface * pSurface, IDirectDrawSurface **ppNewSurface, DWORD dwFlags);
public:
    INTSTRUC_IDirectDraw	m_DDInt;
    INTSTRUC_IDirectDraw2 	m_DD2Int;
    INTSTRUC_IDirectDraw4       m_DD4Int;

    LONG			        m_cRef;
    IUnknown			    *m_pUnkOuter;
    CDDSurface			    *m_pFirstSurface;       // list of surfaces (NOT ADDREF'd!)
    CDDSurface              *m_pPrimaryPaletteList;
    CDDPalette              *m_pFirstPalette;
    BOOL                    m_bExclusive;
    DWORD			        m_dwDDVer;
};


/*
 * DirectDraw simple surface class definition
 */
 
class CDDSurface : public INonDelegatingUnknown
{
friend CDirectDrawEx;

public:
    CDDSurface				*m_pPrev;               // Used by DirectDrawEx to insert in list
    CDDSurface				*m_pNext;
    CDDSurface                          *m_pPrevPalette;
    CDDSurface                          *m_pNextPalette;
    CDDSurface                          *m_pDestroyList;
    CDDPalette                          *m_pCurrentPalette;
    IUnknown				*m_pUnkOuter;
    //this member will be a linked list of explicitly attached surfaces
    //that were not created with the same ddrawex object that this surface
    //was created with
    DDAttachSurface                     *m_pAttach;
    LONG				m_cRef;
    CDirectDrawEx			*m_pDirectDrawEx;
    INTSTRUC_IDirectDrawSurface		m_DDSInt;
    INTSTRUC_IDirectDrawSurface2	m_DDS2Int;
    INTSTRUC_IDirectDrawSurface3	m_DDS3Int;
    INTSTRUC_IDirectDrawSurface4        m_DDS4Int;
    IDirect3DDevice *                   m_D3DDeviceRAMPInt;
    IDirect3DDevice *                   m_D3DDeviceHALInt;
    IDirect3DDevice *                   m_D3DDeviceRGBInt;
    IDirect3DDevice *                   m_D3DDeviceChrmInt;
    IDirect3DDevice *                   m_D3DDeviceMMXInt;
    IDirect3DTexture *                  m_D3DTextureInt;                         
    HDC					m_HDC;
    DWORD				m_dwCaps;
    HDC					m_hDCDib;
    HBITMAP				m_hBMDib;
    HBITMAP                             m_hBMOld;
    LPVOID				m_pBitsDib;
    IDirectDrawPalette		        *m_pDDPal;
    IDirectDrawPalette		        *m_pDDPalOurs;
    WORD				m_dwPalSize;
    WORD				m_dwPalEntries;
    BOOL				m_bOwnDC; //boolean set if we are spoofing ddraw to support owndc
    BOOL                                m_bSaveDC;//boolean to store if DX5 and OWNDC set
    BOOL                                m_bPrimaryPalette;
    BOOL                                m_bIsPrimary;
    ULONG_PTR                           m_pSaveBits;
    DWORD                               m_pSaveHDC;
#ifdef DEBUG
    DWORD                               m_DebugCheckDC;
#endif
    DWORD                               m_pSaveHBM;

public:
    CDDSurface(	DDSURFACEDESC *pSurfaceDesc,
		IDirectDrawSurface *pDDSurface,
		IDirectDrawSurface2 *pDDSurface2,
		IDirectDrawSurface3 *pDDSurface3,
		IDirectDrawSurface4 *pDDSurface4,
		IUnknown *pUnkOuter, CDirectDrawEx *pDirectDrawEx);
    ~CDDSurface();
    HRESULT Init();
    HRESULT MakeDIBSection();
    HRESULT MakeDibInfo( LPDDSURFACEDESC pddsd, LPBITMAPINFO pbmi );
    HRESULT SupportOwnDC();
    static HRESULT CreateSimpleSurface(
    			LPDDSURFACEDESC pSurfaceDesc,
			IDirectDrawSurface *pSurface,
		        IDirectDrawSurface2 *pSurface2,
		        IDirectDrawSurface3 *pSurface3,
                        IDirectDrawSurface4 *pSurface4,
			IUnknown *pUnkOuter,
			CDirectDrawEx *pDirectDrawEx,
			IDirectDrawSurface **ppNewDDSurf,
                        DWORD dwFlags);
    HRESULT InternalGetDC(HDC *);
    HRESULT InternalReleaseDC(HDC);
    HRESULT InternalLock(LPRECT lpDestRect, LPDDSURFACEDESC lpDDSurfaceDesc, DWORD dwFlags, HANDLE hEvent);
    HRESULT InternalUnlock(LPVOID lpSurfaceData);
    HRESULT InternalSetSurfaceDesc(LPDDSURFACEDESC pddsd, DWORD dwFlags);
    HRESULT InternalGetAttachedSurface(LPDDSCAPS lpDDSCaps, LPDIRECTDRAWSURFACE FAR * lpDDS, DWORD dwSurfaceType);
    HRESULT InternalGetAttachedSurface4(LPDDSCAPS2 lpDDSCaps, LPDIRECTDRAWSURFACE FAR * lpDDS);
    HRESULT InternalAddAttachedSurface(LPDIRECTDRAWSURFACE lpDDS, DWORD dwSurfaceType);
    HRESULT InternalDeleteAttachedSurface(DWORD dwFlags, LPDIRECTDRAWSURFACE lpDDS, DWORD dwSurfaceType);
    HRESULT InternalFlip(LPDIRECTDRAWSURFACE lpDDS, DWORD dw, DWORD dwSurfaceType);
    HRESULT InternalBlt(LPRECT lpRect1,LPDIRECTDRAWSURFACE lpDDS, LPRECT lpRect2,DWORD dw, LPDDBLTFX lpfx, DWORD dwSurfaceType);
    HRESULT InternalGetPalette(LPDIRECTDRAWPALETTE FAR * ppPal, DWORD dwSurfaceType);
    HRESULT InternalSetPalette(LPDIRECTDRAWPALETTE pPal, DWORD dwSurfaceType);
    HRESULT InternalGetDDInterface(LPVOID FAR * ppInt);
    HRESULT InternalGetSurfaceDesc(LPDDSURFACEDESC pDesc, DWORD dwSurfaceType);
    HRESULT InternalGetSurfaceDesc4(LPDDSURFACEDESC2 pDesc);
    HRESULT CheckDDPalette();
    void DeleteAttachment(IDirectDrawSurface * pOrigSurf, CDDSurface * pFirst);
    void CleanUpSurface();
    void ReleaseRealInterfaces();
    void AddSurfaceToDestroyList(CDDSurface *pSurface);
    void DeleteAttachNode(CDDSurface * Surface);



    // Non-Delegating versions of IUnknown
    STDMETHODIMP NonDelegatingQueryInterface(REFIID riid, void **ppv);
    STDMETHODIMP_(ULONG) NonDelegatingAddRef(void);
    STDMETHODIMP_(ULONG) NonDelegatingRelease(void);

    // IUnknown
    STDMETHODIMP QueryInterface(REFIID riid, void **ppv);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

};


class CDDPalette : public INonDelegatingUnknown
{
friend CDirectDrawEx;
friend CDDSurface;

public:
    CDDPalette				*m_pPrev;               // Used by DirectDrawEx to insert in list
    CDDPalette				*m_pNext;
    CDDSurface                          *m_pFirstSurface;
    IUnknown				*m_pUnkOuter;
    INTSTRUC_IDirectDrawPalette		m_DDPInt;
    LONG				m_cRef;
    CDirectDrawEx			*m_pDirectDrawEx;
    BOOL                                m_bIsPrimary;

    CDDPalette( IDirectDrawPalette * pDDPalette,IUnknown *pUnkOuter,CDirectDrawEx *pDirectDrawEx);
    ~CDDPalette();
    static HRESULT CreateSimplePalette(LPPALETTEENTRY pEntries, 
                                       IDirectDrawPalette *pDDPalette, 
                                       LPDIRECTDRAWPALETTE FAR * ppPal, 
                                       IUnknown FAR * pUnkOuter, 
                                       CDirectDrawEx *pDirectDrawEx);
    HRESULT SetColorTable (CDDSurface * pSurface, LPPALETTEENTRY pEntries, DWORD dwNumEntries, DWORD dwBase);
    void AddSurfaceToList(CDDSurface *pSurface);
    void RemoveSurfaceFromList(CDDSurface *pSurface);
    STDMETHODIMP InternalSetEntries(DWORD dwFlags, DWORD dwBase, DWORD dwNumEntries, LPPALETTEENTRY lpe); 
    // Non-Delegating versions of IUnknown
    STDMETHODIMP NonDelegatingQueryInterface(REFIID riid, void **ppv);
    STDMETHODIMP_(ULONG) NonDelegatingAddRef(void);
    STDMETHODIMP_(ULONG) NonDelegatingRelease(void);

    // IUnknown
    STDMETHODIMP QueryInterface(REFIID riid, void **ppv);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);
};

/*
 * File name of the Direct3D DLL.
 */
#define D3D_DLLNAME               "D3DIM.DLL"

/*
 * Entry points exported by the Direct3D DLL.
 */
#define D3DCREATE_PROCNAME        "Direct3DCreate"
#define D3DCREATEDEVICE_PROCNAME  "Direct3DCreateDevice"
#define D3DCREATETEXTURE_PROCNAME "Direct3DCreateTexture"


#ifdef USE_D3D_CSECT
    typedef HRESULT (WINAPI * D3DCreateProc)(LPUNKNOWN*         lplpD3D,
					     IUnknown*          pUnkOuter);
#else  /* USE_D3D_CSECT */
    typedef HRESULT (WINAPI * D3DCreateProc)(LPCRITICAL_SECTION lpDDCSect,
					     LPUNKNOWN*         lplpD3D,
					     IUnknown*          pUnkOuter);
#endif /* USE_D3D_CSECT */

typedef HRESULT (WINAPI * D3DCreateTextProc)(REFIID              riid,
                                             LPDIRECTDRAWSURFACE lpDDS,
					     LPUNKNOWN*          lplpD3DText,
					     IUnknown*           pUnkOuter);
typedef HRESULT (WINAPI * D3DCreateDeviceProc)(REFIID              riid,
                                               LPUNKNOWN           lpDirect3D,
                                               LPDIRECTDRAWSURFACE lpDDS,
                                               LPUNKNOWN*          lplpD3DDevice,
                                               IUnknown*           pUnkOuter);

/*
 * some helper functions...
 */

void __stdcall InitDirectDrawInterfaces(IDirectDraw *pDD, INTSTRUC_IDirectDraw *pDDInt, 
                                        IDirectDraw2  *pDD2, INTSTRUC_IDirectDraw2 *pDD2Int,
                                        IDirectDraw4  *pDD4, INTSTRUC_IDirectDraw4 *pDD4Int);
void __stdcall InitSurfaceInterfaces(IDirectDrawSurface *pDDSurface,
	                             INTSTRUC_IDirectDrawSurface *pDDSInt,
                               	     IDirectDrawSurface2 *pDDSurface2,
                            	     INTSTRUC_IDirectDrawSurface2 *pDDS2Int,
                		     IDirectDrawSurface3 *pDDSurface3,
		                     INTSTRUC_IDirectDrawSurface3 *pDDS3Int,
                		     IDirectDrawSurface4 *pDDSurface4,
		                     INTSTRUC_IDirectDrawSurface4 *pDDS4Int );
                                   
void __stdcall InitDirectDrawPaletteInterfaces(IDirectDrawPalette *pDDPalette, 
                                               INTSTRUC_IDirectDrawPalette *pDDInt);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\ddrawex\factory.cpp ===
/*==========================================================================
 *
 *  Copyright (C) 1997 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       factory.cpp
 *  Content:	DirectDraw Factory support
 *  History:
 *   Date	By	Reason
 *   ====	==	======
 *   24-feb-97	ralphl	initial implementation
 *   25-feb-97	craige	minor tweaks for dx checkin
 *   14-mar-97  jeffort version checking changed to support DX3 and above
 *   09-apr-97  jeffort version checking added for DX2 and NT
 *   30-apr-97  jeffort version >DX5 treated as DX5
 *   10-jul-97  jeffort made OSVersion a static variable
 *   09-sep-97  mikear  QI for IUnknown when aggregating
 ***************************************************************************/
#include "ddfactry.h"

//#defines for registry lookup
#define REGSTR_PATH_DDRAW 		"Software\\Microsoft\\DirectDraw"
#define	REGSTR_VAL_DDRAW_OWNDC  	"OWNDC"



CDDFactory::CDDFactory(IUnknown *pUnkOuter) :
    m_cRef(1),
    m_pUnkOuter(pUnkOuter != 0 ? pUnkOuter : CAST_TO_IUNKNOWN(this))
{
    m_hDDrawDLL = NULL;
    DllAddRef();
}


STDAPI DirectDrawFactory_CreateInstance(
				IUnknown * pUnkOuter,
				REFIID riid,
				void ** ppv)
{
    HRESULT hr;
    CDDFactory *pFactory = new CDDFactory(pUnkOuter);

    if( !pFactory )
    {
        hr = E_OUTOFMEMORY;
    }
    else
    {
        hr = pFactory->NonDelegatingQueryInterface(pUnkOuter ? IID_IUnknown : riid, ppv);
        pFactory->NonDelegatingRelease();
    }
    return hr;
}


STDMETHODIMP CDDFactory::NonDelegatingQueryInterface(REFIID riid, void ** ppv)
{
    *ppv=NULL;


    if (IID_IUnknown==riid)
    {
	*ppv=(INonDelegatingUnknown *)this;
    }
    else
    {
	if (IID_IDirectDrawFactory==riid)
	{
            *ppv=(IDirectDrawFactory *)this;
	}
	else
	{
	    return E_NOINTERFACE;
        }
    }

    ((LPUNKNOWN)*ppv)->AddRef();
    return NOERROR;
}


STDMETHODIMP_(ULONG) CDDFactory::NonDelegatingAddRef()
{
    return InterlockedIncrement(&m_cRef);
}


STDMETHODIMP_(ULONG) CDDFactory::NonDelegatingRelease()
{
    LONG lRefCount = InterlockedDecrement(&m_cRef);
    if( lRefCount )
    {
	return lRefCount;
    }
    delete this;
    DllRelease();
    return 0;
}


// Standard IUnknown
STDMETHODIMP CDDFactory::QueryInterface(REFIID riid, void ** ppv)
{
    return m_pUnkOuter->QueryInterface(riid, ppv);
}

STDMETHODIMP_(ULONG) CDDFactory::AddRef(void)
{
    return m_pUnkOuter->AddRef();
}

STDMETHODIMP_(ULONG) CDDFactory::Release(void)
{
    return m_pUnkOuter->Release();
}

/*
 * CDDFactory::CreateDirectDraw
 */
STDMETHODIMP CDDFactory::CreateDirectDraw(
				GUID * pGUID,
				HWND hWnd,
				DWORD dwCoopLevelFlags,
				DWORD dwReserved,
				IUnknown *pUnkOuter,
				IDirectDraw **ppDirectDraw )
{
    static OSVERSIONINFO osVer;
    CDirectDrawEx *pDirectDrawEx;
    HRESULT	hr = S_OK;
    BOOL fDDrawDllVerFound = FALSE;

    *ppDirectDraw = NULL;
    /*
     * first, see if we can get at DirectDraw or not!
     */
    if( m_hDDrawDLL == NULL )
    {
 		char		path[_MAX_PATH];
        char        DllName[25];
        DWORD       dwRet;

	//	m_hDDrawDLL = LoadLibrary( "ddraw.dll" );
        dwRet = GetProfileString("ddrawex","realdll","ddraw.dll",DllName,25);
        if( dwRet == 0 )
        {
            return DDERR_GENERIC;
        }
		m_hDDrawDLL = LoadLibrary( DllName );
		if( m_hDDrawDLL == NULL )
        {
            return DDERR_LOADFAILED;
        }

		/*
		 * get ddraw.dll version number
		 */
		if( GetModuleFileName( (HINSTANCE)m_hDDrawDLL, path, sizeof( path ) ) )
		{
			int		size;
			DWORD	tmp;
			size = (int) GetFileVersionInfoSize( path, (LPDWORD) &tmp );
			if( size != 0 )
			{
				LPVOID	vinfo;
    
				vinfo = (LPVOID) LocalAlloc( LPTR, size );
                if(vinfo == NULL)
                {
                    hr = DDERR_OUTOFMEMORY;
                    goto CleanUp;
                }

				if( GetFileVersionInfo( path, 0, size, vinfo ) )
				{
					VS_FIXEDFILEINFO *ver=NULL;
					UINT cb;

					if( VerQueryValue(vinfo, "\\", (LPVOID *)&ver, &cb) )
					{
						if( ver != NULL )
						{
							/*
							 * we only need the most significant dword,
							 * the LS dword contains the build number only...
							 * Hack: The '|5' forces recognition of DX6+ 
							 */
							m_dwDDVerMS = ver->dwFileVersionMS | 5;
                            fDDrawDllVerFound = TRUE;
						}
					}
				}
				LocalFree( vinfo );
			}
		}

        osVer.dwOSVersionInfoSize = sizeof (OSVERSIONINFO);
        if ( !fDDrawDllVerFound || !GetVersionEx(&osVer) )
        {
            hr = DDERR_BADVERSIONINFO;
            goto CleanUp;
        }

        //if we are on NT4.0 Gold, the DLL version will be 4.00
        if (osVer.dwPlatformId == VER_PLATFORM_WIN32_NT && LOWORD( m_dwDDVerMS) == 0) 
        {
            //boost the LOWORD up so we will not fail the next check below
            m_dwDDVerMS += 3;
        }

		/*
		 * don't work on anything but  DX2 DX 3 or DX 5.
		 */
		if( !((HIWORD( m_dwDDVerMS ) >= 4) && (LOWORD( m_dwDDVerMS) >= 3)) )
		{
            hr = DDERR_UNSUPPORTED;
            goto CleanUp;
		}

		if( LOWORD( m_dwDDVerMS) > 5)
		{
			//we will assume that any version >= DX5 will support what we need, so we
			//will mark anything greater than 5 as DX5
			m_dwDDVerMS = 5;
		}

		/*
		 * get the various entry points we need
		 */
		m_pDirectDrawCreate = (LPDIRECTDRAWCREATE) GetProcAddress((HINSTANCE) m_hDDrawDLL, "DirectDrawCreate" );
		if( m_pDirectDrawCreate == NULL )
		{
            hr = DDERR_BADPROCADDRESS;
            goto CleanUp;
		}

		m_pDirectDrawEnumerateW = (LPDIRECTDRAWENUMW) GetProcAddress( (HINSTANCE)m_hDDrawDLL, "DirectDrawEnumerateW" );
		if( m_pDirectDrawEnumerateW == NULL )
		{
            hr = DDERR_BADPROCADDRESS;
            goto CleanUp;
		}

		m_pDirectDrawEnumerateA = (LPDIRECTDRAWENUMA) GetProcAddress((HINSTANCE) m_hDDrawDLL, "DirectDrawEnumerateA" );
		if( m_pDirectDrawEnumerateA == NULL )
		{
            hr = DDERR_BADPROCADDRESS;
            goto CleanUp;
        }

    } // m_hDDrawDLL = NULL

    /*
     * create and initialize the ddrawex object
     */
    pDirectDrawEx = new CDirectDrawEx(pUnkOuter);
    if( !pDirectDrawEx )
    {
        hr = DDERR_OUTOFMEMORY;
        goto CleanUp;
    }
    else
    {
        hr = pDirectDrawEx->Init( pGUID, hWnd, dwCoopLevelFlags, dwReserved, m_pDirectDrawCreate );

        if( SUCCEEDED(hr) )
        {
            hr = pDirectDrawEx->NonDelegatingQueryInterface(IID_IDirectDraw, (void **)ppDirectDraw);
            /*
             * save the ddraw version number...
             */
            if (osVer.dwPlatformId == VER_PLATFORM_WIN32_NT)
            {
    	        if( LOWORD( m_dwDDVerMS ) == 5 )
    	        {
    	            DWORD	type;
                    DWORD	value;
					DWORD	cb;
                    HKEY	hkey;

                    //DX5 is busted with OwnDC for StretchBlt
                    //check a registry key to see if we are
                    //using dx5 style or dx3 style.
                    //default is dx3
                    pDirectDrawEx->m_dwDDVer = WINNT_DX5;

                    if( ERROR_SUCCESS == RegOpenKey( HKEY_LOCAL_MACHINE, REGSTR_PATH_DDRAW, &hkey ) )
                    {
    	                cb = sizeof( value );
            	        if( ERROR_SUCCESS == RegQueryValueEx( hkey, REGSTR_VAL_DDRAW_OWNDC, NULL, &type, (CONST LPBYTE)&value, &cb ) )
                        {
                            pDirectDrawEx->m_dwDDVer = WINNT_DX5;
                        }
                        RegCloseKey(hkey);
                    }
                }
                else if (LOWORD (m_dwDDVerMS) == 4 )
                {
                    pDirectDrawEx->m_dwDDVer = WINNT_DX3;
                }
                else if (LOWORD (m_dwDDVerMS) == 3 )
                {
                    pDirectDrawEx->m_dwDDVer = WINNT_DX2;
                }
                //should never get here, alread checked above, but be conservative
                else
                {
                    hr = DDERR_UNSUPPORTED;
                    goto CleanUp;
                }
            }
            else
            {
    	        if( LOWORD( m_dwDDVerMS ) == 5 )
    	        {
                    pDirectDrawEx->m_dwDDVer = WIN95_DX5;
        	}
                else if (LOWORD (m_dwDDVerMS) == 4 )
                {
                    pDirectDrawEx->m_dwDDVer = WIN95_DX3;
                }
                else if (LOWORD (m_dwDDVerMS) == 3 )
                {
                    pDirectDrawEx->m_dwDDVer = WIN95_DX2;
                }
                //should never get here, alread checked above, but be conservative
                else
                {
                    hr = DDERR_UNSUPPORTED;
                    goto CleanUp;
                }
            }
        }
        pDirectDrawEx->NonDelegatingRelease();
    }

CleanUp:

    if( hr != S_OK && m_hDDrawDLL != NULL )
    {
        FreeLibrary((HINSTANCE) m_hDDrawDLL );
        m_hDDrawDLL = NULL;
    }

    return hr;
} /* CDDFactory::CreateDirectDraw */

/*
 * CDDFactory::DirectDrawEnumerate
 *
 * implements ddraw enumerate.
 */
STDMETHODIMP CDDFactory::DirectDrawEnumerate(LPDDENUMCALLBACK lpCallback, LPVOID lpContext)
{
    #pragma message( REMIND( "DDFactory::DirectDrawEnumerate assumes ANSI" ))
    return m_pDirectDrawEnumerateA(lpCallback, lpContext);

} /* CDDFactory::DirectDrawEnumerate */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\ddrawex\comdll.c ===
#include <windows.h>
#include "comdll.h"
#include "ddraw.h"
#include "ddrawex.h"




UINT g_cRefDll = 0;     // reference count for this DLL
HANDLE g_hinst = NULL;  // HMODULE for this DLL



typedef struct {
    const IClassFactoryVtbl *cf;
    const CLSID *pclsid;
    HRESULT (STDMETHODCALLTYPE *pfnCreate)(IUnknown *, REFIID, void **);
    HRESULT (STDMETHODCALLTYPE *pfnRegUnReg)(BOOL bReg, HKEY hkCLSID, LPCSTR pszCLSID, LPCSTR pszModule);
} OBJ_ENTRY;

extern const IClassFactoryVtbl c_CFVtbl;        // forward

//
// we always do a linear search here so put your most often used things first
//
const OBJ_ENTRY c_clsmap[] = {
    {&c_CFVtbl, &CLSID_DirectDrawFactory, DirectDrawFactory_CreateInstance, NULL},
    // add more entries here
    { NULL, NULL, NULL, NULL }
};

// static class factory (no allocs!)

STDMETHODIMP CClassFactory_QueryInterface(IClassFactory *pcf, REFIID riid, void **ppvObj)
{
    if (IsEqualIID(riid, &IID_IClassFactory) || IsEqualIID(riid, &IID_IUnknown))
    {
        *ppvObj = (void *)pcf;
    }
    else
    {
        *ppvObj = NULL;
        return E_NOINTERFACE;
    }
    DllAddRef();
    return NOERROR;
}

STDMETHODIMP_(ULONG) CClassFactory_AddRef(IClassFactory *pcf)
{
    DllAddRef();
    return 2;
}

STDMETHODIMP_(ULONG) CClassFactory_Release(IClassFactory *pcf)
{
    DllRelease();
    return 1;
}

STDMETHODIMP CClassFactory_CreateInstance(IClassFactory *pcf, IUnknown *punkOuter, REFIID riid, void **ppvObject)
{
    OBJ_ENTRY *this = IToClass(OBJ_ENTRY, cf, pcf);
    return this->pfnCreate(punkOuter, riid, ppvObject);
}

STDMETHODIMP CClassFactory_LockServer(IClassFactory *pcf, BOOL fLock)
{
    if (fLock)
        DllAddRef();
    else
        DllRelease();
    return S_OK;
}

const IClassFactoryVtbl c_CFVtbl = {
    CClassFactory_QueryInterface, CClassFactory_AddRef, CClassFactory_Release,
    CClassFactory_CreateInstance,
    CClassFactory_LockServer
};

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, void **ppv)
{
    if (IsEqualIID(riid, &IID_IClassFactory) || IsEqualIID(riid, &IID_IUnknown))
    {
        const OBJ_ENTRY *pcls;
        for (pcls = c_clsmap; pcls->pclsid; pcls++)
        {
            if (IsEqualIID(rclsid, pcls->pclsid))
            {
                *ppv = (void *)&(pcls->cf);
                DllAddRef();    // Class Factory keeps dll in memory
                return NOERROR;
            }
        }
    }
    // failure
    *ppv = NULL;
    return CLASS_E_CLASSNOTAVAILABLE;;
}

STDAPI_(void) DllAddRef()
{
    InterlockedIncrement(&g_cRefDll);
}

STDAPI_(void) DllRelease()
{
    InterlockedDecrement(&g_cRefDll);
}

STDAPI DllCanUnloadNow(void)
{
    return g_cRefDll == 0 ? S_OK : S_FALSE;
}

STDAPI_(BOOL) DllEntryPoint(HANDLE hDll, DWORD dwReason, LPVOID lpReserved)
{
    if (dwReason == DLL_PROCESS_ATTACH)
    {
        g_hinst = hDll;
        DisableThreadLibraryCalls(hDll);
    }

    return TRUE;
}

STDAPI_(void) TStringFromGUID(const GUID* pguid, LPTSTR pszBuf)
{
    wsprintf(pszBuf, TEXT("{%08lX-%04X-%04X-%02X%02X-%02X%02X%02X%02X%02X%02X}"), pguid->Data1,
            pguid->Data2, pguid->Data3, pguid->Data4[0], pguid->Data4[1], pguid->Data4[2],
            pguid->Data4[3], pguid->Data4[4], pguid->Data4[5], pguid->Data4[6], pguid->Data4[7]);
}

#ifndef UNICODE
STDAPI_(void) WStringFromGUID(const GUID* pguid, LPWSTR pszBuf)
{
    char szAnsi[40];
    TStringFromGUID(pguid, szAnsi);
    MultiByteToWideChar(CP_ACP, 0, szAnsi, -1, pszBuf, sizeof(szAnsi));
}
#endif


BOOL DeleteKeyAndSubKeys(HKEY hkIn, LPCTSTR pszSubKey)
{
    HKEY  hk;
    TCHAR szTmp[MAX_PATH];
    DWORD dwTmpSize;
    long  l;
    BOOL  f;

    l = RegOpenKeyEx(hkIn, pszSubKey, 0, KEY_ALL_ACCESS, &hk);
    if (l != ERROR_SUCCESS)
        return FALSE;

    // loop through all subkeys, blowing them away.
    //
    f = TRUE;
    while (f) {
        dwTmpSize = MAX_PATH;
        l = RegEnumKeyEx(hk, 0, szTmp, &dwTmpSize, 0, NULL, NULL, NULL);
        if (l != ERROR_SUCCESS)
            break;
        f = DeleteKeyAndSubKeys(hk, szTmp);
    }

    // there are no subkeys left, [or we'll just generate an error and return FALSE].
    // let's go blow this dude away.
    //
    RegCloseKey(hk);
    l = RegDeleteKey(hkIn, pszSubKey);

    return (l == ERROR_SUCCESS) ? TRUE : FALSE;
}

#define INPROCSERVER32  TEXT("InProcServer32")
#define CLSID           TEXT("CLSID")
#define THREADINGMODEL  TEXT("ThreadingModel")
#define TMBOTH          TEXT("Both")

STDAPI DllRegisterServer(void)
{
    const OBJ_ENTRY *pcls;
    TCHAR szPath[MAX_PATH];

    GetModuleFileName(g_hinst, szPath, ARRAYSIZE(szPath));  // get path to this DLL

    for (pcls = c_clsmap; pcls->pclsid; pcls++)
    {
        HKEY hkCLSID;
        if (RegOpenKey(HKEY_CLASSES_ROOT, CLSID, &hkCLSID) == ERROR_SUCCESS)
        {
            HKEY hkOurs;
            LONG err;
            TCHAR szGUID[80];

            TStringFromGUID(pcls->pclsid, szGUID);

            err = RegCreateKey(hkCLSID, szGUID, &hkOurs);
            if (err == ERROR_SUCCESS)
            {
                HKEY hkInproc;
                err = RegCreateKey(hkOurs, INPROCSERVER32, &hkInproc);
                if (err == ERROR_SUCCESS)
                {
                    err = RegSetValueEx(hkInproc, NULL, 0, REG_SZ, (LPBYTE)szPath, (lstrlen(szPath) + 1) * sizeof(TCHAR));
                    if (err == ERROR_SUCCESS)
                    {
                        err = RegSetValueEx(hkInproc, THREADINGMODEL, 0, REG_SZ, (LPBYTE)TMBOTH, sizeof(TMBOTH));
                    }
                    RegCloseKey(hkInproc);
                }

                if (pcls->pfnRegUnReg)
                    pcls->pfnRegUnReg(TRUE, hkOurs, szGUID, szPath);

                RegCloseKey(hkOurs);
            }
            RegCloseKey(hkCLSID);

            if (err != ERROR_SUCCESS)
                return HRESULT_FROM_WIN32(err);
        }
    }
    return S_OK;
}

STDAPI DllUnregisterServer(void)
{
    const OBJ_ENTRY *pcls;
    for (pcls = c_clsmap; pcls->pclsid; pcls++)
    {
        HKEY hkCLSID;
        if (RegOpenKey(HKEY_CLASSES_ROOT, CLSID, &hkCLSID) == ERROR_SUCCESS)
        {
            TCHAR szGUID[80];

            TStringFromGUID(pcls->pclsid, szGUID);

            DeleteKeyAndSubKeys(hkCLSID, szGUID);

            RegCloseKey(hkCLSID);

            if (pcls->pfnRegUnReg)
                pcls->pfnRegUnReg(FALSE, NULL, szGUID, NULL);

        }
    }
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\ddrawex\ddrawex.cpp ===
/*==========================================================================
 *
 *  Copyright (C) 1997 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       ddrawex.cpp
 *  Content:	new DirectDraw object support
 *  History:
 *   Date	By	Reason
 *   ====	==	======
 *   24-feb-97	ralphl	initial implementation
 *   25-feb-97	craige	minor tweaks for dx checkin; integrated IBitmapSurface
 *			stuff
 *   03-mar-97	craige	added palettes to CreateCompatibleBitmapSurface
 *   06-mar-97	craige	IDirectDrawSurface3 support
 *   01-apr-97  jeffort Following changes checked in:
 *                      Attachlist structure added (from ddrawi.h)
 *                      Surface linked list handled
 *                      D3D interfaces added to QueryInterface
 *                      Complex surfaces are handled at CreateSurface calls
 *                      CreatCompatibleBitmap changed to handle > 8bpp bitmaps
 *                      Changed the call to GetPaletteEntries to use a handle to a palette
 *
 *   04-apr-97  jeffort Trident ifdef's removed
 *                      IDirectDraw3 class implemntation
 *                      paramter changed in recursive handling of attach lists
 *   10-apr-97  jeffort Release of pSurface2 in creating a simple surface was incorrect
 *                      this was already being done in surface.cpp
 *
 *   21-apr-97  jeffort Version Check for DX5 for QI of IDirectDrawSurface3
 *   28-apr-97  jeffort Palette wrapping added/DX5 support
 *   28-apr-97  jeffort Palette wrapping if CreatePalette fails in our internal
 *                      function, cleanup code added
 *   30-apr-97  jeffort No longer addref when querying for IDirect3D (done in ddraw QI)
 *                      AddRef attached surfaces (release done in releasing the surface)
 *   02-may-97  jeffort local variable changed from DWORD to WORD
 *
 *   08-may-97  jeffort Better parameter checking
 *   09-may-97  jeffort If GetTransparentIndex has nothing set return OK/COLOR_NO_TRANSPARENT
 *   16-may-97  jeffort A surface failing to be created is already released.  The release here
 *                      was removed.
 *   20-may-97  jeffort GetFormatFromDC checks if this is a surface DC and gets the
 *                      format from the surface instead of GetDeviceCaps
 *   27-may-97  jeffort keep ref count on internal object eual to outer object
 *   12-jun-97  jeffort reversed R and B fields in 32bpp PIXELFORMAT array
 *   20-jun-97  jeffort added debug code to invaliudate objects when freed
 *   27-jun-97  jeffort IDirectDrawSurface3 interface support for DX3 was not
 *                      added.  We now use an IDirectDrawSurface2 to spoof it
 *                      so we can support SetSurfaceDesc
 *   22-jul-97  jeffort Removed IBitmapSurface and associated interfaces
 ***************************************************************************/
#define INITGUID
#define CPP_FUNCTIONS
#include "ddfactry.h"

#define m_pDirectDraw (m_DDInt.m_pRealInterface)
#define m_pDirectDraw2 (m_DD2Int.m_pRealInterface)
#define m_pDirectDraw4 (m_DD4Int.m_pRealInterface)



typedef struct _ATTACHLIST
{
    DWORD 	dwFlags;
    struct _ATTACHLIST			FAR *lpLink; 	  // link to next attached surface
    struct _DDRAWI_DDRAWSURFACE_LCL	FAR *lpAttached;  // attached surface local obj
    struct _DDRAWI_DDRAWSURFACE_INT	FAR *lpIAttached; // attached surface interface
} ATTACHLIST;
typedef ATTACHLIST FAR *LPATTACHLIST;

/*
 * CDirectDrawEx::CDirectDrawEx
 *
 * Constructor for the new DirectDrawEx class
 */
CDirectDrawEx::CDirectDrawEx(IUnknown *pUnkOuter) :
    m_cRef(1),
    m_pUnkOuter(pUnkOuter != 0 ? pUnkOuter : CAST_TO_IUNKNOWN(this)),
    m_pFirstSurface(NULL),
    m_pFirstPalette(NULL),
    m_pPrimaryPaletteList(NULL)
{

    DllAddRef();
    m_pDirectDraw = NULL;
    m_pDirectDraw2 = NULL;
    m_pDirectDraw4 = NULL;
    m_DDInt.m_pDirectDrawEx = this;
    m_DD2Int.m_pDirectDrawEx = this;
    m_DD4Int.m_pDirectDrawEx = this;
} /* CDirectDrawEx::CDirectDrawEx */


/*
 * CDirectDrawEx::Init
 */
HRESULT CDirectDrawEx::Init(
			GUID * pGUID,
			HWND hWnd,
			DWORD dwCoopLevelFlags,
			DWORD dwReserved,
			LPDIRECTDRAWCREATE pDirectDrawCreate )
{
    HRESULT hr;
    if( dwReserved )
    {
	hr = DDERR_INVALIDPARAMS;
    }
    else
    {
        //DDraw will pop a dialog complaining about 4bpp modes, so we need to
        //tell it not to. DDraw will sniff SEM and not pop the dialog if
        //SEM_FAILCRITICALERRORS is set.
        DWORD dw = SetErrorMode(SEM_FAILCRITICALERRORS);
        SetErrorMode(dw | SEM_FAILCRITICALERRORS); // retain old flags too
	hr = pDirectDrawCreate( pGUID, &m_pDirectDraw, NULL );
        SetErrorMode(dw);
	if( SUCCEEDED(hr) )
	{
	    hr = m_pDirectDraw->SetCooperativeLevel(hWnd, dwCoopLevelFlags);
	    if( SUCCEEDED(hr) )
	    {
                if (dwCoopLevelFlags & DDSCL_EXCLUSIVE)
                    m_bExclusive = TRUE;
                else
                    m_bExclusive = FALSE;
		hr = m_pDirectDraw->QueryInterface(IID_IDirectDraw2, (void **)&m_pDirectDraw2);
		if( SUCCEEDED(hr) )
		{
                    m_pDirectDraw->QueryInterface(IID_IDirectDraw4, (void **)&m_pDirectDraw4);
                    InitDirectDrawInterfaces(m_pDirectDraw, &m_DDInt, m_pDirectDraw2, &m_DD2Int, m_pDirectDraw4, &m_DD4Int);
                }
	    }
	}
    }
    return hr;

} /* CDirectDrawEx::Init */

/*
 * CDirectDrawEx::~CDirectDrawEx
 *
 * destructor
 */
CDirectDrawEx::~CDirectDrawEx()
{
    if( m_pDirectDraw )
    {
	m_pDirectDraw->Release();
    }
    if( m_pDirectDraw2 )
    {
	m_pDirectDraw2->Release();
    }
    if (m_pDirectDraw4)
    {
        m_pDirectDraw4->Release();
    }

#ifdef DEBUG
    DWORD * ptr;
    ptr = (DWORD *)this;
    for (int i = 0; i < sizeof(CDirectDrawEx) / sizeof(DWORD);i++)
        *ptr++ = 0xDEADBEEF;
#endif

    DllRelease();

} /* CDirectDrawEx::~CDirectDrawEx */

/*
 * CDirectDrawEx::NonDelegatingQueryInterface
 * 		  NonDelegatingAddRef
 * 		  NonDelegatingRelease
 *
 * The base IUnknown interface (non-delegating)
 */

STDMETHODIMP CDirectDrawEx::NonDelegatingQueryInterface(REFIID riid, void ** ppv)
{
    HRESULT hr;

    *ppv=NULL;

    if( IID_IUnknown == riid )
    {
	*ppv=(INonDelegatingUnknown *)this;
    }
    else if (IID_IDirectDraw3 == riid)
    {
        *ppv=(IDirectDraw3 *)this;
    }

    else if( IID_IDirectDraw==riid )
    {
	*ppv=&m_DDInt;
    }
    else if( IID_IDirectDraw2==riid )
    {
	*ppv=&m_DD2Int;
    }
    else if (IID_IDirectDraw4==riid && m_pDirectDraw4)
    {
        *ppv=&m_DD4Int;
    }
    else if (IID_IDirect3D == riid)
    {
	IUnknown* pUnk;

        HRESULT (__stdcall *lpFunc)(IDirectDrawVtbl **,REFIID, void **);

        *(DWORD *)(&lpFunc) = *(DWORD *)*(DWORD **)m_pDirectDraw;
        hr = lpFunc(&(m_DDInt.lpVtbl), riid, (void **)&pUnk);
        if( SUCCEEDED(hr) )
        {
            *ppv=pUnk;
        }
        else
	{
            *ppv = NULL;
	}
	return hr;
    }
    else if (IID_IDirect3D2 == riid)
    {
	IUnknown* pUnk;

        HRESULT (__stdcall *lpFunc)(IDirectDrawVtbl **,REFIID, void **);

        *(DWORD *)(&lpFunc) = *(DWORD *)*(DWORD **)m_pDirectDraw;
        hr = lpFunc(&(m_DDInt.lpVtbl), riid, (void **)&pUnk);
        if( SUCCEEDED(hr) )
        {
            *ppv=pUnk;
        }
        else
	{
            *ppv = NULL;
	}
	return hr;
    }
    else if (IID_IDirect3D3 == riid)
    {
	IUnknown* pUnk;

        HRESULT (__stdcall *lpFunc)(IDirectDrawVtbl **,REFIID, void **);

        *(DWORD *)(&lpFunc) = *(DWORD *)*(DWORD **)m_pDirectDraw;
        hr = lpFunc(&(m_DDInt.lpVtbl), riid, (void **)&pUnk);
        if( SUCCEEDED(hr) )
        {
            *ppv=pUnk;
        }
        else
	{
            *ppv = NULL;
	}
	return hr;
    }
    else
    {
	   return E_NOINTERFACE;
    }

    ((LPUNKNOWN)*ppv)->AddRef();
    return NOERROR;

} /* CDirectDrawEx::NonDelegatingQueryInterface */


STDMETHODIMP_(ULONG) CDirectDrawEx::NonDelegatingAddRef()
{
    m_pDirectDraw->AddRef();
    return InterlockedIncrement(&m_cRef);

} /* CDirectDrawEx::NonDelegatingAddRef */


STDMETHODIMP_(ULONG) CDirectDrawEx::NonDelegatingRelease()
{
    LONG lRefCount = InterlockedDecrement(&m_cRef);
    if (lRefCount)
    {
        m_pDirectDraw->Release();
	return lRefCount;
    }
    delete this;
    return 0;

} /* CDirectDrawEx::NonDelegatingRelease */

/*
 * CDirectDrawEx::QueryInterface
 *                AddRef
 *                Release
 *
 * The standard IUnknown that delegates...
 */
STDMETHODIMP CDirectDrawEx::QueryInterface(REFIID riid, void ** ppv)
{
    return m_pUnkOuter->QueryInterface(riid, ppv);

} /* CDirectDrawEx::QueryInterface */

STDMETHODIMP_(ULONG) CDirectDrawEx::AddRef(void)
{
    return m_pUnkOuter->AddRef();

} /* CDirectDrawEx::AddRef */

STDMETHODIMP_(ULONG) CDirectDrawEx::Release(void)
{
    return m_pUnkOuter->Release();

} /* CDirectDrawEx::Release */


/*
 * CDirectDrawEx::GetSurfaceFromDC
 *
 * Run the list of surfaces and find which one has this DC.
 * Works with OWNDC surfaces only for now.
 */
STDMETHODIMP CDirectDrawEx::GetSurfaceFromDC(HDC hdc, IDirectDrawSurface **ppSurface)
{
    HRESULT hr = DDERR_NOTFOUND;
    if( !ppSurface )
    {
	hr = E_POINTER;
    }
    else
    {
	*ppSurface = NULL;
	ENTER_DDEX();
	CDDSurface *pSurface = m_pFirstSurface;
	while( pSurface )
	{
	    if( (pSurface->m_HDC == hdc) || (pSurface->m_hDCDib == hdc) )
	    {
		hr = pSurface->m_pUnkOuter->QueryInterface(IID_IDirectDrawSurface, (void **)ppSurface);
		break;
	    }
	    pSurface = pSurface->m_pNext;
	}
	LEAVE_DDEX();
    }
    return hr;

} /* CDirectDrawEx::GetSurfaceFromDC */


/*
 * CDirectDrawEx::AddSurfaceToList
 *
 * Adds a surface to our doubly-linked surface list
 */
void CDirectDrawEx::AddSurfaceToList(CDDSurface *pSurface)
{
    ENTER_DDEX();
    if( m_pFirstSurface )
    {
	m_pFirstSurface->m_pPrev = pSurface;
    }
    pSurface->m_pPrev = NULL;
    pSurface->m_pNext = m_pFirstSurface;
    m_pFirstSurface = pSurface;
    LEAVE_DDEX();

} /* CDirectDrawEx::AddSurfaceToList */

/*
 * CDirectDrawEx::RemoveSurfaceToList
 *
 * Removes a surface to our doubly-linked surface list
 */
void CDirectDrawEx::RemoveSurfaceFromList(CDDSurface *pSurface)
{
    ENTER_DDEX();
    if( pSurface->m_pPrev )
    {
	pSurface->m_pPrev->m_pNext = pSurface->m_pNext;
    }
    else
    {
	m_pFirstSurface = pSurface->m_pNext;
    }
    if( pSurface->m_pNext )
    {
	pSurface->m_pNext->m_pPrev = pSurface->m_pPrev;
    }
    LEAVE_DDEX();

} /* CDirectDrawEx::RemoveSurfaceToList */


/*
 * CDirectDrawEx::AddSurfaceToPrimarList
 *
 * Adds a surface to our doubly-linked surface list which use the primary palette
 */
void CDirectDrawEx::AddSurfaceToPrimaryList(CDDSurface *pSurface)
{
    ENTER_DDEX();
    if( m_pPrimaryPaletteList )
    {
	m_pPrimaryPaletteList->m_pPrevPalette = pSurface;
    }
    pSurface->m_pPrevPalette = NULL;
    pSurface->m_pNextPalette = m_pPrimaryPaletteList;
    m_pPrimaryPaletteList = pSurface;
    pSurface->m_bPrimaryPalette = TRUE;
    LEAVE_DDEX();

} /* CDirectDrawEx::AddSurfaceToList */


/*
 * CDirectDrawEx::RemoveSurfaceFromPrimaryList
 *
 * Removes a surface to our doubly-linked surface list which use the primary palette
 */
void CDirectDrawEx::RemoveSurfaceFromPrimaryList(CDDSurface *pSurface)
{
    ENTER_DDEX();
    if( pSurface->m_pPrevPalette )
    {
	pSurface->m_pPrevPalette->m_pNextPalette = pSurface->m_pNextPalette;
    }
    else
    {
	m_pPrimaryPaletteList = pSurface->m_pNextPalette;
    }
    if( pSurface->m_pNextPalette )
    {
	pSurface->m_pNextPalette->m_pPrevPalette = pSurface->m_pPrevPalette;
    }
    pSurface->m_bPrimaryPalette = FALSE;
    LEAVE_DDEX();

} /* CDirectDrawEx::RemoveSurfaceToList */



/*
 * CDirectDrawEx::AddPaletteToList
 *
 * Adds a palette to our doubly-linked palette list
 */
void CDirectDrawEx::AddPaletteToList(CDDPalette *pPalette)
{
    ENTER_DDEX();
    if( m_pFirstPalette )
    {
	m_pFirstPalette->m_pPrev = pPalette;
    }
    pPalette->m_pPrev = NULL;
    pPalette->m_pNext = m_pFirstPalette;
    m_pFirstPalette = pPalette;
    LEAVE_DDEX();

}

/*
 * CDirectDrawEx::RemovePaletteToList
 *
 * Removes a palette to our doubly-linked palette list
 */
void CDirectDrawEx::RemovePaletteFromList(CDDPalette *pPalette)
{
    ENTER_DDEX();
    if( pPalette->m_pPrev )
    {
	pPalette->m_pPrev->m_pNext = pPalette->m_pNext;
    }
    else
    {
	m_pFirstPalette = pPalette->m_pNext;
    }
    if( pPalette->m_pNext )
    {
	pPalette->m_pNext->m_pPrev = pPalette->m_pPrev;
    }
    LEAVE_DDEX();

}




HRESULT CDirectDrawEx::CreateSimpleSurface(LPDDSURFACEDESC pSurfaceDesc, IUnknown *pUnkOuter, IDirectDrawSurface * pSurface, IDirectDrawSurface **ppNewSurface, DWORD dwFlags)
{
    IDirectDrawSurface2     *pSurface2 = NULL;
    IDirectDrawSurface3     *pSurface3 = NULL;
    HRESULT		    hr;

    hr = pSurface->QueryInterface(IID_IDirectDrawSurface2, (void **)&pSurface2);
    if (FAILED(hr))
        return hr;
    //we only want to do this Query if we are on DX5 or above.  On DX3, this is not supported,
    //and this call will cause D3D to be loaded
    pSurface3 = NULL;
    if (m_dwDDVer == WIN95_DX5 || m_dwDDVer == WINNT_DX5)
    {
        hr = pSurface->QueryInterface(IID_IDirectDrawSurface3, (void **)&pSurface3);
        if( FAILED( hr ) )
        {
            pSurface3 = NULL;
        }
    }
    if (pSurface3 == NULL)
        hr = pSurface->QueryInterface(IID_IDirectDrawSurface2, (void **)&pSurface3);
    if (FAILED(hr))
        return hr;

    IDirectDrawSurface4 *pSurface4 = NULL;
    //
    //  It's fine if this does not work...  Just ignore return code.
    //
    pSurface->QueryInterface(IID_IDirectDrawSurface4, (void **)&pSurface4);

    hr = CDDSurface::CreateSimpleSurface(
                        pSurfaceDesc,
  			pSurface,
 			pSurface2,
 			pSurface3,
                        pSurface4,
			pUnkOuter,
  			this,
                        ppNewSurface,
                        dwFlags);
    return hr;
}

HRESULT CDirectDrawEx::HandleAttachList(LPDDSURFACEDESC pSurfaceDesc, IUnknown *pUnkOuter,IDirectDrawSurface **ppNewSurface, IDirectDrawSurface * pOrigSurf, DWORD dwFlags)
{
    IDirectDrawSurface      *pSurface;
    IDirectDrawSurface      *pSurfaceReturn;
    DDSURFACEDESC           SurfaceDesc;
    HRESULT		    hr;

    //create the necessary SurfaceData here
    pSurface = *ppNewSurface;

    SurfaceDesc.dwSize = sizeof(DDSURFACEDESC);
    //add ref the attached surface here
    pSurface->AddRef();
    hr = pSurface->GetSurfaceDesc(&SurfaceDesc);
    if (!SUCCEEDED(hr))
        return hr;
    hr = CreateSimpleSurface(&SurfaceDesc, pUnkOuter, pSurface, (IDirectDrawSurface **)&pSurfaceReturn, dwFlags);

    if (!SUCCEEDED(hr))
        return hr;
    //we got here via an attachlist, so we need to recurse into the structure more
    LPATTACHLIST lpAttach;

    lpAttach = (LPATTACHLIST)(((LPDDRAWI_DDRAWSURFACE_INT)(pSurface))->lpLcl->lpAttachList);
    while (lpAttach != NULL){
        pSurface =  (IDirectDrawSurface *)((LPATTACHLIST)(((LPDDRAWI_DDRAWSURFACE_INT)(pSurface))->lpLcl->lpAttachList))->lpIAttached;
        lpAttach = lpAttach->lpLink;
        if (pSurface != pOrigSurf){
            hr = HandleAttachList(pSurfaceDesc, pUnkOuter, &pSurface, pOrigSurf, dwFlags);
            if (!SUCCEEDED(hr))
                return hr;
        }
    }
    return hr;
}



/*
 * CDirectDrawEx::CreateSurface
 *
 * Create a DirectDraw surface that supports OWNDC
 */
STDMETHODIMP CDirectDrawEx::CreateSurface(LPDDSURFACEDESC pSurfaceDesc, IDirectDrawSurface **ppNewSurface, IUnknown *pUnkOuter)
{
    DWORD 		origcaps;
    DWORD		newcaps;
    DWORD               dwFlags;
    IDirectDrawSurface	*pSurface;

    if (pSurfaceDesc == NULL)
        return DDERR_INVALIDPARAMS;
    if (ppNewSurface == NULL)
        return DDERR_INVALIDPARAMS;
    origcaps = pSurfaceDesc->ddsCaps.dwCaps;
    newcaps = origcaps;

    /*
     * If OWNDC is specified, it must be a system memory surface
     */
    if ((origcaps & (DDSCAPS_OWNDC | DDSCAPS_SYSTEMMEMORY)) == DDSCAPS_OWNDC)
    {
	return DDERR_INVALIDCAPS;
    }

    /*
     * DATAEXCHANGE has some magic...
     */
    if( (origcaps & DDSCAPS_DATAEXCHANGE) == DDSCAPS_DATAEXCHANGE )
    {
        dwFlags = SURFACE_DATAEXCHANGE;
        //Do not allow the primary surface with these caps!!!!
        if (origcaps & DDSCAPS_PRIMARYSURFACE)
            return DDERR_INVALIDCAPS;
	newcaps &= ~DDSCAPS_DATAEXCHANGE;
	newcaps |= DDSCAPS_SYSTEMMEMORY | DDSCAPS_OWNDC  | DDSCAPS_TEXTURE;
        if (newcaps & DDSCAPS_OFFSCREENPLAIN)
            newcaps &= ~DDSCAPS_OFFSCREENPLAIN;
    }
    else
        dwFlags = 0;

    /*
     * turn off OWNDC when going to DirectDraw 3
     */
    if (m_dwDDVer != WIN95_DX5 && m_dwDDVer != WINNT_DX5)
        newcaps &= ~DDSCAPS_OWNDC;

    /*
     * go create the surface (without the OWNDC attribute)
     */
    pSurfaceDesc->ddsCaps.dwCaps = newcaps;
    HRESULT hr = m_pDirectDraw->CreateSurface(pSurfaceDesc, &pSurface, NULL);
    pSurfaceDesc->ddsCaps.dwCaps = origcaps;
   /*
     * once we have the object, get any additional interfaces we need
     * to support and then create our surface object
     */
    if( SUCCEEDED(hr) )
    {
        hr = CreateSimpleSurface(pSurfaceDesc, pUnkOuter, pSurface, ppNewSurface, dwFlags);
        if (!SUCCEEDED(hr))
        {
            return hr;
        }
        //we need to worry about attached surfaces, do so here
        LPATTACHLIST lpAttach;
        //add the current surface to our list of surfaces
        IDirectDrawSurface * pOrigSurf = pSurface;
        lpAttach = (LPATTACHLIST)(((LPDDRAWI_DDRAWSURFACE_INT)(pSurface))->lpLcl->lpAttachList);
        while (lpAttach != NULL)
        {
            lpAttach = lpAttach->lpLink;
            pSurface =  (IDirectDrawSurface *)((LPATTACHLIST)(((LPDDRAWI_DDRAWSURFACE_INT)(pSurface))->lpLcl->lpAttachList))->lpIAttached;
            hr = HandleAttachList(pSurfaceDesc, pUnkOuter, &pSurface, pOrigSurf, dwFlags);
            if (!SUCCEEDED(hr))
            {
                //we need to drop out of the loop and clean up
                lpAttach = NULL;
            }
        }
        if (!SUCCEEDED(hr))
        {
         //   pSurface =  (IDirectDrawSurface *)((LPATTACHLIST)(((LPDDRAWI_DDRAWSURFACE_INT)(pOrigSurf))->lpLcl->lpAttachList))->lpIAttached;
         //   lpAttach = (LPATTACHLIST)(((LPDDRAWI_DDRAWSURFACE_INT)(pSurface))->lpLcl->lpAttachList);
            while (lpAttach != NULL)
            {
                //clean up these surfaces
                lpAttach = lpAttach->lpLink;
            }
        }
    }
    return hr;
} /* CDirectDrawEX::CreateSurface */


//
//  This is a modified copy of the above except using surfacedesc2 and surface4
//
STDMETHODIMP CDirectDrawEx::CreateSurface(LPDDSURFACEDESC2 pSurfaceDesc2, IDirectDrawSurface4 **ppNewSurface4, IUnknown *pUnkOuter)
{
    DWORD 		origcaps;
    DWORD		newcaps;
    DWORD               dwFlags;
    IDirectDrawSurface4	*pSurface4;

    if (pSurfaceDesc2 == NULL)
        return DDERR_INVALIDPARAMS;
    if (ppNewSurface4 == NULL)
        return DDERR_INVALIDPARAMS;
    origcaps = pSurfaceDesc2->ddsCaps.dwCaps;
    newcaps = origcaps;

    /*
     * If OWNDC is specified, it must be a system memory surface
     */
    if ((origcaps & (DDSCAPS_OWNDC | DDSCAPS_SYSTEMMEMORY)) == DDSCAPS_OWNDC)
    {
	return DDERR_INVALIDCAPS;
    }

    /*
     * DATAEXCHANGE has some magic...
     */
    if( (origcaps & DDSCAPS_DATAEXCHANGE) == DDSCAPS_DATAEXCHANGE )
    {
        dwFlags = SURFACE_DATAEXCHANGE;
        //Do not allow the primary surface with these caps!!!!
        if (origcaps & DDSCAPS_PRIMARYSURFACE)
            return DDERR_INVALIDCAPS;
	newcaps &= ~DDSCAPS_DATAEXCHANGE;
	newcaps |= DDSCAPS_SYSTEMMEMORY | DDSCAPS_OWNDC  | DDSCAPS_TEXTURE;
        if (newcaps & DDSCAPS_OFFSCREENPLAIN)
            newcaps &= ~DDSCAPS_OFFSCREENPLAIN;
    }
    else
        dwFlags = 0;

    /*
     * turn off OWNDC when going to DirectDraw 3
     */
    if (m_dwDDVer != WIN95_DX5 && m_dwDDVer != WINNT_DX5)
        newcaps &= ~DDSCAPS_OWNDC;

    /*
     * go create the surface (without the OWNDC attribute)
     */
    pSurfaceDesc2->ddsCaps.dwCaps = newcaps;
    HRESULT hr = m_pDirectDraw4->CreateSurface(pSurfaceDesc2, &pSurface4, NULL);
    pSurfaceDesc2->ddsCaps.dwCaps = origcaps;
   /*
     * once we have the object, get any additional interfaces we need
     * to support and then create our surface object
     */
    if( SUCCEEDED(hr) )
    {
        IDirectDrawSurface * pSurface;
        pSurface4->QueryInterface(IID_IDirectDrawSurface, (void **)&pSurface);
        pSurface4->Release();
        DDSURFACEDESC ddsd;
        ddsd.dwSize = sizeof(ddsd);
        pSurface->GetSurfaceDesc(&ddsd);
        ddsd.ddsCaps.dwCaps = origcaps;
        IDirectDrawSurface *pNewSurf1;
        hr = CreateSimpleSurface(&ddsd, pUnkOuter, pSurface, &pNewSurf1, dwFlags);
        if (!SUCCEEDED(hr))
        {
            return hr;
        }
        pNewSurf1->QueryInterface(IID_IDirectDrawSurface4, (void **)ppNewSurface4);
        pNewSurf1->Release();
        //we need to worry about attached surfaces, do so here
        LPATTACHLIST lpAttach;
        //add the current surface to our list of surfaces
        IDirectDrawSurface * pOrigSurf = pSurface;
        lpAttach = (LPATTACHLIST)(((LPDDRAWI_DDRAWSURFACE_INT)(pSurface))->lpLcl->lpAttachList);
        while (lpAttach != NULL)
        {
            lpAttach = lpAttach->lpLink;
            pSurface =  (IDirectDrawSurface *)((LPATTACHLIST)(((LPDDRAWI_DDRAWSURFACE_INT)(pSurface))->lpLcl->lpAttachList))->lpIAttached;
            hr = HandleAttachList(&ddsd, pUnkOuter, &pSurface, pOrigSurf, dwFlags);
            if (!SUCCEEDED(hr))
            {
                //we need to drop out of the loop and clean up
                lpAttach = NULL;
            }
        }
        if (!SUCCEEDED(hr))
        {
         //   pSurface =  (IDirectDrawSurface *)((LPATTACHLIST)(((LPDDRAWI_DDRAWSURFACE_INT)(pOrigSurf))->lpLcl->lpAttachList))->lpIAttached;
         //   lpAttach = (LPATTACHLIST)(((LPDDRAWI_DDRAWSURFACE_INT)(pSurface))->lpLcl->lpAttachList);
            while (lpAttach != NULL)
            {
                //clean up these surfaces
                lpAttach = lpAttach->lpLink;
            }
        }
    }
    return hr;
} /* CDirectDrawEX::CreateSurface */


STDMETHODIMP CDirectDrawEx::CreatePalette(DWORD dwFlags, LPPALETTEENTRY pEntries, LPDIRECTDRAWPALETTE FAR * ppPal, IUnknown FAR * pUnkOuter)
{
    IDirectDrawPalette	*pPalette;


    HRESULT hr = m_pDirectDraw->CreatePalette(dwFlags, pEntries, &pPalette, NULL);
    if (SUCCEEDED(hr))
    {
        hr = CDDPalette::CreateSimplePalette(pEntries, pPalette, ppPal, pUnkOuter, this);
        if (FAILED(hr))
        {
            //we were unable to create our palette structure, so we must delete the palette
            //we created here and fail
            pPalette->Release();
            *ppPal = NULL;
        }
    }

    return hr;
}


STDMETHODIMP CDirectDrawEx::SetCooperativeLevel(HWND hwnd, DWORD dwFlags)
{
    HRESULT hr = m_pDirectDraw->SetCooperativeLevel(hwnd, dwFlags);
    //check for exclusive mode here
    if (dwFlags & DDSCL_EXCLUSIVE)
        m_bExclusive = TRUE;
    else
        m_bExclusive = FALSE;
    return hr;
}


/*
 * some quicky inline fns to get at our object data
 */
_inline CDirectDrawEx * PARENTOF(IDirectDraw * pDD)
{
    return ((INTSTRUC_IDirectDraw *)pDD)->m_pDirectDrawEx;
}

_inline CDirectDrawEx * PARENTOF(IDirectDraw2 * pDD2)
{
    return ((INTSTRUC_IDirectDraw2 *)pDD2)->m_pDirectDrawEx;
}

_inline CDirectDrawEx * PARENTOF(IDirectDraw4 * pDD4)
{
    return ((INTSTRUC_IDirectDraw4 *)pDD4)->m_pDirectDrawEx;
}


/*
 * the implementation of the functions in IDirectDraw that we are overriding
 * (IUnknown and CreateSurface)
 */
STDMETHODIMP_(ULONG) IDirectDrawAggAddRef(IDirectDraw *pDD)
{
    return PARENTOF(pDD)->m_pUnkOuter->AddRef();
}

STDMETHODIMP_(ULONG) IDirectDrawAggRelease(IDirectDraw *pDD)
{
    return PARENTOF(pDD)->m_pUnkOuter->Release();
}

STDMETHODIMP IDirectDrawAggCreateSurface(IDirectDraw *pDD, LPDDSURFACEDESC pSurfaceDesc,
				         IDirectDrawSurface **ppNewSurface, IUnknown *pUnkOuter)
{
    return PARENTOF(pDD)->CreateSurface(pSurfaceDesc, ppNewSurface, pUnkOuter);
}

STDMETHODIMP IDirectDrawAggCreatePalette(IDirectDraw *pDD,DWORD dwFlags, LPPALETTEENTRY pEntries, LPDIRECTDRAWPALETTE FAR * ppPal, IUnknown FAR * pUnkOuter)
{
    return PARENTOF(pDD)->CreatePalette( dwFlags, pEntries, ppPal, pUnkOuter);
}

STDMETHODIMP IDirectDrawAggSetCooperativeLevel(IDirectDraw * pDD, HWND hwnd, DWORD dwFlags)
{
    return PARENTOF(pDD)->SetCooperativeLevel(hwnd, dwFlags);
}
/*
 * the implementation of the functions in IDirectDraw2 that we are overriding
 * (IUnknown and CreateSurface)
 */
STDMETHODIMP_(ULONG) IDirectDraw2AggAddRef(IDirectDraw2 *pDD)
{
    return PARENTOF(pDD)->m_pUnkOuter->AddRef();
}

STDMETHODIMP_(ULONG) IDirectDraw2AggRelease(IDirectDraw2 *pDD)
{
    return PARENTOF(pDD)->m_pUnkOuter->Release();
}

STDMETHODIMP IDirectDraw2AggCreateSurface(IDirectDraw2 *pDD, LPDDSURFACEDESC pSurfaceDesc,
					  IDirectDrawSurface **ppNewSurface, IUnknown *pUnkOuter)
{						
    return PARENTOF(pDD)->CreateSurface(pSurfaceDesc, ppNewSurface, pUnkOuter);
}

STDMETHODIMP IDirectDraw2AggCreatePalette(IDirectDraw2 *pDD,DWORD dwFlags, LPPALETTEENTRY pEntries, LPDIRECTDRAWPALETTE FAR * ppPal, IUnknown FAR * pUnkOuter)
{
    return PARENTOF(pDD)->CreatePalette( dwFlags, pEntries, ppPal, pUnkOuter);
}

STDMETHODIMP IDirectDraw2AggSetCooperativeLevel(IDirectDraw2 * pDD, HWND hwnd, DWORD dwFlags)
{
    return PARENTOF(pDD)->SetCooperativeLevel(hwnd, dwFlags);
}


/***************************************************************************
 *
 *
 * IDirectDraw3 stuff follows
 *
 *
 ***************************************************************************/
STDMETHODIMP CDirectDrawEx::Compact()
{
    return m_pDirectDraw2->Compact();
}

STDMETHODIMP CDirectDrawEx::CreateClipper(DWORD dwParam, LPDIRECTDRAWCLIPPER FAR* pClip, IUnknown FAR * pIUnk )
{
    return m_pDirectDraw2->CreateClipper(dwParam, pClip, pIUnk);
}

STDMETHODIMP CDirectDrawEx::DuplicateSurface(LPDIRECTDRAWSURFACE pSurf, LPDIRECTDRAWSURFACE FAR * ppSurf2)
{
    return m_pDirectDraw2->DuplicateSurface(pSurf, ppSurf2);
}


STDMETHODIMP CDirectDrawEx::EnumDisplayModes(DWORD dwParam, LPDDSURFACEDESC pSurfDesc, LPVOID pPtr, LPDDENUMMODESCALLBACK pCallback )
{
    return m_pDirectDraw2->EnumDisplayModes(dwParam, pSurfDesc, pPtr, pCallback);
}

STDMETHODIMP CDirectDrawEx::EnumSurfaces(DWORD dwParam, LPDDSURFACEDESC pSurfDesc, LPVOID pPtr,LPDDENUMSURFACESCALLBACK pCallback)
{
    return m_pDirectDraw2->EnumSurfaces(dwParam, pSurfDesc, pPtr, pCallback);
}

STDMETHODIMP CDirectDrawEx::FlipToGDISurface()
{
    return m_pDirectDraw2->FlipToGDISurface();
}

STDMETHODIMP CDirectDrawEx::GetCaps(LPDDCAPS pDDCaps1, LPDDCAPS pDDCaps2)
{
    return m_pDirectDraw2->GetCaps(pDDCaps1, pDDCaps2);
}

STDMETHODIMP CDirectDrawEx::GetDisplayMode(LPDDSURFACEDESC pSurfDesc)
{
    return m_pDirectDraw2->GetDisplayMode(pSurfDesc);
}

STDMETHODIMP CDirectDrawEx::GetFourCCCodes(LPDWORD pDW1, LPDWORD pDW2 )
{
    return m_pDirectDraw2->GetFourCCCodes(pDW1, pDW2);
}

STDMETHODIMP CDirectDrawEx::GetGDISurface(LPDIRECTDRAWSURFACE FAR * ppSurf)
{
    return m_pDirectDraw2->GetGDISurface(ppSurf);
}

STDMETHODIMP CDirectDrawEx::GetMonitorFrequency(LPDWORD pParam)
{
    return m_pDirectDraw2->GetMonitorFrequency(pParam);
}

STDMETHODIMP CDirectDrawEx::GetScanLine(LPDWORD pParam)
{
    return m_pDirectDraw2->GetScanLine(pParam);
}


STDMETHODIMP CDirectDrawEx::GetVerticalBlankStatus(LPBOOL lpParam )
{
    return m_pDirectDraw2->GetVerticalBlankStatus(lpParam);
}

STDMETHODIMP CDirectDrawEx::Initialize(GUID FAR * pGUID)
{
    return m_pDirectDraw2->Initialize(pGUID);
}

STDMETHODIMP CDirectDrawEx::RestoreDisplayMode()
{
    return m_pDirectDraw2->RestoreDisplayMode();
}

STDMETHODIMP CDirectDrawEx::SetDisplayMode(DWORD dw1, DWORD dw2, DWORD dw3, DWORD dw4, DWORD dw5)
{
    return m_pDirectDraw2->SetDisplayMode(dw1, dw2, dw3, dw4, dw5);
}

STDMETHODIMP CDirectDrawEx::WaitForVerticalBlank(DWORD dw1, HANDLE hdl)
{
    return m_pDirectDraw2->WaitForVerticalBlank(dw1, hdl);
}

STDMETHODIMP CDirectDrawEx::GetAvailableVidMem(LPDDSCAPS pDDSCaps, LPDWORD pParam1, LPDWORD pParam2)
{
    return m_pDirectDraw2->GetAvailableVidMem(pDDSCaps, pParam1, pParam2);
}




/*
 * the implementation of the functions in IDirectDraw4 that we are overriding
 * (IUnknown and CreateSurface)
 */
STDMETHODIMP_(ULONG) IDirectDraw4AggAddRef(IDirectDraw4 *pDD)
{
    return PARENTOF(pDD)->m_pUnkOuter->AddRef();
}

STDMETHODIMP_(ULONG) IDirectDraw4AggRelease(IDirectDraw4 *pDD)
{
    return PARENTOF(pDD)->m_pUnkOuter->Release();
}

STDMETHODIMP IDirectDraw4AggCreateSurface(IDirectDraw4 *pDD, LPDDSURFACEDESC2 pSurfaceDesc2,
					  IDirectDrawSurface4 **ppNewSurface4, IUnknown *pUnkOuter)
{						
    return PARENTOF(pDD)->CreateSurface(pSurfaceDesc2, ppNewSurface4, pUnkOuter);
}

STDMETHODIMP IDirectDraw4AggCreatePalette(IDirectDraw4 *pDD,DWORD dwFlags, LPPALETTEENTRY pEntries, LPDIRECTDRAWPALETTE FAR * ppPal, IUnknown FAR * pUnkOuter)
{
    return PARENTOF(pDD)->CreatePalette( dwFlags, pEntries, ppPal, pUnkOuter);
}

STDMETHODIMP IDirectDraw4AggSetCooperativeLevel(IDirectDraw4 * pDD, HWND hwnd, DWORD dwFlags)
{
    return PARENTOF(pDD)->SetCooperativeLevel(hwnd, dwFlags);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\ddrawex\palette.cpp ===
/*==========================================================================
 *
 *  Copyright (C) 1997 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       palette.cpp
 *  Content:	new DirectDraw object support
 *  History:
 *   Date	By	Reason
 *   ====	==	======
 *   22-apr-97	jeffort	initial implementation
 *   30-apr-97  jeffort critical section shared from ddrawex object
 *   27-may-97  jeffort keep ref count on internal object eual to outer object
 *   18-jun-97  jeffort linked list fix, we were using m_pNext instead of m_pNextPalette
 *   20-jun-97  jeffort added debug code to invaliudate objects when freed
 *   08-jul-97  jeffort switched order of releasing real palette interface BEFORE ddrawex release
 *                      due to the fact if ddraw is released before hand we will GP fault
 ***************************************************************************/
#include "ddfactry.h"

#define m_pDDPalette (m_DDPInt.m_pRealInterface)



CDDPalette::CDDPalette( IDirectDrawPalette * pDDPalette,
		IUnknown *pUnkOuter,
		CDirectDrawEx *pDirectDrawEx) :
    m_cRef(1),
    m_pUnkOuter(pUnkOuter != 0 ? pUnkOuter : CAST_TO_IUNKNOWN(this)),
    m_pDirectDrawEx(pDirectDrawEx)
{

    m_DDPInt.m_pSimplePalette = this;
    m_pDDPalette = pDDPalette;
    m_pFirstSurface = NULL;
    InitDirectDrawPaletteInterfaces( pDDPalette, &m_DDPInt);
    pDirectDrawEx->AddRef();
    pDirectDrawEx->AddPaletteToList(this);
    DllAddRef();

}



CDDPalette::~CDDPalette()
{
    /*
     * clean up...
     */
    //we must mark any surfaces in our list as having no palette
    //we are running this list, must bracket by critical section

    CDDSurface *pSurface = m_pFirstSurface;

    ENTER_DDEX();
    while (pSurface != NULL)
    {
        pSurface->m_pCurrentPalette = NULL;
        pSurface = pSurface->m_pNextPalette;
    }
    //if this is the primary surface, go down the primary list and mark the current palette as null
    if (m_bIsPrimary)
    {
        CDDSurface *pSurface = m_pDirectDrawEx->m_pPrimaryPaletteList;
        while (pSurface != NULL)
        {
            pSurface->m_pCurrentPalette = NULL;
            pSurface = pSurface->m_pNextPalette;
        }
    }
    LEAVE_DDEX();
    m_pDirectDrawEx->RemovePaletteFromList(this);
    m_pDDPalette->Release();
    m_pDirectDrawEx->Release();
    DllRelease();
#ifdef DEBUG
    DWORD * ptr;
    ptr = (DWORD *)this;
    for (int i = 0; i < sizeof(CDDPalette) / sizeof(DWORD);i++)
        *ptr++ = 0xDEADBEEF;
#endif
} /* CDDSurface::~CDDSurface */




/*
 * CDirectDrawEx::AddSurfaceToList
 *
 * Adds a surface to our doubly-linked list of surfaces conatining this palette
 */
void CDDPalette::AddSurfaceToList(CDDSurface *pSurface)
{
    ENTER_DDEX();
    if( m_pFirstSurface )
    {
	m_pFirstSurface->m_pPrevPalette = pSurface;
    }
    pSurface->m_pPrevPalette = NULL;
    pSurface->m_pNextPalette = m_pFirstSurface;
    m_pFirstSurface = pSurface;
    LEAVE_DDEX();

}

/*
 * CDirectDrawEx::RemoveSurfaceFromList
 *
 * Removes a surface from our doubly-linked surface list
 */
void CDDPalette::RemoveSurfaceFromList(CDDSurface *pSurface)
{
    ENTER_DDEX();
    if( pSurface->m_pPrevPalette )
    {
	pSurface->m_pPrevPalette->m_pNextPalette = pSurface->m_pNextPalette;
    }
    else
    {
	m_pFirstSurface = pSurface->m_pNextPalette;
    }
    if( pSurface->m_pNextPalette )
    {
	pSurface->m_pNextPalette->m_pPrevPalette = pSurface->m_pPrevPalette;
    }
    LEAVE_DDEX();

}




HRESULT CDDPalette::CreateSimplePalette(LPPALETTEENTRY pEntries,
                                       IDirectDrawPalette *pDDPalette,
                                       LPDIRECTDRAWPALETTE FAR * ppPal,
                                       IUnknown FAR * pUnkOuter,
                                       CDirectDrawEx *pDirectDrawEx)
{
    HRESULT hr = DD_OK;
    CDDPalette *pPalette = new CDDPalette(pDDPalette,
					  pUnkOuter,
					  pDirectDrawEx);
    if( !pPalette)
    {
	return E_OUTOFMEMORY;
    }
    else
    {
        pPalette->NonDelegatingQueryInterface(pUnkOuter ? IID_IUnknown : IID_IDirectDrawPalette, (void **)ppPal);
        pPalette->NonDelegatingRelease();
    }

    return hr;

}


HRESULT CDDPalette::SetColorTable (CDDSurface * pSurface, LPPALETTEENTRY pEntries, DWORD dwNumEntries, DWORD dwBase)
{
    //cal SetDIBColorTable here
    RGBQUAD rgbq[256];
    HDC hdc;
    HRESULT hr;

    hr = DD_OK;
    if (pSurface->m_bOwnDC)
    {
        if( pSurface->m_hDCDib )
        {
	    hdc = pSurface->m_hDCDib;
        }
        else if( pSurface->m_bOwnDC )
        {
	    hdc = pSurface->m_HDC;
        }
        else
        {
            return DD_OK;
        }
        // we need to copy the entries here for
        // a logical palette
        // we need to ues the struct as a LogPal struct
        for( int i=0;i<(int) dwNumEntries;i++ )
	{
            rgbq[i].rgbBlue = pEntries[i].peBlue;
            rgbq[i].rgbGreen = pEntries[i].peGreen;
            rgbq[i].rgbRed = pEntries[i].peRed;
            rgbq[i].rgbReserved = 0;
        }
        SetDIBColorTable(hdc, dwBase, dwNumEntries, rgbq);
    }
    return hr;
}


STDMETHODIMP CDDPalette::InternalSetEntries(DWORD dwFlags, DWORD dwBase, DWORD dwNumEntries, LPPALETTEENTRY lpe)
{
    HRESULT hr;
    CDDSurface *pSurfaceList;

    hr = m_pDDPalette->SetEntries(dwFlags, dwBase, dwNumEntries, lpe);
    //now we need to traverse the list of Surfaces and if OWNDC is set, set the DibSection ColorTable
    if (m_bIsPrimary)
        pSurfaceList = m_pDirectDrawEx->m_pPrimaryPaletteList;
    else
        pSurfaceList = m_pFirstSurface;

    while (pSurfaceList != NULL)
    {
        SetColorTable(pSurfaceList, lpe, dwNumEntries, dwBase);
        pSurfaceList = pSurfaceList->m_pNextPalette;
    }
    return hr;
}


STDMETHODIMP CDDPalette::QueryInterface(REFIID riid, void ** ppv)
{
    return m_pUnkOuter->QueryInterface(riid, ppv);

} /* CDirectDrawEx::QueryInterface */

STDMETHODIMP_(ULONG) CDDPalette::AddRef(void)
{
    return m_pUnkOuter->AddRef();

} /* CDirectDrawEx::AddRef */

STDMETHODIMP_(ULONG) CDDPalette::Release(void)
{
    return m_pUnkOuter->Release();

} /* CDirectDrawEx::Release */

/*
 * NonDelegating IUnknown for simple surface follows...
 */

STDMETHODIMP CDDPalette::NonDelegatingQueryInterface(REFIID riid, void ** ppv)
{
//    HRESULT hr;

    *ppv=NULL;

    if( IID_IUnknown==riid )
    {
        *ppv=(INonDelegatingUnknown *)this;
    }
    else if( IID_IDirectDrawPalette==riid )
    {
	*ppv=&m_DDPInt;
    }

    else
    {
	   return E_NOINTERFACE;
    }

    ((LPUNKNOWN)*ppv)->AddRef();
    return NOERROR;
}

STDMETHODIMP_(ULONG) CDDPalette::NonDelegatingAddRef()
{
    //addref the internal palette interface
    m_pDDPalette->AddRef();
    return InterlockedIncrement(&m_cRef);
}

STDMETHODIMP_(ULONG) CDDPalette::NonDelegatingRelease()
{
    LONG lRefCount = InterlockedDecrement(&m_cRef);
    if (lRefCount) {
        //we need to release the internal interface as well
        m_pDDPalette->Release();
        return lRefCount;
    }
    delete this;
    return 0;
}

/*
 * Quick inline fns to get at our internal data...
 */
_inline CDDPalette * PALETTEOF(IDirectDrawPalette * pDDP)
{
    return ((INTSTRUC_IDirectDrawPalette *)pDDP)->m_pSimplePalette;
}



STDMETHODIMP_(ULONG) IDirectDrawPaletteAggAddRef(IDirectDrawPalette *pDDP)
{
    return PALETTEOF(pDDP)->m_pUnkOuter->AddRef();
}

STDMETHODIMP_(ULONG) IDirectDrawPaletteAggRelease(IDirectDrawPalette *pDDP)
{
    return PALETTEOF(pDDP)->m_pUnkOuter->Release();
}


STDMETHODIMP IDirectDrawPaletteAggSetEntries(IDirectDrawPalette *pDDP, DWORD dw1, DWORD dw2, DWORD dw3, LPPALETTEENTRY lpe)
{
    return PALETTEOF(pDDP)->InternalSetEntries(dw1, dw2, dw3, lpe);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\ddrawex\sources.inc ===
MAJORCOMP=windows
MINORCOMP=GDI
UMTYPE=windows

TARGETNAME=ddrawex
TARGETTYPE=DYNLINK

INCLUDES= ..\dx6;..\dx3inc;..\..\inc;

USE_MAPSYM = 1

TARGETPATH = obj

TARGETLIBS=$(SDK_LIB_PATH)\user32.lib \
	   $(SDK_LIB_PATH)\kernel32.lib \
	   $(SDK_LIB_PATH)\advapi32.lib \
	   $(SDK_LIB_PATH)\gdi32.lib \
	   $(SDK_LIB_PATH)\version.lib \
	   $(PROJECT_LIB_PATH)\ddrawp.lib \
       $(SDK_LIB_PATH)\uuid.lib

DLLENTRY=DllEntryPoint
!if $(ALPHA)
USE_NTDLL=1
!else
USE_NOLIB=1
!endif

!IFNDEF MSC_WARNING_LEVEL
MSC_WARNING_LEVEL=/W3
!ENDIF
MSC_WARNING_LEVEL=$(MSC_WARNING_LEVEL) /WX

!IFDEF PENTIUMCOUNTER
C_DEFINES=$(C_DEFINES) -DPENTIUMCOUNTER
ASM_DEFINES=$(ASM_DEFINES) -DPENTIUMCOUNTER
!endif

C_DEFINES = $(C_DEFINES) -DIS_32 -D_NO_ENUM -D_NOCSECT_TYPE -D_WIN32 -DUSE_GDI_HDC -DMSBUILD

SOURCES= \
	..\comdll.c \
	..\ddrawex.cpp \
	..\vtable.cpp \
	..\surface.cpp \
	..\factory.cpp \
	..\palette.cpp\
	..\ddrawex.rc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\ddrawex\dx3inc\32to16.asm ===
page	,132

;Thunk Compiler Version 1.8  Dec 14 1994 14:53:05
;File Compiled Fri Jun 20 10:27:33 1997

;Command Line: thunk -P2 -NC ddraw -t thk3216 ..\32to16.thk -o 32to16.asm 

	TITLE	$32to16.asm

	.386
	OPTION READONLY
	OPTION OLDSTRUCTS

IFNDEF IS_16
IFNDEF IS_32
%out command line error: specify one of -DIS_16, -DIS_32
.err
ENDIF  ;IS_32
ENDIF  ;IS_16


IFDEF IS_32
IFDEF IS_16
%out command line error: you can't specify both -DIS_16 and -DIS_32
.err
ENDIF ;IS_16
;************************* START OF 32-BIT CODE *************************


	.model FLAT,STDCALL


;-- Import common flat thunk routines (in k32)

externDef MapHInstLS	:near32
externDef MapHInstLS_PN	:near32
externDef MapHInstSL	:near32
externDef MapHInstSL_PN	:near32
externDef FT_Prolog	:near32
externDef FT_Thunk	:near32
externDef QT_Thunk	:near32
externDef FT_Exit0	:near32
externDef FT_Exit4	:near32
externDef FT_Exit8	:near32
externDef FT_Exit12	:near32
externDef FT_Exit16	:near32
externDef FT_Exit20	:near32
externDef FT_Exit24	:near32
externDef FT_Exit28	:near32
externDef FT_Exit32	:near32
externDef FT_Exit36	:near32
externDef FT_Exit40	:near32
externDef FT_Exit44	:near32
externDef FT_Exit48	:near32
externDef FT_Exit52	:near32
externDef FT_Exit56	:near32
externDef SMapLS	:near32
externDef SUnMapLS	:near32
externDef SMapLS_IP_EBP_8	:near32
externDef SUnMapLS_IP_EBP_8	:near32
externDef SMapLS_IP_EBP_12	:near32
externDef SUnMapLS_IP_EBP_12	:near32
externDef SMapLS_IP_EBP_16	:near32
externDef SUnMapLS_IP_EBP_16	:near32
externDef SMapLS_IP_EBP_20	:near32
externDef SUnMapLS_IP_EBP_20	:near32
externDef SMapLS_IP_EBP_24	:near32
externDef SUnMapLS_IP_EBP_24	:near32
externDef SMapLS_IP_EBP_28	:near32
externDef SUnMapLS_IP_EBP_28	:near32
externDef SMapLS_IP_EBP_32	:near32
externDef SUnMapLS_IP_EBP_32	:near32
externDef SMapLS_IP_EBP_36	:near32
externDef SUnMapLS_IP_EBP_36	:near32
externDef SMapLS_IP_EBP_40	:near32
externDef SUnMapLS_IP_EBP_40	:near32

MapSL	PROTO NEAR STDCALL p32:DWORD



	.code 

;************************* COMMON PER-MODULE ROUTINES *************************

	.data

public thk3216_ThunkData32	;This symbol must be exported.
thk3216_ThunkData32 label dword
	dd	3130534ch	;Protocol 'LS01'
	dd	0210141h	;Checksum
	dd	0	;Jump table address.
	dd	3130424ch	;'LB01'
	dd	0	;Flags
	dd	0	;Reserved (MUST BE 0)
	dd	0	;Reserved (MUST BE 0)
	dd	offset QT_Thunk_thk3216 - offset thk3216_ThunkData32
	dd	offset FT_Prolog_thk3216 - offset thk3216_ThunkData32



	.code 


externDef ThunkConnect32@24:near32

public thk3216_ThunkConnect32@16
thk3216_ThunkConnect32@16:
	pop	edx
	push	offset thk3216_ThkData16
	push	offset thk3216_ThunkData32
	push	edx
	jmp	ThunkConnect32@24
thk3216_ThkData16 label byte
	db	"thk3216_ThunkData16",0


		


pfnQT_Thunk_thk3216	dd offset QT_Thunk_thk3216
pfnFT_Prolog_thk3216	dd offset FT_Prolog_thk3216
	.data
QT_Thunk_thk3216 label byte
	db	32 dup(0cch)	;Patch space.

FT_Prolog_thk3216 label byte
	db	32 dup(0cch)	;Patch space.


	.code 





;************************ START OF THUNK BODIES************************




;
public DD16_GetMonitorMaxSize@4
DD16_GetMonitorMaxSize@4:
	mov	cl,54
; DD16_GetMonitorMaxSize(16) = DD16_GetMonitorMaxSize(32) {}
;
; dword ptr [ebp+8]:  dev
;
public IIDD16_GetMonitorMaxSize@4
IIDD16_GetMonitorMaxSize@4:
	push	ebp
	mov	ebp,esp
	push	ecx
	sub	esp,60
	push	dword ptr [ebp+8]	;dev: dword->dword
	call	dword ptr [pfnQT_Thunk_thk3216]
	cwde
	leave
	retn	4





;
public DD16_GetMonitorRefreshRateRanges@20
DD16_GetMonitorRefreshRateRanges@20:
	mov	cx, (5 SHL 10) + (0 SHL 8) + 53
; DD16_GetMonitorRefreshRateRanges(16) = DD16_GetMonitorRefreshRateRanges(32) {}
;
; dword ptr [ebp+8]:  dev
; dword ptr [ebp+12]:  xres
; dword ptr [ebp+16]:  yres
; dword ptr [ebp+20]:  pmin
; dword ptr [ebp+24]:  pmax
;
public IIDD16_GetMonitorRefreshRateRanges@20
IIDD16_GetMonitorRefreshRateRanges@20:
	call	dword ptr [pfnFT_Prolog_thk3216]
	xor	eax,eax
	push	eax
	push	eax
	mov	edx, dword ptr [ebp+20]
	or	edx,edx
	jz	@F
	or	dword ptr [edx], 0
@@:
	mov	edx, dword ptr [ebp+24]
	or	edx,edx
	jz	@F
	or	dword ptr [edx], 0
@@:
	push	dword ptr [ebp+8]	;dev: dword->dword
	push	word ptr [ebp+12]	;xres: dword->word
	push	word ptr [ebp+16]	;yres: dword->word
	mov	eax, dword ptr [ebp+20]
	call	SMapLS
	mov	[ebp-68],edx
	push	eax
	mov	eax, dword ptr [ebp+24]
	call	SMapLS
	mov	[ebp-72],edx
	push	eax
	call	FT_Thunk
	movsx	ebx,ax
	mov	edx, dword ptr [ebp+20]
	or	edx,edx
	jz	L0
	movsx	ecx, word ptr [edx]
	mov	dword ptr [edx], ecx
L0:
	mov	ecx, dword ptr [ebp-68]
	call	SUnMapLS
	mov	edx, dword ptr [ebp+24]
	or	edx,edx
	jz	L1
	movsx	ecx, word ptr [edx]
	mov	dword ptr [edx], ecx
L1:
	mov	ecx, dword ptr [ebp-72]
	call	SUnMapLS
	jmp	FT_Exit20





;
public DD16_IsWin95MiniDriver@0
DD16_IsWin95MiniDriver@0:
	mov	cl,51
; DD16_IsWin95MiniDriver(16) = DD16_IsWin95MiniDriver(32) {}
;
;
public IIDD16_IsWin95MiniDriver@0
IIDD16_IsWin95MiniDriver@0:
	push	ebp
	mov	ebp,esp
	push	ecx
	sub	esp,60
	call	dword ptr [pfnQT_Thunk_thk3216]
	cwde
	leave
	retn





;
public ModeX_SetPaletteEntries@12
ModeX_SetPaletteEntries@12:
	mov	cl,50
; ModeX_SetPaletteEntries(16) = ModeX_SetPaletteEntries(32) {}
;
; dword ptr [ebp+8]:  wBase
; dword ptr [ebp+12]:  wNum
; dword ptr [ebp+16]:  lpPaletteEntries
;
public IIModeX_SetPaletteEntries@12
IIModeX_SetPaletteEntries@12:
	push	ebp
	mov	ebp,esp
	push	ecx
	sub	esp,60
	push	word ptr [ebp+8]	;wBase: dword->word
	push	word ptr [ebp+12]	;wNum: dword->word
	call	SMapLS_IP_EBP_16
	push	eax
	call	dword ptr [pfnQT_Thunk_thk3216]
	shl	eax,16
	shrd	eax,edx,16
	call	SUnMapLS_IP_EBP_16
	leave
	retn	12





;
public ModeX_SetMode@8
ModeX_SetMode@8:
	mov	cl,49
; ModeX_SetMode(16) = ModeX_SetMode(32) {}
;
; dword ptr [ebp+8]:  wWidth
; dword ptr [ebp+12]:  wHeight
;
public IIModeX_SetMode@8
IIModeX_SetMode@8:
	push	ebp
	mov	ebp,esp
	push	ecx
	sub	esp,60
	push	word ptr [ebp+8]	;wWidth: dword->word
	push	word ptr [ebp+12]	;wHeight: dword->word
	call	dword ptr [pfnQT_Thunk_thk3216]
	shl	eax,16
	shrd	eax,edx,16
	leave
	retn	8





;
public ModeX_RestoreMode@0
ModeX_RestoreMode@0:
	mov	cl,48
; ModeX_RestoreMode(16) = ModeX_RestoreMode(32) {}
;
;
public IIModeX_RestoreMode@0
IIModeX_RestoreMode@0:
	push	ebp
	mov	ebp,esp
	push	ecx
	sub	esp,60
	call	dword ptr [pfnQT_Thunk_thk3216]
	shl	eax,16
	shrd	eax,edx,16
	leave
	retn





;
public ModeX_Flip@4
ModeX_Flip@4:
	mov	cl,47
; ModeX_Flip(16) = ModeX_Flip(32) {}
;
; dword ptr [ebp+8]:  lpBackBuffer
;
public IIModeX_Flip@4
IIModeX_Flip@4:
	push	ebp
	mov	ebp,esp
	push	ecx
	sub	esp,60
	push	dword ptr [ebp+8]	;lpBackBuffer: dword->dword
	call	dword ptr [pfnQT_Thunk_thk3216]
	shl	eax,16
	shrd	eax,edx,16
	leave
	retn	4





;
public DD16_SetEventHandle@8
DD16_SetEventHandle@8:
	mov	cl,46
; DD16_SetEventHandle(16) = DD16_SetEventHandle(32) {}
;
; dword ptr [ebp+8]:  hInstance
; dword ptr [ebp+12]:  dwEvent
;
public IIDD16_SetEventHandle@8
IIDD16_SetEventHandle@8:
	push	ebp
	mov	ebp,esp
	push	ecx
	sub	esp,60
	push	dword ptr [ebp+8]	;hInstance: dword->dword
	push	dword ptr [ebp+12]	;dwEvent: dword->dword
	call	dword ptr [pfnQT_Thunk_thk3216]
	leave
	retn	8





;
public DD16_ChangeDisplaySettings@8
DD16_ChangeDisplaySettings@8:
	mov	cl,42
; DD16_ChangeDisplaySettings(16) = DD16_ChangeDisplaySettings(32) {}
;
; dword ptr [ebp+8]:  pdm
; dword ptr [ebp+12]:  flags
;
public IIDD16_ChangeDisplaySettings@8
IIDD16_ChangeDisplaySettings@8:
	push	ebp
	mov	ebp,esp
	push	ecx
	sub	esp,60
	call	SMapLS_IP_EBP_8
	push	eax
	push	dword ptr [ebp+12]	;flags: dword->dword
	call	dword ptr [pfnQT_Thunk_thk3216]
	shl	eax,16
	shrd	eax,edx,16
	call	SUnMapLS_IP_EBP_8
	leave
	retn	8





;
public DD16_SafeMode@8
DD16_SafeMode@8:
	mov	cl,41
; DD16_SafeMode(16) = DD16_SafeMode(32) {}
;
; dword ptr [ebp+8]:  hdc
; dword ptr [ebp+12]:  fSafeMode
;
public IIDD16_SafeMode@8
IIDD16_SafeMode@8:
	push	ebp
	mov	ebp,esp
	push	ecx
	sub	esp,60
	push	word ptr [ebp+8]	;hdc: dword->word
	push	word ptr [ebp+12]	;fSafeMode: dword->word
	call	dword ptr [pfnQT_Thunk_thk3216]
	cwde
	leave
	retn	8





;
public DD16_GetDC@4
DD16_GetDC@4:
	mov	cl,40
; DD16_GetDC(16) = DD16_GetDC(32) {}
;
; dword ptr [ebp+8]:  pddsd
;
public IIDD16_GetDC@4
IIDD16_GetDC@4:
	push	ebp
	mov	ebp,esp
	push	ecx
	sub	esp,60
	call	SMapLS_IP_EBP_8
	push	eax
	call	dword ptr [pfnQT_Thunk_thk3216]
	movzx	eax,ax
	call	SUnMapLS_IP_EBP_8
	leave
	retn	4





;
public DD16_Exclude@8
DD16_Exclude@8:
	mov	cl,38
; DD16_Exclude(16) = DD16_Exclude(32) {}
;
; dword ptr [ebp+8]:  dwPDevice
; dword ptr [ebp+12]:  prcl
;
public IIDD16_Exclude@8
IIDD16_Exclude@8:
	push	ebp
	mov	ebp,esp
	push	ecx
	sub	esp,60
	push	dword ptr [ebp+8]	;dwPDevice: dword->dword
	call	SMapLS_IP_EBP_12
	push	eax
	call	dword ptr [pfnQT_Thunk_thk3216]
	call	SUnMapLS_IP_EBP_12
	leave
	retn	8





;
public DD16_Unexclude@4
DD16_Unexclude@4:
	mov	cl,37
	jmp	IIDD16_Unexclude@4
public DD16_DoneDriver@4
DD16_DoneDriver@4:
	mov	cl,45
; DD16_Unexclude(16) = DD16_Unexclude(32) {}
;
; dword ptr [ebp+8]:  dwPDevice
;
public IIDD16_Unexclude@4
IIDD16_Unexclude@4:
	push	ebp
	mov	ebp,esp
	push	ecx
	sub	esp,60
	push	dword ptr [ebp+8]	;dwPDevice: dword->dword
	call	dword ptr [pfnQT_Thunk_thk3216]
	leave
	retn	4





;
public DD16_Stretch@56
DD16_Stretch@56:
	mov	cl,36
; DD16_Stretch(16) = DD16_Stretch(32) {}
;
; dword ptr [ebp+8]:  DstPtr
; dword ptr [ebp+12]:  DstPitch
; dword ptr [ebp+16]:  DstBPP
; dword ptr [ebp+20]:  DstX
; dword ptr [ebp+24]:  DstY
; dword ptr [ebp+28]:  DstDX
; dword ptr [ebp+32]:  DstDY
; dword ptr [ebp+36]:  SrcPtr
; dword ptr [ebp+40]:  SrcPitch
; dword ptr [ebp+44]:  SrcBPP
; dword ptr [ebp+48]:  SrcX
; dword ptr [ebp+52]:  SrcY
; dword ptr [ebp+56]:  SrcDX
; dword ptr [ebp+60]:  SrcDY
;
public IIDD16_Stretch@56
IIDD16_Stretch@56:
	push	ebp
	mov	ebp,esp
	push	ecx
	sub	esp,60
	push	dword ptr [ebp+8]	;DstPtr: dword->dword
	push	word ptr [ebp+12]	;DstPitch: dword->word
	push	word ptr [ebp+16]	;DstBPP: dword->word
	push	word ptr [ebp+20]	;DstX: dword->word
	push	word ptr [ebp+24]	;DstY: dword->word
	push	word ptr [ebp+28]	;DstDX: dword->word
	push	word ptr [ebp+32]	;DstDY: dword->word
	push	dword ptr [ebp+36]	;SrcPtr: dword->dword
	push	word ptr [ebp+40]	;SrcPitch: dword->word
	push	word ptr [ebp+44]	;SrcBPP: dword->word
	push	word ptr [ebp+48]	;SrcX: dword->word
	push	word ptr [ebp+52]	;SrcY: dword->word
	push	word ptr [ebp+56]	;SrcDX: dword->word
	push	word ptr [ebp+60]	;SrcDY: dword->word
	call	dword ptr [pfnQT_Thunk_thk3216]
	cwde
	leave
	retn	56





;
public DD16_SelectPalette@12
DD16_SelectPalette@12:
	mov	cl,35
; DD16_SelectPalette(16) = DD16_SelectPalette(32) {}
;
; dword ptr [ebp+8]:  hDC
; dword ptr [ebp+12]:  hPalette
; dword ptr [ebp+16]:  f
;
public IIDD16_SelectPalette@12
IIDD16_SelectPalette@12:
	push	ebp
	mov	ebp,esp
	push	ecx
	sub	esp,60
	push	word ptr [ebp+8]	;hDC: dword->word
	push	word ptr [ebp+12]	;hPalette: dword->word
	push	word ptr [ebp+16]	;f: dword->word
	call	dword ptr [pfnQT_Thunk_thk3216]
	leave
	retn	12





;
public DD16_InquireVisRgn@4
DD16_InquireVisRgn@4:
	mov	cl,34
; DD16_InquireVisRgn(16) = DD16_InquireVisRgn(32) {}
;
; dword ptr [ebp+8]:  hDC
;
public IIDD16_InquireVisRgn@4
IIDD16_InquireVisRgn@4:
	push	ebp
	mov	ebp,esp
	push	ecx
	sub	esp,60
	push	word ptr [ebp+8]	;hDC: dword->word
	call	dword ptr [pfnQT_Thunk_thk3216]
	movzx	eax,ax
	leave
	retn	4





;
public DD16_GetPaletteEntries@12
DD16_GetPaletteEntries@12:
	mov	cl,31
	jmp	IIDD16_GetPaletteEntries@12
public DD16_SetPaletteEntries@12
DD16_SetPaletteEntries@12:
	mov	cl,32
; DD16_GetPaletteEntries(16) = DD16_GetPaletteEntries(32) {}
;
; dword ptr [ebp+8]:  dwBase
; dword ptr [ebp+12]:  dwNum
; dword ptr [ebp+16]:  lpPaletteEntries
;
public IIDD16_GetPaletteEntries@12
IIDD16_GetPaletteEntries@12:
	push	ebp
	mov	ebp,esp
	push	ecx
	sub	esp,60
	push	dword ptr [ebp+8]	;dwBase: dword->dword
	push	dword ptr [ebp+12]	;dwNum: dword->dword
	call	SMapLS_IP_EBP_16
	push	eax
	call	dword ptr [pfnQT_Thunk_thk3216]
	cwde
	call	SUnMapLS_IP_EBP_16
	leave
	retn	12





;
public DDThunk16_SetEntries@4
DDThunk16_SetEntries@4:
	mov	cx, (1 SHL 10) + (0 SHL 8) + 20
; DDThunk16_SetEntries(16) = DDThunk16_SetEntries(32) {}
;
; dword ptr [ebp+8]:  lpSetEntriesData
;
public IIDDThunk16_SetEntries@4
IIDDThunk16_SetEntries@4:
	call	dword ptr [pfnFT_Prolog_thk3216]
	xor	eax,eax
	push	eax
	sub	esp,28
	mov	esi,[ebp+8]
	or	esi,esi
	jz	@F
	or	byte ptr [esi], 0
	or	byte ptr [esi + 27], 0
@@:
	mov	esi,[ebp+8]
	or	esi,esi
	jnz	L2
	push	esi
	jmp	L3
L2:
	lea	edi,[ebp-96]
	push	edi	;lpSetEntriesData: lpstruct32->lpstruct16
	or	dword ptr [ebp-20],01h	;Set flag to fixup ESP-rel argument.
	mov	ecx,4
	rep	movsd
	lodsd	;lpEntries  near32->far16
	call	SMapLS
	mov	[ebp-68],edx
	stosd
	movsd
	movsd
L3:
	call	FT_Thunk
	shrd	ebx,edx,16
	mov	bx,ax
	mov	edi,[ebp+8]
	or	edi,edi
	jz	L4
	lea	esi,[ebp-96]	;lpSetEntriesData  Struct16->Struct32
	mov	ecx,4
	rep	movsd
	lodsd	;lpEntries   far16->near32
	push	eax
	call	MapSL
	stosd
	movsd
	movsd
L4:
	mov	ecx, [ebp-68]	;lpEntries
	call	SUnMapLS
	jmp	FT_Exit4





;
public DDThunk16_GetFlipStatus@4
DDThunk16_GetFlipStatus@4:
	mov	cl,7
	jmp	IIDDThunk16_GetFlipStatus@4
public DDThunk16_CreatePalette@4
DDThunk16_CreatePalette@4:
	mov	cl,30
	jmp	IIDDThunk16_GetFlipStatus@4
public DDThunk16_CreateSurface@4
DDThunk16_CreateSurface@4:
	mov	cl,29
	jmp	IIDDThunk16_GetFlipStatus@4
public DDThunk16_CanCreateSurface@4
DDThunk16_CanCreateSurface@4:
	mov	cl,28
	jmp	IIDDThunk16_GetFlipStatus@4
public DDThunk16_WaitForVerticalBlank@4
DDThunk16_WaitForVerticalBlank@4:
	mov	cl,27
	jmp	IIDDThunk16_GetFlipStatus@4
public DDThunk16_DestroyDriver@4
DDThunk16_DestroyDriver@4:
	mov	cl,26
	jmp	IIDDThunk16_GetFlipStatus@4
public DDThunk16_SetMode@4
DDThunk16_SetMode@4:
	mov	cl,25
	jmp	IIDDThunk16_GetFlipStatus@4
public DDThunk16_GetScanLine@4
DDThunk16_GetScanLine@4:
	mov	cl,24
	jmp	IIDDThunk16_GetFlipStatus@4
public DDThunk16_SetExclusiveMode@4
DDThunk16_SetExclusiveMode@4:
	mov	cl,23
	jmp	IIDDThunk16_GetFlipStatus@4
public DDThunk16_FlipToGDISurface@4
DDThunk16_FlipToGDISurface@4:
	mov	cl,22
	jmp	IIDDThunk16_GetFlipStatus@4
public DDThunk16_DestroyPalette@4
DDThunk16_DestroyPalette@4:
	mov	cl,21
	jmp	IIDDThunk16_GetFlipStatus@4
public DDThunk16_DestroySurface@4
DDThunk16_DestroySurface@4:
	mov	cl,19
	jmp	IIDDThunk16_GetFlipStatus@4
public DDThunk16_Flip@4
DDThunk16_Flip@4:
	mov	cl,18
	jmp	IIDDThunk16_GetFlipStatus@4
public DDThunk16_Blt@4
DDThunk16_Blt@4:
	mov	cl,17
	jmp	IIDDThunk16_GetFlipStatus@4
public DDThunk16_Lock@4
DDThunk16_Lock@4:
	mov	cl,16
	jmp	IIDDThunk16_GetFlipStatus@4
public DDThunk16_Unlock@4
DDThunk16_Unlock@4:
	mov	cl,15
	jmp	IIDDThunk16_GetFlipStatus@4
public DDThunk16_AddAttachedSurface@4
DDThunk16_AddAttachedSurface@4:
	mov	cl,14
	jmp	IIDDThunk16_GetFlipStatus@4
public DDThunk16_SetColorKey@4
DDThunk16_SetColorKey@4:
	mov	cl,13
	jmp	IIDDThunk16_GetFlipStatus@4
public DDThunk16_SetClipList@4
DDThunk16_SetClipList@4:
	mov	cl,12
	jmp	IIDDThunk16_GetFlipStatus@4
public DDThunk16_UpdateOverlay@4
DDThunk16_UpdateOverlay@4:
	mov	cl,11
	jmp	IIDDThunk16_GetFlipStatus@4
public DDThunk16_SetOverlayPosition@4
DDThunk16_SetOverlayPosition@4:
	mov	cl,10
	jmp	IIDDThunk16_GetFlipStatus@4
public DDThunk16_SetPalette@4
DDThunk16_SetPalette@4:
	mov	cl,9
	jmp	IIDDThunk16_GetFlipStatus@4
public DDThunk16_GetBltStatus@4
DDThunk16_GetBltStatus@4:
	mov	cl,8
; DDThunk16_GetFlipStatus(16) = DDThunk16_GetFlipStatus(32) {}
;
; dword ptr [ebp+8]:  lpGetFlipStatusData
;
public IIDDThunk16_GetFlipStatus@4
IIDDThunk16_GetFlipStatus@4:
	push	ebp
	mov	ebp,esp
	push	ecx
	sub	esp,60
	call	SMapLS_IP_EBP_8
	push	eax
	call	dword ptr [pfnQT_Thunk_thk3216]
	shl	eax,16
	shrd	eax,edx,16
	call	SUnMapLS_IP_EBP_8
	leave
	retn	4





;
public DCIIsBanked@4
DCIIsBanked@4:
	mov	cl,6
; DCIIsBanked(16) = DCIIsBanked(32) {}
;
; dword ptr [ebp+8]:  hdc
;
public IIDCIIsBanked@4
IIDCIIsBanked@4:
	push	ebp
	mov	ebp,esp
	push	ecx
	sub	esp,60
	push	word ptr [ebp+8]	;hdc: dword->word
	call	dword ptr [pfnQT_Thunk_thk3216]
	cwde
	leave
	retn	4





;
public DCIOpenProvider@0
DCIOpenProvider@0:
	mov	cl,5
; DCIOpenProvider(16) = DCIOpenProvider(32) {}
;
;
public IIDCIOpenProvider@0
IIDCIOpenProvider@0:
	push	ebp
	mov	ebp,esp
	push	ecx
	sub	esp,60
	call	dword ptr [pfnQT_Thunk_thk3216]
	movzx	eax,ax
	leave
	retn





;
public DCICloseProvider@4
DCICloseProvider@4:
	mov	cl,4
	jmp	IIDCICloseProvider@4
public DD16_SetCertified@4
DD16_SetCertified@4:
	mov	cl,52
	jmp	IIDCICloseProvider@4
public DD16_ReleaseDC@4
DD16_ReleaseDC@4:
	mov	cl,39
	jmp	IIDCICloseProvider@4
public DD16_EnableReboot@4
DD16_EnableReboot@4:
	mov	cl,33
; DCICloseProvider(16) = DCICloseProvider(32) {}
;
; dword ptr [ebp+8]:  hdc
;
public IIDCICloseProvider@4
IIDCICloseProvider@4:
	push	ebp
	mov	ebp,esp
	push	ecx
	sub	esp,60
	push	word ptr [ebp+8]	;hdc: dword->word
	call	dword ptr [pfnQT_Thunk_thk3216]
	leave
	retn	4





;
public DCICreatePrimary32@8
DCICreatePrimary32@8:
	mov	cl,3
; DCICreatePrimary32(16) = DCICreatePrimary32(32) {}
;
; dword ptr [ebp+8]:  hdc
; dword ptr [ebp+12]:  lpSurface
;
public IIDCICreatePrimary32@8
IIDCICreatePrimary32@8:
	push	ebp
	mov	ebp,esp
	push	ecx
	sub	esp,60
	push	word ptr [ebp+8]	;hdc: dword->word
	call	SMapLS_IP_EBP_12
	push	eax
	call	dword ptr [pfnQT_Thunk_thk3216]
	cwde
	call	SUnMapLS_IP_EBP_12
	leave
	retn	8





;
public DCIEndAccess@4
DCIEndAccess@4:
	mov	cl,1
	jmp	IIDCIEndAccess@4
public DD16_GetDriverFns@4
DD16_GetDriverFns@4:
	mov	cl,44
	jmp	IIDCIEndAccess@4
public DD16_GetHALInfo@4
DD16_GetHALInfo@4:
	mov	cl,43
	jmp	IIDCIEndAccess@4
public DCIDestroy32@4
DCIDestroy32@4:
	mov	cl,2
; DCIEndAccess(16) = DCIEndAccess(32) {}
;
; dword ptr [ebp+8]:  pdci
;
public IIDCIEndAccess@4
IIDCIEndAccess@4:
	push	ebp
	mov	ebp,esp
	push	ecx
	sub	esp,60
	call	SMapLS_IP_EBP_8
	push	eax
	call	dword ptr [pfnQT_Thunk_thk3216]
	call	SUnMapLS_IP_EBP_8
	leave
	retn	4





;
public DCIBeginAccess@20
DCIBeginAccess@20:
	mov	cl,0
; DCIBeginAccess(16) = DCIBeginAccess(32) {}
;
; dword ptr [ebp+8]:  pdci
; dword ptr [ebp+12]:  x
; dword ptr [ebp+16]:  y
; dword ptr [ebp+20]:  dx
; dword ptr [ebp+24]:  dy
;
public IIDCIBeginAccess@20
IIDCIBeginAccess@20:
	push	ebp
	mov	ebp,esp
	push	ecx
	sub	esp,60
	call	SMapLS_IP_EBP_8
	push	eax
	push	word ptr [ebp+12]	;x: dword->word
	push	word ptr [ebp+16]	;y: dword->word
	push	word ptr [ebp+20]	;dx: dword->word
	push	word ptr [ebp+24]	;dy: dword->word
	call	dword ptr [pfnQT_Thunk_thk3216]
	cwde
	call	SUnMapLS_IP_EBP_8
	leave
	retn	20




ELSE
;************************* START OF 16-BIT CODE *************************




	OPTION SEGMENT:USE16
	.model LARGE,PASCAL


	.code	ddraw



externDef DCIBeginAccess:far16
externDef DCIEndAccess:far16
externDef DCIDestroy:far16
externDef DCICreatePrimary32:far16
externDef DCICloseProvider:far16
externDef DCIOpenProvider:far16
externDef DCIIsBanked:far16
externDef DDThunk16_GetFlipStatus:far16
externDef DDThunk16_GetBltStatus:far16
externDef DDThunk16_SetPalette:far16
externDef DDThunk16_SetOverlayPosition:far16
externDef DDThunk16_UpdateOverlay:far16
externDef DDThunk16_SetClipList:far16
externDef DDThunk16_SetColorKey:far16
externDef DDThunk16_AddAttachedSurface:far16
externDef DDThunk16_Unlock:far16
externDef DDThunk16_Lock:far16
externDef DDThunk16_Blt:far16
externDef DDThunk16_Flip:far16
externDef DDThunk16_DestroySurface:far16
externDef DDThunk16_SetEntries:far16
externDef DDThunk16_DestroyPalette:far16
externDef DDThunk16_FlipToGDISurface:far16
externDef DDThunk16_SetExclusiveMode:far16
externDef DDThunk16_GetScanLine:far16
externDef DDThunk16_SetMode:far16
externDef DDThunk16_DestroyDriver:far16
externDef DDThunk16_WaitForVerticalBlank:far16
externDef DDThunk16_CanCreateSurface:far16
externDef DDThunk16_CreateSurface:far16
externDef DDThunk16_CreatePalette:far16
externDef DD16_GetPaletteEntries:far16
externDef DD16_SetPaletteEntries:far16
externDef DD16_EnableReboot:far16
externDef DD16_InquireVisRgn:far16
externDef DD16_SelectPalette:far16
externDef DD16_Stretch:far16
externDef DD16_Unexclude:far16
externDef DD16_Exclude:far16
externDef DD16_ReleaseDC:far16
externDef DD16_GetDC:far16
externDef DD16_SafeMode:far16
externDef DD16_ChangeDisplaySettings:far16
externDef DD16_GetHALInfo:far16
externDef DD16_GetDriverFns:far16
externDef DD16_DoneDriver:far16
externDef DD16_SetEventHandle:far16
externDef ModeX_Flip:far16
externDef ModeX_RestoreMode:far16
externDef ModeX_SetMode:far16
externDef ModeX_SetPaletteEntries:far16
externDef DD16_IsWin95MiniDriver:far16
externDef DD16_SetCertified:far16
externDef DD16_GetMonitorRefreshRateRanges:far16
externDef DD16_GetMonitorMaxSize:far16


FT_thk3216TargetTable label word
	dw	offset DCIBeginAccess
	dw	   seg DCIBeginAccess
	dw	offset DCIEndAccess
	dw	   seg DCIEndAccess
	dw	offset DCIDestroy
	dw	   seg DCIDestroy
	dw	offset DCICreatePrimary32
	dw	   seg DCICreatePrimary32
	dw	offset DCICloseProvider
	dw	   seg DCICloseProvider
	dw	offset DCIOpenProvider
	dw	   seg DCIOpenProvider
	dw	offset DCIIsBanked
	dw	   seg DCIIsBanked
	dw	offset DDThunk16_GetFlipStatus
	dw	   seg DDThunk16_GetFlipStatus
	dw	offset DDThunk16_GetBltStatus
	dw	   seg DDThunk16_GetBltStatus
	dw	offset DDThunk16_SetPalette
	dw	   seg DDThunk16_SetPalette
	dw	offset DDThunk16_SetOverlayPosition
	dw	   seg DDThunk16_SetOverlayPosition
	dw	offset DDThunk16_UpdateOverlay
	dw	   seg DDThunk16_UpdateOverlay
	dw	offset DDThunk16_SetClipList
	dw	   seg DDThunk16_SetClipList
	dw	offset DDThunk16_SetColorKey
	dw	   seg DDThunk16_SetColorKey
	dw	offset DDThunk16_AddAttachedSurface
	dw	   seg DDThunk16_AddAttachedSurface
	dw	offset DDThunk16_Unlock
	dw	   seg DDThunk16_Unlock
	dw	offset DDThunk16_Lock
	dw	   seg DDThunk16_Lock
	dw	offset DDThunk16_Blt
	dw	   seg DDThunk16_Blt
	dw	offset DDThunk16_Flip
	dw	   seg DDThunk16_Flip
	dw	offset DDThunk16_DestroySurface
	dw	   seg DDThunk16_DestroySurface
	dw	offset DDThunk16_SetEntries
	dw	   seg DDThunk16_SetEntries
	dw	offset DDThunk16_DestroyPalette
	dw	   seg DDThunk16_DestroyPalette
	dw	offset DDThunk16_FlipToGDISurface
	dw	   seg DDThunk16_FlipToGDISurface
	dw	offset DDThunk16_SetExclusiveMode
	dw	   seg DDThunk16_SetExclusiveMode
	dw	offset DDThunk16_GetScanLine
	dw	   seg DDThunk16_GetScanLine
	dw	offset DDThunk16_SetMode
	dw	   seg DDThunk16_SetMode
	dw	offset DDThunk16_DestroyDriver
	dw	   seg DDThunk16_DestroyDriver
	dw	offset DDThunk16_WaitForVerticalBlank
	dw	   seg DDThunk16_WaitForVerticalBlank
	dw	offset DDThunk16_CanCreateSurface
	dw	   seg DDThunk16_CanCreateSurface
	dw	offset DDThunk16_CreateSurface
	dw	   seg DDThunk16_CreateSurface
	dw	offset DDThunk16_CreatePalette
	dw	   seg DDThunk16_CreatePalette
	dw	offset DD16_GetPaletteEntries
	dw	   seg DD16_GetPaletteEntries
	dw	offset DD16_SetPaletteEntries
	dw	   seg DD16_SetPaletteEntries
	dw	offset DD16_EnableReboot
	dw	   seg DD16_EnableReboot
	dw	offset DD16_InquireVisRgn
	dw	   seg DD16_InquireVisRgn
	dw	offset DD16_SelectPalette
	dw	   seg DD16_SelectPalette
	dw	offset DD16_Stretch
	dw	   seg DD16_Stretch
	dw	offset DD16_Unexclude
	dw	   seg DD16_Unexclude
	dw	offset DD16_Exclude
	dw	   seg DD16_Exclude
	dw	offset DD16_ReleaseDC
	dw	   seg DD16_ReleaseDC
	dw	offset DD16_GetDC
	dw	   seg DD16_GetDC
	dw	offset DD16_SafeMode
	dw	   seg DD16_SafeMode
	dw	offset DD16_ChangeDisplaySettings
	dw	   seg DD16_ChangeDisplaySettings
	dw	offset DD16_GetHALInfo
	dw	   seg DD16_GetHALInfo
	dw	offset DD16_GetDriverFns
	dw	   seg DD16_GetDriverFns
	dw	offset DD16_DoneDriver
	dw	   seg DD16_DoneDriver
	dw	offset DD16_SetEventHandle
	dw	   seg DD16_SetEventHandle
	dw	offset ModeX_Flip
	dw	   seg ModeX_Flip
	dw	offset ModeX_RestoreMode
	dw	   seg ModeX_RestoreMode
	dw	offset ModeX_SetMode
	dw	   seg ModeX_SetMode
	dw	offset ModeX_SetPaletteEntries
	dw	   seg ModeX_SetPaletteEntries
	dw	offset DD16_IsWin95MiniDriver
	dw	   seg DD16_IsWin95MiniDriver
	dw	offset DD16_SetCertified
	dw	   seg DD16_SetCertified
	dw	offset DD16_GetMonitorRefreshRateRanges
	dw	   seg DD16_GetMonitorRefreshRateRanges
	dw	offset DD16_GetMonitorMaxSize
	dw	   seg DD16_GetMonitorMaxSize




	.data

public thk3216_ThunkData16	;This symbol must be exported.
thk3216_ThunkData16	dd	3130534ch	;Protocol 'LS01'
	dd	0210141h	;Checksum
	dw	offset FT_thk3216TargetTable
	dw	seg    FT_thk3216TargetTable
	dd	0	;First-time flag.



	.code ddraw


externDef ThunkConnect16:far16

public thk3216_ThunkConnect16
thk3216_ThunkConnect16:
	pop	ax
	pop	dx
	push	seg    thk3216_ThunkData16
	push	offset thk3216_ThunkData16
	push	seg    thk3216_ThkData32
	push	offset thk3216_ThkData32
	push	cs
	push	dx
	push	ax
	jmp	ThunkConnect16
thk3216_ThkData32 label byte
	db	"thk3216_ThunkData32",0





ENDIF
END
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\ddrawex\dx3inc\d3d.h ===
/*==========================================================================;
 *
 *  Copyright (C) 1995-1996 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       d3d.h
 *  Content:    Direct3D include file
 *
 ***************************************************************************/

#ifndef _D3D_H_
#define _D3D_H_

#include <stdlib.h>

#ifdef _WIN32
#define COM_NO_WINDOWS_H
#include <objbase.h>
#else
#include "d3dcom.h"
#endif

#ifdef _WIN32
#define D3DAPI WINAPI
#else
#define D3DAPI
#endif

/*
 * Interface IID's
 */
#if defined( _WIN32 ) && !defined( _NO_COM)
DEFINE_GUID( IID_IDirect3D,             0x3BBA0080,0x2421,0x11CF,0xA3,0x1A,0x00,0xAA,0x00,0xB9,0x33,0x56 );
DEFINE_GUID( IID_IDirect3DTexture,      0x2CDCD9E0,0x25A0,0x11CF,0xA3,0x1A,0x00,0xAA,0x00,0xB9,0x33,0x56 );
DEFINE_GUID( IID_IDirect3DLight,        0x4417C142,0x33AD,0x11CF,0x81,0x6F,0x00,0x00,0xC0,0x20,0x15,0x6E );
DEFINE_GUID( IID_IDirect3DMaterial,     0x4417C144,0x33AD,0x11CF,0x81,0x6F,0x00,0x00,0xC0,0x20,0x15,0x6E );
DEFINE_GUID( IID_IDirect3DExecuteBuffer,0x4417C145,0x33AD,0x11CF,0x81,0x6F,0x00,0x00,0xC0,0x20,0x15,0x6E );
DEFINE_GUID( IID_IDirect3DViewport,     0x4417C146,0x33AD,0x11CF,0x81,0x6F,0x00,0x00,0xC0,0x20,0x15,0x6E );
#endif

#ifdef __cplusplus
extern "C" {
#endif

/*
 * Data structures
 */
#ifdef __cplusplus

/* 'struct' not 'class' per the way DECLARE_INTERFACE_ is defined */
struct IDirect3D;
struct IDirect3DDevice;
struct IDirect3DExecuteBuffer;
struct IDirect3DLight;
struct IDirect3DMaterial;
struct IDirect3DTexture;
struct IDirect3DViewport;
typedef struct IDirect3D                *LPDIRECT3D;
typedef struct IDirect3DDevice          *LPDIRECT3DDEVICE;
typedef struct IDirect3DExecuteBuffer   *LPDIRECT3DEXECUTEBUFFER;
typedef struct IDirect3DLight           *LPDIRECT3DLIGHT;
typedef struct IDirect3DMaterial        *LPDIRECT3DMATERIAL;
typedef struct IDirect3DTexture         *LPDIRECT3DTEXTURE;
typedef struct IDirect3DViewport        *LPDIRECT3DVIEWPORT;

#else

typedef struct IDirect3D                *LPDIRECT3D;
typedef struct IDirect3DDevice          *LPDIRECT3DDEVICE;
typedef struct IDirect3DExecuteBuffer   *LPDIRECT3DEXECUTEBUFFER;
typedef struct IDirect3DLight           *LPDIRECT3DLIGHT;
typedef struct IDirect3DMaterial        *LPDIRECT3DMATERIAL;
typedef struct IDirect3DTexture         *LPDIRECT3DTEXTURE;
typedef struct IDirect3DViewport        *LPDIRECT3DVIEWPORT;

#endif

#include "d3dtypes.h"
#include "d3dcaps.h"

/*
 * IDirect3D
 */
#undef INTERFACE
#define INTERFACE IDirect3D
DECLARE_INTERFACE_(IDirect3D, IUnknown)
{
    /*** IUnknown methods ***/
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID* ppvObj) PURE;
    STDMETHOD_(ULONG, AddRef) (THIS) PURE;
    STDMETHOD_(ULONG, Release) (THIS) PURE;
    /*** IDirect3D methods ***/
    STDMETHOD(Initialize) (THIS_ REFIID) PURE;
    STDMETHOD(EnumDevices)(THIS_ LPD3DENUMDEVICESCALLBACK, LPVOID) PURE;
    STDMETHOD(CreateLight) (THIS_ LPDIRECT3DLIGHT*, IUnknown*) PURE;
    STDMETHOD(CreateMaterial) (THIS_ LPDIRECT3DMATERIAL*, IUnknown*) PURE;
    STDMETHOD(CreateViewport) (THIS_ LPDIRECT3DVIEWPORT*, IUnknown*) PURE;
    STDMETHOD(FindDevice)(THIS_ LPD3DFINDDEVICESEARCH, LPD3DFINDDEVICERESULT) PURE;
};

#if !defined(__cplusplus) || defined(CINTERFACE)
#define IDirect3D_QueryInterface(p, a, b)         (p)->lpVtbl->QueryInterface(p, a, b)
#define IDirect3D_AddRef(p)                       (p)->lpVtbl->AddRef(p)
#define IDirect3D_Release(p)                      (p)->lpVtbl->Release(p)
#define IDirect3D_Initialize(p, a)                (p)->lpVtbl->Initialize(p, a)
#define IDirect3D_EnumDevices(p, a, b)            (p)->lpVtbl->EnumDevices(p, a, b)
#define IDirect3D_CreateLight(p, a, b)            (p)->lpVtbl->CreateLight(p, a, b)
#define IDirect3D_CreateMaterial(p, a, b)         (p)->lpVtbl->CreateMaterial(p, a, b)
#define IDirect3D_CreateViewport(p, a, b)         (p)->lpVtbl->CreateViewport(p, a, b)
#define IDirect3D_FindDevice(p, a, b)             (p)->lpVtbl->FindDevice(p, a, b)
#endif

/*
 * IDirect3DDevice
 */
#undef INTERFACE
#define INTERFACE IDirect3DDevice
DECLARE_INTERFACE_(IDirect3DDevice, IUnknown)
{
    /*** IUnknown methods ***/
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID* ppvObj) PURE;
    STDMETHOD_(ULONG, AddRef) (THIS) PURE;
    STDMETHOD_(ULONG, Release) (THIS) PURE;
    /*** IDirect3DDevice methods ***/
    STDMETHOD(Initialize) (THIS_ LPDIRECT3D, LPGUID, LPD3DDEVICEDESC) PURE;
    STDMETHOD(GetCaps) (THIS_ LPD3DDEVICEDESC, LPD3DDEVICEDESC) PURE;
    STDMETHOD(SwapTextureHandles) (THIS_ LPDIRECT3DTEXTURE, LPDIRECT3DTEXTURE) PURE;
    STDMETHOD(CreateExecuteBuffer) (THIS_ LPD3DEXECUTEBUFFERDESC, LPDIRECT3DEXECUTEBUFFER*, IUnknown*) PURE;
    STDMETHOD(GetStats) (THIS_ LPD3DSTATS) PURE;
    STDMETHOD(Execute) (THIS_ LPDIRECT3DEXECUTEBUFFER, LPDIRECT3DVIEWPORT, DWORD) PURE;
    STDMETHOD(AddViewport) (THIS_ LPDIRECT3DVIEWPORT) PURE;
    STDMETHOD(DeleteViewport) (THIS_ LPDIRECT3DVIEWPORT) PURE;
    STDMETHOD(NextViewport) (THIS_ LPDIRECT3DVIEWPORT, LPDIRECT3DVIEWPORT*, DWORD) PURE;
    STDMETHOD(Pick) (THIS_ LPDIRECT3DEXECUTEBUFFER, LPDIRECT3DVIEWPORT, DWORD, LPD3DRECT) PURE;
    STDMETHOD(GetPickRecords)(THIS_ LPDWORD, LPD3DPICKRECORD) PURE;
    STDMETHOD(EnumTextureFormats) (THIS_ LPD3DENUMTEXTUREFORMATSCALLBACK, LPVOID) PURE;
    STDMETHOD(CreateMatrix) (THIS_ LPD3DMATRIXHANDLE) PURE;
    STDMETHOD(SetMatrix) (THIS_ D3DMATRIXHANDLE, LPD3DMATRIX) PURE;
    STDMETHOD(GetMatrix) (THIS_ D3DMATRIXHANDLE, LPD3DMATRIX) PURE;
    STDMETHOD(DeleteMatrix) (THIS_ D3DMATRIXHANDLE) PURE;
    STDMETHOD_(HRESULT, BeginScene) (THIS) PURE;
    STDMETHOD_(HRESULT, EndScene) (THIS) PURE;
    STDMETHOD(GetDirect3D) (THIS_ LPDIRECT3D*) PURE;
};

#if !defined(__cplusplus) || defined(CINTERFACE)
#define IDirect3DDevice_QueryInterface(p, a, b)         (p)->lpVtbl->QueryInterface(p, a, b)
#define IDirect3DDevice_AddRef(p)                       (p)->lpVtbl->AddRef(p)
#define IDirect3DDevice_Release(p)                      (p)->lpVtbl->Release(p)
#define IDirect3DDevice_Initialize(p, a, b, c)          (p)->lpVtbl->Initialize(p, a, b, c)
#define IDirect3DDevice_GetCaps(p, a, b)                (p)->lpVtbl->GetCaps(p, a, b)
#define IDirect3DDevice_SwapTextureHandles(p, a, b)     (p)->lpVtbl->SwapTextureHandles(p, a, b)
#define IDirect3DDevice_CreateExecuteBuffer(p, a, b, c) (p)->lpVtbl->CreateExecuteBuffer(p, a, b, c)
#define IDirect3DDevice_GetStats(p, a)                  (p)->lpVtbl->CreateViewport(p, a)
#define IDirect3DDevice_Execute(p, a, b, c)             (p)->lpVtbl->Execute(p, a, b, c)
#define IDirect3DDevice_AddViewport(p, a)               (p)->lpVtbl->AddViewport(p, a)
#define IDirect3DDevice_DeleteViewport(p, a)            (p)->lpVtbl->DeleteViewport(p, a)
#define IDirect3DDevice_NextViewport(p, a, b)           (p)->lpVtbl->NextViewport(p, a, b)
#define IDirect3DDevice_Pick(p, a, b, c, d)             (p)->lpVtbl->Pick(p, a, b, c, d)
#define IDirect3DDevice_GetPickRecords(p, a, b)         (p)->lpVtbl->GetPickRecords(p, a, b)
#define IDirect3DDevice_EnumTextureFormats(p, a, b)     (p)->lpVtbl->EnumTextureFormats(p, a, b)
#define IDirect3DDevice_CreateMatrix(p, a)              (p)->lpVtbl->CreateMatrix(p, a)
#define IDirect3DDevice_SetMatrix(p, a, b)              (p)->lpVtbl->SetMatrix(p, a, b)
#define IDirect3DDevice_GetMatrix(p, a, b)              (p)->lpVtbl->GetMatrix(p, a, b)
#define IDirect3DDevice_DeleteMatrix(p, a)              (p)->lpVtbl->DeleteMatrix(p, a)
#define IDirect3DDevice_BeginScene(p)                   (p)->lpVtbl->BeginScene(p)
#define IDirect3DDevice_EndScene(p)                     (p)->lpVtbl->EndScene(p)
#define IDirect3DDevice_GetDirect3D(p, a)               (p)->lpVtbl->GetDirect3D(p, a)
#endif

/*
 * IDirect3DExecuteBuffer
 */
#undef INTERFACE
#define INTERFACE IDirect3DExecuteBuffer
DECLARE_INTERFACE_(IDirect3DExecuteBuffer, IUnknown)
{
    /*** IUnknown methods ***/
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID* ppvObj) PURE;
    STDMETHOD_(ULONG, AddRef) (THIS) PURE;
    STDMETHOD_(ULONG, Release) (THIS) PURE;
    /*** IDirect3DExecuteBuffer methods ***/
    STDMETHOD(Initialize) (THIS_ LPDIRECT3DDEVICE, LPD3DEXECUTEBUFFERDESC) PURE;
    STDMETHOD(Lock) (THIS_ LPD3DEXECUTEBUFFERDESC) PURE;
    STDMETHOD_(HRESULT, Unlock) (THIS) PURE;
    STDMETHOD(SetExecuteData) (THIS_ LPD3DEXECUTEDATA) PURE;
    STDMETHOD(GetExecuteData) (THIS_ LPD3DEXECUTEDATA) PURE;
    STDMETHOD(Validate) (THIS_ LPDWORD, LPD3DVALIDATECALLBACK, LPVOID, DWORD) PURE;
    STDMETHOD(Optimize) (THIS_ DWORD) PURE;
};

#if !defined(__cplusplus) || defined(CINTERFACE)
#define IDirect3DExecuteBuffer_QueryInterface(p, a, b) (p)->lpVtbl->QueryInterface(p, a, b)
#define IDirect3DExecuteBuffer_AddRef(p)               (p)->lpVtbl->AddRef(p)
#define IDirect3DExecuteBuffer_Release(p)              (p)->lpVtbl->Release(p)
#define IDirect3DExecuteBuffer_Initialize(p, a, b)     (p)->lpVtbl->Initialize(p, a, b)
#define IDirect3DExecuteBuffer_Lock(p, a)              (p)->lpVtbl->Lock(p, a)
#define IDirect3DExecuteBuffer_Unlock(p)               (p)->lpVtbl->Unlock(p)
#define IDirect3DExecuteBuffer_SetExecuteData(p, a)    (p)->lpVtbl->SetExecuteData(p, a)
#define IDirect3DExecuteBuffer_Validate(p, a, b, c, d) (p)->lpVtbl->Validata(p, a, b, c, d)
#endif

/*
 * Flags for execute buffer calls
 */
#define D3DNEXT_NEXT    0x00000001l
#define D3DNEXT_HEAD    0x00000002l
#define D3DNEXT_TAIL    0x00000004l

/*
 * IDirect3DLight
 */
#undef INTERFACE
#define INTERFACE IDirect3DLight
DECLARE_INTERFACE_(IDirect3DLight, IUnknown)
{
    /*** IUnknown methods ***/
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID* ppvObj) PURE;
    STDMETHOD_(ULONG, AddRef) (THIS) PURE;
    STDMETHOD_(ULONG, Release) (THIS) PURE;
    /*** IDirect3DLight methods ***/
    STDMETHOD(Initialize) (THIS_ LPDIRECT3D) PURE;
    STDMETHOD(SetLight) (THIS_ LPD3DLIGHT) PURE;
    STDMETHOD(GetLight) (THIS_ LPD3DLIGHT) PURE;
};

#if !defined(__cplusplus) || defined(CINTERFACE)
#define IDirect3DLight_QueryInterface(p, a, b) (p)->lpVtbl->QueryInterface(p, a, b)
#define IDirect3DLight_AddRef(p)               (p)->lpVtbl->AddRef(p)
#define IDirect3DLight_Release(p)              (p)->lpVtbl->Release(p)
#define IDirect3DLight_Initialize(p, a)        (p)->lpVtbl->Initialize(p, a)
#define IDirect3DLight_SetLight(p, a)          (p)->lpVtbl->SetLight(p, a)
#define IDirect3DLight_GetLight(p, a)          (p)->lpVtbl->GetLight(p, a)
#endif

/*
 * IDirect3DMaterial
 */
#undef INTERFACE
#define INTERFACE IDirect3DMaterial
DECLARE_INTERFACE_(IDirect3DMaterial, IUnknown)
{
    /*** IUnknown methods ***/
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID* ppvObj) PURE;
    STDMETHOD_(ULONG, AddRef) (THIS) PURE;
    STDMETHOD_(ULONG, Release) (THIS) PURE;
    /*** IDirect3DMaterial methods ***/
    STDMETHOD(Initialize) (THIS_ LPDIRECT3D) PURE;
    STDMETHOD(SetMaterial) (THIS_ LPD3DMATERIAL) PURE;
    STDMETHOD(GetMaterial) (THIS_ LPD3DMATERIAL) PURE;
    STDMETHOD(GetHandle) (THIS_ LPDIRECT3DDEVICE, LPD3DMATERIALHANDLE) PURE;
    STDMETHOD_(HRESULT, Reserve) (THIS) PURE;
    STDMETHOD_(HRESULT, Unreserve) (THIS) PURE;
};

#if !defined(__cplusplus) || defined(CINTERFACE)
#define IDirect3DMaterial_QueryInterface(p, a, b) (p)->lpVtbl->QueryInterface(p, a, b)
#define IDirect3DMaterial_AddRef(p)               (p)->lpVtbl->AddRef(p)
#define IDirect3DMaterial_Release(p)              (p)->lpVtbl->Release(p)
#define IDirect3DMaterial_Initialize(p, a)        (p)->lpVtbl->Initialize(p, a)
#define IDirect3DMaterial_SetMaterial(p, a)       (p)->lpVtbl->SetMaterial(p, a)
#define IDirect3DMaterial_GetMaterial(p, a)       (p)->lpVtbl->GetMaterial(p, a)
#define IDirect3DMaterial_GetHandle(p, a, b)      (p)->lpVtbl->GetHandle(p, a, b)
#define IDirect3DMaterial_Reserve(p)              (p)->lpVtbl->Reserve(p)
#define IDirect3DMaterial_Unreserve(p)            (p)->lpVtbl->Unreserve(p)
#endif

/*
 * IDirect3DTexture
 */
#undef INTERFACE
#define INTERFACE IDirect3DTexture
DECLARE_INTERFACE_(IDirect3DTexture, IUnknown)
{
    /*** IUnknown methods ***/
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID* ppvObj) PURE;
    STDMETHOD_(ULONG, AddRef) (THIS) PURE;
    STDMETHOD_(ULONG, Release) (THIS) PURE;
    /*** IDirect3DTexture methods ***/
    STDMETHOD(Initialize) (THIS_ LPDIRECT3DDEVICE, LPDIRECTDRAWSURFACE) PURE;
    STDMETHOD(GetHandle) (THIS_ LPDIRECT3DDEVICE, LPD3DTEXTUREHANDLE) PURE;
    STDMETHOD(PaletteChanged) (THIS_ DWORD, DWORD) PURE;
    STDMETHOD(Load) (THIS_ LPDIRECT3DTEXTURE) PURE;
    STDMETHOD_(HRESULT, Unload) (THIS) PURE;
};

#if !defined(__cplusplus) || defined(CINTERFACE)
#define IDirect3DTexture_QueryInterface(p, a, b) (p)->lpVtbl->QueryInterface(p, a, b)
#define IDirect3DTexture_AddRef(p)               (p)->lpVtbl->AddRef(p)
#define IDirect3DTexture_Release(p)              (p)->lpVtbl->Release(p)
#define IDirect3DTexture_Initialize(p, a, b)     (p)->lpVtbl->Initialize(p, a, b)
#define IDirect3DTexture_GetHandle(p, a, b)      (p)->lpVtbl->GetHandle(p, a, b)
#define IDirect3DTexture_PaletteChanged(p, a, b) (p)->lpVtbl->PaletteChanged(p, a, b)
#define IDirect3DTexture_Load(p, a)              (p)->lpVtbl->Load(p, a)
#define IDirect3DTexture_Unload(p)               (p)->lpVtbl->Unload(p)
#endif

/*
 * IDirect3DViewport
 */
#undef INTERFACE
#define INTERFACE IDirect3DViewport
DECLARE_INTERFACE_(IDirect3DViewport, IUnknown)
{
    /*** IUnknown methods ***/
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID* ppvObj) PURE;
    STDMETHOD_(ULONG, AddRef) (THIS) PURE;
    STDMETHOD_(ULONG, Release) (THIS) PURE;
    /*** IDirect3DViewport methods ***/
    STDMETHOD(Initialize) (THIS_ LPDIRECT3D) PURE;
    STDMETHOD(GetViewport) (THIS_ LPD3DVIEWPORT) PURE;
    STDMETHOD(SetViewport) (THIS_ LPD3DVIEWPORT) PURE;
    STDMETHOD(TransformVertices) (THIS_ DWORD, LPD3DTRANSFORMDATA, DWORD, LPDWORD) PURE;
    STDMETHOD(LightElements) (THIS_ DWORD, LPD3DLIGHTDATA) PURE;
    STDMETHOD(SetBackground) (THIS_ D3DMATERIALHANDLE) PURE;
    STDMETHOD(GetBackground) (THIS_ LPD3DMATERIALHANDLE, LPBOOL) PURE;
    STDMETHOD(SetBackgroundDepth) (THIS_ LPDIRECTDRAWSURFACE) PURE;
    STDMETHOD(GetBackgroundDepth) (THIS_ LPDIRECTDRAWSURFACE*, LPBOOL) PURE;
    STDMETHOD(Clear) (THIS_ DWORD, LPD3DRECT, DWORD) PURE;
    STDMETHOD(AddLight) (THIS_ LPDIRECT3DLIGHT) PURE;
    STDMETHOD(DeleteLight) (THIS_ LPDIRECT3DLIGHT) PURE;
    STDMETHOD(NextLight) (THIS_ LPDIRECT3DLIGHT, LPDIRECT3DLIGHT*, DWORD) PURE;
};

#if !defined(__cplusplus) || defined(CINTERFACE)
#define IDirect3DViewport_QueryInterface(p, a, b)          (p)->lpVtbl->QueryInterface(p, a, b)
#define IDirect3DViewport_AddRef(p)                        (p)->lpVtbl->AddRef(p)
#define IDirect3DViewport_Release(p)                       (p)->lpVtbl->Release(p)
#define IDirect3DViewport_Initialize(p, a)                 (p)->lpVtbl->Initialize(p, a)
#define IDirect3DViewport_GetViewport(p, a)                (p)->lpVtbl->GetViewport(p, a)
#define IDirect3DViewport_SetViewport(p, a)                (p)->lpVtbl->SetViewport(p, a)
#define IDirect3DViewport_TransformVertices(p, a, b, c, d) (p)->lpVtbl->TransformVertices(p, a, b, c, d)
#define IDirect3DViewport_LightElements(p, a, b)           (p)->lpVtbl->LightElements(p, a, b)
#define IDirect3DViewport_SetBackground(p, a)              (p)->lpVtbl->SetBackground(p, a)
#define IDirect3DViewport_GetBackground(p, a, b)           (p)->lpVtbl->GetBackground(p, a, b)
#define IDirect3DViewport_Clear(p, a, b, c)                (p)->lpVtbl->Clear(p, a, b, c)
#define IDirect3DViewport_AddLight(p, a)                   (p)->lpVtbl->AddLight(p, a)
#define IDirect3DViewport_DeleteLight(p, a)                (p)->lpVtbl->DeleteLight(p, a)
#define IDirect3DViewport_NextLight(p, a, b, c)            (p)->lpVtbl->NextLight(p, a, b, c)
#endif

/*
 * Direct3D Errors
 * DirectDraw error codes are used when errors not specified here.
 */
#define D3D_OK                          DD_OK
#define D3DERR_BADMAJORVERSION          MAKE_DDHRESULT(700)
#define D3DERR_BADMINORVERSION          MAKE_DDHRESULT(701)

#define D3DERR_EXECUTE_CREATE_FAILED    MAKE_DDHRESULT(710)
#define D3DERR_EXECUTE_DESTROY_FAILED   MAKE_DDHRESULT(711)
#define D3DERR_EXECUTE_LOCK_FAILED      MAKE_DDHRESULT(712)
#define D3DERR_EXECUTE_UNLOCK_FAILED    MAKE_DDHRESULT(713)
#define D3DERR_EXECUTE_LOCKED           MAKE_DDHRESULT(714)
#define D3DERR_EXECUTE_NOT_LOCKED       MAKE_DDHRESULT(715)

#define D3DERR_EXECUTE_FAILED           MAKE_DDHRESULT(716)
#define D3DERR_EXECUTE_CLIPPED_FAILED   MAKE_DDHRESULT(717)

#define D3DERR_TEXTURE_NO_SUPPORT       MAKE_DDHRESULT(720)
#define D3DERR_TEXTURE_CREATE_FAILED    MAKE_DDHRESULT(721)
#define D3DERR_TEXTURE_DESTROY_FAILED   MAKE_DDHRESULT(722)
#define D3DERR_TEXTURE_LOCK_FAILED      MAKE_DDHRESULT(723)
#define D3DERR_TEXTURE_UNLOCK_FAILED    MAKE_DDHRESULT(724)
#define D3DERR_TEXTURE_LOAD_FAILED      MAKE_DDHRESULT(725)
#define D3DERR_TEXTURE_SWAP_FAILED      MAKE_DDHRESULT(726)
#define D3DERR_TEXTURE_LOCKED           MAKE_DDHRESULT(727)
#define D3DERR_TEXTURE_NOT_LOCKED       MAKE_DDHRESULT(728)
#define D3DERR_TEXTURE_GETSURF_FAILED   MAKE_DDHRESULT(729)

#define D3DERR_MATRIX_CREATE_FAILED     MAKE_DDHRESULT(730)
#define D3DERR_MATRIX_DESTROY_FAILED    MAKE_DDHRESULT(731)
#define D3DERR_MATRIX_SETDATA_FAILED    MAKE_DDHRESULT(732)
#define D3DERR_MATRIX_GETDATA_FAILED    MAKE_DDHRESULT(733)
#define D3DERR_SETVIEWPORTDATA_FAILED   MAKE_DDHRESULT(734)

#define D3DERR_MATERIAL_CREATE_FAILED   MAKE_DDHRESULT(740)
#define D3DERR_MATERIAL_DESTROY_FAILED  MAKE_DDHRESULT(741)
#define D3DERR_MATERIAL_SETDATA_FAILED  MAKE_DDHRESULT(742)
#define D3DERR_MATERIAL_GETDATA_FAILED  MAKE_DDHRESULT(743)

#define D3DERR_LIGHT_SET_FAILED         MAKE_DDHRESULT(750)

#define D3DERR_SCENE_IN_SCENE           MAKE_DDHRESULT(760)
#define D3DERR_SCENE_NOT_IN_SCENE       MAKE_DDHRESULT(761)
#define D3DERR_SCENE_BEGIN_FAILED       MAKE_DDHRESULT(762)
#define D3DERR_SCENE_END_FAILED         MAKE_DDHRESULT(763)

#ifdef __cplusplus
};
#endif

#endif /* _D3D_H_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\ddrawex\dx3inc\d3dhal.h ===
/*==========================================================================;
 *
 *  Copyright (C) 1995-1996 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:	d3dhal.h
 *  Content:	Direct3D HAL include file
 *@@BEGIN_MSINTERNAL
 *  History:
 *   Date	By	Reason
 *   ====	==	======
 *   03/11/95	stevela Initial revision.
 *		servank
 *   04/11/95   stevela	Context added to call blocks.
 *			Materials added. Required as lighting references
 *			handles.
 *			SetViewportData HAL function added.
 *   10/11/95	stevela	Pack structures for driver -p4 option...
 *   11/11/95	stevela Remove definition of D3DHALCreateDriver.
 *			Add lpDDSZ to D3DHAL_CONTEXTCREATEDATA.
 *			Definition of lpLocalVertexBuffer changed to
 *			LPD3DTLVERTEX.
 *   07/12/95	stevela Added texture swapping.
 *   18/12/95	stevela	Added GetState and GetMatrix.
 *   17/02/95	stevela Use execute buffers for tl and h vertex buffers
 *   23/02/95	dougrab Change all handles to DWORD
 *   02/03/96   colinmc Minor build fix
 *   17/04/96	stevela Use ddraw.h externally and ddrawp.h internally
 *@@END_MSINTERNAL
 *
 ***************************************************************************/

#ifndef _D3DHAL_H_
#define _D3DHAL_H_

//@@BEGIN_MSINTERNAL
#include "ddrawp.h"
#if 0
//@@END_MSINTERNAL
#include "ddraw.h"
//@@BEGIN_MSINTERNAL
#endif
//@@END_MSINTERNAL
#include "d3dtypes.h"
#include "d3dcaps.h"
#include "ddrawi.h"

/*
 * If the HAL driver does not implement clipping, it must reserve at least
 * this much space at the end of the LocalVertexBuffer for use by the HEL
 * clipping.  I.e. the vertex buffer contain dwNumVertices+dwNumClipVertices
 * vertices.  No extra space is needed by the HEL clipping in the
 * LocalHVertexBuffer.
 */
#define D3DHAL_NUMCLIPVERTICES	20

/*
 * If no dwNumVertices is given, this is what will be used.
 */
#define D3DHAL_DEFAULT_TL_NUM	((32 * 1024) / sizeof (D3DTLVERTEX))
#define D3DHAL_DEFAULT_H_NUM	((32 * 1024) / sizeof (D3DHVERTEX))

/* --------------------------------------------------------------
 * Instantiated by the HAL driver on driver connection.
 */
typedef struct _D3DHAL_GLOBALDRIVERDATA {
    DWORD		dwSize;			// Size of this structure
    D3DDEVICEDESC	hwCaps;			// Capabilities of the hardware
    DWORD		dwNumVertices;		// see following comment
    DWORD		dwNumClipVertices;	// see following comment
    DWORD		dwNumTextureFormats;	// Number of texture formats
    LPDDSURFACEDESC	lpTextureFormats;	// Pointer to texture formats
} D3DHAL_GLOBALDRIVERDATA;
typedef D3DHAL_GLOBALDRIVERDATA *LPD3DHAL_GLOBALDRIVERDATA;

/*
 * Regarding dwNumVertices, specify 0 if you are relying on the HEL to do
 * everything and you do not need the resultant TLVertex buffer to reside
 * in device memory.
 * The HAL driver will be asked to allocate dwNumVertices + dwNumClipVertices
 * in the case described above.
 */

/* --------------------------------------------------------------
 * Direct3D HAL Table.
 * Instantiated by the HAL driver on connection.
 *
 * Calls take the form of:
 *	retcode = HalCall(HalCallData* lpData);
 */
 
typedef DWORD	(__stdcall *LPD3DHAL_CONTEXTCREATECB)	(LPD3DHAL_CONTEXTCREATEDATA);
typedef DWORD	(__stdcall *LPD3DHAL_CONTEXTDESTROYCB)	(LPD3DHAL_CONTEXTDESTROYDATA);
typedef DWORD	(__stdcall *LPD3DHAL_CONTEXTDESTROYALLCB) (LPD3DHAL_CONTEXTDESTROYALLDATA);
typedef DWORD	(__stdcall *LPD3DHAL_SCENECAPTURECB)	(LPD3DHAL_SCENECAPTUREDATA);
typedef DWORD	(__stdcall *LPD3DHAL_EXECUTECB)		(LPD3DHAL_EXECUTEDATA);
typedef DWORD	(__stdcall *LPD3DHAL_EXECUTECLIPPEDCB)	(LPD3DHAL_EXECUTECLIPPEDDATA);
typedef DWORD	(__stdcall *LPD3DHAL_RENDERSTATECB)	(LPD3DHAL_RENDERSTATEDATA);
typedef DWORD	(__stdcall *LPD3DHAL_RENDERPRIMITIVECB)	(LPD3DHAL_RENDERPRIMITIVEDATA);
typedef DWORD	(__stdcall *LPD3DHAL_EXECUTECLIPPEDCB)	(LPD3DHAL_EXECUTECLIPPEDDATA);
typedef DWORD	(__stdcall *LPD3DHAL_TEXTURECREATECB)	(LPD3DHAL_TEXTURECREATEDATA);
typedef DWORD	(__stdcall *LPD3DHAL_TEXTUREDESTROYCB)	(LPD3DHAL_TEXTUREDESTROYDATA);
typedef DWORD	(__stdcall *LPD3DHAL_TEXTURESWAPCB)	(LPD3DHAL_TEXTURESWAPDATA);
typedef DWORD	(__stdcall *LPD3DHAL_TEXTUREGETSURFCB)	(LPD3DHAL_TEXTUREGETSURFDATA);
typedef DWORD	(__stdcall *LPD3DHAL_MATRIXCREATECB)	(LPD3DHAL_MATRIXCREATEDATA);
typedef DWORD	(__stdcall *LPD3DHAL_MATRIXDESTROYCB)	(LPD3DHAL_MATRIXDESTROYDATA);
typedef DWORD	(__stdcall *LPD3DHAL_MATRIXSETDATACB)	(LPD3DHAL_MATRIXSETDATADATA);
typedef DWORD	(__stdcall *LPD3DHAL_MATRIXGETDATACB)	(LPD3DHAL_MATRIXGETDATADATA);
typedef DWORD	(__stdcall *LPD3DHAL_SETVIEWPORTDATACB)	(LPD3DHAL_SETVIEWPORTDATADATA);
typedef DWORD	(__stdcall *LPD3DHAL_LIGHTSETCB)	(LPD3DHAL_LIGHTSETDATA);
typedef DWORD	(__stdcall *LPD3DHAL_MATERIALCREATECB)	(LPD3DHAL_MATERIALCREATEDATA);
typedef DWORD	(__stdcall *LPD3DHAL_MATERIALDESTROYCB)	(LPD3DHAL_MATERIALDESTROYDATA);
typedef DWORD	(__stdcall *LPD3DHAL_MATERIALSETDATACB)	(LPD3DHAL_MATERIALSETDATADATA);
typedef DWORD	(__stdcall *LPD3DHAL_MATERIALGETDATACB)	(LPD3DHAL_MATERIALGETDATADATA);
typedef DWORD	(__stdcall *LPD3DHAL_GETSTATECB)	(LPD3DHAL_GETSTATEDATA);

typedef struct _D3DHAL_CALLBACKS {
    DWORD			dwSize;
    
    // Device context
    LPD3DHAL_CONTEXTCREATECB	ContextCreate;
    LPD3DHAL_CONTEXTDESTROYCB	ContextDestroy;
    LPD3DHAL_CONTEXTDESTROYALLCB ContextDestroyAll;

    // Scene Capture
    LPD3DHAL_SCENECAPTURECB	SceneCapture;
    
    // Execution
    LPD3DHAL_EXECUTECB		Execute;
    LPD3DHAL_EXECUTECLIPPEDCB	ExecuteClipped;
    LPD3DHAL_RENDERSTATECB	RenderState;
    LPD3DHAL_RENDERPRIMITIVECB	RenderPrimitive;
    
    DWORD			dwReserved;		// Must be zero

    // Textures
    LPD3DHAL_TEXTURECREATECB	TextureCreate;
    LPD3DHAL_TEXTUREDESTROYCB	TextureDestroy;
    LPD3DHAL_TEXTURESWAPCB	TextureSwap;
    LPD3DHAL_TEXTUREGETSURFCB	TextureGetSurf;
    
    // Transform
    LPD3DHAL_MATRIXCREATECB	MatrixCreate;
    LPD3DHAL_MATRIXDESTROYCB	MatrixDestroy;
    LPD3DHAL_MATRIXSETDATACB	MatrixSetData;
    LPD3DHAL_MATRIXGETDATACB	MatrixGetData;
    LPD3DHAL_SETVIEWPORTDATACB	SetViewportData;
    
    // Lighting
    LPD3DHAL_LIGHTSETCB		LightSet;
    LPD3DHAL_MATERIALCREATECB	MaterialCreate;
    LPD3DHAL_MATERIALDESTROYCB	MaterialDestroy;
    LPD3DHAL_MATERIALSETDATACB	MaterialSetData;
    LPD3DHAL_MATERIALGETDATACB	MaterialGetData;

    // Pipeline state
    LPD3DHAL_GETSTATECB		GetState;

    DWORD			dwReserved0;		// Must be zero
    DWORD			dwReserved1;		// Must be zero
    DWORD			dwReserved2;		// Must be zero
    DWORD			dwReserved3;		// Must be zero
    DWORD			dwReserved4;		// Must be zero
    DWORD			dwReserved5;		// Must be zero
    DWORD			dwReserved6;		// Must be zero
    DWORD			dwReserved7;		// Must be zero
    DWORD			dwReserved8;		// Must be zero
    DWORD			dwReserved9;		// Must be zero

} D3DHAL_CALLBACKS;
typedef D3DHAL_CALLBACKS *LPD3DHAL_CALLBACKS;

#define D3DHAL_SIZE_V1 sizeof( D3DHAL_CALLBACKS )

/* --------------------------------------------------------------
 * Argument to the HAL functions.
 */

#include "d3di.h"
 
typedef struct _D3DHAL_CONTEXTCREATEDATA {
    LPDDRAWI_DIRECTDRAW_GBL lpDDGbl;	// in:  Driver struct
    LPDIRECTDRAWSURFACE	lpDDS;		// in:  Surface to be used as target
    LPDIRECTDRAWSURFACE	lpDDSZ;		// in:  Surface to be used as Z
    DWORD		dwPID;		// in:  Current process id
    DWORD		dwhContext;	// out: Context handle
    HRESULT		ddrval;		// out: Return value
} D3DHAL_CONTEXTCREATEDATA;
typedef D3DHAL_CONTEXTCREATEDATA *LPD3DHAL_CONTEXTCREATEDATA;

typedef struct _D3DHAL_CONTEXTDESTROYDATA {
    DWORD		dwhContext;	// in:  Context handle
    HRESULT		ddrval;		// out: Return value
} D3DHAL_CONTEXTDESTROYDATA;
typedef D3DHAL_CONTEXTDESTROYDATA *LPD3DHAL_CONTEXTDESTROYDATA;

typedef struct _D3DHAL_CONTEXTDESTROYALLDATA {
    DWORD		dwPID;		// in:  Process id to destroy contexts for
    HRESULT		ddrval;		// out: Return value
} D3DHAL_CONTEXTDESTROYALLDATA;
typedef D3DHAL_CONTEXTDESTROYALLDATA *LPD3DHAL_CONTEXTDESTROYALLDATA;

typedef struct _D3DHAL_SCENECAPTUREDATA {
    DWORD		dwhContext;	// in:  Context handle
    DWORD		dwFlag;		// in:  Indicates beginning or end
    HRESULT		ddrval;		// out: Return value
} D3DHAL_SCENECAPTUREDATA;
typedef D3DHAL_SCENECAPTUREDATA *LPD3DHAL_SCENECAPTUREDATA;

typedef struct _D3DHAL_EXECUTEDATA {
    DWORD		dwhContext;	// in:  Context handle
    DWORD		dwOffset;	// in/out: Where to start/error occured
    DWORD		dwFlags;	// in:  Flags for this execute
    DWORD		dwStatus;	// in/out: Condition branch status
    D3DI_EXECUTEDATA	deExData;	// in:  Execute data describing buffer
    LPDIRECTDRAWSURFACE	lpExeBuf;	// in:  Execute buffer containing data
    LPDIRECTDRAWSURFACE	lpTLBuf;	// in:  Execute buffer containing TLVertex data
    					//	Only provided if HEL performing transform
    D3DINSTRUCTION	diInstruction;	// in:  Optional one off instruction
    HRESULT		ddrval;		// out: Return value
} D3DHAL_EXECUTEDATA;
typedef D3DHAL_EXECUTEDATA *LPD3DHAL_EXECUTEDATA;

typedef struct _D3DHAL_EXECUTECLIPPEDDATA {
    DWORD		dwhContext;	// in:  Context handle
    DWORD		dwOffset;	// in/out: Where to start/error occured
    DWORD		dwFlags;	// in:  Flags for this execute
    DWORD		dwStatus;	// in/out: Condition branch status
    D3DI_EXECUTEDATA	deExData;	// in:  Execute data describing buffer
    LPDIRECTDRAWSURFACE	lpExeBuf;	// in:  Execute buffer containing data
    LPDIRECTDRAWSURFACE	lpTLBuf;	// in:  Execute buffer containing TLVertex data
    					//	Only provided if HEL performing transform
    LPDIRECTDRAWSURFACE	lpHBuf;		// in:  Execute buffer containing HVertex data
    					//	Only provided if HEL performing transform
    D3DINSTRUCTION	diInstruction;	// in:  Optional one off instruction
    HRESULT		ddrval;		// out: Return value
} D3DHAL_EXECUTECLIPPEDDATA;
typedef D3DHAL_EXECUTECLIPPEDDATA *LPD3DHAL_EXECUTECLIPPEDDATA;

typedef struct _D3DHAL_RENDERSTATEDATA {
    DWORD		dwhContext;	// in:  Context handle
    DWORD		dwOffset;	// in:  Where to find states in buffer
    DWORD		dwCount;	// in:  How many states to process
    LPDIRECTDRAWSURFACE	lpExeBuf;	// in:  Execute buffer containing data
    HRESULT		ddrval;		// out: Return value
} D3DHAL_RENDERSTATEDATA;
typedef D3DHAL_RENDERSTATEDATA *LPD3DHAL_RENDERSTATEDATA;

typedef struct _D3DHAL_RENDERPRIMITIVEDATA {
    DWORD		dwhContext;	// in:  Context handle
    DWORD		dwOffset;	// in:  Where to find primitive data in buffer
    DWORD		dwStatus;	// in/out: Condition branch status
    LPDIRECTDRAWSURFACE	lpExeBuf;	// in:  Execute buffer containing data
    DWORD		dwTLOffset;	// in:  Byte offset in lpTLBuf for start of vertex data
    LPDIRECTDRAWSURFACE	lpTLBuf;	// in:  Execute buffer containing TLVertex data
    D3DINSTRUCTION	diInstruction;	// in:  Primitive instruction
    HRESULT		ddrval;		// out: Return value
} D3DHAL_RENDERPRIMITIVEDATA;
typedef D3DHAL_RENDERPRIMITIVEDATA *LPD3DHAL_RENDERPRIMITIVEDATA;

typedef struct _D3DHAL_TEXTURECREATEDATA {
    DWORD		dwhContext;	// in:  Context handle
    LPDIRECTDRAWSURFACE	lpDDS;		// in:  Pointer to surface object
    DWORD		dwHandle;	// out: Handle to texture
    HRESULT		ddrval;		// out: Return value
} D3DHAL_TEXTURECREATEDATA;
typedef D3DHAL_TEXTURECREATEDATA *LPD3DHAL_TEXTURECREATEDATA;

typedef struct _D3DHAL_TEXTUREDESTROYDATA {
    DWORD		dwhContext;	// in:  Context handle
    DWORD		dwHandle;	// in:  Handle to texture
    HRESULT		ddrval;		// out: Return value
} D3DHAL_TEXTUREDESTROYDATA;
typedef D3DHAL_TEXTUREDESTROYDATA *LPD3DHAL_TEXTUREDESTROYDATA;

typedef struct _D3DHAL_TEXTURESWAPDATA {
    DWORD		dwhContext;	// in:  Context handle
    DWORD		dwHandle1;	// in:  Handle to texture 1
    DWORD		dwHandle2;	// in:  Handle to texture 2
    HRESULT		ddrval;		// out: Return value
} D3DHAL_TEXTURESWAPDATA;
typedef D3DHAL_TEXTURESWAPDATA *LPD3DHAL_TEXTURESWAPDATA;

typedef struct _D3DHAL_TEXTUREGETSURFDATA {
    DWORD		dwhContext;	// in:  Context handle
    DWORD		lpDDS;		// out: Pointer to surface object
    DWORD		dwHandle;	// in:  Handle to texture
    HRESULT		ddrval;		// out: Return value
} D3DHAL_TEXTUREGETSURFDATA;
typedef D3DHAL_TEXTUREGETSURFDATA *LPD3DHAL_TEXTUREGETSURFDATA;

typedef struct _D3DHAL_MATRIXCREATEDATA {
    DWORD		dwhContext;	// in:  Context handle
    DWORD		dwHandle;	// out: Handle to matrix
    HRESULT		ddrval;		// out: Return value
} D3DHAL_MATRIXCREATEDATA;
typedef D3DHAL_MATRIXCREATEDATA *LPD3DHAL_MATRIXCREATEDATA;

typedef struct _D3DHAL_MATRIXDESTROYDATA {
    DWORD		dwhContext;	// in:  Context handle
    DWORD		dwHandle;	// in:  Handle to matrix
    HRESULT		ddrval;		// out: Return value
} D3DHAL_MATRIXDESTROYDATA;
typedef D3DHAL_MATRIXDESTROYDATA *LPD3DHAL_MATRIXDESTROYDATA;

typedef struct _D3DHAL_MATRIXSETDATADATA {
    DWORD		dwhContext;	// in:  Context handle
    DWORD		dwHandle;	// in:  Handle to matrix
    D3DMATRIX		dmMatrix;	// in:  Matrix data
    HRESULT		ddrval;		// out: Return value
} D3DHAL_MATRIXSETDATADATA;
typedef D3DHAL_MATRIXSETDATADATA *LPD3DHAL_MATRIXSETDATADATA;

typedef struct _D3DHAL_MATRIXGETDATADATA {
    DWORD		dwhContext;	// in:  Context handle
    DWORD		dwHandle;	// in:  Handle to matrix
    D3DMATRIX		dmMatrix;	// out: Matrix data
    HRESULT		ddrval;		// out: Return value
} D3DHAL_MATRIXGETDATADATA;
typedef D3DHAL_MATRIXGETDATADATA *LPD3DHAL_MATRIXGETDATADATA;

typedef struct _D3DHAL_SETVIEWPORTDATADATA {
    DWORD		dwhContext;	// in:  Context handle
    DWORD		dwViewportID;	// in:	ID of viewport
    D3DVIEWPORT		dvViewData;	// in:  Viewport data
    HRESULT		ddrval;		// out: Return value
} D3DHAL_SETVIEWPORTDATADATA;
typedef D3DHAL_SETVIEWPORTDATADATA *LPD3DHAL_SETVIEWPORTDATADATA;

typedef struct _D3DHAL_LIGHTSETDATA {
    DWORD		dwhContext;	// in:  Context handle
    DWORD		dwLight;	// in:  Which light to set
    D3DI_LIGHT		dlLight;	// in:  Light data
    HRESULT		ddrval;		// out: Return value
} D3DHAL_LIGHTSETDATA;
typedef D3DHAL_LIGHTSETDATA *LPD3DHAL_LIGHTSETDATA;

typedef struct _D3DHAL_MATERIALCREATEDATA {
    DWORD		dwhContext;	// in:  Context handle
    DWORD		dwHandle;	// out: Handle to material
    D3DMATERIAL		dmMaterial;	// in:  Material data
    HRESULT		ddrval;		// out: Return value
} D3DHAL_MATERIALCREATEDATA;
typedef D3DHAL_MATERIALCREATEDATA *LPD3DHAL_MATERIALCREATEDATA;

typedef struct _D3DHAL_MATERIALDESTROYDATA {
    DWORD		dwhContext;	// in:  Context handle
    DWORD		dwHandle;	// in:  Handle to material
    HRESULT		ddrval;		// out: Return value
} D3DHAL_MATERIALDESTROYDATA;
typedef D3DHAL_MATERIALDESTROYDATA *LPD3DHAL_MATERIALDESTROYDATA;

typedef struct _D3DHAL_MATERIALSETDATADATA {
    DWORD		dwhContext;	// in:  Context handle
    DWORD		dwHandle;	// in:  Handle to material
    D3DMATERIAL		dmMaterial;	// in:  Material data
    HRESULT		ddrval;		// out: Return value
} D3DHAL_MATERIALSETDATADATA;
typedef D3DHAL_MATERIALSETDATADATA *LPD3DHAL_MATERIALSETDATADATA;

typedef struct _D3DHAL_MATERIALGETDATADATA {
    DWORD		dwhContext;	// in:  Context handle
    DWORD		dwHandle;	// in:  Handle to material
    D3DMATERIAL		dmMaterial;	// out: Material data
    HRESULT		ddrval;		// out: Return value
} D3DHAL_MATERIALGETDATADATA;
typedef D3DHAL_MATERIALGETDATADATA *LPD3DHAL_MATERIALGETDATADATA;

typedef struct _D3DHAL_GETSTATEDATA {
    DWORD		dwhContext;	// in:  Context handle
    DWORD		dwWhich;	// in:  Transform, lighting or render?
    D3DSTATE		ddState;	// in/out: State.
    HRESULT		ddrval;		// out: Return value
} D3DHAL_GETSTATEDATA;
typedef D3DHAL_GETSTATEDATA *LPD3DHAL_GETSTATEDATA;

/* --------------------------------------------------------------
 * Flags for the data parameters.
 */

/*
 * SceneCapture()
 * This is used as an indication to the driver that a scene is about to
 * start or end, and that it should capture data if required.
 */
#define D3DHAL_SCENE_CAPTURE_START	0x00000000L
#define D3DHAL_SCENE_CAPTURE_END	0x00000001L
 
/*
 * Execute()
 */
 
/*
 * Use the instruction stream starting at dwOffset.
 */
#define D3DHAL_EXECUTE_NORMAL		0x00000000L

/*
 * Use the optional instruction override (diInstruction) and return
 * after completion.  dwOffset is the offset to the first primitive.
 */
#define D3DHAL_EXECUTE_OVERRIDE		0x00000001L
 
/*
 * GetState()
 * The driver will get passed a flag in dwWhich specifying which module
 * the state must come from.  The driver then fills in ulArg[1] with the
 * appropriate value depending on the state type given in ddState.
 */

/*
 * The following are used to get the state of a particular stage of the
 * pipeline.
 */
#define D3DHALSTATE_GET_TRANSFORM	0x00000001L
#define D3DHALSTATE_GET_LIGHT		0x00000002L
#define D3DHALSTATE_GET_RENDER		0x00000004L


/* --------------------------------------------------------------
 * Return values from HAL functions.
 */
 
/*
 * The context passed in was bad.
 */
#define D3DHAL_CONTEXT_BAD		0x000000200L

/*
 * No more contexts left.
 */
#define D3DHAL_OUTOFCONTEXTS		0x000000201L

/*
 * Execute() and ExecuteClipped()
 */
 
/*
 * Executed to completion via early out.
 * 	(e.g. totally clipped)
 */
#define D3DHAL_EXECUTE_ABORT		0x00000210L

/*
 * An unhandled instruction code was found (e.g. D3DOP_TRANSFORM).
 * The dwOffset parameter must be set to the offset of the unhandled
 * instruction.
 *
 * Only valid from Execute()
 */
#define D3DHAL_EXECUTE_UNHANDLED	0x00000211L

#endif /* _D3DHAL_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\ddrawex\vtable.cpp ===
/*==========================================================================
 *
 *  Copyright (C) 1997 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       vtable.cpp
 *  Content:	declaration of vtables for the various interfaces
 *  History:
 *   Date	By	Reason
 *   ====	==	======
 *   24-feb-97	ralphl	initial implementation
 *   25-feb-97	craige	minor tweaks for dx checkin
 *   06-mar-97	craige	IDirectDrawSurface3 support
 *   14-mar-97  jeffort SetBits changed to reflect DX5 as SetSurfaceDesc
 *   01-apr-97  jeffort Following changes checked in:
 *                      Aggregation of Add/GetAttachedSurface
 *                      Aggregation of Flip/Blt
 *   28-apr-97  jeffort Palette wrapping added/DX5 support
 *
 *   02-may-97  jeffort GetDDInterface wrapping added
 *   06-may-97  jeffort DeleteAttachedSurface wrapping added
 *   07-jul-97  jeffort GetSurfaceDesc wrapping added
 ***************************************************************************/
#define CINTERFACE
#include "ddfactry.h"

#define FORWARD0(Interface, Name) \
STDMETHODIMP Interface##Name(Interface *pIntStruc) \
{	Interface * pReal = ((INTSTRUC_##Interface *)pIntStruc)->m_pRealInterface; \
	return pReal->lpVtbl->Name(pReal); }

#define FORWARD1(Interface, Name, p1) \
STDMETHODIMP Interface##Name(Interface *pIntStruc, p1 a) \
{	Interface * pReal = ((INTSTRUC_##Interface *)pIntStruc)->m_pRealInterface; \
	return pReal->lpVtbl->Name(pReal, a); }

#define FORWARD2(Interface, Name, p1, p2) \
STDMETHODIMP Interface##Name(Interface *pIntStruc, p1 a, p2 b) \
{	Interface * pReal = ((INTSTRUC_##Interface *)pIntStruc)->m_pRealInterface; \
	return pReal->lpVtbl->Name(pReal, a, b); }

#define FORWARD3(Interface, Name, p1, p2, p3) \
STDMETHODIMP Interface##Name(Interface *pIntStruc, p1 a, p2 b, p3 c) \
{	Interface * pReal = ((INTSTRUC_##Interface *)pIntStruc)->m_pRealInterface; \
	return pReal->lpVtbl->Name(pReal, a, b, c); }

#define FORWARD4(Interface, Name, p1, p2, p3, p4) \
STDMETHODIMP Interface##Name(Interface *pIntStruc, p1 a, p2 b, p3 c, p4 d) \
{	Interface * pReal = ((INTSTRUC_##Interface *)pIntStruc)->m_pRealInterface; \
	return pReal->lpVtbl->Name(pReal, a, b, c, d); }

#define FORWARD5(Interface, Name, p1, p2, p3, p4, p5) \
STDMETHODIMP Interface##Name(Interface *pIntStruc, p1 a, p2 b, p3 c, p4 d, p5 e) \
{	Interface * pReal = ((INTSTRUC_##Interface *)pIntStruc)->m_pRealInterface; \
	return pReal->lpVtbl->Name(pReal, a, b, c, d, e); }

#define __QI(p, a, b) (p)->lpVtbl->QueryInterface(p, a, b)

_inline CDirectDrawEx * PARENTOF(IDirectDraw * pDD)
{
    return ((INTSTRUC_IDirectDraw *)pDD)->m_pDirectDrawEx;
}

_inline CDirectDrawEx * PARENTOF(IDirectDraw2 * pDD2)
{
    return ((INTSTRUC_IDirectDraw2 *)pDD2)->m_pDirectDrawEx;
}

_inline CDirectDrawEx * PARENTOF(IDirectDraw4 * pDD4)
{
    return ((INTSTRUC_IDirectDraw4 *)pDD4)->m_pDirectDrawEx;
}

_inline CDDSurface * SURFACEOF(IDirectDrawSurface * pDDS)
{
    return ((INTSTRUC_IDirectDrawSurface *)pDDS)->m_pSimpleSurface;
}

_inline CDDSurface * SURFACEOF(IDirectDrawSurface2 * pDDS2)
{
    return ((INTSTRUC_IDirectDrawSurface2 *)pDDS2)->m_pSimpleSurface;
}

_inline CDDSurface * SURFACEOF(IDirectDrawSurface3 * pDDS3)
{
    return ((INTSTRUC_IDirectDrawSurface3 *)pDDS3)->m_pSimpleSurface;
}

_inline CDDSurface * SURFACEOF(IDirectDrawSurface4 * pDDS4)
{
    return ((INTSTRUC_IDirectDrawSurface4 *)pDDS4)->m_pSimpleSurface;
}

_inline CDDPalette * PALETTEOF(IDirectDrawPalette * pDDP)
{
    return ((INTSTRUC_IDirectDrawPalette *)pDDP)->m_pSimplePalette;
}


/*
 * IDirectDraw
 */

STDMETHODIMP IDirectDrawAggQueryInterface(IDirectDraw *pDD, REFIID riid, void ** ppv)
{
    return __QI(PARENTOF(pDD)->m_pUnkOuter, riid, ppv);
}
STDMETHODIMP_(ULONG) IDirectDrawAggAddRef(IDirectDraw *);
STDMETHODIMP_(ULONG) IDirectDrawAggRelease(IDirectDraw *);
STDMETHODIMP IDirectDrawAggCreateSurface(IDirectDraw *, LPDDSURFACEDESC pSurfaceDesc,
				         IDirectDrawSurface **ppNewSurface, IUnknown *pUnkOuter);
STDMETHODIMP IDirectDrawAggCreatePalette(IDirectDraw *,DWORD, LPPALETTEENTRY, LPDIRECTDRAWPALETTE FAR *, IUnknown FAR *);
STDMETHODIMP IDirectDrawAggSetCooperativeLevel(IDirectDraw *, HWND, DWORD);

FORWARD0(IDirectDraw, Compact)
FORWARD3(IDirectDraw, CreateClipper,		DWORD, LPDIRECTDRAWCLIPPER FAR *, IUnknown *)
FORWARD2(IDirectDraw, DuplicateSurface,		LPDIRECTDRAWSURFACE, LPDIRECTDRAWSURFACE FAR *)
FORWARD4(IDirectDraw, EnumDisplayModes,		DWORD, LPDDSURFACEDESC, LPVOID, LPDDENUMMODESCALLBACK)
FORWARD4(IDirectDraw, EnumSurfaces,		DWORD, LPDDSURFACEDESC, LPVOID, LPDDENUMSURFACESCALLBACK)
FORWARD0(IDirectDraw, FlipToGDISurface)
FORWARD2(IDirectDraw, GetCaps,			LPDDCAPS, LPDDCAPS)
FORWARD1(IDirectDraw, GetDisplayMode,		LPDDSURFACEDESC)
FORWARD2(IDirectDraw, GetFourCCCodes,		LPDWORD, LPDWORD)
FORWARD1(IDirectDraw, GetGDISurface,		LPDIRECTDRAWSURFACE FAR *)
FORWARD1(IDirectDraw, GetMonitorFrequency,	LPDWORD)
FORWARD1(IDirectDraw, GetScanLine,		LPDWORD)
FORWARD1(IDirectDraw, Initialize,		GUID *)
FORWARD1(IDirectDraw, GetVerticalBlankStatus,	LPBOOL)
FORWARD0(IDirectDraw, RestoreDisplayMode)
FORWARD2(IDirectDraw, WaitForVerticalBlank,	DWORD, HANDLE)
FORWARD3(IDirectDraw, SetDisplayMode,		DWORD, DWORD, DWORD)


IDirectDrawVtbl g_DirectDrawVtbl =
{
    IDirectDrawAggQueryInterface,
    IDirectDrawAggAddRef,
    IDirectDrawAggRelease,
    IDirectDrawCompact,
    IDirectDrawCreateClipper,
    IDirectDrawAggCreatePalette,